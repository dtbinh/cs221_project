Journal Artificial Intelligence Research 28 (2007) 183232

Submitted 5/06; published 3/07

Proactive Algorithms Job Shop Scheduling
Probabilistic Durations
J. Christopher Beck

jcb@mie.utoronto.ca

Department Mechanical & Industrial Engineering
University Toronto, Canada

Nic Wilson

n.wilson@4c.ucc.ie

Cork Constraint Computation Centre
University College Cork, Ireland

Abstract
classical scheduling formulations assume fixed known duration activity. paper, weaken assumption, requiring instead duration
represented independent random variable known mean variance.
best solutions ones high probability achieving good makespan.
first create theoretical framework, formally showing Monte Carlo simulation
combined deterministic scheduling algorithms solve problem. propose
associated deterministic scheduling problem whose solution proved, certain conditions, lower bound probabilistic problem. propose investigate
number techniques solving problems based combinations Monte Carlo
simulation, solutions associated deterministic problem, either constraint programming tabu search. empirical results demonstrate combination use
associated deterministic problem Monte Carlo simulation results algorithms
scale best terms problem size uncertainty. experiments point
correlation quality deterministic solution quality
probabilistic solution major factor responsible success.

1. Introduction
Proactive scheduling techniques seek produce off-line schedule robust execution time events. paper, assume perfect knowledge
duration activity: durations determined execution time
observed activity finished. However, partial knowledge form
known probability distribution duration. execution time, activities
dispatched according sequences defined off-line schedule measure
robustness probability given quality achieved. specifically,
paper, address problem job shop scheduling (and related generalizations)
durations activities random variables objective find
solution high probability good (ideally, minimal) makespan.
challenging problem even evaluating solution hard problem.
address problem, develop theoretical framework within formally
define problem (a) construct approach, based Monte Carlo simulation,
evaluating solutions partial solutions, (b) show solving carefully defined
deterministic job shop scheduling problem results lower bound probabilistic
c
2007
AI Access Foundation. rights reserved.

fiBeck & Wilson

minimum makespan probabilistic job shop scheduling problem. use framework
define number algorithms embodying three solution approaches:
1. Branch-and-bound search Monte Carlo simulation: search node,
search pruned almost certain (based Monte Carlo simulation)
partial solution cannot extended solution better current best
solution.
2. Iterative deterministic search descending lower bound: deterministic job
shop problem whose solution lower bound probabilistic job shop problem
defined using parameter, q. lower bound proof depends q less
equal q (I), problem-instance-dependent threshold value problem instance
difficult compute. Starting high q value, use tree search
Monte Carlo simulation solve sequence deterministic problems decreasing
q values. q large, problems highly constrained easy solve (if
solutions exist). q descends, best probabilistic makespan previous
iterations used restrict search. able reach value q
q q (I) within CPU time limit, search approximately complete
subject sampling error.
3. Deterministic filtering search: deterministic scheduling algorithms based constraint
programming tabu search used define number filter-based algorithms.
algorithms operate generating series solution candidates
evaluated Monte Carlo simulation.
empirical results indicate Monte Carlo based branch-and-bound
practical small problems. iterative search based descending q values
good as, better than, branch-and-bound algorithm small problems, performs
significantly better larger problems. However, even medium-sized problems,
techniques inferior heuristic approaches based deterministic filtering.
Contributions.

main contributions paper are:

introduction problem finding proactive schedules probabilistic execution guarantees class problems underlying deterministic scheduling
problem NP-hard;
development method generating lower bound probabilistic minimum makespan;
development particular Monte Carlo approach evaluating solutions;
design empirical analysis number approximately complete heuristic solution techniques based either constraint-based constructive search tabu
search;
identification correlation deterministic probabilistic solution
quality key factor performance filter-based algorithms.
184

fiProactive Algorithms JSP

Plan Paper. next section define probabilistic job shop scheduling problem, illustrating example. Section 3 discusses related work. Section 4,
present theoretical framework: formally define problem, derive approach
generating lower bound based associated deterministic job shop problem,
show Monte Carlo simulation used evaluate solutions partial solutions.
Six search algorithms defined Section 5 empirical investigations results
appear Section 6. Section 7, shown results paper apply much
general classes scheduling problems. Directions future work based theoretical
algorithmic extensions discussed.

2. Probabilistic Job Shop Scheduling Problems
job shop scheduling problem probabilistic durations natural extension
standard (deterministic) job shop scheduling problem (JSP).
2.1 Job Shop Scheduling Problems
JSP involves set activities, Ai positive duration di .
instance JSP, assumed either durations positive integers,
positive real numbers.1 partitioned jobs, job associated
total ordering set activities. activity must execute specified
unary capacity resource. activities require resource overlap
execution, activity started must executed entire duration.
represent formally another partition resource sets: two activities
resource set require resource.
solution consists total ordering resource set, conflict
jobs ordering, i.e., union resource orderings job orderings acyclic
relation A. Thus, Ai Aj resource set, solution either orders Ai
Aj (meaning Aj starts sooner end Ai ), Aj Ai . set
solutions job shop problem labeled S. partial solution consists partial
ordering resource set extended solution.
Let (partial) solution. path (or s-path) sequence activities
Ai immediately precedes Aj sequence, either (i) Ai Aj
job, Ai precedes Aj job, (ii) Ai Aj resource set
orders Ai Aj . length, len(), path
P (of solution) equal
sum durations activities path, i.e., Ai di . makespan, make(s),
solution defined length longest s-path. s-path, , said
critical s-path length equal makespan solution s, i.e., one
longest s-paths. minimum makespan job shop scheduling problem defined
minimum value make(s) solutions s.
definitions focus solutions rather schedules. Here, briefly indicate definitions relate to, perhaps immediately intuitive, definitions focusing
schedules. schedule assigns start time activity, considered
1. empirical investigations examine integer case. shown below, theoretical results hold
case positive real number durations.

185

fiBeck & Wilson

function set activities set time-points, defining activity
starts. set time-points assumed either set non-negative integers
set non-negative real numbers. Let starti start time activity Ai
respect particular schedule, let endi , end time, starti + di . Ai , Aj A,
write Ai Aj constraint endi startj . schedule defined valid
following two conditions hold two different activities Ai , Aj A: (a) Ai precedes
Aj job, Ai Aj ; (b) Ai Aj resource set,
either Ai Aj Aj Ai (since Ai Aj allowed overlap).
Let Z valid schedule. Define make(Z), makespan Z, maxAi endi ,
time last activity completed. minimum makespan defined
minimum value make(Z) valid schedules.
solution defines valid schedule sched(s), activity started soon
immediate predecessors (if any) finished, activities without predecessors
started time-point 0 (so sched(s) non-delay schedule given precedence constraints
expressed s). immediate predecessor activity Aj respect particular
solution defined activity immediate predecessor Aj either
respect ordering job containing Aj , respect ordering (associated
solution) resource set containing Aj . shown makespan
sched(s) equal make(s) defined earlier, hence justifying definition.
Conversely, given valid schedule Z, define solution, call sol(Z),
ordering resource set relation defined above. Z schedule,
makespan sched(sol(Z)), equal make(sol(Z)), less equal
makespan Z. implies minimum makespan solutions equal
minimum makespan valid schedules. Therefore, interested schedules
best makespans, need consider solutions associated schedules.
summarize, aiming find minimum makespan JSP, focus
searching solutions, rather schedules, (i) schedule Z,
exists solution = sol(Z) Z consistent (i.e., satisfies precedence constraints expressed s); (ii) solution s, efficiently construct
schedule sched(s) optimal among schedules consistent (and furthermore,
makespan sched(s) equal make(s)).
JSP Example. Consider job shop scheduling problem involving two jobs five activities shown Figure 1. first job consists sequence (A1 , A2 , A3 ) activities;
second job consists sequence (A4 , A5 ). three resources involved. A1
A4 require first resource; hence activities A1 A4 cannot overlap, either (i)
A1 precedes A4 , (ii) A4 precedes A1 . Activities A3 A5 require second resource;
A2 requires third resource. Hence, resource sets {A1 , A4 }, {A2 } {A3 , A5 }.
four solutions:
sa involves orderings A1 A4 A3 A5 ;
sb defined A1 A4 A5 A3 ;
sc A4 A1 A3 A5 ;
sd A4 A1 A5 A3 .
186

fiProactive Algorithms JSP

A1

A2

A3

A4

A1

A2

A5

A3

A4

A1

A5

A2

A4

A5

Solution Sa
A1

A2

Solution Sb
A3

A4

A3

A1

A5

A2

A3

A4

Solution Sc

A5
Solution Sd

Figure 1: example JSP four solutions.
duration activity Ai di . sequence (A1 , A4 , A5 ) sa -path, whose length
d1 +d4 +d5 . Also, sa -path (A1 , A2 , A3 , A5 ), len() = d1 +d2 +d3 +d5 .
sa -paths subsequences one two. Hence, make(sa ), makespan
solution sa , equal max(d1 + d4 + d5 , d1 + d2 + d3 + d5 ) = d1 + d5 + max(d4 , d2 + d3 ).
particular, d1 = 1, d2 = 2, d3 = 3, d4 = 4 d5 = 5, make(sa ) = 11 time units.
make(sb ) = 13, make(sc ) = 15 make(sd ) = 12. Hence, minimum
makespan make(sa ) = 11.
Let Z = sched(sa ) schedule associated solution sa . generated
follows. A1 predecessors, start A1 beginning, setting Z(A1 ) = 0; hence
activity A1 starts time-point 0 ends time-point d1 . predecessor A4
A1 , set Z(A4 ) = d1 . Similarly, set Z(A2 ) = d1 , activity A2 ends
time-point d1 + d2 . Continuing, set Z(A3 ) = d1 + d2 . Activity A5 two immediate
predecessors (for solution, sa ), A3 A4 , A5 set start soon
activities completed, time-point max(d1 + d2 + d3 , d1 + d4 ).
activities completed A5 completed, time-point
max(d1 +d2 +d3 , d1 +d4 )+d5 = d1 +d5 +max(d4 , d2 +d3 ). confirms makespan
make(sa ) solution sa equal makespan associated schedule sched(sa ).
2.2 Independent General Probabilistic Job Shop Scheduling Problems
independent probabilistic job shop scheduling problem defined way
JSP, except duration di associated activity Ai random variable;
assume instance probabilistic JSP, either durations positive
integer-valued random variables, positive real-valued random variables.
(known) distribution Pi , expected value = E[di ] variance i2 = Var[di ].
187

fiBeck & Wilson

random variables fully independent. length path solution
random variable, write len(). makespan make(s) solution (the
length longest path s) therefore random variable, sometimes
refer random makespan s.
generalize non-independent case. probabilistic job shop scheduling problem joint probability measure P durations vectors. (The intention
efficiently sample joint density function. example, Bayesian
network might used represent P .) Here, activity Ai , distribution Pi defined
appropriate marginal distribution, expected value variance i2 .
Loosely speaking, probabilistic job shop scheduling problem, want find
small value possible solution whose random makespan is,
high probability, less (the deadline activities finish). time value
called probabilistic minimum makespan.
Evaluating solution deterministic JSP, i.e., finding associated makespan given
duration activity, achieved low degree polynomial time using longest
path algorithm. Without ordering resource set, disjunctions resource
constraints must satisfied find solution turn easy problem
NP-complete JSP (Garey & Johnson, 1979). PERT networks, hand, generalize
simple longest-path problem allowing durations independent random variables,
leading #P-complete problem (Hagstrom, 1988). probabilistic JSP makes
generalizations. Consequently, finding optimal solutions probabilistic JSP
appears hard, focus methods finding good solutions instead.
Evaluating (approximately) solution probabilistic JSP done relatively
efficiently using Monte Carlo simulation: large number trials randomly
sample duration every activity generate makespan associated
trial. Roughly speaking, approximately evaluate solution evaluating sampled
distribution makespans. approach described detail Section 4.3.
Almost solution techniques involve associating deterministic job shop problem
given probabilistic job shop problem, replacing, number q, random
duration mean distribution plus q times standard deviation. Hence, set
duration di activity Ai associated deterministic problem +q
case continuous time. case time-points integers, set = bi +qi c.
certain values q, leads minimum makespan deterministic problem
lower bound probabilistic minimum makespan, shown Section 4.2.
lower bound useful pruning branch-and-bound algorithm. generally,
show solving associated deterministic problem used help solve
probabilistic problem.
assumptions joint probability somewhat restrictive. example,
model allow activitys duration depend start time; however,
extended certain situations kind.2 Despite restrictions (which common
related literaturesee Section 3), model apply interesting class problems
2. could allow duration activity probabilistically dependent start time, given
additional (very natural) coherence condition time-point t0 , conditional probability
endi t0 , given starti = t, monotonically increasing t, i.e., Pr(endi t0 |starti = t1 )
Pr(endi t0 |starti = t2 ) t1 t2 . condition ensures that, given solution,

188

fiProactive Algorithms JSP

previously addressed. Extending model richer representations
relaxing assumptions remains future work.
Probabilistic JSP Example. consider independent probabilistic job shop scheduling problem structure JSP example Figure 1. durations
activities A2 , A3 A4 independent real-valued random variables (referred
d2 , d3 d4 , respectively) approximately normally distributed standard deviation 0.5 (2 = 3 = 4 = 0.5) means 2 = 2, 3 = 3 4 = 4.
durations activities A1 A5 deterministic, equal 1 5, respectively.
Let sa -path (A1 , A2 , A3 , A5 ). length len() approximately
normally distributed random variablewith mean 1+2+3+5 = 11 variance 0.5 2 +0.52 =
0.5 hence standard deviation 1/ 2.
length sa -path 0 = (A1 , A4 , A5 ) approximately normal random variable
mean 10 standard deviation 0.5. (random) makespan make(sa ) solution
sa random variable equaling maximum random variables len() len( 0 ).
general, maximum two independent normally distributed random variables
normally distributed; however, is, high probability, longer 0 , distribution
make(sa ) approximately equal distribution len().

3. Previous Work
considerable work scheduling uncertainty variety fields
including artificial intelligence (AI), operations research (OR), fault-tolerant computing,
systems. surveys literature, mostly focusing AI OR, see work
Davenport Beck (2000), Herroelen Leus (2005), Bidot (2005).
highest level, two approaches problems: proactive scheduling,
knowledge uncertainty taken account generating off-line
schedule; reactive scheduling decisions made on-line deal unexpected
changes. significant work reactive scheduling and, indeed, techniques
combine reactive proactive scheduling least commitment approaches (see
surveys noted above), interest pure proactive scheduling. Three categories
proactive approaches identified: redundancy-based techniques, probabilistic
techniques, contingent/policy-based techniques (Herroelen & Leus, 2005). briefly
look turn.
3.1 Redundancy-based Techniques
Redundancy-based techniques generate schedule includes allocation extra
resources and/or time schedule. intuition redundant allocations
help cushion impact unexpected events execution. example, extra time
consumed activity takes longer expected execute.
clear conflict insertion redundancy common measures schedule quality
(e.g., makespan), focus work tends intelligent insertion redundancy
order achieve satisfactory trade-off schedule quality robustness.
advantage delaying starting activity predecessors finished. Allowing delay
would break assumptions underlying formulation.

189

fiBeck & Wilson

common fault-tolerant scheduling real-time guarantees reserve redundant
resources (i.e., processors) time. former case, multiple instantiations given
process executed parallel error detection done comparing results
different instantiations. contrast, time redundancy, time reserved
re-execution process fails. Given fault model, either technique used
provide real-time guarantees (Ghosh, Melhem, & Mosse, 1995; Ghosh, 1996).
similar approach used work Gao (1995) Davenport, Gefflot Beck
(2001) context job shop scheduling. Statistical information mean time
failure mean repair time machines used either extend duration
critical activities former work require solution produced must respect
constraints slack activity. Given solution, slack room
activity move without breaking constraint increasing cost. Typically,
formalized difference activitys possible time window solution (i.e.,
latest possible end time less earliest possible start time) duration activity.
advantage Gaos approach purely modeling approach: problem
changed incorporate extended durations scheduling techniques used
solve problem. However, Davenport et al. show reasoning slack shared
amongst set activities lead better solutions cost specialized solving
approaches.
Leon, Wu Storer (1994) present approach job shop scheduling
objective function modified linear combination expected makespan
expected delay assuming machines break that, execution time, disruptions dealt shifting activities later time maintaining sequence
original schedule. basic technique properly seen probabilistic
approach, authors show exact calculation measure intractable unless
single disruption assumed. likely multiple disruptions, authors
present number surrogate measures. Empirically, best surrogate measure
deterministic makespan minus mean activity slack. Unlike, Gao Davenport et al.,
Leon et al. provide formal probabilistic foundation, temporal redundancy plays
central role practical application approach.
3.2 Probabilistic Techniques
Probabilistic techniques use representations uncertainty reason likely outcomes
schedule executed.3 Rather explicitly inserting redundancy attempt
create robust schedule, probabilistic techniques build schedule optimizes
measure probabilistic performance. Performance measures typically come two forms:
expected value expected makespan expected weighted tardiness, probabilistic guarantee respect threshold value deterministic optimization measure.
example latter measure, discussed below, probability flow time
schedule less particular value.
Optimal expected value scheduling problems widely studied (Pinedo,
2003). many cases, approach takes form dispatch rules slightly
complicated polynomial time algorithms find optimal schedule tractable
3. Alternative representations uncertainty fuzzy sets used (Herroelen & Leus, 2005).

190

fiProactive Algorithms JSP

problems (e.g., 1 2 machine problems) serve heuristics difficult
problems. One example work AI literature Wurman Wellman
(1996) extends decision theoretic planning concepts scheduling. problem
studied assumes single machine, stochastic processing time stochastic set-up time,
objective minimization expected weighted number tardy jobs.
authors propose state-space search solve problem multi-objective stochastic
dominance A*. Critical aspects work use number sophisticated path
pruning rules relaxation-based heuristics evaluation promising nodes.
threshold measure used Burns, Punnekkat, Littlewood Wright (1997)
fault-tolerant, single processor, pre-emptive scheduling application. objective find
minimum fault arrival rate tasks scheduled meet deadlines.
Based fault-model, probability observing fault arrival rate calculated
used measure schedule quality. optimization problem, then, find
schedule maximizes probability tasks meeting deadlines fault
arrival process.
one-machine manufacturing context independent activities, Daniels Carrillo (1997) define -robust schedule sequence maximizes probability
execution achieve flow time greater given threshold. underlying deterministic scheduling problem solvable polynomial time and, indeed,
minimum expected flow time schedule found polynomial time, shown
finding -robust schedule NP-hard. Daniels Carrillo present branch-and-bound
heuristic techniques solve problem.
3.3 Contingent Policy-based Approaches
Unlike approaches described above, contingent policy-based approaches
generate single off-line schedule. Rather, produced branching contingent
schedule or, extreme, policy, specifies actions taken particular
set circumstances arises. Given importance off-line schedule terms
coordination entities context surrounding scheduling problem,
difference significant practical implications (see Herroelen & Leus, 2005,
discussion).
elegant example contingent scheduling approach just-in-case work
Drummond, Bresina Swanson (1994). Given initial, deterministic schedule
single telescope observation problem, approach identifies activity likely fail
based available uncertainty information. point, new schedule produced
assuming activity does, indeed, fail. Repeated application identification
most-likely-to-fail activity generation new schedule results branching schedule
number likely contingencies accounted alternative schedules.
execution time, activity fails, execution switches alternative schedule
one exists. alternative exist, on-line rescheduling done. Empirical results
demonstrate significantly larger portion existing (branching) schedule
executed without revert rescheduling compared original deterministic
schedule.
191

fiBeck & Wilson

One weaknesses just-in-case scheduling surrounds combinatorics
multiple resources. multiple inter-dependent telescopes, problem quickly becomes
intractable. Policy-based approaches Markov Decision Processes (MDPs) (Boutilier,
Dean, & Hanks, 1999) applied problems. Here, objective
produce policy mapping states actions direct on-line execution
schedule: given state encountered, corresponding action taken. Meuleau et
al. (1998) apply MDPs stochastic military resource allocation problem weapons
must allocated targets. Given limited number weapons uncertainty
effectiveness given allocation, MDP used derive optimal policy
states represented number remaining weapons targets, actions
weapon allocation decisions. goal minimize expected number surviving
targets. Empirical results demonstrated computational challenges approach
6 target, 60 weapon problem required approximately 6 hours CPU time (albeit
now-outdated hardware).
literature, substantial work (cited Brucker, Drexl, Mohring,
Neumann Pesch, 1999, Herroelen Leus, 2005) stochastic resource-constraint
project scheduling, generalization job shop scheduling. general form
approaches multi-stage stochastic programming problem, objective finding
scheduling policy minimize expected makespan. context, scheduling
policy makes decisions on-line activities execute. Decisions need made
beginning schedule end time activity, information used
decisions must become known time decision
making. number different classes policy investigated. example,
minimal forbidden subset activities, F , set activities F cannot
executed simultaneously due resource constraints, subset F
executed. pre-selective policy identifies set F waiting activity, j F ,
j cannot started least one activity F {j} executed.
execution, j started least one activity F finished.
proactive problem, then, identify waiting activity minimal forbidden
subset expected makespan minimized. computational challenges
pre-selective policies (in particular, due number minimal forbidden subsets)
led work different classes policy well heuristic approaches.
3.4 Discussion
work paper falls within probabilistic scheduling approaches
closely inspired -robustness work Daniels Carrillo (1997). However, unlike
Daniels Carrillo, address scheduling model deterministic problem
underlies probabilistic job shop scheduling problem is, itself, NP-hard.
first work aware seeks provide probabilistic guarantees
underlying deterministic problem computationally difficult.

4. Theoretical Framework
section, develop theoretical framework probabilistic job shop problems.
Section 4.1, define compare solutions, using call -makespans.
192

fiProactive Algorithms JSP

-makespan solution less time value D, least chance 1
(random) makespan less D. useful idea far
solutions -makespan optimum -makespan (i.e., minimum -makespan
solutions), Section 4.2, describe approach finding lower bound
optimum -makespan. Section 4.3 considers problem evaluating given solution, s,
using Monte Carlo simulation estimate -makespan s.
order separate theoretical contributions empirical analysis, summarize notation introduced section Section 5.1. Readers interested primarily
algorithms empirical results therefore move directly Section 5.
section makes use notation introduced Section 2: definitions Section
2.1 JSP, solution, paths solution, makespan solution, minimum
makespan; definitions Section 2.2 probabilistic JSP random makespan
solution.
4.1 Comparing Solutions Probabilistic Makespan
standard job shop problem, solutions compared considering associated
makespans. probabilistic case, makespan solution random variable,
comparing solutions less straight-forward. map random makespan scalar
quantity, called -makespan, sums good is; solutions compared
comparing associated -makespans. simple idea prefer solutions smaller
expected makespan. However, may substantial probability makespan
solution much higher expected value. Instead, take following
approach: confident random makespan solution D,
cannot confident makespan solution s0 D, prefer
solution solution s0 .
fix value , used bound probabilities. Although imagine
natural applications work, would quite small (e.g., less 0.1)
assume range (0, 0.5]. probability event least 1 ,
say event sufficiently certain. experiments described Section 6
use value = 0.05, sufficiently certain means occurs least 95%
chance.
Let time value, let solution. said -achievable using
sufficiently certain jobs finish use solution s; is,
Pr(make(s) D) 1 , make(s) random makespan s.
said -achievable solution -achievable using
s, i.e., exists solution making sufficiently certain jobs finish D.
Time value -achievable maxsS Pr(make(s) D)) 1 ,
max solutions s.
Define Ach (s) set -achievable using s. define (s),
-makespan s, infimum4 Ach (s). , -minimum makespan,
defined infimum Ach , set -achievable,
4. is, greatest lower bound Ach (s); fact, shown Proposition 1(i), (s) smallest
element Ach (s). Hence, Ach (s) equal closed interval [D (s), ), i.e., set time-points
(s).

193

fiBeck & Wilson

= inf {D : (maxsS Pr(make(s) D)) 1 }. sometimes refer (s)
probabilistic makespan s, refer probabilistic minimum makespan.5
prefer solutions better (i.e., smaller) -makespans. Equivalently, solution
considered better s0 time value -achievable using
-achievable using s0 . Optimal solutions ones whose -makespan equal
-minimum makespan.
prove technical properties -makespans -achievability relevant
mathematical results later sections. particular, Proposition 1(ii) states minimum makespan -achievable: i.e., exists solution makes
sufficiently certain jobs finish . smallest value satisfying
property.
Lemma 1 notation:
(i) Ach =



sS

Ach (s);

(ii) exists solution Ach = Ach (s) = (s);
(iii) = minsS (s), minimum (s) solutions s.
Proof:
(i) -achievable
solution s, Ach (s), true

sS Ach (s).
(ii) Consider following property () set time values A: 0 time
value greater (i.e., 0 > D), 0 A; is, interval upper
bound. Let B two sets property (); either B B A. (To show
this, suppose otherwise, neither B B A; exists x B
B A; x must different, assume, without loss
generality, x < y; property (), contradiction required.)
Hence, B either equal equal B. using induction, follows
union finite number sets
property () one sets. set Ach (s)
satisfies property (); therefore, sS Ach (s) = Achs0 solution s0 , so, (i),
Ach = Achs0 . implies = (s0 ).
(iii) Let solution let time value. Clearly, -achievable using
s, -achievable. implies (s). Hence, minsS (s).
(ii), = (s) solution s, = minsS (s), required.
2

Proposition 1
(i) Let solution. (s) -achievable using s, i.e., Pr(make(s) (s))
1 .
(ii) -achievable, i.e., exists solution Pr(make(s) ) 1.
5. Note probabilistic makespan number (a time value), opposed random makespan
solution, random variable.

194

fiProactive Algorithms JSP

Proof:
discrete case, set time values set non-negative integers,
infimum definitions (s) minimum. (i) (ii)
follow immediately definitions.
consider case set time values set non-negative real
numbers.
1
1
(i): m, n {1, 2, . . . , }, let Gm = Pr(0 < make(s)D (s)
), let gn = Pr( n+1
<
1
make(s) (s) n ). countable additivity axiom probability measures, Gm =
P
P
gn . means l1
n=m
n=m gn tends Gm l tends infinity, hence Gl =
Pl1
P
n=m gn tends 0. So, limm Gm = 0. > 0,
l gn = G
1
) 1 , definition (s). Pr(make(s)
Pr(make(s) (s) +
1
). So, = 1, 2, . . ., Pr(make(s)
(s)) + Gm = Pr(make(s) (s) +
(s)) 1 Gm , implies Pr(make(s) (s)) 1 , Gm tends
0 tends infinity.

(ii): part (ii) Lemma 1, solution s, = (s). Part (i) implies
Pr(make(s) ) 1 .
2
Probabilistic JSP Example continued. continue example Section 2.1
Section 2.2. Set 0.05, corresponding 95% confidence. value = 12.5
-achievable using solution sa , since 95% chance paths
0 (simultaneously) shorter length 12.5, probability random
makespan make(sa ) less 12.5 0.95.
consider value ofD = 12.0. Since len() (the random length ) mean 11
standard deviation 1/ 2, chance
len() 12.0 approximately chance
normal distribution 2 standard deviations mean;
probability 0.92. Therefore, = 12.0 -achievable using solution , since
less 0.95 chance random makespan make(sa ) D.
-makespan (also referred probabilistic makespan) solution
therefore 12.0 12.5. fact, -makespan (sa ) approximately equal
12.16, since approximately 95% chance (random) makespan make(s )
12.16. easy show = 12.16 -achievable using
solution, , -minimum makespan, equal (sa ), hence 12.16.
4.2 Lower Bound -Minimum Makespan
section show lower bound -minimum makespan found
solving particular deterministic JSP.
common approach generate deterministic problem replacing random
duration mean distribution. show, certain conditions, minimum makespan deterministic JSP lower bound probabilistic minimum
makespan. instance, example, minimum makespan deterministic
JSP 11, probabilistic minimum makespan 12.16. However, obvious
weakness approach take account spreads distributions. especially important since typically considering small value ,
195

fiBeck & Wilson

0.05. generate stronger lower bound taking account variances
distributions generating associated deterministic job shop problem.
Generating Deterministic JSP Probabilistic JSP Value q.
probabilistic job shop problem, generate particular deterministic job shop problem, depending parameter q 0. use transformation almost
algorithms Section 5. deterministic JSP probabilistic JSP except
random duration replaced particular time value. Solving corresponding
deterministic problem give us information probabilistic problem. deterministic JSP consists set activities, partitioned resource sets
jobs, total order job. duration activity
deterministic problem defined + qi , respectively mean
standard deviation duration activity Ai probabilistic job shop problem.
Hence, q = 0, associated deterministic problem corresponds replacing random
duration mean. Let makeq (s) deterministic makespan solution s, i.e.,
makespan associated deterministic problem (which defined length
longest s-pathsee Section 2.1). Let makeq minimum deterministic makespan
solutions.
Let solution. say probabilistically optimal (s) = . Let
s-path. ( path probabilistic deterministic problems.) said
(deterministically) critical path critical path deterministic problem.
length deterministic
problem, lenq (), P
equal sum
P
P durations
activities path:
Ai (i + qi ), equals
Ai + q
Ai .
introduce following rather technical definition whose significance made clear
Proposition 2: q -sufficient exists (deterministically) critical path
probabilistically optimal solution Pr(len() > lenq ()) > , i.e.,
chance random path length greater deterministic length.
following result shows -sufficient value q leads deterministic
minimum makespan makeq lower bound probabilistic minimum makespan
. Therefore, lower bound deterministic minimum makespan lower
bound probabilistic minimum makespan.
Proposition 2 probabilistic JSP, suppose q -sufficient. Then, solution
s, Pr(make(s) makeq ) < 1 . Therefore, makeq -achievable, strict
lower bound -minimum makespan , i.e., > makeq .
Proof: Since q -sufficient, exists (deterministically) critical path (probabilistically) optimal solution Pr(len() > lenq ()) > . lenq () =
makeq (so ), critical path, and, definition makeq , makeq (so )
makeq . So, Pr(len() > makeq ) > . definition makespan, sample
random durations vector, make(so ) least large len(). So,
Pr(make(so ) > makeq ) > . Hence, Pr(make(so ) makeq ) = 1 Pr(make(so ) >
makeq ) < 1 . implies (so ) > makeq since Pr(make(so ) (so )) 1 ,
Proposition 1(i). Since probabilistically optimal solution, = (so ),
> makeq . Also, solution s, (s) > makeq , (s) > makeq ,
implies makeq -achievable using s, i.e., Pr(make(s) makeq ) < 1 . 2
196

fiProactive Algorithms JSP

4.2.1 Finding -Sufficient q-Values
Proposition 2 shows find lower bound probabilistic minimum makespan
find -sufficient value q, solve (or find lower bound for)
associated deterministic problem. section looks problem finding -sufficient
values q, breaking condition simpler conditions.
remainder Section 4.2, assume independent probabilistic JSP.
Let path solution. Define E[len()],
P expected value
length (in probabilistic JSP), equal PAi . Define 2
Var[len()], variance length , equal Ai i2 , since
assuming durations independent.
P
Defining -adequate B. B 0, write B () + B , equals Ai +
qP
2
B
Ai . say B -adequate (deterministically) critical path
(probabilistically) optimal solution, Pr(len() > B ()) > , i.e.,
chance B standard deviations longer expected length.
duration normally distributed, len() normally distributed, since
sum independent normal distributions. Even durations normally
distributed, len() often close normally distributed (cf. central limit
theorem extensions). So, Pr(len() > B ()) approximately 1 (B),
unit normal distribution. B value slightly less 1 (1 )
-adequate, given approximate normality.
Defining B-adequate Values q. say q B-adequate exists
(deterministically) critical path (probabilistically) optimal solution
lenq () B ().
following proposition shows task finding -sufficient values q
broken down. follows almost immediately definitions.
Proposition 3 q B-adequate B -adequate, q -sufficient.
Proof: Since q B-adequate, exists (deterministically) critical path
(probabilistically) optimal solution lenq () B (). Since B -adequate,
Pr(len() > B ()) > , hence Pr(len() > lenq ()) > , required.
2
Establishing B-adequate Values q. value q B-adequate
exists (deterministically) critical path (probabilistically) optimal solution
qP
P
P
P
2
lenq () B (), equivalently:
Ai ,
Ai + q
Ai
Ai + B
qP

q

Mean{i2 : Ai }
,
MeanP
{i : Ai }
Ai
number activities path , Mean{i : Ai } = M1 Ai .
activity Ai uncertain (i.e., standard deviation equals 0),
omitted summations means. becomes number uncertain
activities path .
is, q B

P

Ai

i2



. written as: q

197

B


fiBeck & Wilson

well known (and quite easily shown), root qmean square collection
Mean{ 2 : Ai }
numbers always least large mean. Hence, Mean{ i: } greater


equal 1. Therefore, crude sufficient condition q B-adequate is: q BM ,
upper bound number uncertain activities path
probabilistically optimal solution (or could take upper bound number
uncertain activities path solution). particular, could generate Badequate q choosing q = BM .
-sufficient Value q. Putting two conditions together using Proposition
1
3, q-value little less (1)
-sufficient, given

lengths paths approximately normally distributed, upper bound
number uncertain activities path optimal solution. Hence,
Proposition 2, minimum makespan makeq associated deterministic problem
strict lower bound -minimum makespan . example, = 0.05,
1 (1 ) 1.645 (since 0.05 chance normal distribution
1.645 standard deviations mean), set q little less
.
1.645

One sometimes generate larger -sufficient value q, hence stronger lower
bound makeq , focusing significantly uncertain activities. Choose value

P 0 1. path , say
P activity Aj -uncertain (with respect
)
{i : Ai , j } > {i : Ai }; sum durations
activities -uncertain fraction sum durations
path. Hence, activities -uncertain relatively small standard
deviations. define upper bound number -uncertain activities
involved path (probabilistically) optimal solution, shown,

B-adequate,
slight modification earlier argument, q-value (1)B

hence q-value little less

(1)1 (1)





-sufficient.

experiments described Section 6 use, varying n, problems n jobs n
activities per job). Solutions paths involving large numbers activities
unlikely good solutions. particular, one might assume that, problems,
optimal solution (deterministically) critical s-path involving
2n activities. Given assumption, following value q -sufficient,
1
, e.g.,
making makeq lower bound probabilistic minimum makespan: q = (1)
2n
q=

1.645

2n

= 0.05. motivates choice q1 Table 2 Section 6.1.

Probabilistic JSP Example continued. number uncertain activities
running example (see Section 2.2, Figure 1 Section 4.1) 3, one
set = 3.
Using = 0.05, leads choice q slightly less 1.645/ 3 0.950.
Proposition 3 discussion, value q -sufficient. durations
associated deterministic problem given setting di = + qi , d1 = 1,
d2 = 2 + q/2, d3 = 3 + q/2, d4 = 4 + q/2 d5 = 5. Solution sa best solution
makespan makeq (sa ) = 1 + 5 + (2 + q/2) + (3 + q/2) = 11 + q. Hence, minimum
198

fiProactive Algorithms JSP

deterministic makespan makeq equals approximately 11.95, lower bound
probabilistic minimum makespan 12.16, illustrating Proposition 2.
However, sc clearly poor solution, could consider solutions:
{sa , sb , sd }. (deterministically) critical path solutions involves two
uncertain activities (within
range interest q-values), set = 2,
q = 1.16 1.645/ 2. leads stronger lower bound 11 + 1.16 = 12.16,
tight lower bound -minimum makespan .
4.2.2 Discussion lower bound
example, able use approach construct tight lower bound
probabilistic minimum makespan. However, situation rather exceptional.
Two features example enable tight lower bound (a) best
solution path almost always longest path; (b) standard deviations
uncertain durations equal. analysis, root mean square
approximated (from below) mean. good approximation standard
deviations fairly similar, extreme case (non-zero) standard deviations
durations (as example), root mean square actually equal
mean.
generally, number ways lower bound tend
conservative. particular,
choice often conservative us confident
genuine upper bound number uncertain activities path
optimal solution;
approximating root mean square standard deviations average
standard deviations: crude approximation standard deviations
durations vary considerably activities;
approximating random variable make(s) random length particular path.
strength lower bound method, however, computationally feasible
reasonably large problems uses existing well-developed JSP methods.
4.3 Evaluating Solution Using Monte Carlo Simulation
given time value, D, want assess exists solution
chance random makespan greater D. methods
involve generating solutions (or partial solutions), testing condition.
noted earlier, evaluating solution amounts solving PERT problem uncertain durations, #P-complete problem (Hagstrom, 1988). #P-complete
problems computation Dempster-Shafer Belief (Wilson, 2000), natural approach take Monte Carlo simulation (Burt & Garman, 1970); try perform
exact computation instead choose accuracy level require high
chance random estimate within true value. evaluation algorithm
199

fiBeck & Wilson

optimal complexity (low-degree polynomial) potentially high constant factor
corresponding number trials required given accuracy.
evaluate solution (or partial solution) using Monte Carlo simulation perform
(large) number, N , independent trials assigning values random variable.
trial generates deterministic problem, check efficiently corresponding
makespan greater D; so, say trial succeeds. proportion trials
succeed estimate Pr(make(s) > D), chance random makespan
D. case independent probabilistic JSPs, generate
random durations vector picking, using distribution Pi , value random duration
di activity Ai . general case, picking random durations vector still
efficient many situations; example, distribution represented Bayesian
network.
4.3.1 Estimating Chance Random Makespan Greater
Perform N trials: l = 1, . . . , N .
(trial) l:
Pick random durations vector using joint density function.
Let Tl = 1 (the trial succeeds) corresponding (deterministic) makespan greater
D. Otherwise, set Tl = 0.
P
Let = N1 N
l=1 Tl proportion trials succeed. estimate p,
p = Pr(make(s) > D), chance randomly generated durations vector leads
makespan (for solution s) greater D. expected value equal
q p, since
1 PN
E[Tl ] = p E[T ] = N l=1 E[Tl ] = p. standard deviation p(1p)
N ,
shown follows: V ar[Tl ] = E[(Tl )2 ] (E[Tl ])2 = p p2 = p(1 p). variables
P
p(1p)
1
Tl independent V ar[T ] = N12 N
4N
. random variable N
i=1 V ar[Tl ] =
N
binomially distributed, (because deMoivre-Laplace limit theorem (Feller,
1968)) use normal distribution approximate .
means that, large N , generating value algorithm will,
high probability, give value close Pr(make(s) > D). choose accuracy level
> 0 confidence level r (e.g., r = 0.95), choose N Pr(|T p| < ) > r;
particular, r = 0.95 using normal approximation, choosing number N trials
12 sufficient. fixed accuracy level confidence level r, number
trials N constant: depend size problem. algorithm
therefore excellent complexity: complexity (low-order polynomial)
single deterministic propagation, must optimal clearly cannot hope beat
complexity deterministic propagation. However, constant factor 12 large
require high accuracy.
4.3.2 Solution Good Enough?
Let time value let solution. Suppose, based Monte-Carlo
algorithm using N trials, want confident -achievable using (i.e.,
200

fiProactive Algorithms JSP

Pr(make(s) > D) ). therefore need observed least little smaller
, since (only) estimate Pr(make(s) > D).
formalize this, shall use confidence interval-style approach. Let K 0. Recall
p = Pr(make(s) > D) unknown quantity want find information
about. say p K-implausible given result following condition
holds: p p
implies least K standard deviations expected value, i.e.,
p KN p(1 p).
case p , p K-implausible given , unlikely
event would happened. example, K = 2, (given normal approximation),
event happen every 45 experiments; K = 4 event
happen every 32,000 experiments.
Pr(make(s) > D) K-implausible given result , confident
Pr(make(s) > D) < : -achievable using s, upper bound
(s) hence -minimum makespan . confidence level, based
normal approximation binomial distribution, (K), unit normal
distribution. example, K = 2 gives confidence around 97.7%.
Similarly, 0 0.5, say p K-implausible given
result following condition holds: p implies
least K standard
p
deviations expected value, i.e., p + KN p(1 p).
definitions K-implausibility slightly informal. formal definitions
follows. Suppose (0, 0.5], K 0, [0, 1] N {1, 2, . . . , }. define:
p K-implausible given p
p p 1, following
condition holds: p KN p(1 p). Similarly, p K-implausible given
p
p 0 p , following condition holds: p + KN p(1 p).
K-implausibility conditions cannot tested directly using definition since
p unknown. Fortunately, following result, gives equivalent conditions
easily checked.
Proposition 4 definitions:
K
N

p
(1 ).
p
(ii) p K-implausible given + KN (1 ).
(i) p K-implausible given

p
Proof: (i): p K-implausible given , setting p gives KN (1 )
p
required. Conversely, suppose KN (1 ). result follows K = 0,
2

assume K > 0. Write f (x) = (x )2 K x(1x)
. Now, since
N
p
K 2 (1)
K
2
N (1 ), > ( )
so, f () 0. Also, f (T ) 0.
N
Since f (x) quadratic polynomial positive coefficient x2 , implies
either solution equation f (x) = 0, two solutions. Since f () 0
> , follows must either solution f (x) = 0, greater
2
. Since p > ,
solution(s). implies, p > , f (p) > 0, (p )2 > K p(1p)
N
q
p(1p)
p p K
N , is, p K-implausible given ,
proving (i).
201

fiBeck & Wilson

q

. Con(ii) p K-implausible given , setting p gives + K (1)
q N
q
, (since 0.5) p implies p + K p(1p)
since
versely, + K (1)
N
N
right-hand-side strictly increasing function p, p K-implausible given ,
required.
2
Part (i) result shows us evaluate solution respect
p bound
K

D: generate (using Monte Carlo simulation) least N (1 ) less
, confidence p < , i.e., Pr(make(s) > D) < ,
confidence -achievable using solution s, i.e., upper bound
probabilistic makespan (s). Part (ii) used branch-and-bound algorithm
described Section 5.2.1, determining backtrack node.
4.3.3 Generating upper approximation probabilistic makespan
solution
Suppose that, given solution s, wish find time value large enough
confident probabilistic makespan D, i.e.,
upper bound -makespan (s). Monte Carlo simulation
adapted purpose. simulate values random makespan make(s)
record distribution these. decide value K, corresponding desired
degree confidence (e.g., K = 2 corresponds 97.7% confidence) choose
minimal suchpthat associated value (generated simulation results) satisfies
KN (1 ). Proposition 4(i), Pr(make(s) > D) K-implausible
given . therefore confident Pr(make(s) > D) < ,
confidence upper bound -makespan (s) s. balance
paper, use notation D(s) represent (upper) estimate (s) found
way.

5. Searching Solutions
theoretical framework provides two key tools use building search algorithms.
First, use Monte Carlo simulation evaluate solution partial solution (see
Section 4.3). Second, appropriate choice q value, solve associated
deterministic problem find lower bound -minimum makespan problem
instance (see Section 4.2). section, make use tools (and
variations) define number constructive local search algorithms. describing
algorithms, recall important concepts notation introduced
earlier sections.
algorithms, explicitly deal case independent probabilistic JSPs durations positive integer random variables. Given approach,
however, algorithms valid:
generalized probabilistic case, assumptions noted Section 4, provided efficient way sample activity durations;
202

fiProactive Algorithms JSP

continuous random variables, provided deterministic solver
handle continuous time values.
5.1 Summary Notation
remainder paper makes use notation concepts earlier sections,
briefly summarize below.
JSP probabilistic JSP: solution totally orders activities requiring
resource (i.e., activities resource set), activity Ai Aj require
resource, either determines Ai must completed time
Aj starts, vice versa (see Section 2.1). partial solution partially orders set
activities resource set. Associated solution non-delay schedule (relative
solution), activities without predecessors started time 0,
activities started soon predecessors completed. makespan
solution time jobs completed associated non-delay
schedule. probabilistic JSP (see Section 2.2), makespan make(s) solution
random variable, since depends random durations.
quantity use evaluate solution (s), -makespan (also known
probabilistic makespan s), defined Section 4.1. probability (random)
makespan (s) , approximately equal . (More
precisely, (s) smallest time value Pr(make(s) > D) .)
Value therefore represents degree confidence required. -minimum makespan
(also known probabilistic minimum makespan) minimum (s)
solutions s.
time value -achievable using solution chance
random makespan D. -achievable using
(s) (see Section 4.1).
Solutions probabilistic JSPs evaluated Monte Carlo simulation (see Section
4.3). method derived generating upper approximation . use
notation D(s) represent upper approximation, constructed D(s)
approximately equal (s), high chance (s) less
D(s)see Section 4.3.3. D(s) thus represents probable upper bound probabilistic
minimum makespan.
probabilistic job shop problem often associate deterministic JSP (see Section
4.2). mapping parameterized (non-negative real) number q. associated
deterministic JSP structure probabilistic JSP; difference
duration activity Ai equal + qi , mean
standard deviation (respectively) duration Ai probabilistic problem.
write makeq (s) makespan solution respect associated deterministic
JSP, makeq minimum makespan: minimum makeq (s) solutions s.
Section 4.2, shown, using Propositions 2 3 analysis Section
4.2.1, certain values q, time value makeq lower bound .
203

fiBeck & Wilson

5.2 Constructive Search Algorithms
Four constructive-search based algorithms introduced here. uses constraintbased tree search core search technique, incorporating simulation q values different ways. section, define constructive algorithm detail provide
description heuristics constraint propagation building blocks used
them.
5.2.1 B&B-N: Approximately Complete Branch-and-Bound Algorithm
Given ability estimate probabilistic makespan solution, ability
test condition implies partial solution cannot extended solution
better probabilistic makespan, obviously applicable search technique branch-andbound (B&B) use Monte Carlo simulation derive upper- lower-bounds
solution quality. able cover entire search space, approach
approximately complete (only approximately always small probability
miss optimal solution due sampling error).
B&B tree (rooted) binary tree. Associated node e tree
partial solution se , solution node leaf node. empty partial solution
associated root node. associated non-leaf node e pair
activities, Ai , Aj , j 6= i, resource set, whose sequence determined
partial solution se . two nodes e extend se : one sequences Ai Aj ,
adds opposite sequence. heuristic used choose sequence try first
described Section 5.2.5.
value global variable always confidence (corresponding
choice Ksee Section 4.3.2) exists solution whose -makespan, (s),
. Whenever reach leaf node, e, find upper estimate 0 = D(se )
probabilistic makespan (s), Monte Carlo simulation based method
Section 4.3.3. set := min(D , D0 ). Variable initialized high value.
non-leaf nodes, e, check see worth exploring subtree e.
perform Monte Carlo simulation partial solution, se , using current value ;
generates result . use Proposition 4(ii) determine Pr(make(s e ) > )
K-implausible given ; is, backtrack, since confident
exists solution extending partial solution se improves current best solution.
K chosen sufficiently large, confident miss good solution. 6
refer algorithm B&B-N performs B ranch-and-B ound simulation
N ode.
5.2.2 B&B-DQ-L: Approximately Complete Iterative Tree Search
internal node, e, tree, previous algorithm used Monte Carlo simulation
(but without strong propagation within trial) find lower bound probabilistic
makespans solutions extending partial solution se . alternative idea generating
6. large number tests, need much higher confidence usual
confidence interval; fortunately, confidence associated K (based normal approximation
2
1
binomial, approximation tail normal distribution) approximately 1 K 1 2 e 2 K ,
tends 1 extremely fast K increases.

204

fiProactive Algorithms JSP

B&B-DQ-L():
Returns solution lowest probabilistic makespan
1
2
3
4
5
6

7
8

(s , ) findFirstB&BSimLeaves(, 0)
q qinit
q 0 timed-out
(s, D) findOptB&BSimLeaves(D , q)
6= N IL
s;
end
q q qdec
end
return
Algorithm 1: B&B-DQ-L: Approximately Complete Iterative Tree Search

lower bound use approach Section 4.2: find minimum makespan,
solutions extending se , associated deterministic problem based q value
-sufficient. minimum makespan (see Proposition 2) lower bound
probabilistic makespan. Standard constraint propagation deterministic durations
enables lower bound computed much faster simulation previous
algorithm. leaf node, simulation used B&B-N find estimate
probabilistic makespan solution.
basic idea requires selection q value. However, rather parameterize
algorithm (as others below), choose perform repeated tree
searches descending q value.
algorithm finds initial solution (line 1 Algorithm 1) therefore initial
upper bound, , probabilistic makespan q = 0. Subsequently, starting
high q value (one result deterministic lower bound), perform
tree search. leaf, e, reached, simulation used find D(se ).
high q value, likely deterministic makespan makeq (se ) much greater
D(se ). Since enforce constraint makeq (se ) D(se ), finding D(se )
simulation causes search return interior node, i, high tree
makeq (Si ) D(se ) Si represents set solutions subtree node i,
makeq (Si ) deterministic lower bound makespan solutions. high
q values, commonly observed experiments nodes
meet criterion and, therefore, search able quickly exhaust search
space. happens, reduce q value small amount, qdec (e.g., 0.05),
restart tree search. Eventually, often quickly, reach q value
exists full solution, se , makeq (se ) D(se ). solution stored
current best set = D(se ). B&B-N, used upper bound
subsequent search.
Algorithm 1 presents pseudocode basic algorithm. make use two functions
defined using pseudocode:
findFirstB&BSimLeaves(c, q): creates JSP activity durations defined based
q value passed conducts branch-and-bound search Monte Carlo
205

fiBeck & Wilson

simulation used leaf node standard constraint propagation used
interior nodes. first solution found whose probabilistic makespan less
c returned value probabilistic makespan. c set
high line 1, backtracking needed find solution therefore one
leaf node visited one simulation performed.
findOptB&BSimLeaves(c, q): findFirstB&BSimLeaves(c, q) except
solution lowest probabilistic makespan returned rather first one found.
solution found, NIL value returned. Unless q value low enough
deterministic makespan lower bound probabilistic makespan,
function necessarily return globally optimal solution.
find starting solution q = 0 serve initial upper bound optimal
probabilistic makespan. practice, B&B-DQ-L run limit CPU time.
q = 0 reached within time limit, algorithm approximately complete.
noted above, possible, especially high q value, solution, se ,
makeq (se ) much larger D(se ), therefore search backtrack deepest
interior node makeq (Si ) D(se ). fact, assignment D(se ) value
global cut upper bound probabilistic makespan. technical reasons
beyond scope paper, standard constraint-based tree search implementations
automatically handle global cuts. therefore modified standard behavior
repeatedly post upper bound constraint makeq (Si ) causing series backtracks
correct interior node.
refer algorithm B&B-DQ-L series B ranch-and-B ound
searches Descending q values simulation used Leaves tree.
B&B-DQ-L example novel constraint-based search technique might
useful wider context. problem cost function expensive evaluate
inexpensive, parameterizable lower bound calculation, search based overconstraining problem (i.e., choosing parameter value lead lower
bound) iteratively relaxing bounding function, may worth investigating.
discuss approach Section 7.
5.2.3 B&B-TBS: Heuristic Tree Search Algorithm
Previous results algorithm similar B&B-N (Beck & Wilson, 2004) indicated
simulation responsible large percentage (e.g., 95%) run-time.
reduce number times require simulation simulating solutions
good deterministic makespan. deterministic filtering search central idea
rest algorithms investigated paper.
simple method filtering solutions first spend fixed amount CPU time
find solution, s0 , low deterministic makespan, makeq (s0 ), using fixed q value
standard constructive tree search. Then, search restarted using q value
whenever solution, si , found makeq (si ) makeq (s0 ), simulation run
evaluate D(si ), estimate probabilistic makespan, (si ). probabilistic
makespan found better lowest probabilistic makespan far, solution
stored. Search continued entire tree explored maximum allowed
CPU time expired. Algorithm 2 contains pseudocode.
206

fiProactive Algorithms JSP

B&B-TBS(q):
Returns solution lowest probabilistic makespan found
1
2
3
4
5
6
7

8

(s , Dinitial ) findOptB&B(, q, tinitial )

solutions exist timed-out
(s, D) findNextB&B(Dinitial + 1, q, time-remaining)
D0 simulate(s)
D0 <
s; D0
end
end
return
Algorithm 2: B&B-TBS: Heuristic Tree Search Algorithm
Algorithm 1, make use number functions defined pseudocode:
findOptB&B(c, q, t): creates JSP activity durations defined based q
value passed conducts deterministic branch-and-bound search CPU
seconds using c upper bound deterministic makespan. search
tree exhausted time-limit reached, best deterministic solution found
(i.e., one minimum makespan), together deterministic makespan
returned. Monte Carlo simulation done.
findNextB&B(c, q, t): function produces sequence solutions (one solution
time called) whose deterministic makespan less c. problem
defined using q value CPU time limit. solutions produced
leaves B&B search tree order encountered algorithm. Note
Algorithm 2, c value change. Given enough CPU time, algorithm
evaluate probabilistic makespan solutions whose deterministic makespan
less equal Dinitial .
simulate(s): standard Monte Carlo simulation run solution D(s),
estimate probabilistic makespan, (s), returned.

algorithm complete, even choice q value results deterministic
makespans lower bounds probabilistic makespan.
guarantee optimal probabilistic solution deterministic makespan less
Dinitial therefore, even infinite CPU time, may evaluated.
algorithm called B&B-TBS B ranch-and-B ound-T imed B etter olution:
fixed CPU time spent find good deterministic solution, deterministic
solution found good better initial solution simulated.
5.2.4 B&B-I-BS: Iterative Heuristic Tree Search Algorithm
extreme filtering algorithm first finds optimal deterministic solution uses
deterministic makespan filter choosing solutions simulate. Using fixed
207

fiBeck & Wilson

B&B-I-BS(q):
Returns solution smallest probabilistic makespan found
1
2
3
4
5
6
7
8
9

10
11

(s , Dinitial ) findOptB&B(, q, t0 1)
simulate(s )
i0
timed-out
search complete
(s, makeq ) findNextB&B(Dinitial (1 + i/100) + 1, q, time-remaining)
simulate(s)
<
s;
end
end
ii+1
end
return
Algorithm 3: B&B-I-BS: Iterative Heuristic Tree Search Algorithm

q value, optimal solution found simulated. CPU time remaining,
search series iterations starting using optimal deterministic makespan
bound. solutions deterministic makespan good (or, general, better
than) current bound found simulated. subsequent iterations, bound
deterministic makespan increased, resulting larger set solutions
simulated. solution lowest estimated probabilistic makespan returned.
larger problems, optimal deterministic makespan may found within CPU
limit. case, best deterministic solution found simulated returned
(i.e., one simulation done).
formally, finding optimal deterministic solution makespan, make q ,
series iterations beginning = 0 executed. iteration, bound
deterministic makespans set makeq (1+i/100). solutions, se , whose deterministic
makespans, makeq (se ) makeq (1 + i/100), simulated one lowest
probabilistic makespan returned. Algorithm 3 presents pseudocode depends
functions defined above.
algorithm complete. large enough cost bound greater
deterministic makespan activity permutations, simulated.
However, may grow unreasonably large therefore treat algorithm as,
practically, incomplete.
refer algorithm B&B-I-BS B ranch-and-B ound-I terative-B est olution.
5.2.5 Heuristic Constraint Propagation Details
algorithms described use texture-based heuristics decide pair activities sequence sequence try first. heuristic builds resource profiles
combine probabilistic estimates contention activity resource
time-point. maximum point resource profiles selected activity
208

fiProactive Algorithms JSP

pair contends resource selected time-point heuristically chosen.
sequence chosen one maximizes remaining slack. intuition
pair activities contending highly contended-for resource time-point
critical pair activities sequenced early search. Otherwise, via
constraint propagation decisions, time windows activities may
pruned point neither sequence possible. texture-based heuristics
complexity search node O(mn2 ) number resources n
number activities resource.
detailed description analysis texture-based heuristic see work
Beck Fox (2000) Beck (1999).
constraint propagation used (i.e., algorithms except B&B-N),
use strong constraint propagation techniques constraint-based scheduling: temporal
propagation, timetables (Le Pape, Couronne, Vergamini, & Gosselin, 1994), edge-finder
(Nuijten, 1994), balance constraint (Laborie, 2003).
5.3 Local Search Algorithms
reason deterministic filtering search algorithm needs based
branch-and-bound. Indeed, given approach finding simulating solutions
low deterministic makespans, algorithms based local search may perform better
constructive search algorithms.
section, present two deterministic filtering algorithms based tabu search. 7
define algorithm discuss details tabu search procedure itself.
5.3.1 Tabu-TBS: Tabu Search Analog B&B-TBS
central idea behind using tabu search deterministic filtering search generate
sequence promising deterministic solutions simulated. seems reasonable
create analog B&B-TBS using tabu search. fixed q fixed amount
tinitial CPU time, beginning run, solution lowest possible deterministic makespan, Dinitial , sought. Search restarted whenever solution, s,
found deterministic makespan makeq (s) Dinitial , Monte Carlo simulation
used approximate probabilistic makespan. solution lowest estimated
probabilistic makespan returned.
Algorithm 4 presents pseudocode simple approach. use following
functions (pseudo-code given):
findBestTabu(c, q, t): function analogous findOptB&B(c, q, t). Tabu search
run CPU seconds solution lowest deterministic makespan
(based q value) less c returned.
findNextTabu(c, q, t): function analogous findNextB&B(c, q, t). sequence
solutions (one solution time called) whose deterministic makespan less
7. Early experiments explored even simpler way using tabu search solve probabilistic JSP
incorporating simulation neighborhood evaluation. Given search state, move operator (see
Section 5.3.3 details) defines set neighboring states. neighbor, run Monte
Carlo simulation choose neighbor lowest probabilistic makespan. technique,
surprisingly, proved impractical considerable CPU time spent determine single move.

209

fiBeck & Wilson

Tabu-TBS(q):
Returns solution lowest probabilistic makespan found
1
2
3
4
5
6
7

8

(s , Dinitial ) findBestTabu(, q, tinitial )

termination criteria unmet
(s, D) findNextTabu(Dinitial + 1, q, time-remaining)
D0 simulate(s)
D0 <
s; D0
end
end
return
Algorithm 4: Tabu-TBS: Local Search Filtering Algorithm
c returned. problem defined using q value CPU time
limit. solution produced next solution found tabu search meets
makespan requirement.

call algorithm Tabu-TBS Tabu-T imed B etter olution.
B&B-TBS, c value updated iteration. initial search (line
1) used find good deterministic solution simulation done solutions whose
deterministic makespan better solution found initial search.
5.3.2 Tabu-I-BS: Iterative Tabu Search Algorithm
core tabu search implementation fixed durations necessarily use entire
CPU time (see Section 5.3.3) and, fact, especially small instances often terminates
quickly. therefore create iterative tabu-based solver probabilistic
JSP similar B&B-I-BS.
first phase, using time limit one second less overall time limit,
tabu search used find good deterministic solution, based fixed q value.
solution simulated. tabu search may terminate time
limit expired, remaining time spent generating solutions deterministic
makespan within fixed percentage initial solutions deterministic makespan.
B&B-I-BS, iterations run increasing value starting = 0.
iteration, simulate solutions found tabu search whose deterministic makespan
(1 + i/100)Dinitial , Dinitial value deterministic makespan found
phase 1. solution lowest probabilistic makespan returned.8
algorithm termed Tabu-I-BS Tabu-I terative-B est earch. pseudocode
algorithm presented Algorithm 5.
5.3.3 Tabu Search Details
tabu search used find solutions problems deterministic durations TSAB
algorithm due Nowicki Smutnicki (1996). restricted move operator (termed
8. Tabuf algorithm proposed Beck Wilson (2004) corresponds first iteration Tabu-I-BS.

210

fiProactive Algorithms JSP

Tabu-I-BS(q):
Returns solution smallest probabilistic makespan found
1
2
3
4
5
6
7
8
9

10
11

(s , Dinitial ) findBestTabu(, q, t0 1)
simulate(s )
i0
timed-out
termination criteria unmet
(s, makeq ) findNextTabu(Dinitial (1 + i/100) + 1, q, time-remaining)
simulate(s)
<
s;
end
end
ii+1
end
return
Algorithm 5: Tabu-I-BS: Iterative Tabu-based Filtering Algorithm

N 5 Blazewicz, Domschke Pesch, 1996) produces neighborhood swapping
subset pairs adjacent activities resource given solution. standard
tabu list ten moves done immediate past kept escape local minima.
use standard aspiration criteria accepting move tabu list resulting
solution better solution found far.
One important additions basic tabu search mechanism TSAB
maintenance elite pool solutions. small set (i.e., 8) best solutions encountered far updated whenever new best solution
encountered. standard tabu search stagnates (i.e., made large number
moves without finding new best solution), search returns one elite solutions
continues search it. solution removed set elite solutions. Search
terminated either maximum CPU time reached elite solution pool
empty.
5.4 Summary Algorithms
Table 1 summarizes algorithms introduced above.

6. Empirical Investigations
empirical investigations address two main issues: scaling behavior
approximately complete heuristic methods problem size uncertainty increase
whether using deterministic methods, represent uncertainty duration
extensions, useful approach. respect scaling, two interesting subquestions: first, approximately complete techniques compare
and, second, cross-over point terms problem size heuristic
techniques out-perform approximately complete techniques.
211

fiBeck & Wilson

Deterministic
Algorithm
B&B

Complete
Yes

B&B-DQ-L

B&B

Yes

B&B-TBS

B&B



B&B-I-BS

B&B

Yes

Tabu-TBS

Tabu



Tabu-I-BS

Tabu



Name
B&B-N

Description
B&B simulation node find upper
lower bounds
B&B deterministic durations used lower
bounds simulation done leaf node.
durations decrease iteration.
Find good deterministic solution, s,
restart search, simulating whenever
deterministic solution good found.
Find optimal deterministic solution, s.
Restart search simulating whenever
deterministic solution within i% found
Repeat increasing i.
Find good deterministic solution, s,
restart search simulating whenever
deterministic solution good found.
Find good deterministic solution, s,
possible. Restart search simulating whenever
deterministic solution within i%
found. Repeat increasing i.

Table 1: summary algorithms introduced find probabilistic makespan
instance job shop scheduling problem probabilistic durations.

heuristic techniques necessary assign fixed durations activity.
standard approach use mean duration. However, cases
representation uncertainty surrounding duration, take
account want high probability (1 ) execution. general approach
heuristically use formulation lower bound -minimum makespans presented
Section 4.2: duration activity Ai defined + qi , q fixed
non-negative value, (respectively) mean standard deviation
duration Ai . Since longer limited producing lower bound,
flexibility selecting q. Intuitively, want q-value leads situation
good deterministic solutions low values probabilistic makespan (s).
experiment number q-values based analysis Section 4.2 shown Table
2. cases, set B = 1.645 (see Section 4.2) corresponding = 0.05. Value q 3
generated problem instance Monte Carlo simulation: simulating 100000 paths
n activities.
6.1 Experimental Details
empirical investigations examine four sets probabilistic JSPs size {4 4, 6 6, 10
10, 20 20} (where 10 10 problem 10 jobs consisting 10 activities),
set, three uncertainty levels uj {0.1, 0.5, 1} considered. deterministic problem
generated using existing generator (Watson, Barbulescu, Whitley, & Howe, 2002)
212

fiProactive Algorithms JSP

q0
0

q1
1.645

2n

q2
q1 +q3
2

1.645

n

q3
MeanAi i2
MeanAi

q

Table 2: q-values used experiments. choices q1 q3 motivated
analysis Section 4.2.1.

integer durations drawn uniformly interval [1, 99]. Three probabilistic instances
different levels uncertainty produced setting mean duration
deterministic duration activity Ai , randomly drawing (using uniform
distribution) standard deviation duration activity Ai interval [0,
uj ]. distribution duration approximately normal. problem size,
generate 10 deterministic problems transformed 30 probabilistic instances.
problem sizes chosen elicit range behavior, small problems,
approximately complete algorithms expected able find prove
(approximate) optimality, larger problems, even underlying deterministic
problems could solved optimality within time limit used. chose use
existing generator rather than, example, modifying existing benchmark problems,
allowed us full control problem structure. three levels
uncertainty simply chosen low, medium, high uncertainty conditions
compare algorithms.
Given stochastic nature simulation tabu search algorithm, algorithm run 10 times problem instance different random seeds. run
time limit 600 CPU seconds. Monte Carlo simulation uses N = 1000 independent
trials.
hardware used experiments 1.8GHz Pentium 4 512 MB main
memory running Linux RedHat 9. algorithms implemented using ILOG Scheduler
5.3.
Recall B&B-DQ-L algorithm, employ descending sequence q values.
problems except 20 20 problems, initial q value, qinit , set 1.25,
decrement, qdec , 0.05. 20 20 problems, qinit value 0.9 used.
change made observing qinit = 1.25, initial tree search 2020
problems would often fail find solution prove none existed within reasonable
amount time. believe due problem instances size
solution q = 1.25 satisfied constraint simulated makespan must
less equal deterministic approximation (i.e., makeq (se ) D(se )see
Section 5.2.2), yet search space sufficiently large require significant
amount search prove it. Reducing qinit 0.9 results initial solution found
quickly instances.
primary evaluation criterion mean normalized probabilistic makespan (MNPM )
algorithm achieved relevant subset problem instances (we display
data different subsets examine algorithm performance different problem sizes
uncertainty levels). mean normalized probabilistic makespan defined follows:
213

fiBeck & Wilson

MNPM (a, L) =

1 X D(a, l)
|L|
Dlb (l)

(1)



L set problem instances, D(a, l) mean estimate probabilistic
makespan found algorithm l 10 runs, Dlb (l) lower bound probabilistic makespan l. problems except 20 20, Dlb found solving
deterministic problems using q1 , simple, plausibly -sufficient q-value (see Section
4.2 Table 2). instance solved using constraint-based tree search incorporating
texture-based heuristics global constraint propagation used above. maximum
time 600 CPU seconds given. (deterministic) problems smaller 20 20
easily solved optimality. However, none 2020 problems solved optimality.
this, Dlb values chosen represent best solutions found,
true lower bounds.
6.2 Results Analysis
Table 3 presents overview results experiments problem size
uncertainty level. results q = q2 shown heuristic algorithm.
large performance difference among non-zero q-values (q 1 , q2 q3 ). return
issue Section 6.2.2. cell Table 3 mean value 10 independent
runs 10 problems. Aside 4 4 instances, runs reached 600 CPU
second time limit. Therefore, report CPU times.

Problem
Size
44
66
10 10
20 20

Unc.
Level
0.1
0.5
1
0.1
0.5
1
0.1
0.5
1
0.1
0.5
1

B&B Complete
N
DQ-L
1.027* 1.023*
1.060* 1.049*
1.151*
1.129
1.034
1.021
1.113
1.073
1.226
1.170
1.185
1.028
1.241
1.115
1.346
1.234
1.256
1.142
1.326
1.233
1.482
1.388

Algorithms
B&B Heuristic
TBS
I-BS
1.026
1.026
1.064
1.059
1.154
1.149
1.022
1.022
1.083
1.077
1.178
1.174
1.024 1.024
1.101 1.101
1.215 1.215
1.077
1.071
1.177
1.181
1.334
1.338

Tabu
TBS
I-BS
1.027 1.023
1.063 1.046
1.153 1.128
1.027
1.023
1.074
1.074
1.185 1.168
1.035
1.028
1.121
1.112
1.244
1.223
1.029 1.027
1.136 1.137
1.297 1.307

Table 3: mean normalized probabilistic makespans algorithm. * indicates
set runs have, high confidence, found approximately optimal
makespans. indicates problem sets normalization done
approximate lower bounds. lowest MNPM found problem set
shown bold.

214

fiProactive Algorithms JSP

impression results gained looking bold entries indicate
lowest mean normalized probabilistic makespan (MNPM) found problem
set. B&B-N B&B-DQ-L find approximately optimal solutions smallest
problem set, B&B-DQ-L Tabu-I-BS find lowest probabilistic makespans
4 4 6 6 problems. Performance complete B&B techniques,
especially B&B-N, degrade 10 10 problems heuristic B&B algorithms
find lowest probabilistic makespans. Finally, largest problems, tabu-based
techniques clearly superior.
One anomaly overall results Table 3 seen B&B-N B&B-DQ-L
entries 4 4 problems. two three uncertainty levels algorithms terminate limit CPU time resulting approximately optimal solutions. However,
mean normalized probabilistic makespans lower B&B-DQ-L algorithm.
conjecture artifact B&B-DQ-L algorithm biases simulation
toward lower probabilistic makespan values. B&B-N, particular solution, s,
simulated find D(s). B&B-DQ-L, solution may simulated multiple
times leading bias. illustration, assume B&B-DQ-L finds approximately
optimal solution searching tree corresponding q = q 0 > 0. subsequent
iteration q = q 00 < q 0 , provided deterministic makespan less previously identified probabilistic makespan (i.e., makeq (s ) < D(s )), solution found
simulated again. actual identity current best solution used
determine solutions simulate. subsequent simulation, lower value
D(s ) generated, replace previous lowest probabilistic makespan value.
leads situation may re-simulate solution multiple times, keeping
lowest probabilistic makespan found simulations. Similar re-simulation
possible Tabu-I-BS algorithm.
test statistical significance results Table 3, ran series randomized
paired-t tests (Cohen, 1995) p 0.005. results statistical tests
displayed Table 4 different problem sizes. different uncertainty levels
collapsed that, example, 4 4 statistics based 4 4
instances. informal impression discussed reflected tests B&BDQ-L Tabu-I-BS dominating two smallest problem sizes, branch-and-bound
heuristic approaches performing best 1010 problems, tabu-based techniques
delivering best results 20 20 problems.
Overview. primary interpretation performance algorithms
experiments follows. smaller problems (44 66), complete techniques
able cover entire search space least significant portion it. Though
case B&B-DQ-L, solutions chosen simulation heuristically driven
deterministic makespan values, lower bound results Section 4.2 ensure
good solutions found provided iterations small q values run within
CPU time limit. 10 10 problems, complete techniques able
simulate sufficient variety solutions as, especially B&B-N, heuristic guidance
poor. Note, however, B&B-DQ-L competitive with, and, many problems
sets, better tabu-based algorithms 10 10 problems. believe
10 10 results stem ability B&B heuristic algorithms quickly find
215

fiBeck & Wilson

Problem
Size
44
66
10 10
20 20

Statistical Significance
(p 0.005)
{B&B-DQ-L, Tabu-I-BS} < {B&B-TBS, B&B-I-BS, Tabu-TBS, B&B-N}
{B&B-DQ-L, Tabu-I-BS} < {B&B-I-BS} < {B&B-TBS} < {Tabu-TBS} < {B&B-N}
{B&B-TBS, B&B-I-BS} < {Tabu-I-BS, B&B-DQ-L, Tabu-TBS} < {B&B-N}
{Tabu-TBS, Tabu-I-BS} < {B&B-TBS, B&B-I-BS} < {B&B-DQ-L} < {B&B-N}

Table 4: statistically significant relationships among algorithms results
shown Table 3. Algorithms within set show significant difference.
< relation indicates algorithms left-hand set significantly
lower MNPM algorithms right-hand set. set indicated
represents complicated relationship amongst algorithms: Tabu-I-BS <
Tabu-TBS pairs set show significant performance differences.

optimal deterministic solution systematically simulate solutions
deterministic makespans close optimal. contrast, tabu-based algorithms
systematically enumerate solutions. Finally, largest problems,
hypothesize tabu search techniques result best performance able
find better deterministic solutions simulate.
Problem Size. size problems increase, see not-unexpected decrease
quality probabilistic makespans found. simple reasonable explanation
trend less search space explored within given CPU time
larger problems. likely factors contribute trend (e.g.,
quality lower bound may well systematically decrease problem size increases).
Uncertainty Level. normalized makespan values increase within problem size
uncertainty level rises. results calculated normalization
lower bound, possible observed decrease solution quality actually due
decrease quality lower bound rather reduction quality
solutions found algorithms uncertainty increases. test idea, Table 5
normalized 4 4 results using optimal probabilistic makespans found B&B-N
rather deterministic lower bound. table shows algorithms apart
B&B-DQ-L Tabu-I-BS, trend increasing mean normalized probabilistic
makespan still evident. algorithms, least, putative decreasing quality
lower bound cannot entire explanation trend worse performance
results higher levels uncertainty. Section 6.2.2, revisit question provide
evidence could explain algorithms perform worse uncertainty increased.
results lend credibility conjecture observed super-optimal
performance B&B-DQ-L Tabu-I-BS small problems due repeatedly
simulating solution. low levels uncertainty, repeated simulations truly
best solution vary greatly, resulting MNPM value 1. higher levels
uncertainty, distribution simulated makespans wider and, therefore, repeated
simulation solution biases results toward smaller probabilistic makespan values.
observe results B&B-DQ-L Tabu-I-BS Table 5.
216

fiProactive Algorithms JSP

Unc.
Level
0.1
0.5
1

B&B Complete
N
DQ-L
1.004
1.000
1.008
0.998
1.015
0.996

Algorithms
B&B Heuristic
TBS
I-BS
1.003
1.002
1.012
1.008
1.018
1.013

Tabu
TBS
I-BS
1.003 0.999
1.011 0.995
1.017 0.996

Table 5: mean normalized probabilistic makespans algorithm 4 4
problem set normalized optimal probabilistic makespans found B&B-N.

balance section, turn detailed analysis algorithms.
6.2.1 Analysis: B&B Complete Algorithms
performance B&B-N poor unable exhaustively search branchand-bound tree. high computational cost running simulation every node
relatively weak lower bound partial solutions provide9 conspire result technique
scale beyond small problems.
Problem
Size
44
66
10 10
20 20

Uncertainty
0.1
0.5
0
0
0
0.5
0.95 0.85
0.9
0.9

Level
1
0
0.75
0.9
0.9

Table 6: lowest q value used problem size uncertainty level B&BDQ-L. problems except 20 20, initial q value 1.25. 20 20
problems, initial q value 0.9

B&B-DQ-L able perform somewhat better B&B-N larger problems even
able exhaustively search tree q = 0. Table 6 shows
minimum q values attained problem size uncertainty level. deterministic
durations defined q value serve guide prune search iteration and,
therefore, heuristic algorithms (see below), search heuristically guided
extent solutions low deterministic makespans low probabilistic
makespans. However, characteristics solutions found search unclear.
Recall B&B-DQ-L starts high q value that, combination constraint
deterministic makespan must less equal best simulated probabilis9. One idea improving lower bound investigate incorporate resourcebased propagators (e.g., edge-finding) evaluation partial solution. single trial
internal node, deterministic makespan found sampling distributions finding
longest path temporal network. sampling, however, possible apply
standard propagation techniques might insert additional edges precedence graph
thereby increase makespan, improving lower bound.

217

fiBeck & Wilson

tic makespan found far, significantly prunes search space. Ideally, would
search high q find solutions good probabilistic makespans
wish find good solutions quickly simulated probabilistic makespan
values used prune subsequent search lower q values. Therefore, effort
better understand B&B-DQ-L search, examine characteristics initial
solutions finds.
idea quality solutions produced high q values seen
comparing probabilistic makespan found high q (the first solution found)
best solution found run. Table 7 presents comparison form f ,
mean normalized makespans initial solutions found B&B-N B&B-DQL. data indicate first solution found B&B-DQ-L much better
found B&B-N. B&B-N searches initial solution, upper bound
deterministic makespan constrain problem: solution therefore
easy find (i.e., backtracking) little constraint propagation
heuristic information available guide search solution small makespan.
contrast, B&B-DQ-L searches initial solution, high q value means
searching highly constrained search space deterministic makespan must
less probabilistic makespan. Therefore, tight upper bound
deterministic makespan (relative durations incorporate q values).
many cases, initial iterations fail find feasible solutions, quickly.
Eventually, q value low enough allow feasible solution, however search
solution strongly guided propagation problem constraints. summary,
initial search B&B-N guidance constraint propagation toward good
solution B&-DQ-L guided constraint propagation overly constrained
problem. Table 7 shows that, experiments, guidance tends result better
initial solutions. believe observation may useful generally constraint
solving (see Section 7).
provide fuller indication performance differences, Table 7 presents
improvement first solution achieved: difference first solution
last solution (Dl ) found algorithm (Dl value reported Table 3).
larger problem sets, improvement made first solution B&B-DQ-L
greater. smaller problem sets, improvement B&B-N greater
B&B-DQ-L, however, suspect ceiling effect reduces amount B&B-DQ-L
improve (i.e., initial solutions already quite close optimal).
6.2.2 Analysis: Heuristic Algorithms
turn performance heuristic algorithms. first examine hypothesis
performance dependent two factors: ability algorithms find
solutions low deterministic makespans correlation good deterministic
probabilistic makespans. turn analysis effect differing q
values heuristic algorithm performance.
Finding Good Deterministic Makespans. argued performance
heuristic techniques (and B&B-DQ-L) dependent upon ability find solutions
good deterministic makespans. provide evidence argument, looked
218

fiProactive Algorithms JSP

Problem
Size
44
66
10 10
20 20

Unc.
Level
0.1
0.5
1
0.1
0.5
1
0.1
0.5
1
0.1
0.5
1

B&B-N
Df
Df l
1.089
0.062
1.119
0.059
1.227
0.076
1.106
0.072
1.163
0.050
1.301
0.075
1.191
0.006
1.258
0.017
1.369
0.005
1.259
0.003
1.332
0.004
1.494
0.008

B&B-DQ-L
Df
Df l
1.028
0.005
1.078
0.029
1.165
0.036
1.067
0.046
1.108
0.035
1.221
0.051
1.069
0.045
1.151
0.050
1.269
0.054
1.168
0.026
1.242
0.009
1.404
0.016

Table 7: mean normalized makespan first solutions found algorithm
(Df ) difference mean normalized makespans first
last solutions (Df Dl ).

quality best deterministic solutions found B&B-I-BS Tabu-I-BS.
hypothesize better performing algorithm found better deterministic
solutions worse performer.
Table 8 presents results algorithm two largest problem sets. 10 mean
normalized deterministic makespan (MNDM ) calculated follows:
MNDM (a, L) =

makeq (a, l)
1 X
|L|
makeq,min (l, B&B BS)

(2)



L set problem instances, makeq (a, l) mean deterministic makespan found
algorithm l 10 runs, makeq,min (l, B&B BS) lowest deterministic
makespan found B&B-I-BS algorithm runs problem l. MNDM, therefore,
provides relative measure quality average deterministic makespans
two algorithms: higher value, worse average makespan found relative
B&B-I-BS.
Table 8 consistent hypothesis. 10 10 problems, B&B-I-BS
outperforms Tabu-I-BS, former able find solutions lower mean deterministic
makespan. 20 20 problems results reversed Tabu-I-BS finding
better mean deterministic makespans better probabilistic makespans.
result lends support original motivation deterministic filtering algorithms: performance algorithms terms probabilistic solution quality
positively related quality deterministic solutions able find.
next section addresses question performance relationship observed.
10. show 10 10 20 20 problems sets influenced conjectured
repeated simulation behavior Tabu-I-BS.

219

fiBeck & Wilson

Problem
Size
10 10
20 20

Uncertainty
Level
0.1
0.5
1
0.1
0.5
1

MNDM
B&B-I-BS Tabu-I-BS
1.000
1.002
1.000
1.004
1.000
1.004
1.045
1.002
1.041
0.998
1.037
1.002

Table 8: mean normalized deterministic makespan (MNDM) B&B-I-BS TabuI-BS.

Correlation Deterministic Probabilistic Makespan. ability algorithms find good deterministic makespans would irrelevant
ability find good probabilistic makespans without correlation two.
reasonable expect level uncertainty problem instance impact
correlation: low uncertainty variations duration small, meaning
expect probabilistic makespan relatively close deterministic makespan.
uncertainty level high, distribution probabilistic makespans single
solution wider, resulting less correlation. hypothesize impact
uncertainty level contributes observed performance degradation (see Tables 3 5)
heuristic techniques higher uncertainty levels problem size held constant.
examine hypothesis generated 100 new 10 10 deterministic JSP problem
instances generator parameters used above. standard deviations
duration activity 100 instances generated independently
five uncertainty levels uj {0.1, 0.5, 1, 2, 3} resulting total 500 problem
instances (100 uncertainty level). instance four q
values (as Table 2), randomly generated 100 deterministic solutions
simulated. Using R statistical package (R Development Core Team, 2004),
measured correlation coefficient problem set. cell Table 9 result
10000 pairs data points: deterministic probabilistic makespans 100 random
deterministic solutions 100 problem instances.
Uncertainty Level
0.1
0.5
1
2
3

q0
0.9990
0.9767
0.9176
0.8240
0.7381

q1
0.9996
0.9912
0.9740
0.9451
0.9362

q2
0.9996
0.9917
0.9751
0.9507
0.9418

q3
0.9995
0.9909
0.9736
0.9517
0.9423

Table 9: correlation coefficient (r) comparing pairs deterministic probabilistic makespans set 10 10 probabilistic JSPs. cell represents
correlation coefficient 10000 deterministic, probabilistic pairs.

220

fiProactive Algorithms JSP

Table 9 supports explanation performance heuristic techniques.
uncertainty level increases, correlation deterministic makespan
corresponding probabilistic makespan lessens. strength correlation somewhat
surprising: even highest uncertainty level standard deviation duration activity uniformly drawn 0 3 times mean duration,
correlation 0.94 q2 q3 . positive indication heuristic
algorithms suggests may scale well higher uncertainty levels provided
reasonable q value used. examine impact q values original experiments implications deterministic/probabilistic makespan correlation
next section.
emphasized results based correlations deterministic probabilistic makespans randomly generated solutions. addressed
correlations might change high-quality solutions, might considered
appropriate population sample. One technical difficulty
design experiment examine this, ensure sufficiently randomized sample
population good solutions; also, result could depend strongly (rather
arbitrary) particular choice quality cutoff solutions.
Effect q Values. heuristic algorithms requires fixed q value.11
experimented four different values (see Table 2). Table 10 displays significant pairwise differences among q values heuristic measured randomized
paired-t tests (Cohen, 1995) p 0.005. observed, almost
significant differences low levels uncertainty (0.1 0.5) smallest problem
set. higher levels uncertainty larger problems, using q0 never better
using one higher q values many cases, q0 results worst mean makespan.
Among q-values, majority problem sets algorithms
significant differences. given algorithm, never case lower q value leads
significantly better results higher q value.
correlation results Table 9 provide explanation differences.
10 10 problems, performance q0 algorithms competitive
large difference correlations deterministic probabilistic solutions (i.e.,
uncertainty levels 0.1 0.5). uncertainty level 1, significant
reduction correlation coefficient q0 corresponding reduction mean
normalized probabilistic makespans found algorithms using q0 .
6.3 Summary
results experiments summarized follows:
principled use simulation (B&B-N) useful small problems.
simulation time major component run-time resulting little
exploration search space.
Algorithm B&B-DQ-L, based idea iteratively reducing parameter determines validity lower bound, results equal performance small prob11. addressing behavior B&B-DQ-L, q descends run algorithm.
examining algorithms fixed q values.

221

fiBeck & Wilson

Problem
Size
44

66

10 10

20 20

Unc.
Level
0.1
0.5
1

0.1
0.5
1

0.1
0.5
1

0.1
0.5
1


B&B
TBS
I-BS
q2 < {q1 , q3 } < q0
q2 < {q0 , q1 }
{q1 , q2 , q3 } < q0
{q1 , q2 , q3 } < q0
{q1 , q2 , q3 } < q0
{q1 , q2 , q3 } < q0
{q1 , q2 } < q0
{q2 , q3 } < q0
q2 < q 1
q2 < q1 < q0
{q2 , q3 } < q0
q3 < q 0

Tabu
TBS
I-BS
q 2 < q1
{q1 , q2 , q3 } < q0
{q1 , q2 , q3 } < q0
q1 < q 0
{q1 , q3 } < q0
{q2 , q3 } < q0
q1 < q 0
{q1 , q2 , q3 } < q0
q 2 < q0
{q1 , q2 , q3 } < q0 {q1 , q2 , q3 } < q0
{q1 , q2 , q3 } < q0

{q1 , q2 , q3 } < q0

Table 10: results pair-wise statistical tests algorithm problem set.
notation < b indicates algorithm using q = achieved significantly
better solution (i.e., lower probabilistic makespan) used q = b. -
indicates significant differences. statistical tests randomized paired-t
tests (Cohen, 1995) p 0.005.

lems much better performance larger problems compared B&B-N.
work needed understand behavior algorithm, however preliminary evidence indicates able find good solutions quickly current
application domain.
series heuristic algorithms proposed based using deterministic makespan
filter solutions would simulated. demonstrated performance algorithms depends ability find good deterministic
makespans correlation quality deterministic probabilistic solutions. shown even problems quite high uncertainty
level, deterministic problems constructed lead strong deterministic/probabilistic makespan correlation.
Central success heuristic algorithms use q value governed
extent duration uncertainty represented durations activities
deterministic problems. shown incorporation uncertainty
data leads stronger correlation deterministic probabilistic makespans
corresponding ability find better probabilistic makespans.
222

fiProactive Algorithms JSP

7. Extensions Future Work
section, look three kinds extensions work. First, show
theoretical framework fact applies far general probabilistic scheduling problems
job shop scheduling. Section 7.2, discuss ways algorithms
probabilistic JSP presented paper might improved. Finally, discuss
possibility developing central idea B&B-DQ-L algorithm solving approach
general constraint optimization problems.
7.1 Generalization Scheduling Problems
results paper derived important case job shop scheduling
problems. fact, valid much broader class scheduling problems, including
resource-constrained project scheduling problems common form (e.g., probabilistic
version deterministic problems studied work Laborie, 2005). section,
describe extend framework approaches.
approach relies fact job shop scheduling problem, one focus
orderings activities, rather directly assignments start times activities;
specifically, definition minimum makespan based orderings equivalent
one based start time assignments; equivalence holds much generally.
First, 7.1.1, give basic definitions properties immediate extensions defined Section 2. Then, 7.1.2, characterize class scheduling
problems properties require, use logical expression represent
constraints problem. 7.1.3 give key result relating schedule-based
minimum makespan ordering-based minimum makespan. Section 7.1.4 discusses
extended class probabilistic scheduling problems, Section 7.1.5 considers different
optimization functions.
7.1.1 Schedules, Orderings Makespans
Section 2, given set activities, activity Ai associated positive duration di (for deterministic case). schedule (for A) defined
function set activities set time-points (which non-negative
numbers), defining activity starts. Let Z schedule. makespan make(Z)
schedule Z defined time last activity completed, i.e.,
maxAi (Z(Ai ) + di ). say Z orders Ai Aj Aj starts earlier
Ai ends, i.e., Z(Ai ) + di Z(Aj ).
essential aspect job shop problems approach one focus
orderings activities rather schedules; Section 2 use term solution
ordering satisfies constraints given JSP. Define ordering (on A)
strict partial order A, i.e., irreflexive transitive relation set activities.
Hence, ordering s, Ai A, (Ai , Ai )
/ s, (Ai , Aj ) (Aj , Ak ) s,
(Ai , Ak ) s. (Ai , Aj ) s, say orders Ai Aj ; say
Ai predecessor Aj . path (or s-path) sequence activities
Ai precedes Aj sequence, orders Ai Aj . length len() path
(in ordering) defined sum durations activities path,
223

fiBeck & Wilson

P
i.e., Ai di . makespan, make(s), ordering defined length
longest s-path. s-path said critical s-path length equal
makespan ordering s, i.e., one longest s-paths.
schedule associated ordering. schedule Z define ordering sol(Z)
follows: sol(Z) orders activity Ai Aj Z orders Ai Aj .
Conversely, ordering one define non-delay schedule, optimal
among schedules compatible ordering, starting activity soon
predecessors finish. Let ordering. inductively define schedule Z = sched(s)
follows: Ai predecessor, start Ai time 0, i.e., Z(Ai ) = 0. Otherwise,
set Z(Ai ) = maxAj pred(Ai ) (Z(Aj ) + dj ), pred(Ai ) set predecessors Ai .
fact acyclic guarantees defines schedule. Section 2.1,
following two important properties. first states makespan ordering
equal makespan associated schedule. second states makespan
schedule better makespan associated ordering.
Proposition 5
(i) ordering s, make(sched(s)) = make(s).
(ii) schedule Z, make(sol(Z)) make(Z).
proof straight-forward. follows easily induction schedule Z
respects precedence constraints expressed ordering s, last activity
s-path end earlier Z length path; applying critical path
implies (ii) make(sol(Z)) make(Z), implies half (i): make(sched(s)) make(s).
working backwards activity finishes last sched(s), choosing immediate
predecessor stage, one generates (in reverse order) path whose length equal
make(sched(s)), hence showing make(sched(s)) make(s), proving (i).
7.1.2 Positive Precedence Expressions
define class scheduling problems, using call positive precedence expressions (PPEs) represent constraints. scheduling problems assumes
preemption (so activities cannot interrupted started) use
makespan cost function.
activities Ai Aj , expression before(i, j) interpreted constraint (on
possible schedules) activity Aj starts earlier end activity Ai .
expressions called primitive precedence expressions. positive precedence expression
defined logical formula built primitive precedence expressions, conjunctions
disjunctions. (The term positive used since involve negations.) Formally,
set E positive precedence expressions (over A) defined smallest set
(a) E contains before(i, j) Ai Aj A, (b) E,
( ) ( ) E.
Positive precedence expressions interpreted constraining schedules A.
Let E PPE let Z schedule. define Z satisfies recursively
follows:
224

fiProactive Algorithms JSP

Z satisfies primitive precedence expression before(i, j) Z orders
Aj , i.e., Z(Ai ) + di Z(Aj );
Z satisfies conjunction two constraint expressions satisfies
them;
Z satisfies disjunction two constraint expressions satisfies
least one them.
Similarly, ordering positive precedence expression recursively define
satisfies obvious way: satisfies before(i, j) orders
Aj . Ordering satisfies ( ) satisfies . Ordering satisfies
( ) satisfies either .
Positive precedence expressions powerful enough represent constraints
job shop scheduling problem, resource-constrained project scheduling problem.
JSPs Positive Precedence Expressions. Resource constraints job shop scheduling problem give rise disjunctions primitive precedence expressions: pair
activities Ai Aj require resource, expression before(i, j) before(j, i)
expresses Ai Aj overlap (one precedes other).
ordering activities job expressed terms primitive expressions: before(i, j)
Ai precedes Aj within job. Hence, constraints job shop problem
expressed positive precedence expression conjunctive normal form, i.e., conjunction
disjunctions primitive precedence expressions.
RCPSPs PPEs. constraints resource-constrained project scheduling problem
(RCPSP) (Pinedo, 2003; Brucker et al., 1999; Laborie & Ghallab, 1995; Laborie, 2005)
expressed positive precedence expression conjunctive normal form.
RCPSP, precedence constraints activities, expressed
primitive precedence expression; let conjunction these. RCPSP,
set resources, positive capacity. Associated activity
resource r rate usage Ai (r) resource r activity Ai . following
resource constraints schedule: resource r, time-point t, sum
Ai (r) activities Ai progress (i.e., started
yet ended) must exceed capacity resource r.
Define forbidden set (or conflict set) set activities whose total usage
resource exceeds capacity resource. Let F set forbidden sets. (If
wished, could delete F set superset set F;
could delete set H contains elements Ai Aj Ai precedes Aj
according .) resource constraints expressed equivalently as: H F,
exists time every activity H progress. holds
H F, exist two activities H overlap (since pairs
activities H overlap activities H progress latest start time
activities H), i.e., exists Ai , Aj H before(i, j). Hence, schedule satisfies
resource constraints satisfies positive precedence expression defined
225

fiBeck & Wilson


^

HF

_

before(i, j).

Ai ,Aj H
i6=j

Therefore, expression ( ) represents RCPSP, i.e., schedule satisfies constraints
RCPSP satisfies ( ).
Another class scheduling problems, represented positive
precedence expression, class based AND/OR precedence constraints (Gillies &
Liu, 1995; Mohring, Skutella, & Stork, 2004).
7.1.3 Solutions Minimum Makespan
fixed positive precedence expression A, say schedule Z valid
satisfies . say ordering solution satisfies . ordering satisfies
before(i, j), then, construction, sched(s) satisfies before(i, j). follows immediately
schedule Z satisfies before(i, j) sol(Z) satisfies before(i, j). following
result proved easily induction number connectives .
Lemma 2 PPE A, solution, sched(s) valid schedule.
Z valid schedule, sol(Z) solution.
minimum makespan (for ) defined infimum makespan valid
schedules, i.e., infimum make(Z) valid schedules Z. minimum solution
makespan defined minimum makespan solutions, i.e., minimum
make(s) solutions s. following key result links schedulebased definition minimum makespan solution-based definition. follows
Proposition 5 Lemma 2, since solution valid schedule (i.e., sched(s))
value makespan, valid schedule Z solution (i.e.,
sol(Z)) least good value makespan.
Proposition 6 Let positive precedence expression A. minimum
makespan equal minimum solution makespan.
7.1.4 Probabilistic Scheduling Problems based PPEs
probabilistic versions scheduling problems defined way
JSPs. duration activity Ai random variable. positive precedence
expression used represent constraints.
definitions Sections 2 4 immediately extended much
general setting. results paper still hold, exactly proofs.
particular, probabilistic problem one associates corresponding deterministic
problem way; lower bound results Section 4.2 based longest
path characterization makespan; Monte Carlo approach (or least usefulness)
relies fact makespan solution equal makespan associated
schedule. Furthermore, algorithms Section 5 extend, given one method
solving corresponding deterministic problem.
226

fiProactive Algorithms JSP

ordering-based policies use (based fixing partial ordering activities,
irrespective sampled values durations) known Earliest Start policies
(Radermacher, 1985). policies studied RCPSPs (see e.g.,
Stork, 2000, however aim work minimize expected makespan, whereas
attempting minimize -makespan).
7.1.5 Different Optimization Functions
approach evaluating comparing solutions based use Monte
Carlo simulation generate sample distribution, techniques quite general.
Much work paper generalizes immediately regular cost functions, regular means function monotonic sense increasing
end activity schedule decrease cost. regular function based
efficiently computable measurement sample distributions accommodated.
example, could easily adapt situations probability extreme solutions
important basing optimization function maximum sampled makespan. Conversely, could use measures tightness makespan distribution situations
minimizing variance measure accuracy schedule important. Furthermore, weighted combinations functions (e.g., -makespan plus measure
distribution tightness) could easily incorporated.
modify approach account ways comparing solutions
based sample distributions. example, could perform t-tests using sample
distributions determine one solution significantly lower expected makespan.
7.2 Toward Better Algorithms Probabilistic JSPs
two directions future work algorithms presented paper. First,
B&B-N could improved make use deterministic techniques and/or incorporate probabilistic reasoning existing deterministic techniques. example, number
deterministic lower bound formulations PERT networks exist operations research literature (Ludwig, Mohring, & Stork, 2001) may used evaluate partial
solutions. Similarly, perhaps dominance rules presented Daniels Carrillo (1997)
one-machine -robustness problem generalized multiple resources. Another
approach improving B&B-N performance incorporate explicit reasoning
probability distributions standard constraint propagation techniques. Techniques
longest path calculations edge-finding make inferences based propagation
minimum maximum values temporal variables. believe many
techniques adapted reason probabilistic intervals; related work
done, example, simple temporal networks uncertainty (Morris, Muscettola, &
Vidal, 2001; Tsamardinos, 2002).
second direction future work improvement heuristic algorithms.
key advantage algorithms make use deterministic techniques
scheduling: transforming probabilistic problems deterministic problems, bring
significant set existing tools bear problem. developments approach include adaptively changing q-values search order find lead
solutions better values probabilistic makespan (D (s)). deeper understanding
227

fiBeck & Wilson

relationship good deterministic solutions good probabilistic solutions,
building work here, necessary pursue work principled fashion.
course, proactive techniques sufficient. practice, schedules dynamic
need adapted new jobs arrive existing jobs canceled. execution time,
reactive component necessary deal unexpected (or sufficiently unlikely) disruptions
that, nonetheless, occur. complete solution scheduling uncertainty needs
incorporate elements reason uncertainty different levels granularity
different time pressures. See work Bidot, Vidal, Laborie Beck (2007)
recent work direction.
7.3 Exploiting Unsound Lower Bounds Constraint Programming
B&B-DQ-L algorithm may represent problem-solving approach applied
beyond current application area. abstract away probabilistic JSP application,
central idea B&B-DQ-L exploit unsound lower bound (over)constrain
search run subsequent searches gradually relaxed unsound lower bound.
approach may play strengths constraint programming: searching within
highly constrained spaces.
example, assignment problem (AP) well-known lower bound traveling
salesman problem (TSP) used cost-based constraint literature
(Focacci, Lodi, & Milano, 2002; Rousseau, Gendreau, Pesant, & Focacci, 2004). Given
TSP, P , let AP (P, q) corresponding assignment problem travel distances
multiplied q. is, let dij distance cities j P let d0ij
distance cities j AP (P, q). d0ij = dij q q 1. approach
similar B&B-DQ-L algorithm applied solve TSP.
would interesting investigate approach compares traditional
optimization approach constraint programming. may particularly useful applications evaluation partial solutions expensive exists
parameterizable, inexpensive lower bound.

8. Conclusion
paper, addressed job shop scheduling durations activities
independent random variables. theoretical framework created formally define
problem prove soundness two algorithm components: Monte Carlo simulation
find upper bounds probabilistic makespan solution partial solution;
carefully defined deterministic JSP whose optimal makespan lower bound
probabilistic makespan corresponding probabilistic JSP.
used two components together either constraint programming
tabu search define number algorithms solve probabilistic JSPs. introduced
three solution approaches: branch-and-bound technique using Monte Carlo simulation
evaluate partial solutions; iterative deterministic search using Monte Carlo simulation
evaluate solutions series increasingly less constrained problems based
parameterizable lower bound; number deterministic filtering algorithms
generate sequence solutions deterministic JSP, simulated
using Monte Carlo simulation.
228

fiProactive Algorithms JSP

empirical evaluation demonstrated branch-and-bound technique
able find approximately optimal solutions small problem instances. iterative
deterministic search performs well as, better than, branch-and-bound approach
problem sizes. However, medium large instances, deterministic filtering
techniques perform much strongly providing optimality guarantees.
experimentation demonstrated techniques using deterministic methods,
correlation deterministic makespan probabilistic makespan key factor
algorithm performance: taking account variance duration deterministic
problem led strong correlations good algorithmic performance.
Proactive scheduling techniques seek incorporate models uncertainty offline, predictive schedule. goal techniques increase robustness
schedules produced. important schedule typically generated
executed isolation. decisions deliver raw materials
schedule up- down-stream factories affected individual schedule. Indeed,
schedule seen locus competing constraints across company supply
chain (Fox, 1983). Differences predictive schedule execution
significant source disruption leading cascading delays across widely separated entities.
ability, therefore, develop schedules robust uncertainty important.
paper represents step direction.

Acknowledgments
work received support Science Foundation Ireland grants 00/PI.1/C075
05/IN/I886, Natural Sciences Engineering Research Council Canada,
ILOG, SA. authors would thank Daria Terekhov Radoslaw Szymanek
comments previous versions paper. Preliminary versions work reported
paper published Beck Wilson (2004, 2005).

References
Beck, J. C. (1999). Texture measurements basis heuristic commitment techniques
constraint-directed scheduling. Ph.D. thesis, University Toronto.
Beck, J. C., & Fox, M. S. (2000). Dynamic problem structure analysis basis
constraint-directed scheduling heuristics. Artificial Intelligence, 117 (1), 3181.
Beck, J. C., & Wilson, N. (2004). Job shop scheduling probabilistic durations.
Proceedings Sixteenth European Conference Artificial Intelligence (ECAI04),
pp. 652656.
Beck, J. C., & Wilson, N. (2005). Proactive algorithms scheduling probabilistic durations. Proceedings Nineteenth International Joint Conference Artificial
Intelligence (IJCAI05), pp. 12011206.
Bidot, J. (2005). General Framework Integrating Techniques Scheduling Uncertainty. Ph.D. thesis, Ecole Nationale dIngeieurs de Tarbes.
229

fiBeck & Wilson

Bidot, J., Vidal, T., Laborie, P., & Beck, J. C. (2007). general framework scheduling
stochastic environment. Proceedings Twentieth International Joint
Conference Artificial Intelligence (IJCAI07), pp. 5661.
Blazewicz, J., Domschke, W., & Pesch, E. (1996). job shop scheduling problem: Conventional new solution techniques. European Journal Operational Research,
93 (1), 133.
Boutilier, C., Dean, T., & Hanks, S. (1999). Decision-theoretic planning: Structural assumptions computational leverage. Journal Artificial Intelligence Research,
11, 194.
Brucker, P., Drexl, A., Mohring, R., Neumann, K., & Pesch, E. (1999). Resource-constrained
project scheduling: Notation, classification, models methods. European Journal
Operational Research, 112, 341.
Burns, A., Punnekkat, S., Littlewood, B., & Wright, D. (1997). Probabilistic guarantees fault-tolerant real-time systems. Tech. rep. DeVa TR No. 44, Design Validation, Esprit Long Term Research Project No. 20072. Available
http://www.fcul.research.ec.org/deva.
Burt, J. M., & Garman, M. B. (1970). Monte Carlo techniques stochastic network analysis. Proceedings Fourth Annual Conference Applications Simulation,
pp. 146153.
Cohen, P. R. (1995). Empirical Methods Artificial Intelligence. MIT Press, Cambridge, Mass.
Daniels, R., & Carrillo, J. (1997). -robust scheduling single-machine systems
uncertain processing times. IIE Transactions, 29, 977985.
Davenport, A. J., Gefflot, C., & Beck, J. C. (2001). Slack-based techniques robust
schedules. Proceedings Sixth European Conference Planning (ECP-2001).
Davenport, A., & Beck, J. C. (2000). survey techniques scheduling uncertainty.
Tech. rep.. Available at: http://www.tidel.mie.utoronto.ca/publications.php.
Drummond, M., Bresina, J., & Swanson, K. (1994). Just-in-case scheduling. Proceedings
Twelfth National Conference Artificial Intelligence (AAAI-94), pp. 1098
1104, Menlo Park, CA. AAAI Press/MIT Press.
Feller, W. (1968). Introduction Probability Theory Applications (Third edition). John Wiley Sons, New York, London.
Focacci, F., Lodi, A., & Milano, M. (2002). hybrid exact algorithm TSPTW.
INFORMS Journal Computing, 14 (4), 403417.
Fox, M. S. (1983). Constraint-Directed Search: Case Study Job-Shop Scheduling. Ph.D.
thesis, Carnegie Mellon University, Intelligent Systems Laboratory, Robotics Institute, Pittsburgh, PA. CMU-RI-TR-85-7.
Gao, H. (1995). Building robust schedules using temporal protectionan empirical study
constraint based scheduling machine failure uncertainty. Masters thesis,
Department Industrial Engineering, University Toronto.
230

fiProactive Algorithms JSP

Garey, M. R., & Johnson, D. S. (1979). Computers Intractability: Guide Theory
NP-Completeness. W.H. Freeman Company, New York.
Ghosh, S. (1996). Guaranteeing fault tolerance scheduling real-time systems.
Ph.D. thesis, University Pittsburgh.
Ghosh, S., Melhem, R., & Mosse, D. (1995). Enhancing real-time schedules tolerate
transient faults. Real-Time Systems Symposium.
Gillies, D. W., & Liu, J. W.-S. (1995). Scheduling tasks AND/OR precedence constraints. SIAM J. Comput., 24, 797810.
Hagstrom, J. N. (1988). Computational complexity PERT problems. Networks, 18,
139147.
Herroelen, W., & Leus, R. (2005). Project scheduling uncertainty: Survey research
potentials. European Journal Operational Research, 165 (2), 289306.
Laborie, P. (2003). Algorithms propagating resource constraints AI planning
scheduling: Existing approaches new results. Artificial Intelligence, 143, 151188.
Laborie, P. (2005). Complete MCS-Based Search: Application Resource-Constrained
Project Scheduling. Proceedings Nineteenth International Joint Conference
Artificial Intelligence (IJCAI05), pp. 181186.
Laborie, P., & Ghallab, M. (1995). Planning sharable resource constraints. Proceedings Fourteenth International Joint Conference Artificial Intelligence
(IJCAI95).
Le Pape, C., Couronne, P., Vergamini, D., & Gosselin, V. (1994). Time-versus-capacity
compromises project scheduling. Proceedings Thirteenth Workshop
UK Planning Special Interest Group.
Leon, V. J., Wu, S. D., & Storer, R. H. (1994). Robustness measures robust scheduling
job shop. IIE Transactions, 26 (5), 3243.
Ludwig, A., Mohring, R., & Stork, F. (2001). computational study bounding
makespan distribution stochastic project networks. Annals Operations Research,
102, 4964.
Meuleau, N., Hauskrecht, M., Kim, K., Peshkin, L., Kaelbling, L., Dean, T., & Boutilier, C.
(1998). Solving large weakly coupled markov decision processes. Proceedings
Fifteenth National Conference Artificial Intelligence (AAAI-98).
Mohring, R., Skutella, M., & Stork, F. (2004). Scheduling AND/OR precedence constraints. SIAM J. Comput, 33 (2), 393415.
Morris, P., Muscettola, N., & Vidal, T. (2001). Dynamic control plans temporal
uncertainty. Proceedings Seventeenth International Joint Conference
Artificial Intelligence (IJCAI-01).
Nowicki, E., & Smutnicki, C. (1996). fast taboo search algorithm job shop problem.
Management Science, 42 (6), 797813.
Nuijten, W. P. M. (1994). Time resource constrained scheduling: constraint satisfaction approach. Ph.D. thesis, Department Mathematics Computing Science,
Eindhoven University Technology.
231

fiBeck & Wilson

Pinedo, M. (2003). Scheduling: Theory, Algorithms, Systems (2nd edition). PrenticeHall.
R Development Core Team (2004). R: language environment statistical computing.
R Foundation Statistical Computing, Vienna, Austria. ISBN 3-900051-07-0.
Radermacher, F. J. (1985). Scheduling project networks. Annals Operations Research,
4, 227252.
Rousseau, L., Gendreau, M., Pesant, G., & Focacci, F. (2004). Solving VRPTWs
constraint programming based column generation. Annals Operations Research,
130, 190216.
Stork, F. (2000). Branch-and-bound algorithms stochastic resource-constrained project
scheduling. Tech. rep. 702/2000, Technische Universitat Berlin, Department Mathematics.
Tsamardinos, I. (2002). probabilistic approach robust execution temporal plans
uncertainty. Methods Applications Artificial Intelligence: Proceedings
Second Hellenic Conference Artificial Intelligence, Vol. 2308 Lecture Notes
Artificial Intelligence, pp. 97108.
Watson, J.-P., Barbulescu, L., Whitley, L., & Howe, A. (2002). Contrasting structured
random permutation flow-shop scheduling problems: search-space topology
algorithm performance. INFORMS Journal Computing, 14 (1).
Wilson, N. (2000). Algorithms Dempster-Shafer Theory. In: Kohlas, J., Moral, S.,
(eds.) Algorithms Uncertainty Defeasible Reasoning, Volume 5, Handbook
Defeasible Reasoning. Kluwer Academic Publishers.
Wurman, P., & Wellman, M. (1996). Optimal factory scheduling using stochastic dominance
A*. Proceedings Twelfth Conference Uncertainty Artificial Intelligence
(UAI-96).

232


