Journal Artificial Intelligence Research 28 (2007) 431-451

Submitted 07/06; published 04/07

Discovering Classes Strongly Equivalent Logic Programs
Fangzhen Lin

flin@cs.ust.hk

Department Computer Science Engineering
Hong Kong University Science Technology
Clear Water Bay, Kowloon, Hong Kong

Yin Chen

gzchenyin@gmail.com

Department Computer Science
South China Normal University
Guangzhou, P.R. China

Abstract
paper apply computer-aided theorem discovery technique discover theorems strongly equivalent logic programs answer set semantics. discovered theorems capture new classes strongly equivalent logic programs lead
new program simplification rules preserve strong equivalence. Specifically,
help computers, discovered exact conditions capture strong equivalence
rule empty set, two rules, two rules one two
rules, two rules another rule, three rules two three
rules.

1. Introduction
paper apply computer-aided theorem discovery technique discover theorems
strongly equivalent logic programs answer set semantics. discovered
theorems capture new classes strongly equivalent logic programs lead new
program simplification rules preserve strong equivalence.
Theorem discovery highly creative human process. Generally speaking,
divide two steps: (i) conjecture formulation, (ii) conjecture verification,
computers help two steps. instance, machine learning tools
used first step, i.e. coming reasonable conjectures, automated
deduction tools used second step, i.e. verifying correctness
conjectures.
theorem discovery may make use learning, two tasks fundamentally different. Theorem discovery starts theory, aims finding interesting
consequences theory, learning mostly induction, i.e. starts
examples/consequences, aims finding theory would explain given examples/consequences.
Using computers discover theorems old aspiration.
success stories. instance, (Lenat, 1979) reported able come
interesting concepts theorems number theory, remarkable systems
described Petkovsek, Wilf, Zeilberger (1996) discover many identities, especially
hypergeometric identities involving sums binomial coefficients important
analyses algorithms. Yet another example interesting theorems discovered
c
2007
AI Access Foundation. rights reserved.

fiLin & Chen

almost fully automatically recent work Lin (2004) discovering state invariants
planning domains. Lin showed ways classify many state constraints
useful planning according syntactic properties, enumerate easily
many domains. Furthermore, many constraints whether invariants
checked automatically. result, system described Lin (2004) discover
many common constraints planning domains, logistics domain, could even
discover set complete state invariants.
Following line research, paper, consider problem discovering
classes strongly equivalent sets logic program rules answer set semantics.
noted Lifschitz, Pearce, Valverde (2001), two sets rules strongly equivalent,
replace one logic program without changing semantics
program. Thus identifying strongly equivalent sets logic program rules useful
exercise may applications program simplification.
paper organized follows. next section, briefly review basic
concepts logic programming answer set semantics. section 3 state
precise terms type theorems want discover. section 4 prove
general theorems help us prove theorems, section 5, describe
theorems discovered. discuss application logic program
simplification section 6, finally conclude paper section 7.

2. Answer Set Programming
Traditional logic programming systems Prolog solve problems query answering.
user encodes knowledge domain set rules, solves problem issuing
queries set rules. contrast, Answer Set Programming (ASP) (Niemela, 1999;
Lifschitz, 1999; Marek & Truszczynski, 1999) constraint-based programming paradigm.
based logic programming answer set semantics (Gelfond & Lifschitz, 1988,
1991). solve problem, user encodes domain knowledge logic program
way answer sets program correspond solutions original
problem. Compared constraint-based programming paradigms, ASP allows natural
encodings recursive relations, built-in facilities default reasoning. Several ASP
solvers developed (Niemela, Simons, & Syrjanen, 2000; Leone, Pfeifer, Faber,
Eiter, Gottlob, Perri, & Scarcello, 2006; Lin & Zhao, 2004; Lierler & Maratea, 2004).
date, ASP used space shuttle planning (Nogueira, Balduccini, Gelfond, Watson,
& Barry, 2001), evolutional linguistics (Erdem, Lifschitz, Nakhleh, & Ringe, 2003),
others. following, briefly review basic notions ASP.
Let L propositional language, i.e. set atoms. paper shall consider
logic programs rules following form:
h1 ; ; hk p1 , , pm , pm+1 , , pn

(1)

hi pi atoms L. logic program default negation (not ),
constraints (when k = 0), disjunctions head rules. following, r
rule form, write Hdr denote set {h1 , ..., hk }, Psr set {p1 , ..., pm },
Ngr set {pm+1 , ..., pn }. Thus rule r written Hdr Psr , Ngr .
semantics programs given answer sets (Gelfond & Lifschitz, 1991),
432

fiDiscovering Classes Strongly Equivalent Logic Programs

defined fixed-point operator known Gelfond-Lifschitz
transformation. Let X subset L, P logic program. Gelfond-Lifschitz
transformation P X, written P X , set rules obtained P according
following two rules:
1. rule form (1) P , pi X + 1 n, delete
rule.
2. Delete literals form pi bodies remaining rules.
instance, P set following rules:
a; b
c
P {a} {a; b }, P {b} {(a; b ), (c )}.
Clearly, X P , P X set rules operator.
set X answer set P X minimal set atoms satisfies every rule
P X , X satisfies rule form
h 1 ; ; h k p1 , , p
1 k, hi X whenever {p1 , ..., pm } X. instance,
program, {a} {b, c} answer sets, answer sets
program.
Two logic programs P1 P2 said equivalent answer sets,
strongly equivalent (Lifschitz et al., 2001) (under language L), written P1 'se P2 ,
logic program P L, P P1 P P2 equivalent (thus write P1 6'se P2
P1 P2 strongly equivalent). example, {a b} {a c}
equivalent, strongly equivalent. shown {a a} 'se { a}.
abstract, say rule r strongly equivalent another rule r0 , written
r 'se r0 , {r} 'se {r0 }, two rules r1 r2 strongly equivalent rule r, written
{r1 , r2 } 'se r, {r1 , r2 } 'se {r}, on.
notion strong equivalence important ASP several reasons. First all,
helps us understand answer set semantics. instance, Turner (2003) showed
disjunctive rule (a; b ) strongly equivalent set normal rules. implies
cannot modular translation disjunctive logic programs normal logic
programs. However,
{(a; b ), ( a, b)}
strongly equivalent
{(a b), (b a), ( a, b)}.
means constraint ( a, b), disjunctive rule (a; b ) replaced
two rules without disjunction. Secondly, mentioned introduction, P1
P2 strongly equivalent, interchangeable regardless occur.
Thus large repertoire pairs strongly equivalent logic programs, could
433

fiLin & Chen

use transform given program one suitable need hand.
particular, could help us simplify program purpose computing answer
sets. shall see, discovered theorems contribute significantly repertoire.
Lifschitz et al. (2001) showed checking strong equivalence two logic
programs done logic here-and-there, three-valued non-classical logic
somewhere classical logic intuitionistic logic. Lin (2002) provided mapping
logic programs propositional theories showed two logic programs
strongly equivalent iff corresponding theories propositional logic equivalent.
result used generating example pairs strongly equivalent logic
programs, verifying conjecture. repeat here.
Let P1 P2 two finite logic programs, L set atoms them.
Theorem 1 (Lin, 2002) P1 'se P2 iff propositional logic, following sentence valid:
^
^
^
p p0 ) [
(
(r)
(r)],
(2)
pL

rP1

rP2

p L, p0 new atom, rule r form (1), (r)
conjunction following two sentences:
p1 pm p0m+1 p0n h1 hk ,

(3)

p01

(4)



p0m



p0m+1



p0n



h01



h0k .

Notice = n = 0, left sides implications (3) (4) considered
true, k = 0, right sides implications (3) (4) considered
f alse.
general checking two sets rules strongly equivalent coNP-complete (c.f.
Turner, 2001; Pearce, Tompits, & Woltran, 2001; Lin, 2002).

3. Problem
mentioned above, one possible use notion strongly equivalent logic programs
program simplification. instance, given logic program, rule r it,
may ask whether deleted without knowing rules P , i.e.
whether {r} strongly equivalent empty set. may ask whether rule r
P deleted one knows another rule r0 already P , i.e. whether {r, r0 }
strongly equivalent {r0 }. general, may ask following k-m-n question:
{r1 , ..., rk , u1 , ..., um } 'se {r1 , ..., rk , v1 , ..., vn }? Thus theorem discovery task come
up, given k-m-n problem, computationally effective condition holds
answer k-m-n question positive.
suppose condition C, suppose
{r1 , ..., rk , u1 , ..., um } 'se {r1 , ..., rk , v1 , ..., vn },
better replace {u1 , ..., um } {v1 , ..., vn } presence r1 , ..., rk purpose
of, say computing answer sets program. One way use result simplify
given program P first choose k rules P , rules it, try find
434

fiDiscovering Classes Strongly Equivalent Logic Programs

n rules condition C holds, replace rules P simpler n
rules.
However, even checking whether C holds would take negligible constant time, using
procedure simplify given logic program practical k, m, n
small k almost number rules given
program, n small. Thus seems us worthwhile solve
k-m-n problem k, m, n small. particular, paper, shall
concentrate 0-1-0 problem (whether rule always deleted), 0-1-1 problem
(whether rule always replaced another one), 1-1-0 problem (in presence
rule, whether another rule deleted), 2-1-0 problem (in presence two
rules, whether rule always deleted), 0-2-1 problem (if pair rules
replaced single rule).
example theorems want discover problems follows:
rule r, r 'se iff (Hdr Ngr ) Psr 6= .

(5)

4. General Theorems
section, prove general theorems help us verify whether assertion
(5) true.
Let L propositional language, i.e. set atoms. L, construct first-order
language FL equality, two unary predicates H1 H2 , three unary predicates Hdr ,
Psr , Ngr logic program rule r L (we assume rule L unique
name), three unary predicates Xi , Yi , Zi positive number i.
Notice used Hdr , Psr , Ngr denote sets atoms previously,
overload unary predicates. Naturally, intended interpretations
unary predicates respective sets.
Definition 1 Given set L atoms, intended model FL one whose domain L,
rule r L, unary predicates Psr , Hdr , Ngr interpreted
corresponding sets atoms, Psr , Hdr , Ngr , respectively.
Conditions rules L, Psr Ngr 6= , expressed special sentences
called properties FL .
Definition 2 sentence FL property n rules constructed equality
predicates Xi , Yi , Zi , 1 n. property n rules true (holds)
sequence P = [r1 , ..., rn ] n rules [P ] true intended model FL , [P ]
obtained replacing Xi Hdri , Yi Psri , Zi Ngri .
Notice since [P ] mention predicates Xi , Yi , Zi , H1 , H2 , true
one intended model, true intended models.
mentioned above, interested capturing strong equivalence
two programs computationally effective condition. specifically,
small k, m, n, interested finding property k + + n rules
sequence k + + n rules, P = [r1 , ..., rk , u1 , ..., um , v1 , ..., vn ],
{r1 , ..., rk , u1 , ..., um } 'se {r1 , ..., rk , v1 , ..., vn } iff true P .
435

(6)

fiLin & Chen

shall prove general theorems help us verify assertion
class formulas .
First all, Theorem 1 reformulated FL follows reading H1 (p) p
holds, H2 (p) p0 holds:
Theorem 2 P1 'se P2 L iff following sentence
^
^
x(H1 (x) H2 (x)) [
(r)
(r)]
rP1

(7)

rP2

true intended models FL , (r) conjunction following two
sentences:
[x(Psr (x) H1 (x)) x(Ngr (x) H2 (x))] x(Hdr (x) H1 (x)),

(8)

[x(Psr (x) H2 (x)) x(Ngr (x) H2 (x))] x(Hdr (x) H2 (x)).

(9)

first order logic, prenex formula form ~x~y B satisfiable,
satisfiable structure n elements, B formula contains quantifiers,
constants, function symbols, n length ~x non-empty, 1 ~x
empty. prove similar result first-order languages intended
models here.
Definition 3 sentence FL extended property n rules constructed
equality predicates Xi , Yi , Zi , 1 n, H1 H2 . extended
property n rules true (holds) sequence P = [r1 , ..., rn ] n rules model
[P ] true , [P ] obtained replacing Xi Hdri , Yi
Psri , Zi Ngri .
Definition 4 following, P = [r1 , ..., rn ] tuple rules L, L0 subset
L, define restriction P L0 [r10 , ..., rn0 ], ri0
Hdri L0 Psri L0 , (Ngri L0 ).
Lemma 1 Let extended property FL n rules, form ~x~y Q,
~x tuple w variables, Q formula quantifiers.
holds sequence P n rules intended model FL , subset
L0 L L0 w atoms (or one atom w = 0), holds
restriction P L0 intended model FL0 .
Proof: Suppose intended model FL |= [P ]. Thus tuple
p~ w (or one w = 0) atoms L |= ~y Q[P ](~x/~
p). let L0 set
0
atoms p~, defined follows:
predicates H1 , H2 , Xi , Yi , Zi , 1, interpreted restriction
interpretation L0 .
rule r L0 , predicates Hdr , Psr , Ngr interpreted
. well-defined r rule L,
436

fiDiscovering Classes Strongly Equivalent Logic Programs

0 intended model FL0 . Let P 0 restriction P L0 . P 0
tuple rules L0 . Since Q quantifiers (and language function symbols),
instantiation ~u ~y L0 , |= Q[P ](~x/~
p)(~y /~u) iff 0 |= Q[P 0 ](~x/~
p)(~y /~u). Since
0
0
|= ~y Q[P ](~x/~
p), |= ~y Q[P ](~x/~
p), Thus 0 |= ~x~y Q[P 0 ].
Using Theorem 2 lemma, show following theorem enable
us automate verification part (6) property prenex
format.
Theorem 3 Without loss generality, suppose n. property k+m+n
rules form ~x~y Q, ~x tuple w variables, Q formula
quantifiers, following two assertions equivalent:
(a) sequence k + + n rules, P = [r1 , ..., rk , u1 , ..., um , v1 , ..., vn ], true
P , {r1 , ..., rk , u1 , ..., um } 'se {r1 , ..., rk , v1 , ..., vn }.
(b) (b.1) n > 0, sequence P = [r1 , ..., rk , u1 , ..., um , v1 , ..., vn ] rules
w + 2(k + m) atoms, true P ,
{r1 , ..., rk , u1 , ..., um } 'se {r1 , ..., rk , v1 , ..., vn }.
(b.2) n = 0, sequence P = [r1 , ..., rk , u1 , ..., um ] rules
K atoms, true P ,
{r1 , ..., rk , u1 , ..., um } 'se {r1 , ..., rk },
K w + 2k w + 2k > 0, K = 1 otherwise.
Proof: (a) (b) obvious. assume (b) true, show (a) holds
well. Suppose first n > 0. Suppose P = [r1 , ..., rk , u1 , ..., um , v1 , ..., vn ] sequence
k + + n rules language L true P ,
{r1 , ..., rk , u1 , ..., um } 6'se {r1 , ..., rk , v1 , ..., vn }.
Thus intended model FL satisfies [P ], intended model FL
satisfies following sentence:
^
^
(x)H1 (x) H2 (x) [
(r)
(r)],
rP1

rP2

P1 = {r1 , ..., rk , u1 , ..., um }, P2 = {r1 , ..., rk , v1 , ..., vn }. noted Definition 2, satisfy [P ]. Thus satisfies following sentence
^
^
^
^
[P ] (x)H1 (x) H2 (x) {[
(r)
(r)] [
(r)
(r)]}, (10)
rP1

rP3

rP2

rP4

P3 = {v1 , ..., vn }, P4 = {u1 , ..., um }.
rule r, extended property (x, y) one rule
mention quantifiers (r) equivalent x, y.[r]. Thus tuple Q
rules,Vthere extended property rules mention quantifiers
rQ (r) equivalent ~y .[Q], ~y tuple 2t variables.
Thus
437

fiLin & Chen

tuple z~1 2(k + m) variables, tuple z~2 variables, extended property 1
k + + n rules quantifiers, whose free variables z~1
z~2 ;
tuple z~3 2(k + n) variables, tuple v~4 variables, extended property 2
k + + n rules quantifiers, whose free variables
z~3 z~4
v~1 , v~2 , v~3 , v~4 common variables them, (10) equivalent
following sentence:
{ x(H1 (x) H2 (x)) (z~1 z~2 1 z~3 z~4 2 )}[P ].
Since assumed n, thus extended property 3 k + + n
rules mention quantifiers function symbols, whose free variables
among z~1 , z~2 , z~4 sentence equivalent following sentence:
( x(H1 (x) H2 (x)) z~1 (z~2 , z~4 )3 )[P ].
given form assumed theorem, tuple z~5 w + 2(k + m)
variables, tuple z~6 variables, extended property k + + n rules
mention quantifiers, whose free variables among z~5 , z~6
sentence equivalent (z~5 )(z~6 )[P ].
Lemma 1, subset L0 L w + 2(k + m) atoms
(z~5 )(z~6 ) holds P 0 , P 0 restriction P L0 .
P 0 = [r10 , ..., rk0 , u01 , ..., u0m , v10 , ..., vn0 ],
mean true P 0 , {r10 , ..., rk0 , u01 , ..., u0m } 6'se {r10 , ..., rk0 , v10 , ..., vn0 }.
shows (b.1), (a).
proof (b.2) (a) exactly except
^
^
[
(r)
(r)]
rP1

rP2

equivalent
[

^

rP2

^

(r)

(r)].

rP1


part (6) often proved help following theorem.
Theorem 4 Let L1 L2 two languages, f function L1 L2 . P1 P2
two programs L1 strongly equivalent, f (P1 ) f (P2 ) two programs
L2 strongly equivalent. f (P ) obtained P replacing
atom p f (p).
Proof: Theorem 1 fact propositional logic, tautology, f
function L1 L2 , f () tautology, f () formula obtained
replacing atom p f (p).
example using theorems section proving assertions form
(6), see Section 5.1.
438

fiDiscovering Classes Strongly Equivalent Logic Programs

5. Computer-Aided Theorem Discovery
Given k-m-n problem, strategy discovering theorems follows:
1. Choose small language L;
2. Generate possible triples
({r1 , ..., rk }, {u1 , ..., um }, {v1 , ..., vn })

(11)

sets rules L {r1 , ..., rk , u1 , ..., um } 'se {r1 , ..., rk , v1 , ..., vn } L;
3. Formulate conjecture k-m-n problem holds language L, i.e.
condition true triple form (11) iff generated Step 2;
4. Verify correctness conjecture general case.
process may iterated. instance, conjecture formulated Step 3 may
fail generalize Step 4, either need formulate new conjecture start
step 1 using larger language.
Ideally, would process automatic. However, difficult automate
Steps 3 4 - number possible patterns need examine order come
good conjecture Step 3 huge, general theorem
enables us automate verification part Step 4. Theorem 3 enables us
automate proof sufficient part assertion (6) class formulas ,
similar result necessary part - shall see below, Theorem 4 helps
lot here, provide automated procedure. Nonetheless, computers play
crucial role steps, following report theorems discovered
using procedure.
5.1 0-1-0 Problem
problem asks given rule strongly equivalent empty set, thus always
deleted program. following experimental result:
Lemma 2 rule r mentions three distinct atoms, r 'se iff
(Hdr Ngr ) Psr 6= .
Using Theorem 4, show following result:
Lemma 3 rule r form (1) r 'se (Hdr Ngr ) Psr 6=
true, rule mentions three atoms.
Proof: Suppose r 'se , Hdr Psr = , Psr Ngr = . Suppose L set atoms
r, a, b, c three new atoms. Let

p Hdr

b
p Psr
f (p) =

c
otherwise
439

fiLin & Chen

Theorem 4, f (r) 'se . construction f ,
Hdf (r) Psf (r) = , Psf (r) Ngf (r) = , f (r) mentions three distinct
atoms.
Theorem 5 (The 0-1-0 problem) Lemma 2 holds general case, i.e. without
restriction number atoms r.
Proof: notice condition Lemma 2, (Hdr Ngr ) Psr 6= , equivalent
following property
x.(X1 (x) Z1 (x)) Y1 (x)
true [r]. Thus part follows Theorem 3 Lemma 2.
part follows Lemma 2 Lemma 3.
part theorem already well-known, first proved Osorio et. al. (2001).
part proved recently Inoue Sakama (2004).
discover anything new case, reassuring methodology works.
notice need consider 0-n-0 problem n > 1,
n, {r1 , ..., rn } strongly equivalent iff 1 n, {ri } strongly
equivalent .
5.2 1-1-0 0-1-1 Problems
1-1-0 problem asks rule always deleted presence another rule,
0-1-1 problem asks rule always replaced another one. first solve
1-1-0 problem, solution 0-1-1 problem come corollary.
following experimental result 1-1-0 problem:
Lemma 4 two rules r1 r2 mentions three atoms, {r1 , r2 }
{r1 } strongly equivalent iff one following two conditions true:
1. r2 'se .
2. Psr1 Psr2 , Ngr1 Ngr2 , Hdr1 Hdr2 Ngr2 .
Lemma 5 two rules r1 r2 {r1 , r2 } 'se {r2 }, none
two conditions Lemma 4 hold, two rules mention three
atoms.
Proof: Suppose two rules r1 , r2 {r1 , r2 } 'se {r2 }, none two
conditions Lemma 4 hold. Let L set atoms r1 , r2 .
Without loss generality, suppose a1 atom makes condition (2)
Lemma 4 false. Psr2 \ {a1 } empty, let a2 atom it. Let L0 = {a1 , a2 , a3 },
a3 new atom, f function L L0 following:

= a1
a1
a2
Psr2 \ {a1 }
f (a) =

a3
otherwise
440

fiDiscovering Classes Strongly Equivalent Logic Programs

clearly, f (r1 ) f (r2 ) mention three distinct atoms, Theorem 4,
{f (r1 ), f (r2 )} 'se f (r1 ).
show none two conditions Lemma 4 hold f (r1 ) f (r2 ) either.
show first f (r2 ) 6'se . Theorem 5, need show
= Psf (r2 ) (Hdf (r2 ) Ngf (r2 ) )
empty. a1 S, construction f , a1 Psr2 (Hdr2 Ngr2 ), contradiction
assumption r2 strongly equivalent . Similarly, a2 S,
construction f , a2 Psr2 (Hdr2 Ngr2 ), contradiction assumption
r2 strongly equivalent . a3 cannot a3 cannot Psf (r2 ) .
Thus must empty.
show case Psf (r1 ) Psf (r2 ) , Ngf (r1 ) Ngf (r2 ) ,
Hdf (r1 ) Hdf (r2 ) Ngf (r2 ) . assumption, a1 atom makes either Psr1 Psr2 ,
Ngr1 Ngr2 , Hdr1 Hdr2 Ngr2 false. three cases here. Suppose a1 makes
Psr1 Psr2 false, i.e. a1 Psr1 a1 6 Psr2 . construction f ,
a1 Psf (r1 ) a1 6 Psf (r2 ) . two cases similar.
Theorem 6 (The 1-1-0 problem) Lemma 4 holds general case, without restriction number atoms r1 r2 .
Proof: condition Lemma 4 equivalent following property
[x.(X2 (x) Z2 (x)) Y2 (x)]
{[x.Y1 (x) Y2 (x)] [x.Z1 (x) Z2 (x)] [x.X1 (x) (X2 (x) Z2 (x))]}
true [r1 , r2 ]. Thus part follows Theorem 3 Lemma 4, noticing
property written x~y .Q required Theorem 3.
part follows Lemma 4 Lemma 5.
Thus rule r2 cannot deleted deleted presence
another rule r1 , must case r2 redundant given r1 : body r2
satisfied, body r1 satisfied well; furthermore, r2 entail
entailed r1 (Hdr1 Hdr2 Ngr2 ).
Osorio et al. (2001) proved {r1 , r2 } 'se r1 either Psr1 Ngr1 = Hdr1 Ngr2
Psr1 Psr2 , Ngr1 Ngr2 , Hdr1 Hdr2 . recently, Eiter et al. (2004) showed
{r1 , r2 } 'se r1 r1 s-implies r2 (Wang & Zhou, 2005), i.e. exists set
Ngr2 Hdr1 Hdr2 A, Ngr1 Ngr2 \ A, Psr1 Psr2 .
one see, special cases part Theorem 6. result
actually general. instance, special cases apply
{(c b, c), ( b, c)}

{c b, c},
one easily show two sets strongly equivalent using theorem.
solution 1-1-0 problem, derive solution 0-1-1 problem.
441

fiLin & Chen

Theorem 7 (The 0-1-1 problem) two rules r1 r2 , r1 'se r2 iff one
following two conditions true:
1. r1 'se r2 'se .
2. Psr1 = Psr2 , Ngr1 = Ngr2 , Hdr1 Ngr1 = Hdr2 Ngr2 .
Proof: Theorem 1, easy see r1 'se r2 iff {r1 , r2 } 'se r1 {r1 , r2 } 'se r2 .

Thus two rules r1 r2 always interchanged either
deleted (strongly equivalent empty set) body,
consequences body true. instance, {a B, a} 'se { B, a}
matter B is, two rules body, body true,
consequence - contradiction. another example,
{a; b a} 'se {b a},
two rules body, and, body true, consequence,
b.
5.3 2-1-0, 0-2-1, 0-2-2 Problems
2-1-0 problem asks rule deleted presence another two rules,
0-2-1 problem asks two rules replaced single rule, 0-2-2 problem asks
two rules replaced another two rules. Similar previous subsection,
solution 0-2-1 0-2-2 problems follow solution 2-1-0 problem.
experiment 2-1-0 problem difficult turned out,
consider language six atoms case. principle, given language L,
every subset L Hd, Ps, Ng rule. Thus size L six,
principle (26 )3 1 = 262, 143 possible rules, 262, 1433 triples them. However,
cut numbers significantly results already proved.
First, consider rules common elements
two sets {Hd, Ps, Ng}: either Hd Ps Ps Ng common element,
Theorem 5, rule deleted; Hd Ng common elements, according
Theorem 7, obtain strongly equivalent rule deleting common elements Hd.
following, call rules canonical, is, rule r canonical
Hdr Psr = Hdr Ngr = Psr Ngr = .
Secondly, consider isomorphic rules: one-to-one onto
function L L maps {r1 , r2 , r3 } {r10 , r20 , r30 }, two sets rules
essentially except names atoms them.
Thus considering canonical rules using certain normal form triples
rules avoids isomorphic rules, ended roughly 120 million triples rules
consider verifying following result, took 10 hours Solaris server
consisting 8 Sun Ultra-SPARC III 900Mhz CPUs 8GB RAM.
details experiment 2-1-0 problem, please refer (Chen, Lin, & Li,
2005).
442

fiDiscovering Classes Strongly Equivalent Logic Programs

Lemma 6 three canonical rules r1 , r2 r3 mention six atoms,
{r1 , r2 , r3 } 'se {r1 , r2 } iff one following three conditions true:
1. {r1 , r3 } 'se r1 .
2. {r2 , r3 } 'se r2 .
3. atom p that:
3.1 p (Psr1 Psr2 ) (Hdr1 Hdr2 Ngr1 Ngr2 )
3.2 Hdri \ {p} Hdr3 Ngr3 Psri \ {p} Psr3 Ngri \ {p} Ngr3 ,
= 1, 2
3.3 p Psr1 Ngr2 , Hdr1 Hdr3 =
3.4 p Psr2 Ngr1 , Hdr2 Hdr3 =
following lemma reason need consider language six atoms
problem.
Lemma 7 three canonical rules r1 ,r2 r3 {r1 , r2 , r3 } 'se {r1 , r2 },
none three conditions Lemma 6 hold, three rules
mention six atoms.
Proof: proof lemma tedious consider several cases. Consider
following statements three canonical rules r1 , r2 , r3 :
(I) {r1 , r2 , r3 } 'se {r1 , r2 }.
(II) {r1 , r3 } 6'se {r1 }, i.e. Psr1 6 Psr3 Ngr1 6 Ngr3 Hdr1 Ngr1 6 Hdr3 Ngr3
(III) {r2 , r3 } 6'se {r2 }, i.e. Psr2 6 Psr3 Ngr2 6 Ngr3 Hdr2 Ngr2 6 Hdr3 Ngr3
(IV) (Psr1 Psr2 ) (Hdr1 Hdr2 Ngr1 Ngr2 ) =
(V) atom p set (Psr1 Psr2 ) (Hdr1 Hdr2 Ngr1 Ngr2 ), another
different atom q one following three conditions true:
1. q Hdr1 Ngr1 q 6 Hdr3 Ngr3 .
2. q Psr1 q 6 Psr3 .
3. q Ngr1 q 6 Ngr3 .
Notice negation condition (3.2) Lemma 6.
(VI) Hdr1 Hdr3 6 Ngr3 , atom p Psr1 Ngr2 = 1, 2,
Hdri \ {p} Hdr3 Ngr3 , Psri \ {p} Psr3 , Ngri \ {p} Ngr3 .
Since r1 r2 symmetric conditions Lemma 6, prove lemma, need
prove following three assertions:
(a) three canonical rules r1 , r2 , r3 satisfy (I)-(IV), three
canonical rules r10 , r20 , r30 mention six atoms, satisfy (I)-(IV) well.
443

fiLin & Chen

(b) three canonical rules r1 , r2 , r3 satisfy (I)-(III)(V),
three canonical rules r10 , r20 , r30 mention six atoms, satisfy (I)-(III)(V)
well.
(c) three canonical rules r1 , r2 , r3 satisfy (I)-(III)(VI),
three canonical rules r10 , r20 , r30 mention six atoms, satisfy (I)(III)(VI) well.
prove three assertions one one.
(a) Let a1 , a2 two atoms make (II) (III) true. (Psr3 (Psr1 Psr2 ))\{a1 , a2 }
empty, let a3 atom it. Psr3 \(Psr1 Psr2 {a1 , a2 }) empty, let a4
atom it. (Psr1 Psr2 )\(Psr3 {a1 , a2 }) empty, let a5 atom it.
Finally let a6 new atom different a1 a5 , L0 = {a1 , a2 , a3 , a4 , a5 , a6 }.
Let f function L L0 defined following:

a1
= a1





= a2

2


a3
(Psr3 (Psr1 Psr2 )) \ {a1 , a2 }
f (a) =

Psr3 \ (Psr1 Psr2 {a1 , a2 })


4



(Psr1 Psr2 ) \ (Psr3 {a1 , a2 })

5
a6
otherwise
1 3, let ri0 follows:
Psri0 = Psf (ri ) , Ngri0 = Ngf (ri ) , Hdri0 = Hdf (ri ) \ Ngf (ri ) .

(12)


1 3, ri0 canonical rule, ri0 'se f (ri ). this,
need show f (ri ) 6'se 1 3. see this, notice
definition f , atoms a1 a2 Psr3 mapped {a3 , a4 },
atoms a1 a2 Hdr3 Ngr3 mapped {a5 , a6 }. Thus
Psf (r3 ) (Hdf (r3 ) Ngf (r3 ) ) = . Theorem 5, f (r3 ) 6'se . f (r1 ) 6'se
f (r2 ) 6'se , (II) (III) hold f (r1 ), f (r2 ), f (r3 ) definition
f .
(I) holds r10 , r20 , r30 . Theorem 4,
{f (r1 ), f (r2 ), f (r3 )} 6'se {f (r1 ), f (r2 )},
1 3, ri0 'se f (ri ).
(II) (III) hold r10 , r20 , r30 . mentioned, definition f , (II)
(III) hold f (r1 ), f (r2 ), f (r3 ).
(IV) holds r10 , r20 , r30 . Again, need show (IV) holds
f (r1 ), f (r2 ), f (r3 ). see this, notice atoms a1 a2
Psr1 Psr2 mapped {a3 , a5 }, atoms a1 a2
Hdr1 Hdr2 Ngr1 Ngr2 mapped {a4 , a6 }.
444

fiDiscovering Classes Strongly Equivalent Logic Programs

(b) let a1 , a2 two atoms make (II) (III) true. Let p, q two witness
atoms (V). P os(r3 ) \ {a1 , a2 , p, q} empty, let a3 atom it. Let a4
new atom, L0 = {a1 , a2 , a3 , a4 , p, q}. Define f follows:

= a1

a1


a2
= a2



p
a=p
f (a) =
q
a=q






Psr3 \ {a1 , a2 , p, q}
3


a4
otherwise
Define ri0 (12) well 1 3.
1 3, ri0 canonical rule, ri0 'se f (ri ). seen
way (a) above.
Theorem 4, {f (r1 ), f (r2 ), f (r3 )} 'se {f (r1 ), f (r2 )}, thus
{r10 , r20 , r30 } 'se {r10 , r20 }.
(I) holds r10 , r20 , r30 .
definition f , (II) (III) hold f (r1 ), f (r2 ), f (r3 ), thus hold
r10 , r20 , r30 well.
definition f , (V) holds f (r1 ), f (r2 ), f (r3 ): atom
p set (Psf (r1 ) Psf (r2 ) ) (Hdf (r1 ) Hdf (r2 ) Ngf (r1 ) Ngf (r2 ) ), another
different atom q one following three conditions true:
1. q Hdf (r1 ) Ngf (r1 ) q 6 Hdf (r3 ) Ngf (r3 ) .
2. q Psf (r1 ) q 6 Psf (r3 ) .
3. q Ngf (r1 ) q 6 Ngf (r3 ) .
(V) holds r10 , r20 , r30 well 1 3,
Psri0 = Psf (ri ) , Ngri0 = Ngf (ri ) , Hdri0 Ngri0 = Hdf (ri ) Ngf (ri ) .
(c) Let a1 , a2 two atoms make (II) (III) true. Let p witness atom
(VI), let q Hdr1 Hdr3 q 6 Ngr3 . P os(r3 ) \ {a1 , a2 , p, q} empty, let
a3 atom it. Let a4 new atom, Let L0 = {a1 , a2 , a3 , a4 , p, q}, Define f
follows:

a1
= a1





= a2

2


p
a=p
f (a) =
q
a=q






Psr3 \ {a1 , a2 , p, q}

3
a4
otherwise
define ri0 (12) well 1 3.
1 3, ri0 canonical rule, ri0 'se f (ri ). seen
way (a) above.
445

fiLin & Chen

Theorem 4, {f (r1 ), f (r2 ), f (r3 )} 'se {f (r1 ), f (r2 )}, thus
{r10 , r20 , r30 } 'se {r10 , r20 }.
(I) holds r10 , r20 , r30 .
definition f , (II) (III) hold f (r1 ), f (r2 ), f (r3 ), thus
hold r10 , r20 , r30 well.
definition f , (VI) holds f (r1 ), f (r2 ), f (r3 ): Hdf (r1 ) Hdf (r3 ) 6
Ngf (r3 ) , atom p Psf (r1 ) Ngf (r2 ) = 1, 2, Hdf (ri ) \
{p} Hdf (r3 ) Ngf (r3 ) , Psf (ri ) \ {p} Psf (r3 ) , Ngf (ri ) \ {p} Ngf (r3 ) . (VI)
holds r10 , r20 , r30 well
Psri0 = Psf (ri ) , Ngri0 = Ngf (ri ) , Hdri0 Hdf (ri ) .

Theorem 8 (The 2-1-0 problem) Lemma 6 holds general case, without restriction number atoms r1 , r2 , r3 .
Proof: assertion r1 , r2 , r3 canonical rules satisfy one three
conditions Lemma 6 equivalent following property
[x.(((X1 (x) Y1 (x))) ((X1 (x) Z1 (x))) ((Y1 (x) Z1 (x))))]
[x.(((X2 (x) Y2 (x))) ((X2 (x) Z2 (x))) ((Y2 (x) Z2 (x))))]
[x.(((X3 (x) Y3 (x))) ((X3 (x) Z3 (x))) ((Y3 (x) Z3 (x))))]
{[(x.Y1 (x) Y3 (x)) (x.Z1 (x) Z3 (x)) (x.X1 (x) (X3 (x) Z3 (x)))]
[(x.Y2 (x) Y3 (x)) (x.Z2 (x) Z3 (x)) (x.X2 (x) (X3 (x) Z3 (x)))]
[x.CON 1(x) CON 2(x) CON 3(x) CON 4(x)]}
true [r1 , r2 , r3 ], CON 1(x) stands
(Y1 (x) Y2 (x)) (X1 (x) X2 (x) Z1 (x) Z2 (x))
CON 2(x)
y.(x 6= y) [(X1 (y) (X3 (y) Z3 (y))) (Y1 (y) Y3 (y)) (Z1 (y) Z3 (y))
(X2 (y) (X3 (y) Z3 (y))) (Y2 (y) Y3 (y)) (Z2 (y) Z3 (y))]
CON 3(x)
Y1 (x) Z2 (x) y.((X1 (y) X3 (y))),
CON 4(x)
Y2 (x) Z1 (x) y.((X2 (y) X3 (y))).
Thus part follows Theorem 3 Lemma 6, noticing
property written x~y .Q required Theorem 3. part follows
Lemma 6 Lemma 7.
446

fiDiscovering Classes Strongly Equivalent Logic Programs

conditions Lemma 6 (Theorem 8) rather complex, reason
difficult automate Step 3 procedure beginning section.
conditions capture possible cases r3 subsumed r1 r2 , difficult
describe concisely words. give examples.
Consider following three rules:
r1 : (a2 a1 )
r2 : (a3 a1 )
r3 : (a3 a2 ).
{r1 , r2 , r3 } 'se {r1 , r2 } condition (4) Lemma 6 holds.
However, change r3 r30 : a2 a3 , P1 = {r1 , r2 , r30 } P2 = {r1 , r2 }
strongly equivalent: one could check condition (4.3) Lemma 6 hold,
indeed, P2 {a1 a2 } unique answer set {a3 }, P1 {a1 a2 } two
answer sets {a3 } {a1 , a2 }.
easy show Theorem 8 a3 a2 subsumed
{(a1 ; a2 ; a3 ), (a2 ; a3 a1 )},
a2 ; a3 subsumed
{(a2 a1 ), (a3 a1 )}.
results have, following theorem yield solution 0-2-1
problem.
Theorem 9 (the 0-2-1 problem) three rules r1 , r2 r3 , {r1 , r2 } {r3 }
strongly equivalent iff following three conditions true:
1. {r1 , r2 , r3 } 'se {r1 , r2 }.
2. {r1 , r3 } 'se {r3 }.
3. {r2 , r3 } 'se {r3 }.
example,
{(a2 a1 , a3 ), (a1 ; a2 a3 )} 'se {a2 a3 }.

{( a2 , a3 ), ( a3 , a2 )} 'se { a3 },

{(a1 a2 , a3 ), (a1 a3 , a2 )} 6'se {a1 a3 }.
Similarly, following theorem
Theorem 10 (the 0-2-2 problem) four rules r1 , r2 , r3 , r4 , {r1 , r2 } {r3 , r4 }
strongly equivalent iff following four conditions true:
447

fiLin & Chen

1. {r1 , r2 , r3 } 'se {r1 , r2 }.
2. {r1 , r2 , r4 } 'se {r1 , r2 }.
3. {r3 , r4 , r1 } 'se {r3 , r4 }.
4. {r3 , r4 , r2 } 'se {r3 , r4 }.

6. Program Simplification
mentioned one possible use notion strongly equivalent logic programs
simplifying logic programs: P 'se Q, Q simpler P ,
replace P program contains Q.
answer set programming systems perform program simplifications. However,
Smodels (Niemela et al., 2000) stand-alone front-end called lparse
used ground simplify given logic program. seems lparse simplifies grounded
logic program computing first well-founded model. not, however, perform
program simplification using notion strong equivalence. instance, lparse-1.0.13,
current version lparse, nothing following set rules:
{(a b), (b a), (a a)}. replace first rule following
program {(a a), (a b), (b a)} constraint a.
unlikely anyone would intentionally writing rules b a, a.
type rules arise result grounding rules variables.
instance, following typical recursive rule used logic programming encoding
Hamiltonian Circuit problem (Niemela, 1999; Marek & Truszczynski, 1999):
reached(X) arc(Y, X), hc(Y, X), reached(Y ).
instantiated graph cyclic arcs arc(a, a), rule generates cyclic rules
form reached(X) hc(X, X), reached(X). Unless deleted explicitly, rules
slow many systems, especially based SAT. instance, none graphs
tested using ASSAT self-cycles consisting arc node (Lin & Zhao,
2004). cycles included, ASSAT would run significantly longer.
thus useful consider using results program simplification.
Indeed, transformation rules deleting contain common elements
heads positive bodies proposed (Brass & Dix, 1999), studied
perspective strong equivalence (Osorio et al., 2001; Eiter et al., 2004). results
add new transformation rules. instance, Theorem 7, delete
elements head rule appear negation-as-failure part rule.
Theorems 6, 8, 9 used define new transformation rules.

7. Concluding Remarks Future Work
Donald Knuth, Forward (Petkovsek et al., 1996), said
Science understand well enough explain computer. Art
everything else do. ...Science advances whenever Art becomes Science.
448

fiDiscovering Classes Strongly Equivalent Logic Programs

state Art advances too, people always leap new
territory understood old.
hope work, one step closer making discovering classes strongly
equivalent logic programs Science.
mentioned methodology used paper similar (Lin,
2004). cases, plausible conjectures generated testing domains
small sizes, general theorems proved aid verification conjectures
general case. However, plausible conjectures generated automatically
(Lin, 2004), done manually here. verifications conjectures
(Lin, 2004) done automatically well, done semi-automatically here.
Overcoming two weaknesses focus future work. Specifically, would
make Step 3 procedure Section 5 automatic, prove theorem similar
Theorem 3 automate proofs parts theorems Theorems 5 8, way Theorem 3 makes proofs parts theorems
automatic. way, would able discover interesting theorems area,
easily!

Acknowledgments
extended abstract paper appeared Proceedings IJCAI2005. thank Yan
Zhang comments earlier version paper. thank anonymous
reviewers useful comments, especially one pointing error
Lemma 4 earlier version paper. work supported part
Research Grants Council Hong Kong Competitive Earmarked Research Grant
HKUST6170/04E. Part second authors work done student Sun
Yat-Sen University, Guangzhou, China, visiting scholar Department Computer
Science Engineering, Hong Kong University Science Technology, Hong Kong.

References
Brass, S., & Dix, J. (1999). Semantics (disjunctive) logic programs based partial
evaluation. Journal Logic Programming, 40 (1), 146.
Chen, Y., Lin, F., & Li, L. (2005). SELP - system studying strong equivalence
logic programs. Proceedings 8th International Conference Logic
Programming Nonmonotonic Reasoning(LPNMR 2005), pp. 442446.
Eiter, T., Fink, M., Tompits, H., & Woltran, S. (2004). Simplifying logic programs
uniform strong equivalence. Proceedings 7th International Conference
Logic Programming Nonmonotonic Reasoning(LPNMR 2004), pp. 8799.
Erdem, E., Lifschitz, V., Nakhleh, L., & Ringe, D. (2003). Reconstructing evolutionary
history indo-european languages using answer set programming. Proceedings
5th International Symposium Practical Aspects Declarative Languages(PADL
2003), pp. 160176.
449

fiLin & Chen

Gelfond, M., & Lifschitz, V. (1988). stable model semantics logic programming.
Proceedings 5th International Conference Symposium Logic Programming(ICLP/SLP), pp. 10701080.
Gelfond, M., & Lifschitz, V. (1991). Classical negation logic programs disjunctive
databases. New Generation Computing, 9 (3/4), 365386.
Inoue, K., & Sakama, C. (2004). Equivalence logic programs updates. Proceedings 9th European Conference Logics Artificial Intelligence(JELIA), pp.
174186.
Lenat, D. B. (1979). automated scientific theory formation: case study using
program. Machine Intelligence 9, pp. 251283. Jean Hayes, Donald Michie, L.
I. Mikulich, eds. Ellis Horwood.
Leone, N., Pfeifer, G., Faber, W., Eiter, T., Gottlob, G., Perri, S., & Scarcello, F. (2006).
DLV system knowledge representation reasoning. ACM Transactions
Computational Logic, 7 (3).
Lierler, Y., & Maratea, M. (2004). Cmodels-2: SAT-based answer set solver enhanced
non-tight programs. Proceedings 7th International Conference Logic
Programming Nonmonotonic Reasoning(LPNMR 2004), pp. 346350.
Lifschitz, V. (1999). Action languages, answer sets planning. Logic Programming
Paradigm: 25-Year Perspective. K.R. Apt, V.W. Marek, M. Truszczynski, D.S.
Warren, eds, Springer-Verlag.
Lifschitz, V., Pearce, D., & Valverde, A. (2001). Strongly equivalent logic programs. ACM
Transactions Computational Logic, 2 (4), 526541.
Lin, F. (2002). Reducing strong equivalence logic programs entailment classical
propositional logic. Proceedings 8th International Conference Principles
Knowledge Representation Reasoning(KR2002), pp. 170176.
Lin, F. (2004). Discovering state invariants. Proceedings 9th International Conference Principles Knowledge Representation Reasoning(KR2004), pp. 536
544.
Lin, F., & Zhao, Y. (2004). ASSAT: computing answer sets logic program sat solvers.
Artificial Intelligence, 157 (1-2), 115137.
Marek, V. W., & Truszczynski, M. (1999). Stable logic programming - alternative logic
programming paradigm. Logic Programming Paradigm: 25-Year Perspective.
K.R. Apt, V.W. Marek, M. Truszczynski, D.S. Warren, eds, Springer-Verlag.
Niemela, I., Simons, P., & Syrjanen, T. (2000).
Smodels: system answer
set programming. Proceedings 8th International Workshop NonMonotonic Reasoning. Breckenridge, Colorado, USA. (CoRR: arXiv:cs.AI/0003033)
http://www.tcs.hut.fi/Software/smodels/.
Niemela, I. (1999). Logic programs stable model semantics constraint programming
paradigm. Annals Mathematics Artificial Intelligence, 25 (3-4), 241273.
450

fiDiscovering Classes Strongly Equivalent Logic Programs

Nogueira, M., Balduccini, M., Gelfond, M., Watson, R., & Barry, M. (2001). A-Prolog
decision support system space shuttle. Proceedings 3rd International
Symposium Practical Aspects Declarative Languages(PADL 2001), pp. 169183.
Osorio, M., Navarro, J. A., & Arrazola, J. (2001). Equivalence answer set programming.
Selected Papers 11th International Workshop Logic Based Program Synthesis
Transformation(LOPSTR 2001), pp. 5775.
Pearce, D., Tompits, H., & Woltran, S. (2001). Encodings equilibrium logic logic
programs nested expressions. Proceedings 10th Portuguese Conference
Artificial Intelligence(EPIA 2001), pp. 306320.
Petkovsek, M., Wilf, H. S., & Zeilberger, D. (1996). = B. Wellesley, Mass. : K Peters.
Turner, H. (2001). Strong equivalence logic programs default theories (made easy).
Proceedings 6th International Conference Logic Programming Nonmonotonic Reasoning(LPNMR 2001), pp. 8192.
Turner, H. (2003). Strong equivalence made easy: nested expressions weight constraints.
Theory Practice Logic Programming, 3 (4-5), 609622.
Wang, K., & Zhou, L. (2005). Comparisons computation well-founded semantics
disjunctive logic programs. ACM Transactions Computational Logic, 6 (2),
295327.

451


