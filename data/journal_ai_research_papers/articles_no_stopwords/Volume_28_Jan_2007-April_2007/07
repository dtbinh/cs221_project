journal artificial intelligence

submitted published

discovering classes strongly equivalent logic programs
fangzhen lin

flin cs ust hk

department computer science engineering
hong kong university science technology
clear water bay kowloon hong kong

yin chen

gzchenyin gmail com

department computer science
south china normal university
guangzhou p r china

abstract
apply computer aided theorem discovery technique discover theorems strongly equivalent logic programs answer set semantics discovered theorems capture classes strongly equivalent logic programs lead
program simplification rules preserve strong equivalence specifically
help computers discovered exact conditions capture strong equivalence
rule empty set two rules two rules one two
rules two rules another rule three rules two three
rules

introduction
apply computer aided theorem discovery technique discover theorems
strongly equivalent logic programs answer set semantics discovered
theorems capture classes strongly equivalent logic programs lead
program simplification rules preserve strong equivalence
theorem discovery highly creative human process generally speaking
divide two steps conjecture formulation ii conjecture verification
computers help two steps instance machine learning tools
used first step e coming reasonable conjectures automated
deduction tools used second step e verifying correctness
conjectures
theorem discovery may make use learning two tasks fundamentally different theorem discovery starts theory aims finding interesting
consequences theory learning mostly induction e starts
examples consequences aims finding theory would explain given examples consequences
computers discover theorems old aspiration
success stories instance lenat reported able come
interesting concepts theorems number theory remarkable systems
described petkovsek wilf zeilberger discover many identities especially
hypergeometric identities involving sums binomial coefficients important
analyses yet another example interesting theorems discovered
c

ai access foundation rights reserved

filin chen

almost fully automatically recent work lin discovering state invariants
domains lin showed ways classify many state constraints
useful according syntactic properties enumerate easily
many domains furthermore many constraints whether invariants
checked automatically system described lin discover
many common constraints domains logistics domain could even
discover set complete state invariants
following line consider discovering
classes strongly equivalent sets logic program rules answer set semantics
noted lifschitz pearce valverde two sets rules strongly equivalent
replace one logic program without changing semantics
program thus identifying strongly equivalent sets logic program rules useful
exercise may applications program simplification
organized follows next section briefly review basic
concepts logic programming answer set semantics section state
precise terms type theorems want discover section prove
general theorems help us prove theorems section describe
theorems discovered discuss application logic program
simplification section finally conclude section

answer set programming
traditional logic programming systems prolog solve query answering
user encodes knowledge domain set rules solves issuing
queries set rules contrast answer set programming asp niemela
lifschitz marek truszczynski constraint programming paradigm
logic programming answer set semantics gelfond lifschitz
solve user encodes domain knowledge logic program
way answer sets program correspond solutions original
compared constraint programming paradigms asp allows natural
encodings recursive relations built facilities default reasoning several asp
solvers developed niemela simons syrjanen leone pfeifer faber
eiter gottlob perri scarcello lin zhao lierler maratea
date asp used space shuttle nogueira balduccini gelfond watson
barry evolutional linguistics erdem lifschitz nakhleh ringe
others following briefly review basic notions asp
let l propositional language e set atoms shall consider
logic programs rules following form
h hk p pm pm pn



hi pi atoms l logic program default negation
constraints k disjunctions head rules following r
rule form write hdr denote set h hk psr set p pm
ngr set pm pn thus rule r written hdr psr ngr
semantics programs given answer sets gelfond lifschitz


fidiscovering classes strongly equivalent logic programs

defined fixed point operator known gelfond lifschitz
transformation let x subset l p logic program gelfond lifschitz
transformation p x written p x set rules obtained p according
following two rules
rule form p pi x n delete
rule
delete literals form pi bodies remaining rules
instance p set following rules
b
c
p b p b b c
clearly x p p x set rules operator
set x answer set p x minimal set atoms satisfies every rule
p x x satisfies rule form
h h k p p
k hi x whenever p pm x instance
program b c answer sets answer sets
program
two logic programs p p said equivalent answer sets
strongly equivalent lifschitz et al language l written p se p
logic program p l p p p p equivalent thus write p se p
p p strongly equivalent example b c
equivalent strongly equivalent shown se
abstract say rule r strongly equivalent another rule r written
r se r r se r two rules r r strongly equivalent rule r written
r r se r r r se r
notion strong equivalence important asp several reasons first
helps us understand answer set semantics instance turner showed
disjunctive rule b strongly equivalent set normal rules implies
cannot modular translation disjunctive logic programs normal logic
programs however
b b
strongly equivalent
b b b
means constraint b disjunctive rule b replaced
two rules without disjunction secondly mentioned introduction p
p strongly equivalent interchangeable regardless occur
thus large repertoire pairs strongly equivalent logic programs could


filin chen

use transform given program one suitable need hand
particular could help us simplify program purpose computing answer
sets shall see discovered theorems contribute significantly repertoire
lifschitz et al showed checking strong equivalence two logic
programs done logic three valued non classical logic
somewhere classical logic intuitionistic logic lin provided mapping
logic programs propositional theories showed two logic programs
strongly equivalent iff corresponding theories propositional logic equivalent
used generating example pairs strongly equivalent logic
programs verifying conjecture repeat
let p p two finite logic programs l set atoms
theorem lin p se p iff propositional logic following sentence valid



p p

r
r

pl

rp

rp

p l p atom rule r form r
conjunction following two sentences
p pm p p n h hk



p





p



p



p n



h



h k

notice n left sides implications considered
true k right sides implications considered
f alse
general checking two sets rules strongly equivalent conp complete c f
turner pearce tompits woltran lin


mentioned one possible use notion strongly equivalent logic programs
program simplification instance given logic program rule r
may ask whether deleted without knowing rules p e
whether r strongly equivalent empty set may ask whether rule r
p deleted one knows another rule r already p e whether r r
strongly equivalent r general may ask following k n question
r rk u um se r rk v vn thus theorem discovery task come
given k n computationally effective condition holds
answer k n question positive
suppose condition c suppose
r rk u um se r rk v vn
better replace u um v vn presence r rk purpose
say computing answer sets program one way use simplify
given program p first choose k rules p rules try


fidiscovering classes strongly equivalent logic programs

n rules condition c holds replace rules p simpler n
rules
however even checking whether c holds would take negligible constant time
procedure simplify given logic program practical k n
small k almost number rules given
program n small thus seems us worthwhile solve
k n k n small particular shall
concentrate whether rule deleted
whether rule replaced another one presence
rule whether another rule deleted presence two
rules whether rule deleted pair rules
replaced single rule
example theorems want discover follows
rule r r se iff hdr ngr psr



general theorems
section prove general theorems help us verify whether assertion
true
let l propositional language e set atoms l construct first order
language fl equality two unary predicates h h three unary predicates hdr
psr ngr logic program rule r l assume rule l unique
name three unary predicates xi yi zi positive number
notice used hdr psr ngr denote sets atoms previously
overload unary predicates naturally intended interpretations
unary predicates respective sets
definition given set l atoms intended model fl one whose domain l
rule r l unary predicates psr hdr ngr interpreted
corresponding sets atoms psr hdr ngr respectively
conditions rules l psr ngr expressed special sentences
called properties fl
definition sentence fl property n rules constructed equality
predicates xi yi zi n property n rules true holds
sequence p r rn n rules p true intended model fl p
obtained replacing xi hdri yi psri zi ngri
notice since p mention predicates xi yi zi h h true
one intended model true intended
mentioned interested capturing strong equivalence
two programs computationally effective condition specifically
small k n interested finding property k n rules
sequence k n rules p r rk u um v vn
r rk u um se r rk v vn iff true p




filin chen

shall prove general theorems help us verify assertion
class formulas
first theorem reformulated fl follows reading h p p
holds h p p holds
theorem p se p l iff following sentence


x h x h x
r
r
rp



rp

true intended fl r conjunction following two
sentences
x psr x h x x ngr x h x x hdr x h x



x psr x h x x ngr x h x x hdr x h x



first order logic prenex formula form x b satisfiable
satisfiable structure n elements b formula contains quantifiers
constants function symbols n length x non empty x
empty prove similar first order languages intended

definition sentence fl extended property n rules constructed
equality predicates xi yi zi n h h extended
property n rules true holds sequence p r rn n rules model
p true p obtained replacing xi hdri yi
psri zi ngri
definition following p r rn tuple rules l l subset
l define restriction p l r rn ri
hdri l psri l ngri l
lemma let extended property fl n rules form x q
x tuple w variables q formula quantifiers
holds sequence p n rules intended model fl subset
l l l w atoms one atom w holds
restriction p l intended model fl
proof suppose intended model fl p thus tuple
p w one w atoms l q p x
p let l set

atoms p defined follows
predicates h h xi yi zi interpreted restriction
interpretation l
rule r l predicates hdr psr ngr interpreted
well defined r rule l


fidiscovering classes strongly equivalent logic programs

intended model fl let p restriction p l p
tuple rules l since q quantifiers language function symbols
instantiation u l q p x
p u iff q p x
p u since


q p x
p q p x
p thus x q p
theorem lemma following theorem enable
us automate verification part property prenex
format
theorem without loss generality suppose n property k n
rules form x q x tuple w variables q formula
quantifiers following two assertions equivalent
sequence k n rules p r rk u um v vn true
p r rk u um se r rk v vn
b b n sequence p r rk u um v vn rules
w k atoms true p
r rk u um se r rk v vn
b n sequence p r rk u um rules
k atoms true p
r rk u um se r rk
k w k w k k otherwise
proof b obvious assume b true holds
well suppose first n suppose p r rk u um v vn sequence
k n rules language l true p
r rk u um se r rk v vn
thus intended model fl satisfies p intended model fl
satisfies following sentence


x h x h x
r
r
rp

rp

p r rk u um p r rk v vn noted definition satisfy p thus satisfies following sentence




p x h x h x
r
r
r
r
rp

rp

rp

rp

p v vn p u um
rule r extended property x one rule
mention quantifiers r equivalent x r thus tuple q
rules vthere extended property rules mention quantifiers
rq r equivalent q tuple variables
thus


filin chen

tuple z k variables tuple z variables extended property
k n rules quantifiers whose free variables z
z
tuple z k n variables tuple v variables extended property
k n rules quantifiers whose free variables
z z
v v v v common variables equivalent
following sentence
x h x h x z z z z p
since assumed n thus extended property k n
rules mention quantifiers function symbols whose free variables
among z z z sentence equivalent following sentence
x h x h x z z z p
given form assumed theorem tuple z w k
variables tuple z variables extended property k n rules
mention quantifiers whose free variables among z z
sentence equivalent z z p
lemma subset l l w k atoms
z z holds p p restriction p l
p r rk u u v vn
mean true p r rk u u se r rk v vn
shows b
proof b exactly except



r
r
rp

rp

equivalent




rp



r

r

rp


part often proved help following theorem
theorem let l l two languages f function l l p p
two programs l strongly equivalent f p f p two programs
l strongly equivalent f p obtained p replacing
atom p f p
proof theorem fact propositional logic tautology f
function l l f tautology f formula obtained
replacing atom p f p
example theorems section proving assertions form
see section


fidiscovering classes strongly equivalent logic programs

computer aided theorem discovery
given k n strategy discovering theorems follows
choose small language l
generate possible triples
r rk u um v vn



sets rules l r rk u um se r rk v vn l
formulate conjecture k n holds language l e
condition true triple form iff generated step
verify correctness conjecture general case
process may iterated instance conjecture formulated step may
fail generalize step need formulate conjecture start
step larger language
ideally would process automatic however difficult automate
steps number possible patterns need examine order come
good conjecture step huge general theorem
enables us automate verification part step theorem enables us
automate proof sufficient part assertion class formulas
similar necessary part shall see theorem helps
lot provide automated procedure nonetheless computers play
crucial role steps following report theorems discovered
procedure

asks given rule strongly equivalent empty set thus
deleted program following experimental
lemma rule r mentions three distinct atoms r se iff
hdr ngr psr
theorem following
lemma rule r form r se hdr ngr psr
true rule mentions three atoms
proof suppose r se hdr psr psr ngr suppose l set atoms
r b c three atoms let

p hdr

b
p psr
f p

c
otherwise


filin chen

theorem f r se construction f
hdf r psf r psf r ngf r f r mentions three distinct
atoms
theorem lemma holds general case e without
restriction number atoms r
proof notice condition lemma hdr ngr psr equivalent
following property
x x x z x x
true r thus part follows theorem lemma
part follows lemma lemma
part theorem already well known first proved osorio et al
part proved recently inoue sakama
discover anything case reassuring methodology works
notice need consider n n
n r rn strongly equivalent iff n ri strongly
equivalent

asks rule deleted presence another rule
asks rule replaced another one first solve
solution come corollary
following experimental
lemma two rules r r mentions three atoms r r
r strongly equivalent iff one following two conditions true
r se
psr psr ngr ngr hdr hdr ngr
lemma two rules r r r r se r none
two conditions lemma hold two rules mention three
atoms
proof suppose two rules r r r r se r none two
conditions lemma hold let l set atoms r r
without loss generality suppose atom makes condition
lemma false psr empty let atom let l
atom f function l l following




psr
f


otherwise


fidiscovering classes strongly equivalent logic programs

clearly f r f r mention three distinct atoms theorem
f r f r se f r
none two conditions lemma hold f r f r
first f r se theorem need
psf r hdf r ngf r
empty construction f psr hdr ngr contradiction
assumption r strongly equivalent similarly
construction f psr hdr ngr contradiction assumption
r strongly equivalent cannot cannot psf r
thus must empty
case psf r psf r ngf r ngf r
hdf r hdf r ngf r assumption atom makes psr psr
ngr ngr hdr hdr ngr false three cases suppose makes
psr psr false e psr psr construction f
psf r psf r two cases similar
theorem lemma holds general case without restriction number atoms r r
proof condition lemma equivalent following property
x x x z x x
x x x x z x z x x x x x x z x
true r r thus part follows theorem lemma noticing
property written x q required theorem
part follows lemma lemma
thus rule r cannot deleted deleted presence
another rule r must case r redundant given r body r
satisfied body r satisfied well furthermore r entail
entailed r hdr hdr ngr
osorio et al proved r r se r psr ngr hdr ngr
psr psr ngr ngr hdr hdr recently eiter et al showed
r r se r r implies r wang zhou e exists set
ngr hdr hdr ngr ngr psr psr
one see special cases part theorem
actually general instance special cases apply
c b c b c

c b c
one easily two sets strongly equivalent theorem
solution derive solution


filin chen

theorem two rules r r r se r iff one
following two conditions true
r se r se
psr psr ngr ngr hdr ngr hdr ngr
proof theorem easy see r se r iff r r se r r r se r

thus two rules r r interchanged
deleted strongly equivalent empty set body
consequences body true instance b se b
matter b two rules body body true
consequence contradiction another example
b se b
two rules body body true consequence
b

asks rule deleted presence another two rules
asks two rules replaced single rule asks
two rules replaced another two rules similar previous subsection
solution follow solution
experiment difficult turned
consider language six atoms case principle given language l
every subset l hd ps ng rule thus size l six
principle possible rules triples however
cut numbers significantly already proved
first consider rules common elements
two sets hd ps ng hd ps ps ng common element
theorem rule deleted hd ng common elements according
theorem obtain strongly equivalent rule deleting common elements hd
following call rules canonical rule r canonical
hdr psr hdr ngr psr ngr
secondly consider isomorphic rules one one onto
function l l maps r r r r r r two sets rules
essentially except names atoms
thus considering canonical rules certain normal form triples
rules avoids isomorphic rules ended roughly million triples rules
consider verifying following took hours solaris server
consisting sun ultra sparc iii mhz cpus gb ram
details experiment please refer chen lin li



fidiscovering classes strongly equivalent logic programs

lemma three canonical rules r r r mention six atoms
r r r se r r iff one following three conditions true
r r se r
r r se r
atom p
p psr psr hdr hdr ngr ngr
hdri p hdr ngr psri p psr ngri p ngr

p psr ngr hdr hdr
p psr ngr hdr hdr
following lemma reason need consider language six atoms

lemma three canonical rules r r r r r r se r r
none three conditions lemma hold three rules
mention six atoms
proof proof lemma tedious consider several cases consider
following statements three canonical rules r r r
r r r se r r
ii r r se r e psr psr ngr ngr hdr ngr hdr ngr
iii r r se r e psr psr ngr ngr hdr ngr hdr ngr
iv psr psr hdr hdr ngr ngr
v atom p set psr psr hdr hdr ngr ngr another
different atom q one following three conditions true
q hdr ngr q hdr ngr
q psr q psr
q ngr q ngr
notice negation condition lemma
vi hdr hdr ngr atom p psr ngr
hdri p hdr ngr psri p psr ngri p ngr
since r r symmetric conditions lemma prove lemma need
prove following three assertions
three canonical rules r r r satisfy iv three
canonical rules r r r mention six atoms satisfy iv well


filin chen

b three canonical rules r r r satisfy iii v
three canonical rules r r r mention six atoms satisfy iii v
well
c three canonical rules r r r satisfy iii vi
three canonical rules r r r mention six atoms satisfy iii vi well
prove three assertions one one
let two atoms make ii iii true psr psr psr
empty let atom psr psr psr empty let
atom psr psr psr empty let atom
finally let atom different l
let f function l l defined following














psr psr psr
f

psr psr psr






psr psr psr



otherwise
let ri follows
psri psf ri ngri ngf ri hdri hdf ri ngf ri




ri canonical rule ri se f ri
need f ri se see notice
definition f atoms psr mapped
atoms hdr ngr mapped thus
psf r hdf r ngf r theorem f r se f r se
f r se ii iii hold f r f r f r definition
f
holds r r r theorem
f r f r f r se f r f r
ri se f ri
ii iii hold r r r mentioned definition f ii
iii hold f r f r f r
iv holds r r r need iv holds
f r f r f r see notice atoms
psr psr mapped atoms
hdr hdr ngr ngr mapped


fidiscovering classes strongly equivalent logic programs

b let two atoms make ii iii true let p q two witness
atoms v p os r p q empty let atom let
atom l p q define f follows











p
p
f
q
q






psr p q




otherwise
define ri well
ri canonical rule ri se f ri seen
way
theorem f r f r f r se f r f r thus
r r r se r r
holds r r r
definition f ii iii hold f r f r f r thus hold
r r r well
definition f v holds f r f r f r atom
p set psf r psf r hdf r hdf r ngf r ngf r another
different atom q one following three conditions true
q hdf r ngf r q hdf r ngf r
q psf r q psf r
q ngf r q ngf r
v holds r r r well
psri psf ri ngri ngf ri hdri ngri hdf ri ngf ri
c let two atoms make ii iii true let p witness atom
vi let q hdr hdr q ngr p os r p q empty let
atom let atom let l p q define f
follows













p
p
f
q
q






psr p q



otherwise
define ri well
ri canonical rule ri se f ri seen
way


filin chen

theorem f r f r f r se f r f r thus
r r r se r r
holds r r r
definition f ii iii hold f r f r f r thus
hold r r r well
definition f vi holds f r f r f r hdf r hdf r
ngf r atom p psf r ngf r hdf ri
p hdf r ngf r psf ri p psf r ngf ri p ngf r vi
holds r r r well
psri psf ri ngri ngf ri hdri hdf ri

theorem lemma holds general case without restriction number atoms r r r
proof assertion r r r canonical rules satisfy one three
conditions lemma equivalent following property
x x x x x x z x x z x
x x x x x x z x x z x
x x x x x x z x x z x
x x x x z x z x x x x x x z x
x x x x z x z x x x x x x z x
x con x con x con x con x
true r r r con x stands
x x x x x x z x z x
con x
x x x z z z
x x z z z
con x
x z x x x
con x
x z x x x
thus part follows theorem lemma noticing
property written x q required theorem part follows
lemma lemma


fidiscovering classes strongly equivalent logic programs

conditions lemma theorem rather complex reason
difficult automate step procedure beginning section
conditions capture possible cases r subsumed r r difficult
describe concisely words give examples
consider following three rules
r
r
r
r r r se r r condition lemma holds
however change r r p r r r p r r
strongly equivalent one could check condition lemma hold
indeed p unique answer set p two
answer sets
easy theorem subsumed

subsumed

following theorem yield solution

theorem three rules r r r r r r
strongly equivalent iff following three conditions true
r r r se r r
r r se r
r r se r
example
se

se

se
similarly following theorem
theorem four rules r r r r r r r r
strongly equivalent iff following four conditions true


filin chen

r r r se r r
r r r se r r
r r r se r r
r r r se r r

program simplification
mentioned one possible use notion strongly equivalent logic programs
simplifying logic programs p se q q simpler p
replace p program contains q
answer set programming systems perform program simplifications however
smodels niemela et al stand alone front end called lparse
used ground simplify given logic program seems lparse simplifies grounded
logic program computing first well founded model however perform
program simplification notion strong equivalence instance lparse
current version lparse nothing following set rules
b b replace first rule following
program b b constraint
unlikely anyone would intentionally writing rules b
type rules arise grounding rules variables
instance following typical recursive rule used logic programming encoding
hamiltonian circuit niemela marek truszczynski
reached x arc x hc x reached
instantiated graph cyclic arcs arc rule generates cyclic rules
form reached x hc x x reached x unless deleted explicitly rules
slow many systems especially sat instance none graphs
tested assat self cycles consisting arc node lin zhao
cycles included assat would run significantly longer
thus useful consider program simplification
indeed transformation rules deleting contain common elements
heads positive bodies proposed brass dix studied
perspective strong equivalence osorio et al eiter et al
add transformation rules instance theorem delete
elements head rule appear negation failure part rule
theorems used define transformation rules

concluding remarks future work
donald knuth forward petkovsek et al said
science understand well enough explain computer art
everything else science advances whenever art becomes science


fidiscovering classes strongly equivalent logic programs

state art advances people leap
territory understood old
hope work one step closer making discovering classes strongly
equivalent logic programs science
mentioned methodology used similar lin
cases plausible conjectures generated testing domains
small sizes general theorems proved aid verification conjectures
general case however plausible conjectures generated automatically
lin done manually verifications conjectures
lin done automatically well done semi automatically
overcoming two weaknesses focus future work specifically would
make step procedure section automatic prove theorem similar
theorem automate proofs parts theorems theorems way theorem makes proofs parts theorems
automatic way would able discover interesting theorems area
easily

acknowledgments
extended abstract appeared proceedings ijcai thank yan
zhang comments earlier version thank anonymous
reviewers useful comments especially one pointing error
lemma earlier version work supported part
grants council hong kong competitive earmarked grant
hkust e part second authors work done student sun
yat sen university guangzhou china visiting scholar department computer
science engineering hong kong university science technology hong kong

references
brass dix j semantics disjunctive logic programs partial
evaluation journal logic programming
chen lin f li l selp system studying strong equivalence
logic programs proceedings th international conference logic
programming nonmonotonic reasoning lpnmr pp
eiter fink tompits h woltran simplifying logic programs
uniform strong equivalence proceedings th international conference
logic programming nonmonotonic reasoning lpnmr pp
erdem e lifschitz v nakhleh l ringe reconstructing evolutionary
history indo european languages answer set programming proceedings
th international symposium practical aspects declarative languages padl
pp


filin chen

gelfond lifschitz v stable model semantics logic programming
proceedings th international conference symposium logic programming iclp slp pp
gelfond lifschitz v classical negation logic programs disjunctive
databases generation computing
inoue k sakama c equivalence logic programs updates proceedings th european conference logics artificial intelligence jelia pp

lenat b automated scientific theory formation case study
program machine intelligence pp jean hayes donald michie l
mikulich eds ellis horwood
leone n pfeifer g faber w eiter gottlob g perri scarcello f
dlv system knowledge representation reasoning acm transactions
computational logic
lierler maratea cmodels sat answer set solver enhanced
non tight programs proceedings th international conference logic
programming nonmonotonic reasoning lpnmr pp
lifschitz v action languages answer sets logic programming
paradigm year perspective k r apt v w marek truszczynski
warren eds springer verlag
lifschitz v pearce valverde strongly equivalent logic programs acm
transactions computational logic
lin f reducing strong equivalence logic programs entailment classical
propositional logic proceedings th international conference principles
knowledge representation reasoning kr pp
lin f discovering state invariants proceedings th international conference principles knowledge representation reasoning kr pp

lin f zhao assat computing answer sets logic program sat solvers
artificial intelligence
marek v w truszczynski stable logic programming alternative logic
programming paradigm logic programming paradigm year perspective
k r apt v w marek truszczynski warren eds springer verlag
niemela simons p syrjanen
smodels system answer
set programming proceedings th international workshop nonmonotonic reasoning breckenridge colorado usa corr arxiv cs ai
http www tcs hut software smodels
niemela logic programs stable model semantics constraint programming
paradigm annals mathematics artificial intelligence


fidiscovering classes strongly equivalent logic programs

nogueira balduccini gelfond watson r barry prolog
decision support system space shuttle proceedings rd international
symposium practical aspects declarative languages padl pp
osorio navarro j arrazola j equivalence answer set programming
selected papers th international workshop logic program synthesis
transformation lopstr pp
pearce tompits h woltran encodings equilibrium logic logic
programs nested expressions proceedings th portuguese conference
artificial intelligence epia pp
petkovsek wilf h zeilberger b wellesley mass k peters
turner h strong equivalence logic programs default theories made easy
proceedings th international conference logic programming nonmonotonic reasoning lpnmr pp
turner h strong equivalence made easy nested expressions weight constraints
theory practice logic programming
wang k zhou l comparisons computation well founded semantics
disjunctive logic programs acm transactions computational logic





