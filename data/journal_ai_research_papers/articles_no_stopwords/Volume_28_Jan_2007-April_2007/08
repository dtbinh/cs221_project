Journal Artificial Intelligence Research 28 (2007) 299-348

Submitted 07/06; published 03/07

Supporting Temporal Reasoning Mapping
Calendar Expressions Minimal Periodic Sets
Claudio Bettini
Sergio Mascetti

bettini@dico.unimi.it
mascetti@dico.unimi.it

Dipartimento di Informatica e Comunicazione, Universita di Milano
Via Comelico, 39, 20135, Milan, Italy

X. Sean Wang

Sean.Wang@uvm.edu

Department Computer Science, University Vermont
33 Colchester Avenue, Burlington, VT, 05405 USA

Abstract
recent years several research efforts focused concept time granularity applications. first stream research investigated mathematical models
behind notion granularity algorithms manage temporal data based
models. second stream research investigated symbolic formalisms providing set
algebraic operators define granularities compact compositional way. However, limited manipulation algorithms proposed operate directly
algebraic representation making unsuitable use symbolic formalisms
applications need manipulation granularities.
paper aims filling gap results two streams research,
providing efficient conversion algebraic representation equivalent
low-level representation based mathematical models. addition, conversion
returns minimal representation terms period length. results major
practical impact: users easily define arbitrary granularities terms algebraic
operators, access granularity reasoning services operating efficiently
equivalent, minimal low-level representation. example, illustrate
application temporal constraint reasoning multiple granularities.
technical point view, propose hybrid algorithm interleaves
conversion calendar subexpressions periodical sets minimization period length. algorithm returns set-based granularity representations minimal
period length, relevant parameter performance considered reasoning services. Extensive experimental work supports techniques used
algorithm, shows efficiency effectiveness algorithm.

1. Introduction
According 2006 research Oxford University Press, word time found
common noun English language, considering diverse sources
Internet including newspapers, journals, fictions weblogs. somehow surprising
among 25 common nouns find time granularities day, week, month
year. pretty sure many time granularities business day, quarter,
semester, etc. would found quite frequently used natural languages. However,
way computer applications deal concepts still naive mostly hidden program code and/or based limited sometimes imprecise calendar support.

c
2007
AI Access Foundation. rights reserved.

fiBettini, Mascetti & Wang

Temporal representation reasoning long time AI research topic aimed
providing formal framework common sense reasoning, natural language understanding, planning, diagnosis many complex tasks involving time data management.
Despite many relevant contributions, time granularity representation reasoning
support often ignored over-simplified. active area temporal
constraint satisfaction, proposals implicitly assumed adding support granularity trivial extension. quite recently recognized
case specific techniques proposed (Bettini, Wang, & Jajodia, 2002a). Even
intuitively simple task deciding whether specific instant part time granularity
tricky arbitrary user-defined granularities e.g., banking days, academic
semesters considered.
Granularities periodic patterns terms granularities playing role even
emerging application areas inter-organizational workflows personal information
management (PIM). example, inter-organizational workflows need model monitor
constraints like: Event2 occur later two business days occurrence
Event1. context PIM, current calendar applications, even mobile devices,
allow user specify quite involved periodical patterns recurrence events.
example, possible schedule event every last Saturday every two months.
complexity supported patterns increasing last years, current
simple interfaces showing limits. essentially based combination
recurrences based one two granularities taken fixed set (days, weeks, months,
years). foresee possibility significant extensions applications
specifying recurrences user-defined granularities. example, user may define (or
upload granularity library) granularity corresponding academic semester
school teaching at, set date finals last Monday
semester. bank may want define banking days granularity bank
policies may formalized recurrences terms granularity. Automatically
generated appointments policies may appear devices bank employees
involved specific procedures. foresee need show user preferred view
calendar. current standard applications user choice businessday limited view complete view, enabling view based userss
consulting-days, example? new perspective use mobile devices may result
considering time span activities supposed executed (expressed
arbitrary granularities), software agents board alert constraints
may violated, even based contextual information user location traffic
conditions. scenario highlights three main requirements: a) sufficiently expressive
formal model time granularity, b) convenient way define new time granularities,
c) efficient reasoning tools time granularities.
Consider a). last decade significant efforts made provide formal
models notion time granularity devise algorithms manage temporal
data based models. addition logical approaches (Montanari, 1996; Combi,
Franceschet, & Peron, 2004), framework based periodic-set representations
extensively studied (Bettini, Wang, & Jajodia, 2000), recently approach based
strings automata introduced (Wijsen, 2000; Bresolin, Montanari, & Puppis,
2004). mostly interested last two approaches support effective
300

fiMapping Calendar Expressions Minimal Periodic Sets

computation basic operations time granularities. cases representation
granularities considered low-level one, rather involved specification
terms instants time domain.
Consider requirement b) above. Users may hard time defining granularities
formalisms based low-level representations, interpret output operations.
clearly unreasonable ask users specify granularities linear equations
mathematical formalisms operate directly terms instants granules fixed
time granularity. Hence, second stream research investigated high-level symbolic
formalisms providing set algebraic operators define granularities compact
compositional way. efforts task started even research formal
models granularity (Leban, McDonald, & Forster, 1986; Niezette & Stevenne, 1992)
continued parallel stream research (Bettini & Sibi, 2000; Ning, Wang, & Jajodia,
2002; Terenziani, 2003; Urgun, Dyreson, Snodgrass, Miller, Soo, Kline, & Jensen, 2007).
Finally, let us consider requirement c) above. Several inferencing operations
defined low-level representations, including equivalence, inclusion granules
different granularities, even complex inferencing services constraint propagation
(Bettini et al., 2002a). Even simple operations general method available operating
directly high level representation. Indeed, cases, proposed methods
cannot exploit structure expression require enumeration granules,
may inefficient. case, example, granule conversion
methods presented Ning e at. (2002). Moreover, aware method
perform operations, equivalence intersection sets granules, directly
terms high level representation.
major goal paper provide unique framework satisfy requirements
a), b), c) identified above, adding existing results smart efficient
technique convert granularity specifications high-level algebraic formalism
low-level one, many reasoning tools available. particular, paper
focus conversion high-level formalism called Calendar Algebra (Ning
et al., 2002) low-level formalism based periodical sets (Bettini et al., 2000, 2002a).
Among several proposals high-level (algebraic) specification granularities,
choice Calendar Algebra two main motivations: first, allows user express
large class granularities; comparison expressiveness Calendar Algebra
formalisms see (Bettini et al., 2000). Second, provides richest set
algebraic operations designed reflect intuitive ways users define
new granularities. discussion actual usability tool could
enhanced graphical user interface found Section 6.2. choice
low-level formalism based periodic-sets two main motivations: first,
efficient implementation basic operations already exists extensively
experimented (Bettini, Mascetti, & Pupillo, 2005); second, one currently
supporting complex operations granularities needed constraint satisfaction,
illustrated detail Section 6.1.
technical contribution paper hybrid algorithm interleaves conversion calendar subexpressions periodical sets step period minimization.
central phase conversion procedure derive, algebraic subexpression,
periodicity output set. periodicity used build periodical represen301

fiBettini, Mascetti & Wang

tation subexpression recursively used operand expressions.
Given calendar algebra expression, algorithm returns set-based granularity representations minimal period length. period length relevant parameter
performance basic operations granularities specialized ones
operations used constraint satisfaction service. Extensive experimental work
reported paper validates techniques used algorithm, showing, among
things, (1) even large calendar expressions efficiently converted, (2)
less precise conversion formulas may lead unacceptable computation time. latter
property shows importance carefully accurately designed conversion formulas.
Indeed, conversion formulas may seem trivial length periodicity concern.
designing conversion formulas, made effort reduce period length
resulting granularity representation, thus render whole conversion process computationally efficient.
next section define granularities; several interesting relationships among
highlighted periodical set representation formalized. Section 3 define
Calendar Algebra present operations. Section 4 describe conversion
process: definition three steps necessary conversion, algebraic
operation present formulas perform step. Section 5 discuss period
minimality issue, report experimental results based full implementation
conversion algorithm extension ensuring minimality. Section 6
motivate work presenting complete application scenario. Section 7 reports
related work, Section 8 concludes paper.

2. Formal Notions Time Granularities
Time granularities include common ones hours, days, weeks, months years,
well evolution specialization granularities specific contexts
applications. Trading days, banking days, academic semesters examples
specialization granularities become quite common describing policies
constraints.
2.1 Time Granularities
comprehensive formal study time granularities relationships found
(Bettini et al., 2000). paper, introduce notions essential
show results. particular, report notion labeled granularity
proposed specification calendar algebra (Bettini et al., 2000; Ning et al., 2002);
show later labeled granularity reduced standard notion
granularity, one used Bettini et al. (2002a).
Granularities defined grouping sets instants granules. example,
granule granularity day specifies set instants included particular day.
label used refer particular granule. whole set time instants called time
domain, purpose paper domain arbitrary infinite set
total order relationship, .

302

fiMapping Calendar Expressions Minimal Periodic Sets

Definition 1 labeled granularity G pair (LG , ), LG subset
integers, mapping LG subsets time domain
pair integers j LG < j, (i) 6= (j) 6= , (1) element
(i) less every element (j), (2) integer k LG < k < j,
(k) 6= .
former condition guarantees monotonicity granularity; latter
used introduce bounds (see Section 2.2).
call LG label set LG call G(i) granule; G(i) 6= call
non-empty granule. LG exactly integers, granularity called fullinteger labeled. LG = Z+ notion granularity used several
applications, e.g., (Bettini et al., 2002a). example, following labeling schema,
assume map day(1) subset time domain corresponding January 1,
2001, day(32) would mapped February 1, 2001, b-day(6) January 8, 2001 (the
sixth business day), month(15) March 2002. generalization arbitrary label
sets introduced mainly facilitate conversion operations algebra, however
final goal conversion labeled granularity denoted calendar expression
positive-integer labeled one denoted periodic formula.
2.2 Granularity Relationships
interesting relationships granularities follows. definitions extended
ones presented Bettini et al. (2000) cover notion labeled granularity.
Definition 2 G H labeled granularities, G said group H, denoted
G / H, non-empty
granule H(j), exists (possibly infinite) set labels

G H(j) = G(i).
Intuitively, G / H means granule H union granules G.
example, day / week since week composed 7 days day / b-day since business
day day.
Definition 3 G H labeled granularities, G said finer H,
denoted G H, granule G(i), exists granule H(j) G(i) H(j).
example business-day finer day, finer week.
say G partitions H G / H G H. Intuitively G partitions H
G / H granules G included granules H.
example, day b-day group b-week (business week, i.e., business day
week), day partition b-week, b-day does.
Definition 4 labeled granularity G1 label-aligned subgranularity labeled granularity G2 label set LG1 G1 subset label set LG2 G2
LG1 G1 (i) 6= , G1 (i) = G2 (i).
Intuitively, G1 subset granules G2 granules label
two granularities.
303

fiBettini, Mascetti & Wang

Granularities said bounded LG first last element G(i) =
LG . assume existence unbounded bottom granularity, denoted
full-integer labeled groups every granularity system.
time domains that, given set granularities, always possible
find bottom one; example, easily proved property holds
time domain cardinality integers. hand,
property hold time domains (e.g. reals). However, assumption
existence bottom granularity still reasonable since address problems
granularities defined starting bottom one. definition calendar
set granularities bottom granularity (Bettini et al., 2000) captures
idea.
2.3 Granularity Conversions
dealing granularities, often need determine granule (if any)
granularity H covers given granule z another granularity G. example,
may wish find month (an interval absolute time) includes given week
(another interval absolute time).
transformation obtained operation. Formally, label z LG ,
H
0
0
dzeG undefined @z 0 LH s.t. G(z) H(z 0 ) ; otherwise, dzeH
G = z , z
0
0
unique index value G(z) H(z ). uniqueness z guaranteed
monotonicity 1 granularities. example, dzemonth
second gives month includes
month
second z. Note dzesecond always defined, dzemonth
week undefined week
z falls two months. Note G H, function dzeH
G defined
week
index value z. example, since day week, dzeday always defined, i.e.,
day find week contains it. notation dzeH used source
granularity left implicit (e.g., dealing fixed set granularities
distinguished bottom granularity).
Another direction transformation operation: Let G H
H
granularities
G / H, z an2 integer. Define bzcG set labels
granules G jS G(j) = H(z). function useful finding, e.g.,
days month.
2.4 Periodical Granules Representation
central issue temporal reasoning possibility finitely representing infinite granularities. definition granularity provided general expressive may
impossible provide finite representation granularities. Even labels
(i.e., subset integers) necessarily finite representation.
solution first proposed Bettini et al. (2000). idea
commonly used granularities present periodical behavior; means certain
pattern repeats periodically. feature exploited provide method
1. Condition (1) Definition 1.
2. definition different one given Bettini et al (2000) since considers non contiguous
granules G.

304

fiMapping Calendar Expressions Minimal Periodic Sets

finitely describing granularities. formal definition based periodically groups
relationship.
Definition 5 labeled granularity G groups periodically labeled granularity H
(G / H) G / H exist positive integers N P
(1) label H, + N label H unless + N greater greatest
label H,

(2) label H, H(i) = kr=0 G(jr ) H(i + N ) non-empty granule

H H(i + N ) = kr=0 G(jr + P ),
(3) H(s) first non-empty granule H (if exists), H(s + N ) non-empty.
groups periodically relationship special case group characterized
periodic repetition grouping pattern granules G granules H.
definition may appear complicated actually quite simple. Since G groups H,
granule H(i) union granules G; instance assume union
granules G(a1 ), G(a2 ), . . . , G(ak ). Condition (1) ensures label + N exists (if
greater greatest label H) condition (2) ensures that, H(i + N )
empty, union G(a1 + P ), G(a2 + P ), . . . , G(ak + P ). assume
r = 0 . . . k, (jr + P ) LG ; not, conditions considered satisfied. Condition
(3) simply says least one repetitions.
call pair P N Definition 5, period length associated period
label distance. indicate R number granules H corresponding
groups P consecutive granules . formally R equal number labels
H greater equal smaller + N arbitrary label H. Note
R affected value i.
period length period label distance unique; precisely,
G period label
indicate PHG period length H terms G NH
distance H terms G; form PH NH used G = . Note
period length integer value. simplicity indicate one period
granularity H set R consecutive granules H.
general, periodically groups relationship guarantees granularity H
finitely described (in terms granules G).
Definition 6 G / H, H finitely described providing: (i) value P
P
N ; (ii) set LP labels H
one period H; (iii) L , finite set
Sa labels G, H(a) = iSa G(i); (iv) labels first last non-empty
granules H, values infinite.
representation, granules labels LP ones need
explicitly represented; call granules explicit granules.
granularity H represented periodic set granules granularity G,
G ) periodically groups
exists infinite number pairs (PHG , NH
relation satisfied. relation satisfied pair (P, N ), proved
satisfied pair (P, N ) N+ .

305

fiBettini, Mascetti & Wang

Definition 7 periodic representation granularity H terms G called minimal
period length P used representation smallest value among period
G ) H periodically groups G.
lengths appearing pairs (PHG , NH
H fully characterized terms G, possible derive composition,
terms G, granule H. Indeed, LP set labels H values
G 1}, assume H unbounded, description arbitrary
{b, . . . , b + NH
G] + 1
granule H(j) obtained following formula. Given j 0 = [(j 1) mod NH

k
k
j
j
b1
b1
G + j0
G + j0 b


N
NH


G
G
H

NH
NH
k=
k

j


b1

+ 1 N G + j 0 otherwise
G
NH

H


H(j) =

[


G

PHG

iSk




k1
j1
G
+ PH
.

G
G
NH
NH


Example 1 Figure 1 shows granularities day week parts i.e., granularity that,
week, contains granule working days granule weekend.
sake simplicity, denote day week parts W respectively. Since
/ W , W fully characterized terms D. Among different possible representations,
= 7, N = 2, LP = {3, 4},
example decide represent W terms PW
W
W
S3 = {8, 9, 10, 11, 12} S4 = {13, 14}. composition granule W
easily computed; example composition W (6) given formula presented
j 0 = 2 k = 4. Hence W (6) = D(7 2 + 13 7 1) D(7 2 + 14 7 1) =
D(20) D(21).

-1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
j

b

k

2

3

4

j

W
1

5

6

7

8

Figure 1: Periodically groups example

3. Calendar Algebra
Several high-level symbolic formalisms proposed represent granularities (Leban
et al., 1986; Niezette & Stevenne, 1992).
work consider formalism proposed Ning et al. (2002) called Calendar
Algebra. approach set algebraic operations defined; operation generates
new granularity manipulating granularities already generated.
relationships operands resulting granularities thus encoded
operations. granularities generated directly indirectly bottom
granularity form calendar, granularities related
306

fiMapping Calendar Expressions Minimal Periodic Sets

operations define them. practice, choices bottom granularity include day,
hour, second, microsecond granularities, depending accuracy required
application context.
following illustrate calendar algebra operations presented Ning et al.
(2002) together restrictions introduced Bettini et al. (2004).
3.1 Grouping-Oriented Operations
calendar algebra consists following two kinds operations: grouping-oriented
operations granule-oriented operations. grouping-oriented operations group
certain granules granularity together form new granules new granularity.
3.1.1 Grouping Operation
Let G full-integer labeled granularity, positive integer. grouping operation
Groupm (G) generates new granularity G0 partitioning granules G m-granule
groups making group granule resulting granularity. precisely, G0 =
Groupm (G) granularity integer i,
im
[

G0 (i) =

G(j).

j=(i1)m+1

example, given granularity day, granularity week generated calendar
algebra expression week = Group7 (day) assume day(1) corresponds Monday,
i.e., first day week.
3.1.2 Altering-tick Operation
Let G1 , G2 full-integer labeled granularities, l, k, integers, G2 partitions
(G , G ) generates new granularity
G1 , 1 l m. altering-tick operation Alterl,k
2
1
periodically expanding shrinking granules G1 terms granules G2 . Since G2
partitions G1 , granule G1 consists contiguous granules G2 . granules
G1 partitioned m-granule groups G1 (1) G1 (m) one group,
G1 (m + 1) G1 (2m) following group, on. goal altering-tick
operation modify granules G1 l-th granule every m-granule group
|k| additional (or fewer k < 0) granules G2 . example, G1 represents
30-day groups (i.e., G1 = Group30 (day)) want add day every 3-rd month
(i.e., make March 31 days), may perform Alter12
3,1 (day, G1 ).
altering-tick operation formally described follows. integer

G1 (i) 6= , let bi ti integers G1 (i) = tj=b
G2 (j) (the integers bi


0
ti exist G2 partitions G1 ). G = Alterl,k (G2 , G1 ) granularity
integer i, let G0 (i) = G1 (i) = , otherwise let
0

0

G (i) =

ti
[
j=b0i

307

G2 (j),

fiBettini, Mascetti & Wang


b0i


=

bi + (h 1) k, = (h 1) + l,
bi + h k,
otherwise,
t0i = ti + h k,




il
+ 1.
h=



Example 2 Figure 2 shows example Alter operation. Granularity G1 defined
G1 = Group5 (G2 ) granularity G0 defined G0 = Alter22,1 (G2 , G1 ), means
shrinking second one every two granules G1 one granule G2 .
G2
-9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21

G1
-1

0

1

2

3

4

G
-

1

0

1

2

3

4

Figure 2: Altering-tick operation example
original definition altering-tick given Ning et al. (2002) reported above,
following problems arbitrary negative value k used: (1) allows
definition G0 full-integer labeled granularity (2) allows
definition G0 even satisfy definition granularity. order avoid
undesired behavior, impose following restriction:
k > (mindist(G1, 2, G2) 1)
mindist() formally defined Bettini et al. (2000).
Intuitively, mindist(G1, 2, G2) represents minimum distance (in terms granules
G2) two consecutive granules G1.
3.1.3 Shift Operation
Let G full-integer labeled granularity, integer. shifting operation
Shiftm (G) generates new granularity G0 shifting labels G positions.
formally, G0 = Shiftm (G) granularity integer i, G0 (i) = G(i m).
Note G0 full-integer labeled.
3.1.4 Combining Operation
Let G1 G2 granularities label sets LG1 LG2 respectively. combining
operation Combine(G1 , G2 ) generates new granularity G0 combining granules
G2 included one granule G1 one granule G0 . formally,
L1 , let s(i) = G1 (i) = , otherwise let s(i) = {j LG2 | =
6 G2 (j) G1 (i)}.

308

fiMapping Calendar Expressions Minimal Periodic Sets

G0 = Combine(G1 , G2 ) granularity
label set LG0 = {i LG1 |s(i) 6= }

LG0 , G0 (i) = js(i) G2 (j).
example, given granularities b-day month, granularity business months
generated b-month = Combine(month, b-day).
3.1.5 Anchored Grouping Operation
Let G1 G2 granularities label sets LG1 LG2 respectively, G2
label-aligned subgranularity G1 , G1 full-integer labeled granularity. anchored
grouping operation Anchored-group(G1 , G2 ) generates new granularity G0 combining
granules G1 two granules G2 one granule G0 .
formally, G0 = Anchored-group(G1 , G2 ) granularity label set LG0 = LG2
0 1
G1 (j) i0 next label G2 i.
LG0 , G0 (i) = ij=i
example, academic year certain university begins last Monday
August, ends day beginning next academic year. Then,
granularity corresponding academic years generated AcademicY ear =
Anchored-group(day, lastMondayOfAugust).
3.2 Granule-Oriented Operations
Differently grouping-oriented operations, granule-oriented operations
modify granules granularity, rather enable selection granules
remain new granularity.
3.2.1 Subset Operation
Let G granularity label set LG , m, n integers n. subset
operation G0 = Subsetnm (G) generates new granularity G0 taking granules
G whose labels n. formally, G0 = Subsetnm (G) granularity
label set LG0 = {i LG | n}, LG0 , G0 (i) = G(i).
example, given granularity year, years 20th century generated
0
20CenturyYear = Subset1999
1900 (year). Note G label-aligned subgranularity G,
G0 full-integer labeled granularity even G is. allow extensions
setting = n = semantics properly extended.
3.2.2 Selecting Operations
selecting operations binary operations. generate new granularities
selecting granules first operand terms relationship granules
second operand. result always label-aligned subgranularity first operand
granularity.
three selecting operations: select-down, select-up select-by-intersect.
facilitate description operations, lk (S) notation used. Intuitively,
set integers, lk (S) selects l elements starting k-th one (for formal
description operator see (Ning et al., 2002)).
Select-down operation. granule G2 (i), exits set granules G1
contained G2 (i). operation Select-downlk (G1 , G2 ), k 6= 0 l > 0
309

fiBettini, Mascetti & Wang

integers, selects granules G1 using lk () set granules (actually labels)
G1 contained one granule G2 . formally, G0 = Select-downlk (G1 , G2 )
granularity label set
LG0 = iLG2 lk ({j LG1 | 6= G1 (j) G2 (i)}),
LG0 , G0 (i) = G1 (i). example, Thanksgiving days fourth
Thursdays Novembers; Thursday November given, generated
Thanksgiving = Select-down14 (Thursday, November).
Select-up operation. select-up operation Select-up(G1 , G2 ) generates new granularity
G0 selecting granules G1 contain one granules G2 . formally,
G0 = Select-up(G1 , G2 ) granularity label set
6 G2 (j) G1 (i)), }
LG0 = {i LG1 |j LG2 ( =
LG0 , G0 (i) = G1 (i). example, given granularities Thanksgiving
week, weeks contain Thanksgiving days defined ThanxWeek =
Select-up(week, Thanksgiving).
Select-by-intersect operation. granule G2 (i), may exist set granules G1 ,
intersecting G2 (i). Select-by-intersectlk (G1 , G2 ) operation, k 6= 0 l > 0
integers, selects granules G1 applying lk () operator sets, generating
new granularity G0 . formally, G0 = Select-by-intersectlk (G1 , G2 ) granularity
label set
LG0 = iLG2 lk ({j LG1 | G1 (j) G2 (i) 6= }),
LG0 , G0 (i) = G1 (i). example, given granularities week month,
granularity consisting first week month (among weeks intersecting
month) generated FirstWeekOfMonth = Select-by-intersect11 (week, month).
3.2.3 Set Operations
order set operations part calendar algebra make certain
computations easier, restrict operand granularities participating set operations
result operation always valid granularity: set operations
defined G1 G2 exists granularity H G1 G2
label-aligned subgranularities H. following, describe union, intersection,
difference operations G1 G2 , assuming satisfy requirement.
Union. union operation G1 G2 generates new granularity G0 collecting
granules G1 G2 . formally, G0 = G1 G2 granularity
label set LG0 = LG1 LG2 , LG0 ,

G1 (i), L1 ,
0
G (i) =
G2 (i), L2 L1 .
example, given granularities Sunday Saturday, granularity weekend days
generated WeekendDay = Sunday Saturday.
310

fiMapping Calendar Expressions Minimal Periodic Sets

Intersection. intersection operation G1 G2 generates new granularity G0 taking
common granules G1 G2 . formally, G0 = G1 G2 granularity
label set LG0 = LG1 LG2 , LG0 , G0 (i) = G1 (i) (or equivalently
G2 (i)).
Difference. difference operation G1 \ G2 generates new granularity G0 excluding
granules G2 G1 . formally, G0 = G1 \ G2 granularity
label set LG0 = LG1 \ LG2 , LG0 , G0 (i) = G1 (i).

4. Calendar Algebra Periodical Set
section first describe overall conversion process report
formulas specific conversion calendar algebra operation. Finally, present
procedure relabeling resulting granularity, sketch complexity analysis
considerations period length minimality.
4.1 Conversion Process
final goal provide correct effective way convert calendar expressions
periodical representations. appropriate limitations, calendar algebra
operation, periodical descriptions operand granularities known, possible
compute periodical characterization resulting granularity.
result allows us calculate, calendar, periodical description
granularity terms bottom granularity. fact, definition, bottom granularity fully characterized; hence possible compute periodical representation
granularities obtained operations applied bottom granularity.
Recursively, periodical description granularities obtained.
calendar algebra presented previous section represent granularities
periodical finite exceptions (i.e., granularity G bottom groups
periodically finite exceptions G). Since periodical representations defined
Section 2 possible express finite exceptions, need restrict calendar
algebra cannot represent them. implies allowing Subset operation
used last step deriving granularity. Note calendar algebra
presented Ning et al. (2002) extension altering-tick operation allow
usage parameter (i.e., G0 = Alter
l,k (G2 , G1 )); resulting granularity
single exception hence periodic. extension disallowed order
generate periodical granularities (without finite exceptions).
conversion process divided three steps: first one period length
period label distance computed; second derive set LP labels one
period, last one composition explicit granules computed.
operation identify correct formulas algorithms three steps.
first step consists computing period length period label distance
resulting granularity. values calculated function parameters (e.g.
grouping factor m, Group operation) operand granularities (actually
period lengths period label distances).

311

fiBettini, Mascetti & Wang

second step conversion process identification label set
resulting granularity. Section 2.4 pointed order fully characterize
granularity sufficient identify labels period granularity. spite
theoretical result, perform computations required operation need
explicit granules operand granularities aligned. two possible
approaches: first one consist computing explicit granules period
recalculate needed granules correct position order eventually align
them. second one consists aligning periods containing explicit granules
fixed granule bottom granularity. considering possibilities,
performance reasons, decided adopt second approach. decided use (1)
alignment point granularities. formal definition used formalism
follows.
Let G granularity smallest positive integer dieG defined.
call lG = dieG LG set labels G contained lG . . . lG +NG 1. Note
definition LG instance definition LP given Section 2.4. definition
LG provided useful representing G actually final goal step
compute LG ; however LG suitable performing computations. problem
G(lG ) starts (1) (i.e., min(blG cG ) < 1) granule G(lG + NG ) begins
PG PG , hence G(lG + NG ) necessary computations; however
lG + NG
/ LG .
solve problem introduce symbol LG represent set labels
granules G cover one (1) . . . (PG ). easily seen G(lG ) cover
(0), LG = LG , otherwise LG = LG {lG + NG }. Therefore conversion
L L vice versa immediate.
notion L still enough perform computations. problem
granularity G used operand operation, period length
resulting granularity G0 generally bigger period length G. Therefore
necessary extend notion LG period length PG0 G0 using PG0 spite
P 0
PG definition L. symbol used notion LGG .
P 0
idea G used operand operation generates G0 , LGG
computed LG . set used formula provide compute
LG0 .
computation LG0 performed follows: G0 defined operation
0 .
returns full-integer labeled granularity, sufficient compute value lG
0
0
0
Indeed easily seen LG0 = {i Z|lG lG + NG0 1}. G defined
algebraic operation, provide formulas compute LG0 ; LG0 easily
derive LG0 .
Example 3 Figure 3 shows granularities , G H; clear PG = PH = 4
NG = NH = 3. Moreover, lG = lH = 6 therefore LG = LH = {6, 7}. Since 0
/ b6cG
H
LG = LG . hand, since 0 b6c , LH = LH {6 + 3}.
P0
Suppose granularity G0 period length PG0 = 8; LGG = {6, 7, 9, 10}
P 0
LHG = {6, 7, 9, 10, 12}.

312

fiMapping Calendar Expressions Minimal Periodic Sets

^

-6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10

G
1

3

4

6

7

9

10

12

H
1

3

4

6

7

9

10

12 13

Figure 3: L, l, L LPG0 examples
third (and last) step conversion process computation composition explicit granules. LG0 computed, sufficient apply,
label LG0 formulas presented Chapter 3.
Sections 4.3 4.10 show, calendar algebra operation, compute
first second conversion steps.
4.2 Computability Issues
formulas presented necessary compute set labels
granularity G G(i) H(j) H granularity j specific label
H. Since LG contains infinite number labels, possible check, LG
G(i) H(j). However easily seen k s.t. G(dkeG ) H(j). Therefore
k s.t. G(dkeG ) defined k bjcH .
Therefore compute set considering labels LG s.t. n bjcH s.t.
dneG = G(i) H(j). Since set bjcH finite3 , computation performed
finite time. consideration analogous set G(i) H(j)
(G(i) H(j) 6= ).
4.3 Group Operation
Proposition 1 G0 = Groupm (G), then:
PG
1. PG0 = GCD(m,N
NG0 =
G)
j
k

lG 1
+
1
;
2. lG0 =


3. LG0 G0 (i) =

NG
GCD(m,NG ) ;

Sim

j=(i1)m+1 G(j).

Example 4 Figure 4 shows example group operation: G0 = Group3 (G). Since
PG = 1 NG = 1, PG0 = 3 NG = 1. Moreover, since LG = {7}, lG = 7
therefore lG0 = 2 LG0 = {2}. Finally G0 (2) = G(8) G(7) G(6) i.e.,
G0 (2) = (0) (1) (2).
3. calendar algebra possible define granularities granules maps
infinite set time instants.

313

fiBettini, Mascetti & Wang

^

-6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

G
-14-13-12-11-10 -9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12

G
-4

-3

-2

-1

0

1

2

3

4

Figure 4: Group operation example
4.4 Altering-tick Operation
Proposition 2 G0 = Alterm
l,k (G2 , G1 ) then:
1.


N

G0

PG2 NG1
NG2
= lcm NG1 , m,
,
GCD(PG2 NG1 , PG1 ) GCD(NG2 m, |k|)




PG0 =

NG0 k
NG0 PG1 NG2
+
NG1 PG2







PG2
NG2

0

2. lG0 = dlG2 eG
G2 ;
3. LG0 G0 (i) =

St0i

j=b0i

G(j) b0i t0i defined Section 3.1.2.

Referring step 2., note computing lG0 explicit characterization
0
granules G0 still unknown. perform operation dlG2 eG
G2 need know least
explicit granules one periods. choose compute granules labeled
1 . . . NG0 . lG0 derived, granules labeled lG0 . . . lG0 + NG0 1 computed
explicit granules aligned (1) required.
Example 5 Figure 5 shows example altering-tick operation: G0 = Alter32,1 (G2 , G1 ).
Since PG1 = 4, NG1 = 1, PG2 = 4 NG2 = 2, NG0 = 6 PG0 = 28.
G0 = 4
Moreover, since LG2 = {10, 9}, lG2 = 10 therefore lG0 = d10eG
2
hence LG2 = {4, 3, . . . , 0, 1}. Finally G0 (4) = G1 (11) G1 (10) G1 (9) =
(1) (0) (1) (3) (4); analogously derive G0 (3), G0 (2), G0 (1), G0 (0)
G0 (1).

4.5 Shift Operation
Proposition 3 G0 = Shiftm (G), then:
1. PG0 = PG1 NG0 = NG1 ;
2. lG0 = lG + m;
3. LG0 G0 (i) = G(i m).
314

fiMapping Calendar Expressions Minimal Periodic Sets

^

-3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41

G1
-5

-4

-3

-2

-1

0

1

2

3

4

5

G2
-11 -10

-9

-8

-7

-6

-5

-4

-3

-2

-1

0

1

2

3

4

5

6

7

8

9

10

G
-4

-3

-2

-1

0

1

2

3

4

Figure 5: Alter operation example
Example 6 shifting operation easily model time differences. Suppose granularity
USEast-Hour stands hours US Eastern Time. Since hours US Pacific
Time 3 hours later US Eastern Time, hours US Pacific Time
generated USPacific-Hour= Shift3 (USEast-Hour).
USEast-Hour
-6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8

USPacific-Hour
-9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5

Figure 6: Shift operation example

4.6 Combining Operation
Proposition 4 Given G0 = Combining(G1 , G2 ), then:
1. PG0 = lcm(PG1 , PG2 ) NG0 =
P

0

P

lcm(PG1 ,PG2 )NG1
;
PG1
P

0

0

2. LGG1 let se(i) = {j LGG2 | =
6 G2 (j) G1 (i)}; LG0 = {i LGG1 |e
s(i) 6= };

3. LG0 G0 (i) = js(i) G2 (j).
Example 7 Figure 7 shows example combining operation: G0 = Combine(G1 , G2 ).
Since PG1 = 6, NG1 = 2, PG2 = 4 NG2 = 2, PG0 = 12 NG0 = 4. Moreover,
P 0
since LG1 = {1} 0 b1cG1 , LG1 = {1, 3} hence LGG1 = {1, 3, 5}. Since
0
s(i) 6= {1, 3, 5}, LG0 = {1, 3, 5}; moreover, since 0 b1cG , LG0 = {1, 3}.
Finally s(1) = {1, 0} s(3) = {2, 3}; consequently, G0 (1) = G2 (1) G2 (0) i.e.,
G0 (1) = (1) (0) (1) G0 (3) = G2 (2) G2 (3) i.e., G0 (3) = (4) (5) (7).

4.7 Anchored Grouping Operation
Proposition 5 Given G0 = Anchored-group(G1 , G2 ), then:
1. PG0 = lcm(PG1 , PG2 ) NG0 =

lcm(PG1 ,PG2 )NG2
;
PG2

315

fiBettini, Mascetti & Wang

^

-6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

G1
1

3

5

7

G2
-3

-2

-1

0

1

2

3

4

5

6

7

8

9

G
1

3

5

7

Figure 7: Combine operation example
2.
(
LG0 =

P

0

LGG2 ,
lG2 = lG1 ,
PG0
0
{lG2 } LG2 , otherwise,

0
lG
greatest among labels LG2 smaller lG2 .
2

3. LG0 G0 (i) =

Si0 1
j=i

G1 (j) i0 next label G2 i.

Example 8 Figure 8 shows example anchored grouping operation: USweek
(i.e., week starting Sunday) defined operation Anchored-group(day,
Sunday). Since Pday = 1 PSunday = 7, period length USweek 7. MorePUSweek
since lday = 11, lSunday = 14 LSunday
= {14}, LUSweek = {7} {14}.

Clearly, since 0 b7cUSweek LUSweek = {7}. Finally, USweek(7) = 13
j=7 day(j) =
S3
k=3 (k).

^

-18-17-16-15-14-13-12-11-10 -9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12

day
-8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22

Sunday
-7

0

7

14

21

USweek
-7

0

7

14

Figure 8: Anchored Grouping operation example

4.8 Subset Operation
Subset operation modifies operand granularity introducing bounds.
period length, period label distance, L composition explicit granules
affected.

316

fiMapping Calendar Expressions Minimal Periodic Sets

4.9 Selecting Operations
4.9.1 Select-down Operation
Proposition 6 Given G0 = Select-downlk (G1 , G2 ), then:
1. PG0 = lcm(PG1 , PG2 ) NG0 =
2. LG2 let

lcm(PG1 ,PG2 )NG1
;
PG1

6 G1 (j) G2 (i)}) .
A(i) = lk ({j LG1 | =




[ n
P 0
A(i)|a LGG1 ;

LG0 =

P 0

iLGG
2

3. LG0 G0 (i) = G1 (i).
Example 9 Figure 9 shows example Select-down operation granularity
G0 defined as: G0 = Select-down12 (G1 , G2 ). Since PG1 = 4, NG1 = 2 PG2 = 6
PG0 = 12 NG0 = 6. Moreover, since LG2 = {3} 0 b3cG2 , LG2 =
P 0
{3, 2} LGG2 = {3, 2, 1}. Intuitively, A(3) = {5}, A(2) = {2}
0
A(1) = {1}. Hence LG0 = {5, 2, 1} therefore, since 0 b5cG , LG0 = {5, 2}.
Finally G0 (5) = G1 (5) = (0) (1) G0 (2) = G1 (2) = (6).
^

-9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25

G1
-9

-8

-7

-6

-5

-4

-3

-2

-1

0

1

2

3

4

5

6

7

G2
-4

-3

-2

-1

0

1

G
-8

-5

-2

1

4

Figure 9: Select-down operation example

4.9.2 Select-up Operation
Proposition 7 Given G0 = Select-up(G1 , G2 ), then:
1. PG0 = lcm(PG1 , PG2 ) NG0 =

lcm(PG1 ,PG2 )NG1
;
PG1

2.
P

0

LG0 = {i LGG1 |j LG2 s.t. =
6 G2 (j) G1 (i)};
3. LG0 G0 (i) = G1 (i).

317

7

fiBettini, Mascetti & Wang

Example 10 Figure 10 shows example Select-up operation: G0 = Select-up(G1 , G2 ).
Since PG1 = 6, NG1 = 3 PG2 = 4 PG0 = 12 NG0 = 6. Moreover, since LG1 =
P0

{3, 2, 1} 0 b3cG2 , LG1 = {3, 2, 1, 0} LGG1 = {3, 2, 1, 0, 1, 2, 3}.
Since G1 (3) G2 (6), G1 (1) G2 (4) G1 (3) G2 (0) LG0 = {3, 1, 3}
0
and, since 0 b3cG , LG0 = {3, 1} Finally G0 (3) = G1 (3) = (0) (1)
G0 (1) = G1 (1) = (4).
^

-9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16

G1
-8 -7

-6

-5 -4

-3

-2 -1

0

1 2

3

4 5

G2
-10

-8

-6

-4

-2

0

2

G
-7

-3

-1

3

5

Figure 10: Select-up operation example

4.9.3 Select-by-intersect Operation
Proposition 8 Given G0 = Select-by-intersectlk (G1 , G2 ), then:
1. PG0 = lcm(PG1 , PG2 ) NG0 =

lcm(PG1 ,PG2 )NG1
;
PG1

2. LG2 let
A(i) = lk ({j LG1 |G1 (j) G2 (i) 6= }) .

LG0 =


[ n
P 0
A(i)|a LGG1 .
P 0

iLGG
2

3. LG0 G0 (i) = G1 (i).
Example 11 Figure 11 shows example Select-by-intersect operation
G0 = Select-by-intersect12 (G1 , G2 ). Since PG1 = 4, NG1 = 2 PG2 = 6 PG0 = 12
NG0 = 6. Moreover, since LG2 = {3} 0 b3cG2 , LG2 = {3, 2}
P 0
LGG2 = {3, 2, 1}. Intuitively, A(3) = {6}, A(2) = {2} A(1) = {0}. Hence
0
LG0 = {2, 0} therefore, since 0
/ b5cG , LG0 = {2, 0}. Finally G0 (2) =
G1 (2) = (6) G0 (0) = G1 (0) = (10).

318

fiMapping Calendar Expressions Minimal Periodic Sets

^

-9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25

G1
-9

-8

-7

-6

-5

-4

-3

-2

-1

0

1

2

3

4

5

6

7

G2
-4

-3

-2

-1

0

1

G
-8

-6

-2

0

4

6

Figure 11: Select-by-intersect operation example
4.10 Set Operations
Since set operation valid granularities used argument labeled aligned
granularity another granularity, following property used.
Proposition 9 G labeled aligned subgranularity H,

NG
PG

=

NH
PH .

Proposition 10 Given G0 = G1 G2 , G00 = G1 G2 G000 = G1 \ G2 , then:
1. PG0 = PG00 = PG000 = lcm(PG1 , PG2 )
lcm(PG1 ,PG2 )NG1
=
NG0 = NG00 = NG000 =
PG
1

P

0

P

0

P

00

P

lcm(PG1 ,PG2 )NG2
;
PG2

00

P

000

P

000

2. LG0 = LGG1 LGG2 ; LG00 = LGG1 LGG2 ; LG000 = LGG1 \ LGG2 ;

G1 (i), LG1
0
3. LG0 G (i) =
G2 (i), otherwise,
LG00 G00 (i) = G1 (i) LG000 G000 (i) = G1 (i)
Example 12 Figure 12 shows example set operations. Note G1
G2 labeled aligned subgranularities H. G0 = G1 G2 , G00 = G1 G2
G000 = G1 \ G2 . Since PG1 = PG2 = 6 NG1 = NG2 = 6 PG0 = PG00 = PG000 = 6
NG0 = NG00 = NG000 = 2. Moreover, since LG1 = {1, 2} LG2 = {2, 3},
LG0 = {1, 2, 3}, LG00 = {2} LG000 = {1}. Finally G0 (1) = G1 (1), G0 (2) = G1 (2)
G0 (3) = G2 (3); G00 (2) = G1 (2) G000 (1) = G1 (1).

4.11 Relabeling
Granularity processing algorithms much simpler restricted operate full-integer
labeled granularities. Moreover, simplification obtained using positive integers set labels (i.e., L = Z+ ).
section show relabel granularity G obtain full-integer labeled
granularity G0 . granularity G00 LG00 = Z+ obtained using G00 =
0
Subset
1 (G )
Note relabeling process information lost: example, G
labeled aligned subgranularity H G 6= H, then, relabeling, G
319

fiBettini, Mascetti & Wang

^

-9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25

H
-3

-2

-1

-2

-1

0

1

2

1

2

3

4

5

4

5

6

7

8

7

8

9

10

G1
10

G2
-3

-1

0

-1

0

2

3

2

3

5

6

5

6

8

9

8

9

G
-3

-2

1

4

7

10

G
-1

2

5

8

G
-2

1

4

7

10

Figure 12: Set operations example
labeled aligned subgranularity H. lost information semantically meaningful
calendar algebra, therefore relabeling must performed granularity
used operator algebraic operation.
Let G labeled granularity, j integers LG s.t. G(i) 6= .
relabeling operation Relabelji (G) generates full-integer labeled granularity G0 relabeling
G(i) G0 (j) relabel next (and previous) granule G next (and previous,
respectively) integer. formally, integer k, k = j, let G0 (k) = G(i),
otherwise let G0 (k) = G(i0 ) G(i0 ) |j k|-th granule G (before,
respectively) G(i). required |j k|-th granule G exist, let G0 (k) = .
Note G0 always full-integer labeled granularity.
relabeling procedure implemented periodic representation adopted
computing value lG0 . easily seen lG0 known, full characterization G0 obtained with: PG0 = PG ; NG0 = RG0 = RG LG0 =
{lG0 , lG0 + 1, . . . , lG0 + NG0 2, lG0 + NG0 1}. clear explicit representation
granules modified.
j
k
ilG
0
0
compute lG consider label = NG NG ; i0 represents label LG
i0 multiple NG . jTherefore
clear label j 0 LG0 s.t. G0 (j 0 ) = G(i0 )
k
G
computed j 0 = j il
NG0 . Finally lG0 obtained lG0 = j 0 ||
NG
distance, terms number granules G, G(lG ) G(i0 ).
4
Example 13 Figure 13 shows example Relabel operation: G0 = Relabel
33 (G).
336
0
Since PG = 4and R
= 33
5 = 8
5
G = 2 PG0 = 4 NG0 0 = 2. Moreover,
0 ) next granule G
j 0 = 4 336

2
=
6.
Since
l
=
6


=
8

G(i
G
5
G(lG ). = 1 hence lG0 = 6 1 = 7. follows LG0 = {7, 6}.
Finally G0 (7) = G(6) G0 (6) = G(8).

GSTP constraint solver imposes first non-empty granule granularity
( included) labeled 1. Therefore, using relabeling operation producing
320

fiMapping Calendar Expressions Minimal Periodic Sets

Figure 13: Relabeling example
granularities GSTP, parameter j must set 1. parameter equal
smallest label among identify granules G covering granules
labeled positive values. definition lG , = lG min(blG cG ) > 0; otherwise
next label G lG .
4.12 Complexity Issues
operation time necessary perform three conversion steps, depends
operation parameters (e.g. grouping factor m, Group operation)
operand granularities (in particular period length, period label distance
number granules one period).
central issue operand granularity bottom granularity,
period function periods granularities operands operation
defines it. algebraic operations, worst case period
resulting granularity product periods operands granularity.
operations, first step conversion process performed
constant logarithmic time. Indeed formulas necessary derive period length
period label distance involve (i) standard arithmetic operations, (ii) computation
Greatest Common Divisor (iii) computation least common multiple. Part
(i) computed constant time (ii) (iii) computed logarithmic
time using Euclids algorithm.
operations, second step performed constant time (e.g. Group,
Shift Anchored-group) linear time (e.g. set operations). operations
necessary compute set labels granularity G G(i) H(j)
H granularity j LH (analogously set G(i)
H(j) (G(i) H(j) 6= )). computation needs performed
P 0
granule PHG . idea algorithm solving problem presented
Section 4.2. Several optimizations applied algorithm, worst
case (when H covers entire time domain) necessary perform number deG
operations linear period length resulting granularity. optimized data
structure used represent granularities, deG operation performed
constant time 4 , time necessary perform second step linear period
length resulting granularity (O(PG0 )).
last step conversion process performed linear time respect
number granules period G0 .
4. non-optimized data structure used, deG requires logarithmic time.

321

fiBettini, Mascetti & Wang

complexity analysis conversion general algebraic expression needs
consider composition operations hence complexity. Finally, relabeling,
done linear time.
detailed complexity analysis scope work.

5. Minimal Representation Experimental Results
section address problem guaranteeing converted representation
minimal terms period length. show Example 14 conversion
formulas proposed paper guarantee minimal representation result
clear conversion formulas ensuring minimality exist. approach apply
minimization step conversion.
practical applicability minimization step depends period length
representation minimized. Indeed, tests noted minimization
step efficient conversion formulas proposed Section 4 adopted,
impractical conversion procedure returns period orders magnitude
higher minimal one would case conversion formulas constructed
naive way.
5.1 Period Length Minimization
stated Section 2, granularity different periodical representations and,
given granularity, possible identify set representations minimal
i.e. adopting smallest period length.
Unfortunately, conversions always return minimal representation, shown
Example 14.
Example 14 Consider calendar day bottom granularity. define
week week = Group7 (day); applying formulas Group operation obtain
Pweek = 7 Nweek = 1.
apply Altering-tick operation add one day every first week every
two weeks. Let granularity G1 = Alter21,1 (day, week); applying formulas
Altering-tick operation obtain PG1 = 15 NG1 = 2.
apply Altering-tick operation create granularity G2 removing
one day every first granule G1 every two granules G1 : G2 = Alter21,1 (day, G1 ).
Intuitively, applying operation get back granularity week, however
using formulas Altering-tick operation obtain PG2 = 14 NG2 = 2; Hence
G2 minimal.
order qualitatively evaluate close minimal representations results
conversions are, performed set tests using algorithm (Bettini & Mascetti,
2005) minimality checking. experimental results conversions algebraic
expressions defining granularities real-world calendars, including many user-defined nonstandard ones, always returned exactly minimal representations. Non-minimal ones could
obtained artificial examples one presented Example 14.
Although non-minimal result unlikely practical calendars, minimality
granularity representation known greatly affect performance algorithms
322

fiMapping Calendar Expressions Minimal Periodic Sets

granularity processing, e.g., granularity constraint processing (Bettini et al., 2002a), calendar calculations (Urgun et al., 2007), workflow temporal support (Combi & Pozzi, 2003).
Hence, considered extension conversion algorithm adding minimization
step exploiting technique illustrated Bettini et al. (2005) derive minimal representation.
choice using conversion algorithm extended one minimizations, probably driven performance considerations. Section 5.3 report
results experiments showing generally advantageous apply minimization step. implementation, presented Section 5.2, possible specify
minimization step performed.
5.2 Implementation CalendarConverter Web Service
conversion formulas presented Section 4 implemented CalendarConverter web service converts Calendar Algebra representations equivalent
periodical ones. precisely, given calendar granularities expressed Calendar Algebra operations, service converts operation equivalent periodical
representation.
service first rewrites calendar algebra expression order express
terms bottom granularity. example, bottom granularity hour,
expression Monday = Select-down11 (day, week) changed
Monday = Select-down11 (Group24 (hour), Group7 (Group24 (hour)))
Then, Procedure 1 run granularitys expression. idea periodical
representation subexpression recursively computed starting expressions
bottom granularity operand. operand given operation
converted periodical representation, corresponding formula presented Section 4
applied. call step ConvertOperation procedure.
trivial optimization Procedure 1 consists caching results conversions
subexpression computed once, even subexpression appears
several times (like Group24 (hour) Monday definition).
5.3 Experimental Results
experiments address two main issues: first, evaluate conversion formulas
impact practical applicability conversion procedure and, second, evaluate
useful minimization step.
first issue, execute conversion procedure two different sets conversion formulas compare results. first set laid Section 4. other,
less optimized, taken preliminary version paper (Bettini et al.,
2004).
Table 1 shows converting calendars granularities small minimal
period length (first two rows), using formulas Section 4 improves performance
one order magnitude; However, conversions minimizations almost instantaneous approaches. contrary, minimal period length higher,
323

fiBettini, Mascetti & Wang

Procedure 1 ConvertExpression
Input: calendar algebra expression ex; boolean value minimize set
true minimization step executed;
Output: periodical representation ex;
Method:
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:

(ex bottom granularity)
return periodical representation bottom granularity
end
operands :=
(each operand op ex)
add ConvertExpression(op, minimize) operands;
end
result :=ConvertOperation(ex.getOperator(), operands)
(minimize)
minimize periodical representation result
end
return result;

Table 1: Impact conversion formulas performance conversion minimization procedures (time milliseconds).

Calendar
Period
Bot
1 year
day
4 years
day
1 year
hour
4 years
hour
100 years day

Section 4 formulas
Conv. Min. Tot.
4
2
6
7
2
9
9
2
11
16
4
20
127
9 136

Less optimized formulas
Conv.
Min.
Tot.
62
32
94
76
55
131
2,244
126,904
129,148
4,362
908,504
912,866
3,764 1,434,524 1,438,288

(last three rows) time required minimize periodical representation five
orders magnitude larger formulas proposed Bettini et al. (2004) used;
consequence, entire conversion may require several minutes while, using formulas
presented Section 4, still requires fraction second. period length
even larger, conversion procedure impractical formulas presented Bettini et
al. (2004) used, indeed experiments obtain result less
thirteen hours.
second issue, perform set three experiments. first one compare
performance conversion procedure performance minimization step.

324

fiMapping Calendar Expressions Minimal Periodic Sets

experiment consider case conversion procedure produces minimal
representations. case minimization step always overhead since cannot
improve performance conversion procedure.
Figure 14 shows result experiment. Four calendars considered, one
containing set granularities Gregorian calendar. four calendars differs
values two parameters: bottom granularity (it second cal-1 cal-3
minute cal-2 cal-4) period leap years leap years exceptions
represented (it 1, 4, 100 400 years cal-1, cal-3, cal-2 cal-4 respectively);
consequence, minimal period length granularities month year
3 107 cal-1, 5 107 cal-2, 108 cal-3 2 108 cal-4.

Figure 14: Impact minimization conversion; minimal conversions case.
observed Figure 14, ratio time required perform
conversions time required minimization step varies significantly
minimum 3% cal-4 maximum 23% cal-3. reason complexity
conversion procedure mainly affected period length granularity
largest period length. hand, complexity minimization step
affected features granularities internal structure
number integers divide time period label distance, period
length number granules one period; details see (Bettini & Mascetti,
2005).
second experiment consider case conversion procedure produces non-minimal representation granularity input calendar; case
possible benefit minimization step. example, suppose granularity G
converted used argument another Calendar Algebra operation
defines granularity H. time required compute periodical representation
H strongly depends period length G; period length G reduced
execution minimization step, conversion H executed faster.
produced situation using technique similar one Example 14;
created Calendar Algebra definitions Gregorian calendar granularity
day converted granularity non-minimal representation. Figure 15 shows
performance obtained converting granularities used Figure 14.
325

fiBettini, Mascetti & Wang

difference case definition granularity day that,
conversion procedure, period twice large minimal one (i.e., 48 hours
2880 minutes 172800 seconds depending bottom granularity used).
easily seen case use minimization step improve performance
entire algorithm. Indeed, minimization step performed, conversion
procedure requires one half time required minimization
performed.

Figure 15: Impact minimization conversion; non-minimal case.
third experiment evaluate impact minimal representation
performance applications involving intensive manipulations granularities. test
use GSTP solver application; computes solutions temporal constraints
granularities. description architecture GSTP system provided
Section 6.1.
Figure 16 shows experiments performed four temporal constraint networks
granularities. four networks differs number variables, number constraints granularities used express constraints. networks labeled
non-minimal use granularities definitions obtained technique similar
one used Example 14, period twice large minimal one.
Figure 16 shows use minimal representations greatly improves performance GSTP solver. Indeed experiments ratio time required
solve network using non-minimal representation minimal one
three five. Moreover, time required solve network, greater
improvement obtained using minimal representation; means complex
temporal networks expect improvement even higher.
Considering results experiments, conclude that, general, advisable
perform minimization step. particular, advantageous specific case
GSTP, based following considerations: i) time required perform minimization step fraction time required perform conversion procedure, ii)
conversions performed off-line cases, respect granularity processing,
conversion results cached future use, iii) period length strongly influ-

326

fiMapping Calendar Expressions Minimal Periodic Sets

Figure 16: Impact minimal representations performance GSTP solver.
ences GSTP processing time cases much longer time needed
conversion.

6. Applications
section complement motivations work sketch applications
enabled proposed conversion. Firstly describe GSTP system, example
applications involving intensive manipulation time granularities. GSTP used
check consistency find solutions temporal constraint satisfaction problems
granularities5 ; applied check consistency inter-organizational
workflow models (Bettini, Wang, & Jajodia, 2002b). Then, discuss use Calendar
Algebra define new granularities may later part input reasoning services,
GSTP.
6.1 GSTP System
GSTP system developed University Milan objective
providing universal access implementation set algorithms multi-granularity
temporal constraint satisfaction (Bettini et al., 2002a). allows user specify binary
constraints form X [m, n]G n minimum maximum
values distance X terms granularity G. Variables take values
positive integers, unary constraints applied domains. example,
constraint: Event2 occur 2 4 business days occurrence Event1
modeled OccE2 OccE1 [2, 4]BDay. problem considered extension STP
(Dechter, Meiri, & Pearl, 1991) multiple arbitrary granularities. knowledge,
GSTP available system solve class temporal constraint satisfaction
problems.
Figure 17 shows general architecture GSTP system. three main
modules: constraint solver; web service, enables external access solver;
5. detailed description system, see (Bettini et al., 2005).

327

fiBettini, Mascetti & Wang

user interface used locally remotely design analyze constraint
networks.

Figure 17: GSTP Architecture
constraint solver C implementation ACG algorithm
proposed Bettini et al. (2002a), runs server machine. Following approach Bettini et al. (2002a), solver uses representation granularities based
periodical sets. representation makes possible efficiently compute core operations granularities required solve constraint satisfaction problem.
operations involve, example, union intersection periodical sets.
cannot exclude operations may computed terms alternative low level
representations, seems much harder obtain similar results high level representation,
Calendar Algebra, used.
second module system Web Service defines, WSDL
specification, parameters passed constraint solver, including
XML schema constraint network specification.
third module remote Java-based user interface, allows user easily
edit constraint networks, submit constraint solver, analyze results.
particular, possible views terms specific granularities, visualize implicit
constraints, browse descriptions domains, obtain network solution. Fig. 18
shows screenshot interface.
6.2 Defining New Granularities
GSTP solver handle arbitrary granularities, new granularities must added
editing explicit periodical representation. true general multi328

fiMapping Calendar Expressions Minimal Periodic Sets

Figure 18: GSTP User Interface
granularity reasoning service based low-level representation granularities,
painful task granularities large period. example, experimental
results illustrated Figure 16, used representation granularity month
considers leap years leap years exceptions period 400 years. case,
users specify representation 4800 granules i.e., number months 400
years.
period length real world granularities generally high, graphical interface help supports user individually select explicit granules.
effective solution requires use implicit explicit operations granules. Among
various proposals, Calendar Algebra provides richest set operators. question
arises: definition granularities terms Calendar Algebra really simpler
specification periodical representation? Calendar Algebra seem user
friendly: exact semantics operator may immediate inexperienced
user time required order learn use operator.
practice, think reasonable ask unexperienced user
define granularities writing Calendar Algebra expressions. Nevertheless, think
Calendar Algebra used specialized user interfaces guide user
specifying granularities. sense, believe Calendar Algebra plays
role SQL definition databases queries. Similarly Calendar Algebra,
SQL abstraction tool directly exploited expressive power
advanced user, used less experienced user graphical user
interface, possibly reduced expressiveness.
mentioned above, case periodical representations, graphical user interfaces
sufficient making specification new granularities practical. contrary, case Calendar Algebra, user interfaces strongly enhance usability
Calendar Algebra, making practical use possible definition involved
granularities. least two reasons difference. Firstly, main difficulty
Calendar Algebra understanding semantics operators choice
appropriate one given task. effective user interface hide existence algebraic operators user showing operators modify existing

329

fiBettini, Mascetti & Wang

(a) Step 1.

(b) Step 2.

(c) Step 3.

Figure 19: 3-steps wizard visually defining granularity using Calendar Algebra
granularities (i.e., semantics operators). Secondarily, Calendar Algebra allows
compact definition granularities. due fact Calendar Algebra
operations specifically designed reflect intuitive ways users define new
granularities.
Example 15 shows graphical user interface effectively used define new
granularity terms Calendar Algebra expression.
Example 15 example shows graphical user interface used support
user definition granularity final set days, one corresponding
330

fiMapping Calendar Expressions Minimal Periodic Sets

last Monday every academic semester. assume granularities Monday
academicSemester already defined. graphical user interface use
example wizard guides user step step. first step (Figure 19(a))
user chooses kind operation wants perform. second step (Figure 19(b))
user provide details wants modify operand granularity
(Monday, example). results choice Calendar Algebra expression
shown third step (Figure 19(c)); last window user give name
granularity defined.
6.3 Global Architecture

Figure 20: Integration GSTP CalendarConverter web services
Figure 20 shows possible architecture integration GSTP, interface
new granularity definitions CalendarConverter web service. granularity repository
collects Calendar Algebra definitions. Upon request GSTP system definitions
converted low-level representation CalendarConverter web service efficiently
processed. Clearly, caching techniques used optimize process.

7. Related Work
Several formalisms proposed symbolic representation granularities
periodicity. Periodicity application AI DB area extensively
investigated (Tuzhilin & Clifford, 1995; Morris, Shoaff, & Khatib, 1996; Kabanza, Stevenne,
& Wolper, 1990; Ladkin, 1986). Regarding symbolic representation, well known
formalism proposed Leban et al. (1986), based notion collection,
intended represent temporal expressions occurring natural language. collection
structured set time intervals order collection gives measure
structure depth: order 1 collection ordered list intervals, order n
(n > 1) collection ordered list collections order n 1. Two operators,
331

fiBettini, Mascetti & Wang

called slicing dicing used operate collections selecting specific intervals
sub-collections, dividing interval collection, respectively.
example, Weeks:during:January2006 divides interval corresponding January2006
intervals corresponding weeks fully contained month.
formalism adopted extensions many researchers AI (Koomen,
1991; Cukierman & Delgrande, 1998) Database area (Chandra, Segev, & Stonebraker,
1994; Terenziani, 2003). particular, control statements if-then-else
introduced Chandra et al. (1994) facilitate representation certain
sets intervals. example, possible specify: fourth Saturday April
holiday, previous business day otherwise.
deductive database community, second influential proposal slice
formalism introduced Niezette et al. (1992). slice denotes (finite infinite) set
necessarily consecutive time intervals. example, slice all.Years + {2,4}.Months
+ {1}.Days . 2.Days denotes set intervals corresponding first 2 days February
April year.
totally different approach calendar algebra described Ning et al. (2002),
considered paper. representation based rich set algebraic operators
periodic sets opposed slicing dicing nonconvex intervals.
None cited papers provide mapping identify operator changes
mathematical characterization periodicity argument expressions.
problem finding mappings trivial operators.
(Bettini & Sibi, 2000) expressive power algebras proposed Leban et
al. (1986) Niezette et al. (1992) compared extension first proposed
order capture larger set granularities. Since periodical representation
used compare expressiveness, mapping calendar expressions formalisms
periodical representations found proofs paper. However, since
minimality issue purpose comparing expressiveness, many cases
mapping returns non-minimal representations.
Regarding alternative approaches low-level representation, already mentioned
ones based strings (Wijsen, 2000) automata (Dal Lago, Montanari, &
Puppis, 2003; Bresolin et al., 2004) may considered alternative target
conversion. matter fact, example conversion Calendar Algebra
expression string based representation found (Dal Lago & Montanari,
2001). complete conversion procedure appeared revision process paper
PhD Dissertation Puppis (2006). aim conversion prove
granspecs formalism, used represent granularities terms automata, least
expressiveness Calendar Algebra. Hence, obtaining minimal representations
goal. Moreover, case minimization terms period length,
terms automaton size automaton complexity. complexity reasoning,
given automaton , worst case time complexity operations analogous
depends linearly ||M ||, value computed called complexity
. sense ||M || role period length (P ), even precise
relationship two values hard obtain. approach compute
logarithmic time respect P linear time respect dimension
result (that bounded P ). operations, checking equivalence, seem
332

fiMapping Calendar Expressions Minimal Periodic Sets

complex using automata (Bresolin et al., 2004). Techniques minimization
terms automaton complexity presented Dal Lago et al. (2003), time
complexity proved polynomial, even exact bound explicitly given.
3
approach, worst case time complexity minimization O(P 2 ) (Bettini &
Mascetti, 2005). Overall, automata approach elegant well-founded, but,
one side still misses implementation order experimental data
compare with, side basic operations currently defined;
would interesting investigate definition formalism complex
operations ones required GSTP.

8. Conclusion Future Work
presented hybrid algorithm interleaves conversion Calendar Algebra
subexpressions periodical sets minimization period length.
proved algorithm returns set-based granularity representations minimal
period length, extremely important efficiency operations granularities. Based technical contribution paper, software system developed
allowing users access multi-granularity reasoning services defining arbitrary time granularities high-level formalism. current efforts mainly devoted completing
refining development different modules architecture shown Section 6.3.
future work, intend develop effective graphical user interfaces support
definition Calendar Algebra expressions user friendly way. Example 15 described one
possible interfaces. Another open issue convert periodical representation
granularity user friendly Calendar Algebra expression. conversion could
useful, example, present result computation performed using periodical
representation. However, naive conversion may effective since resulting calendar
algebra expression could involved periodical representation
derived. example, conversion procedure presented Bettini et al. (2000) prove
Calendar Algebra least expressive periodical representation; however,
resulting Calendar Algebra expression composed number Calendar Algebra
operations linear number granules one period original
granularity. contrary, effective conversion generate Calendar Algebra
expressions compact easily readable user. problem somehow
related discovery calendar-based association rules (Li, Ning, Wang, & Jajodia,
2001). Finally, intend investigate usage automaton-based representation
low-level granularity formalism. would interesting know whether, using
representation, possible compute operations computed
periodical representation performance gain could achieved.

Acknowledgments
thank anonymous referees useful comments suggestions. work
Bettini Mascetti partially supported Italian MIUR InterLink project N.II04C0EC1D.
work Wang partially supported US NSF grant IIS-0415023.

333

fiBettini, Mascetti & Wang

Appendix A. Proofs
A.1 Transitivity Periodically Groups Relationship
order prove correctness conversions algebraic expressions periodical
sets, useful formal result transitivity periodically groups
relation. addition transitivity / , Theorem 1 says something period
length values.
Theorem 1 Let G H two unbounded granularities G periodic terms
bottom granularity (i.e., / G) H periodic terms G (i.e., G / H). Let
G period length period label distance H terms granules
PHG NH
G, NG period label distance G terms . Then, PHG = NG
positive integer , H periodic terms bottom granularity (i.e., / H)
PH = PG .
G

Proof. Since
Sni hypothesis G / H PH = NG , H(i) =
G
NH ) = r=0 G(ir + NG ). written follows:


Sni

r=0 G(ir ),

H(i +

H(i) = G(i0 ) ... G(ini )

(1)

G
H(i + NH
) = G(i0 + NG ) ... G(ini + NG )

(2)

Ns.t.:

Since / G,


G(ij ) =

ij
[

(ij,k )

(3)

(ij,k + PG )

(4)

k=0




G(ij + NG ) =

ij
[

k=0

clearly extended using NG instead NG .


G(ij + NG ) =

ij
[

(ij,k + PG )

(5)

k=0

Rewriting (1) substituting G(ij ) according (3) rewriting (2) substituting G(ij +
NG ) according (5), obtain:
H(i) = (i0,0 ) . . . (i0,i0 ) . . . (ini ,0 ) ... (ini ,in )

|
{z
}
|
{z
}
G(i0 )

G(ini )

334

fiMapping Calendar Expressions Minimal Periodic Sets

G ) = (i
H(i + NH
0,0 + PG ) . . . (i0,i0 + PG ) . . .
{z
}
|
G(i0 +NG )

(ini ,0 + PG ) . . . (ini ,in + PG )

|
{z
}
G(ini +NG )

Hence second condition Definition 5 satisfied. third one always satisfied
unbounded granularities. first one satisfied too; fact since G / H period
G , label H, + N G label H. Hence, definition
label distance NH
H
G.
periodically-groups-into / H PH = PG NH = NH

A.2 Proof Proposition 1
A.2.1 Part 1
definition Group operation, N:
0

G (i) =

im
[

G(j) = G(im + 1) . . . G(im) = G() . . . G( + 1)

j=(i1)m+1

= im + 1. Furthermore, k N:
(i+k)m

[

0

G (i + k) =

G(j) = G(im + km + 1) . . . G(im + km) =

j=(i+k1)m+1

= G( + km) . . . G( + km + 1)
Hence,
0

0

G (i ) =

m1
[

0

m1
[

0

G( + r) G (i + k) =

r=0

G( + r + km).

(6)

r=0

G
holds k. use k = GCMN(m,N
(note k N), hypotheses
G)
Theorem 1 satisfied: (i) / G (by hypothesis); (ii) G / G0 (since G / G0 , LG0 = Z,
mNG
NG
(6) holds); (iii) PGG0 = GCM
(m,NG ) (since use k = GCM (m,NG ) and, (6)

know PGG0 = km). Therefore, Theorem 1, / G0 PG0 =
NG0 =

mPG
GCM (m,NG )

NG
GCM (mNG ) .

A.2.2 Part 2
definition Group

j

k

j

G0





lG 1
+1

0
operation, G (i) =

definition l, need show G0



lG 1
+1




lG 1


k
+1

[

=
j=

335


= tj=b G(j) b lG t.
Sim
j=(i1)m+1 G(i) ; hence:

j

lG 1


k
m+1

G(j)



fiBettini, Mascetti & Wang

prove thesis showing (1)
lG .
(1) Since

j

lG 1


k



lG 1
,

j

lG 1


lG 1
G
lm

lG 1[(lG 1)mod m]
G
lm
1;


(2) First prove
prove

hence
k
j

j

lG 1


k

m+1 lG (2)

j

lG 1


k


+ 1

k

+ 1 lG
j
k
1. Since lGm1 =

lG 1[(lG 1)mod m]




equivalent thej inequality
[(lG 1)mod m]
k

+ 1 true since (lG 1)mod 1. Since
k

j
lG 1
+
1
lG .


lG 1




lG


1 trivial

A.3 Proof Proposition 2
A.3.1 Part 1
Proof sketch
show G2 / G0 PGG02 = NG2 apply Theorem 1 obtain thesis.
particular use


PG2 NG1
NG2
= lcm NG1 , m,
,
GCD(PG2 NG1 , PG1 ) GCD(NG2 m, |k|)



PG2
PG1 NG2
k

=
+
NG1 PG2

NG2


that, i, j, k : G0 (i) = kr=0 G2 (j + r), G0 (i + ) = kr=0 G2 (j + r +
NG2 ).
Given arbitrary granule G0 (i), show G0 (i + ) union granules
obtained adding NG2 index granule G2 contained G0 (i). Note
+ LG0 since G0 full-integer labeled. order show correct
consider way granules G0 constructed definition altering-tick. precisely,
compute difference label b0i+ first granule G2 included
G0 (i + ) label b0i first granule G2 included G0 (i); show
difference equal difference label t0i+ last granule G2 included
G0 (i + ) label t0i last granule G2 included G0 (i). fact together
consideration G2 full-integer labeled granularity, leads conclusion
G0 (i) G0 (i + ) number granules. clear
computed label differences equal difference label arbitrary
n-th granule G2 included G0 (i + ) label n-th granule
G2 included

G0 (i). difference b0i+ b0i , have: j, k : G0 (i) = kr=0 G2 (j + r),


G0 (i + ) = kr=0 G2 j + r + b0i+ b0i . showing b0i+ b0i multiple NG2
thesis follows.
Proof details


336

fiMapping Calendar Expressions Minimal Periodic Sets

Si
Sti+
Assume G1 (i) = tj=b
G2 (j) G1 (i + ) = j=b
G2 (j). need compute

i+
0
0
bi+ bi . definition altering-tick operation:
b0i

=



k
bi + il



bi +

il


=

il


+ l,
(7)


+ 1 k otherwise.


b0i+

=




k
bi+ + i+l



bi+ +

i+l


+ =

i+l


+ l,
(8)


+ 1 k otherwise.






Note = il
+ l, + = i+l
Indeed, i+l
+l =

+ l.

il

il

il
+
m+l
and,
since



multiple

m,

+
m+l
=
+
m+







il
l = + + l.
Hence, compute b0i+ b0i consider two cases:
b0i+ b0i =






k bi il
k = il
m+l
bi+ + i+l





bi+ +

i+l


(9)




+ 1 k bi il
+ 1 k otherwise.

cases (again considering fact multiple m):
b0i+ b0i = (bi+ bi ) +

k


(10)

left compute bi+ bi , i.e., distance terms granules G2 , G2 (bi )
Sti+
Si
G2 (j),
G2 (j) G1 (i + ) = j=b
G2 (bi+ ). Since, hypothesis, G1 (i) = tj=b

i+
first granule making G2 (bi ) first granule making G1 (i)
granule. observed first granule making G2 (bi+ )
first granule making G1 (i + ). formally:
min bbi cG2 = min bicG1

min bbi+ cG2 = min bi + cG1
Hence, have:
min bbi+ cG2 min bbi cG2 = min bi + cG1 min bicG1

(11)

shown difference index first granule making
G2 (bi+ ) index first granule making G2 (bi ) equal difference
index first granule making G1 (i + ) index first
granule making G1 (i). Then, need compute difference index
first granule making G1 (i + ) index first granuleSof making
G1 (i). Since / G1 multiple NG1 , i, j, : G1 (i) = r=0 (j + r),
337

fiBettini, Mascetti & Wang


P
P
G1 (i + ) = r=0 (j + NGG1 ). Hence, difference value NGG1 ,
1
1
shown value difference index first granule
making G2 (bi+ ) index first granule making G2 (bi ). Then, since
P
/ G2 period length PG2 since NGG1 multiple PG2 , that, if:
1

(j) G2 (i)
then:
(j +
Thus, bi+ bi =
Reconsidering 10:

PG1
PG1 NG2
)
) G2 (i +
NG1
NG1 PG2

PG1 NG2
NG1 PG2 .

b0i+ b0i =

PG1 NG2
k
+
.
NG1 PG2

P

N

Analogously compute t0i+ t0i = NGG1PGG2 + k
.
1
2
0
0
0
0
Thus, bi+ bi = ti+ ti ; hence ti+ bi+ = ti bi . Since G2 full integer labeled
granularity, G0 (i) G0 (i + ) formed number granules.
St0i+
St0i
0
0
0
0
Since know G0 (i+) = j=b
G2 (j) = j=b
0 G2 (j +(bi+ bi )) (bi+ bi )
0


i+

/ G0 ,

PGG02

PG1 NG2
NG1 PG2

multiple NG2 , G2
=
/ G2 . Hence,
hypothesis Theorem 1 hold, application leads thesis proposition.
A.3.2 Part 2
0

Since G2 partitions G0 (see table 2.2 (Bettini et al., 2000)), (1) dlG2 eG
G2 al+
ways defined (2) min({n N |i LG2 s.t. (n) G2 (i)}) = min({m N+ |j
LG0 s.t. (m) G0 (j)}). Therefore lG0 label granule G0 covers
0
granule G2 labeled lG2 ; definition de operation, lG0 = dlG2 eG
G2 .
A.4 Proof Proposition 3
A.4.1 Part 2
definition Shift operation, G0 (i) = G(im). Hence G0 (lG +m) = G(lG +mm) =
G(lG ).
A.5 Proof Proposition 4
A.5.1 Part 1
thesis follow application Theorem 1. Indeed, know / G2
show G2 / G0 PGG02 multiple
s.t.,
NG2 . we0 need identify

0
i, exists s(i) s.t. G (i) = js(i) G2 (j), G (i + ) = js(i) G2 (j + NG2 ).
lcm(P

,P

)N

G1 G2
G1
Consider arbitrary N =
. definition combining
PG1


0
0
operation, G (i) = js(i) G2 (j) G (i + ) = js(i+) G2 (j)

s(i) = {j LG2 | =
6 G2 (j) G1 (i)}
338

fiMapping Calendar Expressions Minimal Periodic Sets


s(i + ) = {j LG2 | =
6 G2 (j) G1 (i + )} .
show s(i + ) composed elements s(i)
lcm(PG1 ,PG2 )NG2
quantity 0 =
added. purpose need:
PG
2

j s(i) (j + 0 ) s(i + )

(12)


j + 0 s(i + ) j s(i)

(13)



12, note j s(i), G2 (j) G1 (i). Since / G2 ,
G2 (j) =

k
[

(jr )

r=0


0



G2 j + =

k
[

(jr + lcm(PG1 , PG2 ))

(14)

r=0

Since G1 (i) G2 (j) =

Sk

r=0 (jr ),

since / G1 ,

G1 (j + )

k
[

(jr + lcm(PG1 , PG2 ))

(15)

r=0

14 15 derive G1 (i + ) G2 (j + 0 ), hence (j + 0 ) s(i + ).
Analogously
validitySof 13; Hence, i, exists s(i) s.t.
proved
0
0
G (i) = js(i) G2 (j), G (i + ) = js(i) G2 (j + 0 ). Hence, considering fact
G2 / G0 , conclude G2 / G0 . Finally, since PGG02 multiple NG2 , Theorem 1
obtain thesis.
A.5.2 Part 2
Let

P 0
s(i) 6= }
LeG0 = {i LGG1 |e
P

0

P

0

LGG1 se(i) = {j LGG2 | =
6 G2 (j) G1 (i)};
show LeG0 = LG0 proving that: (1) LeG0 LG0 (2) LeG0 LG0 .
(1) Suppose contradiction exists k LG0 \ LeG0 . Since k LG0 since G0
derived Combine operation,
q LG2 |G2 (q) G1 (k). definition

0
Combine operation G (k) = js(k) G2 (j); since q s(k), G2 (q) G0 (k). Hence (a)
q LG2 |G2 (q) G0 (k).
P 0
Moreover, since k 6 LeG0 , se(k) = ; therefore @j LGG2 |G2 (j) G1 (k).
definition Combine operation easily seen G0 G1 . Using
P 0
previous formula, derive (b) @j LGG2 |G2 (j) G0 (k).
339

fiBettini, Mascetti & Wang

P

0

(a) (b) follows q LG2 \ LGG2 |G2 (q) G0 (k). show
leads contradiction.
P 0
P 0
P 0
P 0
Since q 6 LGG2 labels LGG2 contiguous (i.e., @i LG2 \ LGG2 s.t. min(LGG2 ) <
P

P

0

P

0

0

< max(LGG2 )), q < min(LGG2 ) q > max(LGG2 ). consider first case,
proof second analogous.
P 0
P 0
q < min(LGG2 ) max(bqcG2 ) < 1 (otherwise q LGG2 ).
0
0
Let = min(bmin(LG0 )cG ). Since k LG0 , bkcG .
1, G0 (k) G2 (q) = contradicting G0 (k) G2 (q).
< 1, G0 (lG0 ) (0) show lG0 LeG0 . Indeed, definition
P 0
P 0
Combine, j LGG2 |G2 (j) G0 (LG0 ). Since G0 G1 j LGG2 |G2 (j)
G1 (LG0 ); hence j se(lG0 ) lG0 LeG0 .
Since 0 G0 (lG0 ) max(bqcG2 ) 0, max(bqcG2 ) < (otherwise G2 (q)
0
0
G0 (lG0 )). Therefore, since min(bkcG ) , bqcG2 blG0 cG = , contradiction
G2 (q) G0 (k).
e
(2) Suppose contradiction k LeG0 \ LG0 . Since k LeG0 , definition L,
P

P

0

0

k LGG1 se(k) 6= ; Therefore, definition se, j LGG2 |G2 (j) G1 (k).
P

0

Since j LGG2 , definition L, h 0 < h PG0 s.t. dheG2 = j. Since
0
G2 (j) G1 (k), dheG1 = k. definition combine operation, dheG = k.
0
Moreover, since 0 < h PG0 , definition L, dheG = k LG0 , contradicting
hypothesis.
A.6 Proof Proposition 5
A.6.1 Part 1
thesis follow application Theorem 1. Indeed, show G1 / G0
PGG01 multiple NG1 . need identify s.t., i, exists s(i)


lcm(PG1 ,PG2 )NG2
s.t. G0 (i) = js(i) G1 (j), G0 (i+) = js(i) G1 (j +NG1 ). Let =
.
PG2
0


0
(i+) 1
1
G1 (j) G0 (i + ) = j=i+ G1 (j)
definition anchored grouping, G0 (i) = ij=i
i0 first label G2 (i + )0 first label G2 + .
periodicity G2 , (and since multiple NG2 ) difference label
granule following G2 (i + ) label granule following G2 (i)
Sk.
0
0
0
0
0
formally, (i + ) = , hence (i + ) = + . Then, i, G (i) = j=i G1 (j),
0 +1
0 1
G0 (i + ) = ij=i+
G1 (j) = ij=i
G1 (j + ). result considering G1 / G0 ,
conclude G1 / G0 PGG01 = . Note Proposition 9, NG1 =
PGG01

multiple . Then, Theorem 1, thesis.

A.6.2 Part 2
Let

(
LeG0 =

P

0

lG2 = lG1 ,
LGG2 ,
PG0
0
{lG2 } LG2 , otherwise,

340

PG1 NG2
PG2 ,

hence

fiMapping Calendar Expressions Minimal Periodic Sets

0
lG
greatest among labels LG2 smaller lG2 . show
2
e
LG0 = LG0 proving (1) LeG0 LG0 (2) LG0 LeG0 .
P 0
(1) Suppose contradiction k LeG0 \ LG0 . Then, since k LeG0 , k LGG2
0 .
k = lG
2
P

P

0

0

k LGG2 , then, definition LGG2 , h 0 < h PG0 s.t. dheG2 = k.
0 1
definition Anchored-group, G0 (k) = kj=k
G1 (j) k 0 first label G2
0
k. Therefore G (k) G1 (k). Since G2 labeled aligned subgranularity G1 since
0
k LG2 , k LG1 G1 (k) = G2 (k). Hence G0 (k) G2 (k). follows dheG = k
therefore, definition L, k LG0 contrast hypothesis.
0 , then, definition L
eG0 , lG 6= lG . Therefore, since G2 labeled aligned
k = lG
2
1
2
0 <l
;

h

0 < h < min(blG2 cG2 ) s.t. dheG1 = lG1 .
<
l
subgranularity G1 lG
G
G
2
1
2

lG2 1
0 ) =
0
Since, definition Anchored-group, G0 (lG
G1 (j) since lG
< lG1 < lG2 ,
j=l0
2
2
G2

0

0 ) G (l ). Hence dheG = l0
0
G0 (lG
1 G1
G2 therefore, definition L, lG2 = k LG0
2
contrast hypothesis.
P 0
(2) Suppose contradiction k LG0 \ LeG0 . k LGG2 then, definition
LeG0 , k LeG0 , contrast hypothesis.
P 0
P 0
P 0
P 0
P 0
k
/ LGG2 , since @q LG2 \LGG2 s.t. min(LGG2 ) q max(LGG2 ), k > max(LGG2 )
P

0

k < min(LGG2 ).

P

0

k > max(LGG2 ) then, definition L, min(bkcG2 ) > PG0 . Since G2 labeled
aligned subgranularity G1 G2 (k) = G1 (k) hence min(bkcG1 ) > PG0 . Since
0 1
0
G0 (k) = kj=k
G1 (j) min(bkcG ) > PG0 contrast hypothesis k LG0 .
P

0

0 , k < l0
0
k < min(LGG2 ) then, definition lG
G2 k = lG2 .
2
0
0
k < lG
then, let k 0 next label G2 k. Since k < lG
then, definition
2
2
0
0
0
0
0
G
lG2 , k lG2 . definition lG2 max(blG2 c 2 ) 0. Since G2 labeled aligned
0 ) = G (l0 ); therefore max(bl0 cG1 ) 0. Since G0 (k) =
subgranularity G1 G1 (lG
2 G2
G2
2
Sk0 1
0
0
G0 ) 0 contrast hypothesis
G
(j)

k

l
,
follows

max(bkc
1
j=k
G2
k LG0 .
SlG2 1
0
0 ) =
0
Finally k = lG
G0 (lG
G1 (j). Since k = lG
LG0 h
j=l0
2
2
2
0

G2

0 . Since G0 composition granules G , dheG1
0 < h PG0 s.t. dheG = lG
1
2
P

0

defined. Let q = dheG1 . definition L, q LGG1 therefore q lG1 . Since,
0
0
definition Anchored-group, G0 composition granules G1 since dheG = lG
2

lG2 1
0 ). Therefore since G0 (l0 ) =
dheG1 = q, G1 (q) G0 (lG
G
(j)

q
<
l
1
G2 .
G2
j=l0
2
G2

0
follows lG1 q < lG2 hence lG1 6= lG2 . definition LeG0 , lG
= k LeG0
2
contrast hypothesis.

A.7 Selecting operations
selecting operations common part proof computation period
length period label distance.

341

fiBettini, Mascetti & Wang

lcm(P

,P

)N

G1 G2
G1
Let =
. proof divided two steps: first show
PG1
select operation LG0 + LG0 (details Select-down, Select-up
Select-by-intersect operations found below). second step application
Theorem 1. Indeed, Select operation, following holds: LG0 G0 (i) = G1 (i);
implies G1 / G0 . step 1 follows + LG0 , hence G0 (i + ) = G1 (i + ).
result considering G1 / G0 , conclude G1 / G0 PGG01 =
multiple NG1 definition. Then, Theorem 1 thesis.

A.8 Proof Proposition 6
A.8.1 Part 1
See Section A.7.
prove LG0 0 = + LG0 .
definition select-down operation, LG0 LG2 s.t. lk (S(i))
S(i) ordered set defined follows: S(i) = {j LG1 | =
6 G1 (j) G2 (i)}.
order prove thesis need show i0 LG2 |0 lk (S(i0 )). Consider
i0 = i+

lcm(PG1 PG2 )NG2
PG2

note i0 LG2 (this trivially derived periodicity

G2 ). prove 0 lk (S(i0 )) show S(i0 ) obtained S(i) adding
elements.
Indeed note periodicity G1 , j S(i) if:
j
[

(jr )

(16)

(jr + lcm(PG1 PG2 ))

(17)

G1 (j) =

r=0

then:
G1 j

0



=

j
[
r=0

Since j S(i), G1 (j) G2 (i) then, (16), G2 (i)
periodicity G2 :

0



G2

j
[

(jr + lcm(PG1 PG2 ))

Sj

r=0 (jr ).

Moreover,

(18)

r=0

Since (17) (18), G2 (i0 ) G1 (j 0 ); hence j S(i), j 0 = (j + ) S(i0 ). Analogously
prove j 0 S(i0 ), j = (j 0 ) S(i).
Thus S(i0 ) obtained S(i) adding elements; therefore j S(i)
position n S(i), j 0 S(i0 ) position n S(i0 ). Hence trivial
position k k + l 1 S(i), 0 position k k + l 1
S(i0 ). Hence LG0 , 0 LG0 .

342

fiMapping Calendar Expressions Minimal Periodic Sets

A.8.2 Part 2
Let
LeG0 =


[ n
P 0
A(i)|a LGG1 ;
P 0

iLGG
2

LG2 :

6 G1 (j) G2 (i)}) .
A(i) = lk ({j LG1 | =

show LeG0 = LG0 proving (1) LeG0 LG0 (2) LeG0 LG0 .
P 0
(1)Suppose contradiction q LeG0 \ LG0 . definition LeG0 , q LGG1 ;
therefore h 0 < h PG0 s.t. dheG1 = q. Moreover, definition LeG0
definition Select-down, LeG0 LG0 hence q LG0 . Since, definition Select-down
0
G0 (q) = G1 (q), dheG = q; hence, definition L, q LG0 contradiction
hypothesis.
(2)Suppose contradiction q LG0 \ LeG0 . Since q LG0 then, definition
Select-down
6 G1 (j) G2 (i)})
LG2 s.t. q lk ({j LG1 | =
therefore, definition A(i), q A(i).
0
Since q LG0 h 0 < h PG0 s.t. dheG = q. definition Select-down,
P 0
G0 (q) = G1 (q), dheG1 = q therefore q LGG1 . Moreover, since G1 (q) G2 (i),
P

P

0

0

P

0

dheG2 = therefore LGG2 . Since q A(i), q LGG1 LGG2 then,
definition LeG0 , q LeG0 , contrast hypothesis.
A.9 Proof Proposition 7
A.9.1 Part 1
See Section A.7. prove LG0 + LG0 . periodicity G1 ,
i+ LG1 (this trivially derived periodicity G1 ). Hence need show
j 0 LG2 | =
6 G2 (j) G1 (i + ). Since LG0 j LG2 | =
6 G2 (j) G1 (i).
periodicity G2 , if:
G2 (j) =

j
[

(jr )

(19)

r=0

then:

[
j
lcm(PG1 PG2 )NG2
G2 j +
=
(jr + lcm(PG1 PG2 ))
PG2
r=0

Moreover, (19) since G1 (i) G2 (j):
G1 (i)

j
[
r=0

periodicity G1 :
343

(jr )

(20)

fiBettini, Mascetti & Wang

G1 (i + )

j
[

(jr + lcm(PG1 PG2 ))

(21)

r=0


(20) (21) follows G1 (i + ) G2 j +

lcm(PG1 PG2 )NG2
PG2



, thesis.

A.9.2 Part 2
Let

P 0
6 G2 (j) G1 (i)};
LeG0 = {i LGG1 |j LG2 s.t. =

show LeG0 = LG0 proving (1) LeG0 LG0 (2) LeG0 LG0 .
P 0
(1) Suppose contradiction k LeG0 \ LG2 . Since k LeG0 , k LGG1 ;
therefore h 0 < h PG0 s. t. dheG1 = k. Moreover, definition LeG0
definition Select-down, LeG0 LG0 hence q LG0 . Since, definition Select-up,
0
G0 (k) = G1 (k), dheG = k. Hence, definition L, k LG0 , contrast
hypothesis.
(2) Suppose contradiction k LG0 \ LeG0 . Since k LG0 , h 0 <
0
h PG0 s.t. dheG = k. Since, definition Select-up, G0 (k) = G1 (k), dheG1 = k;
P 0
Therefore, definition L, k LGG1 . Moreover, since k LG0 LG0 LG0 ,
definition Select-up operation, j LG2 s.t. 6= G2 (j) G1 (k). Hence
definition LeG0 , k LeG0 , contradiction hypothesis.
A.10 Proof Proposition 8
A.10.1 Part 1
See Section A.7. prove LG0 , 0 = + LG0 .
definition select-by-intersect operation, LG0 , LG2 :
lk (S(i)) S(i) ordered set defined follows: S(i) = {j LG1 |G1 (j)G2 (i) 6= }.
order prove thesis need show i0 LG2 : 0 lk (S(i0 )). Consider
i0 = +

lcm(PG1 PG2 )NG2
note i0 LG2 (this
PG2
prove 0 lk (S(i0 )) show

trivially derived periodicity

G2 ).
S(i0 ) obtained S(i) adding
elements.
Indeed note j j S(i), G1 (j) G2 (i) 6= . Hence l Z : (l) G1 (j)
(l) G2 (i). periodicity G1 , G1 (j + ) (l + lcm(PG1 PG2 )).
periodicity G2 , G2 (i0 ) (l + lcm(PG1 PG2 )). G1 (j + ) G2 (i0 ) 6= , therefore
j S(i), (j + ) S(i0 ).
Analogously prove j 0 S(i0 ), (j 0 ) S(i). Hence S(i0 ) obtained
S(i) adding elements. Therefore, j S(i) position n S(i),
j + S(i0 ) position n S(i0 ); hence j position k k + l 1 S(i),
j + position k k + l 1 S(i0 ) j + LG0 .
A.10.2 Part 2
proof analogous ones Proposition 6.
344

fiMapping Calendar Expressions Minimal Periodic Sets

A.11 Set Operations
A.11.1 Proof Proposition 9
Given periodical granularities H G G label aligned subgranularity H,
NH
G
prove N
PG = PH . thesis proved considering common period length H
G i.e. Pc = lcm(PG , PH ).
Let NG0 difference label ith granule one period G
label ith granule next period, considering Pc period length G.
0 defined.
Analogously NH


periodicity G, G(i) = kr=0 (ir ) G(i + NG0 ) = kr=0 (ir + Pc ); since G

aligned subranularity H, LH H(i) = G(i) = kr=0 (ij ) and, since H periodic,
Sk
0 )=
0
0
H(i + NH
r=0 (ij + Pc ); easily derive + NG = + NH , hence
0
0
NG = NH .
0 = N 0 ,
definition Pc , , N s. t. PH = PG . Moreover, since NH
G
PG
PH
=
.
NH = NG . Therefore N
NG
H
A.11.2 Property used proofs set operations
lcm(P

,P

)N

lcm(P

,P

)N

G1 G2
G1
G1 G2
G2
Let 1
2
. Since G1 G2 aligned subgranPG1
PG2
ularity certain granularity H, Proposition 9 easily derive 1 = 2 .

A.12 Proof Proposition 10
A.12.1 Part 1
Union. Let 1

lcm(PG1 ,PG2 )NG2
lcm(PG1 ,PG2 )NG1
2
. thesis
PG1
PG2

Sk
0
0
LG0 if, G (i) = r=0 (ir ), G (i + ) = kr=0 (ir

proved

+ lcm(PG1 , PG2 ))
showing
0
= 1 = 2 . Since LG = LG1 LG2 , two cases considered:

LG1 G0 (i) = G1 (i) = kr=0 (ir ). periodicity G1 , G1 (i + 1 ) =
Sk
Sk
0
r=0 (ir + lcm(PG1 , PG2 )); hence G (i + 1 ) =
r=0 (ir + lcm(PG1 , PG2 )).

LG2 LG1 G0 (i) = G2 (i) = kr=0 (ir ). periodicity G2 , G2 (i + 2 ) =
Sk
Sk
0
r=0 (ir + lcm(PG1 , PG2 )); hence G (i + 2 ) =
r=0 (ir + lcm(PG1 , PG2 )).

Since 1 = 2 , LG0 G0 (i) = kr=0 (ir ), G0 (i + 1 ) = G0 (i + 2 ) =
Sk
r=0 (ir + lcm(PG1 , PG2 )). Hence, definition / , thesis.

Intersect. LG0 = LG1 LG2 G0 (i) = G1 (i) = kr=0 (ir ). periodicity
G1 G2 , + 1 LG1 eSi + 2 LG2 ; since 1 = 2 , + 1 LG0 . Moreover
G0 (i + 1 ) = G1 (i + 1 ) = kr=0 (ir + lcm(PG1 , PG2 )); hence, definition / ,
thesis.

Difference. LG0 = LG1 LG2 G0 (i) = G1 (i) = kr=0 (ir ). Since LG1
periodicity G1 + 1 LG1 . Since
/ LG2 , periodicity G2 , + 2
/ LG2
(if would exists + 2 LG2 , periodicity G2 would exists LG2
0
0

Sk possible hypothesis). Hence + 1 LG . Moreover G (i + 1 ) = G1 (i + 1 ) =
r=0 (ir + lcm(PG1 , PG2 )); hence, definition / , thesis.
345

fiBettini, Mascetti & Wang

A.12.2 Part 2
P 0
P 0
Let LeG0 = LGG1 LGG2 .
show LeG0 = LG0 proving (1) LeG0 LG0 (2) LeG0 LG0 .
P 0
(1) Suppose contradiction k LeG0 \ LG0 . Since k LeG0 k LGG1
P

0

P

P

0

0

P

0

k LGG2 . Suppose k LGG1 (the proof analogous k LGG2 ). Since k LGG1 ,
0
0 < h < PG0 s.t. dheG = k. Since, definition Union operation G0 (k) = G1 (k),
0
dheG = k. Hence, definition L, k LG0 contrast hypothesis.
(2) Suppose contradiction k LG0 \ LeG0 . Since k LG0 , then, definition
0
L, 0 < h < PG0 s.t. dheG = k. Moreover, definition Union operation, k LG1
P 0
P 0
k LG2 . Suppose k LGG1 (the proof analogous k LGG2 ). definition
P

0

Union operation, G0 (k) = G1 (k) therefore dheG1 = k so, definition L, k LGG1 .
e k LeG0 contradiction hypothesis.
Hence, definition L,

References
Bettini, C., & Mascetti, S. (2005). efficient algorithm minimizing time granularity
periodical representations. Proc. 12th International Symposium Temporal
Representation Reasoning (TIME), pp. 2025. IEEE Computer Society.
Bettini, C., Mascetti, S., & Pupillo, V. (2005). system prototype solving multigranularity temporal csp. Recent Advances Constraints, Revised selected papers Workshop Constraint Solving Constraint Logic Programming
(CSCLP), volume 3419 Lecture Notes Computer Science, pp. 142156. Springer.
Bettini, C., Mascetti, S., & Wang., X. S. (2004). Mapping calendar expressions periodical granularities. Proc. 11th International Symposium Temporal
Representation Reasoning (TIME), pp. 96102. IEEE Computer Society.
Bettini, C., & Sibi, R. D. (2000). Symbolic representation user-defined time granularities.
Annals Mathematics Artificial Intelligence, 30 (1-4), 5392.
Bettini, C., Wang, X. S., & Jajodia, S. (2000). Time Granularities Databases, Data
Mining, Temporal Reasoning. Springer.
Bettini, C., Wang, X. S., & Jajodia, S. (2002a). Solving multi-granularity temporal constraint networks. Artificial Intelligence, 140 (1/2), 107152.
Bettini, C., Wang, X. S., & Jajodia, S. (2002b). Temporal reasoning workflow systems.
Distributed Parallel Databases, 11 (3), 269306.
Bresolin, D., Montanari, A., & Puppis, G. (2004). Time granularities ultimately periodic
automata. Proc. 9th European Conference Logics Artificial Intelligence
(JELIA) volume 3229 Lecture Notes Computer Science, pp. 513525. Springer.
Chandra, R., Segev, A., & Stonebraker, M. (1994). Implementing calendars temporal
rules next generation databases. Proc. 10th International Conference
Data Engineering (ICDE), pp. 264273. IEEE Computer Society.
Combi, C., Franceschet, M., & Peron, A. (2004). Representing reasoning temporal
granularities. Journal Logic Computation, 14 (1), 5177.
346

fiMapping Calendar Expressions Minimal Periodic Sets

Combi, C., & Pozzi, G. (2003). Temporal conceptual modelling workflows. Proc.
22nd International Conference Conceptual Modeling (ER) volume 2813 Lecture
Notes Computer Science, pp. 5976. Springer.
Cukierman, D., & Delgrande, J. P. (1998). Expressing time intervals repetition within
formalization calendars. Computational Intelligence, 14, 563597.
Dal Lago, U., & Montanari, A. (2001). Calendars, time granularities, automata. Proc.
7th International Symposium Spatial Temporal Databases (SSTD),
volume 2121 Lecture Notes Computer Science, pp. 279298. Springer.
Dal Lago, U., Montanari, A., & Puppis, G. (2003). Towards compact tractable
automaton-based representations time granularities. Proc. 8th Italian
Conference Theoretical Computer Science (ICTCS), volume 2841 Lecture Notes
Computer Science, pp. 7285. Springer.
Dechter, R., Meiri, I., & Pearl, J. (1991). Temporal constraint networks. Artificial Intelligence, 49 (1-3), 6195.
Kabanza, F., Stevenne, J. M., & Wolper, P. (1990). Handling infinite temporal data. Proc.
9th ACM SIGACT-SIGMOD-SIGART Symposium Principles Database
Systems (PODS), pp. 392403. ACM Press.
Koomen, J. (1991). Reasoning recurrence. International Journal Intelligent Systems, 6, 461496.
Ladkin, P. B. (1986). Primitives units time specification. Proc. 5th National
Conference Artificial Intelligence (AAAI), pp. 353359. Morgan Kaufmann.
Leban, B., McDonald, D., & Forster, D. (1986). representation collections temporal
intervals. Proc. 5th National Conference Artificial Intelligence (AAAI),
pp. 367371. Morgan Kaufmann.
Li, Y., Ning, P., Wang, X. S., & Jajodia, S. (2001). Discovering calendar-based temporal
association rules. Proc. 8th International Symposium Temporal Representation Reasoning (TIME), pp. 111118. IEEE Computer Society.
Montanari, A. (1996). Metric Layered Temporal Logic Time Granularity. Ph.D.
thesis, ILLC Dissertation Series 1996-02, University Amsterdam.
Morris, R., Shoaff, W., & Khatib, L. (1996). Domain-independent temporal reasoning
recurring events. Computational Intelligence, 12, 450477.
Niezette, M., & Stevenne, J. M. (1992). efficient symbolic representation periodic
time. Proc. first International Conference Information Knowledge
Management (CIKM) volume 725 Lecture Notes Computer Science, pp. 161168.
Springer.
Ning, P., Wang, X. S., & Jajodia, S. (2002). algebraic representation calendars.
Annals Mathematics Artificial Intelligence, 36 (1-2), 538.
Puppis, G. (2006). Automata Branching Layered Temporal Structures. Ph.D. thesis,
Universita degli Studi di Udine.
Terenziani, P. (2003). Symbolic user-defined periodicity temporal relational databases.
IEEE Transactions Knowledge Data Engineering, 15 (2), 489509.
347

fiBettini, Mascetti & Wang

Tuzhilin, A., & Clifford, J. (1995). periodicity temporal databases. Information
Systems, 20 (8), 619639.
Urgun, B., Dyreson, C. E., Snodgrass, R. T., Miller, J. K., Soo, M. D., Kline, N., & Jensen,
C. S. (2007). Integrating multiple calendars using TauZaman. Software-Practice
Experience, appear.
Wijsen, J. (2000). string-based model infinite granularities. Spatial Temporal
Granularity: Papers AAAI Workshop. Technical Report WS-00-08, pp. 916.
AAAI Press.

348


