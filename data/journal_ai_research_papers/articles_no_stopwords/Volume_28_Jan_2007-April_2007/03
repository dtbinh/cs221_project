journal artificial intelligence

submitted published

abstract reasoning coordination
bradley j clement

brad clement jpl nasa gov

jet propulsion laboratory mail stop
pasadena ca usa

edmund h durfee

durfee umich edu

university michigan eecs department ann arbor mi usa

anthony c barrett

tony barrett jpl nasa gov

jet propulsion laboratory mail stop
pasadena ca usa

abstract
judicious use abstraction help agents identify key interactions
actions resolve without getting bogged details however ignoring wrong
details lead agents building plans work costly backtracking replanning overlooked interdependencies come light claim associating systematicallygenerated summary information plans abstract operators ensure plan correctness even
asynchronously executed plans must coordinated across multiple agents still achieving valuable efficiency gains formally characterize hierarchical plans whose
actions temporal extent describe principled method deriving summarized state
metric resource information actions provide sound complete along
heuristics exploit summary information hierarchical refinement plan
coordination analyses experiments clearcut reasonable conditions
summary information speed much doubly exponentially even plans
involving interacting subproblems

introduction
abstraction powerful tool solving large scale scheduling abstracting away less critical details looking large agent overall solution easily skeleton overall solution place agent
work additional details solution sacerdoti tsuneto hendler nau
interdependencies fully resolved abstract levels one agents
flesh sub pieces abstract solution full details independently even parallel
divide conquer korf lansky knoblock
unfortunately obvious best abstract large complex achieve
efficiency improvements agent solving complicated many step
example might able identify details earlier parts critical later
ones tried generate plans schedules seen interdependencies end
arising even worse multiple agents trying plan schedule activities shared
environment unless lot prior knowledge extremely
difficult one agent anticipate aspects planned activities likely affect
affected agents

c

ai access foundation rights reserved

fic lement urfee barrett

describe strategy balances benefits risks abstraction largescale single agent multi agent avoids danger ignoring
important details lead incorrect plans whose execution fail due overlooked interdependencies substantial backtracking abstract decisions cannot consistently refined
meanwhile still achieves many computational benefits abstraction long
one number reasonable conditions listed later holds
key idea behind strategy annotate abstract operator plan hierarchy
summary information potential needs effects potential refinements might sound contrary purpose abstraction reducing number
details fact strikes good balance specifically possibly
relevant conditions effects modeled agent agents reasoning abstract
operators absolutely sure important details cannot overlooked however
summary information abstracts away details refinement choices conditions
effects manifested information relative timing conditions needed effects achieved still often exponential reduction information
compared flat representation
concept summary information extends prior work summarized
section make following contributions
formal model hierarchical plans temporal extent execution
many systems sophisticated temporal e g laborie ghallab muscettola additionally use hierarchical representations alternative courses action
allen kautz pelavin tenenberg currie tate chien knight stechert sherwood rabideau castillo fdez olivares garca perez palao know
work extends hierarchical task network htn formalization erol hendler nau
erol nau hendler b include temporal extent need formalism order
clarify semantics summary information concurrently executing agents
deriving summary information propositional metric resource conditions effects information determine potential definite interactions abstract tasks prove summarization techniques guaranteed
correctly capture conditions effects associated abstract operator appropriately augmented modal information whether conditions must may hold whether
hold entire operation time summary information
captures conditions effects reason operators different levels
abstraction predict often resolve operator interactions without fully detailing task hierarchies
even operators executing asynchronously different agents
sound complete hierarchical refinement centralized plan coordination actions temporal extent supporting flexible plan execution systems
agent reduce backtracking selectively interleaving refinement plan
predicting resolving potential interdependencies evolving plan plans
asynchronously executed agents found benefit
guiding refinement conditions specified higher levels plan hierarchy guide refinement sacerdoti young pollack moore tsuneto et al
improve capabilities exploiting hierarchical structure summary



fia bstract r easoning p lanning c oordination

information efficiently converge coordinated plans refined
individually parallel participating agents
ability coordinate abstract levels rather detailed plans allows
agents retain local flexibility refine operators best suits current expected
circumstances without jeopardizing coordination triggering rounds renegotiation
way summary information supports robust execution systems prs georgeff lansky
umprs lee huber durfee kenny raps firby jam huber etc
interleave refinement abstract plan operators execution
extends plan coordination plan merging techniques georgeff lansky ephrati rosenschein utilizing plan hierarchies expressive temporal model prior techniques assume actions atomic meaning action executes
exactly time another contrast use interval point algebra vilain kautz represent possibility several actions one agent executing
execution one action another agent choose alternative
refinements htn dynamically midst plan coordination support interleaved local
multiagent coordination concurrent execution
search techniques heuristics including choose fewest threats first cftf expandmost threats first emtf take advantage summary information prune search
space interdependencies run deeply agents plans resolving abstract levels possible lead unacceptable losses parallel activity fortunately even
agents need delve details plans tease interdependencies summary information still enable exponential speedups guiding decomposition pruning refinement
choices search efficiency summary information comes ignoring irrelevant information distributed system reduces communication overhead exponentially
complexity analyses experiments showing potential doubly exponential speedups refinement local search scheduling summary information
demonstrate exploiting summary information guide hierarchical scheduling
achieve exponential speedups resolving interdependencies abstract levels improve
performance plan coordination doubly exponentially others shown
abstraction exponentially reduce search space size korf knoblock subproblem independence properties hold techniques lead exponential improvements
broader conditions hold
solutions found abstract levels
amount summary information less higher levels lower levels
choices decompositions lead varying numbers plan threats
none conditions hold generating summary information
provides benefit increase computation communication overhead thus care must
taken deciding use summary information though proven extremely worthwhile
types domains examined example next describe



fic lement urfee barrett





e

transport

transport



b

c

tool

bin

bin

bin

bin

dock

figure simple example manufacturing domain
produce h
produce g

produce h g

produce g


produce g


move b

move

move g

build h

move h
bin

build g

move b

figure production managers hierarchical plan
manufacturing example
running example motivate work consider manufacturing plant production
manager facilities manager inventory manager goals separately
constructed hierarchical plans achieve however still need coordinate use
equipment availability parts used manufacturing parts storage parts
use transports moving parts around state factory shown figure
domain agents produce parts machines service machines tool
move parts shipping dock storage bins shop floor transports
initially machines free use transports transport transport
tool parts e shown storage locations available
production manager responsible creating part h machines consume parts b produce g produce h g
production managers hierarchical plan manufacturing h involves transports move
needed parts storage input trays machines manufacturing g h transporting h back storage plan shown figure arcs subplan branches mean
subplans must executed branches without arcs denote alternative choices achieving
parents goal decomposition produce g similar produce g
facilities manager services machine equipping tool calibrating
machines unavailable production serviced facilities managers hierarchical plan branches choices servicing machines different orders uses transports



fia bstract r easoning p lanning c oordination

maintenance
service

service

service

service

move tool
dock

move tool equip tool calibrate


figure facilities managers hierarchical plan
move parts
move c dock

move e

move bin

move e bin

figure inventory managers hierarchical plan
getting tool storage machines figure decomposition service
similar service
parts must available space limited shop floor order agent use
whenever agent moves uses part becomes unavailable inventory managers goal
move part c dock move e bins shop floor shown figure
accelerate coordination plans factory manager analyze hierarchical
plan derive summary information abstract plan operator affect world
information includes summary pre post conditions intuitively correspond
externally required preconditions externally effective postconditions internally required
conditions respectively plan potential refinements summary conditions augment state conditions modal information whether conditions must may hold
effect examples given end section
summary information computed production inventory managers could
send information top level plan facilities manager facilities manager could
reason top level summary information plans determine
facilities manager serviced machines production manager started producing
parts production manager finished inventory manager began moving parts
dock plans executed refined way cananyway
facilities manager could instruct others add communication actions plans
synchronize actions appropriately
top level solution maximizes robustness choices production facilities managers plans preserved solution inefficient concurrent
activityonly one manager executing plan time production manager might
want wait facilities manager finish maintenance could negotiate solution
concurrency case facilities manager could determine could overlap



fic lement urfee barrett

plans way without risking conflict cananyway however summary information
could tell might way overlap plans mightsomeway suggesting
search solution concurrency cost perhaps committing specific
refinement choices hope success case facilities manager could request production manager summary information produce hs subplans reason
interactions lower level actions way way synchronize subplans
fine grained solution plans executed concurrently give
finding solutions section
overview
first formally define model concurrent hierarchical plan execution interactions
section next describe summary information propositional states metric resources
mechanisms determining whether particular interactions must may hold information deriving information section built upon others
summary information determine whether set chips must might execute successfully set ordering constraints section turn used within sound
complete multilevel coordination employs search techniques heuristics
efficiently navigate prune search space refinement section
scheduling coordinating abstract levels exponentially improve performance
search execution section provide experimental demonstrating search
techniques greatly reduce search optimal solutions section finally section
differentiate related work mention elsewhere conclude

model hierarchical plans concurrent execution
representation temporal extent htn important modeling concurrently
executing agents performing abstract reasoning summary information agent
scheduling abstract actions sequentially order severely restricted
kinds solutions example agent may prefer solutions shorter
makespans seek plans subthreads carried concurrently
section define concurrent hierarchical plans chips state changes time
executions concepts success failure executions possible world
history later define summary information abstract plan interactions terms
definitions semantics given section treatment fairly detailed though
even comprehensive treatment see clement however begin summarizing
main concepts notation introduced give reader basic gist
overview
chip plan p mainly differentiated htn including definition inconditions
p sometimes called conditions affect assert condition state
start time p ts p must hold throughout duration p preconditions pre p must
hold start postconditions post p asserted finish time p f p metric
resource res consumption usage p res instantaneous start time resource
defined non consumable instantaneously restored end decompositions p p



fia bstract r easoning p lanning c oordination

style tree partial ordering order p choice child tasks
conditions
execution e p instantiation start time end time decomposition
execution nails exactly done order reason plan interactions
quantify possible histories history corresponds combination possible
executions concurrently executing chips partial ordering activities
context initial state run r h specifies state time history h
achieve clobber undo interactions defined terms executions
plans assert positive literal negative literal relative required another plans
execution history looking literals achieved clobbered undone set
executions history identify conditions must hold prior executions
history external preconditions must hold executions history
external postconditions
value metric resource time r res h calculated subtracting prior
state value usage plans start executing non consumable adding back usages
end execution e p fails condition required asserted time
state r h value resource r res h used plan
limits execution
remainder section give careful detailed descriptions concepts
ground definitions firm semantics casual reader skim
details desired important note rather starting scratch formalization
weaves together necessary augments appropriate aspects theories including
allens temporal plans georgeffs theory multiagent plans fagin et al
theory multiagent reasoning knowledge


ch p

concurrent hierarchical plan p tuple hpre post usage type subplans orderi pre p
p post p sets literals v v propositional variable v representing
preconditions inconditions postconditions defined plan p
borrow existing model metric resources chien rabideu knight sherwood engelhardt mutz estlin smith fisher barrett stebbins tran b laborie ghallab
plans usage function mapping resource variables amount used write
usage p res indicate amount p uses resource res sometimes treat usage p set
pairs res amount metric resource res tuple hmin value max value typei min
max values integer real values representing bounds capacity amount available type resource consumable non consumable example fuel
battery energy consumable resources use depleted amount
non consumable resource available use e g vehicles computers power
domain modelers typically specify state conditions resource usage primitive actions hierarchy thus conditions usage chip used derive summary conditions
describe section reason action hierarchy
order reason plan hierarchies trees actions type plan p type p
functions pre p used referential convenience throughout pre pre p
pre p read preconditions p



fic lement urfee barrett

given value primitive plan non primitive plan accomplished carrying subplans plan non primitive plan accomplished
carrying exactly one subplans subplans set plans primitive plans
subplans empty set order p defined plan p consistent set
temporal relations allen pairs subplans plans left unordered respect
interpreted potentially execute concurrently
decomposition chip style htn described erol et al
plan task network plan extra construct representing set
methods accomplish goal compound task network tasks corresponds
subplans plan
example figure production managers highest level plan produce h figure
tuple
h produce g produce h f rom g f ore
f ore indices subplans decomposition referring produce g
produce h f rom g respectively conditions defined produce h rely
conditions defined primitive plans refinement plan moving part
bin first input tray transport tuple
h start move f inish move meets
plan decomposes two half moves help capture important intermediate effects
parent orders children meets relation bind together single move
start move plan
h bin available f ree transport f ull tray
bin available f ull bin f ull tray f ree transport
bin available f ree transport f ull bin f ull tray
primitive
f inish move plan
h bin available f ree transport f ull bin f ull tray
bin available f ree transport f ull bin f ull tray
bin tray available f ree transport f ull bin f ull tray
primitive
split move plan two parts order ensure action executes
concurrently one use transport part input tray would incorrect
instead specify f ree transport incondition single plan another agent could
instance use transport time f ree transport incondition would agree
f ree transport incondition move action however specification still
insufficient since two pairs start move f inish move actions could start end
time without conflict get around allowing planner reason
move plan parent plans effect hiding transition start finish actions
representing transition f ree f ree without knowing transition


fia bstract r easoning p lanning c oordination

take place modeler ensures another move plan tries use transport concurrently
one cause conflict
postcondition required incondition specify whether incondition changes
clarifies semantics inconditions conditions hold plan execution
whether caused action necessary conditions successful execution
executions
informally execution chip recursively defined instance decomposition
ordering subplans executions intuitively executing plan agent chooses plans
start time refined determining points time conditions must hold
witnesses finish time formalism helps us reason outcomes different ways
execute group plans describe state transitions define summary information
execution e chip p tuple hd ts f ts e f e positive non zero real numbers
representing start finish times execution e ts f thus instantaneous actions
explicitly represented e set subplan executions representing decomposition plan p
execution e specifically p plan contains exactly one execution
subplans plan contains one execution one subplans
empty primitive addition subplan executions e ts e f e must
consistent relations specified order p first subplan start must start
time p ts e ts e last subplan finish must finish time
p f e f e possible executions plan p set e p includes possible
instantiations execution p meaning possible values tuple hd ts f obeying
rules stated
example section execution production managers top level plan
produce h would e e produce h e might h e e e
e produce g e e produce h f rom g means execution produce h
begins time ends time
convenience subexecutions execution e subex e defined recursively
set subplan executions es decomposition unioned subexecutions
histories runs
agent reasoning summary information make decisions abstract levels needs
first able reason chips section complete semantics chips
describing affect state time agent execute plan many different
ways different contexts need able quantify possible worlds histories
agents fulfill plans different ways defining history define run
transformation state time history executions formalization
histories runs follows closely fagin et al describing multiagent execution
state world truth assignment set propositions representing aspect
environment refer state set true propositional variables history
universal quantification weld single plan could agent agent productionmanager
transport agent condition would exclude concurrent access transport could
simply specified transport non consumable resource maximum capacity one



fic lement urfee barrett

h tuple si e set plan executions agents occurring h si
initial state h plan begins executing history h hypothetical world begins
si initial state executions e h occur particular history
manufacturing domain might initial state shown figure parts machines
available transports free set executions e would contain execution
produce h maintenance move parts subexecutions
run r function mapping history time point states gives complete description
state world evolves time time ranges positive real numbers
axiom
r h si
axiom
v r h v r h
p e p e h v p ts e p v post p f e p
p e p e h v p ts e p v post p f e p
axiom states world initial state time zero axiom states predicate
v true time already true beforehand plan asserts v incondition
postcondition case plan asserts v plan starts inconditions
asserted right start small positive real number axiom indicates
inconditions postconditions effects
state resource level value integer real consumable resource usage task
depletes resource modeled instantaneously deplete resource subtract usage
current state start task full amount non consumable resource usage task
depletes usage amount start task usage restored added back
resource state end execution task replenish resource negative usage
refer level resource res time history h r res h axioms
describe calculations consumable non consumable resources respectively
axiom
r consumable res h r consumable res h e p e h ts e p usage p consumable res
axiom
r nonconsumable res h r nonconsumable res h
e p e h ts e p usage p nonconsumable res
e p e h f e p usage p nonconsumable res
described chips change state specify conditions
execution succeeds fails stated formally definition execution succeeds
plans preconditions met start postconditions met end inconditions
met throughout duration including start end used resources stay within
value limits throughout duration executions decomposition succeed otherwise
execution fails


fia bstract r easoning p lanning c oordination

definition
succeeds e p h pre p r h ts e p
post p r h f e p
res ts e p f e p usage p res
p r h
min value res r res h max value res
e e p succeeds e h
asserting clobbering achieving undoing
conventional literature often speaks clobbering achieving preconditions plans
weld chips notions slightly different since inconditions clobber
clobbered seen previous section formalizing concepts another undoing
postconditions helps us define summary conditions section however convenient
define first means assert condition figure gives examples executions involved
interactions define terms follows
definition
asserts e p h e p e h
p ts e p
post p f e p
r h
definition states execution e p history h asserts literal time literal
effect p holds state note point beginning definition
use brackets shorthand defining similar terms procedures example saying
b implies c means implies c b implies shorthand help us avoid repetition
cost slightly difficult parsing
definition
achieves clobbers precondition e p e p h
e p e p e h
asserts e p h pre p ts e p
e p asserts e p h asserts e p h ts e p
definition
clobbers post condition e p e p h
e p e p e h
asserts e p h p post p ts e p ts e p f e p
definition
undoes e p e p h
e p e p e h
asserts e p h post p f e p
e p asserts e p h asserts e p h f e p


fic lement urfee barrett

figure interval interactions plan steps
execution achieves clobbers precondition last one last assert
condition negation respectively required likewise execution undoes
postcondition first one first assert negation condition
condition asserted execution e clobbers incondition postcondition e e asserts
negation condition end respectively e achieving effects inconditions
postconditions make sense formalism defined figure shows
different ways execution e achieves clobbers undoes execution e point
asserted required met
external conditions
recognized tsuneto et al external conditions important reasoning potential refinements abstract plans although basic idea define little
differently call external preconditions differentiate conditions
call external postconditions intuitively external precondition group partially ordered
plans precondition one plans achieved another group must
met external group external postconditions similarly undone
plans group net effects group definition states external pre
post condition execution e p pre post condition subplan
achieved undone subplan
definition
external pre post condition e p
h e h e p subex e p
e p e h pre p post p
e p e h achieves pre undoes post condition e p e p h



fia bstract r easoning p lanning c oordination

example figure available g external precondition although g
must exist produce h g supplied execution produce g plan thus available g
met internally making available g internal condition available external precondition internal condition external postcondition needed externally
internally effect produce g releases finished
plan decomposition undoes effect

plan summary information
summary information used abstract solutions guaranteed succeed matter
refined information describes potential conditions underlying
decomposition thus commitments particular plan choices whether single agent
agents made summary information without worrying deeper details
lurk beneath doom commitments htn planners used abstract conditions
guide search e g sacerdoti tsuneto et al rely user defined subset
constraints help detect potential conflicts contrast summary information
used identify potential conflicts
formalisms previous section define summary information
describe method computing non primitive plans section
many detailed definitions section follow structure
previous section first give informal overview key concepts notation
subsequently delve systematically
overview
summary information plan p consists summary pre postconditions presum p
insum p postsum p summary resource usage usagesum p res resource res whether
plan executed way successfully consistent
summary condition whether pre post specifies positive negated literal
additional modal information summary condition associated existence whose
value must may depending whether must hold possible decompositions
abstract operator may hold depending decomposition chosen timing
summary condition f irst last sometimes specifying condition must
hold plans interval execution plan p must achieve clobber summary precondition
c p execution p plan summary information would
achieve clobber condition summarized c plan summary information
p
deriving summary conditions plan p takes input summary conditions immediate subplans p conditions defined chip p pre
postconditions p become must first must must last summary conditions respectively retains existence timing subplan summary conditions parent
depending whether conditions achieved clobbered undone siblings whether
decomposition whether subplan ordered first last whether subplans
share condition subplan first last conditions become sometimes conditions parent parent computed consistent long subplans consistent



fic lement urfee barrett

subplan may clobber summary condition another summarized resources violate
limits
represent summary resource usage three value ranges hlocal min local max persisti
resources local usage occurs within tasks execution persistent usage represents usage lasts task terminates depletable resources summarization
abstract task takes summary resource usages subtasks considers legal orderings subtasks possible usages subintervals within interval
abstract task build multiple usage profiles profiles combined
computing parallel sequential disjunctive usages give summary usage parent task
summary conditions
summary information plan p psum tuple hpresum insum postsum usagesum consistenti
whose members sets summary conditions summarized resource usage consistent flag
indicating whether plan execute consistently internally presum p postsum p summary pre postconditions external pre postconditions p respectively
summary inconditions p insum p contain conditions must hold within execution
p successful condition c one sets tuple h existence timingi c
literal c existence c must may existence c must c called
must condition must hold every successful plan execution convenience usually
write must c c may condition may c true c must hold successful execution
timing summary condition c sometimes f irst last timing c
c insum c incondition must hold throughout potential executions p
holds otherwise timing c sometimes meaning c holds one point least within
execution p condition must define may inconditions
whether may existence timing significantly different may
sometimes planner reasons whether condition may however defined
may sometimes another plan may clobber relationship condition
defined section note incondition chip restricted meaning
must summary incondition timing f irst c presum c holds beginning
execution p otherwise timing sometimes similarly timing last c postsum c
asserted end successful execution p otherwise sometimes although existence
timing syntactically take one value semantically must c may c c
sometimes c
considered modal logic operators describe concepts mix existing
temporal logic dynamic logic pratt notation could forced work found
terminology made definitions much simpler discuss end
section
definitions give formal semantics existence timing representative
condition types summary conditions plan defined recursively depend
summary conditions plans immediate subplans instead complete decomposition single description summary information could represent many different plan hierarchies
quantify plans p whose subplans summary information
plan p summarized could defined existence timing properties conditions
entire hierarchy deriving summary conditions would expensive



fia bstract r easoning p lanning c oordination

solving one main purposes summary information reduce
computation reason would expensive
worst case legal orderings plan steps must explored determine whether condition
must may discuss example end subsection
definition
must may f irst precondition p
p hpre p p post p type p subplans p order p
summary f ormation f subplans p summary f ormation f subplans p
h e p e h e p subex e p true external precondition e p
e p e h ts e p ts e p pre p

definition
must incondition p
p hpre p p post p type p subplans p order p
summary f ormation f subplans p summary f ormation f subplans p
h e p e h e p subex e p ts e p f e p
e p e h ts e p f e p p

definition
must may sometimes incondition p
p hpre p p post p type p subplans p order p
summary f ormation f subplans p summary f ormation f subplans p
h e p e h e p subex e p ts e p f e p
e p e h ts e p pre p
ts e p f e p p
f e p post p
definition states f irst precondition p external precondition required beginning execution p conditions p
summary information ordering subplans p last postcondition asserted
end execution substitute pre post ts f last two lines definition must may sometimes precondition must may external precondition
f irst precondition sometimes postcondition defined similarly definition states literal
must incondition plan p time isolated execution p
summary information p executing plan p incondition definition
states must may sometimes incondition plan p condition required
execution plan p summary information ordering
subplans p
consistent flag boolean indicating whether plan plan summary information ordering subplans would execute successfully matter decomposed matter subplans executed definition says possible


fic lement urfee barrett

executions succeed consistent plan similar cananyway relation
defined section include whether plan definitely succeed
summary information requires exponential computation see whether conflicts
subplans resolved computation wait done summary
information fully derived
definition
consistent p
p hpre p p post p usage p type p subplans p order p
summary f ormation f subplans p summary f ormation f subplans p
h e p e p e p succeeds
subset summary conditions production managers top level plan
figure following literal modal tags existence timing information mu
must may f f irst l last sometimes
production managers produce h plan
summary preconditions
available muf available mas available mas
summary inconditions
available mus available mas available mus available g mus
available mus available mas available mus available g mus
available h mus available h mus
summary postconditions
available mus available mas available mus available g mus
available h mul

available summary precondition may condition production manager
may end chooses use instead produce g available f irst summary precondition part must used beginning execution transported
one machines machines needed sometime parts transported
sometimes first conditions needed point time beginning execution
production manager may use produce g available summary
incondition produce h available available inconditions
consistent sometimes conditions implying hold different times
plans execution contrast conditions would conflict must
meaning must hold throughout every possible execution plan
summary condition available must postcondition top level plan
definitely consumed make g produced plan decomposition
produce h f rom g even though available g effect produce g external
postcondition produce h undone produce h f rom g consumes g
make h available h last summary postcondition production manager releases
h end execution available last manager finishes
moving h storage
notice available may summary precondition however matter hierarchy decomposed must used produce h available must established


fia bstract r easoning p lanning c oordination

externally production managers plan summary information defined terms
summary information immediate subplans subplans produce h see
produce g available mas precondition available mas postcondition
would achieve available muf precondition produce h f rom g summary
information tell us precondition produce g exists postcondition
exists necessary condition determine derived precondition produce h must
condition thus may augmented summary information subsets conditions
existed together hunting combinations temporal orderings condition subsets among
subplans derive summary conditions would basically adaptation htn summary information intended improve instead derive summary information
polynomial time use improve htn exponentially explain section tradeoff made beginning section defining summary conditions
terms immediate subplans instead entire hierarchy abstraction involves loss
information loss enables computational gains
summary condition relationships
order derive summary conditions according definitions need able recognize
achieve clobber undo relationships summary conditions basic chip
conditions give definitions build constructs
reasoning temporal relationships described appendix
achieving clobbering similar define together definition states
plan p must achieve clobber summary precondition c p executions
two plans p p summary information ordering constraints p
p execution p one subexecutions would achieve clobber external precondition
c p
definition
must achieve clobber precondition p c p psum order
h h psum order p p e p e p
p p summary ordering f ormation p p
e p subex e p e p subex e p
achieve clobber precondition e p c e p h
external precondition c e p
achieving clobbering postconditions defined definition substituting post pre removing last line inconditions additionally substituting gives definitions may achieve clobber furthermore definitions
must may undo obtained substituting post pre undo achieve definition note mentioned section achieving inconditions postconditions
make sense formalism
interactions given figure figure build
others detailed appendix b use interval point algebra determine whether plan must
may assert summary condition time another plan requires summary
condition hold similar definition must achieve chip conditions figure says p


fic lement urfee barrett

must achieve clobber
input plan p summary condition c plan p psum order
output true f alse whether p must achieve clobber c
begin function
c p post p
c c c must c
c insum p p must assert c c return unde f ined true
c postsum p p must assert c c return unde f ined true
c presum p p must assert c c
set assertion inbetween f alse
c p post p p psum assertion inbetween f alse
p may assert c c
p may assert c c
c c c
p must assert c c
p must assert c c
c c c must c
set assertion inbetween true
assertion inbetween return true
return f alse
end function

figure whether plan must achieve clobber summary condition
achieves summary condition c must asserts condition must hold
plans may assert condition negative may achieve
figure mainly differs p may assert condition beforehand plan
must assert undo achieve swapping c
c must may assert lines
complexity determining must may clobber inconditions postconditions simply
c check c conditions p conditions hashed constant time
rest cases complexity walking summary conditions
checking p c nc maximum c summary conditions n plans
represented psum worst case summary conditions summarize propositional
variable nc conditions must visited
lets look examples relationships figure p equip tool mayclobber c available mas summary preconditions p produce g
history equip tool ends produce g starts calibrate starts
produce g starts figure b p build h must achieve c available h muf summary preconditions p move h c available h mul summary postconditions
build h histories build h attempts assert c move h requires c
met plan execution attempts assert condition availability
h equip tool may clobber c available muf summary preconditions
build h even though equip tool asserts c available mul c required
met calibrate must assert available mua time
equip tool asserts c c required thus calibrate must undo equip tool



fia bstract r easoning p lanning c oordination

may achieve clobber
input plan p summary condition c plan p
output true f alse whether p may achieve clobber c
begin function
c p post p
c c c
c insum p p may assert c c return unde f ined true
c postsum p p may assert c c return unde f ined true
c presum p p may assert c c
set assertion inbetween f alse
c p post p p psum assertion inbetween f alse
p must assert c c
p must assert c c
c c c must c
set assertion inbetween true
assertion inbetween return true
return f alse
end function

figure whether plan may achieve clobber summary condition


produce h
produce g

produce h g
move g

build h

move h

service
move

equip

tool

calibrate

tool

b

produce h
produce h g

produce g

move g

move
tool

build h

move h

service

equip

calibrate

tool

figure production facilities managers plans partially expanded managers plans
unordered respect b equip tool must clobber available mal
produce g calibrate must clobber available muf build h

summary postcondition calibrate cannot assert postcondition available mul
build h requires available muf calibrate must clobber summary precondition



fic lement urfee barrett

deriving summary conditions
determine interactions abstract plans summary
conditions create derives summary conditions according definitions section figure shows pseudocode method deriving
summary conditions plan p recursive first summary information derived ps
subplans conditions added ps conditions rest
derives summary conditions ps subplans whether p consistent depends
consistency subplans whether summary conditions resource usages
conflict braces used slightly different semantics used
brackets expression x interpreted simply x respectively
definitions temporal relationships f irst covers
appendix adds copies condition set one condition exist
literal conditions information may overwritten literal cases
must overwrites may f irst last overwrite sometimes vice versa
uses recursion procedure assumed work plans whose expansion finite
summary resource usage
section define representation capturing ranges usage local task interval depleted usage lasting end interval introduce
summarization captures ranges uncertainty represented decomposition choices plans partial temporal orderings plan subtasks representation
allows coordinator planner reason potential conflicts set tasks
discuss reasoning later section although referred resources variables could
durations additive costs rewards
r epresentation
start example simplicity motivates choice representation consider
task coordinating collection rovers explore environment around lander
mars exploration takes form visiting different locations making observations
traversal locations follows established paths minimize effort risk paths combine form network one mapped figure vertices denote distinguished
locations edges denote allowed paths thinner edges harder traverse labeled points
associated observation goals paths hard ground others loose
sand traversal harder since rover slip
figure gives example abstract task imagine rover wants make early
morning trip point point b example map trip sun slowly rises
horizon giving rover ability progressively use soak rays tasks provide
solar power non consumable resource motors wheels addition collecting photons
morning traverse moves rover resultant go tasks require path dependent amounts
power rover traveling point point b take number paths shortest
three involve following one two three steps
important confuse power battery energy power source e g battery solar panels makes fixed
amount power watts available point time batterys energy watt hours reduced integral
total use power time



fia bstract r easoning p lanning c oordination

derive summary information
input plan p
output psum
begin function
derive summary information
p p
v
set consistent p p p consistent p
pre p add h must f irsti presum p
p add h must alwaysi insum p
post p add h must lasti postsum p
summary condition c p p
set c c
c presum p postsum p
c must achieved undone must clobbered within p
type p p f irst last
temporally ordered subplan according order p
sometimes f irst last subplan p
f irst last c condition presum p postsum p
set timing c sometimes
c may achieved undone may clobbered p p
p p must c condition presum p postsum p
set existence c may
copy c presum p postsum p
c insum p p f irst last according order p
must c c f irst last according order p
set existence c must
set p
set allalways true
p p c insum p
c c
c add p p
else set allalways f alse
else allalways f alse
c type p p covers p according order p
type p allalways
set timing c
add c insum p
c may clobbered set consistent f alse
usagesum p summarizeresourceusage p section
consistent usagesum p f alse set consistent p f alse
end function

figure deriving summary information
summarized resource usage consists ranges potential resource usage amounts
performing abstract task represent summary information plan p
resource res structure
usagesum p res hlocal min p res local max p res persist p res



fic lement urfee barrett




b
c
f
e

figure example map established paths points rover domain
morning activities
move b
soak rays soak rays soak rays
use w use w use w
min
min
min
go
use w
min

take low path

go
use w
min

high path
middle path
go b
go b use w go go b
use w min use w use w
min
min min

figure tree defining rovers tasks resource usages
resources local usage occurs within ps execution persistent usage represents
usage lasts execution terminates consumable resources
definition
usagesum p res
h minhh e p e h mints e p f e p r res h maxhh e p e h mints e p f e p r res h
minhh e p e h maxts e p f e p r res h maxhh e p e h maxts e p f e p r res h
minhh e p e h r res h f e p
maxhh e p e h r res h f e p

context definition set histories h value res initial
state e h contains execution p subexecutions thus r res h term
combined usage res time executions hierarchy defined section
maximum local min highest among histories lowest point usage
ps execution usage ranges capture multiple possible usage profiles task multiple
decomposition choices timing choices among loosely constrained subtasks example
high path task h summary power use minute interval case
ranges single points due uncertainty task simply uses watts minutes
followed watts minutes move b task provides slightly complex example
due decompositional uncertainty task h summary power use
minute interval cases persist solar power non consumable
resource
example reasoning resource usage summaries suppose watts power
available move b task given local max know
enough power matter task decomposed raising available power watts makes
task executable depending gets decomposed scheduled raising
watts makes task executable possible decompositions


fia bstract r easoning p lanning c oordination

representation abstract uncertain metric resource usage seen extension
tracking optimistic pessimistic resource levels drabble tate computing
upper lower bounds resource usage abstract plan gives information
whether lower upper bound constraints resource may must must violated
complete representing upper lower bounds ranges bounds
potential histories certainly know whether bounds may must must violated
histories example tracked one range local usage
would know definitely conflict watts available knowing
extra information avoid exploration infeasible search space
r esource ummarization lgorithm
state summarization section recursively propagates summary conditions upwards hierarchys leaves resource summarization takes
starting leaves finds primitive tasks use constant amounts
resource resource summary task x units resource h x x x x
h x x x x x x tasks duration non consumable consumable resources respectively
moving tree summarization comes branch
branch combined summary usage comes computation
h mincchildren lb local min c maxcchildren ub local min c
mincchildren lb local max c maxcchildren ub local max c
mincchildren lb persist c
maxcchildren ub persist c


lb ub extract lower bound upper bound range respectively children
denote branchs children durations extended length longest child
duration extension alters childs resource summary information childs usage profile
zero resource usage extension instance determining resource usage
move b combines two minute tasks minute task resulting
summary information describes minute abstract task whose profile might zero watt
power usage minutes extension move b local min instead
planners reason variable durations could use duration ranging

computing branchs summary information bit complicated due timing
choices among loosely constrained subtasks take x path examples illustrate simplest subcase subtasks tightly constrained execute serially profiles appended together
resulting summary usage information comes serial computation
h mincchildren lb local min c lb c mincchildren ub local min c ub c
pre
pre
maxcchildren lb local max c lb c maxcchildren ub local max c ub c
cchildren lb persist c
cchildren ub persist c

pre

pre

pre
pre
lb
c ub
c respective lower upper bounds cumulative persistent usages children execute c computations form
computations final persist
case subtasks execute parallel identical durations slightly simpler
usage profiles add together branchs resultant summary usage comes



fic lement urfee barrett

move b
soak rays




soak rays


soak rays


figure possible task ordering rovers morning activities resulting subintervals
parallel computation
h cchildren lb local min c
maxcchildren ub local min c non
ub c
non
mincchildren lb local max c lb c cchildren ub local max c
cchildren lb persist c
cchildren ub persist c

non
non
ub c lb c respective sums local max upper bounds local min
lower bounds children except c
handle tasks loose temporal constraints consider legal orderings child
task endpoints example rovers early morning tasks three serial solar energy collection subtasks running parallel subtask drive location b figure shows
one possible ordering subtask endpoints breaks move b three pieces
two soak rays children half given ordering summarization
use endpoints children determine subintervals compute summary information
child task subinterval combination combine parallel subinterval summaries
parallel computation chain subintervals together serialand computation finally tasks summary computed combining summaries
possible orderings computation
describe step generates different summary resource usages subintervals
child task child task summary resource usage h b c e f contributes one two
summary resource usages intersecting subinterval

h b c h

first usage tighter b c local ranges second looser local
ranges since b c bounds apply subintervals containing subtasks minimum
maximum usages tighter ranges apply one subtasks intersecting subintervals
minimum maximum usages may occur subinterval symmetry arguments
let us connect computation thus one subinterval tighter local ranges
intersecting subintervals get looser local ranges extra complexity comes
investigate subtask subinterval assignment options instance three subintervals
intersecting move b figure three different assignments summary resource usages
subintervals placing one subinterval two
placement options subtask n subintervals n possible subinterval assignments
child tasks n alternate assignments nm combinations
potential subtask subinterval summary resource usage assignments thus propagating summary
information branch exponential number subtasks multiple internal
summary resource usages last interval intersecting child task replace e f persist



fia bstract r easoning p lanning c oordination

subintervals however since number subtasks controlled domain modeler
usually bounded constant computation tractable addition summary information
often derived offline domain propagation takes form
consistent ordering endpoints
consistent subtask subinterval summary usage assignment
use parallel computations combine subtask subinterval summary
usages subinterval
use serial computation subintervals combined summary usages
get consistent summary usage
use computation combine consistent summary usages get tasks summary
usage
described derive summary information discuss use

identifying abstract solutions
point detailed deriving summary conditions reasoning
potential may definite must interactions tasks summary information addition outlined deriving summarized resource usage
yet discussed identify solutions abstract levels section
interactions summary conditions summarized metric resource usages identify potentially
resolvable threats unresolvable conflicts among plans group agents
threats summary conditions
agents attempt resolve conflicts among plans considering commitments particular
decompositions ordering constraints order agents must able identify
remaining conflicts threats among plans present simple reasoning
threats abstract plans required conditions
formally set chips p ordering constraints order threat abstract plan
p p summary condition c another plan p p exists iff p may clobber c say
threat unresolvable p must clobber c must c decomposition choices
ordering constraints could added resolve threat
simple identifying threats check see nc summary
conditions n plans psum must may clobbered plan since complexity
checking see particular condition must may clobbered nc
complexity n c
many coordination tasks agents could determine certain temporal constraints
plans decomposed way cananyway constraints
way successfully decomposed mightsomeway make coordination
decisions abstract levels without entering potentially costly search valid plan merges lower
levels formal definitions cananyway mightsomeway



fic lement urfee barrett



produce h

b

maintenance

produce h
maintenance
move parts

move parts
c

produce h
produce g

produce h g
maintenance
service
service

service





move
tool

move parts

figure top level plans managers manufacturing domain
definition
cananyway mightsomeway order psum
h p summary f ormation psum h h p order
e e h succeeds e h
definition states plans summary information psum ordering constraints
execute way sets plans p summary information psum
execute successfully history mightsomeway true set plans
could possibly execute successfully could describe cansomeway order psum
mightanyway rel psum fashion obvious addition could
influence search exploring relations may interesting topic future
figure three top level plans managers unordered respect
leaf plans partially expanded hierarchies comprise psum arrows represent constraints
order cananyway produce g maintenance move parts false several conflicts use machines transports could occur certain executions
plans described section figure however mightsomeway produce g
maintenance move parts true plans might way execute successfully
shown figure b ordering constraints figure b cananyway
produce g maintenance move parts true plans execute
way consistent ordering constraints without conflict figure b example
mightsomeway false calibrate must clobber available muf summary precondition build h
shown figure determining cananyway summary conditions
simple needs check threats mightsomeway complicated
checking unresolvable threat enough shown figure case
plan p must clobber p p could come achieve precondition p
thus p may clobbers p p however obviously p clobber one


fia bstract r easoning p lanning c oordination

cananyway mightsomeway
input order psum
output true f alse
begin function
psum psum
consistent psum f alse return f alse
p sum psum
summary condition c psum
p may clobber must clobber c
c may must must
return f alse
resource res
cananyway mightsomeway order psum res see section
return false
return true
end function

figure determining whether plans given summary information cananyway
mightsomeway execute successfully
p
l

p
l

l

l

p
l

l

l

figure mightsomeway false even though must clobber relationship
mightsomeway false order determine mightsomeway f alse agent must exhaustively
search exponential number schedules see conflicts resolved instead
performing exponential search determine mightsomeway use simple
figure checks must clobber relationships section describe flexible
search conflict free abstract plans scheduling abstract level
thus cananyway sound complete mightsomeway
complete sound means determining mightsomeway sound
complete still make use sound complete coordination section complexity n c since
nc procedures determining must may clobber must run nc conditions c
summary conditions n plans represented psum
summary resource usage threats
planners detect threats resource constraints different ways planner reasons partially ordered actions must consider combinations actions overlap together
exceed fall resources maximum value minimum value polynomial



fic lement urfee barrett

ixtet planner laborie ghallab planners consider total order plans simply project levels resource initial state plan
summing overlapping usages see conflicts e g chien et al b
finding conflicts involving summarized resource usages work way
partial order planner resultant usage clusters actions tested paralleland section total order planner level resource represented
summarized usage initially h x x x x x x consumable resource initial level
x h x x x x non consumable resource subinterval
start end times schedule tasks summary usage computed
parallel level resource computed subinterval
propagating persistent usages serial
decide cananyway mightsomeway defined section terms summary usage values resulting invocations parallel serial propagation end section cananyway order psum res true
potential threats discover threat ever compute interval

lb local min min value res lb persist min value res
ub local max max value res ub persist max value res

mightsomeway order psum res true possible run potentially
threats serial discovers run returns summary usage
ub local min min value res lb persist min value res
lb local max max value res ub persist max value res

mechanisms deriving summary information evaluating plans
summarizations discuss exploit coordination

hierarchical coordination
earlier defined reasoning group agents plans multiple levels
abstraction describe agents efficiently plan coordinate summary
information describe coordination searches ways restrict decomposition ordering collective actions agent order resolve conflicts
maximizing utilities individual agents global utility group
starts making decisions abstract level needed
decomposes agents plans top fashion idea introduce information needed introducing irrelevant details complicates search increases communication
describing top coordination describe search techniques
heuristics use exploit summary information
top hierarchical coordination
formalism summary conditions culminated section determine set
plans abstract primitive partial set ordering constraints definitely conflict free
cananyway unresolvable conflicts mightsomeway integrate
one searches consistent plan one agents particular
describe shown sound complete clement search starts
top level plans agent solution one possible conflicts among


fia bstract r easoning p lanning c oordination

agents plans tries solution top level expands hierarchies
deeper deeper optimal solution found search space exhausted
pseudocode description given figure
state search partially elaborated plan represent set plans one
agent set temporal constraints set blocked plans subplans plans
leaves partially expanded hierarchies agents set temporal constraints
includes synchronization constraints added search addition dictated
agents individual hierarchical plans blocked subplans keep track pruned subplans
decisions made search decentralized fashion agents negotiate
ordering constraints adopt choices subplans accomplish higher level plans
decompositions explore first described specify
commit negotiation technique provide mechanisms identifying choices
agents negotiate although agents make search decisions decentralized fashion describe given centralized process requests summary
information agents coordinated
pseudocode figure coordinating agent collects summary information
agents plans decomposes queue keeps track expanded search states
cananyway relation holds search state dominates function determines current
solutions better every agent solution represented current search state
keeps solution dominated mightsomeway false search space rooted
current search state pruned otherwise coordinator applies operators generate
search states
operators generating successor search states expanding non primitive plans blocking subplans adding temporal constraints pairs plans agent expands one
plans plans summary conditions replaced original conditions
parent plan subplans summary information ordering constraints added
search state subplan plan added selected subplans
blocked applyoperator called select block operators search states
generated selectable blockable subplan respectively blocking subplan
effective resolving constraint subplans involved example
inventory manager plans use transport production manager could block subplans
transport leaving subplans transport conflict inventory managers
plan lead least commitment abstract solutions leave agents flexibility selecting among multiple applicable remaining subplans agents take another
selecting subplan effectively blocking others investigate preferred choice one
likely avoids conflicts
operator add temporal constraint search state created alternative temporal constraint could added successor states enqueued
backtracking needed alternative tried adding temporal constraints generate search states ordering consistent global local constraints
implementation add constraints help resolve threats determined
must may achieves clobbers plan expanded selected ordering
constraints must updated subplans added
soundness completeness coordination depends soundness
completeness identifying solutions complete exploration search space soundness


fic lement urfee barrett

concurrent hierarchical coordination
input set top level plans initial state
output set solutions pair order constraints blocked plan choices
begin function
summarized plans
plan p plans
p get summary information plan p
summarized plans summarized plans p
end
threats p p p p summarized plans mayclobber p p

threats
queue
solutions
loop
queue
return solutions
order blocked threats pop queue
cananyway initial state summarized plans order blocked
solution order blocked
solutions solutions solution
sol sol solutions
dominates sol sol
solutions solutions sol
mightsomeway initial state summarized plans order blocked
operator choose expand select block constrain
queue queue applyoperator operator summarized plans order blocked
return solutions
end function

figure concurrent hierarchical coordination
completeness defined respect achieving particular goal predicates resolving
conflicts plan hierarchies domain modeler may represent goals abstract chips
decompose possible plans accomplish series actions agent execute
successfully
consider would coordinated plans manufacturing agents
beginning search coordinating agent gathers summary information top level
plans three agents plans first ordering constraints order empty
first search state shown figure popped queue cananyway false
mightsomeway true state described earlier section coordinator chooses
operator apply search state could choose constrain order maintenance
plan produce h resolve conflicts two plans order updated
constraint search state inserted queue according ranking
function next iteration loop search state queue inserted
popped coordinator finds cananyway false mightsomeway true since
move parts may still conflict plans use transports choose constrain
produce h move parts resolve remaining conflicts detected next cycle
search loop cananyway found true search state shown figure b



fia bstract r easoning p lanning c oordination

plans two constraints order empty set blocked plans added solution
since previously found solution dominates dominates function uses domain
specific criteria determining solution value alternative kept
inferior compared another dropped manufacturing domain one solution
dominates another finish time least one agent earlier finish times later
agents search continues alternative superior solutions although agents
may decide terminate search interest time
search techniques heuristics
although summary information valuable finding conflict free coordinated plans abstract
levels information valuable directing search avoid branches search
space lead inconsistent suboptimal coordinated plans coordinator prune away
inconsistent coordinated plans abstract level quick check see mightsomeway
false example search somehow reached state shown figure b coordinator
could backtrack expanding hierarchies avoid reasoning details
plans must fail
another strategy first expand plans involved threats sake completeness order plan expansions matter long expanded point
search trail cannot pruned employing expand threats first emtf
heuristic aims driving search hierarchy subplan causing conflicts others resolved quickly similar constrained
variable heuristic often employed constraint satisfaction example facilities
inventory managers wished execute plans concurrently shown figure
abstract level coordinator would conflicts use transports
moving parts instead decomposing produce h reasoning plan details
conflicts emtf heuristic would choose decompose maintenance move parts
conflicts decomposing maintenance agents resolve remaining
conflicts still execute concurrently
another heuristic coordinator use parallel emtf choose fewest threats
first cftf search orders states search queue ascending numbers threats
left resolve effect least constraining value heuristic used constraint satisfaction
approaches mentioned section threats identified cananyway
trying resolve threats coordinated plan search states fewer conflicts hoped
solutions found quickly emtf heuristic ordering subplans expand
cftf effect orders subplan choices example production manager chooses
use machine instead produce g coordinator likely closer solution
fewer conflicts resolve heuristic applied selecting subplan
choices choosing temporal constraints variable bindings search operator
entire set operators
addition trying optimal solutions style branch bound search
coordinator use cost abstract solutions prune away branches search space whose
minimum cost greater maximum cost current best solution role
dominates function description coordination section usually



fic lement urfee barrett



maintenance
produce h
move parts

b

maintenance
service
service

service





move
tool

produce h

move parts

figure

emtf

heuristic resolving conflicts decomposing maintenance plan

assumes cost utility information decomposable hierarchy actions cost
abstract action function decompositions

complexity analyses
even though planner coordinator use search techniques described section
prune search space able solutions multiple levels abstraction reduce
computation much doubly exponentially section give example
analyze complexity scheduling characterize cost reduction
conditions occurs
agent interleaves execution coordination often must limit total computation execution cost required achieve goals described section
able search solutions different levels abstraction manufacturing example
implementation centralized coordinator uses cpu seconds solution top level agents plans shown figure b define cost execution
makespan completion time coordinated plan cost solution
makespan production managers plan facilities managers inventory
managers solution figure c coordinator required cpu seconds
makespan coordinated plan another solution found intermediate level
abstraction taking cpu seconds makespan little effort
expanded hierarchy intermediate level cost solution
reduced thus overall cost reduced coordinating intermediate levels
coordinating higher levels abstraction less costly
fewer plan steps even though fewer plans higher levels plans may
greater numbers summary conditions reason collected much
greater set plans argue even worst case number summary
conditions per plan increases exponentially hierarchy finding solutions abstract levels
expected exponentially cheaper lower levels first analyze complexity


fia bstract r easoning p lanning c oordination

summarization help reader understand summary conditions collect
greater sets higher levels
complexity summarization
consider hierarchy n total plans b subplans non primitive plan depth starting
zero root shown figure procedure deriving summary conditions works
basically propagating conditions primitives hierarchy abstract
plans conditions non primitive plan depend immediate subplans deriving summary conditions done quickly number subplans large
derivation mainly involves checking achieve clobber undo interactions among
subplans possible total orderings subplans described section checking
one relations one summary condition one subplan bs b subplans
summary conditions discussed section since bs conditions must
checked set subplans deriving summary conditions one plan subplans
b
however maximum number summary conditions subplan grows exponentially
hierarchy since worst case summary conditions merge summarization
happens conditions subplan completely different propositions variables
sibling subplan case separate summary condition generated
summary condition subplan children share conditions variable
information collapsed single summary condition parent plan
shown third column table figure plan lowest level c
summary conditions derived c pre postconditions plan level derives c
summary conditions conditions c b subplans giving c bc summary conditions bc worst case bdi c plan level hierarchy
plan c non summary conditions thus complexity summarizing plan
level subplans level b b c b di c bi plans
level second column figure complexity summarizing set plans level
bi b di c b di c shown fourth column figure thus complexity
di c summation
summarizing entire hierarchy plans would
b b


dominates complexity simplified b c n bd plans
hierarchy write simply n c square size hierarchy
best case conditions variable plan c summary

conditions thus complexity summarizing hierarchy
b b c
simplifies bd c nbc case summarization conditions tractable
discussed section summarization resources tractable
complexity finding abstract solutions
order resolve conflicts potentially arrive solution particular level expansion
hierarchy coordination checks threats plans particular
ordering constraints level checking threats involves finding clobber relations among
plans summary conditions complexity finding threats among n plans
summary conditions n shown section mightsomeway
hierarchy expanded level n bi plans frontier expansion plan


fic lement urfee barrett

level plans conds operations test operations solution
plan derive summ info solution candidate space







b











b







b







bdc

b bd c
b dc







b

bd c

bb bd c
b c

b b c
b dc

kb



b

bd c b b bd c
b c

b b c
b dc

kb



bd

b c

bd b bc
bd c

b b c kb
b dc



bd

c b c
bc

bd b c
bd c

b bc kb
b dc



bd

c



b dc

kb



bi

bd ic

b ic

b dc

kbi









figure complexity threat identification resolution abstract levels
bdi c summary conditions shown fifth column table figure
worst case complexity checking threats one synchronization set plans level
b bdi c b c notice drops formula meaning complexity
checking candidate solution independent depth level best case summary
conditions fully merge plan c summary conditions complexity checking
candidate solution b c factor b di faster worst case
however may check many synchronizations particular level finding
solution exhausting search space fact search complexity grows exponentially
number plans thus shown last column table figure search space

kb bi plans level constant k thus search space grows doubly exponentially
hierarchy number plan steps
refinement coordination conflict detection basic operation
done resolving conflicts include effect size conditions
addition plan steps complexity coordination must multiply

complexity check threats thus complexity kb b c summary information

merge kb b c summary information fully merges complexity

resolving conflicts primitive level kb b c resolving conflicts abstract


level speeds search doubly exponentially factor kb b even summary information
merge summarization completely merges speedup factor


kb b b di
fact np complete clement
georgeff chose cluster multiple operators critical regions synchronize fewer regions
since would many fewer interleavings check exploiting hierarchical structure plans
use clusters predefined hierarchy kind advantage without needing cluster bottom




fia bstract r easoning p lanning c oordination

level




branching
factor b






n
c constraints
per hierarchy

v
variables

figure schedule n task hierarchies c constraints v variables
plans analysis case plans able prune
branches higher levels summary information greatly improve search despite
overhead deriving summary conditions pruning effectively reduces branching
factor since branch eliminated investigating details thus complexity

number plan steps becomes k bp fraction p b branches pruned thus
pruning create exponential reduction search
scheduling complexity
local search planner e g aspen chien et al b backtrack
solved one might expect complexity advantages refinement planner however search operations local search planner different
previous study technique called aggregation eliminates search inefficiencies lower levels
detail task hierarchies operating hierarchies single tasks knight rabideau chien
thus immediately clear additional improvements scheduler could obtained
summary information improvements significant first must
provide background aggregation
moving tasks central scheduling operation iterative repair planners planner
effectively schedule tasks moving related groups tasks preserve constraints among
hierarchical task representations common way representing groups constraints aggregation involves moving fully detailed abstract task hierarchy preserving
temporal ordering constraints among subtasks moving individual tasks independently
parent siblings subtasks shown much less efficient knight et al valid placements task hierarchy schedule computed state resource usage profiles
hierarchy tasks context movement hierarchys profile represents one instantiation decomposition temporal ordering abstract task
hierarchy
consider schedule n task hierarchies maximum branching factor b expanded
maximum depth shown figure suppose hierarchy c constraints v
variables states metric resources move hierarchy tasks aggregation scheduler



fic lement urfee barrett

must compute valid intervals resource variable affected hierarchy scheduler
intersects intervals get valid placements abstract tasks children
complexity computing set valid intervals resource cc c number
constraints usages abstract task children variable c number
constraints tasks schedule variable knight et al n similar
task hierarchies entire schedule c n c complexity computing valid
intervals nc computation done v resource variables often constant
domain moving task complexity vnc intersection valid intervals
across variables increase complexity complexity tnr
nr valid intervals timeline intersecting intervals pair timelines linear
number intervals pairs timelines need intersected get intersection
set
summary information abstract task represents constraints children
children share constraints resource information collapsed single
summary resource usage abstract task therefore moving abstract task number
different constraints involved may far fewer depending domain scheduler
trying place summarized abstract task among summarized tasks computation valid
placement intervals greatly reduced c vnc smaller consider
two extreme cases constraints fully collapsed cannot collapsed

case tasks hierarchy constraints variable number
constraints hierarchy bd hierarchy depth branching factor number child
tasks per parent b aggregation hierarchies fully detailed first means
complexity moving task vnb c bd consider aggregation
moving partially expanded hierarchy leaves summarized abstract tasks
hierarchies schedule decomposed level bi tasks hierarchy
one summarized constraint representing yet undetailed subtasks beneath
constraint variable c bi complexity moving task vnb thus
moving abstract task summary information factor b di times faster
aggregation worst case number conflicts increases number plan
steps refinement planner worst case complexity resolving conflicts

number plan steps level kb thus refinement summary
di
information make speedups kb b di summary information fully collapses
extreme tasks place constraints different variables case
c hierarchy one constraint per variable fully detailed hierarchies
contain v bd different variables complexity moving task case nbd
moving summarized abstract task tasks schedule decomposed level v
abstract task summarizes constraints subtask hierarchy
beneath constraints different variables constraints combine
summarized thus complexity moving partially expanded hierarchy
fully expanded one case number conflicts change depth
hierarchy conflicts pairs n hierarchies
analysis applies state constraints restrict discussion resource usage constraints simplicity



fia bstract r easoning p lanning c oordination

extreme case summary information reduce complexity scheduling would
incur unnecessary overhead
complexity analyses shown different forms hierarchical solving
need backtrack lower higher levels interacting subproblems reduce size search space exponential factor korf knoblock
planner scheduler summary information witness exponential improvements without
assumption backtracking across abstraction levels occurs within planner coordinator described section current search state mightsomeway another subplan
higher level selected demonstrated search space grows doubly
exponentially hierarchy number plans grows exponentially resolving
conflicts grows exponentially number plans thus long planner coordinator fully expand abstract plans primitive level summary information


merges higher levels search complexity reduced least factor kb b
level search completed depth hierarchy yang suggests
ways exponential speedups obtained subplans interact hierarchy structure
speedups complementary summary information limits decomposition
task hierarchies compresses information manipulated planner scheduler

experiments
experimentally evaluate use summary information coordination
three different domains evacuation domain manufacturing domain described section
multi rover domain domains define performance different ways
range benefits abstract reasoning offers
evaluate described section implementation orders search states
queue generated synchronization operators precede generated
expansion selection operators thus going deeper part hierarchy implementation explores orderings agents plans digging deeper
hierarchy investigating heuristics choosing synchronization decomposition
operators topic future
next section report experiments evacuation domain abstract
reasoning summary information optimal coordination solutions quickly
conventional search strategies optimal solutions evacuation domain minimal global execution times evacuees must transported safety quickly possible section
summary information improves local search performance significantly tasks
within hierarchy constraints resource solutions found
level abstraction evaluate benefits cftf emtf heuristics
iterative repair summary information slow search
domains computation time may insignificant communication costs costs
could terms privacy self interested agents security sensitive information could
obtained malicious agents simply communication delay section multilevel coordination fails reduce communication delay manufacturing domain example
domains expected reduce communication overhead exponentially



fic lement urfee barrett


















figure evacuation
coordinated experiments
section describe experiments evaluate use summary information coordinating group evacuation transports must together retrieve evacuees number locations
constraints routes comparing emtf cftf search techniques described section conventional htn approaches experiments reasoning summary
information finds optimally coordinated plans much quickly prior htn techniques
compare different techniques ordering expansion subplans
plans direct decomposition plan hierarchies search optimal solutions
expansion techniques expand subplans select subplans operators
described section
compare emtfs expansion plans excon heuristic random selection
heuristic excon heuristic tsuneto et al first selects plans achieve external
precondition plans selects one threatens external precondition
case neither achieving threatening plans chooses randomly note
emtf additionally choose expand plans threatened external preconditions
preference whether plan achieves threatens threatened expansion
plans compare cftf depth first dfs random heuristic
compare combination cftf emtf faf fewest alternatives first
heuristic combination dfs excon faf heuristic employ summary
information rather chooses expand select plans fewest subplans
currie tate tsuneto hendler nau since summary information used
threats resolved primitive levels shown faf heuristic
effectively used htn planner tsuneto et al combination dfs excon
shown make great improvements faf domain task interactions
tsuneto et al one domain cftf emtf heuristics together
outperform combinations faf dfs excon
generated evacuation domain transports responsible
visiting certain locations along restricted routes pick evacuees bring back safety
points transports allowed location time coordinator must
ensure transports avoid collisions along single lane routes addition order avoid
risk oncoming danger typhoon enemy attack transports must accomplish
goals quickly possible
suppose two transports located safety points respectively
must visit locations respectively bring evacuees back safe


fia bstract r easoning p lanning c oordination

evacuate
move

make rounds

one switch

switch
clockwise

first route

cw

second route

cw

move

counterclockwise

ccw

ccw

go back

ccw

goto safe loc

move

move

move

move

figure plan hierarchy transport
locations shown figure overlap locations must visit coordinator
must synchronize actions order avoid collision coordinators goal network includes
two unordered tasks one transport evacuate locations responsible
shown figure high level task evacuate decomposes primitive action
moving location ring abstract plan traverse ring make rounds
travel one direction around ring without switching directions switch directions
go clockwise counterclockwise switching switch directions
location f irst route travel farthest location needs visit switched
second route visited locations continues around reaches first
safety point path go back goto sa f e loc move plan case
already location task refined similarly
suppose coordinator gathers summary information plan hierarchy attempts
resolve conflicts looking summary information one level top coordinator
determine finishes evacuating even begins conflicts
since external conditions evacuate plan none routes traversed
solution makespan total completion time steps optimal solution plan
duration seven moves clockwise reaches location starts clockwise
switches directions location winds solution waits location
one time step avoid collision route location location
generated four six eight twelve locations two three four
transports complete overlap locations transports visit performance measured number search states expanded optimal solution
compared heuristics optimal solution number states expanded
solutions highest common quality within memory time bounds chose instead cpu time measure performance order avoid fairness issues respect
implementation details approaches



fic lement urfee barrett

search states expanded


cftf rand












e

cftf emtf

figure comparing emtf random expansion searching optimal solutions

figure comparing emtf excon searching optimal solutions
scatter plot figure shows relative performance combination cftf
combination cftf random expansion cftf rand
chose scatterplots compare capture simply trying
plot three dimensions size complexity note scatter plots axes
scaled logarithmically points diagonal line mean emtf x axis performing better
rand axis fewer search states required optimal solution
performance similar cases cftf emtf outperformed
cftf rand order magnitude figure exhibits similar effect cftf emtf
cftf excon note runs terminated expansion search states data
points ones forming horizontal line top indicate solution found
within memory time constraints performance similar four
points along top cftf excon finds solution thus although emtf greatly
emtf cftf emtf



fia bstract r easoning p lanning c oordination

figure comparing cftf dfs searching optimal solutions
improve performance many rarely performs much worse almost avoids
getting stuck fruitless areas search space compared excon random heuristic
expected since emtf focuses resolving conflicts among problematic plans
first avoids spending lot time reasoning details less problematic plans
combination cftf emtf pruning inconsistent abstract plan spaces branchand bound pruning costly abstract plan spaces described section much
dramatically outperforms techniques reason abstract levels figure shows dfsrand expanding one three orders magnitude states cftf rand runs
terminated expansion search states data points forming
horizontal line top indicate solution found within memory time constraints
avoiding search spaces greater numbers conflicts cftf finds optimal near optimal solutions much quickly figures cftf emtf outperforms faf faf faf
selecting plans dfs excon one two orders magnitude
last two comparisons especially emphasize importance abstract reasoning finding
optimal solutions within maximum expanded search states lowest cutoff point
experiments cftf emtf cftf rand found optimal solutions
cftf excon faf faf found dfs excon dfs rand found three
surprising faf faf performs much better dfs excon evacuation
contrary given tsuneto et al dfs excon dominating
goal interactions believe reproduced
experiments involved hierarchies plans experiments
selection subplans greatly affects performance order subplans expand
believe dfs excon performed worse faf faf faf better choosing
subplans excon faf stronger selecting subplans dfs
however main point section heuristic combinations use summary information solutions prune search space abstract levels cftf emtf cftfexcon cftf rand greatly outperform faf faf dfs excon
dfs rand searching optimal solutions



fic lement urfee barrett

figure comparing use summary information faf heuristic

figure comparing use summary information external conditions
scheduling experiments
experiments describe summary information improves performance significantly tasks within hierarchy constraints resource solutions
found level abstraction time cases abstract reasoning
incurs significant overhead solutions found deeper levels however domains
decomposition choices critical overhead insignificant
cftf heuristic chooses decompositions quickly lead solutions deeper levels
experiments emtf heuristic outperforms simpler heuristic depending
decomposition rate raising questions use aspen system chien
et al b coordinate rover team described next



fia bstract r easoning p lanning c oordination

figure randomly generated rectangular field triangulated waypoints

figure randomly generated waypoints along corridors
p roblem omains
domain involves team rovers must resolve conflicts shared resources generate
two classes maps within rovers move one randomly generate map triangulated waypoints figure generate corridor paths circle locations
three paths center points circle represent narrow paths around obstacles
figure corridor map used evaluate cftf heuristic select subset
points science locations rovers study rocks soil use simple multiple traveling salesman assign routes rovers traverse perform experiments
idea map area around lander constructed image taken upon landing
mars
paths waypoints assigned random capacities one two three
rovers traverse path simultaneously one rover waypoint rovers may
traverse paths opposite directions time constraints modeled metric
resources state variables used ensure rovers locations
leave addition rovers must communicate lander telemetry shared channel
fixed bandwidth metric resource depending terrain waypoints required
bandwidth varies generated two five rovers three six science locations
per rover waypoints general contain fewer waypoints
science goals difficult interactions among rovers
schedules consist abstract task rover decomposition tasks
visiting assigned science location tasks decomposition three shortest
paths waypoints target science location paths decomposition
movements waypoints additional levels hierarchy introduced longer paths
order keep offline resource summarization tractable schedules ranged
tasks



fic lement urfee barrett

e mpirical r esults ars rovers
compare aspen aggregation without summarization three variations
rectangular field domain summary information aspen uses emtf cftf
decomposition heuristics one domain excludes communications channel resource channel
one excludes path capacity restrictions channel excludes neither mixed
since movement tasks reserve channel resource greater improvement performance
expected summary information according complexity analyses section
constraints channel resource collapse summary information derived
higher levels task hierarchy one constraint resource
aspen use summary information hierarchies must fully expanded number
constraints channel resource equivalent number leaf movement tasks
however tasks within rovers hierarchy rarely place constraints path variables
channel domain corresponds worst case summarization
collapses constraints complexity moving abstract task without summary information fully expanded hierarchy summary information partially
expanded hierarchy
figure top exhibits two distributions channel domain
cases points x diagonal aspen summary information finds solution quickly
level abstraction however many cases summary information performs notably worse
points x diagonal discovered finding solution requires
planner dig deeply rovers hierarchies decomposes hierarchies
level solution difference additional time solution two
approaches negligible unless use summary information found solution slightly higher
level abstraction quickly thus time spent reasoning summary information
higher levels incurred unnecessary overhead
worst case analysis section showed summary information advantage even found abstract solutions summary information perform
better abstract solutions found cftf heuristic since branch
choices small differences numbers conflicts actually stochastic nature aspens iterative repair although moving abstract tasks aggregation without
summary information would enabled aspen solutions quickly fully expanded
hierarchies aspen must sometimes move lower level tasks independently parents siblings order resolve conflicts lower levels aspen heuristic tell
level needs move activities sometimes chooses move activities detailed
levels unnecessarily search lower levels search space explodes summary
information search higher levels lower levels abstraction better protects aspen
unnecessary search
figure middle shows significant improvement summary information mixed domain compared channel domain adding channel resource rarely affects use
summary information collapse summary constraints incurs insignificant additional
complexity however channel resource makes scheduling task noticeably difficult
aspen summary information channel domain figure bottom summary information finds solutions abstract level almost immediately still
complicated aspen use summary information support complexity



fia bstract r easoning p lanning c oordination



b

c
figure plots channel b mixed c channel domains
analysis section argues summary information exponentially improves performance
tasks within hierarchy constraints resource solutions
found level abstraction
summary information generated offline domain modeler knows front whether
constraints significantly collapsed thus obvious avoiding cases
reasoning summary information causes unnecessary overhead fully expand start
scheduling hierarchies tasks summary information collapse
complexity moving task hierarchy case whether fully expanded aspen
waste time duplicating efforts level expansion reaching level
finds solution evaluating subject future work
earlier mentioned cftf heuristic effective rectangular field
choice among different paths science location usually make



fic lement urfee barrett

figure performance cftf heuristic

significant difference number conflicts encounteredif rovers cross paths path
choices usually still lead conflict set corridor path choices lead
different corridor get target location usually path avoids conflict
path causes one depending path choices rovers aspen uses
cftf heuristic performance dominates chooses decompositions randomly
two figure reflects experiments coordination section
cftf crucial reducing search time required solutions
order evaluate emtf heuristic iterative repair compared simple
alternative alternative strategy refer level decomposition interleave repair
decomposition separate steps step planner repairs current schedule
number conflicts cannot reduced step decomposes abstract tasks one level
returns step spending enough time particular level expansion appears
effective planner attempts highest decomposition level solutions exist without
wasting time level time spent searching solution level expansion
controlled rate abstract tasks decomposed emtf heuristic implemented
repair method give priority detailing plans involved conflicts
figure shows performance emtf vs level decomposition different rates decomposition three set varied performance plotted points averages
ten runs depending choice rate decomposition probability
task decompose conflict encountered performance varies significantly however best decomposition rate vary making potentially difficult
domain expert choose example figure tested decomposition
rates emtf outperformed use level decomposition time c
decomposition technique make significant difference b choosing
rate emtf made big difference whether use emtf level decomposition although
examples varied performance showed decompo



fia bstract r easoning p lanning c oordination




level decomp


b
b level decomp
c

cpu seconds



c level decomp























emtf decomposition rate

figure performance emtf vs level decomposition heuristics
sition rate around successful suggests domain modeler may able
choose generally successful decomposition rate running performance experiments set
example
demonstrated many complexity analyses section scheduling
summary information gains speedups aggregation resolving conflicts appropriate levels abstraction summary information collapses scheduler gains exponential
speedups addition cftf heuristic enables exponential speedups decomposition
choices varying numbers conflicts
communication overhead
depending bandwidth latency summary information communicated among agents delays due communication overhead vary communication costs
concern one extreme message delay dominates cost sending plan hierarchy
without summary information makes sense extreme bandwidth costs
dominate makes sense send summary information task separate message
requested still cases sending summary information tasks groups
makes sense section explain system designer choose much
summary information send time order reduce communication overhead exponentially
consider simple protocol agents request coordination central coordinating agent
search feasible solution whenever decomposes task coordinator requests
summary information subtasks yet received manufacturing domain
coordinator may already summary information task move part encounters
different instantiation task schema still must request parameters task
coordinator needs subplans plan client agent sends required information
subplans specifying preferences coordinator chooses preferred
experiments used decomposition rate since seemed work well



fic lement urfee barrett



b

figure delay communicating different granularities summary information varying
latency b bandwidth

subplan case must backtrack chooses next preferred subplan
coordinator finds feasible solution sends modifications agent specifying subplans blocked agent must send wait synchronization messages agent
choose send summary information number levels expansion requested
tasks hierarchy
manufacturing described section communication data terms numbers messages size collected point coordinator found
solution figure c data collected cases agents sent summary information
tasks hierarchies one time two levels time two levels
include requested task immediate subplans following table summarizes
numbers total sizes messages sent granularity level information

one task time
two levels time


number messages




total size bytes




assuming coordinator must wait requested information continuing search
request one task one agent time coordination delayed amount
time depending bandwidth latency message passing total delay calculated n b n number messages sent latency seconds
total size messages b bandwidth bytes per second use n instead n
assume agents transmit first top level summary information message
time three messages actually incur delay instead
figure shows communication delay varies three granularities information
fixed bandwidth bytes second address lack realism example
shortly latency less seconds sending summary information task
separate messages smallest communication overhead latencies greater
seconds sending entire hierarchy best sending summary information two
levels time best latency fixed seconds communication delay varies


fia bstract r easoning p lanning c oordination



b

figure delay varying latency b bandwidth hypothetical example
bandwidth shown figure b bandwidth less bytes second sending
one time best sending best bandwidths greater bytes second
sending two levels time best bandwidths
admittedly values unrealistic manufacturing domain manufacturing simple provided mainly interesting domain coordination realistic involving manufacturing domain could much larger hierarchies require
much larger scales data sent case realistic bandwidth latency values would
exhibit similar tradeoffs
see suppose manufacturing managers hierarchies common branching
factor b depth tasks generally reservations similar resources throughout hierarchies amount total summary information particular level would grow exponentially
hierarchy would number tasks agents agreed feasible solution
depth level hierarchy table messages size would appear follows

one task time
two levels time


number messages
bi



total size
bi
bi
bd

suppose branching factor b depth solution found level
summary information task kbyte table would look

one task time
two levels time


number messages




total size kbytes




fixed bandwidth kbyte second varied latency realistic
tradeoffs seen figure see unless latency small sending summary
information two levels time best shown figure b fix latency one second
vary bandwidth realistic bandwidths sending summary information two levels
time best



fic lement urfee barrett

simple protocol illustrates communication minimized sending summary
information particular granularity agents chose send summary information
unsummarized hierarchies instead would need send entire hierarchies
experiment shows hierarchies grow large sending entire hierarchy would take
long time even high bandwidth thus summary information opposed
reduce communication exponentially solutions found abstract levels
extreme agents sent summary information one task time latency
sending many messages grow large larger task hierarchies solutions could
found primitive levels sending summary information one task time would cause
exponential latency overhead compared sending entire hierarchy solutions
found intermediate levels able send summary information intermediate
granularity minimize total delay
however argument assumes summary information collapses higher levels hierarchy otherwise sending summary information intermediate level could almost
expensive sending entire hierarchy cause unnecessary overhead actual manufacturing domain tasks agents hierarchies mostly constraints different resources
summarization able reduce summary information significantly constraints
collapse better case send entire hierarchy minimize
delay unless unusual bandwidth latency constraints shown experiment
even coordination agent still summarize hierarchies take advantage
computational advantages abstract reasoning
section showed domain modeler minimize communication overhead communicating summary information proper level granularity bandwidth latency
common depth coordination solutions known domain modeler perform hypothetical
experiment one varying granularities summary information determine
granularity optimal summary information collapses hierarchy solutions
found intermediate levels communication exponentially reduced manner

related work
taken abstract reasoning originally inspired earlier work involving
hierarchical behavior space search agents represent planned behaviors multiple
levels abstraction durfee montgomery distributed protocols used decide
level abstraction coordination needed resolve conflicts capitalizes
domains resources abstracted naturally earlier work viewed
limited special case work presented justified intuitively limited
experiments analyses
corkill studied interleaved merging distributed version noah planner
recognized conditions affected abstract plan operator
might unknown refinement deal overall effects preconditions
hold matter operator refined captured used identify resolve
conflicts recognized choices refinement synchronization choices
abstract levels could lead unresolvable conflicts deeper levels backtracking could
necessary work directed toward avoiding backtracking summary information
guide search



fia bstract r easoning p lanning c oordination

closer relation pappachan shows interleave hierarchical plan coordination plan execution cooperative agents online iterative constraint relaxation
oicr pappachan coordination achieved higher
levels abstraction flexible execution agents decompose tasks lower
levels tighter coordination improve plan quality oicr tailored toward
interleaving coordination flexible execution price completeness coordination
presented aimed complete interleaved coordination price
potentially delaying execution due backtracking
hierarchical plans often represented hierarchical task networks htns erol et al planners noah sacerdoti nonlin tate
sipe wilkins plan currie tate umcp erol et al b shop
nau au ilghami kuter murdock wu yaman use search combinations
alternative courses action achieve goals within particular context actions may partially ordered giving timing flexibility execution wilkins currie tate
ch p representation extends htn include temporal extent partial orderings expressed
constraints starting ending timepoints action
yang presented method similar summarization preprocessing plan hierarchy
order able detect unresolvable conflicts abstract level planner could backtrack inconsistent search spaces yang corresponds use mightsomeway
section however requires decomposition hierarchy modeled
abstract operator unique main subaction preconditions effects
parent avoid restriction analyzing subplans conditions ordering constraints
automatically compute parents summary conditions
focused resolving conflicts among agents cox durfee
used summary information exploit synergistic interactions idea summary information identify overlapping effects help agents skip actions whose effects
achieved others thangarajah padgham winikoff used summary information
rescheduling execution representations actually subsumed
work significantly postdates first reporting work clement durfee
dsipe desjardins wolverton distributed version sipe wilkins
hierarchical system way agents use summary information reduce
communication states common constraints dsipe filters conditions
communicated among planners irrelevance reasoning wolverton desjardins
dpocl decompositional partial order causal link planner young et al adds
action decomposition snlp mcallester rosenblitt htn planners preconditions high level effects added abstract tasks order help planner resolve
conflicts decomposition addition causal links specified decomposition schemas
isolate external preconditions dpocl must satisfy however conditions
causal links necessarily capture external conditions abstract tasks planner
solutions abstract levels requires tasks completely decomposed addition dpocl cannot determine abstract plan unresolvable conflicts mightsomeway
may effects hidden decompositions yet undetailed tasks could achieve
open preconditions deriving summary conditions automatically determining causal link information e g must achieve coordination



fic lement urfee barrett

reject abstract plans search without adding burden domain expert specify redundant conditions causal links abstract tasks
dpocl tms framework task analysis environment modeling simulation
allows domain modeler specify wide range task relationships decker
work offers quantitative methods analyzing simulating agents well interactions
interactions represented discovered summary conditions
discover information analysis rather depending model developer
predefine interactions
groszs shared plans model collaboration presents theory modeling multiagent
belief intention shared plans work directed toward cooperative agents represents
action hierarchies provides mental higher level represented article
however use analysis summary information complements groszs work providing
way automatically represent efficiently reason intentions agents multiple levels
abstraction future work needed understand summary information bridged
mental states agents exploit techniques employed shared plans work
bdi belief desire intention agents rao georgeff
analysis hierarchical yang explains case interacting subgoals certain structures hierarchy minimize interactions reduce worst case
complexity exponentially however complexity analyses section explain summary information achieve exponential performance gains addition achieved
restructuring plan hierarchies according yangs analysis limiting decomposition task
hierarchies compressing information manipulated coordinator planner scheduler
shop nau et al htn planner uses domain translation technique reason
durative action however express temporal extent way planner
given model differs supports ordering relationships endpoints well
conditions effects actions execution may domain translation
could achieve expression similar constraints solutions systems
formal model expressions htn
siadex castillo et al another htn planner handles temporal extent use
expressive simple temporal networks dechter meiri pearl performance
improvement techniques reported siadex temporal reasoning specific htns
thus work complementary however work needed understand
summary information exploited conjunction forward expansion
shop siadex use perform competitively competition
another class hierarchical planners abstrips sacerdoti introduces conditions different levels abstraction critical conflicts handled higher levels
abstraction less important easier conflicts resolved later lower levels
similarly resolves conflicts abstract levels decisions may consistent
conditions lower levels resulting backtracking summary information provides means
make sound complete decisions abstract levels without need decompose check
consistency lower levels however resolving conflicts criticality still improve
performance complement
allens temporal planner uses hierarchical representations tasks could applied
reasoning concurrent actions multiple agents however exploit hierarchy
reasoning abstraction levels separately generates plan proving consistency


fia bstract r easoning p lanning c oordination

collective constraints allens model temporal plans subsequent work interval
point algebra vilain kautz strongly influenced hierarchical task representation
reason
many many theories concurrency older examples include
automata representations petri nets hoares theory communicating sequential processes
glabbeek many temporal logics computational tree logic ctl
emerson halpern allow modal expressions proposition holding
possible worlds time time next state eventually
proposition holds another language specifying manufacturing processes process
standardized years bock schlenoff knutilla ray many
logics could used define summary conditions relations mightsomeway however found logics awkward representing inconditions defining summary
conditions terminology used article simplifies definitions
model checking uses temporal logics verify different properties system software
hardware correctness deadlock free convergence fact model checking
used interchangeably e g giunchiglia
traverso context model checking summary information set properties
akin specifiable ctl system model domain summarize system
variable requirements conditions assignments effects thus model checking
could use summary information efficiently identify resolve potential requirement violations bugs condition conflicts deadlock resource conflicts system model operation
scheduling instantiations

conclusion
article provides formalization hierarchical task network unlike umcp
formalism erol et al b includes actions temporal extent introduce sound
complete used generate plan coordinate group agents hierarchical plans interleave coordination
summarizing propositional state metric resource conditions effects
abstract levels mechanisms reason summary information facilitate
construction coordination systems reason plans multiple levels
abstraction mechanisms reasoning summary information determine whether
task level abstraction must may achieve clobber undo condition another task
partial order constraints endpoints tasks built mechanisms mechanisms
determine whether group agents decompose execute set partially ordered abstract
tasks way cananyway might decompose execute way mightsomeway
cannot execute consistently way mightsomeway
enable system solutions multiple levels abstraction
without needing fully detail task hierarchy abstract solutions support flexible execution
remaining uncommitted alternative methods selected runtime
circumstances achieve plan subgoals
complexity analyses experiments different domains quantified benefits summary information refinement local search scheduling


potential doubly exponential speedup kb b b di k ways resolve conflict



fic lement urfee barrett

hierarchy branching factor b depth hierarchy abstract solution depth exponential speedup obtained abstract solutions found fewer summary conditions
abstract levels alternative decomposition choices lead varying numbers threats
conditions exponential improvement significant relaxation compared prior work
performance improvement greater
domain modeler run summarization offline library plan hierarchies
summary information available coordination set goal tasks
supported library reasoning summary information agents
discover coordinate states resources must coordinate negotiate communicating summary information different levels abstraction reduces
communication costs exponentially conditions similar reducing computation time
use summary information local search planner aspen section another
contribution work strength local search ability efficiently reason
large numbers tasks constraints metric resources state variables complex
resource classes integrating reasoning summarized propositional state
metric resource constraints heuristic local search planner scheduler enable scalable
systems scale even larger domains use summary information
different style planner demonstrates applicability abstract reasoning improving
performance different kinds plan coordination systems
future work needed evaluate use summary information
scheduling systems wider classes requiring expressive representations
resources temporal constraints already exploiting cooperative action
among agents summary information developed cox durfee
promising approaches include abstracting plan information probabilistic conditions
effects classes resources states e g location regions sub regions work
needed understand communicate summary information distributed
system

acknowledgments
authors wish thank pradeep pappachan gregg rabideau russell knight help
implementation thank anonymous reviewers many valuable suggestions
work performed jet propulsion laboratory california institute technology
contract national aeronautics space administration university michigan
supported part darpa f

appendix computing interval relations
determining whether defined relations hold summary conditions
plans p use point algebra constraint table vilain kautz point algebra
table constructed interval endpoints corresponding executions plans p
row column p ts e start endpoint execution e p p f e finish
endpoint added plan p p cell table gives time point constraint
row column empty means



fia bstract r easoning p lanning c oordination

p
p
p
p

p





p





p





p





table point algebra table p contains p
p
p
p
p

p





p





p





p





table point algebra table p p
points unconstrained cell empty allowed temporal relations indicating
inconsistency table shows point algebra table plans p p constrained
ps execution contains p table shows table start p constrained
earlier start p transitive closures constraint relations table
computed table constraining p p putting cell row p
column p computing transitive closure n n points vilain
kautz transitive closure computed constraints point
point looked constant time
similarly constraints order p added table transitive closure
computed get constraints entailed order needs done
p order determine achieve clobber relationships defined next section
determine plan q ps subplans temporally ordered f irst last
q q constrained equal points point algebra table
ps subplans done looking entry row q q checking see
constraint case q f irst last
q f irst last row q q entry
constraint otherwise sometimes f irst last
interval covered set intervals ik interval
found intersects intersects nothing particular covering describes
intervals terms partial order endpoints represent intervals point algebra
table covering check see covered looking
pairs intervals see overlap covered intervals meet


intervals endpoint contained
meet opposite endpoint another interval endpoint intervals
overlapping otherwise covered examples given figure



fic lement urfee barrett






b


c

c

e

b



f

g



h



figure interval covered b c b e covered f g h c
covered

appendix b must may asserting summary conditions
describe determining temporal plan relationships summary information used build determine whether plan must may achieve
clobber undo condition another particular ordering constraints
definitions throughout section given within context set
plans p corresponding set summary information psum set ordering constraints order
set histories h including histories e h includes execution e
plan p es subexecutions e h satisfies constraints order concerned
ordering plan execution intervals timing conditions
anything whether conditions may need met must met plan
execution
first order determine whether abstract plan executions achieve clobber undo
conditions others agent needs able reason summary conditions asserted
required met ultimately agent needs able determine whether partial ordering
abstract plans succeed may case agents action fails assert summary
condition required action another agent therefore formalize means
action attempt assert summary condition require summary condition
met definitions rely linking summary condition plan chip conditions
summarizes subplans plans decompositions thus first define means
summary condition summarize conditions
definition
summary condition c summarizes condition condition set conds
plan p iff c added procedure deriving summary information
summary condition set p c c added condition
set conds p p c added summary condition subplan p
summarizes conds p
example bin precondition start move plan moving part bin
machine given section deriving summary conditions start move



fia bstract r easoning p lanning c oordination

bin added summary preconditions thus summary precondition bin
muf summarizes bin preconditions start move
definition
execution e p requires summary condition c met iff c
summary condition ps summary information condition condition
set conds p summarized c f irst c ts e last c f e
c within ts e f e sometimes c execution
subplan p e requires summary condition c met c
summarizes conds p
basically execution requires summary condition met whenever conditions
summarizes required execution build g summary precondition tray
execution requires summary condition met ts build g tray
precondition build gs first subplan summarized build gs summary precondition
definition
execution e p attempts assert summary condition c iff c
summary condition ps summary information condition condition
set conds p summarized c f irst c c smallest
interval ts e start end execution follows ts e
last c f e sometimes c execution subplan p e
attempts assert summary condition c c summarizes conds p
say execution attempts assert summary condition asserting condition
fail due simultaneous assertion negation condition example
requiring summary condition executions build g produce g produce h
assert summary postconditions becomes available f build g
order agents determine potential interactions among abstract plans clobbering achieving need reason summary condition asserted one plan
relation asserted required another interval point algebra constraints
set abstract plans agent specifically would need able determine whether plan
would assert summary condition time another plan requires asserts summary
condition state variable addition reason clobbering inconditions agent
would need determine summary condition would asserted time summary incondition c required asserted c agents need detect summary postcondition
would asserted time another summary postcondition c asserted c
consider cases executions attempt assert summary postcondition
time incondition asserted cases clobber relations already
detected executions require summary inconditions attempt assert
example equip attempted assert incondition unavailable
time build g attempted assert postcondition available incondition would
clobbered postcondition
case ordering constraints allow alternative synchronizations abstract
plans assertions summary conditions may come different orders therefore formalize
must assert may assert determine relationships must may occur respectively
mentioned beginning section use must may disjunctive orderings existence summary conditions different decompositions


fic lement urfee barrett


























c post p
last


f

c p



f
c post p
last

f
c p


f
c post p
last


f
f
c p



f
f

p must assert c c
order must impose
constraints

p must assert c c
order must impose
constraints

p p
p p
p p
p p

p p
p p
p p
p p


f

c p




p p
p p
f alse

p p
p p
f alse

p p
p p

p p
p p



c post p
last

f

f

p p
f alse

p p
f alse

p p
p p
p p
p p

p p
p p
p p
p p


f

f

p p
p p
f alse
f alse

p p
p p
f alse
f alse

c pre p
f irst

f



table table must assert
following definitions must may assert assume c c summary
conditions plans p
definition
p p must assert c c iff histories h h
e top level execution e h p p requires c met
e top level execution p e h e attempts assert c

must assert described table p must assert c c iff order entails
relationship given row corresponding type timing two conditions rows
table indicate timing summary conditions constraints order must dictate
must assert true f table indicate whether timing column true
false condition means timing doesnt matter condition case
example row says case c sometimes last postcondition p c
incondition p timing order must require end p start
p order p must assert c time c asserted required



fia bstract r easoning p lanning c oordination

























c post p
last


f
f
c p



c post p
last


f
f
c p



c post p
last


f
f
c p




p may assert c c
order cannot impose
constraints

p may assert c c
order cannot impose
constraints

p p
p p
p p
p p

p p
p p
p p
p p


f
c p


f

f

p p
p p

p p
p p

p p
p p
p p
p p

p p
p p
p p
p p


f
c post p
last

f

f

p p
p p

p p
p p

p p
p p
p p
p p

p p
p p
p p
p p


f

p p
p p

p p
p p

c pre p
f irst

f

f

table table may assert











c post p
last


f
f
c p



f
f

p must assert c c
order must impose
constraints

c p


f

f

p p p p
f alse
p p p p
f alse


f

f

p p p p
f alse
f alse
f alse

c post p
last


f
f
c p



f
f

c p


f

f

p p
p p
p p
p p






p p
p p
p p
p p


f

f

p p
p p
p p
p p






p p
p p
p p
p p

table table must may assert



p may assert c c
order cannot impose
constraints

fic lement urfee barrett






c post p
last


f
f

c post p
last

f

f

p must assert c c
order must impose
constraints
p p
f alse
f alse
f alse

c post p
last


f
f

c post p
last

f

f

p may assert c c
order cannot impose
constraints
p p
p p p
p p p p
p p p p
p

table table must may assert
definitions assert relationships similar tables describe
logic may relationships returns true iff none
corresponding ordering constraints table imposed deduced order
illustrate relationships example figure figure agents plans
unordered respect part g produced machine depending potential decompositions produce g plan produce g must assert c must
last available g c must f irst available g summary preconditions move g
matter plans decomposed executions histories plans
ordering constraints figure execution produce g attempts assert c execution move g requires c met verifies finding
end produce g ordered start move g row table case
equip tool may assert c must last available c may sometimes available
summary preconditions produce g two plans unordered respect
history equip tool precede produce g finds
true since equip constrained start start produce g row table
figure b move tool may assert c must last f ree transport c may sometimes
f ree transport produce gs summary inconditions history move tool attempts assert c time produce g transport move part machine
addition equip tool must assert c must last available c may last
available produce gs summary postconditions equip tool attempts assert
c time produce g requires c met end section gives examples

references
allen j kautz h pelavin r tenenberg j reasoning plans morgan kaufmann
allen j f maintaining knowledge temporal intervals communications acm

allen j f koomen j temporal world model proceedings
international joint conference artificial intelligence pp
bock c unified process specification language requirements modeling process tech
rep nistir national institute standards technology
castillo l fdez olivares j garca perez palao f efficiently handling temporal
knowledge htn planner th international conference automated


fia bstract r easoning p lanning c oordination

scheduling icaps pp aaai
chien knight r stechert sherwood r rabideau g iterative repair
improve responsiveness scheduling proceedings international
conference ai scheduling pp
chien rabideu g knight r sherwood r engelhardt b mutz estlin smith b
fisher f barrett stebbins g tran b automating space mission operations
automated scheduling proc spaceops
clement b abstract reasoning multiagent coordination ph thesis
university michigan ann arbor
clement b durfee e top search coordinating hierarchical plans
multiple agents proceedings international conference autonomous agents
corkill hierarchical distributed environment proceedings
international joint conference artificial intelligence pp
cox j durfee e h discovering exploiting synergy hierarchical agents proceedings international joint conference autonomous agents
multiagent systems pp
currie k tate plan open architecture artificial intelligence

dechter r meiri pearl j temporal constraint networks artificial intelligence

decker k environment centered analysis design coordination mechanisms ph
thesis university massachusetts
desjardins wolverton coordinating distributed system ai magazine

drabble b tate use optimistic pessimistic resource profiles inform
search activity planner artificial intelligence systems pp
durfee e h montgomery coordination distributed search hierarchical
behavior space ieee transactions systems man cybernetics
emerson e halpern j decision procedures expressiveness temporal logic
branching time journal computer system sciences
ephrati e rosenschein j divide conquer multi agent proceedings
national conference artificial intelligence pp
erol k hendler j nau semantics hierarchical task network tech
rep cs tr university maryland
erol k nau hendler j b umcp sound complete procedure
hierarchical task network proceedings international conference ai
scheduling
fagin r halpern j moses vardi reasoning knowledge mit press
firby j adaptive execution complex dynamic domains ph thesis yale university


fic lement urfee barrett

georgeff p communication interaction multiagent proceedings
national conference artificial intelligence pp
georgeff p theory action multiagent proceedings national
conference artificial intelligence pp
georgeff p lansky procedural knowledge proceedings ieee

giunchiglia f traverso p model checking proceedings th
european conference pp london uk springer verlag
glabbeek r v notes methodology ccs csp theoretical computer science
originally appeared report cs r cwi amsterdam
grosz b kraus collaborative plans complex group action artificial intelligence

huber jam bdi theoretic mobile agent architecture proceedings international conference autonomous agents pp
knight r rabideau g chien computing valid intervals collections activities shared states resources proceedings international conference ai
scheduling pp
knoblock c search reduction hierarchical solving proceedings
national conference artificial intelligence pp
korf r search quantitative artificial intelligence
laborie p ghallab sharable resource constraints proceedings
international joint conference artificial intelligence pp
lansky localized search controlling automated reasoning proceedings
darpa workshop innovative approaches scheduling control pp

lee j huber j durfee e h kenny p g umprs implementation
procedural reasoning system multirobot applications proceedings aiaa nasa
conference intelligent robotics field factory service space pp
mcallester rosenblitt systematic nonlinear proceedings
national conference artificial intelligence pp
muscettola n hsts integrating scheduling intelligent scheduling
nau au ilghami kuter u murdock j wu yaman f shop
htn system journal artificial intelligence
pappachan p coordinating plan execution dynamic multiagent environments ph
thesis university michigan ann arbor
pratt v r semantical considerations floyd hoare logic th annual ieee symposium foundations computer science pp
rao georgeff p bdi agents theory practice proceedings
international conference multi agent systems san francisco


fia bstract r easoning p lanning c oordination

sacerdoti e hierarchy abstraction spaces artificial intelligence

sacerdoti e structure plans behavior elsevier north holland
schlenoff c knutilla ray interprocess communication process specification language tech rep nistir national institute standards technology
tate generating project networks proceedings international joint conference
artificial intelligence pp
thangarajah j padgham l winikoff detecting avoiding interference
goals intelligent agents proceedings international joint conference artificial
intelligence pp
tsuneto r hendler j nau space size minimization refinement
proceedings european conference
tsuneto r hendler j nau analyzing external conditions improve efficiency
htn proceedings national conference artificial intelligence pp

vilain kautz h constraint propagation temporal reasoning proceedings national conference artificial intelligence pp
weld introduction least commitment ai magazine
wilkins e ai planners solve practical computational intelligence

wolverton desjardins controlling communication distributed
irrelevance reasoning proceedings national conference artificial intelligence
pp
yang q formalizing knowledge hierarchical computational intelligence
yang q ed intelligent decomposition abstraction
springer
young pollack moore j decomposition causality partial order
proceedings international conference ai scheduling pp




