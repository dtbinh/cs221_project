journal artificial intelligence

submitted published

clause learning many restarts
bounded width resolution
albert atserias

atserias lsi upc edu

universitat politecnica de catalunya
barcelona spain

johannes klaus fichte

fichte kr tuwien ac

vienna university technology
vienna austria

marc thurley

marc thurley googlemail com

university california berkeley
berkeley usa

abstract
offer understanding aspects practical sat solvers
dpll unit clause propagation clause learning restarts analyzing
concrete claim faithful practical solvers particular
making decision restart solver repeatedly applies unit resolution
rule saturation leaves component mercy non determinism except
internal randomness prove perhaps surprising fact although
solver explicitly designed high probability ends behaving width k
resolution n k conflicts restarts n number
variables words width k resolution thought n k restarts
unit resolution rule learning

introduction
discovery method introduce practically feasible clause learning non chronological backtracking dpll solvers layed foundation sometimes called
modern sat solving silva sakallah bayardo schrag methods
set ground effective implementations moskewicz madigan zhao zhang
malik spawned tremendous gains efficiency sat solvers many
practical applications great somewhat unexpected success seemed contradict
widely assumed intractability sat time uncovered need
formal understanding capabilities limitations underlying methods
several different approaches suggested literature developing rigorous understanding among proof complexity captures
power sat solvers terms propositional proof systems beame kautz sabharwal hertel bacchus pitassi gelder pipatsrisawat darwiche
rewriting provides useful handle reason
properties underlying correctness nieuwenhuis oliveras
tinelli approaches sat solvers viewed search
proofs underlying proof system propositional logic view mind
illuminating understand proof system underlying modern solvers
c

ai access foundation rights reserved

fiatserias fichte thurley

subsystem resolution beame et al particular means performance never beat resolution lower bounds time provides many
explicit examples sat solvers require exponential time complementing
idealized sat solver relies non determinism apply techniques
best possible way able perform good general resolution weak forms
statement first established beame et al hertel et al
current form pipatsrisawat darwiche beame et al put
negative proof complexity uncover examples inherent intractability even
perfect choice strategies positive proof complexity give hope finding
good choice strategy
work add perspective kind rigorous try avoid
non deterministic choices components abstract solver still get positive proof
complexity main finding concrete family sat solvers
rely non determinism besides mild randomness least powerful bounded width
resolution precise proof complexity unit propagation rule
standard learning scheme considered state art solvers totally random decision strategy needs k ln kn n k conflicts deterministic restarts
detect unsatisfiability cnf formula n variables width k resolution
refutation probability least remarkably analysis provide exact expression upper bound holds values n k particular bound
get asymptotic another remarkable feature analysis insensitive
whether implements non chronological backtracking heuristic decisions provided restarts often enough provided performs totally random decisions
often enough details given section
nice theoretical consequences shall sketch briefly
first although explicitly designed purpose sat solvers able solve instances sat polynomial time since every unsatisfiable cnf formula resolution
refutation width two strongly interpreted showing widthk resolution simulated k ln kn n k rounds unit clause propagation
knowledge tight connection width k resolution repeated application
width one methods unknown another consequence sat solvers
able solve formulas bounded branch width hence bounded treewidth polynomial time elaborate later finally partial automatizability
ben sasson wigderson follows sat solvers able solve
formulas polynomial size tree resolution proofs quasipolynomial time
formulas polynomial size general resolution proofs subexponential time
concerning techniques perhaps surprising proof main
proceed showing width k refutation learned
know produced proof much larger width thing
every width k clause refutation absorbed means
behaves learned even though might particular literal
complement absorbed correctly declares formula
unsatisfiable sort analysis main technical contribution


ficlause learning

related work
first attempt compare power sat solvers power resolution
proof system made beame et al main positive
work clause learning specific learning scheme without restarts
provide exponentially shorter proofs proper refinements resolution tree
regular positive resolution furthermore modification standard
solver allow multiple assignments variable would able simulate general
resolution efficiently assuming ideal decision strategy following work showed
requirement multiple assignments variable technical issue
avoided given cnf formula pre processed appropriately hertel et al
work avoid two maneuvers introducing concept clause absorption
help us analyze standard directly
interestingly clauses logical consequences input formulas concept
clause absorption turns dual concept empowerment introduced
independently pipatsrisawat darwiche used empowerment
sat solvers without conceptual modification operation able simulate
general resolution efficiently assuming ideal decision strategy comparison
goal settles weaker simulation bounded width resolution instead general
resolution rely non determinism ideal decision
totally random decision strategy good enough purpose provided restart often
enough complete point worth noting non automatizability
alekhnovich razborov indicate cannot expect efficient simulation
general resolution completely avoid non determinism time
fact concepts discovered independently adds confidence belief
play role subsequent studies power sat solvers indeed
techniques recently extended sat solvers totally random decision
strategy able efficiently simulate local consistency techniques general constraint
satisfaction jeavons petke
organization
section introduce basic notation define analyze
discuss dependence choice learning scheme restart policy
decision strategy used section starts elementary
facts runs continues key definitions absorption
beneficial rounds analysis running time section
contains discussion consequences including implications formulas bounded
treewidth

clause learning
section define discuss choice components
start preliminary definitions
note originally weaker version empowerment introduced pipatsrisawat darwiche




fiatserias fichte thurley

preliminaries
let v v vn fixed set propositional variables literal propositional
variable x negation x use notation x x x x note xa
defined way assignment x satisfies use
literal xa use x clause set literals
formula conjunctive normal form cnf formula set clauses width
clause number literals following formulas set
variables v every clause contains literals variables v
two clauses x r b x define resolvent
b x res b x r variable resolve x
implicit simply write res b clause may contain literal negation note
resolvent res b x b x still well defined case resolution
refutation cnf formula f sequence clauses c cm cm
clause ci sequence belongs f resolvent previous clauses
sequence length refutation number clauses sequence
clause c variable x truth value restriction c x
constant literal xa belongs c c x otherwise write c x
restriction c x
partial assignment sequence assignments x xr ar
variables distinct let partial assignment say satisfies literal xa
contains x say falsifies contains x c clause let
c applying restrictions x xr ar c clearly order
matter say satisfies c satisfies least one literals e
c say falsifies c falsifies literals e c set
clauses let denote applying restriction clause
removing resulting call residual set clauses
definition
state sequence assignments x xr ar variables

distinct assignments marked decisions use notation xi ai
denote assignment xi ai decision assignment case xi called
decision variable rest assignments called implied assignments use
denote states empty state one without assignments define decision level
assignment xi ai number decision assignments x xi ai
convenient identify state underlying partial assignment
decision marks ignored
operation
maintains current state current set clauses four
modes operation default conflict unit decision starts
default mode empty state current state given cnf formula
current set clauses


ficlause learning

default sets variables satisfies clauses stop output
sat together current state otherwise contains empty clause
move conflict mode otherwise contains unit clause move unit
mode finally control reaches point move decision mode
conflict apply learning scheme add clause c c empty
clause stop output unsat otherwise apply restart policy decide whether
continue restart default mode current initialized
empty state case continue repeatedly remove assignments
tail long c go unit mode
unit unit clause xa add x go back default
mode


decision apply decision strategy determine decision x added
go back default mode

guarantee correctness termination learning scheme add clause c
logical consequence c holds time added
contains one variable maximum decision level hard see
properties prevent clause learned twice since number clauses
variables finite implies termination clauses characteristics
exist include asserting clauses zhang madigan moskewicz malik
discussed section
well known dpll procedure precursor conflict
mode learning scheme never adds clause restart policy dictate
restart assignments removed tail latest decision


assignment say x replaced x say dpll procedure
backtracks latest decision contrast modern sat solvers implement learning
schemes backtrack literal determined learned clause necessarily latest decision called non chronological backtracking besides learning
schemes non chronological backtracking modern sat solvers implement restart
policies appropriate decision strategies discuss choice components
section
runs
consider run started default mode empty state initial
set clauses clause falsified variables set run called
complete round started represent sequence states sm
goes empty state sm state
variables set falsified clause found generally round
initial segment sr complete round state sr contains
empty clause sr contain unit clause sr contains empty clause
say round conclusive round conclusive call inconclusive


fiatserias fichte thurley

term inconclusive means reflect fact clause learned round
particular complete round ends satisfying assignment inconclusive
round sr note r state si extends si exactly

one assignment form xi ai xi ai depending whether unit decision
executed iteration mode assigns variables lead
confusion identify round last state interpreted partial assignment
particular say round satisfies clause c c sr falsifies
c sr
restart policy learning scheme decision strategy
following discuss choice learning scheme restart policy
decision strategy used discussion particularly focus
dependence choice
restart policy
restart policy determines whether restart search clause learned
important characteristic need restart policy dictate
restarts often enough particular analysis work equally well aggressive restart policies one dictates restart every conflict
less aggressive strategy allows bounded number conflicts restarts
fact analysis insensitive follow monotonicity property
performance prove lemma precisely
follow monotonicity lemma decide use policy allows c
conflicts restart upper bound number required restarts
decrease stay upper bound number conflicts would
appear multiplied factor c even though truth might even decrease
well simplicity exposition rest assume restart
policy dictates restart every conflict
decision strategy
decision strategy determines variable assigned next value
important characteristic need decision strategy
allow round totally random decisions often enough totally random decision
defined follows current state choose variable x
uniformly random among variables v appear value
uniformly random independently choice x thus analysis
actually applies decision strategy allows bounded number rounds
heuristic decisions totally random ones precisely allow say c
rounds non random decisions random ones number required restarts
conflicts would appear multiplied factor c follow
let us note definitions round conclusive round inconclusive round differ slightly
given conference version atserias fichte thurley current
definitions make concepts robust



ficlause learning

monotonicity lemma referred said simplicity exposition assume
following every decision totally random
learning scheme
learning scheme determines clause added set clauses
conflict occurs let sr conclusive round started set clauses

ends falsifying clause let xi ai xi ai th assignment
round annotate si clause ai reverse induction r
let ar clause falsified sr


r xi ai decision let ai ai
r xi ai implied let bi clause bi si
unit clause xai let ai res ai bi xi clauses resolvable
xi let ai ai otherwise
quite clear construction ai resolution proof clauses
fact resolution proof linear even trivial sense beame et al
call clause ai conflict clause denotes maximum decision level
assignments sr conflict clause called asserting clause contains exactly
one variable decision level asserting clauses originally defined zhang et al
capture properties conflict clauses learned virtually modern sat solver
brevity describe two concrete learning schemes detail schemes see
work zhang et al
decision learning scheme adds clause current set clauses
conflict hard check asserting clause furthermore every literal
negation decision literal sr important later
uip learning scheme stands st unique implication point one adds
clause ai r maximal subject condition ai asserting
clause
following assume tacitly employs asserting
learning scheme one whose learned clauses asserting except
empty clause
clause bookkeeping
mentioned analysis relies crucially assumption learned
clauses never removed current set clauses however practical sat solvers
periodically delete learned clauses save memory avoid overhead
introduce thus interesting question whether made work
without assumption respect strong proof complexity nordstrom
showing every small width resolution refutation made work
small clause space seems indicate assumption similar indeed needed
another remark worth making point concerns width learned clauses
since goal simulate small width resolution seems
natural ask whether restrict learning scheme learn clauses small width


fiatserias fichte thurley

mentioned introduction analysis seem allow moreover
recent ben sasson johannsen general learning short
clauses provably weaker scheme learning arbitrarily long clauses thus
examples ben sasson johannsen small width resolution
refutations therefore keeping long clauses actually required
case conceivable might

analysis
section analyze running time
however introduce key technical concepts absorption beneficial
rounds study important properties
runs
let r r rounds let c clause say r subsumes r decision
marks every assignment r appears r say r r agree c
restrictions r r variables c equal every variable c unassigned
assigned value say r branches c decision
variables r variables c note properties agree c branches c
depend set variables c define clauses simplify notation
later
prove two rather technical lemmas goal inconclusive rounds
robust respect order assignments made example first
lemma shows inconclusive round subsumes round agrees
decisions fact need slightly stronger claim involves rounds two
different sets clauses
lemma let sets clauses let c clause let r
inconclusive round started every round r started branches
c agrees r c holds r subsumes r
proof let r sr induction prove every r every
assignment si made r nothing prove since let

assume every assignment si made r let x x
last assignment si since r r agree c r branches c every decision

assignment made r made r takes care case x suppose
last assignment x si implied means exists clause
si xa since every assignment made si
made r necessarily x appears r r inconclusive cannot leave
unit clauses unset
next lemma shows universal quantifier conclusion previous
lemma void addition round chosen inconclusive
lemma let sets clauses let c clause let r
inconclusive round started exists inconclusive round r started
branches c agrees r c r subsumes r


ficlause learning

proof let r tt define set indices th

assignment r assigns variable c let xi ai xi ai th
assignment r
construct round r ss started inductively associated
sj set ij indices xi left unassigned sj recall
empty state definition hence define following process
sj falsifies clause sets variables v set j stop
otherwise unit clause xa sj let sj sj plus x
otherwise ij non empty let minimum element ij let sj

obtained adding decision xi ai sj
none cases applies set j stop process
construction r valid round started let us see r subsumes r let
set literals made true decisions r construction r r agree
hence r subsumes r lemma furthermore r inconclusive
r inconclusive r contain empty clause r subsumes
r r contain empty clause every variable c belongs
v r inconclusive process stops together fact r
subsumes r shows r r agree c note finally r branches c
construction
absorption
one key feature definition round inconclusive residual set
clauses contain unit clauses particular closed unit propagation
means inconclusive round r started clause r
falsifies literals one r must satisfy remaining literal hence
well besides clauses may property important enough
deserve definition
definition absorption let set clauses let non empty clause let
xa literal say absorbs xa every inconclusive round started
falsifies xa assigns x say absorbs absorbs every
literal
naturally absorbs xa say absorbed xa
intuitively one way think absorbed clauses learned implicitly rest
section devoted make intuition precise let us note
inconclusive rounds started every clause absorbed agrees
given intuition since absence inconclusive rounds means unit clause propagation
applied produces empty clause section notion
clause absorption tightly connected concept empowerment independently
introduced pipatsrisawat darwiche


fiatserias fichte thurley

properties absorption
continue let us discuss key properties absorption argued already
every clause absorbed give example showing may absorb
clauses let set consisting three clauses
b

bc

b e

example clause c belong absorbed since every inconclusive round sets must set c unit propagation every inconclusive
round sets c must set unit propagation may absorb
clauses saw note every non empty clause absorbed logical
consequence write c every satisfying assignment satisfies c
lemma let set clauses let c non empty clause absorbs c
c
proof let full assignment satisfies clauses want
satisfies c well let r sr complete round started
sets decision variables set induction r
si follow r stopped conflict therefore
sr particular r inconclusive falsifies literals c one must
satisfy remaining one c absorbed since r sets variables c sr
means satisfies c
remains si every nothing since

fix assume si let x x last assignment

si case x taken care assumption decision variables r set
suppose last assignment x implied means exists
clause si xa since satisfies si necessarily x
set
next let us see converse lemma hold namely see
every implied clause absorbed previous example instance note
bde consequence resolve first third clause absorbed


consider inconclusive round e
one interesting property illustrated example c resolvent
two absorbed clauses b c absorbed literal appears
b example absorb b e b b appears
clauses b b e whose resolvent precisely b e
prove general fact next section objects study non absorbed
resolvents absorbed clauses
next three key monotonicity properties clause absorption first
one motivated definition
lemma let e sets clauses let b non empty clauses
following hold
belongs absorbs


ficlause learning

b absorbs absorbs b
e absorbs e absorbs
proof prove assume contradiction literal inconclusive
round sr started falsifies satisfy round
inconclusive cannot sr means sr contradiction
definition round
proof let literal b define b b consider two
different cases
b absorbed inconclusive
round falsifies b thus b absorbed case let let
sr inconclusive round started falsifies b falsifies
satisfies absorption thus satisfies b b absorbed case well
remains prove let literal let r
inconclusive round started e falsifies lemma inconclusive
round r started falsifies subsumed r absorbed
see r hence r satisfies
absorption empowerment
next goal absorption empowerment dual notions assignments write every assignment let us reproduce
definition empowerment work pipatsrisawat darwiche slightly
adapted better suit notation terminology
definition empowerment pipatsrisawat darwiche let set
clauses let c non empty clause let xa literal c let assignment
sets b every literal b c xa say c empowering via xa
respect following three conditions met
c logical consequence e c
repeated applications unit clause propagation yield empty clause
repeated applications unit clause propagation assign x
say xa empowering literal c say c empowering
empowering via literal c
preliminary version definition given pipatsrisawat darwiche
second three conditions required
definition absorption see non empty clause absorbed
set clauses inconclusive round r started literal xa
r falsifies xa satisfy xa logical consequence
witnesses precisely fact empowering via xa
converse true
lemma let set clauses let c non empty clause c
let xa literal c c empowering via xa respect
absorb c xa


fiatserias fichte thurley

proof let c c xa assume first absorb c xa let r sr
inconclusive round started witnessing fact e sr falsifies c
assign x particular sr furthermore every unit clause b
b sr r inconclusive round straightforward induction
see every obtained repeated applications unit clause propagation
satisfies sr directly implies conditions definition
empowerment condition met assumption
converse assume c empowering via xa respect
inconclusive round started falsifies c assign
x let r sr round started every decision assignment
chosen falsify literal c among rounds property assigns
many literals c possible clearly maximal round exists since one
make decision meets property
shall r round seek r let
maximal assignment si let obtained repeated applications
unit clause propagation let subset assignments
si particular si shall prove induction si hence
si
base case trivial since assume si
th assignment si decision assignment construction falsifies literal
c hence belongs belongs required
th assignment si implied distinguish two cases whether belongs
implied assignment required
implied assignment hence since
si induction hypothesis unit clause responsible
definition si appears process forming hence process forming
therefore assignment
completes induction shows particular sr r point
definition empowerment r inconclusive furthermore point definition
empowerment sr assign x remains sr falsifies c first
note maximality r fact r inconclusive every literal c
assigned r moreover since decision assignments r chosen falsify
literals c suffices implied assignments r satisfy literal
c thus suppose contradiction b implied assigned r
b literal c let r b unit clause si since
si sr r assigned b unit clause b si appears
empty clause closure unit clause propagation contradicts point
definition empowerment completes proof

let us note point condition definition empowerment
dropped hypothesis c dropped lemma would
make empowerment absorption literally dual


ficlause learning

beneficial rounds
shall study key situation explains possibly simulate
resolution proofs consider resolvent c res b two absorbed clauses b
however absorbed goal study b c look
case start showing c absorbed literal c
appears b property held key discovering concept clauseabsorption relevance simulation resolution proofs similar connection
clause learning observed pipatsrisawat darwiche pointed
condition literal c appears b known merge
resolution andrews
lemma let set clauses let b two resolvable clauses absorbed
let c res b literal c absorb c
appears b
proof let c res b let b b let
xa literal c assume absorb c exists
inconclusive round r falsifies c xa set x since belongs c
c b belongs b belongs
done otherwise assume without loss generality belongs
b case r falsifies b since b absorbed set r r
falsifies xa since absorbed x set r contradicts choice
r x set
continue showing situation interest exist beneficial
round predicts eventual absorption
definition beneficial round let set clauses let non empty clause
let xa literal let r inconclusive round started say r
beneficial xa falsifies xa branches xa leaves x unassigned

yields conclusive round extended decision x conclusive round obtained

extending r x called beneficial xa say r beneficial
beneficial literal
words round started beneficial xa witness
absorb xa minimal property yet yields conflict
x set wrong value thus informally beneficial round witness
almost absorbs xa
lemma let set clauses let b two resolvable clauses
absorbed let c res b c non empty absorbed
round started beneficial c
proof identify literal xa c able build beneficial round c
xa
let c res b let b b c
non empty absorbed literal xa c inconclusive round r


fiatserias fichte thurley

started falsifies c c xa set x x assigned
r since otherwise would falsify c c b absorbs
b would satisfied r shows x unassigned r
let r inconclusive round started obtained applying lemma
c given inconclusive round r claim r beneficial c xa
round r falsifies c agrees r c r branches c r subsumes
r leaves x unassigned finally note r r agree b

hence extending round r decision x yields conclusive round otherwise
would satisfied since b absorbed
main technical lemma
start analyzing number complete rounds takes resolvent
two absorbed clauses absorbed function width however trivial
first determine number complete rounds takes sufficient prerequisite
absorption occurs beneficial round
lemma let set clauses let b two resolvable clauses
absorbed non empty resolvent c res b let n total
number variables k width c every let r rt denote
consecutive complete rounds started let dt
denote intermediate sets clauses probability none ri beneficial
k
c none di absorbs c et n
proof let r rt denote consecutive complete rounds started
let dt intermediate sets clauses particular
ri round started di every let ri event ri
beneficial let di event di absorb c want compute
upper bound joint probability events note




j
j







pr
ri
pr rj dj
ri
pr rj dj
ri



j



j



hence shall give appropriate upper bounds factors right hand side
inequality let us first bound pr rj dj rj dj r
conditions dj rj dj r lemma implies
inconclusive round r started dj beneficial c xa c
probability rj beneficial c bounded probability rj
beneficial c xa therefore bound latter
first let us compute lower bound probability first k decisions

decision strategy chosen falsify c xa k th choice x probability
choices made least






k
k


k



k
k
k
n
n
n k
n k
n
n
note round started dj follows choices may even able
decisions corresponding assignments may implied however


ficlause learning



decision x made round following choices perform decisions
agree r c xa therefore stay subsumed r every decision

lemma particular right decision x inconclusive falsify
c xa leave x unset lemma performed assignments

r order therefore addition x make conclusive follows
probability round beneficial c xa bigger
consequently probability rj conditional dj rj dj r bounded
n k therefore equation
pr






ri




k
k
et n
n

second inequality used fact x ex every real number x
bounds
tools given able prove main
simulation width k resolution shall first give proof
employing decision learning scheme proof easier
instructive get slightly better bounds special case afterwards
see asserting learning schemes general
decision scheme
fact makes decision easier analyze learning scheme
occurrence beneficial round immediately yields absorption next step indeed
r beneficial c branches c means clause learned
complete round subset c particular means next set clauses
absorb subset c hence c well lemma obtain following
direct consequence lemma
lemma let set clauses let b two resolvable clauses
absorbed non empty resolvent c res b let n total
number variables k width c decision
learning scheme probability c absorbed current set clauses
k
restarts et n
proof let r rt denote consecutive complete rounds started
let dt intermediate sets clauses particular
ri round started di every let ri event
ri beneficial c let di event di absorb c one
ri beneficial c di absorbs c see note r branches
c clause ci learned ri satisfies ci c hence di absorbs ci c
lemma dt absorbs c one di absorbs lemma
hence
probability c absorbed dt bounded pr
ri di
k
n
lemma implies bounded e



fiatserias fichte thurley

theorem let f set clauses n variables resolution refutation
width k length probability least started f
decision learning scheme learns empty clause ln nk conflicts
restarts
proof resolution refutation must terminate application resolution rule
form res x x x x probability
absorbed current set clauses ln nk restarts
thus x x absorbed probability least case
straightforward every complete round conclusive particular
round make decision conclusive case empty
clause learned
let c c cr resolution proof included width k
resolution refutation f particular r every ci non empty width
k let ds sequence clause sets produced
rt ln r nk e every r let ei event every
clause initial segment c ci absorbed dit let e negation note
pr e vacuously hence pr e bound probability
ei hold conditional ei cases let pi pr e ei probability
ci clause f pi lemma ci derived two previous clauses
k
pi et n lemma r choice
law total probability gives






pr e pr e ei pr ei pr e e pr e




pr e ei pr e



p
adding r together pr e gives pr e r ri pi
r

r since probability cr absorbed drt bounded pr e r
proof follows
asserting learning schemes general
shall study applying arbitrary asserting learning scheme
analysis bit complex decision scheme since general clause
learned complete round r cannot assumed subset decisions r
therefore resolvent eventually absorbed little detour
note proof overcome similar difficulties inspired proof
proposition work pipatsrisawat darwiche
need preparation let c clause set clauses let wc
denote set literals c exists inconclusive round started
beneficial c let u c denote number variables left unassigned
inconclusive round started beneficial c round
exists define u c note number well defined follows easily
thank anonymous reviewer pointing original proof proposition work
pipatsrisawat darwiche contained error corrected version
webpage proof affected error



ficlause learning

lemma every inconclusive round started beneficial c leaves
number variables unassigned define
uc

x

u c

wc

note c absorbed wc moreover hypothesis
lemma converse true analogously c absorbed uc
hypothesis lemma converse true
lemma let sets clauses let b two resolvable
clauses absorbed let c res b wc wc u c
u c wc
proof wc nothing shown otherwise xa wc start
showing xa belongs wc let r inconclusive round started
beneficial c application lemma r c xa yields inconclusive round
r started following properties r subsumes r agree c xa
r branches c xa r beneficial c xa remains

prove extending r x yields conclusive round let r round defined
extension let c res b r falsifies b
absorption r cannot inconclusive otherwise would satisfied r
proves wc wc
u c u c every wc belong wc
nothing shown since u c case otherwise let r r inconclusive
rounds beneficial c r started r started
lemma r subsumes r finishes proof
lemma let set clauses let b two resolvable clauses
absorbed let c res b let r conclusive round started let
obtained adding asserting clause learned r c empty
r beneficial c c u c u c uc uc
proof lemma already know uc uc u c u c therefore
suffices demonstrate presence r second inequality strict
hypothesis r beneficial c let c asserting clause learned r
let r unique inconclusive round contained r beneficial c
round contain last decision made r lemma number
assignments made two rounds started beneficial c
hence number variables left unassigned r equals u c u c
since least one variable unset
u c already u c u c therefore assume u c
particular exists inconclusive round r started beneficial c
lemma round r subsumes r definition asserting clauses c r
unit clause since c belongs absorbed hence r satisfies c
proves r sets least one variable r therefore u c u c


fiatserias fichte thurley

two technical lemmas hand ready state prove analogue
lemma arbitrary asserting learning schemes
lemma let set clauses let b two resolvable clauses
absorbed non empty resolvent c res b let n total
number variables let k width c arbitrary
asserting learning scheme probability c absorbed current set clauses
k
kn restarts kn et n
proof let b uc bt let ds sequence sets clauses
produced starting every b let xi uc dit
let ei event xi b
bound probability c absorbed dbt since
event implies xb suffices bound pr e b note pr e vacuously
hence pr e bound probability ei hold law
total probability gives






pr e pr e ei pr ei pr e e pr e




pr e ei pr e
let pi pr e ei note pr e xi b hence pi
pr e xi b consider sequence dit sets clauses
corresponding complete rounds conditional xi b
event e implies xi xi hence none sets clauses absorbs
c furthermore lemma none corresponding rounds beneficial c thus
k
lemma pi et n adding r together



pb
k
pr e gives pr e b pi b et n lemma follows necessarily
b kn
able prove main theorem
theorem let f set clauses n variables resolution refutation width
k length probability least started f arbitrary asserting learning scheme learns empty clause km ln knm nk
conflicts restarts
proof proof analogous proof theorem lemma playing role
lemma choosing ln kn nk e

consequences

total number clauses width k n variables bounded k nk
nk every n k therefore f n variables resolution refutation width
k may assume length nk following estimate

k

k
k
x
x
n
n


n n
nk


n




obtain following consequence theorem


ficlause learning

corollary let f set clauses n variables resolution refutation
width k probability least started f arbitrary
asserting learning scheme learns empty clause k k ln kn n k
conflicts restarts
application corollary even though explicitly defined
purpose used decide satisfiability cnf formulas treewidth
k time k log kn n k follows known fact every unsatisfiable formula treewidth k resolution refutation width k
alekhnovich razborov dalmau kolaitis vardi atserias dalmau

interested producing satisfying assignment exists proceed
self reducibility assign variables one time running log n times
assignment detect current partial assignment cannot extended
case choose complementary value variable use
fact f treewidth k f x treewidth k
analysis note since run correct probability least
assignment correct probability least
log n



n

means iterations correct probability least
running time k log kn n k

n
n








acknowledgments
thank martin grohe suggesting comparing power sat solvers
bounded width resolution thank knot pipatsrisawat adnan darwiche
pointing connection empowering absorption thanks
peter jeavons comments conference version anonymous
referees detailed comments
first author supported part cycit tin c second
author supported part european council erc grant
third author supported part fellowship within postdoc programme
german academic exchange service daad preliminary version appeared
proceedings th international conference theory applications
satisfiability testing sat atserias et al

references
alekhnovich razborov satisfiability branch width tseitin tautologies proceedings rd symposium foundations computer science
focs pp ieee computer society
alekhnovich razborov resolution automatizable unless w p
tractable siam j comput


fiatserias fichte thurley

andrews p b resolution merging j acm
atserias dalmau v combinatorial characterization resolution width
j comput syst sci
atserias fichte j k thurley clause learning many
restarts bounded width resolution kullmann ed proceedings th
international conference theory applications satisfiability testing sat
vol lecture notes computer science pp springer
bayardo r j schrag r c csp look back techniques solve real world
sat instances proceedings fourtheenth national conference artificial
intelligence aaai pp
beame p kautz h sabharwal understanding power clause
learning gottlob g walsh eds proceedings eighteenth international joint conference artificial intelligence ijcai pp morgan
kaufmann
beame p kautz h sabharwal towards understanding harnessing
potential clause learning j artif intell res jair
ben sasson e johannsen j lower bounds width restricted clause learning
small width formulas strichman szeider eds proceedings th
international conference theory applications satisfiability testing sat
vol lecture notes computer science pp springer
ben sasson e wigderson short proofs narrow resolution made simple
proceedings thirty first annual acm symposium theory computing
stoc pp
dalmau v kolaitis p g vardi constraint satisfaction bounded
treewidth finite variable logics cp proceedings th international
conference principles practice constraint programming pp london uk springer verlag
fox gomes c p eds proceedings twenty third aaai conference
artificial intelligence aaai chicago illinois usa july aaai
press
hertel p bacchus f pitassi gelder v clause learning effectively
p simulate general propositional resolution fox gomes fox gomes
pp
jeavons p petke j local consistency sat solvers proceedings
th international conference principles practice constraint programming
cp vol lecture notes computer science pp springer
moskewicz w madigan c f zhao zhang l malik chaff engineering efficient sat solver proceedings th design automation conference
dac
nieuwenhuis r oliveras tinelli c solving sat sat modulo theories abstract davisputnamlogemannloveland procedure dpll
journal acm


ficlause learning

nordstrom j narrow proofs may spacious separating space width
resolution siam j comput
pipatsrisawat k darwiche clause learning scheme efficient unsatisfiability proofs fox gomes fox gomes pp
pipatsrisawat k darwiche power clause learning sat solvers
restarts gent p ed proceedings th international conference
principles practice constraint programming cp vol lecture
notes computer science pp springer
silva j p sakallah k grasp search satisfiability
proceedings ieee acm international conference computer aided design
pp
zhang l madigan c f moskewicz w malik efficient conflict driven
learning boolean satisfiability solver international conference computeraided design iccad pp




