journal artificial intelligence

submitted published

complexity integer bound propagation
lucas bordeaux

lucasb microsoft com

microsoft j j thomson avenue cb fb
cambridge united kingdom

george katsirelos

gkatsi gmail com

lri universite paris sud
paris france

nina narodytska

ninan cse unsw edu au

nicta neville roach laboratory
university south wales
anzac parade kensington nsw australia

moshe vardi

vardi cs rice edu

rice university p box
houston tx u

abstract
bound propagation important artificial intelligence technique used constraint
programming tools deal numerical constraints typically embedded within
search procedure branch prune used every node search tree narrow
search space critical fast procedure invokes constraint
propagators common fixpoint reached known
pseudo polynomial worst case time complexity fast indeed variables
small numerical range well known prohibitively
slow ranges large important question therefore whether stronglypolynomial exist compute common bound consistent fixpoint set
constraints answers question particular fixpoint
computation fact np complete even restricted binary linear constraints

introduction overview main
constraint solvers typically solve interleaving search propagation propagation iterative procedure iteration propagates every constraint
narrow domains variables iteration stops constraint
changes domains variables case propagation reached common fixpoint constraints iterative guaranteed compute fixpoint
polynomial time propagating constraint takes polynomial time domains
variables defined lists values often however inconvenient infeasible list values explicitly instead domains defined lower upper bounds
focus representation variables taking integer values setting
computing fixpoint iterative may require exponential time even
constraint propagated polynomial time exponential behaviour
simply due iterative suboptimal rather intrinsic
c

ai access foundation rights reserved

fibordeaux katsirelos narodytska vardi

computing fixpoint np complete even system constraints
restricted binary linear inequality constraints
bound propagation slow convergence
illustrate behaviour iterative fixpoint system two constraints
x x

initial bounds

x

possible trace fixpoint computation following lower bound
initially constraint x deduce cannot take values
sum even fix x highest allowed value therefore
intervals narrowed x similarly



x
x

back

x

deduce
deduce

deduce

x
x
x
x






point reached common fixpoint constraints cannot
deduce domains need narrowed
however exhibits slow convergence behaviour even deceivingly simple
examples
x x

initial bounds

x



iterative fixpoint computation shrinks bounds one unit
iteration means iterations required reach fixpoint
case empty slow convergence fact exponential size
representation log bits enough represent bound behaviour
limited artificial examples previous one fact happens time
solving large numerical ranges severely limits application cp
areas software verification theorem proving large ranges needed e g
whole bit integer range
due importance efforts made alleviate slow convergence notably jaffar maher stuckey yap lhomme gottlieb rueher
taillibert lebbah lhomme leconte berstel proposed
algorithmic improvements prevent slow convergence specific cases fully addressing
slow convergence would require strongly polynomial fixpoint
computation therefore question exist bound propagation fact intractable
prior complexity propagation
standard propagation iterative processes apply propagators e narrowing functions associated constraint reaching fixpoint complexity
therefore determined two complementary questions


fithe complexity integer bound propagation

q hard compute propagator
q hard common fixpoint propagators
complexity constraint propagation sense extremely well studied
aware bound propagation deal question prior
hardness showed complex constraints cannot polynomial time
propagators reaching certain levels consistency two
given linear equality observed yuanlin yap choi harvey
lee stuckey propagator reaches arc consistency bound z
consistency needs solve knapsack np complete weak
sense reason propagators linear constraints used practice reach
weaker consistency bound r consistency restricted small
domains proposed instance trick
bessiere prove even bounded arity two variable constraints
constructed checking bound z consistency np complete
question makes sense course common case propagators
polynomial time computable computing common fixpoint cannot
easy general known fact case standard iterative propagation
often take exponential number steps reach fixpoint practice
mentioned illustrated section leaves open question whether better
exist fixpoint computation fact intrinsically hard
main
consider simple common propagators address question
general even surprisingly simple propagators lead fixpoint computation np hard explains standard iterative fixpointcomputation exponential worst case practice shows unlikely exists better worst case particular important
class simple propagators whose fixpoint computation np hard bound r consistency propagators linear constraints proposition ubiquitous constraints
weak widely used propagators constraints many
use numerical computations large domains tend include least linear constraints
therefore cases slow convergence avoidable nevertheless
identify one case coefficients linear constraints unit absolute
value bound r consistency obtained polynomial time non standard
propagation linear programming study types basic
numerical constraints multiplication max
outline
section summarize required material constraint satisfaction
bound propagation section focuses linear constraints prove
give formal definitions bound r bound z consistency section



fibordeaux katsirelos narodytska vardi

aforementioned proposition identify restricted forms linear constraints
propagation tractable section presents basic propagators
quadratic constraints hardness strengthened holds even fixed
number variables max constraints fixpoint computation interesting complexity
p np complete proved equivalent important open
last comment max closed constraints conclude section

formal background
section summarize required material constraint satisfaction
bound propagation details material found papers e g schulte
carlsson bessiere
constraint satisfaction
constraint satisfaction csp triple hx ci x x xn
set variables dn set finite domains finite sets values one
variable c set constraints consider discrete domains
elements integers moment simply define constraints generally
logical predicates subsets x later consider specific types
constraints instance linear ones assignment function assigns value
xi di every variable xi solution csp assignment satisfies
constraints throughout keep following conventions
n x denotes number variables
c number constraints
maxi n di size largest domain
important note di may represented interval rather explicit
set values work consider domains represented intervals domain
form di li ui li ui lower upper bounds domain
propagators notions bound consistency
constraints associated propagators setting
general several propagators per constraint follow classical presentation
propagators operators lattice initiated work benhamou
details found papers apt schulte carlsson
propagator function narrow domains variables removing
values cannot appear solution thus talk current domain
variable xi narrowed application one propagators


denote x
current lower bound xi xi current upper bound xi

xi initially set initial bounds li ui remain afterwards constrained

li x
xi ui denote cartesian product intervals li ui
n


fithe complexity integer bound propagation

definition propagator propagator constraint k function f
p p
monotone e f f
contracting e f
correct e point f satisfies constraint
restrict propagators polynomial time computable bound consistency propagators additionally restricted elements p representable
cartesian products intervals plus special value
several types propagators used numerical constraints propagators
characterized level consistency enforce since restricted
focus interval domains present bound consistency two main variants
bound z bound r consistency
definition bound z r support bound z bound r support constraint k

assignment integer real values variables x x
xi xi
n satisfies constraint k
definition bound z r consistency constraint k bound z bound r consistent iff every variable xi x exists bound z bound r support
x x
xi x


bound z bound r support
difference two easily understood example
example consider constraint x z
intervals x z bound r consistent since integer bounds
real valued support x supported tuple x z
z tuple x z x z
tuple x z
intervals however bound z consistent integer solution
x z means bound z consistency would reduce bounds
x z
bound z consistency requires check existence integer valued support
classes constraints linear equalities propagator would need
solve np complete since focus computation common fixpoint
simple operators consider bound r consistency noted previously
literature schulte stuckey bound r consistency fact bound
consistency implemented primitive constraints precisely often
one propagators easy compute general large domains
rest focus several main basic types numerical constraints
particular linear ones give details bound r consistency propagators
obtained constraints cases consider propagators simple
indeed


fibordeaux katsirelos narodytska vardi


change true
change
change false
foreach f f
olda
f
olda change true
done
done
figure simple fixpoint computation
fixpoints
propagators monotone narrowing operators thus may consider identifying greatest common fixpoint set propagators
definition greatest common fixpoint greatest common fixpoint gfp f
set propagators f largest cartesian product intervals
operator f f f
two computational related fixpoints
function effectively compute gfp f
decision decide whether gfp f e whether exists nonempty fixpoint note definition propagators implies f
f f therefore common fixpoint words propagators
stabilize non empty domains
often complexity work mostly focus decision
reason basic complexity classes np particular defined decision
hardness decision imply function
hard place refer function section
describe basic greatest fixpoint computation
computing gfp f specified fig presented simplest
form excludes several possible optimizations related particular fact
constraints necessarily deal variables optimizations well known
orthogonal discussion initialize cartesian

product domains words initially x
li xi ui
n simply apply propagators stable state reached e
propagator shrinks domain reader verify specifies
formally reasoning presented informally introductory example sec


fithe complexity integer bound propagation

complexity upper bound fixpoint propagation
worst case time upper bound fixpoint computation analyzed follows
let p f number propagators note general one
propagators per constraint e p enter loop nd times since
every iteration must reduce least one bound one unit time
foreach loop entered p times overall therefore terminates
number propagator applications
npd
words fact exponential number bits encoding complexity
written np b b number bits bound encoding despite
fact propagator polynomial size encoding
called pseudo polynomial contrast truly polynomial number
bits encoding e whose worst case time complexity n log
polynomial called strongly polynomial papadimitiou
pseudo polynomial scales linearly size
domains may exponentially large since propagators consider
take strongly polynomial time analyis upper bound summarized follows
observation naive fixpoint computation fig terminates
pseudo polynomial time
question whether strongly polynomial exist rest
focusses question several classes propagators

linear constraints
section consider linear inequalities e set constraints c contains
inequalities form
x
ai k xi ck
k

n

ck ai k integers convenient introduce extra notation
denote si k sign ith term constraint k e
si k



ai k
ai k



moreover given sign sign defined

otherwise sign simply denote notation terms ai k xi k


ai k xi k simply represent smallest largest elements set ai k v v x
xi
papers give explicit upper bounds complexity computing fixpoint set bound
consistency propagators earliest reference aware work lhomme
considers constraints reals assumes finite precision floating points analysis directly
adapts discrete intervals



fibordeaux katsirelos narodytska vardi

bound r consistency propagators linear inequalities
briefly summarize material need bound r consistency case linear
inequalities refer reader literature details particular papers
harvey stuckey schulte carlsson bessiere apt
zoeteweij substantial material bound r consistency linear constraints
interest works improve bound propagation long linear
constraints harvey schimpf katriel sellmann upfal van hentenryck

consider variable xi bound xi k bound r inconsistent w r kth inequality
system iff even fix terms maximum obtain something
lower ck bound consistent opposite true e iff
k

k x



si k

ai k xi k ai k xi

sn k



ai k xi k k xn

ck



call bound consistency inequality variable xi w r constraint k
bound consistency propagator linear inequality simply shrinks bounds
variable xi let
x

aj k xj j k
qi k ck
j n j



minimal quantity reached ai k xi k satisfy bound consistency

inequality words xi bound consistent w r constraint k iff ai k xi k qi k
bound r consistency propagator associated constraint k variable
n function reduces bound xi closest bound consistent value
defined following pseudo code
ai k x


li k
ai k

x






l



j

max x

min

x


qi k
ai k

qi k
ai k





k

propagator nothing ai k
np completeness integer fixpoint computation
prove propagators li k introduced previous sub section eq
although simple considered independently give rise complex fixpoints
precisely np completeness following decision
decision bound r consistency linear constraints
input csp whose set constraints c linear inequalities
question let f li k n k set bound r consistency propagators associated csp propagators f non empty common fixpoint
characterising fixpoints inequalities
first observation bounds obtained fixpoint reached characterized
bound consistency conditions eq words fixpoint reached iff


fithe complexity integer bound propagation


lower upper bounds x
xi satisfy following inequalities variable
constraint k



k





ai k xi k ai k xi k ai k xi k k xn n k ck
k x




li

x




x


k n
n

ui



clear decision answered positively iff integer values

bounds x
xi n satisfy linear program fixpoint exists
bounds given fixpoint satisfy inequalities within initial bounds
li ui conversely inequalities satisfied fixpoint
first consequence decision membership np straightforward since solvable integer programming
linear inequalities two variables per inequality
key understanding decision hard connect fixpoint computation
special case integer linear programming constraints two variables
per inequality tvpi lp terminology see bar yehuda rawitz
definition tvpi instance constraints n variables integer linear
program following form


ak xik bk xjk ck k
li xi ui
n

b c vectors arbitrary possibly negative integers
feasibility tvpi constraints np complete decided pseudopolynomial time early pseudo polynomial time found work
aspvall shiloach essentially reduces sat
instance size solvable linear time overall therefore
runs pseudo polynomial time pseudo polynomial space requirement
particularly relevant tvpi constraints proposed work baryehuda rawitz pseudo polynomial time complexity
low strongly polynomial space requirements interestingly essentially uses
bound propagation fact precisely bound r consistency embeds amounts
backtrack free search parallel improvement allows amortize overall
runtime
seems suggest strong relation propagation tvpi constraints
particular one could easily mistaken believe propagation decision procedure
systems tvpi constraints say propagation provides decision procedure
class constraints propagation fails exactly constraints unsatisfiable
focus feasibility optimization e optimizing linear function
tvpi constraints strongly np hard e np hard even bounded domain sizes fact domains
enough trivially encodes max sat bar yehuda rawitz



fibordeaux katsirelos narodytska vardi

words existence bound consistent state suffices guarantee existence
solution usual condition guarantees backtrack free search
propagation rarely achieves general case fact decision procedure
tvpi constraints
example consider x x x
inconsistent yet bound r consistent fact bound z consistent
prove main need identify restricted case tvpi constraints
fixpoint computation indeed decision procedure particular case
monotone tvpi constraints two variables inequality coefficients
opposite signs e following form
definition monotone tvpi instance constraints n variables integer linear program following form


ak xik bk xjk ck k
li xi ui
n

ak bk k
prove np hardness monotone tvpi constraints
following
theorem lagarias feasibility two variable per inequality monotone integer programming np complete
np hardness
prove decision np hard already know np
therefore state main bound r consistency linear constraints
proposition decision np complete
proof fixpoint computation decides systems monotone tvpi constraints
consider monotone tvpi instance q form given def want
equivalence q integer solution iff set bound r consistency propagators
obtained q non empty common fixpoint
q integer solution means exist integer values vi variable
xi satisfying li vi ui k
ak vik bk vjk ck




exists common fixpoint means bounds x
xi found


n satisfying li xi xi ui k

ak x
ik bk xjk ck


ak x
ik bk xjk ck



simply constraints eq variable xik left xjk right
rewritten taking account b


fithe complexity integer bound propagation

prove two directions iff
consider integer solution q variable xi takes value vi easy



verify bounds x
xi vi satisfy li xi xi ui eq

consider bound consistent state described bounds x
xi easy verify
solution v defined vi x
n satisfies li vi ui eq

means reduce monotone tvpi feasibility existence
fixpoint decision therefore np hard
note np hardness decision holds even monotone
tvpi constraints pseudo polynomial upper bound section holds general
linear constraints unbounded sizes said earlier membership np valid
general linear constraints
comment linear equalities
beginning section focused linear inequalities reasons
become clear sub section readers may wonder whether considering equalities
would make difference short answer
p
first observation inequality n ai xi c directly encoded
p
p
equality n ai xi c variable ranging u u ai xi si
bijection solutions two constraints therefore
propagating inequalities reduces propagating equalities npcompleteness still holds whose linear constraints equalities
mix equalities inequalities
second observation following focus bound r consistency
p
propagation obtained equality n ai xi c one obtained
p
p
two constraints n ai xi c n ai xi c reason convenient
assume constraints homogeneous form restrict linear
inequalities
tractable classes linear constraints
intractable often become tractable additional restrictions imposed
topology constraint graph constraints subsection
identify one significant class linear constraints propagated strongly
polynomial time restriction coefficients constraints
initial observation one source complexity propagators li k eq
use rounding update variables bounds obtain
variables real value rounded upwards lower bounds downwards upper
bounds effects rounding noticed previous authors used optimize
note case inequalities propagators bound z consistency
bound r consistency since want propagators polynomial time computable case want
avoid however bound z consistency linear equalities cannot define polynomial time
computable propagators unless p np



fibordeaux katsirelos narodytska vardi

propagation harvey stuckey rounding effectively means propagation stabilizes integral solutions linear programs linear programs question
specific form intractability due integrality therefore sub section
observe remove rounding becomes tractable use
observation coefficients unit e belong
effectively rounding means tractability holds
linear propagators without rounding
consider operators similar eq without rounding words
associate linear constraints following operators
ai k x





si k
ai k

x




q

k
max x
ai k

min



qi k
x
ai k







even initial bounds integers assumed throughout
operators general reduce bounds real values note propagators
effectively used deal variables real valued domain indeed used
constraint programming community behamou granvilliers
operations community different terminology used feasibility
bounds tightening see e g belotti cafieri lee liberti
decision focus whether exist real valued bounds
fixpoint note tractable similar reported
independently work belotti cafieri lee liberti
decision fixpoint continuous linear propagators
input csp whose set constraints c linear inequalities
question set real valued propagators f si k n k associated c common fixpoint
observation decision decided linear programming
easy see fixpoints operators si k exactly real valued solutions
system linear constraints eq note careful statement
observation whether linear programming strongly polynomial fact longstanding open question smale best polynomial time lp
encouragingly time complexity n b polynomial b
number bits number encodingthis looks strongly polynomial khachian
catch complexity counted number operations operations
rationals principle expand size numbers repeated multiplications
blow representation exponentially however practical purposes typical lp
implementations prevent blow number representation limiting precision
b bits throughout execution solvability linear programming widely regarded
synonymous strong tractability provably sub exponential lp exist
matousek sharir welzl words observation really read
carefully phrased way say efficiently solvable practice


fithe complexity integer bound propagation

linear constraints unit coefficients
unit linear constraint usual form n ai k xi ck additional
restriction coefficient ai k chosen introductory example
slow convergence eq particularly simple example unit linear constraints
slow convergence could particular case avoided note considering
linear unit constraints number variables special case unit constraints
widely studied class unit tvpi constraints e unit tvpi
perhaps important class linear constraints whose integer feasibility
solved strongly polynomial time see instance work jaffar et al
p

proposition constraints unit coefficients decision
decided linear programming
proof lp course form given eq observation short
rounding needed coefficients unit

precisely cartesian product intervals let l k li k

k si k coefficients unit defined
bounds initial cartesian product integral lt
first note bounds lt integral since original
state integral bounds operator l applies rounding equality
lt proved induction lt
induction hypothesis holds step lt
l lt lt lt integral bounds hence applying l
cartesian product gives eq qi k integral case
ai k unit therefore division qi k ai k gives integer means
propagators li k rounding return non rounded propagators si k
eq
lt easy see gfp li k gfp si k
domains finite lt stabilizes finite particular lt
greatest fixpoint l greatest cartesian product greatest
fixpoint
note general linear programming necessarily integer solutions
system eq shows lp solution iff integer one

exists want actually compute largest consistent bounds x
xi certain


variable xi simply minimize xi maximize xi constraints eq
previous proof shows extremal values integral
tractable cases
interesting consider whether properties make propagation solvable
strongly polynomial time respect restrictions constraint graph
nevertheless reasons pessimistic note feasibility monotone tvpi integer
programming remains np complete strict restrictions constraint graph
shown work hochbaum naor suggests restrictions
unlikely lead interesting tractable classes fixpoint computation


fibordeaux katsirelos narodytska vardi

regarding restrictions coefficients note general np completeness
monotone tvpi constraints assumes coefficients ak bk ck arbitrary
unit restriction imposes contrary strongest restriction coefficients
absolute value impose general bound absolute values
one may wonder whether exhibits form fixed parameter tractability
leave question open future work

generalizations non linear constraints
proposition fixpoint computation numerical constraints basic common
linear constraints intractable several cases non linear constraints nevertheless interest first simplest possible type polynomials single
squaring operation added linear constraints general hardness
strengthened second interesting note enrich unit linear constraints
simple min max constraints fixpoint computation equivalent puzzling open
discussed recently theorem proving literature last briefly comment
connections tractability max closed constraints
quadratic constraints
purposes section sufficient enrich linear constraint language
constraints form given eq squaring constraints form
xi x j
sufficient restrict non negative values variables xi xj e
li ui lj uj setting bound r consistency propagators
defined following instructions




x
max xi xj

x
j



max x
j



q

x








x
min xi xj



x
j





min x
j

q



x








words fixpoints integer solutions following bound consistency
inequalities



x
xj








x
xj





x
j

q

x


x
j

q

x




simple quadratic constraints added language linear constraints
np completeness strengthened np complete even
considering bounded number variables constraints fact one tvpi constraint
one squaring constraint due fact fixpoint computation converges
state encodes complex number theoretic
proposition given csp variables constraints x x c x x
determining whether associated bound r consistency propagators fixpoint
np complete


fithe complexity integer bound propagation

proof membership np straightforward hardness special
case ai focus said positive intervals first note
bound consistency inequalities eq squaring constraint x x



satisfied iff x
x x x since focus integer bounds property
squaring propagator noticed slightly different form schulte stuckey
propagation viewpoint equality x x c seen two inequalities
x x c x x c whose bound consistent inequalities eq



effectively satisfied iff x
x c x x c
rely theorem manders adleman shows deciding whether
equation form x x c integer solutions c
non negative integers np complete reduce existence bound
consistent bounds conjunction x x c x x initial bounds l l
l u u u c need fixpoint computation complete
systema bound consistent state found iff original equation solution
original equation solution e pair non negative integer values




hv v satisfying v v c define x
x v x x v




x x v bounds xi xi c satisfy bound
consistency conditions eq eq




conjunction bound consistent state e bounds x
xi eq

eq satisfied solution v defined v x
v x satisfies

original equation v v c

connections max atom
another common type primitive non linear constraints form
xh max xi xj
bound r consistency propagators constraint following schulte
stuckey

x
min xi xh


x
h max xh xi xj





x
h min xh max xi xj xj min xj xh

fact strictly reach bound r consistency one would need additionally check
whether bounds xh empty intersection bounds one max ed
variables say xi case essentially impose constraint xj xh
purposes section simpler formulation equivalent words
fixpoints characterized following inequalities

x
h max xi xj


x
xh


x
j xh


x
h xi


x
h xj

fixpoint computation max constraints mixed unit linear constraints interesting
complexity open note rounding use


fibordeaux katsirelos narodytska vardi

coefficients definition bound consistency inequalities therefore complexity
arising rounding np complete variants propagation arise
open connect called max atom work bezem nieuwenhuis
rodrguez carbonell see reference prior interest
shown equivalent max atom max atom constraint form max xi xj c xh
work reported bezem et al shows number feasibility
conjunctions max atom constraints significant complexity difference
integer real feasibility decided pseudo polynomial
time amounts fixpoint computation short
proofs unsatisfiability therefore npconp means
different nature np complete variants fact recent atserias
maneva shows complexity max atom equivalent well known open
called mean payoff games turn connections important open
questions model checking parity games class games reducible mean payoff games
equivalent model checking calculus emerson jutla sistla
jurdzinski
draw simple connection follows observation bound

consistency inequalities upper bounds include constraint x
h max xi xj
encode max atom constraints almost directly
proposition bound r consistency combination unit linear max constraints
solved polynomial time max atom solved polynomial time
proof reduce max atom instance variables xi n constraints
fixpoint computation simply introduce one fresh variable yk k
let kth constraint form max xik xjk ck xhk rewrites conjunction
max xik xjk yk yk ck xhk lower bounds variables fixed
p
upper bounds need set k ck small model property lemma
bezem et al bound consistency equations upper bounds directly
encode

max closed constraints
last note connection class max closed constraints
introduced jeavons cooper e g petke jeavons
constraint r x xn max closed whenever two solutions hv vn
hw wn maximum defined hmax v w max vn wn solution
jeavons cooper max closed constraints tractable
system constraints max closed feasibility determined polynomial
time however note essentially assumes explicit table representation
constraint e assumed constraint defined explicitly listing
tuples solutions contrast important types constraints
numerical constraints considered implicitly defined know
list solutions r x xn verify efficiently whether particular tuple
accepted constraint


fithe complexity integer bound propagation

implicitly defined max closed constraints played important role
monotone tvpi constraints considered section max atom constraints
considered section max closed shown respectively hochbaum naor
bezem et al sharp contrast case explicitly defined constraints resolution implicitly defined max closed constraints therefore pseudopolynomial fact intractable shown special case monotone tvpi
constraints
observation feasibility implicitly defined max closed constraints np complete
shown section particular example monotone tvpi constraints
even fixpoint computation implicitly defined max closed constraints fact npcomplete general

conclusion
reasoning intervals introduced ai literature works cleary
davis substantial body ai work ensued see e g hyvonen
bound computation used finite domain cp solvers schulte carlsson

theoretically investigated complexity computing common
fixpoint set bound consistency propagators shown even
propagators simple fixpoint computation used
complex indeed np complete even restricted constraint class linear
monotone inequalities two variables per inequality considered special
classes constraints quadratic constraints max constraints finally identified
class constraints namely linear inequalities unit coefficients allows tractable
fixpoint computation
bound propagation successful widely used technique constraint programing
large literature propagating single constraints van hoeve katriel
bessiere rossi van beek walsh perhaps surprise prior
study exists complexity fixpoint computation np completeness fixpoint
computation simple types constraints fundamental somewhat surprising
one sheds light slow convergence phenomena
puts bound propagation map ai computational
together knapsack constraints forms learning neural nets schaeffer
yannakakis one important ai aware
pseudo polynomial complexity yet intractable
acknowledgments
preliminary bordeaux hamadi vardi showed np completeness
propagation case quadratic constraints considered prop
often good case made similar ideas already present earlier work particular
work lauriere interval computations course used areas fixpoint
computation methods consider relate broader theme interval arithmetic pioneered moore




fibordeaux katsirelos narodytska vardi

thoroughly revised version whose central linear constraints
general part work done g katsirelos n narodytska
vardi visiting microsoft cambridge part work done
g katsirelos employed nicta australia nicta funded australian
governments department broadband communications digital economy
australian council work partially supported anr unloc
project anr blan discussions youssef hamadi claude guy quimper gratefully acknowledged thanks anonymous reviewers whose feedback
helped improve

references
apt k r essence constraint propagation theoretical computer science
tcs
apt k r zoeteweij p analysis arithmetic constraints integer intervals
constraints
aspvall b shiloach polynomial time solving systems
linear inequalities two variables per inequality siam j computing

atserias maneva e mean payoff games max atom tech
rep universitat politecnica de catalunya
bar yehuda r rawitz efficient integer programs two
variables per constraint algorithmica
behamou f granvilliers l continuous interval constraints rossi f
van beek p walsh eds handbook constraint programming chap
elsevier
belotti p cafieri lee j liberti l feasibility bounds tightening via
fixed points proc int conf combinatorial optimization applications
cocoa p appear
benhamou f heterogeneous constraint solving proc int conf algebraic
logic programming alp pp
bessiere c constraint propagation rossi f van beek p walsh eds
handbook constraint programming chap elsevier
bezem nieuwenhuis r rodrguez carbonell e max atom
relevance proc int conf logic programming artificial intelligence reasoning lpar pp
bordeaux l hamadi vardi analysis slow convergence
interval propagation proc int conf principles practice constraint
programming cp pp


fithe complexity integer bound propagation

choi c w harvey w lee j h stuckey p j finite domain bounds
consistency revisited australian conf artificial intelligence pp
cleary j g logical arithmetic future computing systems
davis e constraint propagation interval labels artificial intelligence

emerson e jutla c sistla p model checking fragments
calculus proc int conf computer aided verification cav pp
harvey w schimpf j bound consistency techniques long linear constraints
proc cp workshop techniques implementing constraint propgramming
systems trics
harvey w stuckey p j improving linear constraint propagation changing
constraint representation constraints
hochbaum naor j simple fast linear integer
programs two variables per inequality siam j computing

hyvonen e constraint reasoning interval arithmetic tolerance
propagation artificial intelligence
jaffar j maher j stuckey p j yap r h c beyond finite domains
proc int workshop principles practice constraint programming
ppcp pp
jeavons p cooper c tractable constraints ordered domains artificial
intelligence
jurdzinski deciding winner parity games co inf process
lett
katriel sellmann upfal e van hentenryck p propagating knapsack
constraints sublinear time proc north amer nat conf artificial
intelligence aaai pp
khachian l polynomial linear programming doklady akad ussr

lagarias j c computational complexity simultaneous diophantine approximation siam j computing
lauriere j l language program stating solving combinatorial
artificial intelligence
lebbah lhomme accelerating filtering techniques numeric csps
artificial intelligence


fibordeaux katsirelos narodytska vardi

leconte berstel b extending cp solver congruences domains
program verification cp workshop software testing verification analysis
pp
lhomme consistency techniques numeric csps proc int joint conf
artificial intelligence ijcai pp
lhomme gottlieb rueher taillibert p boosting interval
narrowing proc joint int conf symp logic programming
jicslp pp mit press
manders k l adleman l np complete decision binary
quadratics j computer system sciences
matousek j sharir welzl e subexponential bound linear programming algorithmica
moore r e interval analysis prentice hall
papadimitiou c computational complexity addison wesley
petke j jeavons p tractable benchmarks constraint programming tech
rep cs rr oxford university computing laboratory
rossi f van beek p walsh handbook constraint programming elsevier
schaeffer yannakakis simple local search hard
solve siam j computing
schulte c carlsson finite domain constraint programming rossi f
van beek p walsh eds handbook constraint programming chap
elsevier
schulte c stuckey p j bounds domain propagation lead
search space acm trans programming languages systems
toplas
smale mathematical next century mathematical intelligencer

trick dynamic programming consistency propagation
knapsack constraints proc int conf integration ai techniques
cp combinatorial optimisation cp ai
van hoeve w j katriel global constraints rossi f van beek p
walsh eds handbook constraint programming chap elsevier
yuanlin z yap r h c arc consistency n ary monotonic linear constraints proc int conf principles practice constraint programming
cp pp




