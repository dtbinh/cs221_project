Journal Artificial Intelligence Research 40 (2011) 657-676

Submitted 12/10; published 03/11

Complexity Integer Bound Propagation
Lucas Bordeaux

lucasb@microsoft.com

Microsoft Research, 7 J J Thomson Avenue, CB30FB
Cambridge, UNITED KINGDOM

George Katsirelos

gkatsi@gmail.com

LRI, Universite Paris-Sud 11
Paris, FRANCE

Nina Narodytska

ninan@cse.unsw.edu.au

NICTA Neville Roach Laboratory
University New South Wales
223 Anzac Parade Kensington NSW 2052, AUSTRALIA

Moshe Y. Vardi

vardi@cs.rice.edu

Rice University, P. O. Box 1892
Houston, TX 77251-1892, U.S.A.

Abstract
Bound propagation important Artificial Intelligence technique used Constraint
Programming tools deal numerical constraints. typically embedded within
search procedure (branch prune) used every node search tree narrow
search space, critical fast. procedure invokes constraint
propagators common fixpoint reached, known algorithms
pseudo-polynomial worst-case time complexity: fast indeed variables
small numerical range, well-known problem prohibitively
slow ranges large. important question therefore whether stronglypolynomial algorithms exist compute common bound consistent fixpoint set
constraints. paper answers question. particular show fixpoint
computation fact NP-complete, even restricted binary linear constraints.

1. Introduction Overview Main Results
Constraint solvers typically solve problems interleaving search propagation. Propagation iterative procedure which, iteration, propagates every constraint
problem narrow domains variables. iteration stops constraint
changes domains variables. case, propagation reached common fixpoint constraints. iterative algorithm guaranteed compute fixpoint
polynomial time propagating constraint takes polynomial time domains
variables defined lists values. often, however, inconvenient infeasible list values explicitly: instead domains defined lower upper bounds.
focus representation, variables taking integer values. setting,
computing fixpoint iterative algorithm may require exponential time even
constraint propagated polynomial time. show exponential behaviour
simply due iterative algorithm suboptimal; rather intrinsic
c
2011
AI Access Foundation. rights reserved.

fiBordeaux, Katsirelos, Narodytska, & Vardi

problem computing fixpoint, NP-complete even system constraints
restricted binary linear inequality constraints.
1.1 Bound Propagation Slow Convergence
illustrate behaviour iterative fixpoint algorithm using system two constraints:
x + = 7, x + 1 2y,

initial bounds:

x [0, 5], [0, 10]

possible trace fixpoint computation following. lower bound
initially 0 constraint x + = 7 deduce cannot take values 0 1:
does, sum < 7, even fix x highest allowed value. Therefore
intervals narrowed x [0, 5], [2, 10]. Similarly:



x + = 7,
x + 1 2y,

back

x + = 7,

deduce:
deduce:
and:
deduce:

x [0, 5],
x [3, 5],
x [3, 5],
x [4, 5],

[2, 7];
[2, 7];
[2, 3];
[2, 3].

point reached common fixpoint constraints, cannot
deduce domains need narrowed further.
algorithm, however, exhibits slow convergence behaviour even deceivingly simple
examples as:
x < y, < x

initial bounds:

x [0, 108 ], [0, 108 ]

(1)

iterative algorithm fixpoint computation shrinks bounds one unit
iteration, means 108 iterations required reach fixpoint,
case empty. slow convergence fact exponential size problem
representation, log(108 ) bits enough represent bound. behaviour
limited artificial examples previous one fact happens time
solving problems large numerical ranges. severely limits application CP
areas software verification theorem proving large ranges needed (e.g.,
whole 32-bit integer range).
Due importance problem, efforts made alleviate slow convergence, notably Jaffar, Maher, Stuckey, Yap (1994), Lhomme, Gottlieb, Rueher,
Taillibert (1996), Lebbah Lhomme (2002), Leconte Berstel (2006); proposed
algorithmic improvements prevent slow convergence specific cases. Fully addressing
slow convergence problem would require strongly polynomial algorithm fixpoint
computation. Therefore question is: algorithm exist, bound propagation fact intractable?
1.2 Prior Complexity Results Propagation
Standard propagation algorithms iterative processes apply propagators, i.e., narrowing functions associated constraint, reaching fixpoint. complexity
therefore determined two complementary questions:
658

fiThe Complexity Integer Bound Propagation

Q1: hard compute propagator?
Q2: hard find common fixpoint propagators?
complexity constraint propagation sense extremely well-studied,
results aware bound propagation deal Question 1 only. prior
hardness results showed complex constraints cannot polynomial-time
propagators reaching certain levels consistency. Two results are:
Given linear equality observed (Yuanlin & Yap, 2000; Choi, Harvey,
Lee, & Stuckey, 2006) propagator reaches arc consistency bound(Z)
consistency1 needs solve knapsack problem, NP-complete weak
sense. reason propagators linear constraints used practice either reach
weaker consistency bound(R) consistency, restricted small
domains, proposed instance Trick (2001).
Results Bessiere (2006) prove even bounded-arity (two-variable) constraints
constructed checking bound(Z) consistency NP-complete.
Question 2 makes sense, course, common case propagators
polynomial-time computable (if not, computing common fixpoint cannot
easy general). known fact case standard, iterative propagation
algorithms often take exponential number steps reach fixpoint practice,
mentioned illustrated Section 1.1. leaves open question whether better
algorithms exist fixpoint computation is, fact, intrinsically hard.
1.3 Main Results
paper consider simple, common propagators address Question 2.
show general even surprisingly simple propagators lead fixpoint computation problem NP-hard. explains standard, iterative fixpointcomputation algorithms exponential worst-case practice, shows unlikely exists algorithm better worst case. particular important
class simple propagators whose fixpoint computation NP-hard bound(R) consistency propagators linear constraints (Proposition 1). ubiquitous constraints,
weak widely used propagators constraints. Many problems
use numerical computations large domains tend include least linear constraints,
therefore cases slow convergence avoidable. nevertheless
identify one case: coefficients linear constraints unit (1 absolute
value), bound(R) consistency obtained polynomial time non-standard
propagation algorithm based Linear Programming. study types basic
numerical constraints: multiplication max.
1.4 Outline
Section 2 summarize required material Constraint Satisfaction Problems
bound propagation. Section 3 focuses linear constraints. prove
1. give formal definitions bound(R) bound(Z) consistency Section 2.2.

659

fiBordeaux, Katsirelos, Narodytska, & Vardi

aforementioned Proposition 1, identify restricted forms linear constraints
propagation tractable. Section 4 presents results basic propagators:
quadratic constraints, hardness result strengthened holds even fixed
number variables; max constraints, fixpoint computation interesting complexity
(between P NP-complete) proved equivalent important open problem;
last comment max-closed constraints. conclude Section 5.

2. Formal Background
section summarize required material Constraint Satisfaction Problems
bound propagation. details material found papers e.g. Schulte
Carlsson (2006), Bessiere (2006).
2.1 Constraint Satisfaction Problems
Constraint Satisfaction Problem (CSP) triple hX, D, Ci, where: X = {x1 xn }
set variables, = {D1 Dn } set finite domains (finite sets values), one
variable, C set constraints. paper consider discrete domains:
elements integers. moment simply define constraints generally
logical predicates subsets X; later paper consider specific types
constraints, instance linear ones. assignment function assigns value
(xi ) Di every variable xi . solution CSP assignment satisfies
constraints. Throughout paper, keep following conventions:
n = |X| denotes number variables;
= |C| number constraints;
= maxi1..n |Di | size largest domain.
important note Di may represented interval, rather explicit
set values. work, consider domains represented intervals: domain
form Di = [li , ui ], li ui lower upper bounds domain.
2.2 Propagators Notions Bound Consistency
constraints problem associated propagators. (In setting
be, general, several propagators per constraint.) follow classical presentation
propagators operators lattice, initiated work Benhamou (1996)
details found papers Apt (1999), Schulte Carlsson (2006):
propagator function narrow domains (some of) variables, removing
values cannot appear solution. Thus, talk current domain
variable xi , result narrowed application one propagators.
+

denote x
current lower bound xi xi current upper bound. xi
+
xi initially set initial bounds li , ui remain afterwards constrained
+
li x
xi ui . denote Cartesian product intervals [li , ui ]
1..n.
660

fiThe Complexity Integer Bound Propagation

Definition 1 (Propagator) propagator constraint k 1..m function f :
P(D) P(D), is:
monotone, i.e., A0 f (A0 ) f (A);
contracting, i.e., f (A) A;
correct, i.e., point \ f (A) satisfies constraint.
restrict propagators polynomial-time computable. Bound consistency propagators additionally restricted elements P(D) representable
Cartesian products intervals, plus special value .
Several types propagators used numerical constraints; propagators
characterized level consistency enforce. Since restricted
focus interval domains, present bound consistency. two main variants
bound(Z) bound(R) consistency:
Definition 2 (Bound(Z|R) support) bound(Z) (bound(R)) support constraint k
+
assignment integer (real) values variables X x
(xi ) xi
1..n satisfies constraint k.
Definition 3 (Bound(Z|R) consistency) constraint k bound(Z) (bound(R)) consistent iff every variable xi X, exists bound(Z) (bound(R)) support
+ + (x ) = x+ .
(xi ) = x


bound(Z) (bound(R)) support
difference two easily understood example:
Example 1 Consider constraint 2x + 2y + 3z = 4.
intervals x, y, z [0, 1] bound(R) consistent since integer bounds
real-valued support: x = 0 supported tuple (x = 0, = 1, z = 2/3);
z = 1 = 0 tuple (x = 1/2, = 0, z = 1); x = 1, = 1 z = 0
tuple (x = 1, = 1, z = 0).
intervals are, however, bound(Z) consistent: integer solution
(x = 1, = 1, z = 0), means bound(Z) consistency would reduce bounds
x [1, 1], [1, 1], z [0, 0].
Bound(Z) consistency requires check existence integer-valued support,
classes constraints linear equalities propagator would need
solve NP-complete problem. Since focus computation common fixpoint
simple operators, consider bound(R) consistency paper. noted previously
literature (Schulte & Stuckey, 2005), bound(R) consistency fact bound
consistency implemented primitive constraints, precisely often
one propagators easy compute general large domains.
rest paper focus several main basic types numerical constraints (in
particular linear ones), give details bound(R) consistency propagators
obtained constraints. cases consider propagators simple
indeed.
661

fiBordeaux, Katsirelos, Narodytska, & Vardi

:=
change := true
change
change := false
foreach f F
oldA :=
= f (A)
6= oldA change := true
done
done
Figure 1: simple fixpoint computation algorithm.
2.3 Fixpoints
Propagators monotone narrowing operators, thus may consider problem identifying greatest common fixpoint set propagators.
Definition 4 (Greatest Common Fixpoint) greatest common fixpoint gfp(F )
set propagators F largest Cartesian product intervals
operator f F , f (A) = A.
two computational problems related fixpoints:
Function Problem: Effectively compute gfp(F );
Decision Problem: Decide whether gfp(F ) 6= , i.e., whether exists (nonempty) fixpoint. (Note definition propagators implies f () =
f F . Therefore always common fixpoint.) words: propagators
stabilize non-empty domains?
often complexity work mostly focus Decision problem paper.
reason basic complexity classes (NP particular) defined decision
problems, hardness results decision problem imply function
problem hard. place refer function problem section,
describe basic greatest fixpoint computation algorithm.
algorithm computing gfp(F ) specified Fig. 1. presented simplest
form, excludes several possible optimizations related, particular, fact
constraints necessarily deal variables. (These optimizations well-known
orthogonal discussion paper.) algorithm initialize Cartesian
+
product domains D, words initially x
= li xi = ui ,
1..n; simply apply propagators stable state reached, i.e.,
propagator shrinks domain further. reader verify algorithm specifies
formally reasoning presented informally introductory example (Sec. 1.1).
662

fiThe Complexity Integer Bound Propagation

2.4 Complexity Upper Bound Fixpoint Propagation
worst-case time upper bound fixpoint computation analyzed follows2 .
Let p = |F | number propagators. (Note general one
propagators per constraint, i.e., p m.) enter loop nd times since
every new iteration must reduce least one bound one unit, time
foreach loop entered p times. Overall algorithm therefore terminates
number propagator applications of:
O(npd).
words, fact exponential number bits encoding: complexity
written O(np2b ), b number bits bound encoding. despite
fact propagator polynomial size encoding. algorithms
called pseudo-polynomial. contrast algorithms truly polynomial number
bits encoding, i.e., whose worst-case time complexity O((n, m, log d)),
polynomial , called strongly polynomial (Papadimitiou, 1994). problem
pseudo-polynomial algorithm problem scales linearly size
domains, may exponentially large. Since propagators consider
take strongly polynomial time, analyis upper bound summarized follows:
Observation 1 naive fixpoint computation algorithm (Fig. 1) always terminates
pseudo-polynomial-time.
question whether strongly polynomial algorithms exist. rest paper
focusses question, several classes propagators.

3. Linear Constraints
section consider linear inequalities, i.e., set constraints C contains
inequalities form:
X
ai,k xi ck ,
k 1...m
(2)
i1...n

ck ai,k integers. convenient introduce extra notation:
denote si,k sign ith term constraint k, i.e.,:
si,k =

(

+ ai,k 0
ai,k < 0

(3)

Moreover, given sign {, +}, sign defined + =

otherwise. sign +s simply denote s. notation terms ai,k xi i,k
+s
+
ai,k xi i,k simply represent smallest largest elements set {ai,k v | v [x
, xi ]}.
2. papers give explicit upper bounds complexity computing fixpoint set bound
consistency propagators. earliest reference aware work Lhomme (1993);
considers constraints reals assumes finite precision (floating points), analysis directly
adapts discrete intervals.

663

fiBordeaux, Katsirelos, Narodytska, & Vardi

3.1 Bound(R) Consistency Propagators Linear Inequalities
briefly summarize material need bound(R) consistency case linear
inequalities. refer reader literature details, particular papers
Harvey Stuckey (2003), Schulte Carlsson (2006), Bessiere (2006), Apt
Zoeteweij (2007) substantial material bound(R) consistency linear constraints.
interest works show improve bound propagation long linear
constraints (Harvey & Schimpf, 2002; Katriel, Sellmann, Upfal, & Van Hentenryck, 2007).

Consider variable xi . bound xi i,k bound(R) inconsistent w.r.t. kth inequality
system iff: even fix terms maximum, obtain something
lower ck . bound consistent opposite true i.e., iff:
+s1,k

a1,k x1

+s

si,k

+ . . . + ai1,k xi1i1,k + ai,k xi

+sn,k

+s

+ ai+1,k xi+1i+1,k + . . . + an,k xn

ck

(4)

call bound consistency inequality variable xi w.r.t. constraint k.
bound consistency propagator linear inequality simply shrinks bounds
variable xi . Let:
X
+s
aj,k xj j,k
qi,k = ck
j[1,n], j6=i



minimal quantity reached ai,k xi i,k satisfy bound consistency

inequality (in words: xi bound consistent w.r.t. constraint k iff ai,k xi i,k qi,k ).
(bound(R) consistency) propagator associated constraint k 1..m variable
1..n function reduces bound xi closest bound consistent value.
defined following pseudo-code:
ai,k > 0 x
:=

Li,k :
ai,k < 0

x+


:=



l



j

max x
,
min

x+
,

qi,k
ai,k

qi,k
ai,k



(5)

k

(The propagator nothing ai,k = 0.)
3.2 NP-completeness Integer Fixpoint Computation
prove propagators Li,k introduced previous sub-section (Eq. 5),
although simple considered independently, give rise complex fixpoints.
precisely, show NP-completeness following decision problem:
Decision Problem 1 (Bound(R)-Consistency Linear Constraints)
INPUT: CSP whose set constraints C linear inequalities.
QUESTION: Let F = {Li,k : 1..n, k 1..m} set bound(R) consistency propagators associated CSP. propagators F non-empty common fixpoint?
3.2.1 Characterising Fixpoints Inequalities
first observation bounds obtained fixpoint reached characterized
bound consistency conditions Eq. 4. words fixpoint reached iff
664

fiThe Complexity Integer Bound Propagation

+
lower upper bounds x
xi satisfy following inequalities, variable
constraint k:


+s
+s1,k
+s

+s


+ .. + ai1,k xi1i1,k + ai,k xi i,k + ai+1,k xi+1i+1,k + .. + an,k xn n,k ck
a1,k x1




li

x




x+


k 1 . . . m, 1 . . . n
1 . . . n

ui

(6)

clear Decision Problem 1 answered positively iff integer values
+
bounds x
xi , 1..n, satisfy Linear Program 6. (If fixpoint exists
bounds given fixpoint satisfy inequalities within initial bounds
li , ui . Conversely inequalities satisfied fixpoint.)
first consequence Decision Problem 1 membership NP straightforward since solvable Integer Programming.
3.2.2 Linear Inequalities Two-Variables-Per-inequality
key understanding Decision Problem 1 hard connect fixpoint computation
special case Integer (Linear) Programming constraints Two Variables
Per Inequality (TVPI LP terminology, see Bar-Yehuda & Rawitz, 2001):
Definition 5 TVPI instance constraints n variables Integer Linear
Program following form:
(

ak xik + bk xjk ck k 1 . . .
li xi ui
1 . . . n

a, b, c vectors arbitrary (possibly negative) integers.
feasibility TVPI constraints NP-complete3 decided pseudopolynomial time. early pseudo-polynomial time algorithm found work
Aspvall Shiloach (1980); algorithm essentially reduces problem 2-SAT
instance size d, solvable linear time (the overall algorithm therefore
runs pseudo-polynomial time, pseudo-polynomial space requirement).
particularly relevant algorithm TVPI constraints proposed work BarYehuda Rawitz (2001). algorithm pseudo-polynomial time complexity
low, strongly polynomial space requirements. Interestingly, algorithm essentially uses
bound propagation (in fact, precisely bound(R) consistency), embeds amounts
backtrack-free search parallel improvement allows amortize overall
runtime.
seems suggest strong relation propagation TVPI constraints;
particular one could easily mistaken believe propagation decision procedure
systems TVPI constraints. say propagation provides decision procedure
class constraints propagation fails exactly constraints unsatisfiable (in
3. focus feasibility only. optimization problem, i.e., optimizing linear function
TVPI constraints, strongly NP-hard, i.e., NP-hard even bounded domain sizes (in fact domains
{0, 1} enough), trivially encodes Max-2SAT (Bar-Yehuda & Rawitz, 2001).

665

fiBordeaux, Katsirelos, Narodytska, & Vardi

words: existence bound consistent state suffices guarantee existence
solution). usual condition guarantees backtrack-free search;
propagation rarely achieves general case fact decision procedure
TVPI constraints:
Example 2 Consider problem x + = 1, x = x, [0, 1]. problem
inconsistent yet bound(R) consistent (and also, fact, bound(Z) consistent).
prove main result need identify restricted case TVPI constraints
fixpoint computation indeed decision procedure. particular case
monotone TVPI constraints, two variables inequality coefficients
opposite signs, i.e., problem following form:
Definition 6 monotone TVPI instance constraints n variables Integer Linear Program following form:
(

ak xik bk xjk ck k 1 . . .
li xi ui
1 . . . n

ak 0, bk 0, k 1 . . . m.
prove NP-hardness result monotone TVPI constraints, using
following result:
Theorem 1 (Lagarias, 1985) feasibility Two-Variable-Per-Inequality monotone Integer Programming NP-complete.
3.2.3 NP-hardness
prove Decision Problem 1 NP-hard. already know NP,
therefore state main result bound(R) consistency linear constraints as:
Proposition 1 Decision problem 1 NP-complete.
Proof. show fixpoint computation decides systems monotone TVPI constraints.
Consider monotone TVPI instance Q form given Def. 6. want show
equivalence: Q integer solution iff set bound(R) consistency propagators
obtained Q non-empty common fixpoint.
Q integer solution means exist integer values vi variable
xi satisfying li vi ui and, k 1 . . . m:
ak vik bk vjk ck

(7)

+
exists common fixpoint means bounds x
, xi , found
+

1 . . . n, satisfying li xi xi ui and, k 1 . . . m:

ak x
ik bk xjk ck

+
ak x +
ik bk xjk ck

(8)

(These simply constraints Eq. 6 variable xik (left) xjk (right),
rewritten taking account > 0, b > 0.)
666

fiThe Complexity Integer Bound Propagation

prove two directions iff:
Consider integer solution Q variable xi takes value vi . easy
+

+
verify bounds x
= xi = vi satisfy li xi xi ui Eq. 8.
+
Consider bound consistent state described bounds x
, xi . easy verify
solution v defined vi = x+
, 1 . . . n satisfies li vi ui Eq. 7.

means reduce problem monotone TVPI feasibility existence
fixpoint, Decision Problem 1 therefore NP-hard. 2
Note NP-hardness result Decision Problem 1 holds even (monotone)
TVPI constraints, pseudo-polynomial upper bound Section 2.4 holds general
linear constraints unbounded sizes; said earlier membership NP valid
general linear constraints.
3.3 Comment Linear Equalities
beginning section focused linear inequalities reasons
become clear sub-section. Readers may wonder whether considering equalities
would make difference. short answer no.
P
first observation inequality i1...n ai xi c directly encoded
P
P
equality i1...n ai xi = c new variable ranging [0, u] u > ai xi+si ,
bijection solutions two constraints. Therefore problem
propagating inequalities reduces problem propagating equalities, NPcompleteness result still holds problems whose linear constraints equalities (or
mix equalities / inequalities).
second observation following: focus bound(R) consistency,
P
propagation obtained equality i1...n ai xi = c one obtained using
P
P
two constraints i1...n ai xi c i1...n ai xi c. reason convenient
assume constraints homogeneous form, restrict linear
inequalities4 .
3.4 Tractable Classes Linear Constraints
Intractable problems often become tractable additional restrictions imposed
topology constraint graph, constraints themselves. subsection
identify one significant class linear constraints propagated strongly
polynomial time, based restriction coefficients constraints.
initial observation one source complexity propagators Li,k Eq.
5 use rounding: update variables bounds, obtain
variables real value rounded upwards lower bounds downwards upper
bounds. effects rounding noticed previous authors used optimize
4. Note case inequalities propagators bound(Z) consistency
bound(R) consistency. Since want propagators polynomial-time computable, case want
avoid however bound(Z) consistency linear equalities, cannot define polynomial-time
computable propagators unless P=NP.

667

fiBordeaux, Katsirelos, Narodytska, & Vardi

propagation (Harvey & Stuckey, 2003). Rounding effectively means propagation stabilizes integral solutions Linear Programs. Linear Programs question
specific form, intractability due integrality. Therefore sub-section
(1) observe remove rounding, problem becomes tractable; (2) use
observation show coefficients unit (i.e., belong {1, 0, +1}),
effectively rounding, means tractability result holds.
3.4.1 Linear Propagators without Rounding
consider operators similar Eq. 5 without rounding, words
associate linear constraints following operators:
ai,k > 0 x
:=




Si,k :
ai,k < 0

x+


:=

q

i,k
max x
, ai,k

min



qi,k
x+
, ai,k



(9)



Even initial bounds integers assumed throughout paper,
operators general reduce bounds real-values. Note propagators
effectively used deal variables real-valued domain, indeed used
Constraint Programming community (Behamou & Granvilliers, 2006)
Operations Research community, different terminology used (Feasibility-Based
Bounds Tightening, see e.g. Belotti, Cafieri, Lee & Liberti, 2010).
decision problem focus whether exist real-valued bounds
fixpoint. note problem tractable; similar result reported
independently work Belotti, Cafieri, Lee, Liberti (2010).
Decision Problem 2 (Fixpoint Continuous Linear Propagators)
INPUT: CSP whose set constraints C linear inequalities.
QUESTION: set real-valued propagators F = {Si,k : 1..n, k 1..m} associated C common fixpoint?
Observation 2 Decision problem 2 decided Linear Programming.
easy see fixpoints operators Si,k exactly real-valued solutions
system linear constraints Eq. 6. Note careful statement
Observation 2: whether Linear Programming strongly polynomial fact longstanding open question (Smale, 1998). best polynomial-time LP algorithms are,
encouragingly, time complexity O((n, m, b)) polynomial , b
number bits number encodingthis looks strongly polynomial (Khachian, 1979).
catch: complexity counted number operations, operations
rationals principle expand size numbers (repeated multiplications
blow-up representation exponentially). However, practical purposes, typical LP
implementations prevent blow-up number representation limiting precision
b bits throughout execution; solvability Linear Programming widely regarded
synonymous strong tractability, provably sub-exponential LP algorithms exist
(Matousek, Sharir, & Welzl, 1996). words, Observation 2 really read
carefully phrased way say Problem 2 efficiently solvable practice.
668

fiThe Complexity Integer Bound Propagation

3.4.2 Linear Constraints Unit Coefficients
unit linear constraint usual form i1...n ai,k xi ck additional
restriction coefficient ai,k chosen {1, 0, +1}. introductory example
slow convergence (Eq. 1) (particularly simple) example unit linear constraints,
slow convergence could particular case avoided. Note considering
linear unit constraints number variables. special case unit constraints
widely studied class unit-TVPI constraints (i.e., unit TVPI).
perhaps important class linear constraints whose integer feasibility
solved strongly polynomial time, see instance work Jaffar et al. (1994).
P

Proposition 2 constraints unit coefficients, Decision Problem 1
decided Linear Programming.
Proof. LP is, course, form given Eq. 6. observation is, short,
rounding needed coefficients unit.

precisely, Cartesian product intervals A, let L(A) = i,k Li,k (A)

S(A) = i,k Si,k (A). show coefficients unit (as defined)
bounds initial Cartesian product integral, Lt (D) = (D),
0. first note bounds Lt (D) integral since original
state integral bounds operator L applies rounding. equality
Lt (D) = (D) proved induction t. = 0, Lt (D) = (D) = D.
induction hypothesis holds step t, t+1 (D) = S(S (D)) = S(Lt (D)).
t+1 (D) = L(Lt (D)) = Lt+1 (D) Lt (D) integral bounds, hence applying L
Cartesian product gives result. (In Eq. 5 qi,k integral case
ai,k unit therefore division qi,k /ai,k gives integer, means
propagators Li,k rounding return result non-rounded propagators Si,k
Eq. 9.)
Lt (D) = (D), 0 easy see gfp{Li,k } = gfp{Si,k }.
domains finite Lt (D) stabilizes finite t. particular t, Lt (D)
greatest fixpoint L greatest Cartesian product (D) greatest
fixpoint S. 2
Note general Linear Programming necessarily find integer solutions
system Eq. 6; result shows LP find solution iff integer one
+
exists. want actually compute largest consistent bounds x
xi certain

+
variable xi , simply minimize xi maximize xi constraints Eq. 6.
previous proof shows extremal values integral.
3.4.3 Tractable Cases?
interesting consider whether properties make propagation solvable
strongly polynomial time. respect restrictions constraint graph,
nevertheless reasons pessimistic: note feasibility monotone TVPI Integer
Programming remains NP-complete strict restrictions constraint graph,
shown work Hochbaum Naor (1994). suggests restrictions
unlikely lead interesting tractable classes fixpoint computation.
669

fiBordeaux, Katsirelos, Narodytska, & Vardi

Regarding restrictions coefficients, note general NP-completeness
(monotone) TVPI constraints assumes coefficients ak , bk , ck arbitrary.
Unit restriction imposes, contrary, strongest restriction coefficients:
absolute value 1. impose general bound absolute values
one may wonder whether problem exhibits form fixed-parameter tractability.
leave question open future work.

4. Generalizations Non-Linear Constraints
Proposition 1, fixpoint computation numerical constraints basic common
linear constraints intractable. Several cases non-linear constraints nevertheless interest. First, show simplest possible type polynomials (a single
squaring operation) added linear constraints, general hardness result
strengthened. Second, interesting note enrich unit linear constraints
simple min max constraints, fixpoint computation equivalent puzzling open
problem discussed recently theorem-proving literature. Last, briefly comment
connections results tractability max-closed constraints.
4.1 Quadratic Constraints
purposes section sufficient enrich linear constraint language
(constraints form given Eq. 2) squaring constraints form:
xi = x2j
sufficient restrict non-negative values variables xi xj , i.e.,
0 li ui 0 lj uj . setting bound(R) consistency propagators
defined following instructions:




x
:= max(xi , xj

x
j

:=

max(x
j ,

2

q

x




)

+
+
x+
:= min(xi , xj



x+
j

)

:=

min(x+
j ,

q

2

x+


)



)

words fixpoints integer solutions following bound consistency
inequalities:



x
xj

2

;



+
x+
xj

2

;

x
j

q

x
;

x+
j

q

x+


(10)

simple quadratic constraints added language linear constraints,
NP-completeness result strengthened: problem NP-complete even
considering bounded(!) number variables constraints; fact one TVPI constraint
one squaring constraint. due fact fixpoint computation converges
state encodes complex number-theoretic problem.
Proposition 3 Given CSP 3 variables 2 constraints a1 x1 + a2 x2 = c, x1 = x23 ,
determining whether associated bound(R) consistency propagators fixpoint
NP-complete.
670

fiThe Complexity Integer Bound Propagation

Proof. Membership NP straightforward. show hardness result special
case ai 0, {1, 2, 3} focus, said, positive intervals. first note
bound consistency inequalities (Eq. 10) squaring constraint x1 = x23
2
+
+ 2
satisfied iff x
1 = (x3 ) x1 = (x3 ) since focus integer bounds. (This property
squaring propagator noticed slightly different form Schulte & Stuckey, 2005).
propagation viewpoint equality a1 x1 + a2 x2 = c seen two inequalities
a1 x1 + a2 x2 c a1 x1 a2 x2 c whose bound consistent inequalities (Eq. 4)

+
+
effectively satisfied iff a1 x
1 + a2 x2 = c a1 x1 + a2 x2 = c.
rely theorem (Manders & Adleman, 1978) shows deciding whether
equation form a1 x23 + a2 x2 = c integer solutions, a1 , a2 c
non-negative integers, NP-complete. reduce problem existence bound
consistent bounds conjunction a1 x1 + a2 x2 = c, x1 = x23 initial bounds l1 = l2 =
l3 = 0 u1 = u2 = u3 = c. need show fixpoint computation complete
systema bound consistent state found iff original equation solution:
original equation solution, i.e., pair non-negative integer values

+
+
2
hv2 , v3 satisfying a1 v32 + a2 v2 = c, define x
1 = x1 = v3 , x2 = x2 = v2 ,

+

+
x3 = x3 = v3 . bounds 0 xi xi c satisfy bound
consistency conditions Eq. 10 Eq. 4.

2

+
conjunction bound consistent state, i.e., bounds x
, xi Eq. 10

Eq. 4 satisfied, solution v defined v2 = x+
2 v3 = x3 satisfies
2
original equation a1 v3 + a2 v2 = c.

4.2 Connections Max-Atom Problem
Another common type primitive non-linear constraints form:
xh = max(xi , xj )
bound(R) consistency propagators constraint following (Schulte &
Stuckey, 2005):
+ +
x+
:= min(xi , xh )


x
h := max(xh , xi , xj )

+ +
+
+ +
+
x+
h := min(xh , max(xi , xj )) xj := min(xj , xh )

(In fact strictly reach bound(R) consistency one would need additionally check
whether bounds xh empty intersection bounds one max-ed
variables, say xi , case essentially impose constraint xj = xh ;
purposes section simpler formulation equivalent.) words
fixpoints characterized following inequalities:
+ +
x+
h max(xi , xj )

+
x+
xh

+
x+
j xh


x
h xi


x
h xj

fixpoint computation max constraints mixed unit linear constraints interesting
complexity open problem. Note rounding use
671

fiBordeaux, Katsirelos, Narodytska, & Vardi

coefficients definition bound consistency inequalities, therefore complexity
arising rounding NP-complete variants propagation arise here.
open problem connect called Max-Atom work Bezem, Nieuwenhuis,
Rodrguez-Carbonell (2008); see reference prior problems interest
shown equivalent Max-Atom. max-atom constraint form: max(xi , xj )+c xh .
work reported Bezem et al. (2008) shows number results feasibility
conjunctions max-atom constraints: (1) significant complexity difference
integer real feasibility; (2) problem decided pseudo-polynomial
time using amounts fixpoint computation algorithm; (3) problem short
proofs unsatisfiability therefore NPcoNP; means
different nature NP-complete variants. fact, recent result (Atserias &
Maneva, 2010) shows complexity Max-Atom equivalent well-known open
problems called mean-payoff games, turn connections important open
questions model-checking: parity games, class games reducible mean-payoff games,
equivalent model-checking problem -calculus (Emerson, Jutla, & Sistla, 1993;
Jurdzinski, 1998).
draw simple connection follows observation bound
+ +
consistency inequalities upper bounds include constraint x+
h max(xi , xj )
encode max-atom constraints almost directly.
Proposition 4 Bound(R) consistency combination unit linear max constraints
solved polynomial time Max-Atom solved polynomial time.
Proof. reduce Max-Atom instance variables xi , 1 . . . n constraints
fixpoint computation problem simply introduce one fresh variable yk , k 1 . . . m.
Let kth constraint form max(xik , xjk ) + ck xhk , rewrites conjunction
max(xik , xjk ) = yk , yk + ck xhk . lower bounds variables fixed 0
P
upper bounds need set k1...m ck small model property (Lemma 2)
paper Bezem et al. (2008). bound consistency equations upper bounds directly
encode problem. 2

4.3 Max-Closed Constraints
last note connection results class max-closed constraints
introduced Jeavons Cooper (1995) (more in, e.g., Petke & Jeavons, 2009).
constraint R(x1 , . . . , xn ) max-closed whenever two solutions hv1 . . . vn
hw1 . . . wn i, maximum defined hmax(v1 , w1 ), . . . , max(vn , wn )i solution.
Results Jeavons Cooper (1995) show max-closed constraints tractable:
system constraints max-closed, feasibility determined polynomial
time. However note result essentially assumes explicit (or table) representation
constraint, i.e., assumed constraint defined explicitly listing
tuples solutions it. contrast important types constraints
numerical constraints considered paper implicitly defined: know
list solutions R(x1 , . . . , xn ) verify efficiently whether particular tuple
accepted constraint.
672

fiThe Complexity Integer Bound Propagation

Implicitly-defined max-closed constraints played important role paper:
monotone TVPI constraints, considered Section 3.2 Max-atom constraints
considered Section 4.2, max-closed, shown respectively Hochbaum Naor
(1994), Bezem et al. (2008). sharp contrast case explicitly-defined constraints, resolution implicitly-defined max-closed constraints therefore pseudopolynomial fact intractable, shown special case monotone TVPI
constraints:
Observation 3 feasibility implicitly-defined max-closed constraints NP-complete.
shown Section 3.2 particular example monotone TVPI constraints,
even fixpoint computation implicitly defined max-closed constraints is, fact, NPcomplete general.

5. Conclusion
Reasoning intervals introduced AI literature works Cleary (1987),
Davis (1987)5 . substantial body AI work ensued (see, e.g. Hyvonen, 1992);
bound computation used finite-domain CP solvers (Schulte & Carlsson,
2006).
paper theoretically investigated complexity computing common
fixpoint set bound consistency propagators. shown even
propagators simple, fixpoint computation used algorithms
complex, indeed NP-complete even restricted constraint class linear
monotone inequalities two variables per inequality. considered special
classes constraints, quadratic constraints max constraints. Finally, identified
class constraints, namely, linear inequalities unit coefficients, allows tractable
fixpoint computation algorithm.
Bound propagation successful widely used technique Constraint Programing.
large literature propagating single constraints (Van Hoeve & Katriel, 2006;
Bessiere, 2006; Rossi, van Beek, & Walsh, 2006) perhaps surprise prior
study exists complexity fixpoint computation. NP-completeness fixpoint
computation simple types constraints fundamental somewhat surprising
result, one sheds light slow convergence phenomena.
result puts bound propagation map AI computational problems:
together knapsack constraints forms learning neural nets (Schaeffer &
Yannakakis, 1991), one important AI problems aware
pseudo-polynomial complexity yet intractable.
Acknowledgments
Preliminary results Bordeaux, Hamadi, Vardi (2007) showed NP-completeness
propagation case quadratic constraints considered (Prop. 3).
5. often, good case made similar ideas already present earlier work, particular
work Lauriere (1978). Interval computations course used areas fixpoint
computation methods consider relate broader theme interval arithmetic pioneered Moore
(1966).

673

fiBordeaux, Katsirelos, Narodytska, & Vardi

paper thoroughly revised version whose central result linear constraints new
general. Part work done G. Katsirelos, N. Narodytska
M. Vardi visiting Microsoft Research, Cambridge. Part work done
G. Katsirelos employed NICTA, Australia. NICTA funded Australian
Governments Department Broadband, Communications, Digital Economy
Australian Research Council. work partially supported ANR UNLOC
project: ANR 08-BLAN-0289-01. Discussions Youssef Hamadi Claude-Guy Quimper gratefully acknowledged. Thanks anonymous reviewers whose feedback
helped improve paper.

References
Apt, K. R. (1999). essence constraint propagation. Theoretical Computer Science
(TCS), 221 (1-2), 179210.
Apt, K. R., & Zoeteweij, P. (2007). analysis arithmetic constraints integer intervals.
Constraints, 12 (4), 429468.
Aspvall, B., & Shiloach, Y. (1980). polynomial time algorithm solving systems
linear inequalities two variables per inequality. SIAM J. Computing, 9 (4),
827845.
Atserias, A., & Maneva, E. (2010). Mean-payoff games max-atom problem. Tech.
rep., Universitat Politecnica de Catalunya.
Bar-Yehuda, R., & Rawitz, D. (2001). Efficient algorithms integer programs two
variables per constraint. Algorithmica, 29 (4), 595609.
Behamou, F., & Granvilliers, L. (2006). Continuous interval constraints. Rossi, F.,
van Beek, P., & Walsh, T. (Eds.), Handbook Constraint Programming, chap. 16.
Elsevier.
Belotti, P., Cafieri, S., Lee, J., & Liberti, L. (2010). Feasibility-based bounds tightening via
fixed points. Proc. Int. Conf. Combinatorial Optimization Applications
(COCOA), p. Appear.
Benhamou, F. (1996). Heterogeneous constraint solving. Proc. Int. Conf. Algebraic
Logic Programming (ALP), pp. 6276.
Bessiere, C. (2006). Constraint propagation. Rossi, F., van Beek, P., & Walsh, T. (Eds.),
Handbook Constraint Programming, chap. 3. Elsevier.
Bezem, M., Nieuwenhuis, R., & Rodrguez-Carbonell, E. (2008). max-atom problem
relevance. Proc. Int. Conf. Logic Programming, Artificial Intelligence Reasoning (LPAR), pp. 4761.
Bordeaux, L., Hamadi, Y., & Vardi, M. Y. (2007). analysis slow convergence
interval propagation. Proc. Int. Conf. Principles Practice Constraint
Programming (CP), pp. 790797.
674

fiThe Complexity Integer Bound Propagation

Choi, C. W., Harvey, W., Lee, J. H. M., & Stuckey, P. J. (2006). Finite domain bounds
consistency revisited. Australian Conf. Artificial Intelligence, pp. 4958.
Cleary, J. G. (1987). Logical arithmetic. Future Computing Systems, 2 (2), 125149.
Davis, E. (1987). Constraint propagation interval labels. Artificial Intelligence, 32 (3),
281331.
Emerson, E. A., Jutla, C. S., & Sistla, A. P. (1993). model-checking fragments
-calculus. Proc. Int. Conf. Computer-Aided Verification (CAV), pp. 385396.
Harvey, W., & Schimpf, J. (2002). Bound consistency techniques long linear constraints.
Proc. CP workshop Techniques Implementing Constraint Propgramming
Systems (TRICS).
Harvey, W., & Stuckey, P. J. (2003). Improving linear constraint propagation changing
constraint representation. Constraints, 8 (2), 173207.
Hochbaum, D. S., & Naor, J. (1994). Simple fast algorithms linear integer
programs two variables per inequality. SIAM J. Computing, 23 (6), 1179
1192.
Hyvonen, E. (1992). Constraint reasoning based interval arithmetic: tolerance
propagation approach. Artificial Intelligence, 58 (1-3), 71112.
Jaffar, J., Maher, M. J., Stuckey, P. J., & Yap, R. H. C. (1994). Beyond finite domains.
Proc. Int. Workshop Principles Practice Constraint Programming
(PPCP), pp. 8694.
Jeavons, P., & Cooper, M. C. (1995). Tractable constraints ordered domains. Artificial
Intelligence, 79 (2), 327339.
Jurdzinski, M. (1998). Deciding winner parity games co-UP. Inf. Process.
Lett., 68 (3), 119124.
Katriel, I., Sellmann, M., Upfal, E., & Van Hentenryck, P. (2007). Propagating knapsack
constraints sublinear time. Proc. (North Amer.) Nat. Conf. Artificial
Intelligence (AAAI), pp. 231236.
Khachian, L. (1979). polynomial algorithm linear programming. Doklady Akad. USSR,
244, 10931096.
Lagarias, J. C. (1985). computational complexity simultaneous diophantine approximation problems. SIAM J. Computing, 14 (1), 196209.
Lauriere, J.-L. (1978). language program stating solving combinatorial
problems. Artificial Intelligence, 10 (1), 29127.
Lebbah, Y., & Lhomme, O. (2002). Accelerating filtering techniques numeric CSPs.
Artificial Intelligence, 139 (1), 109132.
675

fiBordeaux, Katsirelos, Narodytska, & Vardi

Leconte, M., & Berstel, B. (2006). Extending CP solver congruences domains
program verification. CP Workshop Software Testing, Verification Analysis,
pp. 2233.
Lhomme, O. (1993). Consistency techniques numeric CSPs. Proc. Int. Joint. Conf.
Artificial Intelligence (IJCAI), pp. 232238.
Lhomme, O., Gottlieb, A., Rueher, M., & Taillibert, P. (1996). Boosting interval
narrowing algorithm. Proc.of Joint Int. Conf. Symp. Logic Programming
(JICSLP), pp. 378392. MIT Press.
Manders, K. L., & Adleman, L. M. (1978). NP-complete decision problems binary
quadratics. J. Computer System Sciences, 16 (2), 168184.
Matousek, J., Sharir, M., & Welzl, E. (1996). subexponential bound linear programming. Algorithmica, 16 (4/5), 498516.
Moore, R. E. (1966). Interval Analysis. Prentice-Hall.
Papadimitiou, C. (1994). Computational Complexity. Addison Wesley.
Petke, J., & Jeavons, P. (2009). Tractable benchmarks constraint programming. Tech.
rep. CS-RR-09-07, Oxford University Computing Laboratory.
Rossi, F., van Beek, P., & Walsh, T. (2006). Handbook Constraint Programming. Elsevier.
Schaeffer, A. A., & Yannakakis, M. (1991). Simple local search problems hard
solve. SIAM J. Computing, 20 (1), 5687.
Schulte, C., & Carlsson, M. (2006). Finite domain constraint programming. Rossi, F.,
van Beek, P., & Walsh, T. (Eds.), Handbook Constraint Programming, chap. 14.
Elsevier.
Schulte, C., & Stuckey, P. J. (2005). bounds domain propagation lead
search space?. ACM Trans. Programming Languages Systems
(TOPLAS), 27 (3), 388425.
Smale, S. (1998). Mathematical problems next century. Mathematical Intelligencer,
20, 715.
Trick, M. A. (2001). dynamic programming approach consistency propagation
knapsack constraints. Proc. Int. Conf. Integration AI Techniques
CP Combinatorial Optimisation Problems (CP-AI-OR).
Van Hoeve, W.-J., & Katriel, I. (2006). Global constraints. Rossi, F., Van Beek, P., &
Walsh, T. (Eds.), Handbook Constraint Programming, chap. 6. Elsevier.
Yuanlin, Z., & Yap, R. H. C. (2000). Arc consistency n-ary monotonic linear constraints. Proc. Int. Conf. Principles Practice Constraint Programming
(CP), pp. 470483.

676


