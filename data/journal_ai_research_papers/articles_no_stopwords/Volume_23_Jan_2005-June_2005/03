journal artificial intelligence

submitted published

improved search
optimal multiple sequence alignment
stefan schroedl

stefan schroedl gmx de

th st
san francisco ca


abstract
multiple sequence alignment msa ubiquitous computational biology
although np hard optimal solution arbitrary number sequences
due importance researchers trying push limits exact
since msa cast classical path finding attracting growing number ai researchers interested heuristic search
challenge actual practical relevance
first review two previous complementary lines
hirschbergs dynamic programming needs kn k space store
search frontier nodes needed reconstruct solution path k sequences
length n best first search hand advantage bounding search
space explored heuristic however necessary maintain
explored nodes final solution order prevent search expanding
higher cost earlier approaches reduce closed list incompatible
pruning methods open list must retain least boundary closed
list
article present attempts combining respective
advantages uses heuristic pruning search space reduces
maximum open closed size kn k dynamic programming
underlying idea conduct series searches successively increasing upper bounds
dp ordering key open priority queue suitable choice
thresholds practice running time four times expected
experiments outperforms one currently
successful optimal multiple sequence alignments partial expansion
time memory moreover apply refined heuristic optimal alignments
pairs sequences larger subsets idea however
make practically relevant equally important bound heuristic
computation appropriately overhead obliterate possible gain
furthermore discuss number improvements time space efficiency
regard practical implementations
used conjunction higher dimensional heuristics able calculate first time optimal alignment almost reference
benchmark database balibase

introduction multiple sequence alignment
multiple sequence alignment msa computational biology consists aligning several sequences e g related genes different organisms order reveal simic

ai access foundation rights reserved

fischroedl

larities differences across group dna directly compared
underlying alphabet consists set c g four standard nucleotide bases
cytosine guanine adenine thymine compare proteins case
comprises twenty amino acids
roughly speaking try write sequences one
columns matching letters maximized thereby gaps denoted additional
letter may inserted order shift remaining characters
better corresponding positions different letters column interpreted
caused point mutations course evolution substituted one amino
acid another one gaps seen insertions deletions since direction
change often known collectively referred indels presumably
alignment fewest mismatches indels constitutes biologically plausible
explanation
host applications msa within computational biology e g determining evolutionary relationship species detecting functionally active sites
tend preserved best across homologous sequences predicting threedimensional protein structure
formally one associates cost alignment tries mathematically
optimal alignment e one minimum cost designing cost function
computational efficiency biological meaning taken account
widely used definition sum pairs cost function first given symmetric
matrix containing penalties scores substituting letter another one
gap simplest case could one mismatch zero match
biologically relevant scores developed dayhoff schwartz orcutt
proposed model molecular evolution estimate exchange
probabilities amino acids different amounts evolutionary divergence gives rise
called pam matrices pam generally widely used jones
taylor thornton refined statistics larger body experimental
data substitution matrix sum pairs cost alignment defined
sum penalties letter pairs corresponding column positions
pairwise alignment conveniently depicted path two opposite
corners two dimensional grid needleman wunsch one sequence placed
horizontal axis left right one vertical axis top
bottom gap string path moves diagonally right gap
vertical horizontal string represented horizontal vertical move right
since letter consumed one strings alignment graph directed
acyclic non border vertex incoming edges left top top left
adjacent vertices outgoing edges right bottom bottom right vertices
pairwise alignment readily generalized simultaneous alignment multiple
sequences considering higher dimensional lattices example alignment three
sequences visualized path cube fig illustrates example strings
abcb bcd db shows computation sum pairs cost hypothetical
substitution matrix real example trx balibase see sec given
fig


fian improved search optimal multiple sequence alignment

alignment

substitution matrix

b c b
b c
b

b c

b

c






cost

end



c

b

b



b



c

b

start

figure fictitious alignment column representation cost matrix threedimensional visualization alignment path cube

number improvements integrated sum pairs cost associating
weights sequences different substitution matrices sequences varying
evolutionary distance major issue multiple sequence alignment
ability handle gaps gap penalties made dependent neighbor letters
moreover found altschul assigning fixed score indel
sometimes produce biologically plausible alignment since insertion
sequence x letters likely x separate insertions single letter gap cost
functions introduced depend length gap useful approximation
affine gap costs distinguish opening extension gap charge
b x gap length x appropriate b another frequently used modification
waive penalties gaps beginning end sequence
technically order deal affine gap costs longer identify nodes
search graph lattice vertices since cost associated edge depends
preceding edge path therefore suitable store lattice edges priority


fischroedl

thx
grx
erv
trcp

aeqpvlvyfwaswcgpcqlmsplinlaantysdrlkvvkleidpnpttvkkyk vegvpal
mqtvi fgrsgcpysvrakdlaeklsnerdd fqyqyvdiraegitkedlqqkagkpvetvp
agdklvvvdfsatwcgpckmikpffhslsekysn viflevdvddcqdvasece vksmptf
kvttivvniyedgvrgcdalnssleclaaeypm vkfckira sntgagdrfs sdvlptl

thx
grx
erv
trcp

rlvkgeqildstegvis kdkllsf ldthln
qifvdqqhiggytdfaawvken lda
qffkkgqkvgefsgan kek leatine lv
lvykggelisnfisvaeqfaedffaadvesflneygllper

figure alignment trx balibase computed settings
described sec



b

c




g

cost c
gap penalty
g

b


cost
gap penalty
g

cost c
gap penalty
g



figure example computing path costs affine gap function substitution matrix
fig gap opening penalty used

queue let transition costs u v v w sum pairs substitution costs
one character sequence gap plus incurred gap penalties
v w followed u v representation adopted program msa gupta
kececioglu schaeffer note state space representation grows
factor k example successor costs calculated cost matrix
fig gap opening penalty shown fig
convenience terminology sequel still refer nodes dealing
search


fian improved search optimal multiple sequence alignment

overview
wang jiang shown optimal multiple sequence alignment
np hard therefore cannot hope achieve efficient arbitrary number
sequences consequence alignment tools widely used practice sacrifice
sound theoretical basis exact heuristic nature chan wong
chiu wide variety techniques developed progressive methods build
alignment gradually starting closest sequences successively adding
distant ones iterative strategies refine initial alignment sequence
improvement steps
despite limitation moderate number sequences however
exact still going trying push practical boundaries still
form building block heuristic techniques incorporating existing tools
could improve example iteratively aligning two groups sequences
time could three better avoid local minima moreover
theoretically important gold standard available evaluation comparison
even
since msa cast minimum cost path finding turns
amenable heuristic search developed ai community actually
among currently best approaches therefore many researchers area
often used puzzles games past study heuristic search recently
rising interest msa testbed practical relevance e g korf
korf zhang yoshizumi miura ishida zhou hansen b study
led major improvements general search techniques
pointed definition msa given
one competes attempts formalizing biological meaning often
imprecise depends type question biologist investigator pursuing e g
concerned global alignment methods alignment
entire sequences local methods contrast geared towards finding maximally similar
partial sequences possibly ignoring remainder
next section briefly review previous approaches dynamic programming incorporating lower upper bounds sec describe
combines extends ideas allows reduce storage closed
nodes partially recomputing solution path end sec moreover turns
iterative deepening strategy transferred good balance
computation improved heuristics main search sec issue
previously major obstacle practical application sec presents
experimental comparison partial expansion yoshizumi miura ishida
one currently successful approaches solve two
reference widely used benchmark database balibase thompson plewniak
poch best knowledge achieved previously
exact


fischroedl

previous work
number exact developed previously compute alignments
moderate number sequences mostly constrained available
memory required computation time roughly
group two categories dynamic programming paradigm
proceed primarily breadth first fashion best first search utilizing lower upper
bounds prune search space recent including
introduced sec attempts beneficially combine approaches
dijkstras dynamic programming
dijkstra presented general finding shortest resp minimum cost
path directed graph uses priority queue heap store nodes v together
shortest found distance start node e top left corner grid v
called g value v starting priority queue step
edge minimum g value removed priority queue expansion consists
generating successors vertices right reachable one step
computing respective g value adding edge cost previous g value
inserting turn priority queue case newly found distance smaller
previous g value time node expanded g value guaranteed
minimal path cost start node g v v procedure runs
priority queue becomes empty target node bottom right corner grid
reached g value constitutes optimal solution cost g
alignment order trace back path corresponding cost move
backwards start node choosing predecessors minimum cost nodes
stored fixed matrix structure corresponding grid dynamically
generated latter case explicitly store node backtrack pointer
optimal parent
integer edge costs priority queue implemented bucket array pointing
doubly linked lists dial operations performed constant time
precise deletemin operation needs pointer runs different
g values however neglect comparison number expansions
expand vertex k successor vertices generated since
choice introducing gap sequence thus dijkstras solve
multiple sequence alignment k n k time n k space k sequences
length n
means reduce number nodes stored path reconstruction
associating counter node maintains number children whose
backtrack pointer refers gupta et al since node expanded
number referring backtrack pointers decrease namely
whenever cheaper path one children found nodes reference count goes
zero whether immediately expansion later loses child
deleted good way keep nodes memory least one
descendant currently priority queue moreover auxiliary data structures vertices


fian improved search optimal multiple sequence alignment

coordinates efficiently stored tries prefix trees equipped
reference counters well freed accordingly longer used edge
complexity dijkstras holds dynamic programming dp
differs former one scans nodes fixed order known
beforehand hence contrary name exploration scheme actually static
exact order scan vary e g row wise column wise long compatible
topological ordering graph e g two sequences cells left top
diagonally top left explored prior cell one particular ordering
antidiagonals diagonals running upper right lower left calculation
antidiagonal node merely amounts summing k coordinates
hirschberg noticed order determine cost optimal alignment g would necessary store whole matrix instead proceeding
e g rows suffices keep track k time deleting row soon
next one completed reduces space requirement one dimension
n k kn k order recover solution path end computation
lost cell values needed divide conquer strategy applies twice
half grid forward backward direction meeting fixed
middle row adding corresponding forward backward distances middle
row finding minimum one cell lying optimal path recovered
cell essentially splits two smaller subproblems one upper left
corner one lower right corner recursively solved
method two dimensions computation time doubled
overhead reduces even higher dimensions
fastlsa davidson refines hirschbergs exploiting additionally available memory store one node optimal path
thereby reducing number computations
utilizing bounds
dijkstras dynamic programming viewed variants breadthfirst search achieve best first search expand nodes v order estimate
lower bound total cost path passing v rather
g value dijkstras use f v g v h v heap key
h v lower bound cost optimal path v h indeed admissible
first solution found guaranteed optimal hart nilsson raphael
classical best first search well known artificial
intelligence community context priority queue maintaining generated nodes
often called open list nodes already expanded
removed constitute closed list fig schematically depicts snapshot
two dimensional alignment nodes f value larger current
fmin expanded since accuracy heuristic decreases distance
goal typical onion shaped distribution bulk located closer
start node tapering towards higher levels
significantly reduce total number expanded generated
nodes therefore higher dimensions clearly superior dynamic programming

fischroedl



ax
um


ia


er
et

closed
open
possible back leak

le

ls


n

tid

ia
go

na
ls

x

start
x x
x
x
x
x

x
x
x
x
x
end

figure snapshot best first search pairwise alignment schematically

ever contrast hirschberg still stores explored nodes
closed list apart keeping track solution path necessary prevent
search leaking back following sense
heuristic h called consistent h x h x c x x node x child x
consistent heuristic ensures case dijkstras time node
expanded g value optimal hence never expanded however try
delete closed nodes topologically smaller nodes open
higher f value expanded later stage lead generation
node non optimal g value since first instantiation longer available
duplicate checking fig nodes might subject spurious expansion
marked x
researchers tried avoid leaks retaining basic search scheme
korf proposed store list forbidden operators node place parents
deleted node open f value infinity korf korf zhang however
zhou hansen remark hard combine techniques
reduction open list moreover storage operators lets size
nodes grow exponentially number sequences keep
track kernel closed list defined set nodes
closed nodes parents otherwise closed node said boundary key
idea boundary nodes maintained since shield kernel
expansions gets close memory limit nodes
kernel deleted backtrack pointer children changed parents


fian improved search optimal multiple sequence alignment

deleted nodes become relay nodes final reconstruction
optimal solution path called recursively relay node bridge
gap missing edges
addition closed list open list grow rapidly sequence alignment
particularly since original expansion node generates
children whose f value larger optimal cost g kept
heap end waste much available space
upper bound u optimal solution cost g known nodes v
f v u pruned right away idea used several articles spouge gupta
et al one successful approaches yoshizumi et al partial
expansion pea node stores additional value f minimum
f value yet ungenerated children step node minimum
f value expanded children f f generated
clearly generates nodes f value larger optimal cost cannot
avoided altogether however overhead computation time considerable
straightforward implementation want maintain nodes constant size generating
one edge requires determining f values successors interior node
eventually fully expanded computation time order square
number successors grows k number sequences k
remedy proposed relax condition generating children
f f c small c
alternative general search strategy uses linear space iterative
deepening ida korf basic conducts depth first search
pre determined threshold f value search keeps track smallest
f value generated successor larger threshold solution found
provides increased threshold used next search iteration
wah shang suggested liberal schemes determining next threshold dynamically order minimize number recomputations ida efficient
tree structured search spaces however difficult detect duplicate expansions without additional memory therefore unfortunately applicable lattice structured
graphs sequence alignment due combinatorially explosive number
paths two given nodes
different line tries restrict search space breadth first approaches incorporating bounds ukkonen presented pairwise
alignment particularly efficient similar sequences computation time
scales dm optimal solution cost first consider deciding
whether solution exists whose cost less upper threshold u restrict
evaluation dp matrix band diagonals minimum number
indels required reach diagonal times minimum indel cost exceed u
general starting minimum u value successively double g test
returns solution increase computation time due recomputations
bounded factor
another multiple sequence alignment make use lower bounds h
key idea following since nodes f value lower g
expanded anyway order guarantee optimality might well explore


fischroedl

reasonable order dijkstras dp knew optimal
cost even slightly higher upper bounds still help pruning spouge proposed
bound dp vertices v g v h v smaller upper bound g
linear bounded diagonal alignment lbd align davidson uses upper
bound order reduce computation time memory solving pairwise alignment
dynamic programming calculates dp matrix one antidiagonal time starting top left corner working towards bottom right
would check bound every expansion lbd align checks
top bottom cell diagonal e g top cell diagonal pruned
remaining cells row pruned well since reachable
means pruning frontier next row shifted one thus
pruning overhead reduced quadratic linear amount terms
sequence length
obtaining heuristic bounds
assumed lower upper bounds without specifying derive
obtaining inaccurate upper bound g fairly easy since use cost
valid path lattice better estimates e g available heuristic linear time
alignment programs fasta blast altschul gish miller myers lipman
standard method database searches davidson employed
local beam search scheme
gusfield proposed approximation called star alignment
sequences aligned one consensus sequence chosen sum pairwise
alignment costs rest sequences minimal best sequence
center ones aligned gap gap rule gusfield
showed cost optimal alignment greater equal cost star
alignment divided k
use heuristic estimates lower bounds k alignment often
optimal alignments subsets k sequences general vertex v k space
looking lower bound path v target corner consider first
case cost path definition sum edge costs
edge cost turn sum pairwise replacement gap penalties multiple
sequence alignment induces pairwise alignment sequences j simply copying
rows j ignoring columns rows pairwise alignments
visualized projection alignment onto faces cf fig
interchange summation order sum pairs cost sum pairwise
alignment costs respective paths projected face cannot smaller
optimal pairwise path cost thus construct admissible heuristic hpair
computing pairwise alignment cell pairwise
cheapest path cost goal node
optimal solutions pairwise alignment needed lower bound h
values usually computed prior main search preprocessing step ikeda imai
end suffices apply ordinary dp procedure however since time
interested lowest cost path v runs backward direction


fian improved search optimal multiple sequence alignment

proceeding lower right corner upper left expanding possible parents
vertex step
let u upper bound cost optimal multiple sequence alignment g
sum optimal alignment costs lij sij tij pairwise subproblems j
k j call l lower bound g carrillo lipman pointed
additivity sum pairs cost function pairwise alignment induced
optimal multiple sequence alignment u l larger
respective optimal pairwise alignment bound used restrict number
values computed preprocessing stage stored
calculation heuristic pair sequences j nodes v feasible
path start node si j goal node ti j exists total cost
li j optimize storage requirements combine two
searches first forward pass determines relevant node v minimum distance
sij v start node subsequent backward pass uses distance exact
heuristic stores distance v tij target node nodes
sij v v tij
still larger alignment required storage size extensive
program msa gupta et al allows user adjust values carrillolipman bound individually pair sequences makes possible generate
least heuristic alignments time memory doesnt allow complete solution
moreover recorded search bound actually reached
negative case optimality found solution still guaranteed otherwise user
try run program slightly increased bounds
general idea precomputing simplified storing solutions use
heuristic explored name pattern databases culberson schaeffer
however approaches implicitly assume computational cost
amortized many search instances target contrast case msa
heuristics instance specific strike balance discuss
greater depth sec

iterative deepening dynamic programming
seen fixed search order dynamic programming several advantages pure best first selection
since closed nodes never reached search safe
delete useless ones part shortest path current open
slight technical complication arises affine gap costs recall dp implementations usually charge
gap opening penalty g value edge e starting gap edge e ending gap
carries extra penalty however since sum pairs heuristics h computed backward
direction would assign penalty path instead e
means heuristic f g h would longer guaranteed lower bound since
contains penalty twice remedy necessary make computation symmetric charging
beginning end gap half cost case beginning end
sequences handled conveniently starting search dummy diagonal edge
defining target edge dummy diagonal edge n n n
n similar arrows shown fig



fischroedl

nodes apply path compression schemes hirschberg
sophisticated schemes avoiding back leaks required abovementioned methods core set maintenance dummy node insertion open
besides size closed list memory requirement open list determined maximum number nodes open simultaneously
time running f value used key
priority queue open list usually contains nodes f values range
fmin fmin set nodes generally spread across search space
since g accordingly h f g vary arbitrarily fmin
opposed dp proceeds along levels antidiagonals rows iteration
k levels maintained time hence size
open list controlled effectively fig pairwise alignment partitioned antidiagonals maximum number open nodes two adjacent
levels four total amounts seventeen
practical purposes running time measured terms
number node expansions one take account execution time
needed expansion arranging exploration order edges
head node generally sharing common coordinate prefix
dealt one much computation cached edge
generation sped significantly come back point sec
remaining issue static exploration scheme consists adequately bounding
search space h values known minimal terms number node
expansions knew cost g cheapest solution path beforehand could
simply proceed level level grid however immediately prune generated edges
e whenever f e g would ensure generate edges would
generated well upper threshold would additionally help
reduce size closed list since node pruned children lie beyond
threshold additionally node child parent give rise
propagating chain ancestor deletions
propose apply search scheme carries series searches successively larger thresholds solution found run memory patience
use upper bound parallels ida
resulting refer iterative deepening dynamic programming iddp sketched fig outer loop initializes threshold
lower bound e g h unless solution found increases upper bound
manner ida order make sure least one additional edge explored iteration threshold increased correspondingly
least minimum cost fringe edge exceeded previous threshold
fringe increment maintained variable minnextthresh initially estimated
upper bound repeatedly decreased course following expansions
contrary figure might suggest open two nodes per level pairwise
alignments set nodes worse fmin contains holes



fian improved search optimal multiple sequence alignment

procedure iddp edge startedge edge targetedge int lowerbound int upperbound
int thresh lowerbound
outer loop iterative deepening phases
thresh upperbound
heap h startedge
int minnextthresh upperbound
inner loop bounded dynamic programming
h isempty
edge e h deletemin remove edge minimum level
e targetedge
optimal alignment found
return tracebackpath startedge targetedge
end
expand e thresh minnextthresh
end
int threshincr computethreshincr compute search threshold next iteration see text
thresh max thresh threshincr minnextthresh
end
print alignment cost upperbound found

figure iterative deepening dynamic programming
step inner loop select remove node priority queue
whose level minimal explained later sec favorable break ties according
lexicographic order target nodes since total number possible levels
comparatively small known advance priority queue implemented
array linked lists dial provides constant time operations insertion
deletion
expansion edge e partial fig child edge might already exist
earlier expansion edge head vertex test decrease
g value otherwise generate edge temporarily sake calculating f value f value exceeds search threshold current iteration
memory immediately reclaimed moreover case fringe threshold minnextthresh updated practical implementation prune unnecessary accesses
partial alignments inside calculation heuristic e geth soon search
threshold already reached
relaxation child edge within threshold performed subprocedure
updateedge cf fig similar corresponding relaxation step updating
childs g f values parent pointers inserting open already
contained however contrast best first search inserted heap according
antidiagonal level head vertex note event former parent loses
last child propagation deletions fig ensure closed nodes
continue stored belong solution path edge deletions ensue
deletion dependent vertex coordinate data structures shown pseudocode
situation gives rise deletions immediately expansion
node children pointing back children might reachable cheaply
different nodes f value might exceed threshold


fischroedl

procedure expand edge e int thresh int minnextthresh
edge child succ e
retrieve child tentatively generate yet existing set boolean variable created
accordingly
int newg e getg gapcost e child
child getcost
int newf newg child geth
newf thresh newg child getg
shorter path current best found estimate within threshold
child setg newg
updateedge e child h update search structures
else newf thresh
minnextthresh
min minnextthresh newf
record minimum pruned edges
created
delete child make sure promising edges stored
end
end
end
e ref
deleterec e promising children could inserted heap
end

figure edge expansion iddp
procedure updateedge edge parent edge child heap h
parent ref
child getbacktrack ref
child getbacktrack ref
deleterec child getbacktrack former parent lost last child becomes useless
end
child setbacktrack parent
h contains child
h insert child child gethead getlevel
end

figure edge relaxation iddp

correctness shown analogously soundness proof
threshold smaller g dp search terminate without encountering
solution otherwise nodes pruned cannot part optimal path
invariant holds node level lies optimal path
open list therefore terminates heap runs empty
best found solution indeed optimal
iterative deepening strategy overhead computation time due reexpansions trying restrict overhead much possible precisely


fian improved search optimal multiple sequence alignment

procedure deleterec edge e
e getbacktrack nil
e getbacktrack ref
e getbacktrack ref
deleterec e getbacktrack
end
end
delete e

figure recursive deletion edges longer part solution path
procedure traceback edge startedge edge e
e startedge
return end recursion
end
e getbacktrack gettarget e getsource
relay node recursive path reconstruction
iddp e getbacktrack e e getf e getf
end
outputedge e
traceback startedge e getbacktrack

figure divide conquer solution reconstruction reverse order
want minimize ratio


niddp

na

niddp na denote number expansions iddp respectively one
way wah shang choose threshold sequence
number expansions ni stage satisfies
ni rni
fixed ratio r choose r small number expansions hence
computation time grow rapidly choose big threshold
last iteration exceed optimal solution cost significantly explore many
irrelevant edges suppose n rp na n rp performs p
iterations worst case overshoot maximal finds optimal solution
previous threshold na n rp total number expansions
p
r r p
r

n p
ratio becomes approximately r
setting
r n
r
derivative expression zero optimal value r number
expansions double one search stage next achieve doubling
expand four times many nodes
wah shangs scheme dynamically adjust threshold runtime information procedure computethreshincr stores sequence expansion numbers
thresholds previous search stages uses curve fitting extrapolation
first iterations without sufficient data available small default threshold
applied found distribution nodes n f value smaller equal


fischroedl

threshold modeled accurately according exponential
n b
consequently order attempt double number expansions choose next
threshold according



log b

sparse representation solution paths
search progresses along antidiagonals fear back leaks
free prune closed nodes similarly zhou hansens work however
want delete lazily incrementally forced
approaching computers memory limit
deleting edge e backtrack pointers child edges refer
redirected respective predecessor e whose reference count increased accordingly
resulting sparse solution path representation backtrack pointers point
optimal ancestors
termination main search trace back pointers starting goal
edge outlined procedure traceback fig prints solution path
reverse order whenever edge e points back ancestor e direct
parent apply auxiliary search start edge e goal edge e order reconstruct
missing links optimal solution path search threshold fixed
known solution cost moreover auxiliary search prune edges cannot
ancestors e coordinate greater corresponding coordinate
e since shortest distance e e known stop first path
found cost improve efficiency auxiliary search even
heuristic could recomputed suit target therefore cost restoring
solution path usually marginal compared main search
edges going prune order simplicity assume
moment closed list consists single solution path according hirschberg
would keep one edge preferably lying near center search
space e g longest anti diagonal order minimize complexity two
auxiliary searches additional available space allowing store three relay edges
would divide search space four subspaces equal size e g additionally
storing antidiagonals half way middle antidiagonal start node resp
target node extension order incrementally save space diminishing
resources would first keep every level every fourth
start edge target edge one edge half way path would left
since general closed list contains multiple solution paths precisely tree
solution paths would density relay edges
case k sequences edge reaching level l head node originate
tail node level l l k thus every solution path passes
level deleting every level could leaving one path completely intact
extinguishing another totally thus better consider contiguous bands k


fian improved search optimal multiple sequence alignment

procedure sparsifyclosed
int sparse blog n c
usedmemory maxmemory exists edge e open e getlastsparse
sparse
edge pred e getbacktrack
trace back solution path
pred nil e getlastsparse sparse
e setlastsparse sparse mark avoid repeated trace back
bpred gethead getlevel kc mod sparse
pred lies prunable band redirect pointer
e setbacktrack pred getbacktrack
e getbacktrack ref
pred ref
pred ref
e last remaining edge referring pred
deleterec pred
end
else
prunable band continue traversal
e e getbacktrack
end
pred e getbacktrack
end
end
end

figure sparsification closed list restricted memory

levels instead individual levels bands size cannot skipped path
total number antidiagonals alignment k sequences length n
k n thus decrease density blog n c steps
technical implementation issue concerns ability enumerate edges reference given prunable edge without explicitly storing list however
reference counting method described ensures closed edge reached
following path bottom edge open procedure sketched fig
variable sparse denotes interval level bands maintained
memory inner loop paths open nodes traversed backward direction
edge e falls prunable band pointer successor e path
redirected respective backtrack pointer e last edge referencing e
latter one deleted path traversal continues start edge open
nodes visited memory bound still exceeded outer loop tries
double number prunable bands increasing sparse
procedure sparsifyclosed called regularly search e g expansion
however naive version described would incur huge overhead computation
time particularly memory consumption close limit therefore optimizations necessary first avoid tracing back solution path
lower sparse interval recording edge interval


fischroedl

traversed last time initially zero increased variable sparse
anything left pruning worst case edge inspected blog n c
times secondly would inefficient actually inspect open node inner
loop solution path traversed previously higher
sparse value however appropriate bookkeeping strategy possible reduce
time search overhead k

use improved heuristics
seen estimator hpair sum optimal pairwise goal distances gives
lower bound actual path length however powerful heuristics
conceivable computation require resources trade prove
worthwhile tighter estimator smaller space main search
needs explore
beyond pairwise alignments
kobayashi imai suggested generalize hpair considering optimal solutions
subproblems size proved following heuristics admissible
informed pairwise estimate
hall sum dimensional optimal costs divided

k


hone splits sequences two sets sizes k heuristic sum
optimal cost first subset plus second one plus sum
dimensional optimal costs pairs sequences different subsets usually
chosen close k
improved heuristics reduce main search effort orders magnitudes
however contrast pairwise sub alignments time space resources devoted compute store higher dimensional heuristics general longer negligible compared
main search kobayashi imai noticed even case
triples sequences impractical compute entire subheuristic hall one
reduction suffices restrict oneself nodes path cost
exceed optimal path cost subproblem




x
k
u
si im ti im






threshold seen generalization carrillo lipman bound however
still
incur excessive overhead space computation time computation
k

lower dimensional subproblems drawback requires upper bound
u whose accuracy efficiency hinges could improve bound
applying sophisticated heuristic methods seems counterintuitive spend
time would rather use calculate exact solution spite
advantages main search expensiveness heuristic calculation appears
major obstacle


fian improved search optimal multiple sequence alignment

mcnaughton lu schaeffer szafron suggested partition heuristic
hyper cubes hierarchical oct tree data structure contrast full cells
empty cells retain values surface main search tries use one
interior values recomputed demand still work assumes
node entire heuristic calculated least dynamic programming
see one cause dilemma implicit assumption complete computation
necessary bound refers worst case generally include many
nodes actually required main search however since dealing
heuristic actually afford miss values occasionally might
slow main search cannot compromise optimality final solution
therefore propose generate heuristics much smaller bound whenever
attempt retrieve value dimensional subheuristic
fails main

search simply revert replacing sum optimal pairwise goal distances
covers
believe iddp lends well make productive use higherdimensional heuristics firstly importantly strategy searching adaptively
increasing thresholds transferred bound well addressed
detail next section
secondly far practical implementation concerned important take
account higher dimensional heuristic affects number node expansions
time complexity time dominated number accesses subalignments k sequences worst case edge k successors leading
total

k
k


evaluations hall one possible improvement enumerate edges emerging
given vertex lexicographic order store partial sums heuristics prefix subsets
sequences later use way allow cache linear size number
accesses reduced

k
x





correspondingly quadratic cache need
k
x











evaluations instance aligning sequences hall linear cache reduces
evaluations percent within one expansion
mentioned contrast iddp gives us freedom choose
particular expansion order edges within given level therefore sort edges
lexicographically according target nodes much cached prefix information
shared additionally across consecutively expanded edges higher dimension
subalignments larger savings experiments experienced speedups
eighty percent heuristic evaluation


fischroedl

execution time



main search
heuristic
total time













heuristic miss ratio r







figure trade heuristic main search execution times tvxa
function heuristic miss ratio

trade computation heuristic main search
seen control size precomputed sub alignments choosing
bound f values edges generated beyond respective optimal
solution cost obviously trade auxiliary main searches
instructive consider heuristic miss ratio r e fraction calculations
heuristic h main search requested entry partial msa
precomputed optimum main search achieved heuristic
computed every requested edge r going beyond point generate
unnecessarily large heuristic containing many entries never actually used
hand free allocate less effort heuristic resulting r
consequently decreasing performance main search generally dependence
shaped form exemplified fig case tvxa balibase
cf next section execution time one iteration main search fixed
threshold lower bound shown includes optimal solution
fig illustrates overall time trade auxiliary main search fix
different levels minimum total execution time sum auxiliary
main search attained r seconds plot corresponding
memory usage trade similar shape
unfortunately general know advance right amount auxiliary search
mentioned choosing according carrillo lipman bound ensure


fian improved search optimal multiple sequence alignment

execution time




















heuristic miss ratio r







figure time last iteration main search tvxa function
heuristic miss ratio

every requested sub alignment cost precomputed however general
considerably overestimate necessary size heuristic
remedy iddp gives us opportunity recompute heuristic
threshold iteration main search way adaptively strike balance
two
currently experienced miss rate r rises threshold suspend
current search recompute pairwise alignments increased threshold
resume main search improved heuristics
main search accurately predict auxiliary computation time
space threshold exponential fitting due lower dimensionality
generally increase less steeply however constant factor might higher
k
heuristic due combinatorial number
alignment solved
doubling scheme explained bound overhead within constant
factor effort last iteration way limiting heuristic
computation time fixed fraction main search ensure expected
upper bound overall execution time stays within constant factor search
time would required pairwise heuristic
knew exact relation r speedup main search ideal
strategy would double heuristic whenever expected computation time smaller
time saved main search however illustrated fig dependence
complex simple exponential growth varies search depth specifics
would need elaborate model search space


fischroedl

would conduct exploratory searches order estimate relation
leave issue future work restrict simplified conservative
heuristic hypothesize main search made twice fast heuristic
doubling miss rate r rises percent experiments found
assumption almost true event since effective branching factor
main search reduced improved heuristic ignore history main search
times exponential extrapolation procedure subsequent iterations

experimental
following compare iddp one currently successful approaches
partial expansion empirically explore benefit higher dimensional heuristics
finally feasibility means benchmark database balibase
comparison partial expansion
first series evaluations ran iddp set sequences chosen
yoshizumi et al elongation factors ef tu ef species
high degree similarity work substitution costs chosen according
pam matrix applied heuristic sum optimal pairwise goal distances
expansion numbers completely match however since applied
biologically realistic affine gap costs gaps length x charged x except
beginning end sequence penalty x
following experiments run redhat linux intel xeont
cpu ghz main memory gigabytes used gcc compiler
total space consumption search determined peak number
open closed edges entire running time table fig give values
series successively larger sets input sequences sequences numbered
defined yoshizumi et al
implementation basic could carried
sequences exhausting computers main memory
confirming yoshizumi et al partial expansion requires
one percent space interestingly iteration peak total numbers
nodes held memory nodes actually closed except might
explained high degree similarity sequences example recall
pea closes node successors f value
optimal solution cost span lower bound small node least
one bad successor exceeds difference
iddp reduces memory requirements factor diagram
shows maximum size open list alone sequences difference
two dominated linear length store solution path
size increases however proportion closed list total memory drops
percent sequences total number expansions including
search stages slightly higher pea however due optimizations made possible
control expansion order execution time sequences reduced
third


fian improved search optimal multiple sequence alignment

num
exp

time
sec

max
open

max
open
closed




















































pea























































iddp








































table comparison varying number input sequences elongation factors
ef tu ef

since pea prune edges maximum space usage total number
edges f value smaller g call edges relevant edges since
inspected admissible iddp hand open list
comprise k adjacent levels edges counting possible threshold
overshoot would contribute factor thus improvement iddp
pea tend increase overall number levels sum


fischroedl

e
e

edges memory

e




max open closed
pea max open closed
iddp max open closed
iddp max open














number sequences







figure memory requirements iddp pea elongation factors ef tu
ef

string lengths divided number sequences words average
sequence length
moreover ratio depends well heuristic suits particular
fig shows distribution edges f value smaller equal g
case example sequences quite extreme bulk edges
concentrated small level band example
even distribution fig depicts situation cpt reference
benchmark set balibase thompson et al heuristic hall case
proportion overall relevant edges maximal among adjacent
levels amounts percent maximum open size iddp
total number edges generated pea improvement factor

multidimensional heuristics
set sequences compared different improved heuristics order get
impression respective potential specifically ran iddp heuristics hpair
hall hall hone k thresholds fig shows total execution time
computing heuristics performing main search case manually
selected value minimized time seen times hone k
lie little bit hpair sequences less six computation
heuristics hall hall dominates overall time increasing dimensions

fian improved search optimal multiple sequence alignment



open edges sum open edges


















level









figure distribution relevant edges levels elongation factors ef tu ef
compare schematic projection fig

ever investment starts yield growing returns hall fastest
requiring percent time hpair sequences
far memory concerned fig reveals maximum size open
closed list chosen values similar hpair hone k one hand
hall hall hand
sequences hone saves percent edges hall needs
percent hall percent space required pairwise heuristic
iddp never ran main memory even larger test sets could aligned range
shown diagrams limited patience wait two
days
experienced burden computing heuristic kobayashi imai
concluded hone preferred hall quite agree judgment see heuristic hall able reduce search space main search
considerably stronger hone beneficial appropriate
amount heuristic computation
benchmark database balibase
balibase thompson et al widely used database manually refined multiple
sequence alignments specifically designed evaluation comparison multiple sequence alignment programs alignments classified reference sets reference
contains alignments six equidistant sequences sequences sim

fischroedl

open edges sum open edges





e

e

e

e











level









figure distribution relevant edges levels cpt balibase
ilar length grouped classes indexed sequence length percentage
identical amino acids columns note many indeed much harder elongation factor examples previous section despite
consisting fewer sequences dissimilarities much pronounced
applied reference substitution costs according pet
matrix jones et al affine gap costs x except leading trailing gaps
gap opening penalty charged instances precomputed pairwise
sub alignments fixed bound optimal solution optimal solution
found within bound cases effort generally marginal compared
overall computation involving three sequences heuristic
hall applied
alignment reference could solve
namely pama gal computer detailed listed tables

thompson plewniak poch compared number widely used heuristic
alignment tools called sp score software calculates percentage
correctly aligned pairs within biologically significant motifs found programs perform equally well sequences medium high amino acid
identity differences occurred case distant sequences less
percent identity called twilight zone particularly challenging
group short sequences subgroup three highest scoring programs prrp
clustalx saga respective median scores
medium score alignments found experiments amounts hence
good prrp beaten clustalx focused exper

fian improved search optimal multiple sequence alignment

e



total time sec






fold heuristic
div conq heuristic
fold heuristic
fold heuristic











number sequences





figure comparison execution times including calculation heuristics elongation
factors ef tu ef

iments algorithmic feasibility rather solution quality would worthwhile
attempt improve alignments found program refined
penalty functions clustalx example uses different pam matrices depending
evolutionary distance sequences moreover assigns weights sequences
phylogenetic tree gap penalties made position specific improvements easily integrated basic sum pairs cost function could
attempt compute optimal alignment respect metrics leave line
future work
fig shows maximum number edges stored open
search dependence search threshold final iteration better comparability
included diagram consist sequences logarithmic
scale emphasizes growth fits exponential curve quite well roughly speaking
increase cost threshold leads ten fold increase space requirements
relation similarly applicable number expansions fig
fig depicts proportion maximum open list size combined
maximum size open closed clearly visible due pruning edges
outside possible solution paths closed list contributes less less overall
space requirements difficult become
finally estimate reduction size open list compared relevant
edges ratio maximum open size last iteration iddp total
number expansions stage equal number edges f value
less equal threshold considering possible overshoot iddp pea


fischroedl

maximum size open closed

e

e







fold heuristic
div conq heuristic
fold heuristic
fold heuristic










number sequences





figure combined maximum size open closed different heuristics elongation
factors ef tu ef

e
e

max open







short
medium length
long









threshold lower bound





figure maximum size open list dependent final search threshold balibase



fian improved search optimal multiple sequence alignment

e
e

expansions

e





short
medium length
long









threshold lower bound





figure number expansions final search iteration balibase



max open max open closed









short
medium length
long









threshold lower bound





figure maximum number open edges divided combined maximum open
closed balibase



fischroedl



short
medium length
long

max open expansions

















threshold lower bound





figure percentage reduction open size balibase
would expand least half nodes proportion ranges percent
cf fig considerable scatter indicates dependence individual properties however slight average decrease noticed difficult



fian improved search optimal multiple sequence alignment

conclusion discussion
presented search optimal multiple sequence alignment
combines effective use heuristic bound best first search ability
dynamic programming reduce maximum size open closed lists
one order magnitude sequence length performs series
searches successively increasing bounds explore search space dp order
thresholds chosen adaptively expected overhead recomputations
bounded constant factor
demonstrated outperform one currently
successful optimal multiple sequence alignments partial expansion
terms computation time memory consumption moreover iterative deepening
strategy alleviates use partially computed higher dimensional heuristics best
knowledge first one able solve standard benchmark
alignment balibase biologically realistic cost function including affine
gap costs without end gap penalties quality alignment range
best heuristic programs concentrated algorithmic feasibility deem
worthwhile incorporate refined cost metrics better study
question future work
recently learned related approaches developed simultaneously independently zhou hansen b sweepa explores search graph according
layers partial order still uses f value selecting nodes within one layer
breadth first heuristic search implicitly defines layers graph uniform costs
according breadth first traversal incorporate upper bounds
optimal solution cost pruning however idea adaptive threshold determination
limit expansion overhead constant factor described moreover
consider flexible use additional memory minimize divide conquer solution
reconstruction phase
although described entirely within framework msa
straightforward transfer domain state space graph directed
acyclic natural candidates include applications ordering imposed
time space coordinates e g finding likely path markov model
two balibase benchmark could still solved
within computers main memory limit future work include integration
techniques exploiting secondary memory expect level wise exploration scheme
lends naturally external search another currently
active topic artificial intelligence theoretical computer science

acknowledgments
author would thank reviewers article whose comments helped
significantly improving



fischroedl

appendix

table balibase reference group short sequences low amino acid
identity columns denote number aligned sequences upper
bound precomputing optimal solutions partial last iteration
main search g optimal solution cost h lower bound solution cost
heuristics exp total number expansions iterations main
search op peak number edges open list course search
op cl peak combined number edges open closed list
search heu peak number subalignment edge costs stored heuristic
time total running time including auxiliary main search seconds mem
peak total memory usage face alignments heuristic main search
kb
aboa
idy
r
tvxa
ubi
wit
trx



















g








h








exp








op








op cl








heu








time








mem








table short sequences medium similarity
aab
fjla
hfh
hpi
csy
pfc
tgxa
ycc
cyr
c

























g











h











exp











op













op cl











heu











time











mem











fian improved search optimal multiple sequence alignment

table short sequences high similarity












aho
csp
dox
fkj
fmb
krn
plc
fxb
mhr
rnt













g











h











exp











op











op cl











heu











time











mem











table medium length sequences low similarity

bbt
sbp
hava
uky
hsda
pia
grs
kinase





















g









h









exp









op









op cl









heu









time









mem









table medium length sequences medium similarity

ad
aym
gdoa
ldg
mrj
pgta
pii
ton
cba























g










h










exp










op












op cl










heu










time










mem










fischroedl

table medium length sequences high similarity












amk
ar
ezm
led
ppn
pysa
thm
tis
zin
ptp













g











h











exp











op











op cl











heu











time











mem











table long sequences low similarity

ajsa
cpt
lvl
ped
myr
enl

















g







h







exp







op







op cl







heu







time







heu













time













mem







table long sequences medium similarity

ac
adj
bgl
dlc
eft
fiea
gowa
pkm
sesa
ack
arp
glg





























g













h













exp













op















op cl













mem













fian improved search optimal multiple sequence alignment

table long sequences high similarity

ad
gpb
gtr
lcf
rtha
taq
pmg
actin





















g









h









exp











op









op cl









heu









time









mem









fischroedl

references
altschul gish w miller w myers e lipman basic local alignment
search tool journal molecular biology
altschul f gap costs multiple sequence alignment journal theoretical
biology
carrillo h lipman multiple sequence alignment biology
siam journal applied mathematics
chan c wong k c chiu k survey multiple sequence
comparison techniques bulletin mathematical biology
culberson j c schaeffer j pattern databases computational intelligence

davidson fast pruning optimal sequence alignment proceedings nd ieee international symposium bioinformatics bioengineering
bibe pp
dayhoff schwartz r orcutt b c model evolutionary change
proteins dayhoff ed atlas protein sequence structure pp
washington c national biomedical foundation
dial r b shortest path forest topological ordering comm acm

dijkstra e w note two connection graphs numerische
mathematik
gupta kececioglu j schaeffer improving practical space time
efficiency shortest paths sum pairs multiple sequence alignment
j computational biology
gusfield efficient methods multiple sequence alignment guaranteed
error bounds bull math biol
hart p e nilsson n j raphael b formal basis heuristic determination
minimum path cost ieee trans systems science cybernetics
hirschberg linear space computing maximal common subsequences comm acm
ikeda imai h fast multiple sequence alignment
proceedings genome informatics workshop pp
jones taylor w r thornton j rapid generation mutation
data matrices protein sequences cabios
kobayashi h imai h improvement multiple sequence
alignment miyano takagi eds genome informatics pp
tokyo universal academy press
korf r e depth first iterative deepening optimal admissible tree search
artificial intelligence


fian improved search optimal multiple sequence alignment

korf r e divide conquer bidirectional search first proceedings
sixteenth international conference artificial intelligence ijcai pp
stockholm sweden
korf r e zhang w divide conquer frontier search applied optimal
sequence alignment proceedings eighteenth national conference artificial
intelligence aaai pp
mcnaughton lu p schaeffer j szafron memory efficient heuristics
multiple sequence alignment proceedings eighteenth national conference
artificial intelligence aaai edmonton alberta canada
spouge j l speeding dynamic programming finding optimal
lattice paths siam j applied mathematics
thompson j plewniak f poch comprehensive comparison multiple
sequence alignment programs nucleic acids res
ukkonen e approximate string matching information control

wah b w shang comparison class ida search
international journal tools artificial intelligence
wang l jiang complexity multiple sequence alignment journal
computational biology
yoshizumi miura ishida partial expansion large branching
factor aaai iaai pp
zhou r hansen e sparse memory graph search th international
joint conference artificial intelligence ijcai acapulco mexico
zhou r hansen e b sweep space efficient heuristic search partiallyordered graphs th ieee international conference tools artificial intelligence sacramento ca
zhou r hansen e breadth first heuristic search fourteenth international conference automated scheduling icaps whistler bc
canada




