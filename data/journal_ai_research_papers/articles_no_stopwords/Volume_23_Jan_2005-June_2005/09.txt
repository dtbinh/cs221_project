Journal Artificial Intelligence Research 23 (2005) 421-440

Submitted 07/04; published 04/05

Practical use Variable Elimination Constraint
Optimization Problems: Still-life Case Study
Javier Larrosa
Enric Morancho
David Niso

larrosa@lsi.upc.edu
enricm@ac.upc.edu
niso57@casal.upc.edu

Universitat Politecnica de Catalunya
Jordi Girona 1-3, 08034 Barcelona, Spain

Abstract
Variable elimination general technique constraint processing. often discarded high space complexity. However, extremely useful
combined techniques. paper study applicability variable elimination challenging problem finding still-lifes. illustrate several alternatives:
variable elimination stand-alone algorithm, interleaved search, source
good quality lower bounds. show techniques best known option
theoretically empirically. experiments able solve n = 20
instance, far beyond reach alternative approaches.

1. Introduction
Many problems arising domains resource allocation (Cabon, de Givry, Lobjois,
Schiex, & Warners, 1999), combinatorial auctions (Sandholm, 1999), bioinformatics
probabilistic reasoning (Pearl, 1988) naturally modeled constraint satisfaction
optimization problems. two main solving schemas search inference. Search
algorithms constitute usual solving approach. transform problem set
subproblems selecting one variable instantiating different alternatives.
Subproblems solved applying recursively transformation rule. recursion
defines search tree normally traversed depth-first manner,
benefit requiring polynomial space. practical efficiency search algorithms
greatly depends ability detect prune redundant subtrees. worst-case,
search algorithms need explore whole search tree. Nevertheless, pruning techniques
make much effective.
Inference algorithms (also known decomposition methods) solve problem sequence transformations reduce problem size, preserving optimal cost.
well known example bucket elimination (BE, known variable elimination) (Bertele
& Brioschi, 1972; Dechter, 1999). algorithm proceeds selecting one variable
time replacing new constraint summarizes effect chosen variable. main drawback new constraints may large arities require
exponentially time space process store. However, nice property
worst-case time space complexities tightly bounded structural parameter called induced width. exponential space complexity limits severely algorithms
c
2005
AI Access Foundation. rights reserved.

fiLarrosa, Morancho & Niso

practical usefulness. Thus, constraint satisfaction community variable elimination
often disregarded.
paper consider challenging problem finding still-lifes stable
patterns maximum density game life. academic problem recently
included CSPlib repository1 dedicated web page2 set maintain
up-to-date results. Bosch Trick (2002), still-life problem solved using two
different approaches: integer programming constraint programming, based
search. None could solve n = 8 problem within reasonable time.
best results obtained hybrid approach combines two techniques
exploits problem symmetries order reduce search space. algorithm,
solved n = 15 case 8 days cpu. Smith (2002) proposed interesting
alternative using pure constraint programming techniques, solving problem
dual form. work, Smith could improve n = 15 limit. Although explicitly
2
mentioned, two works use algorithms worst-case time complexity O(2(n ) ).
paper show usefulness variable elimination techniques. First apply
plain BE. could expected, observe competitive stateof-the-art alternatives. Next, introduce sophisticated algorithm combines
search variable elimination (following ideas Larrosa & Dechter, 2003) uses
lower bound based mini-buckets (following ideas Kask & Dechter, 2001).
algorithm, solve one minute n = 15 instance. able solve
n = 20 instance, far beyond reach previous techniques. readability
reasons, describe main ideas omit algorithmic details.3
structure paper following: next Section give preliminary
definitions. Section 3 solve problem plain BE. Section 4 introduce
hybrid algorithm obtained results reported Section 5. Section 6
discuss ideas explored article extended domains. Besides,
report additional experimental results. Finally, Section 7 gives conclusions
lines future work.

2. Preliminaries
Section first define still-life problem. Next, define weighted CSP
framework formulate still-life weighted CSP. Finally, review main
solving techniques weighted CSPS.
2.1 Life Still-Life
game life (Gardner, 1970) played infinite checkerboard, square
called cell. cell eight neighbors: eight cells share one two corners
it. player places checkers cells. checker it, cell
alive, else dead. state board evolves iteratively according following
three rules: (1) cell exactly two living neighbors state remains
1. www.csplib.org
2. www.ai.sri.com/~ nysmith/life
3. interested reader find extended version, along source code implementation
www.lsi.upc.edu/~ larrosa/publications

422

fiOn practical use variable elimination

3

1

3

1

1

3

1

Xc

4

2



2

2

B

2



C

E

Figure 1: A: 3 3 still-life. B: constraint graph simple WCSP instance four
variables three cost functions. C: constraint graph assigning variable
x4 . D: constraint graph clustering variables x3 x4 . E: constraint
graph eliminating variable x4 .

next iteration, (2) cell exactly three living neighbors alive
next iteration (3) cell fewer two three living neighbors,
dead next iteration. Although defined terms extremely simple rules,
game life proven mathematically rich attracted interest
mathematicians computer scientists.
still-life problem SL(n) consist finding nn stable pattern maximum density
game life. cells outside pattern assumed dead. Considering
rules game, easy see cell (i, j) must satisfy following three
conditions: (1) cell alive, must exactly two three living neighbors, (2)
cell dead, must three living neighbors, (3) cell grid
boundary (i.e, = 1 = n j = 1 j = n), cannot part sequence three
consecutive living cells along boundary. last condition needed three
consecutive living cells boundary would produce living cells outside grid.
Example 1 Figure 1.A shows solution SL(3). easy verify cells
satisfy previous conditions, hence stable. pattern optimal 6
living cells 3 3 stable pattern 6 living cells exists.

2.2 Weighted CSP
weighted constraint satisfaction problem (WCSP) (Bistarelli, Montanari, & Rossi, 1997)
defined tuple (X, D, F), X = {x1 , . . . , xn } set variables taking values
finite domains Di D. F set weighted constraints (i.e., cost functions).
f F defined subset variables, var(f ), called scope. objective
function sum functions F,
F =

X

f

f F

goal find instantiation variables minimizes objective function.
Example 2 Consider WCSP four variables X = {xi }4i=1 domains Di = {0, 1}
three cost functions: f1 (x1 , x4 ) = x1 + x4 , f2 (x2 , x3 ) = x2 x3 f3 (x2 , x4 ) = x2 + x4 .
423

fiLarrosa, Morancho & Niso

objective function F (x1 , x2 , x3 , x4 ) = x1 + x4 + x2 x3 + x2 + x4 . Clearly, optimal
cost 0, obtained every variable taking value 0.
Constraints given explicitly means tables, implicitly mathematical
expressions computing procedures. Infeasible partial assignments specified constraints assign cost them. assignment value variable xi noted
xi = a. partial assignment tuple = (xi1 = v1 , xi2 = v2 , , xij = vj ). extension
xi = noted (xi = a). WCSPs instances graphically depicted means
interaction constraint graph, one node per variable one edge connecting two nodes appear scope cost function. instance,
Figure 1.B shows constraint graph problem previous example.
2.3 Overview Solving Techniques
Subsection review solving techniques widely used reasoning
constraints.
2.3.1 search
WCSPs typically solved depth-first search. Search algorithms defined
terms instantiating functions,
Definition 1 Let P = (X, D, F) WCSP instance, f function F, xi variable
var(f ), v value Di . Instantiating f xi = v new function scope
var(f ) {xi } returns tuple t, f (t (xi = v)). Instantiating P xi = v
new problem P |xi =v = (X {xi }, {Di }, F 0 ), F 0 obtained instantiating
functions F mention xi xi = v.
instance, instantiating problem Example 2 x4 = 1, produces new
problem three variables {xi }3i=1 three cost functions: f1 (x1 , x4 = 1) = x1 + 1,
f2 (x2 , x3 ) = x2 x3 f3 (x2 , x4 = 1) = x2 + 1. Figure 1.C shows corresponding
constraint graph, obtained original graph removing instantiated variable x4
adjacent edges. Observe new graph depends instantiated variable,
depend value assigned it.
Search algorithms transform current problem P set subproblems. Usually
done selecting one variable xi instantiated different domain values
(P |xi =v1 , P |xi =v2 , , P |xi =vd ). transformation called branching. subproblem process recursively applied, defines tree subproblems. Search
algorithms expand subproblems trivial case achieved: variable left,
pruning condition detected. optimization problems, pruning conditions usually
defined terms lower upper bounds. Search keeps cost best solution
far, upper bound optimal cost. node, lower bound best
cost obtainable underneath computed. lower bound greater equal
upper bound, safe backtrack.
size search tree O(dn ) (being size largest domain) bounds
time complexity. tree traversed depth-first, space complexity polynomial.
424

fiOn practical use variable elimination

2.3.2 clustering
well-known technique constraint processing clustering (Dechter & Pearl, 1989).
merges several variables one meta-variable, preserving problem semantics.
Clustering variables xi xj produces meta-variable xk , whose domain Di Dj . Cost
functions must accordingly clustered. instance, problem Example 2, clustering variables x3 x4 produces variable xc domain Dc = {(0, 0), (0, 1), (1, 0), (1, 1)}.
Cost functions f2 f3 clustered fc (x2 , xc ) = f2 + f3 . new variable
notation fc = x2 xc [1] + x2 + xc [2], xc [i] denotes i-th component xc . Function
f1 needs reformulated f1 (x1 , xc ) = x1 + xc [2]. constraint graph resulting
problem obtained merging clustered variables connecting meta-node
nodes adjacent clustered variables. Figure 1.D shows constraint graph clustering x3 x4 . typical use clustering transform
cyclic constraint graph acyclic one, solved efficiently thereafter.
2.3.3 variable elimination
Variable elimination based following two operations,
Definition 2 sum two functions f g, noted (f + g), new function
scope var(f ) var(g) returns tuple sum costs f g,
(f + g)(t) = f (t) + g(t)
Definition 3 elimination variable xi f , noted f xi , new function
scope var(f ) {xi } returns tuple cost best extension xi ,
(f xi )(t) = min {f (t (xi = a))}
aDi

Observe f unary function (i.e., arity one), eliminating variable
scope produces constant.
Definition 4 Let P = (X, D, F) WCSP instance. Let xi X arbitrary variable
let Bi set cost functions xi scope (Bi called bucket
xi ). define gi
X
gi = (
f ) xi
f Bi

elimination xi transforms P new problem P xi = {X {xi }, {Di }, (F
Bi ) {gi }}. words, P xi obtained replacing xi functions bucket
gi .
P P xi optimal cost because, construction, gi compensates
absence xi . constraint graph P xi obtained forming clique
nodes adjacent node xi removing xi adjacent edges. example,
eliminating x4 problem Example 2 produces new problem three variables
{xi }3i=1 two cost functions: f2 g4 . scope g4 {x1 , x2 } defined as,
425

fiLarrosa, Morancho & Niso

g4 = (f1 + f3 ) x4 = (x1 + x4 + x2 + x4 ) x4 = x1 + x2 . Figure 1.D shows constraint
graph elimination.
previous example, new function g4 could expressed mathematical expression. Unfortunately, general, result summing functions eliminating variables
cannot expressed intensionally, new cost functions must stored extensionally
tables. Consequently, space complexity computing P xi proportional numQ
ber entries gi , is: ( xj var(gi ) |Dj |). Since xj var(gi ) iff xj adjacent xi
Q
constraint graph, previous expression rewritten ( xj N (i,GP ) |Dj |),
GP constraint graph P N (i, GP ) set neighbors xi GP .
time complexity computing P xi space complexity multiplied cost
computing entry gi .
Bucket elimination (BE) works two phases. first phase, eliminates variables
one time reverse order. elimination xi , new gi function computed
added corresponding bucket. elimination x1 produces empty-scope
function (i.e., constant) optimal cost problem. second phase,
considers variables increasing order generates optimal assignment variables.
time space complexity exponential structural parameter
constraint graph, called induced width, captures maximum arity among
gi functions. Without additional overhead compute number optimal
solutions (see Dechter, 1999, details).
2.3.4 super-buckets
cases, may convenient eliminate set variables simultaneously (Dechter
& Fatah, 2001). elimination set variables performed collecting
set functions mentioning least one variable . Variables functions
replaced new function gY defined as,
gY = (

X

f)

f

set called super-bucket. Note elimination seen
clustering variables meta-variable xY followed elimination.
2.3.5 mini-buckets
space complexity high, approximation, called mini buckets
(Dechter & Rish, 2003), used. Consider elimination xi , associated
bucket Bi = {fi1 , . . . , fik }. would compute,
gi = (

X

f ) xi

f Bi

time space complexity computation depends arity gi . beyond
available resources, partition bucket Bi so-called mini-buckets Bi1 , . . . , Bik
number variables scopes mini-bucket bounded parameter.
compute,
X
gij = (
f ) xi , j = 1..k
f Bij

426

fiOn practical use variable elimination

6

7

6

1

2

2
2
8

9
3

5

1

8

2

8

9

9
3

1

3

1

8

9

5

5

5

4

4
4

4



B

C



Figure 2: constraint graph evolution sequence variable eliminations
instantiations.

gij bounded arity. Since,
gij

gi

zX }|

(

f Bi

{

f ) xi

k z X }|
X

(

{

f ) xi

j=1 f Bij

elimination variables using mini-buckets yields lower bound actual optimal
cost.
2.3.6 combining search variable elimination
plain costly space, combine search (Larrosa & Dechter,
2003). Consider WCSP whose constraint graph depicted Figure 2.A. Suppose
want eliminate variable want compute store constraints
arity higher two. take consideration variables connected
two variables. example, variable x7 one selected.
elimination transforms problem another one whose constraint graph depicted
Figure 2.B. x6 degree decreased two, eliminated.
new constraint graph depicted Figure 2.C. point, every variable degree
greater two, switch search schema selects variable, say x3 , branches
values produces set subproblems, one value domain.
constraint graph, depicted Figure 2.D. subproblem,
possible eliminate variable x8 x4 . elimination possible eliminate
x2 x9 , subsequently x5 x1 . Eliminations branching done
every subproblem since new constraints eliminated variables replaced
differ one subproblem another. example, one branching made.
Therefore, elimination variables reduced search tree size d9 d,
size domains. example, bounded arity new constraints
two, generalized arbitrary value.

3. Solving Still-life Variable Elimination
SL(n) easily formulated WCSP. natural formulation associates one
variable xij cell (i, j). variable two domain values. xij = 0 cell
427

fiLarrosa, Morancho & Niso

X1
j 2

j 1

j

2

j+1

j+2

X2

1

X3



X4

i+1

X5

+2

X6

B



Figure 3: A: Structure constraint graph SL(n). node center, associated
cell (i, j), linked cells interacts with. shadowed area indicates
scope fij . B (left): Constraint graph SL(6) clustering cells
row variables. B (from left right: Evolution constraint graph
execution BE.

dead, xij = 1 alive. cost function fij variable xij . scope
fij xij neighbors. evaluates stability xij : xij unstable given
neighbors, fij returns ; else fij returns 1 xij .4 objective function minimized
is,
F =

n X
n
X

fij

i=1 j=1

instantiation X represents unstable pattern, F (X) returns ; else returns
number dead cells. fij stored table 29 entries evaluated constant
time.
Figure 3.A illustrates structure constraint graph SL(n). picture shows
arbitrary node xij linked nodes interacts with. instance, edge
xij xi,j+1 xi,j+1 neighbor xij grid and, consequently,
variables scope fij . edge xij xi1,j2
cells neighbors xi1,j1 grid and, therefore, appear scope
fi1,j1 . shadowed area represents scope fij (namely, xij neighbors).
complete graph obtained extending connectivity pattern nodes
graph.
sake clarity, use equivalent compact SL(n) formulation
makes easier describe implement: cluster variables row
single meta-variable. Thus, xi denotes state cells i-th row (namely,
xi = (xi1 , xi2 , . . . , xin ) xij {0, 1}). Accordingly, takes values sequences
n bits or, equivalently, natural numbers interval [0..2n 1]. Cost functions
accordingly clustered: cost function associated row i, defined as,
=

n
X

fij

j=1

4. Recall that, WCSP, task minimize number dead cells. Therefore, give cost 1
dead cells cost 0 living cells.

428

fiOn practical use variable elimination

internal rows, scope {xi1 , xi , xi+1 }. cost function top row, f1 ,
scope {x1 , x2 }. cost function bottom row, fn , scope {xn1 , xn }.
unstable cell xi , (xi1 , xi , xi+1 ) = . Else, returns number dead cells
xi . Evaluating (n) bits arguments need checked.
new, equivalent, objective function is,
F =

n
X



i=1

Figure 3.B (left) shows constraint graph SL(6) formulation. arbitrary
variable xi connected two variables two variables below.
sequential structure constraint graph makes intuitive. eliminates variables
decreasing orders. elimination xi produces new function gi = (fi1 + gi+1 ) xi
scope {xi2 , xi1 }. Figure 3.B (from left right) shows evolution constraint
graph along elimination variables. Formally, applies recursion transforms
subproblem P P xi , xi variable P highest index. satisfies
following property,
Property 1 Let gi function added replace xi . gi (a, b) cost
best extension (xi2 = a, xi1 = b) eliminated variables (xi , . . . , xn ). Formally,
gi (a, b) =

min

vi Di ,...,vn Dn

{fi1 (a, b, vi ) + (b, vi , vi+1 ) +

+fi+1 (vi , vi+1 , vi+2 ) + . . .
+fn1 (vn2 , vn1 , vn ) + fn (vn1 , vn )}
gi (a, b) = , means pattern a, b cannot extended inferior rows
stable pattern. gi (a, b) = k (with k 6= ), means a, b extended
optimal extension k dead cells xi1 xn .
space complexity (n 22n ), due space required store n functions
gi extensionally (2n 2n entries each). Regarding time, computing entry gi
cost (n 2n ) (finding minimum 2n alternatives, computation one
(n)). Since gi 22n entries, total time complexity (n2 23n ). Observe
solving SL(n) exponential improvement search algorithms,
2
time complexity O(2n ).
Table 4 reports empirical results. obtained 2 Ghz Pentium IV
machine 2 Gb memory. first columns reports problem size, second
reports optimal cost number dead cells (in parenthesis, number living
cells), third column reports number optimal solutions. count different
two solutions even one transformed problem symmetry.
fourth column reports CPU time seconds. fifth, sixth seventh
columns report results obtained three approaches tried Bosch Trick
(2002):5 constraint programming (CP), integer programming (IP), sophisticated
algorithm (CP/IP) combines CP IP, exploits problem symmetries.
5. corresponding OPL code available http://mat.gsia.cmu.edu/LIFE.

429

fiLarrosa, Morancho & Niso

n
5
6
7
8
9
10
11
12
13
14
15

opt
9(16)
18(18)
21(28)
28(36)
38(43)
46(54)
57(64)
68(76)
79(90)
92(104)
106(119)

n. sol.
1
48
2
1
76
3590
73
129126
1682
11
?


0
0
0
0
4
27
210
1638
13788
105
*

CP
0
0
4
76
> 600
*
*
*
*
*
*

IP
0
1
3
26
> 600
*
*
*
*
*
*

CP/IP
0
0
0
2
20
60
153
11536
12050
5 105
7 105

Figure 4: Experimental results four different algorithms still-life problem. Times
seconds.

observed clearly outperforms CP IP orders magnitude.
n = 14 case largest instance could solve due exhausting available
space. Comparing CP/IP, observe clear winner. additional
observation scales regularly, execution requiring roughly eight times
time four times space previous, clear accordance
algorithm complexity.

4. Combining Search Variable Elimination
One way overcome high space complexity combine search variable
elimination hybrid approach HYB (Larrosa & Schiex, 2003). idea use search
(i.e, instantiations) order break problem independent smaller parts
variable elimination efficiently performed.
Let us reformulate problem convenient way hybrid algorithm.
sake simplicity without loss generality consider n even. cluster
R
row variables three meta-variables: xC
denotes two central cells row i, xi
n
L
xi denote 2 1 remaining cells right left, respectively (see Figure 5.A).
L
R
Consequently, xC
takes values range [0..3], xi xi take values range
n
1
[0..2 2 1]. Cost functions accordingly clustered,
n

fiL

=

2
X

fiR =

fij ,

n
X
j= n
+1
2

j=1

new, equivalent, objective function is,
F =

n
X

(fiL + fiR )

i=1

430

fij

fiOn practical use variable elimination

Left

X

L
1

Center

X

C
1

Right

X

Left

R
1

Center

Right

X1

X2

X3
X

L


X

C


X

R


X4

X

L
n

X

C
n

X

X5

R
n

X6

B


Left

Center

Right

Left

Center

Right

X1
X1
X2
X2
X3
X3
X4
X4
X5
X5
X6
X6
C



Figure 5: Formulation SL(n) used hybrid algorithm. A: row clustered
three variables. B: Constraint graph SL(6). C: Constraint graph
C
C
assignment xC
n , xn1 xn2 . D: Constraint graph elimination
L
R
xn xn .

431

fiLarrosa, Morancho & Niso

C
L C
L
C
scopes internal row functions, fiL fiR , {xL
i1 , xi1 , xi , xi , xi+1 , xi+1 }
C
R
C
R
C
R
L
R
L
C
C
{xi1 , xi1 , xi , xi , xi+1 , xi+1 }. Top functions f1 f1 scopes {x1 , x1 , xL
2 , x2 }
R C
R
L
R
L
C
L C
{xC
1 , x1 , x2 , x2 }. Bottom functions fn fn scopes {xn1 , xn1 , xn , xn }
R
C
R
C
{xn1 , xn1 , xn , xn }. Figure 5.B shows corresponding constraint graph. imporR
tance formulation xL
xi independent (i.e, edge
constraint graph connecting left right variables).

hybrid algorithm HYB searches central variables eliminates lateral
variables. Variables considered decreasing order index. Thus, algorithm
C
C
starts instantiating xC
n , xn1 xn2 , produces subproblem constraint
R
graph shown Figure 5.C. Observe variable xL
n (respectively, xn ) connected
L
L
R
R
variables xn1 xn2 (respectively, xn1 xn2 ). eliminated producing
L
R
R
R
new function gnL scope {xL
n2 , xn1 } (respectively, gn scope {xn2 , xn1 }).
Figure 5.D shows resulting constraint graph. Lateral variables domains size
n
n
2 2 1 . Hence, elimination space (2n ) time (23 2 ). important note
C
C
eliminations subject current assignment xC
n , xn1 xn2 . Therefore,
recomputed value change. elimination xL
n
C
xR
,

algorithm
would
assign
variable
x


make
possible

elimination

n
n3
L
R
C
xn1 xn1 , on. arbitrary level search, algorithm assigns xi ,
R
makes xL
i+2 xi+2 independent central columns related two
L
variables above. Then, eliminates replacing variables functions gi+2
R scopes {xL , xL } {xR , xR }, respectively. Formally, HYB applies recursion
gi+2

i+1

i+1
transforms subproblem P 4 simpler subproblems {((P |xC =v ) xL ) xR }3v=0 .

i+2
i+2
satisfies following property,

Property 2 Let giL function computed HYB used replace variable xL
.
L
giL (a, b) cost best extension (xL
=
a,
x
=
b)

eliminated
variables
i2
i1
L
R
(xL
, . . . , xn ), conditioned current assignment. Similarly, right side, gi (a, b)
R
R
R
cost best extension (xi2 = a, xi1 = b) eliminated variables (xi , . . . , xR
n ),
conditioned current assignment.

L (a, b) among comA consequence previous Property minimum gi+2
binations b lower bound best cost obtained left
L (a, b)} +
part grid continue current line search. Therefore, mina,b {gi+2
R
mina,b {gi+2 (a, b)} valid lower bound current node used pruning
purposes.

space complexity algorithm (n 2n ), due giL giR functions
need explicitly stored. time complexity O(n 23.5n ), O(4n )
nodes may visited (n variables domains size 4) cost processing
n
node (n 23 2 ) due variable eliminations.
Thus, comparing BE, time complexity increases (n2 23n ) O(n23.5n ).
prize HYB pays space decrement (n 22n ) (n 2n ).
432

fiOn practical use variable elimination

4.1 Refining Lower Bound
well-known average-case efficiency search algorithms depends greatly
lower bound use. algorithm using poor lower bound based giL
giR functions, only.
Kask Dechter (2001) proposed general method incorporate information
yet-unprocessed variables lower bound. Roughly, idea run mini buckets
(MB) prior search save intermediate functions future use. MB executed using
reverse order search instantiate variables. execution MB
completed, search algorithm executed. node, uses mini-bucket functions
compiled look-ahead information. Subsection, show adapted
idea SL(n) integrated HYB.
C
R
Consider SL(n) formulated terms left, central right variables (xL
, xi , xi ).
L
C
R
exact elimination first row variables (x1 , x1 , x1 ) done using super-bucket
B1 = {f1L , f1R , f2L , f2R } computing function,
C
R
h1 = (f1L + f1R + f2L + f2R ) {xL
1 , x1 , x1 }
C
R L C
R
scope h1 {xL
2 , x2 , x2 , x3 , x3 , x3 }. Using mini-buckets idea, partition
L
L
L
R
bucket B1 = {f1 , f2 } B1 = {f1R , f2R }. Then, approximate h1 two smaller
R
functions hL
1 h1 ,
L
L
L C
hL
1 = (f1 + f2 ) {x1 , x1 }
R
R
C
R
hR
1 = (f1 + f2 ) {x1 , x1 }
R
L C
L C
C
R C
R
scopes hL
1 h1 {x2 , x2 , x3 , x3 } {x2 , x2 , x3 , x3 }, respectively.
idea repeated row row increasing order. general, processing row i, yields two
functions,
L
L
L C
hL
= (hi1 + fi+1 ) {xi , xi }
R
R
C
R
hR
= (hi1 + fi+1 ) {xi , xi }
R
L
C
L
C
C
R
C
R
scopes hL
hi {xi+1 , xi+1 , xi+2 , xi+2 } {xi+1 , xi+1 , xi+2 , xi+2 }, respecL
0
0
tively. construction, hi (a, , b, b ) contains cost best extension a, a0 , b, b0
C
L C
processed variables xL
, xi , . . . , x1 , x1 considering left functions only.
0
0
property hR
(a , a, b , b) right functions.
complexity MB space (n2n ) time (n2 21.5n ). Since complexities
smaller complexity HYB, running pre-process affect overall
complexity.
R
MB executed, HYB use information recorded hL
hi functions.
L
R
Consider arbitrary node HYB assigns xC
eliminates xi+2 xi+2 . Let
L
L
L (a, b)
b domain values variables xi xi+1 . Property 2 gi+2
contains best extension a, b attained left part rows + 1
n long current assignment X C maintained. Additionally,
C
C
hL
i1 (a, xi , b, xi+1 ) contains best extension a, b attained left part
L (a, b) + hL (a, xC , b, xC ) lower bound a, b X C
rows 1. Therefore, gi+2
i1

i+1
left part grid. Consequently,
L
C
C
mina,b[0..2 n2 1 1] {gi+2
(a, b) + hL
i1 (a, xi , b, xi+1 )}

433

fiLarrosa, Morancho & Niso

lower bound left part grid current assignment.
reasoning right part that,
L
C
C
mina,b[0..2 n2 1 1] {gi+2
(a, b) + hL
i1 (a, xi , b, xi+1 )} +
R
C
C
+mina,b[0..2 n2 1 1] {gi+2
(a, b) + hR
i1 (xi , a, xi+1 , b)}

lower bound current assignment.
4.2 Refining Upper Bound
efficiency algorithm depends initial value upper bound.
good upper bound facilitates pruning earlier search tree. Bosch Trick (2002)
suggested modify SL(n) adding additional constraint considering symmetric
patterns, only. Since space solutions becomes considerably smaller, problem
presumably simpler. Clearly, cost optimal symmetric stable pattern upper
bound optimal cost SL(n). observed upper bounds
tight.
Since motivation work use variable elimination techniques,
considered still-lifes symmetric vertical reflection,
efficiently solved using BE. symmetric still-life problem SSL(n) consists finding
n n stable pattern maximum density game life subject vertical reflection
symmetry (namely, state cells (i, j) (i, n j + 1) must same.6
Adapting solve SSL(n) extremely simple: need remove symmetrical
values domains. Let us assume n even number (the odd case similar).
represent symmetric sequences bits length n considering left side
sequence (i.e, first n/2 bits). right part implicit left part. Thus,
n
represent symmetrical sequences n bits integers interval [0..2 2 1]. Reversing
sequence bits noted a. Hence, sequence n/2 bits, corresponding
symmetrical sequence n bits.
complexity BE, applied SSL(n) time (n2 21.5n ) space (n2n ).
Therefore, executing prior HYB setting upper bound optimal cost
affect overall complexity hybrid.
4.3 Exploitation Symmetries
SL(n) highly symmetric problem. stable pattern, possible create
equivalent pattern by: (i) rotating board 90, 180 270 degrees, (ii) reflecting
board horizontally, vertically along one diagonal (iii) combination
rotations reflections.
Symmetries exploited different algorithmic levels. general,
save computation whose outcome equivalent previous computation due
symmetry kept outcome. instance, MB necessary compute
0
0
L
0
0
hR
(a , a, b , b) equal hi (a, , b, b ) due vertical reflection symmetry.
C
C
Another example occurs HYB. Let xn = vn , xC
n1 = vn1 , . . . , xi = vi current
6. Unlike Smiths (2002) work cannot easily exploit larger variety symmetries rotations
diagonal reflections.

434

fiOn practical use variable elimination

n
13
14
15
16
17
18
19
20
22
24
26
28

opt
79(90)
92(104)
106(119)
120(136)
137(152)
153(171)
171(190)
190(210)
?
?
?
?

opt-SSL
79
92
106
120
137
154
172
192
232
276
326
378

CP/IP
12050
5 105
7 105
*
*
*
*
*
*
*
*
*


13788
105
*
*
*
*
*
*
*
*
*
*

HYB
2
2
58
7
1091
2029
56027
2 105
*
*
*
*

HYB LB
2750
7400
2 105
6 105
*
*
*
*
*
*
*
*

HYB UB
2
3
61
49
2612
2311
56865
2 105
*
*
*
*

Figure 6: Experimental results three different algorithms still-life problem. Times
seconds.

C
C
assignment. reversed assignment xC
n = vn , xn1 = vn1 , . . . , xi = vi equivalent due
vertical reflection symmetry. Thus, already considered, algorithm
backtrack. implementation uses tricks others
report would require much lower level description algorithms.

5. Experimental Results
Figure 6 shows empirical performance hybrid algorithm. first column contains
problem size. second column contains optimal value number dead
cells (in parenthesis corresponding number living cells). third column contains
optimal value symmetrical problem SSL(n), obtained executing BE.
observed SSL(n) provides tight upper bounds SL(n). fourth column
reports time obtained CP/IP algorithm (Bosch & Trick, 2002). fifth
column reports times obtained BE. sixth column contains times obtained
hybrid algorithm HYB. seen, performance HYB spectacular.
n = 14 n = 15 instances, require several days CPU, solved HYB
seconds. Instances n = 18 solved less one hour. largest instance
solve n = 20, requires two days CPU (Figure 7 shows optimal
n = 19 n = 20 still-lifes). Regarding space, computer handle executions
HYB n = 22. However, neither n = 21 n = 22 instance could solved
within week CPU. may seem solving n = 20 instance petty progress
respect previous results problem. clearly case. search space
2
2
n = 15 n = 20 instances size 215 = 2225 220 = 2400 , respectively. Thus,
able solve problem search space 2175 times larger before.
Since scales regularly, accurately predict would require 4000 Gb
memory 7 centuries solve n = 20 instance.
435

fiLarrosa, Morancho & Niso

Figure 7: Maximum density still-lifes n = 19 n = 20.

Since HYB combines several techniques, interesting assess impact
one. seventh column reports times obtained HYB without using mini-buckets
information lower bound. seen, algorithm still better plain BE,
performance dramatically affected. information gathered preprocess
improves quality lower bound anticipates pruning. Finally, eighth column
reports times obtained HYB without upper bound initialized SSL(n).
case see importance technique quite limited. reason
HYB, even bad initial upper bound, finds optimum rapidly and,
moment, quality initial upper bound becomes irrelevant.

6. Extension Domains
SL(n) problem well defined structure, hybrid algorithm
proposed makes ad hoc exploitation it. easy find right variables
instantiate eliminate. easy find variable order mini buckets
produces good quality lower bounds. natural question whether possible apply
similar ideas well structured problems. answer often possible,
although need rely naive consequently less efficient exploitation
problems structure. Section support claim reporting additional experimental results different benchmarks. particular, consider spot5 DIMACS
instances. Spot5 instances optimization problems taken scheduling earth
observation satellite (Bensana, Lemaitre, & Verfaillie, 1999). DIMACS benchmark contains SAT instances several domain. Since concerned optimization tasks,
selected unsatisfiable instances solved Max-SAT task (i.e, given
unsatisfiable SAT instance, find maximum number clauses simultaneously
satisfied), modeled WCSP (de Givry, Larrosa, Meseguer, & Schiex, 2003).
consider aim instances (artificially generated random 3-SAT), pret (graph coloring), ssa
bf (circuit fault analysis).
Figure 8 shows constraint graph one instance domain, visualized
LEDA graph editor. observed graphs obvious pattern
436

fiOn practical use variable elimination

Figure 8: Constraint graph four WCSP instances. top-left corner, clockwise,
aim-100-1-6-no-1, pret60-25, ssa0432-003 Spot5-404.

exploited. Thus, use variable elimination techniques naive way.
solve problems generic WCSP solver toolbar7 (TB). performs depthfirst branch-and-bound search enhanced general-purpose dynamic variable
value ordering heuristics. modified toolbar combine search variable elimination
follows: arbitrary subproblem, every variable degree less 3 eliminated.
variables degree larger equal 3, unassigned variable
heuristically selected domain values heuristically ordered sequentially
instantiated. process recursively applied subproblems. Note
generic version HYB algorithm decision variables
instantiated variables eliminated left heuristic, instead establishing
7. Available http://carlit.toulouse.inra.fr/cgi-bin/awki.cgi/SoftCSP.

437

fiLarrosa, Morancho & Niso

hand. refer implementation TBHY B . Toolbar offers variety
lower bounds based different forms local consistency (Larrosa & Schiex, 2003).
One them, directional arc consistency (DAC*), essentially equivalent mini-buckets
size 2 and, therefore, similar spirit lower bound computed HYB. However,
unlike HYB mini-buckets executed pre-process, toolbar executes
DAC* every search state, subject current subproblem. shown Kask
(2000) approach generally efficient. main difference respect
HYB, toolbar executes DAC* subject arbitrary variable ordering (in HYB
good order identified problem structure). lower bounds available
toolbar node consistency (NC*) weaker DAC*, full directional
arc consistency (FDAC*) seen (stronger) refinement DAC*.
F DAC
B
experimented four algorithms: TBN C , TBDAC , TBDAC
HY B TBHY B ,
denotes algorithm lower bound B.
spot5 instances difficult toolbar. Therefore, decreased size
letting toolbar make sequence k greedy assignments driven default variable
value ordering heuristics. result subproblem k less variables.
following, Ik denotes instance k variables greedily assigned toolbar
default parameters.
Table 9 reports result experiments. first column indicates instances
subsequent columns indicate CPU time (in seconds) required different algorithms. time limit 3600 seconds set execution. observed
toolbar weakest lower bound (TBN C ) usually inefficient alternative.
cannot solve spot5 instances fails several aim ssa instances.
toolbar enhanced mini buckets lower bound (TBDAC ) spot5 problems
solved. domains, new lower bound produce significant effect. add variable elimination (TBDAC
HY B ) problems solved.
general, clear speed-up. worst improvements pret instances
time divided factor 2 best ones obtained spot5 50340
ssa7552-158 instances solved instantly. Typical speed-ups range 5 10.
DAC ) limited
Finally, observe addition stronger lower bound (TBFHY
B
effect problems. execution instance ssa7552-038 clearly accelerated.
Therefore, experiments conclude main techniques used
solve still-life problem successfully applied domains.

7. Conclusions
paper studied applicability variable elimination problem
finding still-lifes. Finding still-lifes challenging problem developing new solving
techniques interesting task per se. Thus, first contribution paper
observation plain variable elimination (i.e, BE) competitive practice provides
time complexity exponentially better search-based approaches. Besides, developed algorithm able solve n = 20 instance,
clearly improved previous results. second contribution paper
deeper insight. algorithm uses recent techniques based variable elimination.
Since techniques little known rarely applied constraints community,
438

fiOn practical use variable elimination

Problem
Spot5 4040
Spot5 408100
Spot5 412200
Spot5 414260
Spot5 50340
Spot5 505120
Spot5 507200
Spot5 509240
aim-100-1-6-no-1
aim-100-1-6-no-2
aim-100-1-6-no-3
aim-100-1-6-no-4
aim-100-2-0-no-1
aim-100-2-0-no-2
aim-100-2-0-no-3
aim-100-2-0-no-4
bf0432-007
pret60-25
pret60-40
ssa0432-003
ssa2670-141
ssa7552-038
ssa7552-158

BN C
2516
1191
1222
2162
110
110
22
-

BDAC
242
314
223
1533
546
3353
204
684
2007
931
850
1599
120
120
22
-

DAC
BHY
B
40
48
47
221
0
84
58
166
1665
707
1960
2716
830
479
319
738
1206
49
48
5
749
20
0

F DAC
BHY
B
40
43
42
139
0
84
42
121
1427
571
1627
2375
583
285
278
600
1312
56
56
5
767
2
1

Figure 9: Experimental results WCSP instances four different algorithms.
column reports CPU time seconds. Symbol - indicates time limit
3600 seconds reached.

results presented paper add new evidence potential. shown
variable elimination used beyond academic still-life problem providing
experimental results unstructured realistic problems different domains.

Acknowledgments
authors grateful Barbara Smith, Neil Yorke-Smith anonymous reviewers
useful comments different stages work reported article. Marti
Sanchez kindly made plots Figure 8. research funded Spanish
CICYT project TIC2002-04470-C03-01.

References
Bensana, E., Lemaitre, M., & Verfaillie, G. (1999). Earth observation satellite management.
Constraints, 4(3), 293299.
Bertele, U., & Brioschi, F. (1972). Nonserial Dynamic Programming. Academic Press.
439

fiLarrosa, Morancho & Niso

Bistarelli, S., Montanari, U., & Rossi, F. (1997). Semiring-based constraint satisfaction
optimization. Journal ACM, 44 (2), 201236.
Bosch, R., & Trick, M. (2002). Constraint programming hybrid formulations three
life designs. Proceedings International Workshop Integration AI
Techniques Constraint Programming Combinatorial Optimization Problems,
CP-AI-OR02, pp. 7791.
Cabon, B., de Givry, S., Lobjois, L., Schiex, T., & Warners, J. (1999). Radio link frequency
assignment. Constraints, 4, 7989.
de Givry, S., Larrosa, J., Meseguer, P., & Schiex, T. (2003). Solving max-sat weighted
csp. Proc. 9th CP, pp. 363376, Kinsale, Ireland. LNCS 2833. Springer
Verlag.
Dechter, R. (1999). Bucket elimination: unifying framework reasoning. Artificial
Intelligence, 113, 4185.
Dechter, R., & Pearl, J. (1989). Tree clustering constraint networks. Artificial Intelligence, 38, 353366.
Dechter, R., & Fatah, Y. E. (2001). Topological parameters time-space tradeoff. Artificial
Intelligence, 125 (12), 93118.
Dechter, R., & Rish, I. (2003). Mini-buckets: general scheme bounded inference.
Journal ACM, 50 (2), 107153.
Gardner, M. (1970). fantastic combinations john conways new solitary game. Scientific American, 223, 120123.
Kask, K. (2000). New search heuristics max-csp. Proc. 6th CP, pp. 262277,
Singapore. LNCS 1894. Springer Verlag.
Kask, K., & Dechter, R. (2001). general scheme automatic generation search
heuristics specification dependencies. Artificial Intelligence, 129, 91131.
Larrosa, J., & Dechter, R. (2003). Boosting search variable elimination constraint
optimization constraint satisfaction problems. Constraints, 8 (3), 303326.
Larrosa, J., & Schiex, T. (2003). quest best form local consistency
weighted csp. Proc. 18th IJCAI, Acapulco, Mexico.
Pearl, J. (1988). Probabilistic Inference Intelligent Systems. Networks Plausible Inference. Morgan Kaufmann, San Mateo, CA.
Sandholm, T. (1999). algorithm optimal winner determination combinatorial
auctions. IJCAI-99, pp. 542547.
Smith, B. (2002). dual graph translation problem life. Proc. CP-2002, pp.
01, Ithaca, USA. LNCS. Springer Verlag.

440


