Journal Artificial Intelligence Research 23 (2005) 667-726

Submitted 07/04; published 06/05

Keys, Nominals, Concrete Domains
Carsten Lutz

lutz@tcs.inf.tu-dresden.de

Theoretical Computer Science, TU Dresden
D-01062 Dresden, Germany

Carlos Areces

areces@loria.fr

INRIA Lorraine, Nancy
54602 Villers les Nancy Cedex, France

Ian Horrocks

horrocks@cs.man.ac.uk

Department Computer Science
University Manchester
Oxford Road, Manchester M13 9PL, UK

Ulrike Sattler

sattler@cs.man.ac.uk

Department Computer Science
University Manchester
Oxford Road, Manchester M13 9PL, UK

Abstract
Many description logics (DLs) combine knowledge representation abstract, logical
level interface concrete domains numbers strings built-in predicates <, +, prefix-of. hybrid DLs turned useful several
application areas, reasoning conceptual database models. propose
extend DLs key constraints allow expression statements
US citizens uniquely identified social security number. Based idea,
introduce number natural description logics perform detailed analysis
decidability computational complexity. turns naive extensions
key constraints easily lead undecidability, whereas careful extensions yield NExpTime-complete DLs variety useful concrete domains.

1. Motivation
Description logics (DLs) family formalisms allow representation
reasoning conceptual knowledge structured semantically well-understood
manner (Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003). central
entities representing knowledge concepts, constructed atomic
concept names (unary predicates) role names (binary relations) means concept
role constructors offered particular DL. example, basic propositionally
closed description logic ALC (Schmidt-Schau & Smolka, 1991), describe company
part-time employees full-time managers using concept
Company u employee.Parttime u employee.(Manager Parttime).
example, words beginning uppercase letters denote concept names
employee denotes role name.
c
2005
AI Access Foundation. rights reserved.

fiLutz, Areces, Horrocks, & Sattler

Rather viewed conceptual entities knowledge base, concepts
can, generally, understood central notion various kinds class-centered
formalisms. last decade, observation given rise various new challenging applications description logics reasoning database conceptual models
expressed entity-relationship diagrams object-oriented schemas (Calvanese, Lenzerini,
& Nardi, 1998; Calvanese, De Giacomo, & Lenzerini, 1998) reasoning ontologies
use semantic web (Baader, Horrocks, & Sattler, 2002a; Horrocks, 2002; Horrocks,
Patel-Schneider, & van Harmelen, 2002). new applications have, turn, stimulated
research description logics since expressive power existing DLs insufficient
new tasks. One important extension providing expressive means allow
integration numbers datatypes: suppose, example, want
extend earlier descriptions companies employees include founding year
company hiring year employee. Then, may want describe companies
founded 1970 state hiring year employees prior
founding year employing company. this, obviously need way talk
natural numbers (such 1970) comparisons natural numbers.
Nowadays, standard approach integrate datatypes description logics
extend DLs concrete domains, first proposed Baader Hanschke (1991a)
recently surveyed Lutz (2003). precisely, concrete domain consists set
(such natural numbers) predicates associated fixed extension
set1 (such unary =0 , binary <, ternary +). integration
concrete domains into, say, description logic ALC achieved adding
1. abstract features, i.e. functional roles;
2. concrete features, i.e. (partial) functions associating values concrete domain
(e.g., natural numbers) logical objects;
3. concrete domain-based concept constructor.
DL obtained extending ALC way called ALC(D), denotes
concrete domain viewed parameter logic. example, using
suitable concrete domain describe constraints formulated above: concept
Employee u employer.foundingyear.<1970 u hiringyear, (employer foundingyear).
describes set employees employed company founded 1970
hiring year prior companys founding year. example, term
foundingyear.<1970 instance concrete domain concept constructor (not
confused existential value restriction employee.Parttime), third
conjunct. <1970 unary predicate thus former instance takes one
concrete feature foundingyear argument, second instance uses binary predicate
requiring two arguments: concrete feature hiringyear sequence features
(employer foundingyear) consisting abstract feature employer concrete feature
foundingyear.
Concrete domains rather important many applications DLs, including two
mentioned above:
1. fixed extension predicates often called built-in.

668

fiKeys, Nominals Concrete Domains

standard way using description logics reasoning conceptual database
models translate given model DL representation use DL reasoner FaCT (Horrocks, 1998) RACER (Haarslev & Moller, 2001) compute
consequences information provided explicitly model. includes
detecting inconsistencies inferring additional, implicit containments entities/classes (Calvanese et al., 1998). Since databases store concrete data
numbers strings, constraints concerning data usually part
conceptual model thus captured description logic used
reasoning. Indeed, example concepts viewed DL encoding
constraints database companies employees. discussed
Lutz (2002c), description logics concrete domains well-suited conceptual modeling applications involving concrete datatypes.
So-called concrete datatypes play prominent role construction ontologies (Horrocks et al., 2002). Say, example, want construct ontology
used describing car dealers web pages web services.
ontology, concrete datatypes prices, manufacturing years, names car
models doubtlessly important. formulate ontology using DL,
need way represent concrete datatypes. Consequently, almost DLs
proposed ontology language equipped form concrete
domain (Fensel, van Harmelen, Horrocks, McGuinness, & Patel-Schneider, 2001; Horrocks et al., 2002; Dean, Connolly, van Harmelen, Hendler, Horrocks, McGuinness,
Patel-Schneider, & Stein, 2002). Furthermore, since ontology languages provide
inverse abstract roles functional restrictions, users ontology designers
quite surprised find provide inverse concrete functional
featureswhich due fact features correspond concrete key
constraints, reasoning algorithms known whose effect
decidability/complexity yet investigated.
paper, propose enhance expressive power description logics
concrete domains extending concrete key constraints. extension
useful knowledge representation two applications sketched above.
following three examples describe basic idea.
1. Suppose that, knowledge representation application, represent nationalities
concept names US German and, US citizens, store social
security number using concrete feature ssn. would natural state
US citizens uniquely identified social security number, i.e. two distinct
instances
Human u nationality.US
must different values ssn feature. extension DLs concrete
domains, expressed using key assertion 2
(ssn keyfor Human u nationality.US).
2. Readers familiar
Vrelationship DLs first order logic notice key assertion
equivalent x1 x2 .(( i{1,2} (Human(xi )z.(nationality(xi , z)US(z)))(x1 = x2 )) (ssn(x1 ) =
ssn(x2 ))).

669

fiLutz, Areces, Horrocks, & Sattler

2. Returning database companies employees, could useful
equip every employee (i) concrete feature branch storing branch-ID
working (ii) concrete feature id storing personnel-ID. would
natural enforce branch-ID together personnel-ID uniquely
identifies employees, even though personnel-IDs unique.
using composite key assertion
(branch, id keyfor Employee).
3. car dealers ontology, may assume cars well manufacturers
equipped identification numbers every car uniquely identified
combination identification number manufacturers one. express
this, could employ composite key assertion referring sequences features,
case (manufacturer id):
(id, (manufacturer id) keyfor Car).
formally, propose extend DLs provide concrete domains key boxes,
sets key assertions form
(u1 , . . . , un keyfor C),
ui sequence f1 fn g abstract features fj followed single concrete
feature g, C concept. examples illustrate, idea key constraints
natural. Since, moreover, keys play important role databases and, mentioned
above, reasoning database conceptual models important, challenging application
description logics, several approaches extend description logics keys already
investigated (Borgida & Weddell, 1997; Calvanese, De Giacomo, & Lenzerini, 2000;
Khizder, Toman, & Weddell, 2001). distinguishes approach existing ones,
however, idea using concrete domains constructing key constraints, rather
defining keys abstract, logical level.
goal paper provide comprehensive analysis effects decidability computational complexity adding key boxes description logics concrete
domains. end, extend two description logics ALC(D) SHOQ(D) key
boxes, way obtaining ALCK(D) SHOQK(D), respectively. basic DL
concrete domains ALC(D) already discussed above, SHOQ(D) proposed
ontology language (Horrocks & Sattler, 2001). provides wealth expressive
possibilities general concept inclusion axioms (GCIs), transitive roles, role hierarchies, nominals, qualifying number restrictions. Moreover, offers restricted variant
concrete domain constructor disallows use sequences features order
avoid undecidability reasoning. main outcome investigations key
constraints dramatic impact decidability complexity reasoning:
example, whereas satisfiability ALC(D)-concepts known PSpace-complete (Lutz,
2002b), show satisfiability ALCK(D)-concepts w.r.t. key boxes is, general,
undecidable. Decidability regained restrict concepts used key boxes
670

fiKeys, Nominals Concrete Domains

Boolean combinations concept names (Boolean key boxes). Interestingly, satisfiability ALCK(D)-concepts w.r.t. Boolean key boxes still NExpTime-complete even
simple concrete domains. case SHOQ(D) SHOQK(D), leap
complexity somewhat less dramatic since SHOQ(D)-concept satisfiability already ExpTime-complete: again, addition key boxes results NExpTime-complete reasoning
problems.
interesting note exists close connection key assertions
so-called nominals, i.e. concept names one instance,
Pope. Nominals standard means expressivity description logics sometimes
appear disguise one-of operator (Borgida & Patel-Schneider, 1994; Horrocks
et al., 2002). hard see key boxes simulate nominals: if, example,
use concrete domain based natural numbers providing unary predicates
=n equality n , key assertion (g keyfor >), > stands
logical truth, obviously makes concept g.=n behave nominal, n
. reason, consider ALCO(D), extension ALC(D) nominals,
ALCOK(D), extension ALCK(D) nominals.3 main result concerning
nominals that, although general lower expressive power key boxes,
already make reasoning NExpTime-hard combined concrete domains: exist
concrete domains ALCO(D)-concept satisfiability NExpTime-complete.
stress NExpTime-hardness results obtained
paper accordance observation made (Lutz, 2004) PSpace-upper
bound reasoning ALC(D) robust w.r.t. extensions logic: exist
several seemingly harmless extensions ALC(D) (for example acyclic TBoxes
inverse roles) make complexity reasoning leap PSpace-completeness
NExpTime-completeness many natural concrete domains.

N

N

remainder paper organized follows: Section 2, formally introduce
concrete domains, key boxes, DL ALCOK(D) together fragments ALCK(D)
ALCO(D). Moreover, define Boolean key boxes, allow Boolean combinations concept names appear key definitions. Additionally, introduce
important properties key boxes: path-free key boxes prohibit use sequences
features key assertions; unary key boxes, key assertion involves exactly one
sequence features; composite key boxes simply non-unary ones.
Section 3 devoted establishing lower bounds extensions ALC(D) key
boxes nominals. Section 3.1, use reduction Post Correspondence Problem
prove ALCK(D)-concept satisfiability w.r.t. (non-Boolean) key boxes undecidable
large class concrete domains. shift attention Boolean key boxes
since, Section 4, show restriction restores decidability. Section 3.2,
introduce NExpTime-complete variant domino problem three concrete
domains useful reduction problem concept satisfiability DLs
Boolean key boxes nominals. Section 3.3, use concrete domains
prove ALCK(D)-concept satisfiability w.r.t. Boolean, path-free unary key boxes
NExpTime-hard natural concrete domains. Section 3.4, prove
exist concrete domains ALCO(D)-concept satisfiability without reference
3. Note logic SHOQ(D) already provides nominals.

671

fiLutz, Areces, Horrocks, & Sattler

key boxes already NExpTime-hard; show true even concrete
domains computationally simple (PTime) considered isolation.
purpose Section 4 develop reasoning procedures description logics
key boxes prove upper complexity bounds matching NExpTime lower bounds
established previous section. start Section 4.1 tableau algorithm
decides ALCOK(D)-concept satisfiability w.r.t. Boolean key boxes, provided concrete domain key-admissible. Intuitively, concrete domain key-admissible
exists algorithm takes finite conjunction c predicates set
variables, decides whether conjunction satisfiable and, so, chooses solution c
returns information variables take values it. call
algorithm D-tester. chosen tableau algorithm since type reasoning
procedure potential implemented efficient reasoners shown
behave well practice (Horrocks, Sattler, & Tobies, 2000; Haarslev & Moller, 2001).
algorithm implies following upper complexity bound: key-admissible concrete
domain non-deterministic polynomial time D-tester exists, ALCO(D)concept satisfiability w.r.t. Boolean key boxes NExpTime.
Section 4.2, devise tableau algorithm SHOQK(D)-concept satisfiability
w.r.t. path-free key boxes might involve non-Boolean concepts. decidability
ALCOK(D), restricted key boxes Boolean ones. SHOQK(D), restriction possible since SHOQ(D) provides TBoxes, thus longer distinguish
Boolean non-Boolean concepts. hand, follows undecidability proof Baader Hanschke (1992) SHOQ(D) undecidable allow
sequences features concrete domain constructors. Thus restrict key assertions
analogously path-free ones, show yields indeed decidable logic. expressive power orthogonal one ALCOK(D), previous undecidability
results imply combination ALCOK(D) SHOQK(D) undecidable.
by-product correctness proof algorithm, obtain bounded model property SHOQK(D), implies SHOQK(D)-concept satisfiability w.r.t. path-free
key boxes NExpTime key-admissible concrete domain nondeterministic polynomial time D-tester exists.
Section 5, summarize results obtained give outlook possible future
research.

2. Description Logics Concrete Domains
following, introduce description logic ALCOK(D). Let us start defining
concrete domains:
Definition 2.1 (Concrete Domain). concrete domain pair (D , ),
set set predicate names. predicate name P associated
arity n n-ary predicate P nD .
Based concrete domains, define ALCOK(D)-concepts key boxes.
Definition 2.2 (ALCOK(D) Syntax). Let NC , , NR , NcF pairwise disjoint countably infinite sets concept names, nominals, role names, concrete features. Furthermore, assume NR contains countably infinite subset NaF abstract features.
672

fiKeys, Nominals Concrete Domains

path u composition f1 fn g n abstract features f1 , . . . , fn (n 0) concrete
feature g. Let concrete domain. set ALCOK(D)-concepts smallest set

every concept name every nominal concept,
C concepts, R role name, g concrete feature, u1 , . . . , un paths,
P predicate arity n, following expressions concepts:
C, C u D, C D, R.C, R.C, u1 , . . . , un .P, g.
key assertion expression
(u1 , . . . , uk keyfor C),
u1 , . . . , uk (k 1) paths C concept. finite set key assertions
called key box.
usual, use > abbreviation arbitrary propositional tautology,
abbreviation >, C abbreviation C D, C abbreviation
(C D) u (D C). Throughout paper, consider several fragments
description logic ALCOK(D). DL ALCO(D) obtained ALCOK(D)
admitting empty key boxes. particular, set ALCO(D)-concepts set
ALCOK(D)-concepts. Furthermore, disallowing use nominals, obtain
fragment ALC(D) ALCO(D) ALCK(D) ALCOK(D).
description logic ALCOK(D) equipped Tarski-style set-theoretic semantics.
Along semantics, introduce two standard inference problems: concept
satisfiability concept subsumption.
Definition 2.3 (ALCOK(D) Semantics). interpretation pair (I , ),
non-empty set, called domain, interpretation function. interpretation
function maps
concept name C subset C ,
nominal N singleton subset N ,
role name R subset RI ,
abstract feature f partial function f ,
concrete feature g partial function g .
673

fiLutz, Areces, Horrocks, & Sattler

u = f1 fn g path, uI (d) defined g (fnI (f1I (d)) ). interpretation
function extended arbitrary concepts follows:
(C)I := \ C
(C u D)I := C DI
(C D)I := C DI
(R.C)I := {d | e (d, e) RI e C }
(R.C)I := {d | e , (d, e) RI , e C }
(u1 , . . . , un .P )I := {d | x1 , . . . , xn : uIi (d) = xi (x1 , . . . , xn ) P }
(g)I := {d | g (d) undefined}.
Let interpretation. model concept C iff C 6= . Moreover,
satisfies key assertion (u1 , . . . , un keyfor C) if, a, b C ,
uI1 (a) = uI1 (b), . . . , uIn (a) = uIn (b) implies = b.
model key box K iff satisfies key assertions K. concept C satisfiable
w.r.t. key box K iff C K common model. C subsumed concept w.r.t.
key box K (written C vK D) iff C DI models K.
well-known that, description logics providing Boolean operators, subsumption
reduced (un)satisfiability vice versa: C vK iff C u unsatisfiable
w.r.t. K C satisfiable w.r.t. K iff C 6vK . allows us concentrate concept
satisfiability devising complexity bounds reasoning description logics: lower
upper complexity bounds concept satisfiability imply corresponding bounds
concept subsumptiononly complementary complexity class.
decision procedures description logics concrete domains devised
without committing particular concrete domain, well-defined interface
decision procedure concrete domain reasoner needed. Usually, interface
based assumption concrete domain admissible (Baader & Hanschke,
1991a; Lutz, 2002a, 2003):
Definition 2.4 (D-conjunction, Admissibility). Let concrete domain V set
variables. D-conjunction (finite) predicate conjunction form
^ (i)
c=
(x0 , . . . , x(i)
ni ) : Pi ,
i<k
(i)

Pi ni -ary predicate < k xj variables V. D-conjunction
c satisfiable iff exists function mapping variables c elements
(i)
(i)
((x0 ), . . . , (xni )) PiD < k. function called solution c.
say concrete domain admissible iff
1. contains unary predicate >D >D
= ;
2. closed negation, i.e., n-ary predicate P , predicate

P arity n P = nD \ P ;
674

fiKeys, Nominals Concrete Domains

3. satisfiability D-conjunctions decidable.
refer satisfiability D-conjunctions D-satisfiability.
shall see, sometimes makes considerable difference w.r.t. complexity decidability restrict key boxes various ways, example disallow paths length greater
one. Therefore, introduce useful notions.
Definition 2.5 (Boolean, Path-free, Simple). key box K called
Boolean concepts appearing (key assertions in) K Boolean combinations
concept names;
path-free if, key assertions (u1 , . . . , un keyfor C) K, u1 , . . . , un NcF ;
simple path-free Boolean;
unary key assertions K unary key assertions, i.e. form (u keyfor C).
concept C called path-free if, subconcepts form u1 , . . . , un .P , u1 , . . . , un
concrete features.
emphasize key box might necessarily Boolean path-free, sometimes
call key box general. Similarly, emphasize key box necessarily
unary key box, sometimes call key box composite.

3. Lower Bounds
section, prove lower complexity bounds description logics concrete domains key boxes and/or nominals. Section 3.1, start showing satisfiability ALCK(D)-concepts w.r.t. (general) key boxes undecidable many interesting
concrete domains. discouraging picture painted result mitigated fact
that, Section 4.1, shall prove restriction Boolean key boxes restores decidability. thus interesting look lower complexity bounds apply
restriction. preparation this, introduce Section 3.2 NExpTime-complete variant domino problem three concrete domains well-suited reductions
problem.
Section 3.3, prove satisfiability path-free ALCK(D)-concepts w.r.t.
simple key boxes NExpTime-hard large class concrete domains that,
many concrete domains, holds even restrict key boxes unary ones. Finally,
consider description logic ALCO(D) Section 3.4 identify several concrete
domains ALCO(D)-concept satisfiability (without key boxes!) NExpTimehard. already mentioned, key boxes nominals closely related: key boxes
express nominals, general powerful.
3.1 Undecidability ALCK(D) General Key Boxes
prove satisfiability ALCK(D)-concepts w.r.t. key boxes undecidable
large class concrete domains allow complex ALCK(D)-concepts occur key
assertions. proof reduction well-known undecidable Post Correspondence
Problem (Post, 1946; Hopcroft & Ullman, 1979).
675

fiLutz, Areces, Horrocks, & Sattler

Definition 3.1 (PCP). instance P Post Correspondence Problem (PCP) given
finite, non-empty list (`1 , r1 ), . . . , (`k , rk ) pairs words alphabet .
sequence integers i1 , . . . , im , 1, called solution P `i1 `im = ri1 rim .
PCP decide whether given instance P solution.
reducing PCP satisfiability DLs, need appropriate concrete
domain. obviously natural use concrete domain based words concatenation.
later see results obtained concrete domain carry
concrete domains based numbers arithmetics. following concrete domain
introduced Lutz (2004). definition presupposes fixed alphabet least
binary.
Definition 3.2 (Concrete domain W). concrete domain W defined setting W :=
defining W smallest set containing following predicates:
unary predicates word nword wordW = W nwordW = ,
W
+
unary predicates = 6= =W
= {} 6= = ,

binary equality predicate = binary inequality predicate 6= obvious
interpretation,
w + , two binary predicates concw nconcw
W
concW
w = {(u, v) | v = uw} nconcw = {(u, v) | v 6= uw}.

readily checked W satisfies properties 1 2 admissibility (see Definition 2.4).
Moreover, W-satisfiability decidable:
Theorem 3.1 (Lutz, 2004). W-satisfiability PTime.
Thus, W admissible even low complexity. important since aim
demonstrate undecidability ALCK(W)-concept satisfiability due
presence keys, due high complexity W-satisfiability.
discuss reduction PCP. given instance (`1 , r1 ), . . . , (`k , rk )
translated ALCK(D)-concept CP key box KP defined Figure 1
P solution iff CP unsatisfiable w.r.t. KP . idea behind reduction
common model CP KP encodes potential solutions P (i.e., sequences i1 , . . . ,
integers ij 1 k) makes sure none fact solution.
Figure 1, f1 , . . . , fk denote abstract features g, `, r denote concrete features.
definition concept Step serves abbreviation confused
so-called TBoxes (see Section 4.2 definition TBoxes). Models CP KP ,
one displayed Figure 2, form infinite k-ary tree whose root
connected extra node x via role R. Intuitively, node tree represents
one partial solution i1 , . . . , , `-successor represents corresponding left concatenation
`i1 `in , r-successor corresponding right concatenation ri1 rin .
enforce existence infinite tree, employ key box KP : consider
example root nodes f1 -successor Figure 2let us call node y. Due Line 3
676

fiKeys, Nominals Concrete Domains

Step :=

u f .(A u g.= u `, r.6=)
u u (`, f `.conc u r, f r.conc


1ik





1ik



`i

ri )

CP := `.= u r.=
u R.(A u g.= u Step)
u Step
KP := {g keyfor Step}
Figure 1: ALCK(W) reduction concept CP key box KP .
R
=

conc`1

`

r

=

x

fk

concrk

f1


g.=

concr1 conc`k
`
f1



r


fk

f1



r

`


fk



Figure 2: example model CP KP .
CP Line 1 Step, (g.= )I . Due Line 2 CP ,
x (g.= )I x (Step)I , x extra node mentioned above. view
key box KP , implies either (i) x = (ii) StepI . easy see
(i) impossible since Line 2 CP Line 1 Step imply x AI (A)I .
Hence StepI and, Line 2 Step, appropriate -successors 1 n.
way, construction tree continued ad infinitum. second
line definition Step enforces `I (z) = `i1 `in rI (z) = ri1 rin z
fi1 fin -successor root node. Finally, concept `, r.6= Line 1 Step implies
`I (z) 6= rI (z) holds nodes z tree (except root), implies
potential solution solution.
Since size CP KP clearly polynomial k key box KP unary
key box, obtain following proposition.
Proposition 3.2. satisfiability ALCK(W)-concepts w.r.t. (non-Boolean) path-free
unary key boxes undecidable.
677

fiLutz, Areces, Horrocks, & Sattler

emphasize undecidability result obtained using simple concrete
domain, let us combine Theorem 3.1 Proposition 3.2.
Theorem 3.3. exists concrete domain D-satisfiability PTime
satisfiability ALCK(D)-concepts w.r.t. (non-Boolean) path-free unary key boxes
undecidable.
first sight, concrete domain W might look artificial one may question relevance lower bounds obtained using W. However, straightforward
encode words natural numbers define concatenation words rather simple operations natural numbers (Baader & Hanschke, 1992): word w 6=
alphabet cardinality # interpreted number written base # + 1
symbol 0 digit occur. Hence, use corresponding natural number (e.g., base 10) represent word w, number 0
represent empty word. concatenation two words v w expressed
vw = v (#+1)|w| +w, |w| denotes length word w. Moreover, exponentiation expressed multiple multiplications, multiplication multiple additions,
addition multiple incrementation: shown Section 5.6 (Lutz, 2004)
case ALC(D) extended TBoxes (c.f. Section 4.2) easily adapted
ALC(D) non-Boolean key boxes. observation gives rise following theorem:

N

Theorem 3.4. Let concrete domain , contains unary predicate =0 (=0 )D = {0}, binary equality inequality predicates, binary predicate
incr incrD {(n, x) | n x } = {(k, k + 1) | k }. satisfiability
ALCK(D)-concepts w.r.t. (non-Boolean) path-free unary key boxes undecidable.

N

N

3.2 Domino Problems Concrete Domains
section, introduce NExpTime-complete variant well-known, undecidable
domino problem (Berger, 1966; Knuth, 1968), define three concrete domains D1 ,
D2 , D3 . concrete domains used Sections 3.3 3.4 establish
lower bounds reasoning ALCK(D) Boolean key boxes, reasoning
ALCO(D).
general, domino problem given finite set tile types. Intuitively, tile
types size, type square shape colored edges. unlimited
number tiles type available. NExpTime-hard variant domino
problem use, task tile 2n+1 2n+1 -torus (i.e., 2n+1 2n+1 -rectangle
whose borders glued together) neighboring edges color.

N

Definition 3.3 (Domino System). domino system triple (T, H, V ), (
finite set tile types H, V represent horizontal vertical matching
conditions. Let domino system = a0 , . . . , an1 initial condition, i.e.
n-tuple tiles. mapping : {0, . . . , 2n+1 1} {0, . . . , 2n+1 1} solution
iff, x, < 2n+1 , following holds:
(x, y) = (x 2n+1 1, y) = t0 , (t, t0 ) H
(x, y) = (x, 2n+1 1) = t0 , (t, t0 ) V
678

fiKeys, Nominals Concrete Domains

(i, 0) = ai < n.
denotes addition modulo i.
follows results (Borger, Gradel, & Gurevich, 1997) variant
domino problem NExpTime-complete.
define concrete domain D1 used reduction NExpTimecomplete domino problem ALCK(D1 )-concept satisfiability w.r.t. Boolean key boxes.
Definition 3.4 (Concrete Domain D1 ). concrete domain D1 defined setting
D1 := {0, 1} D1 (smallest) set containing following predicates:
unary predicates >D1 (>D1 )D1 = D1 D1 (D1 )D1 = ;
unary predicates =0 =1 (=i )D1 = {i}, {0, 1}.
second concrete domain D2 used reduction NExpTime-complete
domino problem ALCK(D2 )-concept satisfiability w.r.t. Boolean unary key boxes.
reduction need store vectors bits single concrete domain elements.

N

Definition 3.5 (Concrete Domain D2 ). every n , function v : {0, . . . , n 1}
{0, 1} called bit vector dimension n. use BVn denote theSset bit vectors
dimension n. concrete domain D2 defined setting D2 := i>0 BVi D2
(smallest) set containing following predicates:
unary predicates >D2 (>D2 )D2 = D2 D2 (D2 )D2 = ;
every k,

N < k, unary predicates bit0ik bit1ik
(bitnik )D2 = {v D2 | v BVk v(i) = n},

unary predicates bit0ik bit1ik (bitnik )D2 = D2 \ (bitnik )D2 .
last concrete domain D3 used reduction NExpTime-complete domino
problem ALCO(D3 )-concept satisfiability. reduction, concrete domain D3
contains two kinds elements: firstly, elements D3 represent
whole 2n+1 2n+1 -torus, so-called domino arrays. Secondly, elements D3
represent positions torus. technical reasons discussed later, elements
vectors natural numbers rather bit vectors, following shall call
vectors. domino array function mapping pair vectors (of certain
length) natural number represents tile type.

N

N

Definition 3.6 (Concrete Domain D3 ). every k , function v : {0, . . . , k 1}
called vector dimension k. use VEk denote set vectors dimension k.
every k , function k : VEk VEk
called domino array dimension k.
use DAk denote setSof domino
arrays
dimension k. concrete domain D3

defined setting D3 := i>0 VEi i>0 DAi D3 (smallest) set containing
following predicates:

N

N

unary predicates >D3 (>D3 )D3 = D3 D3 (D3 )D3 = ;
679

fiLutz, Areces, Horrocks, & Sattler

every k,

N < k, unary predicates pos0ik pos1ik
(posnik )D3 = {v D3 | v VEk v(i) = n}

unary predicates pos0ik pos1ik (posnik )D3 = D3 \ (posnik )D3 ;
every k,

N, predicate tileik arity 3

(tileik )D3 = {(vx , vy , d) | vx , vy VEk , DAk , d(vx , vy ) = i}
predicate tileik arity 3 (tileik )D3 = (D3 )3 \ (tileik )D3 .
reason using vectors natural numbers rather bit vectors definition
D3 want D3 -satisfiability low complexity, preferably PTime: consider
D3 -conjunction
pos002 (x) pos002 (y) pos002 (z)
tile72 (x, v, d) tile82 (y, v, d) tile92 (z, v, d).
use bit vectors rather vectors natural numbers, upper line enforces
least two three variables x, y, z must take value. Since
value v fixed, lower line makes conjunction unsatisfiable: tries assign
three different values 7, 8, 9 two different positions domino array. seems
unlikely kind inconsistency detected polynomial time. problem
circumvented using vectors natural numbers definition D3 (but enforcing
bit vectors reduction): case, conjunction clearly
satisfiable.
Proposition 3.5. {1, 2, 3}, concrete domain Di admissible satisfiability Di -conjunctions PTime.
D1 , trivial. D2 , proof found Appendix A. D3 , proof
found (Lutz, Areces, Horrocks, & Sattler, 2002).
3.3 NExpTime-hardness ALCK(D) Boolean Key Boxes
section, prove two NExpTime-lower bounds ALCK(D)-concept satisfiability
w.r.t. Boolean key boxes reducing NExpTime-complete domino problem introduced
previous section. first reduction uses simple concrete domain D1 ,
depends composite key assertions. second reduction uses slightly complex
concrete domain D2 , needs unary key assertions. see, two reductions
yield different, incomparable results.
first reduce NExpTime-complete domino problem ALCK(D1 )-concept satisfiability w.r.t. Boolean composite key boxes. domino system = (T, H, V ) initial
condition = a0 , . . . , an1 translated ALCK(D1 )-concept CD,a displayed
Figure 3. Names TreeX TreeY used abbreviations only. use Ri .C
abbreviation n-fold nesting R. R.C. names xposi yposi used
figure denote concrete features. definition Init concept, n , biti (n)

N

680

fiKeys, Nominals Concrete Domains

TreeX := R.X0 u R.X0 u

u R .(DistX


u R.Xi u R.Xi )

i1

i=1..n

TreeY := DistXn u R.Y0 u R.Y0 u

u R .(DistY u DistX u R.Y u R.Y )
DistX := u ((X R.X ) u (X R.X ))
DistY := u ((Y R.Y ) u (Y R.Y ))
TransXPos := u (X xpos . = ) u (X xpos . = )
TransYPos := u (Y ypos . = ) u (Y ypos . = )


i1

i=1..n

k

k



i=0..k

i=0..n











i=0..k



i=0..n

n













1



1



0





0



Succs := Rx .(TransXPos u TransYPos) u Ry .(TransXPos u TransYPos)

XSuccOk :=
(Yi Rx .Yi ) u (Yi Rx .Yi )
i=0..n


Xj (Xk Rx .Xk ) u (Xk Rx .Xk )

u
u u
u X (X R .X ) u (X R .X )

YSuccOk := u (X R .X ) u (X R .X )
u u (Y R .Y ) u (Y R .Y )
u (Y R .Y ) u (Y R .Y )
Label := u u (D u )
CheckMatch := (D u R .D ) u (D u R .D )

u X u u X u u
Init := u
k=0..n

j=0..k

k=0..n

j=0..k


i=0..n

j=0..k

k=0..n

j=0..k



(i,j)H

i=0..n1



j



k



j

j=0..n,bitj (i)=0

x

k





k

x

k



j

i,jT,i6=j



x

k



k=0..n



j

k



k

k



k

k



k

k

j

(i,j)V
j





j

j=0..n,bitj (i)=1

j

j=0..n

j



ai

CD,a := TreeX u Rn+1 .TreeY
u R2(n+1) .(TransXPos u TransYPos u Succs u XSuccOk u YSuccOk)
u R2(n+1) .(Label u CheckMatch u Init)
Figure 3: ALCK(D1 ) reduction concept CD,a .
supposed denote ith bit binary representation n. claim CD,a
satisfiable w.r.t. key box
{(xpos0 , . . . , xposn , ypos0 , . . . , yposn keyfor >)}
iff exists solution a. substantiate claim, let us go
reduction explain various parts concept CD,a . first step towards under681

fiLutz, Areces, Horrocks, & Sattler

standing structure models CD,a (which key understanding reduction
itself) note purpose first line CD,a enforce tree structure
depth 2(n + 1), whose leaves correspond positions 2n+1 2n+1 -torus.
precisely, TreeX concept guarantees that, every model CD,a , exists binary
tree depth n + 1. Moreover, DistXk concepts (there exists one k {0, . . . , n})
ensure leaves tree binarily numbered (from 0 2n+1 1) concept
names X0 , . . . , Xn . precisely, domain object , set

1 XiI
n

xpsn(d) = i=0 (d) 2 (d) =
0 otherwise.
TreeX DistX concepts ensure exist nodes d0 , . . . , d2n+1 1 level n + 1
tree xpsn(di ) = i. Intuitively, numbering represents horizontal
positions 2n+1 2n+1 -torus. vertical positions coded similar way
Y0 , . . . , Yn concept names. specifically, concepts TreeY, DistX, DistY ensure
every di (i 2n+1 1) root another tree, (i) every node
X0 , . . . , Xn -configuration root node, (ii) leaves numbered binarily
using concept names Y0 , . . . , Yn (note TreeY concept appears CD,a inside
Rn+1 value restriction). Define

1 YiI
n

ypsn(d) = i=0 (d) 2 (d) =
0 otherwise.
set leaf nodes trees enforced TreeY concept, exists,
i, j < 2n+1 , object4 ei,j xpsn(ei,j ) = ypsn(ei,j ) = j, i.e., ei,j
represents position (i, j) 2n+1 2n+1 -torus.
next step translate individual bits numbering ei,j -objects,
represented concept names, concrete domain values.
done TransXPos TransYPos concepts ensure that, ` n,
xposI` (ei,j ) = 0 ei,j X` , xposI` (ei,j ) = 1 ei,j X` , similarly ypos` Y` .
Since model key box
{(xpos0 , . . . , xposn , ypos0 , . . . , yposn keyfor >)},
grid positions uniquely represented domain elements (TransXPos u TransYPos)I ,
i.e., d, e (TransXPos u TransYPos)I xpsn(d) = xpsn(e) ypsn(d) = yxpsn(e),
= e. fact used concepts Succs, XSuccOk, YSuccOk enforce that,
two roles Rx Ry i, j n, following holds:
RxI ({ei,j } ) = {(ei,j , e(i2n+1 1),j }
RyI ({ei,j } ) = {(ei,j , ei,(j2n+1 1) }.

()

Succs concept ensures that, ei,j , exists Rx -successor Ry successor, (TransXPos u TransYPos)I . Let Rx -successor ei,j .
XSuccOk concept ensures xpsn(d) = 2n+1 1 ypsn(d) = j.
4. matter one object.

682

fiKeys, Nominals Concrete Domains

explain this, let us note that, since ei,j (TransXPos u TransYPos)I
grid positions uniquely represented elements (TransXPos u TransYPos)I ,
implies = e(i2n+1 1),j shows upper line () indeed hold.
Let us consider XSuccOk concept detail. essentially
DL-formulation well-known propositional formula
n k1
n k1
^
^
^
_
(
xj = 1) (xk = 1 x0k = 0)
(
xj = 0) (xk = x0k )
k=0 j=0

k=0 j=0

encodes incrementation modulo 2n+1 , i.e., number (binarily) encoded
propositional variables x0 , . . . , xn t0 number encoded propositional
variables x00 , . . . , x0n , t0 = + 1 modulo 2n+1 (see Borger et al., 1997). Taking
account Rx quantifiers XSuccOk, readily checked concept
desired effect: ensure that, every Rx -successor ei,j , xpsn(d) =
xpsn(e(i2n+1 1),j ) = 2n+1 1. explanation YSuccOk enforces lower
line () analogous XSuccOk case.
remains ensure every grid position labeled precisely one tile
initial condition well horizontal vertical matching conditions satisfied.
tiles represented concept names Di (where set tiles )
described tasks accomplished standard way concepts Label, Init,
CheckMatch.
worth noting reduction concept path-free key box simple,
i.e., path-free Boolean. Path-freeness concepts often used tame complexity
description logics concrete domains, although largely sacrifices expressive
power (Lutz, 2003; Baader, Lutz, Sturm, & Wolter, 2002b; Haarslev, Moller, & Wessel, 2001;
Horrocks & Sattler, 2001). example, ALC(D) augmented general TBoxes,
reasoning arbitrary concepts undecidable reasoning path-free concepts
ExpTime-complete admissible D-satisfiability ExpTime (Lutz, 2002a).
taming approach work presence key boxes since,
seen, satisfiability ALC(D)-concepts w.r.t. key boxes (under natural assumptions)
NExpTime-hard, even concept key box path-free.
Since size CD,a used key box clearly polynomial n, obtain
following proposition.
Proposition 3.6. satisfiability path-free ALCK(D1 )-concepts w.r.t. simple key boxes
NExpTime-hard.
shown (non path-free) ALC(D)-concept satisfiability PSpace-complete
D-satisfiability PSpace (Lutz, 2002b). Hence, follows Proposition 3.5
ALC(D1 )-concept satisfiability PSpace-complete. Thus, rather dramatic increase complexity key boxes added ALC(D1 ). stress increase due
key boxes complexity D1 -satisfiability, reformulate
Proposition 3.6:
Theorem 3.7. exists concrete domain D-satisfiability PTime
satisfiability path-free ALCK(D)-concepts w.r.t. simple key boxes NExpTime-hard.
683

fiLutz, Areces, Horrocks, & Sattler

Succs2 := Rx .TransPos u Ry .TransPos
TransPos :=

u
u

i=0..n
i=0..n


(Xi bv.bit1i2(n+1) ) u Xi bv.bit0i2(n+1) ) u

n+i+1
n+i+1
(Yi bv.bit12(n+1)
) u Yi bv.bit02(n+1)
)

CD,a := TreeX u Rn+1 .TreeY
u R2(n+1) .(TransPos u Succs2 u XSuccOk u YSuccOk)
u R2(n+1) .(Label u CheckMatch u Init)
Figure 4: ALCK(D2 ) reduction concept CD,a .
Although, due low expressivity, concrete domain D1 natural
knowledge representation, fragment many concrete domains
proposed literature (Baader & Hanschke, 1992; Haarslev & Moller, 2001; Lutz, 2003,
2002b). Indeed, presented reduction strategy adapted several standard
concrete domains. Let us formulate (very weak) condition concrete domain must
satisfy order presented reduction strategy applicable.
Theorem 3.8. Let concrete domain. exist a, b 6= b P1 , P2
P1D = {a} P2D = {b}, satisfiability path-free ALCK(D)-concepts
w.r.t. simple key boxes NExpTime-hard.
present second NExpTime-hardness result ALCK(D)-concept satisfiability.
time, reduce NExpTime-complete domino problem satisfiability pathfree ALCK(D2 )-concepts w.r.t. simple unary key boxes. reduction similar
previous one discuss differences.
first reduction, represented individual bits grid positions individual
concrete features xposi yposi used composite key box ensure point
torus represented one element. second reduction, use single
concrete feature bv represent entire position (i, j) torus using bit vector
concrete domain D2 . allows us enforce mentioned uniqueness
representations using unary key box.
modified reduction concept CD,a found Figure 4, concepts
TreeX, TreeY, DistXk , DistYk , XSuccOk, YSuccOk, Label, CheckMatch, Init defined
Figure 3. translation position torus encoded X0 , . . . , Xn , Y0 , . . . , Yn
bit vector done TransPos concept straightforward manner. Given
said first reduction, hard see CD,a satisfiable w.r.t. key
box {(bv keyfor >)} iff exists solution a. thus obtain following
proposition.
Proposition 3.9. satisfiability path-free ALCK(D2 )-concepts w.r.t. simple unary
key boxes NExpTime-hard.
Again, relate NExpTime lower bound complexity D2 -satisfiability,
determined Proposition 3.5.
684

fiKeys, Nominals Concrete Domains

Theorem 3.10. exists concrete domain D-satisfiability PTime
satisfiability path-free ALCK(D)-concepts w.r.t. simple unary key boxes NExpTime-hard.
Since elements D2 bit vectors, concrete domain D2 cannot considered
natural choice many application areas. But, reduction, D2 replaced
several natural concrete domains.
central observation use bit vectors injectively translate sequences
bits values concrete domain, i.e., translate sequences 2(n + 1) bits
(represented concept names X0 , . . . , Xn Y0 , . . . , Yn ) elements D2
that, distinct sequences, results translation distinct. Due
restricted use bit vectors, several ways replace natural numbers.
example, replace TransPos following concept TransPos0 ensures
that, TransPos0I , sI2n+1 (d) = xpsn(d) + 2n+1 ypsn(d):

u


TransPos0 := zero.=0 u
ti .=2i u (X0 s0 .=0 ) u (X0 s0 .=1 ) u
i=1...2n+1


Xi (si1 , zero, si ).+ u Xi (si1 , ti , si ).+ u
i=1..n



Yi(n+1) (si1 , zero, si ).+ u (Yi(n+1) (si1 , ti , si ).+

u
u

i=n+1..2n+1

N

zero, si , ti concrete features, =k (with k ) denotes unary predicate
obvious extension, + denotes ternary addition predicate that, intuitively,
first two arguments addends third one sum.

easy check that, whenever two objects d, e TransPos0 agree
interpretation X0 , . . . , Xn , Y0 , . . . , Yn , sI2n+1 (d) 6= sI2n+1 (e), thus key
box {(s2n+1 keyfor >)} used reduction. size TransPos0 obviously
polynomial n numbers k appearing =k predicates coded binary. thus
obtain following theorem:
Theorem 3.11. Let concrete domain
1.

N ,
N

2. contains, k , predicate =k (=k )D = {k} size (the
representation ) =k logarithmic k,
3. contains predicate + (+)D {(k1 , k2 , x) | k1 , k2
{(k1 , k2 , k1 + k2 ) | k1 , k2 }.

N

N x

} =

satisfiability path-free ALCK(D)-concepts w.r.t. simple unary key boxes
NExpTime-hard.
example, theorem yields NExpTime-lower bounds ALCK(D) instantiated
concrete domains proposed (Baader & Hanschke, 1992; Haarslev & Moller, 2001; Lutz,
2003, 2002b). alternative addition predicate use multiplication injectively
685

fiLutz, Areces, Horrocks, & Sattler

translate sequences bits natural numbers. precisely, let p1 , . . . , p2n+1
first 2n + 1 prime numbers define another version TransPos follows:
TransPos00 := one.=1 u

u
u

i=1..n

u


ti .=pi u (X0 s0 .=0 ) u (X0 s0 .=1 ) u
i=1...2n+1



Xi (si1 , one, si ). u Xi (si1 , ti , si ). u



Yi(n+1) (si1 , one, si ). u Yi(n+1) (si1 , ti , si ).

i=n+1..2n+1

ternary multiplication predicate.
Since factorization natural numbers prime numbers unique,
use key box {(s2n+1 keyfor >)} reduction. Moreover, well-known
kth prime polynomial k (Graham, Knuth, & Patashnik, 1990), thus size
concept TransPos00 polynomial n even numbers k =k predicates coded
unarily. thus obtain another theorem concerning quite natural concrete domains:
Theorem 3.12. Let concrete domain
1.

N ,

N, predicate =k (=k )D = {k},
3. contains predicate ()D {(k1 , k2 , x) | k1 , k2 N x
{(k1 , k2 , k1 k2 ) | k1 , k2 N}.
2. contains, k

} =

satisfiability path-free ALCK(D)-concepts w.r.t. simple unary key boxes
NExpTime-hard.
3.4 NExpTime-hardness ALCO(D)
already pointed Section 1, relationship key boxes nominals
rather close: latter simulated former concrete domain provides
predicates used uniquely describe elements . example, ALCK(D1 )
concept g.=0 behaves nominal use key assertion (g keyfor >).
even define n nominals using n single concrete features unary-key assertions.
logics ALCK(D2 ) ALCK(D3 ), single concrete feature unary key assertions
sufficient simulate arbitrary number nominals: example, ALCK(D2 )
concept C = g.bit002 u g.bit112 uniquely describes bit vector (0, 1) BV2 D2 , i.e.,
C implies g (a) = (0, 1). Obviously, bit vector (of length!)
described similar way.
illustrates that, non-trivial concrete domains D, logic ALCK(D)
(at least) expressive ALCO(D). Although converse hold, expressive
power ALCO(D) still sufficient prove NExpTime-hardness concept satisfiability,
provided suitable concrete domain used. Since ALCO concept satisfiability
PSpace-complete (Areces, Blackburn, & Marx, 1999), yet another example DL
even seemingly harmless extension concrete domains dramatic effect
computational complexity (Lutz, 2003).
686

fiKeys, Nominals Concrete Domains

Nominal := f.N
XSucc :=
YSucc :=

u u X (X X ) u u X (X X )
u u (Y ) u u (Y )

k=0..n

j=0..k

k=0..n

j=0..k

j

0
k

k

j

0
k

k

k=0..n

k=0..n

j

j=0..k

j=0..k

j

i=0..n


n+1

0



n+1

0



n+1

0



n+1

i,jV

u

i=0..n1


n+1



0


i,jH

Init2 :=


n+1




n+1



i=0..n

i=0..n


n+1



i=0..n



u

0
k

k

u (X bvx.pos1 ) u (X bvx.pos0 )

TransYPos := u (Y bvy.pos1
) u (Y bvy.pos0
)

TransXSucc := u (X bvxs.pos1
) u (X bvxs.pos0
)

TransYSucc := u (Y bvys.pos1
) u (Y bvys.pos0
)
CheckHMatch := ((bvx, bvy, f darr).tile
u (bvxs, bvy, f darr).tile
CheckVMatch := ((bvx, bvy, f darr).tile
u (bvx, bvys, f darr).tile
TransXPos :=

0
k

k


n+1

j
n+1 )


n+1

j
n+1 )

Xj u

u

u

Xj u
Yj
j=0..n
j=0..n,bitj (i)=0
j=0..n,bitj (i)=1


(bvx, bvy, f darr).tilean+1



CD,a := TreeX u Rn+1 .TreeY u R2(n+1) .Nominal u
R2(n+1) .(TransXPos u TransYPos u
XSucc u YSucc u TransXSucc u TransYSucc u
Init2 u CheckHMatch u CheckVMatch)
Figure 5: ALCO(D3 ) reduction concept CD,a .

section, reduce NExpTime-complete domino-problem ALCO(D3 )concept satisfiability. Again, let = (T, H, V ) domino system = a0 , . . . , an1
initial condition. modified reduction concept CD,a defined Figure 5, bvx,
bvy, bvxs, bvys, darr denote concrete features, N denotes nominal, concepts
TreeX, TreeY, DistXk , DistYk defined Figure 3. previous reductions,
give detailed explanation reduction strategy show CD,a satisfiable
iff exists solution a. Formal details easily worked
interested reader.
Let model CD,a . explain structure I, convenient start
first line CD,a . previous reductions, TreeX TreeY concepts
used ensure contains tree-shaped substructure depth n + 1 whose leaf
nodes roots additional trees depth n + 1 set leafs
687

fiLutz, Areces, Horrocks, & Sattler

TreeX

TreeY

...

TreeY

...

...

f

f

TreeY

...f

N
darr

Figure 6: structure models CD,a .
latter trees correspond positions 2n+1 2n+1 -torus, i.e., position,
leaf node representing it. torus positions binarily encoded concept
names X0 , . . . , Xn Y0 , . . . , Yn use ei,j refer leaf xpsn(ei,j ) =
ypsn(ei,j ) = j (see Section 3.3).
previous reductions, numbers coded X0 , . . . , Xn Y0 , . . . , Yn
translated concrete domain values, done TransXPos TransYPos
concepts. Note that, contrast ALCK(D2 )-reduction, x-position yposition stored bit vector, rather two distinct ones bvx
bvy. contrast previous reduction, actual tiling torus
represented leaf nodes ei,j , rather domino array: last conjunct
first line CD,a ensures every leaf ei,j connected via abstract feature f
(unique) element w N .
domain element w associated domino array via concrete feature darr (as
shall see later, guaranteed CheckHMatch CheckVMatch concepts).
domino array represents tiling 2n+1 2n+1 -torus. Summing up, structure
roughly shown Figure 6.
Since tiling stored domino array, need explain purpose leaf
nodes ei,j : nodes used enforce initial condition horizontal
vertical matching condition. Let us discuss horizontal matching condition (the vertical
matching condition enforced analogously): XSucc concept DL reformulation
propositional logic formula incrementation modulo 2n+1 ensures that,
ei,j , concept names X00 , . . . , Xn0 encode number 2n+1 1, i.e., horizontal
position ei,j horizontal neighbor. addition storage horizontal vertical
position ei,j bvx(ei,j ) bvy(ei,j ), store horizontal position i2n+1 1 ei,j
horizontal successor bvxs(ei,j ). Finally, CheckHMatch verifies tiles positions
688

fiKeys, Nominals Concrete Domains

(i, j) (i 2n+1 1, j), stored domino array, compatible
horizontal matching condition.
Note CheckHMatch ensures domain element w (with {w} = N )
domino array attached via concrete feature darr that, position (i, j),
(unique!) tile stored domino array set . initial condition ensured
via Init2 concept similar way. (again) use bitj (i) denote jth bit
binary encoding natural number i.
Using considerations, correctness reduction readily checked.
Moreover, size CD,a polynomial n. Note CD,a path-free:
paths length two appear concepts CheckHMatch, CheckVMatch, Init2. Summing
up, reduction described yields following result:
Proposition 3.13. satisfiability ALCO(D3 )-concepts NExpTime-hard.
Again, relate NExpTime lower bound complexity D3 -satisfiability,
determined Proposition 3.5.
Theorem 3.14. exists concrete domain D-satisfiability PTime
satisfiability ALCO(D)-concepts NExpTime-hard.
Note reduction uses single nominal N . dramatic increase complexity since shown satisfiability ALC(D)-concepts (i.e., without nominals
key boxes) PSpace-complete provided admissible D-satisfiability
PSpace (Lutz, 2002b).
previous sections, note D3 replaced natural concrete
domains NExpTime-hardness proof presented. idea represent whole
domino array single natural number use arithmetic operations access
individual positions: natural number k viewed domino array partitioning
binary representation 2n+1 2n+1 = 22(n+1) sections length dlog(#T )e,
#T denotes cardinality set tile types . section describes tile
single position torus. sections accessed using integer division
reminder operations: k natural number representing torus, tile
posisition computed
(k div 2idlog(#T )e ) mod 2dlog(#T )e + 1.
Thus, introduce ternary predicates div integer division mod computing
remainder division, binary predicate 2x expressing exponentiation basis 2.
modify reduction follows: replace TransXPos TransYPos
TransPos0 concept Section 3.3 translate two numbers encoded X1 , . . . , Xn
Y1 , . . . , Yn single natural number stored concrete feature s2n+1 .
devise new concept Tile[i] (for ) enforcing position identified
feature s2n+1 labeled tile i:
Tile[i] := r.=dlog(#T )e u s2n+1 , r, r0 . u r0 , r00 .2x u one.=1 u r, one, t.+ u t, t0 .2x
u f torus, r00 , u.div u u, t00 , tile.mod u tile.=i .
689

fiLutz, Areces, Horrocks, & Sattler

Here, r, r0 , r00 , t, t0 , u, one, torus, tile concrete features. torus feature counterpart darr feature original reduction, i.e., stores natural number
represents tiling array. use Tile[i] concept obvious way inside
CheckHMatch, CheckVMatch, Init2 concepts. size resulting reduction concept
polynomial n numbers k appearing =k predicates coded binary.
thus obtain following theorem:
Theorem 3.15. Let concrete domain
1.

N ,

2. contains predicates predicate =k (for k
following extensions
(2x )D

{(k, x) | k
(+)D {(k1 , k2 , x) | k1 , k2
()D {(k1 , k2 , x) | k1 , k2
(div)D {(k1 , k2 , x) | k1 , k2
(mod)D {(k1 , k2 , x) | k1 , k2







N
N
N
N
N

(=k )D
x }
x }
x }
x }
x }

=
=
=
=
=
=

N), 2x, +, , div, mod

{k}
{(k, 2k ) | k }
{(k1 , k2 , k1 + k2 ) | k1 , k2 }
{(k1 , k2 , k1 k2 ) | k1 , k2 }
{(k1 , k2 , k1 div k2 ) | k1 , k2 }
{(k1 , k2 , k1 mod k2 ) | k1 , k2 }

N

N
N
N
N

satisfiability ALCO(D)-concepts NExpTime-hard.

4. Reasoning Procedures
section devoted developing reasoning procedures DLs concrete domains,
nominals, keys. start devising tableau algorithm decides satisfiability
ALCOK(D)-concepts w.r.t. Boolean key boxes. algorithm yields NExpTime upper
complexity bound matching lower bounds established Section 3.3.
consider rather powerful description logic SHOQK(D). DL,
extension SHOQ(D) (Horrocks & Sattler, 2001; Pan & Horrocks, 2002), provides
wealth expressive means transitive roles, role hierarchies, nominals, qualifying
number restrictions. Moreover, SHOQK(D) equipped restricted variant
concrete domain constructor key boxes. develop tableau algorithm
deciding satisfiability SHOQK(D)-concepts w.r.t. path-free key boxes. Due
restrictedness SHOQK(D)s concrete domain constructor, even admit general
rather Boolean key boxes. Again, algorithm yields tight NExpTime upper
complexity bound.
4.1 Tableau Algorithm ALCOK(D) Boolean Key Boxes
Tableau algorithms decide satisfiability input concept (in case w.r.t. input
key box) attempting construct model it. precisely, tableau algorithm
starts initial data structure induced input concept repeatedly applies so-called completion rules it. rule application thought attempting
construct model input concept. Finally, either algorithm find obvious contradiction encounter situation contradiction-free
690

fiKeys, Nominals Concrete Domains

completion rules applicable. former case, input concept unsatisfiable,
satisfiable latter.
devising tableau algorithm description logic concrete domains
without committing particular concrete domain, commonly assumed concrete domain admissible, implies decidability satisfiability D-conjunctions.
presence keys, however, enough: D-conjunction satisfiable,
want know variables take values arbitrary fixed solution.
example, consider concrete domain N = ( , {<n | n }) N-conjunction

N

N

c = <2 (v1 ) <2 (v2 ) <2 (v3 ).
Obviously, one solution c satisfies (v1 ) = (v2 ), another satisfies (v1 ) = (v3 ),
on. tableau algorithm uses identity information passed concrete domain
reasoner since, presence key boxes, impact structure
constructed model. example, information reveals unsatisfiability
R.A u R.(A u B) u R.(A u B) u R.g.<2 w.r.t. (g keyfor >).
formalize requirement, strengthen notion admissibility key-admissibility.
Since tableau algorithm developed section non-deterministic, formulate keyadmissibility non-deterministic way.
Definition 4.1 (Key-admissible). concrete domain key-admissible iff satisfies
following properties:
1. contains name >D ;
2. closed negation;
3. exists algorithm takes input D-conjunction c, returns clash c
unsatisfiable, otherwise non-deterministically outputs equivalence relation
set variables V used c exists solution c
following property: v, v 0 V
(v) = (v 0 ) iff v v 0 .
algorithm showing behaviour described item 3 called D-tester,
equivalence relations called concrete equivalences. say extended Dsatisfiability NP exists D-tester running polynomial time.
Please note key-admissibility less esoteric might seem: concrete domain
admissible provides equality predicate key-admissible. Due
admissibility, presence equality predicate implies inequality predicate
available. thus construct D-tester algorithm D-satisfiability:
presented predicate conjunction c, simply guess equivalence relation
set variables
used c. VThen decide (non-extended) satisfiability
V
conjunction c vv0 =(v, v 0 ) v6v0 6=(v, v 0 ), return clash unsatisfiable
otherwise. rather weak condition equality predicate present
691

fiLutz, Areces, Horrocks, & Sattler

(C u D)
(R.C)

C (C D)
R.C
(R.C)

(u1 , . . . , un .P )
(g)

C u
R.C

C

C

u1 , . . . , un .P u1 un
g.>D

Figure 7: NNF rewrite rules.
satisfied almost concrete domains proposed literature (see, e.g. (Lutz, 2003;
Baader & Hanschke, 1991b; Kamp & Wache, 1996; Haarslev, Lutz, & Moller, 1998; Baader
& Sattler, 1998)).
Throughout chapter, assume concrete domain equipped
equality predicate. assumption w.l.o.g. since D-conjunction using equality
translated equivalent one without equality identifying variables according
stated equalities. assumption must confused discussed
previous paragraph: even concrete domain admissible set predicates
thus closed negation, assumption imply presence inequality
predicate.
need prerequisites start presentation tableau
algorithm: concept negation normal form (NNF) negation occurs front
concept names nominals. easily seen that, concrete domain admissible,
every ALCOK(D)-concept converted equivalent one NNF exhaustively applying rewrite rules displayed Figure 7. use C denote result
converting C NNF. key box NNF concepts occurring key assertions
NNF. follows, generally assume input concepts key boxes NNF.
Let C ALCOK(D)-concept K key box. use sub(C) denote set
subconcepts C (including C itself) con(K) denote set concepts appearing

right-hand side key assertions K. set concepts , sub() denotes
set C sub(C). Moreover, write cl(C, K) abbreviation set
sub(C) sub(con(K)) {D
| sub(con(K))}.
start presentation tableau algorithm introducing underlying data
structure.
Definition 4.2 (Completion System). Let Oa Oc disjoint countably infinite
sets abstract concrete nodes. completion tree ALCOK(D)-concept C
key box K finite, labeled tree = (Va , Vc , E, L) nodes Va Vc Va Oa ,
Vc Oc , nodes Vc leaves. tree labeled follows:
node Va labeled subset L(a) cl(C, K);
edge (a, b) E a, b Va labeled role name L(a, b) occurring C
K;
edge (a, x) E Va x Vc labeled concrete feature L(a, x)
occurring C K.
692

fiKeys, Nominals Concrete Domains

Va , use levT (a) denote depth occurs (starting
root node depth 0). completion system ALCOK(D)-concept C key box
K tuple (T, P, , ),
= (Va , Vc , E, L) completion tree C K,
P function mapping P arity n C subset Vcn ,
linear ordering Va levT (a) levT (b) implies b,
equivalence relation Vc .
Let (Va , Vc , E, L) completion tree. node b Va R-successor node Va
(a, b) E L(a, b) = R, node x Vc g-successor (a, x) E
L(a, x) = g. path u, notion u-successor defined obvious way.
Intuitively, relation records equalities concrete nodes found
(non-deterministic) model construction process. recording necessary since equalities concrete nodes induce equalities abstract nodes which, turn,
imply equalities concrete nodes. seen following example: assume completion tree contains, {1, 2}, abstract node ai
concrete g-successor xi concrete g 0 -successor yi . assume key box contains (g keyfor >), D-tester returns x1 x2 . consequence, a1 a2
represent element thus functionality g 0 implies y1 y2 represent
(concrete) element. deal effects, define equivalence relation
abstract nodes second equivalence relation c concrete nodes.
Definition 4.3 (a c Relations). Let = (T, P, , ) completion system
concept C key box K = (Va , Vc , E, L), let equivalence relation
Va . R NR , node b Va R/-neighbor node Va exists
node c Va c b R-successor c. Similarly, g NcF ,
node x Vc g/-neighbor exists node c Va c x
g-successor c. paths u, notion u/-neighbor defined obvious way.
define sequence equivalence relations 0a 1a Va follows:
0a = {(a, a) Va2 }
{(a, b) Va2 | N N L(a) L(b)}
i+1
= ia

{(a, b) Va2 | c Va f NaF
b f /ia -neighbors c}
{(a, b) Va2 | (u1 , . . . , un keyfor C) K,
ui /ia -neighbors xi 1 n,
ui /ia -neighbors yi b 1 n
C L(a) L(b) xi yi 1 n}.
Finally, set =




i0 .

define

c = {(x, y) Vc2 | Va g NcF
x g/a -neighbors a}.
693

fiLutz, Areces, Horrocks, & Sattler

definition reflects mentioned tight coupling concrete abstract equalities: D-tester finds (or guesses) two concrete nodes equal,
tableau algorithm may use deduce (via computation c ) even
equalities concrete nodes.
Let key-admissible concrete domain. decide satisfiability ALCOK(D)concept C0 w.r.t. Boolean key box K (both NNF), tableau algorithm started
initial completion tree
TC0 = ({a0 }, , , {a0 7 {C0 }})
initial completion system
SC0 = (TC0 , P , , ),
P maps P occurring C0 . introduce operation
used completion rules add new nodes completion trees.
Definition 4.4 (+ Operation). abstract concrete node called fresh completion tree appear T. Let = (T, P, , ) completion system
= (Va , Vc , E, L). use following notions:
Let Va , b Oa fresh T, R NR . write +aRb denote completion
system 0 obtained adding b Va (a, b) E setting
L(a, b) = R L(b) = . Moreover, b inserted b c implies
levT (b) levT (c).
Let Va , x Oc fresh g NcF . write +agx denote completion
system 0 obtained adding x Vc (a, x) E setting
L(a, x) = g.
nesting + operation, omit brackets, writing, example, + aR1 b + bR2 c
(S + aR1 b) + bR2 c. Let u = f1 fn g path. Va x Oc fresh T,
use + aux denote completion system obtained taking distinct
nodes b1 , . . . , bn Oa fresh setting
+ aux := + af1 b1 + + bn1 fn bn + bn gx.
Strictly speaking, + aRb operation non-deterministic since specify
precisely node b inserted . However, since dont care non-determinism,
view + operation deterministic.
completion rules found Figure 8. Note Rt Rch rules
non-deterministic, i.e., one possible outcome (this true dont know
non-determinism). remarks completion rules order: upper
five rules well-known existing tableau algorithms ALC(D)-concept satisfiability
(see, e.g., Lutz, 2002a). use R/ -neighbors u/ -neighbors rules
R, R, Rc deserves comment. Take example R: intuitively, b
two abstract nodes b completion tree, b describe
domain element constructed model (and similarly c relation concrete
694

fiKeys, Nominals Concrete Domains

Ru

C1 u C2 L(a) {C1 , C2 } 6 L(a)
L(a) := L(a) {C1 , C2 }

Rt

C1 C2 L(a) {C1 , C2 } L(a) =
L(a) := L(a) {C} C {C1 , C2 }

R

R.C L(a) R/a -neighbor b C L(b),
set := + aRb fresh b Oa L(b) := {C}

R

R.C L(a), b R/a -neighbor a, C
/ L(b)
set L(b) := L(b) {C}

Rc

u1 , . . . , un .P L(a) exist x1 , . . . , xn Vc
xi ui /a -neighbor 1 n (x1 , . . . , xn ) P(P )
set := (S + au1 x1 + + aun xn ) x1 , . . . , xn Oc fresh
P(P ) := P(P ) {(x1 , . . . , xn )}

Rch

(u1 , . . . , un keyfor C) K exist x1 , . . . , xn Vc
xi ui /a -neighbor 1 n {C, C}

L(a) =
set L(a) := L(a) {D} {C, C}


Rp

L(b) 6 L(a) Va minimal w.r.t. b
set L(a) := L(a) L(b)

Figure 8: Completion rules ALCOK(D).
nodes). Thus b c R-successor a, c R-successor
b. However, since want completion tree tree, make latter
successorship explicit. compensate this, R rule talks R/a -neighbors
rather R-successors.
lower two rules necessary dealing key boxes. Rch rule
so-called choose rule (Hollunder & Baader, 1991; Horrocks et al., 2000): intuitively,
guesses whether abstract node satisfies C exists key assertion
(u1 , . . . , un keyfor C) K neighbors paths ui .
necessary since possibilities may ramifications: satisfies C, must
taken account construction relation ; satisfy C,
must deal consequences satisfying C
(e.g. case C >).
Rp rule deals equalities abstract nodes recorded relation:
since b means b describe node constructed model,
node labels identical. suffices, however, choose one representative
equivalence class make sure representatives node label contains
labels -equivalent nodes. representative, use node minimal
w.r.t. ordering , introduced solely reason. Rp rule
appropriate copying node labels.
Let us formalize means completion system contain contradiction.
Definition 4.5 (Clash). Let = (T, P, , ) completion system concept C
key box K = (Va , Vc , , ). say completion system concrete
695

fiLutz, Areces, Horrocks, & Sattler

define procedure sat(S)

contains clash
return unsatisfiable
:= test(S )
compute
compute c
=
6 c
contains clash
return unsatisfiable
complete
return satisfiable
0
:= application completion rule
return sat(S 0 )
Figure 9: ALCOK(D) tableau algorithm.
domain satisfiable iff conjunction
^
=

^

P (x1 , . . . , xn )

P used C (x1 ,...,xn )P(P )

^

=(x, y)

xc

satisfiable. said contain clash iff
1. Va NC {A, A} L(a),
2. Va x Vc g L(a) x g/a -neighbor a,
3. concrete domain satisfiable.
contain clash, called clash-free. called complete iff completion
rule applicable S.
tableau algorithm described Figure 9 pseudo-code notation. figure, test
calls D-tester specified Definition 4.1. Let us say words loop.
obviously exist close relationships relations c predicate
conjunction :
c (note c depend thus recomputed
step loop);
definition D-tester, result test(S ) yields relation containing c
(and thus ).
Using facts, one may check that, step loop, new tuples added
relation, none deleted (see proof Lemma B.2 appendix).
loop needed (i) defined using , (ii), c defined using ,
696

fiKeys, Nominals Concrete Domains

(iii) new concrete equalities c may imply even concrete and/or abstract
equalities, on.
similar concrete-abstract interplay takes place course several recursion steps:
equalities concrete nodes provided D-tester may make new rules applicable
(for example Rp Rc) changes P thus . may subsequently lead
detection equalities concrete nodes D-tester, on.
considerations show that, presence keys, exists close interplay
concrete domain reasoner tableau algorithm, needed keys
present: without keys, suffices apply concrete domain satisfiability check
completion rules exhaustively applied (Baader & Hanschke, 1991a).
detailed proof termination, soundness, completeness together complexity analysis tableau algorithm defined section given Appendix B.
Theorem 4.1. Let key-admissible concrete domain. extended D-satisfiability
NP, ALCOK(D)-concept satisfiability w.r.t. Boolean key boxes NExpTime.
note that, way presented here, algorithm leaves considerable
room optimizations. One possible optimization concerns re-use f -successors
(for abstract features f ): example, applying R rule concept f.C L(a),
already f -successor b, could simply add C L(b) instead adding
new f -successor c recording b c.
Another candidate optimizations test function. Recall function takes
predicate conjunction c set variables V non-deterministically returns concrete
equivalence, i.e., relation exists solution c vi vj iff
(vi ) = (vj ) (see Definition 4.1). hard devise ALC(D)-concept forces
completion systems exponentially many concrete nodes slightly adapting wellknown ALC-concepts require models exponential size (Halpern & Moses, 1992).
Hence, size input conjunctions c test exponential size input
concept. Even trivial D-conjunctions
c = >D (v1 ) >D (vk )
exponential number distinct concrete equivalences . Thus, number
possible outcomes call test function may double exponential size
input concept. Considering example, natural response problem
require test return minimal concrete equivalences: intuitively, equivalence
minimal variables equivalent whose equality enforced conjunction.
precisely, called minimal exists concrete equivalence 0
{(x, y) | x 0 y} {(x, y) | x y}. conjecture restricting test way
destroy soundness completeness tableau algorithm. However, although
definitely worthwhile optimization, help overcome existence
doubly exponentially many outcomes test worst caseat least concrete
domains D: consider concrete domain N Page 691 conjunctions form
ci = <i (v1 ) <i (v2i ).
readily checked that, 1, number minimal concrete equivalences
ci exponential i. Moreover, hard devise concept Ci size logarithmic
697

fiLutz, Areces, Horrocks, & Sattler

leads completion systems = ci . Hence, still doubly
exponentially many possible outcomes test function.
example discussed, exponential branching test clearly due
discreteness natural numbers. Indeed, use dense structure defining concrete
domains, seems restriction minimal concrete equivalences desired
effect, namely number tests possible outcomes becomes polynomial size
input thus exponential size input concept. example, consider
concrete domain Q, defined follows:
Q set

Q rational numbers;

Q contains unary predicates >Q negation Q , unary predicates =q 6=q
q , binary comparison predicates {<, , =, 6=, , >}, ternary addition
predicate +, negation + (all obvious semantics).

Q

readily checked Q key-admissible (note provides binary equality predicate) thus falls framework. conjecture exists one minimal
concrete equivalence every Q-predicate conjunction c: intuitively, seems possible
(inductively) determine relation set variables V used c (i) x
implies (x) = (y) every solution c (ii) exists solution c
v 6 v 0 implies (v) 6= (v 0 ). Clearly, minimal concrete equivalence. Moreover,
due (i) one.
4.2 Tableau Algorithm SHOQK(D)
Although ALCOK(D) quite powerful DL, lacks several expressive means
found state-of-the-art description logic systems FaCT RACER (Horrocks,
1998; Horrocks et al., 2000; Haarslev & Moller, 2001). section, consider
expressive description logic SHOQK(D) provides concrete domains, key
boxes, nominals, many means expressivity transitive
roles, role hierarchies, qualifying number restrictions, general TBoxes. Modulo
details, SHOQK(D) viewed extension DL SHOQ(D) key boxes.
SHOQ(D) proposed Horrocks Sattler (2001) (see Pan & Horrocks, 2002)
tool ontology reasoning context semantic web (Berners-Lee, Hendler,
& Lassila, 2001; Baader et al., 2002a).
One important feature SHOQK(D) so-called TBoxes, i.e. concept equations5
.
form C = used background theory reasoning. Since wellknown combining general TBoxes concrete domain constructor easily leads
undecidability (Baader & Hanschke, 1992; Lutz, 2004), SHOQK(D) offers pathfree variant concrete domain constructori.e. concrete features admitted
inside constructor rather paths arbitrary length. restriction indeed regains
decidability (Haarslev et al., 2001; Horrocks & Sattler, 2001). Path-freeness concrete
domain constructor obviously renders abstract features unnecessary, thus syntactic
type available SHOQK(D).
5. TBox formalisms allow concept inclusions C v D, re-written
equivalent equations, see Section 2.2.2.5 (Baader et al., 2003).

698

fiKeys, Nominals Concrete Domains

4.2.1 Description Logic SHOQK(D)
Let us define SHOQK(D) formal way, starting syntax.
Definition 4.6 (SHOQK(D) Syntax). role axiom either role inclusion,
form R v R, NR , transitivity axiom Trans(R) R NR . role
box R finite set role axioms. Let v
* reflexive-transitive closure role
inclusions R. role name R called simple v
* R implies Trans(S)
/ R role
names S. Let concrete domain. set SHOQK(D)-concepts smallest set

every concept name every nominal concept,
C concepts, R role name, simple role name, n k natural
numbers, g1 , . . . , gn concrete features, P predicate arity n,
following expressions concepts:
C, C u D, C D, R.C, R.C, (> k C), (6 k C), g1 , . . . , gn .P, g1 .
.
concept equation expression C = C concepts. TBox finite set
concept equations.
SHOQK(D), consider key boxes differ two aspects ones considered ALCOK(D): following, assume key boxes path-free, admit
complex concepts occur key assertions. Note abstract features paths
occur syntax SHOQK(D)as become clear semantics
defined, former simulated general number restrictions (6 n R C).
usual description logics SHIQ/SHOQ family, require role names
number restrictions simple since admitting arbitrary roles yields undecidability
reasoning (Horrocks et al., 2000; Horrocks & Sattler, 2001). role box R clear
context, usually write Trans(R) instead Trans(R) R. introduce
semantics SHOQK(D) relevant reasoning problems.
Definition 4.7 (SHOQK(D) Semantics). Interpretations = (I , ) defined
Definition 2.3, function extended novel SHOQK(D)-concepts
follows:
(6 k R C)I := {d | ]{e | (d, e) RI } k}
(> k R C)I := {d | ]{e | (d, e) RI } k}.
.
Let interpretation. satisfies concept equation C = C = DI .
model TBox satisfies concept equations . Similarly, satisfies role
inclusion R v RI transitivity axiom Trans(R) RI transitive relation.
model role box R satisfies role inclusions transitivity axioms R.
Let TBox, R role box, K key box. concept C satisfiable w.r.t. ,
R, K iff C, , R, K common model. C subsumed concept w.r.t.
, R, K (written C vT ,R,K D) iff C DI common models , R, K.
699

fiLutz, Areces, Horrocks, & Sattler

Note that, due requirement role names used inside number restrictions
simple, existential universal value restrictions syntactic sugar: contrast
number restrictions, used roles.
well-known that, many expressive description logics, reasoning TBoxes
reduced reasoning without (Schild, 1991; Horrocks & Sattler, 2001):
SHOQK(D), concept C satisfiable w.r.t. , R, K iff concept
R.C u R.

u


DE u
.
D=ET

u

R.N



nominal N used
C, , K

satisfiable w.r.t. R0 , K, empty TBox, R fresh role appearing
C, R, ,
[
{S v R}.
R0 := R {Trans(R)}
role name used
C, , R, K

Since subsumption reduced satisfiability described Section 2, following
consider satisfiability concepts w.r.t. role boxes key boxes, without
TBoxes. generally assume role boxes R acyclic, i.e. satisfy following
condition: role name R, role names R1 , . . . , Rk R = R1 = Rk
Ri v Ri+1 R 1 < k. hard see restriction since
cycles eliminated: R1 , . . . , Rk cycle R, R1I = = RkI
interpretations I. Thus simply remove cycle R replace every
occurrence R2 , . . . , Rk C, R, K R1 , add Trans(R1 ) if, cycle
elimination, Trans(Ri ) 1 n.
turn attention construction tableau algorithm SHOQK(D),
let us comment minor differences SHOQK(D) introduced
original version SHOQ(D) described (Horrocks & Sattler, 2001). main
difference logic, extensions investigated (Haarslev et al., 2001; Pan &
Horrocks, 2002), allows n-ary predicates Horrocks Sattler restrict
unary predicates. Moreover, SHOQ(D) introduced (Horrocks & Sattler, 2001) uses
concrete roles rather concrete features, difference concrete roles
necessarily functional. Due non-functionality, original SHOQ(D) admits two
variants T.P T.P concrete domain constructor (where concrete role
P unary predicate). SHOQK(D), simulate universal variant writing
g.P g since concrete features g interpreted partial functions and, contrast
Horrocks Sattler, undefinedness constructor g available. Except
n-ary predicates provide important additional expressivity, view deviations
minor ones since easy see affect decidability complexity
reasoning.
4.2.2 Tableau Algorithm SHOQK(D)
basic intuitions SHOQK(D) tableau algorithm similar ALCOK(D)
algorithm, one exception: deal various expressive means SHOQK(D),
700

fiKeys, Nominals Concrete Domains

(> n R C)
(> 0 R C)
(6 n R C)

(6 (n 1) R C) n 1

(> (n + 1) R C)

Figure 10: SHOQK(D) NNF rewrite rules.
convenient introduce certain abstraction models, so-called tableaux. main
difference tableaux models that, tableaux, roles declared transitive
necessarily described transitive relations. show exists tableau
given concept key box common model. aim
SHOQK(D) algorithm construct tableau input rather trying
construct model. this, algorithm employs completion forests underlying
data structure.
first introduce tableaux. Let us start discussing preliminaries.
ALCOK(D), assume concepts key boxes NNF, i.e. negation occurs
front concept names nominals. use C denote NNF C.
additional NNF rewrite rules SHOQK(D) found Figure 10 complete
given ALCOK(D) Figure 7.
concept D, role box R, key box K, define
cl(D, K) := sub(D) sub(con(K)) {C
| C sub(D) sub(con(K))}
cl(D, R, K) := cl(D, K) {R.C | R v
* S.C cl(D, K)}.
Obviously, cardinality cl(D, R, K) linear size D, R, K.
D,K
denote set role names occurring D, R, K, NcF
follows, write ND,R,K
R
denote sets concrete features occurring K. ready define
tableaux.
Definition 4.8 (Tableau). Let SHOQK(D)-concept NNF, R role box, K
path-free key box NNF. tableau w.r.t. R K tuple (Sa , Sc , L, E, e, P)

Sa , Sc sets abstract concrete individuals,
L : Sa 2cl(D,R,K) maps abstract individual subset cl(D, R, K),
D,R,K

E : Sa Sa 2NR

maps pairs abstract individuals sets roles,

e : Sa ND,K
cF Sc maps pairs abstract individuals concrete features concrete
individuals,
P maps n-ary concrete predicate cl(D, R, K) set n-tuples Sc ,
abstract individual s0 Sa L(s0 ),
s, Sa , C, C1 , C2 cl(D, R, K), R, ND,R,K
,
R
(s, C) := {t Sa | E(s, t) C L(t)},
case that:
701

fiLutz, Areces, Horrocks, & Sattler

(T1) C L(s), C
/ L(s),
(T2) C1 u C2 L(s), C1 L(s) C2 L(s),
(T3) C1 C2 L(s), C1 L(s) C2 L(s),
(T4) R E(s, t) R v
* S, E(s, t),
(T5) R.C L(s) R E(s, t), C L(t),
(T6) R.C L(s), Sa R E(s, t) C L(t),
(T7) S.C L(s) R E(s, t) R v
* Trans(R), R.C L(t),
(T8) (> n C) L(s), ]S (s, C) > n,
(T9) (6 n C) L(s), ]S (s, C) 6 n,
(T10) either (6 n C) L(s) E(s, t) (g1 , . . . , gn keyfor C) K e(t, gi )
defined 1 n, {C, C} L(t) 6= ,
(T11) N L(s) L(t), = t,
(T12) g1 , . . . , gn .P L(s), x1 , . . . , xn Sc e(s, gi ) = xi
(x1 , . . . , xn ) P(P ),
V
V
V
(T13) P used D,K (x1 ,...,xn )P(P ) P (x1 , . . . , xn ) x6=y x 6= satisfiable,
(T14) (g1 , . . . , gn keyfor C) K, C L(s) L(t), e(s, gi ) = e(t, gi ) 1 n,
= t,
(T15) g L(s), e(s, g) undefined.
Note predicate conjunction (T13) uses binary inequality predicate. general,
require concrete domain equipped predicate thus
predicate conjunction necessarily D-conjunction. However, nevertheless safe
use (T13) given form since tableaux used proofs need
concrete domain reasoner capable deciding satisfiability conjunction.
following lemma, whose proof provided Appendix C, shows definition
tableaux provides adequate abstraction models.
Lemma 4.2. Let SHOQK(D)-concept NNF, R role box, K key box
NNF. satisfiable w.r.t. R K iff tableau w.r.t. R K.
Given Lemma 4.2, order decide satisfiability SHOQK(D)-concepts w.r.t. role
key boxes, may use (tableau) algorithm tries construct tableau input.
following, describe algorithm detail.
previous section, algorithm works completion systems. However,
case SHOQK(D) core component completion systems completion forest
rather completion tree. reason completion rules remove
nodes edges completion system way disconnect one tree
two subtrees.
702

fiKeys, Nominals Concrete Domains

Definition 4.9 (Completion System). Let SHOQK(D)-concept NNF, R role
box, K path-free key box NNF. concept (> n R C) cl(D, R, K)
1 n, reserve concept name AnRC
appearing cl(D, R, K) define

extended closure
nRc
cl+ (D, R, K) := cl(D, R, K) {AnRc
| (> n R C) cl(D, R, K)}.
1 , . . . ,

Let Oa Oc disjoint countably infinite sets abstract concrete nodes.
completion forest D, R, K finite forest F = (Va , Vc , E, L) nodes Va Vc
Va Oa , Vc Oc , nodes Vc leaves. forest labelled
follows:
node Va labelled subset L(a) cl+ (D, R, K),
edge (a, b) E a, b Va labeled non-empty set role names
L(a, b) occurring D, R, K,
edge (a, x) E Va x Vc labeled concrete feature L(a, x)
occurring D, R, K.
completion system D, R, K tuple = (F, P, c , )
F = (Va , Vc , E, L) completion forest D, R, K,
P maps n-ary concrete predicate cl(D, R, K) set n-tuples Vc ,
c equivalence relation Vc ,
linear ordering Va .
node Va called R-successor node Va if, R0 R0 v
* R,
R0 L(s, t). node x Vc called g-successor node Va L(s, x) = g. Finally,
.
write =
6 R-successors node AnRC
L(s)

nRC
Aj
L(t) 6= j.
remarks order here. Firstly, contrast ALCOK(D) case, relation
longer required respect level node. due fact (a)
enforce termination artificially mentioned property used
ensure automatic termination, (b) level node might change since node
might become root node completion rules remove nodes edges.
Secondly, relation c returned D-tester, used compute
relation used tableau algorithm. However, need
compute relation c ALCOK(D) case since concepts key
boxes assumed path-free.
Thirdly, new concept names AnRC
used ensure successors node

x generated (> n R C) L(x) merged later due concept (6
n0 R C 0 ) L(x): generated successor labelled different concept AnRC
;

since merging two nodes means unifying node labels, suffices disallow
703

fiLutz, Areces, Horrocks, & Sattler

occurrence distinct concepts AnRC
node label suitable definition

clash.
Since SHOQK(D) provides transitive roles, need cycle-detection mechanism
order guarantee termination algorithm: roughly speaking, encounter
node similar already existing one, node need
explored. Speaking terms (Horrocks et al., 2000; Baader & Sattler, 2000),
employ mechanism called subset blocking.
Definition 4.10 (Blocked). Let reflexive closure . node Va blocked
node Va L(t) L(s), s0 , s0 L(t) L(s0 ).
Note that, unlike done, e.g., (Horrocks et al., 2000), blocking node
necessarily ancestor blocked node, anywhere forest. may even
blocked nodes unblocked successors. modification used later obtain
NExpTime upper bound.
decide satisfiability ALCOK(D)-concept w.r.t. role box R pathfree key box K (where K NNF), tableau algorithm started
initial completion system
SD = (FD , P , , ),
FD = ({s0 }, , , {s0 7 {D}})
P
maps P occurring K .
algorithm repeatedly applies completion rules. actual rules given,
introduce new notions: firstly, define equivalence relation Va
follows: one following conditions satisfied:
N L(s) L(t) nominal N
(g1 . . . , gn keyfor C) K, C L(s)L(t), xi , yi gi E(s, xi )
E(t, yi ) xi c yi 1 n.
Intuitively, two abstract nodes related via relation describe individual
tableau.
Secondly, use following abbreviations formulation rules (written
italic):
remove abstract node incoming outgoing edges, remove
Va (s, t) (t, s) E Va Vc .
Adding g-successor abstract node means nothing exists
g-successor x Vc and, otherwise, adding E(s, x) = g x Oc
yet occur completion forest.
update relation c , D-tester asked decide satisfiability Dconjunction
^
^
:=
P (x1 , . . . , xn )
x=y
P used D,K
(x1 ,...,xn )P(P )

xc

returns, case conjunction satisfiable, updated concrete equivalence c defined Definition 4.1.
704

fiKeys, Nominals Concrete Domains

Concerning predicate conjunction used updates, recall w.l.o.g. assume
concrete domain contain equality predicate discussed Definition 4.1.
completion rules given Figure 11. generally assume new nodes x
introduced completion forest x already existing nodes y.
describing tableau algorithm, comment completion rules.
rules Rt, R6, Rc, Rch non-deterministic, i.e., application one
possible outcome. Rc rule, due update operation performed c
using D-tester: discussed end Section 4.1, computing concrete equivalence
given D-conjunction may result high degree non-determinism. Please note that,
contrast ALCOK(D), need call D-tester ruleand
rule application.
Next, Ra rule takes care abstract nodes related via . Since nodes
-equivalence class denote individual, choose one representative whose
node label contains labels nodes class. representative simply
-minimal node equivalence class Ra rule performs appropriate
copying node labels.
R6 rule rule remove nodes edges: removes surplus R-successor
node (6 n R C) L(s). Since subtree removed, ts successors
new, additional root nodes. behavior reason work completion
forest.
ALCOK(D) case, tableau algorithm stops applying rules finds
obvious contradiction, clash, completion rules applicable.
Definition 4.11 (Clash). Let = (F, P, c , ) completion system D, R K,
F = (Va , Vc , E, L). said contain clash one following conditions
applies:
(C1) concept name NC node Va , {A, A} L(s);
(C2) D-conjunction defined satisfiable;
.
(C3) =
6 Va ;
(C4) Va g NcF , g L(s) g-successor.
completion system containing clash called clash-free. completion system
complete none completion rules applicable.
Due simplicity algorithm, refrain describing pseudo-code notation: algorithm starts initial completion system repeatedly applies
completion rules, checking clashes rule application. clash detected, returns unsatisfiable. complete clash-free completion system found,
algorithm returns satisfiable. Note that, since completion rules
non-deterministic, algorithm non-deterministic.
Details proof termination, soundness, completeness given Appendix C. Unfortunately, leave complexity algorithm open
problem: hard prove runs double exponential time, clear
whether exponential time suffices. However, still use algorithm obtain
705

fiLutz, Areces, Horrocks, & Sattler

Ru

C1 u C2 L(s), blocked, {C1 , C2 } 6 L(s),
L(s) := L(s) {C1 , C2 }

Rt

C1 C2 L(s), blocked, {C1 , C2 } L(s) = ,
L(s) := L(s) {C} C {C1 , C2 }

R

R.C L(s), blocked, R-successor C L(t)
create new node t0 t0 Va
set E(s, t) := {R} L(t) := {C}

R>

(> n C) L(s), blocked, n S-successors
.
t1 , . . . , tn C L(ti ) ti =
6 tj 1 < j n,
create n new nodes t1 , . . . , tn s.t. t0 ti 1 n t0 Va ,
set E(s, ti ) := {S} L(ti ) := {C, AnSC
} 1 n


R6

(6 n C) L(s), blocked, n + 1 S-successors t0 , . . . , tn
C L(ti ) 0 n,
choose i, j ti tj , set L(ti ) := L(ti ) L(tj ),
L(s, ti ) := L(s, ti ) L(s, tj ), remove tj incoming
outgoing edges

Rc

g1 , . . . , gn .P L(s), blocked,
gi -successors xi (x1 , . . . , xn ) P(P )
add gi -successor 1 n,
yi gi -successor s, add (y1 , . . . , yn ) P(P ),
update c

R

R.C L(s), blocked,
R-successor C
/ L(t),
L(t) := L(t) {C}

R+

S.C L(s), blocked, R
Trans(R) R v
* S, R-successor R.C
/ L(t),
L(t) := L(t) {R.C}

Rch

S-successor s0 (6 n C) L(s0 )
gi -successors xi 1 n (g1 , . . . gn keyfor C) K
blocked {C, C} L(s) = ,
L(s) := L(s) {E} E {C, C}

Ra

t, L(t) 6 L(s), t, blocked,
set L(s) := L(s) L(t)
Figure 11: completion rules SHOQK(D).

706

fiKeys, Nominals Concrete Domains

tight complexity bound SHOQK(D): following corollary easy by-product
correctness proofs (for proof see Appendix C).
Corollary 4.3. SHOQK(D)-concept satisfiable w.r.t. role box R path-free
key box K, satisfiable w.r.t. R K model size |I | 2m
= # cl+ (D, R, K).
Thus following alternative algorithm deciding satisfiability SHOQK(D)concept w.r.t. role box R path-free key box K: first, guess interpretation
cardinality bounded 2m , using placeholder variables Oc instead
concrete values interpretation concrete features. Let Vc set variables
Oc occuring I. Additionally guess interpretation P concrete domain
predicates: completion forests, P maps n-ary concrete predicate used
K n-ary relation Vc . perform standard (polynomial-time) model checking
ensure model D. this, treat concepts form g1 , . . . , gn .P using
interpretation predicates P. easily checked polynomial time
model R Kfor latter, assume placeholder variables stand different
values. Finally, use concrete domain D-tester check whether conjunction
^
P (x1 , . . . , xn )
P used inD,K
(x1 ,...,xn )P(P )

satisfiable. Answer yes otherwise. Since algorithm clearly
implemented NExpTime provided D-tester running non-deterministic
polynomial time, obtain following:
Theorem 4.4. Let key-admissible concrete domain extended D-satisfiability
NP, SHOQK(D)-concept satisfiability w.r.t. TBoxes, role boxes, path-free
key boxes NExpTime.

5. Conclusion
paper, identified key constraints interesting extension description
logics concrete domains. Starting observation, introduced number
natural description logics provided comprehensive analysis decidability
complexity reasoning. main observation investigations key boxes
dramatic consequences complexity reasoning: example, PSpacecomplete DL ALC(D) becomes NExpTime-complete extended path-free, unary,
Boolean key boxes undecidable extended path-free, unary, non-Boolean key
boxes. Thus effect key boxes complexity quite different effect
key assertions abstract features allowed (Calvanese et al., 2000):
abstract key assertions said free since increase complexity
expressive description logics.
show restriction Boolean key boxes (in ALCOK(D) case)
path-free key boxes (in SHOQK(D) case) yield decidabile NExpTime-complete
reasoning problems. selected ALC(D) SHOQ(D) basis analysis since,
707

fiLutz, Areces, Horrocks, & Sattler

opinion, fundamental description logics concrete domains.
Going one step further, would interesting combine key boxes extensions
concrete domains, ones presented Lutz (2003, 2004). name one
possibility, extension ALCOK(D) SHOQ(D) inverse roles seems
natural idea. Note inverse roles interact several available means
expressivity: ALC inverse roles PSpace complete (Horrocks, Sattler, & Tobies,
1999), ALCO inverse roles ExpTime-complete (Areces et al., 1999) ALC(D)
inverse roles even NExpTime-complete (Lutz, 2004).
options future research closely related material presented
paper. example, SHOQK(D)-concept satisfiability still decidable drop
requirement key boxes path-free? Moreover, leave exact time
requirements tableau algorithm open problem. algorithm runs (nondeterministic) exponential time, directly yields Theorem 4.4 rather via bounded
model property.

Acknowledgments
would thank anonymous reviewers valuable comments. paper
extended version (Lutz, Areces, Horrocks, & Sattler, 2003).

Appendix A. Proofs Section 3.2
prove D2 -satisfiability decided PTime.
Proposition A.1. D2 -satisfiability PTime.
Proof. Let c D2 -conjunction. show c satisfiable iff none following
conditions applies:
1. c contains conjunct D2 (x);
2. c contains conjuncts bit0ik (x) bit1ik (x);
3. c contains conjuncts bitnik (x) bitmj` (x) k 6= `;
4. c contains conjuncts bitnik (x) bitnik (x);
5. c contains conjuncts bitnik (x), bit0jk (x), bit1jk (x).
easily seen c unsatisfiable one conditions applies. Assume
Conditions 1 5 apply c let X set variables used c.
x X, set t(x) = k bitnik (x) c n, .6 bitnik (x)
/ c n, i, k ,
set t(x) = r r appearing index r predicate c. mapping
well-defined since c finite, Condition 3 apply, predicates available
bitnik (), D2 (), >D2 (). define solution c follows: x X, set
(x) bit vector v BVt(x) ith bit 1 bit1it(x) (x) c bit0it(x) (x) c,
0 otherwise. remains prove indeed solution c:

N

6. use P (x) c abbreviation P (x) conjunct c.

708

N

fiKeys, Nominals Concrete Domains

Let bit0ik (x) c. t(x) = k thus (x) BVk . Since Condition 2
/ c. Moreover, non-applicability Condition 4 implies
apply, bit1ik (x)

/ c. definition , ith bit (x) thus 0.
bit0k (x)
Let bit1ik (x) c. t(x) = k (x) BVk . definition , ith bit
(x) 1.
Let bit0ik (x) c. t(x) 6= k, (x)
/ BVk . Thus (x) (bit0ik )D2
done. t(x) = k, ith bit (x) 1 definition thus
(x) (bit0ik )D2 .
/ BVk done. t(x) = k,
Let bit1ik (x) c. t(x) 6= k, (x)
j
bitnk (x) c n, j . Since Condition 5 apply, thus

N

/ c. Thus,

/ c. Moreover, non-applicability Condition 4 yields bit1ik (x)
definition , ith bit (x) 0.

bit0ik (x)

obvious listed properties checked polynomial time.

Appendix B. Proofs Section 4.1
prove termination, soundness, completeness ALCOK(D) tableau algorithm
presented Section 4.1, starting termination. start establishing notions
technical lemmas.
Let C concept K key box. use |C| denote
P length C, i.e.
number symbols used write down, |K| denote (u1 ,...,uk keyfor C)K |C|.
path u = f1 fk g, use |u| denote k + 1. role depth concepts defined
inductively follows:
rd(A) = rd(N ) = rd(g) = 0
rd(u1 , . . . , un .P ) = max{|ui | | 1 n} 1
rd(C u D) = rd(C D) = max{rd(C), rd(D)}
rd(R.C) = rd(R.C) = rd(C) + 1.
following series lemmas eventually allow us prove termination.
Lemma B.1. constant k that, tableau algorithm started input
C0 , K = (Va , Vc , E, L) completion tree constructed run algorithm,
k
k
#Va 2|C0 | #Vc 2|C0 | .
Proof. Using induction number rule applications case distinction according
applied rule, straightforward show
C L(a) implies rd(C) |C0 | levT (a)

()

constructed completion trees T. omit details note that, (1) treating
Rch rule, one needs employ fact K Boolean thus adds concepts
role depth 0 node labels, (2) treating Rp rule, use b implies
levT (a) levT (b).
709

fiLutz, Areces, Horrocks, & Sattler

implies upper bound depth constructed completion trees: first,
R Rc rules generate new nodes, application either rule node
Va implies L(a) 6= thus levT (a) |C0 | (). Second, new (abstract
concrete) node b generated application rules node Va clearly satisfies
levT (b) levT (a) + max(1, mpl(C0 )), mpl(C0 ) denotes maximum length paths
C0 (note concepts K may contain paths since Boolean). Since
mpl(C0 ) |C0 |, observations imply depth constructed completion
trees bounded 2 |C0 |.
out-degree. node generated, due application
rule R Rc and, initially, one successor. Let us analyze number
successors generated later applications rules R Rc a: rules
applied concept form R.C u1 , . . . , un .P L(a).
definition cl(C0 , K) since K Boolean, number concepts per node
label bounded #sub(C0 ) |C0 |. Moreover, rule application creates |C0 |
successors. Hence, out-degree constructed completion trees bounded |C0 |2 + 1.

Lemma B.2. constant k that, tableau algorithm started C0 , K,
k
then, every recursion step, loop terminates 2|C0 | steps.
Proof. Fix argument = (T, P, , ) = (Va , Vc , E, L) passed sat function,
let 1 , 2 , . . . sequence concrete equivalences computed loop, let
1c , 2c , . . . corresponding c relations. Since test(S ) calls D-tester,
calls indeed terminates.
show
1 ( 2 ( ,
()
k

implies Lemma B.2: Lemma B.1, exists constant k #Vc 2|C0 | .
k
Hence, #i 22|C0 | which, together (), implies number steps
k
performed loop bounded 22|C0 | .
proof (). loop reaches i-th step, i1 6= i1
c
step 1. Since i1 i1
definition, implies i1 ( ci1 . definition
c
, easy see i1
1. Hence i1 ( .
c
Lemma B.3. constant k that, tableau algorithm started C0 , K,
k
number recursive calls bounded 2(|C0 |+|K|) .
Proof. obviously suffices establish appropriate upper bound number rule
applications. Ru, Rt, R, Rc rules applied concept
node label. Lemma B.1, number nodes exponential |C0 | + |K|.
Since neither nodes concepts node labels ever deleted, fact node labels
subsets cl(C0 , K) thus implies number applications rules
exponential |C0 | + |K|. holds rules R Rp, applied
every concept C cl(C0 , K) every pair (abstract) nodes. Finally,
number Rch applications exponential |C0 | + |K| since rule
applied every abstract node every key assertion K.
710

fiKeys, Nominals Concrete Domains

Termination obvious consequence Lemmas B.2 B.3.
Corollary B.4 (Termination). tableau algorithm terminates input.
Let us prove soundness algorithm.
Lemma B.5 (Soundness). tableau algorithm returns satisfiable, input concept
C0 satisfiable w.r.t. input key box K.
Proof. tableau algorithm returns satisfiable, exists complete clashfree completion system = (T, P, , ) C0 . Let = (Va , Vc , E, L). definition
tableau algorithm, completion system 0 = (T, P, , 0 ) call
test(S 0 ) returned . Moreover, = c S. Thus, exists solution
0
(x) = (y) iff x c y.
()
0
Clearly, solution : since
^ second
^ component P ,
solution first part
P (x1 , . . . , xn ) . Moreover,
P used C (x1 ,...,xn )P(P )

conjunct =(x, y) second part , x c definition
thus (x) = (y) ().
use construct interpretation setting


= {a Va | b Va b b a} {w}

AI

= {a | L(a)}

{a | N L(a)} N L(a)
=
{w}
otherwise

NI
RI

= {(a, b) | a0 , b0 Va a0 , b b0 ,
b0 R-successor a0 }

gI

= {(a, (x)) | x g/a -neighbor a}

NC , N , R NR , g NcF . first show well-defined:
N singleton N . Assume exist a, b 6= b
N L(a) L(b). definition (Definition 4.3), N L(a) L(b) implies
b. This, together a, b , yields b b a, contradicting
linear ordering.
f functional f NaF . Assume exist a, b, c
{(a, b), (a, c)} f b 6= c. exist a1 , a2 , b0 , c0 Va a1
a2 , b b0 , c c0 , b0 f -successor a1 , c0 f -successor a2 .
definition , thus b0 c0 implying b c. Since b, c , yields
b c c b, contradiction.
g functional g NcF . Assume exist x, Vc
{(a, (x)), (a, (y))} f (x) 6= (y). x g/a neighbors a. definition c , thus x c implying (x) = (y) (),
contradiction.
711

fiLutz, Areces, Horrocks, & Sattler

show following claim. proof, use notion f1 fk /a -neighbors
(with f1 , . . . fk abstract features), defined analogously u/a -neighbors paths u.
Claim 1: paths u, uI (a) = iff ui / -neighbor
x (x) = .
Proof: Let u = f1 fk g. Using induction easily proved that,
b , fiI ( (f1I (a)) ) = b iff f1 /a -neighbor b0
b b0 . Thus particular fkI ( (f1I (a)) ) = b iff f1 fk /a neighbor b0 b b0 . prove claim, hence remains use definition
g together ().
following claim central showing model C0 K.
Claim 2: C cl(C0 , K), C L(a), C .
Since C0 label root node, Claim 2 clearly implies model C0 .
Moreover, use prove satisfies key assertions (u1 , . . . , un keyfor C)
K: fix a, b C uIi (a) = uIi (b) 1 n. Non-applicability Rch yields
{C, C} L(a) 6= . C L(a), Claim 2 implies ( C)I contradiction
C . Thus obtain C L(a). analogous way, argue C L(b). Since
uIi (a) uIi (b) defined 1 n, Claim 1 yields ui /a -neighbor xi
(xi ) = uIi (a) b ui /a -neighbor yi (yi ) = uIi (b) 1 n. Thus
fact uIi (a) = uIi (b) yields (xi ) = (yi ) 1 n. () obtain xi c yi
thus xi yi 1 n. definition , thus get b. Since a, b ,
obtain 6 b b 6 definition thus = b.
remains prove Claim 2, using structural induction:
C concept name nominal. Easy construction I.
C = D. Since C cl(C0 , K), C NNF concept name. Since
clash-free, C L(a) implies
/ L(a). Thus,
/ DI construction I,

yields (D) .
C = u1 , . . . , un .P . Since Rc rule applicable, exist x1 , . . . , xn Vc
xi ui /a -neighbor 1 n (x1 , . . . , xn ) P(P ). Claim 1
yields uIi (a) = (xi ) 1 n. Since (x1 , . . . , xn ) P(P ) solution
, ((x1 ), . . . , (xn )) P thus C .
C = g. Since clash-free, exists x Vc x g/a -neighbor
a. Thus Claim 1 (a, ) g .
C = u E C = E. Straightforward using completeness induction
hypothesis.
C = R.D. Since R rule applicable, R/a -neighbor b
L(b). Let b0 minimal w.r.t. b b0 . definition I,
(a, b0 ) RI . Non-applicability Rp rule yields L(b0 ). induction, get
b0 DI thus C .
712

fiKeys, Nominals Concrete Domains

C = R.D. Let (a, b) RI . definition I, implies exist a0 , b0 Va
minimal w.r.t. a0 , b minimal w.r.t. b b0 , b0
R-successor a0 . Since b0 clearly R/a -neighbor a, non-applicability
R yields L(b0 ), implies L(b) due non-applicability Rp.
induction, get b DI . Since holds independently choice b, obtain
(R.D)I .

Lemma B.6 (Completeness). input concept C0 satisfiable w.r.t. input key box
K, tableau algorithm returns satisfiable.
Proof. Let model C0 K. use guide (the non-deterministic parts
of) algorithm constructs complete clash-free completion system.
completion system = (T, P, , ) = (Va , Vc , E, L) called I-compatible
exist mappings : Va : Vc
(Ca) C L(a) (a) C
(Cb) b R-successor ((a), (b)) RI
(Cc) x g-successor g ((a)) = (x)
(Cd) (x1 , . . . , xn ) P(P ) ( (x1 ), . . . , (xn )) P
(Ce) x (x) = (y).
first establish following claim:
Claim 1: completion system I-compatible, (i) b implies (a) = (b)
(ii) x c implies (x) = (y).
Proof: show induction ia b implies (a) = (b) (see Definition 4.3),
yields (i).
Start. 0a b, exists nominal N N L(a) L(b). (Ca)
obtain (a) N (b) N , yields (a) = (b) definition
semantics.
Step. ia b, distinguish three cases:
1. i1
b, (a) = (b) induction.

2. c Va f NaF b f /i1
-neighbors
i1 c , f -successor
c. Hence, exist c1 , c2 Va c i1
c

1
2


c1 , b f -successor c2 . induction, (c) = (c1 ) = (c2 ).
Thus (Cb) yields {((c), (a)), ((c), (b))} f , implies (a) = (b)
definition semantics.
3. exist (u1 , . . . , un keyfor C) K, ui /ai1 -neighbors xi ui /ai1 neighbors yi b 1 n C L(a)L(b) xi yi 1 n.
(Ca) yields a, b C . Using induction, (Cb), (Cc), straightforward
713

fiLutz, Areces, Horrocks, & Sattler

show uIi ((a)) = (xi ) uIi ((b)) = (yi ) 1 n. (Ce),
implies uIi ((a)) = uIi ((b)) 1 k. Since model key box K,
yields (a) = (b) definition semantics.
Part (ii) Claim 1. x c y, either x Va g NcF
x g/a -neighbors a. former case, (Ce) yields (x) = (y).
latter case, Part (i) claim (Cc) yields {((a), (x)), ((a), (y))} g
implies (x) = (y). finishes proof Claim 1.
show completion rules applied I-compatibility
preserved.
Claim 2: completion system I-compatible rule R applicable S, R
applied I-compatible completion system 0 obtained.
Proof: Let I-compatible completion system, let functions satisfying
(Ca) (Ce), let R completion rule applicable S. make case distinction
according type R.
Ru rule applied concept C1 u C2 L(a). (Ca), C1 u C2 L(a) implies
(a) (C1 u C2 )I hence (a) C1I (a) C2I . Since rule adds C1
C2 L(a), yields completion system I-compatible via .
Rt rule applied C1 tC2 L(a). C1 tC2 L(a) implies (a) C1I (a) C2I .
Since rule adds either C1 C2 L(a), applied yields
completion system I-compatible via .
R rule applied concept R.C L(a), generates new R-successor b
sets L(b) = {C}. (Ca), (a) (R.C)I and, hence, exists
((a), d) RI C . Set 0 := {b 7 d}. readily checked
resulting completion system I-compatible via 0 .
R rule applied concept R.C L(a) adds C L(b) existing
R/a -neighbor b a. Hence, exists a0 a0 b Rsuccessor a0 . Part (i) Claim 1, (a) = (a0 ). Thus, (Ca)
(a0 ) (R.C)I (Cb) yields (((a0 ), (b)) RI . definition semantics,
(b) C thus resulting completion system I-compatible via .
(i)

(i)

Rc rule applied concept u1 , . . . , un .P L(a) ui = f1 fki gi
(i)

1 n. rule application generates new abstract nodes bj xj 1 n
1 j ki
(i)

(i)

(i)

(i)

b1 f1 -successor 1 n,
(i)

bj fj -successor bj1 1 n 2 j ki ,
(i)

xi gi -successor bki 1 n,
(x1 , . . . , xn ) P(P ).
714

fiKeys, Nominals Concrete Domains

(i)

(Ca), (a) (u1 , . . . , un .P )I . Hence, exist dj 1 n
1 j ki 1 , . . . , n
(i)

(i)

(i)

(i)

((a), d1 ) (f1 )I 1 n,
(i)

(dj1 , dj ) (fj )I 1 n 2 j ki ,
(i)

giI (dki ) = 1 n,
(1 , . . . , n ) P .


(i)
(i)
Set 0 := 1in 1jki {bj 7 dj } 0 := 1in {xi 7 }.
resulting completion system I-compatible via 0 0 .
Rch rule applied abstract node key assertion (u1 , . . . , un keyfor C)
K non-deterministically adds either C C. definition semantics,
(a) C (a) ( C)I . Hence, Rch applied resulting
completion system I-compatible via .
Rp rule applied concept C L(a) adds C label L(b) node b
b. (Ca), (a) C . Since Claim 1 yields (a) = (b), follows
resulting completion system I-compatible via .
Finally, show I-compatibility implies clash-freeness.
Claim 3: Every I-compatible completion system clash-free.
Proof: Let = (T, P, , ) I-compatible completion system. Consider three
kinds clash:
Due (Ca), clash form {A, A} L(a) clearly contradicts semantics.
Assume Va x Vc g L(a) x g/a -neighbor
a. exists b Va b x g-successor b. Claim 1,
b implies (a) = (b). Thus, g L(a) (Ca) give (b) (g)I . obtain
contradiction since (Cc) yields ((b), (x)) g .
Properties (Cd) (Ce) Part (ii) Claim 1 imply solution .
Thus, concrete domain satisfiable.
describe guidance tableau algorithm model detail:
ensure that, times, considered completion systems I-compatible.
obviously holds initial completion system
SC0 = (TC0 , P , , ) TC0 = ({a0 }, , , {a0 7 {C}}).
guide non-deterministic test function that, given predicate conjunction
set variables Vc Oc input, returns relation defined setting x
iff (x) = (y) x, V . relation concrete equivalence since solution
(see above). guidance, (Ce) obviously satisfied call test,
properties affected call. According Claim 2, apply
715

fiLutz, Areces, Horrocks, & Sattler

completion rules I-compatibility preserved. Corollary B.4, algorithm
always terminates, hence guided way. Since, Claim 3, find
clash, algorithm returns satisfiable.
tableau algorithm yields decidability tight upper complexity bound ALCOK(D)concept satisfiability w.r.t. key boxes.
Theorem B.7 (Theorem 4.1 Section 4.1). Let key-admissible concrete domain.
extended D-satisfiability NP, ALCOK(D)-concept satisfiability w.r.t. Boolean
key boxes NExpTime.
Proof. Corollary B.4 Lemmas B.5 B.6 yield decidability ALCOK(D)-concept
satisfiability w.r.t. Boolean key boxes. complexity, Lemma B.3 provides exponential
bound number recursive calls. Hence, remains show single recursion
step needs exponential time. Lemma B.2, loop terminates
exponentially many steps. step, compute relations c ,
used construction predicate conjunction checking termination
loop. Since, Lemma B.1, exists exponential bound number
abstract concrete nodes completion system S, obviously done
exponential time. Moreover, Lemma B.1 implies size exponential.
together fact extended D-satisfiability NP implies call
test needs exponential time. remaining tasks (checking clashes, completeness,
rule applicability) clearly performed exponential time.

Appendix C. Proofs Section 4.2
first provide proof Lemma 4.2 shows notion tableaux introduced
Section 4.2 adequate abstraction models.
Lemma C.1 (Lemma 4.2 Section 4.2). Let SHOQK(D)-concept NNF, R
role box, K path-free key box NNF. satisfiable w.r.t. R K iff
tableau w.r.t. R K.
Proof. only-if direction, construct tableau common model D,
R, K follows:
Sa :=
Sc := {x | g (s) = x Sa }
L(s) := {C cl(D, R, K) | C }
E(s, t) := {S ND,R,K
| (s, t) }
R
e(s, g) := g (s) g (s) defined
P(P ) := {(x1 , . . . , xn ) Snc | (x1 , . . . , xn ) P }.
easily verified tableau w.r.t. R K: proof satisfies
(T1) (T9) identical corresponding cases (Horrocks et al., 2000; Horrocks &
Sattler, 2001); (T10) holds definition L; (T11) definition L fact
nominals interpreted singleton sets; (T12) definition L, e, P together
716

fiKeys, Nominals Concrete Domains

semantics concepts g1 , . . . , gn .P ; (T13) since identity function Sc clearly
solution listed predicate conjunction; (T14) definition L e together
semantics key constraints; finally (T15) definition L e together
semantics concepts g.
direction, let = (Sa , Sc , L, E, e, P) tableau w.r.t. R K
let solution predicate conjunction (T13). construct model
follows:


:= Sa

AI

:= {s | L(s)}

concept names

NI

:= {s | N L(s)} nominals N
(

R NR \ NcF Trans(R)
v
* R {(s, t) | R E(s, t)}

S6=R
R :=
{(s, t) | R E(s, t)}+
R NR \ NcF Trans(R)

(x)
e(s, g) = x
g (s) :=
g NcF .
undefined e(s, g) undefined
Due (T11), interpretation nominals singleton. Moreover, interpretation
roles well-defined since role boxes acyclic. following claim central proving
indeed model D, R, K:
Claim: C cl(D, R, K), C L(s) implies C .
Proof: proceed induction norm ||C|| C, defined follows:
||A||
||g||
||C1 u C2 ||
||(> n R C)||

:=
:=
:=
:=

||A||
||u1 , . . . , un .P ||
||C1 C2 ||
||(6 n R C)||

:=
:=
:=
:=

0 concept name
0
1 + ||C1 || + ||C2 ||
1 + ||C||

concept names nominals N , claim follows definition AI N .
negation concept names nominals N (note C NNF), claim follows
definition AI N together (T1). Concepts C form C1 u C2 C1 C2
treated using (T2) (T3) together induction hypothesis. existential,
universal, number restrictions, proof analogous one SHIQ (Horrocks
et al., 2000). concepts form C = g1 , . . . gn .P L(s), C immediate
consequence (T12), definition giI , fact (x1 , . . . , xn ) P(P ) implies
((x1 ), . . . , (xn )) P (T13). Finally, concepts C = g, C immediate
consequence definition g together (T15). finishes proof
claim.
definition tableaux, exists s0 Sa C L(s0 ). claim,
s0 C thus model C.
Next, show model R. definition RI , obvious Trans(R)
R implies RI transitive relation. let v R R. Trans(R)
/ R,
RI definition RI . let Trans(R) R (s, t) . E(s, t),
(T4) implies R E(s, t), thus (s, t) RI . Otherwise, 0 v
*
Trans(S 0 ) R (s, t) {(u, v) | 0 E(u, v)}+ . (T4) together 0 v
* R implies
717

fiLutz, Areces, Horrocks, & Sattler

{(u, v) | 0 E(u, v)} {(u, v) | R E(u, v)}, thus Trans(R) R implies
(s, t) RI .
remains show model K. end, let (g1 , . . . , gn keyfor C) K
s, C giI (s) = giI (t) 1 n. Since predicate conjunction
(T13) contains explicit inequalities distinct concrete individuals, implies
e(s, gi ) = e(t, gi ) 1 n. (T10) implies {C, C} L(s) 6= {C, C} L(t) 6= .
C L(s), claim yields ( C)I contradicting C . Thus obtain
C L(s) and, similar way, C L(t). Finally, (T14) implies = t, thus
satisfies K.
proceed prove termination, soundness, completeness tableau algorithm
presented Section 4.2, starting termination. following, use |D, R, K|
denote | cl+ (D, R, K)|. Recall number polynomial size D, R, K.
Lemma C.2 (Termination). Let key-admissible concrete domain. started
SHOQK(D) concept NNF, role box R, path-free key box K NNF,
tableau algorithm terminates.
Proof. Assume D, R, K tableau algorithm terminate. Since key-admissible, means infinite sequence S0 , S1 , . . .
completion systems (a) S0 initial completion system SD (b) Si+1
result applying completion rule Si .
possible R R> rules applied infinitely often: easily seen
rules Ru, Rt, R6, Rc, R, R+ , Rch, Ra applied finitely often
completion systems whose set abstract nodes Va increase since either
add concepts node labels (whose size bounded), add concrete nodes (whose
number bounded linearly number abstract nodes), remove abstract
nodes forest. Hence sub-sequence Si1 , Si2 , . . . S0 , S1 , . . .
Sij result applying R R> rule Sij 1 . Let si` abstract node
R R> rule applied Si` 1 . Since implies
generated s, linear ordering well-founded. Thus, find infinite subsequence Sj1 , Sj2 , . . . Si1 , Si2 , . . . either sj` = sj`+1 ` 1 sj` sj`+1
` 1. former, however, possible since R R> rules
applied per node concept cl(D, R, K): even node removed,
label copying performed R6 rule together clashes type (C3) ensures
R> rule re-applied concept node. Thus second option
remains: subsequence Sj1 , Sj2 , . . . Si1 , Si2 , . . . sj` sj`+1
` 1. Let Lj labeling function Sj . Since abstract node labeled
subset Lj cl+ (D, R, K), nodes sjk sj` k ` Ljk (sjk ) = Lj` (sj` ).
node labels increase and, node removed, label conjoined
label node t. Thus node completion system Sj`
sj` Lj` (sj` ) Lj` (t). definition, sj` thus blocked Sj` , contradicting
assumption R R> rule applied sj` Sj` .
Lemma C.3 (Soundness). expansion rules applied SHOQK(D) concept
NNF, role box R, path-free key box K yield complete
clash-free completion forest, tableau w.r.t. R K.
718

fiKeys, Nominals Concrete Domains

Proof. Let = ((Va , Vc , E, L), P, c , ) complete clash-free completion system.
find solution (x) = (y) iff x c y: Rc rule updates
predicate conjunction , rule application c relation updated
using concrete equivalence D-tester returns (note satisfiable due
clash-freeness). According Definition 4.1, thus find solution required.
, define finite tableau = (Sa , Sc , E, L, P) follows:
Sa := {s Va | occurs blocked}
Sc := {(x) | (s, x) E(g) Sa g}
L(s) := L(s) cl(D, R, K) (the intersection due auxiliary concepts AnRC
),

E(s, t) := {R | R-successor blocks R-successor t0 s}

(x)
x g-successor
e(s, g) :=
undefined x g-successor
P := restriction P Sc .
Note function e well-defined due definition adding g-successors.
remains show satisfies (T1)(T14), basically consequence
clash-free complete.
(T1) satisfied since contain clash (C1).
(T2) satisfied since Ru rule cannot applied, thus C1 u C2 L(s) implies
C1 , C2 L(s).
(T3) satisfied since Rt rule cannot applied, thus C1 C2 L(s) implies
{C1 , C2 } L(s) 6= .
(T4), consider s, Sa R E(s, t) R v
* R0 . R E(s, t) implies
blocks R-successor s. definition successor, blocks
R0 -successor s, thus R0 E(s, t).
(T5), let R.C L(s) R E(s, t). R-successor s,
blocked implies C L(t) since R rule cannot applied. blocks
R-successor t0 s, blocked fact R rule cannot
applied yields C L(t0 ), blocking condition implies C L(t).
cases, thus C L(t).
(T6) (T7) satisfied reasons (T5) R replaced R
R+ .
(T8), consider (> n R C) L(s). Hence (> n R C) L(s)
completeness implies existence R-successors t1 , . . . , tn C L(ti )
.
ti =
6 tj 6= j. latter implies, 6= j, existence integers k, `
k 6= `, AnRC
L(ti ), AnRC
L(tj ). (T8) satisfied, remains
k
`
verify
ti block tj : case, blocking condition would imply
{AnRC
, AnRC
} L(ti ).
k
`
719

fiLutz, Areces, Horrocks, & Sattler

block ti tj 6= j: similarly, would imply
{AnRC
, AnRC
} L(t).
k
`
case, would clash (C3), contradiction clash-free.
(T9), consider (6 n R C) L(s). Hence (6 n R C) L(s) and, since
R6 rule cannot applied, n R-successors ti s. Since
ti either blocked blocked exactly one node (due linear
ordering), n ui Sa R E(s, ui ) C L(ui ).
(T10), let (6 n R C) L(s) R E(s, t). Hence (6 n R C) L(s)
either R-successor blocks R-successor s. first case, nonapplicability Rch rule implies {C, C} L(t) 6= . second case,
{C, C} L(t0 ) 6= t0 R-successor blocked t, thus blocking
condition yields {C, C} L(t) 6= . cases, implies {C, C} L(t) 6= .
Next, consider (g1 , . . . , gn keyfor C) K e(s, gi ) defined
i. Hence gi -successor i, thus blocked nonapplicability Rch rule imply {C, C} L(t) 6= .
(T11), consider N L(s) L(t). definition, N L(s) L(t) thus t.
Moreover, totality implies assume without loss generality
= t. Thus non-applicability Ra rule implies L(t) L(s),
thus blocked implies = t.
(T12) satisfied since rule Rc cannot applied.
(T13), clash-freeness implies satisfiability
^

^

P (x1 , . . . , xn ).

P used D,K (x1 ,...,xn )P(P )

choice , (x) = (y) iff x c y, thus (T13) satisfied.
(T14), let (g1 , . . . , gn keyfor C) K, C L(s) L(t), e(s, gi ) = e(t, gi ),
1 n. Thus C L(s) L(t) and, choice e , xi c yi
gi E(s, xi ) E(t, yi ). Hence t. Without loss generality, assume
= t. Thus non-applicability Ra rule implies L(t) L(s),
thus blocked implies = t.
(T15) satisfied definition since contain clash (C4).

Lemma C.4 (Completeness). SHOQK(D)-concept NNF tableau w.r.t.
role box R path-free key box K, expansion rules applied D, R,
K yield complete clash-free completion forest.
720

fiKeys, Nominals Concrete Domains

Proof. Given tableau = (Sa , Sc , L, E, e, P) w.r.t. R K, guide
non-deterministic rules Rt, Rch, Ra way rule application preserves
clash-freeness. together termination Lemma C.2 finishes proof.
Along rule application, perform stepwise construction total mapping
takes abstract nodes completion forest elements Sa concrete nodes
completion forest elements Sc .
L(s) cl(D, R, K) L((s)) Va ,
R-successor s, R E((s), (t)),
x g-successor s, e((s), g) = (x),
x c iff (x) = (y),
.
=
6 t, (s) 6= (t).
mapping satisfying four conditions called correct following. Note
completion system exists correct mapping contain clash: due
(T1) first property, encounter clash (C1). clash (C3) cannot occur
due last property. first third property together (T15) ensure
clash (C4) occur. Finally, clash (C2) cannot occur following reason:
construction P since edges labelled abstract features never removed,
tuple (x1 , . . . , xn ) P(P ), find abstract node paths u1 , . . . , un
u1 , . . . , un .P L(s) xi ui -successor 1 n. Thus, first, second,
third property together (T12) (T13) ensure conjunction
^
P ((x1 ), . . . , (xn ))
P used inD,K
(x1 ,...,xn )P(P )

solution ((x)) 6= ((x)) iff (x) 6= (y). fourth property, setting
0 (x) := ((x)) x Vc thus yields solution 0 .
total mapping inductively defined follows: let solution equation
(T13). Choose node s0 L(s0 ), set (s0 ) := s0 s0 (only) node
initial completion forest. Obviously, correct. show completion
rule applied way either still correct extended
correct mapping.
application rule Ru preserves correctness due (T2).
Due (T3), rule Rt applied correctness preserved.
rule R adds new node R.C L(s), correctness implies R.C
L((s)), thus (T6) implies existence Sa R E((s), t)
C L(t). Thus extending (t) := obviously yields correct mapping.
rule R> adds n nodes ti (> n R C) L(s), correctness implies
(> n R C) L((s)), thus (T8) implies existence t1 , . . . , tn Sa
ti 6= tj 6= j, R E((s), ti ), C L(ti ). Thus extending (ti ) := ti
obviously yields correct mapping.
721

fiLutz, Areces, Horrocks, & Sattler

Assume R6 rule applicable node (6 n R C) L(s)
n R-successors ti C L(ti ). correctness implies (6 n R C)
L((s)), R E((s), (ti )), C L(ti ). Thus, (T9), 6= j
.
(ti ) = (tj ). Again, correctness implies ti =
6 tj and, without loss generality, assume ti tj . Hence applying rule thereby merging L(tj )
L(ti ) preserves correctness.
rule Rc, extended similar way R: new gi -successor xi
added, extending (xi ) := e((s), gi ) yields correct . Moreover,
(T13) ensures c updated way fourth condition
preserved.
R rule, need extended, (T5), (T4), definition
R-successors imply correctness preserved.
R+ rule similar, difference (T7) takes place (T5).
Due (T10), rule Rch applied without violating correctness.
Ra , consider two reasons Ra applicable:
N L(s) L(t). correctness (T11) imply (s) = (t).
(g1 , . . . , gn keyfor C) K, C L(s) L(t), gi E(s, xi ) E(t, yi )
xi c yi 1 n. correctness implies e((s), gi ) = e((t), gi ),
thus (T14) together first property correctness imply (s) = (t).
cases, applying Ra preserves correctness.

immediate consequence Lemmas 4.2, C.2, C.3, C.4, tableau algorithm
always terminates answers satisfiable w.r.t. R K input
concept satisfiable w.r.t. input role box R input key box K. Since concept
satisfiability w.r.t. TBoxes reduced concept satisfiability without TBoxes,
obtain following result:
Proposition C.5. Let key-admissible concrete domain. tableau algorithm
decides satisfiability SHOQK(D) concepts w.r.t. TBoxes, role boxes, path-free key
boxes.
hard verify proof Lemma C.4 together Lemmas 4.2 C.2
yield bounded model property SHOQK(D), bound exponential.
Corollary C.6. SHOQK(D)-concept satisfiable w.r.t. role box R pathfree key box K, satisfiable w.r.t. R K model size |I | 2m
= # cl+ (D, R, K).
722

fiKeys, Nominals Concrete Domains

Proof. SHOQK(D)-concept satisfiable w.r.t. role box R path-free key
box K, Lemma C.4 implies tableau algorithm constructs complete clash-free
completion forest D, R, K. definition blocking, number abstract
nodes completion forest blocked bounded 2m : 6= Va
abstract nodes completion forest L(s) = L(t), either blocks t, blocks s,
blocked another node u. Moreover, easily seen number
concrete successors per abstract node bounded number concrete features C, R,
K. Now, proof Lemma C.4, abstract nodes tableau constructed
complete clash-free completion forest coincide nodes blocked
completion forest. Finally, proof Lemma 4.2 interpretation domain
model constructed tableau coincides abstract nodes tableau.
Summing up, SHOQK(D)-concept satisfiable w.r.t. R K model size
|I | 2m .

References
Areces, C., Blackburn, P., & Marx, M. (1999). road-map complexity hybrid logics.
Flum, J., & Rodrguez-Artalejo, M. (Eds.), Computer Science Logic, No. 1683
Lecture Notes Computer Science, pp. 307321. Springer-Verlag.
Baader, F., Horrocks, I., & Sattler, U. (2002a). Description logics semantic web. KI
Kunstliche Intelligenz, 16 (4), 5759.
Baader, F., Lutz, C., Sturm, H., & Wolter, F. (2002b). Fusions description logics
abstract description systems. Journal Artificial Intelligence Research (JAIR), 16,
158.
Baader, F., & Sattler, U. (1998). Description logics concrete domains aggregation. Prade, H. (Ed.), Proceedings 13th European Conference Artificial
Intelligence (ECAI98), pp. 336340. John Wiley & Sons.
Baader, F., Calvanese, D., McGuinness, D. L., Nardi, D., & Patel-Schneider, P. F. (2003).
Description Logic Handbook: Theory, implementation applications. Cambridge University Press, Cambridge, MA, USA.
Baader, F., & Hanschke, P. (1991a). scheme integrating concrete domains concept
languages. Proceedings 12th International Joint Conference Artificial
Intelligence (IJCAI-91), pp. 452457, Sydney, Australia.
Baader, F., & Hanschke, P. (1991b). scheme integrating concrete domains concept
languages. DFKI research report RR-91-10, German Research Center Artificial
Intelligence (DFKI).
Baader, F., & Hanschke, P. (1992). Extensions concept languages mechanical
engineering application. Proceedings 16th German AI-Conference (GWAI92), Vol. 671 Lecture Notes Computer Science, pp. 132143. Springer-Verlag.
Baader, F., & Sattler, U. (2000). Tableau algorithms description logics. Dyckhoff,
R. (Ed.), Proceedings International Conference Automated Reasoning
Tableaux Related Methods (Tableaux 2000), Vol. 1847 Lecture Notes Artificial
Intelligence, pp. 118. Springer-Verlag.
723

fiLutz, Areces, Horrocks, & Sattler

Berger, R. (1966). undecidability domino problem. Memoirs American
Mathematical Society, 66, 172.
Berners-Lee, T., Hendler, J., & Lassila, O. (2001). semantic web. Scientific American,
284 (5), 3443.
Borger, E., Gradel, E., & Gurevich, Y. (1997). Classical Decision Problem. Perspectives
Mathematical Logic. Springer-Verlag.
Borgida, A., & Patel-Schneider, P. F. (1994). semantics complete algorithm
subsumption CLASSIC description logic. Journal Artificial Intelligence Research, 1, 277308.
Borgida, A., & Weddell, G. E. (1997). Adding uniqueness constraints description logics
(preliminary report). Bry, F., Ramakrishnan, R., & Ramamohanarao, K. (Eds.),
Proceedings 5th International Conference Deductive Object-Oriented
Databases (DOOD97), Vol. 1341 LNCS, pp. 85102. Springer.
Calvanese, D., De Giacomo, G., & Lenzerini, M. (1998). decidability query
containment constraints. Proceedings 17th ACM SIGACT-SIGMODSIGART Symposium Principles Database Systems (PODS98), pp. 149158.
Calvanese, D., De Giacomo, G., & Lenzerini, M. (2000). Keys free description logics.
Baader, F., & Sattler, U. (Eds.), Proceedings 2000 International Workshop
Description Logics (DL2000), No. 33 CEUR-WS (http://ceur-ws.org/), pp. 7988.
Calvanese, D., Lenzerini, M., & Nardi, D. (1998). Description logics conceptual data
modeling. Chomicki, J., & Saake, G. (Eds.), Logics Databases Information
Systems, pp. 229263. Kluwer Academic Publisher.
Dean, M., Connolly, D., van Harmelen, F., Hendler, J., Horrocks, I., McGuinness, D. L.,
Patel-Schneider, P. F., & Stein, L. A. (2002). Web ontology language (OWL) reference
version 1.0. W3C Working Draft.
Fensel, D., van Harmelen, F., Horrocks, I., McGuinness, D. L., & Patel-Schneider, P. F.
(2001). OIL: ontology infrastructure semantic web. IEEE Intelligent
Systems, 16 (2), 3845.
Graham, R. L., Knuth, D. E., & Patashnik, O. (1990). Concrete Mathematics. Addison
Wesley Publ. Co., Reading, Massachussetts.
Haarslev, V., Lutz, C., & Moller, R. (1998). Foundations spatioterminological reasoning
description logics. Cohn, A., Schubert, L., & S.C.Shapiro (Eds.), Proceedings
6th International Conference Principles Knowledge Representation
Reasoning (KR98), pp. 112124. Morgan Kaufman.
Haarslev, V., & Moller, R. (2001). RACER system description. Gore, R., Leitsch,
A., & Nipkow, T. (Eds.), Proceedings 1st International Joint Conference
Automated Reasoning (IJCAR01), No. 2083 Lecture Notes Artificial Intelligence,
pp. 701705. Springer-Verlag.
Haarslev, V., Moller, R., & Wessel, M. (2001). description logic ALCN HR+ extended
concrete domains: practically motivated approach. Gore, R., Leitsch, A.,
724

fiKeys, Nominals Concrete Domains

& Nipkow, T. (Eds.), Proceedings 1st International Joint Conference Automated Reasoning IJCAR01, No. 2083 Lecture Notes Artificial Intelligence, pp.
2944. Springer-Verlag.
Halpern, J. Y., & Moses, Y. (1992). guide completeness complexity modal
logics knowledge belief. Artificial Intelligence, 54 (3), 319380.
Hollunder, B., & Baader, F. (1991). Qualifying number restrictions concept languages.
Proceedings 2nd International Conference Principles Knowledge Representation Reasoning (KR91), pp. 335346, Boston, MA, USA.
Hopcroft, J. E., & Ullman, J. D. (1979). Introduction Automata Theory, Languages
Computation. Addison-Wesley.
Horrocks, I., Sattler, U., & Tobies, S. (2000). Practical reasoning expressive description logics. Logic Journal IGPL, 8 (3), 239264.
Horrocks, I. (1998). Using expressive description logic: FaCT fiction?. Proceedings
6th International Conference Principles Knowledge Representation
Reasoning (KR98), pp. 636647.
Horrocks, I. (2002). Reasoning expressive description logics: Theory practice.
Voronkov, A. (Ed.), Proceedings 18th International Conference Automated
Deduction (CADE 2002), No. 2392 Lecture Notes Artificial Intelligence, pp. 115.
Springer.
Horrocks, I., Patel-Schneider, P. F., & van Harmelen, F. (2002). Reviewing design
DAML+OIL: ontology language semantic web. Proceedings 18th
National Conference Artificial Intelligence (AAAI 2002), pp. 792797.
Horrocks, I., & Sattler, U. (2001). Ontology reasoning SHOQ(D) description logic.
Nebel, B. (Ed.), Proceedings 17th International Joint Conference Artificial
Intelligence (IJCAI01), pp. 199204. Morgan-Kaufmann.
Horrocks, I., Sattler, U., & Tobies, S. (1999). Practical reasoning expressive description
logics. Ganzinger, H., McAllester, D., & Voronkov, A. (Eds.), Proceedings
6th International Conference Logic Programming Automated Reasoning
(LPAR99), No. 1705 Lecture Notes Artificial Intelligence, pp. 161180. SpringerVerlag.
Kamp, G., & Wache, H. (1996). CTL - description logic expressive concrete domains.
Tech. rep. LKI-M-96/01, Laboratory Artificial Intelligence (LKI), Universitity
Hamburg, Germany.
Khizder, V. L., Toman, D., & Weddell, G. E. (2001). decidability complexity description logics uniqueness constraints. den Bussche, J. V., & Vianu, V. (Eds.),
Proceedings 8th International Conference Database Theory (ICDT2001), Vol.
1973 LNCS, pp. 5467. Springer.
Knuth, D. (1968). Art Computer Programming, Vol. 1. Addison-Wesley.
Lutz, C. (2003). Description logics concrete domainsa survey. Advances Modal
Logics Volume 4, pp. 265296. World Scientific Publishing Co. Pte. LTd.
725

fiLutz, Areces, Horrocks, & Sattler

Lutz, C. (2002a). Complexity Reasoning Concrete Domains. Ph.D. thesis,
LuFG Theoretical Computer Science, RWTH Aachen, Germany.
Lutz, C. (2002b). PSpace reasoning description logic ALCF(D). Logic Journal
IGPL, 10 (5), 535568.
Lutz, C. (2002c). Reasoning entity relationship diagrams complex attribute
dependencies. Horrocks, I., & Tessaris, S. (Eds.), Proceedings International
Workshop Description Logics 2002 (DL2002), No. 53 CEUR-WS (http://ceurws.org/), pp. 185194.
Lutz, C. (2004). NExpTime-complete description logics concrete domains. ACM
Transactions Computational Logic, 5 (4), 669705.
Lutz, C., Areces, C., Horrocks, I., & Sattler, U. (2002). Keys, nominals, concrete
domains. LTCS-report 02-04, Technical University Dresden. See http://lat.inf.tudresden.de/research/reports.html.
Lutz, C., Areces, C., Horrocks, I., & Sattler, U. (2003). Keys, nominals, concrete
domains. Proceedings 18th International Joint Conference Artificial Intelligence (IJCAI03), pp. 349354. Morgan-Kaufmann Publishers.
Pan, J. Z., & Horrocks, I. (2002). Reasoning SHOQ(Dn ) description logic. Horrocks, I., & Tessaris, S. (Eds.), Proceedings International Workshop Description Logics 2002 (DL2002), No. 53 CEUR-WS (http://ceur-ws.org/), pp. 5362.
Post, E. M. (1946). variant recursively unsolvable problem. Bulletin American
Mathematical Society, 52, 264268.
Schild, K. D. (1991). correspondence theory terminological logics: Preliminary report.
Mylopoulos, J., & Reiter, R. (Eds.), Proceedings 12th International Joint
Conference Artificial Intelligence (IJCAI-91), pp. 466471. Morgan Kaufmann.
Schmidt-Schau, M., & Smolka, G. (1991). Attributive concept descriptions complements. Artificial Intelligence, 48 (1), 126.

726


