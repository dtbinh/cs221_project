Journal Artificial Intelligence Research 23 (2005) 245-297

Submitted 12/03; published 03/05

Graduality Argumentation
Claudette Cayrol
Marie-Christine Lagasquie-Schiex

ccayrol@irit.fr
lagasq@irit.fr

IRIT-UPS, 118 route de Narbonne
31062 Toulouse Cedex, FRANCE

Abstract
Argumentation based exchange valuation interacting arguments, followed
selection acceptable (for example, order take decision,
make choice). Starting framework proposed Dung 1995, purpose
introduce graduality selection best arguments, i.e. able
partition set arguments two usual subsets selected
non-selected arguments order represent different levels selection. basic idea
argument acceptable preferred attackers. First,
discuss general principles underlying gradual valuation arguments based
interactions. Following principles, define several valuation models abstract
argumentation system. Then, introduce graduality concept acceptability
arguments. propose new acceptability classes refinement existing classes
taking advantage available gradual valuation.

1. Introduction
shown Dung (1995), argumentation frameworks provide unifying powerful
tool study several formal systems developed common-sense reasoning, well
giving semantics logic programs. Argumentation based exchange
valuation interacting arguments support opinions assertions. applied,
among others, legal domain, collective decision support systems negotiation
support.
fundamental characteristic argumentation system interaction arguments. particular, relation attack may exist arguments. example,
argument takes form logical proof, arguments proposition arguments
proposition advanced. case, attack relation relies logical
inconsistency.
argumentation process usually divided two steps: valuation relative
strength arguments, followed selection acceptable arguments.
valuation step, usual distinguish two different types valuations:
intrinsic valuation: here, value argument independent interactions
arguments. enables simply express extent argument
increases confidence statement supports (see Pollock, 1992; Krause, Ambler, Elvang, & Fox, 1995; Parsons, 1997; Prakken & Sartor, 1997; Amgoud & Cayrol,
1998; Kohlas, Haenni, & Berzati, 2000; Pollock, 2001).
c
2005
AI Access Foundation. rights reserved.

fiCayrol, Lagasquie-Schiex

example, work Krause et al. (1995), using following knowledge base,
composed (formula, probability) pairs {(1 , 0.8), (2 , 0.8), (3 , 0.8), ((1 2
4 ), 1), ((1 3 4 ), 1)}, two arguments produced1 :
A1 =< {1 , 2 , (1 2 4 )}, 4 >
A2 =< {1 , 3 , (1 3 4 )}, 4 >.

arguments weight 0.8 0.8 1 = 0.64, formula 4
weight 0.64 + 0.64 0.512 = 0.7682 .
interaction-based valuation: value argument depends attackers
(the arguments attacking it), attackers attackers (the defenders), etc. 3
Several approaches proposed along line (see Dung, 1995; Amgoud &
Cayrol, 1998; Jakobovits & Vermeir, 1999; Besnard & Hunter, 2001) differ
sets values used. Usually, two values considered. However,
proposals use two values (three values Jakobovits & Vermeir,
1999, infinity values Besnard & Hunter, 2001).
example, work Besnard Hunter (2001), set values
interval real line [0, 1]. case, set arguments4 {A1 , A2 , A3 }
considering A1 attacks A2 attacks A3 , value argument A1
(resp. A2 , A3 ) 1 (resp. 21 , 32 ).
Intrinsic valuation interaction-based valuation often used separately, according considered applications. recent works however consider combination
approaches (see Amgoud & Cayrol, 1998; Karacapilidis & Papadias, 2001; Pollock,
2001).
Considering selection acceptable arguments, usual distinguish
two approaches:
individual acceptability: here, acceptability argument depends
properties. example, argument said acceptable
attacker (in case, interaction arguments considered,
see Elvang-Goransson et al., 1993). context intrinsic valuation, argument said acceptable better attackers
(see Amgoud & Cayrol, 1998).
collective acceptability: case, acceptability set arguments explicitly
defined. example, acceptable, set arguments may contain two
1. Here, arguments form Explanation-Conclusion Pair. one possible way
compute arguments (see Lin & Shoham, 1989; Vreeswijk, 1997; Pollock, 1992; Prakken & Sartor,
1997; Simari & Loui, 1992; Elvang-Goransson, Fox, & Krause, 1993; Kohlas et al., 2000; Amgoud &
Cayrol, 2002).
2. Weights probabilities, weight argument probability conjunction
formulae argument, weight 4 probability disjunction A1 A2 .
3. Here, consider interactions corresponding attacks arguments. exist
types interactions (for example, arguments reinforce arguments instead attacking them, see Karacapilidis & Papadias, 2001; Verheij, 2002). kind interaction, graduality
considered.
4. Here, initial knowledge base useless.

246

fiGraduality argumentation

arguments one attacks (interactions arguments used).
Dungs (1995) framework well suited kind approach allows
binary classification: argument belongs belong acceptable set.
clear except intrinsic valuations, proposals allow gradual
notion valuation acceptability (i.e. low number levels describe values
acceptability usually binary). aim therefore introduce graduality
two steps.
However, processes valuation selection often linked together.
case selection done basis value arguments5 selection
defines binary valuation arguments. therefore:
first consider discuss general principles concerning definition gradual
interaction-based valuation define valuation models abstract
argumentation system,
then, introduce notion graduality definition acceptability using
previously defined gradual valuations, classical mechanisms.
graduality already introduced argumentation systems. instance,
work Pollock (2001), degrees justification beliefs computed. Arguments
sequences conclusive and/or prima-facie inferences. Arguments collected graph
node represents conclusion argument, support link ties node nodes
inferred, attack link indicates attack nodes. degree
justification belief computed strength arguments concluding
belief strength arguments concluding attacker belief.
work takes place abstract framework since consider argument
structure. valuation models based interactions arguments directly
apply arguments.
use framework defined Dung (1995): set arguments binary attack
relation arguments. use graphical representation argumentation systems (see Section 2). gradualisation interaction-based valuations presented
Section 3. Then, Section 4, consider different mechanisms leading gradual
acceptability, sometimes relying gradual valuations defined Section 3.
conclude Section 5.
proofs properties stated Sections 3 4 given Appendix A.

2. Dungs (1995) framework graphical representation
consider abstract framework introduced Dung (1995). argumentation system
<A, R> set arguments binary relation R called attack relation:
consider Ai Aj A, Ai RAj means Ai attacks Aj Aj attacked Ai (also
denoted (Ai , Aj ) R).
5. example, using Besnard Hunters (2001) valuation, decide arguments whose
value > 0.5 selected, 0.5 mean value set values; Another possibility,
different valuations (interaction-based intrinsic), accept argument value better
value attackers.

247

fiCayrol, Lagasquie-Schiex

argumentation system well-founded infinite sequence 0 , A1 ,
. . . , , . . . i, Ai Ai+1 RAi .
Here, interested structure arguments consider arbitrary
attack relation.
Notation: <A, R> defines directed graph G called attack graph. Consider A,
set R (A) set arguments attacking A6 set R+ (A) set
arguments attacked A7 .
Example 1
system <A = {A1 , A2 , A3 , A4 }, R = {(A2 , A3 ), (A4 , A3 ), (A1 , A2 )}> defines following graph G root8 A3 :
A1

A2
A3
A4

Definition 1 (Graphical representation argumentation system) Let G
attack graph associated argumentation system <A, R>, define:
Leaf attack graph leaf G argument without attackers9 .
Path attack graph path B sequence arguments C = A1
. . . that:
= A1 ,
A1 RA2 ,
...,
An1 RAn ,
= B.
length path n 1 (the number edges used path)
denoted lC .
special case path10 whose length 0.
set paths B denoted C(A, B).
6. R (A) = {Ai A|Ai RA}.
7. R+ (A) = {Ai A|ARAi }.
8. word root used informal sense (it means graph paths
leading node). term terms (leaf, branch, path, . . . ) used
document standard graph theory may different definition. usual terms
argumentation domain. Please see Definition 1 order know precise meaning document.
definitions simply take account fact directed edges graph link attackers
attacked argument).
9. leaf iff R (A) = .
10. assume exists infinity paths. assumption greatly simplifies handling
leaves later paper.

248

fiGraduality argumentation

Dependence, independence, root-dependence path
Consider 2 paths CA C(A1 , ) CB C(B1 , Bm ).
two paths said dependent iff Ai CA , Bj CB Ai = Bj .
Otherwise independent.
two paths said root-dependent iff = Bm Ai 6= CA ,
6 Bj CB Ai = Bj .
Cycles attack graph cycle11 path C = A1 . . . A1 i, j
[1, n], 6= j, Ai 6= Aj .
cycle C isolated iff C, 6 B BRA B 6 C.
Two cycles CA = A1 . . . A1 CB = B1 . . . Bm B1 interconnected
iff [1, n], j [1, m] Ai = Bj .
use notions direct indirect attackers defenders. notions introduced
inspired related definitions first introduced Dung (1995) strictly
equivalent12 .
Definition 2 (Direct/Indirect Attackers/Defenders argument) Consider
A:
direct attackers elements R (A).
direct defenders direct attackers elements R (A).
indirect attackers elements Ai defined by:
C C(Ai , A) lC = 2k + 1, k 1.
indirect defenders elements Ai defined by:
C C(Ai , A) lC = 2k, k 2.
argument attacker (direct indirect) argument B, say
attacks B (or B attacked A). way, argument defender
(direct indirect) argument B, defends B (or B defended A).
Note attacker defender (for example, A1 attacks A2 attacks
A3 , A1 attacks A3 ). way, direct attacker indirect attacker
(for example, A1 attacks A2 attacks A3 attacks A4 , A1 attacks A4 )
thing may occur defenders.
Definition 3 (Attack branch defence branch argument) Consider
A, attack branch (resp. defence branch) path G leaf whose
length odd (resp. even). say root attack branch (resp. defence
branch).
11. definition cycle corresponds definition elementary cycle graph theory (an
elementary cycle contain 2 edges initial extremity, ending extremity).
12. Dungs (1995) work, direct attackers (resp. defenders) indirect attackers (resp. defenders)
true definitions.

249

fiCayrol, Lagasquie-Schiex

Note notion defence basis usual notion reinstatement (B attacks
C, attacks B C reinstated A). paper, reinstatement taken
account indirectly, value argument C possibility selecting
C increased thanks presence A.
notions illustrated following example:
Example 2

graph G, see:
path C2 whose length 2 (C2 B1 A),
2 cycles A1 A3 A2 A1 A1 A3 A4 A1 , length
3, isolated (note A1 A3 A2 A1
A3 A4 A1 cycle definition),
two previous cycles interconnected (in A1 A3 ),
paths D1 C1 B1 C3 B2 independent,
paths D1 C1 B1 C3 B2 root-dependent
paths D1 C1 B1 C2 B1 dependent,
D1 , C2 , E1 leaves G,
D1 C1 B1 attack branch whose length
3, C2 B1 defence branch whose length 2,
C2 , B1 B2 direct attackers A,
C1 , C2 (which already direct attacker A) C3
direct defenders A,
D1 D2 two indirect attackers A,
E1 indirect defender A.

A3

A4

A1

A2


B2

B1

C1

D1

C2

C3

D2

E1

3. Graduality interaction-based valuations
consider two different valuation methods taking account quality attackers
defenders argument order define value argument using
interaction arguments13 :
first approach, value argument depends values direct
attackers argument. Therefore, defenders taken account
attackers. approach called local.
second approach, value argument represents set attack
defence branches argument. approach called global.
main difference two approaches illustrated following example:


C1

C

B

B

C2

13. pursue work initiated (Cayrol & Lagasquie-Schiex, 2003c) propose improvements.

250

fiGraduality argumentation

local approach, B two direct attackers (C2 C1 ) whereas B 0 one
(C 0 ). Thus B 0 better B (since B 0 suffers one attack whereas B suffers two attacks).
global approach, two branches (one attack one defence) lead B whereas
one branch attack leads B 0 . Thus B better B 0 (since least one
defence whereas B 0 none). case, C1 loses negative status attacker, since
fact carrying defence B.
3.1 Local approach (generic valuation)
existing proposals already considered examples local valuations.
Jakobovits Vermeirs (1999) approach, labelling set arguments assigns
status (accepted, rejected, undecided) argument using labels set {+, , ?}.
+ (resp. , ?) represents accepted (resp. rejected, undecided) status. Intuitively,
argument labelled ? supported weakened.
Definition 4 (Jakobovits Vermeirs labellings, 1999) Let <A, R> argumentation system. complete labelling <A, R> function Lab : {+, ?, }
that:
1. Lab(A) {?, } B R (A) Lab(B) {+, ?}
2. Lab(A) {+, ?} B R (A) R+ (A), Lab(B) {?, }
underlying intuition argument weakened (label ?) one
direct attackers supported (condition 1); argument get support
direct attackers weakened argument supported (label + ?) weakens
arguments attacks (condition 2). So:





attacker Lab(A) = +.
Lab(A) =? B R (A) Lab(B) =?.
(B R (A), Lab(B) = ) Lab(A) = +.
Lab(A) = + B R (A) R+ (A), Lab(B) = .

Every argumentation system completely labelled. associated semantics
acceptable set arguments iff exists complete labelling Lab <A, R>
= {A|Lab(A) = +}.
types labellings introduced Jakobovits Vermeir (1999) among
so-called rooted labelling induces corresponding rooted semantics. idea
reject arguments attacked accepted arguments: attack undecided
argument rooted since undecided attacker may become rejected.
Definition 5 (Jakobovits Vermeirs labellings, 1999 continuation)
complete labelling Lab rooted iff A, Lab(A) = B R (A)
Lab(B) = +.
rooted semantics enables clarify links semantics introduced
Jakobovits Vermeir (1999) semantics introduced Dung (1995).
251

fiCayrol, Lagasquie-Schiex

Example 3 following example:


An1

A2

A1

n even, obtain Lab(An ) = Lab(An2 ) = . . . = Lab(A2 ) = + Lab(An1 ) =
Lab(An3 ) = . . . = Lab(A1 ) = .
n odd, obtain Lab(An ) = Lab(An2 ) = . . . = Lab(A1 ) = + Lab(An1 ) =
Lab(An3 ) = . . . = Lab(A2 ) =
Another type local valuation introduced recently Besnard Hunter (2001)
deductive arguments. approach characterised follows. argument
structured pair hsupport, conclusioni, support consistent set formulae
enables prove formula conclusion. attack relation considered strict
cycles allowed. notion tree arguments allows concise
exhaustive representation attackers defenders given argument, root tree.
function, called categoriser, assigns value tree arguments. value
represents relative strength argument (root tree) given attackers
defenders. Another function, called accumulator, synthesises values assigned
argument trees whose root argument (resp. against) given conclusion.
phase categorisation therefore corresponds interaction-based valuation. Besnard
Hunter (2001) introduce following function Cat:
R (A) = , Cat(A) = 1
R (A) 6= R (A) = {A1 , . . . , }, Cat(A) =

1
1+Cat(A1 )+...+Cat(An )

Intuitively, larger number direct attackers argument, lower value.
larger number defenders argument, larger value.
Example 3 (continuation) obtain:
Cat(A
n ) = 1, Cat(An1 ) = 0.5, Cat(An2 ) = 0.66, Cat(An3 ) = 0.6, . . . , Cat(A1 ) =

( 5 1)/2 n (this value inverse golden ratio14 ).
So, have:
n even Cat(An1 ) . . . Cat(A3 ) Cat(A1 ) Cat(A2 ) . . . Cat(An ) = 1
n odd Cat(An1 ) . . . Cat(A2 ) Cat(A1 ) Cat(A3 ) . . . Cat(An ) = 1
approach local valuations generalisation two previous proposals
sense Besnard Hunters (2001) Cat function Jakobovits Vermeirs (1999)
labellings instances approach.
main idea value argument obtained composition two
functions:
one aggregating values direct attackers argument; so,
function computes value direct attack;
computing effect direct attack value argument:
value direct attack increases value argument decreases,
value direct attack decreases value argument increases.
14. golden ratio famous number since antiquity several interesting properties
several domains (architecture, example).

252

fiGraduality argumentation

Let (W, ) totally ordered set minimum element (VMin ) subset V W ,
contains VMin maximum element VMax .
Definition 6 (Generic gradual valuation) Let <A, R> argumentation system.
valuation function v : V that:
1. A, v(A) VMin
2. A, R (A) = , v(A) = VMax
3. A, R (A) = {A1 , . . . , } 6= , v(A) = g(h(v(A1 ), . . . , v(An )))
h : V W (V denotes set finite sequences elements V )
h(x) = x
h() = VMin
permutation (xi1 , . . . , xin ) (x1 , . . . , xn ), h(xi1 , . . . , xin ) = h(x1 , . . . , xn )
h(x1 , . . . , xn , xn+1 ) h(x1 , . . . , xn )
xi x0i h(x1 , . . . , xi , . . . , xn ) h(x1 , . . . , x0i , . . . , xn )
g : W V
g(VMin ) = VMax
g(VMax ) < VMax
g non-increasing (if x g(x) g(y))
Note h(x1 , . . . , xn ) max(x1 , . . . , xn ) logical consequence properties
function h.
first property function g explains behaviour local valuation case
argument root one branch (like Example 3):
Property 1 function g satisfies n 1:
g(VMax ) g 3 (VMax ) . . . g 2n+1 (VMax ) g 2n (VMax ) . . . g 2 (VMax ) VMax
Moreover, g strictly non-increasing g(VMax ) > VMin , previous inequalities
become strict.
second property shows local valuation induces ordering relation arguments:
Property 2 (Complete preordering) Let v valuation sense Definition 6.
v induces complete15 preordering set arguments defined by: B iff
v(A) v(B).
third property handles cycles:
15. complete preordering means two elements comparable.

253

fiCayrol, Lagasquie-Schiex

Property 3 (Value cycle) Let C isolated cycle attack graph, whose
length n. n odd, arguments cycle value value
fixpoint function g. n even, value argument cycle
fixpoint function g n .
following property shows underlying principles satisfied local valuations
defined according schema:
Property 4 (Underlying principles) gradual valuation given Definition 6 respects following principles:
P1 valuation maximal argument without attackers non maximal
attacked undefended argument.
P2 valuation argument function valuation direct attackers (the
direct attack).
P3 valuation argument non-increasing function valuation direct
attack.
P4 attacker argument contributes increase valuation direct
attack argument.
last properties explain Jakobovits Vermeir (1999) Besnard Hunter
(2001) propose instances local valuation described Definition 6:
Property 5 (Link Jakobovits & Vermeir, 1999)
Every rooted labelling <A, R> sense Jakobovits Vermeir (1999)
defined instance generic valuation that:
V = W = {, ?, +} < ? < +,
VMin = ,
VMax = +,
g defined g() = +, g(+) = , g(?) =?
h function max.
Property 6 (Link Besnard & Hunter, 2001) gradual valuation Besnard
Hunter (2001) defined instance generic valuation that:
V = [0, 1],
W = [0, [,
VMin = 0,
VMax = 1,
1
g : W V defined g(x) = 1+x
h defined h(x1 , . . . , xn ) = x1 + . . . + xn .
254

fiGraduality argumentation

Note that, work Besnard Hunter (2001), valued graphs acyclic. However, easy show valuation proposed Besnard Hunter (2001)
generalised graphs cycles (in case, must solve second degree equations see
Example 5).

















































B1B2B3









































C1

C3





C2
C4























































D1












D2
D3

































































E1















































































Example 4 Consider following graph:

B4

example, generic valuation, obtain:
v(E1 ) = v(D2 ) = v(D3 ) = v(C4 ) = v(B4 ) = VMax
v(D1 ) = v(C2 ) = v(C3 ) = v(B3 ) = g(VMax )
v(C1 ) = v(B2 ) = g 2 (VMax )
v(B1 ) = g(h(g 2 (VMax ), g(VMax )))
v(A) = g(h(g(h(g 2 (VMax ), g(VMax ))), g 2 (VMax ), g(VMax ), VMax ))
So, have:
E 1 , 2 , 3 , C 4 , B4

C 1 , B2

1 , C 2 , C 3 , B3
However, constraints v(A) v(B1 ) insufficient compare B1
arguments.
problem exists reduce example hatched part graph
previous figure; obtain E1 , D2 C1 D1 , C2 , B1 cannot compared
arguments16 .
Now, use instance generic valuation proposed Besnard Hunter (2001):
v(E1 ) = v(D2 ) = v(D3 ) = v(C4 ) = v(B4 ) = 1,
v(D1 ) = v(C2 ) = v(C3 ) = v(B3 ) = 12 ,
v(C1 ) = v(B2 ) = 23 ,
16. v(A) = g 2 (h(g 2 (VMax , g(VMax ))) v(B1 ) = g(h(g 2 (VMax ), g(VMax ))).

255

fiCayrol, Lagasquie-Schiex

6
,
v(B1 ) = 13
78
v(A) = 283 .

So, have:
E 1 , 2 , 3 , C 4 , B4

C 1 , B2

1 , C 2 , C 3 , B3

B1


However, reduce example hatched part graph, value
13
19 . So, v(A) better v(B1 ) v(D1 ), v(C1 ) (A becomes better
defender).
Example 5 (Isolated cycle) Consider following graph reduced isolated cycle:


B

.

generic valuation gives v(A) = v(B) = fixpoint g 2 .
use instance proposed Besnard Hunter (2001), v(A) v(B) solutions
following second degree equation:
x2 + x 1 = 0.

1+ 5
So, obtain: v(A) = v(B) =
0.618 (the inverse golden ratio again).
2
3.2 Global approach (with tuples)
consider second approach valuation step, called global approach. Here,
key idea value must describe subgraph whose root A. So,
want memorise length branch leading tuple (for attack branch,
odd integer, defence branch, even integer).
approach, main constraint must able identify branches
leading argument compute lengths. easy case
acyclic graph. therefore introduce first global gradual valuation acyclic graphs.
Then, next sections, extend proposition case graphs cycles,
study properties global gradual valuation.
3.2.1 Gradual valuation tuples acyclic graphs
First, order record lengths branches leading arguments, use
notion tuples define operations tuples:
256

fiGraduality argumentation

Definition 7 (Tuple) tuple sequence integers. tuple (0, . . . , 0, . . .)
|
{z
}
denoted 0 . tuple (1, . . . , 1, . . .) denoted 1 .
|
{z
}





Notation 1 denotes set tuples built positive integers.
Definition 8 (Operations tuples) two kinds operations tuples:
concatenation two tuples defined function ? :
0 ? = ? 0 = 6= ()

(x1 , . . . , xn , . . .) ? (x01 , . . . , x0n , . . .) = Sort(x1 , . . . , xn , . . . , x01 , . . . , x0n , . . .)
Sort function orders tuple increasing values.
addition tuple integer defined function :




0 k = (k)
() k = ()

(x1 , . . . , xn ) k = (x1 + k, . . . , xn + k)

(x1 , . . . , xn , . . .) k = (x1 + k, . . . , xn + k, . . .) (x1 , . . . , xn , . . .) 6= 0
Note allow infinite tuples, among reasons, needed later
order compute ordering relations described Section 3.2.4 (in particular
graph cyclic).
operations tuples following properties:
Property 7 (Properties ? )
concatenation ? commutative associative.
tuple integers k k 0 , (t k) k 0 = (k + k 0 ).
integer k tuples t0 different 017 , (t ? t0 ) k = (t k) ? (t0 k).
order valuate arguments, split set lengths branches leading
argument two subsets, one lengths defence branches (even integers)
one lengths attack branches (odd integers). captured
notion tupled values:
Definition 9 (Tupled value) tupled value pair tuples vt = [vtp , vti ] with:
vtp tuple even integers ordered increased values; tuple called even
component vt;
vti tuple odd integers ordered increased values; tuple called odd
component vt.
17. Otherwise false : (0 ? (p)) k = (p + k), whereas (0 k) ? ((p) k) = (k) ? (p + k) = (k, p + k).

257

fiCayrol, Lagasquie-Schiex

Notation 2 V denotes subset tupled values (so, vt V, vt pair
tuples satisfying Definition 9).
Using notion tupled-values, define computation process gradual
valuation tuples18 case acyclic graphs.
Definition 10 (Valuation tuples acyclic graphs) Let <A, R> argumentation system without cycles. valuation tuples function v : V
that:
leaf

v(A) = [0 , ()].

direct attackers denoted B1 , . . . , Bn , . . .
v(A) = [vp (A), vi (A)] with:

vp (A) = (vi (B1 )1)?. . .?(vi (Bn )1)?. . .
vi (A) = (vp (B1 )1)?. . .?(vp (Bn )1)?. . .

Notes: choice value [0 , ()] leaves justified fact value
argument memorises lengths branches leading argument. Using
constraint, either vp (A) vi (A) may empty both19 .
Note set direct attackers argument infinite (this property
used take account argumentation graph cycles).
Example 6 graph, valuation tuples gives following results:

B2

B1

C1

D1

graph G, have:

C2

C3

D2

v(D1 ) = v(C2 ) = v(E1 ) = [0 , ()],
v(C1 ) = v(D2 ) = [(), (1)],
v(C3 ) = [(2), ()],
v(B1 ) = [(2), (1)],
v(B2 ) = [(), (3)],
v(A) = [(2, 4), (1, 3)].

E1

18. definition different definition given (Cayrol & Lagasquie-Schiex, 2003c). ideas
formalisation different.
19. proof following:.
leaf, least one tuples empty, exists least one branch
whose length > 0 leading (see Definitions 8 10).
And, leaf, exists least one defence branch path
allowed length 0 (in fact, infinity paths see Definition 1) attack
branch leading leaf (see Definition 10).
So, value leaf [0 , ()], impossible vp (A) = vi (A) = ().

258

fiGraduality argumentation

3.2.2 Study cycles
Handling cycles raises important issues: notion branch always useful
cycle (for example, unattacked cycle Examples 5 7), notion
useful, length branch defined different ways.
Let us consider different examples:
Example 7 (Unattacked cycle) graph reduced unattacked cycle B
attacks argument C:


B

C

notion branch useless case, leaf graph.
two possibilities:
First, one consider cycle infinite branch; (resp. B)
root one branch whose length . parity length branch
undefined, impossible say branch attack branch defence
branch.
second possibility consider cycle infinity branches;
(resp. B) root infinity attack branches defence branches whose
lengths known finite.
second possibility means cycle may two representations acyclic
infinite graphs (one root one root B).
rewriting process cycle:
B4

A4

B1

B5

B6

A1

A2

A3

B2

B3

B4

A1

A5

A6

B1

B2

B3

A2

A3

A4

B



Ai Bi must new arguments created rewriting process cycle.
Example 8 (Attacked cycle) cycle B attacked least one argument
belong cycle (here, attacker unattacked argument D):
259

fiCayrol, Lagasquie-Schiex





B

C

E

case, notion branch useful exists one leaf graph,
difficulty compute length branch. Example 7, consider either
one infinite branch (so, impossible know branch attack
defence branch), infinity attack branches defence branches
whose lengths known finite.
second case, graph rewritten following structures:




A6

A3





B3

A4

A5



B3

A1

A2



B1

B2

B1

B2

A1

A2

A3



B

C

E

Ai Bi must new arguments created rewriting process graph.
previous examples, chosen manage cycle infinity attack
branches defence branches whose lengths known finite would
able apply Definition 10 cases (acyclic graphs graphs cycles). However,
need rewriting process graph cycles acyclic graph. two
different cases, one unattacked cycles one attacked cycles:
Definition 11 (Rewriting unattacked cycle) Let C = A0 A1 . . . An1 A0
unattacked cycle. graph G contains C rewritten follows:
260

fiGraduality argumentation

1. cycle C removed,
2. replaced infinite acyclic graphs, one Ai , = 0 . . . n 1:

%
Ai 11

%
Ai 21

Ai 22

Ai
...
...
...
...
...

-

Ai n1
1

Ai n1
2
...

Ai n1
n1

Ai n1

Ai n2
...

Ai nn1

Ai nn

-

Ai n+1
1

Ai n+1
2
...

Ai n+1
n1

Ai n+1
n

Ai n+1
n+1

...
...
...
...
...
...
...
...
...
...
...

3. edges Ai argument belong C kept.
Example 7 Unattacked cycle (continuation) graph G containing unattacked
cycle B argument C, attacked A, rewritten follows:
C


%
A11

%
A21

A22

B
A31

A32

A33

%
B11

...
...
...
...
...
...

%
B12

B22

B13

B23

B33

...
...
...
...
...
...

Alk Bkl new arguments.
Definition 12 (Rewriting attacked cycle) Let C = A0 A1 . . . An1 A0
attacked cycle, direct attacker Ai denoted Bi , exists. graph G
contains C rewritten follows:
1. cycle C removed,
2. replaced infinite acyclic graphs, one Ai = 0 . . . n 1:
261

fiCayrol, Lagasquie-Schiex

%
Bi

%
Ai 11


B(i1+n) mod n

Ai
...
...
...
...
...

Ai n1
1

Ai n1
2
...

Ai n1
n1


Ai n1

Ai n2
...

Ai nn1

Ai nn

Bi

B(i+1) mod n

Ai n+1
1

Ai n+1
2
...

Ai n+1
n1

Ai n+1
n

Ai n+1
n+1


B(i1+n) mod n

...
...
...
...
...
...
...
...
...
...
...
...
...

(the branches leading Bk exist iff Bk exists20 ).
3. edges Ai argument belong C kept.
4. edges Bi argument belong C kept.
Example 8 Attacked cycle (continuation) graph G containing cycle
B attacked argument argument C (resp. E) attacked
(resp. B) rewritten follows:
E

B

C


%



A21

A22



A41

A42

A43

A44



%
B11



...
...
...
...
...
...
...
...
...
...

Alk Bkl new arguments.
20. operator mod modulo function.

262


B13

B23

B33



B15

B25

B35

B45

B55



...
...
...
...
...
...
...
...
...
...
...
...

fiGraduality argumentation

Note: exist several cycles graph, two cases.
interconnected, rewrite cycle, valuation resulting
graph rewriting depend order cycles select rewrite
valuation process uses length branches.
interconnected, considered metacyle turn attacked unattacked previous methodology used leading
complex rewriting process formalized (see details examples
Appendix B).
3.2.3 gradual valuation tuples general graphs
Using definitions given Sections 3.2.1 3.2.2, gradual valuation tuples
given Definition 10 applicable arbitrary graphs rewriting process.
Let us apply rewriting process Definition 10 different examples.
Example 7 Unattacked cycle (continuation)
Consider following graph:


B

C

rewriting graph given Section 3.2.2.
Definition 10 produces:
vp (A) = (vi (A11 ) 1) ? . . . ? (vi (An1 ) 1) ? . . .
vi (A) = (vp (A11 ) 1) ? . . . ? (vp (An1 ) 1) ? . . .
Applying Definition 10 different arguments rewritten graph produces following
equalities:
v(Ann ) = [0 , ()] n 1
v(Ann1 ) = [(), (1)] n 2


v(Am
n ) = [vp (An+2 ) 2, vi (An+2 ) 2] n 1 n + 2

So, using equalities formulae giving vp (A) vi (A), define two sequences tuples : sequence (xk , k 1) infinite tuples even integers, sequence
(yk , k 1) infinite tuples odd integers
n
xk = (2) ? (vi (A2k+1
2k1 ) 1) ? . . . ? (vi (A2k1 ) 1) ? . . .
n
yk = (1) ? (vp (A2k+1
2k1 ) 1) ? . . . ? (vp (A2k1 ) 1) ? . . .

263

fiCayrol, Lagasquie-Schiex

results stated Property 7, easy prove vp (A) = x1 k 1,
xk = (2) ? (xk+1 2).
Similarly, vi (A) = y1 k 1, yk = (1) ? (yk+1 2).
equations enable prove :
even integer p p > 0, p belongs tuple xi , 1.
odd integer p, p belongs tuple yi , 1.

proof done induction p.
So, v(A) = v(B) = [(2, 4, 6, . . .), (1, 3, 5, . . .)].
Then, v(C) = [(2, 4, 6, . . .), (3, 5, 7, . . .)].
Note results readily extended unattacked cycle length n,
n 2.
Property 8 (Properties unattacked cycles)
unattacked cycle, argument cycle, v(A) = [(2, 4, 6, . . .), (1, 3, 5, . . .)].
Example 8 Attacked cycle (continuation)

Consider following graph:





B

C

E

rewriting graph given Section 3.2.2.
Definition 10 produces:
vp (A) = (vi (D) 1) ? (vi (A21 ) 1) ? . . . ? (vi (A2n
1 ) 1) ? . . .
vi (A) = (vp (D) 1) ? (vp (A21 ) 1) ? . . . ? (vp (A2n
1 ) 1) ? . . .

v(D) = [0 , ()]
v(Ann ) = [(), (1)] n 2
done treatment Example 7, formulae giving vp (A) vi (A) rewritten
order bring light interesting sequences tuples.
264

fiGraduality argumentation

2(k+p)

x0k = (vi (A2k
2k1 ) 1) ? . . . ? (vi (A2k1 ) 1) ? . . .
2(k+p)

yk0 = (1) ? (vp (A2k
2k1 ) 1) ? . . . ? (vp (A2k1 ) 1) ? . . .
Then, easy prove vp (A) = x01 k 1, x0k = (x0k+1 2).
0
2).
Similarly, vi (A) = y10 k 1, yk0 = (1) ? (yk+1

first equation enables prove x01 empty tuple21 .
second equation already solved produces y10 = (1, 3, 5, . . .).
So, v(A) = [(), (1, 3, 5, . . .)]. B, reason A, v(B) = [(2, 4, 6, . . .), ()].
Then, v(C) = [(2, 4, 6, . . .), ()], v(E) = [(), (3, 5, 7 . . .)].
Notation: order simplify writing, repeat values inside tuples
(we indicate value many times appears). example:
[(2, 4, 4, 6, 6, 6, 8, 8, 8, 8 . . .), (3, 5, 5, 7, 7, 7, 9, 9, 9, 9 . . .)]
denoted
[(2, |{z}
4 , |{z}
6 , |{z}
8 , . . .), (3, |{z}
5 , |{z}
7 , |{z}
9 , . . .)]
2

3

4

2

3

4

Conclusion cycles Cycles expensive since values obtained infinite.
appendix B, introduce algorithm computing tupled values. uses
process value propagation parameterised maximum number runs
cycle. number used order stop propagation mechanism
obtain finite (thus incomplete) tupled values.
3.2.4 Comparison tupled values
section, define comparison relation arguments (so, particular tupled values), using following idea: argument better argument
B iff better defence (for it) lower attack (against it).
first idea use lexicographic ordering tuples. lexicographic ordering
denoted lex defined by:
21. proof following:.
x01 contains even integers.
k, x0k 6= 0 since x0k result addition tuple integer.
x01 empty, let e1 denote least even integer present x01 . x01 = x02 2, x02 empty
e2 denote least integer present x02 . e1 = e2 + 2. So, able build
sequence positive even integers e1 , e2 , . . ., strictly decreasing. impossible. So,
x01 = ().

265

fiCayrol, Lagasquie-Schiex

Definition 13 (Lexicographic ordering tuples)
Let (x1 , . . . , xn , . . .) (y1 , . . . , ym , . . .) 2 finite infinite tuples .
(x1 , . . . , xn , . . .) <lex (y1 , . . . , ym , . . .) iff 1 that:
j < i, xj = yj
yi exists and:
either tuple (x1 , . . . , xn , . . .) finite number elements equal 1
(so, xi exist),
xi exists xi < yi .
(x1 , . . . , xn , . . .) =lex (y1 , . . . , ym , . . .) iff tuples contain number p {}
elements i, 1 p, xi = yi .
So, define: (x1 , . . . , xn , . . .) lex (y1 , . . . , ym , . . .) iff
(x1 , . . . , xn , . . .) =lex (y1 , . . . , ym , . . .) (x1 , . . . , xn , . . .) <lex (y1 , . . . , ym , . . .).
ordering <lex generalisation classical lexicographic ordering (see Xuong,
1992) case infinite tuples. ordering complete well-founded (there
exist infinite sequences strictly non-increasing: (0) <lex (0, 0) <lex . . . <lex
(0, . . . , 0, . . .) <lex . . . <lex (0, 1)).
Since even values odd values tupled value argument play
role, cannot use classical lexicographic comparison. So, compare tupled
values two steps:
first step compares number attack branches number defence
branches argument. So, two criteria (one defence
attack). criteria aggregated using cautious method: conclude
one arguments defence branches (it better according defence
criterion) less attack branches argument (it better according
attack criterion). Note conclude positively criteria
agree: one arguments defence branches (it better according
defence criterion) attack branches argument (it worse
according attack criterion), arguments considered incomparable.
Else, arguments number defence branches number
attack branches, second step compares quality attacks
quality defences using length branch. comparison made
lexicographic principle (see Definition 13) gives two criteria
aggregated using cautious method. case disagreement, arguments
considered incomparable.
Let us consider examples:
[(2), (1)] better [(2), (1, 1)] less attack branches first
tupled value second tupled value, numbers defence branches
(first step).
[(2), (1)] incomparable [(2, 2), (1, 1)] less defence branches
less attack branches first tupled value second tupled value (first
step).
266

fiGraduality argumentation

[(2), (3)] better [(2), (1)] weaker attack branches first
tupled value second tupled value (the attack branch first tupled
value longer one second tupled value), defence branches
(second step, using lexicographic comparison applied even parts
odd parts tupled values).
[(2), (3)] better [(4), (3)] stronger defence branches
first tupled value second tupled value (the defence branch shorter
first tupled value second tupled value), attack branches
(second step).
[(2), (1)] incomparable [(4), (3)] worse attack branches
better defence branches first tupled value second tupled value
(second step).
comparison arguments done using Algorithm 1 implements principle
double comparison (first quantitative, qualitative) two criteria (one defence
criterion one attack criterion) using cautious method.
Algorithm 1: Comparison two tupled values
% Description parameters:
% v, w: 2 tupled values
% Notations:
%
|vp | (resp. |wp |): number elements even component v (resp. w)
%
vp (resp. wp ) infinite |vp | (resp. |wp |) taken equal
%
|vi | (resp. |wi |): number elements odd component v (resp. w)
%
vi (resp. wi ) infinite |vi | (resp. |wi |) taken equal
%
usual, denote strict relation associated defined by:
%
v w iff v w not(w v).

%
%
%
%
%
%
%
%
%

begin
v = w v w w v
% Case 1 %
2
else
3
|vi | = |wi | |vp | = |wp |
% lexicographic comparisons vp wp vi wi %
4
vp lex wp vi lex wi v w
% case 2 %
5
else
6
vp lex wp vi lex wi v w
% case 3 %
7
else v 6 w v 6 w
% Incomparable tupled values. case 4 %
1

8
9
10
11
12

else
|vi | |wi | |vp | |wp | v w
% case 5 %
else
|vi | |wi | |vp | |wp | v w
% case 6 %
else v 6 w v 6 w
% Incomparable tupled values. Case 7 %

end

Algorithm 1 defines partial preordering set v(A):
Property 9 (Partial preordering) Algorithm 1 defines partial preordering
set v(A).
267

fiCayrol, Lagasquie-Schiex

tupled value [0 , ()] maximal value partial preordering .
tupled value [(), 1 ] minimal value partial preordering .
Notation: partial preordering set v(A) induces partial preordering
arguments (the partial preordering denoted partial preordering
v(A)): B v(A) v(B)22 .
order present underlying principles satisfied global valuation, first
consider different ways modifying defence part attack part argument:
Definition 14 (Adding/removing branch argument)
Let argument whose tupled value v(A) = [vp (A), vi (A)] vp (A) = (xp1 , . . . , xpn )
vi (A) = (xi1 , . . . , xim ) (vp (A) vi (A) may empty simultaneously).
Adding (resp. removing) defence branch defined by:
vp (A) becomes Sort(xp1 , . . . , xpn , xpn+1 ) xpn+1 length added branch (resp.
j [1..n] vp (A) becomes (xp1 , . . . , xpj1 , xpj+1 , . . . , xpn )).
thing vi (A) adding (resp. removing) attack branch A.
Definition 15 (Increasing/decreasing length branch argument)
Let argument whose tupled value v(A) = [vp (A), vi (A)] vp (A) = (xp1 , . . . , xpn )
vi (A) = (xi1 , . . . , xim ) (vp (A) vi (A) may empty simultaneously).
Increasing (resp. decreasing) length defence branch defined by:
p
p
0p
p
j [1..n] vp (A) becomes (xp1 , . . . , xpj1 , x0p
j , xj+1 , . . . , xn ) xj > xj (resp.
p
0p
p
x0p
j < xj ) parity xj parity xj .
thing vi (A) increasing (resp. decreasing) attack branch A.
Definition 16 (Improvement/degradation defences/attacks)
Let argument whose tupled value v(A) = [vp (A), vi (A)] (vp (A) vi (A) may
empty simultaneously). define:
improvement (resp. degradation) defence consists
adding defence branch initially vp (A) 6= 0 (resp. removing
defence branch A);
decreasing (resp. increasing) length defence branch A;
removing defence branch leading (resp. adding defence branch leading initially vp (A) = 0 );
improvement (resp. degradation) attack consists
adding (resp. removing) attack branch A;
decreasing (resp. increasing) length attack branch A.
Property 10 (Underlying principles) Let v valuation tuples (Definition 10)
associated Algorithm 1, v respects following principles:
P10 valuation maximal argument without attackers non maximal
argument attacked (whether defended not).
22. use notation B defined by: B iff B.

268

fiGraduality argumentation

P20 valuation argument takes account branches rooted
argument.
P30 improvement defence degradation attack argument leads
increase value argument.
P40 improvement attack degradation defence argument leads
decrease value argument.
Example 4 (continuation)

valuation tuples, obtain:

v(E1 ) = v(D2 ) = v(D3 ) = v(C4 ) = v(B4 ) = [0 , ()],
v(D1 ) = v(C2 ) = v(C3 ) = v(B3 ) = [(), (1)],
v(C1 ) = v(B2 ) = [(2), ()],
v(B1 ) = [(2), (3)],
v(A) = [(2, 4), (1, 3, 3)].
So, have:
E 1 , 2 , 3 , C 4 , B4

C 1 , B2

B1

1 , C 2 , C 3 , B3



E 1 , 2 , 3 , C 4 , B4



incomparable almost arguments (except leaves graph).
Similarly, hatched part graph, obtain following results:
E1 , D2 C 1 B 1 1 , C 2
comparable arguments (in particular, worse
defender C1 direct attacker B1 ).
3.3 Main differences local global valuations
Cayrol Lagasquie-Schiex (2003c) give comparison approaches existing approaches (Dung, 1995; Jakobovits & Vermeir, 1999; Besnard & Hunter, 2001),
comparison local approaches global approach. improvement
global approach proposed paper modify main results
comparison.
Let us recall example essential point differentiates (this example
already presented beginning Section 3):


C1

C

B
C2

269

B

fiCayrol, Lagasquie-Schiex

local approach, B 0 better B (since B 0 suffers one attack whereas B suffers
two attacks).
global approach, B better B 0 (since least defence whereas B 0
none). case, C1 loses negative status attacker, since fact carrying
defence B.
following table synthesises results different proposed valuations:
global approach
arguments
ing
branches

havattack



arguments
attack
branches

defence
branches



arguments
defence
branches



arguments
never attacked

local approach
arguments
arguments
havonly one attacked
ing

one


direct
attacker
unattacked direct
(possibly
defended)
attacker
arguments several attacked direct attackers (possibly defended)

arguments
several unattacked
direct attackers



arguments
never attacked

difference local approaches global approach illustrated
following property:
Property 11 (Independence branches global approach)
Let argument following direct attackers:
A1 whose value v(A1 ) = [(a1p1 , . . . , a1pm ), (a1i1 , . . . , a1im )],
1
1
...,
whose value v(An ) = [(anp1 , . . . , anpmn ), (ani1 , . . . , animn )].
Let A0 argument following direct attackers:
A1p1 whose value v(A1p1 ) = [(a1p1 )()],
...,
A1pm whose value v(A1pm ) = [(a1pm )()],
1

1

1

A1i1 whose value v(A1i1 ) = [()(a1i1 )],
...,
A1im whose value v(A1im ) = [()(a1im )],
1
1
1
...,
Anp1 whose value v(Anp1 ) = [(anp1 )()],
...,
270

fiGraduality argumentation

Anpmn whose value v(Anpmn ) = [(anpmn )()],
Ani1 whose value v(Ani1 ) = [()(ani1 )],
...,
Animn whose value v(Animn ) = [()(animn )].
v(A) = v(A0 ).
property illustrates independence branches computation
values global approach, even branches graphically independent.
following example, A0 value [(2, 2)()] though root
different subgraphs:
C1

C1
B

B1



C2

C2

B2

property satisfied local approach since, using underlying principles
local approach (see Property 4), value argument must least
good (and sometimes better than23 ) value argument A0 (A one direct
attacker, A0 two direct attackers).
3.4 Conclusion valuation step
proposed two different gradual valuation models able make
distinction different arguments using preordering associated valuation
model. valuations used selection arguments (see Section 4).

4. Graduality acceptability
section, shift selection step introduce graduality notion
acceptability24 .
basic idea select argument depending non-selection direct attackers.
Following idea, propose two different methods:
first method consists refining classical partition issued Dungs collective acceptability; refinement may achieved using gradual valuations
defined Section 3.
second method takes place individual acceptability consists defining
new acceptability using gradual valuations defined Section 3.
4.1 Dungs (1995) collective acceptability
framework collective acceptability, consider acceptability set
arguments. acceptability defined respect properties sets
satisfy properties called acceptable sets extensions. argument
said acceptable belongs extension.
23. valuation proposed Besnard Hunter (2001), obtain: v(A) = 34 v(A0 ) = 12 .
24. work presented workshop (Cayrol & Lagasquie-Schiex, 2003b).

271

fiCayrol, Lagasquie-Schiex

Definition 17 (Basic properties extensions following Dung, 1995)
Let <A, R> argumentation system, have:
Conflict-free set set E conflict-free 6 A, B E ARB.
Collective defence Consider E A, A. E collectively defends
B A, BRA, C E CRB. E defends elements
E, E collectively defends A.
Dung (1995) defines several semantics collective acceptability: mainly, admissible
semantics, preferred semantics stable semantics (with corresponding extensions:
admissible sets, preferred extensions stable extensions).
Definition 18 (Some semantics extensions following Dung, 1995) Let <A, R>
argumentation system.
Admissible semantics (admissible set) set E admissible E
conflict-free E defends elements.
Preferred semantics (preferred extension) set E preferred extension
E maximal set inclusion among admissible sets.
Stable semantics (stable extension) set E stable extension E
conflict-free E attacks argument belong E (A \ E,
B E BRA).
Note definitions, attacker given argument considered
separately (the direct attack whole considered). Dung (1995) proves that:
admissible set <A, R> included preferred extension <A, R>.
always exists least one preferred extension <A, R>.
<A, R> well-founded one preferred extension
stable extension.
stable extension preferred extension (the converse false).
always stable extension.
Property 12 set leaves (i.e. {A|R (A) = }) included every preferred extension every stable extension.
4.2 Different levels collective acceptability
given semantics, following Dung, acceptability argument depends
membership extension semantics. consider three possible cases 25 :
25. terminology used section used domain nonmonotonic reasoning (see Pinkas
& Loui, 1992): word uni comes word universal synonym word skeptical,
word exi comes word existential synonym word credulous.
chosen use words uni exi recall logical quantificators (for all) (exists
least one).

272

fiGraduality argumentation

argument uni-accepted, belongs extensions semantics,
argument exi-accepted, belongs least one extension
semantics,
argument not-accepted belong extension
semantics.
However, three levels seem insufficient. example, concluded
case two arguments B exi-accepted ARB BRA?
So, introduce new definition takes account situation argument
w.r.t. attackers. refines class exi-accepted arguments given
semantics S.
Definition 19 (Cleanly-accepted argument) Consider A, cleanly-accepted
belongs least one extension B BRA, B
belong extension S.
Thus, capture idea argument better accepted, attackers
not-accepted.
Property 13 Consider semantics extension conflictfree. uni-accepted cleanly-accepted. converse false.
notion cleanly-accepted argument refines class exi-accepted arguments.
semantics argument A, following states:
uni-accepted, belongs extensions (so,
cleanly-accepted);
cleanly-accepted (so, definition exi-accepted); note
possible argument uni-accepted;
only-exi-accepted, cleanly-accepted, exi-accepted;
not-accepted belong extension S.
Example 9 Consider following argumentation system.
two preferred extensions {D, C2 , A, G}
J
{D, C2 , E, G, I}. So, preferred semantics, acI
ceptability
levels following:
E

G
H



B

F

C1

C2

D, C2 G uni-accepted,
cleanly-accepted uni-accepted,
E only-exi-accepted,
B, C1 , F , H J not-accepted.

Note that, cases one extension, first three levels acceptability coincide26 . case:
26. one extension fact belongs extensions equivalent
fact belongs least one extension. Moreover, one extension containing A,
attackers belong extension. So, cleanly-accepted.

273

fiCayrol, Lagasquie-Schiex

preferred semantics, even cycle (see Doutre, 2002).
basic semantics (another semantics proposed Dung see Dung, 1995;
Doutre, 2002 presented one extension).
Looking closely, prove following result (proof Appendix A):
Property 14 stable semantics, class uni-accepted arguments coincides
class cleanly-accepted arguments.
Then, using result issued work Dunne Bench-Capon (2001, 2002)
reused Doutre (2002) shows that, odd cycle, preferred
extensions stable27 , apply Property 14 obtain following consequence:
Consequence 1 preferred semantics, odd cycle, class
uni-accepted arguments coincides class cleanly-accepted arguments.
Finally, exploitation gradual interaction-based valuations (see Section 3) allows
us define new levels collective acceptability.
Let v gradual valuation let associated preordering (partial complete)
A. preordering used inside acceptability level (for example, level
exi-accepted arguments) order identify arguments better accepted
others.
Example 9 (continuation)
graph:

Two different gradual valuations applied

0,674

0,590

0,482

J



E

0,694

H

G 0,666

0,441
0,4 B


1

C1

F

0,5

C2 1

0.5

Besnard & Hunters (2001) valuation
instance generic valuation proposed Besnard Hunter (2001) (see
Section 3.1), obtain following comparisons:
D, C2 E G J C1 , F H B
27. corresponds consistent argumentation system proposed Dung (1995).

274

fiGraduality argumentation

{
{

[(6,8,10,12,...),
2 3
{
{
{

(7,9,10,11,...)]
2 2 3

J

[(4,6,8,10,...),
(3,5,7,9,...)]

E
H

2 2 3

2 3

[(2,4,6,8,...),
(3,5,7,9...)]


G [(2),()]

{
{
{

{
{

[(4,6,8,10,...),
2 3
(5,7,9,11,...)]

{
{
{

[(6,8,10,12,...),
2 2 3
(5,7,9,11,...)]
{
{



[(2),(1)]



B

C1

[(0,...,0),()]

F [(),(1)]

C2 [(0,...,0),()]

[(),(1)]

Valuation tuples

global valuation tuples presented Section 3.2, obtain following comparisons:
D, C2 G B F, C1
D, C2 E
D, C2 H E
D, C2
D, C2 J
So, arguments belonging cycle incomparable G, B, F , C 1 and, even
them, comparison results.
apply preordering induced valuation without respecting acceptability
levels defined section, counter-intuitive situations may happen. Example 9,
obtain:
valuation Besnard Hunter (2001) preferred semantics,
E G despite fact G uni-accepted E only-exi-accepted.
valuation tuples preferred semantics, H E despite
fact E only-exi-accepted H not-accepted.
counter-intuitive situations illustrate difference acceptability definition valuation definitions (even use interaction arguments,
use way).
275

fiCayrol, Lagasquie-Schiex

4.3 Towards gradual individual acceptability
individual acceptability based comparison argument attackers.
first proposal select argument attacker
(see Elvang-Goransson et al., 1993).
later extended Amgoud Cayrol (1998) where, using preference
relation arguments (an intrinsic valuation), argument accepted
preferred attackers.
Following proposal, propose mechanism interaction-based
valuation.
Given v gradual valuation, preordering induced v directly used order
compare, acceptability point view, argument attackers 28 .
defines new class acceptable arguments: well-defended arguments.
Definition 20 (Well-defended argument) Consider A, well-defended (for v)
B BRA, B 6 A.
Thus, capture idea argument better accepted least good
direct attackers (or incomparable case partial ordering).
set well-defended arguments depend valuation used.
Using new notion, set arguments partitioned three classes:
first class contains arguments attacked,
second class contains arguments attacked well-defended,
third class contains arguments (attacked well-defended).
Note set well-defended arguments corresponds union two first
classes. refinement uses gradual valuation inside classes
Section 4.2.
Example 9 presented Section 4.2, well-defended arguments are:
D, C2 , G, H (A incomparable B better E) valuation
tuples,
though valuation Besnard Hunter (2001) well-defended arguments
D, C2 , G, E (E better A).
Note that, semantics Dung (1995), Definition 20 considers attackers
one one. suitable valuation handles direct attack whole
(as valuation Besnard Hunter (2001) see counterexamples presented
Section 4.4).
28. idea used notion defeat proposed Bench-Capon (2002). So, link
well-defended argument argument attacked sense BenchCapon (2002) direct attackers. Note that, work Bench-Capon (2002), valuation
extra knowledge added argumentation framework. contrast, here, v-preference extracted
attack graph.

276

fiGraduality argumentation

4.4 Compatibility acceptability gradual valuation
Following previous sections, set arguments partitioned two different
ways:
First, given semantics gradual valuation v, possible use partition
issued Dung (1995) refined:
Uni
accepted
Cleanly
accepted

Exi
accepted

OnlyExi
accepted


accepted

Refinement level gradual valuation v

Second, given gradual valuation v, possible use partition induced
notion well-defended arguments:
Attaked
Welldefended
Arguments

Attaked
Arguments


















WellDefended





valuation
v
















Unattacked
Arguments

natural interesting question is: possible find semantics gradual
valuation v associated partitions compatibilities?
following examples show class well-defended arguments correspond class cleanly-accepted arguments (in cases, uni-accepted
arguments even well-defended).
277

fiCayrol, Lagasquie-Schiex

4.4.1 Examples showing non-compatibility general case
give examples usual valuation (the global valuation tuples 2 instances
generic local valuation: Besnard & Hunter, 2001; Jakobovits & Vermeir, 1999)
classical semantics acceptability (preferred semantics stable semantics
Dung, 1995).
Cleanly-accepted argument well-defended: 3 examples (each using distinct valuation: one global valuation two two well-known instances
local valuation):
argument cleanly-accepted well-defended:


0.4

0.5

B1

B2

B3
0.5

C2

C3
1

0.5

C1
1

1

1 preferred stable extension = { C1, C2, C3, A}
B1, B2, B3 belong preferred extension
Bi
forall = 1, 2, 3

argument cleanly-accepted well-defended:
?

C

2 preferred stable extensions : {C,A} {D,A}
B doesnt belong preferred extension
B





B
?

?

argument cleanly-accepted well-defended:
[(4,4),(3)]

[(0,...0),()]

B

C

[(),(1)]

[(2),()]


[(),(3)]
H
[(),(3)]

E

F
[(4),(5,5)]

G
[(6,6),(5)]


[(6),(7,7)]

1 preferred stable extension = {A,C,F,I}
G doesnt belong preferred extension
G


Well-defended argument cleanly-accepted: Similarly, three valuations,
have:
argument C well-defended cleanly-accepted:
?

+


?

B
C
?

1 preferred stable extension : {D, B}
C
B
C doesnt belong preferred stable extension

argument F well-defended cleanly-accepted:
278

fiGraduality argumentation

0.618

2 preferred stable extensions = {A,H,E} {B,H,F}
F belongs preferred stable extension
F
E E belongs preferred stable extension
E attacks F

0.618
B



E

G
0.5

0.472

H
1

F
0.679

argument G well-defended cleanly-accepted:
[(4,4),(3)]

[(0,...,0),()]

B

C

[(),(1)]

[(2),()]


[(),(3)]

E

F
[(4),(5,5)]

G
[(6,6),(5)]


[(6),(7,7)]

H
[(),(3)]

1 preferred stable extension = {A,C,F,I}
G
F
G doesnt belong preferred stable extension

4.4.2 Particular cases leading compatibility
context argumentation system finite relation R without cycles 29 ,
stable preferred semantics provide one extension levels uni-accepted,
exi-accepted, cleanly-accepted coincide.
context, least two particular cases leading compatibility.
First case: deals global valuation tuples.
Theorem 1 Let G graph associated <A, R>, <A, R> argumentation
system finite relation R without cycles satisfying following condition:

Xi , leaf G, one path Xi A, Xi1 . . . Xili Xi1 = Xi
li length path (if li even, path defence branch A, else
attack branch),
paths Xi root-dependent A,
Ai A, Xj leaf G Ai belongs path Xj A.
Let v valuation tuples. Let semantics {preferred, stable}.
1. B A, B 6= A, B (exi, uni, cleanly) accepted iff B well-defended v.
2. (exi, uni, cleanly) accepted well-defended v (the converse
false).
3. well-defended v branches leading defence branches
(exi, uni, cleanly) accepted S.
29. So, (A, R) well-founded.

279

fiCayrol, Lagasquie-Schiex

Note Theorem 1 is, general, satisfied local valuation. See following
counterexample valuation Besnard Hunter (2001):
0,4

0,5

1

B1

C1

0,5

B2

1 C2

0,5

B3

1 C3

graph satisfies condition stated Theorem 1. set well-defended arguments
{C1 , C2 , C3 } (so, well-defended). Nevertheless, {C1 , C2 , C3 , A} preferred
extension.
Second case: second case concerns generic local valuation:
Theorem 2 Let <A, R> argumentation system finite relation R without
cycles. Let semantics {preferred, stable}. Let v generic local valuation
satisfying following condition ():
(i = 1 . . . n, g(xi ) xi ) (g(h(x1 , . . . , xn )) h(x1 , . . . , xn ))
()
A, (exi, uni, cleanly) accepted iff well-defended v.
theorem direct consequence following lemma:
Lemma 1 Let <A, R> argumentation system finite relation R without cycles.
Let semantics {preferred, stable}. Let v generic local valuation satisfying
condition ().
(i) exi-accepted one direct attacker B B.
(ii) B not-accepted B one direct attacker C C B.
Remark: condition () stated Theorem 2 is:
false local valuation proposed Besnard Hunter (2001) shown
following graph:
0,4

0,5

1

know g(x) =

1
1+x



B1

C1

0,5

B2

0,5

B3

1 C2

1 C3
h(x1 , . . . , xn ) = ni=1 xi

(see Property 6). get:

= 1 . . . 3, xi = v(Bi ) = 0.5,
= 1 . . . 3, g(xi ) = 0.66, g(xi ) xi ,
nevertheless g(h(x1 , x2 , x3 )) = v(A) = 0.4 6 h(x1 , x2 , x3 ) = 1.5.
280

fiGraduality argumentation

false local valuations defined h n > 1 h(x1 , . . . , xn ) >
max(x1 , . . . , xn ) (for functions g strictly non-increasing): see previous graph
h(x1 , x2 , x3 ) = 1.5 max(x1 , x2 , x3 ) = 0.5.
true local valuations defined h = max (for functions g): h = max
g(h(x1 , . . . , xn )) = g(max(x1 , . . . , xn )) = g(xj ), xj maximum xi ;
and, assumption, g(xi ) xi , xi , particular xj ; so, get:
g(h(x1 , . . . , xn )) = g(xj ) xj = max(x1 , . . . , xn ) = h(x1 , . . . , xn ).

5. Conclusion
paper, introduced graduality two main related issues argumentation
systems:
valuation arguments,
acceptability arguments.
Regarding first issue, defined two formalisms introducing interaction-based
gradual valuation arguments.
First, generic gradual valuation covers existing proposals (for example Besnard
& Hunter, 2001 Jakobovits & Vermeir, 1999). approach essentially local
since computes value argument value direct attackers.
Then, approach based labelling takes form pair tuples;
labelling memorises structure graph representing interactions (the
attack graph), associating branch length (number edges
leaf current node) attack graph (if length branch even
integer, branch defence branch current node, otherwise branch
attack branch current node). approach said global since
computes value argument using whole attack graph influencing
argument.
shown valuations induces preordering set arguments, brought light main differences two approaches.
Regarding second issue, two distinct approaches proposed:
First, context collective acceptability Dung (1995): three levels
acceptability (uni-accepted, exi-accepted, not-accepted) already defined.
graduality introduced collective acceptability using notion cleanlyaccepted arguments (those whose direct attackers not-accepted).
Then, context individual acceptability: using previously defined gradual
valuations, new notion well-defended arguments introduced (those
preferred direct attackers sense given gradual valuation
v).
first concept induces refinement level exi-accepted two sublevels (cleanlyaccepted arguments only-exi-accepted arguments). gradual valuation allows graduality inside level collective acceptability.
281

fiCayrol, Lagasquie-Schiex

second concept induces two new levels acceptability (well-defended arguments
not-well-defended arguments). gradual valuation allows graduality inside
level individual acceptability.
Regarding initial purpose introducing graduality definition acceptability,
adopted basic principle:
acceptability strongly related interactions arguments (represented
graph interactions),
argument acceptable preferred direct attackers.
Then, followed two different directions. One based refinement existing
partition remains framework Dungs work. one based
original concept well-defended, deserves investigation, particular
computational point view.

Acknowledgements
Thanks reviewers interesting constructive comments.
Thanks Thomas Schiex help.

Appendix A. proofs
section, give proofs properties presented Sections 3 4.
Proof
(of Property 1) induction VMin g(VMax ) < VMax applying
function g twice.


Proof
(of Property 2) valuation function v associates argument
value v(A) belonging set V subset completely ordered set
W.


Proof
(of Property 3) Let C = An1 . . . A2 A1 cycle:
n even: n = 2k v(A1 ) = g(v(A2 )) = . . . = g 2k1 (v(A2k )) =
g 2k (v(A1 )); so, v(A1 ) fixpoint g 2k = g n . Ai ,
1 2k.
However, Ai may different values: example, n = 2,
valuation Jakobovits Vermeir (1999), v(A1 ) = + v(A2 ) =
g(+) = g() = +. Ai value,
value fixpoint g (because v(A1 ) = g(v(A2 )) = g(v(A1 ))).
282

fiGraduality argumentation

n odd: n = 2k + 1 v(A1 ) = g(v(A2 )) = . . . = g 2k (v(A2k+1 )) =
g 2k+1 (v(A1 )); so, v(A1 ) fixpoint g 2k+1 = g n .
Ai , 1 2k + 1.
Since function g non-increasing, function g 2k+1 nonincreasing apply following result: non-increasing function fixpoints, fixpoints identical30 . So, v(A1 ) = . . . =
v(A2k+1 ). But, v(A1 ) = g(v(A2 )) = g(v(A1 )), v(A1 ) fixpoint g.
So, 1 2k + 1, v(Ai ) fixpoint g.

Proof
(of Property 4)
P1 satisfied because: A, direct attacker (R (A) empty),
v(A) = VMax g(VMax ) < VMax .
P2 satisfied R (A) = {A1 , . . . , }, h(v(A1 ), . . . , v(An )) evaluates
direct attack A.
P3 satisfied function g supposed non-increasing.
P4 satisfied due properties function h.



Proof
(of Property 5) valuation proposed Jakobovits Vermeir (1999)
following:
Let <A, R> argumentation system. complete labelling <A, R>
function Et : {+, ?, } that:
1. Et(A) {?, } B R (A) Et(B) {+, ?}

2. Et(A) {+, ?} B R (A) R+ (A), Et(B) {?, }
Moreover, Jakobovits Vermeir (1999) define complete rooted labelling
Et with: A, Et(A) = B R (A) Et(B) = +.

translation Et local gradual valuation easy:

g defined g() = +, g(+) = , g(?) =? h function max.



Proof
(of Property 6) Besnard Hunter (2001) introduce following function
Cat (in context deductive arguments acyclic graph):
R (A) = , Cat(A) = 1
30. Proof: let g non-increasing function, let two fixpoints g. 6= , may suppose
> , g() g() (since g non-increasing), (since fixpoints g),
contradiction assumption > .

283

fiCayrol, Lagasquie-Schiex

R (A) 6= R (A) = {A1 , . . . , }, Cat(A) =

1
1+Cat(A1 )+...+Cat(An )

translation Cat gradual valuation is: V = [0, 1], W = [0, [,
1
h
VMin = 0 VMax = 1 g : W V defined g(x) = 1+x
defined h({x1 , . . . , xn }) = x1 + + xn .

Proof
(of Property 7) Let = (x1 , . . . , xn , . . .), t0 = (y1 , . . . , yn , . . .), t00 = (z1 , . . . , zn , . . .)
tuples.
Commutativity ?: ? t0 = t0 ? two cases:
t0 = 0 , property given Definition 8.
t0 6= 0 :
? t0 = Sort(x1 , . . . , xn , . . . , y1 , . . . , yn , . . .)
= Sort(y1 , . . . , yn , . . . , x1 , . . . , xn , . . .)
= t0 ?
Associativity ?: (t ? t0 ) ? t00 = ? (t0 ? t00 ) two cases:
t0 t00 = 0 , simplify expression. example,
= 0 :
(t ? t0 ) ? t00 = t0 ? t00
= ? (t0 ? t00 )
t, t0 t00 6= 0 :
(t ? t0 ) ? t00 = Sort(x1 , . . . , xn , . . . , y1 , . . . , yn , . . . , z1 , . . . , zn , . . .)
= ? (t0 ? t00 )
Property : (t k) k 0 = (k + k 0 ) have:
(t k) k 0 = (x1 + k, . . . , xn + k, . . .) k 0

= (x1 + k + k 0 , . . . , xn + k + k 0 , . . .)

= (k + k 0 )
Distributivity: (t ? t0 ) k = (t k) ? (t0 k) have:
(t ? t0 ) k = Sort(x1 , . . . , xn , . . . , x01 , . . . , x0n , . . .) k

= Sort(x1 + k, . . . , xn + k, . . . , x01 + k, . . . , x0n + k, . . .)

= (t k) ? (t0 k)


284

fiGraduality argumentation

Proof
(of Property 9) First, show relation defined Algorithm 1
partial ordering:
Let u, v, w three tupled values, relation defined Algorithm 1 is:
reflexive: u u u = u, u u u u (case 1
Algorithm 1);
transitive: suppose u v v w consider
possible cases:
u = v:
v = w: u = w u w,
|vi | |wi | |vp | > |wp |: |vi | = |ui | |wi |
|vp | = |up | > |wp |, u w,
|vi | < |wi | |vp | |wp |: |vi | = |ui | < |wi |
|vp | = |up | |wp |, u w,
|vi | = |wi | |vp | = |wp | vp lex wp
vi lex wi : |vi | = |ui | = |wi | |vp | = |up | = |wp |
vp = lex wp vi = ui lex wi , u w;
|ui | |vi | |up | > |vp |:
v = w: |ui | |vi | = |wi | |up | > |vp | = |wp |
u w,
|vi | |wi | |vp | > |wp |: |ui | |vi | |wi |
|up | > |vp | > |wp |, u w,
|vi | < |wi | |vp | |wp |: |ui | |vi | < |wi |
|up | > |vp | |wp |, u w,
|vi | = |wi | |vp | = |wp |: |ui | |vi | = |wi |
|up | > |vp | = |wp |, u w;
|ui | < |vi | |up | |vp |:
v = w: |ui | < |vi | = |wi | |up | |vp | = |wp |
u w,
|vi | |wi | |vp | > |wp |: |ui | < |vi | |wi |
|up | |vp | > |wp |, u w,
|vi | < |wi | |vp | |wp |: |ui | < |vi | < |wi |
|up | |vp | |wp |, u w,
|vi | = |wi | |vp | = |wp |: |ui | < |vi | = |wi |
|up | |vp | = |wp |, u w;
|ui | = |vi | |up | = |vp | lex vp ui lex
vi :
v = w: |ui | = |vi | = |wi | |up | = |vp | = |wp |
lex vp = wp ui lex vi = wi u w,
|vi | |wi | |vp | > |wp |: |ui | = |vi | |wi |
|up | = |vp | > |wp |, u w,
285

fiCayrol, Lagasquie-Schiex

|vi | < |wi | |vp | |wp |: |ui | = |vi | < |wi |
|up | = |vp | |wp |, u w,
|vi | = |wi | |vp | = |wp | vp lex wp
vi lex wi : |ui | = |vi | = |wi | |up | = |vp | = |wp |
lex vp lex wp ui lex vi lex wi ,
u w.
cases, u w.
Now, consider maximal minimal values:
tupled value [0 , ()] unique maximal element preordering
: let v tupled value v 6= [0 , ()], |vp | |vi | 0.
Compare [0 , ()] v Algorithm 1: [0 , ()] 6= v case number
1 used; then, |()| = 0 |vi | |0 | = |vp | two
cases:
|vp | = |vi | = 0, case 3 Algorithm 1 applied
[0 , ()] v,
else |vp | |vi | 0, case 5 Algorithm 1 applied
[0 , ()] v.
tupled value [(), 1 ] unique minimal element preordering
: let v tupled value v 6= [(), 1 ], |vi | |vp | 0.
Compare [(), 1 ] v Algorithm 1: [(), 1 ] 6= v case number
1 used; then, |()| = 0 |vp | |1 | = |vi | two
cases:
|vi | = |vp | = 0, case 2 Algorithm 1 applied
[(), 1 ] v,
else |vi | |vp | 0, case 6 Algorithm 1 applied
[(), 1 ] v.

Proof
(of Property 10) principle P10 satisfied Definition 10
fact [0 , ()] unique maximal element v(A) (see Property 9).
principle P20 satisfied Definition 10.
principles P30 P40 satisfied: possible cases improvement/degradation defence/attack given argument (see Definition 16)
applied case case31 . case leads new argument. Using Algorithm 1, comparison argument application
case shows principle P30 (or P40 , depending applied case)
31. work case case order avoid complex cases several simultaneous simple
modifications. example, modification length branch changes status
branch (an even integer replaced odd integer) complex case corresponding two simple cases:
removal branch given status, addition new branch different status.

286

fiGraduality argumentation

satisfied.



Proof
(of Property 11) Definition 10.



Proof
(of Property 12) First, consider case preferred extensions: Let
E preferred extension A, assume E contain
unattacked arguments A. So, let unattacked argument
6 E.
Consider E {A}:
E {A} conflict-free then, unattacked argument E
preferred extension, E {A} collectively defends itself, E {A}
admissible E E {A}. contradicts fact E preferred
extension.
E {A} contains least one conflict, then:

B E BRA. impossible since unattacked.
B E ARB. But, since unattacked, @C E
CRA. So, E collectively defend B,
contradiction fact E preferred extension.

So, assumption E contain unattacked arguments
cannot hold.
Now, consider stable extensions: Let E stable extension A, assume
E contain unattacked arguments A. So, let
unattacked argument 6 E.
Since 6 E exists E another argument B attacks A;
impossible since unattacked.
So, assumption E contain unattacked arguments
cannot hold.


Proof
(of Property 13) argument one direct attackers cannot belong
extension sense Dung (1995) extension must
conflict-free. So, since uni-accepted, means belongs
extensions, none direct attackers belongs extensions.
converse, use following counterexample case preferred
semantics:
287

fiCayrol, Lagasquie-Schiex

F



K

C

B
H

J

E

G

two preferred extensions
{K, H, G} {A, E, K, H}. argument cleanly-accepted (B
C belong preferred extension, belongs least one
two extensions). But,
uni-accepted belong
preferred extensions.



Proof
(of Property 14) First, uni-accepted cleanly-accepted result
Property 13.
Conversely, let cleanly-accepted argument, exists least one stable extension E E B, BRA, B 6 E 0 , E 0 stable extension.
Using reductio ad absurdum, assume exists stable extension
E 00 6 E 00 ; but, 6 E 00 , means B E 00 BRA,
so, direct attacker B belongs stable extension; so, contradiction assumption (A cleanly-accepted); so, E 00 exist
uni-accepted.


Proof
(of Theorem 1)
1. consider arguments B B 6= A. Let Xi leaf,
path C C(Xi , A) Xi1 . . . Xili Xi1 = Xi li denoting
length path (if li even, path defence branch A, else
attack branch).
constraints Xi1 Xili following:
Xi1 Xi3 . . . Xili Xili 1 . . . Xi4 Xi2 li odd 1

Xi1 Xi3 . . . Xili 1 Xili . . . Xi4 Xi2 li even 2
So, path Xi1 . . . Xili , set well-defended arguments
{Xi1 , Xi3 , . . . , Xili } li odd, {Xi1 , Xi3 , . . . , Xili 1 } otherwise (this
set arguments value strictly better
direct attackers). set denoted Accepi .
definition, set conflict-free, defends elements (because
contains leaf path arguments defended
leaf) attacks arguments path. try
288

fiGraduality argumentation

include another argument path X {Xi1 , . . . , Xili }\ Accepi ,
obtain conflict (because arguments path attacked
elements Accepi ). So, {Xi1 , . . . , Xili }, Accepi
preferred stable extension.
Consider A0 = \ {A}, R0 restriction R A032
Union Accep= Accepi , Union Accep preferred
stable extension <A0 , R0 >.
So, B A, B 6= A, B accepted iff B well-defended.

2. Now, consider A. accepted Union Accep {A}
preferred stable extension <A, R>. So, i, Xili belong
extension. Then, i, Xili 1 Xili . Therefore, branch leading
defence branch A. So, i, v(Xili ) = [()(li 1)]. So, v(A) =
[(l1 , l2 , . . . , ln )()]. Then, i, v(A) v(Xili ). Therefore, well-defended.
Using following example, show converse false:
[(2,2)(3)]

A1

[()(1)]

B1

C1
[(0...0)()]

[()(1)]

B2

[()(1)]

C2
[(0...0)()]

[(2)()]

B3

C3
[(0...0)()]

well-defended (A B1 , B2 incomparable A1 )
accepted.
3. Now, well-defended branches leading defence
branches A, Union Accep {A} conflict-free defended
direct attackers (because Xili 1 Union Accep
branch i). So, Union Accep {A} preferred stable extension
<A, R> accepted.


Proof
(of Lemma 1) Let <A, R> argumentation system finite relation
R without cycles (so, one non empty preferred stable extension
denoted E). know that:
exi-accepted direct attacker denoted B B
not-accepted,
32. R0 restriction R A0 R0 = {(a, b)|aRb, A0 , b A0 }.

289

fiCayrol, Lagasquie-Schiex

B not-accepted exists least one argument C
CRB C exi-accepted (because B belong E E
stable, C must E). So, fortiori, B not-accepted
one direct attacker C, C exi-accepted.
proof done induction depth proof tree C.
Basic case (i): exi-accepted one direct attacker B (BRA)
C1 . . . Cn direct attackers B; so, proof tree whose
depth 2 one unattacked Ci , example C1 ; so:
v(B) = g(h(v(C1 ), . . . , v(Cn )))
g(v(C1 ))

h(v(C1 ), . . . , v(Cn )) h(v(C1 )) = v(C1 )

g non-increasing

g(VMax )

v(C1 ) = VMax

so:

v(A) = g(v(B))
g 2 (VMax )
But, Property 1 says g 2 (VMax ) g(VMax ), v(A) v(B).
Basic case (ii): CRB C direct attacker B; so,
proof tree whose depth 0 C, i.e. C unattacked; so, v(C) = VMax
v(B) = g(VMax ) v(C) (following Definition 6).
General case (i): exi-accepted one direct attacker B
(BRA) C1 . . . Cn direct attackers B, one Ci exiaccepted, example C1 ; consider subgraph leading C1
add C1 RBRA, assume:
g(v(C1 )) v(C1 ) (induction assumption issued (ii))
So:

v(B) = g(h(v(C1 ), . . . , v(Cn )))
g(v(C1 ))
v(C1 )

reasons basic case
induction assumption

h(v(C1 ), . . . , v(Cn ))

property h

non-increasing g:

v(A) = g(v(B))
g(h(v(C1 ), . . . , v(Cn ))) = v(B)
290

fiGraduality argumentation

General case (ii): B not-accepted, C exi-accepted; assume
C several direct attackers D1 . . . Dp not-accepted
(because C exi-accepted); consider subgraph leading Di
add Di RCRB assume:
= 1 . . . p, g(v(Di )) v(Di ) (induction assumption issued (i))
so:
v(C) = g(h(v(D1 ), . . . , v(Dp )))
h(v(D1 ), . . . , v(Dp ))

application condition ()
since induction assumption
corresponds premise ()

so:
v(B) = g(v(C))
g(h(v(D1 ), . . . , v(Dp ))) = v(C)

Proof
(of Theorem 2) Assume () true consider exiaccepted. Let Bi , = 1 . . . n, direct attackers A. Then, =
1 . . . n, subgraph leading Bi completed Bi RA, apply
lemma obtain: g(v(Bi )) v(Bi ), = 1 . . . n. Thus, have:
v(A) = g(h(v(B1 ), . . . , v(Bn )))
h(v(B1 ), . . . , v(Bn ))

v(Bi ), = 1 . . . n

applying ()
property h

So, well-defended.
converse, let well-defended. Let B1 , . . . , Bn direct
attackers assume exi-accepted. Then, exists
least one direct attacker Bi Bi exi-accepted (because
one preferred stable extension). apply (ii) lemma
subgraph leading Bi completed Bi RA obtain g(v(Bi )) v(Bi ).
So, exists Bi direct attacker that:

v(A) = g(h(v(B1 ), . . . , v(Bn )))
g(v(Bi ))

v(Bi )

property h non-increasing g
using lemma
291

fiCayrol, Lagasquie-Schiex

contradiction well-defended. So, exi-accepted.



Appendix B. Computation tupled values
propose algorithm computing tupled values arbitrary graph (cyclic
acyclic, cycles may isolated not). algorithm uses principle propagation
values: argument evaluated values direct attackers known.
must consider cycles meta-arguments evaluated direct
attackers cycle (i.e. direct attackers one elements cycle
belong cycle) evaluated.
beginning process follows: consider arguments
initial value [0 , ()], leaves graph marked final
values. Thus, following partition graph G:
Gv : part graph already evaluated (at beginning, part contains
leaves graph),
Gv : part graph evaluated (at beginning, part contains
arguments graph G except leaves).
algorithm relies special data structure denoted L giving list
cycles graph main characteristics:
list arguments belong cycle,
list arguments belong cycle direct attackers outside
cycle (these arguments called inputs cycle; used
order propagate values across cycle case non isolated cycle);
list empty case isolated cycle.
Remark: sake efficiency, interconnected cycles (see Definition 1)
considered whole algorithm used meta-cycle. example,
two cycles B B C B direct attacker outside
cycles, described data structure L one meta-cycle
following lists:
A, B, C,
nothing (because isolated meta-cycle).
order avoid ambiguity, meta-cycles defined mcycles:
Definition 21 (mcycle) Let G attack graph. Let CC set cycles
G. Let CC 0 CC CC 0 = {C1 , . . . , Cn } set cycles.
Let ACC 0 set: {Aj Ci CC 0 Aj Ci }.
CC 0 satisfies following properties:
Aj , Ak ACC 0 , path Aj Ak element (arguments edges
arguments) path belongs cycles CC 0 ,
Ck CC \ CC 0 , 6 Ci CC 0 Ck interconnected Ci .
292

fiGraduality argumentation

union Ci belonging CC 0 mcycle.
Thus, make partition CC using notion interconnection cycles,
element partition different mcycle. See following example:


J
C

B

E

F

G



K

L

graph, 6 cycles:
{J},
{I, J, K},
{K, L},
{B, C, D},
{C, E},
{F, G}.
3 mcycles:
{I, J, K, L},
{B, C, D, E},
{F, G}.
Algorithm 2 main algorithm used computing tupled values.
function Add-Node (respectively Remove-Node) whose parameters subgraph
Gx attack graph node s, adds (resp. removes) (resp. of) Gx .
functions described (Cayrol & Lagasquie-Schiex, 2003a).
Algorithm 2 applied example step rewriting (see Figure 1). Note
order make understanding results easier, created new
arguments (as Definitions 11 12), course, would necessary rigorous
formalization.

293

fiCayrol, Lagasquie-Schiex

Algorithm 2: Algorithm computing tupled values
% Description parameters:
%
G: attack graph (partitioned Gv Gv )
%
L: data structure describing mcycles
%
n: number propagation steps mcycles
% Used variables:
%
A: current argument (to evaluated)
%
C: current mcycle (to evaluated) (containing A)
%
LAD: list direct attackers C
%
Bi : current direct attackers A, C

begin
least one argument Gv
2
= Choose-Argument(Gv )
3
belong mcycle C described L
4
Bi R (A), Bi already evaluated
5
Gv = Add-Node(Gv ,Evaluate-Node(A, R (A), 1))

%
%
%
%
%
%
%
%
%

1

Gv = Remove-Node(Gv , A)

6
7
8
9
10
11
12
13
14
15

% value
% value
% direct attackers
% add 1
% see Definition 10

else
C isolated
Gv = Add-Mcycle(Gv ,Evaluate-Mcycle-Isolated(G, C, n))
Gv = Remove-Mcycle(Gv , C)

else
LAD = Find-Direct-Attackers-Mcycle(C, G)
Bi LAD, Bi already evaluated
Gv = Add-Mcycle(Gv ,
Evaluate-Mcycle-Not-Isolated(G, C, LAD,n))
Gv = Remove-Mcycle(Gv , C)

return G
end

16

294

%
%
%
%
%

fiGraduality argumentation



C

B



E

G

F

previous argumentation graph rewritten follows:









B

B

B

C



C



C



B

B



B

B

E

C

C

E

C

C

C











B

B



B

C



C

B



C



B

B

C

B

B

E



C

C

C

C

C

B

B

B

....

....
B

C

....


....
E

G
F

results valuation obtained one propagation step are:
v(A) = [(0, . . . , 0)()],
v(B) = [(6, 8, 8, . . .)(1, 3, 5, . . .)],
v(C) = [(2, 4, 6, . . .)(5, . . .)],
v(D) = [(6, . . .)(3, 5, . . .)],
v(E) = [(4, 6, . . .)()],
v(F ) = [(8, . . .)(3, 5, 5, 7, 7, . . .)],
v(G) = [(2, 4, 6, . . .)(7, . . .)],
Figure 1: Example rewriting

295

fiCayrol, Lagasquie-Schiex

References
Amgoud, L., & Cayrol, C. (1998). acceptability arguments preference-based
argumentation. Cooper, G. F., & Moral, S. (Eds.), Proc. 14th Uncertainty
Artificial Intelligence, pp. 17, Madison, Wisconsin. Morgan-Kaufmann.
Amgoud, L., & Cayrol, C. (2002). Inferring inconsistency preference-based argumentation frameworks. Journal Automated Reasoning, 29, 125169.
Bench-Capon, T. J. (2002). Value based argumentation frameworks. Benferhat, &
Giunchiglia (Eds.), Proc. 9th International Workshop Nonmonotonic Reasoning (session Argument, Dialogue Decision), pp. 444453, Toulouse, France.
Besnard, P., & Hunter, A. (2001). logic-based theory deductive arguments. Artificial
Intelligence, 128 (1-2), 203235.
Cayrol, C., & Lagasquie-Schiex, M.-C. (2003a). Critique et amelioration de levaluation
graduelle par tuples pour le traitement des circuits. Rapport de recherche 2003-13-R,
Institut de Recherche en Informatique de Toulouse (I.R.I.T.), France.
Cayrol, C., & Lagasquie-Schiex, M.-C. (2003b). Gradual acceptability argumentation
systems. Proc. 3rd CMNA (International workshop computational models
natural argument), pp. 5558, Acapulco, Mexique.
Cayrol, C., & Lagasquie-Schiex, M.-C. (2003c). Gradual handling contradiction argumentation frameworks. Bouchon-Meunier, B., L.Foulloy, & Yager, R. (Eds.),
Intelligent Systems Information Processing: representation Applications,
chap. Reasoning, pp. 179190. Elsevier.
Doutre, S. (2002). Autour de la semantique preferee des systemes dargumentation. These,
Universite Paul Sabatier, IRIT.
Dung, P. M. (1995). acceptability arguments fundamental role nonmonotonic reasoning, logic programming n-person games. Artificial Intelligence,
77, 321357.
Dunne, P. E., & Bench-Capon, T. J. (2001). Coherence finite argument systems. Technical
report 01-006, University Liverpool, Department Computer Science (U.L.C.S.).
Dunne, P. E., & Bench-Capon, T. J. (2002). Coherence finite argument system. Artificial
Intelligence, 141 (1-2), 187203.
Elvang-Goransson, M., Fox, J., & Krause, P. (1993). Dialectic reasoning inconsistent
information. Heckerman, D., & Mamdani, A. (Eds.), Proc. 9th UAI, pp.
114121, Washington, DC. Morgan-Kaufmann.
Jakobovits, H., & Vermeir, D. (1999). Robust semantics argumentation frameworks.
Journal logic computation, 9(2), 215261.
Karacapilidis, N., & Papadias, D. (2001). Computer supported argumentation collaborative decision making: hermes system. Information systems, 26 (4), 259277.
Kohlas, J., Haenni, R., & Berzati, D. (2000). Probabilistic argumentation systems
abduction. Proc. 8th International Workshop Non-Monotonic Reasoning
- special session Uncertainty Frameworks Non-Monotonic Reasoning, pp. 391
398, Breckenridge, Colorado.
296

fiGraduality argumentation

Krause, P., Ambler, S., Elvang, M., & Fox, J. (1995). logic argumentation reasoning
uncertainty. Computational Intelligence, 11 (1), 113131.
Lin, F., & Shoham, Y. (1989). Argument systems - uniform basis non-monotonic
reasoning. Proc. first International Conference Principles Knowledge
Representation Reasoning (KR), pp. 245255.
Parsons, S. (1997). Normative argumentation qualitative probability. Proc.
first International Joint Conference Qualitative quantitative practical reasoning, ECSQARU-FAPR, LNAI 1244, pp. 466480, Germany.
Pinkas, G., & Loui, R. P. (1992). Reasoning inconsistency: taxonomy principles
resolving conflict. Allen, J., Fikes, R., & Sandewall, E. (Eds.), Proc. 3rd
KR, pp. 709719, Cambridge, MA. Morgan-Kaufmann.
Pollock, J. L. (1992). reason defeasibly. Artificial Intelligence, 57, 142.
Pollock, J. L. (2001). Defeasible reasoning variable degrees justification. Artificial
Intelligence, 133, 233282.
Prakken, H., & Sartor, G. (1997). Argument-based extended logic programming defeasible priorities. Journal Applied Non-Classical Logics, 7, 2575.
Simari, G., & Loui, R. (1992). mathematical treatment defeasible reasoning
implementation. Artificial Intelligence, 53, 125157.
Verheij, B. (2002). existence multiplicity extension dialectical argumentation. Benferhat, S., & Giunchiglia, E. (Eds.), Proceedings 9th International
Workshop Non-Monotonic Reasoning (NMR2002), pp. 416425.
Vreeswijk, G. (1997). Abstract argumentation systems. Artificial Intelligence, 90, 225279.
Xuong, N. (1992). Mathematiques discretes et informatique. Masson.

297


