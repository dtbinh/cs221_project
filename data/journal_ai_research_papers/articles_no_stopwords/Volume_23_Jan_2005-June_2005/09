journal artificial intelligence

submitted published

practical use variable elimination constraint
optimization still life case study
javier larrosa
enric morancho
david niso

larrosa lsi upc edu
enricm ac upc edu
niso casal upc edu

universitat politecnica de catalunya
jordi girona barcelona spain

abstract
variable elimination general technique constraint processing often discarded high space complexity however extremely useful
combined techniques study applicability variable elimination challenging finding still lifes illustrate several alternatives
variable elimination stand alone interleaved search source
good quality lower bounds techniques best known option
theoretically empirically experiments able solve n
instance far beyond reach alternative approaches

introduction
many arising domains resource allocation cabon de givry lobjois
schiex warners combinatorial auctions sandholm bioinformatics
probabilistic reasoning pearl naturally modeled constraint satisfaction
optimization two main solving schemas search inference search
constitute usual solving transform set
subproblems selecting one variable instantiating different alternatives
subproblems solved applying recursively transformation rule recursion
defines search tree normally traversed depth first manner
benefit requiring polynomial space practical efficiency search
greatly depends ability detect prune redundant subtrees worst case
search need explore whole search tree nevertheless pruning techniques
make much effective
inference known decomposition methods solve sequence transformations reduce size preserving optimal cost
well known example bucket elimination known variable elimination bertele
brioschi dechter proceeds selecting one variable
time replacing constraint summarizes effect chosen variable main drawback constraints may large arities require
exponentially time space process store however nice property
worst case time space complexities tightly bounded structural parameter called induced width exponential space complexity limits severely
c

ai access foundation rights reserved

filarrosa morancho niso

practical usefulness thus constraint satisfaction community variable elimination
often disregarded
consider challenging finding still lifes stable
patterns maximum density game life academic recently
included csplib repository dedicated web page set maintain
date bosch trick still life solved two
different approaches integer programming constraint programming
search none could solve n within reasonable time
best obtained hybrid combines two techniques
exploits symmetries order reduce search space
solved n case days cpu smith proposed interesting
alternative pure constraint programming techniques solving
dual form work smith could improve n limit although explicitly

mentioned two works use worst case time complexity n
usefulness variable elimination techniques first apply
plain could expected observe competitive stateof art alternatives next introduce sophisticated combines
search variable elimination following ideas larrosa dechter uses
lower bound mini buckets following ideas kask dechter
solve one minute n instance able solve
n instance far beyond reach previous techniques readability
reasons describe main ideas omit algorithmic details
structure following next section give preliminary
definitions section solve plain section introduce
hybrid obtained reported section section
discuss ideas explored article extended domains besides
report additional experimental finally section gives conclusions
lines future work

preliminaries
section first define still life next define weighted csp
framework formulate still life weighted csp finally review main
solving techniques weighted csps
life still life
game life gardner played infinite checkerboard square
called cell cell eight neighbors eight cells share one two corners
player places checkers cells checker cell
alive else dead state board evolves iteratively according following
three rules cell exactly two living neighbors state remains
www csplib org
www ai sri com nysmith life
interested reader extended version along source code implementation
www lsi upc edu larrosa publications



fion practical use variable elimination















xc











b





c

e

figure still life b constraint graph simple wcsp instance four
variables three cost functions c constraint graph assigning variable
x constraint graph clustering variables x x e constraint
graph eliminating variable x

next iteration cell exactly three living neighbors alive
next iteration cell fewer two three living neighbors
dead next iteration although defined terms extremely simple rules
game life proven mathematically rich attracted interest
mathematicians computer scientists
still life sl n consist finding nn stable pattern maximum density
game life cells outside pattern assumed dead considering
rules game easy see cell j must satisfy following three
conditions cell alive must exactly two three living neighbors
cell dead must three living neighbors cell grid
boundary e n j j n cannot part sequence three
consecutive living cells along boundary last condition needed three
consecutive living cells boundary would produce living cells outside grid
example figure shows solution sl easy verify cells
satisfy previous conditions hence stable pattern optimal
living cells stable pattern living cells exists

weighted csp
weighted constraint satisfaction wcsp bistarelli montanari rossi
defined tuple x f x x xn set variables taking values
finite domains di f set weighted constraints e cost functions
f f defined subset variables var f called scope objective
function sum functions f
f

x

f

f f

goal instantiation variables minimizes objective function
example consider wcsp four variables x xi domains di
three cost functions f x x x x f x x x x f x x x x


filarrosa morancho niso

objective function f x x x x x x x x x x clearly optimal
cost obtained every variable taking value
constraints given explicitly means tables implicitly mathematical
expressions computing procedures infeasible partial assignments specified constraints assign cost assignment value variable xi noted
xi partial assignment tuple xi v xi v xij vj extension
xi noted xi wcsps instances graphically depicted means
interaction constraint graph one node per variable one edge connecting two nodes appear scope cost function instance
figure b shows constraint graph previous example
overview solving techniques
subsection review solving techniques widely used reasoning
constraints
search
wcsps typically solved depth first search search defined
terms instantiating functions
definition let p x f wcsp instance f function f xi variable
var f v value di instantiating f xi v function scope
var f xi returns tuple f xi v instantiating p xi v
p xi v x xi di f f obtained instantiating
functions f mention xi xi v
instance instantiating example x produces
three variables xi three cost functions f x x x
f x x x x f x x x figure c shows corresponding
constraint graph obtained original graph removing instantiated variable x
adjacent edges observe graph depends instantiated variable
depend value assigned
search transform current p set subproblems usually
done selecting one variable xi instantiated different domain values
p xi v p xi v p xi vd transformation called branching subproblem process recursively applied defines tree subproblems search
expand subproblems trivial case achieved variable left
pruning condition detected optimization pruning conditions usually
defined terms lower upper bounds search keeps cost best solution
far upper bound optimal cost node lower bound best
cost obtainable underneath computed lower bound greater equal
upper bound safe backtrack
size search tree dn size largest domain bounds
time complexity tree traversed depth first space complexity polynomial


fion practical use variable elimination

clustering
well known technique constraint processing clustering dechter pearl
merges several variables one meta variable preserving semantics
clustering variables xi xj produces meta variable xk whose domain di dj cost
functions must accordingly clustered instance example clustering variables x x produces variable xc domain dc
cost functions f f clustered fc x xc f f variable
notation fc x xc x xc xc denotes th component xc function
f needs reformulated f x xc x xc constraint graph resulting
obtained merging clustered variables connecting meta node
nodes adjacent clustered variables figure shows constraint graph clustering x x typical use clustering transform
cyclic constraint graph acyclic one solved efficiently thereafter
variable elimination
variable elimination following two operations
definition sum two functions f g noted f g function
scope var f var g returns tuple sum costs f g
f g f g
definition elimination variable xi f noted f xi function
scope var f xi returns tuple cost best extension xi
f xi min f xi
adi

observe f unary function e arity one eliminating variable
scope produces constant
definition let p x f wcsp instance let xi x arbitrary variable
let bi set cost functions xi scope bi called bucket
xi define gi
x
gi
f xi
f bi

elimination xi transforms p p xi x xi di f
bi gi words p xi obtained replacing xi functions bucket
gi
p p xi optimal cost construction gi compensates
absence xi constraint graph p xi obtained forming clique
nodes adjacent node xi removing xi adjacent edges example
eliminating x example produces three variables
xi two cost functions f g scope g x x defined


filarrosa morancho niso

g f f x x x x x x x x figure shows constraint
graph elimination
previous example function g could expressed mathematical expression unfortunately general summing functions eliminating variables
cannot expressed intensionally cost functions must stored extensionally
tables consequently space complexity computing p xi proportional numq
ber entries gi xj var gi dj since xj var gi iff xj adjacent xi
q
constraint graph previous expression rewritten xj n gp dj
gp constraint graph p n gp set neighbors xi gp
time complexity computing p xi space complexity multiplied cost
computing entry gi
bucket elimination works two phases first phase eliminates variables
one time reverse order elimination xi gi function computed
added corresponding bucket elimination x produces empty scope
function e constant optimal cost second phase
considers variables increasing order generates optimal assignment variables
time space complexity exponential structural parameter
constraint graph called induced width captures maximum arity among
gi functions without additional overhead compute number optimal
solutions see dechter details
super buckets
cases may convenient eliminate set variables simultaneously dechter
fatah elimination set variables performed collecting
set functions mentioning least one variable variables functions
replaced function gy defined
gy

x

f

f

set called super bucket note elimination seen
clustering variables meta variable xy followed elimination
mini buckets
space complexity high approximation called mini buckets
dechter rish used consider elimination xi associated
bucket bi fik would compute
gi

x

f xi

f bi

time space complexity computation depends arity gi beyond
available resources partition bucket bi called mini buckets bi bik
number variables scopes mini bucket bounded parameter
compute
x
gij
f xi j k
f bij



fion practical use variable elimination


























































b

c



figure constraint graph evolution sequence variable eliminations
instantiations

gij bounded arity since
gij

gi

zx



f bi



f xi

k z x
x





f xi

j f bij

elimination variables mini buckets yields lower bound actual optimal
cost
combining search variable elimination
plain costly space combine search larrosa dechter
consider wcsp whose constraint graph depicted figure suppose
want eliminate variable want compute store constraints
arity higher two take consideration variables connected
two variables example variable x one selected
elimination transforms another one whose constraint graph depicted
figure b x degree decreased two eliminated
constraint graph depicted figure c point every variable degree
greater two switch search schema selects variable say x branches
values produces set subproblems one value domain
constraint graph depicted figure subproblem
possible eliminate variable x x elimination possible eliminate
x x subsequently x x eliminations branching done
every subproblem since constraints eliminated variables replaced
differ one subproblem another example one branching made
therefore elimination variables reduced search tree size
size domains example bounded arity constraints
two generalized arbitrary value

solving still life variable elimination
sl n easily formulated wcsp natural formulation associates one
variable xij cell j variable two domain values xij cell


filarrosa morancho niso

x
j

j

j



j

j

x



x



x



x



x

b



figure structure constraint graph sl n node center associated
cell j linked cells interacts shadowed area indicates
scope fij b left constraint graph sl clustering cells
row variables b left right evolution constraint graph
execution

dead xij alive cost function fij variable xij scope
fij xij neighbors evaluates stability xij xij unstable given
neighbors fij returns else fij returns xij objective function minimized

f

n x
n
x

fij

j

instantiation x represents unstable pattern f x returns else returns
number dead cells fij stored table entries evaluated constant
time
figure illustrates structure constraint graph sl n picture shows
arbitrary node xij linked nodes interacts instance edge
xij xi j xi j neighbor xij grid consequently
variables scope fij edge xij xi j
cells neighbors xi j grid therefore appear scope
j shadowed area represents scope fij namely xij neighbors
complete graph obtained extending connectivity pattern nodes
graph
sake clarity use equivalent compact sl n formulation
makes easier describe implement cluster variables row
single meta variable thus xi denotes state cells th row namely
xi xi xi xin xij accordingly takes values sequences
n bits equivalently natural numbers interval n cost functions
accordingly clustered cost function associated row defined


n
x

fij

j

recall wcsp task minimize number dead cells therefore give cost
dead cells cost living cells



fion practical use variable elimination

internal rows scope xi xi xi cost function top row f
scope x x cost function bottom row fn scope xn xn
unstable cell xi xi xi xi else returns number dead cells
xi evaluating n bits arguments need checked
equivalent objective function
f

n
x





figure b left shows constraint graph sl formulation arbitrary
variable xi connected two variables two variables
sequential structure constraint graph makes intuitive eliminates variables
decreasing orders elimination xi produces function gi gi xi
scope xi xi figure b left right shows evolution constraint
graph along elimination variables formally applies recursion transforms
subproblem p p xi xi variable p highest index satisfies
following property
property let gi function added replace xi gi b cost
best extension xi xi b eliminated variables xi xn formally
gi b

min

vi di vn dn

b vi b vi vi

vi vi vi
fn vn vn vn fn vn vn
gi b means pattern b cannot extended inferior rows
stable pattern gi b k k means b extended
optimal extension k dead cells xi xn
space complexity n n due space required store n functions
gi extensionally n n entries regarding time computing entry gi
cost n n finding minimum n alternatives computation one
n since gi n entries total time complexity n n observe
solving sl n exponential improvement search

time complexity n
table reports empirical obtained ghz pentium iv
machine gb memory first columns reports size second
reports optimal cost number dead cells parenthesis number living
cells third column reports number optimal solutions count different
two solutions even one transformed symmetry
fourth column reports cpu time seconds fifth sixth seventh
columns report obtained three approaches tried bosch trick
constraint programming cp integer programming ip sophisticated
cp ip combines cp ip exploits symmetries
corresponding opl code available http mat gsia cmu edu life



filarrosa morancho niso

n












opt












n sol

























cp












ip












cp ip












figure experimental four different still life times
seconds

observed clearly outperforms cp ip orders magnitude
n case largest instance could solve due exhausting available
space comparing cp ip observe clear winner additional
observation scales regularly execution requiring roughly eight times
time four times space previous clear accordance
complexity

combining search variable elimination
one way overcome high space complexity combine search variable
elimination hybrid hyb larrosa schiex idea use search
e instantiations order break independent smaller parts
variable elimination efficiently performed
let us reformulate convenient way hybrid
sake simplicity without loss generality consider n even cluster
r
row variables three meta variables xc
denotes two central cells row xi
n
l
xi denote remaining cells right left respectively see figure
l
r
consequently xc
takes values range xi xi take values range
n

cost functions accordingly clustered
n

fil




x

fir

fij

n
x
j n



j

equivalent objective function
f

n
x

fil fir





fij

fion practical use variable elimination

left

x

l


center

x

c


right

x

left

r


center

right

x

x

x
x

l


x

c


x

r


x

x

l
n

x

c
n

x

x

r
n

x

b


left

center

right

left

center

right

x
x
x
x
x
x
x
x
x
x
x
x
c



figure formulation sl n used hybrid row clustered
three variables b constraint graph sl c constraint graph
c
c
assignment xc
n xn xn constraint graph elimination
l
r
xn xn



filarrosa morancho niso

c
l c
l
c
scopes internal row functions fil fir xl
xi xi xi xi xi
c
r
c
r
c
r
l
r
l
c
c
xi xi xi xi xi xi top functions f f scopes x x xl
x
r c
r
l
r
l
c
l c
xc
x x x bottom functions fn fn scopes xn xn xn xn
r
c
r
c
xn xn xn xn figure b shows corresponding constraint graph imporr
tance formulation xl
xi independent e edge
constraint graph connecting left right variables

hybrid hyb searches central variables eliminates lateral
variables variables considered decreasing order index thus
c
c
starts instantiating xc
n xn xn produces subproblem constraint
r
graph shown figure c observe variable xl
n respectively xn connected
l
l
r
r
variables xn xn respectively xn xn eliminated producing
l
r
r
r
function gnl scope xl
n xn respectively gn scope xn xn
figure shows resulting constraint graph lateral variables domains size
n
n
hence elimination space n time important note
c
c
eliminations subject current assignment xc
n xn xn therefore
recomputed value change elimination xl
n
c
xr



would
assign
variable
x


make
possible

elimination

n
n
l
r
c
xn xn arbitrary level search assigns xi
r
makes xl
xi independent central columns related two
l
variables eliminates replacing variables functions gi
r scopes xl xl xr xr respectively formally hyb applies recursion
gi




transforms subproblem p simpler subproblems p xc v xl xr v



satisfies following property

property let gil function computed hyb used replace variable xl

l
gil b cost best extension xl


x

b

eliminated
variables


l
r
xl
xn conditioned current assignment similarly right side gi b
r
r
r
cost best extension xi xi b eliminated variables xi xr
n
conditioned current assignment

l b among coma consequence previous property minimum gi
binations b lower bound best cost obtained left
l b
part grid continue current line search therefore mina b gi
r
mina b gi b valid lower bound current node used pruning
purposes

space complexity n n due gil gir functions
need explicitly stored time complexity n n n
nodes may visited n variables domains size cost processing
n
node n due variable eliminations
thus comparing time complexity increases n n n n
prize hyb pays space decrement n n n n


fion practical use variable elimination

refining lower bound
well known average case efficiency search depends greatly
lower bound use poor lower bound gil
gir functions
kask dechter proposed general method incorporate information
yet unprocessed variables lower bound roughly idea run mini buckets
mb prior search save intermediate functions future use mb executed
reverse order search instantiate variables execution mb
completed search executed node uses mini bucket functions
compiled look ahead information subsection adapted
idea sl n integrated hyb
c
r
consider sl n formulated terms left central right variables xl
xi xi
l
c
r
exact elimination first row variables x x x done super bucket
b f l f r f l f r computing function
c
r
h f l f r f l f r xl
x x
c
r l c
r
scope h xl
x x x x x mini buckets idea partition
l
l
l
r
bucket b f f b f r f r approximate h two smaller
r
functions hl
h
l
l
l c
hl
f f x x
r
r
c
r
hr
f f x x
r
l c
l c
c
r c
r
scopes hl
h x x x x x x x x respectively
idea repeated row row increasing order general processing row yields two
functions
l
l
l c
hl
hi xi xi
r
r
c
r
hr
hi xi xi
r
l
c
l
c
c
r
c
r
scopes hl
hi xi xi xi xi xi xi xi xi respecl


tively construction hi b b contains cost best extension b b
c
l c
processed variables xl
xi x x considering left functions


property hr
b b right functions
complexity mb space n n time n n since complexities
smaller complexity hyb running pre process affect overall
complexity
r
mb executed hyb use information recorded hl
hi functions
l
r
consider arbitrary node hyb assigns xc
eliminates xi xi let
l
l
l b
b domain values variables xi xi property gi
contains best extension b attained left part rows
n long current assignment x c maintained additionally
c
c
hl
xi b xi contains best extension b attained left part
l b hl xc b xc lower bound b x c
rows therefore gi



left part grid consequently
l
c
c
mina b n gi
b hl
xi b xi



filarrosa morancho niso

lower bound left part grid current assignment
reasoning right part
l
c
c
mina b n gi
b hl
xi b xi
r
c
c
mina b n gi
b hr
xi xi b

lower bound current assignment
refining upper bound
efficiency depends initial value upper bound
good upper bound facilitates pruning earlier search tree bosch trick
suggested modify sl n adding additional constraint considering symmetric
patterns since space solutions becomes considerably smaller
presumably simpler clearly cost optimal symmetric stable pattern upper
bound optimal cost sl n observed upper bounds
tight
since motivation work use variable elimination techniques
considered still lifes symmetric vertical reflection
efficiently solved symmetric still life ssl n consists finding
n n stable pattern maximum density game life subject vertical reflection
symmetry namely state cells j n j must
adapting solve ssl n extremely simple need remove symmetrical
values domains let us assume n even number odd case similar
represent symmetric sequences bits length n considering left side
sequence e first n bits right part implicit left part thus
n
represent symmetrical sequences n bits integers interval reversing
sequence bits noted hence sequence n bits corresponding
symmetrical sequence n bits
complexity applied ssl n time n n space n n
therefore executing prior hyb setting upper bound optimal cost
affect overall complexity hybrid
exploitation symmetries
sl n highly symmetric stable pattern possible create
equivalent pattern rotating board degrees ii reflecting
board horizontally vertically along one diagonal iii combination
rotations reflections
symmetries exploited different algorithmic levels general
save computation whose outcome equivalent previous computation due
symmetry kept outcome instance mb necessary compute


l


hr
b b equal hi b b due vertical reflection symmetry
c
c
another example occurs hyb let xn vn xc
n vn xi vi current
unlike smiths work cannot easily exploit larger variety symmetries rotations
diagonal reflections



fion practical use variable elimination

n













opt













opt ssl













cp ip



























hyb













hyb lb













hyb ub













figure experimental three different still life times
seconds

c
c
assignment reversed assignment xc
n vn xn vn xi vi equivalent due
vertical reflection symmetry thus already considered
backtrack implementation uses tricks others
report would require much lower level description

experimental
figure shows empirical performance hybrid first column contains
size second column contains optimal value number dead
cells parenthesis corresponding number living cells third column contains
optimal value symmetrical ssl n obtained executing
observed ssl n provides tight upper bounds sl n fourth column
reports time obtained cp ip bosch trick fifth
column reports times obtained sixth column contains times obtained
hybrid hyb seen performance hyb spectacular
n n instances require several days cpu solved hyb
seconds instances n solved less one hour largest instance
solve n requires two days cpu figure shows optimal
n n still lifes regarding space computer handle executions
hyb n however neither n n instance could solved
within week cpu may seem solving n instance petty progress
respect previous clearly case search space


n n instances size respectively thus
able solve search space times larger
since scales regularly accurately predict would require gb
memory centuries solve n instance


filarrosa morancho niso

figure maximum density still lifes n n

since hyb combines several techniques interesting assess impact
one seventh column reports times obtained hyb without mini buckets
information lower bound seen still better plain
performance dramatically affected information gathered preprocess
improves quality lower bound anticipates pruning finally eighth column
reports times obtained hyb without upper bound initialized ssl n
case see importance technique quite limited reason
hyb even bad initial upper bound finds optimum rapidly
moment quality initial upper bound becomes irrelevant

extension domains
sl n well defined structure hybrid
proposed makes ad hoc exploitation easy right variables
instantiate eliminate easy variable order mini buckets
produces good quality lower bounds natural question whether possible apply
similar ideas well structured answer often possible
although need rely naive consequently less efficient exploitation
structure section support claim reporting additional experimental different benchmarks particular consider spot dimacs
instances spot instances optimization taken scheduling earth
observation satellite bensana lemaitre verfaillie dimacs benchmark contains sat instances several domain since concerned optimization tasks
selected unsatisfiable instances solved max sat task e given
unsatisfiable sat instance maximum number clauses simultaneously
satisfied modeled wcsp de givry larrosa meseguer schiex
consider aim instances artificially generated random sat pret graph coloring ssa
bf circuit fault analysis
figure shows constraint graph one instance domain visualized
leda graph editor observed graphs obvious pattern


fion practical use variable elimination

figure constraint graph four wcsp instances top left corner clockwise
aim pret ssa spot

exploited thus use variable elimination techniques naive way
solve generic wcsp solver toolbar tb performs depthfirst branch bound search enhanced general purpose dynamic variable
value ordering heuristics modified toolbar combine search variable elimination
follows arbitrary subproblem every variable degree less eliminated
variables degree larger equal unassigned variable
heuristically selected domain values heuristically ordered sequentially
instantiated process recursively applied subproblems note
generic version hyb decision variables
instantiated variables eliminated left heuristic instead establishing
available http carlit toulouse inra fr cgi bin awki cgi softcsp



filarrosa morancho niso

hand refer implementation tbhy b toolbar offers variety
lower bounds different forms local consistency larrosa schiex
one directional arc consistency dac essentially equivalent mini buckets
size therefore similar spirit lower bound computed hyb however
unlike hyb mini buckets executed pre process toolbar executes
dac every search state subject current subproblem shown kask
generally efficient main difference respect
hyb toolbar executes dac subject arbitrary variable ordering hyb
good order identified structure lower bounds available
toolbar node consistency nc weaker dac full directional
arc consistency fdac seen stronger refinement dac
f dac
b
experimented four tbn c tbdac tbdac
hy b tbhy b
denotes lower bound b
spot instances difficult toolbar therefore decreased size
letting toolbar make sequence k greedy assignments driven default variable
value ordering heuristics subproblem k less variables
following ik denotes instance k variables greedily assigned toolbar
default parameters
table reports experiments first column indicates instances
subsequent columns indicate cpu time seconds required different time limit seconds set execution observed
toolbar weakest lower bound tbn c usually inefficient alternative
cannot solve spot instances fails several aim ssa instances
toolbar enhanced mini buckets lower bound tbdac spot
solved domains lower bound produce significant effect add variable elimination tbdac
hy b solved
general clear speed worst improvements pret instances
time divided factor best ones obtained spot
ssa instances solved instantly typical speed ups range
dac limited
finally observe addition stronger lower bound tbfhy
b
effect execution instance ssa clearly accelerated
therefore experiments conclude main techniques used
solve still life successfully applied domains

conclusions
studied applicability variable elimination
finding still lifes finding still lifes challenging developing solving
techniques interesting task per se thus first contribution
observation plain variable elimination e competitive practice provides
time complexity exponentially better search approaches besides developed able solve n instance
clearly improved previous second contribution
deeper insight uses recent techniques variable elimination
since techniques little known rarely applied constraints community


fion practical use variable elimination


spot
spot
spot
spot
spot
spot
spot
spot
aim
aim
aim
aim
aim
aim
aim
aim
bf
pret
pret
ssa
ssa
ssa
ssa

bn c









bdac

















dac
bhy
b
























f dac
bhy
b
























figure experimental wcsp instances four different
column reports cpu time seconds symbol indicates time limit
seconds reached

presented add evidence potential shown
variable elimination used beyond academic still life providing
experimental unstructured realistic different domains

acknowledgments
authors grateful barbara smith neil yorke smith anonymous reviewers
useful comments different stages work reported article marti
sanchez kindly made plots figure funded spanish
cicyt project tic c

references
bensana e lemaitre verfaillie g earth observation satellite management
constraints
bertele u brioschi f nonserial dynamic programming academic press


filarrosa morancho niso

bistarelli montanari u rossi f semiring constraint satisfaction
optimization journal acm
bosch r trick constraint programming hybrid formulations three
life designs proceedings international workshop integration ai
techniques constraint programming combinatorial optimization
cp ai pp
cabon b de givry lobjois l schiex warners j radio link frequency
assignment constraints
de givry larrosa j meseguer p schiex solving max sat weighted
csp proc th cp pp kinsale ireland lncs springer
verlag
dechter r bucket elimination unifying framework reasoning artificial
intelligence
dechter r pearl j tree clustering constraint networks artificial intelligence
dechter r fatah e topological parameters time space tradeoff artificial
intelligence
dechter r rish mini buckets general scheme bounded inference
journal acm
gardner fantastic combinations john conways solitary game scientific american
kask k search heuristics max csp proc th cp pp
singapore lncs springer verlag
kask k dechter r general scheme automatic generation search
heuristics specification dependencies artificial intelligence
larrosa j dechter r boosting search variable elimination constraint
optimization constraint satisfaction constraints
larrosa j schiex quest best form local consistency
weighted csp proc th ijcai acapulco mexico
pearl j probabilistic inference intelligent systems networks plausible inference morgan kaufmann san mateo ca
sandholm optimal winner determination combinatorial
auctions ijcai pp
smith b dual graph translation life proc cp pp
ithaca usa lncs springer verlag




