Journal Artificial Intelligence Research 23 (2005) 533-585

Submitted 4/04; published 5/05

Using Memory Transform Search Planning Graph
Terry Zimmerman

WIZIM@CS.CMU.EDU

Robotics Institute, Carnegie Mellon University
Pittsburgh, PA 15213-3890

Subbarao Kambhampati

RAO@ASU.EDU

Department Computer Science & Engineering
Arizona State University, Tempe AZ 85287-5406

Abstract
Graphplan algorithm generating optimal make-span plans containing parallel sets actions remains one effective ways generate plans. However, despite enhancements range fronts, approach currently dominated terms speed, state space
planners employ distance-based heuristics quickly generate serial plans. report family strategies employ available memory construct search trace learn various
aspects Graphplans iterative search episodes order expedite search subsequent episodes.
planning approaches partitioned two classes according type extent
search experience captured trace. planners using aggressive tracing method
able avoid much Graphplans redundant search effort, planners second class trade
aspect favor much higher degree freedom Graphplan traversing space
states generated regression search planning graph. tactic favored second approach, exploiting search trace transform depth-first, IDA* nature Graphplans
search iterative state space view, shown powerful. demonstrate
distance-based, state space heuristics adapted informed traversal search trace used
second class planners develop augmentation targeted specifically planning graph
search. Guided heuristic, step-optimal version planner class clearly
dominates even highly enhanced version Graphplan. adopting beam search search
trace show virtually optimal parallel plans generated speeds quite competitive
modern heuristic state space planner.

1. Introduction
Graphplan introduced 1995 (Blum & Furst, 1995) became one fastest programs
solving benchmark planning problems time and, accounts, constituted radically different approach automated planning. Despite recent dominance heuristic state-search
planners Graphplan-style planners, Graphplan approach still one effective ways
generate so-called optimal parallel plans. State-space planners drowned exponential
branching factors search space parallel plans (the exponential branching result fact
planner needs consider subset non-interfering actions). 8 years since
introduction, Graphplan system enhanced numerous fronts, ranging planning
graph construction efficiencies reduce size build time one orders magnitude (Smith & Weld, 1998; Long & Fox, 1999), search speedup techniques variable
value ordering, dependency-directed backtracking, explanation based learning (Kambhampati,
2000). spite advances, Graphplan ceded lead planning speed variety heuristic-guided planners (Bonet & Geffner, 1999; Nguyen & Kambhampati, 2000; Gerevini & Serina,
2002). Notably, several exploit planning graph powerful state-space heuristics,
2005 AI Access Foundation. rights reserved.

fiZIMMERMAN & KAMBHAMPATI

eschewing search graph itself. Nonetheless, Graphplan approach remains perhaps fastest parallel planning mainly way combines iterative deepening A* (IDA*,
Korf, 1985) search style highly efficient CSP-based incremental generation applicable action
subsets.
investigate use available memory surmount Graphplans major
drawbacks, redundant search effort need exhaustively search k-length planning
graph proceeding k+1 length graph. time wish retain attractive features Graphplans IDA* search rapid generation parallel action steps ability
find step optimal plans. approach describe remains rooted iterative search planning
graph greatly expedites search building maintaining concise search trace.
Graphplan alternates two phases; one data structure called planning graph
incrementally extended, backward phase planning graph searched extract
valid plan. first regression search phase space explored given episode closely
correlated conducted preceding episode. strategy pursue work employ appropriately designed trace search conducted episode n (which failed find solution) identify avoid aspects search provably unchanged episode n+1,
focus effort features may evolved. identified precisely features dynamic across Graphplan search episodes construct search traces capture exploit features different degrees. Depending design search trace may provide benefits 1)
avoidance much Graphplans redundant search effort, 2) learning iterative search experience improve heuristics constraints embodied planning graph, 3)
realizing much higher degree freedom Graphplan, traversing space states generated regression search process. show third advantage particularly key
search trace effectiveness, allows planner focus attention promising areas
search space.
issue much memory right amount use boost algorithms performance
cuts across range computational approaches search paging process operating systems, Internet browsing database processing operations. investigation explore several alternative search trace based methods differ markedly terms memory demands.
describe four approaches paper. Figure 1 depicts pedigree family search
trace-based planners, well primary impetus leading evolution system
predecessor. figure suggests relative degree planner steps away
original IDA* search process underlying Graphplan. two tracks correspond two genres
search trace developed;


left track: EGBG planners (Explanation Guided Backward search Graphplan) employ
comprehensive search trace focused minimizing redundant search.



right track: PEGG planners (Pilot Explanation Guided Graphplan) use skeletal
trace, incurring Graphplans redundant search effort exchange reduced memory
demands increased ability exploit state space view search space.

EGBG planner (Zimmerman & Kambhampati, 1999) adopts memory intensive structure
search trace seeks primarily minimize redundant consistency-checking across Graphplans
search iterations. proves effective range smaller problems memory constraints

534

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

XY

Search
Trace
Exploiting Graphplan
Symmetry & Redundancy

Exploiting
state space view

EGBG
Leveraging CSP & memory efficiency

so-PEGG
me-EGBG
Trading step-optimality
speedup episodes

PEGG

Figure 1: Applying available memory step away Graphplan search process;
family search trace-based planners
impede ability scale up. Noting Graphplans search process viewed specialized
form CSP search (Kambhampati, 2000), explore middle ground terms memory usage augmenting EGBG several methods known effective speedup techniques CSP
problems.
primary interest techniques, however, impact memory reduction describe accomplish beyond search speedup benefit afford. implemented planner, me-EGBG, markedly outperforms EGBG speed capabilities, variety
problems still lie beyond planners reach due memory constraints.
search trace structure used PEGG track planners trades minimization redundant
search exchange much smaller memory footprint. addition greatly reduced memory
demands, PEGG search trace structure exploited intrinsic state space view
essentially Graphplans CSP-oriented search space. significant speedup advantage approach
Graphplan EGBG track planners derives ability employ distance-based
heuristics power many current generation state-space planners (Bonet & Geffner, 1999;
Nguyen & Kambhampati, 2000; Hoffman, 2001). adapt heuristics task identifying
promising states visit search trace implement approach first so-PEGG
planner (step-optimal PEGG, Zimmerman & Kambhampati, 2003). So-PEGG outperforms even
highly enhanced version Graphplan two orders magnitude terms speed,
maintaining guarantee finding step-optimal plan.
Finally explore adoption beam search approach visiting state space implicit
PEGG-style trace. employ distance-based heuristics extracted planning graph
itself, direct order search trace states visited, prune restrict
space heuristically best set states, according user-specified metric. show
planning graph leveraged provide measure likelihood previously generated regression state might spawn new search branches higher planning graph level.
535

fiZIMMERMAN & KAMBHAMPATI

term metric flux employ effective filter states skipped even
though might appear promising based distance-based heuristic. Implemented PEGG
system (Zimmerman & Kambhampati, 2003), approach exploiting search trace produces
two-fold benefit previous approaches; 1) reduction search trace memory demands
2) effective release Graphplans exhaustive search planning graph search episodes. PEGG exhibits speedups ranging 300x enhanced version Graphplan
quite competitive recent state space planner using similar heuristics. adopting beam
search PEGG necessarily sacrifices guarantee step-optimality empirical evidence indicates
secondary heuristics remarkably effective ensuring make-span solutions produced
virtually optimal.
fact systems successfully employ search trace noteworthy. general,
tactic adopting search trace algorithms explicitly generate node-states iterative
search episodes, found infeasible due memory demands exponential
depth solution. Sections 2 3 describe tight integration search trace
planning graph permits EGBG PEGG planners largely circumvent issue.
planning graph structure costly construct, terms memory time;
well-known problems even domains problematic planners employ it. (PostGraphplan planners employ planning graph purpose include STAN, Long & Fox,
1999, Blackbox, Kautz & Selman, 1999, IPP, Koehler et al., 1997, AltAlt, Nguyen & Kambhampati, 2000, LPG Gerevini & Serina, 2002). planning systems described share
memory overhead course, interestingly, found search trace memory demands
PEGG class planners significantly limited range problems solve.
remainder paper organized follows: Section 2 provides brief overview
planning graph Graphplans search process. discussion CSP nature manner process viewed IDA* search motivates potential employing available memory accelerate solution extraction. Section 3 addresses two primary challenges attempting build use search trace advantage Graphplan: 1) done within
reasonable memory constraints given Graphplans CSP-style search planning graph? and, 2)
trace available, effectively used? section briefly describes EGBG
(Zimmerman & Kambhampati, 1999), first system use search trace guide Graphplans
search, outlines limitations method (Details algorithm contained Appendix
A.) Section 4 summarizes investigations variety memory reduction techniques reports impact combination six performance EGBG. PEGG planners
discussed Section 5 performance so-PEGG PEGG (using beam search) compared enhanced version Graphplan, EGBG, modern, serial state-space planner. Section
6 contains discussion findings Section 7 compares work related research. Finally,
Section 8 wraps conclusions.
2. Background & Motivation: Planning Graphs Nature Direct
Graph Search
outline Graphplan algorithm discuss traits suggesting judicious use additional
memory might greatly improve performance. touch three related views Graphplans
search; 1) form CSP, 2) IDA* search and, 3) state space aspect.
536

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

Actions
Level 1

Initial
State
W

Planning Graph
Propositions
Propositions
Actions
Level 1
Level 2
Level 2
nop
nop

~W
W

nop

a1


Actions
Level 3

~W

nop

~W

W

nop

W

a1

a1

nop

~Y


nop

nop

nop

X
~Y

Z
H

a2

nop



a3

a3

nop

H

nop



nop

~Y


nop

H

Propositions
Level 3

a3



a4
a5

a5

nop

J

a5

J

nop

J

Domain Actions



a1

IHW
HJ

a2

X

action descriptions:



a3

~W
IJ

a4

Z


a5

J ~Y

action-ID [effects]
[preconditions]

Figure 2: Planning graph representation three levels Alpha domain
2.1 Construction Search Planning Graph
Graphplan algorithm employs two interleaved phases forward phase, data structure
called planning graph incrementally extended, backward phase planning graph
searched extract valid plan. planning graph consists two alternating structures, called
proposition lists action lists. bottom Figure 2 depicted simple domain refer
Alpha domain use illustration study. figure shows four action proposition levels planning graph engendered simple initial state given domain. start
initial state zeroth level proposition list. Given k-level planning graph, extension
graph structure level k+1 involves introducing actions whose preconditions present
kth level proposition list. addition actions domain model, operation actions
introduced, one condition kth level proposition list (abbreviated nop papers
figures, termed persists others). nop-C action C precondition C
effect. Given kth level actions, proposition list level k+1 constructed union
effects introduced actions. planning graph maintains dependency links

537

fiZIMMERMAN & KAMBHAMPATI

actions level k+1, preconditions level k proposition list, effects level
k+1 proposition list.
planning graph construction binary "mutex'' constraints computed propagated.
Figure 2, arcs denote mutex relations pairs propositions pairs actions.
propagation starts level 1 labeling mutex pairs actions statically interfering
(static mutex), preconditions effects logically inconsistent. Mutexes
propagated level forward using two simple propagation rules. Two propositions
level k marked mutex actions level k support one proposition mutex actions support second proposition. Two actions level 2 mutex statically
interfering precondition first action mutually exclusive precondition second . (We term latter dynamic mutex, since constraint may relax higher planning graph
level).1 propositions either static mutex (one negates other) dynamic mutex (all actions supporting one proposition mutex actions supporting other).
reduce Figure 2 clutter mutex arcs propositions negations omitted.
search phase k-level planning graph involves checking see sub-graph
planning graph corresponds valid solution problem. Figure 3 depicts Graphplan search
manner similar CSP variable-value assignment process. Beginning propositions
corresponding goals level k, incrementally select set actions level k action
list support goals, two actions selected supporting two different goals
mutually exclusive (if are, backtrack try change selection actions). essentially CSP problem goal propositions level variables, actions establish
proposition values, mutex conditions constitute constraints. search proceeds
depth-first fashion: goals level supported, recursively call search process k-1 level planning graph, preconditions actions selected level k
goals k-1 level search. search succeeds reach level 0 (the initial state)
solution extracted unwinding recursive goal assignment calls. process viewed
system solving Dynamic CSPs (DCSP) (Mittal & Falkenhainer, 1990; Kambhampati 2000),
wherein standard CSP formalism augmented concept variables appear
(a.k.a. get activated) variables assigned.
interleaved planning graph extension search phases, graph may extended
stasis condition, changes occur actions, propositions, mutex conditions.
sufficient condition defining level-off level new actions introduced
existing mutex conditions propositions go away. refer planning graph levels
level-off static levels. Note although graph becomes static point, finding
solution may require many episodes composed adding identical static levels conducting
regression search problem goals.
many fielded CSP solvers, Graphplan's search process benefits simple form nogood learning. set (sub)goals level k determined unsolvable, memoized level hash table. Subsequently, backward search process later enters level k
set subgoals first checked hash table, match found search
1

static mutex condition called eternal mutex dynamic mutex termed conditional mutex (Smith
& Weld, 1998).

538

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

J nop



a3



a5

W

J



a5



a5

J

a3

YJ






a3

W

Z nop



J


J

a4

nop

nop

H nop


a1
a5

J


a3

nop



J

nop

a2

X

a3

nop



Level 1

a1

X




YH J

a5



W

a4

Ha1 nop

a5



nop

nop

a1



nop


J



a1

nop







a3

Z nop

WXYZ



H nop


a1

nop J
a5

nop

nop

WYHIJ

Initial State

a5


Goal State

nop

a1

a2

a3


a3

nop

H
a1

a5

Level 2

Level 3

YHI

Icon explanation:
Action a5 assigned give
Assigned action
Assigned action
J

goal J
static mutex
dynamic mutex
a5
previous assigned action
previous assigned action
a1
Goal already satisfied
Set regressed subgoals

previously assigned action a1
satisfied next lower level

Figure 3: CSP-style trace Graphplans regression search Figure 2 planning graph
process backtracks. constitutes one three conditions backtracking: two others arise
attempts assign static mutex actions dynamic mutex actions (See Figure 3 legend).
next discuss Graphplans search higher-level view abstracts away CSP nature.
2.2 Graphplan State Space Search
abstract perspective, Graphplan viewed conducting regression state space
search problem goals initial state. view, states generated expanded subgoals result CSP process given set subgoals finds consistent
set actions satisfying subgoals planning graph level (c.f. Kambhampati & Sanchez,
2000). view state-generator function effectively Graphplans CSP-style goal assignment routine seeks non-mutex set actions given set subgoals within given planning
graph level. view depicted Figure 4, top graph casts CSP-style search trace
539

fiZIMMERMAN & KAMBHAMPATI

1

Init
State

W


2

Proposition Levels

6

2 valid sets action
assignments satisfy
goals WXYZ level 7

J a1

1

2

Init
State

W

7

W
a2 a4
H
Goal

W
X

Z

H a1, a2

4

6

Proposition Levels

S11

S6

S5

S9

S8

7

S4
W

H


S7

S10
S18

S12

8

S14

S13

S15


J

Goal

W
X

Z


S19

S17

S16


H


S20

S21
1

2

3
S23
S24

S22

W

8

S8

S27

S25

S7

W

H


S14

S13

S26

S15


J


H


S29
S19

S17

9

S5

S11

S12

7

S4

S10
S18

S30

S6
S9

S28

Init
State



Proposition Levels

S16
S21

Goal
W
X

Z

S20

Figure 4: Graphplans regression search space: Three consecutive search episodes
Figure 3 high-level state-space search trace. terms box depict set (positive)
subgoals result action assignment process goals higher-level state
box linked.2
Recognizing state-space aspect Graphplans search helps understanding connection
IDA* search. First noted briefly discussed (Bonet & Geffner, 1999), highlight expand
upon relationship here. three correspondences algorithms:
1. Graphplans episodic search process nodes generated previous episode regenerated new episode (and possibly new nodes), corresponds IDA*s iterative
search. Graphplan nodes states (sets subgoals) result regres2

Figure 4 facilitates discussion search trace next section, conjuring hypothetical problem
first search episode begins level 7 planning graph instead level 3, Figure 3.

540

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

sion search given plan graph level succeeds. perspective node-generator
function effectively Graphplans CSP-style goal assignment routine seeks non-mutex
set actions given set propositions within given planning graph level.
2. state space view Graphplans search (ala Figure 4), within given search episode/iteration algorithm conducts search depth-first fashion IDA*. ensures
space requirements linear depth solution node.
3. upper bound iteratively deepened ala IDA* node-state heuristic f-value;
f = g + h. context h distance terms associated planning graph levels
state generated Graphplans regression search initial state3 g cost reaching
state goal state terms number CSP epochs (i.e. numerical difference highest graph level states level).
purposes, perhaps important observation implicit f-value bound
given iteration length planning graph associated iteration. is,
node-state, associated planning graph level determines distance initial state (h)
cost reach goal state (g), total must always equal length plan graph.
heuristic clearly admissible; shorter distance goal Graphplan
exhaustively searches shorter length planning graphs (any) previous iterations. heuristic
implicit Graphplan algorithm guarantees step-optimal solution returned. Note
perspective nodes visited given Graphplan search iteration implicitly
f-value: g + h = length planning graph. consider implications property
address informed traversal Graphplans search space Section 5.
primary shortcoming standard IDA* approach search regenerates many
nodes iterations. long recognized IDA*s difficulties
problem spaces traced using little memory (Russell, 1992; Sen & Bagchi, 1989).
information carried one iteration next upper bound f-value. Graphplan partially addresses shortcoming memo caches store no-goods -states found
inconsistent successive episodes. However, IDA* nature search make inefficient planner problems goal propositions appear non-mutex planning graph
many levels valid plan actually extracted.
second shortcoming IDA* nature Graphplans search node-states generated
given Graphplan episode f-value (i.e. length graph). such, within
iteration (search episode) discernible preference visiting one state another.
next discuss use available memory target shortcomings Graphplans search.
3. Efficient Use Search Trace Guide Planning Graph Search
search space Graphplan explores given search episode defined constrained three
factors: problem goals, plan graph associated episode, cache memoized nogood states created previous search episodes. Typical IDA* search considerable
3

Bonet & Geffner define hG (the Graphplan h-value) somewhat differently first level goals
state appear non-mutex memoized. definition (which necessarily first level
Sm goals appear non-mutex) produces informed admissible estimate cases.
guarantees states generated Graphplan f-value equal planning graph length,
property primary interest us.

541

fiZIMMERMAN & KAMBHAMPATI

similarity (i.e. redundancy) search space successive episodes plan graph extended.
fact, discussed below, backward search conducted level k+1 graph essentially
replay search conducted previous level k certain well-defined extensions.
specifically, essentially every set subgoals generated backward search episode n, starting
level k, regenerated Graphplan episode n+1 starting level k+1 (unless solution
found first).4
returning Figure 4 entirety, note depicts state space tree structure corresponding Graphplans search three consecutive iterations. top graph, discussed above, represents subgoal states generated course Graphplans first attempt satisfy WXYZ
goal problem resembling running example. (It implied W,X,Y,Z propositions
present planning graph level 7 first level pair
mutex.) second search episode (the middle Figure 4 graph), states generated again,
one level higher. addition, states expanded generate number children,
shown darker shade. (Since Figure 4 hypothetical variation Alpha domain problem
detailed Figures 2 3, states created beyond first episode labeled state numbers representing order generated.) Finally, third episode, Graphplan regenerates states previous two episodes attempting satisfy WXYZ level 9, ultimately finds solution (the assigned actions associated figures double outlined subgoal
sets) generating states shown darkest shading bottom graph Figure 4.
Noting extent consecutive iterations Graphplans search overlap, investigate
application additional memory store trace explored search tree. first implemented
approach, EGBG (which summarized following subsection), seeks leverage appropriately designed search trace avoid much inter-episode redundant search effort possible
(Zimmerman & Kambhampati, 1999).
3.1 Aggressive Use Memory Tracing Search: EGBG Planner
types CSP-based algorithms, Graphplan consumes computational effort
given problem checking constraints. instrumented version planner reveals typically,
60 - 90% cpu run-time spent creating checking action proposition mutexes -both
planning graph construction search process. (Mutex relations incorporated planning graph primary constraints CSP view Graphplan, Kambhampati, 2000)
such, obvious starting point seeking efficiency improvements planner
primary tactic adopted EGBG. provide overview approach, referring
interested reader Appendix details.
EGBG exploits four features planning graph Graphplans search process:

4

set actions establish given proposition level k+1 always superset
establishing proposition level k.

Strictly speaking, always case due impact Graphplans memoizing process. problems
particular branch search tree generated search episode n rooted planning graph level k may revisited
episode n+1 level k+1 due no-good proposition set memoized level k+1. However, memo merely acts
avoid redundant search neglecting relatively rare cases serves simplify visualization symmetry
across Graphplans search episodes. .

542

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH



constraints (mutexes) active level k monotonically decrease increasing
planning graph levels. is, mutex active level k may may continue
active level k+1 becomes inactive never gets re-activated future levels.



Two actions level statically mutex (i.e. effects preconditions conflict
other) mutex succeeding levels.



problem goal set satisfied level k set searched
level k+1 planning graph extended. is, subgoal set present level k
two propositions mutex, remain future levels.

Given appropriate trace search conducted episode n (which failed find solution)
would ignore aspects search provably unchanged episode n+1, focus effort features may evolved. previous search failed extract solution
k-length planning graph, search k+1 length graph succeed one
following conditions holds:
1. dynamic mutex condition pair actions whose concurrent assignment
attempted episode n longer holds episode n+1.
2. subgoal generated regression search episode n planning graph level
k, action establishes episode n+1 first appears level k+1.
3. episode n regression state (subgoal set) level k matched cached memo
level memo-match generated level k+1 episode n+1.
(The discussion Appendix formalizes conditions.) instance one
conditions hold, complete policy must resume backward search search parameters associated instance previous episode, n. resumed partial search episodes
either find solution generate additional trace subgoal sets augment parent trace. specialized search trace used direct future backward search episodes problem,
viewed explanation failure search process episode. hereafter use
terms pilot explanation (PE) search trace interchangeably. following definitions useful describing search process:
Search segment: essentially state, specifically set planning graph level-specific subgoals
generated regression search goal state (which first search segment).
EGBG search segment Sn , generated planning graph level k contains:
subgoal set propositions satisfied
pointer parent search segment (Sp ), (the state level k+1 gave rise Sn)
list actions assigned Sp resulted subgoals Sn
pointer PE level (as defined below) associated Sn
sequential list results action consistency-checking process attempt satisfy Sns subgoals. possible trace results given consistency check are: static mutex,
dynamic mutex, action consistent prior assigned actions. Trace results
stored list bit vectors efficiency.
search segment therefore represents state plus path information, often use search
segment state interchangeably. such, boxes Figure 4 (whether state goals
explicitly shown not) viewed search segments.

543

fiZIMMERMAN & KAMBHAMPATI

Pilot explanation (PE): search trace. consists entire linked set search segments
representing search space visited Graphplan backward search episode. convenient
visualize Figure 4: tiered structure separate caches segments associated search
planning graph level. adopt convention numbering PE levels reverse
order plan graph: top PE level 0 (it contains single search segment whose goals
problem goals) level number incremented move towards initial state.
solution found, PE necessarily extend highest plan graph level initial state,
shown third graph Figure 4.
PE transposition: state first generated search episode n associated specific
planning graph level, say k. premise using search trace guide search episode n+1
based idea re-associating PE search segment (state) generated (or updated) episode n
next higher planning graph level. is, define transposing PE as: search
segment PE associated planning graph level k search episode n, associate
level k+1 episode n+1.
Given definitions, note states PE search episode n plan graph
level k, loosely constitute minimal set 5 states visited backward search conducted episode n+1 level k+1. (This bound visualized sliding fixed tree search
segments first graph Figure 4 one level.)
3.2 Conducting Search EGBG Search Trace
EGBG builds initial pilot explanation first regression search episode tracing
search process augmented version Graphplans assign-goals routine. solution
possible k-length planning graph, PE transposed one level, key features previous search replayed significant new search effort occurs points one
three conditions described holds. new search process PE augmented according search space visited.
EGBG search algorithm exploits search trace essentially bi-modal fashion: alternates
informed selection state search trace previous experience focused CSP-type
search states subgoals. discussion EGBGs bi-modal algorithm revolves around
second mode; minimizing redundant search effort state chosen visitation.
describe PEGGs use search trace Section 5 see greater potential
dramatic efficiency increases lies first mode; selection promising state
search trace.
choosing state visit, EGBG uses trace previous episode focus
aspects entailed search could possibly changed. search segment Si
planning graph level k+1, visitation 4step process:
1. Perform memo check ensure subgoals Si valid level k+1
2. Replay previous episodes action assignment sequence subgoals Si, using
segments ordered trace vectors. Mutex checking conducted pairs actions
dynamic mutex level k. actions longer dynamic mutex, add can5

possible Graphplans memoizing process preclude states regenerated subsequent episode.
See footnote 2 brief explanation conditions may occur.

544

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

didate action Sis list consistent assignments resume Graphplan-style search remaining goals. Si ,is augmented PE extended process. Whenever Sis goals
successfully assigned, entailing new set subgoals satisfied lower level k, child
search segment created, linked Si , added PE.
3. Si subgoal replay sequence, check new actions appearing level k+1
establish subgoal. New actions inconsistent previously assigned action
logged Sis assignments. new actions conflict previously assigned, assign resume Graphplan-style search point step 2.
4. Memoize Sis goals level k+1 solution found via search process steps 2 3.
long segments PE visited manner, planner guaranteed find
optimal plan search episode Graphplan. Hereafter refer PE search segment
visited extended via backward search find valid plan, seed segment. addition,
segments part plan extracted PE call plan segments. Thus, third
graph Figure 4, S18 apparent seed segment plan segments (in bottom order) are;
S30, S29, S18, S17, S16, S15, labeled segments YH, YHI, goal state WXYZ.
principle freedom traverse search states encapsulated PE order
longer restricted (non-informed) depth-first nature Graphplans search process.
Unfortunately, EGBG incurs high overhead associated visiting search segments order bottom (in terms PE levels). ancestor state represented PE
visited state itself, EGBGs search process would regenerate state
descendents (unless first finds solution). non-trivial cost associated generating
assignment trace information EGBGs search segments; search advantage lies reusing trace data without regenerate it.
hand, top-down visitation segments PE levels degenerate mode.
search process essentially mimics Graphplans, since episode begins search
problem goal set, (with exception replay top-level search segments assignments)
regenerates states generated previous episode -plus possibly new states-
regression search. search trace provides significant advantage top-down visitation
policy.
bottom-up policy, hand, intuitive appeal since lowest levels PE correspond portions search space lie closest initial state (in terms plan steps).
state one lower levels fact extended solution, planner avoids search
effort Graphplan would expend reaching state top-level problem goals.
Adopting bottom-up visitation policy amounts layering secondary heuristic primary
IDA* heuristic, planning graph length iteratively deepened. Recalling Section 2.2 states PE f-value terms primary heuristic, essentially biasing favor states low h-values. Support policy comes work
heuristic guided state-space planning (Bonet & Geffner, 1999; Nguyen & Kambhampati, 2000)
weighting h factor 5 relative g component heuristic f-value generally improved performance. However, unlike state-space planning systems, primary heuristic, EGBG employs secondary heuristic guarantee step optimality

545

fiZIMMERMAN & KAMBHAMPATI

Standard Graphplan

Speedup Ratios

EGBG

Problem
Time

Bktrks

Mutex
Chks

7919

2.7x

3.2x

5.5x

3,400 K

1020

10.0x

11.4x

22x

240 K

548 K

2722

24.5x

33x

42x

977 K

8901 K

6611

5.1x

6.0x

9.1x

Total
Time

Backtracks

Mutex
Checks

Total
Time

Backtracks

Mutex
Checks

Size
PE

BW-Large-B
(18/18)

213

2823 K

121,400 K

79

880 K

21,900 K

Rocket-ext-a
(7/36)

402

8128 K

74,900 K

40

712 K

Tower-5
(31/31)

811

7907 K

23040 K

33

Ferry-6
(39/39)

319

5909 K

81000 K

62

Table 1: Comparison EGBG standard Graphplan.
Numbers parentheses give number time steps / number actions respectively. Search backtracks
mutex checks performed search shown. "Size PE" pilot explanation size terms
final number search segments. Standard Graphplan Lisp version Smith Peot.

depend admissibility. found bottom-up visitation efficient mode
EGBG default order EGBG results reported study.
3.3 EGBG Experimental Results
Table 1 shows performance results reported first version EGBG (Zimmerman &
Kambhampati, 1999). Amongst search trace designs tried, version memory
intensive records greatest extent search experience. Runtime, number search
backtracks, number search mutex checks performed compared Lisp implementation original Graphplan algorithm. EGBG exhibits clear advantage Graphplan
small set problems;




total problem runtime: 2.7 - 24.5x improvement
Number backtracks search: 3.2 - 33x improvement
Number mutex checking operations search: 5.5 - 42x improvement

Since total time is, course, highly dependent machine well coding language 6
(EGBG performance particularly sensitive available memory), backtrack mutex checking
metrics provide better comparative measure search efficiency. Graphplan, mutex checking
far biggest consumer computation time and, such, latter metric perhaps
complete indicator search process improvements. problem-to-problem variation
EGBGs effectiveness attributed static/dynamic mutex ratio characterizing Graphplans
action assignment routine. action assignments rejected due pair-wise statically mutex
actions, greater advantage enjoyed system doesnt need retest them. Tower-ofHanoi problems fall classification.
noted original study (Zimmerman & Kambhampati, 1999) range problems
6

planners developed report coded Allegro Lisp run Pentium 900 mhz, 384 RAM.
Runtimes include plangraph construction time exclude garbage collection time. Values Table 1 differ
published 1999 problems re-run platform. reflect changes tracking statistics.

546

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

handled implementation significantly restricted amount memory available
program runtime. example, PE consisting almost 8,000 search segments,
modest sized BW-Large-B problem challenges available memory limit test machine.
consider next approach (me-EGBG Figure 1) occupies middle ground terms memory
demands amongst search trace approaches investigated.
4. Engineering Reduce EGBG Memory Requirements: me-EGBG Planner
memory demands associated Graphplans search process major concern, since
conducts depth-first search search space requirements linear depth solution node.
Since seek avoid redundancy inherent IDA* episodes Graphplans search using
search trace, must deal much different memory-demand profile. search trace design
employed EGBG memory requirements exponential depth solution. However, search trace grows direct proportion search space actually visited, techniques
prune search act greatly reduce memory demands.
examined variety methods respect issue, eventually implemented suite
seven together proven instrumental helping EGBG (and later, PEGG) overcome memorybound limitations. Six known techniques planning CSP fields: variable ordering, value ordering, explanation based learning (EBL), dependency directed backtracking (DDB),
domain preprocessing invariant analysis, transitioning bi-partite planning graph. Four
six effective methods CSP speedup techniques, however interest lies primarily
impact search trace memory demands. challenging aspects adapting
methods planning graph search trace context, focus paper. Thus details
motivation implementation methods relegated Appendix B.
seventh method, novel variant variable ordering call EBL-based reordering, exploits
fact using EBL search trace available. Although method readily implemented PEGG, strict ordering trace vectors required EGBG search trace make
costly implement planner. such, memory-efficient EGBG (me-EGBG) use
EBL-based reordering defer discussion PEGG introduced Section 5.
4.1 Impact Enhancements EGBG Memory Demands
two major modes first six techniques impact memory demand me-EGBG:
1) Reduction size pilot explanation (search trace), either number search segments
(states), average trace content within segments, 2) Reduction requirements
structures compete pilot explanation available memory (i.e. planning graph
memo caches). Admittedly, two dimensions independent, since number
memos (though size) linear number search segments. nonetheless consider
partition discussion facilitate comparison methods impact search
trace.
general, impact enhancements search process depends significantly,
particular problem, presence (or absence) methods.
single configuration techniques proves optimal across wide range problems. Indeed, due
computational overhead associated methods, generally possible find class
problems planner performance degrades due presence method. chose
547

fi90
DDB

40

50

60

70

80

six combination
( me-EGBG )

30

EBL

20

Domain preprocess /
Invariant Analysis
Value Ordering

10

% reduction PE (search trace) memory requirement

100

ZIMMERMAN & KAMBHAMPATI

Variable Ordering

10

20

30

Bi-partite graph

40

50

60

70

80

90

100

% reduction planning graph, memo cache memory requirements

Figure 5: Memory demand impact along two dimensions six memory reduction/speedup
techniques. Plots applied independently suite (within EGBG).
set techniques then, based joint average impact me-EGBG / PEGG memory footprint
extensive variety problems.
Figure 5 illustrates method impact memory reduction relative two dimensions above, method operates isolation others. plot reflects results based
twelve problems three domains (logistics, blocksworld, tower-of-hanoi), chosen include
mix problems entailing large planning graphs, problems requiring extensive search, problems
requiring both. horizontal axis plots percent reduction end-of-run memory footprint
combined memo caches planning graph. ratios along ordinate assessed based
runs Graphplan (no search trace employed) memo cache planning graph
globally defined structures significant size remain Lisp interpreted environment
run completion.7 Similarly, vertical axis plots percent reduction space required PE
end EGBG runs without method activated, planning graph
memo cache structures purged working memory.
plot crossbars method depict spread reduction values seen across twelve
problems along dimensions, intersection average. bi-partite planning
graph, surprisingly, impacts graph aspect, five six methods seen
impact search trace size graph/memo cache size. these, DDB greatest influence PE size little impact graph memo cache size, EBL modest influence former larger impact latter (due smaller memos creates
7

Allegro Common Lisp global scavenging function used purge target global data structures
workspace.

548

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

production general memos, engender backtracks). Domain preprocessing/ invariant analysis major impact graph size PE size due processes
extraction invariants operator preconditions. highly domain dependent, little effect case blocksworld problems, great consequence tower-ofHanoi logistics problems.
six methods combined complement evidenced crossbars plotting space reduction six employed once. twelve problems average reduction
PE size approaches 90% average reduction planning graph/memo cache aspect exceeds
80%. single method isolation averages 55% reduction along dimensions.
runtime reduction associated methods isolation highly dependent
problem methods active. general, relative time reduction
two methods correlate closely relative memory reduction. However, found
similarly, techniques broadly complement net speedup accrues.
techniques listed (and been) used improve Graphplans performance also, terms speed. order focus impact planning search trace, use
version Graphplan enhanced six methods comparisons me-EGBG
PEGG study (We hereafter refer enhanced version Graphplan GP-e).
4.2 Experimental Results me-EGBG
Table 2 illustrates impact six augmentations discussed previous section EGBGs
(and Graphplans) performance, terms space runtime. Standard Graphplan, GP-e,
EGBG, me-EGBG compared across 37 benchmark problems wide range domains, including problems first three AIPS planning competitions held date. problems
selected satisfy three objectives: subset standard Graphplan EGBG could solve
comparison me-EGBG, different subsets exceed memory limitations three
planners terms either planning graph PE size, subset gives rough impression
search time limitations.
surprisingly, memory efficient EGBG clearly outperforms early version problems attempted. importantly, me-EGBG able solve variety problems beyond reach
standard Graphplan EGBG. 37 problems, standard Graphplan solves 12, original EGBG solves 14, GP-e solves 32, me-EGBG solves 32. Wherever me-EGBG GP-e solve
problem, me-EGBG faster factor 62x, averages ~4x speedup. Standard
Graphplan (on twelve problems solve), bested me-EGBG factors ranging 3x
1000x.
striking improvement memory efficient version EGBG first version
simply due speedup associated five techniques discussed previous section,
directly tied impact search trace memory requirements. Table 2 indicates one three reasons instance problem solved planner: 1) s: planner still search
30 cpu minutes, 2) pg: memory exhausted exceeded 30 minutes planning graph building phase, 3) pe: memory exhausted search due pilot explanation extension. third reason clearly favors me-EGBG size PE (reported terms search segments time
problem solved) indicates generates retains trace 100x fewer states
EGBG. translates much broader reach me-EGBG; exhausts memory 14%
549

fiZIMMERMAN & KAMBHAMPATI

Table 2 problems compared 49% first version EGBG. Regardless, GP-e solves three
problems me-EGBG fails 30 minutes due search trace memory demands
table illustrates dramatic impact speedup techniques Graphplan itself.
enhanced version, GP-e, well 10x faster original version problems
solve 30 minutes, solve many problems entirely beyond standard Graphplans reach.
Nonetheless, me-EGBG modestly outperforms GP-e majority problems
solve. Since EGBG (and PEGG) planners derive strength using PE shortcut
Graphplans episodic search process, advantage realized problems multiple search
episodes high fraction runtime devoted search. Thus, speedup seen grid-y-1
problems mystery, movie, mprime domains solution extracted
soon planning graph reaches level containing problem goals non-mutex state.
bottom-up order EGBG visits PE search segments turns surprisingly effective many problems. Table 2 problems found great majority PE final
episode contains seed segment (a state search reach initial state) within
deepest two three PE levels. supports intuition discussed Section 3.2 suggests
advantage low h-value bias observed heuristic state-space planners (Bonet & Geffner,
1999; Nguyen & Kambhampati, 2000) trans-lates search planning graph.
Results even memory efficient version EGBG reveal two primary weaknesses:
1. action assignment trace vectors allow EGBG avoid redundant search somewhat
costly generate, make significant demands available memory problems elicit large
search (e.g. Table 2 problems: log-y-4, 8puzzle-1, freecell-2-1), difficult revise
search experience alters drastically subsequent visits.
2. Despite surprising effectiveness many problems, bottom visitation PE search
segments inefficient others. Table 2 problems freecell-2-1 essentially
schedule domain problems, planning graph gets extended level
solution extracted, solution arises via new search branch generated root
search segment (i.e. problem goal state). Thus, seed segment PE topmost search segment, bottom-up visitation PE states costly Graphplans
top-down approach.
first shortcoming particularly manifest problems allow EGBG exploit
PE (e.g. problems solution extracted first search episode). hit EGBG
takes problems relative Graphplan closely tied overhead associated building
search trace. compelling tactic address second shortcoming traverse search space
implicit PE according state space heuristics. might wish, example, exploit
variety state-space heuristics revolutionized state space planners recent years
(Bonet & Geffner, 1999; Nguyen & Kambhampati, 2000; Gerevini & Serina, 2002). However,
noted Section 3.2, depart policy visiting EGBG search segments level-bylevel, bottom-up order, face costly bookkeeping high memory management overhead.
informed traversal state-space view Graphplans search space taken next,
argue perhaps key benefit afforded trace search planning graph.

550

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

Problem

(steps/actions)

bw-large-B (18/18)
huge-fct
(18/18)
rocket-ext-a (7/34)
att-log-a
(11/79)
gripper-8 (15/23)
Tower-6
(63/63)
Tower-7 (127/127)
8puzzle-1 (31/31)
8puzzle-2 (30/30)
TSP-12
(12/12)
AIPS 1998
grid-y-1 (14/14)
grid-y-2 (??/??)
gripper-x-3 (15/23)
gripper-x-4 (19/29)
gripper-x-5 (23/35)
log-y-4
(11/56)
mprime-x-29 (4/6)
movie-x-30 (2/7)
mysty-x-30 (6/14)
AIPS 2000
blocks-10-1 (32/32)
blocks-12-0 (34/34)
logistics-10-0 (15/56)
logistics-11-0 (13/56)
logistics-12-1 (15/77)
freecell-2-1 (6/10)
schedule-8-5 (4/14)
schedule-9-2 (5/13)
AIPS 2002
depot-6512 (10/26)
depot-7654a (10/28)
driverlog-2-3-6a (10/24)
driverlog-2-3-6e (12/28)
roverprob1425 (10/32)
roverprob1423 (9/30)
strips-sat-x-5 (7/22)
strips-sat-x-9 (6/35)
ztravel-3-8a (7/25)
ztravel-3-7a (10/21)

EGBG

Graphplan
cpu sec

Stnd.
126
165

GP-e

cpu sec

(enhanced)

11.4
13.0

3.5

12.2
125
14.2

43.1

158
667
57.1
304
48.3

454
Graphplan
GP-e
388
16.7
pg
pg
291
16.1

190


pg
470
15.7
5.5
.1
.05
83
13.5
Graphplan
GP-e

101

24.2

30.0

78.6



98.0
pg
63.5
pg
58.1
Graphplan
GP-e
239
5.1

32.5
1280
2.8

169

18.9

170
313
47.0



972



79
98
40.3
pe
88
39.1

pe
pe
pe
393
pg
200
pe
pe
pg
6.6
.06
85

size
PE

7919
8410
1020
9790
3303

EGBG
19
9888

4
2
32
EGBG

pe
pe

pe
pe
pe
pg
pg
219

807

979
pe
272

pe
pe

EGBG
4272
1569
10028
4111

me-EGBG

SPEEDUP
(me-EGBG
vs. GP-e)

2090
2964
174
1115
2313
80
166
pe
>16000
26.9
10392
97.0
7155
me-EGBG
16.9
15
pg
8.4
2299
65.7
6351
433
13572
pe
>25000
5.5
4
.05
2
13.5
19
me-EGBG
16.1
6788
14.5
3220
16.3
1259
10.0
1117
1205
7101
pe
>12000
42.9
6
46.8
6
me-EGBG
4.1
456
14.8
1199
1.0
230
83.3
7691
10.3
1522
94.7
10217
23.0
2717
84.4
306
15.6
1353
>20000
pe

1.2x
1.4x
1.9x
1.7x
1.8x
5.7x
7.9x
(pe)
1.8x
4.7x
Speedup
1x
~
1.9x
2.9x
> 5x
(pe)
1x
1x
1x
Speedup
6.3x
1.7x
1.8x
7.9x
> 2x
(pe)
1.5x
1.2x
Speedup
1.25x
2.2x
2.8x
2x
1.8x
1.8x
2.0x
>21x
62x
~

(memory efficient EGBG)
cpu sec
size
PE

9.2
9.1
1.8
7.2
7.9
7.6
20.0

Table 2: Search step-optimal plans: EGBG, me-EGBG, standard & enhanced Graphplan
Standard Graphplan: Lisp version Smith Peot
GP-e: Graphplan enhanced per Section 4.1 me-EGBG: memory efficient EGBG
Size PE final search trace size terms number "search segments"
Search failure modes: pg Exceeded 30 mins. memory constraints graph building
pe Exceeded memory limit search due size PE
Exceeded 30 mins. search
Parentheses adjacent cpu time give (# steps / # actions) solution.
551

fiZIMMERMAN & KAMBHAMPATI

5. Focusing State Space View: so-PEGG PEGG Planners
costs associated EGBGs generation use search trace directly attributable
storage, updating, replay CSP value assignments search segments subgoals.
therefore investigated stripped version search trace abandons tactic focuses
instead embodied state space information. show PEGG planners employing
search trace (both so-PEGG, step-optimal version PEGG, version using beam search),
outperform EGBG planners larger problems. key difference EGBGs pilot explanation pared down, skeletal PE used PEGG planners, elimination detailed
mutex-checking information contained bit vectors former (i.e. last item bullet
list EGBG search segment contents Section 3.1). PEGG planners apply state-space
heuristics rank PE search segments based associated subgoal sets (states) free
visit state space informed manner. tradeoff PE state visited
planner must regenerate CSP effort finding consistent action assignments subgoals.
Figure 6 illustrates PEGG advantage small hypothetical search trace final search episode. search segments PE onset episode appear solid lines plan
segments (states extendable valid plan) shown double-lined boxes. figure reflects
fact typically may many latent plan segments diverse branches search trace
solution-bearing episode. Clearly planner discriminate plan segment states
states PE could solve problem quickly planner restricted bottom-up traversal (deepest PE level first). State space heuristics endow PEGG planners capability.
so-PEGG planner visits every search segment PE search episode (comparable Graphplans exhaustive search given length graph) thereby guaranteeing returned
plans step-optimal. such, advantage heuristic-guided traversal realized
final episode. many problems, computational effort expended Graphplan last search
episode greatly exceeds previous episodes combined, still powerful advantage. However, scale problems larger terms number size search
episodes, cost exhaustive search even intermediate episodes becomes prohibitive.

3
Init
State

Goal

1

W

W
X

Z

2



4
.
.

.
.

.
.

1

2

3

.
.

.
.
.

Proposition Levels

7

8

Figure 6: PE final search episode hypothetical problem. Search segments PE
onset search appear solid lines, double-lined boxes represent plan segments,
dashed lined boxes states newly generated regression search episode.
Visitation order dictated secondary heuristic shown via numbering.
552

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

planner refer simply PEGG employs beam search, applying search trace heuristics
intermediate search episodes visit select subset PE segments. PEGG
trades step-optimality guarantee often greatly reduced solution times.
several challenges must dealt effectively use pared search trace
employed so-PEGG PEGG, including adaptation augmentation distance-based heuristics guide search trace traversal dealing memory management problems induced
tactic skipping search space. describe addressed issues
give complete description algorithm, first present results provide perspective effectiveness planners.
5.1 Experimental Results so-PEGG PEGG
Table 3 compares Graphplan (standard GP-e), me-EGBG, so-PEGG, PEGG
problems Table 2, adds variety larger problems latter two systems
handle. Table 2 problems easily solved GP-e me-EGBG (e.g. AIPS-98
movie mystery domains) omitted Table 3. Here, planners employ variable
value ordering (i.e. except standard Graphplan), configured use value ordering based
planning graph level action first appears goal ordering based proposition distance
determined adjusted-sum heuristic (which defined below). variety
parameters so-PEGG PEGG planners optimal configurations tend
problem-dependent. defer discussion Sections 5.3, 5.4, 5.6 note
Table 3 results following parameter settings used based good performance average
across variety domains problems:
Secondary heuristic visiting states: adjusted-sum w0=1 (eqn 5-1)
Beam search: visit best 20% (lowest f-value) search segments per search episode,
minimum 25 maximum 50. Search segments flux lower 10% average
visited regardless heuristic rank. (wcf = .01, see section 5.6.1)
Focusing first GP-e, me-EGBG, so-PEGG columns, clearly see impact
tradeoff storing exploiting intra-segment action assignment information PE.
set 37 problems, 16 result me-EGBG exceeding available memory due size
PE one pushes limit so-PEGG. Seven problems cause me-EGBG run
memory actually solved so-PEGG remainder exceed time limit
search. addition, so-PEGG handles five problems table GP-e fails on. problems
typically entail extensive search final episode, PE efficiently shortcuts full-graph
search conducted GP-e. speedup advantage so-PEGG relative GP-e ranges
modest slowdown three problems almost 87x Zeno-Travel problems, average
5x. (Note speedup values reported table so-PEGG.)
Generally, planner using search trace perform GP-e single search episode problems grid-y-1, cost building trace recovered. low overhead associated building so-PEGGs search trace means suffers little relative GP-e case.
problems me-EGBG so-PEGG solve, me-EGBG upper hand due
ability avoid redundant consistency-checking effort. fact me-EGBGs advantage soPEGG greater problems attributable so-PEGGs ability move PE
search space final search episode (versus me-EGBGs bottom-up traversal) lower
553

fiZIMMERMAN & KAMBHAMPATI

Graphplan

Problem

cpu sec (steps/acts)

Stnd.
bw-large-B
bw-large-C
bw-large-D
att-log-a
att-log-b
Gripper-8
Gripper-15
Tower-7
Tower-9
8puzzle-1
8puzzle-2
TSP-12
AIPS 1998
grid-y-1
gripper-x-5
gripper-x-8
log-y-5
AIPS 2000
blocks-10-1
blocks-12-0
blocks-16-2
logistics-10-0
logistics-12-1
logistics-14-0
freecell-2-1
freecell-3-5
schedule-8-9
AIPS 2002
depot-7654a
depot-4321
depot-1212
driverlog-2-3-6e
driverlog-3-3-6b
roverprob1423
roverprob4135
roverprob8271
sat-x-5
sat-x-9
ztravel-3-8a
ztravel-3-7a

194.8








2444
1546

Stnd GP
388


pg
Stnd GP

~

~


pg
pg
pg
Stnd GP








313




GP-e

me-EGBG
cpu sec
(steps/acts)

(enhanced )

11.4 (18/18)
(28/28)
(38/38)
31.8 (11/79)

14.2 (15/23)

158 (127/127)
(511/511)
57.1 (31/31)
48.3 (30/30)
454 (12/12)
GP-e
16.7 (14/14)


470 (16/41)
GP-e
95.4 (32/32)
26.6 (34/34)

30.0 (15/56)


98.0 (6/10)
1885 (7/16)
300 (5/12)
GP-e
32.5 (10/28)


166 (12/28)

170 (9/30)


45 (7/22)

972 (7/25)


9.2

so-PEGG
heur:istic:
adjsum

cpu sec
(steps/acts)

7.0
1104
pe
7.2
2.9 (11/72)
pe

7.9
30.6
pe

20.0
14.3
232
118
pe
31.1
26.9
31.3
97.0
390
me-EGBG
so-PEGG
17.9
16.8
433
512
pe

pe
361
me-EGBG
so-PEGG
16.1
18.7
14.5
23.0
pe

16.6
21
1205 (15/77) 1101 (15/75)
pe

pe
102
pe
511
615
719
me-EGBG
so-PEGG
14.8
12.9




83.3
109
pe
1437 (11/39)
pe
63.4
pe

pe

43.0
27.0
918
9.9
15.6
11.2
pe

pe
pe

PEGG

heur: adjsum-u

cpu sec
(steps/acts)

Speedup
(PEGG
vs. GP-e)

4.1
24.2
388
2.2
21.6
5.5
46.7
6.1
23.6
9.2
7.0
6.9

(18/18)
(28/28)
(38/38)
(11/62)
(13/64)
(15/23)
(31/45)
(127/127)
(511/511)
(31/31)
(32/32)
(12/12)
PEGG
16.8 (14/14)
110 (23/35)
520 (35/53)
30.5 (16/34)
PEGG
6.9 (32/32)
9.4 (34/34)
28.1 (56/56)
7.3 (15/53)
17.4 (15/75)
678 (13/74)
19.5 (6/10)
101 (7/17)
719 (5/12)
PEGG
13.2 (10/26)
42.6 (14/37)
79.1 (22/53)
80.6 (12/26)
169 (14/45)
15.0 (9/26)
379 (12 / 43)
220 (11 / 39)
25.1 (7 / 22)
9.9
(6 / 35)
15.1 (9/26)
101 (10/23)

2.8x
> 74x
> 4.6x
14.5x
> 83x
2.6x
> 38.5x
26x
> 76x
6.2x
6.9x
51x
Speedup
1x
> 16x
> 3.5x
15.4x
Speedup
13.8x
2.8x
> 64 x
4.1x
> 103x
> 2.7x
>92x
18.7x
(.42x)
Speedup
2.7x
>42x
>22.8x
2.1x
> 10.7x
11.3x
> 4.7x
> 8.2x
1.7x
>182x
119x
> 18x

Table 3: so-PEGG PEGG comparison Graphplan, GP-e, me-EGBG
GP-e: Graphplan enhanced per Section 4.1 me-EGBG: memory efficient EGBG
so-PEGG: step-optimal, search via PE, segments ordered adjusted-sum-u heuristic
PEGG: beam search, best 20% segments PE ordered adjusted-sum-u heuristic
Parentheses give (# steps/ # actions) plan. Boldface values exceed known
step-optimal.
See Table 2 definitions s, pg, pe
554

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

overhead due concise search trace. Note obvious reason prefer one state
traversal order non solution-bearing episodes since step-optimal planners visit
states PE search episodes. 8
turning attention PEGG results, apparent beam search greatly extends
size problems handled. PEGG solves ten larger problems Table 3 could
solved either so-PEGG enhanced Graphplan. Speed-wise PEGG handily outperforms
planners every problem except schedule-8-9, GP-e factor 2.3x advantage. indicated tables right-hand column, speedup PEGG GP-e ranges .42x
182x. conservative bound PEGGs maximum advantage relative GP-e since speedup
values seventeen problems GP-e fails solve conservatively assessed time
limit 1800 seconds.
defer analysis results Section 6 order first describe PEGG algorithm
advantages extracts search trace.
5.2 Algorithm PEGG Planners
high-level algorithm so-PEGG PEGG given Figure 7. Graphplan, search begins planning graph extended level problem goals first appear
binary mutex conditions. (The routine, find_1st_level_with_goals virtually
Graphplans defined here). first search episode conducted Graphplan fashion,
except assign_goals assign_next_level_goals routines Figure 8 initialize PE
create search segments hold states generated regression search process. assign_goals pseudo-code outlines process compiling conflict sets (see Appendix B) means
implementing DDB EBL action assignment search. assign_next_level_goals
routine illustrates role top-level conflict set recording minimal no-good search
state completed (EBL) depicts variable ordering need done state
(when search segment created). child segment created linked parent (extending
PE) assign_next_level_goals whenever parent goals successfully assigned. assign_next_level_goals routine determines subgoals child search segment regressing
parents goals actions assigned checks see either initial state
reached remaining goals. so, success signaled returning child search segment used extract ordered actions plan.
Subsequent first episode, PEGG_plan enters outer loop employs PE conduct
successive search episodes. episode, newly generated search segments previous
episode evaluated according state space heuristic, ranked, merged already ordered
PE. inner loop search segment visited turn passing subgoals Graphplanlike assign_goals routine.
exit conditions inner loop primarily differentiate so-PEGG PEGG.
Whereas so-PEGG visit every search segment whose goals found match memo,
PEGG restricts visitation best subset, based user-specified criterion. such, expansion
planning graph deferred segment chosen visitation transposes planning graph level exceeding current graph length. consequence, problems PEGG
8

fact found advantages respect traversal order even intermediate search episodes problems. However, highly problem-dependent, consider study.

555

fiZIMMERMAN & KAMBHAMPATI

PEGG_PLAN (Ops, Init, Goals) /*{ Ops, Init, Goals} constitutes planning problem */
/* build plangraph, PG, level n goals first occur non-mutex state*/

Let PG find_1st_level_with_goals( Ops, Init, Goals )
PG reached level-off goals present non-mutex state Return FAIL
Let n number levels PG
Reorder Goals according variable ordering method
Let SS0 new search segment fields:
goalsGoals, parent root, PE-level 0, parent-actions {}
Let PE pilot explanation structure fields: ranked-segs {SS0}, new-segs {}

/* Conduct Graphplan-style backward search n-length planning graph, storing trace PE..*/

Let search-reslt assign_goals(Goals, {}, n, SS0, PG, PE)
search-reslt search segment /* Success */
Let Plan extract plan actions ancestors linked search-reslt
Return Plan
else /* n-length solution possible ...use PE search longer length solution */
loop forever
n n+1
/* rank newly generated states merge existing ordered PE segments list */
PE<ranked-segs> merge sort(PE<ranked-segs> U heuristic_sort( PE<new-segs> ) )

loop unvisited search segments PE[ranked-segs] (optionally: segments
heuristic threshold)
Let SS highest ranked, unvisited segment PEs ranked-segs
Let k = n (PE-level SS)
/*... planning graph level SS based transposed PE */
k = n PG extend_plangraph(PG) /*.. delays extending graph unavoidable! */
optionally: flux metric SS goals < user-specified threshold continue loop.
SS goals memos level k PG remove SS PEs ranked-segs
else /* visit search segment SS... */
search-reslt assign_goals (SS<goals>, {}, k, SS, PG, PE)
search-reslt search segment /* Success...*/
Let Plan extract plan actions ancestors linked search-reslt
Return Plan
else search-reslt conflict set..
add conflict set level k memos PG /* memoize minimal nogood */
reorder SS goals goals conflict set appear first /* EBL-based reordering */
end
end-loop
end

Figure 7: Top-level algorithm PEGG so-PEGG planners.
planners may able extract step-optimal solution building one less level Graphplan-based planners.9

9

Interestingly, PEGG beam search could conceivably extract optimal solution planning graph arbitrary number levels shorter required Graphplan. Consider case PE, average, extends least
one level deeper episode subset PE search segments visited always resides deepest levels PE.
arbitrary number search episodes might completed without extending planning graph. Based experiments problems date however, advantage seldom saves one planning graph level extension.

556

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

Conduct DDB & EBL-enhanced Graphplan-style search building search trace
arguments> G: goals still assigned, A: action set already assigned, k: PG level,
SS1: search segment, PG: planning graph, PE: pilot explanation (search trace)
ASSIGN_GOALS (G, A, k, SS1, PG, PE)
Let g goal selected G
Let Ag actions PG level k support g, ordered value-ordering heuristic
Let cs {g} /* initialize conflict set DDB */
loop act Ag
Let search-reslt = {}
act mutex action
Let b goal conflicted action assigned support
cs cs U {b} /* augment conflict set continue loop*/
else /* act conflict actions already */
G-{g} empty
/* continue goal assignment level */
search-reslt assign_goals (G-{g}, U{act}, k, SS1, PG, PE)
else /* SS1 goals left satisfy...setup search next lower level */
search-reslt assign_next_level-goals (A U{act}, k, SS1, PG, PE)
search-reslt conflict set, check contains current goal..
g search-reslt
/* absorb returned conflict set & try next action */
cs cs U search-reslt
else Return search-reslt /*just return conflict set */
else search-reslt search segment: /* Success.. */
Return search-reslt
end loop (actions)
Return cs /* soln reached .. compiled conflict set returned*/
end-if
end
Set search graph level k-1 given SS1 goals satisfied actions level k
ASSIGN_NEXT_LEVEL_GOALS (A, k, SS1, PG, PE)
Let nextgoals regress SS1 goals (the actions assigned satisfy goals)
nextgoals empty k = 0 (its initial state)
Return SS1 /* Success */
else memos level k-1 PG nextgoals
Return conflict set /* backtrack due nogood */
else /* initiate search next lower PG level*/
Let SS2 new search segment holding nextgoals, pointer SS1, & actions assigned SS1
Add SS2 PE new-segs list
Let search-reslt assign_goals (nextgoals, {}, k-1, SS2, PG, PE)
search-reslt search segment /* Success.. */
Return search-reslt
else search-reslt conflict set: /*memoize minimal nogood return conflict set */
add conflict set level k-1 memos PG
reorder SS2 goals goals conflict set appear first /* .. EBL-based reordering */
Return search-reslt
end-if
end

Figure 8: PEGG / so-PEGG regression search algorithm Graphplan-style regression search
subgoals concurrently building search trace (PE)
557

fiZIMMERMAN & KAMBHAMPATI

Note PEGGs algorithm combines state-space CSP-based aspects search:
chooses expansion promising state based previous search iteration
state space heuristics. PEGG so-PEGG free traverse states search trace
order.
selected state expanded Graphplans CSP-style, depth-first fashion, making full use
CSP speedup techniques outlined above.
first aspect clearly distinguishes PEGG EGBG: traversal state space PE
longer constrained bottom-up level-by-level. EGBG, management
memory associated search trace challenge PEGG stray bottom-up traversal, less daunting. easier outline address first discuss
development adaptation heuristics search trace traversal.
5.3 Informed Traversal Search Trace Space
HSP HSP-R state space planners (Bonet & Geffner, 1999) introduced idea using
reachability propositions sets propositions (states) assess difficulty degree relaxed version problem. concept underlies powerful distance based heuristics selecting promising state visit. Subsequent work demonstrated planning graph
function rich source heuristics (Nguyen & Kambhampati, 2000). Since planning
graph already available PEGG, adapt extend heuristics latter work serve
secondary heuristic role direct PEGGs traversal search trace states. Again, primary heuristic planning graph length iteratively deepened (Section 2.2), step-optimality
guarantee so-PEGG planner depend admissibility secondary heuristic.
important differences heuristic ranking states generated state space planner ordering search segments (states) PEGGs search trace. example, state space
planner chooses visit given state PEGG planners often must consider whether
revisit state many consecutive search episodes. Ideally, heuristic rank states search
trace reflect level-by-level evolutions planning graph, since transposition process
associates search segment higher level successive episode. higher planning
graph level given state associated with, effective regression search space
changes complex function number new actions appear graph, number
dynamic mutexes relax, no-goods memo caches. Moreover, unlike state space
planners queue previously unvisited states, states search trace include children
state generated last visited. Ideally value visiting state assessed independently value associated children, since assessed turn. Referring back search trace depicted Figure 6, desire heuristic can, example, discriminate #4 ranked search segment ancestor, top goal segment (WXYZ).
would heuristic assessment segment WXYZ discount value associated children already present trace, ranked based potential generating new local search branches.
next discuss adaptation known planning graph based heuristics effective use
search trace.

558

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

5.3.1 ADOPTION DISTANCE-BASED STATE SPACE HEURISTICS
heuristic value state, S, generated backward search problem goals expressed as:
5-1)

f ( ) = g ( ) + w0 * h( )
where: g(S) distance problem goals (e.g. terms steps)
h(S) distance estimate initial state (e.g. steps)
w0 optional weighting factor

value g state generated search (e.g. states PE) easily assessed
cumulative cost assigned actions point. h values consider taken
distance heuristics adapted exploit planning graph (Nguyen & Kambhampati,
2000). One heuristic readily extractable planning graph based notion
level set propositions:
Set Level heuristic: Given set propositions, denote lev(S) index first level
leveled serial planning graph propositions appear non-mutex one another. (If singleton, lev(S) index first level singleton element
occurs.) level exists, lev(S) = .
admissible heuristic embodies lower bound number actions needed achieve
initial state captures negative interactions actions (due planning graph binary mutexes). Nguyen & Kambhampati, 2000 study, set level heuristic
found moderately effective backward state space (BSS) planner AltAlt, tended result many states f-value. directing search PEGGs search trace
somewhat effective, still suffers lower level discrimination
heuristics examined -especially problems engender planning graph relatively
levels. Nonetheless, noted Appendix B discussion memory efficiency improvements
use planning graph construction default heuristic value ordering, due low
computational cost synergy building using bi-partite planning graph.
inadmissible heuristics investigated Nguyen & Kambhampati, 2000 work based
computing heuristic cost h(p) single proposition iteratively fixed point follows.
proposition p assigned cost 0 initial state otherwise. action, a, adds
p, h(p) updated as:
5-2) h(p) := min{ h(p), 1+h(Prec(a) }
h(Prec(a)) sum h values preconditions action a.
Given estimate propositions h-value, variety heuristic estimates state
studied, including summing h values subgoal taking maximum subgoal hvalues. study focus heuristic termed adjusted-sum (Nguyen & Kambhampati, 2000), combines set-level heuristic measure sum h-values states
goals. Though powerful heuristic tested them, computationally cheap planning graph based planner found quite effective BSS planners tested.
Adjusted-sum heuristic: Define lev(p) first level p appears plan graph
lev(S) first level plan graph propositions state appear nonmutexed one another. adjusted-sum heuristic may stated as:
559

fiZIMMERMAN & KAMBHAMPATI

5-3)

hadjsum ( ) :=

h( p ) + ( lev(S ) max lev( p ) )


pi

pi



2-part heuristic; summation, estimate cost achieving assumption goals independent, estimate cost incurred negative interactions
amongst actions must assigned achieve goals. latter factor estimated taking
difference planning graph level propositions first become non-mutex
level propositions first appear together graph.
complex heuristics proposed include measure positive interactions subgoals state, is, extent action establishes one relevant subgoal. so-called relaxed plan distance-based heuristics focus positive interactions,
several studies demonstrated power backward forward state-space planners
(Nguyen & Kambhampati, 2000; Hoffman, 2001). However, reported former study, primary advantage adding positive interactions adjusted-sum heuristic produce shorter
make-span plans expense modest increase planning time. Since PEGGs IDA* search
already ensures optimal make-span little incentive incur expense relaxed plan
calculation, restricted work simpler adjusted-sum heuristic eqn 5-3.
adjusted-sum heuristic adapted search planning graph leveraging
information PEGGs search trace. takes form heuristic updating dynamically improve h value estimate states PE. lev(S) term adjusted-sum heuristic represents
first planning graph level subgoals state appear binary non-mutex
other. However, regression search graph level k fails given episode, search
process essentially discovered n-ary mutex condition subset goals
level k (This subset conflict set, C, gets memoized PEGG algorithm Figures 7
8). point lev(S) value updated k+1, indicating k+1 conservative estimate
first level goals appear n-ary non-mutex state. desirable property
ranking search trace states; longer state resides search trace, often h-value gets
increased, less appealing becomes candidate visit again. is, heuristic update
biases states visited failed extend solution. use
augmented adjusted-sum heuristic PEGG runs work refer adjusted-sum-u.
Experimentally, find advantage given heuristic ordering PE states highly
domain dependent (but less sensitive particular domain problem). example, compared
simple bottom-up visitation strategy, adjusted-sum-u heuristic improves so-PEGG runtimes
order magnitude domains (e.g. Freecell and, Satellite) degrading
factor 2x 7x others (e.g. Zenotravel). Figure 9 depicts performance adjusted-sum-u
heuristic relative bottom-up heuristic so-PEGG several sets problems. heuristics compared terms so-PEGGs average computation time percentage GP-es
final search episode -the important measure exhaustive search planning graph.
informed heuristic find seed segment sooner but, event many
(typical logistics domains), find one lies planning graph level closer
initial state. less informed heuristic may cause PEGG end conducting search final
episode GP-e, may many states PE would regenerated Graphplan
final regression search finds solution. direct measure power

560

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

bottom-up

adjusted-sum-u

Depot
Schedule

Problem Set

ZenoTravel
Freecell
Driverlog
Satellite
Logistics
Blocks
TSP
0.00

20.00

40.00

60.00

80.00 100.00 120.00 140.00

% Graphplan's search cost final episode

Figure 9: Heuristic accuracy so-PEGG final search episode --relative GP-e
search segment selection heuristic. Since performance vary considerably specific problem results figure averages three representative examples domain10.
5.4 Memory Management Arbitrary Search Trace Traversal Order

return memory management problems induced strategy skipping
search space. Consider PE time final search episode Figure 6. search segments visited order deepest PE level first, encounter problem regenerating states already contained PE. visitation order depicted numbered segments
figure could result fairly informed heuristic (the 4th segment chooses visit plan
segment), implies many states already resident PE regenerated. includes,
example, yet unvisited descendents third segment visited. Unchecked, process
significantly inflate search trace memory demands well overhead associated regenerating search segments. addition, heuristic information state lost state regenerated instead revisited extant PE search segment. due adjustedsum-u secondary heuristic PEGG learns improved n-ary mutex level search segments goals
updates f-value accordingly search episode.
address issue hashing every search segment generated associated PE state hash
table according canonically ordered goal set. One hash table built PE level.
Prior initiating regression search subgoal set search segment, Sn , PEGG first checks
planning graph memo caches and, relevant memo found, checks PE state hash table
see Sns goals already embodied existing PE search segment relevant PE level.
10

Problem sets used- Blocksworld: bw-large-b, blocks-10-1 12-0 Logistics: att-log-a, logistics-10-0, 12-0, Gripper:
gripper8, gripper-x-3, x-5, Depot: depotprob6512, -5646, 6587, Driverlog: dlog-3-36a, -2-3-6a, 2-3-6e, Zenotravel:
ztravel-3-8a, -3-8b, 3-7b, Freecell: freecell-2-1, -2-2, -3-5, Satellite: strips-sat-x-4, x-5, x-9.

561

fiZIMMERMAN & KAMBHAMPATI

search segment, Se,, returned PE state check, Se made child Sn (if already) establishing link, search proceed Se goals.11
Another search trace memory management issue associated fact PEGG visits
subset PE states -a set call active PE. tempting pursue minimal memory
footprint strategy retaining memory active search segments PE. However unlike
Graphplan, initial state reached PEGG cannot extract solution unwinding complete sequence action assignment calls since may begun regression search arbitrary state branch search trace tree. PEGG depends instead link child
search segment parent extract plan actions solution found. must
retain minimum, active search segments ancestor segments root node.
Beyond requirement retain search segments tied active PE, many strategies
might used managing inactive portion. study attempted reduce
PE memory requirements manner, instead focusing might termed search space
field view. beam search, heuristic effectiveness depends informed is,
search trace states available rank. reduced memory footprint PEGGs skeletal
search trace allows us adopt strategy retaining memory search segments generated.
segments f-values updated ranked, giving beam search wide selection states contending active status given search episode.
5.5 Learning Order States Subgoals

PEGG planners employ EBL search trace, allows overlay yet
sophisticated version variable ordering top distance-based ordering heuristic. guiding
principle variable ordering search fail early, failure inevitable. terms Graphplan-style search regressed state, translates Since state goals must assigned action, best attempt satisfy difficult goals first. adjusted-sum heuristic described
above, applied single goal, provides estimate difficulty based structure
planning graph. However, EBL provides additional information difficulty goal achievement
based directly search experience. wit, conflict set returned PEGGs assign_goals routine search goal set explicitly identifies goals responsible search failure. intuition behind EBL-based reordering technique then,
goals likely difficult assign search segment revisited next
search episode. constitutes dynamic form variable ordering that, unlike distance-based
ordering, search segments goals may reordered successive search episodes based
recent search experience.
Figure 10 compares influence adjusted sum variable ordering EBL-based reordering
methods memory demand, manner similar Figure 5. impact EBL-based reordering EGBGs performance reported PEGG tightly integrates various CSP efficiency methods, independent influence cannot readily assessed.12 isolate impact
EBL-based reordering EBL activating EBL using produced con11
12

interests simplicity, Figure 8 algorithm outline memory management process.
Given success various memory-efficiency methods within EGBG, versions PEGG implement
default. graph analogous Figure 5 PEGG planner would differ terms actual memory reduction values, confident overall benefits methods would persist, would relative benefit relationship
methods.

562

fi30
20

Variable Ordering (adjsum) & EBLReordering
Variable ordering
EBL- Reordering
10

% reduction PE (search trace) memory requirement

USING MEMORY TRANSFORM SEARCH PLANNING GRAPH

10
20
30
% reduction planning graph, memo cache memory requirements

Figure 10: Memory demand impact along two dimensions adjusted-sum
variable ordering EBL-based reordering techniques applied
independently together.
flict sets reordering, memoization. average reduction search trace memory
12-problem sample seen 18% EBL-based reordering alone. compares
favorably 22% average reduction distance-based ordering, especially since, unlike
adjusted sum ordering, EBL-based reordering takes effect 2nd search episode. plot
reveals two modes ordering quite complimentary.
Across variety problems domains found following approach effective
combining distance-based variable ordering EBL-based reordering: 1) newly created search
segments goals ordered according distance-based heuristic. 2) visit search
segment, subset goals appear conflict set reordered appear first. 3) goals
conflict set ordered distance-based heuristic appended non-conflict goals,
set distance-based order.
indicated Figure 10, hybrid form variable ordering boosts average memory reduction almost 30%, significantly reduces wide fluctuation performance
either method isolation. re-emphasize search experience-informed goal ordering
available search algorithm maintains memory states visited. therefore
portable Graphplan-based planner know of.
5.6 Trading Guaranteed Step-Optimality Speed Reach:
PEGG Beam Search

Many difficult benchmark problems Graphplans IDA* style search 20
search episodes reaching episode solution extracted. cumulative search time tied episodes large portion total search time and, indicated
Table 3, so-PEGG exhausts search time limits well reaching episode solution
extracted. strategy exhaustively searching planning graph, episode
solution bearing level, gives step-optimal guarantee Graphplans solutions exact
563

fiZIMMERMAN & KAMBHAMPATI

high cost ensure is, all, one aspect plan quality. explore PEGG, nonexhaustive search version so-PEGG, extent search episodes truncated
producing plans virtually makespan Graphplans solution.
PEGG shortcuts time spent search intermediate episodes using secondary
heuristic direct order PE states visited prune search space visited
episode. beam search seeks visit promising PE states, measured
f-values user-specified limit. addition, beam search important dual benefit
PEGG reduces memory demands search trace and, depending
problem, even planning graph. PEGG algorithm Figure 8, loop statement
point beam search f-value threshold optionally applied PE states candidates visitation. first segment exceeding threshold reached sorted queue
search episode ends.
devise effective threshold test must reconcile competing goals: minimizing search nonsolution bearing episodes maximizing likelihood PE retains visits (preferably
early possible), search segment thats extendable solution graph reaches first
level extant solution. narrower window states visited, difficult
heuristic ranks states ensure includes plan segment, i.e. one part stepoptimal plan. PEGG return step-optimal plan long search strategy leads visit
plan segment (including top, root segment PE) belonging plan latent PE, search first solution-bearing planning graph. heuristics job selecting window
search segments visit made less daunting many problems many step-optimal
plans latent solution-bearing level.
next describe effective planning graph based metric augments state space heuristic
choosing set PE states visit search episode.
5.6.1 MINING PLANNING GRAPH FILTER BEAM
Beyond heuristic updating introduced Section 3, distance-based heuristics virtually
insensitive planning graph evolution search segment transposed successive levels. Since
search trace contains children states generated regression search state episode n, heuristic preference include states trace visit episode n+1
reflect chance directly generate new promising search branches. child states
search episode n competitors S, ideally heuristics rank reflect
sense value visiting state beyond importance children.
Consider sensitivity adjusted-sum heuristic (or distance-based heuristics)
possible differences implicit regression search space set propositions, S, planning graph level k versus level k+1. Given propositions present binary non-mutex
level k, cost summation factor equation 5-3 could conceivably change
evaluated level k+1. would require two conditions: new action must establish one
propositions first time level k+1 actions precondition costs must sum less
precondition costs establisher proposition. practice happens infrequently since later action appears graph construction process, higher cost tends
be. Consequently h-values states based distance-based heuristics remain remarkably constant planning graph levels beyond propositions appear binary non564

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

mutex13. desire means compensating static h-value state transposed planning graph level promising new branches regression search open up.
likelihood state visited episode n graph level k give rise new child states
visited episode n+1 level k+1 rooted graph dynamics summarized Observations A-1
A-2 Appendix A. Three planning graph memo cache properties determine whether regression search subgoal set evolve successive episodes:
1. new actions level k+1 establish subgoal
2. dynamic mutexes level k actions establishing subgoals relax
level k+1
3. no-good memos encountered regression search state episode n
encountered level k+1 (and converse).
set measures potential new search branches result visiting state PE
refer flux; intuition higher flux, likely search
given state differ seen previous search episode (and captured PE). none
three factors applies state consideration, point visiting it, new
search result relative previous episode.
first factor readily assessed state (thanks part bi-partite graph structure). second flux factor unfortunately expensive assess; direct measure requires storing
pairs attempted action assignments goals inconsistent episode n retesting new planning graph level. However, graph mechanics relaxation
dynamic mutex two actions level k requires relaxation dynamic mutex condition
pair preconditions level k-1 (one precondition action). relaxation, turn, either due one new establishing actions preconditions level k-1
recursively, relaxations existing actions establishing preconditions. such, number new
actions establishing subgoals state PE (factor 1 above) provide measure
flux S, predictor flux due factor 2 parent (and higher ancestors) S.
Thus, turns simply tracking number new actions state subgoal current level propagating appropriately weighted measure parent, compile useful
estimate flux factors 1 2 above.
third flux factor unwieldy costly estimate; exact measure requires
storing child states generated regression search level k caused backtracking due
cached memos, retesting see memos present level k+1.14 Ignoring
factor, sum two flux measures depend new actions derive filtering metric
used assist largely static adjusted-sum distance-based heuristic culling
beam. resulting (inexact) metric sensitive evolution search potential state transposed higher planning graph levels:

13

This, part, explains observation (Nguyen & Kambhampati, 2000) AltAlt state space planner performance
generally degrades little planning graph used extract heuristic values built level problem goals appear non-mutex, rather extending level-off.
14
Note long using EBL/DDB, sufficient test whether memo exists child state.
no-good goals contribute conflict set used direct search within whenever backtracking occurs.

565

fiZIMMERMAN & KAMBHAMPATI

5-4)

flux( ) =

newacts( p )


pi

|S|

+ wcf

childflux(s )

si c



where: pi proposition state
newacts(pi) number new actions establish proposition pi
associated planning graph level
| | normalization factor; number propositions
Sc set child states currently represented search trace
childflux(si) sum two flux terms eqn 5-4 applied child state si
wcf weights contribution flux child states parent state

number new actions establishing subgoals state normalized relative number subgoals state.
report elsewhere (Zimmerman, 2003) use flux directly augment secondary
heuristic. Depending domain weighting flux contribution adjusted-sum heuristic, speedups order magnitude observed15. However impact highly domain
dependent since primarily concerned performance general purpose planner,
study consider use beam filter.
beam search, flux measure strongly impact every search episode, influences
states actually included active PE. used mode, search segments assessed
flux specified threshold skipped even f-value places active PE.
Flux proves broadly effective across domains used mode. mentioned
Section 5.1, use flux cutoff search episode 10% average flux search segments PE; segment value visited regardless heuristic rank.
setting impact speedup PEGG column problems Table 3 ranges nil factor
9x PEGGs performance without flux filter. Higher settings dramatically speed
solution search, often expense greater solution makespan.
5.6.2 PEGGS ABILITY FIND STEP-OPTIMAL PLANS
variety parameters associated beam search approach described admits considerable flexibility biasing PEGG towards producing plans different quality. Shorter makespan plans
favored extensive search PE states episode heuristically truncated
search tends generate non-optimal plans quickly, often containing redundant unnecessary
actions. settings used study clearly bias PEGG solutions towards step-optimality:
step-optimal plan produced enhanced Graphplan matched PEGG four 37
problems reported Table 3, indicated annotated steps actions numbers given parenthesis next successful GP-e PEGG runs16. (PEGG solutions longer makespan
step-optimal boldface step/action values.) four problems, PEGG returns solutions
15

example, compared simple bottom-up visitation strategy, flux-augmented adjusted-sum heuristic improves
so-PEGG runtimes 11x domains (e.g. Freecell and, Satellite) degrading much 2x 7x
others (e.g. Zenotravel).

16

one guaranteed step-optimal planners (GP-e, me-EGBG so-PEGG) finds solution steps
actions reported one them, since makespan.

566

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

Problem

N-best first
PEGG
[N=100, state-space search] [ adjusted-sum-u heuristic beam search
100 best search segments]

SATPLAN
(optimal)

bw-large-a

8

6

(.1 s)

6

bw-large-b

12

9 (4.5 s)

9

bw-large-c

21

14 (39.0 s)

14

bw-large-d

25

18 (412 s)

18

Table 4: Quality comparison (in terms plan steps) PEGG N-best beam search
forward state space planner (Bonet et al., 1997).
within four steps optimum, spite highly pruned search. proved fairly robust
property PEGGs beam search settings across problems tested date.
PEGG adjusted-sum-u secondary heuristic often finds plans fewer actions
GP-e parallel domains, Graphplan hybrid system impressive serial domains
blocksworld (which exactly Graphplans forte).
tactic trading optimal plan length favor reduced search effort well known
planning community. comparison, PEGGs beam search approach biased towards producing
high quality plan possibly expense runtime. example, paper focusing
action selection mechanism planning, Bonet et. al. briefly describe work N-best
first algorithm (Bonet, Loerincs, & Geffner, 1997). employ distance-based heuristic
conduct beam search forward state space planning. report small set results case
100 best states retained queue considered search.
Table 4 reproduces results alongside PEGGs performance problems using beam
search. Here, approximate N-best algorithm, PEGG run 100 states visited
intermediate search episode. 1997 study compared N-best first approach SATPLAN,
produces optimal length plan, make point approach could produce plans reasonably close optimal much less search. N-best first code available run
test platform, PEGGs runtime reported. Focusing plan makespan, clear even
serial domain, parallel planner PEGG produces much shorter plan N-best first
state space approach, fact finds optimum length plan generated SATPLAN cases.
recently LPG (Gerevini & Serina, 2002), another planner whose search tightly integrated
planning graph, awarded top honors AIPS-2002 planning competition, due
ability quickly produce high quality plans across variety domains currently interest.
Figure 11 scatter plot, solution quality terms steps LPG PEGG compared
optimal 22 problems three domains 2002 AIPS planning competition. chose
particular problems optimal solution known, interested comparing
quality baseline. LPGs results particularly apt case, planner nonexhaustively searches planning graph level extending it, although search process
differs markedly PEGGs. LPG, too, biased produce plans higher quality (generally
expense speed) report competition results quality mode. terms
number actions solutions neither planner consistently dominates problems
PEGG clearly excels step-optimality. maximum deviation optimum four steps
567

fiZIMMERMAN & KAMBHAMPATI

18

LPG: dlog

16

LPG: depot

Steps optimal

14

LPG: ztravel

12

PEGG: dlog

10

PEGG: depot

8

PEGG: ztravel

6
4
2
0
0

2

4

6

8

10

Problem number

12

14

16

18

Figure 11: Makespan comparison PEGG LPG -Departure step-optimal
plan length. (LPG data taken AIPS 2002 competition results.)
plot points solutions lie right optimal makespan axis. possible
sets actions within LPGs solutions could conducted parallel algorithms quality
mode heuristic insensitive .
noted LPG produced solutions difficult problems domains
PEGG currently solve within reasonable time limit. investigating characteristics
problems make difficult PEGG.
5.6.3 PEGG COMPARED HEURISTIC STATE SPACE SEARCH
attempted run PEGG head-to-head speed recent IPC planners, part
due platform difficulties (PEGG written Lisp competition planners generally
coded C published results based execution competition machines) partly
due focus near-optimal makespan parallel plans rather speed. Given PEGGs close
coupling planning graph, relevant comparisons parallel planners
employ graph form. comparisons, would isolate search component runtime planning graph construction, since variety routines produce essentially graph widely different expenditures computational time memory. reported runtimes LPG planner AIPS-02 competition generally much
smaller PEGGs, difficult isolate impact graph construction platform-related
effects, mention disparity makespan plans produced.
Table 5 compares PEGG Lisp version fast distance-based heuristic state space planner using problems Table 3. AltAlt (Srivastava et al., 2001), PEGG, depends
planning graph derive powerful heuristics uses direct regression search
problem goals. facilitates planner performance comparison based differences search without confusing graph construction time issues. last column Table 5 reports AltAlt performance
(runtime makespan) two effective heuristics developed planner (Nguyen &
Kambhampati, 2000), first adjusted-sum heuristic described Section 5.3.1.

568

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

Problem
bw-large-B
bw-large-C
bw-large-D
rocket-ext-a
att-log-a
att-log-b
Gripper-8
Gripper-15
Gripper-20
Tower-7
Tower-9
8puzzle-1
8puzzle-2
TSP-12
AIPS 1998
grid-y-1
gripper-x-5
gripper-x-8
log-y-5
mprime-1
AIPS 2000
blocks-10-1
blocks-12-0
blocks-16-2
logistics-10-0
logistics-12-1
freecell-2-1
schedule-8-9
AIPS 2002
depot-6512
depot-1212
driverlog-2-3-6e
driverlog-4-4-8
roverprob1423
roverprob4135
roverprob8271
sat-x-5
sat-x-9
ztravel-3-7a
ztravel-3-8a

PEGG
heuristic: adjusted-sum-u
cpu sec (steps/acts)
4.1
24.2
388
1.1
2.2
21.6
5.5
46.7
1110.8
6.1
23.6
9.2
7.0
6.9

(18/18)
(28/28)
(38/38)
(7/34)
(11/62)
(13/64)
(15/23)
(36/45)
(40/59)
(127/127)
(511/511)
(31/31)
(32/32)
(12/12)
PEGG
16.8 (14/14)
110
(23/35)
520
(35/53)
30.5 (16/34)
2.1 (4/6)
PEGG
6.9 (32/32)
9.4 (34/34)
40.9 (56/56)
7.3 (15/ 53)
17.4 (15/75)
19.1 (6/10)
297
(5/12)
PEGG
2.1 (14/31)
79.1 (22/53)
80.6 (12/26)
889
(23/38)
15
(9/28)
379
(12 / 43)
220
(11 / 39)
25.1 (7/22)
9.1 (6/35)
101
(10/23)
15.1 (9/26)

Alt Alt (Lisp version)
cpu sec ( / acts)
heuristics:
combo
adjusum2
67.1 (/ 18 ) 19.5 (/28 )
608 (/ 28) 100.9 (/38)
950 (/ 38)
~
23.6 (/ 40) 1.26 (/ 34)
16.7 ( /56) 2.27( / 64)
189 (/ 72) 85.0 (/77)
6.6 (/ 23)
*
10.1 (/ 45)
6.98 (/45)
38.2 (/ 59) 20.9 (/59)
7.0 (/127)
*
28.0 (/511)
*
33.7 ( / 31) 9.5 ( /39)
28.3 (/ 30)
5.5 (/ 48)
21.1 (/12) 18.9 (/12)
Alt Alt
17.4 (/14)
17.5 (/14)
9.9 (/35)
8.0 (/37)
73 (/48)
25.0 (/53)
44 (/38)
29.0 (/42)
722.6 (/ 4)
79.6 (/ 4)
Alt Alt
13.3 (/32)
7.1 (/36)
17.0 (/34)
61.9 (/56)
31.5 (/53)
80 (/77)
49 (/12)
123 (/15)
Alt Alt
1.2 (/33)
290 (/61)
50.9 (/28)
461 (/44)
2.0 ( /33)
292 ( /45)
300 ( / 45)
3.1 (/25)
5.9 (/ 35)
77 (/28)
15.4 (/31)

Table 5: PEGG state space planner using variations adjusted-sum heuristic
PEGG: bounded PE search, best 20% search segments visited search episode, ordered
adjusted-sum-u state space heuristic
AltAlt: Lisp version, state space planner two effective planning graph distance-based
heuristics: adjusum2 combo (combo results reported problems since
adjusum2 produces plans competitive PEGG terms makespan.)

569

fiZIMMERMAN & KAMBHAMPATI

Surprisingly, majority problems PEGG returns parallel, generally step-optimal plan faster
AltAlt returns serial plan. (AltAlt cannot construct plan parallel actions, however recent
work highly modified version AltAlt does, fact, construct plans -Nigenda & Kambhampati, 2003). PEGG plans seen comparable length, terms number actions, best AltAlt plans.
6. Discussion Results

distinguishing feature EGBG PEGG planners relative planners exploit
planning graph, aggressive use available memory learn online episodic search
experience expedite search subsequent episodes. Although employ search trace
structure log experience, EGBG PEGG systems differ content granularity search experience track aggressiveness use memory. differ
confront common problem faced learning systems; utility learned information
versus cost storing accessing needed.
first efforts focused primarily using search trace learn mutex-related redundancies
episodic search process. Although resulting planners, EGBG me-EGBG, avoid virtually redundant mutex checking based search experience embodied PEs, empirically
find limited class problems winning strategy. utility tracking
mutex checking experience search function number times information
subsequently used. Specifically:
EPS ( p )

6 1) U mt ( p)

PE

visit

( e)

PE

add

(e)

e =1
EPS ( p )
e =1

where: Umt utility tracking mutex checking experience
p planning problem
EPS(p) number search episodes problem p
PEvisit (e) number PE search segments visited search episode e
PEadd (e)is number new search segments added PE episode e
Thus payback EGBGs incurred overhead tracing consistency-checking experience
search depends number times sets revisited relative total number subgoal
sets generated (and added PE) problem run. characteristic explains less
2x speedups observed me-EGBG many Table 2 problems. approach handicap single search episode problems. ineffectual problems final search episode search generates large number states relative previous episodes seed segment(s)
top levels PE (due need bottom-up visitation search segments EGBGs
search trace).
PE thought snapshot regression search reachable (RS reachable) states
search episode. is, regression search process generates state level k
planning graph, state reachable search higher levels graph future search
episodes. Essentially, search segments PE represent RS reachable states,
570

fispeedup wrt enhanced Graphplan

USING MEMORY TRANSFORM SEARCH PLANNING GRAPH

so-PEGG: log

1000.0

PEGG: log
so-PEGG: ztravel
PEGG:ztravel

100.0

10.0

1.0
1
0.1

2

3

4

5

6

7

search episodes problem

Figure 12: Speedup vs. number search episodes: Logistics '00 Zenotravel '02 domains
candidate set partial plans segments state current tail state plan. Table 3 5 results indicate utility learning states RS reachable given search
episode generally outweighs utility learning details episodes consistency-checking,
require much less memory. Freed need regenerate RS reachable states IDA* fashion search episode, PEGG visit states heuristically preferred order.
Tables 2, 3 5 shed light several classes problems problematic search trace
guided search planning graph:
1. Domains high branching factors operator descriptions thwart DDB EBL
(e.g. larger Schedule, Satellite, Zenotravel domain problems)
2. Problems significant fraction runtime consumed planning graph construction.
(e.g. Grid domain,, dlog-2-3-6e, freecell-2-1)
3. Problems one two search episodes ( grid-y-1, schedule-8-5)
problems first class, Graphplan-style CSP assignment search prone bogging
certain PE states selected visitation. second class search time
reduction dominated large graph construction time (a problem shared planner
builds complete planning graph). Problems third class give PEGG sufficient
opportunity exploit PE, since built first episode (and first episode PE typically
small) benefit subsequent episodes. aspect PEGGs behavior illustrated
Figure 12. speedup factors so-PEGG PEGG (under beam search) plotted
series problems ordered according number search episodes Graphplan would conduct prior finding solution. data gathered running GP-e, so-PEGG, PEGG
planners two different domains (the Logistics domain AIPS-00 planning competition,
Zenotravel domain AIPS-02 competition) averaging speedups observed
problems number observed search episodes. downturn PEGG/ Ztravel
curve seven episodes surprising given one problem
many factors beyond number search episodes impact solution time. Noting speed571

fiZIMMERMAN & KAMBHAMPATI

ups plotted logarithmic scale, power search trace given multiple search episode problems evident. PEGG using beam search handily outperforms so-PEGG problems three
search episodes, largely shortcuts exhaustive search intermediate episodes.
several avenues addressing above-listed limitations PEGG explored anticipate investigating. example, unlike N-best first state space planner reported
Table 4, PEGG enforces user-specified limit state f-values selecting PE search
segments visit. search segment chosen visitation, Graphplan-style regression search
state goals continues either solution found sub-branches fail. greedy
approach would apply heuristic bound regression search. is, could
backtrack whenever state generated exceeds f-value threshold applied search segments
visited. translates Greedy Best First Search (GBFS) algorithm employed
HSP-r (Bonet & Geffner, 1999) state space search, form hill-climbing search planning graph.
Experimentally find PEGG adapted enforce PE state f-value limit
regression search, improvements unpredictable best. Speedups factor 100
observed cases (all logistics problems) many cases runtimes increased search failed
entirely within time limit. addition, quality (make-span) returned solutions suffered
across broad range problems. two factors may explain result: 1) PEGGs regression search greatly expedited DDB EBL, regressed conflict set rely
undefined regression search space state fully explored, fvalue limit enforced. Without conducting search informed basis returning anything full set subgoals state, essentially forces search towards chronological backtracking. 2) Assessing f-value newly generated state compare fvalue bound based states generated previous episodes problematic.
heuristic values PE states determine f-value bound increased PEGGs use
search experience improve h-value estimates (Section 5.1.2).
Degradation solution quality shift PEGG closer greedy search approach may indicator PEGGs ability return step-optimal plans (as evidenced Table 3 results) rooted
interleaving best-state selection PE Graphplan-style depth-first search
states subgoals.
7. Related Work

focus related alternative strategies employing search heuristics planning, generating parallel plans, making use memory expedite search. Related work pertaining
search techniques, efficiencies, data structures enable EGBG PEGG successfully
employ search trace cited arose considered here.17
noted Section 2.2, shortcoming IDA* search (and Graphplan) inadequate use
available memory: information carried one iteration next upper
bound f-value. Exploitation search trace directly addresses shortcoming serving
memory states visited search space previous episode order reduce redun17

Support methodologies include memory efficient bi-partite planning graph models, explanation based learning dependency directed backtracking context planning graph search, variable value ordering strategies, evolution
extraction distance-based heuristics planning graph.

572

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

dant regeneration. respect PEGGs search closely related methods MREC (Sen,
Anup & Bagchi, 1989), MA*, SMA* (Russell, 1992) lie middle ground
memory intensive A* IDA*s scant use memory. central concern algorithms
using prescribed amount available memory efficiently possible. EGBG PEGG,
retain much search experience memory permits avoid repeating regenerating
nodes, depend heuristic order nodes memory visitation. Unlike search trace
based algorithms though, three algorithms backup deleted nodes f-value parent node. ensures deleted branch re-expanded promising node remains open list. implemented extended memory management PEGG
(though would straight-forward so) primarily because, least beam search, PEGG
seldom confronted PE-related memory limitations.
EGBG PEGG first planners directly interleave CSP state space views problem search, related approaches synthesize different views planning problem.
Blackbox system (Kautz & Selman 1999) constructs planning graph instead exploiting
CSP nature, converted SAT encoding extension k-step solution
sought. GP-CSP (Do & Kambhampati, 2000), similarly alternates extending planning
graph converting it, transforms graph CSP format seeks satisfy constraint
set search phase.
beam search concept employed context propositional satisfiability GSAT (Selman, Levesque, & Mitchell, 1992) option Blackbox planner (Kautz & Selman, 1999).
systems greedy local search conducted assessing episode, n-best flips
variable values randomly generated truth assignment (Where best flips lead
greatest number satisfied clauses). n flips fail find solution, GSAT restarts new
random variable assignment tries n-best flips. several important differences
relative PEGGs visitation n-best search trace states. search trace captures state aspect engendered Graphplans regression search problem goals such, PEGG exploits
reachability information implicit planning graph. conducting search purely propositional level, SAT solvers leverage global view problem constraints cannot exploit
state-space information. Whereas GSAT (and Blackbox) improve performance based
experience one n-best search episode next, PEGG learns variety modes; improving heuristic estimate states visited, reordering state goals based prior search experience, memorizing general no-goods based use EBL.
PEGG, LPG system (Gerevini & Serina, 2002) heavily exploits structure planning graph, leverages variety heuristics expedite search, generates parallel plans. However,
LPG conducts greedy local search space composed subgraphs given length planning
graph, PEGG combines state space view search experience Graphplans CSP-style
search graph itself. LPG systematically search planning graph heuristically
moving extend it, guarantee step-optimality forfeited. PEGG operate either
step-optimal mode modes trade optimality speed varying degrees.
currently investigating interesting parallel LPGs ability simultaneously consider
candidate partial plans different lengths. principle, nothing prevents PEGG
simultaneously considering given PE search segment Sn, terms heuristic rankings
transposed onto various levels planning graph. tantamount simultaneously consider573

fiZIMMERMAN & KAMBHAMPATI

ing arbitrary number candidate partial plans different implied lengths extend first
(each partial plan Sn tail state). search trace proves useful
regard state contains transposed desired number levels -subject
ability extend planning graph needed- heuristics re-evaluated level. Referring back Figure 4, first search episode pictured (top), YJ state PE could
expanded multiple distinct states transposing graph level 5 levels 6, 7, higher,
heuristically evaluating level. graph-level indexed instances YJ
simultaneously compared. Ideally wed move directly visiting YJ planning graph level 7,
since point becomes plan segment problem (bottom graph Figure 4). secondary heuristic discriminate solution potential state sequential levels
transposed to, effective means shortcutting Graphplans level-bylevel search process. flux adjunct likely one key boosting sensitivity distancebased heuristic regard.
Generating assessing arbitrarily large number graph-level transposed instances PE
states would prohibitive terms memory requirements store multiple versions
PE. However simply store level-specific heuristic information search segments
single PE values indexed associated planning graph levels. Challenging issues include
things range plan lengths considered one time potential plans
steps consisting entirely persists actions.
havent examined PEGG context real-time planning here, use search
trace reflects flavor real-time search methods, LRTA* (Korf, 1990)
variants B-LRTA* (Bonet, Loerincs, & Geffner, 1997), -a variant applies distance-based
heuristic oriented planning problems. Real-time search algorithms interleave search execution,
performing action limited local search. LRTA* employs search heuristic based
finding less-than-optimal solution improving heuristic estimate series iterations.
associates h-value every state estimate goal distance state (similar h-values
A*). always first updates h-value current state uses h-values successors move successor believed minimum-cost path current state goal.
Unlike traditional search methods, act real-time amortize learning consecutive planning episodes solves planning task repeatedly. allows find suboptimal plan fast improve plan converges minimum-cost plan.
LRTA*, PEGG search process iteratively improves h-value estimates states
generated determines optimal make-span plan. Unlike LRTA*, PEGG doesnt actually
find sub-optimal plan first. Instead converges minimum-cost plan either exhaustively extending candidate partial plans monotonically increasing length (so-PEGG) extending
promising candidates according secondary heuristic (PEGG beam search). realtime version PEGG closely related LRTA* might based method described above,
search segments simultaneously transposed onto multiple planning graph levels.
mode PEGG would biased search quickly plan length, search anytime
fashion progressively shorter length planning graphs lower cost plans.
methodology direct relevance work reported elsewhere multi-PEGG
(Zimmerman & Kambhampati, 2002; Zimmerman 2003), version PEGG operates anytime fashion, seeking optimize multiple plan quality criteria. Currently multi-PEGG first re-

574

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

turns optimal make-span plan, exploits search trace novel way efficiently
stream plans monotonically improve terms quality metrics. discussed paper,
important step away multi-PEGGs bias towards make-span plan quality metric would
modification. Co-mingling versions state transposed onto multiple planning
graph levels would enable planner concurrently consider visitation candidate search segments might seed segments latent plans various lengths.
8. Conclusions

investigated presented family methods make efficient use available memory
learn different aspects Graphplans iterative search episodes order expedite search
subsequent episodes. motivation, design, performance four different planners build
exploit search trace described. methods differ significantly either information
content trace manner leverage it. However, cases high-level
impact transform IDA* nature Graphplans search capturing aspect search
experience first episode using guide search subsequent episodes, dynamically updating along way.
EGBG planners employ aggressive mode tracing search experience PEGG
planners. track use action assignment consistency checking performed search
subgoal set (state) minimize effort expended state next visited. EGBG approach found memory intensive, motivating incorporation variety techniques
planning CSP fields which, apart well-known speedup benefits, shown
dramatic impact search trace planning graph memory demands. resulting planner,
me-EGBG, frequently two orders magnitude faster either standard Graphplan EGBG
problems handle, generally fastest guaranteed step-optimal approaches
investigated. comparisons GP-e, version Graphplan enhanced space saving
speedup techniques, me-EGBG solves problems average 5 times faster.
PEGG planners adopt skeletal search trace, design conducive informed traversal search space. Ultimately proves powerful approach exploiting
episodic search experience. adapt distance-based, state space heuristics support informed traversal states implicit search trace describe metric call flux effectively
focuses search states worth visiting. flux measure sensitive potential search
trace state seed new search branches transposed higher planning graph levels.
describe new techniques leverage search experience captured search trace
demonstrate effectiveness.
so-PEGG planner, me-EGBG, produces guaranteed optimal parallel plans similarly
averages 5x speedup GP-e. greatly reduced memory demands allow so-PEGG handles
one 16 problems me-EGBG exceeds available memory. compelling evidence speedup potential search trace guided planner provided PEGG beam
search. Since longer exhaustively searches planning graph episode, PEGG sacrifices
guarantee returning optimal make-span plan. Nonetheless, even beam search limited
best 20% PE states episode, PEGG returns step-optimal plan almost 90%
test bed problems comes within steps optimal others. speedups

575

fiZIMMERMAN & KAMBHAMPATI

ranging almost two orders magnitude GP-e, quite competitively modern state
space planner (which finds serial plans).
code PEGG planners (including GP-e) instructions running various
modes available download http://rakaposhi.eas.asu.edu/pegg.html
Acknowledgements

research improved many discussions Binh Minh Do, XuanLong Nguyen, Romeo
Sanchez Nigenda William Cushing. Thanks David Smith anonymous reviewers,
whose copious suggestions greatly improved presentation paper. research supported
part NSF grants IRI-9801676 IIS-0308139, DARPA AASERT Grant DAAH04-96-10247 NASA grants NAG2-1461 NCC-1225.

Appendix A: EGBG Planner

insight behind EGBGs use search trace based characterization Graphplans
search given beginning Section 3.1 entailed observations:
Observation A-1) intra-level CSP-style search process conducted Graphplan set propositions (subgoals) , planning graph level k+1 episode n+1 identical search process
level k episode n IF:
1. mutexes pairs actions establishers propositions level k remain
mutex level k+1. (this concerns dynamic mutexes; static mutexes persist definition)
2. actions establishing proposition level k+1 present level k.
Observation A-2) trace Graphplans search episode n+1, set goals G, planning
graph level m+1, identical episode n search level IF:
1. two conditions observation A-1 hold every subgoal set (state) generated Graphplan
episode n+1 regression search G.
2. every subgoal set planning graph level j search episode n matching
level j memo, exists equivalent memo level j+1 generated episode n+1.
Conversely, every subgoal set level j search episode n matching level j memo
existed time generated, matching memo level j+1 time generated episode n+1.

Now, suppose search trace states (including no-good states) generated Graphplans regression search problem goals planning graph level episode n. search
failed extract solution m-length planning graph (i.e. reach initial state), necessary condition extract solution m+1 length graph one conditions
observations A-1 A-2 fails hold states episode n search trace.
observations A-1 A-2 mind, exploit search trace new episode
sound complete manner focusing search effort three situations could lead
solution: 1) state variables newly extended value ranges (i.e. search segment goals
least one new establishing action newly associated graph level), 2) points previous search episode backtracked due violation dynamic constraint (i.e. two actions
576

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

W

nop a1
OK OK
1



7

nop a3
OK SM

nop a3
OK SM

2

nop a1
OK OK

H

3



6

8

nop a3 a1
OK SM OK
4 nop a55

J

DM SM

nop a5 nop a5
DM SM DM SM

nop a5
DM SM

Figure A1: Bit vector representation search trace WYHIJ state Figure 3.
Semantics: OK > assigned (no action conflicts) SM > action static mutex previous assign
DM > action dynamic mutex previous assign
NG > no-conflict action results no-good state lower graph level

dynamic mutex), 3) states matched cached memo episode n. assignment mutex checking operations involved satisfying set subgoals static across search
episodes.
experimented several search trace designs capturing key decision points. design
adopted EGBG employs ordered sequence bit vectors, vector contains results
Graphplans CSP-style action assignment process related given subgoal search segment.
Efficient action assignment replay possible trace uses vectors two-bit tags represent
four possible assignment outcomes: 1) dynamic mutex, 2) static mutex, 3) conflict, 4) complete, consistent set assignments rejected next level due memoized no-good. Figure A1 illustrates sequence eight bit vectors used capture search experience search segment state goals WYHIJ Figure 3 Alpha problem. propositional goals (the variables) appear left sets bit vectors (depicted segmented bars)
encode outcome possible action assignment (the values). possible establishing
action goal appears bit vector tag.
numbered edges reflect order trace vectors initially created first
goal action tried. Note whenever candidate action goal conflict free respect
previously assigned actions (indicated OK figure), action checking goal suspended, process jumps next goal, new bit vector initialized goals possible
establishers. edge numbering reflects order vectors popped
search segment trace list segment revisited next episode. scheme work,
bit vectors must pushed onto search segment trace list actions goal tried,
reverse numbered edge order. Long edges skip one goals indicate
goals already established previously assigned actions.
long order actions appearing establishers list planning graph proposition remains constant, bit vectors used replay search next episode next
higher planning graph level. graph building routine EGBG enforces constraint.

577

fiZIMMERMAN & KAMBHAMPATI

EGBG Algorithm

high-level EGBG algorithm given Figure A2. Graphplan, search planning
graph occurs extended level problem goals first appear
binary mutex conditions. (the call find_1st_level_with_goals). first search episode conducted
Graphplan fashion except assign_goals routines Figure A3 create search segments
hold states trace information generated regression search process. necessary
trace information search segment captured trace vectors described above. segments stored PE structure indexed according level generated
(where current highest planning graph level corresponds 0 contains problem goals).
Subsequent first episode, EGBG_plan enters outer loop employs PE conduct
successive episodes (Referred search trace guided). search strategy alternates
selection visitation promising state trace previous experience (select_searchseg_from_PE routine), focused CSP-type search states subgoals (the replay_trace_goals assign_goals routines Figures A3 A4).
episode, inner loop visits PE search segments level-by-level, bottom-up fashion
(for reasons discussed Section 3). extend_plangraph routine called state
visited corresponds level beyond current graph length.
replay_trace_goals routine counterpart Graphplans assign_goals routine, except
avoids latters full-blown mutex checking stepping trace vectors captured
previous search experience given state. Unlike assign_goals, branch child
states already contained PE. conditional checking trace vectors establishing
actions initiates new search calling assign_goals two conditions: 1) dynamic mutexes
previous episodes longer hold 2) new establishing actions appear subgoal (These
tried establishers replayed.) dynamic mutex longer holds new
establishing action considered trace vector modified accordingly EGBG resumes Graphplans CSP-style search, adding new trace vectors search segment process.

578

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

EGBG-PLAN ( Ops, Init, Goals) /* {Ops,Init,Goals} planning problem */
/* build plangraph, PG, level n goals first occur non-mutex state*/

Let PG find_1st_level_with_goals( Ops, Init, Goals )
PG reached level-off goals present non-mutex state Return FAIL
Let n number levels PG
Let SS0 new search segment fields:
goalsGoals, parentroot, PE-level 0, parent-actions {} trace {}
Let PE pilot explanation structure fields hold search segments plangraph level
PE[0] {SS0} /* 0 top level PE */
/* Conduct Graphplan-style backward search n-length plangraph, store trace PE...*/

Let search-reslt assign_goals(Goals, {}, n, SS0, PG, PE)
search-reslt search segment /* Success */
Plan extract plan actions ancestors linked search-reslt
Return Plan
else /* n-length solution possible ...use PE search longer length solution */
loop forever
n n+1
loop pe-lev ranging number deepest level PE 0 (top level)
let k planning graph level associated PE level pe-lev
= n pe-lev /* ..essentially translates PE one planning graph level */
pe-lev = 0 PG extend_plangraph(PG) /*.. must extend plangraph point */
loop search segments PE[pe-lev]
SS select_searchseg_from_PE[pe-lev]
SSassigns SS<trace> /* get ordered, goal-by-goal trace vectors search segment */
SS<trace> {} /* Clear search segment trace vectors field */
SS<goals> memos(k, PG) /*check nogoods level k */
goals match nogood level, loop next search segment
else /* use SS trace avoid redundant search effort SS goals.. */
search-reslt replay_trace_goals (SS<goals>, {}, k, SSassigns, SS, PG, PE)
search-reslt search segment
Plan extract plan actions ancestors linked search-reslt
Return Plan
else Add SS<goals> memos(k, PG) /*memoize nogood */
end loop (search segments)
end loop (PE levels)
end-loop (PG level)
end

Figure A2: EGBG planner top level algorithm

579

fiZIMMERMAN & KAMBHAMPATI

Conduct Graphplan-style search subgoal set planning graph level k
arguments> G: goals still assigned, A: actions already assigned, k: PG level,
SS1: search segment, PG: planning graph, PE: pilot explanation (search trace)
ASSIGN_GOALS (G, A, k, SS1, PG, PE)
G empty k = 0 (the initial state) Return SS1 /* Success */
else /* goals left satisfy*/
Let g-assigns ={} /* trace vector hold ordered action assignment tags */
Let g goal selected G
Let Ag = actions PG level k support g, ordered value-ordering heuristic
loop act Ag
Let search-reslt = {}
action dynamic mutex act append dm tag g-assigns
else action static mutex act append sm tag g-assigns
else /* act conflict actions already */
G empty
/* done G goals, setup search next lower level */
search-reslt assign_next_level_goals (A U{act}, k, SS1, PG, PE)
search-reslt nogood append ng tag g-assigns
else append ok tag g-assigns /* search occurred lower level */
else /* search continues level next goal */
append ok tag g-assigns
search-reslt assign_goals (G-{g}, U{act}, k, SS1, PG, PE)
end-if
search-reslt search segment Return search-reslt /* Success */
/* else loop try another action*/

end-if
end loop (actions)
push g-assigns trace field SS1
Return nil /* solution found */
end-if
end

/*add trace data search segment */

Setup search graph level k-1 given actions satisfy goals SS1 level k
ASSIGN_NEXT_LEVEL_GOALS (A, k, SS1, PG, PE)
Let nextgoals regress SS1 goals assigned actions
nextgoals memos PG level k-1 Return nogood /* backtrack nogood goals */
else /* initiate search next lower PG level*/
Let SS2 new search segment fields:
goalsnextgoals, parentSS1, parent-actionsA, trace{}
Add SS2 PE level: (maximum PG level) (k-1)
Let search-reslt assign_goals (nextgoals, {}, k-1, SS2, PG, PE)
search-reslt nil /* search level k-1 failed */
Add nextgoals memos level k-1 PG /*memoize nogood */
Return search-reslt
end-if
end
ASSIGN_NEW_ACTIONS (G, A, Ag, g, g-assigns, k, SS, PG, PE)
/* Routine essentially assign_goals, except attempts satisfy goal g actions
new actions (i.e. first appearing recent plangraph extension */

Figure A3: EGBGs non-guided regression search algorithm

580

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

Regression search using search trace (PE) replay
arguments> G: goals still assigned, A: actions already assigned, k: PG level,
SS1: search segment, PG: planning graph, PE: pilot explanation (search trace)
REPLAY_TRACE_GOALS (G, A, k, SS1, PG, PE)
G empty /* SS1 goals branch successfully assigned last episode...*/
Return /* .. continue level k replay, ignoring search replay next lower level */
else /* goals left satisfy*/
Let g select goal G
Let g-assigns pop front trace vector SS<trace>
Let Ag set actions level k PG support g
/* replay assignments g previous episode, rechecking may changed..*/

loop tag g-assigns
Let search-reslt {}, Let act pop action Ag
tag = ok /* act conflict actions last episode.. go next goal */
search-reslt replay_trace_goals (G-{g}, U{act}, k, SSassigns, SS1, PG, PE)
else-if tag =ng loop /* last action assign level & act mutex last
episode --So next-level regressed goals reside child search segment already visited */

else tag = sm loop /* act static mutex action last episode */
else tag = dm /* act dynamic mutex action last episode retest it...*/
dynamic mutex persists loop
else change tag ok g-assigns vector /* act longer mutex actions */
G-{g} empty /* resume backward search level */
search-reslt assign_goals (G-{g}, U{act}, k, SS1, PG,PE)
else /* goals left satisfy SS1, setup search lower level */
search-reslt assign_next_level_goals (A U{act}, k, SS1, PG, PE)
search-reslt =nogood change g-assigns vector tag ng
end-if
search-reslt search segment Return search-reslt (Success)
else loop (check next action)
end-loop /* establishment possibilities prior episode tried ..Now check new actions */
Ag still contains actions /* new actions establishing g level .. attempt assign */
search-reslt assign_new_actions(G, A, Ag, g, g-assigns, k, SS1, PG, PE)
search-reslt search segment Return search-reslt /* Success */
else push g-assigns SS1<trace>
Return nil /* solution found search stemming SS1 goals */
end-if
end

Figure A4: EGBGs search-trace guided algorithm

581

fiZIMMERMAN & KAMBHAMPATI

Appendix B: Exploiting CSP Speedup Methods Reduce Memory Demands

Background implementation details provided six techniques planning
CSP fields proved key controlling memory demands search trace based
planners. variable ordering, value ordering, explanation based learning (EBL), dependency
directed backtracking (DDB), domain preprocessing invariant analysis, replacing redundant multi-level planning graph bi-partite version.
Domain preprocessing invariant analysis:
speedups attainable preprocessing domain problem specifications well
documented (Fox & Long, 1998; Gerevini & Schubert, 1996). Static analysis prior planning
process used infer certain invariant conditions implicit domain theory and/or problem
specification. domain preprocessing me-EGBG PEGG fairly basic, focusing identification extraction invariants action descriptions, typing constructs, subsequent rewrite
domain form efficiently handled planning graph build routines. implementation discriminates static (or permanent) mutex relations dynamic mutex relations
(in mutex condition may eventually relax) actions proposition pairs. information used expedite graph construction me-EGBGs replay action assignments search segment visited.
Domain preprocessing significantly reduce memory requirements extent identifies
propositions need explicitly represented level graph. (Examples
terms extracted action preconditions -and hence get explicitly represented
planning graph levels- include (SMALLER ?X ?Y) term MOVE action towers Hanoi domain typing terms (AUTO ?X) (PLACE ?Y) logistics domains.) benefit
compounded EGBG PEGG since propositions removed action preconditions directly reduce size subgoal sets generated regression search episodes,
hence size search trace.
Bi-partite planning graph:
original Graphplan maintains level-by-level action, proposition, mutex information
distinct structures level, thereby duplicating -often many times over- information contained previous levels. multi-level planning graph efficiently represented indexed
two-part structure finite differencing techniques employed focus aspects
graph structure possibly change extension. leads rapid construction
concise planning graph (Fox & Long 1998; Smith & Weld, 1998).
me-EGBG PEGG, bi-partite graph offers benefit beyond reduced memory demands faster graph construction time; PE transposition process described section 3.1 reduced simply incrementing search segments graph level index. straightforward
multi-level graph built Graphplan, since proposition (and action) referenced
search segments unique data structure itself.
Explanation Based Learning Dependency Directed Backtracking:
application explanation based learning (EBL) dependency directed backtracking (DDB)
investigated preliminary way (Zimmerman & Kambhampati, 1999), primary
interest speedup benefits. techniques shown result modest speedups
582

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

several small problems complexity integrating maintenance PE replay
vectors limited size problem could handled. since succeeded implementing
robust version methods, results reported reflect that.
EBL DDB based explaining failures leaf-nodes search tree, propagating explanations upwards search tree (Kambhampati, 1998). DDB involves using propagation failure explanations support intelligent backtracking, EBL involves
storing interior-node failure explanations, pruning future search nodes. approach implements complimentary techniques Graphplan reported (Kambhampati, 2000)
speedups ranged ~2x blocksworld problems ~100x ferry domain problems.
refer study full description EBL/DDB Graphplan context, note aspects particularly relevant me-EGBG PEGG.
conflict directed back-jumping (Prosser, 1993), failure explanations compactly represented terms conflict sets identify specific action/goal assignments gave rise
backtracking. liberates search chronological backtracking, allowing jump back
recent variable taking part conflict set. attempts satisfy set subgoals (a
state) fail, conflict set regressed back represents useful minimal no-good memoization. (See PEGG algorithm Figures 8 9 depiction process.) conflict set
memo usually shorter hence general one generated stored standard
Graphplan. Additionally, EBL-augmented Graphplan generally requires less memory memo
caches.
Less obvious speedup benefit perhaps, role EBL DDB often play dramatically reducing memory footprint pilot explanation. Together EBL DDB shortcut
search process steering away areas search space provably devoid solutions.
Search trace memory demands decrease proportionally.
me-EGBG PEGG outfitted EBL/DDB non-PE directed Graphplan-style search. me-EGBG however, use EBL/DDB replay action assignment results PE search segment due complexity retract parts assignment
vectors whenever conflict set new episode entails new replay order.
Value Variable Ordering:
Value variable ordering well known speedup methods CSP solvers. context
Graphplans regression search given planning graph level k, variables regressed subgoals values possible actions give propositions level k graph.
original paper, Blum Furst (1997) argue variable value ordering heuristics
particularly useful improving Graphplan, mainly exhaustive search required levels
solution bearing level anyway. Nonetheless, impact dynamic variable ordering
(DVO) Graphplan performance examined (Kambhampati, 2000), modest speedups
achieved using standard CSP technique selecting assignment subgoal (variable)
least number remaining establishers (values). impressive results reported
later study (Nguyen & Kambhampati, 2000) distance-based heuristics rooted planning
graph exploited order subgoals goal establishers. configuration, Graphplan
exhibits speedups ranging 1.3 100x, depending particular heuristic problem.

583

fiZIMMERMAN & KAMBHAMPATI

study fix variable ordering according adjusted sum heuristic value ordering
according set level heuristic, found combination reasonably robust across
range test bed problems. heuristics described Section 5 used
direct traversal PE states discussed. Section 4.1 describes highly problem-dependent
performance distance-based variable value ordering search trace-based planners.
manner EGBG/PEGG builds maintains planning graph search trace
structures actually reduces cost variable value ordering. default order Graphplan considers establishers (values) satisfying proposition (variable) given level set
order appear planning graph structure. graph construction me-EGBG
PEGG set order correspond desired value ordering heuristic, ordering computed once. part, PE constructed search record
heuristically-best ordering regression states goals, variable ordering done
given state. contrasts versions Graphplan outfitted
variable value ordering (Kambhampati, 2000) ordering reassessed time state
regenerated successive search episodes.

References
Blum, A. & Furst, M.L. (1997). Fast planning planning graph analysis. Artificial
Intelligence, 90(1-2).
Bonet, B., Loerincs, G., & Geffner, H. (1997). robust fast action selection mechanism
planning. Proceedings AAAI-97.
Bonet, B. & Geffner, H. (1999). Planning heuristic search: New results. Proceedings
ECP-99.
Do, M.B. & Kambhampati, S. (2000). Solving Planning-Graph compiling CSP.
Proceedings AIPS-00.
Fox, M., & Long, D. (1998). automatic inference state invariants TIM. Journal
Artificial Intelligence Research, 9, 317-371.
Frost, D. & Dechter, R. (1994). search best constraint satisfaction search. Proceedings
AAAI-94.
Gerevini , A., & Schubert, L. (1996). Accelerating Partial Order Planners: techniques
effective search control pruning. Journal Artificial Intelligence Research 5, 95-137.
Gerevini, A. & Serina, I., (2002). LPG: planner based local search planning graphs
action costs. Proceedings AIPS-02.
Haslum, P., & Geffner, H. (2000). Admissible Heuristics Optimal Planning. Proceedings.
AIPS-00.
Hoffman, J. (2001) heuristic domain independent planning use enforced hillclimbing algorithm. Technical Report No. 133, Albert Ludwigs University.
Kambhampati, S. (1998). relations Intelligent Backtracking Failure-driven
Explanation Based Learning Constraint Satisfaction Planning. Artificial Intelligence,
105(1-2).
Kambhampati, S. (2000). Planning Graph (dynamic) CSP: Exploiting EBL, DDB
CSP search techniques Graphplan. Journal Artificial Intelligence Research, 12, 1-34.
Kambhampati, S. & Sanchez, R. (2000). Distance-based Goal-ordering heuristics Graphplan.
Proceedings AIPS-00.
584

fiUSING MEMORY TRANSFORM SEARCH PLANNING GRAPH

Kambhampati, S., Parker, E., & Lambrecht, E. (1997). Understanding extending Graphplan.
Proceedings ECP-97.
Kautz, H. & Selman, B. (1996). Pushing envelope:
stochastic search. Proceedings AAAI-96.

Planning, prepositional logic

Kautz, H. & Selman, B. (1999). Unifying SAT-based Graph-based Planning. Proceedings
IJCAI-99, Vol 1.
Koehler, D., Nebel, B., Hoffman, J., & Dimopoulos, Y., (1997). Extending planning graphs
ADL subset. Proceedings ECP-97, 273-285.
Korf, R. (1985). Depth-first iterative-deepening: optimal admissible tree search. Artificial
Intelligence, 27(1), 97-109.
Korf, R. (1990). Real-time heuristic search. Artificial Intelligence, 42, 189-211.
Long, D. & Fox, M. (1999). Efficient implementation plan graph STAN. Journal
Artificial Intelligence Research, 10, 87-115.
Mittal, S., & Falkenhainer, B. (1990). Dynamic constraint satisfaction problems. Proceedings
AAAI-90.
McDermott, D. (1999). Using regression graphs control search planning. Artificial
Intelligence, 109(1-2), 111-160.
Nigenda, R., & Kambhampati, S. (2003). AltAltp: Online Parallelization Plans Heuristic
State Search. Journal Artificial Intelligence Research, 19, 631-657.
Nguyen, X. & Kambhampati, S. (2000). Extracting effective admissible state space heuristics
planning graph. Proceedings AAAI-00.
Prosser, P. (1993). Domain filtering degrade intelligent backtracking search. Proceedings
IJCAI-93.
Russell, S.J., (1992). Efficient memory-bounded search methods. Proceedings ECAI 92.
Sen, A.K., & Bagchi, A., (1989). Fast recursive formulations best-first search allow
controlled use memory. Proceedings IJCAI-89.
Selman, B, Levesque, H., & Mitchell, D. (1992). new method solving hard satisfiability
problems. Proceedings AAAI-92.
Smith, D., Weld, D. (1998). Incremental Graphplan. Technical Report 98-09-06. Univ. Wash.
Srivastava, B., Nguyen, X., Kambhampati, S., Do, M., Nambiar, U. Nie, Z., Nigenda, R.,
Zimmerman, T. (2001). AltAlt: Combining Graphplan Heuristic State Search. AI
Magazine, 22(3), American Association Artificial Intelligence, Fall 2001.
Zimmerman, T. (2003). Exploiting memory search high quality plans planning
graph. PhD dissertation, Arizona State University.
Zimmerman, T. & Kambhampati, S. (1999). Exploiting Symmetry Planning-graph via
Explanation-Guided Search. Proceedings AAAI-99.
Zimmerman, T., Kambhampati, S. (2002). Generating parallel plans satisfying multiple criteria
anytime fashion. Proceedings workshop Planning Scheduling Multiple
Criteria, AIPS-02.
Zimmerman, T. & Kambhampati, S. (2003). Using available memory transform Graphplans
search. Poster paper Proceedings IJCAI-03.

585


