journal artificial intelligence

submitted published

memory transform search graph
terry zimmerman

wizim cs cmu edu

robotics institute carnegie mellon university
pittsburgh pa

subbarao kambhampati

rao asu edu

department computer science engineering
arizona state university tempe az

abstract
graphplan generating optimal make span plans containing parallel sets actions remains one effective ways generate plans however despite enhancements range fronts currently dominated terms speed state space
planners employ distance heuristics quickly generate serial plans report family strategies employ available memory construct search trace learn
aspects graphplans iterative search episodes order expedite search subsequent episodes
approaches partitioned two classes according type extent
search experience captured trace planners aggressive tracing method
able avoid much graphplans redundant search effort planners second class trade
aspect favor much higher degree freedom graphplan traversing space
states generated regression search graph tactic favored second exploiting search trace transform depth first ida nature graphplans
search iterative state space view shown powerful demonstrate
distance state space heuristics adapted informed traversal search trace used
second class planners develop augmentation targeted specifically graph
search guided heuristic step optimal version planner class clearly
dominates even highly enhanced version graphplan adopting beam search search
trace virtually optimal parallel plans generated speeds quite competitive
modern heuristic state space planner

introduction
graphplan introduced blum furst became one fastest programs
solving benchmark time accounts constituted radically different automated despite recent dominance heuristic state search
planners graphplan style planners graphplan still one effective ways
generate called optimal parallel plans state space planners drowned exponential
branching factors search space parallel plans exponential branching fact
planner needs consider subset non interfering actions years since
introduction graphplan system enhanced numerous fronts ranging
graph construction efficiencies reduce size build time one orders magnitude smith weld long fox search speedup techniques variable
value ordering dependency directed backtracking explanation learning kambhampati
spite advances graphplan ceded lead speed variety heuristic guided planners bonet geffner nguyen kambhampati gerevini serina
notably several exploit graph powerful state space heuristics
ai access foundation rights reserved

fizimmerman kambhampati

eschewing search graph nonetheless graphplan remains perhaps fastest parallel mainly way combines iterative deepening ida
korf search style highly efficient csp incremental generation applicable action
subsets
investigate use available memory surmount graphplans major
drawbacks redundant search effort need exhaustively search k length
graph proceeding k length graph time wish retain attractive features graphplans ida search rapid generation parallel action steps ability
step optimal plans describe remains rooted iterative search
graph greatly expedites search building maintaining concise search trace
graphplan alternates two phases one data structure called graph
incrementally extended backward phase graph searched extract
valid plan first regression search phase space explored given episode closely
correlated conducted preceding episode strategy pursue work employ appropriately designed trace search conducted episode n failed solution identify avoid aspects search provably unchanged episode n
focus effort features may evolved identified precisely features dynamic across graphplan search episodes construct search traces capture exploit features different degrees depending design search trace may provide benefits
avoidance much graphplans redundant search effort learning iterative search experience improve heuristics constraints embodied graph
realizing much higher degree freedom graphplan traversing space states generated regression search process third advantage particularly key
search trace effectiveness allows planner focus attention promising areas
search space
issue much memory right amount use boost performance
cuts across range computational approaches search paging process operating systems internet browsing database processing operations investigation explore several alternative search trace methods differ markedly terms memory demands
describe four approaches figure depicts pedigree family search
trace planners well primary impetus leading evolution system
predecessor figure suggests relative degree planner steps away
original ida search process underlying graphplan two tracks correspond two genres
search trace developed


left track egbg planners explanation guided backward search graphplan employ
comprehensive search trace focused minimizing redundant search



right track pegg planners pilot explanation guided graphplan use skeletal
trace incurring graphplans redundant search effort exchange reduced memory
demands increased ability exploit state space view search space

egbg planner zimmerman kambhampati adopts memory intensive structure
search trace seeks primarily minimize redundant consistency checking across graphplans
search iterations proves effective range smaller memory constraints



fiusing memory transform search graph

xy

search
trace
exploiting graphplan
symmetry redundancy

exploiting
state space view

egbg
leveraging csp memory efficiency

pegg
egbg
trading step optimality
speedup episodes

pegg

figure applying available memory step away graphplan search process
family search trace planners
impede ability scale noting graphplans search process viewed specialized
form csp search kambhampati explore middle ground terms memory usage augmenting egbg several methods known effective speedup techniques csp

primary interest techniques however impact memory reduction describe accomplish beyond search speedup benefit afford implemented planner egbg markedly outperforms egbg speed capabilities variety
still lie beyond planners reach due memory constraints
search trace structure used pegg track planners trades minimization redundant
search exchange much smaller memory footprint addition greatly reduced memory
demands pegg search trace structure exploited intrinsic state space view
essentially graphplans csp oriented search space significant speedup advantage
graphplan egbg track planners derives ability employ distance
heuristics power many current generation state space planners bonet geffner
nguyen kambhampati hoffman adapt heuristics task identifying
promising states visit search trace implement first pegg
planner step optimal pegg zimmerman kambhampati pegg outperforms even
highly enhanced version graphplan two orders magnitude terms speed
maintaining guarantee finding step optimal plan
finally explore adoption beam search visiting state space implicit
pegg style trace employ distance heuristics extracted graph
direct order search trace states visited prune restrict
space heuristically best set states according user specified metric
graph leveraged provide measure likelihood previously generated regression state might spawn search branches higher graph level


fizimmerman kambhampati

term metric flux employ effective filter states skipped even
though might appear promising distance heuristic implemented pegg
system zimmerman kambhampati exploiting search trace produces
two fold benefit previous approaches reduction search trace memory demands
effective release graphplans exhaustive search graph search episodes pegg exhibits speedups ranging x enhanced version graphplan
quite competitive recent state space planner similar heuristics adopting beam
search pegg necessarily sacrifices guarantee step optimality empirical evidence indicates
secondary heuristics remarkably effective ensuring make span solutions produced
virtually optimal
fact systems successfully employ search trace noteworthy general
tactic adopting search trace explicitly generate node states iterative
search episodes found infeasible due memory demands exponential
depth solution sections describe tight integration search trace
graph permits egbg pegg planners largely circumvent issue
graph structure costly construct terms memory time
well known even domains problematic planners employ postgraphplan planners employ graph purpose include stan long fox
blackbox kautz selman ipp koehler et al altalt nguyen kambhampati lpg gerevini serina systems described share
memory overhead course interestingly found search trace memory demands
pegg class planners significantly limited range solve
remainder organized follows section provides brief overview
graph graphplans search process discussion csp nature manner process viewed ida search motivates potential employing available memory accelerate solution extraction section addresses two primary challenges attempting build use search trace advantage graphplan done within
reasonable memory constraints given graphplans csp style search graph
trace available effectively used section briefly describes egbg
zimmerman kambhampati first system use search trace guide graphplans
search outlines limitations method details contained appendix
section summarizes investigations variety memory reduction techniques reports impact combination six performance egbg pegg planners
discussed section performance pegg pegg beam search compared enhanced version graphplan egbg modern serial state space planner section
contains discussion findings section compares work related finally
section wraps conclusions
background motivation graphs nature direct
graph search
outline graphplan discuss traits suggesting judicious use additional
memory might greatly improve performance touch three related views graphplans
search form csp ida search state space aspect


fiusing memory transform search graph

actions
level

initial
state
w

graph
propositions
propositions
actions
level
level
level
nop
nop

w
w

nop




actions
level

w

nop

w

w

nop

w





nop




nop

nop

nop

x


z
h



nop







nop

h

nop



nop




nop

h

propositions
level










nop

j



j

nop

j

domain actions





ihw
hj



x

action descriptions





w
ij



z




j

action id effects
preconditions

figure graph representation three levels alpha domain
construction search graph
graphplan employs two interleaved phases forward phase data structure
called graph incrementally extended backward phase graph
searched extract valid plan graph consists two alternating structures called
proposition lists action lists bottom figure depicted simple domain refer
alpha domain use illustration study figure shows four action proposition levels graph engendered simple initial state given domain start
initial state zeroth level proposition list given k level graph extension
graph structure level k involves introducing actions whose preconditions present
kth level proposition list addition actions domain model operation actions
introduced one condition kth level proposition list abbreviated nop papers
figures termed persists others nop c action c precondition c
effect given kth level actions proposition list level k constructed union
effects introduced actions graph maintains dependency links



fizimmerman kambhampati

actions level k preconditions level k proposition list effects level
k proposition list
graph construction binary mutex constraints computed propagated
figure arcs denote mutex relations pairs propositions pairs actions
propagation starts level labeling mutex pairs actions statically interfering
static mutex preconditions effects logically inconsistent mutexes
propagated level forward two simple propagation rules two propositions
level k marked mutex actions level k support one proposition mutex actions support second proposition two actions level mutex statically
interfering precondition first action mutually exclusive precondition second term latter dynamic mutex since constraint may relax higher graph
level propositions static mutex one negates dynamic mutex actions supporting one proposition mutex actions supporting
reduce figure clutter mutex arcs propositions negations omitted
search phase k level graph involves checking see sub graph
graph corresponds valid solution figure depicts graphplan search
manner similar csp variable value assignment process beginning propositions
corresponding goals level k incrementally select set actions level k action
list support goals two actions selected supporting two different goals
mutually exclusive backtrack try change selection actions essentially csp goal propositions level variables actions establish
proposition values mutex conditions constitute constraints search proceeds
depth first fashion goals level supported recursively call search process k level graph preconditions actions selected level k
goals k level search search succeeds reach level initial state
solution extracted unwinding recursive goal assignment calls process viewed
system solving dynamic csps dcsp mittal falkenhainer kambhampati
wherein standard csp formalism augmented concept variables appear
k get activated variables assigned
interleaved graph extension search phases graph may extended
stasis condition changes occur actions propositions mutex conditions
sufficient condition defining level level actions introduced
existing mutex conditions propositions go away refer graph levels
level static levels note although graph becomes static point finding
solution may require many episodes composed adding identical static levels conducting
regression search goals
many fielded csp solvers graphplan search process benefits simple form nogood learning set sub goals level k determined unsolvable memoized level hash table subsequently backward search process later enters level k
set subgoals first checked hash table match found search


static mutex condition called eternal mutex dynamic mutex termed conditional mutex smith
weld



fiusing memory transform search graph

j nop









w

j









j



yj








w

z nop



j


j



nop

nop

h nop





j




nop



j

nop



x



nop



level



x




yh j





w



ha nop





nop

nop





nop


j





nop









z nop

wxyz



h nop




nop j


nop

nop

wyhij

initial state




goal state

nop










nop

h




level

level

yhi

icon explanation
action assigned give
assigned action
assigned action
j

goal j
static mutex
dynamic mutex

previous assigned action
previous assigned action

goal already satisfied
set regressed subgoals

previously assigned action
satisfied next lower level

figure csp style trace graphplans regression search figure graph
process backtracks constitutes one three conditions backtracking two others arise
attempts assign static mutex actions dynamic mutex actions see figure legend
next discuss graphplans search higher level view abstracts away csp nature
graphplan state space search
abstract perspective graphplan viewed conducting regression state space
search goals initial state view states generated expanded subgoals csp process given set subgoals finds consistent
set actions satisfying subgoals graph level c f kambhampati sanchez
view state generator function effectively graphplans csp style goal assignment routine seeks non mutex set actions given set subgoals within given
graph level view depicted figure top graph casts csp style search trace


fizimmerman kambhampati



init
state

w




proposition levels



valid sets action
assignments satisfy
goals wxyz level

j





init
state

w



w

h
goal

w
x

z

h





proposition levels














w

h


















j

goal

w
x

z









h















w











w

h











j


h





























init
state



proposition levels




goal
w
x

z



figure graphplans regression search space three consecutive search episodes
figure high level state space search trace terms box depict set positive
subgoals action assignment process goals higher level state
box linked
recognizing state space aspect graphplans search helps understanding connection
ida search first noted briefly discussed bonet geffner highlight expand
upon relationship three correspondences
graphplans episodic search process nodes generated previous episode regenerated episode possibly nodes corresponds ida iterative
search graphplan nodes states sets subgoals regres

figure facilitates discussion search trace next section conjuring hypothetical
first search episode begins level graph instead level figure



fiusing memory transform search graph

sion search given plan graph level succeeds perspective node generator
function effectively graphplans csp style goal assignment routine seeks non mutex
set actions given set propositions within given graph level
state space view graphplans search ala figure within given search episode iteration conducts search depth first fashion ida ensures
space requirements linear depth solution node
upper bound iteratively deepened ala ida node state heuristic f value
f g h context h distance terms associated graph levels
state generated graphplans regression search initial state g cost reaching
state goal state terms number csp epochs e numerical difference highest graph level states level
purposes perhaps important observation implicit f value bound
given iteration length graph associated iteration
node state associated graph level determines distance initial state h
cost reach goal state g total must equal length plan graph
heuristic clearly admissible shorter distance goal graphplan
exhaustively searches shorter length graphs previous iterations heuristic
implicit graphplan guarantees step optimal solution returned note
perspective nodes visited given graphplan search iteration implicitly
f value g h length graph consider implications property
address informed traversal graphplans search space section
primary shortcoming standard ida search regenerates many
nodes iterations long recognized ida difficulties
spaces traced little memory russell sen bagchi
information carried one iteration next upper bound f value graphplan partially addresses shortcoming memo caches store goods states found
inconsistent successive episodes however ida nature search make inefficient planner goal propositions appear non mutex graph
many levels valid plan actually extracted
second shortcoming ida nature graphplans search node states generated
given graphplan episode f value e length graph within
iteration search episode discernible preference visiting one state another
next discuss use available memory target shortcomings graphplans search
efficient use search trace guide graph search
search space graphplan explores given search episode defined constrained three
factors goals plan graph associated episode cache memoized nogood states created previous search episodes typical ida search considerable


bonet geffner define hg graphplan h value somewhat differently first level goals
state appear non mutex memoized definition necessarily first level
sm goals appear non mutex produces informed admissible estimate cases
guarantees states generated graphplan f value equal graph length
property primary interest us



fizimmerman kambhampati

similarity e redundancy search space successive episodes plan graph extended
fact discussed backward search conducted level k graph essentially
replay search conducted previous level k certain well defined extensions
specifically essentially every set subgoals generated backward search episode n starting
level k regenerated graphplan episode n starting level k unless solution
found first
returning figure entirety note depicts state space tree structure corresponding graphplans search three consecutive iterations top graph discussed represents subgoal states generated course graphplans first attempt satisfy wxyz
goal resembling running example implied w x z propositions
present graph level first level pair
mutex second search episode middle figure graph states generated
one level higher addition states expanded generate number children
shown darker shade since figure hypothetical variation alpha domain
detailed figures states created beyond first episode labeled state numbers representing order generated finally third episode graphplan regenerates states previous two episodes attempting satisfy wxyz level ultimately finds solution assigned actions associated figures double outlined subgoal
sets generating states shown darkest shading bottom graph figure
noting extent consecutive iterations graphplans search overlap investigate
application additional memory store trace explored search tree first implemented
egbg summarized following subsection seeks leverage appropriately designed search trace avoid much inter episode redundant search effort possible
zimmerman kambhampati
aggressive use memory tracing search egbg planner
types csp graphplan consumes computational effort
given checking constraints instrumented version planner reveals typically
cpu run time spent creating checking action proposition mutexes
graph construction search process mutex relations incorporated graph primary constraints csp view graphplan kambhampati
obvious starting point seeking efficiency improvements planner
primary tactic adopted egbg provide overview referring
interested reader appendix details
egbg exploits four features graph graphplans search process



set actions establish given proposition level k superset
establishing proposition level k

strictly speaking case due impact graphplans memoizing process
particular branch search tree generated search episode n rooted graph level k may revisited
episode n level k due good proposition set memoized level k however memo merely acts
avoid redundant search neglecting relatively rare cases serves simplify visualization symmetry
across graphplans search episodes



fiusing memory transform search graph



constraints mutexes active level k monotonically decrease increasing
graph levels mutex active level k may may continue
active level k becomes inactive never gets activated future levels



two actions level statically mutex e effects preconditions conflict
mutex succeeding levels



goal set satisfied level k set searched
level k graph extended subgoal set present level k
two propositions mutex remain future levels

given appropriate trace search conducted episode n failed solution
would ignore aspects search provably unchanged episode n focus effort features may evolved previous search failed extract solution
k length graph search k length graph succeed one
following conditions holds
dynamic mutex condition pair actions whose concurrent assignment
attempted episode n longer holds episode n
subgoal generated regression search episode n graph level
k action establishes episode n first appears level k
episode n regression state subgoal set level k matched cached memo
level memo match generated level k episode n
discussion appendix formalizes conditions instance one
conditions hold complete policy must resume backward search search parameters associated instance previous episode n resumed partial search episodes
solution generate additional trace subgoal sets augment parent trace specialized search trace used direct future backward search episodes
viewed explanation failure search process episode hereafter use
terms pilot explanation pe search trace interchangeably following definitions useful describing search process
search segment essentially state specifically set graph level specific subgoals
generated regression search goal state first search segment
egbg search segment sn generated graph level k contains
subgoal set propositions satisfied
pointer parent search segment sp state level k gave rise sn
list actions assigned sp resulted subgoals sn
pointer pe level defined associated sn
sequential list action consistency checking process attempt satisfy sns subgoals possible trace given consistency check static mutex
dynamic mutex action consistent prior assigned actions trace
stored list bit vectors efficiency
search segment therefore represents state plus path information often use search
segment state interchangeably boxes figure whether state goals
explicitly shown viewed search segments



fizimmerman kambhampati

pilot explanation pe search trace consists entire linked set search segments
representing search space visited graphplan backward search episode convenient
visualize figure tiered structure separate caches segments associated search
graph level adopt convention numbering pe levels reverse
order plan graph top pe level contains single search segment whose goals
goals level number incremented move towards initial state
solution found pe necessarily extend highest plan graph level initial state
shown third graph figure
pe transposition state first generated search episode n associated specific
graph level say k premise search trace guide search episode n
idea associating pe search segment state generated updated episode n
next higher graph level define transposing pe search
segment pe associated graph level k search episode n associate
level k episode n
given definitions note states pe search episode n plan graph
level k loosely constitute minimal set states visited backward search conducted episode n level k bound visualized sliding fixed tree search
segments first graph figure one level
conducting search egbg search trace
egbg builds initial pilot explanation first regression search episode tracing
search process augmented version graphplans assign goals routine solution
possible k length graph pe transposed one level key features previous search replayed significant search effort occurs points one
three conditions described holds search process pe augmented according search space visited
egbg search exploits search trace essentially bi modal fashion alternates
informed selection state search trace previous experience focused csp type
search states subgoals discussion egbgs bi modal revolves around
second mode minimizing redundant search effort state chosen visitation
describe peggs use search trace section see greater potential
dramatic efficiency increases lies first mode selection promising state
search trace
choosing state visit egbg uses trace previous episode focus
aspects entailed search could possibly changed search segment si
graph level k visitation step process
perform memo check ensure subgoals si valid level k
replay previous episodes action assignment sequence subgoals si
segments ordered trace vectors mutex checking conducted pairs actions
dynamic mutex level k actions longer dynamic mutex add

possible graphplans memoizing process preclude states regenerated subsequent episode
see footnote brief explanation conditions may occur



fiusing memory transform search graph

didate action sis list consistent assignments resume graphplan style search remaining goals si augmented pe extended process whenever sis goals
successfully assigned entailing set subgoals satisfied lower level k child
search segment created linked si added pe
si subgoal replay sequence check actions appearing level k
establish subgoal actions inconsistent previously assigned action
logged sis assignments actions conflict previously assigned assign resume graphplan style search point step
memoize sis goals level k solution found via search process steps
long segments pe visited manner planner guaranteed
optimal plan search episode graphplan hereafter refer pe search segment
visited extended via backward search valid plan seed segment addition
segments part plan extracted pe call plan segments thus third
graph figure apparent seed segment plan segments bottom order
labeled segments yh yhi goal state wxyz
principle freedom traverse search states encapsulated pe order
longer restricted non informed depth first nature graphplans search process
unfortunately egbg incurs high overhead associated visiting search segments order bottom terms pe levels ancestor state represented pe
visited state egbgs search process would regenerate state
descendents unless first finds solution non trivial cost associated generating
assignment trace information egbgs search segments search advantage lies reusing trace data without regenerate
hand top visitation segments pe levels degenerate mode
search process essentially mimics graphplans since episode begins search
goal set exception replay top level search segments assignments
regenerates states generated previous episode plus possibly states
regression search search trace provides significant advantage top visitation
policy
bottom policy hand intuitive appeal since lowest levels pe correspond portions search space lie closest initial state terms plan steps
state one lower levels fact extended solution planner avoids search
effort graphplan would expend reaching state top level goals
adopting bottom visitation policy amounts layering secondary heuristic primary
ida heuristic graph length iteratively deepened recalling section states pe f value terms primary heuristic essentially biasing favor states low h values support policy comes work
heuristic guided state space bonet geffner nguyen kambhampati
weighting h factor relative g component heuristic f value generally improved performance however unlike state space systems primary heuristic egbg employs secondary heuristic guarantee step optimality



fizimmerman kambhampati

standard graphplan

speedup ratios

egbg


time

bktrks

mutex
chks



x

x

x

k



x

x

x

k

k



x

x

x

k

k



x

x

x

total
time

backtracks

mutex
checks

total
time

backtracks

mutex
checks

size
pe

bw large b




k

k



k

k

rocket ext




k

k



k

tower




k

k



ferry




k

k



table comparison egbg standard graphplan
numbers parentheses give number time steps number actions respectively search backtracks
mutex checks performed search shown size pe pilot explanation size terms
final number search segments standard graphplan lisp version smith peot

depend admissibility found bottom visitation efficient mode
egbg default order egbg reported study
egbg experimental
table shows performance reported first version egbg zimmerman
kambhampati amongst search trace designs tried version memory
intensive records greatest extent search experience runtime number search
backtracks number search mutex checks performed compared lisp implementation original graphplan egbg exhibits clear advantage graphplan
small set




total runtime x improvement
number backtracks search x improvement
number mutex checking operations search x improvement

since total time course highly dependent machine well coding language
egbg performance particularly sensitive available memory backtrack mutex checking
metrics provide better comparative measure search efficiency graphplan mutex checking
far biggest consumer computation time latter metric perhaps
complete indicator search process improvements variation
egbgs effectiveness attributed static dynamic mutex ratio characterizing graphplans
action assignment routine action assignments rejected due pair wise statically mutex
actions greater advantage enjoyed system doesnt need retest tower ofhanoi fall classification
noted original study zimmerman kambhampati range


planners developed report coded allegro lisp run pentium mhz ram
runtimes include plangraph construction time exclude garbage collection time values table differ
published run platform reflect changes tracking statistics



fiusing memory transform search graph

handled implementation significantly restricted amount memory available
program runtime example pe consisting almost search segments
modest sized bw large b challenges available memory limit test machine
consider next egbg figure occupies middle ground terms memory
demands amongst search trace approaches investigated
engineering reduce egbg memory requirements egbg planner
memory demands associated graphplans search process major concern since
conducts depth first search search space requirements linear depth solution node
since seek avoid redundancy inherent ida episodes graphplans search
search trace must deal much different memory demand profile search trace design
employed egbg memory requirements exponential depth solution however search trace grows direct proportion search space actually visited techniques
prune search act greatly reduce memory demands
examined variety methods respect issue eventually implemented suite
seven together proven instrumental helping egbg later pegg overcome memorybound limitations six known techniques csp fields variable ordering value ordering explanation learning ebl dependency directed backtracking ddb
domain preprocessing invariant analysis transitioning bi partite graph four
six effective methods csp speedup techniques however interest lies primarily
impact search trace memory demands challenging aspects adapting
methods graph search trace context focus thus details
motivation implementation methods relegated appendix b
seventh method novel variant variable ordering call ebl reordering exploits
fact ebl search trace available although method readily implemented pegg strict ordering trace vectors required egbg search trace make
costly implement planner memory efficient egbg egbg use
ebl reordering defer discussion pegg introduced section
impact enhancements egbg memory demands
two major modes first six techniques impact memory demand egbg
reduction size pilot explanation search trace number search segments
states average trace content within segments reduction requirements
structures compete pilot explanation available memory e graph
memo caches admittedly two dimensions independent since number
memos though size linear number search segments nonetheless consider
partition discussion facilitate comparison methods impact search
trace
general impact enhancements search process depends significantly
particular presence absence methods
single configuration techniques proves optimal across wide range indeed due
computational overhead associated methods generally possible class
planner performance degrades due presence method chose



ddb











six combination
egbg



ebl



domain preprocess
invariant analysis
value ordering



reduction pe search trace memory requirement



zimmerman kambhampati

variable ordering







bi partite graph















reduction graph memo cache memory requirements

figure memory demand impact along two dimensions six memory reduction speedup
techniques plots applied independently suite within egbg
set techniques joint average impact egbg pegg memory footprint
extensive variety
figure illustrates method impact memory reduction relative two dimensions method operates isolation others plot reflects
twelve three domains logistics blocksworld tower hanoi chosen include
mix entailing large graphs requiring extensive search
requiring horizontal axis plots percent reduction end run memory footprint
combined memo caches graph ratios along ordinate assessed
runs graphplan search trace employed memo cache graph
globally defined structures significant size remain lisp interpreted environment
run completion similarly vertical axis plots percent reduction space required pe
end egbg runs without method activated graph
memo cache structures purged working memory
plot crossbars method depict spread reduction values seen across twelve
along dimensions intersection average bi partite
graph surprisingly impacts graph aspect five six methods seen
impact search trace size graph memo cache size ddb greatest influence pe size little impact graph memo cache size ebl modest influence former larger impact latter due smaller memos creates


allegro common lisp global scavenging function used purge target global data structures
workspace



fiusing memory transform search graph

production general memos engender backtracks domain preprocessing invariant analysis major impact graph size pe size due processes
extraction invariants operator preconditions highly domain dependent little effect case blocksworld great consequence tower ofhanoi logistics
six methods combined complement evidenced crossbars plotting space reduction six employed twelve average reduction
pe size approaches average reduction graph memo cache aspect exceeds
single method isolation averages reduction along dimensions
runtime reduction associated methods isolation highly dependent
methods active general relative time reduction
two methods correlate closely relative memory reduction however found
similarly techniques broadly complement net speedup accrues
techniques listed used improve graphplans performance terms speed order focus impact search trace use
version graphplan enhanced six methods comparisons egbg
pegg study hereafter refer enhanced version graphplan gp e
experimental egbg
table illustrates impact six augmentations discussed previous section egbgs
graphplans performance terms space runtime standard graphplan gp e
egbg egbg compared across benchmark wide range domains including first three aips competitions held date
selected satisfy three objectives subset standard graphplan egbg could solve
comparison egbg different subsets exceed memory limitations three
planners terms graph pe size subset gives rough impression
search time limitations
surprisingly memory efficient egbg clearly outperforms early version attempted importantly egbg able solve variety beyond reach
standard graphplan egbg standard graphplan solves original egbg solves gp e solves egbg solves wherever egbg gp e solve
egbg faster factor x averages x speedup standard
graphplan twelve solve bested egbg factors ranging x
x
striking improvement memory efficient version egbg first version
simply due speedup associated five techniques discussed previous section
directly tied impact search trace memory requirements table indicates one three reasons instance solved planner planner still search
cpu minutes pg memory exhausted exceeded minutes graph building phase pe memory exhausted search due pilot explanation extension third reason clearly favors egbg size pe reported terms search segments time
solved indicates generates retains trace x fewer states
egbg translates much broader reach egbg exhausts memory


fizimmerman kambhampati

table compared first version egbg regardless gp e solves three
egbg fails minutes due search trace memory demands
table illustrates dramatic impact speedup techniques graphplan
enhanced version gp e well x faster original version
solve minutes solve many entirely beyond standard graphplans reach
nonetheless egbg modestly outperforms gp e majority
solve since egbg pegg planners derive strength pe shortcut
graphplans episodic search process advantage realized multiple search
episodes high fraction runtime devoted search thus speedup seen grid
mystery movie mprime domains solution extracted
soon graph reaches level containing goals non mutex state
bottom order egbg visits pe search segments turns surprisingly effective many table found great majority pe final
episode contains seed segment state search reach initial state within
deepest two three pe levels supports intuition discussed section suggests
advantage low h value bias observed heuristic state space planners bonet geffner
nguyen kambhampati trans lates search graph
even memory efficient version egbg reveal two primary weaknesses
action assignment trace vectors allow egbg avoid redundant search somewhat
costly generate make significant demands available memory elicit large
search e g table log puzzle freecell difficult revise
search experience alters drastically subsequent visits
despite surprising effectiveness many bottom visitation pe search
segments inefficient others table freecell essentially
schedule domain graph gets extended level
solution extracted solution arises via search branch generated root
search segment e goal state thus seed segment pe topmost search segment bottom visitation pe states costly graphplans
top
first shortcoming particularly manifest allow egbg exploit
pe e g solution extracted first search episode hit egbg
takes relative graphplan closely tied overhead associated building
search trace compelling tactic address second shortcoming traverse search space
implicit pe according state space heuristics might wish example exploit
variety state space heuristics revolutionized state space planners recent years
bonet geffner nguyen kambhampati gerevini serina however
noted section depart policy visiting egbg search segments level bylevel bottom order face costly bookkeeping high memory management overhead
informed traversal state space view graphplans search space taken next
argue perhaps key benefit afforded trace search graph



fiusing memory transform search graph



steps actions

bw large b
huge fct

rocket ext
att log

gripper
tower

tower
puzzle
puzzle
tsp

aips
grid
grid
gripper x
gripper x
gripper x
log

mprime x
movie x
mysty x
aips
blocks
blocks
logistics
logistics
logistics
freecell
schedule
schedule
aips
depot
depot
driverlog
driverlog e
roverprob
roverprob
strips sat x
strips sat x
ztravel
ztravel

egbg

graphplan
cpu sec

stnd



gp e

cpu sec

enhanced



















graphplan
gp e


pg
pg






pg







graphplan
gp e












pg

pg

graphplan
gp e
























pe



pe
pe
pe

pg

pe
pe
pg




size
pe







egbg






egbg

pe
pe

pe
pe
pe
pg
pg





pe


pe
pe

egbg





egbg

speedup
egbg
vs gp e








pe





egbg


pg






pe







egbg










pe





egbg



















pe

x
x
x
x
x
x
x
pe
x
x
speedup
x

x
x
x
pe
x
x
x
speedup
x
x
x
x
x
pe
x
x
speedup
x
x
x
x
x
x
x
x
x


memory efficient egbg
cpu sec
size
pe









table search step optimal plans egbg egbg standard enhanced graphplan
standard graphplan lisp version smith peot
gp e graphplan enhanced per section egbg memory efficient egbg
size pe final search trace size terms number search segments
search failure modes pg exceeded mins memory constraints graph building
pe exceeded memory limit search due size pe
exceeded mins search
parentheses adjacent cpu time give steps actions solution


fizimmerman kambhampati

focusing state space view pegg pegg planners
costs associated egbgs generation use search trace directly attributable
storage updating replay csp value assignments search segments subgoals
therefore investigated stripped version search trace abandons tactic focuses
instead embodied state space information pegg planners employing
search trace pegg step optimal version pegg version beam search
outperform egbg planners larger key difference egbgs pilot explanation pared skeletal pe used pegg planners elimination detailed
mutex checking information contained bit vectors former e last item bullet
list egbg search segment contents section pegg planners apply state space
heuristics rank pe search segments associated subgoal sets states free
visit state space informed manner tradeoff pe state visited
planner must regenerate csp effort finding consistent action assignments subgoals
figure illustrates pegg advantage small hypothetical search trace final search episode search segments pe onset episode appear solid lines plan
segments states extendable valid plan shown double lined boxes figure reflects
fact typically may many latent plan segments diverse branches search trace
solution bearing episode clearly planner discriminate plan segment states
states pe could solve quickly planner restricted bottom traversal deepest pe level first state space heuristics endow pegg planners capability
pegg planner visits every search segment pe search episode comparable graphplans exhaustive search given length graph thereby guaranteeing returned
plans step optimal advantage heuristic guided traversal realized
final episode many computational effort expended graphplan last search
episode greatly exceeds previous episodes combined still powerful advantage however scale larger terms number size search
episodes cost exhaustive search even intermediate episodes becomes prohibitive


init
state

goal



w

w
x

z




























proposition levels





figure pe final search episode hypothetical search segments pe
onset search appear solid lines double lined boxes represent plan segments
dashed lined boxes states newly generated regression search episode
visitation order dictated secondary heuristic shown via numbering


fiusing memory transform search graph

planner refer simply pegg employs beam search applying search trace heuristics
intermediate search episodes visit select subset pe segments pegg
trades step optimality guarantee often greatly reduced solution times
several challenges must dealt effectively use pared search trace
employed pegg pegg including adaptation augmentation distance heuristics guide search trace traversal dealing memory management induced
tactic skipping search space describe addressed issues
give complete description first present provide perspective effectiveness planners
experimental pegg pegg
table compares graphplan standard gp e egbg pegg pegg
table adds variety larger latter two systems
handle table easily solved gp e egbg e g aips
movie mystery domains omitted table planners employ variable
value ordering e except standard graphplan configured use value ordering
graph level action first appears goal ordering proposition distance
determined adjusted sum heuristic defined variety
parameters pegg pegg planners optimal configurations tend
dependent defer discussion sections note
table following parameter settings used good performance average
across variety domains
secondary heuristic visiting states adjusted sum w eqn
beam search visit best lowest f value search segments per search episode
minimum maximum search segments flux lower average
visited regardless heuristic rank wcf see section
focusing first gp e egbg pegg columns clearly see impact
tradeoff storing exploiting intra segment action assignment information pe
set egbg exceeding available memory due size
pe one pushes limit pegg seven cause egbg run
memory actually solved pegg remainder exceed time limit
search addition pegg handles five table gp e fails
typically entail extensive search final episode pe efficiently shortcuts full graph
search conducted gp e speedup advantage pegg relative gp e ranges
modest slowdown three almost x zeno travel average
x note speedup values reported table pegg
generally planner search trace perform gp e single search episode grid cost building trace recovered low overhead associated building peggs search trace means suffers little relative gp e case
egbg pegg solve egbg upper hand due
ability avoid redundant consistency checking effort fact egbgs advantage sopegg greater attributable peggs ability move pe
search space final search episode versus egbgs bottom traversal lower


fizimmerman kambhampati

graphplan



cpu sec steps acts

stnd
bw large b
bw large c
bw large
att log
att log b
gripper
gripper
tower
tower
puzzle
puzzle
tsp
aips
grid
gripper x
gripper x
log
aips
blocks
blocks
blocks
logistics
logistics
logistics
freecell
freecell
schedule
aips
depot
depot
depot
driverlog e
driverlog b
roverprob
roverprob
roverprob
sat x
sat x
ztravel
ztravel













stnd gp



pg
stnd gp






pg
pg
pg
stnd gp













gp e

egbg
cpu sec
steps acts

enhanced













gp e




gp e









gp e















pegg
heur istic
adjsum

cpu sec
steps acts



pe


pe



pe





pe





egbg
pegg




pe

pe

egbg
pegg




pe




pe

pe

pe



egbg
pegg








pe

pe

pe

pe







pe

pe
pe

pegg

heur adjsum u

cpu sec
steps acts

speedup
pegg
vs gp e


























pegg




pegg









pegg














x
x
x
x
x
x
x
x
x
x
x
x
speedup
x
x
x
x
speedup
x
x
x
x
x
x
x
x
x
speedup
x
x
x
x
x
x
x
x
x
x
x
x

table pegg pegg comparison graphplan gp e egbg
gp e graphplan enhanced per section egbg memory efficient egbg
pegg step optimal search via pe segments ordered adjusted sum u heuristic
pegg beam search best segments pe ordered adjusted sum u heuristic
parentheses give steps actions plan boldface values exceed known
step optimal
see table definitions pg pe


fiusing memory transform search graph

overhead due concise search trace note obvious reason prefer one state
traversal order non solution bearing episodes since step optimal planners visit
states pe search episodes
turning attention pegg apparent beam search greatly extends
size handled pegg solves ten larger table could
solved pegg enhanced graphplan speed wise pegg handily outperforms
planners every except schedule gp e factor x advantage indicated tables right hand column speedup pegg gp e ranges x
x conservative bound peggs maximum advantage relative gp e since speedup
values seventeen gp e fails solve conservatively assessed time
limit seconds
defer analysis section order first describe pegg
advantages extracts search trace
pegg planners
high level pegg pegg given figure graphplan search begins graph extended level goals first appear
binary mutex conditions routine st level goals virtually
graphplans defined first search episode conducted graphplan fashion
except assign goals assign next level goals routines figure initialize pe
create search segments hold states generated regression search process assign goals pseudo code outlines process compiling conflict sets see appendix b means
implementing ddb ebl action assignment search assign next level goals
routine illustrates role top level conflict set recording minimal good search
state completed ebl depicts variable ordering need done state
search segment created child segment created linked parent extending
pe assign next level goals whenever parent goals successfully assigned assign next level goals routine determines subgoals child search segment regressing
parents goals actions assigned checks see initial state
reached remaining goals success signaled returning child search segment used extract ordered actions plan
subsequent first episode pegg plan enters outer loop employs pe conduct
successive search episodes episode newly generated search segments previous
episode evaluated according state space heuristic ranked merged already ordered
pe inner loop search segment visited turn passing subgoals graphplanlike assign goals routine
exit conditions inner loop primarily differentiate pegg pegg
whereas pegg visit every search segment whose goals found match memo
pegg restricts visitation best subset user specified criterion expansion
graph deferred segment chosen visitation transposes graph level exceeding current graph length consequence pegg


fact found advantages respect traversal order even intermediate search episodes however highly dependent consider study



fizimmerman kambhampati

pegg plan ops init goals ops init goals constitutes
build plangraph pg level n goals first occur non mutex state

let pg st level goals ops init goals
pg reached level goals present non mutex state return fail
let n number levels pg
reorder goals according variable ordering method
let ss search segment fields
goalsgoals parent root pe level parent actions
let pe pilot explanation structure fields ranked segs ss segs

conduct graphplan style backward search n length graph storing trace pe

let search reslt assign goals goals n ss pg pe
search reslt search segment success
let plan extract plan actions ancestors linked search reslt
return plan
else n length solution possible use pe search longer length solution
loop forever
n n
rank newly generated states merge existing ordered pe segments list
pe ranked segs merge sort pe ranked segs u heuristic sort pe segs

loop unvisited search segments pe ranked segs optionally segments
heuristic threshold
let ss highest ranked unvisited segment pes ranked segs
let k n pe level ss
graph level ss transposed pe
k n pg extend plangraph pg delays extending graph unavoidable
optionally flux metric ss goals user specified threshold continue loop
ss goals memos level k pg remove ss pes ranked segs
else visit search segment ss
search reslt assign goals ss goals k ss pg pe
search reslt search segment success
let plan extract plan actions ancestors linked search reslt
return plan
else search reslt conflict set
add conflict set level k memos pg memoize minimal nogood
reorder ss goals goals conflict set appear first ebl reordering
end
end loop
end

figure top level pegg pegg planners
planners may able extract step optimal solution building one less level graphplan planners



interestingly pegg beam search could conceivably extract optimal solution graph arbitrary number levels shorter required graphplan consider case pe average extends least
one level deeper episode subset pe search segments visited resides deepest levels pe
arbitrary number search episodes might completed without extending graph experiments date however advantage seldom saves one graph level extension



fiusing memory transform search graph

conduct ddb ebl enhanced graphplan style search building search trace
arguments g goals still assigned action set already assigned k pg level
ss search segment pg graph pe pilot explanation search trace
assign goals g k ss pg pe
let g goal selected g
let ag actions pg level k support g ordered value ordering heuristic
let cs g initialize conflict set ddb
loop act ag
let search reslt
act mutex action
let b goal conflicted action assigned support
cs cs u b augment conflict set continue loop
else act conflict actions already
g g empty
continue goal assignment level
search reslt assign goals g g u act k ss pg pe
else ss goals left satisfy setup search next lower level
search reslt assign next level goals u act k ss pg pe
search reslt conflict set check contains current goal
g search reslt
absorb returned conflict set try next action
cs cs u search reslt
else return search reslt return conflict set
else search reslt search segment success
return search reslt
end loop actions
return cs soln reached compiled conflict set returned
end
end
set search graph level k given ss goals satisfied actions level k
assign next level goals k ss pg pe
let nextgoals regress ss goals actions assigned satisfy goals
nextgoals empty k initial state
return ss success
else memos level k pg nextgoals
return conflict set backtrack due nogood
else initiate search next lower pg level
let ss search segment holding nextgoals pointer ss actions assigned ss
add ss pe segs list
let search reslt assign goals nextgoals k ss pg pe
search reslt search segment success
return search reslt
else search reslt conflict set memoize minimal nogood return conflict set
add conflict set level k memos pg
reorder ss goals goals conflict set appear first ebl reordering
return search reslt
end
end

figure pegg pegg regression search graphplan style regression search
subgoals concurrently building search trace pe


fizimmerman kambhampati

note peggs combines state space csp aspects search
chooses expansion promising state previous search iteration
state space heuristics pegg pegg free traverse states search trace
order
selected state expanded graphplans csp style depth first fashion making full use
csp speedup techniques outlined
first aspect clearly distinguishes pegg egbg traversal state space pe
longer constrained bottom level level egbg management
memory associated search trace challenge pegg stray bottom traversal less daunting easier outline address first discuss
development adaptation heuristics search trace traversal
informed traversal search trace space
hsp hsp r state space planners bonet geffner introduced idea
reachability propositions sets propositions states assess difficulty degree relaxed version concept underlies powerful distance heuristics selecting promising state visit subsequent work demonstrated graph
function rich source heuristics nguyen kambhampati since
graph already available pegg adapt extend heuristics latter work serve
secondary heuristic role direct peggs traversal search trace states primary heuristic graph length iteratively deepened section step optimality
guarantee pegg planner depend admissibility secondary heuristic
important differences heuristic ranking states generated state space planner ordering search segments states peggs search trace example state space
planner chooses visit given state pegg planners often must consider whether
revisit state many consecutive search episodes ideally heuristic rank states search
trace reflect level level evolutions graph since transposition process
associates search segment higher level successive episode higher
graph level given state associated effective regression search space
changes complex function number actions appear graph number
dynamic mutexes relax goods memo caches moreover unlike state space
planners queue previously unvisited states states search trace include children
state generated last visited ideally value visiting state assessed independently value associated children since assessed turn referring back search trace depicted figure desire heuristic example discriminate ranked search segment ancestor top goal segment wxyz
would heuristic assessment segment wxyz discount value associated children already present trace ranked potential generating local search branches
next discuss adaptation known graph heuristics effective use
search trace



fiusing memory transform search graph

adoption distance state space heuristics
heuristic value state generated backward search goals expressed


f g w h
g distance goals e g terms steps
h distance estimate initial state e g steps
w optional weighting factor

value g state generated search e g states pe easily assessed
cumulative cost assigned actions point h values consider taken
distance heuristics adapted exploit graph nguyen kambhampati
one heuristic readily extractable graph notion
level set propositions
set level heuristic given set propositions denote lev index first level
leveled serial graph propositions appear non mutex one another singleton lev index first level singleton element
occurs level exists lev
admissible heuristic embodies lower bound number actions needed achieve
initial state captures negative interactions actions due graph binary mutexes nguyen kambhampati study set level heuristic
found moderately effective backward state space bss planner altalt tended many states f value directing search peggs search trace
somewhat effective still suffers lower level discrimination
heuristics examined especially engender graph relatively
levels nonetheless noted appendix b discussion memory efficiency improvements
use graph construction default heuristic value ordering due low
computational cost synergy building bi partite graph
inadmissible heuristics investigated nguyen kambhampati work
computing heuristic cost h p single proposition iteratively fixed point follows
proposition p assigned cost initial state otherwise action adds
p h p updated
h p min h p h prec
h prec sum h values preconditions action
given estimate propositions h value variety heuristic estimates state
studied including summing h values subgoal taking maximum subgoal hvalues study focus heuristic termed adjusted sum nguyen kambhampati combines set level heuristic measure sum h values states
goals though powerful heuristic tested computationally cheap graph planner found quite effective bss planners tested
adjusted sum heuristic define lev p first level p appears plan graph
lev first level plan graph propositions state appear nonmutexed one another adjusted sum heuristic may stated


fizimmerman kambhampati



hadjsum

h p lev max lev p


pi

pi



part heuristic summation estimate cost achieving assumption goals independent estimate cost incurred negative interactions
amongst actions must assigned achieve goals latter factor estimated taking
difference graph level propositions first become non mutex
level propositions first appear together graph
complex heuristics proposed include measure positive interactions subgoals state extent action establishes one relevant subgoal called relaxed plan distance heuristics focus positive interactions
several studies demonstrated power backward forward state space planners
nguyen kambhampati hoffman however reported former study primary advantage adding positive interactions adjusted sum heuristic produce shorter
make span plans expense modest increase time since peggs ida search
already ensures optimal make span little incentive incur expense relaxed plan
calculation restricted work simpler adjusted sum heuristic eqn
adjusted sum heuristic adapted search graph leveraging
information peggs search trace takes form heuristic updating dynamically improve h value estimate states pe lev term adjusted sum heuristic represents
first graph level subgoals state appear binary non mutex
however regression search graph level k fails given episode search
process essentially discovered n ary mutex condition subset goals
level k subset conflict set c gets memoized pegg figures
point lev value updated k indicating k conservative estimate
first level goals appear n ary non mutex state desirable property
ranking search trace states longer state resides search trace often h value gets
increased less appealing becomes candidate visit heuristic update
biases states visited failed extend solution use
augmented adjusted sum heuristic pegg runs work refer adjusted sum u
experimentally advantage given heuristic ordering pe states highly
domain dependent less sensitive particular domain example compared
simple bottom visitation strategy adjusted sum u heuristic improves pegg runtimes
order magnitude domains e g freecell satellite degrading
factor x x others e g zenotravel figure depicts performance adjusted sum u
heuristic relative bottom heuristic pegg several sets heuristics compared terms peggs average computation time percentage gp es
final search episode important measure exhaustive search graph
informed heuristic seed segment sooner event many
typical logistics domains one lies graph level closer
initial state less informed heuristic may cause pegg end conducting search final
episode gp e may many states pe would regenerated graphplan
final regression search finds solution direct measure power



fiusing memory transform search graph

bottom

adjusted sum u

depot
schedule

set

zenotravel
freecell
driverlog
satellite
logistics
blocks
tsp










graphplan search cost final episode

figure heuristic accuracy pegg final search episode relative gp e
search segment selection heuristic since performance vary considerably specific figure averages three representative examples domain
memory management arbitrary search trace traversal order

return memory management induced strategy skipping
search space consider pe time final search episode figure search segments visited order deepest pe level first encounter regenerating states already contained pe visitation order depicted numbered segments
figure could fairly informed heuristic th segment chooses visit plan
segment implies many states already resident pe regenerated includes
example yet unvisited descendents third segment visited unchecked process
significantly inflate search trace memory demands well overhead associated regenerating search segments addition heuristic information state lost state regenerated instead revisited extant pe search segment due adjustedsum u secondary heuristic pegg learns improved n ary mutex level search segments goals
updates f value accordingly search episode
address issue hashing every search segment generated associated pe state hash
table according canonically ordered goal set one hash table built pe level
prior initiating regression search subgoal set search segment sn pegg first checks
graph memo caches relevant memo found checks pe state hash table
see sns goals already embodied existing pe search segment relevant pe level


sets used blocksworld bw large b blocks logistics att log logistics gripper
gripper gripper x x depot depotprob driverlog dlog e zenotravel
ztravel b b freecell freecell satellite strips sat x x x



fizimmerman kambhampati

search segment se returned pe state check se made child sn already establishing link search proceed se goals
another search trace memory management issue associated fact pegg visits
subset pe states set call active pe tempting pursue minimal memory
footprint strategy retaining memory active search segments pe however unlike
graphplan initial state reached pegg cannot extract solution unwinding complete sequence action assignment calls since may begun regression search arbitrary state branch search trace tree pegg depends instead link child
search segment parent extract plan actions solution found must
retain minimum active search segments ancestor segments root node
beyond requirement retain search segments tied active pe many strategies
might used managing inactive portion study attempted reduce
pe memory requirements manner instead focusing might termed search space
field view beam search heuristic effectiveness depends informed
search trace states available rank reduced memory footprint peggs skeletal
search trace allows us adopt strategy retaining memory search segments generated
segments f values updated ranked giving beam search wide selection states contending active status given search episode
learning order states subgoals

pegg planners employ ebl search trace allows overlay yet
sophisticated version variable ordering top distance ordering heuristic guiding
principle variable ordering search fail early failure inevitable terms graphplan style search regressed state translates since state goals must assigned action best attempt satisfy difficult goals first adjusted sum heuristic described
applied single goal provides estimate difficulty structure
graph however ebl provides additional information difficulty goal achievement
directly search experience wit conflict set returned peggs assign goals routine search goal set explicitly identifies goals responsible search failure intuition behind ebl reordering technique
goals likely difficult assign search segment revisited next
search episode constitutes dynamic form variable ordering unlike distance
ordering search segments goals may reordered successive search episodes
recent search experience
figure compares influence adjusted sum variable ordering ebl reordering
methods memory demand manner similar figure impact ebl reordering egbgs performance reported pegg tightly integrates csp efficiency methods independent influence cannot readily assessed isolate impact
ebl reordering ebl activating ebl produced con


interests simplicity figure outline memory management process
given success memory efficiency methods within egbg versions pegg implement
default graph analogous figure pegg planner would differ terms actual memory reduction values confident overall benefits methods would persist would relative benefit relationship
methods






variable ordering adjsum eblreordering
variable ordering
ebl reordering


reduction pe search trace memory requirement

memory transform search graph




reduction graph memo cache memory requirements

figure memory demand impact along two dimensions adjusted sum
variable ordering ebl reordering techniques applied
independently together
flict sets reordering memoization average reduction search trace memory
sample seen ebl reordering alone compares
favorably average reduction distance ordering especially since unlike
adjusted sum ordering ebl reordering takes effect nd search episode plot
reveals two modes ordering quite complimentary
across variety domains found following effective
combining distance variable ordering ebl reordering newly created search
segments goals ordered according distance heuristic visit search
segment subset goals appear conflict set reordered appear first goals
conflict set ordered distance heuristic appended non conflict goals
set distance order
indicated figure hybrid form variable ordering boosts average memory reduction almost significantly reduces wide fluctuation performance
method isolation emphasize search experience informed goal ordering
available search maintains memory states visited therefore
portable graphplan planner know
trading guaranteed step optimality speed reach
pegg beam search

many difficult benchmark graphplans ida style search
search episodes reaching episode solution extracted cumulative search time tied episodes large portion total search time indicated
table pegg exhausts search time limits well reaching episode solution
extracted strategy exhaustively searching graph episode
solution bearing level gives step optimal guarantee graphplans solutions exact


fizimmerman kambhampati

high cost ensure one aspect plan quality explore pegg nonexhaustive search version pegg extent search episodes truncated
producing plans virtually makespan graphplans solution
pegg shortcuts time spent search intermediate episodes secondary
heuristic direct order pe states visited prune search space visited
episode beam search seeks visit promising pe states measured
f values user specified limit addition beam search important dual benefit
pegg reduces memory demands search trace depending
even graph pegg figure loop statement
point beam search f value threshold optionally applied pe states candidates visitation first segment exceeding threshold reached sorted queue
search episode ends
devise effective threshold test must reconcile competing goals minimizing search nonsolution bearing episodes maximizing likelihood pe retains visits preferably
early possible search segment thats extendable solution graph reaches first
level extant solution narrower window states visited difficult
heuristic ranks states ensure includes plan segment e one part stepoptimal plan pegg return step optimal plan long search strategy leads visit
plan segment including top root segment pe belonging plan latent pe search first solution bearing graph heuristics job selecting window
search segments visit made less daunting many many step optimal
plans latent solution bearing level
next describe effective graph metric augments state space heuristic
choosing set pe states visit search episode
mining graph filter beam
beyond heuristic updating introduced section distance heuristics virtually
insensitive graph evolution search segment transposed successive levels since
search trace contains children states generated regression search state episode n heuristic preference include states trace visit episode n
reflect chance directly generate promising search branches child states
search episode n competitors ideally heuristics rank reflect
sense value visiting state beyond importance children
consider sensitivity adjusted sum heuristic distance heuristics
possible differences implicit regression search space set propositions graph level k versus level k given propositions present binary non mutex
level k cost summation factor equation could conceivably change
evaluated level k would require two conditions action must establish one
propositions first time level k actions precondition costs must sum less
precondition costs establisher proposition practice happens infrequently since later action appears graph construction process higher cost tends
consequently h values states distance heuristics remain remarkably constant graph levels beyond propositions appear binary non

fiusing memory transform search graph

mutex desire means compensating static h value state transposed graph level promising branches regression search open
likelihood state visited episode n graph level k give rise child states
visited episode n level k rooted graph dynamics summarized observations
appendix three graph memo cache properties determine whether regression search subgoal set evolve successive episodes
actions level k establish subgoal
dynamic mutexes level k actions establishing subgoals relax
level k
good memos encountered regression search state episode n
encountered level k converse
set measures potential search branches visiting state pe
refer flux intuition higher flux likely search
given state differ seen previous search episode captured pe none
three factors applies state consideration point visiting
search relative previous episode
first factor readily assessed state thanks part bi partite graph structure second flux factor unfortunately expensive assess direct measure requires storing
pairs attempted action assignments goals inconsistent episode n retesting graph level however graph mechanics relaxation
dynamic mutex two actions level k requires relaxation dynamic mutex condition
pair preconditions level k one precondition action relaxation turn due one establishing actions preconditions level k
recursively relaxations existing actions establishing preconditions number
actions establishing subgoals state pe factor provide measure
flux predictor flux due factor parent higher ancestors
thus turns simply tracking number actions state subgoal current level propagating appropriately weighted measure parent compile useful
estimate flux factors
third flux factor unwieldy costly estimate exact measure requires
storing child states generated regression search level k caused backtracking due
cached memos retesting see memos present level k ignoring
factor sum two flux measures depend actions derive filtering metric
used assist largely static adjusted sum distance heuristic culling
beam resulting inexact metric sensitive evolution search potential state transposed higher graph levels



part explains observation nguyen kambhampati altalt state space planner performance
generally degrades little graph used extract heuristic values built level goals appear non mutex rather extending level

note long ebl ddb sufficient test whether memo exists child state
good goals contribute conflict set used direct search within whenever backtracking occurs



fizimmerman kambhampati



flux

newacts p


pi



wcf

childflux

si c



pi proposition state
newacts pi number actions establish proposition pi
associated graph level
normalization factor number propositions
sc set child states currently represented search trace
childflux si sum two flux terms eqn applied child state si
wcf weights contribution flux child states parent state

number actions establishing subgoals state normalized relative number subgoals state
report elsewhere zimmerman use flux directly augment secondary
heuristic depending domain weighting flux contribution adjusted sum heuristic speedups order magnitude observed however impact highly domain
dependent since primarily concerned performance general purpose planner
study consider use beam filter
beam search flux measure strongly impact every search episode influences
states actually included active pe used mode search segments assessed
flux specified threshold skipped even f value places active pe
flux proves broadly effective across domains used mode mentioned
section use flux cutoff search episode average flux search segments pe segment value visited regardless heuristic rank
setting impact speedup pegg column table ranges nil factor
x peggs performance without flux filter higher settings dramatically speed
solution search often expense greater solution makespan
peggs ability step optimal plans
variety parameters associated beam search described admits considerable flexibility biasing pegg towards producing plans different quality shorter makespan plans
favored extensive search pe states episode heuristically truncated
search tends generate non optimal plans quickly often containing redundant unnecessary
actions settings used study clearly bias pegg solutions towards step optimality
step optimal plan produced enhanced graphplan matched pegg four
reported table indicated annotated steps actions numbers given parenthesis next successful gp e pegg runs pegg solutions longer makespan
step optimal boldface step action values four pegg returns solutions


example compared simple bottom visitation strategy flux augmented adjusted sum heuristic improves
pegg runtimes x domains e g freecell satellite degrading much x x
others e g zenotravel



one guaranteed step optimal planners gp e egbg pegg finds solution steps
actions reported one since makespan



fiusing memory transform search graph



n best first
pegg
n state space search adjusted sum u heuristic beam search
best search segments

satplan
optimal

bw large









bw large b







bw large c







bw large







table quality comparison terms plan steps pegg n best beam search
forward state space planner bonet et al
within four steps optimum spite highly pruned search proved fairly robust
property peggs beam search settings across tested date
pegg adjusted sum u secondary heuristic often finds plans fewer actions
gp e parallel domains graphplan hybrid system impressive serial domains
blocksworld exactly graphplans forte
tactic trading optimal plan length favor reduced search effort well known
community comparison peggs beam search biased towards producing
high quality plan possibly expense runtime example focusing
action selection mechanism bonet et al briefly describe work n best
first bonet loerincs geffner employ distance heuristic
conduct beam search forward state space report small set case
best states retained queue considered search
table reproduces alongside peggs performance beam
search approximate n best pegg run states visited
intermediate search episode study compared n best first satplan
produces optimal length plan make point could produce plans reasonably close optimal much less search n best first code available run
test platform peggs runtime reported focusing plan makespan clear even
serial domain parallel planner pegg produces much shorter plan n best first
state space fact finds optimum length plan generated satplan cases
recently lpg gerevini serina another planner whose search tightly integrated
graph awarded top honors aips competition due
ability quickly produce high quality plans across variety domains currently interest
figure scatter plot solution quality terms steps lpg pegg compared
optimal three domains aips competition chose
particular optimal solution known interested comparing
quality baseline lpgs particularly apt case planner nonexhaustively searches graph level extending although search process
differs markedly peggs lpg biased produce plans higher quality generally
expense speed report competition quality mode terms
number actions solutions neither planner consistently dominates
pegg clearly excels step optimality maximum deviation optimum four steps


fizimmerman kambhampati



lpg dlog



lpg depot

steps optimal



lpg ztravel



pegg dlog



pegg depot



pegg ztravel

















number









figure makespan comparison pegg lpg departure step optimal
plan length lpg data taken aips competition
plot points solutions lie right optimal makespan axis possible
sets actions within lpgs solutions could conducted parallel quality
mode heuristic insensitive
noted lpg produced solutions difficult domains
pegg currently solve within reasonable time limit investigating characteristics
make difficult pegg
pegg compared heuristic state space search
attempted run pegg head head speed recent ipc planners part
due platform difficulties pegg written lisp competition planners generally
coded c published execution competition machines partly
due focus near optimal makespan parallel plans rather speed given peggs close
coupling graph relevant comparisons parallel planners
employ graph form comparisons would isolate search component runtime graph construction since variety routines produce essentially graph widely different expenditures computational time memory reported runtimes lpg planner aips competition generally much
smaller peggs difficult isolate impact graph construction platform related
effects mention disparity makespan plans produced
table compares pegg lisp version fast distance heuristic state space planner table altalt srivastava et al pegg depends
graph derive powerful heuristics uses direct regression search
goals facilitates planner performance comparison differences search without confusing graph construction time issues last column table reports altalt performance
runtime makespan two effective heuristics developed planner nguyen
kambhampati first adjusted sum heuristic described section



fiusing memory transform search graph


bw large b
bw large c
bw large
rocket ext
att log
att log b
gripper
gripper
gripper
tower
tower
puzzle
puzzle
tsp
aips
grid
gripper x
gripper x
log
mprime
aips
blocks
blocks
blocks
logistics
logistics
freecell
schedule
aips
depot
depot
driverlog e
driverlog
roverprob
roverprob
roverprob
sat x
sat x
ztravel
ztravel

pegg
heuristic adjusted sum u
cpu sec steps acts





























pegg







pegg








pegg

















alt alt lisp version
cpu sec acts
heuristics
combo
adjusum




















alt alt










alt alt








alt alt












table pegg state space planner variations adjusted sum heuristic
pegg bounded pe search best search segments visited search episode ordered
adjusted sum u state space heuristic
altalt lisp version state space planner two effective graph distance
heuristics adjusum combo combo reported since
adjusum produces plans competitive pegg terms makespan



fizimmerman kambhampati

surprisingly majority pegg returns parallel generally step optimal plan faster
altalt returns serial plan altalt cannot construct plan parallel actions however recent
work highly modified version altalt fact construct plans nigenda kambhampati pegg plans seen comparable length terms number actions best altalt plans
discussion

distinguishing feature egbg pegg planners relative planners exploit
graph aggressive use available memory learn online episodic search
experience expedite search subsequent episodes although employ search trace
structure log experience egbg pegg systems differ content granularity search experience track aggressiveness use memory differ
confront common faced learning systems utility learned information
versus cost storing accessing needed
first efforts focused primarily search trace learn mutex related redundancies
episodic search process although resulting planners egbg egbg avoid virtually redundant mutex checking search experience embodied pes empirically
limited class winning strategy utility tracking
mutex checking experience search function number times information
subsequently used specifically
eps p

u mt p

pe

visit

e

pe

add

e

e
eps p
e

umt utility tracking mutex checking experience
p
eps p number search episodes p
pevisit e number pe search segments visited search episode e
peadd e number search segments added pe episode e
thus payback egbgs incurred overhead tracing consistency checking experience
search depends number times sets revisited relative total number subgoal
sets generated added pe run characteristic explains less
x speedups observed egbg many table handicap single search episode ineffectual final search episode search generates large number states relative previous episodes seed segment
top levels pe due need bottom visitation search segments egbgs
search trace
pe thought snapshot regression search reachable rs reachable states
search episode regression search process generates state level k
graph state reachable search higher levels graph future search
episodes essentially search segments pe represent rs reachable states


fispeedup wrt enhanced graphplan

memory transform search graph

pegg log



pegg log
pegg ztravel
pegg ztravel





















search episodes

figure speedup vs number search episodes logistics zenotravel domains
candidate set partial plans segments state current tail state plan table indicate utility learning states rs reachable given search
episode generally outweighs utility learning details episodes consistency checking
require much less memory freed need regenerate rs reachable states ida fashion search episode pegg visit states heuristically preferred order
tables shed light several classes problematic search trace
guided search graph
domains high branching factors operator descriptions thwart ddb ebl
e g larger schedule satellite zenotravel domain
significant fraction runtime consumed graph construction
e g grid domain dlog e freecell
one two search episodes grid schedule
first class graphplan style csp assignment search prone bogging
certain pe states selected visitation second class search time
reduction dominated large graph construction time shared planner
builds complete graph third class give pegg sufficient
opportunity exploit pe since built first episode first episode pe typically
small benefit subsequent episodes aspect peggs behavior illustrated
figure speedup factors pegg pegg beam search plotted
series ordered according number search episodes graphplan would conduct prior finding solution data gathered running gp e pegg pegg
planners two different domains logistics domain aips competition
zenotravel domain aips competition averaging speedups observed
number observed search episodes downturn pegg ztravel
curve seven episodes surprising given one
many factors beyond number search episodes impact solution time noting speed

fizimmerman kambhampati

ups plotted logarithmic scale power search trace given multiple search episode evident pegg beam search handily outperforms pegg three
search episodes largely shortcuts exhaustive search intermediate episodes
several avenues addressing listed limitations pegg explored anticipate investigating example unlike n best first state space planner reported
table pegg enforces user specified limit state f values selecting pe search
segments visit search segment chosen visitation graphplan style regression search
state goals continues solution found sub branches fail greedy
would apply heuristic bound regression search could
backtrack whenever state generated exceeds f value threshold applied search segments
visited translates greedy best first search gbfs employed
hsp r bonet geffner state space search form hill climbing search graph
experimentally pegg adapted enforce pe state f value limit
regression search improvements unpredictable best speedups factor
observed cases logistics many cases runtimes increased search failed
entirely within time limit addition quality make span returned solutions suffered
across broad range two factors may explain peggs regression search greatly expedited ddb ebl regressed conflict set rely
undefined regression search space state fully explored fvalue limit enforced without conducting search informed basis returning anything full set subgoals state essentially forces search towards chronological backtracking assessing f value newly generated state compare fvalue bound states generated previous episodes problematic
heuristic values pe states determine f value bound increased peggs use
search experience improve h value estimates section
degradation solution quality shift pegg closer greedy search may indicator peggs ability return step optimal plans evidenced table rooted
interleaving best state selection pe graphplan style depth first search
states subgoals
related work

focus related alternative strategies employing search heuristics generating parallel plans making use memory expedite search related work pertaining
search techniques efficiencies data structures enable egbg pegg successfully
employ search trace cited arose considered
noted section shortcoming ida search graphplan inadequate use
available memory information carried one iteration next upper
bound f value exploitation search trace directly addresses shortcoming serving
memory states visited search space previous episode order reduce redun

support methodologies include memory efficient bi partite graph explanation learning dependency directed backtracking context graph search variable value ordering strategies evolution
extraction distance heuristics graph



fiusing memory transform search graph

dant regeneration respect peggs search closely related methods mrec sen
anup bagchi sma russell lie middle ground
memory intensive ida scant use memory central concern
prescribed amount available memory efficiently possible egbg pegg
retain much search experience memory permits avoid repeating regenerating
nodes depend heuristic order nodes memory visitation unlike search trace
though three backup deleted nodes f value parent node ensures deleted branch expanded promising node remains open list implemented extended memory management pegg
though would straight forward primarily least beam search pegg
seldom confronted pe related memory limitations
egbg pegg first planners directly interleave csp state space views search related approaches synthesize different views
blackbox system kautz selman constructs graph instead exploiting
csp nature converted sat encoding extension k step solution
sought gp csp kambhampati similarly alternates extending
graph converting transforms graph csp format seeks satisfy constraint
set search phase
beam search concept employed context propositional satisfiability gsat selman levesque mitchell option blackbox planner kautz selman
systems greedy local search conducted assessing episode n best flips
variable values randomly generated truth assignment best flips lead
greatest number satisfied clauses n flips fail solution gsat restarts
random variable assignment tries n best flips several important differences
relative peggs visitation n best search trace states search trace captures state aspect engendered graphplans regression search goals pegg exploits
reachability information implicit graph conducting search purely propositional level sat solvers leverage global view constraints cannot exploit
state space information whereas gsat blackbox improve performance
experience one n best search episode next pegg learns variety modes improving heuristic estimate states visited reordering state goals prior search experience memorizing general goods use ebl
pegg lpg system gerevini serina heavily exploits structure graph leverages variety heuristics expedite search generates parallel plans however
lpg conducts greedy local search space composed subgraphs given length
graph pegg combines state space view search experience graphplans csp style
search graph lpg systematically search graph heuristically
moving extend guarantee step optimality forfeited pegg operate
step optimal mode modes trade optimality speed varying degrees
currently investigating interesting parallel lpgs ability simultaneously consider
candidate partial plans different lengths principle nothing prevents pegg
simultaneously considering given pe search segment sn terms heuristic rankings
transposed onto levels graph tantamount simultaneously consider

fizimmerman kambhampati

ing arbitrary number candidate partial plans different implied lengths extend first
partial plan sn tail state search trace proves useful
regard state contains transposed desired number levels subject
ability extend graph needed heuristics evaluated level referring back figure first search episode pictured top yj state pe could
expanded multiple distinct states transposing graph level levels higher
heuristically evaluating level graph level indexed instances yj
simultaneously compared ideally wed move directly visiting yj graph level
since point becomes plan segment bottom graph figure secondary heuristic discriminate solution potential state sequential levels
transposed effective means shortcutting graphplans level bylevel search process flux adjunct likely one key boosting sensitivity distancebased heuristic regard
generating assessing arbitrarily large number graph level transposed instances pe
states would prohibitive terms memory requirements store multiple versions
pe however simply store level specific heuristic information search segments
single pe values indexed associated graph levels challenging issues include
things range plan lengths considered one time potential plans
steps consisting entirely persists actions
havent examined pegg context real time use search
trace reflects flavor real time search methods lrta korf
variants b lrta bonet loerincs geffner variant applies distance
heuristic oriented real time search interleave search execution
performing action limited local search lrta employs search heuristic
finding less optimal solution improving heuristic estimate series iterations
associates h value every state estimate goal distance state similar h values
first updates h value current state uses h values successors move successor believed minimum cost path current state goal
unlike traditional search methods act real time amortize learning consecutive episodes solves task repeatedly allows suboptimal plan fast improve plan converges minimum cost plan
lrta pegg search process iteratively improves h value estimates states
generated determines optimal make span plan unlike lrta pegg doesnt actually
sub optimal plan first instead converges minimum cost plan exhaustively extending candidate partial plans monotonically increasing length pegg extending
promising candidates according secondary heuristic pegg beam search realtime version pegg closely related lrta might method described
search segments simultaneously transposed onto multiple graph levels
mode pegg would biased search quickly plan length search anytime
fashion progressively shorter length graphs lower cost plans
methodology direct relevance work reported elsewhere multi pegg
zimmerman kambhampati zimmerman version pegg operates anytime fashion seeking optimize multiple plan quality criteria currently multi pegg first



fiusing memory transform search graph

turns optimal make span plan exploits search trace novel way efficiently
stream plans monotonically improve terms quality metrics discussed
important step away multi peggs bias towards make span plan quality metric would
modification co mingling versions state transposed onto multiple
graph levels would enable planner concurrently consider visitation candidate search segments might seed segments latent plans lengths
conclusions

investigated presented family methods make efficient use available memory
learn different aspects graphplans iterative search episodes order expedite search
subsequent episodes motivation design performance four different planners build
exploit search trace described methods differ significantly information
content trace manner leverage however cases high level
impact transform ida nature graphplans search capturing aspect search
experience first episode guide search subsequent episodes dynamically updating along way
egbg planners employ aggressive mode tracing search experience pegg
planners track use action assignment consistency checking performed search
subgoal set state minimize effort expended state next visited egbg found memory intensive motivating incorporation variety techniques
csp fields apart well known speedup benefits shown
dramatic impact search trace graph memory demands resulting planner
egbg frequently two orders magnitude faster standard graphplan egbg
handle generally fastest guaranteed step optimal approaches
investigated comparisons gp e version graphplan enhanced space saving
speedup techniques egbg solves average times faster
pegg planners adopt skeletal search trace design conducive informed traversal search space ultimately proves powerful exploiting
episodic search experience adapt distance state space heuristics support informed traversal states implicit search trace describe metric call flux effectively
focuses search states worth visiting flux measure sensitive potential search
trace state seed search branches transposed higher graph levels
describe techniques leverage search experience captured search trace
demonstrate effectiveness
pegg planner egbg produces guaranteed optimal parallel plans similarly
averages x speedup gp e greatly reduced memory demands allow pegg handles
one egbg exceeds available memory compelling evidence speedup potential search trace guided planner provided pegg beam
search since longer exhaustively searches graph episode pegg sacrifices
guarantee returning optimal make span plan nonetheless even beam search limited
best pe states episode pegg returns step optimal plan almost
test bed comes within steps optimal others speedups



fizimmerman kambhampati

ranging almost two orders magnitude gp e quite competitively modern state
space planner finds serial plans
code pegg planners including gp e instructions running
modes available download http rakaposhi eas asu edu pegg html
acknowledgements

improved many discussions binh minh xuanlong nguyen romeo
sanchez nigenda william cushing thanks david smith anonymous reviewers
whose copious suggestions greatly improved presentation supported
part nsf grants iri iis darpa aasert grant daah nasa grants nag ncc

appendix egbg planner

insight behind egbgs use search trace characterization graphplans
search given beginning section entailed observations
observation intra level csp style search process conducted graphplan set propositions subgoals graph level k episode n identical search process
level k episode n
mutexes pairs actions establishers propositions level k remain
mutex level k concerns dynamic mutexes static mutexes persist definition
actions establishing proposition level k present level k
observation trace graphplans search episode n set goals g
graph level identical episode n search level
two conditions observation hold every subgoal set state generated graphplan
episode n regression search g
every subgoal set graph level j search episode n matching
level j memo exists equivalent memo level j generated episode n
conversely every subgoal set level j search episode n matching level j memo
existed time generated matching memo level j time generated episode n

suppose search trace states including good states generated graphplans regression search goals graph level episode n search
failed extract solution length graph e reach initial state necessary condition extract solution length graph one conditions
observations fails hold states episode n search trace
observations mind exploit search trace episode
sound complete manner focusing search effort three situations could lead
solution state variables newly extended value ranges e search segment goals
least one establishing action newly associated graph level points previous search episode backtracked due violation dynamic constraint e two actions


fiusing memory transform search graph

w

nop
ok ok






nop
ok sm

nop
ok sm



nop
ok ok

h









nop
ok sm ok
nop

j

dm sm

nop nop
dm sm dm sm

nop
dm sm

figure bit vector representation search trace wyhij state figure
semantics ok assigned action conflicts sm action static mutex previous assign
dm action dynamic mutex previous assign
ng conflict action good state lower graph level

dynamic mutex states matched cached memo episode n assignment mutex checking operations involved satisfying set subgoals static across search
episodes
experimented several search trace designs capturing key decision points design
adopted egbg employs ordered sequence bit vectors vector contains
graphplans csp style action assignment process related given subgoal search segment
efficient action assignment replay possible trace uses vectors two bit tags represent
four possible assignment outcomes dynamic mutex static mutex conflict complete consistent set assignments rejected next level due memoized good figure illustrates sequence eight bit vectors used capture search experience search segment state goals wyhij figure alpha propositional goals variables appear left sets bit vectors depicted segmented bars
encode outcome possible action assignment values possible establishing
action goal appears bit vector tag
numbered edges reflect order trace vectors initially created first
goal action tried note whenever candidate action goal conflict free respect
previously assigned actions indicated ok figure action checking goal suspended process jumps next goal bit vector initialized goals possible
establishers edge numbering reflects order vectors popped
search segment trace list segment revisited next episode scheme work
bit vectors must pushed onto search segment trace list actions goal tried
reverse numbered edge order long edges skip one goals indicate
goals already established previously assigned actions
long order actions appearing establishers list graph proposition remains constant bit vectors used replay search next episode next
higher graph level graph building routine egbg enforces constraint



fizimmerman kambhampati

egbg

high level egbg given figure graphplan search
graph occurs extended level goals first appear
binary mutex conditions call st level goals first search episode conducted
graphplan fashion except assign goals routines figure create search segments
hold states trace information generated regression search process necessary
trace information search segment captured trace vectors described segments stored pe structure indexed according level generated
current highest graph level corresponds contains goals
subsequent first episode egbg plan enters outer loop employs pe conduct
successive episodes referred search trace guided search strategy alternates
selection visitation promising state trace previous experience select searchseg pe routine focused csp type search states subgoals replay trace goals assign goals routines figures
episode inner loop visits pe search segments level level bottom fashion
reasons discussed section extend plangraph routine called state
visited corresponds level beyond current graph length
replay trace goals routine counterpart graphplans assign goals routine except
avoids latters full blown mutex checking stepping trace vectors captured
previous search experience given state unlike assign goals branch child
states already contained pe conditional checking trace vectors establishing
actions initiates search calling assign goals two conditions dynamic mutexes
previous episodes longer hold establishing actions appear subgoal
tried establishers replayed dynamic mutex longer holds
establishing action considered trace vector modified accordingly egbg resumes graphplans csp style search adding trace vectors search segment process



fiusing memory transform search graph

egbg plan ops init goals ops init goals
build plangraph pg level n goals first occur non mutex state

let pg st level goals ops init goals
pg reached level goals present non mutex state return fail
let n number levels pg
let ss search segment fields
goalsgoals parentroot pe level parent actions trace
let pe pilot explanation structure fields hold search segments plangraph level
pe ss top level pe
conduct graphplan style backward search n length plangraph store trace pe

let search reslt assign goals goals n ss pg pe
search reslt search segment success
plan extract plan actions ancestors linked search reslt
return plan
else n length solution possible use pe search longer length solution
loop forever
n n
loop pe lev ranging number deepest level pe top level
let k graph level associated pe level pe lev
n pe lev essentially translates pe one graph level
pe lev pg extend plangraph pg must extend plangraph point
loop search segments pe pe lev
ss select searchseg pe pe lev
ssassigns ss trace get ordered goal goal trace vectors search segment
ss trace clear search segment trace vectors field
ss goals memos k pg check nogoods level k
goals match nogood level loop next search segment
else use ss trace avoid redundant search effort ss goals
search reslt replay trace goals ss goals k ssassigns ss pg pe
search reslt search segment
plan extract plan actions ancestors linked search reslt
return plan
else add ss goals memos k pg memoize nogood
end loop search segments
end loop pe levels
end loop pg level
end

figure egbg planner top level



fizimmerman kambhampati

conduct graphplan style search subgoal set graph level k
arguments g goals still assigned actions already assigned k pg level
ss search segment pg graph pe pilot explanation search trace
assign goals g k ss pg pe
g empty k initial state return ss success
else goals left satisfy
let g assigns trace vector hold ordered action assignment tags
let g goal selected g
let ag actions pg level k support g ordered value ordering heuristic
loop act ag
let search reslt
action dynamic mutex act append dm tag g assigns
else action static mutex act append sm tag g assigns
else act conflict actions already
g empty
done g goals setup search next lower level
search reslt assign next level goals u act k ss pg pe
search reslt nogood append ng tag g assigns
else append ok tag g assigns search occurred lower level
else search continues level next goal
append ok tag g assigns
search reslt assign goals g g u act k ss pg pe
end
search reslt search segment return search reslt success
else loop try another action

end
end loop actions
push g assigns trace field ss
return nil solution found
end
end

add trace data search segment

setup search graph level k given actions satisfy goals ss level k
assign next level goals k ss pg pe
let nextgoals regress ss goals assigned actions
nextgoals memos pg level k return nogood backtrack nogood goals
else initiate search next lower pg level
let ss search segment fields
goalsnextgoals parentss parent actionsa trace
add ss pe level maximum pg level k
let search reslt assign goals nextgoals k ss pg pe
search reslt nil search level k failed
add nextgoals memos level k pg memoize nogood
return search reslt
end
end
assign actions g ag g g assigns k ss pg pe
routine essentially assign goals except attempts satisfy goal g actions
actions e first appearing recent plangraph extension

figure egbgs non guided regression search



fiusing memory transform search graph

regression search search trace pe replay
arguments g goals still assigned actions already assigned k pg level
ss search segment pg graph pe pilot explanation search trace
replay trace goals g k ss pg pe
g empty ss goals branch successfully assigned last episode
return continue level k replay ignoring search replay next lower level
else goals left satisfy
let g select goal g
let g assigns pop front trace vector ss trace
let ag set actions level k pg support g
replay assignments g previous episode rechecking may changed

loop tag g assigns
let search reslt let act pop action ag
tag ok act conflict actions last episode go next goal
search reslt replay trace goals g g u act k ssassigns ss pg pe
else tag ng loop last action assign level act mutex last
episode next level regressed goals reside child search segment already visited

else tag sm loop act static mutex action last episode
else tag dm act dynamic mutex action last episode retest
dynamic mutex persists loop
else change tag ok g assigns vector act longer mutex actions
g g empty resume backward search level
search reslt assign goals g g u act k ss pg pe
else goals left satisfy ss setup search lower level
search reslt assign next level goals u act k ss pg pe
search reslt nogood change g assigns vector tag ng
end
search reslt search segment return search reslt success
else loop check next action
end loop establishment possibilities prior episode tried check actions
ag still contains actions actions establishing g level attempt assign
search reslt assign actions g ag g g assigns k ss pg pe
search reslt search segment return search reslt success
else push g assigns ss trace
return nil solution found search stemming ss goals
end
end

figure egbgs search trace guided



fizimmerman kambhampati

appendix b exploiting csp speedup methods reduce memory demands

background implementation details provided six techniques
csp fields proved key controlling memory demands search trace
planners variable ordering value ordering explanation learning ebl dependency
directed backtracking ddb domain preprocessing invariant analysis replacing redundant multi level graph bi partite version
domain preprocessing invariant analysis
speedups attainable preprocessing domain specifications well
documented fox long gerevini schubert static analysis prior
process used infer certain invariant conditions implicit domain theory
specification domain preprocessing egbg pegg fairly basic focusing identification extraction invariants action descriptions typing constructs subsequent rewrite
domain form efficiently handled graph build routines implementation discriminates static permanent mutex relations dynamic mutex relations
mutex condition may eventually relax actions proposition pairs information used expedite graph construction egbgs replay action assignments search segment visited
domain preprocessing significantly reduce memory requirements extent identifies
propositions need explicitly represented level graph examples
terms extracted action preconditions hence get explicitly represented
graph levels include smaller x term move action towers hanoi domain typing terms auto x place logistics domains benefit
compounded egbg pegg since propositions removed action preconditions directly reduce size subgoal sets generated regression search episodes
hence size search trace
bi partite graph
original graphplan maintains level level action proposition mutex information
distinct structures level thereby duplicating often many times information contained previous levels multi level graph efficiently represented indexed
two part structure finite differencing techniques employed focus aspects
graph structure possibly change extension leads rapid construction
concise graph fox long smith weld
egbg pegg bi partite graph offers benefit beyond reduced memory demands faster graph construction time pe transposition process described section reduced simply incrementing search segments graph level index straightforward
multi level graph built graphplan since proposition action referenced
search segments unique data structure
explanation learning dependency directed backtracking
application explanation learning ebl dependency directed backtracking ddb
investigated preliminary way zimmerman kambhampati primary
interest speedup benefits techniques shown modest speedups


fiusing memory transform search graph

several small complexity integrating maintenance pe replay
vectors limited size could handled since succeeded implementing
robust version methods reported reflect
ebl ddb explaining failures leaf nodes search tree propagating explanations upwards search tree kambhampati ddb involves propagation failure explanations support intelligent backtracking ebl involves
storing interior node failure explanations pruning future search nodes implements complimentary techniques graphplan reported kambhampati
speedups ranged x blocksworld x ferry domain
refer study full description ebl ddb graphplan context note aspects particularly relevant egbg pegg
conflict directed back jumping prosser failure explanations compactly represented terms conflict sets identify specific action goal assignments gave rise
backtracking liberates search chronological backtracking allowing jump back
recent variable taking part conflict set attempts satisfy set subgoals
state fail conflict set regressed back represents useful minimal good memoization see pegg figures depiction process conflict set
memo usually shorter hence general one generated stored standard
graphplan additionally ebl augmented graphplan generally requires less memory memo
caches
less obvious speedup benefit perhaps role ebl ddb often play dramatically reducing memory footprint pilot explanation together ebl ddb shortcut
search process steering away areas search space provably devoid solutions
search trace memory demands decrease proportionally
egbg pegg outfitted ebl ddb non pe directed graphplan style search egbg however use ebl ddb replay action assignment pe search segment due complexity retract parts assignment
vectors whenever conflict set episode entails replay order
value variable ordering
value variable ordering well known speedup methods csp solvers context
graphplans regression search given graph level k variables regressed subgoals values possible actions give propositions level k graph
original blum furst argue variable value ordering heuristics
particularly useful improving graphplan mainly exhaustive search required levels
solution bearing level anyway nonetheless impact dynamic variable ordering
dvo graphplan performance examined kambhampati modest speedups
achieved standard csp technique selecting assignment subgoal variable
least number remaining establishers values impressive reported
later study nguyen kambhampati distance heuristics rooted
graph exploited order subgoals goal establishers configuration graphplan
exhibits speedups ranging x depending particular heuristic



fizimmerman kambhampati

study fix variable ordering according adjusted sum heuristic value ordering
according set level heuristic found combination reasonably robust across
range test bed heuristics described section used
direct traversal pe states discussed section describes highly dependent
performance distance variable value ordering search trace planners
manner egbg pegg builds maintains graph search trace
structures actually reduces cost variable value ordering default order graphplan considers establishers values satisfying proposition variable given level set
order appear graph structure graph construction egbg
pegg set order correspond desired value ordering heuristic ordering computed part pe constructed search record
heuristically best ordering regression states goals variable ordering done
given state contrasts versions graphplan outfitted
variable value ordering kambhampati ordering reassessed time state
regenerated successive search episodes

references
blum furst l fast graph analysis artificial
intelligence
bonet b loerincs g geffner h robust fast action selection mechanism
proceedings aaai
bonet b geffner h heuristic search proceedings
ecp
b kambhampati solving graph compiling csp
proceedings aips
fox long automatic inference state invariants tim journal
artificial intelligence
frost dechter r search best constraint satisfaction search proceedings
aaai
gerevini schubert l accelerating partial order planners techniques
effective search control pruning journal artificial intelligence
gerevini serina lpg planner local search graphs
action costs proceedings aips
haslum p geffner h admissible heuristics optimal proceedings
aips
hoffman j heuristic domain independent use enforced hillclimbing technical report albert ludwigs university
kambhampati relations intelligent backtracking failure driven
explanation learning constraint satisfaction artificial intelligence

kambhampati graph dynamic csp exploiting ebl ddb
csp search techniques graphplan journal artificial intelligence
kambhampati sanchez r distance goal ordering heuristics graphplan
proceedings aips


fiusing memory transform search graph

kambhampati parker e lambrecht e understanding extending graphplan
proceedings ecp
kautz h selman b pushing envelope
stochastic search proceedings aaai

prepositional logic

kautz h selman b unifying sat graph proceedings
ijcai vol
koehler nebel b hoffman j dimopoulos extending graphs
adl subset proceedings ecp
korf r depth first iterative deepening optimal admissible tree search artificial
intelligence
korf r real time heuristic search artificial intelligence
long fox efficient implementation plan graph stan journal
artificial intelligence
mittal falkenhainer b dynamic constraint satisfaction proceedings
aaai
mcdermott regression graphs control search artificial
intelligence
nigenda r kambhampati altaltp online parallelization plans heuristic
state search journal artificial intelligence
nguyen x kambhampati extracting effective admissible state space heuristics
graph proceedings aaai
prosser p domain filtering degrade intelligent backtracking search proceedings
ijcai
russell j efficient memory bounded search methods proceedings ecai
sen k bagchi fast recursive formulations best first search allow
controlled use memory proceedings ijcai
selman b levesque h mitchell method solving hard satisfiability
proceedings aaai
smith weld incremental graphplan technical report univ wash
srivastava b nguyen x kambhampati nambiar u nie z nigenda r
zimmerman altalt combining graphplan heuristic state search ai
magazine american association artificial intelligence fall
zimmerman exploiting memory search high quality plans
graph phd dissertation arizona state university
zimmerman kambhampati exploiting symmetry graph via
explanation guided search proceedings aaai
zimmerman kambhampati generating parallel plans satisfying multiple criteria
anytime fashion proceedings workshop scheduling multiple
criteria aips
zimmerman kambhampati available memory transform graphplans
search poster proceedings ijcai




