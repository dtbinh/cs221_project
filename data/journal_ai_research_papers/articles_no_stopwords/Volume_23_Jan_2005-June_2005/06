journal artificial intelligence

submitted published

keys nominals concrete domains
carsten lutz

lutz tcs inf tu dresden de

theoretical computer science tu dresden
dresden germany

carlos areces

areces loria fr

inria lorraine nancy
villers les nancy cedex france

ian horrocks

horrocks cs man ac uk

department computer science
university manchester
oxford road manchester pl uk

ulrike sattler

sattler cs man ac uk

department computer science
university manchester
oxford road manchester pl uk

abstract
many description logics dls combine knowledge representation abstract logical
level interface concrete domains numbers strings built predicates prefix hybrid dls turned useful several
application areas reasoning conceptual database propose
extend dls key constraints allow expression statements
us citizens uniquely identified social security number idea
introduce number natural description logics perform detailed analysis
decidability computational complexity turns naive extensions
key constraints easily lead undecidability whereas careful extensions yield nexptime complete dls variety useful concrete domains

motivation
description logics dls family formalisms allow representation
reasoning conceptual knowledge structured semantically well understood
manner baader calvanese mcguinness nardi patel schneider central
entities representing knowledge concepts constructed atomic
concept names unary predicates role names binary relations means concept
role constructors offered particular dl example basic propositionally
closed description logic alc schmidt schau smolka describe company
part time employees full time managers concept
company u employee parttime u employee manager parttime
example words beginning uppercase letters denote concept names
employee denotes role name
c

ai access foundation rights reserved

filutz areces horrocks sattler

rather viewed conceptual entities knowledge base concepts
generally understood central notion kinds class centered
formalisms last decade observation given rise challenging applications description logics reasoning database conceptual
expressed entity relationship diagrams object oriented schemas calvanese lenzerini
nardi calvanese de giacomo lenzerini reasoning ontologies
use semantic web baader horrocks sattler horrocks horrocks
patel schneider van harmelen applications turn stimulated
description logics since expressive power existing dls insufficient
tasks one important extension providing expressive means allow
integration numbers datatypes suppose example want
extend earlier descriptions companies employees include founding year
company hiring year employee may want describe companies
founded state hiring year employees prior
founding year employing company obviously need way talk
natural numbers comparisons natural numbers
nowadays standard integrate datatypes description logics
extend dls concrete domains first proposed baader hanschke
recently surveyed lutz precisely concrete domain consists set
natural numbers predicates associated fixed extension
set unary binary ternary integration
concrete domains say description logic alc achieved adding
abstract features e functional roles
concrete features e partial functions associating values concrete domain
e g natural numbers logical objects
concrete domain concept constructor
dl obtained extending alc way called alc denotes
concrete domain viewed parameter logic example
suitable concrete domain describe constraints formulated concept
employee u employer foundingyear u hiringyear employer foundingyear
describes set employees employed company founded
hiring year prior companys founding year example term
foundingyear instance concrete domain concept constructor
confused existential value restriction employee parttime third
conjunct unary predicate thus former instance takes one
concrete feature foundingyear argument second instance uses binary predicate
requiring two arguments concrete feature hiringyear sequence features
employer foundingyear consisting abstract feature employer concrete feature
foundingyear
concrete domains rather important many applications dls including two
mentioned
fixed extension predicates often called built



fikeys nominals concrete domains

standard way description logics reasoning conceptual database
translate given model dl representation use dl reasoner fact horrocks racer haarslev moller compute
consequences information provided explicitly model includes
detecting inconsistencies inferring additional implicit containments entities classes calvanese et al since databases store concrete data
numbers strings constraints concerning data usually part
conceptual model thus captured description logic used
reasoning indeed example concepts viewed dl encoding
constraints database companies employees discussed
lutz c description logics concrete domains well suited conceptual modeling applications involving concrete datatypes
called concrete datatypes play prominent role construction ontologies horrocks et al say example want construct ontology
used describing car dealers web web services
ontology concrete datatypes prices manufacturing years names car
doubtlessly important formulate ontology dl
need way represent concrete datatypes consequently almost dls
proposed ontology language equipped form concrete
domain fensel van harmelen horrocks mcguinness patel schneider horrocks et al dean connolly van harmelen hendler horrocks mcguinness
patel schneider stein furthermore since ontology languages provide
inverse abstract roles functional restrictions users ontology designers
quite surprised provide inverse concrete functional
featureswhich due fact features correspond concrete key
constraints reasoning known whose effect
decidability complexity yet investigated
propose enhance expressive power description logics
concrete domains extending concrete key constraints extension
useful knowledge representation two applications sketched
following three examples describe basic idea
suppose knowledge representation application represent nationalities
concept names us german us citizens store social
security number concrete feature ssn would natural state
us citizens uniquely identified social security number e two distinct
instances
human u nationality us
must different values ssn feature extension dls concrete
domains expressed key assertion
ssn keyfor human u nationality us
readers familiar
vrelationship dls first order logic notice key assertion
equivalent x x human xi z nationality xi z us z x x ssn x
ssn x



filutz areces horrocks sattler

returning database companies employees could useful
equip every employee concrete feature branch storing branch id
working ii concrete feature id storing personnel id would
natural enforce branch id together personnel id uniquely
identifies employees even though personnel ids unique
composite key assertion
branch id keyfor employee
car dealers ontology may assume cars well manufacturers
equipped identification numbers every car uniquely identified
combination identification number manufacturers one express
could employ composite key assertion referring sequences features
case manufacturer id
id manufacturer id keyfor car
formally propose extend dls provide concrete domains key boxes
sets key assertions form
u un keyfor c
ui sequence f fn g abstract features fj followed single concrete
feature g c concept examples illustrate idea key constraints
natural since moreover keys play important role databases mentioned
reasoning database conceptual important challenging application
description logics several approaches extend description logics keys already
investigated borgida weddell calvanese de giacomo lenzerini
khizder toman weddell distinguishes existing ones
however idea concrete domains constructing key constraints rather
defining keys abstract logical level
goal provide comprehensive analysis effects decidability computational complexity adding key boxes description logics concrete
domains end extend two description logics alc shoq key
boxes way obtaining alck shoqk respectively basic dl
concrete domains alc already discussed shoq proposed
ontology language horrocks sattler provides wealth expressive
possibilities general concept inclusion axioms gcis transitive roles role hierarchies nominals qualifying number restrictions moreover offers restricted variant
concrete domain constructor disallows use sequences features order
avoid undecidability reasoning main outcome investigations key
constraints dramatic impact decidability complexity reasoning
example whereas satisfiability alc concepts known pspace complete lutz
b satisfiability alck concepts w r key boxes general
undecidable decidability regained restrict concepts used key boxes


fikeys nominals concrete domains

boolean combinations concept names boolean key boxes interestingly satisfiability alck concepts w r boolean key boxes still nexptime complete even
simple concrete domains case shoq shoqk leap
complexity somewhat less dramatic since shoq concept satisfiability already exptime complete addition key boxes nexptime complete reasoning

interesting note exists close connection key assertions
called nominals e concept names one instance
pope nominals standard means expressivity description logics sometimes
appear disguise one operator borgida patel schneider horrocks
et al hard see key boxes simulate nominals example
use concrete domain natural numbers providing unary predicates
n equality n key assertion g keyfor stands
logical truth obviously makes concept g n behave nominal n
reason consider alco extension alc nominals
alcok extension alck nominals main concerning
nominals although general lower expressive power key boxes
already make reasoning nexptime hard combined concrete domains exist
concrete domains alco concept satisfiability nexptime complete
stress nexptime hardness obtained
accordance observation made lutz pspace upper
bound reasoning alc robust w r extensions logic exist
several seemingly harmless extensions alc example acyclic tboxes
inverse roles make complexity reasoning leap pspace completeness
nexptime completeness many natural concrete domains

n

n

remainder organized follows section formally introduce
concrete domains key boxes dl alcok together fragments alck
alco moreover define boolean key boxes allow boolean combinations concept names appear key definitions additionally introduce
important properties key boxes path free key boxes prohibit use sequences
features key assertions unary key boxes key assertion involves exactly one
sequence features composite key boxes simply non unary ones
section devoted establishing lower bounds extensions alc key
boxes nominals section use reduction post correspondence
prove alck concept satisfiability w r non boolean key boxes undecidable
large class concrete domains shift attention boolean key boxes
since section restriction restores decidability section
introduce nexptime complete variant domino three concrete
domains useful reduction concept satisfiability dls
boolean key boxes nominals section use concrete domains
prove alck concept satisfiability w r boolean path free unary key boxes
nexptime hard natural concrete domains section prove
exist concrete domains alco concept satisfiability without reference
note logic shoq already provides nominals



filutz areces horrocks sattler

key boxes already nexptime hard true even concrete
domains computationally simple ptime considered isolation
purpose section develop reasoning procedures description logics
key boxes prove upper complexity bounds matching nexptime lower bounds
established previous section start section tableau
decides alcok concept satisfiability w r boolean key boxes provided concrete domain key admissible intuitively concrete domain key admissible
exists takes finite conjunction c predicates set
variables decides whether conjunction satisfiable chooses solution c
returns information variables take values call
tester chosen tableau since type reasoning
procedure potential implemented efficient reasoners shown
behave well practice horrocks sattler tobies haarslev moller
implies following upper complexity bound key admissible concrete
domain non deterministic polynomial time tester exists alco concept satisfiability w r boolean key boxes nexptime
section devise tableau shoqk concept satisfiability
w r path free key boxes might involve non boolean concepts decidability
alcok restricted key boxes boolean ones shoqk restriction possible since shoq provides tboxes thus longer distinguish
boolean non boolean concepts hand follows undecidability proof baader hanschke shoq undecidable allow
sequences features concrete domain constructors thus restrict key assertions
analogously path free ones yields indeed decidable logic expressive power orthogonal one alcok previous undecidability
imply combination alcok shoqk undecidable
product correctness proof obtain bounded model property shoqk implies shoqk concept satisfiability w r path free
key boxes nexptime key admissible concrete domain nondeterministic polynomial time tester exists
section summarize obtained give outlook possible future


description logics concrete domains
following introduce description logic alcok let us start defining
concrete domains
definition concrete domain concrete domain pair
set set predicate names predicate name p associated
arity n n ary predicate p nd
concrete domains define alcok concepts key boxes
definition alcok syntax let nc nr ncf pairwise disjoint countably infinite sets concept names nominals role names concrete features furthermore assume nr contains countably infinite subset naf abstract features


fikeys nominals concrete domains

path u composition f fn g n abstract features f fn n concrete
feature g let concrete domain set alcok concepts smallest set

every concept name every nominal concept
c concepts r role name g concrete feature u un paths
p predicate arity n following expressions concepts
c c u c r c r c u un p g
key assertion expression
u uk keyfor c
u uk k paths c concept finite set key assertions
called key box
usual use abbreviation arbitrary propositional tautology
abbreviation c abbreviation c c abbreviation
c u c throughout consider several fragments
description logic alcok dl alco obtained alcok
admitting empty key boxes particular set alco concepts set
alcok concepts furthermore disallowing use nominals obtain
fragment alc alco alck alcok
description logic alcok equipped tarski style set theoretic semantics
along semantics introduce two standard inference concept
satisfiability concept subsumption
definition alcok semantics interpretation pair
non empty set called domain interpretation function interpretation
function maps
concept name c subset c
nominal n singleton subset n
role name r subset ri
abstract feature f partial function f
concrete feature g partial function g


filutz areces horrocks sattler

u f fn g path ui defined g fni f interpretation
function extended arbitrary concepts follows
c c
c u c di
c c di
r c e e ri e c
r c e e ri e c
u un p x xn uii xi x xn p
g g undefined
let interpretation model concept c iff c moreover
satisfies key assertion u un keyfor c b c
ui ui b uin uin b implies b
model key box k iff satisfies key assertions k concept c satisfiable
w r key box k iff c k common model c subsumed concept w r
key box k written c vk iff c di k
well known description logics providing boolean operators subsumption
reduced un satisfiability vice versa c vk iff c u unsatisfiable
w r k c satisfiable w r k iff c vk allows us concentrate concept
satisfiability devising complexity bounds reasoning description logics lower
upper complexity bounds concept satisfiability imply corresponding bounds
concept subsumptiononly complementary complexity class
decision procedures description logics concrete domains devised
without committing particular concrete domain well defined interface
decision procedure concrete domain reasoner needed usually interface
assumption concrete domain admissible baader hanschke
lutz
definition conjunction admissibility let concrete domain v set
variables conjunction finite predicate conjunction form

c
x x
ni pi
k


pi ni ary predicate k xj variables v conjunction
c satisfiable iff exists function mapping variables c elements


x xni pid k function called solution c
say concrete domain admissible iff
contains unary predicate

closed negation e n ary predicate p predicate

p arity n p nd p


fikeys nominals concrete domains

satisfiability conjunctions decidable
refer satisfiability conjunctions satisfiability
shall see sometimes makes considerable difference w r complexity decidability restrict key boxes ways example disallow paths length greater
one therefore introduce useful notions
definition boolean path free simple key box k called
boolean concepts appearing key assertions k boolean combinations
concept names
path free key assertions u un keyfor c k u un ncf
simple path free boolean
unary key assertions k unary key assertions e form u keyfor c
concept c called path free subconcepts form u un p u un
concrete features
emphasize key box might necessarily boolean path free sometimes
call key box general similarly emphasize key box necessarily
unary key box sometimes call key box composite

lower bounds
section prove lower complexity bounds description logics concrete domains key boxes nominals section start showing satisfiability alck concepts w r general key boxes undecidable many interesting
concrete domains discouraging picture painted mitigated fact
section shall prove restriction boolean key boxes restores decidability thus interesting look lower complexity bounds apply
restriction preparation introduce section nexptime complete variant domino three concrete domains well suited reductions

section prove satisfiability path free alck concepts w r
simple key boxes nexptime hard large class concrete domains
many concrete domains holds even restrict key boxes unary ones finally
consider description logic alco section identify several concrete
domains alco concept satisfiability without key boxes nexptimehard already mentioned key boxes nominals closely related key boxes
express nominals general powerful
undecidability alck general key boxes
prove satisfiability alck concepts w r key boxes undecidable
large class concrete domains allow complex alck concepts occur key
assertions proof reduction well known undecidable post correspondence
post hopcroft ullman


filutz areces horrocks sattler

definition pcp instance p post correspondence pcp given
finite non empty list r k rk pairs words alphabet
sequence integers im called solution p im ri rim
pcp decide whether given instance p solution
reducing pcp satisfiability dls need appropriate concrete
domain obviously natural use concrete domain words concatenation
later see obtained concrete domain carry
concrete domains numbers arithmetics following concrete domain
introduced lutz definition presupposes fixed alphabet least
binary
definition concrete domain w concrete domain w defined setting w
defining w smallest set containing following predicates
unary predicates word nword wordw w nwordw
w

unary predicates w


binary equality predicate binary inequality predicate obvious
interpretation
w two binary predicates concw nconcw
w
concw
w u v v uw nconcw u v v uw

readily checked w satisfies properties admissibility see definition
moreover w satisfiability decidable
theorem lutz w satisfiability ptime
thus w admissible even low complexity important since aim
demonstrate undecidability alck w concept satisfiability due
presence keys due high complexity w satisfiability
discuss reduction pcp given instance r k rk
translated alck concept cp key box kp defined figure
p solution iff cp unsatisfiable w r kp idea behind reduction
common model cp kp encodes potential solutions p e sequences
integers ij k makes sure none fact solution
figure f fk denote abstract features g r denote concrete features
definition concept step serves abbreviation confused
called tboxes see section definition tboxes cp kp
one displayed figure form infinite k ary tree whose root
connected extra node x via role r intuitively node tree represents
one partial solution successor represents corresponding left concatenation
r successor corresponding right concatenation ri rin
enforce existence infinite tree employ key box kp consider
example root nodes f successor figure let us call node due line


fikeys nominals concrete domains

step

u f u g u r
u u f conc u r f r conc


ik





ik





ri

cp u r
u r u g u step
u step
kp g keyfor step
figure alck w reduction concept cp key box kp
r


conc



r



x

fk

concrk

f


g

concr conc k

f



r


fk

f



r




fk



figure example model cp kp
cp line step g due line cp
x g x step x extra node mentioned view
key box kp implies x ii stepi easy see
impossible since line cp line step imply x ai
hence stepi line step appropriate successors n
way construction tree continued ad infinitum second
line definition step enforces z ri z ri rin z
fin successor root node finally concept r line step implies
z ri z holds nodes z tree except root implies
potential solution solution
since size cp kp clearly polynomial k key box kp unary
key box obtain following proposition
proposition satisfiability alck w concepts w r non boolean path free
unary key boxes undecidable


filutz areces horrocks sattler

emphasize undecidability obtained simple concrete
domain let us combine theorem proposition
theorem exists concrete domain satisfiability ptime
satisfiability alck concepts w r non boolean path free unary key boxes
undecidable
first sight concrete domain w might look artificial one may question relevance lower bounds obtained w however straightforward
encode words natural numbers define concatenation words rather simple operations natural numbers baader hanschke word w
alphabet cardinality interpreted number written base
symbol digit occur hence use corresponding natural number e g base represent word w number
represent empty word concatenation two words v w expressed
vw v w w w denotes length word w moreover exponentiation expressed multiple multiplications multiplication multiple additions
addition multiple incrementation shown section lutz
case alc extended tboxes c f section easily adapted
alc non boolean key boxes observation gives rise following theorem

n

theorem let concrete domain contains unary predicate binary equality inequality predicates binary predicate
incr incrd n x n x k k k satisfiability
alck concepts w r non boolean path free unary key boxes undecidable

n

n

domino concrete domains
section introduce nexptime complete variant well known undecidable
domino berger knuth define three concrete domains
concrete domains used sections establish
lower bounds reasoning alck boolean key boxes reasoning
alco
general domino given finite set tile types intuitively tile
types size type square shape colored edges unlimited
number tiles type available nexptime hard variant domino
use task tile n n torus e n n rectangle
whose borders glued together neighboring edges color

n

definition domino system domino system triple h v
finite set tile types h v represent horizontal vertical matching
conditions let domino system initial condition e
n tuple tiles mapping n n solution
iff x n following holds
x x n h
x x n v


fikeys nominals concrete domains

ai n
denotes addition modulo
follows borger gradel gurevich variant
domino nexptime complete
define concrete domain used reduction nexptimecomplete domino alck concept satisfiability w r boolean key boxes
definition concrete domain concrete domain defined setting
smallest set containing following predicates
unary predicates
unary predicates
second concrete domain used reduction nexptime complete
domino alck concept satisfiability w r boolean unary key boxes
reduction need store vectors bits single concrete domain elements

n

definition concrete domain every n function v n
called bit vector dimension n use bvn denote thesset bit vectors
dimension n concrete domain defined setting bvi
smallest set containing following predicates
unary predicates
every k

n k unary predicates bit ik bit ik
bitnik v v bvk v n

unary predicates bit ik bit ik bitnik bitnik
last concrete domain used reduction nexptime complete domino
alco concept satisfiability reduction concrete domain
contains two kinds elements firstly elements represent
whole n n torus called domino arrays secondly elements
represent positions torus technical reasons discussed later elements
vectors natural numbers rather bit vectors following shall call
vectors domino array function mapping pair vectors certain
length natural number represents tile type

n

n

definition concrete domain every k function v k
called vector dimension k use vek denote set vectors dimension k
every k function k vek vek
called domino array dimension k
use dak denote setsof domino
arrays
dimension k concrete domain

defined setting vei dai smallest set containing
following predicates

n

n

unary predicates


filutz areces horrocks sattler

every k

n k unary predicates pos ik pos ik
posnik v v vek v n

unary predicates pos ik pos ik posnik posnik
every k

n predicate tileik arity

tileik vx vy vx vy vek dak vx vy
predicate tileik arity tileik tileik
reason vectors natural numbers rather bit vectors definition
want satisfiability low complexity preferably ptime consider
conjunction
pos x pos pos z
tile x v tile v tile z v
use bit vectors rather vectors natural numbers upper line enforces
least two three variables x z must take value since
value v fixed lower line makes conjunction unsatisfiable tries assign
three different values two different positions domino array seems
unlikely kind inconsistency detected polynomial time
circumvented vectors natural numbers definition enforcing
bit vectors reduction case conjunction clearly
satisfiable
proposition concrete domain di admissible satisfiability di conjunctions ptime
trivial proof found appendix proof
found lutz areces horrocks sattler
nexptime hardness alck boolean key boxes
section prove two nexptime lower bounds alck concept satisfiability
w r boolean key boxes reducing nexptime complete domino introduced
previous section first reduction uses simple concrete domain
depends composite key assertions second reduction uses slightly complex
concrete domain needs unary key assertions see two reductions
yield different incomparable
first reduce nexptime complete domino alck concept satisfiability w r boolean composite key boxes domino system h v initial
condition translated alck concept cd displayed
figure names treex treey used abbreviations use ri c
abbreviation n fold nesting r r c names xposi yposi used
figure denote concrete features definition init concept n biti n

n



fikeys nominals concrete domains

treex r x u r x u

u r distx


u r xi u r xi



n

treey distxn u r u r u

u r disty u distx u r u r
distx u x r x u x r x
disty u r u r
transxpos u x xpos u x xpos
transypos u ypos u ypos




n

k

k



k

n











k



n

n































succs rx transxpos u transypos u ry transxpos u transypos

xsuccok
yi rx yi u yi rx yi
n


xj xk rx xk u xk rx xk

u
u u
u x x r x u x r x

ysuccok u x r x u x r x
u u r u r
u r u r
label u u u
checkmatch u r u u r

u x u u x u u
init u
k n

j k

k n

j k


n

j k

k n

j k



j h

n



j



k



j

j n bitj

x

k





k

x

k



j

jt j



x

k



k n



j

k



k

k



k

k



k

k

j

j v
j





j

j n bitj

j

j n

j



ai

cd treex u rn treey
u r n transxpos u transypos u succs u xsuccok u ysuccok
u r n label u checkmatch u init
figure alck reduction concept cd
supposed denote ith bit binary representation n claim cd
satisfiable w r key box
xpos xposn ypos yposn keyfor
iff exists solution substantiate claim let us go
reduction explain parts concept cd first step towards

filutz areces horrocks sattler

standing structure cd key understanding reduction
note purpose first line cd enforce tree structure
depth n whose leaves correspond positions n n torus
precisely treex concept guarantees every model cd exists binary
tree depth n moreover distxk concepts exists one k n
ensure leaves tree binarily numbered n concept
names x xn precisely domain object set

xii
n

xpsn
otherwise
treex distx concepts ensure exist nodes n level n
tree xpsn di intuitively numbering represents horizontal
positions n n torus vertical positions coded similar way
yn concept names specifically concepts treey distx disty ensure
every di n root another tree every node
x xn configuration root node ii leaves numbered binarily
concept names yn note treey concept appears cd inside
rn value restriction define

yii
n

ypsn
otherwise
set leaf nodes trees enforced treey concept exists
j n object ei j xpsn ei j ypsn ei j j e ei j
represents position j n n torus
next step translate individual bits numbering ei j objects
represented concept names concrete domain values
done transxpos transypos concepts ensure n
xposi ei j ei j x xposi ei j ei j x similarly ypos
since model key box
xpos xposn ypos yposn keyfor
grid positions uniquely represented domain elements transxpos u transypos
e e transxpos u transypos xpsn xpsn e ypsn yxpsn e
e fact used concepts succs xsuccok ysuccok enforce
two roles rx ry j n following holds
rxi ei j ei j e n j
ryi ei j ei j ei j n



succs concept ensures ei j exists rx successor ry successor transxpos u transypos let rx successor ei j
xsuccok concept ensures xpsn n ypsn j
matter one object



fikeys nominals concrete domains

explain let us note since ei j transxpos u transypos
grid positions uniquely represented elements transxpos u transypos
implies e n j shows upper line indeed hold
let us consider xsuccok concept detail essentially
dl formulation well known propositional formula
n k
n k





xj xk x k

xj xk x k
k j

k j

encodes incrementation modulo n e number binarily encoded
propositional variables x xn number encoded propositional
variables x x n modulo n see borger et al taking
account rx quantifiers xsuccok readily checked concept
desired effect ensure every rx successor ei j xpsn
xpsn e n j n explanation ysuccok enforces lower
line analogous xsuccok case
remains ensure every grid position labeled precisely one tile
initial condition well horizontal vertical matching conditions satisfied
tiles represented concept names di set tiles
described tasks accomplished standard way concepts label init
checkmatch
worth noting reduction concept path free key box simple
e path free boolean path freeness concepts often used tame complexity
description logics concrete domains although largely sacrifices expressive
power lutz baader lutz sturm wolter b haarslev moller wessel
horrocks sattler example alc augmented general tboxes
reasoning arbitrary concepts undecidable reasoning path free concepts
exptime complete admissible satisfiability exptime lutz
taming work presence key boxes since
seen satisfiability alc concepts w r key boxes natural assumptions
nexptime hard even concept key box path free
since size cd used key box clearly polynomial n obtain
following proposition
proposition satisfiability path free alck concepts w r simple key boxes
nexptime hard
shown non path free alc concept satisfiability pspace complete
satisfiability pspace lutz b hence follows proposition
alc concept satisfiability pspace complete thus rather dramatic increase complexity key boxes added alc stress increase due
key boxes complexity satisfiability reformulate
proposition
theorem exists concrete domain satisfiability ptime
satisfiability path free alck concepts w r simple key boxes nexptime hard


filutz areces horrocks sattler

succs rx transpos u ry transpos
transpos

u
u

n
n


xi bv bit n u xi bv bit n u

n
n
yi bv bit n
u yi bv bit n


cd treex u rn treey
u r n transpos u succs u xsuccok u ysuccok
u r n label u checkmatch u init
figure alck reduction concept cd
although due low expressivity concrete domain natural
knowledge representation fragment many concrete domains
proposed literature baader hanschke haarslev moller lutz
b indeed presented reduction strategy adapted several standard
concrete domains let us formulate weak condition concrete domain must
satisfy order presented reduction strategy applicable
theorem let concrete domain exist b b p p
p p b satisfiability path free alck concepts
w r simple key boxes nexptime hard
present second nexptime hardness alck concept satisfiability
time reduce nexptime complete domino satisfiability pathfree alck concepts w r simple unary key boxes reduction similar
previous one discuss differences
first reduction represented individual bits grid positions individual
concrete features xposi yposi used composite key box ensure point
torus represented one element second reduction use single
concrete feature bv represent entire position j torus bit vector
concrete domain allows us enforce mentioned uniqueness
representations unary key box
modified reduction concept cd found figure concepts
treex treey distxk distyk xsuccok ysuccok label checkmatch init defined
figure translation position torus encoded x xn yn
bit vector done transpos concept straightforward manner given
said first reduction hard see cd satisfiable w r key
box bv keyfor iff exists solution thus obtain following
proposition
proposition satisfiability path free alck concepts w r simple unary
key boxes nexptime hard
relate nexptime lower bound complexity satisfiability
determined proposition


fikeys nominals concrete domains

theorem exists concrete domain satisfiability ptime
satisfiability path free alck concepts w r simple unary key boxes nexptime hard
since elements bit vectors concrete domain cannot considered
natural choice many application areas reduction replaced
several natural concrete domains
central observation use bit vectors injectively translate sequences
bits values concrete domain e translate sequences n bits
represented concept names x xn yn elements
distinct sequences translation distinct due
restricted use bit vectors several ways replace natural numbers
example replace transpos following concept transpos ensures
transpos si n xpsn n ypsn

u


transpos zero u
ti u x u x u
n


xi si zero si u xi si ti si u
n



yi n si zero si u yi n si ti si

u
u

n n

n

zero si ti concrete features k k denotes unary predicate
obvious extension denotes ternary addition predicate intuitively
first two arguments addends third one sum

easy check whenever two objects e transpos agree
interpretation x xn yn si n si n e thus key
box n keyfor used reduction size transpos obviously
polynomial n numbers k appearing k predicates coded binary thus
obtain following theorem
theorem let concrete domain


n
n

contains k predicate k k k size
representation k logarithmic k
contains predicate k k x k k
k k k k k k

n

n x



satisfiability path free alck concepts w r simple unary key boxes
nexptime hard
example theorem yields nexptime lower bounds alck instantiated
concrete domains proposed baader hanschke haarslev moller lutz
b alternative addition predicate use multiplication injectively


filutz areces horrocks sattler

translate sequences bits natural numbers precisely let p p n
first n prime numbers define another version transpos follows
transpos one u

u
u

n

u


ti pi u x u x u
n



xi si one si u xi si ti si u



yi n si one si u yi n si ti si

n n

ternary multiplication predicate
since factorization natural numbers prime numbers unique
use key box n keyfor reduction moreover well known
kth prime polynomial k graham knuth patashnik thus size
concept transpos polynomial n even numbers k k predicates coded
unarily thus obtain another theorem concerning quite natural concrete domains
theorem let concrete domain


n

n predicate k k k
contains predicate k k x k k n x
k k k k k k n
contains k



satisfiability path free alck concepts w r simple unary key boxes
nexptime hard
nexptime hardness alco
already pointed section relationship key boxes nominals
rather close latter simulated former concrete domain provides
predicates used uniquely describe elements example alck
concept g behaves nominal use key assertion g keyfor
even define n nominals n single concrete features unary key assertions
logics alck alck single concrete feature unary key assertions
sufficient simulate arbitrary number nominals example alck
concept c g bit u g bit uniquely describes bit vector bv e
c implies g obviously bit vector length
described similar way
illustrates non trivial concrete domains logic alck
least expressive alco although converse hold expressive
power alco still sufficient prove nexptime hardness concept satisfiability
provided suitable concrete domain used since alco concept satisfiability
pspace complete areces blackburn marx yet another example dl
even seemingly harmless extension concrete domains dramatic effect
computational complexity lutz


fikeys nominals concrete domains

nominal f n
xsucc
ysucc

u u x x x u u x x x
u u u u

k n

j k

k n

j k

j


k

k

j


k

k

k n

k n

j

j k

j k

j

n


n





n





n





n

jv

u

n


n






jh

init


n




n



n

n


n



n



u


k

k

u x bvx pos u x bvx pos

transypos u bvy pos
u bvy pos


transxsucc u x bvxs pos
u x bvxs pos


transysucc u bvys pos
u bvys pos

checkhmatch bvx bvy f darr tile
u bvxs bvy f darr tile
checkvmatch bvx bvy f darr tile
u bvx bvys f darr tile
transxpos


k

k


n

j
n


n

j
n

xj u

u

u

xj u
yj
j n
j n bitj
j n bitj


bvx bvy f darr tilean



cd treex u rn treey u r n nominal u
r n transxpos u transypos u
xsucc u ysucc u transxsucc u transysucc u
init u checkhmatch u checkvmatch
figure alco reduction concept cd

section reduce nexptime complete domino alco concept satisfiability let h v domino system
initial condition modified reduction concept cd defined figure bvx
bvy bvxs bvys darr denote concrete features n denotes nominal concepts
treex treey distxk distyk defined figure previous reductions
give detailed explanation reduction strategy cd satisfiable
iff exists solution formal details easily worked
interested reader
let model cd explain structure convenient start
first line cd previous reductions treex treey concepts
used ensure contains tree shaped substructure depth n whose leaf
nodes roots additional trees depth n set leafs


filutz areces horrocks sattler

treex

treey



treey





f

f

treey

f

n
darr

figure structure cd
latter trees correspond positions n n torus e position
leaf node representing torus positions binarily encoded concept
names x xn yn use ei j refer leaf xpsn ei j
ypsn ei j j see section
previous reductions numbers coded x xn yn
translated concrete domain values done transxpos transypos
concepts note contrast alck reduction x position yposition stored bit vector rather two distinct ones bvx
bvy contrast previous reduction actual tiling torus
represented leaf nodes ei j rather domino array last conjunct
first line cd ensures every leaf ei j connected via abstract feature f
unique element w n
domain element w associated domino array via concrete feature darr
shall see later guaranteed checkhmatch checkvmatch concepts
domino array represents tiling n n torus summing structure
roughly shown figure
since tiling stored domino array need explain purpose leaf
nodes ei j nodes used enforce initial condition horizontal
vertical matching condition let us discuss horizontal matching condition vertical
matching condition enforced analogously xsucc concept dl reformulation
propositional logic formula incrementation modulo n ensures
ei j concept names x xn encode number n e horizontal
position ei j horizontal neighbor addition storage horizontal vertical
position ei j bvx ei j bvy ei j store horizontal position n ei j
horizontal successor bvxs ei j finally checkhmatch verifies tiles positions


fikeys nominals concrete domains

j n j stored domino array compatible
horizontal matching condition
note checkhmatch ensures domain element w w n
domino array attached via concrete feature darr position j
unique tile stored domino array set initial condition ensured
via init concept similar way use bitj denote jth bit
binary encoding natural number
considerations correctness reduction readily checked
moreover size cd polynomial n note cd path free
paths length two appear concepts checkhmatch checkvmatch init summing
reduction described yields following
proposition satisfiability alco concepts nexptime hard
relate nexptime lower bound complexity satisfiability
determined proposition
theorem exists concrete domain satisfiability ptime
satisfiability alco concepts nexptime hard
note reduction uses single nominal n dramatic increase complexity since shown satisfiability alc concepts e without nominals
key boxes pspace complete provided admissible satisfiability
pspace lutz b
previous sections note replaced natural concrete
domains nexptime hardness proof presented idea represent whole
domino array single natural number use arithmetic operations access
individual positions natural number k viewed domino array partitioning
binary representation n n n sections length dlog e
denotes cardinality set tile types section describes tile
single position torus sections accessed integer division
reminder operations k natural number representing torus tile
posisition computed
k div idlog e mod dlog e
thus introduce ternary predicates div integer division mod computing
remainder division binary predicate x expressing exponentiation basis
modify reduction follows replace transxpos transypos
transpos concept section translate two numbers encoded x xn
yn single natural number stored concrete feature n
devise concept tile enforcing position identified
feature n labeled tile
tile r dlog e u n r r u r r x u one u r one u x
u f torus r u div u u tile mod u tile


filutz areces horrocks sattler

r r r u one torus tile concrete features torus feature counterpart darr feature original reduction e stores natural number
represents tiling array use tile concept obvious way inside
checkhmatch checkvmatch init concepts size resulting reduction concept
polynomial n numbers k appearing k predicates coded binary
thus obtain following theorem
theorem let concrete domain


n

contains predicates predicate k k
following extensions
x

k x k
k k x k k
k k x k k
div k k x k k
mod k k x k k







n
n
n
n
n

k
x
x
x
x
x








n x div mod

k
k k k
k k k k k k
k k k k k k
k k k div k k k
k k k mod k k k

n

n
n
n
n

satisfiability alco concepts nexptime hard

reasoning procedures
section devoted developing reasoning procedures dls concrete domains
nominals keys start devising tableau decides satisfiability
alcok concepts w r boolean key boxes yields nexptime upper
complexity bound matching lower bounds established section
consider rather powerful description logic shoqk dl
extension shoq horrocks sattler pan horrocks provides
wealth expressive means transitive roles role hierarchies nominals qualifying
number restrictions moreover shoqk equipped restricted variant
concrete domain constructor key boxes develop tableau
deciding satisfiability shoqk concepts w r path free key boxes due
restrictedness shoqk concrete domain constructor even admit general
rather boolean key boxes yields tight nexptime upper
complexity bound
tableau alcok boolean key boxes
tableau decide satisfiability input concept case w r input
key box attempting construct model precisely tableau
starts initial data structure induced input concept repeatedly applies called completion rules rule application thought attempting
construct model input concept finally obvious contradiction encounter situation contradiction free


fikeys nominals concrete domains

completion rules applicable former case input concept unsatisfiable
satisfiable latter
devising tableau description logic concrete domains
without committing particular concrete domain commonly assumed concrete domain admissible implies decidability satisfiability conjunctions
presence keys however enough conjunction satisfiable
want know variables take values arbitrary fixed solution
example consider concrete domain n n n n conjunction

n

n

c v v v
obviously one solution c satisfies v v another satisfies v v
tableau uses identity information passed concrete domain
reasoner since presence key boxes impact structure
constructed model example information reveals unsatisfiability
r u r u b u r u b u r g w r g keyfor
formalize requirement strengthen notion admissibility key admissibility
since tableau developed section non deterministic formulate keyadmissibility non deterministic way
definition key admissible concrete domain key admissible iff satisfies
following properties
contains name
closed negation
exists takes input conjunction c returns clash c
unsatisfiable otherwise non deterministically outputs equivalence relation
set variables v used c exists solution c
following property v v v
v v iff v v
showing behaviour described item called tester
equivalence relations called concrete equivalences say extended dsatisfiability np exists tester running polynomial time
please note key admissibility less esoteric might seem concrete domain
admissible provides equality predicate key admissible due
admissibility presence equality predicate implies inequality predicate
available thus construct tester satisfiability
presented predicate conjunction c simply guess equivalence relation
set variables
used c vthen decide non extended satisfiability
v
conjunction c vv v v v v v v return clash unsatisfiable
otherwise rather weak condition equality predicate present


filutz areces horrocks sattler

c u
r c

c c
r c
r c

u un p
g

c u
r c

c

c

u un p u un
g

figure nnf rewrite rules
satisfied almost concrete domains proposed literature see e g lutz
baader hanschke b kamp wache haarslev lutz moller baader
sattler
throughout chapter assume concrete domain equipped
equality predicate assumption w l g since conjunction equality
translated equivalent one without equality identifying variables according
stated equalities assumption must confused discussed
previous paragraph even concrete domain admissible set predicates
thus closed negation assumption imply presence inequality
predicate
need prerequisites start presentation tableau
concept negation normal form nnf negation occurs front
concept names nominals easily seen concrete domain admissible
every alcok concept converted equivalent one nnf exhaustively applying rewrite rules displayed figure use c denote
converting c nnf key box nnf concepts occurring key assertions
nnf follows generally assume input concepts key boxes nnf
let c alcok concept k key box use sub c denote set
subconcepts c including c con k denote set concepts appearing

right hand side key assertions k set concepts sub denotes
set c sub c moreover write cl c k abbreviation set
sub c sub con k
sub con k
start presentation tableau introducing underlying data
structure
definition completion system let oa oc disjoint countably infinite
sets abstract concrete nodes completion tree alcok concept c
key box k finite labeled tree va vc e l nodes va vc va oa
vc oc nodes vc leaves tree labeled follows
node va labeled subset l cl c k
edge b e b va labeled role name l b occurring c
k
edge x e va x vc labeled concrete feature l x
occurring c k


fikeys nominals concrete domains

va use levt denote depth occurs starting
root node depth completion system alcok concept c key box
k tuple p
va vc e l completion tree c k
p function mapping p arity n c subset vcn
linear ordering va levt levt b implies b
equivalence relation vc
let va vc e l completion tree node b va r successor node va
b e l b r node x vc g successor x e
l x g path u notion u successor defined obvious way
intuitively relation records equalities concrete nodes found
non deterministic model construction process recording necessary since equalities concrete nodes induce equalities abstract nodes turn
imply equalities concrete nodes seen following example assume completion tree contains abstract node ai
concrete g successor xi concrete g successor yi assume key box contains g keyfor tester returns x x consequence
represent element thus functionality g implies represent
concrete element deal effects define equivalence relation
abstract nodes second equivalence relation c concrete nodes
definition c relations let p completion system
concept c key box k va vc e l let equivalence relation
va r nr node b va r neighbor node va exists
node c va c b r successor c similarly g ncf
node x vc g neighbor exists node c va c x
g successor c paths u notion u neighbor defined obvious way
define sequence equivalence relations va follows
va
b va n n l l b

ia

b va c va f naf
b f ia neighbors c
b va u un keyfor c k
ui ia neighbors xi n
ui ia neighbors yi b n
c l l b xi yi n
finally set






define

c x vc va g ncf
x g neighbors


filutz areces horrocks sattler

definition reflects mentioned tight coupling concrete abstract equalities tester finds guesses two concrete nodes equal
tableau may use deduce via computation c even
equalities concrete nodes
let key admissible concrete domain decide satisfiability alcok concept c w r boolean key box k nnf tableau started
initial completion tree
tc c
initial completion system
sc tc p
p maps p occurring c introduce operation
used completion rules add nodes completion trees
definition operation abstract concrete node called fresh completion tree appear let p completion system
va vc e l use following notions
let va b oa fresh r nr write arb denote completion
system obtained adding b va b e setting
l b r l b moreover b inserted b c implies
levt b levt c
let va x oc fresh g ncf write agx denote completion
system obtained adding x vc x e setting
l x g
nesting operation omit brackets writing example ar b br c
ar b br c let u f fn g path va x oc fresh
use aux denote completion system obtained taking distinct
nodes b bn oa fresh setting
aux af b bn fn bn bn gx
strictly speaking arb operation non deterministic since specify
precisely node b inserted however since dont care non determinism
view operation deterministic
completion rules found figure note rt rch rules
non deterministic e one possible outcome true dont know
non determinism remarks completion rules order upper
five rules well known existing tableau alc concept satisfiability
see e g lutz use r neighbors u neighbors rules
r r rc deserves comment take example r intuitively b
two abstract nodes b completion tree b describe
domain element constructed model similarly c relation concrete


fikeys nominals concrete domains

ru

c u c l c c l
l l c c

rt

c c l c c l
l l c c c c

r

r c l r neighbor b c l b
set arb fresh b oa l b c

r

r c l b r neighbor c
l b
set l b l b c

rc

u un p l exist x xn vc
xi ui neighbor n x xn p p
set au x aun xn x xn oc fresh
p p p p x xn

rch

u un keyfor c k exist x xn vc
xi ui neighbor n c c

l
set l l c c


rp

l b l va minimal w r b
set l l l b

figure completion rules alcok
nodes thus b c r successor c r successor
b however since want completion tree tree make latter
successorship explicit compensate r rule talks r neighbors
rather r successors
lower two rules necessary dealing key boxes rch rule
called choose rule hollunder baader horrocks et al intuitively
guesses whether abstract node satisfies c exists key assertion
u un keyfor c k neighbors paths ui
necessary since possibilities may ramifications satisfies c must
taken account construction relation satisfy c
must deal consequences satisfying c
e g case c
rp rule deals equalities abstract nodes recorded relation
since b means b describe node constructed model
node labels identical suffices however choose one representative
equivalence class make sure representatives node label contains
labels equivalent nodes representative use node minimal
w r ordering introduced solely reason rp rule
appropriate copying node labels
let us formalize means completion system contain contradiction
definition clash let p completion system concept c
key box k va vc say completion system concrete


filutz areces horrocks sattler

define procedure sat

contains clash
return unsatisfiable
test
compute
compute c

c
contains clash
return unsatisfiable
complete
return satisfiable

application completion rule
return sat
figure alcok tableau
domain satisfiable iff conjunction





p x xn

p used c x xn p p



x

xc

satisfiable said contain clash iff
va nc l
va x vc g l x g neighbor
concrete domain satisfiable
contain clash called clash free called complete iff completion
rule applicable
tableau described figure pseudo code notation figure test
calls tester specified definition let us say words loop
obviously exist close relationships relations c predicate
conjunction
c note c depend thus recomputed
step loop
definition tester test yields relation containing c
thus
facts one may check step loop tuples added
relation none deleted see proof lemma b appendix
loop needed defined ii c defined


fikeys nominals concrete domains

iii concrete equalities c may imply even concrete abstract
equalities
similar concrete abstract interplay takes place course several recursion steps
equalities concrete nodes provided tester may make rules applicable
example rp rc changes p thus may subsequently lead
detection equalities concrete nodes tester
considerations presence keys exists close interplay
concrete domain reasoner tableau needed keys
present without keys suffices apply concrete domain satisfiability check
completion rules exhaustively applied baader hanschke
detailed proof termination soundness completeness together complexity analysis tableau defined section given appendix b
theorem let key admissible concrete domain extended satisfiability
np alcok concept satisfiability w r boolean key boxes nexptime
note way presented leaves considerable
room optimizations one possible optimization concerns use f successors
abstract features f example applying r rule concept f c l
already f successor b could simply add c l b instead adding
f successor c recording b c
another candidate optimizations test function recall function takes
predicate conjunction c set variables v non deterministically returns concrete
equivalence e relation exists solution c vi vj iff
vi vj see definition hard devise alc concept forces
completion systems exponentially many concrete nodes slightly adapting alc concepts require exponential size halpern moses
hence size input conjunctions c test exponential size input
concept even trivial conjunctions
c v vk
exponential number distinct concrete equivalences thus number
possible outcomes call test function may double exponential size
input concept considering example natural response
require test return minimal concrete equivalences intuitively equivalence
minimal variables equivalent whose equality enforced conjunction
precisely called minimal exists concrete equivalence
x x x x conjecture restricting test way
destroy soundness completeness tableau however although
definitely worthwhile optimization help overcome existence
doubly exponentially many outcomes test worst caseat least concrete
domains consider concrete domain n page conjunctions form
ci v v
readily checked number minimal concrete equivalences
ci exponential moreover hard devise concept ci size logarithmic


filutz areces horrocks sattler

leads completion systems ci hence still doubly
exponentially many possible outcomes test function
example discussed exponential branching test clearly due
discreteness natural numbers indeed use dense structure defining concrete
domains seems restriction minimal concrete equivalences desired
effect namely number tests possible outcomes becomes polynomial size
input thus exponential size input concept example consider
concrete domain q defined follows
q set

q rational numbers

q contains unary predicates q negation q unary predicates q q
q binary comparison predicates ternary addition
predicate negation obvious semantics

q

readily checked q key admissible note provides binary equality predicate thus falls framework conjecture exists one minimal
concrete equivalence every q predicate conjunction c intuitively seems possible
inductively determine relation set variables v used c x
implies x every solution c ii exists solution c
v v implies v v clearly minimal concrete equivalence moreover
due one
tableau shoqk
although alcok quite powerful dl lacks several expressive means
found state art description logic systems fact racer horrocks
horrocks et al haarslev moller section consider
expressive description logic shoqk provides concrete domains key
boxes nominals many means expressivity transitive
roles role hierarchies qualifying number restrictions general tboxes modulo
details shoqk viewed extension dl shoq key boxes
shoq proposed horrocks sattler see pan horrocks
tool ontology reasoning context semantic web berners lee hendler
lassila baader et al
one important feature shoqk called tboxes e concept equations

form c used background theory reasoning since combining general tboxes concrete domain constructor easily leads
undecidability baader hanschke lutz shoqk offers pathfree variant concrete domain constructori e concrete features admitted
inside constructor rather paths arbitrary length restriction indeed regains
decidability haarslev et al horrocks sattler path freeness concrete
domain constructor obviously renders abstract features unnecessary thus syntactic
type available shoqk
tbox formalisms allow concept inclusions c v written
equivalent equations see section baader et al



fikeys nominals concrete domains

description logic shoqk
let us define shoqk formal way starting syntax
definition shoqk syntax role axiom role inclusion
form r v r nr transitivity axiom trans r r nr role
box r finite set role axioms let v
reflexive transitive closure role
inclusions r role name r called simple v
r implies trans
r role
names let concrete domain set shoqk concepts smallest set

every concept name every nominal concept
c concepts r role name simple role name n k natural
numbers g gn concrete features p predicate arity n
following expressions concepts
c c u c r c r c k c k c g gn p g

concept equation expression c c concepts tbox finite set
concept equations
shoqk consider key boxes differ two aspects ones considered alcok following assume key boxes path free admit
complex concepts occur key assertions note abstract features paths
occur syntax shoqk become clear semantics
defined former simulated general number restrictions n r c
usual description logics shiq shoq family require role names
number restrictions simple since admitting arbitrary roles yields undecidability
reasoning horrocks et al horrocks sattler role box r clear
context usually write trans r instead trans r r introduce
semantics shoqk relevant reasoning
definition shoqk semantics interpretations defined
definition function extended novel shoqk concepts
follows
k r c e e ri k
k r c e e ri k

let interpretation satisfies concept equation c c di
model tbox satisfies concept equations similarly satisfies role
inclusion r v ri transitivity axiom trans r ri transitive relation
model role box r satisfies role inclusions transitivity axioms r
let tbox r role box k key box concept c satisfiable w r
r k iff c r k common model c subsumed concept w r
r k written c vt r k iff c di common r k


filutz areces horrocks sattler

note due requirement role names used inside number restrictions
simple existential universal value restrictions syntactic sugar contrast
number restrictions used roles
well known many expressive description logics reasoning tboxes
reduced reasoning without schild horrocks sattler
shoqk concept c satisfiable w r r k iff concept
r c u r

u


de u

et

u

r n



nominal n used
c k

satisfiable w r r k empty tbox r fresh role appearing
c r

v r
r r trans r
role name used
c r k

since subsumption reduced satisfiability described section following
consider satisfiability concepts w r role boxes key boxes without
tboxes generally assume role boxes r acyclic e satisfy following
condition role name r role names r rk r r rk
ri v ri r k hard see restriction since
cycles eliminated r rk cycle r r rki
interpretations thus simply remove cycle r replace every
occurrence r rk c r k r add trans r cycle
elimination trans ri n
turn attention construction tableau shoqk
let us comment minor differences shoqk introduced
original version shoq described horrocks sattler main
difference logic extensions investigated haarslev et al pan
horrocks allows n ary predicates horrocks sattler restrict
unary predicates moreover shoq introduced horrocks sattler uses
concrete roles rather concrete features difference concrete roles
necessarily functional due non functionality original shoq admits two
variants p p concrete domain constructor concrete role
p unary predicate shoqk simulate universal variant writing
g p g since concrete features g interpreted partial functions contrast
horrocks sattler undefinedness constructor g available except
n ary predicates provide important additional expressivity view deviations
minor ones since easy see affect decidability complexity
reasoning
tableau shoqk
basic intuitions shoqk tableau similar alcok
one exception deal expressive means shoqk


fikeys nominals concrete domains

n r c
r c
n r c

n r c n

n r c

figure shoqk nnf rewrite rules
convenient introduce certain abstraction called tableaux main
difference tableaux tableaux roles declared transitive
necessarily described transitive relations exists tableau
given concept key box common model aim
shoqk construct tableau input rather trying
construct model employs completion forests underlying
data structure
first introduce tableaux let us start discussing preliminaries
alcok assume concepts key boxes nnf e negation occurs
front concept names nominals use c denote nnf c
additional nnf rewrite rules shoqk found figure complete
given alcok figure
concept role box r key box k define
cl k sub sub con k c
c sub sub con k
cl r k cl k r c r v
c cl k
obviously cardinality cl r k linear size r k
k
denote set role names occurring r k ncf
follows write nd r k
r
denote sets concrete features occurring k ready define
tableaux
definition tableau let shoqk concept nnf r role box k
path free key box nnf tableau w r r k tuple sa sc l e e p

sa sc sets abstract concrete individuals
l sa cl r k maps abstract individual subset cl r k
r k

e sa sa nr

maps pairs abstract individuals sets roles

e sa nd k
cf sc maps pairs abstract individuals concrete features concrete
individuals
p maps n ary concrete predicate cl r k set n tuples sc
abstract individual sa l
sa c c c cl r k r nd r k

r
c sa e c l
case


filutz areces horrocks sattler

c l c
l
c u c l c l c l
c c l c l c l
r e r v
e
r c l r e c l
r c l sa r e c l
c l r e r v
trans r r c l
n c l c n
n c l c n
n c l e g gn keyfor c k e gi
defined n c c l
n l l
g gn p l x xn sc e gi xi
x xn p p
v
v
v
p used k x xn p p p x xn x x satisfiable
g gn keyfor c k c l l e gi e gi n

g l e g undefined
note predicate conjunction uses binary inequality predicate general
require concrete domain equipped predicate thus
predicate conjunction necessarily conjunction however nevertheless safe
use given form since tableaux used proofs need
concrete domain reasoner capable deciding satisfiability conjunction
following lemma whose proof provided appendix c shows definition
tableaux provides adequate abstraction
lemma let shoqk concept nnf r role box k key box
nnf satisfiable w r r k iff tableau w r r k
given lemma order decide satisfiability shoqk concepts w r role
key boxes may use tableau tries construct tableau input
following describe detail
previous section works completion systems however
case shoqk core component completion systems completion forest
rather completion tree reason completion rules remove
nodes edges completion system way disconnect one tree
two subtrees


fikeys nominals concrete domains

definition completion system let shoqk concept nnf r role
box k path free key box nnf concept n r c cl r k
n reserve concept name anrc
appearing cl r k define

extended closure
nrc
cl r k cl r k anrc
n r c cl r k


let oa oc disjoint countably infinite sets abstract concrete nodes
completion forest r k finite forest f va vc e l nodes va vc
va oa vc oc nodes vc leaves forest labelled
follows
node va labelled subset l cl r k
edge b e b va labeled non empty set role names
l b occurring r k
edge x e va x vc labeled concrete feature l x
occurring r k
completion system r k tuple f p c
f va vc e l completion forest r k
p maps n ary concrete predicate cl r k set n tuples vc
c equivalence relation vc
linear ordering va
node va called r successor node va r r v
r
r l node x vc called g successor node va l x g finally

write
r successors node anrc
l

nrc
aj
l j
remarks order firstly contrast alcok case relation
longer required respect level node due fact
enforce termination artificially mentioned property used
ensure automatic termination b level node might change since node
might become root node completion rules remove nodes edges
secondly relation c returned tester used compute
relation used tableau however need
compute relation c alcok case since concepts key
boxes assumed path free
thirdly concept names anrc
used ensure successors node

x generated n r c l x merged later due concept
n r c l x generated successor labelled different concept anrc


since merging two nodes means unifying node labels suffices disallow


filutz areces horrocks sattler

occurrence distinct concepts anrc
node label suitable definition

clash
since shoqk provides transitive roles need cycle detection mechanism
order guarantee termination roughly speaking encounter
node similar already existing one node need
explored speaking terms horrocks et al baader sattler
employ mechanism called subset blocking
definition blocked let reflexive closure node va blocked
node va l l l l
note unlike done e g horrocks et al blocking node
necessarily ancestor blocked node anywhere forest may even
blocked nodes unblocked successors modification used later obtain
nexptime upper bound
decide satisfiability alcok concept w r role box r pathfree key box k k nnf tableau started
initial completion system
sd fd p
fd
p
maps p occurring k
repeatedly applies completion rules actual rules given
introduce notions firstly define equivalence relation va
follows one following conditions satisfied
n l l nominal n
g gn keyfor c k c l l xi yi gi e xi
e yi xi c yi n
intuitively two abstract nodes related via relation describe individual
tableau
secondly use following abbreviations formulation rules written
italic
remove abstract node incoming outgoing edges remove
va e va vc
adding g successor abstract node means nothing exists
g successor x vc otherwise adding e x g x oc
yet occur completion forest
update relation c tester asked decide satisfiability dconjunction



p x xn
x
p used k
x xn p p

xc

returns case conjunction satisfiable updated concrete equivalence c defined definition


fikeys nominals concrete domains

concerning predicate conjunction used updates recall w l g assume
concrete domain contain equality predicate discussed definition
completion rules given figure generally assume nodes x
introduced completion forest x already existing nodes
describing tableau comment completion rules
rules rt r rc rch non deterministic e application one
possible outcome rc rule due update operation performed c
tester discussed end section computing concrete equivalence
given conjunction may high degree non determinism please note
contrast alcok need call tester ruleand
rule application
next ra rule takes care abstract nodes related via since nodes
equivalence class denote individual choose one representative whose
node label contains labels nodes class representative simply
minimal node equivalence class ra rule performs appropriate
copying node labels
r rule rule remove nodes edges removes surplus r successor
node n r c l since subtree removed ts successors
additional root nodes behavior reason work completion
forest
alcok case tableau stops applying rules finds
obvious contradiction clash completion rules applicable
definition clash let f p c completion system r k
f va vc e l said contain clash one following conditions
applies
c concept name nc node va l
c conjunction defined satisfiable

c
va
c va g ncf g l g successor
completion system containing clash called clash free completion system
complete none completion rules applicable
due simplicity refrain describing pseudo code notation starts initial completion system repeatedly applies
completion rules checking clashes rule application clash detected returns unsatisfiable complete clash free completion system found
returns satisfiable note since completion rules
non deterministic non deterministic
details proof termination soundness completeness given appendix c unfortunately leave complexity open
hard prove runs double exponential time clear
whether exponential time suffices however still use obtain


filutz areces horrocks sattler

ru

c u c l blocked c c l
l l c c

rt

c c l blocked c c l
l l c c c c

r

r c l blocked r successor c l
create node va
set e r l c

r

n c l blocked n successors

tn c l ti ti
tj j n
create n nodes tn ti n va
set e ti l ti c ansc
n


r

n c l blocked n successors tn
c l ti n
choose j ti tj set l ti l ti l tj
l ti l ti l tj remove tj incoming
outgoing edges

rc

g gn p l blocked
gi successors xi x xn p p
add gi successor n
yi gi successor add yn p p
update c

r

r c l blocked
r successor c
l
l l c

r

c l blocked r
trans r r v
r successor r c
l
l l r c

rch

successor n c l
gi successors xi n g gn keyfor c k
blocked c c l
l l e e c c

ra

l l blocked
set l l l
figure completion rules shoqk



fikeys nominals concrete domains

tight complexity bound shoqk following corollary easy product
correctness proofs proof see appendix c
corollary shoqk concept satisfiable w r role box r path free
key box k satisfiable w r r k model size
cl r k
thus following alternative deciding satisfiability shoqk concept w r role box r path free key box k first guess interpretation
cardinality bounded placeholder variables oc instead
concrete values interpretation concrete features let vc set variables
oc occuring additionally guess interpretation p concrete domain
predicates completion forests p maps n ary concrete predicate used
k n ary relation vc perform standard polynomial time model checking
ensure model treat concepts form g gn p
interpretation predicates p easily checked polynomial time
model r kfor latter assume placeholder variables stand different
values finally use concrete domain tester check whether conjunction

p x xn
p used ind k
x xn p p

satisfiable answer yes otherwise since clearly
implemented nexptime provided tester running non deterministic
polynomial time obtain following
theorem let key admissible concrete domain extended satisfiability
np shoqk concept satisfiability w r tboxes role boxes path free
key boxes nexptime

conclusion
identified key constraints interesting extension description
logics concrete domains starting observation introduced number
natural description logics provided comprehensive analysis decidability
complexity reasoning main observation investigations key boxes
dramatic consequences complexity reasoning example pspacecomplete dl alc becomes nexptime complete extended path free unary
boolean key boxes undecidable extended path free unary non boolean key
boxes thus effect key boxes complexity quite different effect
key assertions abstract features allowed calvanese et al
abstract key assertions said free since increase complexity
expressive description logics
restriction boolean key boxes alcok case
path free key boxes shoqk case yield decidabile nexptime complete
reasoning selected alc shoq basis analysis since


filutz areces horrocks sattler

opinion fundamental description logics concrete domains
going one step would interesting combine key boxes extensions
concrete domains ones presented lutz name one
possibility extension alcok shoq inverse roles seems
natural idea note inverse roles interact several available means
expressivity alc inverse roles pspace complete horrocks sattler tobies
alco inverse roles exptime complete areces et al alc
inverse roles even nexptime complete lutz
options future closely related material presented
example shoqk concept satisfiability still decidable drop
requirement key boxes path free moreover leave exact time
requirements tableau open runs nondeterministic exponential time directly yields theorem rather via bounded
model property

acknowledgments
would thank anonymous reviewers valuable comments
extended version lutz areces horrocks sattler

appendix proofs section
prove satisfiability decided ptime
proposition satisfiability ptime
proof let c conjunction c satisfiable iff none following
conditions applies
c contains conjunct x
c contains conjuncts bit ik x bit ik x
c contains conjuncts bitnik x bitmj x k
c contains conjuncts bitnik x bitnik x
c contains conjuncts bitnik x bit jk x bit jk x
easily seen c unsatisfiable one conditions applies assume
conditions apply c let x set variables used c
x x set x k bitnik x c n bitnik x
c n k
set x r r appearing index r predicate c mapping
well defined since c finite condition apply predicates available
bitnik define solution c follows x x set
x bit vector v bvt x ith bit bit x x c bit x x c
otherwise remains prove indeed solution c

n

use p x c abbreviation p x conjunct c



n

fikeys nominals concrete domains

let bit ik x c x k thus x bvk since condition
c moreover non applicability condition implies
apply bit ik x

c definition ith bit x thus
bit k x
let bit ik x c x k x bvk definition ith bit
x
let bit ik x c x k x
bvk thus x bit ik
done x k ith bit x definition thus
x bit ik
bvk done x k
let bit ik x c x k x
j
bitnk x c n j since condition apply thus

n

c thus

c moreover non applicability condition yields bit ik x
definition ith bit x

bit ik x

obvious listed properties checked polynomial time

appendix b proofs section
prove termination soundness completeness alcok tableau
presented section starting termination start establishing notions
technical lemmas
let c concept k key box use c denote
p length c e
number symbols used write k denote u uk keyfor c k c
path u f fk g use u denote k role depth concepts defined
inductively follows
rd rd n rd g
rd u un p max ui n
rd c u rd c max rd c rd
rd r c rd r c rd c
following series lemmas eventually allow us prove termination
lemma b constant k tableau started input
c k va vc e l completion tree constructed run
k
k
va c vc c
proof induction number rule applications case distinction according
applied rule straightforward
c l implies rd c c levt



constructed completion trees omit details note treating
rch rule one needs employ fact k boolean thus adds concepts
role depth node labels treating rp rule use b implies
levt levt b


filutz areces horrocks sattler

implies upper bound depth constructed completion trees first
r rc rules generate nodes application rule node
va implies l thus levt c second abstract
concrete node b generated application rules node va clearly satisfies
levt b levt max mpl c mpl c denotes maximum length paths
c note concepts k may contain paths since boolean since
mpl c c observations imply depth constructed completion
trees bounded c
degree node generated due application
rule r rc initially one successor let us analyze number
successors generated later applications rules r rc rules
applied concept form r c u un p l
definition cl c k since k boolean number concepts per node
label bounded sub c c moreover rule application creates c
successors hence degree constructed completion trees bounded c

lemma b constant k tableau started c k
k
every recursion step loop terminates c steps
proof fix argument p va vc e l passed sat function
let sequence concrete equivalences computed loop let
c c corresponding c relations since test calls tester
calls indeed terminates



k

implies lemma b lemma b exists constant k vc c
k
hence c together implies number steps
k
performed loop bounded c
proof loop reaches th step
c
step since
definition implies ci definition
c
easy see
hence
c
lemma b constant k tableau started c k
k
number recursive calls bounded c k
proof obviously suffices establish appropriate upper bound number rule
applications ru rt r rc rules applied concept
node label lemma b number nodes exponential c k
since neither nodes concepts node labels ever deleted fact node labels
subsets cl c k thus implies number applications rules
exponential c k holds rules r rp applied
every concept c cl c k every pair abstract nodes finally
number rch applications exponential c k since rule
applied every abstract node every key assertion k


fikeys nominals concrete domains

termination obvious consequence lemmas b b
corollary b termination tableau terminates input
let us prove soundness
lemma b soundness tableau returns satisfiable input concept
c satisfiable w r input key box k
proof tableau returns satisfiable exists complete clashfree completion system p c let va vc e l definition
tableau completion system p call
test returned moreover c thus exists solution

x iff x c


clearly solution since
second
component p
solution first part
p x xn moreover
p used c x xn p p

conjunct x second part x c definition
thus x
use construct interpretation setting


va b va b b w

ai

l

n l n l

w
otherwise

ni
ri

b b va b b
b r successor

gi

x x g neighbor

nc n r nr g ncf first well defined
n singleton n assume exist b b
n l l b definition definition n l l b implies
b together b yields b b contradicting
linear ordering
f functional f naf assume exist b c
b c f b c exist b c va
b b c c b f successor c f successor
definition thus b c implying b c since b c yields
b c c b contradiction
g functional g ncf assume exist x vc
x f x x g neighbors definition c thus x c implying x
contradiction


filutz areces horrocks sattler

following claim proof use notion f fk neighbors
f fk abstract features defined analogously u neighbors paths u
claim paths u ui iff ui neighbor
x x
proof let u f fk g induction easily proved
b fii f b iff f neighbor b
b b thus particular fki f b iff f fk neighbor b b b prove claim hence remains use definition
g together
following claim central showing model c k
claim c cl c k c l c
since c label root node claim clearly implies model c
moreover use prove satisfies key assertions u un keyfor c
k fix b c uii uii b n non applicability rch yields
c c l c l claim implies c contradiction
c thus obtain c l analogous way argue c l b since
uii uii b defined n claim yields ui neighbor xi
xi uii b ui neighbor yi yi uii b n thus
fact uii uii b yields xi yi n obtain xi c yi
thus xi yi n definition thus get b since b
obtain b b definition thus b
remains prove claim structural induction
c concept name nominal easy construction
c since c cl c k c nnf concept name since
clash free c l implies
l thus
di construction

yields
c u un p since rc rule applicable exist x xn vc
xi ui neighbor n x xn p p claim
yields uii xi n since x xn p p solution
x xn p thus c
c g since clash free exists x vc x g neighbor
thus claim g
c u e c e straightforward completeness induction
hypothesis
c r since r rule applicable r neighbor b
l b let b minimal w r b b definition
b ri non applicability rp rule yields l b induction get
b di thus c


fikeys nominals concrete domains

c r let b ri definition implies exist b va
minimal w r b minimal w r b b b
r successor since b clearly r neighbor non applicability
r yields l b implies l b due non applicability rp
induction get b di since holds independently choice b obtain
r

lemma b completeness input concept c satisfiable w r input key box
k tableau returns satisfiable
proof let model c k use guide non deterministic parts
constructs complete clash free completion system
completion system p va vc e l called compatible
exist mappings va vc
ca c l c
cb b r successor b ri
cc x g successor g x
cd x xn p p x xn p
ce x x
first establish following claim
claim completion system compatible b implies b
ii x c implies x
proof induction ia b implies b see definition
yields
start b exists nominal n n l l b ca
obtain n b n yields b definition
semantics
step ia b distinguish three cases

b b induction

c va f naf b f
neighbors
c f successor
c hence exist c c va c
c





c b f successor c induction c c c
thus cb yields c c b f implies b
definition semantics
exist u un keyfor c k ui ai neighbors xi ui ai neighbors yi b n c l l b xi yi n
ca yields b c induction cb cc straightforward


filutz areces horrocks sattler

uii xi uii b yi n ce
implies uii uii b k since model key box k
yields b definition semantics
part ii claim x c x va g ncf
x g neighbors former case ce yields x
latter case part claim cc yields x g
implies x finishes proof claim
completion rules applied compatibility
preserved
claim completion system compatible rule r applicable r
applied compatible completion system obtained
proof let compatible completion system let functions satisfying
ca ce let r completion rule applicable make case distinction
according type r
ru rule applied concept c u c l ca c u c l implies
c u c hence c c since rule adds c
c l yields completion system compatible via
rt rule applied c tc l c tc l implies c c
since rule adds c c l applied yields
completion system compatible via
r rule applied concept r c l generates r successor b
sets l b c ca r c hence exists
ri c set b readily checked
resulting completion system compatible via
r rule applied concept r c l adds c l b existing
r neighbor b hence exists b rsuccessor part claim thus ca
r c cb yields b ri definition semantics
b c thus resulting completion system compatible via




rc rule applied concept u un p l ui f fki gi


n rule application generates abstract nodes bj xj n
j ki








b f successor n


bj fj successor bj n j ki


xi gi successor bki n
x xn p p


fikeys nominals concrete domains



ca u un p hence exist dj n
j ki n








f n


dj dj fj n j ki


gii dki n
n p




set jki bj dj xi
resulting completion system compatible via
rch rule applied abstract node key assertion u un keyfor c
k non deterministically adds c c definition semantics
c c hence rch applied resulting
completion system compatible via
rp rule applied concept c l adds c label l b node b
b ca c since claim yields b follows
resulting completion system compatible via
finally compatibility implies clash freeness
claim every compatible completion system clash free
proof let p compatible completion system consider three
kinds clash
due ca clash form l clearly contradicts semantics
assume va x vc g l x g neighbor
exists b va b x g successor b claim
b implies b thus g l ca give b g obtain
contradiction since cc yields b x g
properties cd ce part ii claim imply solution
thus concrete domain satisfiable
describe guidance tableau model detail
ensure times considered completion systems compatible
obviously holds initial completion system
sc tc p tc c
guide non deterministic test function given predicate conjunction
set variables vc oc input returns relation defined setting x
iff x x v relation concrete equivalence since solution
see guidance ce obviously satisfied call test
properties affected call according claim apply


filutz areces horrocks sattler

completion rules compatibility preserved corollary b
terminates hence guided way since claim
clash returns satisfiable
tableau yields decidability tight upper complexity bound alcok concept satisfiability w r key boxes
theorem b theorem section let key admissible concrete domain
extended satisfiability np alcok concept satisfiability w r boolean
key boxes nexptime
proof corollary b lemmas b b yield decidability alcok concept
satisfiability w r boolean key boxes complexity lemma b provides exponential
bound number recursive calls hence remains single recursion
step needs exponential time lemma b loop terminates
exponentially many steps step compute relations c
used construction predicate conjunction checking termination
loop since lemma b exists exponential bound number
abstract concrete nodes completion system obviously done
exponential time moreover lemma b implies size exponential
together fact extended satisfiability np implies call
test needs exponential time remaining tasks checking clashes completeness
rule applicability clearly performed exponential time

appendix c proofs section
first provide proof lemma shows notion tableaux introduced
section adequate abstraction
lemma c lemma section let shoqk concept nnf r
role box k path free key box nnf satisfiable w r r k iff
tableau w r r k
proof direction construct tableau common model
r k follows
sa
sc x g x sa
l c cl r k c
e nd r k

r
e g g g defined
p p x xn snc x xn p
easily verified tableau w r r k proof satisfies
identical corresponding cases horrocks et al horrocks
sattler holds definition l definition l fact
nominals interpreted singleton sets definition l e p together


fikeys nominals concrete domains

semantics concepts g gn p since identity function sc clearly
solution listed predicate conjunction definition l e together
semantics key constraints finally definition l e together
semantics concepts g
direction let sa sc l e e p tableau w r r k
let solution predicate conjunction construct model
follows


sa

ai

l

concept names

ni

n l nominals n


r nr ncf trans r
v
r r e

r
r
r e
r nr ncf trans r

x
e g x
g
g ncf
undefined e g undefined
due interpretation nominals singleton moreover interpretation
roles well defined since role boxes acyclic following claim central proving
indeed model r k
claim c cl r k c l implies c
proof proceed induction norm c c defined follows

g
c u c
n r c







u un p
c c
n r c






concept name

c c
c

concept names nominals n claim follows definition ai n
negation concept names nominals n note c nnf claim follows
definition ai n together concepts c form c u c c c
treated together induction hypothesis existential
universal number restrictions proof analogous one shiq horrocks
et al concepts form c g gn p l c immediate
consequence definition gii fact x xn p p implies
x xn p finally concepts c g c immediate
consequence definition g together finishes proof
claim
definition tableaux exists sa c l claim
c thus model c
next model r definition ri obvious trans r
r implies ri transitive relation let v r r trans r
r
ri definition ri let trans r r e
implies r e thus ri otherwise v

trans r u v e u v together v
r implies


filutz areces horrocks sattler

u v e u v u v r e u v thus trans r r implies
ri
remains model k end let g gn keyfor c k
c gii gii n since predicate conjunction
contains explicit inequalities distinct concrete individuals implies
e gi e gi n implies c c l c c l
c l claim yields c contradicting c thus obtain
c l similar way c l finally implies thus
satisfies k
proceed prove termination soundness completeness tableau
presented section starting termination following use r k
denote cl r k recall number polynomial size r k
lemma c termination let key admissible concrete domain started
shoqk concept nnf role box r path free key box k nnf
tableau terminates
proof assume r k tableau terminate since key admissible means infinite sequence
completion systems initial completion system sd b si
applying completion rule si
possible r r rules applied infinitely often easily seen
rules ru rt r rc r r rch ra applied finitely often
completion systems whose set abstract nodes va increase since
add concepts node labels whose size bounded add concrete nodes whose
number bounded linearly number abstract nodes remove abstract
nodes forest hence sub sequence si si
sij applying r r rule sij let si abstract node
r r rule applied si since implies
generated linear ordering well founded thus infinite subsequence sj sj si si sj sj sj sj
former however possible since r r rules
applied per node concept cl r k even node removed
label copying performed r rule together clashes type c ensures
r rule applied concept node thus second option
remains subsequence sj sj si si sj sj
let lj labeling function sj since abstract node labeled
subset lj cl r k nodes sjk sj k ljk sjk lj sj
node labels increase node removed label conjoined
label node thus node completion system sj
sj lj sj lj definition sj thus blocked sj contradicting
assumption r r rule applied sj sj
lemma c soundness expansion rules applied shoqk concept
nnf role box r path free key box k yield complete
clash free completion forest tableau w r r k


fikeys nominals concrete domains

proof let va vc e l p c complete clash free completion system
solution x iff x c rc rule updates
predicate conjunction rule application c relation updated
concrete equivalence tester returns note satisfiable due
clash freeness according definition thus solution required
define finite tableau sa sc e l p follows
sa va occurs blocked
sc x x e g sa g
l l cl r k intersection due auxiliary concepts anrc


e r r successor blocks r successor

x
x g successor
e g
undefined x g successor
p restriction p sc
note function e well defined due definition adding g successors
remains satisfies basically consequence
clash free complete
satisfied since contain clash c
satisfied since ru rule cannot applied thus c u c l implies
c c l
satisfied since rt rule cannot applied thus c c l implies
c c l
consider sa r e r v
r r e implies
blocks r successor definition successor blocks
r successor thus r e
let r c l r e r successor
blocked implies c l since r rule cannot applied blocks
r successor blocked fact r rule cannot
applied yields c l blocking condition implies c l
cases thus c l
satisfied reasons r replaced r
r
consider n r c l hence n r c l
completeness implies existence r successors tn c l ti

ti
tj j latter implies j existence integers k
k anrc
l ti anrc
l tj satisfied remains
k

verify
ti block tj case blocking condition would imply
anrc
anrc
l ti
k



filutz areces horrocks sattler

block ti tj j similarly would imply
anrc
anrc
l
k

case would clash c contradiction clash free
consider n r c l hence n r c l since
r rule cannot applied n r successors ti since
ti blocked blocked exactly one node due linear
ordering n ui sa r e ui c l ui
let n r c l r e hence n r c l
r successor blocks r successor first case nonapplicability rch rule implies c c l second case
c c l r successor blocked thus blocking
condition yields c c l cases implies c c l
next consider g gn keyfor c k e gi defined
hence gi successor thus blocked nonapplicability rch rule imply c c l
consider n l l definition n l l thus
moreover totality implies assume without loss generality
thus non applicability ra rule implies l l
thus blocked implies
satisfied since rule rc cannot applied
clash freeness implies satisfiability




p x xn

p used k x xn p p

choice x iff x c thus satisfied
let g gn keyfor c k c l l e gi e gi
n thus c l l choice e xi c yi
gi e xi e yi hence without loss generality assume
thus non applicability ra rule implies l l
thus blocked implies
satisfied definition since contain clash c

lemma c completeness shoqk concept nnf tableau w r
role box r path free key box k expansion rules applied r
k yield complete clash free completion forest


fikeys nominals concrete domains

proof given tableau sa sc l e e p w r r k guide
non deterministic rules rt rch ra way rule application preserves
clash freeness together termination lemma c finishes proof
along rule application perform stepwise construction total mapping
takes abstract nodes completion forest elements sa concrete nodes
completion forest elements sc
l cl r k l va
r successor r e
x g successor e g x
x c iff x



mapping satisfying four conditions called correct following note
completion system exists correct mapping contain clash due
first property encounter clash c clash c cannot occur
due last property first third property together ensure
clash c occur finally clash c cannot occur following reason
construction p since edges labelled abstract features never removed
tuple x xn p p abstract node paths u un
u un p l xi ui successor n thus first second
third property together ensure conjunction

p x xn
p used ind k
x xn p p

solution x x iff x fourth property setting
x x x vc thus yields solution
total mapping inductively defined follows let solution equation
choose node l set node
initial completion forest obviously correct completion
rule applied way still correct extended
correct mapping
application rule ru preserves correctness due
due rule rt applied correctness preserved
rule r adds node r c l correctness implies r c
l thus implies existence sa r e
c l thus extending obviously yields correct mapping
rule r adds n nodes ti n r c l correctness implies
n r c l thus implies existence tn sa
ti tj j r e ti c l ti thus extending ti ti
obviously yields correct mapping


filutz areces horrocks sattler

assume r rule applicable node n r c l
n r successors ti c l ti correctness implies n r c
l r e ti c l ti thus j

ti tj correctness implies ti
tj without loss generality assume ti tj hence applying rule thereby merging l tj
l ti preserves correctness
rule rc extended similar way r gi successor xi
added extending xi e gi yields correct moreover
ensures c updated way fourth condition
preserved
r rule need extended definition
r successors imply correctness preserved
r rule similar difference takes place
due rule rch applied without violating correctness
ra consider two reasons ra applicable
n l l correctness imply
g gn keyfor c k c l l gi e xi e yi
xi c yi n correctness implies e gi e gi
thus together first property correctness imply
cases applying ra preserves correctness

immediate consequence lemmas c c c tableau
terminates answers satisfiable w r r k input
concept satisfiable w r input role box r input key box k since concept
satisfiability w r tboxes reduced concept satisfiability without tboxes
obtain following
proposition c let key admissible concrete domain tableau
decides satisfiability shoqk concepts w r tboxes role boxes path free key
boxes
hard verify proof lemma c together lemmas c
yield bounded model property shoqk bound exponential
corollary c shoqk concept satisfiable w r role box r pathfree key box k satisfiable w r r k model size
cl r k


fikeys nominals concrete domains

proof shoqk concept satisfiable w r role box r path free key
box k lemma c implies tableau constructs complete clash free
completion forest r k definition blocking number abstract
nodes completion forest blocked bounded va
abstract nodes completion forest l l blocks blocks
blocked another node u moreover easily seen number
concrete successors per abstract node bounded number concrete features c r
k proof lemma c abstract nodes tableau constructed
complete clash free completion forest coincide nodes blocked
completion forest finally proof lemma interpretation domain
model constructed tableau coincides abstract nodes tableau
summing shoqk concept satisfiable w r r k model size


references
areces c blackburn p marx road map complexity hybrid logics
flum j rodrguez artalejo eds computer science logic
lecture notes computer science pp springer verlag
baader f horrocks sattler u description logics semantic web ki
kunstliche intelligenz
baader f lutz c sturm h wolter f b fusions description logics
abstract description systems journal artificial intelligence jair

baader f sattler u description logics concrete domains aggregation prade h ed proceedings th european conference artificial
intelligence ecai pp john wiley sons
baader f calvanese mcguinness l nardi patel schneider p f
description logic handbook theory implementation applications cambridge university press cambridge usa
baader f hanschke p scheme integrating concrete domains concept
languages proceedings th international joint conference artificial
intelligence ijcai pp sydney australia
baader f hanschke p b scheme integrating concrete domains concept
languages dfki report rr german center artificial
intelligence dfki
baader f hanschke p extensions concept languages mechanical
engineering application proceedings th german ai conference gwai vol lecture notes computer science pp springer verlag
baader f sattler u tableau description logics dyckhoff
r ed proceedings international conference automated reasoning
tableaux related methods tableaux vol lecture notes artificial
intelligence pp springer verlag


filutz areces horrocks sattler

berger r undecidability domino memoirs american
mathematical society
berners lee hendler j lassila semantic web scientific american

borger e gradel e gurevich classical decision perspectives
mathematical logic springer verlag
borgida patel schneider p f semantics complete
subsumption classic description logic journal artificial intelligence
borgida weddell g e adding uniqueness constraints description logics
preliminary report bry f ramakrishnan r ramamohanarao k eds
proceedings th international conference deductive object oriented
databases dood vol lncs pp springer
calvanese de giacomo g lenzerini decidability query
containment constraints proceedings th acm sigact sigmodsigart symposium principles database systems pods pp
calvanese de giacomo g lenzerini keys free description logics
baader f sattler u eds proceedings international workshop
description logics dl ceur ws http ceur ws org pp
calvanese lenzerini nardi description logics conceptual data
modeling chomicki j saake g eds logics databases information
systems pp kluwer academic publisher
dean connolly van harmelen f hendler j horrocks mcguinness l
patel schneider p f stein l web ontology language owl reference
version w c working draft
fensel van harmelen f horrocks mcguinness l patel schneider p f
oil ontology infrastructure semantic web ieee intelligent
systems
graham r l knuth e patashnik concrete mathematics addison
wesley publ co reading massachussetts
haarslev v lutz c moller r foundations spatioterminological reasoning
description logics cohn schubert l c shapiro eds proceedings
th international conference principles knowledge representation
reasoning kr pp morgan kaufman
haarslev v moller r racer system description gore r leitsch
nipkow eds proceedings st international joint conference
automated reasoning ijcar lecture notes artificial intelligence
pp springer verlag
haarslev v moller r wessel description logic alcn hr extended
concrete domains practically motivated gore r leitsch


fikeys nominals concrete domains

nipkow eds proceedings st international joint conference automated reasoning ijcar lecture notes artificial intelligence pp
springer verlag
halpern j moses guide completeness complexity modal
logics knowledge belief artificial intelligence
hollunder b baader f qualifying number restrictions concept languages
proceedings nd international conference principles knowledge representation reasoning kr pp boston usa
hopcroft j e ullman j introduction automata theory languages
computation addison wesley
horrocks sattler u tobies practical reasoning expressive description logics logic journal igpl
horrocks expressive description logic fact fiction proceedings
th international conference principles knowledge representation
reasoning kr pp
horrocks reasoning expressive description logics theory practice
voronkov ed proceedings th international conference automated
deduction cade lecture notes artificial intelligence pp
springer
horrocks patel schneider p f van harmelen f reviewing design
daml oil ontology language semantic web proceedings th
national conference artificial intelligence aaai pp
horrocks sattler u ontology reasoning shoq description logic
nebel b ed proceedings th international joint conference artificial
intelligence ijcai pp morgan kaufmann
horrocks sattler u tobies practical reasoning expressive description
logics ganzinger h mcallester voronkov eds proceedings
th international conference logic programming automated reasoning
lpar lecture notes artificial intelligence pp springerverlag
kamp g wache h ctl description logic expressive concrete domains
tech rep lki laboratory artificial intelligence lki universitity
hamburg germany
khizder v l toman weddell g e decidability complexity description logics uniqueness constraints den bussche j v vianu v eds
proceedings th international conference database theory icdt vol
lncs pp springer
knuth art computer programming vol addison wesley
lutz c description logics concrete domainsa survey advances modal
logics pp world scientific publishing co pte ltd


filutz areces horrocks sattler

lutz c complexity reasoning concrete domains ph thesis
lufg theoretical computer science rwth aachen germany
lutz c b pspace reasoning description logic alcf logic journal
igpl
lutz c c reasoning entity relationship diagrams complex attribute
dependencies horrocks tessaris eds proceedings international
workshop description logics dl ceur ws http ceurws org pp
lutz c nexptime complete description logics concrete domains acm
transactions computational logic
lutz c areces c horrocks sattler u keys nominals concrete
domains ltcs report technical university dresden see http lat inf tudresden de reports html
lutz c areces c horrocks sattler u keys nominals concrete
domains proceedings th international joint conference artificial intelligence ijcai pp morgan kaufmann publishers
pan j z horrocks reasoning shoq dn description logic horrocks tessaris eds proceedings international workshop description logics dl ceur ws http ceur ws org pp
post e variant recursively unsolvable bulletin american
mathematical society
schild k correspondence theory terminological logics preliminary report
mylopoulos j reiter r eds proceedings th international joint
conference artificial intelligence ijcai pp morgan kaufmann
schmidt schau smolka g attributive concept descriptions complements artificial intelligence




