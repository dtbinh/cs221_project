Journal Artificial Intelligence Research 42 (2011) 5590

Submitted 04/11; published 09/11

APP: Scalable Multi-Agent Path Planning Algorithm
Tractability Completeness Guarantees
Ko-Hsin Cindy Wang
Adi Botea

C INDY.WANG @ RSISE . ANU . EDU . AU
DI .B OTEA @ NICTA . COM . AU

NICTA & Australian National University,
Canberra, Australia

Abstract
Multi-agent path planning challenging problem numerous real-life applications. Running centralized search A* combined state space units complete
cost-optimal, scales poorly, state space size exponential number mobile units.
Traditional decentralized approaches, FAR W HCA *, faster scalable,
based problem decomposition. However, methods incomplete provide guarantees respect running time solution quality. necessarily able tell
reasonable time whether would succeed finding solution given instance.
introduce APP, tractable algorithm multi-agent path planning undirected graphs.
present basic version several extensions. low-polynomial worst-case upper
bounds running time, memory requirements, length solutions. Even though
algorithmic versions incomplete general case, provides formal guarantees
problems solve. version, discuss algorithms completeness respect
clearly defined subclasses instances.
Experiments run realistic game grid maps. APP solved 99.86% mobile units,
1822% better percentage FAR W HCA *. APP marked 98.82%
units provably solvable first stage plan computation. Parts APPs computation
re-used across instances map. Speed-wise, APP competitive significantly
faster W HCA *, depending whether APP performs computations scratch.
data APP re-use preprocessed offline readily available, APP slower
fast FAR algorithm factor 2.18 average. APPs solutions average 20%
longer FARs solutions 731% longer W HCA *s solutions.

1. Introduction
Path planning important many real-life problems, including robotics, military operations, disaster rescue, logistics, commercial games. Single-agent path planning, size state
space bounded size map, tackled search algorithm A* (Hart,
Nilsson, & Raphael, 1968). However, many units moving simultaneously inside
shared space, problem becomes much harder. centralized search initial state goal
state difficult problem even inside fully known, two-dimensional environment represented
weighted graph, one node occupied exactly one unit time. Assuming
units size, unit moves synchronously adjacent unoccupied node one
time step, problems state space grows exponentially number mobile units. Existing
hardness results shown NP-complete decide solution k moves exists (Ratner & Warmuth, 1986), optimize solution makespan (Surynek, 2010b). version
problem one robot movable obstacles several nodes, either robot
c
2011
AI Access Foundation. rights reserved.

fiWANG & B OTEA

obstacle move adjacent vacant node per step, NP-complete (Papadimitriou,
Raghavan, Sudan, & Tamaki, 1994). Yet another version problem, determining solution exists moving two-dimensional rectangles different sizes inside box, shown
PSPACE-hard, even without requiring optimality (Hopcroft, Schwartz, & Sharir, 1984). Despite completeness solution optimality guarantees, centralized A* search little practical
value multi-agent path planning problem, intractable even relatively small maps
collections mobile units.
Scalability larger problems achieved decentralized approaches, decompose
global search series smaller searches significantly reduce computation. However,
existing decentralized methods FAR (Wang & Botea, 2008) W HCA * (Silver, 2006)
incomplete, provide formal criteria distinguish problem instances
successfully solved instances. Further, guarantees given respect running
time quality computed solutions.
work present algorithm combines strengths worlds: working well
practice featuring theoretical tractability partial completeness guarantees. introduce
APP, tractable multi-agent path planning algorithm undirected graphs. problem instance, APP systematically identifies set units, contain units instance,
guaranteed solved within low-polynomial time. sake clarity distinguish
basic version extended versions APP. APP provides formal guarantees
problems solve. Basic APP algorithm complete class problems, called
LIDABLE, define Section 3. Extended versions algorithm enlarge completeness range, discussed Section 7, improve solution length, discussed Section 8.
evaluate version attempts solve units, provably solvable ones.
Given problem graph nodes n mobile units, APPs worst case performance
running time O(m2 n2 ), even smaller (e.g., O(max(mn2 , m2 log m))), depending
assumptions input instance. worst-case memory requirements within O(m2 n)
even O(mn). upper bound solution length, measured total number moves,
order O(m2 n2 ) even O(mn2 ). See Section 6 detailed discussion.
APP keeps running costs low eliminating need replanning. path (u)
unit u computed beginning. replanning required runtime. blank travel
idea, inspired way blank moves around sliding tile puzzles, center
u
algorithm. unit u progress current location liu next location li+1
path
u
(u) blank located (i.e., li+1 empty). Intuitively, next location currently
occupied another unit, APP tries bring blank along alternate path, outlined bold
u
u
li+1
without passing liu . possible, blank
Figure 1, connects li1
u
brought li+1 shifting units along alternate path, blank travels sliding tile
puzzle. ability bring blank next location key guarantee units progress. Formal
details provided Section 5.
performed detailed experiments, evaluating different versions APP comparing
APP fast incomplete methods FAR W HCA * grid maps. results
presented Section 9. benchmark data (Wang & Botea, 2008) consist 100 2000 mobile
units uniformly randomly generated 10 game maps, 10 scenario instances per number
units map. conclude extended APP significantly better success ratio
scalability state-of-the-art incomplete decentralized algorithms. particular, APP solves
higher percentage units even crowded instances. Despite APPs incompleteness
56

fiM APP : CALABLE ULTI -AGENT PATH P LANNING



b

u

l


u

c

b
c

Figure 1: left, unit u blocked a. blank found location l along alternate
path, marked bold contour. right: sliding b along
u . sake clarity simplicity,
alternate path, blank brought li+1
illustrate examples four-connected grid world.

general case, algorithm marks 98.82% units provably solvable first stage
plan computation. attempting solve units, provably solvable ones, APP
succeeds 99.86% units. comparison, FAR solved 81.87% units. W HCA * solved
77.84% (with diagonal moves allowed) 80.87% (with diagonal moves) units. Even
challenging instances 2,000 mobile units maps, 92% 99.7% mobile units test
data fall within APPs completeness range (i.e., provably solvable). terms percentage fully solved instances, version APP attempts solve units,
provably solvable, successful 84.5% instances. significantly better
FAR (70.6%), W HCA * diagonal moves (58.3%), W HCA * diagonals (71.25%).
Parts APPs computation re-used across instances map. instances
solved algorithms, APP competitive speed significantly faster W HCA *, depending whether APP performs computations scratch. re-usable data
available, APP slower fast FAR algorithm factor 2.18 average. APPs
solutions reported average 20% longer FARs solutions 731% longer
W HCA *s solutions.
Parts work reported shorter conference papers follows. theoretical
description Basic APP, experiments, provided earlier paper (Wang & Botea,
2009). brief overview APP extensions brief summary initial results topic
two-page paper (Wang & Botea, 2010). New material added current paper includes detailed
algorithmic description enhancements Basic APP formal proofs algorithms
properties. provide comprehensive empirical analysis enhanced APP, several
additional experiments.
rest paper structured follows. Next briefly overview related work. Then,
state problem definition Section 3. Sections 46 focus Basic APP. Sections 7
8 cover enhancements Basic APP algorithm, extending completeness range (Section 7),
57

fiWANG & B OTEA

improving quality plans running time (Section 8). empirical evaluation
topic Section 9. last part contains conclusions future work ideas.

2. Related Work
Finding shortest path connects single pair start-target points known, finite map
optimally solved A* algorithm (Hart et al., 1968). extension path planning
multiple simultaneously moving units, distinct start target positions, introduces potential
collisions due physical constraint one location occupied one unit
time. Units interact share information units path planning, making
problem complex.
multi-agent path planning, centralized A* performs single global search combined
state space L1 L2 Ln n units, Li set possible locations unit i.
Centralized A* plans paths units simultaneously, finding joint plan containing units
actions (waits well moves). retains optimality completeness guarantees A*,
prohibitively large state space O(mn ) states, n units graph nodes. Moreover,
search nodes generated unpromising, taking units farther goal (Standley,
2010). poses strong limiting factor problems centralized A* solve practice.
hand, purely decentralized method, Local Repair A* (L RA *) (Stout, 1996) first
plans units path independently A*. Then, execution, L RA * replans additional
independent A* searches every time collision occurs. good case, L RA * significantly
reduce computations O(mn). However, generate cycles units, unable
prevent bottlenecks. problems discussed Silver (2005), Bulitko, Sturtevant, Lu,
Yau (2007), Pottinger (1999), Zelinsky (1992). cases, L RA * exhibits significant
increase running time may terminate. Therefore, straightforward extensions
single-agent A* outlined strong limitations practice.
Traditionally, multi-agent path planning took centralised decentralised approach (Latombe,
1991; Choset et al., 2005). centralized approach plans globally, sharing information centrally,
using potential field (Barraquand, Langlois, & Latombe, 1991). contrast, decentralized approach decomposes problem series smaller subproblems, typically first computing units paths individually, ignoring units, handling interactions online.
Examples robotics include computing velocity profiles avoid collisions units (Kant
& Zucker, 1986), pre-assigning priorities process robots one one (Erdmann & LozanoPerez, 1986). Recent algorithms use combination two approaches. instance,
Biased Cost Pathfinding (BCP) technique (Geramifard, Chubak, & Bulitko, 2006) generalised
notion centralized planning central decision maker resolves collision points paths
pre-computed independently per unit, replanning colliding units around highestpriority unit. avoid excessively long (or even potentially unbounded) conflict resolutions, limit
planning time set. BCP returns paths fewest collisions within time. algorithm
shown work well small-scale gridworld scenarios, complete optimal
general case. Standleys (2010) algorithm, hand, improved standard centralized
search whilst preserving optimality completeness. new state space representation incorporates next move assignments every unit state, decomposes timestep
advancing units advancing units one one fixed ordering. Thus branching factor
reduced 9n 9, increasing depth search factor n. technique gen58

fiM APP : CALABLE ULTI -AGENT PATH P LANNING

erates 9nt state nodes perfect heuristic (t number timesteps
optimal solution). practice, operator decomposition technique (OD) still often intractable,
producing lower exponential search space standard joint search space. Recognising
much cheaper perform several independent searches one global search, Standley
decoupled planning non-interfering subgroups units independence detection (ID).
group solved centrally optimality overall solution still guaranteed.
fully developed hybrid algorithm, OD+ID, uses operator decomposition improve centralized planning non-independent subproblems. Nonetheless, optimality requirement costly
practice. Planning time still dominated largest subgroup units. number
units increases, less likely independent paths unavoidably overlap,
subgroups expected increase size too. Standleys (2010) experiments showed incomplete algorithm HCA* (Silver, 2005) actually solved instances. Furthermore,
relatively small problems compared experiments (Wang & Botea, 2008, 2010),
least 2 orders magnitude fewer agents (between 260 units), much smaller maps, 1 2
orders magnitude fewer tiles (approximately 819 tiles).
Therefore, methods tackling larger problems take decentralized approach, usually suboptimal nature. general, giving optimality reduces computation significantly. Decentralized path planning often much faster, scales much larger problems, yields
suboptimal solutions provides completeness guarantees. Recent work grid maps include
W HCA * (Silver, 2006), uses 3-dimensional temporal-spatial reservation table performs
series windowed forward searches unit, based true distance heuristic obtained
initial backward A* search target. FAR algorithm (Wang & Botea, 2008),
units follow flow annotation map planning moving, repairing plans locally using
heuristic procedures break deadlocks. flow related ideas include Jansen Sturtevants
(2008) direction map sharing information units directions travel, later units
follow movement earlier ones, improved coherence leading reduced collisions.
Methods scale instances number units well beyond capabilities
centralized search. However, mentioned earlier, methods known formal characterizations running time, memory requirements, quality solutions worst
case. lack ability answer reasonable bounded time whether given problem would
successfully solved, always important case incomplete algorithms.
practice, traditional approaches multi-agent pathfinding serious drawbacks,
inherent trade-off scalability, optimality completeness. Recently, body work
begun bridge gap two, addressing completeness tractability issues
hand hand, bounded suboptimal approach. Ryan (2008) introduced complete method
combines multi-agent path planning hierarchical planning search graphs specific substructures stacks, halls, cliques rings. example, stack narrow corridor
one entrance, placed one end stack. Many maps, including game maps
used experiments, seem allow efficient decomposition stacks, halls, cliques
rings. B IBOX (Surynek, 2009b) solves problems least 2 unoccupied vertices biconnected graph. worst case, number steps cubic number nodes. B IBOX
later extended work 1 unoccupied vertex necessary (Surynek, 2009a).
densely populated problems algorithm designed for, Surynek (2010a) expressed
B IBOX target computer game scenarios, normally lot fewer units
locations map. B IBOX suited multi-robot scenarios automatic packages
59

fiWANG & B OTEA

inside warehouse (Surynek, 2010c). Bibox- (Surynek, 2009a), requires 1 unoccupied
node, shown run significantly faster significantly shorter solutions Kornhauser,
Miller, Spirakiss (1984) algorithm related pebble coordination game. performed
quick evaluation B IBOX using code obtained author. found that, graphs
order magnitude smaller game maps, B IBOX exhibits fast-growing runtime (e.g.,
10 minutes graph 2500 locations) long solutions, millions moves.
Part explanation B IBOX builds instances crowded. understanding,
B IBOX designed solve crowded instances, necessarily efficiently solve instances
significantly fewer units locations.

3. Problem Statement
instance characterized graph representation map, non-empty collection
mobile units U . Units homogeneous speed size. unit u U associated starttarget pair (su , tu ). units distinct starting target positions. objective navigate
units start positions targets avoiding fixed mobile obstacles. state
contains positions units given time. work assumes undirected weighted graphs
unit occupies exactly one node time, move unoccupied neighbour
node. time discretized one units move synchronously time step.
Travelling along edge depend interfere rest problem, except
two nodes connected edge.
Several methods exist abstract problem map search graph, including navigation
meshes (Tozour, 2002), visibility points (Rabin, 2000), quadtrees (Samet, 1988). However,
graph abstraction generates nodes, visibility graph, may render multi-agent
pathfinding problem unsolvable, even though works single agent case. hand,
search graph obtained imposing regular grid contains nodes, covering locations
traversable space, offers path options avoid collisions units. Hence,
grid maps, besides popular easy implement, suitable multi-agent
problems. clarity practicality, focus grid maps examples experiments.
Nonetheless, conditions algorithmic definitions APP, introduce next
sections, specific regular grid maps. illustrated examples, assume
straight moves four cardinal directions performed (4 connected grid). Restricting
movements 8 directions (cardinal + diagonals) 4 cardinal directions negative impact
completeness. Since standard practice allow diagonal move equivalent (but
longer) two-move path exists, every solution allows diagonal moves, solution
cardinal moves. Therefore, problem diagonal moves reduced problem
straight moves, price possibly taking longer paths. Introducing diagonal moves could
reduce path length, potential drawback blocking units often straight
moves crowded maps. Whether enough clearance make diagonal move depends
two adjacent nodes (i.e., two tiles sharing common corner grid), since
physically impossible squeeze two units.

4. LIDABLE Class Instances
introduce subclass instances Basic APP shown complete.

60

fiM APP : CALABLE ULTI -AGENT PATH P LANNING


i+1

u

(u)
i-1

u lu (denoted 1
Figure 2: example alternate path, , connecting locations li1
i+1
+ 1 picture) belong precomputed path (u) unit u.

Definition 1 (S LIDABLE unit LIDABLE instance). mobile unit u LIDABLE iff path
u
u
(u) = (l0u , l1u , . . . , l|(u)|
) nodes exists, l0u = su , l|(u)|
= tu , following
conditions met:
u , lu , lu (u), except
1. Alternate connectivity. three consecutive locations li1
i+1
last triple ending tu , i.e. 0 < < |(u)| 1, alternate path ui exists
u lu go lu . See Figure 2 example.
li1
i+1


2. Initial blank. initial state, l1u blank (i.e. unoccupied).
3. Target isolation. target interferes -paths units. formally,
following hold tu :
(a) (v U \ {u}) : tu
/ (v);
(b) (v U, {1, . . . , |(v)| 1}) : tu
/ vi .
instance belongs class LIDABLE iff units u U LIDABLE.
three conditions verified polynomial time. verification includes attempting
compute paths unit. Since state space A* explore linear
m, A* search time polynomial m. checks blank location first step,
passing targets, trivial. process checks LIDABLE conditions
serves important additional purpose. time checks succeed instance known
belong LIDABLE, completed search needed solve instance.
remaining part algorithm simply tell units wait, move forward,
move backwards along already computed paths.
Notice three conditions restricted grid maps only. work standard
assumption one graph node occupied one unit time, moving along
edge neither depends interferes parts graph except two nodes ends
edge.
61

fiWANG & B OTEA

Algorithm 1 Overview APP.
1: u U
2:
compute (u) (as needed) su tu
3:
LIDABLE conditions hold
4:
mark u LIDABLE
5: initialize set LIDABLE units {optional: make units active, discussed text}
6: 6=
7:
progression step
8:
repositioning step needed

5. Basic APP
present basic version APP algorithm, complete LIDABLE class
problems. main feature Basic APP (and extensions presented Sections 7 8)
deadlock-free cycle-free, due total ordering active units. Units lower priority
interfere ability higher priority units advance.
illustrated Algorithm 1, problem instance, APP starts computing path (u)
unit u target (goal), constructing caching alternate paths along way. Note
paths alternate paths need satisfy conditions Definition 1. loop
lines 14 succeeds units, APP tell instance hand belongs LIDABLE,
APP complete.
subset units marked LIDABLE, APP guaranteed solve them.
equivalent solving smaller instance LIDABLE. Optionally, APP attempt
solve remaining units well, adding set active units giving lower
priority LIDABLE units. important stress that, remaining part paper,
implicit assumption APP attempts solve provably solvable units, unless
explicitly state opposite. experiments section, however, discuss options.
set LIDABLE units partitioned subset solved units already reached
targets, subset active units. Initially, units active. LIDABLE class,
becoming solved, units interfere rest problem (as ensured target
isolation condition). shown later, Basic APP solved units never become active again,
considered remaining part solving process.
Definition 2. advancing condition active unit u satisfied iff current position, pos(u),
belongs path (u) next location path blank.
Definition 3. state well positioned iff active units advancing condition satisfied.
Lines 68 Algorithm 1 describe series two-step iterations. progression step advances
active units towards targets. shown later, progression step brings least one active
unit target, shrinking active set ensuring algorithm terminates, reaching
state units solved. progression could result breaking advancing condition
one active units, remain. objective repositioning step ensure
active unit advancing condition satisfied starting next progression step. Note
repositioning step necessary every progression step except last.
62

fiM APP : CALABLE ULTI -AGENT PATH P LANNING


b

b





b

b





b


b



b
ii

b
iii

b
iv

v

Figure 3: Example APP works.

5.1 Example
simple example APP works illustrated Figure 3. two units, b.
APP uses total ordering active units progression step (Section 5.3). Here,
higher priority b. targets b drawn stars. Figure 3 (i), b progress
towards targets, becomes blocked b. (ii), blank brought front sliding
b ai (outlined bold); side effect, b pushed path. end current
progression step (iii), reaches target. repositioning step (iv), since already solved,
moves ignored. Repositioning undoes bs moves b back path blank
front it. bs advancing condition restored therefore global state example
well positioned. next progression step (v), b reaches target. algorithm terminates.
5.2 Path Computation
problem instance, compute path (u) individually. paths (u) fixed
throughout solving process. ensure paths satisfy alternate connectivity condition
(Definition 1), modify standard A* algorithm follows. expanding node x0 ,
neighbour x00 added open list alternate path x00 x, parent
x0 . process compute path (u) family alternate paths simultaneously.
give neighbour x00 node x0 chance added open list, node x0 might
expanded three times, per possible parent x. Therefore, O(m) node expansions
required A* search find path, number locations map.
Equivalently, computing path could seen standard A* search extended space
pairs neighbouring nodes (at four nodes created extended space original
node).
Since alternate paths depend triple locations, unit, re-use information planning paths units problem. means alternate path
set three adjacent tiles map computed per problem instance,
cached later use. Given location l grid map, eight locations could
path two moves away four-connect grid. shown Figure 4a, eight locations
form diamond shape around l. four locations straight line l
63

fiWANG & B OTEA

1
8

1
2

l

7
6

8
3

7

4



2

l

ii

6

3

4

5

5



b

Figure 4: (a) eight locations two moves away l. (b) Two two-move paths l location
2 go ii.

(locations 1, 3, 5, 7), precompute alternate path avoids in-between location
targets. four locations (labeled 2, 4, 6, 8), need compute (at most) two
alternate paths. example, two possible paths l 2 two moves long:
ii (Figure 4b). need one alternate path avoid intermediate location,
ii. summary, precompute 12 paths l. locations map,
need 12m
2 = 6m alternate paths (only one computation triple, since alternate
path connects two endpoints ways).
possible optimization reuse alternate paths across LIDABLE instances map.
Alternate paths overlap targets new instance need re-computed. discuss
option experiments section.
5.3 Progression
Algorithm 2 shows progression step pseudocode. iteration outer loop, active
units attempt progress one move towards targets. processed order (line 2).
unit v processed unit w, say v higher priority write v < w. ordering
fixed inside progression step, may change one progression step another. actual
ordering affects neither correctness completeness method, may impact
speed solution length. ordering units chosen heuristically, e.g. giving higher
priority units closer target. Thus, units could get target quickly,
solved way remaining units problem.
ensure lower priority units harm ability higher priority units progress,
introduce notion private zone. see Algorithm 2 unit cannot cause
moves occupy private zone higher-priority unit.1 Given unit u, let pos(u)
u
current position, let int((u)) = {l1u , . . . , l|(u)|1
} interior precomputed path
(u). shown Algorithm 2, unit u might get pushed precomputed path, case
pos(u)
/ (u).
u , lu } pos(u) = lu int((u)).
Definition 4. private zone, (u), unit u (u) = {li1


Otherwise, (u) = {pos(u)}. words, private zone includes current location

1. move caused unit u either move u along (u) path, move different unit w,
pushed around u side effect blank travel.

64

fiM APP : CALABLE ULTI -AGENT PATH P LANNING

Algorithm 2 Progression step.
1: changes occur
2:
u order
3:
pos(u)
/ (u)
4:
nothing {u pushed track result blank travel}
u current progression step
5:
else u already visited li+1
6:
nothing
u , belongs private zone higher priority unit, i.e.
7:
else next location, li+1
u
v < u : li+1 (v)
u released v}
8:
nothing {wait li+1
u blank
9:
else li+1
u
10:
move u li+1
u
11:
else bring blank li+1
u
12:
bring blank li+1
u
13:
move u li+1
14:
else
15:
nothing

unit. addition, unit pre-computed path start position, location
behind unit belongs private zone well.
Lines 315 Algorithm 2 show processing u, active unit hand. u pushed
precomputed path, action taken (lines 34). Lines 5 6 cover situation
unit u pushed around (via blank travel) higher-priority units back location (u)
already visited current progression step. case, u doesnt attempt travel
previously traversed portion path, ensuring bounds total travelled distance
u
introduced later hold. u path next location li+1
currently blocked higheru available, u
priority unit v, action taken (lines 78). Otherwise, next location li+1
u
moves (lines 910). Finally, li+1 occupied smaller-priority unit, attempt made
u
first bring blank li+1
u move (lines 1113). u moves new
u
u target location u.
location li+1 (lines 10 13), test performed check li+1
case, u marked solved removing adding S, set solved
units.
u
Bringing blank li+1
(lines 11 12) illustrated Figure 1. discuss
process detail. location l ui sought following properties: (1) l blank,
u (inclusive) along u belongs private zone higher(2) none locations l li+1

u
priority unit, (3) l closest (along ui ) li+1
property. location l
u
found, test line 11 succeeds. actual travel blank l li+1
along ui
(line 12) identical movement tiles sliding-tile puzzle. Figure 1 shows example
u
blank traveling. intuition behind seeking blank along ui that, often, li1
u lu test line 11
remains blank time interval u advances li1

performed. guaranteed always hold case active unit highest priority,
call master unit.
Let us introduce characterize behaviour master unit formally. beginning progression step, one master unit u selected. unit highest priority among
65

fiWANG & B OTEA

units active beginning progression step. status master unit
preserved entire progression step, even u becomes solved. beginning
next progression step, new master unit selected among remaining active units.
Lemma 5. master unit u always bring blank front, needs one.
u , belongs private zone, (u), unit
Proof. Since us previous location, li1
u .
move private zone highest priority unit, u guaranteed always find blank li1
u lu belong private zone higher priority
Moreover, location along ui li1
i+1
unit since units higher priority. Note ui free physical obstacles
u lu .
construction. must possible blank travel li1
i+1

Lemma 6. master unit u never pushed -path.
Proof. u pushed (u) blank travelling performed another unit, contradicts u
highest priority unit.
Theorem 7. long master unit u solved, guaranteed advance along (u)
iteration outer (while) loop Algorithm 2. end current progression
step, least u reached target.
Proof. Using previous two lemmas, easy check u never enters nothing line
Algorithm 2. Similar Lemma 6, u never pushed cannot revisit previous location. Also,
since u highest priority, next location cannot held private zone another unit.
Hence, us progress target guaranteed.
following result useful ensure progression step always terminates, either
state units solved state remaining active units stuck.
Theorem 8. Algorithm 2 generates cycles (i.e., repetitions global state).
Proof. show proof contradiction. Assume cycles. Consider cycle
active unit u cycle highest priority. Since unit cycle dominates u,
means movements u cannot part blank travel triggered higher priority unit.
Therefore, movements u result either line 10 line 13. is, us moves
along path (u). Since (u) contains cycles, u cannot run cycle.
5.4 Repositioning
end progression step, remaining active units (if left)
advancing condition broken. Recall happens unit u either pos(u)
/ (u) u
placed precomputed path next location path blank. repositioning
step ensures well positioned state reached (i.e., active units advancing condition
satisfied) starting next progression step.
simple computationally efficient method perform repositioning undo block
recent moves performed preceding progression step. Undoing move means carrying
reverse move. Solved units affected. remaining active units, undo
moves, reverse global order, well positioned state encountered. call strategy
reverse repositioning. example provided Section 5.1.
66

fiM APP : CALABLE ULTI -AGENT PATH P LANNING

Proposition 9. reverse repositioning strategy used line 7 Algorithm 1 (when needed),
progression steps start well positioned state.
Proof. lemma proven induction iteration number j Algorithm 1. Since
initial state well positioned (this follows easily Definitions 1 3), proof j = 1
trivial. Assume repositioning step performed starting iteration j + 1.
worst case, reverse repositioning undoes moves remaining active units (but
moves units become solved), back original positions beginning j-th
progression step. words, reach state similar state s0 beginning
previous progression step, except units targets s. Since s0 well
positioned (according induction step), follows easily well positioned too.

6. Worst-case Best-case Analysis
give bounds runtime, memory usage, solution length APP algorithm
problem LIDABLE n units map traversable tiles. examine worst case
scenario case, discuss best-case scenario end.
introduce additional parameter, , measure maximal length alternate paths .
worst case, grows linearly m. However, many practical situations, small constant,
since ends path close other. analysis discusses scenarios.
Theorem 10. Algorithm 1 worst-case running time O(max(n2 m, m2 log m))
constant, O(n2 m2 ) grows linearly m.
Proof. outlined Section 5.2, single-agent A* search consistent heuristic 2 expands
O(m) nodes. Hence, assuming open list implemented priority queue, A* search
takes O(m log m) time. Note that, graphs edges cost, log factor
could principle eliminated using breadth-first search find optimal path. Grid maps
cardinal moves fit category. However, simplicity, assume log
factor present.
Hence, worst case, searches -paths take O(nm log m) time n units.
A* searches take O(m2 log m) time.
single progression step, outlined Algorithm 2, suppose blank travel required n
units, every move along way except first last moves. Since length paths
bounded length alternate paths bounded , total number moves
progression step O(nm), running time Algorithm 2.
Clearly, complexity repositioning step cannot exceed complexity previous
progression step. Hence complexity iteration Algorithm 1 (lines 57) O(nm).
number iterations n, since size reduces least one iteration.
APP takes O(max(nm log m, m2 log m, n2 m)) time run, O(max(n2 m, m2 log m))
constant O(n2 m2 ) grows linearly m.
Theorem 11. maximum memory required execute APP O(nm) constant,
O(nm2 ) grows linearly m.
2. well known Manhattan heuristic, used implementation, consistent. proof
easy, direct result 1) definition consistency 2) way Manhattan distance computed (by
pretending obstacles map).

67

fiWANG & B OTEA

Proof. Caching possible paths entire problem described Section 5.2 takes O(m)
memory. A* searches paths performed one time. search, stored
cache, memory used open closed lists released. A* working memory
takes O(m) space, storing paths takes O(nm) space. Overall, path computation
across units requires O(nm + m) space.
Then, lines 57 Algorithm 1, memory required store stack moves performed
one progression step, used repositioning. shown proof Theorem 10,
number moves progression step within O(nm). So, overall maximum memory
required execute program O(nm), O(nm) constant O(nm2 )
grows linearly m.
Theorem 12. total distance travelled units O(n2 m) constant,
O(n2 m2 ) grows linearly m.
Proof. shown previously, number moves progression step within O(nm).
number moves repositioning step strictly smaller number moves previous
progression step. n progression steps (followed repositioning steps). Hence,
total travelled distance within O(n2 m).
Corollary 13. Storing global solution takes O(n2 m) memory constant, O(n2 m2 )
grows linearly m.
discuss best case scenario. APP computes optimal solutions number moves
paths optimal units reach targets without blank traveling (i.e., units
travel along paths ). obvious example paths disjoint. case,
solutions makespan optimal too. well preserving optimality best case, search
effort APP smaller spent centralised A* search, n single-agent
m!
O(m) searches, compared searching combined state space n units, (mn)!
states.

7. Extending Completeness Range
extend APPs completeness beyond class LIDABLE, evaluated impact
three LIDABLE conditions preliminary experiment. ran Basic APP data
set used main experiments (the data set main experiments described
Section 9). preliminary experiment, switched one LIDABLE condition time
counted many units satisfy remaining two conditions. larger increase number
solvable units suggests relaxing definition condition hand could provide
significant increase completeness range.
initial experimental evaluation indicates Basic APP three LIDABLE conditions solves 70.57% units (basic case). alternate connectivity requirement switched off,
87.06% units satisfy remaining two conditions. Switching target isolation makes 85.05%
units satisfy remaining two conditions. However, ignoring blank availability condition
small impact, increasing percentage slightly, 70.57% basic case 70.73%.
results suggest alternate connectivity target isolation conditions restrictive blank availability condition. Thus, focus relaxing two conditions.
68

fiM APP : CALABLE ULTI -AGENT PATH P LANNING

target isolation, extension allows unit plan path targets,
still guarantee clearly identified set units reach targets. topic
Section 7.1. extend alternate connectivity, developed technique allows paths
planned regions alternate paths, tunnels. blank travelling operation
tunnel-crossing unit uses blank positions ahead unit, along remaining
pre-computed path, describe detail Section 7.2. empirical analysis
features provided Section 9.
7.1 Relaxing Target Isolation Condition
several targets close other, target isolation condition, forbidding paths
pass targets, make targets behave virtual wall, disconnecting two areas
map. result, Basic APP report many units non-S LIDABLE.
extension introduce allows unit u plan path target another unit v,
subsequently v never assigned higher priority u. specifically, partial ordering
defined, u v iff target v belongs -path u
path along us
u 2
ui ). Every
-path. Written formally, u v iff tv (u), (u) = ((u) ki=1
time mention refer transitive closure. show section that, paths
planned way (possibly empty) relation creates cycles type u u,
instance solved slight modification Basic APP.
Units plan paths foreign target choice.
achieve strategy, A* searches assign high cost graph search edges adjacent
foreign target. desirable outcome reducing interactions caused target
isolation relaxation. particular, way original LIDABLE units compute paths
preserved, foreign targets crossed cases. words, instances LIDABLE
characterized empty relation.
Definition 14. instance belongs class I-S LIDABLE iff every unit u exists path (u)
satisfying alternate connectivity initial blank condition definition LIDABLE
(Definition 1). Furthermore, cycles allowed relation.
Assume moment (possibly empty) relation without cycles available. Aspects
related obtaining one discussed later section.
Definition 15. solving I-S LIDABLE instances, extended algorithm, APP, two
small modifications original algorithm:
1. total ordering < inside progression step stays consistent : u v u < v.
2. u v, v cannot marked solved (i.e. moved S) unless u already
marked solved.
extra conditions hand, ensure even unit x arrives target tx
units clear tx -paths, units get past x performing normal blank
travel. Following that, x undo moves back tx repositioning step, Basic APP.
prove APP terminates, first prove following two lemmas hold highest
priority unit, u, progression step:
69

fiWANG & B OTEA

Lemma 16. unit visit target u, tu , current progression step.
Proof. Since u master unit, follows u < v active unit v. According
point 1 Definition 15, follows u v. Relation cycles, means v u.
Therefore, applying definition , follows tu
/ (v). completes proof,
APP movements performed along paths.
Since repositioning step undo moves made previous progression step, units
revisit locations visited progression step. So, following direct result
Lemma 16:
Corollary 17. unit visit tu repositioning step follows.
Corollary 18. u solved, cannot interfere rest problem.
Theorem 19. APP terminates.
Proof. Showing least highest priority unit u reaches target given progression step
virtually identical proof Lemma 7. Corollary 18 guarantees that, solving u,
interfere rest problem. Hence, number active units strictly decreases
progression step, algorithm eventually terminates.
Let us get back question provide cycle-free relation. Testing whether
units plan paths way cycle introduced might end expensive.
unit u cant possibly avoid targets, might choose crossing
target v crossing target w. One option might lead cycle whereas might
avoid cycles. Therefore, systematic search might required seek cycle-free relation .
Rather searching systematically, APP takes cheaper, greedy approach.
cycles, mark number units I-S LIDABLE. selected way
units remain cycle-free (we call I-S LIDABLE units). I-S LIDABLE units
guaranteed solved.
result greedy approach, APP complete class I-S LIDABLE. Still,
complete superset LIDABLE able identify many units (often all)
provably solved.
Finally, wrap discussion extension concluding upper bounds
APP, given Section 6, still apply APP. proof identical make
worst-case assumptions before: master unit gets solved progression step,
every move along units path requires blank travel. Moreover, note additional step
path pre-computation topologically sorting partial order, , linear priority order <,
done cheaply time linear number units (Tarjan, 1976).
7.2 Relaxing Alternate Connectivity Condition
show Section 9, previous extension target isolation significantly improves
APPs success ratio (i.e., percentage solvable units). Yet, significant room
improvement. particular, maps single-width tunnels still showed bottleneck terms
success ratio. Tunnels make alternate connectivity condition connecting two ends
consecutive triple locations without going middle harder even impossible
70

fiM APP : CALABLE ULTI -AGENT PATH P LANNING

satisfy. single-width tunnel bridges two otherwise disjoint regions, shown Figure 5,
versions APP presented far fail find path two regions, alternate
connectivity broken triples inside tunnel.

Figure 5: example units targets side, way
cross single-width bridge. Units drawn circles, corresponding targets
squares shade.

section introduce buffer zone extension, solution relaxing alternate
connectivity condition. allows many paths, corresponding many units, cross singlewidth tunnel. intuition simple. Often, plenty blank positions ahead unit, along
remaining locations precomputed -path corresponding paths along it.
tunnel-crossing operation essentially generalisation blank travelling, blank position
sought path ahead, instead alternate path current location triple.
Definition 20. precomputed path (u) crosses tunnels, define following:
buffer zone, ((u)), portion (u) target end
last tunnel (at theSj-th move (u)), together corresponding alternate paths:
((u)) =
{liu } ui .
i{j+2,...,ku 1}

dynamic counter, ((u)), keeps track many positions buffer zone blank.
counter initialized beginning appropriate value, incremented
decremented necessary later on.
threshold ((u)) set length(t) + 2, longest tunnel crossed
unit u. threshold acts minimal value ((u)) guarantees u cross
tunnels safely.

71

fiWANG & B OTEA

unit u attempts cross tunnel, push units lower priorities closest blank
locations buffer zone, u exits tunnel. tunnel-crossing operation
possible, enough blanks available buffer zone. analyse new extended
algorithm detail, introduce extended class AC LIDABLE, whose definition includes
units meeting new buffer zone extension.
Definition 21. relaxing alternate connectivity condition, allow (u) go one
single-width tunnels iff enough blanks us buffer zone, least ((u)) blank
locations ((u)) initial state, i.e., ((u)) ((u)). before, alternate paths still
needed locations outside tunnels.
Definition 22. unit u U belongs extended class, call AC LIDABLE, iff
path (u) meeting initial blank target isolation conditions given definition
LIDABLE (Definition 1), relaxed alternate connectivity condition (Definition 21 above).
AC APP modified Basic APP following two ways integrate buffer
zone technique relaxing alternate connectivity condition. Firstly, repositioning step cannot
finish counter () value threshold (). words, need ensure
enough blanks available buffer zone progression step begins. following
new advancing condition, updated Definition 2 adding extra, aforementioned condition.
Definition 23. advancing condition active, tunnel-crossing unit u satisfied iff current
position belongs path (u) next location path blank (as given Definition 2),
((u)) ((u)).
Secondly, need preserve one Basic APPs main features, units lower priority
never block units higher priority, ensuring APP run cycles deadlocks.
Hence, unit u lower priority v cannot cause moves bring ((v))
threshold (i.e., ((v)) ((v)) 1). Recall move caused u either move
u along (u) path (checked lines 7-8 Algorithm 4), move different unit
w, pushed around u side effect blank travel (checked lines 7-11
Algorithm 3). Thus buffer zone u acts generalised private zone, u holds least
((u)) locations accessible units lower priorities.
extensions AC APP maintain following properties Basic APP.
Lemma 24. long master unit u solved, guaranteed advance along (u)
iteration outer (while) loop Algorithm 4. end current progression
step, least u reached target.
Proof. result follows directly proof Lemma 7. parts new
Algorithm 4 compared Algorithm 2 (the progression step Basic APP) check
lines 7-8 modified blank travelling operation (lines 13-15). Since u highest priority
current progression step, cause moves affecting buffer zone every unit,
unit move buffer zone u would bring number blanks
threshold, i.e. ((u)) < ((u)). Hence u guaranteed enough blanks cross
tunnel (u).
proof Lemma 25 similar Lemma 8 Section 5.3.
72

fiM APP : CALABLE ULTI -AGENT PATH P LANNING

u )
Algorithm 3 AC APP canBringBlank( unit u, location li+1
1: u outside tunnels
2:
look nearest blank b along ui
3: else u inside tunnel
4:
look nearest blank b ((u))
5: b found
6:
return false
u } {segment along u ((u)) above}
7: location l {b, . . . , li+1

8:
v < u : l (v) {check causing another unit move private zone
higher priority unit, v}
9:
return false
10:
else v < u : l ((v)) & ((v)) ((v)) {check causing another unit
move buffer zone higher priority unit, v}
11:
return false
12: return true

Algorithm 4 AC APP Progression step.
1: changes occur
2:
u order
3:
pos(u)
/ (u)
4:
nothing
u
5:
else v < u : li+1
(v)
6:
nothing
u
7:
else v < u : li+1
((v)) & ((v)) ((v)) {check moving
buffer zone higher priority unit}
8:
nothing {wait v blanks buffer zone}
u current progression step
9:
else u already visited li+1
10:
nothing
u blank
11:
else li+1
u
12:
move u li+1
u ) {Algorithm 3}
13:
else canBringBlank( u, li+1
u
14:
bring blank li+1
u
15:
move u li+1
16:
else
17:
nothing

Lemma 25. Algorithm 4 generates cycles (i.e., repetitions global state).
Theorem 26. AC APP terminates.
Proof. follows Lemmas 24 25 number active units strictly decreases
successive iterations Algorithm 4. Hence, algorithm AC APP eventually terminates.
Since shown algorithm AC APP guaranteed solve class AC LID completeness result shown follows directly.

ABLE ,

73

fiWANG & B OTEA

Corollary 27. AC APP complete class AC LIDABLE.
AC APP extension preserves upper bounds running time, memory usage, solution length given Section 6. Here, introduce max denote maximal length tunnels
units cross. worst case analysis, units initiate blank travelling every move along
way, involves tunnels. So, depending whether max , maximal length
paths, longer, AC APP runs O(n2 mmax ) O(n2 m) time. Since parameters
often constant practice, grow worst linear m, running time O(n2 m) O(n2 m2 ),
before. bounds total travel distance global solution follow directly. Lastly,
virtually additional memory required storing buffer zones, except one counter one
threshold variable, per unit.
7.3 Combining Target Isolation Alternate Connectivity Relaxations
show two extensions LIDABLE class combined.
Definition 28. instance belongs extended class, I+AC LIDABLE, iff every unit u
exists path (u) meeting initial blank condition given Definition 1, relaxed
alternate connectivity condition Definition 22. Furthermore, (possibly empty) relation
introduced result target isolation relaxation cycle-free, Definition 14.
obtain extended algorithm, I+AC APP, combining APP (Definition 15)
AC APP (Algorithms 3 4).
Theorem 29. I+AC APP terminates.
Proof. proof Lemma 24, show least highest priority unit u reaches
target progression step, follows. Definition 21, u guaranteed enough blanks
clear single-width tunnels along path. Definitions 14 15 guarantee that,
outside tunnels, u always bring blank needed, stated Lemma 5. Furthermore,
progression step generates cycles. proved cases Lemmas 25 8.
know solved unit u interfere rest problem,
results Lemmas 16 18, Corollary 17. Note tricky cases units
targets inside single-width tunnels excluded extended class I+AC LIDABLE,
zero buffer capacity according defined Definition 20.
Since iteration algorithm solves least one unit, I+AC APP terminates.

8. Improving Solution Length
mentioned before, avoid replanning, units pushed off-track blank travelling units
undo moves get back -paths immediate repositioning step.
observed that, practice, reverse repositioning strategy (defined Section 5.4) introduce
many unnecessary moves, increase solution length, increase running time, may
hurt visual quality solutions.
Recall that, standard reverse repositioning step, new moves added solution
built. moves undo, reverse order, moves active units (i.e., solved
yet) made previous progression step. process continues well positioned state
74

fiM APP : CALABLE ULTI -AGENT PATH P LANNING

u

(v)

u

(v)

v

v

(u)

(u)

Figure 6: Two examples global checking well positioned state.

reached, means active units advancing condition satisfied (i.e., every
active unit -path blank front).
undo move, well-positioned check performed globally. words, Basic
APP checks advancing condition active units, unit affected
recent undo move. global checking guarantees eventually reach well-positioned state,
proved Proposition 9, but, mentioned earlier, often create many unnecessary moves.
provide two simple examples Figure 6, illustrate one case global checking
useful, one case global checking strong condition, adding unnecessary moves.
First, consider two units, u v, undoing one move global moves stack places u
back path, blank front. Assume us current position way vs
future undo moves, shown left Figure 6. Therefore, even us advancing condition
satisfied, u needs additional undo moves, make room undo moves units, v,
order reach globally well positioned state. case, global checking useful. second
example, imagine u vs moves recent progression step independent
other, possibly even two map areas far away other. simple case shown
right Figure 6. recent progression, vs last move (when v derailed) followed
sequence us moves. final move u pushed track, whereas preceding
moves along us -path, (u). Reverse repositioning would undo moves reverse global
order, means undoing us moves undoing vs last move. However, one undo
move u one undo move v sufficient restore units well positioned state.
illustrated, global checking advancing condition could strong, whereas
local checking could insufficient. solution introduce section,
called repositioning counting, finds middle ground two extremes, improves
number moves still maintains guarantee reaching well-positioned state. Intuitively,
undo moves unit u stop soon (a) us advancing condition satisfied, (b)
current position cannot possibly interfere future undo moves units, (c) unit
performing repositioning possibly stop blank position front u us -path,
75

fiWANG & B OTEA

(d) u doesnt stop initial second location another active unit v. initial second
location unit v position ahead v beginning recent progression step.
fourth condition ensures units blank front end, worst case
revert back initial position beginning recent progression step.3
Definition 30. location l path, keep counter, c(l), that:
beginning progression step, counter c(l) reset 0, l empty, 1,
l occupied.
Every time l visited progression step, c(l) incremented.
Every time unit leaves l result undo move repositioning step, c(l)
decremented.
Following directly definition c(l) given above, formulate following two
results c(l) repositioning time:
Lemma 31. c(l) = 0, unit pass l remaining part current
repositioning step.
Lemma 32. given active unit u, current position pos(u), c(pos(u)) = 1,
progression moves location pos(u) already undone. words,
unit remainder repositioning step pass pos(u).
introduce new enhancement APP, aimed eliminating many useless undo
moves repositioning steps.
Definition 33. enhanced algorithm, R C APP, uses repositioning counting strategy
line 7 Algorithm 1. means active unit u stops undoing moves current
repositioning step, soon meets following conditions:
(a) advancing condition u satisfied according Definition 2, plus extension Definition 23.
(b) us current location, pos(u), c(pos(u)) = 1
u , c(lu ) = 0
(c) location front u, li+1
i+1

(d) current location initial second location another active unit.
Theorem 34. repositioning steps R C APP end well-positioned state.
3. Condition d) ignored without invalidating algorithms ability make progress towards goal state. Even
units could possibly end state without blank front, guaranteed least one unit (i.e.,
one finishes repositioning first) blank front. guarantees least one unit
solved next progression step.

76

fiM APP : CALABLE ULTI -AGENT PATH P LANNING

Proof. Recall moves made progression step kept totally ordered list.
prove directly repositioning counting, undoing subset moves, reaches wellpositioned state. Since counter c(l) incremented decremented according Definition 30,
unit u satisfying three conditions Definition 33 restored advancing condition.
Furthermore, combined results Lemmas 31 32 guarantee units later
get us way, u way units repositioning moves.

Theorem 34, applying R C repositioning steps extended algorithm I+AC APP
negative impact completeness.

9. Experimental Results
section present empirical evaluation APP algorithm. first point
impact newly added feature. put I+AC+R C enhanced APP test
comparison existing state-of-the-art decoupled, incomplete methods. Specifically,
benchmarks FAR (Wang & Botea, 2008), extended version Silvers (2005) W HCA *
algorithm Sturtevant Buro (2006), called W HCA *(w,a), applies abstraction
expensive initial backward A* searches. APP, algorithms tested rather
large problems, terms map size number units. aware programs
scale well FAR W HCA *. strengths two methods potential ability
find solution quickly, weakness cannot tell whether would able
solve given instance.
implemented APP scratch integrated Hierarchical Open Graph4 (HOG)
framework. source code extended W HCA * algorithm, W HCA *(w, a) (Sturtevant &
Buro, 2006), extra features spatial abstraction diagonal moves (but without priority
system unit replanning), obtained Nathan Sturtevant. FAR algorithm
implementation used previous experiments (Wang & Botea, 2008).
Experiments run data set randomly generated instances used previously published work (Wang & Botea, 2008). input grid maps5 10 largest game Baldurs Gate6 , range 13765 51586 traversable tiles size, listed Table 1.
game maps quite challenging, containing different configurations obstacles forming different
shapes rooms, corridors, narrow tunnels. test map 100 2000 mobile units
increments 100. 10-minute timeout per instance set. W HCA *(w, a) experiments,
set window size, w, 8, use first level abstraction (a = 1). seems
good parameter setting work Sturtevant Buro (2006), experiments comparing
W HCA *(20,1) show W HCA *(8,1) work better data set. Abstraction allows W HCA *
build heuristic graph smaller actual graph movement takes
place. FAR, units make reservations k = 2 steps ahead, recommended setting.
experiments run 2.8 GHz Intel Core 2 Duo iMac 2GB RAM.
77

fiWANG & B OTEA

Basic MAPP

Number SLIDABLE

2000

700
414
400
500
300
204
602
411
603
307

1500
1000
500
0
0

500
1000
1500
Total number agents

2000

TI MAPP
414
400
204
500
411
300
700
602
603
307

1500
1000
500
0

AC MAPP
2000

0

Number AC-SLIDABLE

Number TI-SLIDABLE

2000

500
1000
1500
Total number agents

2000

700
500
300
400
414
204
602
411
603
307

1500
1000
500
0
0

500
1000
1500
Total number agents

2000

TI + AC MAPP
Number TI+AC-SLIDABLE

2000

700
300
500
414
400
602
204
603
411
307

1500
1000
500
0
0

500
1000
1500
Total number agents

2000

Figure 7: MAPPs widened completeness range relaxation: graph line represents
number units solved problem instances map. Here, provably solvable
units counted.

78

fiM APP : CALABLE ULTI -AGENT PATH P LANNING

FAR

Number agents solved

2000

414
204
400
411
700
500
300
602
603
307

1500

1000

500

0

0

500
1000
1500
Total number agents

2000

WHCA* diagonals

Number agents solved

2000

400
204
414
411
700
500
300
603
602
307

1500
1000
500
0
0

500
1000
1500
Total number agents

2000

WHCA* diagonals

Number agents solved

2000

204
414
400
411
700
500
300
603
602
307

1500
1000
500
0
0

500
1000
1500
Total number agents

2000

Figure 8: success ratios (averaged 10 trials) FAR, W HCA *(8,1), without
diagonals, set problem instances. timeout set 10 minutes per
instance 3 incomplete algorithms.
79

fiWANG & B OTEA

Map ID
AR0700SR
AR0500SR
AR0300SR
AR0400SR
AR0602SR
AR0414SR
AR0204SR
AR0307SR
AR0411SR
AR0603SR

Short ID
700
500
300
400
602
414
204
307
411
603

# nodes
51586
29160
26950
24945
23314
22841
15899
14901
14098
13765

Table 1: 10 maps descending order, terms number nodes.

9.1 Scalability Percentage Solved Units
compare FAR, W HCA *(8,1) four versions APP: Basic APP original LID ABLE definitions; APP , version target isolation relaxation switched on; AC
APP, based relaxing alternate connectivity condition; +AC APP, relaxing
target isolation condition, alternate connectivity condition. measure success ratio,
defined percentage solved units. Note repositioning counting (R C)
considered section, since impact success ratio, designed
improve solution length.
APP versions used section attempt solve units provably solvable
(i.e., units marked LIDABLE, LIDABLE, AC LIDABLE, I+AC LIDABLE respectively).
reason want evaluate many units fall subclasses practice.
next section show data obtained version APP attempts solve units.
Figure 7 summarizes success ratio data version APP algorithm
maps. closer curve top diagonal line (being total number units), better
success ratio map. Basic APP exhibits mixed behaviour, greater success ratio
six maps. four challenging maps (602, 411, 603, 307), success ratio gets often
50% number mobile units increases. maps common feature containing
long narrow corridors even single-width tunnels, connecting wider, open regions
map. Thus surprising that, mentioned Section 7, alternate path target isolation
conditions identified greatest causes failing find LIDABLE path.
Relaxing target isolation condition (T APP) significantly improves success ratio
maps. good success ratio (93% higher) achieved 7 maps across entire
range number mobile units. 3 maps contain high proportion narrow
corridors, single-width tunnels.
Relaxing alternate connectivity well (T +AC APP) yields excellent success ratio
unit numbers maps. example, scenarios 2000 units,
4. http://webdocs.cs.ualberta.ca/nathanst/hog.html
5. experimental maps viewed online, at: http://users.cecs.anu.edu.au/cwang/gamemaps
6. http://www.bioware.com/games/baldurs_gate/

80

fiM APP : CALABLE ULTI -AGENT PATH P LANNING

challenging according Figures 7 8, smallest success ratio 92% (map 307) largest
one 99.7%. scenarios fewer mobile units, I+AC APP even better success ratios.
Next compare success ratio I+AC APP (bottom plot Figure 7) FAR
(top plot Figure 8) W HCA *(8,1) (middle bottom Figure 8, without diagonals,
respectively). Extended APP clear winner terms scalability. FAR W HCA * suffer
number units increased. incomplete algorithms often time even scenarios
significantly fewer units 2000. 2000 units, FAR solves 17.5% units,
W HCA * solves 16.7% (no diagonal moves) 12.3% (with diagonal moves)
units. entire data set, I+AC APP solved 98.82% units, FAR solved
81.87% units, 77.84% 80.87% solved W HCA * without diagonal moves
allowed, respectively.
9.2 Scalability Attempting Solve Units
previous section, compare FAR, W HCA * APP. I+AC APP version
used attempts solve units, provably solvable ones (attempt-all feature).
mentioned earlier, achieved marking units active beginning. Active units
partitioned three categories: i) provably solvable units reach target; ii)
units reached target; iii) units reached target location,
still active units still cross location. total ordering <
active units must respect conditions units category i) higher priority units
category ii), higher priority units category iii).
attempt-all feature turned on, I+AC APPs percentage solved units increases
98.82% (Section 9.1) 99.86%.
Next focus number solved instances. instance considered solved iff
units solved. APP successful 84.5% instances. significantly better FAR
(70.6%), W HCA * diagonal moves (58.3%), W HCA * diagonals (71.25%).
attempt-all feature massive impact percentage fully solved instances, improving 34% 84.5%. might seem counter-intuitive attempt-all feature
small impact percentage solved units great impact percentage solved instances. explanation following. APP fails instance,
small percentage units remain unsolved. Often, one two
unsolved units failed instance. Managing solve remaining units well
attempt-all feature result whole instance changing label failed solved, even
though change overall percentage solved units small.
remaining sections use attempt-all feature well. reason increases
number solved instances therefore obtain larger set data analyse.
9.3 Total Travel Distance
Factors may impact length plans lengths initial paths, extra movements caused blank travel repositioning. experiments, length precomputed
paths virtually negative impact travel distance. Even APPs paths
satisfy additional constraints, avoiding targets possible, similar
length normal unconstrained shortest paths, 1.4% longer average.
81

fiWANG & B OTEA

RC-Improved Travel Distance (Map 400)
800000

MAPP total
RC MAPP total
MAPP Pre-Computed Pi
MAPP undos
RC MAPP undos

Distance (moves)

700000
600000
500000
400000
300000
200000
100000
0
0

2

4

6 8 10 12 14 16 18 20
Number agents (100s)

Figure 9: typical case improved distances R C APP normal APP. Note precomputed -paths affected R C enhancement.

section, first evaluate improvement repositioning counting (R C)
standard reverse repositioning. compare total distance travelled R C APP
FAR W HCA *.
9.3.1 R EDUCING U NDO OVES
identified excessive undoing moves repositioning bottleneck Basic APP. Figure 9 shows benefits repositioning counting (R C), enhancement described Section 8. figure compares total travelled distance, well number undo moves,
R C+T I+AC APP (shown R C APP short) I+AC APP (M APP short) average case. shown, repositioning counting turns quite effective, eliminating many
unnecessary undo moves (that help reach globally restored state). Averaged
entire data set, R C APP 59.7% shorter undo distance APP standard reverse
repositioning, results reducing total travelled distance 30.4% average.
9.3.2 C OMPARING OTAL ISTANCE FAR W HCA *(8,1)
evaluate solution length attempt-all R C+T I+AC APP compared FAR
W HCA *(8,1). plot total travel distance averaged subset input instances
algorithms considered fully solve.
Figures 10 11 show average results maps. APP, show length
precomputed paths, number undo (repositioning) moves, total travelled distance.
According performance criterion, set maps roughly partitioned three subsets.
good case, map 307, APP performs better W HCA *(8,1) without diagonals
terms total travel distance, even comparable FAR. average case, APPs travel
82

fiM APP : CALABLE ULTI -AGENT PATH P LANNING

Total Travel Distance: Good Case (307)
90000

WHCA*(8,1) noD
FAR
MAPP Total
WHCA*(8,1)
MAPP Pi
MAPP Undos

70000
60000
50000

250000
Distance

80000

Distance

Total Distance Travelled: Average Case (411)
300000

40000
30000

200000

WHCA* noD
MAPP Total
FAR
WHCA*(8,1)
MAPP Pi
MAPP Undos

150000
100000

20000

50000

10000
0
100

200

300

400 500 600
Number agents

700

800

0
900

200

Total Distance Travelled (603)
160000

Distance

140000
120000
100000

WHCA* noD
MAPP Total
WHCA*
FAR
MAPP Pi
MAPP Undos

250000

80000
60000

200000

MAPP Total
WHCA* noD
FAR
MAPP Pi
WHCA*
MAPP Undos

150000
100000

40000

50000

20000
0
100

600 800 1000 1200 1400 1600
Number agents

Total Distance Travelled (602)
300000

Distance

180000

400

200

300

400 500 600 700
Number agents

800

0
900

200

400

600
800
1000
Number agents

1200

Figure 10: Distance travelled plotted averaged instances fully solved algorithms.

distance roughly comparable W HCA * without diagonals. Maps 603, 411, 602 belong
category. Finally, harder case, APPs total distance increases faster rate
others, direct result increasingly larger number undo moves. harder cases
include maps 204, 414, 700, 400, 300, 500. Upon inspection, cases typically involve
high number turns corners. APPs case, results high degree path overlapping,
units keep close edge rounding corner, obtain shorter -paths.
summarise overall results, APPs travel distance ranges 18.5% shorter W HCA *
without diagonal moves, 132% longer, 7% longer average. Compared
version W HCA * diagonal moves enabled, APPs total distance 31% longer average,
varying 5.8% shorter 154% longer. Compared FAR, APPs solutions range
4.8% shorter 153% longer, 20% longer average.
closer look results reveals that, even repositioning counting use, APP
still make unnecessary undo moves. useless undo move counts double final solution
length, since undo matched new forward move next progression step.
Improving solution length promising direction future work.
9.4 Running Time Analysis
case travel distance analysis, meaningful runtime comparison, restrict
analysis subset instances completed algorithms (FAR, W HCA * versions,
83

fiWANG & B OTEA

Total Travel Distance: Harder Case (700)
300000

Distance

250000
200000

MAPP Total
WHCA*(8,1) noD
FAR
MAPP Pi
WHCA*
MAPP Undos

150000

Total Distance Travelled (300)
400000
350000
300000
Distance

350000

250000
200000
150000

100000

100000

50000

50000

0
200

400

0
600 800 1000 1200 1400
Number agents

MAPP Total
WHCA* noD
FAR
MAPP Pi
WHCA*
MAPP Undos

200

MAPP Total
WHCA* noD
FAR
MAPP Pi
WHCA*
MAPP Undos

250000
200000

MAPP Total
WHCA*(8,1) noD
FAR
MAPP Pi
WHCA*(8,1)
MAPP Undos

150000
100000
50000
0

200 400 600 800 1000 1200 1400 1600 1800 2000
Number agents

200 400 600 800 1000 1200 1400 1600 1800 2000
Number agents

Total Distance Travelled (414)
300000

Distance

250000
200000

MAPP Total
WHCA* noD
FAR
MAPP Pi
WHCA*
MAPP Undos

150000

Total Distance Travelled (500)
300000
250000
Distance

350000

200000

MAPP Total
WHCA* noD
FAR
MAPP Pi
WHCA*
MAPP Undos

150000
100000

100000

50000

50000
0

600 800 1000 1200 1400
Number agents

Total Travel Distance (204)
300000

Distance

Distance

Total Distance Travelled (400)
500000
450000
400000
350000
300000
250000
200000
150000
100000
50000
0

400

0
200 400 600 800 1000 1200 1400 1600 1800 2000
Number agents

200

400

600 800 1000 1200 1400
Number agents

Figure 11: Distance travelled continued: remaining six maps.

I+AC+R C APP attempt-all feature turned on). show overall summary data,
Tables 2 3, charts 10 maps, Figures 12 13.
implementation APP builds scratch required paths, including -paths.
However, -paths re-used instances map. -paths
contain target current instance might recomputed. small percentage
-paths, since number targets typically much smaller map size.
evidence strongly supports taking -path computations offline map pre-processing step
improve APPs running time. Hence, distinguish case APP performs
computations scratch, case alternate paths (i.e., paths) already
available (e.g., previous instances map hand, result preprocessing). Note
84

fiM APP : CALABLE ULTI -AGENT PATH P LANNING

Time ratio:
Average
Min
Max

vs FAR
10.14
2.90
60.46

vs W HCA *
0.96
0.08
4.57

vs W HCA *+d
0.93
0.11
4.92

Table 2: APPs runtime divided runtime FAR, W HCA *, W HCA *+d. table,
assume APP performs computations, including alternate-path search,
scratch.

Time ratio:
Average
Min
Max

vs FAR
2.18
0.56
7.00

vs W HCA *
0.21
0.01
0.99

vs W HCA *+d
0.19
0.01
0.70

Table 3: APPs runtime divided runtime FAR, W HCA *, W HCA *+d. table,
time compute alternate paths omitted, could re-used instances
map.

FAR W HCA *, computation depends every units start target locations,
therefore cannot easily taken map pre-processing step (since storing entire search trees
take much memory practical).
Table 2 shows that, APP performs computations scratch, comparable
speed W HCA *, actually slightly faster average. However, version APP
10 times slower FAR average. paths already available, APPs speed
improves significantly, -path computation expensive part APP. seen
Table 3, APPs speed ratio vs FAR reduces 2.18. APP becomes 4.85.2 times faster
W HCA *(with without diagonals) average.
Figure 12 shows detailed runtime data 8 10 maps. Even computation scratch, APP faster W HCA *+d (i.e., diagonal moves enabled).
often faster, least comparable, W HCA * without diagonals. APP offline preprocessing reasonably close FAR, even though FAR consistently faster least comparable
APP. remaining two maps, represent difficult cases APP, presented
Figure 13. map 700 especially, largest data set, significantly larger
rest (almost 24 times larger), APP significantly higher total time, shown top
right Figure 13.
break APPs total running time (shown bottom Figure 13 map 700)
consistently shows search time dominates. Furthermore, node expansions, node
expansions generally several times greater node expansions, resulting majority
path computation time spent searching -paths.
85

fiWANG & B OTEA

Total Running Times (411)
400

WHCA*(8,1) noD
WHCA*(8,1)
MAPP total
MAPP preprocessing
FAR

300
250

120
100
Time (s)

350

Time (s)

Total Running Times (307)
140

200
150

80
60
40

100

20

50
0

WHCA*(8,1) noD
WHCA*(8,1)
MAPP total
MAPP preprocessing
FAR

200

400

0
100

600 800 1000 1200 1400 1600
Number agents

200

400

900

300

100
700

800

0
900

200 400 600 800 1000 1200 1400 1600 1800 2000
Number agents
Total Running Times (602)
400

WHCA*(8,1) noD
WHCA*(8,1)
MAPP total
MAPP preprocessing
FAR

350
300
Time (s)

Time (s)

400

800

200

WHCA*(8,1)
WHCA*(8,1) noD
MAPP total
MAPP preprocessing
FAR

500

700

WHCA*(8,1)
MAPP total
WHCA*(8,1) noD
MAPP preprocessing
FAR

500

Total Running Times (414)
600

400 500 600
Number agents

Total Running Times (204)
600

Time (s)

Time (s)

Total Running Times (603)
500
WHCA*(8,1) noD
450
WHCA*(8,1)
MAPP total
400
350 MAPP preprocessing
FAR
300
250
200
150
100
50
0
100 200 300 400 500 600
Number agents

300

300
200

250
200
150
100

100
0

50
0
200 400 600 800 1000 1200 1400 1600 1800 2000
Number agents
Total Running Times (300)

300

400
350
300
Time (s)

Time (s)

200
150
100

600
800
Number agents

1000

1200

MAPP total
WHCA*(8,1) noD
WHCA*(8,1)
MAPP preprocessing
FAR

250
200
150
100

50
0

400

Total Running Times (400)
450

WHCA*(8,1) noD
WHCA*(8,1)
MAPP total
MAPP preprocessing
FAR

250

200

50
200

400

600
800 1000
Number agents

1200

0
1400

200 400 600 800 1000 1200 1400 1600 1800 2000
Number agents

Figure 12: Runtime data averaged fully completed instances algorithms. Map IDs
displayed shorthand brackets. APP preprocessing stands version
computes alternate paths.

86

fiM APP : CALABLE ULTI -AGENT PATH P LANNING

Total Running Times (500)
140

Time (s)

120
100

Total Running Times: Worst Case (700)
350

WHCA*(8,1)
MAPP total
WHCA*(8,1) noD
MAPP preprocessing
FAR

MAPP total
WHCA*(8,1)
WHCA*(8,1) noD
250 MAPP preprocessing
FAR
200
300

Time (s)

160

80
60

150

40

100

20

50

0
200

400

600
800 1000
Number agents

1200

0
1400

200

400

600
800 1000
Number agents

1200

1400

MAPP Times Breakdown (700)
350

Total Runtime
Total Search
Omega Search
Repositioning

300

Time (s)

250
200
150
100
50
0
200

400

600
800 1000
Number agents

1200

1400

Figure 13: Top: hard cases I+AC+R C APPs total runtime. Bottom: time breakdown, showing -path computation takes majority APPs search time.

10. Conclusion
Traditional multi-agent path planning methods trade optimality, completeness, scalability. centralised method typically preserves optimality (theoretical) completeness,
decentralised method achieve significantly greater scalability efficiency. hand,
approaches shortcomings. former faces exponentially growing state space
number units. latter gives optimality offers guarantees respect completeness, running time solution length. new approach, aimed bridging missing links,
identifies classes multi-agent path planning problems solved polynomial time.
introduced algorithm, APP, solve problems classes, low polynomial upper
bounds time, space solution length.
performed detailed empirical evaluation APP. extended APPs completeness
range reaches 92%99.7%, even challenging scenarios 2000 mobile units.
completeness range even better scenarios fewer units. data set, APP significantly better percentage solved units (98.82% provably solvable, 99.86% attempt-all
mode) FAR (81.87%) W HCA * (77.84% 80.87%, without diagonal moves).
attempt-all version APP solves 1326% instances benchmark algorithms.
87

fiWANG & B OTEA

instances solved algorithms, APP significantly faster variants W HCA *,
slower fast FAR algorithm factor 2.18 average, alternate
paths needed instance readily available. performing computations scratch,
APPs speed comparable W HCA *. APPs solutions reported average 20% longer
FARs solutions 731% longer W HCA *s solutions. However, unlike algorithms
FAR W HCA *, APP offer partial completeness guarantees low-polynomial bounds
runtime, memory solution length. Thus, APP combines strengths two traditional
approaches, providing formal completeness upper-bound guarantees, well scalable
efficient practice.
findings presented open avenues future research large-scale multi-agent
pathfinding. long term, APP part algorithm portfolio, since cheaply
detect guaranteed solve instance. Thus worthwhile investigate tractable
classes, subclasses FAR complete. APP improved run faster,
compute better solutions, cover instances. Solution quality measured
total travel distance, terms makespan (i.e., total duration actions run
parallel) total number actions (including move wait actions). far, worked
relaxing two original LIDABLE conditions: target isolation alternate connectivity. Future
work could address initial blank condition. Moreover, initially non-S LIDABLE units
problem could become LIDABLE later on, LIDABLE units getting solved.
Extending APP instances units heterogeneous size speed another promising
direction.

Acknowledgments
NICTA funded Australian Governments Department Communications, Information
Technology, Arts Australian Research Council Backing Australias Ability
ICT Research Centre Excellence programs.
Many thanks Nathan Sturtevant providing HOG framework, help
understanding program. Thanks Philip Kilby, Jussi Rintanen, Nick Hay
many helpful comments. thank anonymous reviewers valuable feedback.

References
Barraquand, J., Langlois, B., & Latombe, J.-C. (1991). Numerical potential field techniques
robot path planning. International Conference Advanced Robotics (ICAR), Vol. 2, pp.
10121017.
Bulitko, V., Sturtevant, N., Lu, J., & Yau, T. (2007). Graph Abstraction Real-time Heuristic
Search. Journal Artificial Intelligence Research (JAIR), 30, 51100.
Choset, H., Lynch, K., Hutchinson, S., Kantor, G., Burgard, W., Kavaraki, L., & Thrun, S. (2005).
Principles Robot Motion: Theory, Algorithms, Implementation. MIT Press.
Erdmann, M., & Lozano-Perez, T. (1986). Multiple Moving Objects. IEEE International
Conference Robotics Automation (ICRA), pp. 14191424.
Geramifard, A., Chubak, P., & Bulitko, V. (2006). Biased Cost Pathfinding. Artificial Intelligence
Interactive Digital Entertainment conference (AIIDE), pp. 112114.
88

fiM APP : CALABLE ULTI -AGENT PATH P LANNING

Hart, P., Nilsson, N., & Raphael, B. (1968). Formal Basis Heuristic Determination
Minimum Cost Paths. IEEE Transactions Systems Science Cybernetics, 4(2), 100
107.
Hopcroft, J. E., Schwartz, J. T., & Sharir, M. (1984). complexity motion planning
multiple independent objects: PSPACE-hardness warehousemans problem. International Journal Robotics Research (IJRR), 3(4), 7688.
Jansen, R., & Sturtevant, N. (2008). New Approach Cooperative Pathfinding. International
Conference Autonomous Agents Multiagent Systems (AAMAS), pp. 14011404.
Kant, K., & Zucker, S. W. (1986). Toward Efficient Trajectory Planning: Path-Velocity Decomposition. International Journal Robotics Research (IJRR), 5(3), 7289.
Kornhauser, D., Miller, G., & Spirakis, P. (1984). Coordinating pebble motion graphs, diameter permutation groups, applications. Proceedings 25th Annual Symposium
Foundations Computer Science (FOCS), pp. 241250.
Latombe, J.-C. (1991). Robot Motion Planning. Kluwer Academic Publishers.
Papadimitriou, C., Raghavan, P., Sudan, M., & Tamaki, H. (1994). Motion planning graph.
35th Annual Symposium Foundations Computer Science, pp. 511520.
Pottinger, D. (1999). Coordinated Unit Movement. http://www.gamasutra.com/view/
feature/3313/coordinated_unit_movement.php.
Rabin, S. (2000). A* Speed Optimizations. Deloura, M. (Ed.), Game Programming Gems, pp.
272287. Charles River Media.
Ratner, D., & Warmuth, M. (1986). Finding shortest solution N N extension 15puzzle intractable. Proceedings AAAI National Conference Artificial Intelligence
(AAAI-86), pp. 168172.
Ryan, M. R. K. (2008). Exploiting Subgraph Structure Multi-Robot Path Planning. Journal
Artificial Intelligence Research (JAIR), 31, 497542.
Samet, H. (1988). Overview Quadtrees, Octrees, Related Hierarchical Data Structures.
NATO ASI Series, Vol. F40.
Silver, D. (2005). Cooperative Pathfinding. Artificial Intelligence Interactive Digital Entertainment conference (AIIDE), pp. 117122.
Silver, D. (2006). Cooperative pathfinding. AI Programming Wisdom, 3, 99111.
Standley, T. (2010). Finding Optimal Solutions Cooperative Pathfinding Problems. Proceedings Twenty-Fourth AAAI Conference Artificial Intelligence (AAAI-10), pp. 173178.
Stout, B. (1996). Smart Moves: Intelligent Pathfinding. Game Developer Magazine.
Sturtevant, N. R., & Buro, M. (2006). Improving collaborative pathfinding using map abstraction..
Artificial Intelligence Interactive Digital Entertainment (AIIDE), pp. 8085.
Surynek, P. (2009a). Application Pebble Motion Graphs Abstract Multi-robot Path Planning. Proceedings 21st International Conference Tools Artificial Intelligence
(ICTAI), pp. 151158.
Surynek, P. (2009b). novel approach path planning multiple robots bi-connected graphs.
IEEE International Conference Robotics Automation (ICRA), pp. 36133619.
89

fiWANG & B OTEA

Surynek, P. (2010a) personal communication.
Surynek, P. (2010b). Optimization Variant Multi-Robot Path Planning Intractable.
Proceedings 24th AAAI Conference Artificial Intelligence (AAAI-10), pp. 1261
1263.
Surynek, P. (2010c). Multi-robot Path Planning, pp. 267290. InTech - Open Access Publisher.
Tarjan, R. E. (1976). Edge-disjoint spanning trees depth-first search. Acta Informatica, 6(2),
171185.
Tozour, P. (2002). Building Near-Optimal Navigation Mesh. Rabin, S. (Ed.), AI Game Programming Wisdom, pp. 171185. Charles River Media.
Wang, K.-H. C., & Botea, A. (2008). Fast Memory-Efficient Multi-Agent Pathfinding. Proceedings International Conference Automated Planning Scheduling (ICAPS),
pp. 380387.
Wang, K.-H. C., & Botea, A. (2009). Tractable Multi-Agent Path Planning Grid Maps. Proceedings International Joint Conference Artificial Intelligence (IJCAI), pp. 1870
1875.
Wang, K.-H. C., & Botea, A. (2010). Scalable Multi-Agent Pathfinding Grid Maps
Tractability Completeness Guarantees. Proceedings European Conference
Artificial Intelligence (ECAI), pp. 977978.
Zelinsky, A. (1992). mobile robot navigation exploration algorithm. IEEE Transactions
Robotics Automation, 8(6), 707717.

90


