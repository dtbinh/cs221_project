journal artificial intelligence

submitted published

app scalable multi agent path
tractability completeness guarantees
ko hsin cindy wang
adi botea

c indy wang rsise anu edu au
di b otea nicta com au

nicta australian national university
canberra australia

abstract
multi agent path challenging numerous real life applications running centralized search combined state space units complete
cost optimal scales poorly state space size exponential number mobile units
traditional decentralized approaches far w hca faster scalable
decomposition however methods incomplete provide guarantees respect running time solution quality necessarily able tell
reasonable time whether would succeed finding solution given instance
introduce app tractable multi agent path undirected graphs
present basic version several extensions low polynomial worst case upper
bounds running time memory requirements length solutions even though
algorithmic versions incomplete general case provides formal guarantees
solve version discuss completeness respect
clearly defined subclasses instances
experiments run realistic game grid maps app solved mobile units
better percentage far w hca app marked
units provably solvable first stage plan computation parts apps computation
used across instances map speed wise app competitive significantly
faster w hca depending whether app performs computations scratch
data app use preprocessed offline readily available app slower
fast far factor average apps solutions average
longer fars solutions longer w hca solutions

introduction
path important many real life including robotics military operations disaster rescue logistics commercial games single agent path size state
space bounded size map tackled search hart
nilsson raphael however many units moving simultaneously inside
shared space becomes much harder centralized search initial state goal
state difficult even inside fully known two dimensional environment represented
weighted graph one node occupied exactly one unit time assuming
units size unit moves synchronously adjacent unoccupied node one
time step state space grows exponentially number mobile units existing
hardness shown np complete decide solution k moves exists ratner warmuth optimize solution makespan surynek b version
one robot movable obstacles several nodes robot
c

ai access foundation rights reserved

fiwang b otea

obstacle move adjacent vacant node per step np complete papadimitriou
raghavan sudan tamaki yet another version determining solution exists moving two dimensional rectangles different sizes inside box shown
pspace hard even without requiring optimality hopcroft schwartz sharir despite completeness solution optimality guarantees centralized search little practical
value multi agent path intractable even relatively small maps
collections mobile units
scalability larger achieved decentralized approaches decompose
global search series smaller searches significantly reduce computation however
existing decentralized methods far wang botea w hca silver
incomplete provide formal criteria distinguish instances
successfully solved instances guarantees given respect running
time quality computed solutions
work present combines strengths worlds working well
practice featuring theoretical tractability partial completeness guarantees introduce
app tractable multi agent path undirected graphs instance app systematically identifies set units contain units instance
guaranteed solved within low polynomial time sake clarity distinguish
basic version extended versions app app provides formal guarantees
solve basic app complete class called
lidable define section extended versions enlarge completeness range discussed section improve solution length discussed section
evaluate version attempts solve units provably solvable ones
given graph nodes n mobile units apps worst case performance
running time n even smaller e g max mn log depending
assumptions input instance worst case memory requirements within n
even mn upper bound solution length measured total number moves
order n even mn see section detailed discussion
app keeps running costs low eliminating need replanning path u
unit u computed beginning replanning required runtime blank travel
idea inspired way blank moves around sliding tile puzzles center
u
unit u progress current location liu next location li
path
u
u blank located e li empty intuitively next location currently
occupied another unit app tries bring blank along alternate path outlined bold
u
u
li
without passing liu possible blank
figure connects li
u
brought li shifting units along alternate path blank travels sliding tile
puzzle ability bring blank next location key guarantee units progress formal
details provided section
performed detailed experiments evaluating different versions app comparing
app fast incomplete methods far w hca grid maps
presented section benchmark data wang botea consist mobile
units uniformly randomly generated game maps scenario instances per number
units map conclude extended app significantly better success ratio
scalability state art incomplete decentralized particular app solves
higher percentage units even crowded instances despite apps incompleteness


fim app calable ulti agent path p lanning



b

u

l


u

c

b
c

figure left unit u blocked blank found location l along alternate
path marked bold contour right sliding b along
u sake clarity simplicity
alternate path blank brought li
illustrate examples four connected grid world

general case marks units provably solvable first stage
plan computation attempting solve units provably solvable ones app
succeeds units comparison far solved units w hca solved
diagonal moves allowed diagonal moves units even
challenging instances mobile units maps mobile units test
data fall within apps completeness range e provably solvable terms percentage fully solved instances version app attempts solve units
provably solvable successful instances significantly better
far w hca diagonal moves w hca diagonals
parts apps computation used across instances map instances
solved app competitive speed significantly faster w hca depending whether app performs computations scratch usable data
available app slower fast far factor average apps
solutions reported average longer fars solutions longer
w hca solutions
parts work reported shorter conference papers follows theoretical
description basic app experiments provided earlier wang botea
brief overview app extensions brief summary initial topic
two page wang botea material added current includes detailed
algorithmic description enhancements basic app formal proofs
properties provide comprehensive empirical analysis enhanced app several
additional experiments
rest structured follows next briefly overview related work
state definition section sections focus basic app sections
cover enhancements basic app extending completeness range section


fiwang b otea

improving quality plans running time section empirical evaluation
topic section last part contains conclusions future work ideas

related work
finding shortest path connects single pair start target points known finite map
optimally solved hart et al extension path
multiple simultaneously moving units distinct start target positions introduces potential
collisions due physical constraint one location occupied one unit
time units interact share information units path making
complex
multi agent path centralized performs single global search combined
state space l l ln n units li set possible locations unit
centralized plans paths units simultaneously finding joint plan containing units
actions waits well moves retains optimality completeness guarantees
prohibitively large state space mn states n units graph nodes moreover
search nodes generated unpromising taking units farther goal standley
poses strong limiting factor centralized solve practice
hand purely decentralized method local repair l ra stout first
plans units path independently execution l ra replans additional
independent searches every time collision occurs good case l ra significantly
reduce computations mn however generate cycles units unable
prevent bottlenecks discussed silver bulitko sturtevant lu
yau pottinger zelinsky cases l ra exhibits significant
increase running time may terminate therefore straightforward extensions
single agent outlined strong limitations practice
traditionally multi agent path took centralised decentralised latombe
choset et al centralized plans globally sharing information centrally
potential field barraquand langlois latombe contrast decentralized decomposes series smaller subproblems typically first computing units paths individually ignoring units handling interactions online
examples robotics include computing velocity profiles avoid collisions units kant
zucker pre assigning priorities process robots one one erdmann lozanoperez recent use combination two approaches instance
biased cost pathfinding bcp technique geramifard chubak bulitko generalised
notion centralized central decision maker resolves collision points paths
pre computed independently per unit replanning colliding units around highestpriority unit avoid excessively long even potentially unbounded conflict resolutions limit
time set bcp returns paths fewest collisions within time
shown work well small scale gridworld scenarios complete optimal
general case standleys hand improved standard centralized
search whilst preserving optimality completeness state space representation incorporates next move assignments every unit state decomposes timestep
advancing units advancing units one one fixed ordering thus branching factor
reduced n increasing depth search factor n technique gen

fim app calable ulti agent path p lanning

erates nt state nodes perfect heuristic number timesteps
optimal solution practice operator decomposition technique od still often intractable
producing lower exponential search space standard joint search space recognising
much cheaper perform several independent searches one global search standley
decoupled non interfering subgroups units independence detection id
group solved centrally optimality overall solution still guaranteed
fully developed hybrid od id uses operator decomposition improve centralized non independent subproblems nonetheless optimality requirement costly
practice time still dominated largest subgroup units number
units increases less likely independent paths unavoidably overlap
subgroups expected increase size standleys experiments showed incomplete hca silver actually solved instances furthermore
relatively small compared experiments wang botea
least orders magnitude fewer agents units much smaller maps
orders magnitude fewer tiles approximately tiles
therefore methods tackling larger take decentralized usually suboptimal nature general giving optimality reduces computation significantly decentralized path often much faster scales much larger yields
suboptimal solutions provides completeness guarantees recent work grid maps include
w hca silver uses dimensional temporal spatial reservation table performs
series windowed forward searches unit true distance heuristic obtained
initial backward search target far wang botea
units follow flow annotation map moving repairing plans locally
heuristic procedures break deadlocks flow related ideas include jansen sturtevants
direction map sharing information units directions travel later units
follow movement earlier ones improved coherence leading reduced collisions
methods scale instances number units well beyond capabilities
centralized search however mentioned earlier methods known formal characterizations running time memory requirements quality solutions worst
case lack ability answer reasonable bounded time whether given would
successfully solved important case incomplete
practice traditional approaches multi agent pathfinding serious drawbacks
inherent trade scalability optimality completeness recently body work
begun bridge gap two addressing completeness tractability issues
hand hand bounded suboptimal ryan introduced complete method
combines multi agent path hierarchical search graphs specific substructures stacks halls cliques rings example stack narrow corridor
one entrance placed one end stack many maps including game maps
used experiments seem allow efficient decomposition stacks halls cliques
rings b ibox surynek b solves least unoccupied vertices biconnected graph worst case number steps cubic number nodes b ibox
later extended work unoccupied vertex necessary surynek
densely populated designed surynek expressed
b ibox target computer game scenarios normally lot fewer units
locations map b ibox suited multi robot scenarios automatic packages


fiwang b otea

inside warehouse surynek c bibox surynek requires unoccupied
node shown run significantly faster significantly shorter solutions kornhauser
miller spirakiss related pebble coordination game performed
quick evaluation b ibox code obtained author found graphs
order magnitude smaller game maps b ibox exhibits fast growing runtime e g
minutes graph locations long solutions millions moves
part explanation b ibox builds instances crowded understanding
b ibox designed solve crowded instances necessarily efficiently solve instances
significantly fewer units locations

statement
instance characterized graph representation map non empty collection
mobile units u units homogeneous speed size unit u u associated starttarget pair su tu units distinct starting target positions objective navigate
units start positions targets avoiding fixed mobile obstacles state
contains positions units given time work assumes undirected weighted graphs
unit occupies exactly one node time move unoccupied neighbour
node time discretized one units move synchronously time step
travelling along edge depend interfere rest except
two nodes connected edge
several methods exist abstract map search graph including navigation
meshes tozour visibility points rabin quadtrees samet however
graph abstraction generates nodes visibility graph may render multi agent
pathfinding unsolvable even though works single agent case hand
search graph obtained imposing regular grid contains nodes covering locations
traversable space offers path options avoid collisions units hence
grid maps besides popular easy implement suitable multi agent
clarity practicality focus grid maps examples experiments
nonetheless conditions algorithmic definitions app introduce next
sections specific regular grid maps illustrated examples assume
straight moves four cardinal directions performed connected grid restricting
movements directions cardinal diagonals cardinal directions negative impact
completeness since standard practice allow diagonal move equivalent
longer two move path exists every solution allows diagonal moves solution
cardinal moves therefore diagonal moves reduced
straight moves price possibly taking longer paths introducing diagonal moves could
reduce path length potential drawback blocking units often straight
moves crowded maps whether enough clearance make diagonal move depends
two adjacent nodes e two tiles sharing common corner grid since
physically impossible squeeze two units

lidable class instances
introduce subclass instances basic app shown complete



fim app calable ulti agent path p lanning




u

u


u lu denoted
figure example alternate path connecting locations li

picture belong precomputed path u unit u

definition lidable unit lidable instance mobile unit u lidable iff path
u
u
u l u l u l u
nodes exists l u su l u
tu following
conditions met
u lu lu u except
alternate connectivity three consecutive locations li

last triple ending tu e u alternate path ui exists
u lu go lu see figure example
li



initial blank initial state l u blank e unoccupied
target isolation target interferes paths units formally
following hold tu
v u u tu
v
b v u v tu
vi
instance belongs class lidable iff units u u lidable
three conditions verified polynomial time verification includes attempting
compute paths unit since state space explore linear
search time polynomial checks blank location first step
passing targets trivial process checks lidable conditions
serves important additional purpose time checks succeed instance known
belong lidable completed search needed solve instance
remaining part simply tell units wait move forward
move backwards along already computed paths
notice three conditions restricted grid maps work standard
assumption one graph node occupied one unit time moving along
edge neither depends interferes parts graph except two nodes ends
edge


fiwang b otea

overview app
u u

compute u needed su tu

lidable conditions hold

mark u lidable
initialize set lidable units optional make units active discussed text


progression step

repositioning step needed

basic app
present basic version app complete lidable class
main feature basic app extensions presented sections
deadlock free cycle free due total ordering active units units lower priority
interfere ability higher priority units advance
illustrated instance app starts computing path u
unit u target goal constructing caching alternate paths along way note
paths alternate paths need satisfy conditions definition loop
lines succeeds units app tell instance hand belongs lidable
app complete
subset units marked lidable app guaranteed solve
equivalent solving smaller instance lidable optionally app attempt
solve remaining units well adding set active units giving lower
priority lidable units important stress remaining part
implicit assumption app attempts solve provably solvable units unless
explicitly state opposite experiments section however discuss options
set lidable units partitioned subset solved units already reached
targets subset active units initially units active lidable class
becoming solved units interfere rest ensured target
isolation condition shown later basic app solved units never become active
considered remaining part solving process
definition advancing condition active unit u satisfied iff current position pos u
belongs path u next location path blank
definition state well positioned iff active units advancing condition satisfied
lines describe series two step iterations progression step advances
active units towards targets shown later progression step brings least one active
unit target shrinking active set ensuring terminates reaching
state units solved progression could breaking advancing condition
one active units remain objective repositioning step ensure
active unit advancing condition satisfied starting next progression step note
repositioning step necessary every progression step except last


fim app calable ulti agent path p lanning


b

b





b

b





b


b



b
ii

b
iii

b
iv

v

figure example app works

example
simple example app works illustrated figure two units b
app uses total ordering active units progression step section
higher priority b targets b drawn stars figure b progress
towards targets becomes blocked b ii blank brought front sliding
b ai outlined bold side effect b pushed path end current
progression step iii reaches target repositioning step iv since already solved
moves ignored repositioning undoes bs moves b back path blank
front bs advancing condition restored therefore global state example
well positioned next progression step v b reaches target terminates
path computation
instance compute path u individually paths u fixed
throughout solving process ensure paths satisfy alternate connectivity condition
definition modify standard follows expanding node x
neighbour x added open list alternate path x x parent
x process compute path u family alternate paths simultaneously
give neighbour x node x chance added open list node x might
expanded three times per possible parent x therefore node expansions
required search path number locations map
equivalently computing path could seen standard search extended space
pairs neighbouring nodes four nodes created extended space original
node
since alternate paths depend triple locations unit use information paths units means alternate path
set three adjacent tiles map computed per instance
cached later use given location l grid map eight locations could
path two moves away four connect grid shown figure eight locations
form diamond shape around l four locations straight line l


fiwang b otea







l















l

ii













b

figure eight locations two moves away l b two two move paths l location
go ii

locations precompute alternate path avoids location
targets four locations labeled need compute two
alternate paths example two possible paths l two moves long
ii figure b need one alternate path avoid intermediate location
ii summary precompute paths l locations map
need
alternate paths one computation triple since alternate
path connects two endpoints ways
possible optimization reuse alternate paths across lidable instances map
alternate paths overlap targets instance need computed discuss
option experiments section
progression
shows progression step pseudocode iteration outer loop active
units attempt progress one move towards targets processed order line
unit v processed unit w say v higher priority write v w ordering
fixed inside progression step may change one progression step another actual
ordering affects neither correctness completeness method may impact
speed solution length ordering units chosen heuristically e g giving higher
priority units closer target thus units could get target quickly
solved way remaining units
ensure lower priority units harm ability higher priority units progress
introduce notion private zone see unit cannot cause
moves occupy private zone higher priority unit given unit u let pos u
u
current position let int u l u l u
interior precomputed path
u shown unit u might get pushed precomputed path case
pos u
u
u lu pos u lu int u
definition private zone u unit u u li


otherwise u pos u words private zone includes current location

move caused unit u move u along u path move different unit w
pushed around u side effect blank travel



fim app calable ulti agent path p lanning

progression step
changes occur

u order

pos u
u

nothing u pushed track blank travel
u current progression step

else u already visited li

nothing
u belongs private zone higher priority unit e

else next location li
u
v u li v
u released v

nothing wait li
u blank

else li
u

move u li
u

else bring blank li
u

bring blank li
u

move u li

else

nothing

unit addition unit pre computed path start position location
behind unit belongs private zone well
lines processing u active unit hand u pushed
precomputed path action taken lines lines cover situation
unit u pushed around via blank travel higher priority units back location u
already visited current progression step case u doesnt attempt travel
previously traversed portion path ensuring bounds total travelled distance
u
introduced later hold u path next location li
currently blocked higheru available u
priority unit v action taken lines otherwise next location li
u
moves lines finally li occupied smaller priority unit attempt made
u
first bring blank li
u move lines u moves
u
u target location u
location li lines test performed check li
case u marked solved removing adding set solved
units
u
bringing blank li
lines illustrated figure discuss
process detail location l ui sought following properties l blank
u inclusive along u belongs private zone higher none locations l li

u
priority unit l closest along ui li
property location l
u
found test line succeeds actual travel blank l li
along ui
line identical movement tiles sliding tile puzzle figure shows example
u
blank traveling intuition behind seeking blank along ui often li
u lu test line
remains blank time interval u advances li

performed guaranteed hold case active unit highest priority
call master unit
let us introduce characterize behaviour master unit formally beginning progression step one master unit u selected unit highest priority among


fiwang b otea

units active beginning progression step status master unit
preserved entire progression step even u becomes solved beginning
next progression step master unit selected among remaining active units
lemma master unit u bring blank front needs one
u belongs private zone u unit
proof since us previous location li
u
move private zone highest priority unit u guaranteed blank li
u lu belong private zone higher priority
moreover location along ui li

unit since units higher priority note ui free physical obstacles
u lu
construction must possible blank travel li


lemma master unit u never pushed path
proof u pushed u blank travelling performed another unit contradicts u
highest priority unit
theorem long master unit u solved guaranteed advance along u
iteration outer loop end current progression
step least u reached target
proof previous two lemmas easy check u never enters nothing line
similar lemma u never pushed cannot revisit previous location
since u highest priority next location cannot held private zone another unit
hence us progress target guaranteed
following useful ensure progression step terminates
state units solved state remaining active units stuck
theorem generates cycles e repetitions global state
proof proof contradiction assume cycles consider cycle
active unit u cycle highest priority since unit cycle dominates u
means movements u cannot part blank travel triggered higher priority unit
therefore movements u line line us moves
along path u since u contains cycles u cannot run cycle
repositioning
end progression step remaining active units left
advancing condition broken recall happens unit u pos u
u u
placed precomputed path next location path blank repositioning
step ensures well positioned state reached e active units advancing condition
satisfied starting next progression step
simple computationally efficient method perform repositioning undo block
recent moves performed preceding progression step undoing move means carrying
reverse move solved units affected remaining active units undo
moves reverse global order well positioned state encountered call strategy
reverse repositioning example provided section


fim app calable ulti agent path p lanning

proposition reverse repositioning strategy used line needed
progression steps start well positioned state
proof lemma proven induction iteration number j since
initial state well positioned follows easily definitions proof j
trivial assume repositioning step performed starting iteration j
worst case reverse repositioning undoes moves remaining active units
moves units become solved back original positions beginning j th
progression step words reach state similar state beginning
previous progression step except units targets since well
positioned according induction step follows easily well positioned

worst case best case analysis
give bounds runtime memory usage solution length app
lidable n units map traversable tiles examine worst case
scenario case discuss best case scenario end
introduce additional parameter measure maximal length alternate paths
worst case grows linearly however many practical situations small constant
since ends path close analysis discusses scenarios
theorem worst case running time max n log
constant n grows linearly
proof outlined section single agent search consistent heuristic expands
nodes hence assuming open list implemented priority queue search
takes log time note graphs edges cost log factor
could principle eliminated breadth first search optimal path grid maps
cardinal moves fit category however simplicity assume log
factor present
hence worst case searches paths take nm log time n units
searches take log time
single progression step outlined suppose blank travel required n
units every move along way except first last moves since length paths
bounded length alternate paths bounded total number moves
progression step nm running time
clearly complexity repositioning step cannot exceed complexity previous
progression step hence complexity iteration lines nm
number iterations n since size reduces least one iteration
app takes max nm log log n time run max n log
constant n grows linearly
theorem maximum memory required execute app nm constant
nm grows linearly
well known manhattan heuristic used implementation consistent proof
easy direct definition consistency way manhattan distance computed
pretending obstacles map



fiwang b otea

proof caching possible paths entire described section takes
memory searches paths performed one time search stored
cache memory used open closed lists released working memory
takes space storing paths takes nm space overall path computation
across units requires nm space
lines memory required store stack moves performed
one progression step used repositioning shown proof theorem
number moves progression step within nm overall maximum memory
required execute program nm nm constant nm
grows linearly
theorem total distance travelled units n constant
n grows linearly
proof shown previously number moves progression step within nm
number moves repositioning step strictly smaller number moves previous
progression step n progression steps followed repositioning steps hence
total travelled distance within n
corollary storing global solution takes n memory constant n
grows linearly
discuss best case scenario app computes optimal solutions number moves
paths optimal units reach targets without blank traveling e units
travel along paths obvious example paths disjoint case
solutions makespan optimal well preserving optimality best case search
effort app smaller spent centralised search n single agent

searches compared searching combined state space n units mn
states

extending completeness range
extend apps completeness beyond class lidable evaluated impact
three lidable conditions preliminary experiment ran basic app data
set used main experiments data set main experiments described
section preliminary experiment switched one lidable condition time
counted many units satisfy remaining two conditions larger increase number
solvable units suggests relaxing definition condition hand could provide
significant increase completeness range
initial experimental evaluation indicates basic app three lidable conditions solves units basic case alternate connectivity requirement switched
units satisfy remaining two conditions switching target isolation makes
units satisfy remaining two conditions however ignoring blank availability condition
small impact increasing percentage slightly basic case
suggest alternate connectivity target isolation conditions restrictive blank availability condition thus focus relaxing two conditions


fim app calable ulti agent path p lanning

target isolation extension allows unit plan path targets
still guarantee clearly identified set units reach targets topic
section extend alternate connectivity developed technique allows paths
planned regions alternate paths tunnels blank travelling operation
tunnel crossing unit uses blank positions ahead unit along remaining
pre computed path describe detail section empirical analysis
features provided section
relaxing target isolation condition
several targets close target isolation condition forbidding paths
pass targets make targets behave virtual wall disconnecting two areas
map basic app report many units non lidable
extension introduce allows unit u plan path target another unit v
subsequently v never assigned higher priority u specifically partial ordering
defined u v iff target v belongs path u
path along us
u
ui every
path written formally u v iff tv u u u ki
time mention refer transitive closure section paths
planned way possibly empty relation creates cycles type u u
instance solved slight modification basic app
units plan paths foreign target choice
achieve strategy searches assign high cost graph search edges adjacent
foreign target desirable outcome reducing interactions caused target
isolation relaxation particular way original lidable units compute paths
preserved foreign targets crossed cases words instances lidable
characterized empty relation
definition instance belongs class lidable iff every unit u exists path u
satisfying alternate connectivity initial blank condition definition lidable
definition furthermore cycles allowed relation
assume moment possibly empty relation without cycles available aspects
related obtaining one discussed later section
definition solving lidable instances extended app two
small modifications original
total ordering inside progression step stays consistent u v u v
u v v cannot marked solved e moved unless u already
marked solved
extra conditions hand ensure even unit x arrives target tx
units clear tx paths units get past x performing normal blank
travel following x undo moves back tx repositioning step basic app
prove app terminates first prove following two lemmas hold highest
priority unit u progression step


fiwang b otea

lemma unit visit target u tu current progression step
proof since u master unit follows u v active unit v according
point definition follows u v relation cycles means v u
therefore applying definition follows tu
v completes proof
app movements performed along paths
since repositioning step undo moves made previous progression step units
revisit locations visited progression step following direct
lemma
corollary unit visit tu repositioning step follows
corollary u solved cannot interfere rest
theorem app terminates
proof showing least highest priority unit u reaches target given progression step
virtually identical proof lemma corollary guarantees solving u
interfere rest hence number active units strictly decreases
progression step eventually terminates
let us get back question provide cycle free relation testing whether
units plan paths way cycle introduced might end expensive
unit u cant possibly avoid targets might choose crossing
target v crossing target w one option might lead cycle whereas might
avoid cycles therefore systematic search might required seek cycle free relation
rather searching systematically app takes cheaper greedy
cycles mark number units lidable selected way
units remain cycle free call lidable units lidable units
guaranteed solved
greedy app complete class lidable still
complete superset lidable able identify many units often
provably solved
finally wrap discussion extension concluding upper bounds
app given section still apply app proof identical make
worst case assumptions master unit gets solved progression step
every move along units path requires blank travel moreover note additional step
path pre computation topologically sorting partial order linear priority order
done cheaply time linear number units tarjan
relaxing alternate connectivity condition
section previous extension target isolation significantly improves
apps success ratio e percentage solvable units yet significant room
improvement particular maps single width tunnels still showed bottleneck terms
success ratio tunnels make alternate connectivity condition connecting two ends
consecutive triple locations without going middle harder even impossible


fim app calable ulti agent path p lanning

satisfy single width tunnel bridges two otherwise disjoint regions shown figure
versions app presented far fail path two regions alternate
connectivity broken triples inside tunnel

figure example units targets side way
cross single width bridge units drawn circles corresponding targets
squares shade

section introduce buffer zone extension solution relaxing alternate
connectivity condition allows many paths corresponding many units cross singlewidth tunnel intuition simple often plenty blank positions ahead unit along
remaining locations precomputed path corresponding paths along
tunnel crossing operation essentially generalisation blank travelling blank position
sought path ahead instead alternate path current location triple
definition precomputed path u crosses tunnels define following
buffer zone u portion u target end
last tunnel thesj th move u together corresponding alternate paths
u
liu ui
j ku

dynamic counter u keeps track many positions buffer zone blank
counter initialized beginning appropriate value incremented
decremented necessary later
threshold u set length longest tunnel crossed
unit u threshold acts minimal value u guarantees u cross
tunnels safely



fiwang b otea

unit u attempts cross tunnel push units lower priorities closest blank
locations buffer zone u exits tunnel tunnel crossing operation
possible enough blanks available buffer zone analyse extended
detail introduce extended class ac lidable whose definition includes
units meeting buffer zone extension
definition relaxing alternate connectivity condition allow u go one
single width tunnels iff enough blanks us buffer zone least u blank
locations u initial state e u u alternate paths still
needed locations outside tunnels
definition unit u u belongs extended class call ac lidable iff
path u meeting initial blank target isolation conditions given definition
lidable definition relaxed alternate connectivity condition definition
ac app modified basic app following two ways integrate buffer
zone technique relaxing alternate connectivity condition firstly repositioning step cannot
finish counter value threshold words need ensure
enough blanks available buffer zone progression step begins following
advancing condition updated definition adding extra aforementioned condition
definition advancing condition active tunnel crossing unit u satisfied iff current
position belongs path u next location path blank given definition
u u
secondly need preserve one basic apps main features units lower priority
never block units higher priority ensuring app run cycles deadlocks
hence unit u lower priority v cannot cause moves bring v
threshold e v v recall move caused u move
u along u path checked lines move different unit
w pushed around u side effect blank travel checked lines
thus buffer zone u acts generalised private zone u holds least
u locations accessible units lower priorities
extensions ac app maintain following properties basic app
lemma long master unit u solved guaranteed advance along u
iteration outer loop end current progression
step least u reached target
proof follows directly proof lemma parts
compared progression step basic app check
lines modified blank travelling operation lines since u highest priority
current progression step cause moves affecting buffer zone every unit
unit move buffer zone u would bring number blanks
threshold e u u hence u guaranteed enough blanks cross
tunnel u
proof lemma similar lemma section


fim app calable ulti agent path p lanning

u
ac app canbringblank unit u location li
u outside tunnels

look nearest blank b along ui
else u inside tunnel

look nearest blank b u
b found

return false
u segment along u u
location l b li


v u l v check causing another unit move private zone
higher priority unit v

return false

else v u l v v v check causing another unit
move buffer zone higher priority unit v

return false
return true

ac app progression step
changes occur

u order

pos u
u

nothing
u

else v u li
v

nothing
u

else v u li
v v v check moving
buffer zone higher priority unit

nothing wait v blanks buffer zone
u current progression step

else u already visited li

nothing
u blank

else li
u

move u li
u

else canbringblank u li
u

bring blank li
u

move u li

else

nothing

lemma generates cycles e repetitions global state
theorem ac app terminates
proof follows lemmas number active units strictly decreases
successive iterations hence ac app eventually terminates
since shown ac app guaranteed solve class ac lid completeness shown follows directly

able



fiwang b otea

corollary ac app complete class ac lidable
ac app extension preserves upper bounds running time memory usage solution length given section introduce max denote maximal length tunnels
units cross worst case analysis units initiate blank travelling every move along
way involves tunnels depending whether max maximal length
paths longer ac app runs n mmax n time since parameters
often constant practice grow worst linear running time n n
bounds total travel distance global solution follow directly lastly
virtually additional memory required storing buffer zones except one counter one
threshold variable per unit
combining target isolation alternate connectivity relaxations
two extensions lidable class combined
definition instance belongs extended class ac lidable iff every unit u
exists path u meeting initial blank condition given definition relaxed
alternate connectivity condition definition furthermore possibly empty relation
introduced target isolation relaxation cycle free definition
obtain extended ac app combining app definition
ac app
theorem ac app terminates
proof proof lemma least highest priority unit u reaches
target progression step follows definition u guaranteed enough blanks
clear single width tunnels along path definitions guarantee
outside tunnels u bring blank needed stated lemma furthermore
progression step generates cycles proved cases lemmas
know solved unit u interfere rest
lemmas corollary note tricky cases units
targets inside single width tunnels excluded extended class ac lidable
zero buffer capacity according defined definition
since iteration solves least one unit ac app terminates

improving solution length
mentioned avoid replanning units pushed track blank travelling units
undo moves get back paths immediate repositioning step
observed practice reverse repositioning strategy defined section introduce
many unnecessary moves increase solution length increase running time may
hurt visual quality solutions
recall standard reverse repositioning step moves added solution
built moves undo reverse order moves active units e solved
yet made previous progression step process continues well positioned state


fim app calable ulti agent path p lanning

u

v

u

v

v

v

u

u

figure two examples global checking well positioned state

reached means active units advancing condition satisfied e every
active unit path blank front
undo move well positioned check performed globally words basic
app checks advancing condition active units unit affected
recent undo move global checking guarantees eventually reach well positioned state
proved proposition mentioned earlier often create many unnecessary moves
provide two simple examples figure illustrate one case global checking
useful one case global checking strong condition adding unnecessary moves
first consider two units u v undoing one move global moves stack places u
back path blank front assume us current position way vs
future undo moves shown left figure therefore even us advancing condition
satisfied u needs additional undo moves make room undo moves units v
order reach globally well positioned state case global checking useful second
example imagine u vs moves recent progression step independent
possibly even two map areas far away simple case shown
right figure recent progression vs last move v derailed followed
sequence us moves final move u pushed track whereas preceding
moves along us path u reverse repositioning would undo moves reverse global
order means undoing us moves undoing vs last move however one undo
move u one undo move v sufficient restore units well positioned state
illustrated global checking advancing condition could strong whereas
local checking could insufficient solution introduce section
called repositioning counting finds middle ground two extremes improves
number moves still maintains guarantee reaching well positioned state intuitively
undo moves unit u stop soon us advancing condition satisfied b
current position cannot possibly interfere future undo moves units c unit
performing repositioning possibly stop blank position front u us path


fiwang b otea

u doesnt stop initial second location another active unit v initial second
location unit v position ahead v beginning recent progression step
fourth condition ensures units blank front end worst case
revert back initial position beginning recent progression step
definition location l path keep counter c l
beginning progression step counter c l reset l empty
l occupied
every time l visited progression step c l incremented
every time unit leaves l undo move repositioning step c l
decremented
following directly definition c l given formulate following two
c l repositioning time
lemma c l unit pass l remaining part current
repositioning step
lemma given active unit u current position pos u c pos u
progression moves location pos u already undone words
unit remainder repositioning step pass pos u
introduce enhancement app aimed eliminating many useless undo
moves repositioning steps
definition enhanced r c app uses repositioning counting strategy
line means active unit u stops undoing moves current
repositioning step soon meets following conditions
advancing condition u satisfied according definition plus extension definition
b us current location pos u c pos u
u c lu
c location front u li


current location initial second location another active unit
theorem repositioning steps r c app end well positioned state
condition ignored without invalidating ability make progress towards goal state even
units could possibly end state without blank front guaranteed least one unit e
one finishes repositioning first blank front guarantees least one unit
solved next progression step



fim app calable ulti agent path p lanning

proof recall moves made progression step kept totally ordered list
prove directly repositioning counting undoing subset moves reaches wellpositioned state since counter c l incremented decremented according definition
unit u satisfying three conditions definition restored advancing condition
furthermore combined lemmas guarantee units later
get us way u way units repositioning moves

theorem applying r c repositioning steps extended ac app
negative impact completeness

experimental
section present empirical evaluation app first point
impact newly added feature put ac r c enhanced app test
comparison existing state art decoupled incomplete methods specifically
benchmarks far wang botea extended version silvers w hca
sturtevant buro called w hca w applies abstraction
expensive initial backward searches app tested rather
large terms map size number units aware programs
scale well far w hca strengths two methods potential ability
solution quickly weakness cannot tell whether would able
solve given instance
implemented app scratch integrated hierarchical open graph hog
framework source code extended w hca w hca w sturtevant
buro extra features spatial abstraction diagonal moves without priority
system unit replanning obtained nathan sturtevant far
implementation used previous experiments wang botea
experiments run data set randomly generated instances used previously published work wang botea input grid maps largest game baldurs gate range traversable tiles size listed table
game maps quite challenging containing different configurations obstacles forming different
shapes rooms corridors narrow tunnels test map mobile units
increments minute timeout per instance set w hca w experiments
set window size w use first level abstraction seems
good parameter setting work sturtevant buro experiments comparing
w hca w hca work better data set abstraction allows w hca
build heuristic graph smaller actual graph movement takes
place far units make reservations k steps ahead recommended setting
experiments run ghz intel core duo imac gb ram


fiwang b otea

basic mapp

number slidable























total number agents



ti mapp
















ac mapp




number ac slidable

number ti slidable






total number agents























total number agents



ti ac mapp
number ti ac slidable























total number agents



figure mapps widened completeness range relaxation graph line represents
number units solved instances map provably solvable
units counted



fim app calable ulti agent path p lanning

far

number agents solved



























total number agents



whca diagonals

number agents solved























total number agents



whca diagonals

number agents solved























total number agents



figure success ratios averaged trials far w hca without
diagonals set instances timeout set minutes per
instance incomplete


fiwang b otea

map id
ar sr
ar sr
ar sr
ar sr
ar sr
ar sr
ar sr
ar sr
ar sr
ar sr

short id











nodes











table maps descending order terms number nodes

scalability percentage solved units
compare far w hca four versions app basic app original lid able definitions app version target isolation relaxation switched ac
app relaxing alternate connectivity condition ac app relaxing
target isolation condition alternate connectivity condition measure success ratio
defined percentage solved units note repositioning counting r c
considered section since impact success ratio designed
improve solution length
app versions used section attempt solve units provably solvable
e units marked lidable lidable ac lidable ac lidable respectively
reason want evaluate many units fall subclasses practice
next section data obtained version app attempts solve units
figure summarizes success ratio data version app
maps closer curve top diagonal line total number units better
success ratio map basic app exhibits mixed behaviour greater success ratio
six maps four challenging maps success ratio gets often
number mobile units increases maps common feature containing
long narrow corridors even single width tunnels connecting wider open regions
map thus surprising mentioned section alternate path target isolation
conditions identified greatest causes failing lidable path
relaxing target isolation condition app significantly improves success ratio
maps good success ratio higher achieved maps across entire
range number mobile units maps contain high proportion narrow
corridors single width tunnels
relaxing alternate connectivity well ac app yields excellent success ratio
unit numbers maps example scenarios units
http webdocs cs ualberta ca nathanst hog html
experimental maps viewed online http users cecs anu edu au cwang gamemaps
http www bioware com games baldurs gate



fim app calable ulti agent path p lanning

challenging according figures smallest success ratio map largest
one scenarios fewer mobile units ac app even better success ratios
next compare success ratio ac app bottom plot figure far
top plot figure w hca middle bottom figure without diagonals
respectively extended app clear winner terms scalability far w hca suffer
number units increased incomplete often time even scenarios
significantly fewer units units far solves units
w hca solves diagonal moves diagonal moves
units entire data set ac app solved units far solved
units solved w hca without diagonal moves
allowed respectively
scalability attempting solve units
previous section compare far w hca app ac app version
used attempts solve units provably solvable ones attempt feature
mentioned earlier achieved marking units active beginning active units
partitioned three categories provably solvable units reach target ii
units reached target iii units reached target location
still active units still cross location total ordering
active units must respect conditions units category higher priority units
category ii higher priority units category iii
attempt feature turned ac apps percentage solved units increases
section
next focus number solved instances instance considered solved iff
units solved app successful instances significantly better far
w hca diagonal moves w hca diagonals
attempt feature massive impact percentage fully solved instances improving might seem counter intuitive attempt feature
small impact percentage solved units great impact percentage solved instances explanation following app fails instance
small percentage units remain unsolved often one two
unsolved units failed instance managing solve remaining units well
attempt feature whole instance changing label failed solved even
though change overall percentage solved units small
remaining sections use attempt feature well reason increases
number solved instances therefore obtain larger set data analyse
total travel distance
factors may impact length plans lengths initial paths extra movements caused blank travel repositioning experiments length precomputed
paths virtually negative impact travel distance even apps paths
satisfy additional constraints avoiding targets possible similar
length normal unconstrained shortest paths longer average


fiwang b otea

rc improved travel distance map


mapp total
rc mapp total
mapp pre computed pi
mapp undos
rc mapp undos

distance moves
















number agents

figure typical case improved distances r c app normal app note precomputed paths affected r c enhancement

section first evaluate improvement repositioning counting r c
standard reverse repositioning compare total distance travelled r c app
far w hca
r educing u ndo oves
identified excessive undoing moves repositioning bottleneck basic app figure shows benefits repositioning counting r c enhancement described section figure compares total travelled distance well number undo moves
r c ac app shown r c app short ac app app short average case shown repositioning counting turns quite effective eliminating many
unnecessary undo moves help reach globally restored state averaged
entire data set r c app shorter undo distance app standard reverse
repositioning reducing total travelled distance average
c omparing otal istance far w hca
evaluate solution length attempt r c ac app compared far
w hca plot total travel distance averaged subset input instances
considered fully solve
figures average maps app length
precomputed paths number undo repositioning moves total travelled distance
according performance criterion set maps roughly partitioned three subsets
good case map app performs better w hca without diagonals
terms total travel distance even comparable far average case apps travel


fim app calable ulti agent path p lanning

total travel distance good case


whca nod
far
mapp total
whca
mapp pi
mapp undos






distance



distance

total distance travelled average case







whca nod
mapp total
far
whca
mapp pi
mapp undos

















number agents










total distance travelled


distance





whca nod
mapp total
whca
far
mapp pi
mapp undos








mapp total
whca nod
far
mapp pi
whca
mapp undos













number agents

total distance travelled


distance










number agents













number agents



figure distance travelled plotted averaged instances fully solved

distance roughly comparable w hca without diagonals maps belong
category finally harder case apps total distance increases faster rate
others direct increasingly larger number undo moves harder cases
include maps upon inspection cases typically involve
high number turns corners apps case high degree path overlapping
units keep close edge rounding corner obtain shorter paths
summarise overall apps travel distance ranges shorter w hca
without diagonal moves longer longer average compared
version w hca diagonal moves enabled apps total distance longer average
varying shorter longer compared far apps solutions range
shorter longer longer average
closer look reveals even repositioning counting use app
still make unnecessary undo moves useless undo move counts double final solution
length since undo matched forward move next progression step
improving solution length promising direction future work
running time analysis
case travel distance analysis meaningful runtime comparison restrict
analysis subset instances completed far w hca versions


fiwang b otea

total travel distance harder case


distance




mapp total
whca nod
far
mapp pi
whca
mapp undos



total distance travelled



distance






















number agents

mapp total
whca nod
far
mapp pi
whca
mapp undos



mapp total
whca nod
far
mapp pi
whca
mapp undos




mapp total
whca nod
far
mapp pi
whca
mapp undos







number agents


number agents

total distance travelled


distance




mapp total
whca nod
far
mapp pi
whca
mapp undos



total distance travelled


distance





mapp total
whca nod
far
mapp pi
whca
mapp undos












number agents

total travel distance


distance

distance

total distance travelled
















number agents






number agents

figure distance travelled continued remaining six maps

ac r c app attempt feature turned overall summary data
tables charts maps figures
implementation app builds scratch required paths including paths
however paths used instances map paths
contain target current instance might recomputed small percentage
paths since number targets typically much smaller map size
evidence strongly supports taking path computations offline map pre processing step
improve apps running time hence distinguish case app performs
computations scratch case alternate paths e paths already
available e g previous instances map hand preprocessing note


fim app calable ulti agent path p lanning

time ratio
average
min
max

vs far




vs w hca




vs w hca




table apps runtime divided runtime far w hca w hca table
assume app performs computations including alternate path search
scratch

time ratio
average
min
max

vs far




vs w hca




vs w hca




table apps runtime divided runtime far w hca w hca table
time compute alternate paths omitted could used instances
map

far w hca computation depends every units start target locations
therefore cannot easily taken map pre processing step since storing entire search trees
take much memory practical
table shows app performs computations scratch comparable
speed w hca actually slightly faster average however version app
times slower far average paths already available apps speed
improves significantly path computation expensive part app seen
table apps speed ratio vs far reduces app becomes times faster
w hca without diagonals average
figure shows detailed runtime data maps even computation scratch app faster w hca e diagonal moves enabled
often faster least comparable w hca without diagonals app offline preprocessing reasonably close far even though far consistently faster least comparable
app remaining two maps represent difficult cases app presented
figure map especially largest data set significantly larger
rest almost times larger app significantly higher total time shown top
right figure
break apps total running time shown bottom figure map
consistently shows search time dominates furthermore node expansions node
expansions generally several times greater node expansions resulting majority
path computation time spent searching paths


fiwang b otea

total running times


whca nod
whca
mapp total
mapp preprocessing
far






time



time

total running times
















whca nod
whca
mapp total
mapp preprocessing
far









number agents


















number agents
total running times


whca nod
whca
mapp total
mapp preprocessing
far



time

time







whca
whca nod
mapp total
mapp preprocessing
far





whca
mapp total
whca nod
mapp preprocessing
far



total running times



number agents

total running times


time

time

total running times

whca nod

whca
mapp total

mapp preprocessing
far








number agents

















number agents
total running times






time

time







number agents





mapp total
whca nod
whca
mapp preprocessing
far











total running times


whca nod
whca
mapp total
mapp preprocessing
far












number agents







number agents

figure runtime data averaged fully completed instances map ids
displayed shorthand brackets app preprocessing stands version
computes alternate paths



fim app calable ulti agent path p lanning

total running times


time




total running times worst case


whca
mapp total
whca nod
mapp preprocessing
far

mapp total
whca
whca nod
mapp preprocessing
far



time























number agents












number agents





mapp times breakdown


total runtime
total search
omega search
repositioning



time













number agents





figure top hard cases ac r c apps total runtime bottom time breakdown showing path computation takes majority apps search time

conclusion
traditional multi agent path methods trade optimality completeness scalability centralised method typically preserves optimality theoretical completeness
decentralised method achieve significantly greater scalability efficiency hand
approaches shortcomings former faces exponentially growing state space
number units latter gives optimality offers guarantees respect completeness running time solution length aimed bridging missing links
identifies classes multi agent path solved polynomial time
introduced app solve classes low polynomial upper
bounds time space solution length
performed detailed empirical evaluation app extended apps completeness
range reaches even challenging scenarios mobile units
completeness range even better scenarios fewer units data set app significantly better percentage solved units provably solvable attempt
mode far w hca without diagonal moves
attempt version app solves instances benchmark


fiwang b otea

instances solved app significantly faster variants w hca
slower fast far factor average alternate
paths needed instance readily available performing computations scratch
apps speed comparable w hca apps solutions reported average longer
fars solutions longer w hca solutions however unlike
far w hca app offer partial completeness guarantees low polynomial bounds
runtime memory solution length thus app combines strengths two traditional
approaches providing formal completeness upper bound guarantees well scalable
efficient practice
findings presented open avenues future large scale multi agent
pathfinding long term app part portfolio since cheaply
detect guaranteed solve instance thus worthwhile investigate tractable
classes subclasses far complete app improved run faster
compute better solutions cover instances solution quality measured
total travel distance terms makespan e total duration actions run
parallel total number actions including move wait actions far worked
relaxing two original lidable conditions target isolation alternate connectivity future
work could address initial blank condition moreover initially non lidable units
could become lidable later lidable units getting solved
extending app instances units heterogeneous size speed another promising
direction

acknowledgments
nicta funded australian governments department communications information
technology arts australian council backing australias ability
ict centre excellence programs
many thanks nathan sturtevant providing hog framework help
understanding program thanks philip kilby jussi rintanen nick hay
many helpful comments thank anonymous reviewers valuable feedback

references
barraquand j langlois b latombe j c numerical potential field techniques
robot path international conference advanced robotics icar vol pp

bulitko v sturtevant n lu j yau graph abstraction real time heuristic
search journal artificial intelligence jair
choset h lynch k hutchinson kantor g burgard w kavaraki l thrun
principles robot motion theory implementation mit press
erdmann lozano perez multiple moving objects ieee international
conference robotics automation icra pp
geramifard chubak p bulitko v biased cost pathfinding artificial intelligence
interactive digital entertainment conference aiide pp


fim app calable ulti agent path p lanning

hart p nilsson n raphael b formal basis heuristic determination
minimum cost paths ieee transactions systems science cybernetics

hopcroft j e schwartz j sharir complexity motion
multiple independent objects pspace hardness warehousemans international journal robotics ijrr
jansen r sturtevant n cooperative pathfinding international
conference autonomous agents multiagent systems aamas pp
kant k zucker w toward efficient trajectory path velocity decomposition international journal robotics ijrr
kornhauser miller g spirakis p coordinating pebble motion graphs diameter permutation groups applications proceedings th annual symposium
foundations computer science focs pp
latombe j c robot motion kluwer academic publishers
papadimitriou c raghavan p sudan tamaki h motion graph
th annual symposium foundations computer science pp
pottinger coordinated unit movement http www gamasutra com view
feature coordinated unit movement php
rabin speed optimizations deloura ed game programming gems pp
charles river media
ratner warmuth finding shortest solution n n extension puzzle intractable proceedings aaai national conference artificial intelligence
aaai pp
ryan r k exploiting subgraph structure multi robot path journal
artificial intelligence jair
samet h overview quadtrees octrees related hierarchical data structures
nato asi series vol f
silver cooperative pathfinding artificial intelligence interactive digital entertainment conference aiide pp
silver cooperative pathfinding ai programming wisdom
standley finding optimal solutions cooperative pathfinding proceedings twenty fourth aaai conference artificial intelligence aaai pp
stout b smart moves intelligent pathfinding game developer magazine
sturtevant n r buro improving collaborative pathfinding map abstraction
artificial intelligence interactive digital entertainment aiide pp
surynek p application pebble motion graphs abstract multi robot path proceedings st international conference tools artificial intelligence
ictai pp
surynek p b novel path multiple robots bi connected graphs
ieee international conference robotics automation icra pp


fiwang b otea

surynek p personal communication
surynek p b optimization variant multi robot path intractable
proceedings th aaai conference artificial intelligence aaai pp

surynek p c multi robot path pp intech open access publisher
tarjan r e edge disjoint spanning trees depth first search acta informatica

tozour p building near optimal navigation mesh rabin ed ai game programming wisdom pp charles river media
wang k h c botea fast memory efficient multi agent pathfinding proceedings international conference automated scheduling icaps
pp
wang k h c botea tractable multi agent path grid maps proceedings international joint conference artificial intelligence ijcai pp

wang k h c botea scalable multi agent pathfinding grid maps
tractability completeness guarantees proceedings european conference
artificial intelligence ecai pp
zelinsky mobile robot navigation exploration ieee transactions
robotics automation




