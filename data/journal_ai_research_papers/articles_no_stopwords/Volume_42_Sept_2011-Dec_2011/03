journal artificial intelligence

submitted published

unfounded sets well founded semantics
answer set programs aggregates
mario alviano
francesco calimeri
wolfgang faber
nicola leone
simona perri

alviano mat unical
calimeri mat unical
faber mat unical
leone mat unical
perri mat unical

department mathematics
university calabria
rende cs italy

abstract
logic programs aggregates lpa one major linguistic extensions
logic programming lp work propose generalization notions unfounded set well founded semantics programs monotone antimonotone
aggregates lpa
programs particular present notion unfounded set

lpm programs sound generalization original definition standard
aggregate free lp basis define well founded operator lpa
programs
fixpoint called well founded model well founded semantics lpa

programs important properties unfounded sets well founded semantics standard lp retained generalization notably existence uniqueness
well founded model together strong relationship answer set semantics lpa
programs one well founded semantics defined
pelov denecker bruynooghe broader class aggregates approximating
operators coincides well founded model defined work lpa
programs discuss complexity issues importantly give formal proof
tractable computation well founded model lpa
programs moreover prove

general lp programs may contain aggregates neither monotone
antimonotone deciding satisfaction aggregate expressions respect partial
interpretations conp complete consequence well founded semantics general
lpa programs allows tractable computation unlikely exist justifies
restriction lpa
programs finally present prototype system extending dlv
supports well founded semantics lpa
programs time writing
implemented system experiments prototype significant
computational advantages aggregate constructs equivalent aggregate free encodings

introduction
use logical formulas basis knowledge representation language proposed years ago seminal works mccarthy mccarthy
hayes however soon realized monotonic nature classical logic
addition knowledge may increase set consequences theory
classical logic suited model commonsense reasoning sometimes
intrinsically nonmonotonic minsky alternative suggested represent
c

ai access foundation rights reserved

fialviano calimeri faber leone perri

commonsense reasoning logical languages nonmonotonic consequence relations
better simulate forms human reasoning allowing knowledge invalidate previous conclusions observation opened important
field called nonmonotonic reasoning led definition investigation
logical formalisms called nonmonotonic logics popular nonmonotonic logics
circumscription mccarthy default logic reiter nonmonotonic
modal logics mcdermott doyle mcdermott moore later
cross fertilizations field nonmonotonic logics logic programming
another nonmonotonic language called declarative logic programming lp emerged
incorporating nonmonotonic negation operator denoted declarative logic programming gained popularity last years today widely used formalism
knowledge representation reasoning applications scientific disciplines
even industry ricca alviano dimasi grasso ielpa iiritano manna leone
ricca grasso alviano manna lio iiritano leone manna ricca terracina manna ruffolo oro alviano leone lp solved
means declarative specifications requirements achieved ad hoc
required
several semantics lp proposed literature take care
inherent non monotonicity operator programs well founded
semantics van gelder ross schlipf one prominent among
associates three valued model well founded model every logic program originally
well founded semantics defined normal logic programs standard
logic programs nonmonotonic negation distinguishing property well founded
semantics existence uniqueness well founded model guaranteed
logic programs moreover well founded semantics computable polynomial time
respect input program propositional case
even lp declarative programming language standard lp allow
representing properties sets data natural way relevant aspect many application domains addressing insufficiency several extensions lp
proposed relevant introduction aggregate functions lpa
kemp stuckey denecker pelov bruynooghe dix osorio gelfond simons niemela soininen dellarmi faber ielpa leone pfeifer
pelov truszczynski pelov denecker bruynooghe among
recursive definitions involving aggregate functions e aggregation aggregated
data depend evaluation aggregate particularly interesting
definition semantics straightforward pelov faber leone pfeifer
son pontelli liu pontelli son truszczynski note similar
construct referred abstract constraint introduced literature marek
truszczynski liu truszczynski son pontelli tu truszczynski
brewka carry lp abstract
constraints well founded semantics knowledge defined far
focus fragment lpa allowing monotone antimonotone

aggregate expressions lpa
calimeri faber leone perri lpm programs
many interesting properties among highlight similarities monotone
aggregate expressions positive standard literals antimonotone aggregate


fiunfounded sets well founded semantics asp programs aggregates

expressions negative standard literals particular take advantage aspect
defining unfounded sets definition well founded semantics

lpa
fragment well founded semantics lpm programs obtained way
retains many desirable properties original well founded semantics lp
extends lpa
program unique well founded model exists polynomialtime computable approximates programs answer sets coincides answer
set stratified lpa
programs
actually turns well founded semantics thus obtained coincides lpa

programs well founded semantics proposed pelov denecker bruynooghe
pelov et al define several semantics logic programs aggregates approximating immediate consequence operators notion logic program adopted
pelov et al general one considered present work allowing
arbitrary first order formulas bodies unrestricted aggregates non herbrand interpretations equivalence two semantics properties proved
pelov et al carry work well applies well founded
model total stratified programs theorem well founded model contained
answer set theorem well founded model computable polynomial time theorem however framework introduced article considerably
different one developed pelov et al allows giving alternative proofs
vice versa article contains many carry
framework pelov et al lpa
programs particular provides alternative
definition well founded semantics characterization answer sets means unfounded sets implemented system computing well founded semantics
time writing one kind
would point extensions lpa
programs come
mind definition unfounded sets would considerably changed see instance definition provided faber moreover main desired properties
well founded semantics would longer guaranteed instance obvious extension including aggregate expressions neither monotone antimonotone
would likely computable polynomial time fact evaluation
aggregate expressions respect partial interpretations tractable monotone
antimonotone aggregates task conp complete general aggregate expressions instance allowing aggregates rule heads would necessarily complicate
definition unfounded sets would guarantee existence well founded model
every program would likely guarantee polynomial time computability
concepts defined directly give rise computation method
well founded semantics lpa
programs implemented method
best knowledgethe first kind conducted experiments
system lpa
encodings particular domain compared
encodings aggregates latter encodings tested system
prototype derived xsb state art system computing
well founded model experiments clear advantage lpa
encodings
run prototype system
summarizing main contributions follows


fialviano calimeri faber leone perri

define notion unfounded set logic programs monotone
antimonotone aggregates lpa
programs notion sound generalization
concept unfounded set previously given standard logic programs
definition coincides original definition unfounded sets van gelder
et al class normal aggregate free programs shares
distinguishing properties existence greatest unfounded set
define well founded operator wp logic programs aggregates extends classical well founded operator van gelder et al total fixpoints
wp exactly answer sets p least fixpoint wp contained
intersection answer sets operator equivalent
operator defined pelov et al
provide declarative characterization answer sets terms unfounded sets
particular prove answer sets lpa
program precisely
unfounded free
reasoning aggregates without restrictions may easily increase
complexity computation particular prove deciding truth
falsity aggregate expression respect partial interpretation
conp complete however intractable general
polynomial time solvable monotone antimonotone aggregates
analyze complexity well founded semantics confirming extending
work pelov et al importantly turns wp
polynomial time computable propositional lpa
programs non ground
programs data complexity remains polynomial program complexity
rises p exptime aggregate free programs
present prototype system supporting well founded semantics defined
article prototype obtained extending dlv first system implementing
well founded semantics unrestricted lpa
programs
report experimental implemented prototype specifically
define attacks inspired classic win lose
often considered context well founded semantics standard logic programs compare execution times prototype lpa
encoding
equivalent lp encodings particular one tested lp encodings obtained means compilation aggregates standard lp briefly
presented obtained evidence computational advantages
encoding aggregate expressions without
presentation organized follows section present basics
lpa language particular introduce lpa
fragment fragment
define unfounded sets well founded semantics section relationships
well founded semantics answer set semantics discussed section complexity
analysis well founded semantics lpa
programs reported section


fiunfounded sets well founded semantics asp programs aggregates

section discuss implemented prototype system experimentation finally
related work discussed section section draw conclusions

lpa language
syntax instantiation interpretations lpa programs introduced
section moreover introduce lpa
fragment language define
well founded semantics section additional background standard lp refer
literature gelfond lifschitz baral
syntax
assume sets variables constants predicates given similar prolog
assume variables strings starting uppercase letters constants nonnegative integers strings starting lowercase letters predicates strings starting
lowercase letters arity non negative integer associated predicate
moreover language allows built predicates e predicates fixed
meaning common arithmetic operations positive integers e
etc written infix notation interpreted standard mathematical way
standard atom
term variable constant standard atom expression p tn
p predicate arity n tn terms atom p tn ground
tn constants
set term
set term symbolic set ground set symbolic set pair terms conj
terms list terms variables constants conj conjunction standard
atoms conj form ak ai k standard
atom intuitively set term x x c p x stands set x values making
conjunction x c p x true e x x c p x true ground set set
pairs form hconsts conj consts list constants conj conjunction
ground standard atoms
aggregate function
aggregate function form f set term f aggregate
function symbol intuitively aggregate function thought possibly partial
function mapping multisets constants constant throughout remainder
adopt notation dlv system leone pfeifer faber eiter gottlob
perri scarcello representing aggregates
example common aggregate functions listed
min minimal term undefined empty set
max maximal term undefined empty set


fialviano calimeri faber leone perri

count number terms
sum sum integers
times product integers
avg average integers undefined empty set
aggregate atom
aggregate atom structure form f f aggregate function
comparison operator term variable constant
aggregate atom f ground constant ground set
example following aggregate atoms dlv notation
max z r z z v
max h r h r n

literal
literal standard atom ii standard atom preceded negation
failure symbol iii aggregate atom two standard literals complementary
form standard atom standard literal
denote complement abusing notation l set standard literals
l denotes set l
program
rule r construct form


standard atom literals atom referred
head r conjunction body r body empty
rule called fact denote head atom h r set
body literals b r moreover set positive standard body literals
denoted b r set negative standard body literals b r set
aggregate body literals b r rule r ground h r literals b r
ground program set rules program ground rules ground
safety
local variable rule r variable appearing solely sets terms r variable r
local global rule r safe following conditions hold
global variable x r positive standard literal b r x appears
ii local variable r appearing symbolic set terms conj appears
conj note condition standard safety condition adopted lp guarantee
variables range restricted ullman condition ii specific
aggregates program safe rules safe


fiunfounded sets well founded semantics asp programs aggregates

example consider following rules
p x q x v max z r z z v
p x q x v sum z r x x
p x q x v min z r z z v

first rule safe second local variable z violates condition
ii third rule safe since global variable violates condition
program instantiation interpretations
section define well founded semantics relevant class lpa programs
well founded semantics defined ground programs programs variables
associated equivalent ground programs section introduce preliminary
notions program instantiation interpretations
universe base
given lpa program p universe p denoted set constants
appearing p base p denoted bp set standard atoms constructible
predicates p constants
instantiation
substitution mapping set variables given substitution
lpa object obj rule set etc denote obj object obtained replacing
variable x obj x substitution set global variables rule
r global substitution r substitution set local variables
set term local substitution given set term without global variables
terms conj instantiation following ground set
inst hterms conj local substitution
ground instance rule r obtained two steps first global substitution r
applied every set term r replaced instantiation inst
instantiation ground p program p set instances rules p
example consider following program p
q p
p q

q p
p q

x q x sum p x

instantiation ground p p following program
q p
p q

q p
p q

q sum h p h p
q sum h p h p

aggregate function domain
x

given set x let denote set multisets elements x domain
aggregate function set multisets function defined without loss
generality assume aggregate functions map z set integers


fialviano calimeri faber leone perri

example let us look common domains aggregate functions example
u
z
count defined p sum times min max avg
z

interpretation
interpretation lpa program p consistent set standard ground literals
bp bp denote set standard
positive negative literals occurring respectively interpretation total
bp otherwise partial set interpretations p denoted
ip given interpretation standard literal evaluation respect
defined follows true respect ii
false respect iii otherwise undefined
respect interpretation provides meaning set terms aggregate functions
aggregate literals namely multiset value truth value respectively
first consider total interpretation evaluation set term respect
multiset defined follows let ht tn ht tn conj
atoms conj true respect multiset obtained
projection tuples si first constant ht tn
evaluation f aggregate function f respect
application f multiset domain f f
fixed symbol occurring p ground aggregate atom f k
true respect f f k hold otherwise false
example let total interpretation f g g g g
h h h assuming variables local check
count x g x false indeed corresponding ground set
h h count
count x g x true indeed corresponding ground set
h h h h count
times f x g x true indeed corresponding ground
set h h h times
sum x g x h true indeed corresponding ground set
h h sum
sum x g x h false indeed corresponding ground
set h h h h sum

min x f x h x false indeed corresponding ground set
min recall domain
min
consider aggregate functions value polynomial time computable
respect input multiset



fiunfounded sets well founded semantics asp programs aggregates

consider partial interpretation refer interpretation j
j extension ground aggregate atom true resp false respect
total interpretation j extending true resp false respect
otherwise undefined
example let ground set literal sum h p h p
consider partial interpretation p since total interpretation
extending contains p p
thus application sum yields thus true
respect
remark observe definitions interpretation truth values preserve knowledge monotonicity interpretation j extends e j literal true
respect true respect j literal false respect
false respect j well
model
given interpretation rule r satisfied respect least one following
conditions satisfied h r true respect ii literal b r false
respect iii h r literal b r undefined respect
interpretation model lpa program p rules r ground p
satisfied respect
example consider program p example let total interpretation
p q p minimal model p
lpa
language

definition lpa
programs fragment lp analyzed
following notion monotonicity literals

monotonicity
given two interpretations j say j j j
ground literal monotone interpretations j j
true respect implies true respect j ii false respect
j implies false respect ground literal antimonotone opposite
happens interpretations j j false
respect implies false respect j ii true respect j implies
true respect ground literal nonmonotone neither monotone
antimonotone note positive standard literals monotone whereas negative standard
literals antimonotone aggregate literals instead may monotone antimonotone
nonmonotone examples shown complete picture
common aggregate functions summarized table
example let us assume universe numerical constants non negative
integers ground instances following aggregate literals thus monotone


fialviano calimeri faber leone perri

table character common aggregate literals
function domain operator
character
count


monotone

antimonotone
sum
n

monotone

antimonotone
z
nonmonotone
times
n

monotone

antimonotone
n z
nonmonotone
min


nonmonotone

monotone
max


monotone

nonmonotone
avg
n z
nonmonotone


antimonotone context guarantees set term aggregate never becomes empty

sum z r z

count z r z

ground instances following literals instead antimonotone
sum z r z

count z r z

lpa
programs

let lpa
denote fragment lp allowing monotone antimonotone literals
lpa
rule r set monotone antimonotone body literals denoted

b r b r respectively lpa
program p stratified exists function
called level mapping set predicates p ordinals
pair b predicates occurring head body rule r p respectively b
appears antimonotone literal b ii otherwise b intuitively
stratification forbids recursion antimonotone literals aggregate free programs
definition coincides common notion stratification respect negation

example consider lpa
program consisting following rules
q x p x count x b x
p x q x b x

assume predicates b defined facts include
explicitly program stratified level mapping b p q
satisfies required conditions add rule b x p x levelmapping exists program becomes unstratified
would note definition lpa
could enlarged form
given classifies literals independently context program


fiunfounded sets well founded semantics asp programs aggregates

occur aggregates nonmonotone definition given might
manifest nonmonotone effects given context one limits interpretations
considered violate program literal occurs
interpretation pairs violate monotonicity antimonotonicity may longer
present fact one could refine definition way considering pairs
non violating interpretations given context program modified definition would
enlarge class lpa
programs retaining
simplicity exposition refrain formally example aggregate
atom involving max operator formally lpa
one considers
occurrences program non violating interpretation
set term aggregate aggregate behaves antimonotone
way particular program noted cases footnote table

unfounded sets well founded semantics
section introduce notion unfounded set lpa
programs
extends original definition aggregate free programs introduced van gelder et al
unfounded sets used extending well founded semantics originally
defined aggregate free programs van gelder et al lpa
programs
highlight number desirable properties semantics following deal
ground programs usually denote p ground program use
notation l l set l l l l l sets standard ground
literals
definition unfounded set set x bp ground atoms unfounded set
lpa
program p respect partial interpretation rule
r p h r x least one following conditions holds
antimonotone literal b r false respect
monotone literal b r false respect x
intuitively rule head atom belonging unfounded set x already
satisfied respect case condition holds satisfiable taking false
atoms unfounded set case condition holds note according
definition empty set unfounded set respect every program
interpretation
example consider interpretation following program
p
r
r
r

count h h h

count h h h

x unfounded set p respect since condition
definition holds r rule head indeed monotone literal
appearing b r false respect x similarly
unfounded sets p respect clearly
unfounded set sets atoms unfounded p respect


fialviano calimeri faber leone perri

formalized definition generalizes one given van gelder et al
aggregate free programs set standard atoms x bp unfounded set
program p respect interpretation rule r p
h r x b r ii b r x

theorem aggregate free program p definition equivalent one introduced work van gelder et al
proof aggregate free program p conditions definition equivalent b r b b r x respectively condition b
equivalent b r x x holds b
b r x b b r x
condition b exactly condition ii
work van gelder et al concerning condition b since b r contains
positive literals ignore negative literals x positive literals
x noting negative literals x precisely negative literals
conclude b equivalent b r finally combining
previous statement condition obtain condition work van
gelder et al

thus definition alternative characterization unfounded sets aggregate free
programs fact condition definition exactly cover first one
van gelder et al condition catches cases second work van gelder
et al missed condition
theorem x x unfounded sets lpa
program p respect

interpretation x x unfounded set p respect
proof let r p h r x x want
antimonotone literal b r false respect monotone literal
b r false respect j x x symmetry assume
h r belongs x since x unfounded set respect hypothesis
antimonotone literal b r false respect b monotone
literal b r false respect k x case equals thus
remains prove case b implies indeed j k j k
j k therefore definition monotonicity monotone literal
false respect k false respect j well done

corollary theorem union unfounded sets unfounded set
well
corollary union unfounded sets lpa
program p respect
interpretation unfounded set p respect well refer set
greatest unfounded set p respect denoted gu sp
important monotonicity property greatest unfounded set
proposition let j interpretations lpa
program p j
gu sp gu sp j


fiunfounded sets well founded semantics asp programs aggregates

proof since gu sp j union unfounded sets p respect j
definition enough x gu sp unfounded set p respect
j thus want rule r p h r x
antimonotone literal b r false respect j monotone literal
b r false respect j x already know x unfounded set p
respect corollary therefore antimonotone literal b r
false respect b monotone literal b r false respect
x since j j j x extensions interpretations
x respectively hence remark implies b implies
done

ready extending well founded operator defined van gelder et al
case lpa
programs
definition let p lpa
program immediate logical consequence operator
b
p
tp ip
well founded operator wp ip bp bp defined follows
tp bp r p h r
literals b r true respect
wp tp gu sp
intuitively given interpretation program p wp derives true set
atoms belonging every model extending means tp operator moreover
wp derives false atoms belonging unfounded set p respect
means gu sp operator note tp gu sp set atoms
wp tp wp gu sp following proposition formalizes
intuition definition extends wp operator defined van gelder et al
standard programs lpa
programs
proposition let p aggregate free program wp operator definition
coincides wp operator defined van gelder et al
proof since wp equal union tp gu sp cases
definitions tp gu sp coincide introduced van gelder
et al aggregate free programs
two immediate logical consequence operators tp coincide aggregate free
program p indeed rule r p b r standard literals
definition gu sp coincides one van gelder et al
aggregate free program p interpretation indeed cases gu sp
defined union unfounded sets p respect notion
unfounded set coincides one work van gelder et al standard
programs theorem

next fixpoint well founded operator wp possibly partial
model


fialviano calimeri faber leone perri

b

b



b

b b

b




figure meet semilattice
theorem let p lpa
program partial interpretation
fixpoint wp partial model p
proof let us assume wp holds thus tp gu sp
hold consider rule r p literals b r true respect
h r tp h r false respect h r gu sp
since gu sp unfounded set p respect corollary
literal b r false respect literal b r false respect
gu sp conclude r satisfied

theorem states wp monotone operator meet semilattice induced ip subset containment relationship recall meet semilattice
partially ordered set meet greatest lower bound nonempty finite
subset example meet semilattice program base b reported
figure
theorem let p lpa
program well founded operator wp monotone
operator meet semilattice hip
proof since wp equal union tp gu sp definition
prove monotonicity operators tp gu sp
first tp monotone operator pair interpretations
j p j holds tp tp j consider atom tp
definition rule r p h r literals b r
true respect since j conclude literals b r
true respect j well see remark h r belongs tp j
definition
already know gu sp monotone operator proposition
pair interpretations j p j holds gu sp gu sp j

prove sequence w wn wp wn well defined
element sequence interpretation
theorem let p lpa
program sequence w wn wp wn
well defined


fiunfounded sets well founded semantics asp programs aggregates

proof use strong induction base case trivial since w order prove
consistency wn tp wn gu sp wn assume consistency every wm
n since wp monotone operator theorem enough
gu sp wn wn end next set x atoms
x wn unfounded set p respect wn contained
gu sp wn let wm first element sequence x wm note
n consider atom x wm definition tp rule r p
h r literals b r true respect wm note
atom wm belong x way wm chosen thus
remark literals b r true respect wn wn x
recall wn wm wp monotone ends proof neither condition
definition hold

theorem theorem imply wp admits least fixpoint tarski
referred well founded model p well founded semantics lpa

program p given model state first important property
well founded semantics lpa
programs
property every lpa
program well founded model exists unique
another important property well founded semantics easily follows proposition
property aggregate free programs well founded semantics defined
coincides classical well founded semantics van gelder et al
although well founded model general might leave atoms undefined
cases wp total interpretation
example consider following program p
sum h h
b
b c

iterated application wp yields following sets




wp c
wp c c b
wp c b c b wp

case well founded model total indeed atom bp true false
respect wp
totality well founded model program due stratification
formalized next theorem given corollary equivalent stated
already pelov et al theorem corollary however proof
labelled sketch pelov et al moreover relies rather different formalisms
proof


fialviano calimeri faber leone perri

theorem stratified lpa
programs well founded model total

proof let p stratified lpa
program order prove wp total
standard atom bp wp false respect wp definition
stratification level mapping standard predicates p
pair b standard predicates occurring head body rule r p
respectively following conditions satisfied b appears antimonotone literal
b holds ii otherwise b appears monotone literal b
holds order define non decreasing sequence subsets bp follows

l
li li bp predicate p p

n

aim n set li wp contained wp
use induction base case trivial l holds definition
suppose atoms li wp false respect wp order
atoms li wp false respect wp well end
prove li wp unfounded set p respect wp consider
rule r ground p h r li wp want
antimonotone literal b r false respect wp monotone
literal b r false respect wp li wp since h r li
definition stratification following propositions hold
literal b r negated standard atom belonging li aggregate
literal depending atoms li
b literal b r standard atom belonging li aggregate
literal depending atoms li
since h r wp h r tp wp literal b r
true respect wp definition tp antimonotone literal
apply induction hypothesis conclude holds cannot undefined
respect wp must false monotone literal apply b
induction hypothesis conclude holds cannot undefined respect
wp li wp wp li wp wp holds must
false


answer set characterization via unfounded sets
well founded semantics three valued semantics program associated model atoms true false undefined semantics
literature associate programs two valued e without undefined
atoms commonly accepted two value semantics lp answer set semantics
section present number concerning unfounded sets answer sets
lpa
programs first recall definition answer sets provided faber leone
pfeifer


fiunfounded sets well founded semantics asp programs aggregates

definition minimal model total model p subset minimal total
model n p exists n note definitions words
interpretation model refer possibly partial interpretations minimal model
total interpretation
next provide transformation reduct ground program
respect total interpretation formed note definition generalization faber
et al gelfond lifschitz transformation standard logic programs
definition program reduct given lpa program p total interpretation
let ground p denote transformed program obtained ground p deleting
rules body literal false respect e
ground p r ground p literals b r true respect
ready introducing notion answer set lpa programs
definition answer set lpa programs given lpa program p total interpretation p answer set p minimal model
ground p
example consider two total interpretations p p
following two programs
p p count x p x
p p count x p x

obtain following transformed programs
ground p
ground p
ground p
ground p

ground p p count h p


ground p p count h p

hence answer set p indeed minimal model ground p
moreover p answer sets indeed minimal model ground p
model ground p ground p
note answer set p total model p ground p
ground p rules ground p ground p satisfied respect
definition rules must least one body literal false
respect
language lpa
considered work answer sets defined definition
coincide stable defined pelov denecker bruynooghe
hence defined pelov et al son et al equivalence
follows propositions ferraris respectively state stable
pelov et al lpa
coincide semantics defined ferraris
turn coincides definition larger class programs means
involving answer sets hold semantics lpa

hand implies example theorem consequences
work pelov et al virtue theorem section
remainder section highlight relevant relationships answer sets
unfounded sets introducing let us provide additional definition


fialviano calimeri faber leone perri

definition unfounded free interpretation interpretation lpa
program p unfounded free x holds unfounded set x p
respect
total interpretations equivalent characterization unfounded free property
given
lemma total interpretation lpa
program p unfounded free

empty set subset unfounded set p respect
proof straightforward definition disjoint unfounded set
p respect
prove contrapositive unfounded free exists non empty
subset unfounded set p respect definition
unfounded free exists unfounded set x p respect
x
next x unfounded set p respect e
rule r p h r x antimonotone literal b r
false respect monotone literal b r false respect
x since x unfounded set definition antimonotone
literal b r false respect b monotone literal b r false
respect x thus end proof showing x x
end observe x x x moreover since total
bp thus ii x x x
x x x simplifying ii obtain x x x
conclude observing x x thus x x
holds

give another interesting characterization total lpa
programs
lemma total interpretation total model lpa
program p
unfounded set p respect
proof start observing rule r p h r satisfied
thus rule r p h r literal
b r false respect antimonotone literal b r
false respect monotone literal b r false respect
end enough prove holds
definition consistency
disjoint moreover subset
simplifying last two sentences obtain

give characterizations answer sets lpa
programs
theorem total model answer set lpa
program p
unfounded free


fiunfounded sets well founded semantics asp programs aggregates

proof prove contrapositive total model lpa
program p
unfounded free answer set p lemma since total
interpretation unfounded free exists unfounded set x p
respect x x
therefore prove answer

set p next x model p x
end consider rule r p definition reduct literals b r true
respect h r model p p p
consider two cases
h r x case h r x well
h r x case since x unfounded set p respect
literal b r false respect literal b r false
respect x previous considerations since r p cannot hold
conclude literal b r false respect x
hence r satisfied x head case h r x
body case h r x done
prove contrapositive total model lpa
program p
answer set p unfounded free since model p p
answer set p exists total model n p n next
n unfounded set p respect rule r p
h r n antimonotone literal b r false respect
monotone literal b r false respect n
start showing n n definition n
n n n b n
n moreover since n total interpretations n c
n n n thus b obtain
n n n observing n n
holds c conclude e n n n n
consider rule r p h r n deal two cases
r p p case definition must literal b r
false respect antimonotone literal holds otherwise
monotone literal false respect n well since n thus
holds e
r p case since n model p h r false respect n
h r n assumption must literal b r
false respect n antimonotone literal false respect
well since n holds otherwise monotone literal
holds e

ready state important connection answer sets unfounded
sets
theorem total interpretation lpa
program p answer set p
gu sp


fialviano calimeri faber leone perri

proof let answer set p lemma unfounded set p
respect hence gu sp theorem unfounded free
hence gu sp total sum gu sp
let total interpretation gu sp gu sp
disjoint unfounded free moreover corollary gu sp
unfounded set p respect applying lemma conclude
model p order apply theorem unfounded free
model p conclude answer set p

following theorem shows answer sets lpa
programs exactly total
fixpoints well founded operator defined section
theorem let total interpretation lpa
program p
answer set p fixpoint well founded operator wp
proof let answer set p want fixpoint wp
wp aim tp gu sp
since answer set applying theorem obtain gu sp
equivalent gu sp therefore remains prove tp
consider atom tp definition rule r p
h r literals b r true respect thus holds
model p
consider atom since answer set p apply theorem
conclude unfounded free hence singleton set
unfounded set p respect thus definition rule
r p h r neither antimonotone literal b r
false respect monotone literal b r false respect
since total interpretation neither equivalent
antimonotone literals b r true respect ii
monotone literals b r true respect observing
state ii implies monotone literals
b r true respect well combining latter statement
obtain literals b r true respect tp
definition
let total fixpoint wp e wp thus gu sp
definition answer set p theorem

observe theorem generalization theorem van gelder et al
class lpa
programs worth noting wp extends preserving
correctness contained answer set wp may add literals
never introduces literal would inconsistent
proposition let interpretation lpa
program p let
answer set p wp


fiunfounded sets well founded semantics asp programs aggregates

proof trivial consequence monotonicity operator wp theorems
theorem indeed theorems wp implies wp wp
wp theorem

next well founded model lpa
program contained
answer sets p would point due theorem section
showing equivalence well founded operators defined work one
defined pelov et al propositions ferraris showing
equivalence answer sets faber et al stable pelov et al
following hold virtue definitions well founded stable
semantics work pelov et al particular due proposition
nevertheless provide proof concepts defined earlier

theorem let p lpa
program answer set p wp

proof let answer set p note wp limit sequence w
wn wp wn wn induction n base case trivially
true since w definition assume wn order wn
since wn wp wn definition wn induction hypothesis apply
proposition conclude wn

theorem suggests another property well founded semantics lpa
programs
property well founded semantics lpa
programs approximates answer set
semantics well founded model contained intersection answer sets

combining theorem theorem obtain following claim

corollary let p lpa
program wp total interpretation
unique answer set p

therefore combining theorem corollary obtain another property
well founded semantics lpa
programs
property stratified lpa
programs well founded model coincides
unique answer set

complexity well founded semantics
complexity analysis carried section consider ground programs
polynomial time computable aggregate functions note example aggregate functions
appearing fall class however eventually provide discussion
change considering non ground programs start important
property monotone antimonotone aggregate literals


fialviano calimeri faber leone perri

lemma let partial interpretation ground lpa
program p define
two total interpretations p follows imin bp imax bp
ground aggregate literal occurring p following statements hold
monotone literal true resp false respect
true respect imin resp false respect imax
antimonotone literal true resp false respect
true respect imax resp false respect imin
proof start noting imin resp imax total interpretation extending
standard atoms undefined respect false
respect imin resp true respect imax thus imin imax
monotone true respect imin resp false respect imax true
resp false respect antimonotone true respect
imax resp false respect imin true resp false respect
end proof observing true resp false respect
true respect imin imax definition

ready analyze computational complexity well founded semantics
lpa
programs analysis lead prove following fundamental property
property well founded model ground lpa
program efficiently polynomialtime computable
given corollary property follows theorem work pelov
et al following provide alternative proof concepts
defined earlier leads several interesting intermediate
property trivial aggregates may easily increase complexity
evaluation indeed even deciding truth aggregate respect partial interpretation intractable general similar observation already made pelov
however task polynomial time computable aggregate literals occurring lpa
programs
proposition deciding whether ground aggregate literal true resp false
respect partial interpretation
co np complete general
b polynomial time computable monotone antimonotone literal
proof membership consider complementary
deciding whether ground aggregate literal true resp false respect
partial interpretation prove belongs np order
true resp false respect enough total interpretation j
extending j false resp true respect j thus
guess j check falsity resp truth respect j polynomial


fiunfounded sets well founded semantics asp programs aggregates

time aggregate function computed polynomial time respect size
input multiset assuming
hardness first consider checking truth aggregate provide polynomial time reduction tautology tautology
co np complete stated follow given proposition formula
variables x xn truth assignment v variables x xn satisfy
formula without loss generality assume dnf formula form
dm

disjunct di conjunction ji positive negative
literal note context tautology term literal denotes variable
xk variable preceded negation symbol given consider
partial interpretation construct aggregate literal sum
contains two groups elements elements first group represent disjuncts

h

j propositional atom ji defined
follows

j
xk positive literal xk k n
j

f
xk ji negative literal xk k n
elements second group represent variables follows

h


h
h



h

xk
xk xtk

xk xfk
xk xtk xfk

k n

xk xk constants associated variable xk note variable
xk two atoms xtk xfk thus interpretation j four cases
possible
xtk xfk j case h xk contribute evaluation
contribution
xtk xfk j case four elements contribute evaluation
thus contribution note h xk xtk h xk xfk
give total contribution pure set
xtk xfk j case h xk h xk xtk contribute giving

xtk xfk j case h xk h xk xfk contribute giving



fialviano calimeri faber leone perri

thus k n total contribution four elements associated
variable xk note total contribution elements
e first group therefore k n
case occurs interpretation j trivially satisfies otherwise j
variable k n occurs case say
j good interpretation
next define one one mapping set assignments set
good interpretations let v assignment good interpretation iv associated
v iv

f
xtk xk iv v xk

k n

f

xk xk iv v xk
want v satisfies true respect iv since iv
good interpretation elements second group give total contribution
consider elements first group elements give
contribution holds least one n
holds v di holds disjunct di conclude
true respect iv v
concerning check falsity aggregate start dnf formula
construct aggregate literal sum obtained described
tautology false respect
b let partial interpretation lpa
program p aggregate literal
occurring p want deciding whether true resp false respect
done polynomial time size bp lemma enough evaluate
aggregate respect imin bp imax bp
end proof observing interpretations imin imax constructed
polynomial time value aggregate function computed
polynomial time respect size input multiset assumption

order prove tractability well founded semantics need efficient
method computing greatest unfounded set part well founded operator
wp hence next give polynomial time construction set bp gu sp means
monotone operator
definition let interpretation lpa
program p operator
b
b
p
p
defined follows

bp r p h r
antimonotone literal b r false respect
monotone literals b r true respect
least fixpoint coincides greatest unfounded set p respect

theorem let p lpa
program interpretation p


fiunfounded sets well founded semantics asp programs aggregates

operator least fixpoint
gu sp bp
proof operator monotonically increasing operator meet semilattice
hbp therefore admits least fixpoint tarski next prove
gu sp bp two steps
first observe computed iteratively starting empty set
limit sequence f thus prove induction
gu sp bp holds base case trivial since f definition
gu sp subset bp definition assume gu sp bp
order prove gu sp bp since gu sp unfounded set p
respect theorem definition gu sp
rule r p h r antimonotone literal
b r false respect monotone literal b r false
respect gu sp want belong
rule r antimonotone literal
b r false respect ii monotone literal b r true
respect recall definition since
equals implies ii end assume
monotone literal b r false respect gu sp
aim false respect j bp
since case would true respect see lemma
start proving gu sp gu sp subset j
observe j bp bp
subset bp thus since gu sp bp induction hypothesis obtain
gu sp gu sp bp j since j total
gu sp j implies extension k gu sp
k j k j example one containing true
standard positive literals undefined respect gu sp since
false respect gu sp assumption k extension
gu sp false respect k remark thus since j k
monotone latter implies false respect j well
prove bp unfounded set p respect
r p h r bp antimonotone literal b r
false respect monotone literal b r false respect
bp definition h r implies
antimonotone literal b r false respect ii monotone
literal b r true respect since equals
ii implies end assume monotone
literal b r true respect thus
extension false particular must false
respect j bp lemma
observe bp bp bp


fialviano calimeri faber leone perri

j holds bp bp j j total
combining last two sentences obtain bp j therefore
since monotone literal false respect j latter implies
false respect bp well holds

eventually property consequence following theorem mentioned earlier
theorem follows theorem work pelov et al
corollary proof provided differs considerably one theorem
work pelov et al
theorem given lpa
program p
greatest unfounded set gu sp p respect given interpretation
polynomial time computable
wp polynomial time computable
proof theorem gu sp bp next
efficiently computable fixpoint limit sequence k
k limit reached polynomial number applications
element sequence k must add least atom otherwise limit
already reached bp application feasible
polynomial time conclude computable polynomial time step
processes rules rule checks truth value
body literals check truth valuation clearly tractable standard
e non aggregates literals tractability check aggregate literals stems
proposition deal monotone antimonotone aggregate atoms
conclusion computable polynomial time gu sp tractable well since
obtainable bp
argumentation carried wp computed
number steps polynomial actually linear bp indeed step
polynomial time computable proved tractability gu sp tp
polynomial time computable well

positive impact computation answer set semantics
logic programs aggregates indeed stated theorem wp approximates
intersection answer sets bottom therefore used
efficiently prune search space worthwhile noting computation
well founded semantics hard polynomial time particular deciding whether
ground atom true respect well founded semantics p complete
task p hard even standard well founded semantics aggregate free programs
proposition semantics coincides standard well founded aggregatefree programs
end section briefly addressing complexity non ground programs
considering data complexity e lpa
program p fixed input consists
facts propositional programs deciding whether ground atom
true respect well founded semantics non ground program p complete


fiunfounded sets well founded semantics asp programs aggregates

data complexity van gelder et al however program complexity e
lpa
program p given input considered complexity reasoning rises exponentially indeed non ground program p reduced naive instantiation ground
instance general size ground p single exponential
size p complexity reasoning increases accordingly one exponential p
exptime derived complexity upgrading techniques eiter
gottlob mannila gottlob leone veith

compilation standard lp implementation experimental

well founded semantics lpa
programs implemented extending
dlv system leone et al section briefly describe implemented
prototype report experiments aimed assessing efficiency
note even lpa
programs replaced equivalent lp programs
rewriting strategy see section experimental highlight significant
performance advantage lpa
encodings
compilation standard logic programming
section briefly present strategy representing count sum times
standard constructs compilation spirit one introduced min
max alviano faber leone defines subprogram computing
value possibly recursive aggregate compilation takes account specific properties monotone antimonotone aggregate functions therefore referred
monotone antimonotone encoding mae
monotone antimonotone encoding lpa
program p obtained replacing
aggregate literal f predicate symbol f predicate f defined
means subprogram e set rules thought compilation
standard lp compilation uses total order elements
symbol occurring p u u assume
presence built relation yn yn
lists terms built relation precedes
lexicographical order induced moreover use built relation
true simplicity let us assume
form f p z k z lists local variables k
integer constant aggregate introduce predicate symbol faux arity
rules modeling atom faux must true whenever value
f p z least thus use fact representing value
aggregate function empty set rule increasing value larger sets
lexicographical order induced used guarantee elements set
since considering monotone antimonotone aggregate literals domains sum
times assumed n n respectively



fialviano calimeri faber leone perri

user interface

diagnosis
frontend

inheritance
frontend

sql
frontend


frontend

dlv core
ground
program

intelligent
grounding

model
checker

model
generator

file
system

relational
database

filtering

output

figure prototype system architecture
considered particular following rules introduced

faux
f count
f sum

faux x faux p z

f times
x
truth aggregate f p z k must inferred
atom faux k true aspect modeled means
following rules
fk faux k

f k faux k

instead truth aggregate f p z k must inferred
atoms faux k false similar aspects
modeled means following rules
fk f k

f k fk

extending technique aggregate literals global variables quite simple
global variables added arguments atoms used compilation
predicate fgroupby used collecting possible substitutions
system architecture usage
extended dlv implementing well founded operator well founded
semantics lpa
programs described architecture prototype


fiunfounded sets well founded semantics asp programs aggregates

reported figure detail modified two modules dlv intelligent grounding
module model generator module prototype well founded semantics
adopted one wf well founded specified command line otherwise
stable model semantics adopted usual well founded operator wp introduced
section used semantics particular stable model semantics
well founded model profitably used pruning search space well founded
semantics well founded model printed computation least fixpoint
well founded operator case output system consists two sets
representing true undefined standard atoms well founded model binary
prototype available http www dlvsystem com dlvrecaggr
experimental
knowledge implemented prototype currently system supporting
well founded semantics logic programs recursive aggregates certain special
cases well founded model total well founded model coincides
semantics answer sets see corollary theses cases systems supporting
semantics idp wittocx marien denecker smodels simons et al
clasp gebser kaufmann neumann schaub used compute
well founded model
however interested systems able compute well founded model
input programs one major systems supporting well founded semantics
xsb swift warren support aggregates apart min
max xsb support recursive aggregates e aggregates occurring recursive
definitions therefore experiments designed investigating computational behavior aggregate constructs respect equivalent encodings without
aggregates
specifically introduce attacks inspired classic
win lose often used context well founded semantics standard
logic programs study performance
definition attacks attacks set p players positive integer given player attacks n players player wins
winners attack kind frequently present turn strategy
games
note definition winner recursive particular recursive aggregate
natural way encoding
example instance attacks p n could
following
player attacks players b c

player attacks players b f

player b attacks players c

player e attacks players c f

player c attacks players b

player f attacks players e



fialviano calimeri faber leone perri

b





f

e

c

figure instance attacks players one attacking
players

graphical representation instance shown figure since attacked
f conclude winner similarly e therefore f winner
f attacked e winners players namely b c
cannot determine winner
experiments instances attacks encoded means predicates max
player attacks representing parameter set players attacks
players respectively consider three equivalent encodings attacks
aggregate encoding
encoding natural representation attacks lp
complete
encoding consists single rule reported
win x max player x count attacks x win

join encoding
equivalent encoding obtained computing number joins proportional
tested encoding reported
win x player x lose x
lose x max attacks x win
attacks x win
lose x max attacks x win
attacks x win
attacks x win
lose x max

note encoding rule possible value parameter
however one rules considered solver program instantiation
fact rule instantiated contains instance atom max
fact present rules satisfied false body literal


fiunfounded sets well founded semantics asp programs aggregates





dlv join

dlv






























x






































x

players

























b players




































x





































x

c players































players

figure attacks average execution time dlv running aggregate encoding
dlv running join encoding

mae encoding
encoding obtained applying compilation presented section
minor simplifications full encoding reported
win x player x lose x
lose x count x max
count x aux x
count x count x aux x
aux x attacks x win

intuitively atom count x stands least constants
attacks x win true note rules defining predicate count use
natural order integers guarantee counted
example instance shown figure represented means following facts
player
attacks b
attacks c
max

player b
attacks b
attacks b c

player c
attacks c
attacks c b

player
attacks b
attacks f



player e
attacks e c
attacks e f

player f
attacks f
attacks f e

fialviano calimeri faber leone perri





xsb join

dlv



































x







































x

e players

























f players









































x



































x

g players































h players

figure attacks average execution time dlv running aggregate encoding
xsb running join encoding

encodings well founded model restricted win predicate win
win e win f note win win b win c neither true false
undefined
discussion
performed intensive experimentation benchmark varying parameters
p n combination parameters measured average execution
time dlv xsb version randomly generated instances experiments
r
r
performed ghz intel
xeon
processor system gb ram
debian operating system gnu linux kernel dlv prototype used
compiled gcc every instance allowed maximum running
time seconds minutes maximum memory usage gb
experimentation reported figures graphs dlv
implemented prototype aggregate encoding dlv join dlv mae
implemented prototype aggregate free encodings xsb join xsb mae
xsb system aggregate free encodings mentioned earlier xsb support


fiunfounded sets well founded semantics asp programs aggregates

dlv mae

dlv

































x








































x

players



























j players





















x







































x

k players































l players

figure attacks average execution time dlv running aggregate encoding
dlv running mae encoding

recursive aggregates xsb system explicitly set indices tabled predicates
optimizing computation
graph number players fixed parameters x axis n
axis vary therefore size instances grows moving left right along
axis invariant respect x axis however number joins
required join encoding depends parameter matter fact
observe graphs figures average execution time join
encoding increases along x axis dlv xsb instead
encoding aggregates mae encoding average execution time
depends instance sizes shown graphs figures
join encoding xsb generally faster dlv consumes much
memory indeed figure observe xsb terminates computation
seconds smallest instances rapidly runs memory slightly larger
instances considering mae encoding observe significant performance
gains dlv xsb see figures indeed systems complete computation allowed time memory larger instances computational advantages
mae encoding respect join encoding particularly evident


fialviano calimeri faber leone perri

xsb mae

dlv



































x










































x

players



























n players



























x









































x

players































p players

figure attacks average execution time dlv running aggregate encoding
xsb running mae encoding

xsb solved tested instances encoding however xsb
mae encoding outperformed dlv native support aggregate constructs
see figure
sum experimental highlight presence aggregate constructs
significantly speed computation indeed encoding recursive aggregates
outperforms aggregate free encodings tested instances

related work
defining well founded semantics logic programs aggregates challenge
major interest last years first attempts relying notion unfounded
set defined restricted language discussed kemp
stuckey another semantics falling class one introduced van gelder
subsequently generalized osorio jayaraman main
semantics often leave many undefined literals shown ross
sagiv


fiunfounded sets well founded semantics asp programs aggregates

first attempt define well founded semantics unrestricted lpa done
kemp stuckey semantics notion unfounded sets according
kemp stuckey set x standard atoms unfounded set ground program
p respect interpretation rule r p h r x
literal b r false respect b b r x
note standard
literals considered condition b aggregates covered point
definition unfounded set makes semantics inadequate programs
recursive aggregates even monotone aggregates considered example
program count x x well founded model work kemp
stuckey reasonable well founded semantics identify false
pelov et al defined well founded semantics approximating operators
namely well founded semantics extends standard well founded semantics indeed coincide aggregate free programs detail work aggregates
evaluated one three possible ways therefore family semantics defined
pelov et al ordered precision precise three valued aggregates lead
precise semantics general higher precision comes price higher computational complexity authors discuss following three valued aggregate relations
evaluation aggregate literals trivial bound ultimate approximating aggregates first less precise last precise semantics relying
trivial approximating aggregates imprecise still suitable class
stratified aggregate programs trivial bound approximations polynomial
complexity ultimate shown intractable nonmonotone aggregate
functions pelov detailed comparison presented section
ferraris showed semantics smodels programs positive weight
constraints equal answer sets defined faber et al respective
fragment since theorem wp approximates answer sets defined faber et al
wp used approximating operator respective smodels programs
indeed shown atmost pruning operator smodels simons et al
special case operator defined proof theorem
works attempted define stronger notions well founded semantics
programs aggregates ultimate well founded semantics denecker et al
wfs wfs dix osorio whether characterization
semantics terms unfounded sets exist semantics unclear left
future
concerning compilations lp programs standard lp transformation provided van gelder compilation presented section differs
one introduced van gelder several respects uses total order
universe input program takes advantage character monotonicity antimonotonicity aggregate literals input program transformation
defined van gelder uses uninterpreted function symbols representing ground sets
recursive negation checking truth aggregate literals briefly discuss aspects following roughly aggregate f k uninterpreted function symbols
used transformation work van gelder determining pairs k
ground set associated k f transformation defined van gelder checks whether exists pair k satisfying following


fialviano calimeri faber leone perri

conditions every element hconsts conji conj true ii k k holds
point condition requires recursive negation order checked indeed
equivalent element hconsts conji conj true
aspect transformation undesirable side effect stratified lpa
programs
may partial well founded theorem hold programs compiled transformation introduced van gelder example side effect
given van gelder shown transformation possibly leads partial
well founded instances company controls well known
modeled monotone recursive aggregates
comparison work pelov et al
section report detailed comparison well founded semantics defined
one pelov et al recall pelov et al defines wellfounded stable semantics least total fixpoints three valued stable
model operator extended aggregate programs
start observing evaluation ultimate approximating aggregates coincides
evaluation aggregates defined article evaluation bound approximating aggregates coincides monotone antimonotone aggregates consequence
lemma proposition work pelov et al
let us introduce translation aggregate literal formula standard
literals partial interpretation let conj denote conjunction literals
translation trm ground aggregate literal defined follows
w
trm conj subset minimal interpretation
true respect
note partial interpretation j evaluation respect j coincides
evaluation trm respect j proposition proposition
work pelov et al moreover monotone resp antimonotone aggregate literal
positive resp negative literals appear trm
rule r ground lpa
program p aggregate literal b r
translation trm p r r program obtained p removing r
adding rule r h r h r b r b r conj
conj trm therefore full translation trm p p defined recursive
application trm p r note order rules aggregates processed
relevant next p trm p unfounded sets
lemma set atoms x unfounded set program p respect
interpretation x unfounded set trm p respect
proof use induction number aggregate literals p p aggregate
literals p trm p consider program p rule r p aggregate
literal b r want set x atoms unfounded set p
respect x unfounded set trm p r respect since
case might apply induction hypothesis prove claim thus
end proof means following observations false respect


fiunfounded sets well founded semantics asp programs aggregates

interpretation j trm false respect j
conjunction conj trm literal conj false respect
j ii positive resp negative standard literal monotone
resp antimonotone

prove well founded operators p trm p coincide
lemma let p lpa
program interpretation p wp
wtrm p
proof tp ttrm p gu sp gu strm p
note immediately follows lemma order prove consider
aggregate literal occurring p previous considerations true
respect conjunct trm true respect
thus holds

ready relate well founded operator one provided pelov
et al
theorem class lpa
programs well founded operator herein defined
coincides one pelov et al ultimate bound approximating
aggregate semantics
proof lemma already know wp wtrm p
wtrm p coincides one work van gelder et al theorem
since trm p standard logic program hand ultimate
bound approximating aggregate semantics well founded operators defined pelov
et al p trm p coincide consequence theorem work
pelov et al three valued immediate consequence operators work
pelov et al pelov et al coincide see definition pelov et al
definition pelov et al moreover well founded operator pelov et al
coincides one work van gelder et al standard logic programs
thereby obtaining equality operators

correspondence two well founded semantics immediately follows
theorem indeed two well founded defined fixpoints
respective well founded operators
corollary well founded model herein defined one pelov et al
ultimate bound approximating aggregate semantics coincide lpa

programs
mentioned earlier virtue theorem corollary
presented follow earlier literature particular
theorem theorem complexity follow definitions
pelov pelov et al
note operator referred stable revision operator pelov et al



fialviano calimeri faber leone perri

conclusion
introduced notion unfounded set lpa
programs analyzed
well founded semantics language notion semantics generalizes
traditional well founded semantics aggregate free programs coincides
well founded semantics aggregate programs defined pelov et al latter
defined means notion unfounded set could
semantics main operator wp close ties answer sets defined faber
et al hence serve approximations
proved computing semantics tractable indeed semantics
given least fixpoint well founded operator wp fixpoint reached
polynomial number applications operator wp respect size input
program requiring polynomial time showing application wp
polynomial time feasible proved evaluating monotone antimonotone
aggregate literals remains polynomial time computable partial interpretations since
case one possibly exponential extensions must checked monotone
aggregate literal extension obtained falsifying undefined literal
antimonotone aggregate literal undefined literal taken true extension
motivated positive theoretical implemented first system
supporting well founded semantics unrestricted lpa
allowing monotone
antimonotone aggregate literals implemented prototype ready experimenting
lpa
framework experiments conducted attacks benchmark highlight
computational gains native implementation aggregate constructs respect
equivalent encodings standard lp

acknowledgments
partly supported regione calabria eu por calabria fesr within
pia project dlvsystem r l miur prin project loden
pon project frame proposed atos italia p thank
anonymous reviewers valuable comments

references
alviano faber w leone n compiling minimum maximum aggregates
standard asp formisano ed proceedings rd italian conference
computational logic cilc
baral c knowledge representation reasoning declarative solving
cambridge university press
brewka g well founded semantics extended logic programs dynamic
preferences journal artificial intelligence
calimeri f faber w leone n perri declarative computational
properties logic programs aggregates nineteenth international joint
conference artificial intelligence ijcai pp


fiunfounded sets well founded semantics asp programs aggregates

dellarmi faber w ielpa g leone n pfeifer g aggregate functions
dlv de vos provetti eds proceedings asp answer set
programming advances theory implementation pp messina italy
online http ceur ws org vol
denecker pelov n bruynooghe ultimate well founded stable
model semantics logic programs aggregates codognet p ed proceedings th international conference logic programming pp
springer verlag
dix j osorio well behaved semantics suitable aggregation
proceedings international logic programming symposium ilps port jefferson n
eiter gottlob g mannila h disjunctive datalog acm transactions
database systems
faber w unfounded sets disjunctive logic programs arbitrary aggregates baral c greco g leone n terracina g eds logic programming nonmonotonic reasoning th international conference lpnmr
diamante italy september proceedings vol lecture notes computer science pp springer verlag
faber w leone n pfeifer g recursive aggregates disjunctive logic programs semantics complexity alferes j j leite j eds proceedings
th european conference artificial intelligence jelia vol
lecture notes ai lnai pp springer verlag
faber w leone n pfeifer g semantics complexity recursive aggregates
answer set programming artificial intelligence special issue
john mccarthys legacy
ferraris p answer sets propositional theories baral c greco g leone
n terracina g eds logic programming nonmonotonic reasoning th
international conference lpnmr diamante italy september proceedings
vol lecture notes computer science pp springer verlag
ferraris p logic programs propositional connectives aggregates acm
transactions computational logic press
gebser kaufmann b neumann schaub conflict driven answer
set solving twentieth international joint conference artificial intelligence
ijcai pp morgan kaufmann publishers
gelfond representing knowledge prolog kakas c sadri f
eds computational logic logic programming beyond vol lncs pp
springer
gelfond lifschitz v classical negation logic programs disjunctive
databases generation computing
gottlob g leone n veith h succinctness source expression complexity annals pure applied logic
kemp b stuckey p j semantics logic programs aggregates
saraswat v ueda k eds proceedings international symposium
logic programming islp pp mit press


fialviano calimeri faber leone perri

leone n pfeifer g faber w eiter gottlob g perri scarcello f
dlv system knowledge representation reasoning acm transactions
computational logic
liu l pontelli e son c truszczynski logic programs abstract
constraint atoms role computations artificial intelligence
liu l truszczynski properties applications programs monotone
convex constraints journal artificial intelligence
manna ruffolo oro e alviano leone n hilex system
semantic information extraction transactions large scale data knowledgecentered systems springer berlin heidelberg appear
manna ricca f terracina g consistent query answering via asp
different perspectives theory practice theory practice logic programming appear
marek v w truszczynski logic programs abstract constraint atoms
proceedings nineteenth national conference artificial intelligence aaai
pp aaai press mit press
mccarthy j programs common sense proceedings teddington
conference mechanization thought processes pp majestys
stationery office
mccarthy j circumscription form non monotonic reasoning artificial
intelligence
mccarthy j applications circumscription formalizing common sense
knowledge artificial intelligence
mccarthy j formalization common sense papers john mccarthy edited
v lifschitz ablex
mccarthy j hayes p j philosophical standpoint
artificial intelligence meltzer b michie eds machine intelligence
pp edinburgh university press reprinted mccarthy
mcdermott v non monotonic logic ii nonmonotonic modal theories journal
acm
mcdermott v doyle j non monotonic logic artificial intelligence

minsky framework representing knowledge winston p h ed
psychology computer vision pp mcgraw hill
moore r c semantical considerations nonmonotonic logic artificial intelligence
osorio jayaraman b aggregation negation failure generation
computing
pelov n semantics logic programs aggregates ph thesis katholieke
universiteit leuven leuven belgium
pelov n denecker bruynooghe translation aggregate programs
normal logic programs de vos provetti eds proceedings asp
answer set programming advances theory implementation pp
messina italy online http ceur ws org vol


fiunfounded sets well founded semantics asp programs aggregates

pelov n denecker bruynooghe partial stable logic programs aggregates proceedings th international conference logic
programming non monotonic reasoning lpnmr vol lecture notes
ai lnai pp springer
pelov n denecker bruynooghe well founded stable semantics
logic programs aggregates theory practice logic programming

pelov n truszczynski semantics disjunctive programs monotone
aggregates operator proceedings th international
workshop non monotonic reasoning nmr whistler bc canada pp

reiter r logic default reasoning artificial intelligence
ricca f alviano dimasi grasso g ielpa iiritano manna
leone n logic system e tourism fundamenta informaticae
ios press
ricca f grasso g alviano manna lio v iiritano leone n
team building answer set programming gioia tauro seaport theory
practice logic programming cambridge university press appear
ross k sagiv monotonic aggregation deductive databases journal
computer system sciences
simons p niemela soininen extending implementing stable
model semantics artificial intelligence
son c pontelli e constructive semantic characterization aggregates
answer set programming theory practice logic programming
son c pontelli e tu p h answer sets logic programs arbitrary
abstract constraint atoms journal artificial intelligence
swift warren xsb extending prolog tabled logic programming
computing repository corr abs
tarski lattice theoretical fixpoint theorem applications pacific j
math
truszczynski reducts propositional theories satisfiability relations
generalizations semantics logic programs artificial intelligence
ullman j principles database knowledge base systems computer
science press
van gelder well founded semantics aggregation proceedings
eleventh symposium principles database systems pods pp
acm press
van gelder ross k schlipf j well founded semantics
general logic programs journal acm
wittocx j marien denecker idp system model expansion
system extension classical logic denecker ed proceedings
nd workshop logic search computation structures declarative
descriptions lash pp




