Journal Artificial Intelligence Research 42 (2011) 487-527

Submitted 7/11; published 11/11

Unfounded Sets Well-Founded Semantics
Answer Set Programs Aggregates
Mario Alviano
Francesco Calimeri
Wolfgang Faber
Nicola Leone
Simona Perri

alviano@mat.unical.it
calimeri@mat.unical.it
faber@mat.unical.it
leone@mat.unical.it
perri@mat.unical.it

Department Mathematics
University Calabria
I-87030 Rende (CS), Italy

Abstract
Logic programs aggregates (LPA ) one major linguistic extensions
Logic Programming (LP). work, propose generalization notions unfounded set well-founded semantics programs monotone antimonotone
aggregates (LPA
m,a programs). particular, present new notion unfounded set

LPm,a programs, sound generalization original definition standard
(aggregate-free) LP. basis, define well-founded operator LPA
m,a programs,
fixpoint called well-founded model (or well-founded semantics) LPA
m,a
programs. important properties unfounded sets well-founded semantics standard LP retained generalization, notably existence uniqueness
well-founded model, together strong relationship answer set semantics LPA
m,a programs. show one D-well-founded semantics, defined
Pelov, Denecker, Bruynooghe broader class aggregates using approximating
operators, coincides well-founded model defined work LPA
m,a programs. discuss complexity issues, importantly give formal proof
tractable computation well-founded model LPA
m,a programs. Moreover, prove

general LP programs, may contain aggregates neither monotone
antimonotone, deciding satisfaction aggregate expressions respect partial
interpretations coNP-complete. consequence, well-founded semantics general
LPA programs allows tractable computation unlikely exist, justifies
restriction LPA
m,a programs. Finally, present prototype system extending DLV,
supports well-founded semantics LPA
m,a programs, time writing
implemented system so. Experiments prototype show significant
computational advantages aggregate constructs equivalent aggregate-free encodings.

1. Introduction
use logical formulas basis knowledge representation language proposed 50 years ago seminal works McCarthy (1959), McCarthy
Hayes (1969). However, soon realized monotonic nature classical logic
(the addition new knowledge may increase set consequences theory
classical logic) always suited model commonsense reasoning, sometimes
intrinsically nonmonotonic (Minsky, 1975). alternative, suggested represent
c
2011
AI Access Foundation. rights reserved.

fiAlviano, Calimeri, Faber, Leone, & Perri

commonsense reasoning using logical languages nonmonotonic consequence relations,
better simulate forms human reasoning, allowing new knowledge invalidate previous conclusions. observation opened new important
research field, called nonmonotonic reasoning, led definition investigation
new logical formalisms, called nonmonotonic logics. popular nonmonotonic logics
circumscription (McCarthy, 1980, 1986), default logic (Reiter, 1980), nonmonotonic
modal logics (McDermott & Doyle, 1980; McDermott, 1982; Moore, 1985). Later on,
cross fertilizations field nonmonotonic logics logic programming,
another nonmonotonic language, called Declarative Logic Programming (LP) emerged,
incorporating nonmonotonic negation operator denoted not. Declarative Logic Programming gained popularity last years, today widely used formalism
knowledge representation reasoning, applications various scientific disciplines
even industry (Ricca, Alviano, Dimasi, Grasso, Ielpa, Iiritano, Manna, & Leone,
2010; Ricca, Grasso, Alviano, Manna, Lio, Iiritano, & Leone, 2011; Manna, Ricca, & Terracina, 2011; Manna, Ruffolo, Oro, Alviano, & Leone, 2011). LP problems solved
means declarative specifications requirements achieved. ad-hoc algorithms
required.
Several semantics LP proposed literature, take care
inherent non-monotonicity operator programs. well-founded
semantics (Van Gelder, Ross, & Schlipf, 1991) one prominent among them.
associates three-valued model, well-founded model, every logic program. Originally,
well-founded semantics defined normal logic programs, is, standard
logic programs nonmonotonic negation. distinguishing property well-founded
semantics existence uniqueness well-founded model guaranteed
logic programs. Moreover, well-founded semantics computable polynomial time
respect input program propositional case.
Even LP declarative programming language, standard LP allow
representing properties sets data natural way, relevant aspect many application domains. addressing insufficiency, several extensions LP
proposed, relevant introduction aggregate functions (LPA ;
Kemp & Stuckey, 1991; Denecker, Pelov, & Bruynooghe, 2001; Dix & Osorio, 1997; Gelfond, 2002; Simons, Niemela, & Soininen, 2002; DellArmi, Faber, Ielpa, Leone, & Pfeifer,
2003; Pelov & Truszczynski, 2004; Pelov, Denecker, & Bruynooghe, 2004). Among them,
recursive definitions involving aggregate functions (i.e., aggregation aggregated
data depend evaluation aggregate itself) particularly interesting,
definition semantics straightforward (Pelov, 2004; Faber, Leone, & Pfeifer,
2004; Son & Pontelli, 2007; Liu, Pontelli, Son, & Truszczynski, 2010). Note similar
construct, referred abstract constraint, introduced literature (Marek
& Truszczynski, 2004; Liu & Truszczynski, 2006; Son, Pontelli, & Tu, 2007; Truszczynski,
2010; Brewka, 1996). results paper carry LP abstract
constraints, well-founded semantics knowledge defined far.
paper focus fragment LPA allowing monotone antimonotone

aggregate expressions (LPA
m,a ; Calimeri, Faber, Leone, & Perri, 2005). LPm,a programs
many interesting properties. Among them, highlight similarities monotone
aggregate expressions positive standard literals, antimonotone aggregate
488

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

expressions negative standard literals. particular, take advantage aspect
defining unfounded sets and, based definition, well-founded semantics

LPA
m,a fragment. well-founded semantics LPm,a programs obtained way
retains many desirable properties original well-founded semantics LP,
extends: LPA
m,a program unique well-founded model exists, polynomialtime computable, approximates programs answer sets, coincides answer
set stratified LPA
m,a programs.
Actually turns well-founded semantics thus obtained coincides (on LPA
m,a
programs) well-founded semantics proposed Pelov, Denecker, Bruynooghe
(2007). Pelov et al. define several semantics logic programs aggregates using various approximating immediate consequence operators. notion logic program adopted
Pelov et al. general one considered present work, allowing
arbitrary first-order formulas bodies, unrestricted aggregates, non-Herbrand interpretations. equivalence two semantics, properties proved
Pelov et al. carry work well. applies results well-founded
model total stratified programs (Theorem 9), well-founded model contained
answer set (Theorem 16), well-founded model computable polynomial time (Theorem 21). However, framework introduced article considerably
different one developed Pelov et al., allows giving alternative proofs
result. Vice versa, article contains many new results, carry
framework Pelov et al. LPA
m,a programs. particular, provides alternative
definition well-founded semantics, characterization answer sets means unfounded sets, implemented system computing well-founded semantics,
time writing one kind.
would point extensions LPA
m,a programs come
mind, definition unfounded sets would considerably changed (see instance definition provided Faber, 2005), moreover main desired properties
well-founded semantics would longer guaranteed. instance, obvious extension, including aggregate expressions neither monotone antimonotone
would likely computable polynomial time: fact, evaluation
aggregate expressions respect partial interpretations tractable monotone
antimonotone aggregates, task coNP-complete general aggregate expressions. Also, instance allowing aggregates rule heads would necessarily complicate
definition unfounded sets, would guarantee existence well-founded model
every program, would likely guarantee polynomial-time computability.
concepts defined paper directly give rise computation method
well-founded semantics LPA
m,a programs. implemented method,
best knowledgethe first kind. conducted experiments
system LPA
m,a encodings particular problem domain, compared
encodings using aggregates. latter encodings tested system
prototype derived XSB, state-of-the-art system computing
well-founded model. experiments show clear advantage LPA
m,a encodings
run prototype system.
Summarizing, main contributions paper follows.
489

fiAlviano, Calimeri, Faber, Leone, & Perri

define new notion unfounded set logic programs monotone
antimonotone aggregates (LPA
m,a programs). notion sound generalization
concept unfounded set previously given standard logic programs. show
definition coincides original definition unfounded sets (Van Gelder
et al., 1991) class normal (aggregate-free) programs, shares
distinguishing properties (such existence greatest unfounded set).
define well-founded operator WP logic programs aggregates, extends classical well-founded operator (Van Gelder et al., 1991). total fixpoints
WP exactly answer sets P, least fixpoint WP () contained
intersection answer sets. show operator equivalent
operator defined Pelov et al. (2007).
provide declarative characterization answer sets terms unfounded sets.
particular, prove answer sets LPA
m,a program precisely
unfounded-free models.
show reasoning aggregates without restrictions may easily increase
complexity computation. particular, prove deciding truth
falsity aggregate expression respect partial interpretation
coNP-complete problem. However, problem intractable general,
polynomial-time solvable monotone antimonotone aggregates.
analyze complexity well-founded semantics, confirming extending
results work Pelov et al. (2007). Importantly, turns WP ()
polynomial-time computable propositional LPA
m,a programs. non-ground
programs, data-complexity remains polynomial, program complexity
rises P EXPTIME, aggregate-free programs.
present prototype system supporting well-founded semantics defined
article. prototype, obtained extending DLV, first system implementing
well-founded semantics (unrestricted) LPA
m,a programs.
report experimental results implemented prototype. specifically,
define Attacks problem, problem inspired classic Win-Lose problem
often considered context well-founded semantics standard logic programs. compare execution times prototype LPA
m,a encoding
equivalent LP encodings. particular, one tested LP encodings obtained means compilation aggregates standard LP, briefly
presented paper. obtained results evidence computational advantages
problem encoding using aggregate expressions without them.
presentation organized follows. Section 2 present basics
LPA language and, particular, introduce LPA
m,a fragment. fragment,
define unfounded sets well-founded semantics Section 3. Relationships
well-founded semantics answer set semantics discussed Section 4. complexity
analysis well-founded semantics LPA
m,a programs reported Section 5.
490

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

Section 6 discuss implemented prototype system experimentation. Finally,
related work discussed Section 7, Section 8 draw conclusions.

2. LPA Language
Syntax, instantiation, interpretations models LPA programs introduced
section. Moreover, introduce LPA
m,a fragment language, define
well-founded semantics Section 3. additional background standard LP, refer
literature (Gelfond & Lifschitz, 1991; Baral, 2003).
2.1 Syntax
assume sets variables, constants, predicates given. Similar Prolog,
assume variables strings starting uppercase letters constants nonnegative integers strings starting lowercase letters. Predicates strings starting
lowercase letters. arity (non-negative integer) associated predicate.
Moreover, language allows using built-in predicates (i.e., predicates fixed
meaning) common arithmetic operations positive integers (i.e., =, , , +, ,
etc.; written infix notation), interpreted standard mathematical way.
2.1.1 Standard Atom
term either variable constant. standard atom expression p(t1 , . . . , tn ),
p predicate arity n t1 , . . . , tn terms. atom p(t1 , . . . , tn ) ground
t1 , . . . , tn constants.
2.1.2 Set Term
set term either symbolic set ground set. symbolic set pair {Terms : Conj },
Terms list terms (variables constants) Conj conjunction standard
atoms, is, Conj form a1 , . . . , ak ai (1 k) standard
atom. Intuitively, set term {X : a(X, c), p(X)} stands set X-values making
conjunction a(X, c), p(X) true, i.e., {X | a(X, c) p(X) true}. ground set set
pairs form hconsts : conj i, consts list constants conj conjunction
ground standard atoms.
2.1.3 Aggregate Function
aggregate function form f (S), set term, f aggregate
function symbol. Intuitively, aggregate function thought (possibly partial)
function mapping multisets constants constant. Throughout remainder
paper, adopt notation DLV system (Leone, Pfeifer, Faber, Eiter, Gottlob,
Perri, & Scarcello, 2006) representing aggregates.
Example 1 common aggregate functions listed below:
#min, minimal term, undefined empty set;
#max, maximal term, undefined empty set;
491

fiAlviano, Calimeri, Faber, Leone, & Perri

#count, number terms;
#sum, sum integers;
#times, product integers;
#avg, average integers, undefined empty set.
2.1.4 Aggregate Atom
aggregate atom structure form f (S) , f (S) aggregate function,
{<, , >, } comparison operator, term (variable constant).
aggregate atom f (S) ground constant ground set.
Example 2 following aggregate atoms DLV notation:
#max{Z : r(Z), a(Z, V )} >
#max{h2 : r(2), a(2, m)i, h2 : r(2), a(2, n)i} > 1

2.1.5 Literal
literal either (i) standard atom, (ii) standard atom preceded negation
failure symbol not, (iii) aggregate atom. Two standard literals complementary
form a, standard atom a. standard literal ,
denote . complement . Abusing notation, L set standard literals,
.L denotes set {. | L}.
2.1.6 Program
rule r construct form
: 1 , . . . , .

standard atom, 1 , . . . , literals, 0. atom referred
head r, conjunction 1 , . . . , body r. body empty
(m = 0), rule called fact. denote head atom H(r) = a, set
body literals B(r) = {1 , . . . , }. Moreover, set positive standard body literals
denoted B + (r), set negative standard body literals B (r), set
aggregate body literals B (r). rule r ground H(r) literals B(r)
ground. program set rules. program ground rules ground.
2.1.7 Safety
local variable rule r variable appearing solely sets terms r; variable r
local global. rule r safe following conditions hold: (i)
global variable X r positive standard literal B + (r) X appears
; (ii) local variable r appearing symbolic set {Terms : Conj } appears
Conj . Note condition (i) standard safety condition adopted LP guarantee
variables range restricted (Ullman, 1989), condition (ii) specific
aggregates. program safe rules safe.
492

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

Example 3 Consider following rules:
p(X) : q(X, Y, V ), #max{Z : r(Z), a(Z, V )} > Y.
p(X) : q(X, Y, V ), #sum{Z : r(X), a(X, S)} > Y.
p(X) : q(X, Y, V ), #min{Z : r(Z), a(Z, V )} > T.

first rule safe, second local variable Z violates condition
(ii). third rule safe, since global variable violates condition (i).
2.2 Program Instantiation, Interpretations Models
Section 3 define well-founded semantics relevant class LPA programs.
well-founded semantics defined ground programs, programs variables
associated equivalent ground programs. section introduce preliminary
notions program instantiation, interpretations models.
2.2.1 Universe Base
Given LPA program P, universe P, denoted , set constants
appearing P. base P, denoted BP , set standard atoms constructible
predicates P constants .
2.2.2 Instantiation
substitution mapping set variables . Given substitution
LPA object obj (rule, set, etc.), denote obj object obtained replacing
variable X obj (X). substitution set global variables rule
r (to ) global substitution r; substitution set local variables
set term (to ) local substitution S. Given set term without global variables
= {Terms : Conj }, instantiation following ground set:
inst(S) = {hTerms : Conj | local substitution S}.
ground instance rule r obtained two steps: First, global substitution r
applied, every set term r replaced instantiation inst(S).
instantiation Ground(P) program P set instances rules P.
Example 4 Consider following program P1 :
q(1) : p(2, 2).
p(2, 2) : q(1).

q(2) : p(2, 1).
p(2, 1) : q(2).

t(X) : q(X), #sum{Y : p(X, )} > 1.

instantiation Ground(P1 ) P1 following program:
q(1) : p(2, 2).
p(2, 2) : q(1).

q(2) : p(2, 1).
p(2, 1) : q(2).

t(1) : q(1), #sum{h1 : p(1, 1)i, h2 : p(1, 2)i} > 1.
t(2) : q(2), #sum{h1 : p(2, 1)i, h2 : p(2, 2)i} > 1.

2.2.3 Aggregate Function Domain
X

Given set X, let 2 denote set multisets elements X. domain
aggregate function set multisets function defined. Without loss
generality, assume aggregate functions map Z (the set integers).
493

fiAlviano, Calimeri, Faber, Leone, & Perri

Example 5 Let us look common domains aggregate functions Example 1:
U
Z
#count defined 2 ,P #sum #times 2 , #min, #max #avg
Z
2 \ {}.
2.2.4 Interpretation
interpretation LPA program P consistent set standard ground literals,
is, BP .BP .I = . denote + set standard
positive negative literals occurring I, respectively. interpretation total
+ .I = BP , otherwise partial. set interpretations P denoted
IP . Given interpretation standard literal , evaluation respect
defined follows: (i) I, true respect I; (ii) . I,
false respect I; (iii) otherwise, 6 . 6 I, undefined
respect I. interpretation provides meaning set terms, aggregate functions
aggregate literals, namely multiset, value, truth value, respectively.
first consider total interpretation I. evaluation I(S) set term respect
multiset I(S) defined follows: Let = {ht1 , ..., tn | ht1 , ..., tn : Conj
atoms Conj true respect I}; I(S) multiset obtained
projection tuples SI first constant, is, I(S) = [t1 | ht1 , ..., tn ].
evaluation I(f (S)) aggregate function f (S) respect result
application f I(S).1 multiset I(S) domain f , I(f (S)) =
(where fixed symbol occurring P). ground aggregate atom = f (S) k
true respect I(f (S)) 6= I(f (S)) k hold; otherwise, false.
Example 6 Let I1 total interpretation I1+ = {f (1), g(1, 2), g(1, 3), g(1, 4), g(2, 4),
h(2), h(3), h(4)}. Assuming variables local, check that:
#count{X : g(X, )} > 2 false; indeed, S1 corresponding ground set,
S1I1 = {h1i, h2i}, I1 (S1 ) = [1, 2] #count([1, 2]) = 2.
#count{X, : g(X, )} > 2 true; indeed, S2 corresponding ground set,
S2I1 = {h1, 2i, h1, 3i, h1, 4i, h2, 4i}, I1 (S2 ) = [1, 1, 1, 2] #count([1, 1, 1, 2]) = 4.
#times{Y : f (X), g(X, )} <= 24 true; indeed, S3 corresponding ground
set, S3I1 = {h2i, h3i, h4i}, I1 (S3 ) = [2, 3, 4] #times([2, 3, 4]) = 24.
#sum{X : g(X, ), h(Y )} <= 3 true; indeed, S4 corresponding ground set,
S4I1 = {h1i, h2i}, I1 (S4 ) = [1, 2] #sum([1, 2]) = 3.
#sum{X, : g(X, ), h(Y )} <= 3 false; indeed, S5 corresponding ground
set, S5I1 = {h1, 2i, h1, 3i, h1, 4i, h2, 4i}, I1 (S5 ) = [1, 1, 1, 2] #sum([1, 1, 1, 2]) =
5.;
#min{X : f (X), h(X)} >= 2 false; indeed, S6 corresponding ground set,
S6I1 = , I1 (S6 ) = , I1 (#min()) = (we recall domain
#min).
1. paper, consider aggregate functions value polynomial-time computable
respect input multiset.

494

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

consider partial interpretation refer interpretation J
J extension I. ground aggregate atom true (resp. false) respect
total interpretation J extending I, true (resp. false) respect I;
otherwise, undefined.
Example 7 Let S7 ground set literal 1 = #sum{h1 : p(2, 1)i, h2 : p(2, 2)i} >
1, consider partial interpretation I2 = {p(2, 2)}. Since total interpretation
extending I2 contains either p(2, 1) p(2, 1), either I2 (S7 ) = [2] I2 (S7 ) =
[1, 2]. Thus, application #sum yields either 2 > 1 3 > 1, thus 1 true
respect I2 .
Remark 1 Observe definitions interpretation truth values preserve knowledge monotonicity: interpretation J extends (i.e., J), literal true
respect true respect J, literal false respect
false respect J well.
2.2.5 Model
Given interpretation I, rule r satisfied respect least one following
conditions satisfied: (i) H(r) true respect I; (ii) literal B(r) false
respect I; (iii) H(r) literal B(r) undefined respect I.
interpretation model LPA program P rules r Ground(P)
satisfied respect .
Example 8 Consider program P1 Example 4. Let I3 total interpretation
P1 I3+ = {q(2), p(2, 2), t(2)}. I3 minimal model P1 .
2.3 LPA
m,a Language

definition LPA
m,a programs, fragment LP analyzed paper, based
following notion monotonicity literals.

2.3.1 Monotonicity
Given two interpretations J, say J + J + J .
ground literal monotone if, interpretations I, J J, that:
(i) true respect implies true respect J, (ii) false respect
J implies false respect I. ground literal antimonotone opposite
happens, is, interpretations I, J J, that: (i) false
respect implies false respect J, (ii) true respect J implies
true respect I. ground literal nonmonotone neither monotone
antimonotone. Note positive standard literals monotone, whereas negative standard
literals antimonotone. Aggregate literals, instead, may monotone, antimonotone
nonmonotone. examples shown complete picture
common aggregate functions summarized Table 1.
Example 9 Let us assume universe numerical constants non-negative
integers. ground instances following aggregate literals thus monotone:
495

fiAlviano, Calimeri, Faber, Leone, & Perri

Table 1: Character common aggregate literals.
Function Domain Operator
Character
#count

>,
monotone
<,
antimonotone
#sum
N
>,
monotone
<,
antimonotone
Z
<, , >, nonmonotone
#times
N+
>,
monotone
<,
antimonotone
N, Z
<, , >, nonmonotone
#min

>,
nonmonotone
<,
monotone
#max

>,
monotone
<,
nonmonotone
#avg
N, Z
<, , >, nonmonotone


Antimonotone context guarantees set term aggregate never becomes empty.

#sum{Z : r(Z)} 10.

#count{Z : r(Z)} > 1;

Ground instances following literals instead antimonotone:
#sum{Z : r(Z)} 10.

#count{Z : r(Z)} < 1;

2.3.2 LPA
m,a Programs

Let LPA
m,a denote fragment LP allowing monotone antimonotone literals.
LPA
m,a rule r, set monotone antimonotone body literals denoted

B (r) B (r), respectively. LPA
m,a program P stratified exists function
|| ||, called level mapping, set predicates P ordinals,
pair a, b predicates, occurring head body rule r P, respectively: (i) b
appears antimonotone literal, ||b|| < ||a||, (ii) otherwise ||b|| ||a||. Intuitively,
stratification forbids recursion antimonotone literals (for aggregate-free programs
definition coincides common notion stratification respect negation).

Example 10 Consider LPA
m,a program consisting following rules:
q(X) : p(X), #count{Y : a(Y, X), b(X)} 2.
p(X) : q(X), b(X).

assume predicates b defined facts, include
explicitly. program stratified, level mapping ||a|| = ||b|| = 1, ||p|| = ||q|| = 2
satisfies required conditions. add rule b(X) : p(X), levelmapping exists, program becomes unstratified.
would note definition LPA
m,a could enlarged, form
given classifies literals independently context (that is, program)
496

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

occur. aggregates nonmonotone definition given above, might
manifest nonmonotone effects given context: one limits interpretations
considered violate program literal occurs,
interpretation pairs violate monotonicity antimonotonicity may longer
present. fact, one could refine definition way (considering pairs
non-violating interpretations given context program). modified definition would
enlarge class LPA
m,a programs, retaining results paper,
simplicity exposition refrain formally. example, aggregate
atom involving #max < operator formally LPA
m,a , one considers
occurrences program non-violating interpretation I(S) =
(where set term aggregate), aggregate behaves antimonotone
way particular program. noted cases footnote Table 1.

3. Unfounded Sets Well-Founded Semantics
section introduce new notion unfounded set LPA
m,a programs,
extends original definition aggregate-free programs introduced Van Gelder et al.
(1991). Unfounded sets used extending well-founded semantics, originally
defined aggregate-free programs Van Gelder et al., LPA
m,a programs.
highlight number desirable properties semantics. following deal
ground programs, usually denote P ground program. use
notation L .L set (L \ L ) .L , L L sets standard ground
literals.
Definition 1 (Unfounded Set) set X BP ground atoms unfounded set
LPA
m,a program P respect (partial) interpretation if, rule
r P H(r) X , least one following conditions holds:
(1) (antimonotone) literal B (r) false respect I,
(2) (monotone) literal B (r) false respect .X .
Intuitively, rule head atom belonging unfounded set X already
satisfied respect (in case condition (1) holds), satisfiable taking false
atoms unfounded set (in case condition (2) holds). Note that, according
definition above, empty set unfounded set respect every program
interpretation.
Example 11 Consider interpretation I4 = {a(1), a(2), a(3)} following program
P2 :
r1 :
r2 :
r3 :

a(1) : #count{h1 : a(1)i, h2 : a(2)i, h3 : a(3)i} > 2.
a(2).
a(3) : #count{h1 : a(1)i, h2 : a(2)i, h3 : a(3)i} > 2.

X1 = {a(1)} unfounded set P2 respect I4 , since condition (2)
Definition 1 holds r1 (the rule head a(1)). Indeed, (monotone) literal
appearing B (r1 ) false respect I4 .X1 = {not a(1), a(2), a(3)}. Similarly,
{a(3)} {a(1), a(3)} unfounded sets P2 respect I4 . Clearly,
unfounded set. sets atoms unfounded P2 respect I4 .
497

fiAlviano, Calimeri, Faber, Leone, & Perri

formalized below, Definition 1 generalizes one given Van Gelder et al. (1991)
aggregate-free programs: set standard atoms X BP unfounded set
program P respect interpretation if, rule r P
H(r) X , either (i) B(r) .I 6= , (ii) B + (r) X =
6 .
Theorem 1 aggregate-free program P, Definition 1 equivalent one introduced work Van Gelder et al. (1991).
Proof. aggregate-free program P, conditions (1) (2) Definition 1 equivalent (a) B (r) .I 6= (b) B + (r) .(I .X ) 6= , respectively. Condition (b)
equivalent B + (r) (.(I \ X ) ..X ) 6= , holds either (b.1)
B + (r) .(I \ X ) 6= , (b.2) B + (r) X =
6 . Condition (b.2) exactly condition (ii)
work Van Gelder et al. Concerning condition (b.1), since B + (r) contains
positive literals, ignore negative literals .(I \ X ), is, positive literals
\ X . noting negative literals \ X precisely negative literals
I, conclude (b.1) equivalent B + (r) .I 6= . Finally, combining
previous statement condition (a) above, obtain condition (i) work Van
Gelder et al.

Thus, Definition 1 alternative characterization unfounded sets aggregate-free
programs. fact, condition (1) Definition 1 exactly cover first one
Van Gelder et al., condition (2) catches cases second work Van Gelder
et al. missed condition (1).
Theorem 2 X X unfounded sets LPA
m,a program P respect

interpretation I, X X unfounded set P respect I.
Proof. Let r P H(r) X X . want show either (1)
(antimonotone) literal B (r) false respect I, (2) (monotone) literal
B (r) false respect J = .(X X ). symmetry, assume
H(r) belongs X . Since X unfounded set respect hypothesis, either
(a) (antimonotone) literal B (r) false respect I, (b) (monotone)
literal B (r) false respect K = .X . Case (a) equals (1). Thus,
remains prove case (b) implies (2). Indeed, J K J + K +
J K . Therefore, definition monotonicity, monotone literal
false respect K false respect J well, done.

corollary Theorem 2, union unfounded sets unfounded set
well.
Corollary 3 union unfounded sets LPA
m,a program P respect
interpretation unfounded set P respect well. refer set
greatest unfounded set P respect I, denoted GU SP (I).
important monotonicity property greatest unfounded set.
Proposition 4 Let J interpretations LPA
m,a program P. J,
GU SP (I) GU SP (J).
498

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

Proof. Since GU SP (J) union unfounded sets P respect J
definition, enough show X = GU SP (I) unfounded set P respect
J. Thus, want show that, rule r P H(r) X , either (1)
(antimonotone) literal B (r) false respect J, (2) (monotone) literal
B (r) false respect J .X . already know X unfounded set P
respect Corollary 3. Therefore, either (a) (antimonotone) literal B (r)
false respect I, (b) (monotone) literal B (r) false respect
.X . Since J, J J .X extensions interpretations
.X , respectively. Hence, Remark 1, (a) implies (1) (b) implies (2),
done.

ready extending well-founded operator defined Van Gelder et al.
(1991) case LPA
m,a programs.
Definition 2 Let P LPA
m,a program. immediate logical consequence operator
B
P
TP : IP 2
well-founded operator WP : IP 2BP .BP defined follows:
TP (I) = { BP | r P H(r) =
literals B(r) true respect I}
WP (I) = TP (I) .GU SP (I).
Intuitively, given interpretation program P, WP derives true set
atoms belonging every model extending (by means TP operator). Moreover,
WP derives false atoms belonging unfounded set P respect
(by means GU SP operator). Note TP (I) GU SP (I) set atoms,
WP (I)+ = TP (I) WP (I) = .GU SP (I). following proposition formalizes
intuition Definition 2 extends WP operator defined Van Gelder et al. (1991)
standard programs LPA
m,a programs.
Proposition 5 Let P aggregate-free program. WP operator Definition 2
coincides WP operator defined Van Gelder et al. (1991).
Proof. Since WP equal union TP .GU SP cases,
show definitions TP GU SP coincide introduced Van Gelder
et al. (1991) aggregate-free programs.
two immediate logical consequence operators (TP ) coincide aggregate-free
program P. Indeed, rule r P, B(r) standard literals.
definition GU SP (I) coincides one Van Gelder et al. (1991)
aggregate-free program P interpretation I. Indeed, cases GU SP (I)
defined union unfounded sets P respect I, notion
unfounded set coincides one work Van Gelder et al. standard
programs Theorem 1.

next show fixpoint well-founded operator WP (possibly partial)
model.
499

fiAlviano, Calimeri, Faber, Leone, & Perri

{a, b}

{a, b}

{a}

{b}

{not a, b} {not a, b}

{not b}

{not a}


Figure 1: meet semilattice
Theorem 6 Let P LPA
m,a program (partial) interpretation.
fixpoint WP , (partial) model P.
Proof. Let us assume WP (M ) = holds. Thus, TP (M ) .GU SP (M )
hold. Consider rule r P. literals B(r) true respect ,
H(r) TP (M ) . H(r) false respect , H(r) GU SP (M ).
Since GU SP (M ) unfounded set P respect Corollary 3, either
literal B (r) false respect , literal B (r) false respect
.GU SP (M ) = . conclude r satisfied .

theorem states WP monotone operator meet semilattice induced IP subset-containment relationship. recall meet semilattice
partially ordered set meet (or greatest lower bound) nonempty finite
subset. example meet semilattice program base {a, b} reported
Figure 1.
Theorem 7 Let P LPA
m,a program. well-founded operator WP monotone
operator meet semilattice hIP , i.
Proof. Since WP equal union TP .GU SP Definition 2,
prove monotonicity operators TP GU SP .
first show TP monotone operator, is, pair interpretations
I, J P J, holds TP (I) TP (J). Consider atom TP (I).
Definition 2, rule r P H(r) = literals B(r)
true respect I. Since J, conclude literals B(r)
true respect J well (see Remark 1), H(r) = belongs TP (J)
Definition 2.
already know GU SP monotone operator Proposition 4:
pair interpretations I, J P J, holds GU SP (I) GU SP (J).

prove sequence W0 = , Wn+1 = WP (Wn ) well-defined, is,
element sequence interpretation.
Theorem 8 Let P LPA
m,a program. sequence W0 = , Wn+1 = WP (Wn )
well-defined.
500

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

Proof. use strong induction. base case trivial, since W0 = . order prove
consistency Wn+1 = TP (Wn ).GU SP (Wn ), assume consistency every Wm
n. Since WP monotone operator Theorem 7, enough show
GU SP (Wn ) Wn+1 = . end, next show set X atoms
X Wn+1 6= unfounded set P respect Wn (and contained
GU SP (Wn )). Let Wm+1 first element sequence X Wm+1 6= (note
n). Consider atom X Wm+1 . definition TP , rule r P
H(r) = literals B(r) true respect Wm . Note
atom Wm belong X (for way Wm+1 chosen). Thus,
Remark 1, literals B(r) true respect Wn Wn .X (we
recall Wn Wm WP monotone). ends proof, neither condition
(1) (2) Definition 1 hold .

Theorem 8 Theorem 7 imply WP admits least fixpoint (Tarski, 1955),
referred well-founded model P. well-founded semantics LPA
m,a
program P given model. state first important property
well-founded semantics LPA
m,a programs.
Property 1 every LPA
m,a program, well-founded model always exists unique.
Another important property well-founded semantics easily follows Proposition 5.
Property 2 aggregate-free programs, well founded semantics defined
paper coincides classical well-founded semantics Van Gelder et al. (1991).
Although well-founded model, general, might leave atoms undefined,
cases WP () total interpretation.
Example 12 Consider following program P3 :
a(1) : #sum{h1 : a(1)i, h2 : a(2)i} > 2.
a(2) : b.
b : c.

iterated application WP yields following sets:
1.
2.
3.

WP () = {not a(1), c};
WP ({not a(1), c}) = {not a(1), c, b};
WP ({not a(1), c, b}) = {not a(1), c, b, a(2)} = WP ().

case, well-founded model total. Indeed, atom BP either true false
respect WP ().
totality well-founded model program due stratification,
formalized next theorem. Given Corollary 25, equivalent result stated
already Pelov et al. (2007) Theorem 7.2 Corollary 7.1. However, proof
labelled sketch Pelov et al., moreover relies rather different formalisms
proof.
501

fiAlviano, Calimeri, Faber, Leone, & Perri

Theorem 9 stratified LPA
m,a programs, well-founded model total.

Proof. Let P stratified LPA
m,a program. order prove WP () total,
show (standard) atom BP \WP () false respect WP (). definition
stratification, level mapping || || (standard) predicates P that,
pair a, b standard predicates occurring head body rule r P,
respectively, following conditions satisfied: (i) b appears antimonotone literal,
||b|| < ||a|| holds; (ii) otherwise, b appears monotone literal, ||b|| ||a||
holds. order define non-decreasing sequence subsets BP follows:

L0 =
Li+1 = Li { BP | predicate p ||p|| = i},

N.

aim show that, N, set Li+1 \WP () contained .WP () .
use induction i. base case trivial L0 = holds definition.
suppose atoms Li \ WP () false respect WP () order show
atoms Li+1 \ WP () false respect WP () well. end,
prove Li+1 \ WP () unfounded set P respect WP (). Consider
rule r Ground(P) H(r) Li+1 \ WP (). want show either (1)
(antimonotone) literal B (r) false respect WP (), (2) (monotone)
literal B (r) false respect WP () .(Li+1 \ WP ()). Since H(r) Li+1 ,
definition stratification following propositions hold:
(a) literal B (r) either negated standard atom belonging Li , aggregate
literal depending atoms Li ;
(b) literal B (r) either standard atom belonging Li+1 , aggregate
literal depending atoms Li+1 .
Since H(r) 6 WP () (that is, H(r) 6 TP (WP ())), literal B(r)
true respect WP () (by definition TP ). antimonotone literal,
apply (a) induction hypothesis conclude (1) holds ( cannot undefined
respect WP (), must false). monotone literal, apply (b)
induction hypothesis conclude (2) holds ( cannot undefined respect
WP () .(Li+1 \ WP ()) WP () .(Li+1 \ WP ()) WP () holds, must
false).


4. Answer Set Characterization via Unfounded Sets
well-founded semantics three-valued semantics, is, program associated model atoms either true, false undefined. semantics
literature associate programs two-valued models (i.e., models without undefined
atoms). commonly accepted two-value semantics LP answer set semantics.
section present number results concerning unfounded sets answer sets
LPA
m,a programs. first recall definition answer sets provided Faber, Leone,
Pfeifer (2011).
502

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

Definition 3 (Minimal Model) total model P (subset-)minimal total
model N P exists N + + . Note that, definitions, words
interpretation model refer possibly partial interpretations, minimal model
always total interpretation.
next provide transformation reduct ground program
respect total interpretation formed. Note definition generalization (Faber
et al., 2004) Gelfond-Lifschitz transformation (1991) standard logic programs.
Definition 4 (Program Reduct) Given LPA program P total interpretation
I, let Ground(P)I denote transformed program obtained Ground(P) deleting
rules body literal false respect I, i.e.:
Ground(P)I = {r Ground(P) | literals B(r) true respect I}.
ready introducing notion answer set LPA programs.
Definition 5 (Answer Set LPA Programs) Given LPA program P, total interpretation P answer set P minimal model
Ground(P)M .
Example 13 Consider two total interpretations I5 = {p(0)} I6 = {not p(0)}
following two programs:
P4 = {p(0) : #count{X : p(X)} > 0.}
P5 = {p(0) : #count{X : p(X)} 0.}

obtain following transformed programs:
Ground(P4 )I5
Ground(P4 )I6
Ground(P5 )I5
Ground(P5 )I6

= Ground(P4 ) = {p(0) : #count{h0 : p(0)i} > 0.}
=
=
= Ground(P5 ) = {p(0) : #count{h0 : p(0)i} 0.}

Hence, I6 answer set P4 . Indeed, I5 minimal model Ground(P4 )I5 .
Moreover, P5 answer sets. Indeed, I5 minimal model Ground(P5 )I5 ,
I6 model Ground(P5 )I6 = Ground(P5 ).
Note answer set P total model P Ground(P)M
Ground(P), rules Ground(P) \ Ground(P)M satisfied respect
(by Definition 4, rules must least one body literal false
respect ).
language LPA
m,a considered work, answer sets defined Definition 5
coincide stable models defined Pelov, Denecker, Bruynooghe (2003)
hence defined Pelov et al. (2007) Son et al. (2007). equivalence
follows Propositions 3.7 3.8 Ferraris (2011), respectively state stable
models Pelov et al. (2003) LPA
m,a coincide semantics defined Ferraris (2011),
turn coincides Definition 5 larger class programs. means
results involving answer sets hold semantics LPA
m,a .
hand, implies results (for example Theorem 16) consequences
results work Pelov et al. (2007) virtue Theorem 24 Section 7.
remainder section highlight relevant relationships answer sets
unfounded sets. introducing results, let us provide additional definition.
503

fiAlviano, Calimeri, Faber, Leone, & Perri

Definition 6 (Unfounded-free Interpretation) interpretation LPA
m,a program P unfounded-free X = holds unfounded set X P
respect I.
total interpretations, equivalent characterization unfounded-free property
given below.
Lemma 10 total interpretation LPA
m,a program P unfounded-free
+
empty set subset unfounded set P respect I.
Proof. () Straightforward: Definition 6, disjoint unfounded set
P respect I.
() prove contrapositive: unfounded-free, exists non-empty
subset + unfounded set P respect I. Definition 6,
unfounded-free, exists unfounded set X P respect
X =
6 . next show X unfounded set P respect I, i.e.,
rule r P H(r) X , either (1) (antimonotone) literal B (r)
false respect I, (2) (monotone) literal B (r) false respect
.(I X ). Since X unfounded set, Definition 1, either (a) (antimonotone)
literal B (r) false respect I, (b) (monotone) literal B (r) false
respect .X . Thus, end proof showing .X = .(I X ).
end, observe (i) .X = .(X \ I) .(I X ). Moreover, since total,
.(BP \ + ) = , thus (ii) .(X \ I) = .(X \ + ) \ X . using (i)
.X = (I \ X ) .X simplifying (ii) obtain .X = (I \ X ) .(I X ).
conclude observing \ X = \ (I X ), thus .X = .(I X )
holds.

give another interesting characterization total models LPA
m,a programs.
Lemma 11 total interpretation (total) model LPA
m,a program P
.M unfounded set P respect .
Proof. start observing rule r P H(r) + satisfied
. Thus, show that, rule r P H(r) .M , literal
B(r) false respect either (1) (antimonotone) literal B (r)
false respect , (2) (monotone) literal B (r) false respect
.(.M ). end, enough prove .(.M ) = holds.
definition, () .(.M ) = (M \ .M ) ..M . consistency
.M disjoint. Moreover, ..M = subset .
simplifying () last two sentences, obtain .(.M ) = .

give characterizations answer sets LPA
m,a programs.
Theorem 12 total model answer set LPA
m,a program P
unfounded-free.
504

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

Proof. () prove contrapositive: total model LPA
m,a program P
unfounded-free, answer set P. Lemma 10, since total
interpretation unfounded-free, exists unfounded set X P
respect X + X =
6 . Therefore, prove answer

set P, next show .X model P .X .
end, consider rule r P . Definition 4 reduct, literals B(r) true
respect , H(r) + model P P P.
consider two cases:
1. H(r) 6 X . case, H(r) .X well.
2. H(r) X . case, since X unfounded set P respect , either
(1) literal B (r) false respect , (2) literal B (r) false
respect .X . previous considerations, since r P , (1) cannot hold,
conclude literal B(r) false respect .X .
Hence, r satisfied .X either head (in case H(r) 6 X ),
body (in case H(r) X ), done.
() prove contrapositive: total model LPA
m,a program P
answer set P, unfounded-free. Since model P P
answer set P, exists total model N P N + + . next show
+ \ N + unfounded set P respect , is, rule r P
H(r) + \ N + , either (1) (antimonotone) literal B (r) false respect
, (2) (monotone) literal B (r) false respect .(M + \ N + ).
start showing .(M + \ N + ) = N . definition, (a) .(M + \ N + ) =
(M \ (M + \ N + )) .(M + \ N + ). N + + (b) \ (M + \ N + ) =
N + . Moreover, since N total interpretations N + + , (c)
N (d) .(M + \ N + ) = N \ . Thus, using (b) (d) (a) obtain
.(M + \ N + ) = N + (N \M ), observing (N \M ) = N
holds (c), conclude (e) .(M + \ N + ) = N + N = N .
Consider rule r P H(r) + \ N + . deal two cases:
1. r P \ P . case, Definition 4, must literal B(r)
false respect . antimonotone literal, (1) holds. Otherwise,
monotone literal false respect N well, since N ; thus,
(2) holds (e).
2. r P . case, since N model P H(r) false respect N
(because H(r) + \ N + assumption), must literal B(r)
false respect N . antimonotone literal, false respect
well, since N , (1) holds. Otherwise, monotone literal
(2) holds (e).

ready state important connection answer sets unfounded
sets.
Theorem 13 total interpretation LPA
m,a program P answer set P
GU SP (M ) = .M .
505

fiAlviano, Calimeri, Faber, Leone, & Perri

Proof. () Let answer set P. Lemma 11, .M unfounded set P
respect , hence GU SP (M ) .M . Theorem 12, unfounded-free,
hence GU SP (M ) .M total. sum, GU SP (M ) = .M .
() Let total interpretation GU SP (M ) = .M . GU SP (M ) =
.M disjoint, unfounded-free. Moreover, Corollary 3, GU SP (M ) =
unfounded set P respect so, applying Lemma 11, conclude
model P. order apply Theorem 12 (M unfounded-free
model P) conclude answer set P.

following theorem shows answer sets LPA
m,a programs exactly total
fixpoints well-founded operator defined Section 3.
Theorem 14 Let total interpretation LPA
m,a program P.
answer set P fixpoint well-founded operator WP .
Proof. () Let answer set P. want show fixpoint WP ,
is, WP (M ) = . aim show TP (M ) = + .GU SP (M ) = .
Since answer set, applying Theorem 13, obtain GU SP (M ) = .M ,
equivalent .GU SP (M ) = . Therefore, remains prove TP (M ) = + :
() Consider atom TP (M ). Definition 2, rule r P
H(r) = literals B(r) true respect . Thus, + holds
model P.
() Consider atom + . Since answer set P, apply Theorem 12
conclude unfounded-free. Hence, (singleton) set {} +
unfounded set P respect . Thus, Definition 1, rule
r P H(r) = neither (1) (antimonotone) literal B (r)
false respect , (2) (monotone) literal B (r) false respect
.{}. Since total interpretation, neither (1) (2) equivalent
(i) (antimonotone) literals B (r) true respect , (ii)
(monotone) literals B (r) true respect .{}. observing
.{} , state (ii) implies (monotone) literals
B (r) true respect well. combining latter statement (i)
obtain literals B(r) true respect , TP (M )
Definition 2.
() Let total fixpoint WP , i.e., WP (M ) = . Thus, = .GU SP (M )
Definition 2, answer set P Theorem 13.

Observe Theorem 14 generalization Theorem 5.4 Van Gelder et al. (1991)
class LPA
m,a programs. worth noting WP (I) extends preserving
correctness: contained answer set , WP (I) may add literals
, never introduces literal would inconsistent .
Proposition 15 Let interpretation LPA
m,a program P, let
answer set P. , WP (I) .
506

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

Proof. trivial consequence monotonicity operator WP (Theorems 7)
Theorem 14. Indeed, Theorems 7, WP implies WP (I) WP (M ),
WP (M ) = Theorem 14.

next show well-founded model LPA
m,a program contained
answer sets (if any) P. would point due Theorem 24 Section 7
(showing equivalence well-founded operators defined work one
defined Pelov et al., 2007) Propositions 3.77 3.8 Ferraris (2011; showing
equivalence answer sets Faber et al., 2011 stable models Pelov et al., 2007),
following results hold virtue definitions well-founded stable
semantics work Pelov et al., particular due Proposition 7.3 paper.
nevertheless provide proof using concepts defined earlier.

Theorem 16 Let P LPA
m,a program. answer set P, WP () .

Proof. Let answer set P. Note WP () limit sequence W0 = ,
Wn = WP (Wn1 ). show Wn induction n. base case trivially
true since W0 = definition. assume Wn order show Wn+1 .
Since Wn+1 = WP (Wn ) definition Wn induction hypothesis, apply
Proposition 15 conclude Wn+1 .

theorem suggests another property well-founded semantics LPA
m,a programs.
Property 3 well-founded semantics LPA
m,a programs approximates answer set
semantics: well-founded model contained intersection answer sets (if
any).
combining Theorem 14 Theorem 16, obtain following claim.

Corollary 17 Let P LPA
m,a program. WP () total interpretation,
unique answer set P.

Therefore, combining Theorem 9 corollary above, obtain another property
well-founded semantics LPA
m,a programs.
Property 4 stratified LPA
m,a programs, well-founded model coincides
unique answer set.

5. Complexity Well-Founded Semantics
complexity analysis carried section, consider ground programs
polynomial-time computable aggregate functions (note example aggregate functions
appearing paper fall class). However, eventually provide discussion
results change considering non-ground programs. start important
property monotone antimonotone aggregate literals.
507

fiAlviano, Calimeri, Faber, Leone, & Perri

Lemma 18 Let partial interpretation ground LPA
m,a program P. define
two total interpretations P follows: Imin = .(BP \ I) Imax = (BP \ .I).
(ground) aggregate literal occurring P, following statements hold:
1. monotone literal, true (resp. false) respect
true respect Imin (resp. false respect Imax ).
2. antimonotone literal, true (resp. false) respect
true respect Imax (resp. false respect Imin ).
Proof. start noting Imin (resp. Imax ) total interpretation extending
standard atoms undefined respect false
respect Imin (resp. true respect Imax ). Thus, () Imin Imax .
monotone true respect Imin (resp. false respect Imax ), true
(resp. false) respect (). antimonotone true respect
Imax (resp. false respect Imin ), true (resp. false) respect
(). end proof observing true (resp. false) respect
I, true respect Imin Imax definition.

ready analyze computational complexity well-founded semantics
LPA
m,a programs. analysis lead prove following fundamental property.
Property 5 well-founded model ground LPA
m,a program efficiently (polynomialtime) computable.
Given Corollary 25, property follows Theorem 7.4 work Pelov
et al. (2007). following, provide alternative proof based concepts
defined earlier paper, leads several interesting intermediate results.
Property 5 trivial aggregates may easily increase complexity
evaluation. Indeed, even deciding truth aggregate respect partial interpretation intractable general; similar observation already made Pelov
(2004). However, task polynomial-time computable aggregate literals occurring LPA
m,a programs.
Proposition 19 Deciding whether ground aggregate literal true (resp. false)
respect partial interpretation is:
(a) co-NP-complete general;
(b) polynomial-time computable either monotone antimonotone literal.
Proof. (a) membership, consider complementary problem, is,
deciding whether ground aggregate literal true (resp. false) respect
partial interpretation I, prove belongs NP. order show
true (resp. false) respect enough find total interpretation J
extending (that is, J I) false (resp. true) respect J. Thus,
guess J check falsity (resp. truth) respect J polynomial
508

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

time (if aggregate function computed polynomial time respect size
input multiset, assuming).
hardness, first consider problem checking truth aggregate provide polynomial-time reduction TAUTOLOGY. TAUTOLOGY
problem co-NP-complete stated follow: Given proposition formula
variables X1 , . . . , Xn , truth assignment v variables X1 , . . . , Xn satisfy
formula ? Without loss generality, assume 3-DNF formula form
= D1 Dm ,

disjunct Di conjunction 1i 2i 3i , ji positive negative
literal (note that, context TAUTOLOGY, term literal denotes variable
Xk variable preceded negation symbol ). given , consider
partial interpretation = {} construct aggregate literal = #sum{S} 1,
contains two groups elements. elements first group represent disjuncts

h1 : (1i ), (2i ), (3i )i,
= 1, . . . , ,
where, = 1, . . . , j = 1, . . . , 3, propositional atom (ji ) defined
follows:

j
xk positive literal Xk , k {1, . . . , n}.
j
(i ) =
f
xk ji negative literal Xk , k {1, . . . , n}.
elements second group represent variables follows:

h 1,


h1,
h1,



h 1,

xk :
xk : xtk
,
xk : xfk
xk : xtk , xfk

k = 1, . . . , n ,

xk xk constants associated variable Xk . Note that, variable
Xk , two atoms A, xtk xfk . Thus, interpretation J, four cases
possible:
(1) {not xtk , xfk } J: case, h1, xk : contribute evaluation
A, contribution 1;
(2) {xtk , xfk } J: case, four elements contribute evaluation A,
thus contribution 1 1 + 1 = 1 (note h1, xk : xtk h1, xk : xfk
give total contribution 1 pure set approach);
(3) {xtk , xfk } J: case, h1, xk : h1, xk : xtk contribute, giving
1 1 = 0;
(4) {not xtk , xfk } J: case, h1, xk : h1, xk : xfk contribute, giving
1 1 = 0.
509

fiAlviano, Calimeri, Faber, Leone, & Perri

Thus, k {1, . . . , n}, total contribution four elements associated
variable Xk either 0 1. Note total contribution elements
(i.e., first group) either 0 1. Therefore, k {1, . . . , n}
either case (1) (2) occurs, interpretation J trivially satisfies A. Otherwise, J
that, variable k {1, . . . , n}, either (3) (4) occurs. case, say
J good interpretation.
next define one-to-one mapping set assignments set
good interpretations. Let v assignment . good interpretation Iv associated
v Iv

f
{xtk , xk } Iv v(Xk ) = 1
,
k = 1, . . . , n .

f

{not xk , xk } Iv v(Xk ) = 0
want show v satisfies true respect Iv . Since Iv
good interpretation, elements second group give total contribution 0,
consider elements first group. elements give
contribution 1 {(1i ), (2i ), (3i )} holds least one {1, . . . , n},
holds v(Di ) = 1 holds disjunct Di . conclude
true respect Iv v() = 1.
Concerning check falsity aggregate, start 3-DNF formula
construct aggregate literal = #sum{S} < 1, obtained described
above. tautology false respect = {}.
(b) Let partial interpretation LPA
m,a program P aggregate literal
occurring P. want show deciding whether true (resp. false) respect
done polynomial-time size BP . Lemma 18, enough evaluate
aggregate respect either Imin = .(BP \ I) Imax = (BP \ .I).
end proof observing interpretations Imin Imax constructed
polynomial time, value aggregate function computed
polynomial time respect size input multiset assumption.

order prove tractability well-founded semantics need efficient
method computing greatest unfounded set, part well-founded operator
WP . Hence, next give polynomial-time construction set BP \GU SP (I) means
monotone operator.
Definition 7 Let interpretation LPA
m,a program P. operator :
B
B
P
P
defined follows:
2 2
(Y ) = { BP | r P H(r) =
(antimonotone) literal B (r) false respect I,
(monotone) literals B (r) true respect \ .I }
least fixpoint coincides greatest unfounded set P respect
I.
Theorem 20 Let P LPA
m,a program interpretation P. Then:
510

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

1. operator least fixpoint ();
2. GU SP (I) = BP \ ().
Proof. operator monotonically increasing operator meet semilattice
hBP , i, therefore admits least fixpoint () (Tarski, 1955). next prove
GU SP (I) = BP \ () two steps:
() first observe () computed iteratively, starting empty set,
limit sequence F0 = , Fi+1 = (Fi ). Thus, prove induction
GU SP (I) BP \Fi holds. base case trivial, since F0 = definition
GU SP (I) subset BP Definition 1. assume GU SP (I) BP \
order prove GU SP (I) BP \ Fi+1 . Since GU SP (I) unfounded set P
respect Theorem 2, Definition 1 that, GU SP (I)
rule r P H(r) = , either (1) (antimonotone) literal
B (r) false respect I, (2) (monotone) literal B (r) false
respect .GU SP (I). want show belong Fi+1 ,
is, rule r either (i) (antimonotone) literal
B (r) false respect I, (ii) (monotone) literal B (r) true
respect \ .I (recall Fi+1 = (Fi ) definition). Since (1) (i)
equals, show (2) implies (ii). end, assume
(monotone) literal B (r) false respect .GU SP (I).
aim show false respect J = (Fi \ .I ) .(BP \ (Fi \ .I )),
since case would true respect \ .I (see Lemma 18).
start proving (I .GU SP (I)) = .GU SP (I) subset J .
Observe J = .(BP \ (Fi \ .I )) = .(BP \ ) .I
subset BP . Thus, since GU SP (I) BP \ induction hypothesis, obtain
(I .GU SP (I)) = .GU SP (I) .(BP \ ) = J . Since J total,
(I .GU SP (I)) J implies extension K .GU SP (I)
K J K + J (for example, one containing true
standard positive literals undefined respect .GU SP (I)). Since
false respect .GU SP (I) assumption K extension
.GU SP (I), false respect K Remark 1. Thus, since J K
monotone, latter implies false respect J well.
() prove BP \ () unfounded set P respect I, is,
r P H(r) BP \ (), either (1) (antimonotone) literal B (r)
false respect I, (2) (monotone) literal B (r) false respect
.(BP \ ()). Definition 7, H(r) 6 () implies either (i)
(antimonotone) literal B (r) false respect I, (ii) (monotone)
literal B (r) true respect () \ .I . Since (i) (1) equals,
show (ii) implies (2). end, assume (monotone)
literal B (r) true respect () \ .I . Thus,
extension () \ .I false, particular must false
respect J = (I () \ .I ) .(BP \ (I () \ .I )) Lemma 18.
observe (I .(BP \ ())) = .(BP \I ()) = .(BP \(I ()\.I )) =
511

fiAlviano, Calimeri, Faber, Leone, & Perri

J holds (because .I BP ), (I .(BP \ ()))+ J + J total.
combining last two sentences obtain .(BP \ ()) J. Therefore,
since monotone literal false respect J, latter implies
false respect .(BP \ ()) well, (2) holds.

Eventually, Property 5 consequence following theorem. mentioned earlier,
theorem follows Theorem 7.4 work Pelov et al. (2007)
Corollary 25, proof provided differs considerably one Theorem 7.4
work Pelov et al.
Theorem 21 Given LPA
m,a program P:
1. greatest unfounded set GU SP (I) P respect given interpretation
polynomial-time computable;
2. WP () polynomial-time computable.
Proof. (1.) Theorem 20, GU SP (I) = BP \ (). next show ()
efficiently computable. fixpoint () limit sequence 0 = , k =
(k1 ). limit reached polynomial number applications
new element sequence k must add least new atom (otherwise limit
already reached), is, |BP |. show application feasible
polynomial time, conclude computable polynomial time. step
processes rules once, rule checks truth-value
body literals once. check truth valuation clearly tractable standard
(i.e., non-aggregates) literals; tractability check aggregate literals stems
Proposition 19, deal monotone antimonotone aggregate atoms only.
conclusion, computable polynomial time, GU SP (I) tractable well since
obtainable BP \ ().
(2.) argumentation carried (), show WP () computed
number steps polynomial (actually linear) |BP |. Indeed, step
polynomial-time computable: proved tractability GU SP (I), TP
polynomial-time computable well.

result positive impact computation answer set semantics
logic programs aggregates. Indeed, stated Theorem 16, WP () approximates
intersection answer sets (if any) bottom, therefore used
efficiently prune search space. worthwhile noting computation
well-founded semantics hard polynomial-time. particular, deciding whether
(ground) atom true respect well-founded semantics P-complete,
task P-hard even standard well-founded semantics aggregate-free programs (and,
Proposition 5, semantics coincides standard well-founded aggregatefree programs).
end section briefly addressing complexity non-ground programs.
considering data-complexity (i.e., LPA
m,a program P fixed input consists
facts), results propositional programs: Deciding whether (ground) atom
true respect well-founded semantics non-ground program P-complete,
512

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

data-complexity (Van Gelder et al., 1991). However, program complexity (i.e.,
LPA
m,a program P given input) considered, complexity reasoning rises exponentially. Indeed, non-ground program P reduced, naive instantiation, ground
instance problem, general size Ground(P) single exponential
size P. complexity reasoning increases accordingly one exponential, P
EXPTIME, result derived using complexity upgrading techniques (Eiter,
Gottlob, & Mannila, 1997; Gottlob, Leone, & Veith, 1999).

6. Compilation Standard LP, Implementation Experimental
Results
well-founded semantics LPA
m,a programs implemented extending
DLV system (Leone et al., 2006). section briefly describe implemented
prototype report results experiments aimed assessing efficiency.
Note that, even LPA
m,a programs replaced equivalent LP programs (for
rewriting strategy see Section 6.1 below), experimental results highlight significant
performance advantage LPA
m,a encodings.
6.1 Compilation Standard Logic Programming
section briefly present strategy representing #count, #sum #times
standard constructs.2 compilation spirit one introduced #min
#max Alviano, Faber, Leone (2008) defines subprogram computing
value (possibly recursive) aggregate. compilation takes account specific properties monotone antimonotone aggregate functions, therefore referred
monotone/antimonotone encoding (mae).
monotone/antimonotone encoding LPA
m,a program P obtained replacing
aggregate literal = f (S) new predicate symbol f . Predicate f defined
means subprogram (i.e., set rules) thought compilation
standard LP. compilation uses total order < elements {},
symbol occurring P < u u . assume
presence built-in relation < , = Y1 , . . . , Yn = Y1 , . . . , Yn
lists terms. built-in relation < precedes
lexicographical order induced <. Moreover, use built-in relation ,
true either < = . simplicity, let us assume
form f ({Y : p(Y , Z)}) k, Z lists local variables k
integer constant. aggregate, introduce new predicate symbol faux arity
|Y | + 1 rules modeling atom faux (y, s) must true whenever value
f ({Y : p(Y , Z), y}) least s. Thus, use fact representing value
aggregate function empty set, rule increasing value larger sets.
lexicographical order induced < used guarantee elements set
2. Since considering monotone antimonotone aggregate literals, domains #sum
#times assumed N N+ , respectively.

513

fiAlviano, Calimeri, Faber, Leone, & Perri

User Interface

Diagnosis
Frontend

Inheritance
Frontend

SQL3
Frontend

Planning
Frontend

DLV core
Ground
Program

Intelligent
Grounding

Model
Checker

Model
Generator

File
System

Relational
Database

Filtering

Output

Figure 2: Prototype system architecture.
considered once. particular, following rules introduced:

faux (, ).
= 0, = + 1 f = #count;
= 0, = + Y1 f = #sum;

faux (Y , X) : faux (Y , S), p(Y , Z),

= 1, = Y1 f = #times.
< , X = .
{, >}, truth aggregate f ({Y : p(Y , Z)}) k must inferred
atom faux (y, s) k true. aspect modeled means
following rules:
fk : faux (Y , S), k.

f>k : faux (Y , S), > k.

, instead, truth aggregate f ({Y : p(Y , Z)}) k must inferred
atoms faux (y, s) > k false (and similar <). aspects
modeled means following rules:
fk : f>k .

f<k : fk .

Extending technique aggregate literals global variables quite simple:
Global variables added arguments atoms used compilation,
new predicate fgroupby used collecting possible substitutions.
6.2 System Architecture Usage
extended DLV implementing well-founded operator well-founded
semantics LPA
m,a programs described paper. architecture prototype
514

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

reported Figure 2. detail, modified two modules DLV, Intelligent Grounding
module Model Generator module. prototype, well-founded semantics
adopted one -wf --well-founded specified command-line. Otherwise,
stable model semantics adopted usual. well-founded operator WP introduced
Section 3 used semantics. particular, stable model semantics,
well-founded model profitably used pruning search space. well-founded
semantics, well-founded model printed computation least fixpoint
well-founded operator. case output system consists two sets,
representing true undefined standard atoms well-founded model. binary
prototype available http://www.dlvsystem.com/dlvRecAggr/.
6.3 Experimental Results
knowledge, implemented prototype currently system supporting
well-founded semantics logic programs recursive aggregates. certain special
cases, well-founded model total, well-founded model coincides
semantics answer sets (see Corollary 17) theses cases systems supporting
semantics IDP (Wittocx, Marien, & Denecker, 2008), Smodels (Simons et al.,
2002), clasp (Gebser, Kaufmann, Neumann, & Schaub, 2007), used compute
well-founded model.
however interested systems able compute well-founded model
input programs. One major systems supporting well-founded semantics,
XSB (Swift & Warren, 2010), support aggregates, (apart #min
#max) XSB support recursive aggregates (i.e., aggregates occurring recursive
definitions). Therefore, experiments designed investigating computational behavior aggregate constructs respect equivalent encodings without
aggregates.
specifically, introduce Attacks problem, inspired classic
Win-Lose problem often used context well-founded semantics standard
logic programs, study performance it.
Definition 8 (Attacks Problem) Attacks problem, set p players positive integer given. player attacks n players. player wins
winners attack it. kind problem frequently present turn-based strategy
games.
Note definition winner recursive and, particular, recursive aggregate
natural way encoding problem.
Example 14 instance Attacks problem p = 6, n = 2 = 1 could
following:
player attacks players b c;

player attacks players b f ;

player b attacks players c;

player e attacks players c f ;

player c attacks players b;

player f attacks players e.

515

fiAlviano, Calimeri, Faber, Leone, & Perri

b





f

e

c

Figure 3: instance Attacks problem 6 players, one attacking 2
players.

graphical representation instance shown Figure 3. Since attacked
f , conclude winner. Similarly e. Therefore, f winner
f attacked e, winners. players, namely a, b c,
cannot determine winner not.
experiments, instances Attacks encoded means predicates max,
player attacks representing parameter m, set players attacks
players, respectively. consider three equivalent encodings Attacks problem.
6.3.1 Aggregate-Based Encoding
encoding natural representation Attacks problem LP
m,a . complete
encoding consists single rule, reported below:
win(X) : max(M ), player(X), #count{Y : attacks(Y, X), win(Y )} M.

6.3.2 Join-Based Encoding
equivalent encoding obtained computing number joins proportional
m. tested encoding reported below:
win(X) : player(X), lose(X).
lose(X) : max(1), attacks(Y1 , X), win(Y1 ),
attacks(Y2 , X), win(Y2 ), Y1 < Y2 .
lose(X) : max(2), attacks(Y1 , X), win(Y1 ),
attacks(Y2 , X), win(Y2 ), Y1 < Y2 ,
attacks(Y3 , X), win(Y3 ), Y1 < Y3 , Y2 < Y3 .
lose(X) : max(3), . . .

Note encoding rule possible value parameter m.
However, one rules considered solver program instantiation.
fact, rule instantiated, contains instance atom max(m)
fact present. rules satisfied false body literal.
516

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

30

300

DLV-join

DLV

25

250

20

200

15

150

10

100

5
01

2

3

4

5

6

x

7

8

9 1

2

3

4

5

6

7

8

9

10

50
01



2

3

4

6

x

(a) 100 players

7

8

9 1

2

3

4

5

6

8

9

10



(b) 200 players

600

600

500

500

400

400

300

300

200

200

100
01

5

7

2

3

4

5

x

6

7

8

9 1

2

3

4

5

6

7

8

9

10

100
01



2

3

4
x

(c) 400 players

5

6

7

8

9 1

2

3

4

5

6

7

8

9

10



(d) 800 players

Figure 4: Attacks: Average execution time DLV running aggregate-based encoding
DLV running join-based encoding.

6.3.3 Mae-Based Encoding
encoding obtained applying compilation presented Section 6.1
minor simplifications. full encoding reported below:
win(X) : player(X), lose(X).
lose(X) : count(X, Y, S), max(M ), > M.
count(X, Y, 1) : aux(X, ).
count(X, , ) : count(X, Y, S), aux(X, ), < , = + 1.
aux(X, ) : attacks(Y, X), win(Y ).

Intuitively, atom count(x, y, s) stands least constants
attacks(y , x), win(y ) true. Note rules defining predicate count use
natural order integers guarantee counted once.
Example 15 instance shown Figure 3 represented means following facts:
player(a).
attacks(a, b).
attacks(a, c).
max(1).

player(b).
attacks(b, a).
attacks(b, c).

player(c).
attacks(c, a).
attacks(c, b).

player(d).
attacks(d, b).
attacks(d, f ).

517

player(e).
attacks(e, c).
attacks(e, f ).

player(f ).
attacks(f, d).
attacks(f, e).

fiAlviano, Calimeri, Faber, Leone, & Perri

8

10

XSB-join

DLV

7
6

9
8
7

5

6

4

5

3

4
3

2
1
01

2

3

4

5

6

x

7

8

9 1

2

3

4

5

6

7

8

9

10

2
1
01



2

3

4

6

x

(e) 100 players

7

8

9 1

2

3

4

5

6

8

9

10



(f) 200 players

9

12

8

10

7
6

8

5

6

4
3

4

2
1
01

5

7

2

3

4

5

6

x

7

8

9 1

2

3

4

5

6

7

8

9

10

2
01



2

3

4
x

(g) 400 players

5

6

7

8

9 1

2

3

4

5

6

7

8

9

10



(h) 800 players

Figure 5: Attacks: Average execution time DLV running aggregate-based encoding
XSB running join-based encoding.

encodings, well-founded model restricted win predicate {win(d),
win(e), win(f )}. Note win(a), win(b) win(c) neither true false,
undefined.
6.3.4 Discussion
performed intensive experimentation benchmark varying parameters
p, n. combination parameters, measured average execution
time DLV XSB (version 3.2) 3 randomly generated instances. experiments
R
R
performed 3GHz Intel
Xeon
processor system 4GB RAM
Debian 4.0 operating system GNU/Linux 2.6.23 kernel. DLV prototype used
compiled GCC 4.4.1. every instance, allowed maximum running
time 600 seconds (10 minutes) maximum memory usage 3GB.
results experimentation reported Figures 47. graphs, DLV
implemented prototype aggregate-based encoding, DLV-join DLV-mae
implemented prototype aggregate-free encodings, XSB-join XSB-mae
XSB system aggregate-free encodings (as mentioned earlier, XSB support
518

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

DLV-mae

DLV
6

12

5

10

4

8

3

6

2

4

1
01

2

3

4

5

6

x

7

8

9 1

2

3

4

5

6

7

8

9

10

2
01



2

3

4

5

6

x

(i) 1600 players

7

8

9 1

2

3

4

5

6

7

8

9

10



(j) 3200 players

25

60
50

20

40
15
30
10
20
5
01

2

3

4
x

5

6

7

8

9 1

2

3

4

5

6

7

8

9

10

10
01



2

3

4
x

(k) 6400 players

5

6

7

8

9 1

2

3

4

5

6

7

8

9

10



(l) 12800 players

Figure 6: Attacks: Average execution time DLV running aggregate-based encoding
DLV running mae-based encoding.

recursive aggregates). XSB system, explicitly set indices tabled predicates
optimizing computation.
graph, number players fixed, parameters (x-axis) n
(y-axis) vary. Therefore, size instances grows moving left right along
y-axis, invariant respect x-axis. However, number joins
required join-based encoding depends parameter m. matter fact,
observe graphs Figures 45 average execution time join-based
encoding increases along x- y-axis (for DLV XSB). Instead,
encoding using aggregates, mae-based encoding, average execution time
depends instance sizes, shown graphs Figures 67.
join-based encoding, XSB generally faster DLV, consumes much
memory. Indeed, Figure 5, observe XSB terminates computation
seconds smallest instances, rapidly runs memory slightly larger
instances. Considering mae-based encoding, observe significant performance
gains DLV XSB (see Figures 67). Indeed, systems complete computation allowed time memory larger instances. Computational advantages
mae-based encoding respect join-based encoding particularly evident
519

fiAlviano, Calimeri, Faber, Leone, & Perri

XSB-mae

DLV
3.5

9
8

3

7
2.5

6

2

5

1.5

4
3

1
0.5
01

2

3

4

5

6

x

7

8

9 1

2

3

4

5

6

7

8

9

2

10

1
01



2

3

4

5

6

x

(m) 6400 players

7

8

9 1

2

3

4

5

6

7

8

9

10



(n) 12800 players

60

400
350

50

300
40

250

30

200
150

20
10
01

2

3

4
x

5

6

7

8

9 1

2

3

4

5

6

7

8

9

100

10

50
01



2

3

4
x

(o) 25600 players

5

6

7

8

9 1

2

3

4

5

6

7

8

9

10



(p) 51200 players

Figure 7: Attacks: Average execution time DLV running aggregate-based encoding
XSB running mae-based encoding.

XSB, solved tested instances encoding. However, XSB
mae-based encoding outperformed DLV native support aggregate constructs
(see Figure 7).
sum, experimental results highlight presence aggregate constructs
significantly speed-up computation. Indeed, encoding using recursive aggregates
outperforms aggregate-free encodings tested instances.

7. Related Work
Defining well-founded semantics logic programs aggregates challenge
major interest last years. first attempts, relying notion unfounded
set, defined restricted language. discussed Kemp
Stuckey (1991). Another semantics falling class one introduced Van Gelder
(1992), subsequently generalized Osorio Jayaraman (1999). main problem
semantics often leave many undefined literals, shown Ross
Sagiv (1997).
520

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

first attempt define well-founded semantics unrestricted LPA done
Kemp Stuckey (1991). semantics based notion unfounded sets. According
Kemp Stuckey, set X standard atoms unfounded set (ground) program
P respect interpretation if, rule r P H(r) X , either (a)
literal B(r) false respect I, (b) B(r) X =
6 . Note standard
literals considered condition (b), aggregates covered it. point
definition unfounded set makes semantics inadequate programs
recursive aggregates, even monotone aggregates considered. example,
program {a(1):#count{X : a(X)} > 0.}, well-founded model work Kemp
Stuckey , reasonable well-founded semantics identify a(1) false.
Pelov et al. (2007) defined well-founded semantics based approximating operators,
namely D-well-founded semantics, extends standard well-founded semantics; indeed, coincide aggregate-free programs. detail, work aggregates
evaluated one three possible ways. Therefore, family semantics defined
Pelov et al., ordered precision: precise three-valued aggregates lead
precise semantics. general, higher precision comes price higher computational complexity. authors discuss following three-valued aggregate relations
evaluation aggregate literals: trivial, bound ultimate approximating aggregates, first less precise, last precise. Semantics relying
trivial approximating aggregates imprecise, still suitable class
stratified aggregate programs. trivial bound approximations polynomial
complexity, ultimate shown intractable nonmonotone aggregate
functions (Pelov, 2004). detailed comparison results presented Section 7.1.
Ferraris (2005) showed semantics Smodels programs positive weight
constraints equal answer sets defined Faber et al. (2004) respective
fragment. Since Theorem 16 WP () approximates answer sets defined Faber et al.,
WP () used approximating operator respective Smodels programs.
Indeed, shown AtMost pruning operator Smodels (Simons et al., 2002)
special case operator (defined proof Theorem 21).
works attempted define stronger notions well-founded semantics (also
programs aggregates), Ultimate Well-Founded Semantics (Denecker et al.,
2001), WFS1 WFS2 (Dix & Osorio, 1997). Whether characterization
semantics terms unfounded sets exist semantics unclear left
future research.
Concerning compilations LP programs standard LP, transformation provided Van Gelder (1992). compilation presented Section 6.1 differs
one introduced Van Gelder several respects. approach uses total order
universe input program takes advantage character monotonicity/antimonotonicity aggregate literals input program, transformation
defined Van Gelder uses uninterpreted function symbols representing ground sets,
recursive negation checking truth aggregate literals. briefly discuss aspects following. Roughly, aggregate f (S) k, uninterpreted function symbols
used transformation work Van Gelder determining pairs , k
ground set associated k = f (S ). that, transformation defined Van Gelder checks whether exists pair , k satisfying following
521

fiAlviano, Calimeri, Faber, Leone, & Perri

conditions: (i) every element hconsts : conji , conj true; (ii) k k holds.
point Condition (i) requires recursive negation order checked. Indeed,
equivalent element hconsts : conji conj true.
aspect transformation undesirable side effect: Stratified LPA
m,a programs
may partial well-founded models, is, Theorem 9 hold programs compiled transformation introduced Van Gelder. example side effect
given Van Gelder, shown transformation possibly leads partial
well-founded models instances Company Controls, well-known problem
modeled using monotone recursive aggregates.
7.1 Comparison work Pelov et al. (2007)
section report detailed comparison well-founded semantics defined
paper one Pelov et al. (2007). recall Pelov et al. defines wellfounded stable semantics least total fixpoints three-valued stable
model operator extended aggregate programs.
start observing evaluation ultimate approximating aggregates coincides
evaluation aggregates defined article; evaluation bound approximating aggregates coincides monotone antimonotone aggregates (as consequence
Lemma 18 paper Proposition 7.16 work Pelov et al., 2007).
Let us introduce translation aggregate literal formula standard
literals. (partial) interpretation I, let conj(I) denote conjunction literals
I. translation trm(A) ground aggregate literal defined follows:
W
trm(A) = {conj(I) | subset-minimal interpretation
true respect I}
Note that, (partial) interpretation J, evaluation respect J coincides
evaluation trm(A) respect J (Proposition 2 Proposition 3
work Pelov et al., 2003). Moreover, monotone (resp. antimonotone) aggregate literal
A, positive (resp. negative) literals appear trm(A).
rule r ground LPA
m,a program P aggregate literal B(r),
translation trm(P, r, A) r program obtained P removing r
adding rule r H(r ) = H(r) B(r ) = B(r) \ {A} conj,
conj trm(A). Therefore, full translation trm(P) P defined recursive
application trm(P, r, A) (note order rules aggregates processed
relevant). next show P trm(P) unfounded sets.
Lemma 22 set atoms X unfounded set program P respect
interpretation X unfounded set trm(P) respect I.
Proof. use induction number aggregate literals P. P aggregate
literals, P = trm(P). consider program P rule r P aggregate
literal B(r). want show set X atoms unfounded set P
respect X unfounded set trm(P, r, A) respect I, since
case might apply induction hypothesis prove claim. Thus,
end proof means following observations: (i) false respect
522

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

interpretation J trm(A) false respect J, is,
conjunction conj trm(A) literal conj false respect
J; (ii) positive (resp. negative) standard literal monotone
(resp. antimonotone).

prove well-founded operators P trm(P) coincide.
Lemma 23 Let P LPA
m,a program interpretation P. WP (I) =
Wtrm(P) (I).
Proof. show (1) TP (I) = Ttrm(P) (I) (2) GU SP (I) = GU Strm(P) (I).
note (2) immediately follows Lemma 22. order prove (1), consider
aggregate literal occurring P. previous considerations, true
respect conjunct trm(A) true respect
I. Thus, (1) holds.

ready relate well-founded operator one provided Pelov
et al. (2007).
Theorem 24 class LPA
m,a programs, well-founded operator herein defined
coincides one Pelov et al. (2007; ultimate bound approximating
aggregate semantics).3
Proof. Lemma 23, already know WP (I) = Wtrm(P) (I).
Wtrm(P) (I) coincides one work Van Gelder et al. (1991) Theorem 1
(since trm(P) standard logic program). hand, ultimate
bound approximating aggregate semantics, well-founded operators (as defined Pelov
et al., 2007) P trm(P) coincide: consequence Theorem 1 work
Pelov et al. (2003), three-valued immediate consequence operators work
Pelov et al. (2003) Pelov et al. (2007) coincide (see Definition 7 Pelov et al., 2003
Definition 7.5 Pelov et al., 2007). Moreover, well-founded operator Pelov et al.
(2007) coincides one work Van Gelder et al. standard logic programs,
thereby obtaining equality operators.

correspondence two well-founded semantics immediately follows
theorem above. Indeed, two well-founded models defined fixpoints
respective well-founded operators.
Corollary 25 well-founded model herein defined one Pelov et al. (2007;
ultimate bound approximating aggregate semantics) coincide LPA
m,a
programs.
mentioned earlier, virtue theorem corollary,
results presented paper follow earlier results literature. particular,
Theorem 9, Theorem 16 complexity results follow definitions
results Pelov (2004) Pelov et al. (2007).
3. Note operator referred stable revision operator Pelov et al. (2007).

523

fiAlviano, Calimeri, Faber, Leone, & Perri

8. Conclusion
paper introduced new notion unfounded set LPA
m,a programs analyzed
well-founded semantics language based notion. semantics generalizes
traditional well-founded semantics aggregate-free programs coincides
well-founded semantics aggregate programs defined Pelov et al. (2007; latter
defined means notion unfounded set). could show
semantics main operator WP close ties answer sets defined Faber
et al. (2004, 2011), hence serve approximations.
proved computing semantics tractable problem. Indeed, semantics
given least fixpoint well-founded operator WP . fixpoint reached
polynomial number applications operator WP (with respect size input
program), requiring polynomial time. showing application WP
polynomial-time feasible, proved evaluating monotone antimonotone
aggregate literals remains polynomial-time computable partial interpretations, since
case one possibly exponential extensions must checked. monotone
aggregate literal, extension obtained falsifying undefined literal,
antimonotone aggregate literal, undefined literal taken true extension.
Motivated positive theoretical results, implemented first system
supporting well-founded semantics unrestricted LPA
m,a . Allowing using monotone
antimonotone aggregate literals, implemented prototype ready experimenting
LPA
m,a framework. experiments conducted Attacks benchmark highlight
computational gains native implementation aggregate constructs respect
equivalent encodings standard LP.

Acknowledgments
Partly supported Regione Calabria EU POR Calabria FESR 2007-2013 within
PIA project DLVSYSTEM s.r.l., MIUR PRIN project LoDeN
PON project FRAME proposed Atos Italia S.p.a.; thank
anonymous reviewers valuable comments.

References
Alviano, M., Faber, W., & Leone, N. (2008). Compiling minimum maximum aggregates
standard ASP. Formisano, A. (Ed.), Proceedings 23rd Italian Conference
Computational Logic (CILC 2008).
Baral, C. (2003). Knowledge Representation, Reasoning Declarative Problem Solving.
Cambridge University Press.
Brewka, G. (1996). Well-Founded Semantics Extended Logic Programs Dynamic
Preferences. Journal Artificial Intelligence Research, 4, 1936.
Calimeri, F., Faber, W., Leone, N., & Perri, S. (2005). Declarative Computational
Properties Logic Programs Aggregates. Nineteenth International Joint
Conference Artificial Intelligence (IJCAI-05), pp. 406411.
524

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

DellArmi, T., Faber, W., Ielpa, G., Leone, N., & Pfeifer, G. (2003). Aggregate Functions
DLV. de Vos, M., & Provetti, A. (Eds.), Proceedings ASP03 - Answer Set
Programming: Advances Theory Implementation, pp. 274288, Messina, Italy.
Online http://CEUR-WS.org/Vol-78/.
Denecker, M., Pelov, N., & Bruynooghe, M. (2001). Ultimate Well-Founded Stable
Model Semantics Logic Programs Aggregates. Codognet, P. (Ed.), Proceedings 17th International Conference Logic Programming, pp. 212226.
Springer Verlag.
Dix, J., & Osorio, M. (1997). Well-Behaved Semantics Suitable Aggregation.
Proceedings International Logic Programming Symposium (ILPS 97), Port Jefferson, N.Y.
Eiter, T., Gottlob, G., & Mannila, H. (1997). Disjunctive Datalog. ACM Transactions
Database Systems, 22 (3), 364418.
Faber, W. (2005). Unfounded Sets Disjunctive Logic Programs Arbitrary Aggregates. Baral, C., Greco, G., Leone, N., & Terracina, G. (Eds.), Logic Programming Nonmonotonic Reasoning 8th International Conference, LPNMR05,
Diamante, Italy, September 2005, Proceedings, Vol. 3662 Lecture Notes Computer Science, pp. 4052. Springer Verlag.
Faber, W., Leone, N., & Pfeifer, G. (2004). Recursive aggregates disjunctive logic programs: Semantics complexity. Alferes, J. J., & Leite, J. (Eds.), Proceedings
9th European Conference Artificial Intelligence (JELIA 2004), Vol. 3229
Lecture Notes AI (LNAI), pp. 200212. Springer Verlag.
Faber, W., Leone, N., & Pfeifer, G. (2011). Semantics complexity recursive aggregates
answer set programming. Artificial Intelligence, 175 (1), 278298. Special Issue:
John McCarthys Legacy.
Ferraris, P. (2005). Answer Sets Propositional Theories. Baral, C., Greco, G., Leone,
N., & Terracina, G. (Eds.), Logic Programming Nonmonotonic Reasoning 8th
International Conference, LPNMR05, Diamante, Italy, September 2005, Proceedings,
Vol. 3662 Lecture Notes Computer Science, pp. 119131. Springer Verlag.
Ferraris, P. (2011). Logic programs propositional connectives aggregates. ACM
Transactions Computational Logic, 12 (4). press.
Gebser, M., Kaufmann, B., Neumann, A., & Schaub, T. (2007). Conflict-driven answer
set solving. Twentieth International Joint Conference Artificial Intelligence
(IJCAI-07), pp. 386392. Morgan Kaufmann Publishers.
Gelfond, M. (2002). Representing Knowledge A-Prolog. Kakas, A. C., & Sadri, F.
(Eds.), Computational Logic. Logic Programming Beyond, Vol. 2408 LNCS, pp.
413451. Springer.
Gelfond, M., & Lifschitz, V. (1991). Classical Negation Logic Programs Disjunctive
Databases. New Generation Computing, 9, 365385.
Gottlob, G., Leone, N., & Veith, H. (1999). Succinctness Source Expression Complexity. Annals Pure Applied Logic, 97 (13), 231260.
Kemp, D. B., & Stuckey, P. J. (1991). Semantics Logic Programs Aggregates.
Saraswat, V. A., & Ueda, K. (Eds.), Proceedings International Symposium
Logic Programming (ISLP91), pp. 387401. MIT Press.
525

fiAlviano, Calimeri, Faber, Leone, & Perri

Leone, N., Pfeifer, G., Faber, W., Eiter, T., Gottlob, G., Perri, S., & Scarcello, F. (2006).
DLV System Knowledge Representation Reasoning. ACM Transactions
Computational Logic, 7 (3), 499562.
Liu, L., Pontelli, E., Son, T. C., & Truszczynski, M. (2010). Logic programs abstract
constraint atoms: role computations. Artificial Intelligence, 174 (34), 295315.
Liu, L., & Truszczynski, M. (2006). Properties applications programs monotone
convex constraints. Journal Artificial Intelligence Research, 27, 299334.
Manna, M., Ruffolo, M., Oro, E., Alviano, M., & Leone, N. (2011). HiLeX System
Semantic Information Extraction. Transactions Large-Scale Data KnowledgeCentered Systems. Springer Berlin/Heidelberg, appear.
Manna, M., Ricca, F., & Terracina, G. (2011). Consistent Query Answering via ASP
Different Perspectives: Theory Practice. Theory Practice Logic Programming, appear.
Marek, V. W., & Truszczynski, M. (2004). Logic programs abstract constraint atoms.
Proceedings Nineteenth National Conference Artificial Intelligence (AAAI
2004), pp. 8691. AAAI Press / MIT Press.
McCarthy, J. (1959). Programs Common Sense. Proceedings Teddington
Conference Mechanization Thought Processes, pp. 7591. Majestys
Stationery Office.
McCarthy, J. (1980). Circumscription Form Non-Monotonic Reasoning. Artificial
Intelligence, 13 (12), 2739.
McCarthy, J. (1986). Applications Circumscription Formalizing Common-Sense
Knowledge. Artificial Intelligence, 28 (1), 89116.
McCarthy, J. (1990). Formalization Common Sense, papers John McCarthy edited
V. Lifschitz. Ablex.
McCarthy, J., & Hayes, P. J. (1969). Philosophical Problems Standpoint
Artificial Intelligence. Meltzer, B., & Michie, D. (Eds.), Machine Intelligence 4,
pp. 463502. Edinburgh University Press. reprinted (McCarthy, 1990).
McDermott, D. V. (1982). Non-Monotonic Logic II: Nonmonotonic Modal Theories. Journal
ACM, 29 (1), 3357.
McDermott, D. V., & Doyle, J. (1980). Non-Monotonic Logic I. Artificial Intelligence,
13 (12), 4172.
Minsky, M. (1975). Framework Representing Knowledge. Winston, P. H. (Ed.),
Psychology Computer Vision, pp. 211277. McGraw-Hill.
Moore, R. C. (1985). Semantical Considerations Nonmonotonic Logic. Artificial Intelligence, 25 (1), 7594.
Osorio, M., & Jayaraman, B. (1999). Aggregation Negation-As-Failure. New Generation
Computing, 17 (3), 255284.
Pelov, N. (2004). Semantics Logic Programs Aggregates. Ph.D. thesis, Katholieke
Universiteit Leuven, Leuven, Belgium.
Pelov, N., Denecker, M., & Bruynooghe, M. (2003). Translation Aggregate Programs
Normal Logic Programs. de Vos, M., & Provetti, A. (Eds.), Proceedings ASP03
- Answer Set Programming: Advances Theory Implementation, pp. 2942,
Messina, Italy. Online http://CEUR-WS.org/Vol-78/.
526

fiUnfounded Sets Well-Founded Semantics ASP Programs Aggregates

Pelov, N., Denecker, M., & Bruynooghe, M. (2004). Partial stable models logic programs aggregates. Proceedings 7th International Conference Logic
Programming Non-Monotonic Reasoning (LPNMR-7), Vol. 2923 Lecture Notes
AI (LNAI), pp. 207219. Springer.
Pelov, N., Denecker, M., & Bruynooghe, M. (2007). Well-founded Stable Semantics
Logic Programs Aggregates. Theory Practice Logic Programming, 7 (3),
301353.
Pelov, N., & Truszczynski, M. (2004). Semantics disjunctive programs monotone
aggregates - operator-based approach. Proceedings 10th International
Workshop Non-monotonic Reasoning (NMR 2004), Whistler, BC, Canada, pp.
327334.
Reiter, R. (1980). Logic Default Reasoning. Artificial Intelligence, 13 (12), 81132.
Ricca, F., Alviano, M., Dimasi, A., Grasso, G., Ielpa, S. M., Iiritano, S., Manna, M., &
Leone, N. (2010). Logic-Based System e-Tourism. Fundamenta Informaticae.
IOS Press, 105 (12), 3555.
Ricca, F., Grasso, G., Alviano, M., Manna, M., Lio, V., Iiritano, S., & Leone, N. (2011).
Team-building Answer Set Programming Gioia-Tauro Seaport. Theory
Practice Logic Programming. Cambridge University Press, appear.
Ross, K. A., & Sagiv, Y. (1997). Monotonic Aggregation Deductive Databases. Journal
Computer System Sciences, 54 (1), 7997.
Simons, P., Niemela, I., & Soininen, T. (2002). Extending Implementing Stable
Model Semantics. Artificial Intelligence, 138, 181234.
Son, T. C., & Pontelli, E. (2007). Constructive semantic characterization aggregates
answer set programming. Theory Practice Logic Programming, 7, 355375.
Son, T. C., Pontelli, E., & Tu, P. H. (2007). Answer Sets Logic Programs Arbitrary
Abstract Constraint Atoms. Journal Artificial Intelligence Research, 29, 353389.
Swift, T., & Warren, D. S. (2010). XSB: Extending prolog tabled logic programming.
Computing Research Repository (CoRR), abs/1012.5123.
Tarski, A. (1955). lattice-theoretical fixpoint theorem applications. Pacific J.
Math, 5, 285309.
Truszczynski, M. (2010). Reducts propositional theories, satisfiability relations,
generalizations semantics logic programs. Artificial Intelligence, 174, 12851306.
Ullman, J. D. (1989). Principles Database Knowledge Base Systems. Computer
Science Press.
Van Gelder, A. (1992). Well-Founded Semantics Aggregation. Proceedings
Eleventh Symposium Principles Database Systems (PODS92), pp. 127138.
ACM Press.
Van Gelder, A., Ross, K. A., & Schlipf, J. S. (1991). Well-Founded Semantics
General Logic Programs. Journal ACM, 38 (3), 620650.
Wittocx, J., Marien, M., & Denecker, M. (2008). IDP system: model expansion
system extension classical logic. Denecker, M. (Ed.), Proceedings
2nd Workshop Logic Search, Computation Structures Declarative
Descriptions (LaSh08), pp. 153165.

527


