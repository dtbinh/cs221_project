Journal Artificial Intelligence Research 4 (1996) 1-18

Submitted 9/95; published 1/96

Design Experimental Analysis Algorithms
Temporal Reasoning
Peter van Beek
Dennis W. Manchak

Department Computing Science, University Alberta
Edmonton, Alberta, Canada T6G 2H1

vanbeek@cs.ualberta.ca
dmanchak@vnet.ibm.com

Abstract

Many applications|from planning scheduling problems molecular biology|
rely heavily temporal reasoning component. paper, discuss design
empirical analysis algorithms temporal reasoning system based Allen's uential
interval-based framework representing temporal information. core system
algorithms determining whether temporal information consistent, and, so,
finding one scenarios consistent temporal information. Two
important algorithms tasks path consistency algorithm backtracking
algorithm. path consistency algorithm, develop techniques result
ten-fold speedup already highly optimized implementation.
backtracking algorithm, develop variable value ordering heuristics shown
empirically dramatically improve performance algorithm. well, show
previously suggested reformulation backtracking search problem reduce
time space requirements backtracking search. Taken together, techniques
develop allow temporal reasoning component solve problems practical
size.

1. Introduction
Temporal reasoning essential part many artificial intelligence tasks. desirable,
therefore, develop temporal reasoning component useful across applications.
applications, planning scheduling, rely heavily temporal reasoning component success application depend eciency
underlying temporal reasoning component. paper, discuss design empirical analysis two algorithms temporal reasoning system based Allen's (1983)
uential interval-based framework representing temporal information. two algorithms, path consistency algorithm backtracking algorithm, important two
fundamental tasks: determining whether temporal information consistent, and, so,
finding one scenarios consistent temporal information.
stress designing algorithms robust ecient practice.
path consistency algorithm, develop techniques result ten-fold
speedup already highly optimized implementation. backtracking algorithm,
develop variable value ordering heuristics shown empirically dramatically
improve performance algorithm. well, show previously suggested
reformulation backtracking search problem (van Beek, 1992) reduce time
space requirements backtracking search. Taken together, techniques develop
c 1996 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fivan Beek & Manchak

Relation
Symbol Inverse
x
b
bi
x meets

mi
x overlaps

oi
x starts



si

x



di

x finishes

f



x equal

eq

eq

Meaning
x

x

x

x

x

x

x


Figure 1: Basic relations intervals
allow temporal reasoning component solve problems realistic size. part
evidence support claim, evaluate techniques improving algorithms
large problem arises molecular biology.

2. Representing Temporal Information
section, review Allen's (1983) framework representing relations intervals. discuss set problems chosen test algorithms.

2.1 Allen's framework

thirteen basic relations hold two intervals (see Figure 1; Allen,
1983; Bruce, 1972). order represent indefinite information, relation two
intervals allowed disjunction basic relations. Sets used list
disjunctions. example, relation fm,o,sg events B represents
disjunction, (A meets B) _ (A overlaps B) _ (A starts B): Let set basic
relations, fb,bi,m,mi,o,oi,s,si,d,di,f,fi,eqg. Allen allows relation two events
subset .
use graphical notation vertices represent events directed edges
labeled sets basic relations. graphical convention, never show edges
(i; i), show edge (i; j ), show edge (j; i). edge
explicit knowledge relation labeled ; convention edges
shown. call networks labels arbitrary subsets , interval
algebra IA networks.
Example 1. Allen Koomen (1983) show IA networks used non-linear
planning concurrent actions. example representing temporal information using
IA networks, consider following blocks-world planning problem. three blocks,
A, B, C. initial state, three blocks table. goal state
2

fiAlgorithms Temporal Reasoning

simply tower blocks B B C. associate states, actions,
properties intervals hold over, immediately write
following temporal information.
Initial Conditions
Goal Conditions
Initial fdg Clear(A)
Goal fdg On(A,B)
Initial fdg Clear(B)
Goal fdg On(B,C)
Initial fdg Clear(C)
action called \Stack". effect stack action On(x; ): block x
top block . action successfully executed, conditions Clear(x)
Clear(y ) must hold: neither block x block block them. Planning introduces
two stacking actions following temporal constraints.
Stacking Action
Stacking Action
Stack(A,B) fbi,mig Initial
Stack(B,C) fbi,mig Initial
Stack(A,B) fdg Clear(A)
Stack(B,C) fdg Clear(B)
Stack(A,B) ffg Clear(B)
Stack(B,C) ffg Clear(C)
Stack(A,B) fmg On(A,B)
Stack(B,C) fmg On(B,C)
graphical representation IA network planning problem shown
Figure 2a. Two fundamental tasks determining whether temporal information
consistent, and, so, finding one scenarios consistent temporal
information. IA network consistent exists mapping
real interval (u) event vertex u network relations events satisfied (i.e., one disjuncts satisfied). example, consider
small subnetwork Figure 2a consisting events On(A,B), On(B,C), Goal.
subnetwork consistent demonstrated assignment, (On(A,B)) = [1; 5],
(On(B,C)) = [2; 5], (Goal) = [3; 4]. change subnetwork insist
On(A,B) must On(B,C), mapping would exist subnetwork
would inconsistent. consistent scenario IA network non-disjunctive subnetwork (i.e., every edge labeled single basic relation) consistent.
planning example, finding consistent scenario network corresponds finding
ordering actions accomplish goal stacking three blocks. One
consistent scenario reconstructed qualitative mapping shown Figure 2b.
Example 2. Golumbic Shamir (1993) discuss IA networks used
problem molecular biology: examining structure DNA organism (Benzer, 1959). intervals IA network represent segments DNA. Experiments
performed determine whether pair segments either disjoint intersects.
Thus, IA networks result contain edges labeled disjoint (fb,big), intersects
(fm,mi,o,oi,s,si,d,di,f,fi,eqg), , set basic relations|which indicates experiment performed. IA network consistent, evidence hypothesis
DNA linear structure; inconsistent, DNA nonlinear (it forms loops,
example). Golumbic Shamir (1993) show determining consistency restricted version IA networks NP-complete. show problems arise
application often solved quickly practice.
3

fivan Beek & Manchak










@






@@

=





@R

1







PP -

HYHHPHPPPPPq J]
JJ ,
HH
HHH
JJ ,,
Z}
ZZJ ,
HHH Z
HH


(a) IA network block-stacking example:

fbi,mig
fdg

fdg

1
Initial

fdg

fbi,mig

fdg

2
Clear(A)
3
Clear(B)
4
Clear(C)

5
Stack(A,B)
ffg

fdg

ffg

fmg

7
On(A,B)
8
On(B,C)

fmg

PiP
)PP

fdg
fdg

9
Goal

6
Stack(B,C)

(b) Consistent scenario:
Initial

Stack(B,C)
Goal
Stack(A,B)
Clear(C)
On(B,C)
Clear(B)
On(A,B)
Clear(A)

Figure 2: Representing qualitative relations intervals

2.2 Test problems
tested well heuristics developed improving path consistency backtracking algorithms perform test suite problems.
purpose empirically testing algorithms determine performance
algorithms proposed improvements \typical" problems. two
approaches: (i) collect set \benchmark" problems representative problems
arise practice, (ii) randomly generate problems \investigate algorithmic
performance depends problem characteristics ... learn predict algorithm
perform given problem class" (Hooker, 1994).
IA networks, existing collection large benchmark problems actually
arise practice|as opposed to, example, planning toy domain blocks
world. start collection, propose IA network 145 intervals arose
problem molecular biology (Benzer, 1959, pp. 1614-15; see Example 2, above).
proposed benchmark problem strictly speaking temporal reasoning problem
4

fiAlgorithms Temporal Reasoning

intervals represent segments DNA, intervals time. Nevertheless,
formulated temporal reasoning problem. value benchmark problem
arose real application. refer problem Benzer's matrix.
addition benchmark problem, paper use two models random IA
network, denoted B(n) S(n; p), evaluate performance algorithms, n
number intervals, p probability (non-trivial) constraint two
intervals. Model B(n) intended model problems arise molecular biology (as
estimated problem discussed Benzer, 1959). Model S(n; p) allows us study
algorithm performance depends important problem characteristic sparseness
underlying constraint graph. models, course, allow us study algorithm
performance depends size problem.
B(n), random instances generated follows.
Step 1. Generate \solution" size n follows. Generate n real intervals randomly
generating values end points intervals. Determine IA network determining, pair intervals, whether two intervals either intersect disjoint.
Step 2. Change constraints edges trivial constraint setting
label , set 13 basic relations. represents case experiment
performed determine whether pair DNA segments intersect disjoint.
Constraints changed percentage non-trivial constraints (approximately
6% intersects 17% disjoint) distribution graph similar
Benzer's matrix.
S(n; p), random instances generated follows.
Step 1. Generate underlying constraint graph indicating possible (n2)
edges present. Let edge present probability p, independently presence
absence edges.
Step 2. edge occurs underlying constraint graph, randomly chose label
edge set possible labels (excluding empty label) label
chosen equal probability. edge occur, label edge , set
13 basic relations.
Step 3. Generate \solution" size n follows. Generate n real intervals randomly
generating values end points intervals. Determine consistent scenario
determining basic relations satisfied intervals. Finally, add solution
IA network generated Steps 1{2.
Hence, consistent IA networks generated S(n; p). omit Step 3,
shown analytically empirically almost different possible
IA networks generated distribution inconsistent inconsistency
easily detected path consistency algorithm. avoid potential pitfall, test
algorithms consistent instances problem. method appears generate
reasonable test set temporal reasoning algorithms problems range easy
hard. found, example, instances drawn S(n; 1=4) hard problems
backtracking algorithms solve, whereas values p either side (S(n; 1=2)
S(n; 1=8)) problems easier.
5

fivan Beek & Manchak

3. Path Consistency Algorithm
Path consistency transitive closure algorithms (Aho, Hopcroft, & Ullman, 1974; Mackworth, 1977; Montanari, 1974) important temporal reasoning. Allen (1983) shows
path consistency algorithm used heuristic test whether IA network
consistent (sometimes algorithm report information consistent
really not). path consistency algorithm useful backtracking search
consistent scenario used preprocessing algorithm (Mackworth, 1977;
Ladkin & Reinefeld, 1992) algorithm interleaved backtracking search (see next section; Nadel, 1989; Ladkin & Reinefeld, 1992). section,
examine methods speeding path consistency algorithm.
idea behind path consistency algorithm following. Choose three
vertices i, j , k network. labels edges (i; j ) (j; k) potentially
constrain label edge (i; k) completes triangle. example, consider
three vertices Stack(A,B), On(A,B), Goal Figure 2a. Stack(A,B) fmg
On(A,B) On(A,B) fdig Goal deduce Stack(A,B) fbg Goal therefore
change label edge , set basic relations, singleton
set fbg. perform deduction, algorithm uses operations set intersection
(\) composition () labels checks whether C = C \ C C , C
label edge (i; k). C updated, may constrain labels, (i; k)
added list processed turn, provided edge already list.
algorithm iterates changes possible. unary operation, inverse,
used algorithm. inverse label inverse elements
(see Figure 1 inverses basic relations).
designed experimentally evaluated techniques improving eciency
path consistency algorithm. starting point variation Allen's (1983) algorithm
shown Figure 3. implementation algorithm ecient, intersection
composition operations labels must ecient (Steps 5 & 10). Intersection
made ecient implementing labels bit vectors. intersection two labels
simply logical two integers. Composition harder make ecient.
Unfortunately, impractical implement composition two labels using table
lookup table would need size 213 213, 213 possible labels.
experimentally compared two practical methods composition
proposed literature. Allen (1983) gives method composition uses table
size 13 13. table gives composition basic relations (see Allen, 1983,
table). composition two labels computed nested loop forms
union pairwise composition basic relations labels. Hogge (1987) gives
method composition uses four tables size 27 27, 27 26, 26 27, 26 26.
composition two labels computed taking union results four array
references (H. Kautz independently devised similar scheme). experiments,
implementations two methods differed composition computed.
both, list, L, edges processed implemented using first-in, first-out policy
(i.e., stack).
experimentally evaluated methods reducing number composition operations need performed. One idea examined improving eciency
ik

ik

6

ik

ij

jk

ik

fiAlgorithms Temporal Reasoning

(C; n)

Path-Consistency

1. L f(i; j ) j 1 < j ng
2. (L empty)
3. select delete (i; j ) L
4.
k 1 n, k 6= k 6= j
5.
C \ C C
6.
(t 6= C )
7.
C
8.
C
Inverse(t)
9.
L
L [ f(i; k )g
10.

C
\C
C
11.
(t 6= C )
12.
C
13.
C
Inverse(t)
14.
L
L [ f(k; j )g
ik

ij

jk

ki

ij

ik

ik

ki

kj

kj

kj

jk

Figure 3: Path consistency algorithm IA networks
avoid computation predicted result constrain
label edge completes triangle. Three cases identified shown
Figure 4. Another idea examined, first suggested Mackworth (1977, p. 113),
order edges processed affect eciency algorithm.
reason following. edge appear list, L, edges processed
many times progressively gets constrained. number times particular edge
appears list reduced good ordering. example, consider edges
(3; 1) (3; 5) Figure 2a. process edge (3; 1) first, edge (3; 2) updated
fo,oi,s,si,d,di,f,fi,eqg added L (k = 2 Steps 5{9). process edge
(3; 5), edge (3; 2) updated fo,s,dg added L second time. However,
process edge (3; 5) first, (3; 2) immediately updated fo,s,dg
added L once.
Three heuristics devised ordering edges shown Figure 9. edges
assigned heuristic value processed ascending order. new edge
added list (Steps 9 & 14), edge inserted appropriate spot according
new heuristic value. little work ordering heuristics path consistency
algorithms. Wallace Freuder (1992) discuss ordering heuristics arc consistency
algorithms, closely related path consistency algorithms. Two heuristics
cannot applied context heuristics assume constraint satisfaction problem
finite domains, whereas IA networks examples constraint satisfaction problems
infinite domains. third heuristic (due B. Nudel, 1983) closely corresponds
cardinality heuristic.
experiments performed Sun 4/25 12 megabytes memory.
report timings rather measure number iterations believe
gives accurate picture whether results practical interest. Care
7

fivan Beek & Manchak

computation, C \ C C , skipped known result
composition constrain label edge (i; k):
a. either C C equal , result composition therefore
constrain label edge (i; k). Thus, Step 1 Figure 3, edges
labeled added list edges process.
b. condition,
ik

ij

ij

jk

jk

(b 2 C

ij ^

bi 2 C ) _ (bi 2 C

ij ^

jk

b 2 C ) _ (d 2 C
jk

ij ^

di 2 C );
jk

true, result composing C C . condition quickly tested
using bit operations. Thus, condition true Step 5, Steps 5{9
skipped. similar condition formulated tested Step 10.
c. point computation C C determined result
accumulated far would constrain label C , rest computation
skipped.
ij

jk

ij

jk

ik

Figure 4: Skipping techniques
taken always start base implementation algorithm add
enough code implement composition method, new technique, heuristic
evaluating. well, every attempt made implement method heuristic
eciently could.
Given implementations, Hogge's method composition found
ecient Allen's method benchmark problem random instances
(see Figures 5{8). much surprising. However, addition skipping
techniques, two methods became close eciency. skipping techniques sometimes
dramatically improved eciency methods. ordering heuristics improve
eciency, although results less dramatic. cardinality heuristic
constraintedness heuristic tried ordering edges. found
cardinality heuristic costly compute weight heuristic
perform it. constraintedness heuristic reduced number iterations proved
costly compute. illustrates balance must struck effectiveness
heuristic additional overhead heuristic introduces.
S(n; p), skipping techniques weight ordering heuristic together result
ten-fold speedup already highly optimized implementation using Hogge's
method composition. largest improvements eciency occur IA networks
sparse (p smaller). encouraging appears problems arise
planning molecular biology sparse. B(n) Benzer's matrix, speedup
approximately four-fold. Perhaps importantly, execution times reported indicate
path consistency algorithm, even though O(n3 ) algorithm, used
practical-sized problems. Figure 8, show well algorithms scale up.
8

fiAlgorithms Temporal Reasoning

Allen

137.7

Hogge

10.3

Allen+skip

5.7

Hogge+skip

4.0

Hogge+skip+weight

2.7

Figure 5: Effect heuristics time (sec.) path consistency algorithms applied
Benzer's matrix

time (sec.)

100

10

1

Allen
Hogge
Allen+skip
Hogge+skip
Hogge+skip+weight

0.1
50

75

100
n

125

150

Figure 6: Effect heuristics average time (sec.) path consistency algorithms.
data point average 100 tests random instances IA networks drawn
B(n); coecient variation (standard deviation / average) set
100 tests bounded 0.20
seen algorithm includes weight ordering heuristic performs others.
However, algorithm requires much space largest problem able solve
500 intervals. algorithms included skipping techniques
able solve much larger problems running space (up 1500 intervals)
constraint time took solve problems.

9

fivan Beek & Manchak

100

time (sec.)

10

1

Allen
Hogge
Allen+skip
Hogge+skip
Hogge+skip+weight

0.1
1/8

1/4

1/2
p

3/4

1

Figure 7: Effect heuristics average time (sec.) path consistency algorithms.
data point average 100 tests random instances IA networks drawn
S(100; p); coecient variation (standard deviation / average)
set 100 tests bounded 0.25
9000
8000
S(n,1/4):

Allen+skip
Hogge+skip
Hogge+skip+weight

7000

time (sec.)

6000

B(n):

Allen+skip
Hogge+skip
Hogge+skip+weight

5000
4000
3000
2000
1000
0
100

200

300

400

500

600
n

700

800

900

1000

Figure 8: Effect heuristics average time (sec.) path consistency algorithms.
data point average 10 tests random instances IA networks drawn
S(n; 1=4) B(n); coecient variation (standard deviation / average) set 10 tests bounded 0.35
10

fiAlgorithms Temporal Reasoning

4. Backtracking Algorithm

Allen (1983) first propose backtracking algorithm (Golomb & Baumert,
1965) could used find consistent scenario IA network. worst case,
backtracking algorithm take exponential amount time complete. worst
case applies Vilain Kautz (1986, 1989) show finding consistent
scenario NP-complete IA networks. spite worst case estimate, backtracking
algorithms work well practice. section, examine methods speeding
backtracking algorithm finding consistent scenario present results well
algorithm performs different classes problems. particular, compare eciency
algorithm two alternative formulations problem: one previously
proposed others one proposed (van Beek, 1992). improve
eciency algorithm designing heuristics ordering instantiation
variables ordering values domains variables.
starting point, modeled backtracking algorithm Ladkin
Reinefeld (1992) results experimentation suggests successful
finding consistent scenarios quickly. Following Ladkin Reinefeld algorithm
following characteristics: preprocessing using path consistency algorithm, static order
instantiation variables, chronological backtracking, forward checking pruning
using path consistency algorithm. chronological backtracking, search reaches
dead end, search simply backs next recently instantiated variable
tries different instantiation. Forward checking (Haralick & Elliott, 1980) technique
determined recorded instantiation current variable restricts
possible instantiations future variables. technique viewed hybrid
tree search consistency algorithms (see Nadel, 1989; Nudel, 1983). (See Dechter, 1992,
general survey backtracking.)

4.1 Alternative formulations

Let C matrix representation IA network, C label edge (i; j ).
traditional method finding consistent scenario IA network search
subnetwork network C that,
(a) C ,
(b) jS j = 1, i; j ,
(c) consistent.
find consistent scenario simply search different possible 's satisfy
conditions (a) (b)|it simple matter enumerate them|until find one
satisfies condition (c). Allen (1983) first propose using backtracking search
search potential 's.
alternative formulation based results two restricted classes IA networks,
denoted SA networks NB networks. IA networks, relation two
intervals subset , set thirteen basic relations. SA networks
(Vilain & Kautz, 1986), allowed relations two intervals subsets
translated, using relations f<, , =, >, , 6=g, conjunctions
ij

ij

ij

ij

11

fivan Beek & Manchak

relations endpoints intervals. example, IA network Figure 2a
SA network. specific example, interval relation \A fbi,mig B"
expressed conjunction point relations, (B, < B+ ) ^ (A, < A+ ) ^ (A, B+ );
A, A+ represent start end points interval A, respectively. (See Ladkin
& Maddux, 1988; van Beek & Cohen, 1990, enumeration allowed relations
SA networks.) NB networks (Nebel & Burckert, 1995), allowed relations
two intervals subsets translated, using relations f<,
, =, >, , 6=g, conjunctions Horn clauses express relations
endpoints intervals. set NB relations strict superset SA relations.
alternative formulation follows. describe method terms SA
networks, method applies NB networks. idea that, rather
search directly consistent scenario IA network previous work, first
search something general: consistent SA subnetwork IA network.
is, use backtrack search find subnetwork network C that,
(a)

Sij Cij

(b)

Sij

(c)



,

allowed relation SA networks, i; j ,

consistent.

previous work, search alternative singleton labelings edge, i.e.,
jS j = 1. key idea proposal decompose labels largest
possible sets basic relations allowed SA networks search
decompositions. considerably reduce size search space. example,
suppose label edge fb,bi,m,o,oi,sig. six possible ways label
edge singleton label: fbg, fbig, fmg, fog, foig, fsig, two possible ways
label edge decompose labels largest possible sets basic relations
allowed SA networks: fb,m,og fbi,oi,sig. another example, consider
network shown Figure 2a. searching alternative singleton labelings,
worst case size search space C12 C13 C89 = 314 (the edges labeled
must included calculation). decomposing labels largest
possible sets basic relations allowed SA networks searching
decompositions, size search space 1, backtracking necessary (in general,
search is, course, always backtrack free).
test whether instantiation variable consistent instantiations past
variables possible instantiations future variables, use incremental path
consistency algorithm (in Step 1 Figure 3 instead initializing L edges,
initialized single edge changed). result backtracking algorithm
consistent SA subnetwork IA network, report IA network inconsistent.
backtracking completes, solution SA network found using fast
algorithm given van Beek (1992).
ij

4.2 Ordering heuristics

Backtracking proceeds progressively instantiating variables. consistent instantiation
exists current variable, search backs up. order variables
12

fiAlgorithms Temporal Reasoning

Weight. weight heuristic estimate much label edge restrict
labels edges. Restrictiveness measured basic relation successively composing basic relation every possible label summing cardinalities
results. results suitably scaled give table shown below.
relation b bi mi oi si di f eq
weight 3 3 2 2 4 4 2 2 4 3 2 2 1
weight label sum weights elements. example, weight
relation fm,o,sg 2 + 4 + 2 = 8.
Cardinality. cardinality heuristic variation weight heuristic. Here,
weight every basic relation set one.
Constraint. constraintedness heuristic estimate much change label
edge restrict labels edges. determined follows. Suppose
edge interested (i; j ). constraintedness label edge (i; j )
sum weights labels edges (k; i) (j; k), k = 1; :::; n; k 6= i; k 6= j .
intuition comes examining path consistency algorithm (Figure 3) would
propagate change label C . see C composed C (Step 5)
C (Step 10), k = 1; :::; n; k 6= i; k 6= j .
ij

ij

ki

jk

Figure 9: Ordering heuristics
instantiated order values domains tried possible
instantiations greatly affect performance backtracking algorithm various
methods ordering variables (e.g. Bitner & Reingold, 1975; Freuder, 1982; Nudel,
1983) ordering values (e.g. Dechter & Pearl, 1988; Ginsberg et al., 1990; Haralick
& Elliott, 1980) proposed.
idea behind variable ordering heuristics instantiate variables first
constrain instantiation variables most. is, backtracking search
attempts solve highly constrained part network first. Three heuristics
devised ordering variables (edges IA network) shown Figure 9.
alternative formulation, cardinality redefined count decompositions rather
elements label. variables put ascending order. experiments
ordering static|it determined backtracking search starts
change search progresses. context, cardinality heuristic similar
heuristic proposed Bitner Reingold (1975) studied Purdom (1983).
idea behind value ordering heuristics order values domains
variables values likely lead solution tried first. Generally,
done putting values first constrain choices variables least.
propose novel technique value ordering based knowledge structure
solutions. idea first choose small set problems class problems,
find consistent scenario instance without using value ordering.
set solutions, examine solutions determine values domains
13

fivan Beek & Manchak

120

100

SI

SA

time (sec.)

80

60

40

20

0
50

100

150
n

200

250

Figure 10: Effect decomposition method average time (sec.) backtracking algorithm. data point average 100 tests random instances IA
networks drawn B(n); coecient variation (standard deviation /
average) set 100 tests bounded 0.15
likely appear solution values least likely. information
used order values subsequent searches solutions problems
class problems. example, five problems generated using model S(100; 1=4)
consistent scenarios found using backtracking search variable ordering
heuristic constraintedness/weight/cardinality. rounding two significant digits,
relations occurred solutions following frequency,
relation
b, bi d, di o, oi
value (10) 1900 240 220

eq
53

m, mi f, s, si
20
15 14

example using information order values domain, suppose
label edge fb,bi,m,o,oi,sig. decomposing labels singleton labels,
would order values domain follows (most preferred first): fbg, fbig, fog,
foig, fmg, fsig. decomposing labels largest possible sets basic
relations allowed SA networks, would order values domain
follows: fb,m,og, fbi,oi,sig, since 1900 + 20 + 220 > 1900 + 220 + 14. technique
used whenever something known structure solutions.

4.3 Experiments

experiments performed Sun 4/20 8 megabytes memory.
first set experiments, summarized Figure 10, examined effect problem
formulation execution time backtracking algorithm. implemented three
14

fiAlgorithms Temporal Reasoning

10000
Random value ordering, Random
Heuristic value ordering, random
Random value ordering, best heuristic
Heuristic value ordering, best heuristic

variable
variable
variable
variable

ordering
ordering
ordering
ordering

time

1000

100

10
0

10

20

30

40

50
test

60

70

80

90

100

Figure 11: Effect variable value ordering heuristics time (sec.) backtracking
algorithm. curve represents 100 tests random instances IA networks
drawn S(100; 1=4) tests ordered time taken solve
instance. backtracking algorithm used SA decomposition method.
versions algorithm identical except one searched singleton
labelings (denoted hereafter Figure 10 SI method) two searched
decompositions labels largest possible allowed relations SA networks NB networks, respectively. methods solved set random
problems drawn B(n) applied Benzer's matrix (denoted +
Figure 10). problem, amount time required solve given IA network recorded. mentioned earlier, IA network preprocessed path
consistency algorithm backtracking search. timings include preprocessing
time. experiments indicate speedup using SA decomposition method
three-fold SI method. well, SA decomposition method
able solve larger problems running space (n = 250 versus n = 175).
NB decomposition method gives exactly result SA method
problems structure constraints. tested three methods
set random problems drawn S(100; p), p = 1; 3=4; 1=2, 1=8.
experiments, SA NB methods consistently twice fast SI method.
well, NB method showed advantage SA method problems.
surprising branching factor, hence size search space, smaller
NB method SA method.
second set experiments, summarized Figure 11, examined effect
execution time backtracking algorithm heuristically ordering variables
values domains variables backtracking search begins. variable
ordering, six permutations cardinality, constraint, weight heuristics tried
15

fivan Beek & Manchak

primary, secondary, tertiary sorting keys, respectively. basis comparison,
experiments included case heuristics. Figure 11 shows approximate cumulative
frequency curves experimental results. Thus, example, read
curve representing heuristic value ordering best heuristic variable ordering
approximately 75% tests completed within 20 seconds, whereas random value
variable ordering approximately 5% tests completed within 20 seconds.
read curves 0, 10, : : : , 100 percentiles data sets (where
value median 50th percentile value 50th test). curves
truncated time = 1800 (1/2 hour), backtracking search aborted
time limit exceeded.
experiments found S(100; 1=4) represents particularly dicult class
problems different heuristics resulted dramatically different performance, heuristic case different heuristics.
value ordering, best heuristic variable ordering combination constraintedness/weight/cardinality constraintedness primary sorting key
remaining keys used break subsequent ties. Somewhat surprisingly, best heuristic
variable ordering changes heuristic value ordering incorporated. combination weight/constraintedness/cardinality works much better. heuristic together
value ordering particularly effective \ attening out" distribution allowing much greater number problems solved reasonable amount time.
S(100; p), p = 1; 3=4; 1=2, 1=8, problems much easier three
hundreds tests completed within 20 seconds. problems, heuristic used
result significantly different performance.
summary, experiments indicate changing decomposition method
able solve larger problems running space (n = 250 vs n = 175
machine 8 megabytes; see Figure 10). experiments indicate good heuristic
orderings essential able find consistent scenario IA network
reasonable time. good heuristic ordering able solve much larger problems
running time (see Figure 11). experiments provide additional evidence
ecacy Ladkin Reinefeld's (1992, 1993) algorithm. Nevertheless, even
improvements, problems still took considerable amount time solve.
consideration, surprising. all, problem known NP-complete.

5. Conclusions
Temporal reasoning essential part tasks planning scheduling. paper, discussed design empirical analysis two key algorithms temporal
reasoning system. algorithms path consistency algorithm backtracking algorithm. temporal reasoning system based Allen's (1983) interval-based framework
representing temporal information. emphasis make algorithms
robust ecient practice problems vary easy hard. path consistency algorithm, bottleneck performing composition operation. developed
methods reducing number composition operations need performed.
methods result almost order magnitude speedup already highly
optimized implementation algorithm. backtracking algorithm, developed
16

fiAlgorithms Temporal Reasoning

variable value ordering heuristics showed alternative formulation
problem considerably reduce time taken find solution. techniques allow
interval-based temporal reasoning system applied larger problems perform
eciently existing applications.

References

Aho, A. V., Hopcroft, J. E., & Ullman, J. D. (1974). Design Analysis Computer
Algorithms. Addison-Wesley.
Allen, J. F. (1983). Maintaining knowledge temporal intervals. Comm. ACM, 26,
832{843.
Allen, J. F., & Koomen, J. A. (1983). Planning using temporal world model. Proceedings
Eighth International Joint Conference Artificial Intelligence, pp. 741{747
Karlsruhe, West Germany.
Benzer, S. (1959). topology genetic fine structure. Proc. Nat. Acad. Sci. USA,
45, 1607{1620.
Bitner, J. R., & Reingold, E. M. (1975). Backtrack programming techniques. Comm. ACM,
18, 651{655.
Bruce, B. C. (1972). model temporal references application question
answering program. Artificial Intelligence, 3, 1{25.
Dechter, R. (1992). local global consistency. Artificial Intelligence, 55, 87{107.
Dechter, R., & Pearl, J. (1988). Network-based heuristics constraint satisfaction problems. Artificial Intelligence, 34, 1{38.
Freuder, E. C. (1982). sucient condition backtrack-free search. J. ACM, 29, 24{32.
Ginsberg, M. L., Frank, M., Halpin, M. P., & Torrance, M. C. (1990). Search lessons learned
crossword puzzles. Proceedings Eighth National Conference Artificial
Intelligence, pp. 210{215 Boston, Mass.
Golomb, S., & Baumert, L. (1965). Backtrack programming. J. ACM, 12, 516{524.
Golumbic, M. C., & Shamir, R. (1993). Complexity algorithms reasoning
time: graph-theoretic approach. J. ACM, 40, 1108{1133.
Haralick, R. M., & Elliott, G. L. (1980). Increasing tree search eciency constraint
satisfaction problems. Artificial Intelligence, 14, 263{313.
Hogge, J. C. (1987). TPLAN: temporal interval-based planner novel extensions. Department computer science technical report UIUCDCS-R-87, University Illinois.
Hooker, J. N. (1994). Needed: empirical science algorithms. Operations Research,
42, 201{212.
17

fivan Beek & Manchak

Ladkin, P., & Reinefeld, A. (1992). Effective solution qualitative interval constraint
problems. Artificial Intelligence, 57, 105{124.
Ladkin, P., & Reinefeld, A. (1993). symbolic approach interval constraint problems.
Calmet, J., & Campbell, J. (Eds.), Artificial Intelligence Symbolic Mathematical
Computing, Springer Lecture Notes Computer Science 737. Springer-Verlag.
Ladkin, P. B., & Maddux, R. D. (1988). binary constraint networks. Technical report,
Kestrel Institute, Palo Alto, Calif.
Mackworth, A. K. (1977). Consistency networks relations. Artificial Intelligence, 8,
99{118.
Montanari, U. (1974). Networks constraints: Fundamental properties applications
picture processing. Inform. Sci., 7, 95{132.
Nadel, B. A. (1989). Constraint satisfaction algorithms. Computational Intelligence, 5,
188{224.
Nebel, B., & Burckert, H.-J. (1995). Reasoning temporal relations: maximal
tractable subclass Allen's interval algebra. J. ACM, 42, 43{66.
Nudel, B. (1983). Consistent-labeling problems algorithms: Expected-complexities
theory-based heuristics. Artificial Intelligence, 21, 135{178.
Purdom, Jr., P. W. (1983). Search rearrangement backtracking polynomial average
time. Artificial Intelligence, 21, 117{133.
van Beek, P. (1992). Reasoning qualitative temporal information. Artificial Intelligence, 58, 297{326.
van Beek, P., & Cohen, R. (1990). Exact approximate reasoning temporal
relations. Computational Intelligence, 6, 132{144.
Vilain, M., & Kautz, H. (1986). Constraint propagation algorithms temporal reasoning.
Proceedings Fifth National Conference Artificial Intelligence, pp. 377{382
Philadelphia, Pa.
Vilain, M., Kautz, H., & van Beek, P. (1989). Constraint propagation algorithms
temporal reasoning: revised report. Weld, D. S., & de Kleer, J. (Eds.), Readings
Qualitative Reasoning Physical Systems, pp. 373{381. Morgan Kaufmann.
Wallace, R. J., & Freuder, E. C. (1992). Ordering heuristics arc consistency algorithms.
Proceedings Ninth Canadian Conference Artificial Intelligence, pp. 163{
169 Vancouver, B.C.

18


