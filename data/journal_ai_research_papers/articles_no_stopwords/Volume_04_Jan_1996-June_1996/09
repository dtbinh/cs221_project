Divergence Critic
Bundy, A., van Harmelen, F., Horn, C., & Smaill, A. (1990). Oyster-Clam system.
Stickel, M. (Ed.), 10th International Conference Automated Deduction, pp. 647{
648. Springer-Verlag. Lecture Notes Artificial Intelligence No. 449.
Dershowitz, N., & Pinchover, E. (1990). Inductive Synthesis Equational Programs.
Proceedings 8th National Conference AI, pp. 234{239. American Association
Artificial Intelligence.
Hermann, M. (1989). Crossed term rewriting systems. CRIN report 89-R-003, Centre de
Recherche en Informatique de Nancy.
Ireland, A. (1992). Use Planning Critics Mechanizing Inductive Proof. Proceedings LPAR'92, Lecture Notes Artificial Intelligence 624. Springer-Verlag.
available Research Report 592, Dept AI, Edinburgh University.
Ireland, A., & Bundy, A. (1992). Using failure guide inductive proof. Tech. rep., Dept.
Artificial Intelligence, University Edinburgh. Available Edinburgh DAI
Research Paper 613.
Kirchner, H. (1987). Schematization infinite sets rewrite rules. Application
divergence completion processes. Proceedings RTA'87, pp. 180{191.
Protzen, M. (1992). Disproving conjectures. Kapur, D. (Ed.), 11th Conference
Automated Deduction, pp. 340{354. Springer Verlag. Lecture Notes Computer
Science No. 607.
Thomas, M., & Jantke, K. (1989). Inductive Inference Solving Divergence KnuthBendix Completion. Proceedings International Workshop AII'89, pp. 288{303.
Thomas, M., & Watson, P. (1993). Solving divergence Knuth-Bendix completion
enriching signatures. Theoretical Computer Science, 112, 145{185.
Walsh, T. (1994). divergence critic. Bundy, A. (Ed.), 12th Conference Automated
Deduction, pp. 14{25. Springer Verlag. Lecture Notes Artificial Intelligence No.
814.
Walsh, T., Nunes, A., & Bundy, A. (1992). use proof plans sum series. Kapur,
D. (Ed.), 11th Conference Automated Deduction, pp. 325{339. Springer Verlag.
Lecture Notes Computer Science No. 607. available Edinburgh DAI
Research Paper 563.
Yoshida, T., Bundy, A., Green, I., Walsh, T., & Basin, D. (1994). Coloured rippling:
extension theorem proving heuristic. Cohn, A. (Ed.), Proceedings ECAI-94,
pp. 85{89. John Wiley. available Edinburgh DAI Research Paper 779.

235

fiWalsh
way. types divergence could perhaps recognized
divergence critic. research needed identify divergence patterns, isolate
causes propose ways fixing them. research may take advantage close
links divergence patterns particular types generalization. instance,
may possible identify specific divergence patterns need generalize common
subterms theorem proved.

Acknowledgements

research supported Human Capital Mobility Postdoctoral Fellowship.
wish thank: Adel Bouhoula Michael Rusinowitch invaluable assistance
Spike; Pierre Lescanne inviting visit Nancy research
performed; David Basin, Alan Bundy, Miki Hermann, Andrew Ireland, Michael
Rusinowitch comments questions; reviewers comments suggestions; members Eureca Protheo groups INRIA; members
DReaM group Edinburgh MRG groups Trento Genova.

References

Aubin, R. (1976). Mechanizing Structural Induction. Ph.D. thesis, University Edinburgh.
Basin, D., & Walsh, T. (1992). Difference matching. Kapur, D. (Ed.), 11th Conference
Automated Deduction, pp. 295{309. Springer Verlag. Lecture Notes Computer
Science No. 607. available Edinburgh DAI Research Paper 556.
Basin, D., & Walsh, T. (1993). Difference unification. Proceedings 13th IJCAI.
International Joint Conference Artificial Intelligence. available Technical
Report MPI-I-92-247, Max-Planck-Institute fur Informatik.
Basin, D., & Walsh, T. (1994). Termination orderings rippling. Bundy, A. (Ed.), 12th
Conference Automated Deduction, pp. 466{483. Springer Verlag. Lecture Notes
Artificial Intelligence No. 814.
Bouhoula, A., Kounalis, E., & Rusinowitch, M. (1992). Spike: theorem-prover.
Proceedings LPAR'92, Lecture Notes Artificial Intelligence 624. Springer-Verlag.
Bouhoula, A., & Rusinowitch, M. (1995a). Implicit induction conditional theories. Journal Automated Reasoning, 14 (2), 189{235.
Bouhoula, A., & Rusinowitch, M. (1995b). Spike user manual.. INRIA Lorraine
CRIN, 615 rue du Jardin Botanique, Villers-les-Nancy, France. Available
ftp://ftp.loria.fr/pub/loria/protheo/softwares/Spike/.
Boyer, R., & Moore, J. (1979). Computational Logic. Academic Press. ACM monograph
series.
Bundy, A., Stevens, A., van Harmelen, F., Ireland, A., & Smaill, A. (1993). Rippling:
heuristic guiding inductive proofs. Artificial Intelligence, 62, 185{253.
available Edinburgh DAI Research Paper No. 567.
234

fiA Divergence Critic
rev(qrev(x; nil)) = x
rev(qrev(x; cons(y; nil) )) = cons(y; x)
rev(qrev(x; cons(z; cons(y; nil)) )) = cons(z; cons(y; x))
..
.

annotated sequence unique maximal difference match. annotations suggest
need wave rule,
rev(qrev(X; cons(Y; nil) )) = cons(Y; rev(qrev(X; nil))) :

rule allows proof go without divergence. comparison, specific
generalization seems unable identify rule. specific generalization
left hand side sequence gives term rev(qrev(X; Z)) (or, ignoring first term
sequence, rev(qrev(X; cons(Y; Z)))). specific generalization cannot, however,
identify useful pattern, rev(qrev(X; cons(Y; nil))).
Nqthm contains simple test divergence based subsumption. instance,
example 13 last section, Nqthm unable simplify following subgoal
step case proof,
(EQUAL (ROT (LENGTH X) (APPEND X (LIST Z)))
(CONS Z (ROT (LENGTH X) X))))

Note lemma speculated divergence critic. Nqthm generalizes (LENGTH
X) subgoal giving false conjecture,
(EQUAL (ROT (APPEND X (LIST Z)))
(CONS Z (ROT X))))

several attempts induction generalization, Nqthm realizes proof
diverging since subgoal subsumed parent. proof therefore loop,
Nqthm gives up. attempt made analyse failed proof attempt identify
started go wrong. addition, subsumption weak test divergence, much
weaker tests based difference matching generalization. subsumption test
recognizes divergence small number failed examples last section.

10. Conclusions

described divergence critic, computer program attempts identify diverging proof attempts propose lemmas generalizations overcome
divergence. divergence critic proved successful; enables system Spike
prove many theorems definitions alone. divergence critic's success
largely attributed power rippling heuristic. heuristic originally
developed proofs using explicit induction since found several applications.
Difference matching used identify accumulating term structure causing divergence. Lemmas generalizations proposed ripple term structure
233

fiWalsh
divergence critic described works implicit (and explicit) induction setting.
Second, divergence critic automatically invoked must identify proof
failing. Third, divergence critic less specialized. last two differences ect
fact critics Clam usually associated failure particular precondition
heuristic. divergence pattern can, comparison, arise many different
reasons: need generalize variables apart, generalize common subterms, add
lemma, etc. Fourth, divergence critic must use difference matching annotate terms;
Clam, terms usually already appropriately annotated. Finally, divergence critic
less tightly coupled theorem prover's inference rules heuristics. critic
therefore exploit strengths prover without needing reason complex
rules heuristics used. instance, divergence critic diculty identifying
divergence complex situations nested mutual inductions. critic benefits
powerful simplification rules used Spike.
Divergence studied quite extensively completion procedures. Two
main novelties critic described use difference matching identify
divergence, use rippling speculation lemmas overcome divergence.
Dershowitz Pinchover, comparison, use specific generalization identify divergence patterns critical pairs produced completion (Dershowitz & Pinchover, 1990).
Kirchner uses generalization modulo equivalence relation recognise divergence
patterns (Kirchner, 1987); meta-rules synthesized describe infinite families
rules common structure. Thomas Jantke use generalization inductive
inference recognize divergence patterns replace infinite sequences critical pairs
finite number generalizations (Thomas & Jantke, 1989). Thomas Watson use
generalization replace infinite set rules finite complete set enriched
signature (Thomas & Watson, 1993).
Generalization modulo equivalence enables complex divergence patters identified. However, general undecidable. specific generalization, comparison,
limited. cannot recognize divergence patterns give nested wave-fronts like,

s( s(x) + x) :
addition, specific generalization cannot identify term structure wave-holes.
example, consider divergence sequence equations produced Spike attempts
prove example 25 Section 8,
rev(qrev(x; nil)) = x
rev(qrev(x; cons(y; nil))) = cons(y; x)
rev(qrev(x; cons(z; cons(y; nil)))) = cons(z; cons(y; x))
..
.

Divergence analysis identifies term structure accumulating within accumulator argument
qrev ,
232

fiA Divergence Critic
Unfortunately heuristics instantiating right hand side speculated lemmas
strong enough suggest rule,

X + (Y + Z ) = + (X + Z )
rule, Spike finds proof commutativity multiplication without diculty.
diculties speculating rule arise wave-front stuck similar
position sides equality. clues therefore suggest ripple
top term tree.
example 33, divergence critic proposes lemma one needed. Spike
able find proof theorem definitions alone using 16 inductions. Three
inductions equations,
0+x = x
s(0) + x = s(x)
s(s(0)) + x = s(s(x))
sequence equations satisfies divergence critic's preconditions. critic therefore
proposes wave rules moving accumulating successor functions first argument
position +. Although proposed lemmas necessary, either give much shorter
simpler proof needing 7 inductions.
Example 34 lemma speculated example 24. Divergence analysis Spike's
attempt prove theorem identifies term structure accumulating second (alias
accumulator) argument qrev . first two lemmas proposed removing term
structure use subsumed recursive definition qrev . third
lemma fails prevent divergence. lemma simplifies two element lists second
argument position qrev . However, divergence still occur prover cannot simplify
lists occur second argument position qrev contain 3 elements.
Divergence overcome introduce derived function appending onto end
list. used simplify terms list arbitrary size occurs
second argument position qrev . example, simplify rule,

qrev(X; ) = app(qrev(X; nil); )
Unfortunately, append occur specification theorem dicult
find heuristic would speculate rule.

9. Related Work

Critics monitoring construction proofs first proposed Ireland Clam
prover (Ireland, 1992). framework, failure one proof methods automatically
invokes critic. Various critics explicit induction developed speculate
missing lemmas, perform generalizations, look suitable case splits, etc. rippling plays
central role Clam's proof methods, many heuristics similar described
(Ireland & Bundy, 1992). are, however, several significant differences. First,
231

fiWalsh

Theorem
31
s(x) y=y+(x y)
32
x y=y x
33 x+(y+(z+(v+w))) = w+(x+(y+(z+v)))

Lemmas speculated
Time/s
{
n/a
s(X)+Y=X+s(Y)
8.0
s(X)+Y=s(X+Y)
17.7
s(X)+Y=X+s(Y)
34 qrev(qrev(x,[y]),z)=y ::qrev(qrev(x,[]),z)
qrev(Y,X ::Z)) = qrev(X ::Y,Z)
9.6
qrev(qrev(X,Y ::Z),W)=qrev(qrev(Y ::X,Z),W)
qrev(qrev(X,Y ::[Z]),W)=Z::qrev(qrev(X,[Y]),W)

Table 2: divergence critic's failures.
diverges, generating following sequence equations,
s(y) + (x + (x y)) = s(y) + (y + (x y))
s(s(y)) + (x + (x + (x y))) = s(x) + (s(y) + (x + (x y))
s(s(s(y))) + (x + (x + (x + (x y)))) = s(x) + (s(s(y)) + (x + (x + (x y))))
..
.
Divergence analysis left hand sides equations suggests need rule
form,

s(Y ) + (X + Z ) = F (Y + Z )
Unfortunately heuristics lemma speculation suciently strong suggest
suitable instantiation F (for example, z : s(X + z )). lemma rather complex
result two overlapping divergence patterns. annotations considered
separately, suggest rules,

s(X ) + = s(X + )
+ (X + Z ) = X + (Y + Z )
two rules, Spike finds proof without diculty.
Example 32 commutativity multiplication. divergence critic identifies
divergence pattern proposes transverse wave rule,

s(X ) + = X + s(Y )
However, Spike unable prove commutativity multiplication addition
rule. proof attempt somewhat simpler contains diverging sequence
equations,
x + (y + (x + (x y))) = + (x + (x + (x y)))
x + (y + (x + (x + (x y))) ) = + (x + (x + (x + (x y))))

x + (y + (x + (x + (x + (x y)))) ) = + (x + (x + (x + (x + (x y)))))
..
.

230

fiA Divergence Critic
speculate non-theorems. research optimal strength generalization
heuristics would valuable.
Example 24 disappointment; lemma proposed fixes divergence
dicult proved automatically, even assistance divergence critic.
See example 34 end section details. Example 25 discussed
detail related work Section 9 demonstrates superiority difference
matching generalization techniques divergence analysis. Examples 26 28 require
little discussion. Finally, examples 29 30 demonstrate critic cope
divergence moderately complex theories containing conditional equations.
results pleasing. Using divergence critic, 30 theorems listed (with
exception 24) proved definitions alone. provide indication
diculty theorems, Nqthm system (Boyer & Moore, 1979),
perhaps best known explicit induction theorem prover, unable prove
half theorems definitions alone. precise, Nqthm failed 5, 6, 7, 8, 9,
11, 12, 13, 14, 15, 18, 19, 21, 22, 24, 25, 26, 27 28. course, addition
simple lemmas, Nqthm able prove theorems. Indeed, many cases, Nqthm
needs lemmas proposed divergence critic required Spike.
suggests divergence critic especially tied particular prover used
even implicit induction setting.
test hypothesis, presented output diverging proof attempt Nqthm
critic. chose commutativity multiplication perhaps simplest
theorem causes Nqthm diverge. critic proposed lemma,
(EQUAL (TIMES (ADD1 X)) (PLUS (TIMES X))))

TIMES PLUS primitives Nqthm's logic recursively defined first
arguments. exactly lemma needed Nqthm prove commutativity
multiplication. Nqthm fails many examples similar reasons Spike,
divergence analysis identifies appropriate lemma. supports suggestion
divergence critic likely useful wide variety provers.
divergence critic several limitations. Recognizing divergence is, general,
undecidable since reduces halting problem. divergence critic therefore
sometimes fail identify diverging proof attempt. addition, critic sometimes
identify \divergence" pattern proof attempt diverging. Even divergence correctly identified, critic sometimes fail speculate appropriate
lemma. Finally, critic speculates wave-rules. Whilst many theories contain large
number wave-rules, often useful fixing divergence, types
lemma needed.
Table 2 lists four theorems divergence critic fails. problems
representative different ways critic fail. two main cause
failure overlapping divergence patterns, inability heuristics speculate
appropriate right hand side lemma. times speculate lemmas
find proof theorem.
Example 31 commuted version recursive definition multiplication (
defined recursively second argument position). Spike's attempt prove theorem
229

fiWalsh
examples 6 7, optimal rules fixing divergence. Nevertheless, either proposed rules fix divergence proved without diculty
Spike. Example 9 similar example 8.
Examples 10 12 require little comment. example 13, proposed lemma
dicult proved automatically. However, divergence critic able identify
cause diculty propose lemma allows proof go (example
15). example 14, speculated lemma optimal. simpler lemma speculated
example 13 would adequate prove theorem without divergence. speculated
lemma optimal divergence critic attempts ripple accumulating
term structure two functors, len rot top term tree. However,
sucient problem ripple one functor, rot.
Examples 16 19 straightforward require discussion. example 20,
critic identifies two separate divergence patterns. overcome divergence, first lemma
plus one second third therefore needed. first divergence pattern
occurs sequence subgoals,

len(rev(x)) = 0 + len(x)
len( app(rev(x); cons(y; nil)) ) = s(0 + len(x))
len( app(app(rev(x); cons(y; nil)); cons(z; nil)) ) = s(s(0 + len(x)))
..
.

Term structure accumulating second argument append. term structure
removed first rule,

len( app(X; cons(Y; nil)) ) = s(len(X ))
second divergence pattern occurs sequence subgoals,

s(x) + len(y) = s(x + len(y))
s(s(x)) + len(y) = s(s(x + len(y)))
s(s(s(x))) + len(y) = s(s(s(x + len(y))))
..
.

Term structure accumulating first argument +. removed one
second third rules,

s(X ) + = s(X + )
s(X ) + = X + s(Y )
Examples 21 23 reasonably straightforward. lemma speculated example
22 special case associativity append. powerful generalization heuristics
could speculated associativity append. However, heuristics would
228

fiA Divergence Critic
causes divergence current release. speculated lemmas do, however, simplify
proof. Example 4 used text illustrate generalization heuristics. second
lemma example 5 perhaps little surprising,

len(app(X; (cons(W; cons(Z; ) )))) = s(len(app(X; cons(W; )))) :
Although complex first lemma, nearly good fixing divergence.
example 6, lemma proposed,

even( s(s(X )) + ) = even(X + )
optimal. is, simplest possible lemma fixes divergence. fix
divergence, merely need one rules, s(X ) + = s(X + ) s(X ) + = X +
s(Y ). Either ripple successor functions accumulating first argument
position +. divergence critic attempts construct lemma ripple two successor
functions across first second argument positions +. Unfortunately,
critic fails find appropriate instantiation right hand side lemma.
critic instead proposes rule move two successor functions top term
wave-front peter out. Example 7 similar example 6.
Examples 8 10 demonstrate critic cope divergence theories involving mutual recursion. example 8, Spike attempts prove induction equations,

evenm(x + x)
oddm(s(x) + x)
evenm (s(s(x)) + x)
oddm(s(s(s(x))) + x)
evenm (s(s(s(s(x)))) + x)

=
=
=
=
=
..
.

true
true
true
true
true

critic identifies two inter-linking divergence patterns,

evenm (x + x) = true
evenm ( s(s(x)) + x) = true
evenm ( s(s(s(s(x)))) + x) = true

oddm(s(x) + x) = true
oddm( s(s(s(x))) + x) = true
oddm( s(s(s(s(s(x))))) + x) = true

..
.

..
.

critic therefore proposes rules ripple accumulating term structure
top term peters out,

evenm( s(s(X )) + ) = evenm (X + )
oddm( s(s(X )) + ) = oddm(X + )
227

fiWalsh

1

Theorem
s(x)+x=s(x+x)

Lemmas speculated
Time/s
s(X)+Y=s(X+Y)
7.8
s(X)+Y=X+s(Y)
2
dbl(x)=x+x $
s(X)+Y=s(X+Y)
8.2
dbl(0)=0, dbl(s(x))=s(s(dbl(x)))
s(X)+Y=X+s(Y)
3
len(x @ y)=len(y @ x)
len(X @ (Z ::Y))=s(len(X @ Y))
3.6
len(X @ (Z ::Y))=len((W ::X) @ Y)
4
len(x @ y)=len(x)+len(y)
s(X)+Y=s(X+Y)
7.2
s(X)+Y=X+s(Y)
5
len(x @ x)=dbl(len(x))
len(X @ (Z ::Y))=s(len(X @ Y))
11.6
len(X @ (W ::Z ::Y))=s(len(X @ (W ::Y)))
6
even(x+x)
even(s(s(X))+Y)=even(X+Y)
5.4
7
odd(s(x)+x)
odd(s(s(X))+Y)=odd(X+Y)
16.0
8
evenm (x+x)
evenm (s(s(X))+Y)=evenm (X+Y)
28.4
oddm (s(s(X))+Y)=oddm (X+Y)
9
oddm (s(x)+x)
evenm (s(s(X))+Y)=evenm (X+Y)
65.5
oddm (s(s(X))+Y)=oddm (X+Y)
10
evenm (x) ! half(x)+half(x)=x
s(X)+Y=s(X+Y)
6.0
s(X)+Y=X+s(Y)
11
half(x+x)=x
s(s(X))+Y=X+s(s(Y))
11.1
half(s(s(X))+Y)=half(X+Y)
12
half(s(x)+x)=x
s(s(X))+Y=X+s(s(Y))
31.0
half(s(s(X))+Y)=half(X+Y)
13
rot(len(x),x)=x
rot(len(X),X @ [Y])=Y::rot(len(X),X)
2.4
14
len(rot(len(x),x))=len(x)
len(rot(X,Z @ [Y]))=s(len(rot(X,Z)))
4.8
15
rot(len(x),x @ [y])=y ::rot(len(x),x)
(X @ [Y])@ Z=X @ (Y ::Z)
86.3
rot(len(X),(X @ [Y])@ Z)=Y ::rot(len(X),X @ Z)
16
len(rev(x))=len(x)
len(X @ [Y])=s(len(X))
2.0
17
rev(rev(x))=x
rev(X @ [Y])=Y::rev(X)
1.2
18
rev(rev(x) @ [y])=y ::x
rev(X @ [Y])=Y::rev(X)
16.0
19
rev(rev(x) @ [y])=y ::rev(rev(x))
rev(X @ [Y])=Y::rev(X)
18.6
20
len(rev(x @ y))=len(x)+len(y)
len(X @ [Y])=s(len(X))
10.0
s(X)+Y=s(X+Y)
s(X)+Y=X+s(Y)
21
len(qrev(x,[]))=len(x)
len(qrev(X,Z ::Y))=s(len(qrev(X,Y)))
2.2
22
qrev(x,y)=rev(x) @
(X @ [Y])@ Z=X @ (Y ::Z)
3.4
23
len(qrev(x,y))=len(x)+len(y)
s(X)+Y=s(X+Y)
12.0
s(X)+Y=X+s(Y)
24
qrev(qrev(x,[]),[])=x
qrev(qrev(X,[Y]),Z)=Y ::qrev(qrev(X,[]),Z)
5.0
25
rev(qrev(x,[]))=x
rev(qrev(X,[Y]))=Y ::rev(qrev(X,[]))
5.8
26
qrev(rev(x),[])=x
qrev(X @ [Y],Z)=Y::qrev(X,Z)
5.2
27
nth(i,nth(j,x))=nth(j,nth(i,x))
nth(s(I),nth(J,Y ::X))=nth(I,nth(J,X))
7.4
28 nth(i,nth(j,nth(k,x)))=nth(k,nth(j,nth(i,x)))
nth(s(I),nth(J,Y ::X))=nth(I,nth(J,X))
7.6
29
len(isort(x))=len(x)
len(insert(Y,X))=s(len(X))
2.0
30
sorted(isort(x))
sorted(insert(Y,X))=sorted(X)
114
sorted(insert(Y,insert(Z,X)))=sorted(X)

Table 1: lemmas speculated divergence critic.
Notes: :: written infix cons, @ infix append, [] nil, [x] cons(x,nil).
addition, even defined s(s(x)) recursion, evenm mutual recursion oddm ,
rot(n; l) rotates list l n elements.
226

fiA Divergence Critic
critic successful identifying divergence proposing appropriate lemmas
generalizations significant number theorems. Divergence analysis quick
examples. divergence pattern recognized usually less second.
time spent looking generalizations refuting over-generalizations
conjecture disprover. usually takes 1 100 seconds. Additional heuristics
preventing over-generalization ecient implementation conjecture
disprover would speed critic considerably.

8. Results

Table 1 lists 30 theorems cause Spike diverge lemmas speculated
divergence critic analysing diverging proof attempts. problems provide
representative sample type theorems cause divergence
identified appropriate lemma generalization speculated. Many problems
come Clam library corpus. Part table appeared (Walsh, 1994).
Times divergence critic speculate lemmas average 10
runs Sun 4 running Quintus 3.1.1.
Spike's proof attempt diverges example given definitions alone.
30 cases, critic quickly able suggest lemma overcomes divergence.
multiple lemmas proposed (with exception 20) one
sucient fix divergence. every case (except 13 24) lemmas proposed
suciently simple proved automatically without introducing fresh divergence.
majority cases, lemmas proposed optimal; is, simplest possible
lemmas fix divergence. cases lemma optimal, usually
slightly complex simplest lemma fixes divergence. many
examples, lemmas conjectured divergence analysis quickly
rejected conjecture disprover. example, example 16, divergence analysis
petering heuristic suggest rule,
## len( app(X; cons(Y; nil)) ) = len(X ) ##
However, refuted exhaustive normalization using ground terms X .
case, cancellation heuristic identifies required lemma,
len( app(X; cons(Y; nil)) ) = s(len(X )) :
examples deserve additional comment. example 1, divergence critic
identifies successor functions accumulating first argument position +.
critic speculates lemma moving successor functions either top
term (so immediate cancellation occur) onto second argument position
(so simplification recursive definition + occur). first lemma
speculated fact generalization theorem proved. Example 2 simple
program verification problem taken Dershowitz Pinchover (1990). forward
direction theorem discussed introduction. Similar divergence occurs
example 1 and, generalization, lemmas speculated.
Example 3 caused divergence beta-version Spike available summer
1994. proof rules Spike since strengthened example longer
225

fiWalsh

% compiling file /home/dream5/tw/work/Spike/diverge/data.double.x+x
% data.double.x+x compiled module user, 0.233 sec 1,612 bytes
| ?- speculate.
Equations input:
double(x1)=x1+x1
s(x1+x1)=s(x1)+x1
s(s(x1+x1))=s(s(x1))+x1
s(s(s(x1+x1)))=s(s(s(x1)))+x1
Lemmas speculated:
s(x1)+x1=s(x1+x1)
s(x1)+x99=s(x1+x99)
s(x99)+x1=s(x99+x1)
s(x99)+x100=s(x99+x100)
s(x1)+x1=x1+s(x1)
s(x1)+x99=x1+s(x99)
s(x99)+x1=x99+s(x1)
s(x99)+x100=x99+s(x100)
Deleting lemmas subsumed:
s(x1)+x99=s(x1+x99)
s(x1)+x99=x1+s(x99)
Merging remaining lemmas:
s(x1)+x99=s(x1+x99)
s(x1)+x99=x1+s(x99)
yes
| ?-

Figure 4: Example output divergence critic.
Figure 1 gives divergence critic's output problem discussed introduction.
Either proposed lemmas used rewrite rule adequate fix divergence.
addition, proposed lemmas suciently simple proved automatically without
introducing fresh divergence. first lemma rewrite rule moving accumulating
successor functions first argument position + top term tree.
second lemma transverse wave rule discussed Section 6 moving accumulating
successor functions first argument position + second argument position.
224

fiA Divergence Critic

Preconditions:
1. sequence equations si = ti
prover attempts prove induction (i = 0, 1 ...);
2. exists (non trivial) G; H j ,
maximal difference match sj = G(Uj ; Acc)
sj+1 = G( H (Uj ) ; Acc).
Postconditions:
1. critic proposes rule form,

G( H (U0) ; Acc) = G(U0; F (Acc) )
2. F instantiated fertilization simplification
heuristics;
3. lemma generalized using (augmented) primary terms equality heuristics;
4. Generalized lemmas filtered type checker
conjecture disprover;
5. several lemmas suggested, critic deletes
subsumed.
Figure 3: Speculation transverse wave rules.
annotations. could speculate hybrid wave rules ripple part wave-front
across part term tree. However, rules appear rare. addition,
hybrid wave rules often decomposed pair wave rules, one
moves wave-fronts term tree, another moves wave-fronts
across.

7. Implementation

divergence critic described previous sections implemented Prolog.
system consists 787 lines code defining approximate 100 different Prolog predicates. recently cut version incorporated directly within Spike
system written Caml Light (Bouhoula & Rusinowitch, 1995b). output
Spike parsed generate input critic. input consists of: equations
prover attempts prove induction; sort information (for type checker
difference matcher); recursive argument positions (for constructing primary terms);
rewrite rules defining theory (used conjecture disprover).
223

fiWalsh
rule allows proof go without divergence.
Speculated transverse wave rules generalized using extended primary terms
heuristic described Section 5. divergence critic generalizes transverse wave
rules means equality heuristic. heuristic attempts cancel equal outermost
functors possible. example, consider theorem,

8x; : (x + y) , x =
addition defined recursively second argument position subtraction
defined rewrite rules,

X ,0 = X
0,X = 0
s(X) , s(Y) = X , Y:
Spike's attempt prove theorem diverges generating (amongst others) goals,

(x + ) , x =
(s(x) + ) , x = s(y )
(s(s(x)) + ) , x = s(s(y ))
..
.
Divergence analysis identifies accumulating term structure within equations,
(x + ) , x =
( s(x) + ) , x = s(y)
( s(s(x)) + ) , x = s(s(y ))
..
.
unique maximal difference match. annotations suggest need
transverse rule,
( s(X ) + ) , X = (X + s(Y ) ) , X:
equality heuristic deletes equal outermost function, z : z , X . gives
general lemma,
s(X ) + = X + s(Y ) :
speculated lemmas filtered type checker ensure erasure
well typed. Speculated lemmas filtered conjecture disprover guard
over-generalization.
actions critic summarized Figure 3. specification preconditions
postconditions uses second order variables limited manner. implementation merely requires second order matching first order difference matching.
preconditions postconditions easily generalised include multiple nested
222

fiA Divergence Critic
qrev(a; b) = app(rev(a); b)
qrev(a; cons(c; b) ) = app( app(rev(a); cons(c; nil)) ; b)
qrev(a; cons(c; cons(d; b)) ) = app( app(app(rev(a); cons(c; nil)); cons(d; nil)) ; b)
..
.

unique maximal difference match. Rather move accumulating term
structure right hand side equations top term, much simpler
move accumulating term structure first onto second argument
outermost append. critic therefore proposes transverse wave rule, preserves
skeleton moves difference onto different argument position. example,
rule form,

app( app(rev(A); cons(C; nil)) ; B) = app(rev(A); F (B) ):
moving difference onto another argument position, difference may change syntactically. right hand side lemma therefore partially determined.
instantiate F , critic uses two heuristics: fertilization simplification.
fertilization heuristic uses matching find instantiation F enables
immediate fertilization. case, matching universally quantified variable b
induction hypothesis suggests,

app( app(rev(A); cons(C; nil)) ; B) = app(rev(A); cons(C; B) ):
Finally critic generalizes lemma using extended primary term heuristic
(i.e., augmenting recursive positions wave-hole positions). gives rule,

app( app(A; cons(C; nil)) ; B) = app(A; cons(C; B) ):
exactly rule needed Spike complete proof. addition, simple
enough proved without divergence; true ungeneralized rule.
heuristic used instantiate right hand side speculated lemma
simplification heuristic. heuristic uses regular matching find instantiation
F enable wave-front simplified using one recursive definitions.
Consider dbl theorem introduction. Divergence analysis identifies successor functions accumulating first argument position +. accumulating term
structure either moved top term tree alternatively onto second
argument position + using transverse wave rule form,

s(X ) + = X + F (Y ) :
right hand side transverse wave rule instantiated simplification heuristic.
wave-front right hand side simplified rewrite rule recursively
defining + F instantiated z : s(z ). is, rule,

s(X ) + = X + s(Y ) :
221

fiWalsh
f0; s(Y)g cover set natural numbers, two rules merged give,
sorted( insert(Y; X) ) = sorted(X):

6. Transverse Wave Rules
lemmas speculated far moved accumulating term structure directly top
term removed cancellation petering out. alternative way
removing accumulating term structure move onto another argument position where:
either removed matching \sink", universally quantified variable
induction hypothesis; moved upwards rewriting recursive
definitions. Annotated rewrite rules preserve skeleton move wave-fronts
across argument positions called transverse wave rules (Bundy et al., 1993).
Theorems involving functions accumulators provide rich source examples
rewrite rules prevent divergence.
Consider, example, theorem correctness tail recursive list reversal,

8a; b : qrev(a; b) = app(rev(a); b)
b universally quantified, rev naive list reversal using append,
qrev tail recursive list reversal building reversed list second argument position.
functions defined rewrite rules,
rev(nil)
rev(cons(H; T))
qrev(nil; R)
qrev(cons(H; T); R)

=
=
=
=

nil
app(rev(T); cons(H; nil))
R
qrev(T; cons(H; R)):

Spike's attempt prove theorem diverges generating following sequence equa-

tions prover attempts show induction,

qrev(a; b) = app(rev(a); b)
qrev(a; cons(c; b)) = app(app(rev(a); cons(c; nil)); b)
qrev(a; cons(c; cons(d; b))) = app(app(app(rev(a); cons(c; nil)); cons(d; nil)); b)
..
.

Difference matching identifies term structure accumulating within equations
causing divergence,
220

fiA Divergence Critic
s(0) + len(b) = s(len(b))
s(s(0)) + len(b) = s(s(len(b)))

..
.
Difference matching identifies term structure causing divergence,
0 + len(b) = len(b)
s(0) + len(b) = s(len(b))

s(s(0)) + len(b) = s(s(len(b)))

..
.
unique maximal difference match. annotations suggest need
wave rule,
s(0) + len(B) = s(0 + len(B)) :
set candidate terms generalization constructed computing intersection
primary terms two sides rule. case, primary terms left
hand side set fs(0) + len(B); len(B); Bg, primary terms right hand
side set fs(0 + len(B)); 0 + len(B); len(B); Bg. intersection primary terms
thus set flen(B); Bg. critic picks members intersection generalize new
variables. Picking B justs gives equivalent lemma renaming variables. Picking
len(B) gives generalization,
s(0) + = s(0 + Y) :
reason considering primary terms recursive definitions typically
provide wave rules removing term structure accumulates positions.
addition primary terms, divergence critic therefore considers positions
wave-holes (but wave-fronts) skeleton lemma speculated.
motivation extension speculated lemma allow accumulating term
structure moved wave-hole positions; positions therefore candidates generalization. Positions wave-fronts included since want
speculate lemma move term structure positions.
instance, wave-hole first argument + last example,
0 included intersection set candidate terms generalization. Picking 0
generalize gives,
s(X) + = s(X + Y) :
speculated lemma general possible. rule allows proof go
without divergence.
critic heuristic merging speculated lemmas. instance,
theorem sorted(isort(x)), critic speculates several rules including,
sorted( insert(0; X) ) = sorted(X)
sorted( insert(s(Y); X) ) = sorted(X)
219

fiWalsh

1. critic proposes rule form,

G( H (U0) ) = F (G(U0))
2. F instantiated cancellation petering
heuristics;
3. Lemmas filtered type checker conjecture disprover;
4. several lemmas suggested, critic deletes
subsumed.
Figure 2: Postconditions divergence critic

5. Generalization

major cause divergence need generalize. lemmas proposed
critic fix divergence, attempting prove lemmas cause
fresh divergence. addition, several speculated lemmas sometimes replaced
single generalization. Generalized lemmas lead shorter, elegant
natural proofs. critic therefore attempts generalize lemma speculated, using
conjecture disprover guard over-generalization.
main heuristic used generalization extension primary term heuristic
(Aubin, 1976). primary terms terms encountered term explored
root leaves ignoring non-recursive argument positions functions.
notion recursive argument position used critic defined Bouhoula
Rusinowitch (1995a) used Spike performing inductions.
Consider, example, theorem,

8a; b : len(a) + len(b) = len(app(a; b))
+ defined recursively second argument, len app defined
means rewrite rules,
len(nil)
len(cons(H; T))
app(nil; T)
app(cons(H; T); R)

=
=
=
=

0
s(len(T))

cons(H; app(T; R)):

problem taken Clam library corpus (Bundy et al., 1990). Spike's attempt
prove theorem diverges. One sequences equations generated is,
0 + len(b) = len(b)
218

fiA Divergence Critic
Spike's diverging attempt prove theorem generates equations,

nth(s(i); nth(j; x)) = nth(s(j ); nth(i; x))
nth(s(s(i)); nth(j; cons(y; x))) = nth(s(j ); nth(i; x))
nth(s(s(s(i))); nth(j; cons(z; cons(y; x)))) = nth(s(j ); nth(i; x))
..
.

Divergence analysis identifies term structure accumulating two different places,

nth(s(i); nth(j; x)) = nth(s(j ); nth(i; x))
nth( s(s(i)) ; nth(j; cons(y; x) )) = nth(s(j ); nth(i; x))
nth( s(s(s(i))) ; nth(j; cons(z; cons(y; x)) )) = nth(s(j ); nth(i; x))
..
.

unique maximal difference match. divergence pattern suggests need
rewrite rule form,

nth( s(I ) ; nth(J; cons(Y; X ) )) = F (nth(I; nth(J; X ))) :
petering heuristic instantiates F identity function z : z giving rule,

nth( s(I ) ; nth(J; cons(Y; X) )) = nth(I; nth(J; X )):
rule allows proof go without divergence.
Since erasure wave rule must properly typed, sort information used
prune inappropriate instantiations F . speculated lemmas therefore filtered
type checker. Speculated lemmas filtered conjecture disprover.
con uent set rewrite rules exists ground terms, exhaustive normalization
representative set ground instances equations used filter nontheorems. Alternatively, prover could used filter non-theorems. Unlike
many induction theorem provers, Spike refute conjectures since inference
rules refutationally complete conditional theories axioms ground
convergent defined functions completely defined free constructors (Bouhoula &
Rusinowitch, 1995a). techniques disproving conjectures described Protzen
(1992).
critic's lemma speculation summarized Figure 2 (using variable
names preconditions). specification uses second order variables
limited manner. First order difference matching merely required construct lemmas.
preconditions, specification postconditions easily extended
deal multiple nested wave-fronts (as nth(i; nth(j; l)) = nth(j; nth(i; l))
example). Since rules proposed critic move wave-fronts top term,
usually introduce fresh divergence rare cases cancellation fertilization
fails. unlikely since cancellation petering heuristics attempt ensure
precisely cancellation fertilization take place.
217

fiWalsh
divergence pattern suggests F instantiated z : s(z) enable immediate cancellation. Thus, required, cancellation heuristic suggests rule,
s(X ) + = s(X + ) :
heuristic used instantiate right hand side speculated lemmas
petering out. moving differences top term, may disappear
altogether. Consider, example, theorem,
8l : sorted(isort(l)) = true
isort insertion sort sorted true iff list sorted order. defined
conditional rewrite rules,
sorted(nil) = true
sorted(cons(X; nil)) = true
X < ! sorted(cons(X; cons(Y; Z ))) = sorted(cons(Y; Z ))
isort(nil) = nil
isort(cons(X; )) = insert(X; isort(Y ))
insert(X; Z ), inserts element X list Z order, X <
defined rewrite rules,
0 < X = true
s(X ) < 0 = false
s(X ) < s(Y ) = X <
insert(X; nil) = cons(X; nil)
X < ! insert(X; cons(Y; Z )) = cons(X; cons(Y; Z ))
:(X < ) ! insert(X; cons(Y; Z )) = cons(Y; insert(X; Z ))
Divergence analysis Spike's attempt prove theorem suggests need
rule form,
sorted( insert(Y; X) ) = F (sorted(X) :
petering heuristic instantiates F identity function z : z. gives rule,
sorted( insert(Y; X) ) = sorted(X):
rule allows proof go without divergence.
complex example, consider theorem,
8i; j; l : nth(i; nth(j; l)) = nth(j; nth(i; l))
nth defined rewrite rules,
nth(0; L) = L
nth(N; nil) = nil
nth(s(N ); cons(H; )) = nth(N; ):
216

fiA Divergence Critic
nested annotations. allows critic recognise multiple sources divergence
equation. Techniques identify accumulating term structure specific
generalization (Dershowitz & Pinchover, 1990) cannot cope divergence patterns
give rise nested annotations (see Section 9 details).
specification preconditions left length sequence undefined.
sequence length 2, critic preemptive. is, propose lemma
another induction attempted divergence begins. short sequence risks
identifying divergence none exists. hand using long sequence expensive test allows prover waste time diverging proof attempts. Empirically,
good compromise appears look sequences length 3. cheap
test reliable. identify accumulating term structure, appears sucient
use ground difference matching alpha conversion variable names. exists
fast polynomial algorithm perform difference matching based upon ground
difference matching algorithm using dynamic programming (Basin & Walsh, 1993). Since
skeleton must well typed (along erasure), algorithm extended use
sort information prune potential difference matches.

4. Lemma Speculation
One way removing accumulating nested term structure propose wave rule
moves difference top term leaving skeleton unchanged. hope
either cancel wave-fronts side equality
disappear process moved. dbl theorem, generalization
(which discussed next section) divergence pattern suggests rule form,

s(X ) + = F (X + )
F second order variable need instantiate. Instantiating F ultimately dicult synthesis problem hope heuristics work
time. Two heuristics used divergence critic instantiate F
cancellation petering out.
cancellation heuristic uses difference matching identify term structure accumulating opposite side sequence would allow cancellation occur. Failing
that, cancellation heuristic looks suitable term structure cancel new
sequence (the original sequence usually divergence pattern step case, whilst
new sequence usually divergence pattern base case). dbl example, successor
functions accumulate top left hand side diverging equations,

s(x + x) = s(x) + x
s(s(x + x)) = s(s(x)) + x
s(s(s(x + x))) = s(s(s(x))) + x
..
.

215

fiWalsh
critic attempts find accumulating nested term structure
sequence causing divergence. case, successor functions accumulating
first argument +. identify accumulating term structure, critic uses
difference matching. Difference matching successive equations gives annotated sequence,

s(x + x) = s(x) + x
s(s(x + x)) = s(s(x)) + x
s(s(s(x + x))) = s(s(s(x))) + x
..
.

unique maximal difference match.
critic tries speculate lemma used rewrite rule move
accumulating nested term structure way. case, critic speculates
rule moving successor function first argument +. is, rule,

s(X ) + = s(X + ) :
rule, Spike able prove dbl theorem without divergence. addition,
rule suciently simple proved without assistance. heuristics used
critic perform lemma speculation described detail next two
sections.
divergence analysis performed critic summarised Figure 1. analysing
1. sequence equations si = ti
prover attempts prove induction (i = 0, 1 ...);
2. exists (non trivial) G; H j ,
maximal difference match sj = G(Uj ), sj +1 =
G( H (Uj ) ).
Figure 1: Preconditions divergence critic
divergence, consider equations prover attempts prove induction. includes equation induction proof succeeds often
suggest useful patterns. \non-trivial" wish exclude z : z, identity substitution. H thus accumulating nested term structure appears causing
divergence. dbl example, H z : s(z), G z : z + x, U0 s(x). Although
G H second order variables, second order nature divergence analysis
limited. Indeed, implementation critic merely requires first order difference
matching polynomial. simplicity, preconditions ignore orientation
equations. addition, preconditions easily generalised include multiple
214

fiA Divergence Critic
Rippling several desirable properties. highly goal directed, manipulating
differences induction hypothesis induction conclusion.
annotations restrict application rewrite rules, rippling involves little
search. Difference matching rippling proved useful domains outside explicit
induction. example, used sum series (Walsh, Nunes, & Bundy, 1992)
prove limit theorems (Yoshida, Bundy, Green, Walsh, & Basin, 1994). rest
paper, show difference matching rippling useful identifying
correcting divergence prover neither uses explicit rules induction uses
annotations control rewriting.

3. Divergence Analysis

initial problem recognizing proof diverging. Various properties rewrite
rules identified cause divergence like, example, forwards backwards
crossed systems (Hermann, 1989). However, properties fail capture diverging
rewrite systems since problem is, general, undecidable. divergence critic instead
studies proof attempt looking patterns divergence; attempt made analyse
rewrite rules structures give rise divergence. advantage
approach critic need know details rewrite rules applied,
type induction performed, control structure used prover. critic
thus recognise divergence patterns arising complex mutual multiple inductions
little diculty divergence patterns arising simple straightforward
inductions. disadvantage approach critic identify \divergence"
pattern none exists. Fortunately, cases appear rare, even
occur, critic usually suggests lemma generalization gives shorter
elegant proof (see Section 8 example).
illustrate ideas behind critic's divergence analysis, consider theorem
introduction,
8n : dbl(n) = n + n:
divergence critic first partitions sequence equations prover attempts
prove induction. necessary since several diverging sequences may interleaved
prover's output. Several heuristics used reduce number partitions
considered. useful heuristic parentage sequence partitioned
equation derived previous one. is, equations lie
single branch proof tree. particular, base case step case induction
partitioned different sequences. heuristics used include:
function constant symbols occur one equation occur next equation
partition, weights equations partition form simple arithmetic
progression. case, single open branch proof tree,
s(x + x) = s(x) + x
s(s(x + x)) = s(s(x)) + x
s(s(s(x + x))) = s(s(s(x))) + x
..
.
213

fiWalsh
annotated term r. Difference matching unitary. is, two terms
one difference match. example, s(s(x)) s( s(x) ) difference matches
s(s(x)) s(x). number difference matches reduced compute
maximal difference match wave-fronts high possible term tree.
formal definition well founded ordering annotated terms given
Basin Walsh (1994).
aim rippling rewrite annotated induction conclusion skeleton,
induction hypothesis, preserved differences, wave-fronts moved
harmless places (for example, top term). rewriting succeeds,
able appeal induction hypothesis. rewrite annotated induction
conclusion, use following annotated rewrite rules, wave rules:

dbl( s(X ) ) = s(s(dbl(X )))
X + s(Y ) = s(X + )
s(X ) + = s(X + )

(1)
(2)
(3)

first two annotated rewrite rules derived recursive definitions dbl
+ whilst second derived lemma proposed end introduction.
annotated rewrite rules preserves skeleton term rewritten,
moves wave-fronts higher term tree. Wave rules guarantee this: wave rule
annotated rewrite rule identical skeleton left right hand sides
moves wave-fronts well founded direction like, instance, top term tree
(Basin & Walsh, 1994).
Rippling left hand side annotated induction conclusion using (1) yields,

s(s(dbl(x))) = s(x) + s(x) :
rippling right hand side (2) gives,

s(s(dbl(x))) = s( s(x) + x) :
Finally rippling (3) right hand side yields,

s(s(dbl(x))) = s(s(x + x)) :
wave-fronts top term, successfully rippled sides
equality. appeal induction hypothesis left hand side giving,

s(s(x + x)) = s(s(x + x)) :
simple identity proof complete. Note complete proof,
needed rewrite lemma, (3). aim divergence critic described
paper propose lemmas.
212

fiA Divergence Critic
Section 2, describe difference matching rippling, two key ideas heart
divergence critic. outline difference matching identifies accumulating
term structure causing divergence (Section 3). Section 4 6, show
lemmas speculated \ripple" term structure way. Section 5,
describe heuristics used generalizing lemmas. Finally, implementation
results described Sections 7 8.

2. Difference matching rippling

Rippling powerful heuristic developed Edinburgh proving theorems involving
explicit induction (Bundy, Stevens, van Harmelen, Ireland, & Smaill, 1993) implemented Clam theorem prover (Bundy, van Harmelen, Horn, & Smaill, 1990).
step case inductive proof, induction conclusion typically differs induction
hypothesis addition constructors destructors. Rippling uses annotations
mark differences applies annotated rewrite rules remove them.
simple example, consider theorem discussed introduction.
step case, induction hypothesis is,

dbl(x) = x + x
induction conclusion is,

dbl(s(x)) = s(x) + s(x):
\difference match" induction conclusion induction hypothesis (Basin
& Walsh, 1992), obtain following annotated induction conclusion,

dbl( s(x) ) = s(x) + s(x) :
annotation consists wave-front, box wave-hole, underlined term. Wavefronts always one functor thick (Basin & Walsh, 1994). is, every wave-front
one immediate subterm annotated wave-hole. make presentation simpler,
display adjacent wave-fronts merged. Thus, s(s(x)) syntactic sugar
annotated term, s( s(x) ) . Wave-fronts include arrows indicate
whether moving towards top term tree towards leaves.
extension can, however, safely ignored here.
skeleton annotated term formed deleting everything appears
wave-front wave-hole. erasure annotated terms formed
deleting annotations terms contain. case, skeleton
annotated induction conclusion identical induction hypothesis, erasure
annotated induction conclusion unannotated induction conclusion. Difference
matching guarantees this; is, difference matching induction conclusion
induction hypothesis annotates induction conclusion skeleton matches
induction hypothesis.
Formally, r difference match substitution iff (skeleton(r)) =
erase(r) = skeleton(r) erase(r) build skeleton erasure
211

fiWalsh
alpha convert variable names necessary. Rewriting induction conclusion
recursive definitions dbl + gives,

s(s(dbl(x))) = s(s(x) + x):
outermost successor functions either side equality cancelled,

s(dbl(x)) = s(x) + x:
prover fertilizes induction hypothesis left hand side,

s(x + x) = s(x) + x:
equation cannot simplified another induction performed. Unfortunately,
generates diverging sequence subgoals,

s(x + x)
s(s(x + x))
s(s(s(x + x)))
s(s(s(s(x + x))))
s(s(s(s(s(x + x)))))

=
=
=
=
=
..
.

s(x) + x
s(s(x)) + x
s(s(s(x))) + x
s(s(s(s(x)))) + x
s(s(s(s(s(x))))) + x

problem prover repeatedly tries induction x unable simplify
successor functions introduces first argument position +. proof
go without divergence rewrite rule,

s(X ) + = s(X + ):
rule \ripples" accumulating successor functions first argument position +.
rewrite rule derived lemma,

8x; : s(x) + = s(x + y):
commuted version recursive definition addition is, coincidently,
generalization first subgoal. lemma proved without divergence
induction variable, occurs second argument position +.
paper describe simple \divergence critic", computer program attempts
automate process. divergence critic identifies proof attempt diverging
means \difference matching" procedure. critic proposes lemmas
generalizations hopefully allow proof go without divergence. Although
critic designed work prover Spike, work induction
provers (Walsh, 1994). Spike rewrite based theorem prover first order conditional
theories. contains powerful rules case analysis, simplification implicit induction
using notion test set. Unfortunately, case inductive theorem
provers, attempts prove many theorems diverge without appropriate generalization
addition suitable lemma.
210

fiJournal Artificial Intelligence Research 4 (1996) 209-235

Submitted 1/96; published 4/96

Divergence Critic Inductive Proof
toby@itc.it

Toby Walsh

IRST, Location Pante di Povo
I38100 Trento, ITALY

Abstract

Inductive theorem provers often diverge. paper describes simple critic, computer program monitors construction inductive proofs attempting identify
diverging proof attempts. Divergence recognized means \difference matching"
procedure. critic proposes lemmas generalizations \ripple" differences away proof go without divergence. critic enables
theorem prover Spike prove many theorems completely automatically definitions alone.

1. Introduction

Two key problems inductive theorem proving proposing lemmas generalizations.
prover's divergence often suggests user appropriate lemma generalization
enable proof go without divergence. simple example, consider
theorem,

8n : dbl(n) = n + n:
part simple program verification problem (Dershowitz & Pinchover, 1990).
Addition doubling defined recursively means rewrite rules,

X+0 = X
X + s(Y ) = s(X + )
dbl(0) = 0
dbl(s(X )) = s(s(dbl(X )))
s(X ) represents successor X (that is, X + 1). adopted Prolog
convention writing meta-variables X upper case.

theorem prover Spike (Bouhoula, Kounalis, & Rusinowitch, 1992) fails prove
theorem. proof attempt begins simple one step induction x. base
case trivial. step case, induction hypothesis is,
dbl(x) = x + x
induction conclusion is,

dbl(s(x)) = s(x) + s(x):
ease presentation, variables paper are, here, sometimes renamed
introduced Spike. effect results prover divergence critic

c 1996 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.


