journal artificial intelligence

submitted published

design experimental analysis
temporal reasoning
peter van beek
dennis w manchak

department computing science university alberta
edmonton alberta canada g h

vanbeek cs ualberta ca
dmanchak vnet ibm com

abstract

many applications scheduling molecular biology
rely heavily temporal reasoning component discuss design
empirical analysis temporal reasoning system allen uential
interval framework representing temporal information core system
determining whether temporal information consistent
finding one scenarios consistent temporal information two
important tasks path consistency backtracking
path consistency develop techniques
ten fold speedup already highly optimized implementation
backtracking develop variable value ordering heuristics shown
empirically dramatically improve performance well
previously suggested reformulation backtracking search reduce
time space requirements backtracking search taken together techniques
develop allow temporal reasoning component solve practical
size

introduction
temporal reasoning essential part many artificial intelligence tasks desirable
therefore develop temporal reasoning component useful across applications
applications scheduling rely heavily temporal reasoning component success application depend eciency
underlying temporal reasoning component discuss design empirical analysis two temporal reasoning system allen
uential interval framework representing temporal information two path consistency backtracking important two
fundamental tasks determining whether temporal information consistent
finding one scenarios consistent temporal information
stress designing robust ecient practice
path consistency develop techniques ten fold
speedup already highly optimized implementation backtracking
develop variable value ordering heuristics shown empirically dramatically
improve performance well previously suggested
reformulation backtracking search van beek reduce time
space requirements backtracking search taken together techniques develop
c ai access foundation morgan kaufmann publishers rights reserved

fivan beek manchak

relation
symbol inverse
x
b
bi
x meets

mi
x overlaps

oi
x starts



si

x



di

x finishes

f



x equal

eq

eq

meaning
x

x

x

x

x

x

x


figure basic relations intervals
allow temporal reasoning component solve realistic size part
evidence support claim evaluate techniques improving
large arises molecular biology

representing temporal information
section review allen framework representing relations intervals discuss set chosen test

allen framework

thirteen basic relations hold two intervals see figure allen
bruce order represent indefinite information relation two
intervals allowed disjunction basic relations sets used list
disjunctions example relation fm sg events b represents
disjunction meets b overlaps b starts b let set basic
relations fb bi mi oi si di f eqg allen allows relation two events
subset
use graphical notation vertices represent events directed edges
labeled sets basic relations graphical convention never edges
edge j edge j edge
explicit knowledge relation labeled convention edges
shown call networks labels arbitrary subsets interval
algebra ia networks
example allen koomen ia networks used non linear
concurrent actions example representing temporal information
ia networks consider following blocks world three blocks
b c initial state three blocks table goal state


fialgorithms temporal reasoning

simply tower blocks b b c associate states actions
properties intervals hold immediately write
following temporal information
initial conditions
goal conditions
initial fdg clear
goal fdg b
initial fdg clear b
goal fdg b c
initial fdg clear c
action called stack effect stack action x block x
top block action successfully executed conditions clear x
clear must hold neither block x block block introduces
two stacking actions following temporal constraints
stacking action
stacking action
stack b fbi mig initial
stack b c fbi mig initial
stack b fdg clear
stack b c fdg clear b
stack b ffg clear b
stack b c ffg clear c
stack b fmg b
stack b c fmg b c
graphical representation ia network shown
figure two fundamental tasks determining whether temporal information
consistent finding one scenarios consistent temporal
information ia network consistent exists mapping
real interval u event vertex u network relations events satisfied e one disjuncts satisfied example consider
small subnetwork figure consisting events b b c goal
subnetwork consistent demonstrated assignment b
b c goal change subnetwork insist
b must b c mapping would exist subnetwork
would inconsistent consistent scenario ia network non disjunctive subnetwork e every edge labeled single basic relation consistent
example finding consistent scenario network corresponds finding
ordering actions accomplish goal stacking three blocks one
consistent scenario reconstructed qualitative mapping shown figure b
example golumbic shamir discuss ia networks used
molecular biology examining structure dna organism benzer intervals ia network represent segments dna experiments
performed determine whether pair segments disjoint intersects
thus ia networks contain edges labeled disjoint fb big intersects
fm mi oi si di f eqg set basic relations indicates experiment performed ia network consistent evidence hypothesis
dna linear structure inconsistent dna nonlinear forms loops
example golumbic shamir determining consistency restricted version ia networks np complete arise
application often solved quickly practice


fivan beek manchak

























r









pp

hyhhphpppppq j
jj
hh
hhh
jj
z
zzj
hhh z
hh


ia network block stacking example

fbi mig
fdg

fdg


initial

fdg

fbi mig

fdg


clear

clear b

clear c


stack b
ffg

fdg

ffg

fmg


b

b c

fmg

pip
pp

fdg
fdg


goal


stack b c

b consistent scenario
initial

stack b c
goal
stack b
clear c
b c
clear b
b
clear

figure representing qualitative relations intervals

test
tested well heuristics developed improving path consistency backtracking perform test suite
purpose empirically testing determine performance
proposed improvements typical two
approaches collect set benchmark representative
arise practice ii randomly generate investigate algorithmic
performance depends characteristics learn predict
perform given class hooker
ia networks existing collection large benchmark actually
arise practice opposed example toy domain blocks
world start collection propose ia network intervals arose
molecular biology benzer pp see example
proposed benchmark strictly speaking temporal reasoning


fialgorithms temporal reasoning

intervals represent segments dna intervals time nevertheless
formulated temporal reasoning value benchmark
arose real application refer benzer matrix
addition benchmark use two random ia
network denoted b n n p evaluate performance n
number intervals p probability non trivial constraint two
intervals model b n intended model arise molecular biology
estimated discussed benzer model n p allows us study
performance depends important characteristic sparseness
underlying constraint graph course allow us study
performance depends size
b n random instances generated follows
step generate solution size n follows generate n real intervals randomly
generating values end points intervals determine ia network determining pair intervals whether two intervals intersect disjoint
step change constraints edges trivial constraint setting
label set basic relations represents case experiment
performed determine whether pair dna segments intersect disjoint
constraints changed percentage non trivial constraints approximately
intersects disjoint distribution graph similar
benzer matrix
n p random instances generated follows
step generate underlying constraint graph indicating possible n
edges present let edge present probability p independently presence
absence edges
step edge occurs underlying constraint graph randomly chose label
edge set possible labels excluding empty label label
chosen equal probability edge occur label edge set
basic relations
step generate solution size n follows generate n real intervals randomly
generating values end points intervals determine consistent scenario
determining basic relations satisfied intervals finally add solution
ia network generated steps
hence consistent ia networks generated n p omit step
shown analytically empirically almost different possible
ia networks generated distribution inconsistent inconsistency
easily detected path consistency avoid potential pitfall test
consistent instances method appears generate
reasonable test set temporal reasoning range easy
hard found example instances drawn n hard
backtracking solve whereas values p side n
n easier


fivan beek manchak

path consistency
path consistency transitive closure aho hopcroft ullman mackworth montanari important temporal reasoning allen shows
path consistency used heuristic test whether ia network
consistent sometimes report information consistent
really path consistency useful backtracking search
consistent scenario used preprocessing mackworth
ladkin reinefeld interleaved backtracking search see next section nadel ladkin reinefeld section
examine methods speeding path consistency
idea behind path consistency following choose three
vertices j k network labels edges j j k potentially
constrain label edge k completes triangle example consider
three vertices stack b b goal figure stack b fmg
b b fdig goal deduce stack b fbg goal therefore
change label edge set basic relations singleton
set fbg perform deduction uses operations set intersection
composition labels checks whether c c c c c
label edge k c updated may constrain labels k
added list processed turn provided edge already list
iterates changes possible unary operation inverse
used inverse label inverse elements
see figure inverses basic relations
designed experimentally evaluated techniques improving eciency
path consistency starting point variation allen
shown figure implementation ecient intersection
composition operations labels must ecient steps intersection
made ecient implementing labels bit vectors intersection two labels
simply logical two integers composition harder make ecient
unfortunately impractical implement composition two labels table
lookup table would need size possible labels
experimentally compared two practical methods composition
proposed literature allen gives method composition uses table
size table gives composition basic relations see allen
table composition two labels computed nested loop forms
union pairwise composition basic relations labels hogge gives
method composition uses four tables size
composition two labels computed taking union four array
references h kautz independently devised similar scheme experiments
implementations two methods differed composition computed
list l edges processed implemented first first policy
e stack
experimentally evaluated methods reducing number composition operations need performed one idea examined improving eciency
ik

ik



ik

ij

jk

ik

fialgorithms temporal reasoning

c n

path consistency

l f j j j ng
l empty
select delete j l

k n k k j

c c c

c

c

c
inverse

l
l f k g


c
c
c

c

c

c
inverse

l
l f k j g
ik

ij

jk

ki

ij

ik

ik

ki

kj

kj

kj

jk

figure path consistency ia networks
avoid computation predicted constrain
label edge completes triangle three cases identified shown
figure another idea examined first suggested mackworth p
order edges processed affect eciency
reason following edge appear list l edges processed
many times progressively gets constrained number times particular edge
appears list reduced good ordering example consider edges
figure process edge first edge updated
fo oi si di f eqg added l k steps process edge
edge updated fo dg added l second time however
process edge first immediately updated fo dg
added l
three heuristics devised ordering edges shown figure edges
assigned heuristic value processed ascending order edge
added list steps edge inserted appropriate spot according
heuristic value little work ordering heuristics path consistency
wallace freuder discuss ordering heuristics arc consistency
closely related path consistency two heuristics
cannot applied context heuristics assume constraint satisfaction
finite domains whereas ia networks examples constraint satisfaction
infinite domains third heuristic due b nudel closely corresponds
cardinality heuristic
experiments performed sun megabytes memory
report timings rather measure number iterations believe
gives accurate picture whether practical interest care


fivan beek manchak

computation c c c skipped known
composition constrain label edge k
c c equal composition therefore
constrain label edge k thus step figure edges
labeled added list edges process
b condition
ik

ij

ij

jk

jk

b c

ij

bi c bi c

ij

jk

b c c
jk

ij

di c
jk

true composing c c condition quickly tested
bit operations thus condition true step steps
skipped similar condition formulated tested step
c point computation c c determined
accumulated far would constrain label c rest computation
skipped
ij

jk

ij

jk

ik

figure skipping techniques
taken start base implementation add
enough code implement composition method technique heuristic
evaluating well every attempt made implement method heuristic
eciently could
given implementations hogge method composition found
ecient allen method benchmark random instances
see figures much surprising however addition skipping
techniques two methods became close eciency skipping techniques sometimes
dramatically improved eciency methods ordering heuristics improve
eciency although less dramatic cardinality heuristic
constraintedness heuristic tried ordering edges found
cardinality heuristic costly compute weight heuristic
perform constraintedness heuristic reduced number iterations proved
costly compute illustrates balance must struck effectiveness
heuristic additional overhead heuristic introduces
n p skipping techniques weight ordering heuristic together
ten fold speedup already highly optimized implementation hogge
method composition largest improvements eciency occur ia networks
sparse p smaller encouraging appears arise
molecular biology sparse b n benzer matrix speedup
approximately four fold perhaps importantly execution times reported indicate
path consistency even though n used
practical sized figure well scale


fialgorithms temporal reasoning

allen



hogge



allen skip



hogge skip



hogge skip weight



figure effect heuristics time sec path consistency applied
benzer matrix

time sec







allen
hogge
allen skip
hogge skip
hogge skip weight







n





figure effect heuristics average time sec path consistency
data point average tests random instances ia networks drawn
b n coecient variation standard deviation average set
tests bounded
seen includes weight ordering heuristic performs others
however requires much space largest able solve
intervals included skipping techniques
able solve much larger running space intervals
constraint time took solve



fivan beek manchak



time sec





allen
hogge
allen skip
hogge skip
hogge skip weight







p





figure effect heuristics average time sec path consistency
data point average tests random instances ia networks drawn
p coecient variation standard deviation average
set tests bounded


n

allen skip
hogge skip
hogge skip weight



time sec



b n

allen skip
hogge skip
hogge skip weight


















n









figure effect heuristics average time sec path consistency
data point average tests random instances ia networks drawn
n b n coecient variation standard deviation average set tests bounded


fialgorithms temporal reasoning

backtracking

allen first propose backtracking golomb baumert
could used consistent scenario ia network worst case
backtracking take exponential amount time complete worst
case applies vilain kautz finding consistent
scenario np complete ia networks spite worst case estimate backtracking
work well practice section examine methods speeding
backtracking finding consistent scenario present well
performs different classes particular compare eciency
two alternative formulations one previously
proposed others one proposed van beek improve
eciency designing heuristics ordering instantiation
variables ordering values domains variables
starting point modeled backtracking ladkin
reinefeld experimentation suggests successful
finding consistent scenarios quickly following ladkin reinefeld
following characteristics preprocessing path consistency static order
instantiation variables chronological backtracking forward checking pruning
path consistency chronological backtracking search reaches
dead end search simply backs next recently instantiated variable
tries different instantiation forward checking haralick elliott technique
determined recorded instantiation current variable restricts
possible instantiations future variables technique viewed hybrid
tree search consistency see nadel nudel see dechter
general survey backtracking

alternative formulations

let c matrix representation ia network c label edge j
traditional method finding consistent scenario ia network search
subnetwork network c
c
b js j j
c consistent
consistent scenario simply search different possible satisfy
conditions b simple matter enumerate one
satisfies condition c allen first propose backtracking search
search potential
alternative formulation two restricted classes ia networks
denoted sa networks nb networks ia networks relation two
intervals subset set thirteen basic relations sa networks
vilain kautz allowed relations two intervals subsets
translated relations f g conjunctions
ij

ij

ij

ij



fivan beek manchak

relations endpoints intervals example ia network figure
sa network specific example interval relation fbi mig b
expressed conjunction point relations b b b
represent start end points interval respectively see ladkin
maddux van beek cohen enumeration allowed relations
sa networks nb networks nebel burckert allowed relations
two intervals subsets translated relations f
g conjunctions horn clauses express relations
endpoints intervals set nb relations strict superset sa relations
alternative formulation follows describe method terms sa
networks method applies nb networks idea rather
search directly consistent scenario ia network previous work first
search something general consistent sa subnetwork ia network
use backtrack search subnetwork network c


sij cij

b

sij

c





allowed relation sa networks j

consistent

previous work search alternative singleton labelings edge e
js j key idea proposal decompose labels largest
possible sets basic relations allowed sa networks search
decompositions considerably reduce size search space example
suppose label edge fb bi oi sig six possible ways label
edge singleton label fbg fbig fmg fog foig fsig two possible ways
label edge decompose labels largest possible sets basic relations
allowed sa networks fb og fbi oi sig another example consider
network shown figure searching alternative singleton labelings
worst case size search space c c c edges labeled
must included calculation decomposing labels largest
possible sets basic relations allowed sa networks searching
decompositions size search space backtracking necessary general
search course backtrack free
test whether instantiation variable consistent instantiations past
variables possible instantiations future variables use incremental path
consistency step figure instead initializing l edges
initialized single edge changed backtracking
consistent sa subnetwork ia network report ia network inconsistent
backtracking completes solution sa network found fast
given van beek
ij

ordering heuristics

backtracking proceeds progressively instantiating variables consistent instantiation
exists current variable search backs order variables


fialgorithms temporal reasoning

weight weight heuristic estimate much label edge restrict
labels edges restrictiveness measured basic relation successively composing basic relation every possible label summing cardinalities
suitably scaled give table shown
relation b bi mi oi si di f eq
weight
weight label sum weights elements example weight
relation fm sg
cardinality cardinality heuristic variation weight heuristic
weight every basic relation set one
constraint constraintedness heuristic estimate much change label
edge restrict labels edges determined follows suppose
edge interested j constraintedness label edge j
sum weights labels edges k j k k n k k j
intuition comes examining path consistency figure would
propagate change label c see c composed c step
c step k n k k j
ij

ij

ki

jk

figure ordering heuristics
instantiated order values domains tried possible
instantiations greatly affect performance backtracking
methods ordering variables e g bitner reingold freuder nudel
ordering values e g dechter pearl ginsberg et al haralick
elliott proposed
idea behind variable ordering heuristics instantiate variables first
constrain instantiation variables backtracking search
attempts solve highly constrained part network first three heuristics
devised ordering variables edges ia network shown figure
alternative formulation cardinality redefined count decompositions rather
elements label variables put ascending order experiments
ordering static determined backtracking search starts
change search progresses context cardinality heuristic similar
heuristic proposed bitner reingold studied purdom
idea behind value ordering heuristics order values domains
variables values likely lead solution tried first generally
done putting values first constrain choices variables least
propose novel technique value ordering knowledge structure
solutions idea first choose small set class
consistent scenario instance without value ordering
set solutions examine solutions determine values domains


fivan beek manchak





si

sa

time sec















n





figure effect decomposition method average time sec backtracking data point average tests random instances ia
networks drawn b n coecient variation standard deviation
average set tests bounded
likely appear solution values least likely information
used order values subsequent searches solutions
class example five generated model
consistent scenarios found backtracking search variable ordering
heuristic constraintedness weight cardinality rounding two significant digits
relations occurred solutions following frequency
relation
b bi di oi
value

eq


mi f si



example information order values domain suppose
label edge fb bi oi sig decomposing labels singleton labels
would order values domain follows preferred first fbg fbig fog
foig fmg fsig decomposing labels largest possible sets basic
relations allowed sa networks would order values domain
follows fb og fbi oi sig since technique
used whenever something known structure solutions

experiments

experiments performed sun megabytes memory
first set experiments summarized figure examined effect
formulation execution time backtracking implemented three


fialgorithms temporal reasoning


random value ordering random
heuristic value ordering random
random value ordering best heuristic
heuristic value ordering best heuristic

variable
variable
variable
variable

ordering
ordering
ordering
ordering

time

















test











figure effect variable value ordering heuristics time sec backtracking
curve represents tests random instances ia networks
drawn tests ordered time taken solve
instance backtracking used sa decomposition method
versions identical except one searched singleton
labelings denoted hereafter figure si method two searched
decompositions labels largest possible allowed relations sa networks nb networks respectively methods solved set random
drawn b n applied benzer matrix denoted
figure amount time required solve given ia network recorded mentioned earlier ia network preprocessed path
consistency backtracking search timings include preprocessing
time experiments indicate speedup sa decomposition method
three fold si method well sa decomposition method
able solve larger running space n versus n
nb decomposition method gives exactly sa method
structure constraints tested three methods
set random drawn p p
experiments sa nb methods consistently twice fast si method
well nb method showed advantage sa method
surprising branching factor hence size search space smaller
nb method sa method
second set experiments summarized figure examined effect
execution time backtracking heuristically ordering variables
values domains variables backtracking search begins variable
ordering six permutations cardinality constraint weight heuristics tried


fivan beek manchak

primary secondary tertiary sorting keys respectively basis comparison
experiments included case heuristics figure shows approximate cumulative
frequency curves experimental thus example read
curve representing heuristic value ordering best heuristic variable ordering
approximately tests completed within seconds whereas random value
variable ordering approximately tests completed within seconds
read curves percentiles data sets
value median th percentile value th test curves
truncated time hour backtracking search aborted
time limit exceeded
experiments found represents particularly dicult class
different heuristics resulted dramatically different performance heuristic case different heuristics
value ordering best heuristic variable ordering combination constraintedness weight cardinality constraintedness primary sorting key
remaining keys used break subsequent ties somewhat surprisingly best heuristic
variable ordering changes heuristic value ordering incorporated combination weight constraintedness cardinality works much better heuristic together
value ordering particularly effective attening distribution allowing much greater number solved reasonable amount time
p p much easier three
hundreds tests completed within seconds heuristic used
significantly different performance
summary experiments indicate changing decomposition method
able solve larger running space n vs n
machine megabytes see figure experiments indicate good heuristic
orderings essential able consistent scenario ia network
reasonable time good heuristic ordering able solve much larger
running time see figure experiments provide additional evidence
ecacy ladkin reinefeld nevertheless even
improvements still took considerable amount time solve
consideration surprising known np complete

conclusions
temporal reasoning essential part tasks scheduling discussed design empirical analysis two key temporal
reasoning system path consistency backtracking temporal reasoning system allen interval framework
representing temporal information emphasis make
robust ecient practice vary easy hard path consistency bottleneck performing composition operation developed
methods reducing number composition operations need performed
methods almost order magnitude speedup already highly
optimized implementation backtracking developed


fialgorithms temporal reasoning

variable value ordering heuristics showed alternative formulation
considerably reduce time taken solution techniques allow
interval temporal reasoning system applied larger perform
eciently existing applications

references

aho v hopcroft j e ullman j design analysis computer
addison wesley
allen j f maintaining knowledge temporal intervals comm acm

allen j f koomen j temporal world model proceedings
eighth international joint conference artificial intelligence pp
karlsruhe west germany
benzer topology genetic fine structure proc nat acad sci usa

bitner j r reingold e backtrack programming techniques comm acm

bruce b c model temporal references application question
answering program artificial intelligence
dechter r local global consistency artificial intelligence
dechter r pearl j network heuristics constraint satisfaction artificial intelligence
freuder e c sucient condition backtrack free search j acm
ginsberg l frank halpin p torrance c search lessons learned
crossword puzzles proceedings eighth national conference artificial
intelligence pp boston mass
golomb baumert l backtrack programming j acm
golumbic c shamir r complexity reasoning
time graph theoretic j acm
haralick r elliott g l increasing tree search eciency constraint
satisfaction artificial intelligence
hogge j c tplan temporal interval planner novel extensions department computer science technical report uiucdcs r university illinois
hooker j n needed empirical science operations



fivan beek manchak

ladkin p reinefeld effective solution qualitative interval constraint
artificial intelligence
ladkin p reinefeld symbolic interval constraint
calmet j campbell j eds artificial intelligence symbolic mathematical
computing springer lecture notes computer science springer verlag
ladkin p b maddux r binary constraint networks technical report
kestrel institute palo alto calif
mackworth k consistency networks relations artificial intelligence

montanari u networks constraints fundamental properties applications
picture processing inform sci
nadel b constraint satisfaction computational intelligence

nebel b burckert h j reasoning temporal relations maximal
tractable subclass allen interval algebra j acm
nudel b consistent labeling expected complexities
theory heuristics artificial intelligence
purdom jr p w search rearrangement backtracking polynomial average
time artificial intelligence
van beek p reasoning qualitative temporal information artificial intelligence
van beek p cohen r exact approximate reasoning temporal
relations computational intelligence
vilain kautz h constraint propagation temporal reasoning
proceedings fifth national conference artificial intelligence pp
philadelphia pa
vilain kautz h van beek p constraint propagation
temporal reasoning revised report weld de kleer j eds readings
qualitative reasoning physical systems pp morgan kaufmann
wallace r j freuder e c ordering heuristics arc consistency
proceedings ninth canadian conference artificial intelligence pp
vancouver b c




