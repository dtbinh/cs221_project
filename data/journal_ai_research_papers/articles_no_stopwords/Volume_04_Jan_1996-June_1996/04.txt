Journal Artificial Intelligence Research 4 (1996) 419-443

Submitted 2/96; published 6 /96

Principled Approach Towards Symbolic
Geometric Constraint Satisfaction
Sanjay Bhansali

BHANSALI@EECS.WSU.EDU

School EECS, Washington State University
Pullman, WA 99164-2752

Glenn A. Kramer

GAK@EIT.COM

Enterprise Integration Technologies, 800 El Camino Real
Menlo Park, CA 94025

Tim J. Hoar

TIMHOAR@MICROSOFT.COM

Microsoft Corporation
One Microsoft Way, 2/2069
Redmond, WA 98052

Abstract
important problem geometric reasoning find configuration collection
geometric bodies satisfy set given constraints. Recently, suggested
problem solved efficiently symbolically reasoning geometry. approach, called
degrees freedom analysis, employs set specialized routines called plan fragments
specify change configuration set bodies satisfy new constraint
preserving existing constraints. potential drawback, limits scalability approach,
concerned difficulty writing plan fragments. paper address limitation
showing plan fragments automatically synthesized using first principles
geometric bodies, actions, topology.

1. Introduction
important problem geometric reasoning following: given collection geometric
bodies, called geoms, set constraints them, find configuration i.e., position,
orientation, dimension geoms satisfies constraints. Solving problem
integral task many applications constraint-based sketching design, geometric
modeling computer-aided design, kinematics analysis robots mechanisms
(Hartenberg & Denavit, 1964), describing mechanical assemblies.
General purpose constraint satisfaction techniques well suited solving constraint
problems involving complicated geometry. techniques represent geoms constraints
algebraic equations, whose real solutions yield numerical values describing desired
configuration geoms. equation sets highly non-linear highly coupled
general case require iterative numerical solutions techniques. Iterative numerical techniques
particularly efficient problems stability robustness (Press,
Flannery, Teukolsky & Vetterling, 1986). many tasks (e.g., simulation optimization
mechanical devices) equations solved repeatedly makes compiled solution
desirable. theory, symbolic manipulation equations often yield non-iterative, closed
form solution. found, closed-form solution executed efficiently.
1996 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiBHANSALI, KRAMER & HOAR

However, computational intractability symbolic algebraic solution equations renders
approach impractical (Kramer, 1992; Liu & Popplestone, 1990).
earlier work Kramer describes system called GCE uses alternative approach
called degrees freedom analysis (1992, 1993). approach based symbolic reasoning
geometry, rather equations, shown efficient systems based
algebraic equation solvers. approach uses two models. symbolic geometric model used
reason symbolically assemble geoms satisfy constraints
incrementally. "assembly plan" thus developed used guide solution complex
nonlinear equations - derived second, numerical model - highly decoupled, stylized
manner.
GCE system used analyze problems domain kinematics shown
perform kinematics simulation complex mechanisms (including Stirling engine,
elevator door mechanism, sofa-bed mechanism) much efficiently pure numerical
solvers (Kramer, 1992). GCE subsequently integrated commercial system
called BravoTM Applicon used drive 2D sketcher (Brown-Associates, 1993).
Several academic systems currently using degrees freedom analysis
applications assembly modeling (Anantha, Kramer & Crawford, 1992), editing
animating planar linkages (Brunkhart, 1994), feature-based design (Salomons, 1994; Shah &
Rogers, 1993).
GCE employs set specialized routines called plan fragments create assembly plan.
plan fragment specifies change configuration geom using fixed set
operators available degrees freedom, new constraint satisfied
preserving prior constraints geom. assembly plan completed
constraints satisfied degrees freedom reduced zero. approach
canonical: constraints may satisfied order; final status geom terms
remaining degrees freedom (p. 80-81, Kramer, 1992). algorithm finding
assembly procedure time complexity O(cg) c number constraints
g number geoms (p. 139, Kramer, 1992).
Since crux problem-solving taken care plan fragments, success
approach depends ones ability construct complete set plan fragments meeting
canonical specification. number plan fragments needed grows geometrically
number geoms constraints increase. Worse, complexity plan
fragments increases exponentially since various constraints interact subtle ways creating
large number special cases need individually handled. potentially serious
limitation extending degrees freedom approach. paper address problem
showing plan fragments automatically generated using first principles
geoms, actions, topology.
approach based planning. Plan fragment generation reduced planning
problem considering various geoms invariants describing state.
Operators actions, rotate, change configuration geoms, thereby
violating achieving constraint. initial state specified set existing
invariants geom final state additional constraints satisfied. plan
sequence actions applied initial state achieves final state.
formulation, one could presumably use classical planner, STRIPS (Fikes
& Nilsson, 1971), automatically generate plan-fragment. However, operators
domain parametric operators real-valued domain. Thus, search space consists
infinite number states. Even real-valued domain discretized considering realvalued intervals still large search space finding plan satisfies
420

fiPRINCIPLED SYMBOLIC GEOMETRIC CONSTRAINT SATISFACTION

specified constraints would intractable problem. approach uses loci information
(representing set points satisfy constraints) reason effects various
operators thus reduces search problem problem topology, involving reasoning
intersection various loci.
issue faced using conventional planner frame problem: determine
properties relationships change result action. typical solution use
assumption: action modify property relationship unless explicitly stated
effect action. approach works well one knows priori possible
constraints invariants might interest relatively constraints get affected
action - true case. use novel scheme representing effects
actions. based reifying (i.e., treating first class objects) actions addition geometric
entities invariant types. associate, pair geom invariants, set actions
used achieve preserve invariant geom. Whenever new geom
invariant type introduced corresponding rules actions achieve/preserve
invariants added. Since many invariant types actions
domain, scheme results simpler rules. Borgida, Mylopoulos & Reiter (1993) propose
similar approach reasoning program specifications. unique feature work
use geometric-specific matching rules determine two general actions
achieve/preserve different constraints reformulated less general action.
Another shortcoming using conventional planner difficulty representing
conditional effects operators. GCE operations effect depends type geom
well particular geometry. example, action translating body intersection
two lines plane would normally reduce bodys translational degrees freedom
zero; however, two lines happen coincide body still retains one degree
translational freedom two lines parallel coincide action fails.
situations called degeneracies. One approach handling degeneracies use
reactive planner dynamically revises plan run-time. However, could result
unacceptable performance many real-time applications. approach makes possible precompile potential degeneracies plan. achieve dividing planning
algorithm two phases. first phase skeletal plan generated works normal
case second phase, skeletal plan refined take care singularities
degeneracies. approach similar idea refining skeletal plans MOLGEN
(Friedland, 1979) idea critics HACKER (Sussman, 1975) fix known bugs
plan. However, skeletal plan refinement MOLGEN essentially consisted instantiating
partial plan work specific conditions, whereas method complete plan works
normal case extended handle special conditions degeneracies singularities.
1.1 Plan Fragment Example.
use simple example plan fragment specification illustrate approach.
Domains mechanical CAD computer-based sketching rely heavily complex
combinations relatively simple geometric elements, points, lines, circles
small collection constraints coincidence, tangency, parallelism. Figure 1
illustrates fairly complex mechanisms (all implemented GCE) using simple geoms
constraints.

421

fiBHANSALI, KRAMER & HOAR

Automobile suspension

Elevator Doors
Stirling Engine
Figure 1. Modeling complex mechanisms using simple geoms constraints. constraints
needed model joints mechanisms solvable using degrees freedom approach.

example problem illustrated Figure 2 specified follows:
Geom-type: circle
Name: $c
Invariants: (fixed-distance-line $c $L1 $dist1 BIAS_COUNTERCLOCKWISE)
To-be-achieved: (fixed-distance-line $c $L2 $dist2 BIAS_CLOCKWISE)
example, variable-radius circle $c1 prior constraint specifying circle
fixed distance $dist1 left fixed line $L1 (or alternatively, line drawn parallel
$L1 distance $dist1 center $c tangent counterclockwise direction
circle). new constraint satisfied circle fixed distance $dist2
right another fixed line $L2.

$L2
$L2
$c
$c

$dist2

$L1

$dist1
$L1

Figure 2. Example problem (initial state)

1We use following conventions: symbols preceded $ represent constants, symbols preceded ?
represent variables, expressions form (>> parent subpart) denote subpart compound term, parent.

422

fiPRINCIPLED SYMBOLIC GEOMETRIC CONSTRAINT SATISFACTION

solve problem, three different plans used: (a) translate circle
current position position touches two lines $L2 $L1 shown figure
(b) scale circle keeping point contact $L1 fixed, touches $L2 (c)
scale translate circle touches $L2 $L1.
action sequences constitute one plan fragment used
situation would available GCE plan-fragment library. Note
plan fragments would applicable certain situations. example, $L1 $L2
parallel, single translation never achieve constraints, plan-fragment (a)
would applicable. paper show plan-fragments
automatically synthesized reasoning fundamental principles.
rest paper organized follows: Section 2 gives architectural overview
system built synthesize plan fragments automatically detailed description various
components. Section 3 illustrates plan fragment synthesis process using example
Figure 2. Section 4 describes results current implementation system. Section
5 relates approach work geometric constraint satisfaction. Section 6 summarizes
main results suggests future extensions work.

2. Overview System Architecture
Figure 3 gives overview architecture system showing various knowledge
components plan generation process. knowledge represented system broadly
categorized Geom knowledge-base contains knowledge specific particular
geometric entities Geometry knowledge-base independent particular geoms
reused generating plan fragments geom.
Knowledge Components
Geometry knowledge-base
Geom knowledge-base
Geoms

Actions

Invariants

Action Matching Rules
Action Rules

Loci

Reformulation Rules

Signatures

Measurements

Plan fragment
specification

Planner
Phase

Prioritization Strategy

Skeletal
Plan

Planner
Phase II

Plan fragment

Figure 3. Architectural overview plan fragment generator

2.1 Geom Knowledge-base
geom specific knowledge-base decomposed seven knowledge
components.
423

fiBHANSALI, KRAMER & HOAR

2.1.1 ACTIONS
describe operations performed geoms. GCE domain, three actions
suffice change configuration body arbitrary configuration: (translate g v)
denotes translation geom g vector v; (rotate g pt ax amt) denotes rotation
geom g, around point pt, axis ax, angle amt; (scale g pt amt) g
geom, pt point geom, amt scalar. semantics scale operation depends
type geom; example, circle, scale indicates change radius
circle line-segment denotes change line-segments length. Pt point
geom fixed (e.g., center circle).
2.1.2 INVARIANTS
describe constraints solved geoms. initial version system
designed generate plan fragments variable-radius circle variable length linesegment fixed workplane, constraints distances geoms points,
lines, geoms workplane. seven invariant types represent
constraints. Examples two invariants are:



(Invariant-point g pt glb-coords) specifies point pt geom g
coincident global coordinates glb-coords,
(Fixed-distance-point g pt dist bias) specifies geom g lies fixed
distance dist point pt; bias either BIAS_INSIDE BIAS_OUTSIDE
depending whether g lies inside outside circle radius dist around point pt.

2.1.3 LOCI
represent sets possible values geom parameter, position point
geom. various kinds loci grouped either 1d-locus (representable set
parametric equations one parameter) 2d-locus (representable set parametric
equations two variables). For, example line 1d locus specified (make-line-locus
through-pt direc) represents infinite line passing through-pt
direction direc. loci represented system include rays, circles, parabolas, hyperbolas,
ellipses.
2.1.4 MEASUREMENTS
used represent computation function, object, relationship
objects. terms mapped set service routines get called plan
fragments. example measurement term is: (0d-intersection 1d-locus1 1d-locus2).
represents intersection two 1d-loci. normal case, intersection two 1dimensional loci point. However, may singular cases, example, two
loci happen coincide; case intersection returns one locus instead
point. may degenerate cases, example, two loci intersect;
case, intersection undefined. exceptional conditions represented
measurement type used second phase plan generation process
elaborate skeletal plan (see Section 3.3).
424

fiPRINCIPLED SYMBOLIC GEOMETRIC CONSTRAINT SATISFACTION

2.1.5 GEOMS
objects interest solving geometric constraint satisfaction problems. Examples
geoms lines, line-segments, circles, rigid bodies. Geoms degrees freedoms
allow vary location size. example, 3D-space circle variable
radius, three translational, two rotational, one dimensional degree freedom.
configuration variables geom defined minimal number real-valued
parameters required specify geometric entity space unambiguously. Thus, circle
six configuration variables (three center, one radius, two plane
normal). addition, representation geom includes following:





name: unique symbol identify geom;
action-rules: set rules describe invariants geom
preserved achieved actions (see below);
invariants: set current invariants geom;
invariants-to-be-achieved: set invariants need achieved
geom.

2.1.6 ACTION RULES
action rule describes effect action invariant. two facts interest
planner constructing plan: (1) achieve invariant using action (2)
choose actions preserve many existing invariants possible. general,
several ways achieve invariant several actions preserve invariant.
intersection two sets actions set feasible solutions. system, effect
actions represented part geom-specific knowledge form Action rules, whereas
knowledge compute intersections two sets actions represented
geometry-specific knowledge (since depend particular geom acted on).
action rule consists three-tuple (pattern, to-preserve, to-[re]achieve). Pattern
invariant term interest; to-preserve list actions taken without violating
pattern invariant; to-[re]achieve list actions taken achieve invariant
re-achieve existing invariant clobbered earlier action. actions stated
general form possible. matching rules Geometry Knowledge base
used obtain general unifier two actions. example action rule,
associated variable-radius circle geoms is:
pattern: (1d-constrained-point ?circle (>> ?circle CENTER) ?1dlocus)
to-preserve: (scale ?circle (>> ?circle CENTER) ?any)
(translate ?circle (v- (>> ?1dlocus ARBITRARY-POINT)
(>> ?circle CENTER))
to-[re]achieve: (translate ?circle (v- (>> ?1dlocus ARBITRARY-POINT)
(>> ?circle CENTER))

(AR-1)

action rule used preserve achieve constraint center circle geom
lie 1d locus. two actions may performed without violating constraint:
(1) scale circle center. would change radius circle position
center remains hence 1d-constrained-point invariant preserved. (2)
425

fiBHANSALI, KRAMER & HOAR

translate circle vector goes current center arbitrary point 1dimensional locus ((v- b) denotes vector point b point a). achieve invariant
one action may performed: translate circle center moves current
position arbitrary position 1-dimensional locus.
2.1.7 SIGNATURES
completeness, necessary exist plan fragment possible combination
constraints geom. However, many cases, two constraints describe
situation geom (in terms degrees freedom). example, constraints
ground two end-points line-segment constraints ground direction, length,
one end-point line-segment reduce degrees freedom line-segment
zero hence describe situation. order minimize number plan fragments
need written, desirable group sets constraints describe situation
equivalence classes represent equivalence class using canonical form.
state geom, terms prior constraints it, summarized signature.
signature scheme geom set canonical signatures plan fragments need
written. Kramers earlier work (1993) signature scheme determined manually
examining signature obtained combining constraint types designating one
set equivalent signatures canonical. approach allows us construct signature
scheme geom automatically using reformulation rules (described shortly).
reformulation rule rewrites one constraints simpler form. signature scheme
obtained first generating possible combinations constraint types yield set
possible signatures. signatures reduced using reformulation rules
signature reduced simplest form. set (unique) signatures left constitute
signature scheme geom.
example, consider set constraint types variable radius circle. signature
geom represented tuple <Center, Normal, Radius, FixedPts, FixedLines> where:







Center denotes invariants center point either Free (i.e.,
constraint center point), L2 (i.e., center point constrained 2dimensional locus), L1 (i.e., center point constrained 1-dimensional
locus), Fixed.
Normal denotes invariant normal plane circle
either Free, L1, Fixed (in 2D always fixed).
Radius denotes invariant radius either Free Fixed.
FixedPts denotes number Fixed-distance-point invariants either 0,1,
2.
FixedLines denotes number Fixed-distance-line invariants either
0,1, 2.

L2 L1 denote 2D 1D locus respectively. assume 2D geometry, L2 invariant
Center redundant, Normal always Fixed. 3 x 1 x 2 x 3 x 3 = 54
possible signatures geom. However, several describe situation.
example, signature:
<Center-Free,Radius-Free, FixedPts-0,FixedLines-2>
describes circle constrained specific distances two fixed lines,
rewritten to:
426

fiPRINCIPLED SYMBOLIC GEOMETRIC CONSTRAINT SATISFACTION

<Center-L1, Radius-Free,FixedPts-0,FixedLines-0>
describes circle constrained 1-dimensional locus (in case angular
bisector two lines). Using reformulation rules, derive signature scheme variable
radius circles consisting 10 canonical signatures given below:
<Center-Free,Radius-Free, FixedPts-0,FixedLines-0>
<Center-Free,Radius-Free, FixedPts-0,FixedLines-1>
<Center-Free,Radius-Free, FixedPts-1,FixedLines-0>
<Center-Free,Radius-Fixed, FixedPts-0,FixedLines-0>
<Center-L1,Radius-Free, FixedPts-0,FixedLines-0>
<Center-L1,Radius-Free, FixedPts-0,FixedLines-1>
<Center-L1,Radius-Free, FixedPts-1,FixedLines-0>
<Center-L1,Radius-Fixed, FixedPts-0,FixedLines-0>
<Center-Fixed,Radius-Free, FixedPts-0,FixedLines-0>
<Center-Fixed,Radius-Fixed, FixedPts-0,FixedLines-0>
Similarly, number signatures line-segments reduced 108 19 using
reformulation rules.
2.2 Geometry Specific Knowledge
geometry specific knowledge organized three different kinds rules.
2.2.1 MATCHING RULES
used match terms using geometric properties. planner employs unification
algorithm match actions determine whether two actions common unifier. However,
standard unification algorithm sufficient purposes, since purely syntactic
use knowledge geometry. illustrate this, consider following two
actions:
(rotate $g $pt1 ?vec1 ?amt1),
(rotate $g $pt2 ?vec2 ?amt2).
first term denotes rotation fixed geom $g, around fixed point $pt1
arbitrary axis arbitrary amount. second term denotes rotation geom
around different fixed point $pt2 rotation axis amount unspecified before.
Standard unification fails applied terms binding variables
makes two terms syntactically equal2. However, resorting knowledge geometry,
match two terms yield following term:
(rotate $g $pt1 (v- $pt2 $pt1) ?amt1)
denotes rotation geom around axis passing points $pt1 $pt2.
point around body rotated point axis (here arbitrarily chosen
one fixed points, $pt1) amount rotation anything.
planner applies matching rules match outermost expression term first;
rule applies, tries subterms term, on. none matching rules apply,
2 Specifically, unification fails tries unify $pt1 $pt2.

427

fiBHANSALI, KRAMER & HOAR

algorithm degenerates standard unification. matching rules conditions
attached them. condition boolean function; however, part
tend simple type checks.
2.2.2 REFORMULATION RULES
mentioned earlier, several ways specify constraints restrict degrees
freedom geom. GCE, plan fragments indexed signatures summarize
available degrees freedom geom. reduce number plan fragments need
written indexed, desirable reduce number allowable signatures.
accomplished set invariant reformulation rules used rewrite pairs
invariants geom equivalent pair simpler invariants (using well-founded
ordering). equivalence means two sets invariants produce range
motions geom. reduces number different combinations invariants
plan fragments need written. example invariant reformulation following:
(fixed-distance-line ?c ?l1 ?d1 BIAS_COUNTERCLOCKWISE)
(fixed-distance-line ?c ?l2 ?d2 BIAS_CLOCKWISE)



(RR-1)

(1d-constrained-point ?c (>> ?c center) (angular-bisector
(make-displaced-line ?l1 BIAS_LEFT ?d1)
(make-displaced-line ?l2 BIAS_RIGHT ?d2)
BIAS_COUNTERCLOCKWISE
BIAS_CLOCKWISE))

rule takes two invariants: (1) geom fixed distance left given line,
(2) geom fixed distance right given line. reformulation produces
invariant geom lies angular bisector two lines parallel two given
lines specified distance them. Either two original invariants conjunction
new one equivalent original set invariants.
Besides reducing number plan fragments, reformulation rules help simplify
action rules. Currently action rules (for variable radius circles line-segments) use
single action preserve achieve invariant. restrict allowable signatures
geom, possible create examples need sequence (more one) actions
rule achieve invariant, need complex conditions need checked
determine rule applicability. Allowing sequences conditionals rules increases
complexity rules pattern matcher. makes difficult verify
correctness rules reduces efficiency pattern matcher.
Using invariant reformulation rules allows us limit action rules contain
single action. Unfortunately, seems still need conditions achieve certain invariants.
example, consider following invariant variable radius circle:
(fixed-distance-point ?circle ?pt ?dist BIAS_OUTSIDE)
states circle, ?circle distance ?dist point ?pt lie outside
circle around ?pt radius ?dist. One action may taken achieve constraint is:
(scale ?circle
(>> ?circle center)
428

fiPRINCIPLED SYMBOLIC GEOMETRIC CONSTRAINT SATISFACTION

(minus (>> (v- (>> ?circle center) ?pt)
magnitude)
?dist)
is, scale circle setting radius distance center point ?pt
minus scalar amount ?dist (see Figure 4). However, action achieves constraint
circle happens lie outside circular region radius ?dist center ?pt.

$C
$c

Figure 4. geom $c scaled touch $C center $c lies shaded region.

Therefore, need pre-condition rule checks indeed case. Note
action necessary completeness (otherwise planner would able solve
certain cases solution). Instead allowing conditional rules, use rules without
condition second phase plan generation check see
exceptions. Thus, example, exception would detected since third argument
scale operation returns negative number considered exception condition scale
operation.
2.2.3 PRIORITIZING STRATEGY
Given set invariants achieved geom, planner generally creates multiple
solutions. valid solutions absence exception conditions yield
configuration geom. However, plan fragments contain redundant action
sequences (e.g., two consecutive translations). Moreover, geom constrained
exception conditions, plan fragments able provide solution
whereas others not. prioritization strategy used prioritize skeletal plan
fragments plan fragments least redundancy flexibility chosen.
Eliminating plan fragments redundant actions turns straightforward.
assume one degree dimensional freedom geometric body.
assumption proved 1 translation, 1 rotation, 1 scale sufficient change
configuration object arbitrary configuration 3D space. Therefore, plan
fragment contains one instance action type contains redundancies
rewritten equivalent plan fragment eliminating redundant actions, combining two
action single composite action. example, consider following pair
translations geom:


(translate $g ?vec)
429

fiBHANSALI, KRAMER & HOAR



(translate $g (v- ?to 2 (>> $g center)))

?vec represents arbitrary vector ?to2 represents arbitrary position. ?to2
independent positional parameter geom, first translate action redundant
removed. Hence plan fragments contain redundant actions
eliminated.
prioritize remaining plan fragments following principle used:
Prefer solutions subsume alternative solution.
rationale principle permits greater flexibility solving constraints
exception conditions. example, suppose two solutions circle geom:
Solution 1: Translate circle center lies fixed position 1dimensional locus.
Solution 2: Translate circle center lies arbitrary point 1dimensional locus; scale fixed amount (which function
position arbitrary point).
first solution subsumed second solution since always choose
arbitrary point Solution 2 fixed position specified Solution 1 (the scale operation
case leaves dimension circle unchanged). Therefore Solution 2 preferred
Solution 1.
subsumption relation imposes partial order set skeletal plan fragments.
prioritization strategy selects maximal elements partial order. runtime
tried turn one yields solution.

3.0 Plan Fragment Generation
plan fragment generation process divided two phases (Figure 1). first phase
specification plan fragment taken input, planner used generate set
skeletal plans. form input second phase chooses one
skeletal plans elaborates take care singularities degeneracies. output
phase complete plan fragments.
3.1 Phase
skeletal plan generated using breadth-first search process. Figure 5 gives general form
search tree produced planner. first action typically reformulation
planner uses reformulation rules rewrite geom invariants canonical form. Next,
planner searches actions produce state least 1 invariant Preserved
list preserved least 1 action To-be-achieved (TBA) list achieved. preserved
achieved invariants pushed Preserved list, clobbered unachieved
invariants pushed TBA list child state.
strategy produce intermediate nodes search tree might clobber
one preserved invariant without achieving new invariant might produce state
identical parent state terms invariants Preserved

430

fiPRINCIPLED SYMBOLIC GEOMETRIC CONSTRAINT SATISFACTION

Preserved: P
TBA:
Reformulate
Preserved: P
TBA:
Action 1
Preserved: P1
TBA: A1

Action 3
Action 2
Preserved: P2
TBA: A2

Preserved: P3
TBA: A3

Actions
Preserved: P +
TBA: nil
Figure 5. Overview search tree produced planner

TBA list. initial state geom may arbitrary configuration
(among set allowable configurations) may necessary first move geom
alternative allowable configuration find optimal solution.
illustrate need, consider example Figure 6. example, one prior
constraint variable radius circle geom: center lies 1-dimensional locus. new
constraint achieved is: geom lie fixed distance line. order
achieve constraint one following two actions may taken: 1) scale

(a)

(b) Scale

(c) Translate

(d) Translate & scale

Figure 6. Example illustrate need actions produce state equivalent parent state.

431

fiBHANSALI, KRAMER & HOAR

circle fixed distance line (Figure 6b), 2) translate circle
new position 1-dimensional locus touches line (Figure 6c). However,
infinite number additional solutions consisting combinations scale translation
(Figure 6d). solutions derived planner first changes configuration
geom preserves existing invariant without achieving new invariant (i.e.,
scale arbitrary amount translate arbitrary point 1-dimensional locus)
followed action achieves new invariant. Therefore planner creates child
states identical parent state terms invariants Preserved TBA lists.
planner iteratively expands leaf node search tree one following
true:
1. node represents solution; is, TBA list nil.
2. node represents cycle; is, invariants Preserved TBA lists
identical one ancestor nodes.
node marked terminal search tree pruned point. leaf nodes
marked terminal, search terminates. planner collects terminal nodes
solutions. plan-steps solution nodes represents skeletal plan
fragment. multiple skeletal plan fragments obtained planner, one
chosen using prioritizing rule described earlier passed second phase plan
fragment generation.
3.2 Phase I: Example
use example Section 1 illustrate Phase planner. planner begins
attempting reformulate given constraints. uses reformulation rule RR-1 described earlier
repeated convenience:
(fixed-distance-line ?c ?l1 ?d1 BIAS_COUNTERCLOCKWISE)
(fixed-distance-line ?c ?l2 ?d2 BIAS_CLOCKWISE)



(RR-1)

(1d-constrained-point ?c (>> ?c center) (angular-bisector
(make-displaced-line ?l1 BIAS_LEFT ?d1)
(make-displaced-line ?l2 BIAS_RIGHT ?d2)
BIAS_COUNTERCLOCKWISE
BIAS_CLOCKWISE))

ii

L2


iii

iv

L1

Figure 7. Four possible angular bisectors two lines L1 L2. bias symbols L1
L2 corresponding ray (i) BIAS_COUNTERCLOCKWISE & BIAS_CLOCKWISE,respectively.

432

fiPRINCIPLED SYMBOLIC GEOMETRIC CONSTRAINT SATISFACTION

rule two measurement terms: make-displaced-line angular-bisector.
Make-displaced-line takes three arguments: line, l, bias symbol indicating whether
displaced line left right l, distance, d. returns line parallel
given line l distance left right line depending bias. Angular-bisector
takes two lines, l1 l2, two bias symbols returns one four rays bisects
lines l1 l2 depending bias symbols (see Figure 7). reformulation, state
search tree shown Figure 8. reformulation rules applicable point.

Preserved: (fixed-distance-line $c $L1 $dist1 BIAS_COUNTERCLOCKWISE)
TBA:
(fixed-distance-line $c $L2 $dist2 BIAS_CLOCKWISE)

Reformulation

Preserved: (fixed-distance-line $c $L1 $dist1 BIAS_COUNTERCLOCKWISE)
TBA:
(1d-constrained-point $c
(>> $c CENTER)
(angular-bisector
(make-displaced-line $L1 $BIAS_LEFT $dist1)
(make-displaced-line $L2 $BIAS_RIGHT $dist2)
BIAS_COUNTERCLOCKWISE
BIAS_CLOCKWISE))
Figure 8. Search tree reformulating invariants

Next, planner searches actions achieve new invariant preserve
existing invariant both. describe steps involved finding actions satisfy
maximal number constraints (in case, two). planner first finds actions
achieve 1d-constrained-point invariant examining action rules associated
variable-circle geom. action rule AR-1 contains pattern matches 1d-constrainedpoint invariant:
pattern: (1d-constrained-point ?circle (>> ?circle center) ?1dlocus)
to-preserve: (scale ?circle (>> ?circle center) ?any)
(translate ?circle (v- (>> ?1dlocus arbitrary-point)
(>> ?circle center))
to-[re]achieve: (translate ?circle (v- (>> ?1dlocus arbitrary-point)
(>> ?circle center))
following bindings:

(AR-1)

{?circle = $c, ?1d-locus = (angular-bisector (make-displaced -line ...) ...)}
Substituting bindings obtain following action:

433

fiBHANSALI, KRAMER & HOAR

(translate $c (v- (>> (angular-bisector (make-displaced-line $L1 BIAS_LEFT $dist1)
(make-displaced-line $L2 BIAS_RIGHT $dist2)
arbitrary-point)
(>> $c center)))
(a1)
taken achieve constraint. Similarly, planner finds actions
preserve fixed-distance-line invariant. relevant action rule following:
pattern: (fixed-distance-line ?circle ?line ?distance)
(AR-2)
to-preserve: (translate ?circle (v- (>> (make-line-locus (>> ?circle center)
(>> ?line direction))
arbitrary-point)
(>> ?circle center))
to-[re]achieve: (translate ?circle (v- (>> (make-displaced-line
?line
BIAS_LEFT

(plus ?distance (>> ?circle radius)))
arbitrary-point)
(>> ?circle center)))
relevant action appropriate substitutions is:
(translate $c (v- (>> (make-line-locus
(>> $c center)
(>> L1 direction))
arbitrary-point)
(>> $c center))

(a2)

Now, find action preserves preserved invariant achieves TBA
invariant, planner attempts match preserving action (a2) achieving action (a1).
two actions match using standard unification, match employing following
geometry-specific matching rule:
# move arbitrary point two
# different loci, move point
# intersection two loci

(v- (>> $1d-locus1 arbitrary-point) $to)
(v- (>> $1d-locus2 arbitrary-point) $to)



(v- (0d-intersection $1d-locus1 $1d-locus2) $to)
yield following action:
(translate $c (v- (0d-intersection (angular-bisector
(make-displaced-line ...) ...)
(make-line-locus (>> $c center) (>> $L1 direction))
(>> $c CENTER)))
action moves circle point shown Figure 9 achieves constraints.
simple one-step plan constitutes skeletal plan fragment.
434

fiPRINCIPLED SYMBOLIC GEOMETRIC CONSTRAINT SATISFACTION

$L2

$c

angular-bisector
make-line-locus

$dist2
$dist1
$L1

Figure 9.

denotes point circle moved.

two actions generated planner first iteration. One
achieves new constraint clobbers prior invariant. moves circle
another configuration without achieving new constraint preserving prior constraint.
first action produces terminal state since constraints achieved.
Hence search tree pruned point. However, planner continues search
alternative solutions expanding two nodes. two iterations following
solutions obtained:
1. Translate intersection angular-bisector make-line-locus.
2. Translate arbitrary point angular-bisector, followed translation
intersection point.
3. Translate arbitrary point make-line-locus, followed translation
intersection point.
4. Translate arbitrary point angular-bisector scale.
stage first phase plan fragment generation terminated skeletal
plan fragments passed second phase planner.
3.3 Phase II: Elaboration Skeletal Plan Fragment
purpose Phase 2 planning i) select one skeletal plan fragments, ii)
elaborate generate desirable configuration geom
constrained well handle exception conditions.
3.3.1 SELECTION SKELETAL PLAN FRAGMENTS
two primary considerations selecting skeletal plan fragment reduce redundant
actions plan increase generality plan. considerations used formulate
prioritization strategy described Section 2. strategy implemented lookup table
assigns weights various plan fragments. plan fragments maximal weights
selected elaboration Phase 2. Readers interested implementation details
referred (Hoar, 1995).
3.3.2 PLAN FRAGMENT ELABORATION
Plan fragment elaboration refines skeletal plan fragment two ways. First, refines actions
435

fiBHANSALI, KRAMER & HOAR

constrained (e.g., translate arbitrary point locus) appropriate
instantiation unconstrained parameters (e.g., selecting specific point locus). Second,
handles exception conditions result constrained over-constrained systems.
action refinement exception handling treated using common technique.
Plan elaboration based "principle least motion": multiple
solutions problem choose solution minimizes total amount perturbation
(motion) system. Implementing principle requires definition motion function,
CA,G action, A, geom type, G. example, translation geom, motion
function, CT,circle could square displacement center geom
initial final position. need motion summation function, G sums motion
produced individual actions geom G. example summation function
normal addition operator: plus. total motion produced geom computed using
summation function motion functions action- geom pairs.
plan fragment constrained, expression representing total motion
would contain one variables representing ungrounded parameters geom.
Formal optimization techniques, based finite difference methods, used obtain values
parameters would minimize motion function. However, use efficient,
algorithm based hill-climbing guarantee optimality yields good results
practice. use heuristic algorithm justified many interactive applications
sketching, fast, sub-optimal solution preferable computationally expensive,
optimal one.
algorithm begins segmenting continuous loci discrete intervals.
systematically searches resultant, discrete n-dimensional space. algorithm first finds
local minima along one dimension holding variables constant values.
holds first variable minimum value found searches lower local minima along
second dimension on. Although algorithm guarantee finding global
even local minima, efficient yields good results practice. implemented
algorithm somewhat complex simple description above; details
found elsewhere (Hoar, 1995).
Exception conditions handled using technique above. Exception
conditions identified service routine returns set solutions solution (e.g.,
routine compute intersection two 1-dimensional loci returns 1-dimensional locus
nil). Multiple solutions represent constrained system requires search among
set solutions returned. conditions handled exactly described previous
paragraph. no-solution exception occurs, system aborts plan fragment prints
diagnostic message explaining constraint could solved.
3.4 Phase II: Example
Four skeletal plan fragments generated first phase planner (Section 3.2). Using
rule eliminating redundant translations given earlier, second third plan fragments
reduced single translation plan fragments equivalent first plan fragment.
leaves two distinct plan fragment solutions consider.
Using prioritizing rule, system concludes first plan fragment consisting
single translation subsumed second plan fragment consisting translation
scale. Thus, second plan fragment chosen preferred solution.
plan fragment deterministic since contains action translates circle
436

fiPRINCIPLED SYMBOLIC GEOMETRIC CONSTRAINT SATISFACTION

geom arbitrary point angular-bisector. Therefore, system inserts iterative loop
computes amount motion circle various points angular bisector,
breaking loop finds minima. Similarly, service routine may
return exception, system inserts case statement contains loop handle
situations one solution returned. Online Appendix 1 contains complete
example plan fragment generated system.

4.0 Results
plan fragment generator described implemented using CLOS (Common Lisp
Object System). implemented parts geometric constraint engine (GCE) described
Kramer C++ XMotif based graphical user interface. written
translator translates synthesized plan fragments C++. complete plan fragment
library representative geom (line segment) synthesized integrated
constraint engine. Using able successfully demonstrate solution
several geometric constraints. present evaluation system.
primary contribution research novel geometric constraint satisfaction
approach. perspective constraint satisfaction techniques, novel feature
approach - degrees freedom analysis - already described earlier works
second author (Kramer, 1992, 1993). goal research develop automated
techniques enable degrees freedom approach scale reducing amount
effort needed creating plan fragment libraries. Hence, evaluation based
successful automating plan fragment synthesis process.
used plan fragment generator described automatically synthesize plan
fragments two representative geoms -- line-segments circles -- 2D. seven
types constraints thirty four rules system (12 action rules line-segments, 8 action
rules circles, 7 Reformulation rules, 7 Matching rules). Using rules
successfully generated skeletal plan fragments various combinations constraints line
segments (249) circles (50). largest search tree produced planner order
hundred nodes takes minutes Macintosh Quadra. evaluation
purposes, present data one representative geom - line segment.
4.1 Programming Effort
Figure 10 shows number lines code comprising current system. areas solid
represent code written manually. includes 5000 lines CLOS code
plan fragment synthesizer, 5400 lines C/C++ user interface, 3300 lines C/C++
support routines. hatched area represent code synthesized plan
fragment generator. represents 27000 lines C++ code (for plan fragments linesegment geom). size synthesized plan fragment (about 121 lines average) much less
plan fragments written manually (in C) original version GCE. Thus, using
automated plan fragment generator considerably reduced amount programming.
reduction ratio 5:1 good indicator reduction programming effort,
subject criticism since compares code two different programming languages
comprising different degrees difficulty.
accurate evaluation obtained comparing total effort required writing plan
fragments manually total effort required synthesizing using
437

fiBHANSALI, KRAMER & HOAR

12% (CLOS)

13% (C/C++)

67%
(C++)

User Interface

8% (C/C++)

Support routines

Generator

Plan Fragments

Figure 10. Lines code different parts system

technique described paper. extremely difficult, impossible,
controlled experimental setting number factors cost involved. best
done compare empirical data based experience developing system.
following table shows effort person days developing plan fragment library
line-segment geom using technique.

Plan Fragment Generator
Manually

Research
90
0

Development
150
498

Total
210
498

Table 1. Effort (in person-days) creating plan fragments
effort involved writing plan fragments manually, use conservative estimate
2 person days plan fragment3. table shows using plan fragment generator
obtained 58% reduction effort creating plan fragment library. testing
debugging time ignored assumed cases (although
believe time much manually generated plan fragments).
4.2 Scalability
much stronger evidence support technique obtained look effort
3 estimate based effort required developing plan fragment library GCE well
experimental data obtained two graduate students write plan fragments manually.

438

fiPRINCIPLED SYMBOLIC GEOMETRIC CONSTRAINT SATISFACTION

required extending plan fragment library adding features (e.g., new kinds
geoms constraints). evaluate scalability approach, decided extend plan
fragments 3D geoms added degrees rotational translational freedom.
extension done manually would significant exercise software maintenance since
requires changes plan fragment library. Using plan fragment generator
needed revise rules used planner make changes support routines. Since
support routines written manually, cost modify
approaches, effort needed rewrite rules relevant. took 1 week
effort rewrite debug action rules synthesize complete plan fragment library
3D, link successfully constraint engine. significant result
demonstrating technique used scale degrees freedom analysis
complex geoms geometries.
4.3 Correctness
important issue ignored far is: one verify correctness
completeness plan fragment generator? done extensive testing evaluation
plan fragments synthesized plan fragment generator. Table 2 summarizes results.
Number plan fragment specifications
Specs. solutions:
Completeness
solution exists
Missing rules
symbolic solution
Total
Plan fragments errors:
Correctness
Faults due errors logic
Support routine errors
Total

249
65
13
2
80
0
56
56

Table 2. Completeness Correctness synthesized plan fragments
eighty plan fragment specifications planner failed produce
solution. sixty five specifications, solutions general case --
specifications represent overconstrained problems, constraining one end point linesegment one-dimensional locus previous constraints already reduced
end-points translational degrees freedom zero. action planner take
cases check new constraint already satisfied. Thirteen cases
solutions two missing rules: one action rule, one reformulation rule. two
rules added thirteen specifications solved. Finally, two plan
fragments planner failed produce analytical solution. cases shown
Figure 11. solve problems need reformulation rule reformulates existing
invariant constraint endpoint $lseg curve $L3. Instead representing
complex 1-dimensional (and higher dimensional) loci $L3, assume constraint
engine would call numerical solver computes solution iteratively. alternative would
extend set support routines handle complex loci intersections.

439

fiBHANSALI, KRAMER & HOAR

.
$L2

$P
$L3

$lseg

$L1

Figure 11. Example problem generated symbolic solution. $lseg line-segment
constrained one end-point $L1, fixed length, tangent
circle centered $P. new constraint end-point $lseg $L2.

check correctness plan fragments, exhaustive evaluation
plan fragments. seen Table 2, code synthesized perfect.
20% plan fragments function correctly. analyzed reasons
failure manually inspecting plan fragments. significant finding none
failures due logical errors plan fragments. words skeletal plan
fragments generated Phase correct complete. failures
bugs mathematical support routines called plan fragments.
instances failures traced bugs implementing Phase 2 plan fragment: either
selecting wrong skeletal plan fragment computing least motion correctly.
expected first version automatically generated plan fragments completely
bug-free. Indeed, high percentage plan fragments function correctly (almost 80%)
positive result reflects significant increase quality corresponding
decrease maintenance effort building geometric constraint satisfaction systems using
approach.

5.0 Related Work
Geometric constraint satisfaction old problem. Probably first application problem
constraint-based sketching Sketchpad program developed Sutherland (1963).
Sketchpad program based constraint relaxation limited problems
modeled point variables.
field mechanical design, graph based approach constraint satisfaction
described Serrano (1987). Serranos approach constraints modeled using
constraint network; constraint satisfaction engine finds values constrained variables
satisfy constraints network using constraint propagation techniques. approach
identifies loops cycles network, collapses supernodes, applies
conventional sequential local propagation. approach uses numerical iterative techniques
problems stability. computational advantage approach reduces
equations tightly coupled.
commercial systems kinematics analysis based numerical iterative
techniques algebraic techniques combination two. Although approaches
principle robust, several shortcomings make inappropriate real-time
applications.
Among non-commercial systems, notable new approach constraint based sketching
440

fiPRINCIPLED SYMBOLIC GEOMETRIC CONSTRAINT SATISFACTION

Juno-2 developed DEC-SRC (Heydon & Nelson, 1994). Constraints Juno-2
specified using expressive, declarative constraint language seems powerful enough
express constraints arise practice. Juno-2 uses combination symbolic
numerical techniques solve geometric constraints efficiently. key difference Juno2 degrees freedom approach Juno-2 symbolic reasoning done
domain equations. example, Juno-2 uses symbolic techniques local propagation,
unpacking, unification closure reduce number unknowns system equations.
equations solved Newtons method. degrees freedom analysis, symbolic
reasoning done domain geometry rather equations.
Geometric constraints arise robotics, primary issues concerned
finding physically realizable path space robot manipulator part
assembly. fundamental analytical tool solving motion planning problems robotics
configuration space framework (Lozano-Perez, 1983). configuration space approach,
problem planning motion part space obstacles transformed
equivalent simpler problem planning motion point space enlarged
configuration-space obstacles. Degrees freedom analysis finesses problem since uses
notion incremental assembly metaphor solving geometric constraint systems.
physical meaning ascribed objects move need
- factor quite important real-world assembly problem arising robotics.
use plan guide solution complicated non-linear equations arising
formulating solving problems algebraically.

6.0 Conclusions
described plan fragment generation methodology synthesize plan fragments
geometric constraint satisfaction systems reasoning first principles geometric
entities, actions, topology. technique used successfully synthesize plan
fragments realistic set constraints geoms. may seem substituted one
hard task - writing complete set correct plan fragments various combinations geoms
constraints - even harder task: creating knowledge base rules automate
process. rules difficult write found necessary spend
effort debugging rules. However, estimate total effort write debug rules
still order magnitude less writing debugging manually written plan fragment
code. future work investigate approach scales complex constraints
geometries.
Another useful extension work would concerned pushing automation one
level automatically acquire types knowledge simpler building
blocks. example, technique automatically synthesizing least motion function
description geometry would useful.
method plan fragment generation divided two disjoint phases.
alternative method would explore two phases interleaved. One possibility
degeneracy redundant constraint, planner could reformulate
problem removing redundant constraint re-synthesize skeletal plan fragment
new set constraints. resultant plan would form part original plan
fragment deal degenerate cases. words, plan fragments would generated
on-the-fly needed constraint solver.

441

fiBHANSALI, KRAMER & HOAR

Acknowledgments
thank Qiqing Xia helped implementing parts system described paper.
acknowledge support resources provided School Electrical
Engineering Computer Science, Washington State University. work originated
first author Knowledge Systems Laboratory, Stanford University, second
author Schlumberger Laboratory Computer Science, Austin.

References
Anantha, R., Kramer, G., & Crawford, R. (1992). architecture represent over, under,
fully constrained assemblies. Proceedings ASME Winter Annual Meeting, 233-244.
Borgida, A., Mylopoulos, J., & Reiter, R. (1993). ... nothing else changes: frame problem
procedure specifications. Proceedings 15th International Conference
Software Engineering, Baltimore, MD.
Brown-Associates. (1993). Applicons GCE: Strong Technical Framework. Brown Associates
Inc.
Brunkhart, M. W. (1994). Interactive geometric constraint systems. Masters thesis, TR No.
CSD-94-808, Department EE&CS, University California, Berkeley.
Fikes, R. E., & Nilsson, N. J. (1971). STRIPS: new approach applicatiion theorem
proving problem solving. Artificial Intelligence, 2, 198-208.
Friedland, P. E. (1979). Knowledge-based experiment design molecular genetics. Tech. report
CSD-79-771, Department Computer Science, Stanford University.
Hartenberg, R. S., & Denavit, J. (1964). Kinematic Synthesis Linkages. New York: McGraw
Hill.
Heydon, A., & Nelson, G. (1994). Juno-2 constraint-based drawing editor. SRC Research
report 131a, Digital Systems Research Center, Palo Alto, CA.
Hoar, T. (1995). Automatic program synthesis geometric constraint satisfaction. Masters
Thesis, School EECS, Washington State University.
Kramer, G. A. (1992). Solving Geometric Constraint Systems: Case Study Kinematics.
Cambridge, MA: MIT Press.
Kramer, G. A. (1993). geometric constraint engine. Artificial Intelligence, 58(1-3), 327-360.
Liu, Y., & Popplestone, R. J. (1990, ). Symmetry constraint inference assembly planning:
automatic assembly configuration specification. Proceedings AAAI-90, Boston, MA,
1038-1044.
Lozano-Perez, T. (1983). Spatial planning: configuration space approach. IEEE Transactions
Computers, C-32, 108-120.
442

fiPRINCIPLED SYMBOLIC GEOMETRIC CONSTRAINT SATISFACTION

Press, W. H., Flannery, B. P., Teukolsky, S. A., & Vetterling, W. T. (1986). Numerical Recipes:
Art Scientific Computing. Cambridge, England: Cambridge University Press.
Salomons, O. (1994). Computer support design mechanical products. Ph.D. Thesis,
Universiteit Twente, Netherlands.
Serrano, D. (1987). Constraints conceptual design. Ph.D. thesis, Massachusetts Institute
Technology.
Shah, J. J., & Rogers, M. T. (1993). Assembly modeling extension feature-based design.
Research Engineering Design, 5, 218-237.
Sussman, G. J. (1975). Computer Model Skill Acquisition. New York: American Elsevier.
Sutherland, I. E. (1963). Sketchpad, man-machine graphical communication system. Ph.D.
Thesis, Massachusetts Institute Technology.

443


