journal artificial intelligence

submitted published

binary encodings non binary constraint satisfaction
experimental
nikolaos samaras

samaras uom gr

department applied informatics
university macedonia greece

kostas stergiou

konsterg aegean gr

department information communication systems engineering
university aegean greece

abstract
non binary constraint satisfaction csp solved directly extended versions binary techniques alternatively non binary translated equivalent binary one case generally accepted translated
solved applying well established techniques binary csps
evaluate applicability latter demonstrate use
standard techniques binary csps encodings non binary problematic
rarely competitive non binary representation
overcome propose specialized arc consistency search binary encodings evaluate theoretically empirically consider three
binary representations hidden variable encoding dual encoding double
encoding theoretical empirical certain classes non binary
constraints binary encodings competitive option many cases better one
non binary representation

introduction
constraint satisfaction csps appear many real life applications
scheduling resource allocation timetabling vehicle routing frequency allocation etc
csps naturally eciently modelled non binary n ary constraints
may involve arbitrary number variables well known non binary csp
converted equivalent binary one well known translations
dual encoding dechter pearl hidden variable encoding rossi petrie
dhar ability translate non binary csp binary often used
past justication restricting attention binary csps implicitly assumption faced non binary csp simply convert
binary one apply well known generic techniques solving binary equivalent
assumption awed generic techniques
binary csps suitable binary encodings non binary
past years theoretical empirical studies eciency
binary encodings comparisons binary encodings non binary representation bacchus van beek stergiou walsh mamoulis stergiou
smith bacchus chen van beek walsh theoretical showed
c

ai access foundation rights reserved

fisamaras stergiou

converting non binary csps binary equivalents potentially ecient way
solve certain classes non binary however limited empirical studies
cases appears true conways game life smith
notable exception reasons many cases
extensive space requirements binary encodings make infeasible
many non binary utilize ecient specialized propagators certain constraints developed regin dierent constraint
converting constraints binary clearly impractical another reason
overlooked experimental studies use well known generic local
consistency search encodings way fail exploit
structure constraints encodings ending inecient
make binary encodings realistic choice modelling solving non binary csps
need utilize structural properties finally important point
use binary encoding necessarily mean convert
non binary constraints binary commonly perceived
selective constraints encode properties arity tightness
get ecient hybrid
address issues use specialized arc consistency search
binary encodings non binary csps lead ecient consider three encodings dual hidden variable double encoding latter
basically conjunction two encodings received little attention
may well turn signicant practice aim study
twofold first present ecient binary encodings analyze
theoretically experimentally second importantly investigate
use help solve non binary eciently towards
aims make following contributions
describe simple enforces arc consistency hidden variable
encoding arbitrary non binary csp ekdk time complexity e
number constraints k maximum arity constraints
maximum domain size gives improvement compared asymptotic
complexity generic arc consistency improved complexity
complexity optimal generalized arc consistency
non binary representation identify property arc
consistency hidden variable encoding make run faster
arc inconsistent generalized arc consistency
consider search maintain local consistencies search
hidden variable encoding maintaining arc consistency
generalizations forward checking non binary csps emulated
corresponding forward checking run hidden variable encoding
instantiate original variables e variables initial non binary
corresponding nonbinary constraints following relationships visit number
search tree nodes asymptotic cost within polynomial
bound


fibinary encodings non binary csps experimental

describe specialized dual encoding achieves arc consistency
e dk worst case time complexity signicantly lower e k
complexity generic arc consistency improvement complexity
bound stems observation constraints dual encoding specic
structure namely piecewise functional van hentenryck deville teng
apart applying arc consistency dual encoding non binary
csp used specialized ltering certain
classes non binary constraints
adapt search run double encoding compare
theoretically similar hidden variable encoding non binary
representation search operate double encoding exploit
advantages hidden variable dual encoding example
certain conditions asymptotic cost maintaining arc consistency
double encoding polynomially worse asymptotic
cost corresponding non binary representation hidden
variable encoding exponentially better
finally make extensive empirical study domains consider
random well structured ones crossword puzzle generation conguration frequency assignment study consists two parts rst
part give experimental demonstrate advantages specialized
binary encodings compared generic example
specialized arc consistency dual encoding orders magnitude faster generic arc consistency second part
use binary encodings oer signicant benets solving certain classes
non binary csps example solving dual encoding conguration
orders magnitudes ecient solving non binary
representation empirical frequency assignment
demonstrate binary encoding benecial even non binary constraints
intentionally specied

structured follows section give necessary denitions
background section describe specialized arc consistency hidden
variable encoding demonstrate extensions forward checking
non binary csps emulated binary forward checking run
hidden variable encoding section explain complexity arc consistency
dual encoding improved describe specialized arc consistency
section discusses double encoding section present experimental
random structured demonstrate usefulness proposed
draw conclusions regarding applicability encodings
theoretical experimental section discusses related work finally
section conclude


fisamaras stergiou

background
section give necessary denitions csps describe hidden variable
dual double encodings non binary csps
basic definitions
constraint satisfaction csp p dened tuple x c
x x xn nite set n variables
din x din xn set initial domains variable xi x
din xi initial nite domain possible values csp remove
values domains variables value assignments propagation
variable xi denote xi current domain xi time consists
values removed din xi assume every xi x
total ordering dened din xi
c c ce set e constraints constraint ci
pair vars ci rel ci vars ci xj xjk
x called constraint scheme rel ci subset
din xj x xdin xjk species allowed combinations
ables vars ci

c dened
ordered subset
cartesian product
values vari

size vars ci called arity constraint ci constraints arity called
binary constraints arity greater called non binary n ary tuple
rel ci ordered list values ak aj din xj j k
tuple ak valid aj j k aj xj tuple valid
values tuple present domains corresponding variables
process veries whether given tuple allowed constraint ci called
consistency check constraint dened extensionally set allowed
disallowed tuples intensionally predicate arithmetic function binary csp
represented graph called constraint graph nodes correspond variables
edges correspond constraints non binary csp represented constraint
hyper graph constraints correspond hyper edges connecting two nodes
assignment value variable xi denoted xi tuple
ak viewed set value variable assignments x xk ak
set variables tuple dened denoted vars
subset vars vars vars denotes sub tuple includes assignments
variables vars two tuples rel ci ordered lexicographic
ordering lex ordering lex exists subset x xj ci
x xj x xj xj lex xj assignment consistent
constraints ci vars ci vars vars ci rel ci solution csp
x c consistent assignment variables x exists solution
given csp say csp soluble otherwise insoluble
basic way solving csps backtracking search seen
traversal search tree comprises possible assignments values variables


fibinary encodings non binary csps experimental

level tree corresponds variable node search tree corresponds
tuple e assignment values variables root tree corresponds
empty tuple rst level nodes correspond tuples assignment value
one variable second level nodes correspond tuples assignment values two
variables generated extending rst level tuples etc stage search
tree traversal variables already assigned called past variables
recently assigned variable called current variable variables
assigned yet called future variables
rest use notation n number variables
csp e number constraints maximum domain size
variables k maximum arity constraints
arc consistency
important concept csps concept local consistency local consistencies
properties applied csp typically polynomial remove
inconsistent values prior search arc consistency commonly
used local consistency property existing constraint programming engines
give denition arc consistency
definition value xj consistent constraint ci xj vars ci
rel ci xj valid case say support
ci constraint ci arc consistent ac variable xj vars ci xj
exists support ci csp x c arc consistent empty
domain constraints c arc consistent
arc consistency enforced csp removing unsupported values
domains variables enforcing arc consistency local consistency property
general csp p mean applying yields csp
arc consistent property set solutions p
denition arc consistency applies constraints arity distinguish
binary non binary cases use term arc consistency ac refer
property arc consistency binary constraints non binary constraints
use term generalized arc consistency gac
usefulness ac processing recognized early ac
binary constraints proposed literature e g ac mackworth ac mohr henderson ac van hentenryck et al ac
bessiere et al ac bessiere regin ac zhang yap
extended non binary case e g gac mohr masini
gac schema bessiere regin gac bessiere regin
ac enforced binary csp ed optimal worst case time complexity
worst case complexity enforcing gac non binary csp ekdk bessiere regin

use ac gac theoretical empirical
comparisons specialized encodings restrictive
sense generic ac gac used instead


fisamaras stergiou

following debruyne bessiere call local consistency property stronger
b enforcing deletes least values b strictly
stronger stronger least one deletes values
b call equivalent b delete values similarly
call search stronger search b every visits
search tree nodes b strictly stronger stronger
least one visits less nodes b equivalent b visit
nodes
following bacchus et al asymptotic cost cost hereafter search
determined worst case number nodes
visit solve csp worst case time complexity node
bacchus et al use measure set asymptotic bounds
relative performance example two
b visit nodes enforces property node exponentially
higher complexity property enforced b say
exponentially greater cost b
functional piecewise functional constraints
specialized ac hidden variable dual encoding
describe sections exploit structural properties encodings
explain detail later binary constraints hidden variable encoding one way
functional binary constraints dual encoding piecewise functional
dene concepts
definition binary constraint c vars c xi xj functional respect
xi xj xi resp b xj exists one value
b xj resp xi b support c resp support b
example functional constraint xi xj binary constraint one way functional
functionality property holds respect one variables involved
constraint
informally piecewise functional constraint variables xi xj constraint
domains xi xj partitioned groups group xi
supported one group xj vice versa give formal denition
rst dene concept piecewise decomposition
definition van hentenryck et al let c binary constraint vars c
xi xj partitions sm xi sm xj
piecewise decomposition xi xj respect c sl sl
following property holds sl b sl b rel c sl b sl
b
rel c
bacchus et al cost applying variable ordering heuristic node
taken account theoretically compare search assume
use variable ordering take cost account



fibinary encodings non binary csps experimental

definition van hentenryck et al binary constraint c vars c
xi xj piecewise functional respect xi xj exists piecewise
decomposition sm xi sm xj respect
c sl resp sl exists one sl resp sl
sl b sl b rel c
example piecewise functional constraints modulo x mod x integer
division x div x constraints
binary encodings
two well known methods transforming non binary csp binary one
dual graph encoding hidden variable encoding encode non binary
constraints variables domains valid tuples constraints
building binary encoding non binary constraint store extensional representation
constraint set allowed tuples third method double encoding
combines two
dual encoding
dual encoding originally called dual graph encoding inspired work relational
databases dual encoding de dechter pearl variables swapped
constraints vice versa constraint c original non binary csp represented variable call dual variable denote vc refer variables
original non binary csp original variables domain dual variable vc
consists set allowed tuples original constraint c binary constraints
two dual variables vc vc exist vars c vars c constraints c
c share one original variables common vars set original variables
common c c tuple vc supported constraint vc
vc exists tuple vc common vars common vars

v c

v c
















v c

v c

figure dual encoding non binary csp


fisamaras stergiou

consider following example six variables domains four constraints
c x x x c x x x c x x x c x x
x de represents dual variables one constraint
domains dual variables tuples satisfy respective constraint
example dual variable vc associated third constraint domain
tuples values x x x
satisfy x x x second example dual variable vc associated
last constraint domain vc vc
compatibility constraint ensure two original variables common x x
values constraint allows pairs tuples agree
second third elements e vc vc vc
vc de shown figure
rest sometimes denote cvi non binary constraint
encoded dual variable vi original variable xj vars cvi pos xj cvi
denote position xj cvi instance given constraint cvi variables x x x
pos x cvi
hidden variable encoding
hidden variable encoding hve inspired work philosopher peirce
according rossi et al peirce rst showed binary relations
expressive power non binary relations
hve rossi et al set variables consists original variables
non binary csp plus set dual variables dual encoding dual
variable vc corresponds constraint c original domain dual
variable consists tuples satisfy original constraint every dual variable
vc binary constraint vc original variables xi
xi vars c tuple vc supported constraint vc xi
exists value xi xi
consider previous example six variables domains four constraints
c x x x c x x x c x x x c x x x
hve addition original six variables four dual variables
de domains variables tuples satisfy respective constraint
compatibility constraints dual variable vc original variables
contained constraint c example constraints vc x
vc x vc x variables involved constraint c
compatibility constraint cv x relation true rst element
tuple assigned cv equals value x hve shown figure
double encoding
double encoding stergiou walsh combines hidden variable dual
encoding hve set variables double encoding consists
variables original non binary csp plus dual variables every dual variable
vc binary constraint vc original variables xi involved
corresponding non binary constraint c de binary constraints


fibinary encodings non binary csps experimental

v c

v c









x

x

x

x



x



x








v c

v c

figure hidden variable encoding non binary csp
two dual variables vc vc non binary constraints c c share one
original variables

hidden variable encoding
section discuss specialized hve rst describe simple
ac hve worst case time complexity optimal
gac non binary representation appendix
arc consistent csp proposed ac performs exactly number
consistency checks corresponding gac arc inconsistent
ac hve detect inconsistency earlier thus
perform fewer consistency checks gac
consider search hve maintain local consistencies
search maintaining arc consistency generalizations forward
checking non binary csps emulated corresponding binary forward checking
hve instantiate original variables
arc consistency
proved ac hve equivalent gac non binary
stergiou walsh since hve binary csp one obvious way apply ac
generic ac however redundant processing
asymptotic time complexity worse ekdk precise hve
kary constraints ek binary constraints dual original variables
constraint ac enforced ddk worst case time complexity
whole complexity ekdk
instead describe simple ac operates hve
achieves worst case time complexity optimal gac applied
non binary representation achieve slightly modifying gac


fisamaras stergiou

bessiere regin gac figure sketch ac
hve call hac hidden ac
function hac

q

dual variable vj

variable xi xi vars cvj

revise xi vj ru e

xi empty return inconsistency

put q dual variable vl xi vars cvl

return p ropagation
function p ropagation

q empty

pop dual variable vj q

unassigned variable xi xi vars cvj

revise xi vj ru e

xi empty return inconsistency

put q dual variable vl xi vars cvl
return consistency
function revise xi vj
deletion false

value xi

currentsupportxi vj valid

vj lex currentsupportxi vj xi valid

currentsupportxi vj

else

remove xi

vl xi vars cvl

remove vl tuple xi

vl empty return inconsistency

deletion true
return deletion
figure hac ac hidden variable encoding
hac uses stack queue dual variables propagate value deletions works follows initialization phase iterates dual variable
vj line every original variable xi constrained vj revises
constraint vj xi done calling function revise line
revision value xi look tuple domain vj supports
ac store currentsupportxi vj recent tuple found
vj supports value variable xi tuple deleted vj
assume without loss generality looks supports checking tuples
lexicographic order



fibinary encodings non binary csps experimental

know supported otherwise look supporting tuple starting
tuple immediately currentsupportxi vj tuple found
removed xi line case tuples include value removed
domains dual variables constrained xi lines
dual variables already stack added dual variables
removed stack sequentially dual variable vj removed
stack revises constraint vj original variable xi constrained vj terminates values domain deleted
case arc consistent stack becomes empty case
arc consistent
main dierence hac gac gac include
lines even non binary constraints given extension gac remove tuples become invalid lists allowed tuples
two check validity tuple lines dierent
ways later section explain detail apart dierence
important aects run times two essentially
move hac gac removing lines substituting
references dual variables references corresponding constraints example
currentsupportxi vj corresponds currentsupportxi cvj gac e last tuple
constraint cvj supports value variable xi note implementation
gac propagation constraint utilizes stack
constraints perform propagation value deletions
complexities
give upper bound number consistency checks performed hac
worst case function revise xi vj called kd times dual variable
vj every deletion value domain xi xi one k original
variables constrained vj call revise xi vj performs
checks one value xi see currentsupportxi vj valid line
currentsupportxi vj valid hac tries nd supporting tuple vj
check tuple contains assignment xi supports need check
valid tuple valid one values removed domain
corresponding variable means tuple removed
domain dual variable therefore checking validity tuple done
constant time looking domain dual variable needs
check support dk maximum tuples contain assignment xi
since hac stores currentsupportxi vj call revise xi vj value
xi checks tuples checked words
check dk tuples value xi overall worst
case dk checks plus checks test validity current support
kd values upper bound checks performed hac make one dual variable ac
note dual variables already stack never added sense stack
implemented set



fisamaras stergiou

kd dk kdk e dual variables worst case complexity bound ekdk
complexity gac non binary representation
asymptotic space complexity hac dominated edk
space needed store domains dual variables requires nde
space store current supports since space required grows exponentially
arity constraints reasonable assume hve binary
encodings cannot practical constraints large arity unless constraints
tight
mentioned consistency check non binary representation done dierent
way hve assume gac looks support value ai xi
constraint c vars c x xk xi vars c tuple ak
supports ai xi ai valid check valid gac check
values ak except ai still domains variables x xk therefore
worst case consistency check gac involves k operations contrast
hac checks validity tuple constant time looking domain
corresponding dual variable see tuple still however means
update usually large domains dual variables value
deletion original variable aects run times dierent
settings
appendix hac complexity
performs exactly number consistency checks gac arc consistent
arc inconsistent dierence
number checks favor hve
search
search maintain local consistencies widely used csp solving
extended non binary case example maintaining arc consistency
mac forward checking fc shown non binary version mac
mgac applied non binary csp equivalent mac applied hve
csp original variables instantiated variable orderings used
stergiou walsh mgac non binary extensions fc
emulated equivalent run hve
fc haralick elliot rst generalized handle non binary constraints
van hentenryck according denition van hentenryck forward
checking performed k variables k ary constraint assigned
remaining variable unassigned called nfc bessiere
meseguer freuder larrosa stronger generalizations fc
non binary constraints introduced generalizations dier
extent look ahead perform variable instantiation nfc applies
one pass gac constraint constraint projection involving current variable
exactly one future variable nfc applies gac set constraints
involving current variable least one future variable one pass nfc
applies gac set constraints involving current variable least one future
one pass means constraint processed



fibinary encodings non binary csps experimental

variable nfc applies gac set constraints involving least one
past variable least one future variable one pass nfc
strongest version applies gac set constraints involving least one past variable
least one future variable generalizations reduce simple fc applied
binary constraints
versions nfc equivalent terms visited nodes
binary versions fc run hve holds
assumption binary assign original variables use
variable value ordering heuristics static dynamic non binary counterparts
note nds consistent assignment original variables
assignments propagated dual variables domains dual
variables reduced singletons domain dual variable vc
contain single tuple consistent assignments original variables
constrained vc therefore proceed assign dual variables
backtrack free manner
equivalence nfc version fc hve called fc bacchus
van beek proved bessiere et al fc specialized forward
checking hve operates standard binary fc except
domain dual variable pruned fc removes adjacent original variables
value longer supported
nfc nfc equivalent operate hve
call hfc hfc example hfc enforce ac set dual
variables original variables connected dual variable connected
least one past original variable least one future original variable note
nfc natural equivalent hve emulate hve
get inecient awkward following hfc refer standard
binary fc hfc refer fc

proposition non binary csp xed variable value ordering nfci equivalent hfci operates hidden variable
encoding
proof prove nfc strongest among generalized fc
proof versions similar need prove node
search tree nfc hfc delete exactly values
domains original variables assume node instantiating current
variable nfc deletes value future variable xi exists constraint
c including xi least one past variable value xi supporting tuple c
hve hfc tries make vc dual variable corresponding c ac
remove tuples assign xi hence hfc delete domain xi
opposite case hfc deletes value original variable xi means
tuples including assignment removed domains dual variables
include xi least one past variable non binary representation
assignment xi supporting tuples constraints involve xi
least one past variable therefore nfc delete domain xi


fisamaras stergiou

nfc nfc equivalent node visits corresponding hfc hfc asymptotic cost holds
condition non binary use gac optimal
enforce gac hve versions use hac
proposition non binary csp xed variable value ordering nfci asymptotic cost hfci operates
hidden variable encoding
proof section showed enforce ac hve non binary
csp worst case complexity gac non binary representation
since nfci enforces gac part
hfci enforces ac visit nodes search tree follows
two asymptotic cost
bessiere et al detailed discussion complexities nfc nfc made worst case complexity nfc nfc one node
cc f k dk cc f number constraints involving current variable least one future variable complexity hfc hfc
worst case complexity nfc nfc one node cp f k dk cp f
number constraints involving least one past variable least one future
variable complexity hfc hfc
assuming nodes algi set search tree nodes visited search
algi following holds
corollary given hidden variable encoding csp xed variable value
ordering schemes following relations hold
nodes hfc nodes hfc
nodes hfc nodes hfc
nodes hfc nodes hfc nodes hfc
nodes hfc nodes hfc nodes hfc
nodes mac nodes hfc
proof proof straightforward see bacchus van beek
proof straightforward consequence proposition corollary
bessiere et al hierarchy nfc nfc node visits
given easy see holds since hfc applies ac part csp
mac applies whole therefore mac prune least many
values hfc given node search tree since variable value
ordering heuristics used means mac visit number
nodes hfc
note bacchus van beek experimental differences fc hve fc non binary representation however


fibinary encodings non binary csps experimental

compared fc nfc equivalent
proved hfc exponentially greater cost nfc vice versa
bacchus et al however equivalent proved proposition bacchus et al hold comparing equivalent

far showed solving non binary csp directly many ways equivalent
solving hve assuming original variables instantiated
natural question whether search techniques inapplicable
non binary case applied encoding answer ability search
operates encoding instantiate dual variables equivalent
non binary representation would imply instantiating values one variables
simultaneously implement would modify standard search
heuristics devise ones hand hve
instantiates dual variables easily implemented

dual encoding
section turn attention de describe specialized ac
signicantly lower complexity generic
arc consistency
know ac de strictly stronger gac non binary representation
ac hve stergiou walsh since de binary csp one obvious
way apply ac generic ac domain size dual variable
corresponding kary constraint dk worst case therefore apply
optimal ac enforce ac one dual constraint k worstcase complexity de csp e constraints maximum arity k
e e binary constraints pairs dual variables share one
original variables therefore enforce ac de csp e k worstcase complexity signicantly expensive compared ekdk complexity
bound gac non binary representation ac hve
high complexity bound ac processing de considered impractical except
perhaps tight constraints
however ac applied de much eciently
precise enforce ac de non binary csp e dk worst case time
complexity improvement asymptotic complexity achieved exploiting
structure de namely fact constraints de piecewise
functional
consider binary constraint dual variables vi vj create piecewise
decomposition tuples domain dual variable groups
tuples group supported group tuples variable
non binary constraints corresponding two dual variables share f original variables
x xf domain size partition tuples vi vj df groups
tuple group includes sub tuple form af
x af xf tuple supported tuples group


fisamaras stergiou

variable tuple includes sub tuple af tuples
belonging supports tuple since tuple contain
sub tuple af words group tuples variable vi
supported corresponding group variable vj tuples groups
values original variables common two encoded non binary
constraints therefore constraints de piecewise functional
example assume two dual variables v v v encodes constraint
x x x v encodes constraint x x x original variables
x x domain partition tuples dual variable
groups rst group include tuples form second include tuples form third include tuples form
star means corresponding original variable take value group
supported corresponding group variable note tuples
variable vi partitioned dierent groups according constraint involves vi
instance another dual variable v encoding constraint x x x
partition tuples v according constraint v v groups
form
van hentenryck deville teng shown ac achieved
set binary piecewise functional constraints ed worst case time complexity
improvement compared ed complexity arbitrary binary constraints
van hentenryck et al since showed constraints de piecewise
functional van hentenryck et al means improve
e k complexity ac de
figure sketch ac ac specically designed de
call pw ac piecewise arc consistency
worst case time complexity e dk complexity bound achieved
ac van hentenryck et al specialization piecewise
functional constraints necessary adaptations operate de
ac pw ac uses stack queue propagate deletions domains
variables stack processes groups piecewise decompositions instead variables
constraints usual ac use following notation
vi vj vi vj sm vi vj denotes piecewise decomposition vi
respect constraint vi vj sl vi vj l
group partition
sup sl vi vj denotes group vj vi support group sl vi vj
vi vj discussed group unique
counter sl vi vj holds number valid tuples belong group sl vi vj
decomposition vi vj time value counter sl vi vj gives
current cardinality group
groupof vi vj function returns group vi vj tuple
belongs implement function constraint dual variables vi


fibinary encodings non binary csps experimental

function p w ac

q

initialize group counters

variable vi

variable vj constrained vi

tuple vi

counter groupof vi vj counter groupof vi vj

variable vi

variable vj constrained vi

group sl vi vj

counter sl vi vj

put sl vi vj q
return p ropagation
function p ropagation
q empty

pop group sl vi vj q



revise vi vj sl vi vj

vj empty return inconsistency

group sl vj vk put sl vj vk q
return consistency
function revise vi vj sl vi vj
tuple vj sup sl vi vj

remove vj

group sl vj vk includes

counter sl vj vk counter sl vj vk

counter sl vj vk

add sl vj vk
return
figure pw ac ac dual encoding

vj store original variables shared non binary constraints cvi
cvj original variable xl store pos xl cvi pos xl cvj
way groupof function takes constant time
set contains groups counter reduced call
function revise groups tuples belonging
deleted
works follows initialization phase group count
number tuples contains lines variable vi iterate


fisamaras stergiou

variables vj constrained vi group sl vi vj vi vj check
sl vi vj empty line empty added stack propagation
next phase function p ropagation called delete unsupported tuples
propagate deletions line previous phase nished stack
contain number groups cardinality group sl vi vj must
remove tuples belonging group sup sl vi vj since lost support
done successively removing group sl vi vj stack calling function
revise since group sup sl vi vj lost support tuple xj belongs
sup sl vi vj deleted lines apart sup sl vi vj tuple may belong
groups vj partitioned respect constraints vj
variables since deleted counters groups must updated e reduced
one done lines implementation use function groupof
access relevant groups counter group becomes group
added stack propagation lines process stops
stack domain variable becomes empty former case de ac
latter
following example illustrates advantage pw ac generic
ac employed de ac hve gac non binary representation
example consider three constraints c c c part csp vars c
x x x vars c x x x vars c x x x assume point
domains variables de shown figure disregarding
original variables depicted dashed lines assume try enforce ac

x x x

x x x

vc







vc









x

x x x





vc


x

figure dual encoding non binary csp
de ac discover rst tuple vc
support vc tuple x x delete
deletion rst two tuples vc lose support vc
ac must therefore look supports two tuples vc
check remaining tuples vc discovering
support two tuples deleted pw ac
hand set counter group rst tuple vc belongs according
partition vc vc deletes tuple call function
note construct similar examples generic ac



fibinary encodings non binary csps experimental

revise automatic deletion rst two tuples vc saving total
checks
consider hve applying ac hve eect
values x x supported vc vc therefore
propagation variables two tuples vc
deleted similarly propagation apply gac non binary
representation
note theoretical regarding de presented rest
hold ac van hentenryck et al adapted used de
instead pw ac two similarities e g use function
access group decomposition certain tuple belongs though implemented
dierently basic operation dierent van hentenryck et al
instantiation ac handles queue triples vi vj implement
constraint propagation vi vj two variables involved constraint
value removed vj pw ac utilizes queue piecewise
decompositions data structures used dierent pw ac
checks updates counters perform propagation explain requires
space exponential number common variables non binary constraints
van hentenryck et al utilizes complicated data structure
requires space exponential arity non binary constraints noted
however pw ac specically designed de operation data
structures way checks consistency fact domains
dual variables consist tuples original constraints extensionally stored
hand van hentenryck et al generic sense
adapted operate piecewise functional constraint
complexities
pw ac consists two phases initialization phase set group
counters main phase delete unsupported tuples propagate deletions
analyze time complexity pw ac note complexity analysis
measure operations incrementing decrementing counter since pw ac
perform consistency checks usual sense
proposition worst case time complexity pw ac e dk
proof assume constraint dual encoding non binary constraints corresponding two dual variables vi vj share f original variables
x xf domain size means piecewise decomposition consists
df groups obviously f equal k k maximum arity
constraints initialization phase lines iterate constraints
constraint variables vi vj iterate tuples vi
done e dk asymptotic time complexity empty groups inserted
q lines requires e df operations worst case initialization
function p ropagation called group inserted q later removed
becomes empty means loop p ropagation executed


fisamaras stergiou

df times constraint e df times total maximum
number times function revise called every iteration loop cost
function revise computed follows assuming revise called group sl vi vj
iterate dkf tuples group sup sl vi vj line iteration
remove tuple line update counters groups belongs
lines e groups case vj constrained dual
variables therefore iteration costs e call revise costs
edkf since revise called e df times complexity pw ac including
initialization step e dk e df e df edkf e dk
note pw ac easily used incrementally search case
initialization phase executed asymptotic space complexity pwac ac binary encoding dominated edk space need
store allowed tuples non binary constraints pw ac requires
e df space store counters groups e df space stack
f e space fast implementation function groupof

double encoding
double encoding rarely used experiments binary encodings although
combines features hve de therefore may exploit advantages
worlds precise double encoding oers following interesting potential
search deploy dynamic variable ordering heuristics assign values
original variables constraint propagation implemented constraints
dual variables achieve higher pruning section rst briey discuss
ac applied double encoding search
adapted operate double encoding
arc consistency
ac enforced double encoding pw ac addition
time value original variable xi loses supports adjacent dual
variable deleted xi alternatively use generic ac
ac note ac applied double encoding enforce
levels consistency depending constraints uses propagation dual
variables propagation done directly constraints
dual variables indirectly constraints dual original variables
example use constraints dual original variables get
level consistency ac hve propagation dual variables
performed constraints de get level consistency ac
de dual variables prune domains original variables
option use dierent constraints propagation dierent parts
next example shows ac double encoding achieve
high level consistency compared non binary representation sections
profound eect practice


fibinary encodings non binary csps experimental

example consider figure applying ac constraint
two dual variables determine insoluble however
non binary representation gac singleton generalized
arc consistent sgac high level consistency csp sgac
applying gac induced instantiation single variable
domain wipeout debruyne bessiere prosser stergiou walsh

x
x x x x


x




x

x x x x

x
vc













vc


x

figure double encoding ac double encoding sgac
non binary representation

search
search double encoding dened depending variables
instantiated constraints used propagation restrict
instantiate original variables perform propagation
constraints dual variables intuitively interesting class
combine nice features non binary representation
hve small domain sizes de strong propagation
rst fc versions hve discussed section adapted
yield run double encoding call dfc dfc
dfci instantiates original variables enforces ac
exactly set variables double encoding corresponding hfci
hve example dfc enforce ac set dual variables original
variables connected dual variable connected least one past
original variable least one future original variable dierence
dfci hfci former exploit constraints dual
variables enforce higher level consistency latter surprisingly
stronger
proposition non binary csp xed variable value ordering dfci strictly stronger respective hfci
proof easy see value pruned hfci hve
pruned dfci double encoding straightforward consequence
fact double encoding subsumes hve dfci hfci
enforce ac set variables dfci strictly stronger hfci


fisamaras stergiou

exploiting constraints dual variables prune values
hfci consider instance two constraints c c vars c
x x x x vars c x x x x variables xi domains
allowed tuples constraints rel c
rel c x given value hve
hfc hfc prune tuples domains dual
variables vc vc respectively pruning performed double
encoding variable assignment dfc dfc cause
domain wipe two dual variables
corollary non binary csp xed variable value ordering
dfci strictly stronger respective nfci
proof straightforward consequence propositions
easy see hfc e simple binary fc equivalent dfc
holds hfc dfc versions fc mac
adapted run double encoding original variables
instantiated propagation implemented constraints dual
variables easy see strictly stronger corresponding
hve proof similar proof proposition interestingly mac double encoding
polynomially greater cost corresponding mac hve
hand exponentially better
proposition non binary csp xed variable value ordering
mac hidden variable encoding instantiates original variables
exponentially greater cost corresponding mac double
encoding
proof prove use example bacchus et al
example csp n variables x x n domain
n n constraints
c x x mod x x mod
c x x mod x x mod

c n x n x n mod x n x n mod
c n x n x n mod x x mod
assume variables assigned lexicographic order double encoding x
x assigned values x x mod enforcing ac prune
tuples vc x x mod turn prune vc
tuples x x mod continuing way ac propagation prune
vc n values x x mod deletions propagated
vc vc become empty similar way enforcing ac assignments


fibinary encodings non binary csps experimental

x x x x mod leaves vc empty therefore csp
insoluble mac double encoding needs instantiate two variables discover
visit n nodes hand explained bacchus et al mac
hve needs visit nlog n nodes conclude insoluble finally
note node asymptotic costs mac double encoding pwac mac hve polynomially related therefore mac hve
exponentially worse mac double encoding
corollary proposition mac double encoding exponentially smaller cost mgac non binary representation
proposition non binary csp xed variable value ordering
mac double encoding instantiates original variables
polynomially greater cost corresponding mac hidden
variable encoding
proof prove need two things number node visits made
mac double encoding polynomial factor greater number
node visits made mac hve node worst case cost mac
double encoding polynomial factor greater worst case cost ac
hve former true since mac double encoding strictly stronger
mac hve latter established considering worst case complexities
node mac hve costs ekdk node mac
double encoding use pw ac enforce ac costs e dk therefore
polynomial dierence
similar way prove relationship proposition holds
dfci corresponding hfci corollary proposition mac double encoding polynomially greater cost
mgac non binary representation important note proposition
holds pw ac used enforce ac double encoding use
generic ac get exponential dierences favor mac
hve finally regarding relationship node visits among
double encoding following
proposition given double encoding csp xed variable value ordering schemes following relations hold
nodes dfc nodes dfc
nodes dfc nodes dfc
nodes dfc nodes dfc nodes dfc
nodes dfc nodes dfc nodes dfc
nodes dmac nodes dfc
proof proof simple comparing size subsets
enforces ac


fisamaras stergiou

experimental
section make empirical study binary encodings empirical
study organized two parts
rst part subsections evaluate improvements oered
specialized compared generic ones time compare
eciency run binary encodings non binary counterparts comparison give us better understanding encoding
non binary binary one pays encoding preferable
empirical investigation use randomly generated random
added structure benchmark crossword puzzle generation random
allow us relate performance certain parameters
tightness constraint graph density domain size crossword puzzles
standard benchmarks comparing binary non binary constraint allow us evaluate performance include
constraints high arity
second part subsection investigate usefulness binary encodings
realistic settings study use domains
conguration frequency assignment compare performance mac
run encodings mgac non binary representation
implemented c experiments run pc
ghz pentium processor gb ram experiments use
dom deg heuristic bessiere regin b dynamic variable ordering lexicographic value ordering
random
random instances generated extended model b described bessiere
et al summarize generation method random non binary csp dened
following input parameters
n number variables
uniform domain size
k uniform arity constraints
p density percentage generated graph e ratio existing constraints
number possible sets k variables
q uniform looseness percentage constraints e ratio allowed
tuples dk total tuples constraint
constraints allowed tuples generated following uniform distribution
made sure generated graphs connected following class non binary


fibinary encodings non binary csps experimental

csps denoted tuple form n k p q use star case
one parameters varied example tuple stands
class variables domain size arity graph density
varying constraint looseness
crossword puzzles
crossword puzzle generation used evaluation
heuristics csps ginsberg frank halpin torrance beacham chen sillito
van beek binary encodings non binary bacchus van beek
stergiou walsh crossword puzzle generation try construct puzzles
given number words given grid lled words
represented non binary binary csp straightforward way
non binary representation variable letter lled nonbinary constraint set k variables form word puzzle domain
variable consists low case letters english alphabet giving domain
size allowed tuples constraint words k letters
dictionary used compared k possible combinations letters
means constraints tight de variable word
length k puzzle possible values variable words k
letters dictionary gives variables large domains values
unix dictionary used experiments binary constraints
variables intersect e common letter hve
original variables well set dual variables one non binary constraint
hidden variable encoding
rst empirical study investigated performance two mac
operate hve compared mgac counterpart nonbinary representation two mac hve mhac
stands mac hve instantiates original variables mhac f ull
mac may instantiate variable dual original according
heuristic choice stated names three use ac gac
enforce ac although run experiments versions fc
include since inecient hard especially hard
crossword puzzles however qualitative comparison fc
hve non binary representation similar comparison regarding macbased
random
table shows performance measured cpu time classes
randomly generated csps classes hard phase transition region classes
sparse dense include mhac f ull
experiments showed similar behavior mhac
reason nature constraints dom deg heuristic almost


fisamaras stergiou

selects original variables instantiation rare cases heuristic
selected dual variables resulted large increase cpu time
class
mgac mhac















table comparison mgac mhac random classes
classes taken bessiere et al give
average run times seconds instances class winning
time instance given bold follow rest

table see mhac performs better mgac
sparse general ary classes tried density less
relative run time performance mhac compared mgac ranged
equal around times faster sparse class includes
ary constraints mhac considerably ecient mgac due fact sparse relatively large domain sizes
hard region located low constraint looseness e small domains dual variables
operations required revision dual variables another factor
contributing dominance binary class larger arity
constraints non binary requires operations check validity
tuples tuples large arity explained section
density graph increases class overhead revising domains
dual variables restoring failed instantiations slows mhac
outperformed mgac denser classes ones reported
phase transition region point half tuples allowed
cases non binary performs even better
crossword puzzles
table demonstrates performance search crossword puzzles
used benchmark puzzles papers ginsberg et al beacham et al
four puzzles could solved
within hours cpu time two puzzles arc inconsistent
cases gac discovered inconsistency slower ac hve around time
dierence latter method discovered early domain
wipe dual variable
rest puzzles observe mhac performs better mgac hard instances hard insoluble puzzles mhac times
faster mgac mainly due large arity constraints


fibinary encodings non binary csps experimental

puzzle










n










e mgac mhac mhac f ull





































table comparison cpu time hve
non binary representation crossword puzzles n number words e
number blanks times seconds except followed
minutes dash placed wherever manage nd
solution within hours cpu time marked insoluble
include reasonably hard least one
time solvable within hours least one

classes another interesting observation signicant dierences
performance methods may instantiate dual variables instantiate
original ones many cases mac f ull managed nd dierent solution
mhac mgac earlier hand mac f ull subject
thrashing instances methods terminate fact insoluble
puzzles mac f ull better mhac shows performance
largely dependent variable ordering scheme many cases mac f ull visited
less nodes mhac however reected similar time performance
dierence dual variable instantiated mac f ull work
original one instantiated instantiate automatically original
variable xi constrained dual variable propagate changes dual
variables containing xi
dual double encodings
empirical study investigated performance de double
encoding tried answer following three questions ecient specialized
compared generic use specialized
make de eective option solving non binary csps take advantage
theoretical properties double encoding practice answer questions
run experiments random structured evaluate benets oered
specialized pw ac maintaining ac search compared
puzzles correspond square grids blank squares



fisamaras stergiou

performance two mac one uses ac enforce ac mac another uses pw ac enforce ac mac pw ac compared
maintains gac non binary representation
gac mgac mac maintain ac double
encoding pw ac mac pw acd ac mac
random
rst give indicative comparison
random figure compares time required enforce ac de
gac non binary representation figures compare
maintain consistencies
figure shows average cpu times msecs pw ac ac take
enforce ac de random csps variables domain size ternary
constraints graph density constraints include average time gac takes enforce gac non binary representation generated instances
looseness constraints varied starting point instances gac
gac ac de delete values signicant dierence
performance pw ac compared ac constantly rises looseness
constraints becomes higher expected since number allowed tuples
constraint grows ac takes time nd supports gac faster
pw ac one order magnitude looseness low dierence
becomes smaller looseness grows
figure shows cpu times relatively sparse class variables
ternary constraints p figure shows cpu times node visits denser class
variables ternary constraints p along x axis vary domain
size variables data points average cpu times secs instances
taken hard phase transition region
make following observations mac pw ac mac pw acd signicantly faster one order magnitude mac mac respectively
classes classes non binary representation preferable de mgac two orders magnitude faster denser class
sparser class mac double encoding e mac pw acd competitive
mgac small domain sizes considerably faster larger domain sizes
eect domain size relative performance mainly due
run time advantage pw ac compared gac higher consistency
level achieved double encoding run time advantage pw ac explained
considering domain size increases gac check increasing number
tuples supports operation costly counter updates pw ac
denser class mgac constantly faster domain
sizes surprising considering e dk ekdk complexities pw ac
gac e factor e becomes signicant
figure compare mgac mac pw acd faster among
encodings class variables ary
verified looking node visits two



fibinary encodings non binary csps experimental




cpu time secs


cpu time msecs



ac
pw ac
gac






















q



















figure csps


mac
mac ac
mac pw ac
mac pw acd
mgac

mgac
mac pw acd


cpu time secs







figure csps

cpu time secs

mac
mac
mac pw ac
mgac
mac pw acd








































figure csps

figure csps

constraints encodings competitive class
see mgac ecient small domain sizes
larger domain sizes mac pw acd one order magnitude faster however
denser classes reversed
experiments random conjecture double encoding
preferred model sparse provided ecient
pw ac used propagation csps medium high density non binary
representation preferable encodings
random added structure experiments ternary csps
detect advantage de compared non binary representation
consequently hve mac de rarely better mgac
cases tight constraints large domain sizes despite use pw ac
propagation mac pw acd competitive often faster mgac sparse random reversed density increases basic
reason randomly generated especially ones ternary
constraints get many pairs non binary constraints share one original
variable known see bacchus et al example pair
constraints ltering achieved ac de ltering achieved
gac non binary representation ac hve therefore ac de
looses much ltering power


fisamaras stergiou

validate conjecture experimented generation model structure
added purely random precise experimented
clique variables embedded randomly generated instance ternary
two constraints clique may share one two variables decided random
ary two constraints clique may share one two three variables
decided random table compares performance mac
type second
class include mac pw acd far best
mgac
arity clique size mgac mac mac pw ac mac mac pw acd








































table average cpu times mac de double encoding
mgac non binary representation random embedded
cliques times seconds number gives average instances
around phase transition region
see comparative vary according size
embedded clique clique embedded clique size mgac
faster binary encodings clique size grows binary
encodings especially double become ecient double encoding
eective de clique sizes large clique covers variables mac
double encoding many orders magnitude faster mgac huge
dierence caused presence many constraints share one variable
non binary representation cases ltering constraints dual
variables strong however much advantage lost generic
used encodings similar occur denser generation
model used
crossword puzzles
table compares cpu times two mac de mgac
non binary representation benchmark crossword puzzles include
mac double encoding since particular representation crossword
puzzle generation impractical reason pair dual
variables involved constraint two variables one original variable
common e letter two words intersect explained previously


fibinary encodings non binary csps experimental

degrades ltering achieved constraints dual variables constraints
double encoding redundant since ltering achieved
constraints dual original variables

puzzle

















n

















e mgac mac mac pw ac

































































table comparison cpu time mac de mgac
non binary representation crossword puzzles times seconds except
followed minutes cpu limit hours marked
insoluble include reasonably hard
mgac mac pw ac time solvable within hours
least one

data table clearly see mac pw ac signicantly faster
mac instances speedup oered use pw ac makes mac
de competitive mgac many cases generic
de clear advantage favor mgac instances e g puzzles
use pw ac makes mac de considerably faster
mgac however still instances mgac consequently mhac
nds solution proves insolubility fast mac de thrashes vice versa
note hard puzzles tried solved
within time limit two hours mac pw ac managed solve
instances relatively fast two solved within
cpu limit


fisamaras stergiou

experiments realistic
next sections present experimental conguration frequency assignment aim experiments investigate usefulness binary
encodings realistic structured domains focus dual double encodings
promising binary encodings strong propagation oer
configuration
conguration area csp technology particularly eective conguration viewed trying specify product dened set attributes
attribute values combined predened ways
modelled csps variables correspond attributes domains variables
correspond possible values attributes constraints specify predened
ways values combined many conguration constraints
expressed extensionally lists allowed disallowed combinations values alternatively constraints expressed rules easily transformed
extensional representation consider following example adapted
subbarayan jensen hadzic andersen hulgaard moller
example conguration shirt requires specify size small
medium large print men black mib save whales stw
color black white red following constraints small size chosen
stw print cannot selected mib print chosen black color
chosen well stw print chosen black color cannot selected
conguration modelled csp three variables x x x representing size print color respectively domains variables x
small medium large x ib st w x black white red
rst constraint binary constraint variables x x following allowed
tuples small ib medium ib medium st w large ib
large st w second constraint binary constraint variables x x
following allowed tuples ib black st w white st w red
practice many solvers conguration able interact user
apart meeting given specications users choices values certain
attributes satised study use conguration instances compare
non binary representation binary encodings structured realistic although
would interesting investigate applicability binary encodings interactive
congurator work outside scope
run experiments taken clib library benchmark conguration clib rst thing noticed encoding
binary non binary csps trivially solvable without
backtracking closer look structure clibss revealed reason
constraint graphs consist unconnected components component consists
cases single variable split independent subproblems trivially solved order obtain dicult
instances benchmarking made graphs connected adding randomness


fibinary encodings non binary csps experimental

extended adding variables constraints
graph became connected table shows total number variables
constraints modied added constraints arity chosen
random variables posted selected random making
sure resulting graph connected looseness added constraint
set random nally allowed tuples constraint chosen random
according looseness

n

e arity dom

machine
fx
fs
esvs
bike

























mgac
mac pw ac mac pw acd
nodes time
nodes time
nodes time














table comparison conguration arity dom
maximum constraint arity maximum domain size run times
given seconds

table gives average run times node visits mgac
non binary representation mac pw ac de mac pw acd double
encoding benchmarks repeatedly generated instances
model described generated instance solved three
stored instance hard least one otherwise discarded
instance considered hard least one took one second
solve table reports averages rst hard instances generated
benchmark run hard instances total note binary encodings
constraints original even binary ones encoded dual variables
experimental table signicant advantage favor
binary encodings compared non binary representation node visits run
times de clearly ecient model mac pw ac de
three orders magnitude faster mgac non binary representation
single instance among instances mgac faster
mac pw ac double encoding much ecient non binary
representation main factor contributing performance encodings
strong propagation achieved constraints dual variables
reected numbers node visits number reasons related
structure conguration justify strong performance
encodings
experiments showed minimum additions need made order get hard
without altering structure much



fisamaras stergiou

constraint graphs sparse typical conguration since
usually attribute product specication dependencies
attributes
constraints high arity tight moreover value variables
large domain sizes typically one supporting tuple constraints
variables participate
intersecting non binary constraints one original variable
common explained demonstrated empirically section
signicant impact propagation power ac dual double encodings
note prole conguration analyzed agrees conjectures made random dual double
encodings suitable sparse tight constraints intersecting constraints may share one variable
frequency assignment
frequency assignment important radiocommunication industry
radio communications network given region consisting
set transmitters transmitter position region frequency spectrum
certain power directional distribution aim assign values
properties transmitters certain criteria satised
types frequency assignment study consider version radio
link frequency assignment rlfa given set links
l ln consisting transmitter receiver link must assigned
frequency given set f time total interference receivers must
reduced acceptable level frequencies possible
typically optimization purposes study treat
satisfaction
rlfa modelled csp transmitter corresponds
variable domain variable consists frequencies assigned
corresponding transmitter interferences transmitters modelled
binary constraints form xi xj xi xj variables
required frequency separation constraint restricts frequencies two
transmitters simultaneously assigned way interference
minimized realistic assumption closer two frequencies
greater interference binary model used extensively
represent rlfa numerous solution methods csp
proposed rlfa widely used benchmark test
binary constraints mainly ac
argued standard binary model frequency assignment
fails capture important aspects real multiple interferences
resulting non optimal frequency assignments jeavons dunkin bater watkins
hurley smith bater hodge hurley smith consequence
eorts introduce expressive methods utilize non binary


fibinary encodings non binary csps experimental

constraints frequency assignment e g bater hodge et al many
types non binary constraints considered following ones received
attention
co channel constraints e g frequencies assigned n transmitters equal
adjacent channel constraints e g frequencies assigned n transmitters
least one frequency apart
separation constraints e g frequencies assigned n transmitters least
frequencies apart
obviously separation constraints generalize adjacent channel constraints rst
two types constraints typically loose third tight separation
constraints used densely constrained areas representing conurbations region
large number links closely situated cases large separations
frequencies transmitters must imposed resulting tight constraints
consider richer type separation constraints frequencies assigned set n
transmitters least frequencies apart n transmitters among least
frequencies apart others note non binary constraints
equivalently decomposed clique binary constraints without introducing
dual variables resulting however weaker propagation example adjacent channel
constraints others cannot equivalently expressed set binary constraints unless
binary encoding used example co channel constraints noted hodge et al
non binary constraints low arity utilized practice
shown many cases constraints sucient achieve low interferences
constraints higher arity may oer improvements quality solutions tend
slow solution process extend solving large real becomes
infeasible
empirical study presented interested comparing rlfatype non binary constraints corresponding binary encodings
devising ecient methods solving rlfa since available rlfa
benchmarks follow standard binary test generated nonbinary placing variables corresponding links grid following typical
rlfa structure consist several groups closely situated variables
plus constraints connect groups example structures depicted
figure corresponds constraint graph binary rlfa
typically consists set cliques near cliques binary constraints small number
constraints connecting cliques e g benchmarks cabon de givry
lobjois schiex warners binary encodings considered
double since dual variables large domains makes de inecient
indicative experiments run depicted table experiments
posted low arity e ary ary separation constraints shown figure
compared performance mgac non binary model
performance mac pw acd double encoding
tried two implementations mgac one utilizes specialized propagators


fisamaras stergiou

prob

b prob

c prob

figure examples rlfa non binary separation constraints

separation constraints written functions another operates extensional
representation constraints rst implementation generally faster
mgac presented refer intentional implementation double
encoding built translating separation constraints lists allowed tuples
preprocessing step


prob
prob
prob
prob
prob
prob
prob
prob
prob
prob
prob
prob
prob
prob
prob

easiest
median
hardest
easiest
median
hardest
easiest
median
hardest
easiest
median
hardest
easiest
median
hardest

n
















e arity
































mgac
mac pw acd
nodes time
nodes time






























table comparison rlfa separation constraints arity
maximum constraint arity run times given seconds dash
placed wherever nish run within hours cpu time



fibinary encodings non binary csps experimental

table reports total instances created dierent constraint
graph topologies variables domains values number allowed
tuples constraints varied around tight constraints several thousands looser ones according frequency separation imposed parameters
separation constraints parameters set random constraint
making sure loose constraints generated example ary basic
separation constraint variables domain size least giving allowed
tuples giving allowed tuples
prob prob prob refer topologies shown figure
prob consists three groups variables similar ones prob arranged
chain structure finally instances prob consist randomly generated groups
variables one variables ary ary constraints groups
interconnected according topological distance e constraints posted
variables nearby groups instances prob prob xed topology
topology set instances created changing type constraints example
two instances topology prob may dier type separation constraints
basic richer include frequency separations imposed
constraint may dier instances prob may dier constraint graph topology
report node visits run times easiest median hardest instance
topology respect performance mgac hardest instances
encoding non binary representation except prob easiest
median instances sometimes dierent
table see substantial dierences favor
double encoding many instances solvable double encoding
little backtracking mgac thrashed mainly due large number
interleaved constraints sharing one variable boosts propagation
double encoding performance seems heavily dependent
topology example instances prob non binary representation
much ecient double encoding seems particular class
heuristic choices misled propagation achieved double encoding
able come satisfactory explanation occurred
particular topology
finally investigate eect presence loose constraints higher arity
run experiments ary adjacent channel constraints posted
variables apart graph addition separation constraints
case double encoding model constraints infeasible
due spatial requirements example trying generate allowed tuples
single ary adjacent channel constraint consumed memory system therefore
compared mgac non binary model mac
runs hybrid model tight separation constraints modelled
double encoding loose adjacent channel constraints kept intentional nonbinary representation table reports total instances created
create instances varied type constraints values parameters
non trivial generated consider trivial arc inconsistent solvable
backtracking



fisamaras stergiou


prob
prob
prob
prob
prob
prob
prob
prob
prob

easiest
median
hardest
easiest
median
hardest
easiest
median
hardest

n










e arity




















mgac
mac hybrid
nodes time
nodes time



















table comparison rlfa separation adjacentchannel constraints mac hybrid corresponds mac runs
hybrid model

graph topologies prob prob prob addition four ary adjacent channel
constraints instance hybrid model ecient instances prob
prob strong propagation achieved binary encoding tight
constraints non binary model better instances prob seems
propagation binary encoding bad heuristic choices
discussion
section summarize experimental studies draw conclusions regarding applicability encodings theoretical experimental
analysis
hidden variable encoding theoretical suggested empirical conrmed solving hve instantiate original variables
essentially analogous solving non binary representation directly commonly
used non binary applied adjustments hve
vice versa used hve oers moderate computational
savings compared non binary representation especially sparse
savings due ability ac hve detect inconsistencies earlier corresponding gac non binary representation therefore
conjecture hve applicable sparse non binary constraints
extensionally specied cases hve less ecient run times
non binary representation e g dense building hve adds space
overheads justied marginal gains search eort additionally
enough empirical evidence suggest essential dierence search
hve non binary representation e ability former
branch dual variables make hve signicantly ecient class


fibinary encodings non binary csps experimental

coupled fact benets gained instantiating dual
variables maximized double encoding used instead hve limits
applicability
dual double encodings de double encoding advantage
strong ltering constraints dual variables showed
advantage exploited low cost specialized pw ac make
de competitive often signicantly better non binary representation
several sparse csps crossword puzzle generation conguration
dense csps de pay spatial requirements make use
infeasible case advantages oered outweighed overhead
updating domains dual variables holds csps containing constraints
large arity unless tight crossword puzzles
double encoding demonstrate especially promising performance
many non binary constraints share one variable present
mac double encoding exploit benets variable
ordering heuristic borrowed non binary representation stronger ltering
borrowed de outperform representations demonstrated
structure random frequency assignment
case still life explains success double encoding
addition double encoding oers interesting potential hybrid certain
constraints encoded binary others kept non binary representation
certain properties constraints precise benet encoding
constraints naturally specied extension relatively low arity
tight demonstrated domains notably frequency assignment double encoding hybrid one payed cases
although constraints naturally dened intentionally

related work
although de proposed dechter pearl hve rossi
et al rst substantial eort towards evaluating eciency carried
bacchus van beek work bacchus van beek compared theoretically empirically fc two encodings fc non binary
csps introduced fc specialized hve
compared bacchus van beek simplest versions fc hfc hfc e
fc hve nfc non binary representation extend work
studying recent advanced versions fc
following bacchus van beek stergiou walsh made theoretical
empirical study ac encodings stergiou walsh proved ac
hve equivalent gac non binary representation ac de
stronger small experimental study included stergiou walsh
mac hve de double encoding compared mgac non binary
although title smiths refers de model still life used
double encoding



fisamaras stergiou

representation crossword puzzles golomb rulers showed
advantage non binary representation hve important note
mac used generic inecient enforce ac
smith stergiou walsh performed extensive experimental comparison
mac hve double encoding mgac non binary model
golomb rulers however mac encodings used generic
enforce ac outperformed mgac non binary
model
beacham et al compared performances dierent heuristics
csps crossword puzzle generation benchmarks among
compared hve de non binary representation
applied encodings generic
example two implemented de mac uses ac
propagation mac uses ac suer high complexity ac propagation demonstrated use pw ac propagation
signicantly enhance performance mac crossword puzzle
bacchus et al presented extensive theoretical study de hve
among polynomial bounds placed relative performance fc
mac two encodings non binary representation shown
polynomial bound exists example shown fc hve e hfc
terminology use never polynomial factor worse fc de
fc de exponentially worse fc hve fc non binary
representation e nfc terminology use exponentially worse fc
hve vice versa add analyzing performance
advanced hve double encoding
smith modelled nding maximum density stable pattern still life
conways game life mac double encoding remarkable success
compared constraint programming integer programming approaches smith
mac implemented table constraint ilog solver
constraint implements generic ac bessiere regin
expensive used de high time complexity believe
presented smith improved mac pw ac used instead

conclusion
studied three binary translations non binary csps hidden variable
encoding dual encoding double encoding showed common perception standard binary csps used encodings non binary
csps suers aws namely standard exploit structure encodings end inecient address proposed specialized arc
consistency search encodings evaluated theoretically
empirically showed arc consistency enforced hidden variable
encoding non binary csp worst case time complexity generalized arc
consistency non binary representation showed structure constraints
dual encoding exploited achieve much lower time complexity


fibinary encodings non binary csps experimental

generic empirical demonstrated use specialized
makes dual encoding signicantly ecient showed generalized search
non binary csps relatively easily adjusted operate hidden
variable encoding showed double encoding
designed exploit properties double encoding strong ltering branching original variables achieve good certain
empirical random structured showed certain classes
non binary constraints binary encodings competitive option many cases
better one solving non binary representation

acknowledgements
would thank panagiotis karagiannis nikos mamoulis toby walsh
help stages work would thank anonymous reviewers
earlier version useful comments suggestions

appendix
explained main dierence ac hve corresponding gac fact ac update domains
dual variables well original ones incurs time overhead
deleting values dual variables help propagation discover domain wipe outs
arc inconsistent faster
proposition let p non binary csp assume generalized arc consistency applied p domain wipeout resulting enforcing arc
consistency hidden variable encoding p hac requires number
consistency checks enforcing generalized arc consistency p gac assuming two follow ordering variables values looking
supports propagating deletions
proof first consider domain wipeout variable original dual occurs
two add constraints dual variables stack remove
revision exactly order therefore need
value deleted variable revision constraint nds support
constraint operations require number checks
representations assume non binary version value deleted
domain variable xi support constraint c
number allowed tuples c determining lack support require
currentsupportxi c checks one tuples c checked yet
value deleted nds support currentsupportxi c
currentsupportxi c checks performed hve xi processed
order non binary version require currentsupportxi vc
currentsupportxi vc checks depending case obviously currentsupportxi c
currentsupportxi vc since tuple c corresponds value vc
therefore number checks performed representations


fisamaras stergiou

proposition let p non binary csp assume application generalized
arc consistency p domain wipeout hac applied hidden
variable encoding p discovers domain wipeout number
consistency checks gac non binary representation assuming
two follow ordering variables values looking supports
propagating deletions
proof csp arc inconsistency detected domain variable wiped
applying ac hve non binary csp arc inconsistency detected
domain original variable wiped crucially domain dual
variable wiped second possibility make ac operates
hve ecient corresponding gac prove consider
arc inconsistent non binary assume domain original variable xi
wiped processing constraint c encoded dual variable vc
hve point function revise called xi c arguments
inconsistency according proposition gac
ac hve perform number consistency checks assume
j values left xi call revise function revise
unsuccessfully look support j values number allowed
tuples c value xi require currentsupportxi c checks
gac currentsupportxi vc checks ac since
currentsupportxi c currentsupportxi vc two perform
number consistency checks detect domain wipeout
following example demonstrates hac may discover inconsistency less
checks consider variables x x x x domains
respectively two constraints c c vars c
x x x vars c x x x respectively value x supported c
tuples include assignment x value x supported c tuples
include assignment x constraint c allows tuples include assignment
x values x supported c tuples include x tuples
include x assume variable x instantiated means
deletion x must propagated hve rst delete
tuples include value x dual variables vc vc add dual
variables vc vc stack remove revise original variables connected
assuming vc removed rst value x support vc
deleted delete tuples dual variable vc include
pair x means domain vc wiped non binary
representation proceed similar way perform number checks
deleted x deletion look supports c
value x values x involve checks avoided hve
inconsistency discovered later process constraint c nd
value x support c resulting domain wipeout x



fibinary encodings non binary csps experimental

references
bacchus f chen x van beek p walsh binary vs non binary csps
artificial intelligence
bacchus f van beek p conversion non binary binary
constraint satisfaction proceedings aaai pp
bater j non binary higher order modelling solution techniques frequency assignment mobile communications networks ph thesis university
london
beacham chen x sillito j van beek p constraint programming lessons
learned crossword puzzles proceedings th canadian conference
ai
bessiere c freuder e regin j inference reduce arc consistency
computation proceedings ijcai pp
bessiere c meseguer p freuder e larrosa j forward checking
non binary constraint satisfaction artificial intelligence
bessiere c regin j arc consistency general constraint networks preliminary proceedings ijcai pp
bessiere c regin j b mac combined heuristics two reasons forsake
fc cbj hard proceedings cp pp
bessiere c regin j rening basic constraint propagation
proceedings ijcai pp
cabon b de givry lobjois l schiex warners j radio link frequency
assignment constraints
clib conguration benchmarks library http www itu dk doi vecos clib
maintained vecos group university copenhagen
debruyne r bessiere c domain filtering consistencies journal artificial
intelligence
dechter r pearl j tree clustering constraint networks artificial intelligence
ginsberg frank halpin torrance search lessons learned
crossword puzzles proceedings aaai pp
haralick r elliot g increasing tree search eciency constraint satisfaction artificial intelligence
hodge l hurley smith higher order constraint techniques
frequency assignment tech rep university cardi
jeavons p dunkin n bater j higher order constraints necessary
model frequency assignment ecai workshop non binary
constraints
mackworth consistency networks relations artificial intelligence


fisamaras stergiou

mamoulis n stergiou k solving non binary csps hidden variable
encoding proceedings cp pp
mohr r henderson arc path consistency revisited artificial intelligence
mohr r masini g good old discrete relaxation proceedings ecai
pp
peirce c collected papers vol iii cited f rossi c petrie v dhar
prosser p stergiou k walsh singleton consistencies proceedings
cp pp
regin j filtering constraints dierence csps proceedings
aaai pp
rossi f petrie c dhar v equivalence constraint satisfaction
proceedings ecai pp
smith b dual graph translation life proceedings
cp pp
smith b stergiou k walsh auxiliary variables implied constraints model non binary proceedings aaai pp
stergiou k walsh encodings non binary constraint satisfaction proceedings aaai pp
subbarayan jensen r hadzic andersen h hulgaard h moller j
comparing two implementations complete backtrack free interactive congurator proceedings cp workshop csp techniques immediate
application pp
van hentenryck p ed constraint satisfaction logic programming mit
press
van hentenryck p deville teng c generic arc consistency
specializations artificial intelligence
watkins w hurley smith area coverage frequency assignment evaluation area coverage tech rep university glamorgan presented
informs
zhang yap r making ac optimal proceedings
ijcai pp




