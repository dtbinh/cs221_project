journal artificial intelligence

submitted published

engineering note
optiplan unifying ip graph
menkes h l van den briel

menkes asu edu

department industrial engineering
arizona state university tempe az usa

subbarao kambhampati

rao asu edu

department computer science engineering
arizona state university tempe az usa

abstract
optiplan system first integer programming planner
successfully participated international competition engineering note
describes architecture optiplan provides integer programming formulation
enabled perform reasonably well competition touch upon
recent developments make integer programming encodings significantly competitive

introduction
optiplan system uses integer linear programming ip solve strips
first system take part international
competition ipc judged second best performer four competition domains
optimal track propositional domains optiplans underlying integer programming
formulation extends state change model vossen colleagues architecture similar blackbox kautz selman gp csp
kambhampati instead unifying satisfiability sat constraint satisfaction
csp graph optiplan uses integer programming blackbox
gp csp optiplan works two phases first phase graph built
transformed ip formulation second phase ip formulation solved
commercial solver ilog cplex ilog inc
practical difference original state change model optiplan
former takes input ground actions fluents initialized plan steps
latter takes input actions fluents instantiated graphplan
blum furst well known use graphs significant
effect size final encoding matter combinatorial transformation method
ip sat csp used instance kautz selman well kambhampati
pointed blackboxs success satplan kautz selman mainly
explained graphplans ability produce better refined propositional structures
satplan addition optiplan allows propositions deleted without required
preconditions state changes modeled original state change model
therefore optiplan considered general encoding one although
c

ai access foundation rights reserved

fivan den briel kambhampati

minor implementation detail optiplan state change model optiplan
reads pddl files
engineering note organized follows section provides brief background
integer programming section discusses previous ip approaches section
describes optiplan system underlying ip formulation section
give experimental look optiplans performance international
competition ipc conclusions brief discussion recent
developments given section

background
linear program represented linear objective function set inequalities
min cx ax b x x n dimensional column vector variables
n matrix c n dimensional row vector b dimensional column vector
variables constrained integers integer linear program
variables restricted values binary integer program
widely used method solving general integer programs branch
bound linear programming relaxation branch bound general search
method subproblems created restrict range integer variables
linear programming relaxation linear program obtained original integer
program omitting integrality constraints ideal formulation integer program
one solution linear programming relaxation integral even though
every integer program ideal formulation wolsey practice hard
characterize ideal formulation may require exponential number inequalities
ideal formulation cannot determined often desirable
strong formulation integer program suppose p min cx x b x
p min cx x b x linear programming relaxations two ip
formulations say formulation p stronger formulation p
p p set solutions p subsumed set solutions p

integer programming approaches
despite vast amount conducted field ai
use linear programming lp integer linear programming explored
marginal level quite surprising since mixed integer linear programming provide
feasible environments numeric constraints arbitrary linear objective functions
two important aspects real world
handful works explored use lp ip techniques ai
bylander developed ip formulation classical used lp relaxation heuristic partial order however seem scale
well compared graph satisfiability planners
difficulty developing strong ip formulations performance often depends way ip formulation constructed vossen et al compared two
formulations classical first consider straightforward ip formulation
converting propositional representation given satplan kautz selman


fioptiplan unifying ip graph

ip formulation variables take value certain proposition
true otherwise formulation assertions expressed ip constraints
directly correspond logical conditions propositional representation second
consider ip formulation original propositional variables replaced
state change variables state change variables take value certain proposition
added deleted persisted otherwise vossen et al formulation
state change variables outperforms straightforward formulation converting
propositional representation
dimopoulos improves ip formulation state change variables identifying valid inequalities tighten formulation yet even stronger ip formulations
given bockmayr dimopoulos ip formulations contain
domain dependent knowledge therefore limited solving specific
domains
lp ip techniques explored non classical dimopoulos
gerevini describe mixed integer programming formulation temporal wolfman weld use lp formulation combination sat
formulation solve resource kautz walser use ip
formulations resource addition incorporate action costs
complex objectives
far none ip approaches ai ever participated ipc making
harder assess relative effectiveness line work optiplan planner
state change formulation first ip planner

optiplan
optiplan graph planner works follows first build
graph level goal fluents appear non mutex compile
graph integer program solve plan found
graph extended one level graph compiled integer program
solved process repeated plan found
remainder section give ip formulation used optiplan
order present ip formulation use following notation f set fluents
set actions operators fluents true initial state
fluents must true goal given g respectively furthermore
use sets
pref f f set actions fluent f precondition
addf f f set actions fluent f add effect
delf f f set actions fluent f delete effect
variables defined layer graph
variables actions variables possible state changes fluent
make variables reachable relevant graph analysis
instantiated action variables


fivan den briel kambhampati

ya



action executed period
otherwise

op actions included ya variables represented separately
state change variable xmaintain

f
optiplan state change formulation vossen et al formulation fluents represented explicitly instead state change variables used model
transitions world state fluent true added state
preadd
xadd
persisted previous state xmaintain
optiplan extends
f xf
f
state change formulation vossen et al introducing extra state change
variable xdel
f allows actions delete fluents without requiring preconditions
original state change formulation allow actions therefore added
state change variables keep track state changes altered model
take variables account ipc domains airport psr
many actions delete fluents without requiring preconditions therefore making
original state change formulation ineffective optiplan instantiates
variables constraints reachable relevant graph analysis
therefore creates smaller encoding original one f f
following state change variables

fluent f propagated period
maintain

xf
otherwise

action executed period pref
delf
preadd
xf

otherwise

action executed period pref delf
predel
xf

otherwise

action executed period
pref addf

xadd
f
otherwise

action executed period tsuch
pref delf
xdel

f
otherwise
summary xmaintain
truth value fluent propagated xpreadd

f
f
action executed requires fluent delete xpredel
action
f
add
executed requires fluent deletes xf action executed
require fluent adds xdel
f action executed require
fluent deletes complete ip formulation optiplan given following
objective function constraints

objective
classical ai minimization maximization required instead
want feasible solution search solution however may guided


fioptiplan unifying ip graph

objective function minimization number actions currently
implemented optiplan objective function given
min

xx

ya



aa

since constraints guarantee feasibility could used linear objective function example could easily set objective deal cost sensitive plans
context non uniform action cost utility sensitive plans context oversubscription goal utilities metric transformed linear
expression indeed flexibility handle linear objective function one advantages ip formulations

constraints
requirements initial goal transition given
xadd
f
maintain preadd
xadd
xf
f xf
maintain
xadd
xpreadd
f xf
f

f





f






f g



constraints add initial fluents step used
actions appear first layer step graph constraints
represent goal state requirements fluents appear goal must
added propagated step
state change variables linked actions following effect implication
constraints f f
x
ya xadd

f
aaddf pref

ya xadd
f
x

ya

addf pref

xdel
f




adelf pref

ya xdel
f
x

delf pref

ya xpreadd
f




apref delf

ya xpreadd
f
x

ya xpredel
f

pref delf




apref delf

constraints represent logical relations action
state change variables equality sign actions f


fivan den briel kambhampati

precondition delete effect mutually exclusive means
substitute xpredel
variables done implementation
f
optiplan however use variables clarity mutexes appear
different state change variables expressed constraints follows

predel
maintain

xdel
xadd
f xf
f xf



predel
xpreadd
xmaintain
xdel

f
f xf
f



constraints restrict certain state changes occurring parallel
del
example xmaintain
propagating fluent f step mutually exclusive xadd
f
f xf
xpredel
adding deleting f
f
finally backward chaining requirements binary constraints represented

add
maintain
xpreadd
xmaintain
xpredel
xpreadd
f
f
f
f xf xf

f f



del maintain
xpreadd
xpredel
xadd

f xf xf
f
f



ya



constraints describe backward chaining requirements fluent
f added maintained step state f changed action step
xpreadd
xpredel
propagated xmaintain
constraints
f
f
f
binary constraints state change action variables respectively

loc

truck

loc

truck

figure simple logistics example

example
example constraints initialized comment
interaction state change variables action variables
consider simple logistics example two locations two trucks
one package package transported one location another one
trucks built formulation three plan steps initial state package


fioptiplan unifying ip graph

trucks location given figure initial state constraints
xadd
pack

loc

xadd
truck

loc
add
xtruck loc
add maintain preadd
xf xf
xf






f

goal get package location three plan steps expressed
follows
xadd
pack

loc

xmaintain
pack

loc

xpreadd
pack

loc



write effect implication constraints comment
xadd
f certain fluent f execute least one action
f add effect precondition example
yunload

truck loc

yunload

truck loc

xadd
pack

loc

preadd
state changes xdel
similar requirement change
f xf
state del preadd must execute least one action corresponding effects hand execute action must change
fluent states according effects example

yunload

truck loc

xadd
pack

yunload

truck loc



yunload

truck loc



loc
preadd
xtruck loc
xpredel
pack truck

one one correspondence note equality sign execution
actions xpredel
state change variables actions
f
predel effect must mutex mutexes present state changes example
fluent f maintained propagated cannot added deleted two state
changes mutex add preadd add state
change behaves preadd state change corresponding fluent already present
state world introduce two separate mutex constraints one
includes add state change one includes preadd example
constraints mutex state changes follows
xadd
pack

truck

xpreadd
pack

truck

xmaintain
pack

truck

xdel
pack

truck

xpredel
pack

truck



xmaintain
pack

truck

xdel
pack

truck

xpredel
pack

truck



state fluent change another state correct state changes
occurred previously hence fluent deleted propagated used preconditions
step added propagated step example
xpreadd
pack

predel
maintain
truck xpack truck xpack truck
add
maintain
xpreadd
pack truck xpack truck xpack truck





fivan den briel kambhampati


xadd
pack
xadd
truck
xadd
truck

loc


yload truck loc
xadd
pack truck
xpredel
pack loc
xpreadd
truck loc

loc

xmaintain
truck

loc


ydrive truck loc loc
xmaintain
pack truck
xadd
truck
xpredel
truck

loc


yunload truck loc
xadd
pack loc
xpredel
pack truck
xpreadd
truck loc

loc

loc

table solution simple logistics example displayed variables value
variables value

simple total variables action state change
constraints however graph analysis fixes variables action state
change zero substituting values applying presolve techniques
built ilog cplex solver variables constraints
solution example given table note actions
actively delete f nothing ensures xmaintain
true whenever f
f
true preceding state example see fluent truck loc since negative
preconditions allowed option letting xmaintain
false
f
true cannot cause actions become executable
miss solutions constraints ensure goal fluents satisfied
therefore forcing xmaintain
true whenever helps us generate plan
f

experimental
first compare optiplan original state change model check
optiplan performed ipc
optiplan original state change formulation implemented two different
languages optiplan implemented c concert technology set
libraries allow embed ilog cplex optimizers ilog inc
original state change model implemented ampl fourer gay kernighan
modeling language mathematical programming order compare
formulations produced two implementations written output
file mps format mps standard data format often used transferring
linear integer linear programming different applications
mps file contains ip formulation written read
solved ilog cplex pentium ghz gb ram
table shows encoding size two implementations encoding size
characterized number variables number constraints formulation
encoding size applying ilog cplex presolve given presolve
reduction technique brearley mitra williams helps linear
programming simplifying reducing eliminating redundancies short


fioptiplan unifying ip graph


bw sussman
bw step
bw large
att log
log easy
log

state change model
presolve
presolve
var cons var cons

























optiplan
presolve
presolve
var cons var cons

























table encoding size original state change formulation optiplan
ilog cplex presolve var cons give number variables
constraints respectively


bw sussman
bw step
bw large
bw large b
att log
att log
att log
att log
att log
att loga
rocket
rocket b
log easy
log
log b
log c

var

















state change model
cons nodes

































time

















var

















optiplan
cons nodes

































time

















table performance encoding size original state change formulation optiplan var cons give number variables constraints
ilog cplex presolve nodes give number nodes explored
branch bound finding first feasible solution



fivan den briel kambhampati

presolve tries remove redundant constraints fixed variables formulation
aggregate substitute variables possible
encoding size presolve actual encoding size
see significant use graphs optiplan instantiates
fluents actions reachable relevant graph
analysis produces encodings cases one order magnitude smaller
encodings produced original state change model instantiates ground
fluents actions although difference encoding size reduces substantially
applying presolve graph analysis still finds redundancies presolve fails
detect consequently encodings produced optiplan still smaller
encodings produced original state change model
performance encoding size presolve optiplan original
state change model given table performance measured time
first feasible solution overall effectiveness graph
analysis optiplan generates smaller encodings performs
better encodings generated state change model
ipc
optiplan participated propositional domains optimal track ipc
track planners could minimize number actions bfhsp semsyn
minimize makespan cpt hsp optiplan satplan tp minimize
metric
ipc makespan optimal planners given figure
evaluated competition organizers looking runtime plan quality graphs
planners compared estimating asymptotic runtime
analyzing solution quality performance seven competition domains
optiplan judged second best four quite remarkable integer
programming hitherto considered competitive
optiplan reached second place optical telegraph philosopher domains
domains optiplan one order magnitude slower satplan
clearly outperforms participating planners pipesworld tankage domain
optiplan awarded second place together satplan satellite domain
optiplan cpt semsyn tied second place domains optiplan
perform well airport domain optiplan solves first
takes time pipesworld notankage
psr domains optiplan slowest solves fewest number
among participating planners
looking domains optiplan difficulty scaling notice
lead large ip encodings since size encoding
function plan length optiplan often fails solve long solution plans
one way resolve issue de link encoding size solution length
done recent work van den briel vossen kambhampati
fact year following ipc developed novel ip encodings


fioptiplan unifying ip graph

model transitions individual fluents separate loosely coupled network flow
control encoding length generalizing notion parallelism

conclusions
optiplan system performs significantly better original state change
model vossen colleagues performed respectably ipc still
lags behind sat csp planners blackbox chaff satplan siege
gp csp believe however performance gap ip techniques
inferior sat csp rather reflection types ip formulations
tried far specifically encodings tried
tailored strengths ip solvers chandru hooker
experience optiplan encouraged us continue working improved ip
formulations ai recent work van den briel vossen kambhampati
model fluents loosely coupled network flow control encoding
length generalizing notion parallelism resulting ip encodings solved
within branch cut yield impressive
shown highly competitive state art sat planners

references
blum furst fast graph analysis proceedings
th international joint conference artificial intelligence ijcai pp

bockmayr dimopoulos mixed integer programming working notes cp constraint reformulation
workshop
bockmayr dimopoulos integer programs valid inequalities proceedings european conference ecp
pp springer verlag
brearley mitra g williams h analysis mathematical programming
prior applying simplex mathematical programming

bylander linear programming heuristic optimal aaai iaai proceedings pp
chandru v hooker j optimization methods logical inference john wiley
sons york
dimopoulos improved integer programming heuristic search
ai proceedings european conference ecp pp
springer verlag


fivan den briel kambhampati










time sec

time sec



optiplan





optiplan

satplan




cpt
























satplan
cpt

tp





















time sec

time sec











satellite nr

airport nr


optiplan






satplan


optiplan


cpt

satplan

tp

cpt
















































time sec



optiplan
satplan



hsps


























satplan

cpt

tp







philosophers nr

optical telegraph nr


optiplan



satplan
hsps



tp
cpt









optiplan
hsps











tp







cpt






pipesworld tankge nr



time sec

time sec

pipesworld notankage nr























psr nr

figure ipc makespan optimal planners





fioptiplan unifying ip graph

dimopoulos gerevini temporal mixed integer programming proceeding aips workshop temporal domains
pp
kambhampati constraint satisfaction solving graph compiling csp artificial intelligence
fourer r gay kernighan b ampl modeling language mathematical programming duxbury press belmont ca
ilog inc mountain view ca ilog cplex users manual
kambhampati challenges bridging plan synthesis paradigms proceedings
th international joint conference artificial intelligence ijcai pp

kautz h selman b satisfiability proceedings european
conference artificial intelligence ecai
kautz h selman b blackbox unifying sat graph
proceedings th international joint conference artificial intelligence
ijcai pp
kautz h walser j state space integer optimization aaai iaai proceedings pp
van den briel vossen kambhampati reviving integer programming approaches ai branch cut framework proceedings
international conference automated scheduling icaps pp

vossen ball lotem nau use integer programming
ai proceedings th international joint conference
artificial intelligence ijcai pp
wolfman weld lpsat engine application resource proceedings th international joint conference artificial intelligence ijcai pp
wolsey l integer programming wiley interscience series discrete mathematics
optimization john wiley sons york




