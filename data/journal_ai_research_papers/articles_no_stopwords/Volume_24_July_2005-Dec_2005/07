Journal Artificial Intelligence Research 24 (2005) 919-931

Submitted 01/05; published 12/05

Engineering Note
Optiplan: Unifying IP-based Graph-based Planning
Menkes H.L. van den Briel

menkes@asu.edu

Department Industrial Engineering
Arizona State University, Tempe, AZ 85281 USA

Subbarao Kambhampati

rao@asu.edu

Department Computer Science Engineering
Arizona State University, Tempe, AZ 85281 USA

Abstract
Optiplan planning system first integer programming-based planner
successfully participated international planning competition. engineering note
describes architecture Optiplan provides integer programming formulation
enabled perform reasonably well competition. touch upon
recent developments make integer programming encodings significantly competitive.

1. Introduction
Optiplan planning system uses integer linear programming (IP) solve STRIPS
planning problems. first system take part international planning
competition (IPC) judged second best performer four competition domains
optimal track propositional domains. Optiplans underlying integer programming
formulation extends state change model Vossen colleagues (1999). architecture similar Blackbox (Kautz & Selman, 1999) GP-CSP (Do &
Kambhampati, 2001), instead unifying satisfiability (SAT) constraint satisfaction
(CSP) graph based planning, Optiplan uses integer programming. Blackbox
GP-CSP, Optiplan works two phases. first phase planning graph built
transformed IP formulation, second phase IP formulation solved
using commercial solver ILOG CPLEX (ILOG Inc., 2002).
practical difference original state change model Optiplan
former takes input ground actions fluents initialized plan steps,
latter takes input actions fluents instantiated Graphplan
(Blum & Furst, 1995). well known use planning graphs significant
effect size final encoding matter combinatorial transformation method
(IP, SAT, CSP) used. instance, Kautz Selman (1999) well Kambhampati
(1997) pointed Blackboxs success Satplan (Kautz & Selman, 1992) mainly
explained Graphplans ability produce better, refined, propositional structures
Satplan. addition, Optiplan allows propositions deleted without required
preconditions. state changes modeled original state change model,
therefore Optiplan considered general encoding. One more, although
c
2005
AI Access Foundation. rights reserved.

fiVan den Briel, & Kambhampati

minor, implementation detail Optiplan state change model Optiplan
reads PDDL files.
engineering note organized follows. Section 2 provides brief background
integer programming Section 3 discusses previous IP approaches planning. Section
4 describes Optiplan planning system underlying IP formulation. Section 5
give experimental results look Optiplans performance international
planning competition 2004 (IPC4). Conclusions brief discussion recent
developments given Section 6.

2. Background
linear program represented linear objective function set inequalities,
min{cx : Ax b, x 0} x n-dimensional column vector variables,
n matrix, c n-dimensional row vector, b m-dimensional column vector.
variables constrained integers integer (linear) program,
variables restricted 0-1 values binary integer program.
widely used method solving general integer programs using branch
bound linear programming relaxation. Branch bound general search
method subproblems created restrict range integer variables,
linear programming relaxation linear program obtained original integer
program omitting integrality constraints. ideal formulation integer program
one solution linear programming relaxation integral. Even though
every integer program ideal formulation (Wolsey, 1998), practice hard
characterize ideal formulation may require exponential number inequalities.
problems ideal formulation cannot determined, often desirable find
strong formulation integer program. Suppose P1 = min{cx : A1 x b1 , x 0}
P2 = min{cx : A2 x b2 , x 0} linear programming relaxations two IP
formulations problem, say formulation P1 stronger formulation P2
P1 P2 . is, set solutions P1 subsumed set solutions P2 .

3. Integer Programming Approaches Planning
Despite vast amount research conducted field AI planning,
use linear programming (LP) integer linear programming explored
marginal level. quite surprising since (mixed) integer linear programming provide
feasible environments using numeric constraints arbitrary linear objective functions,
two important aspects real-world planning problems.
handful works explored use LP IP techniques AI planning.
Bylander (1997) developed IP formulation classical planning used LP relaxation heuristic partial order planning. results, however, seem scale
well compared planning graph satisfiability based planners.
difficulty developing strong IP formulations performance often depends way IP formulation constructed. Vossen et al. (1999) compared two
formulations classical planning. First, consider straightforward IP formulation
based converting propositional representation given Satplan (Kautz & Selman,
920

fiOptiplan: Unifying IP-based Graph-based Planning

1992) IP formulation variables take value 1 certain proposition
true, 0 otherwise. formulation, assertions expressed IP constraints
directly correspond logical conditions propositional representation. Second,
consider IP formulation original propositional variables replaced
state change variables. State change variables take value 1 certain proposition
added, deleted, persisted, 0 otherwise. Vossen et al. show formulation based
state change variables outperforms straightforward formulation based converting
propositional representation.
Dimopoulos (2001) improves IP formulation based state change variables identifying valid inequalities tighten formulation. Yet, even stronger IP formulations
given Bockmayr Dimopoulos (1998, 1999), IP formulations contain
domain dependent knowledge are, therefore, limited solving problems specific
problem domains only.
LP IP techniques explored non-classical planning. Dimopoulos
Gerevini (2002) describe mixed integer programming formulation temporal planning Wolfman Weld (1999) use LP formulation combination SAT
formulation solve resource planning problems. Kautz Walser (1999) use IP
formulations resource planning problems but, addition, incorporate action costs
complex objectives.
far, none IP approaches AI planning ever participated IPC, making
harder assess relative effectiveness line work. Optiplan, planner based
state change formulation, first IP-based planner so.

4. Optiplan
Optiplan planning graph based planner works follows. First build
planning graph level goal fluents appear non-mutex. compile
planning graph integer program solve it. plan found, planning
graph extended one level new graph compiled integer program
solved again. process repeated plan found.
remainder section give IP formulation used Optiplan.
order present IP formulation use following notation. F set fluents
set actions (operators). fluents true initial state
fluents must true goal given G respectively. Furthermore,
use sets:
pref A, f F, set actions fluent f precondition;
addf A, f F, set actions fluent f add effect;
delf A, f F, set actions fluent f delete effect;
Variables defined layer 1 planning graph.
variables actions variables possible state changes fluent
make, variables reachable relevant planning graph analysis
instantiated. A, 1, ..., action variables
921

fiVan den Briel, & Kambhampati

ya,t =



1 action executed period t,
0 otherwise.

no-op actions included ya,t variables represented separately
state change variable xmaintain
.
f,t
Optiplan based state change formulation (Vossen et al., 1999). formulation fluents represented explicitly, instead state change variables used model
transitions world state. is, fluent true added state
preadd
xadd
, persisted previous state xmaintain
. Optiplan extends
f,t xf,t
f,t
state change formulation (Vossen et al., 1999) introducing extra state change
variable, xdel
f,t , allows actions delete fluents without requiring preconditions.
original state change formulation allow actions, therefore added
new state change variables keep track state changes altered model
take new variables account. IPC4 domains Airport PSR
many actions delete fluents without requiring preconditions, therefore making
original state change formulation ineffective. Also, Optiplan instantiates
variables constraints reachable relevant planning graph analysis,
therefore creates smaller encoding original one. f F, 1, ...,
following state change variables:

1 fluent f propagated period t,
maintain
=
xf,t
0 otherwise.

1 action executed period pref
/ delf ,
preadd
xf,t
=
0 otherwise.

1 action executed period pref delf ,
predel
xf,t
=
0 otherwise.

1 action executed period
/ pref addf ,
=
xadd
f,t
0 otherwise.

1 action executed period tsuch
/ pref delf ,
xdel
=
f,t
0 otherwise.
summary: xmaintain
= 1 truth value fluent propagated; xpreadd
= 1
f,t
f,t
action executed requires fluent delete it; xpredel
= 1 action
f,t
add
executed requires fluent deletes it; xf,t = 1 action executed
require fluent adds it; xdel
f,t = 1 action executed require
fluent deletes it. complete IP formulation Optiplan given following
objective function constraints.

4.1 Objective
classical AI planning problems, minimization maximization required, instead
want find feasible solution. search solution, however, may guided
922

fiOptiplan: Unifying IP-based Graph-based Planning

objective function minimization number actions, currently
implemented Optiplan. objective function given by:
min

XX

ya,t

(1)

aA

Since constraints guarantee feasibility could used linear objective function. example, could easily set objective deal cost-sensitive plans
(in context non-uniform action cost), utility-sensitive plans (in context oversubscription goal utilities), metric transformed linear
expression. Indeed flexibility handle linear objective function one advantages IP formulations.

4.2 Constraints
requirements initial goal transition given by:
xadd
f,0 = 1
maintain preadd
xadd
, xf,0
f,0 , xf,0
maintain
xadd
+ xpreadd
f,T + xf,T
f,T

f

(2)

=0

f
/I

(3)

1

f G

(4)

constraints (2), (3) add initial fluents step 0 used
actions appear first layer (step 1) planning graph. Constraints
(4) represent goal state requirements, is, fluents appear goal must
added propagated step .
state change variables linked actions following effect implication
constraints. f F 1 have:
X
ya,t xadd
(5)
f,t
aaddf \pref

ya,t xadd
f,t
X

ya,t

addf \ pref

xdel
f,t

(6)
(7)

adelf \pref

ya,t xdel
f,t
X

delf \ pref

ya,t xpreadd
f,t

(8)
(9)

apref \delf

ya,t xpreadd
f,t
X

ya,t = xpredel
f,t

pref \ delf

(10)
(11)

apref delf

constraints (5) (11) represent logical relations action
state change variables. equality sign (11) actions f
923

fiVan den Briel, & Kambhampati

precondition delete effect mutually exclusive. means
substitute xpredel
variables, done implementation
f,t
Optiplan. will, however, use variables clarity. Mutexes appear
different state change variables expressed constraints follows:

predel
maintain
1
+ xdel
xadd
f,t + xf,t
f,t + xf,t

(12)

predel
xpreadd
+ xmaintain
+ xdel
1
f,t
f,t + xf,t
f,t

(13)

constraints (12) (13) restrict certain state changes occurring parallel.
del
example, xmaintain
(propagating fluent f step t) mutually exclusive xadd
f,t
f,t , xf,t ,
xpredel
(adding deleting f t).
f,t
Finally, backward chaining requirements binary constraints represented by:

add
maintain
xpreadd
+ xmaintain
+ xpredel
xpreadd
f,t
f,t
f,t
f,t1 + xf,t1 + xf,t1

f F, 1, ...,

(14)

del maintain
xpreadd
, xpredel
, xadd
{0, 1}
f,t , xf,t , xf,t
f,t
f,t

(15)

ya,t {0, 1}

(16)

constraints (14) describe backward chaining requirements, is, fluent
f added maintained step t1 state f changed action step
xpreadd
, xpredel
, propagated xmaintain
. Constraints (15)
f,t
f,t
f,t
(16) binary constraints state change action variables respectively.

Loc1

Truck1

Loc2

Truck2

Figure 1: simple logistics example

4.3 Example
example, show constraints initialized comment
interaction state change variables action variables.
Consider simple logistics example two locations, two trucks,
one package. package transported one location another one
trucks. built formulation three plan steps. initial state package
924

fiOptiplan: Unifying IP-based Graph-based Planning

trucks location 1 given Figure 1. initial state constraints are:
xadd
pack1

loc1,0

xadd
truck1

loc1,0
add
xtruck2 loc1,0
add maintain preadd
xf,0 , xf,0
, xf,0

=1
=1
=1
=0

f 6=

goal get package location 2 three plan steps, expressed
follows:
xadd
pack1

loc2,3

+ xmaintain
pack1

loc2,3

+ xpreadd
pack1

loc2,3

1

write effect implication constraints, comment
them. xadd
f,t = 1 certain fluent f , execute least one action
f add effect precondition. example:
yunload

truck1 loc2,t

+ yunload

truck2 loc2,t

xadd
pack1

loc2,t

preadd
state changes xdel
similar requirement, change
f,t xf,t
state del preadd must execute least one action corresponding effects. hand, execute action must change
fluent states according effects a. example:

yunload

truck1 loc2,t

xadd
pack1

yunload

truck1 loc2,t



yunload

truck1 loc2,t

=

loc2,t
preadd
xtruck loc2,t
xpredel
pack1 truck1,t

one-to-one correspondence (note equality sign) execution
actions xpredel
state change variables. because, actions
f,t
predel effect must mutex. Mutexes present state changes. example,
fluent f maintained (propagated) cannot added deleted. two state
changes mutex add preadd. add state
change behaves preadd state change corresponding fluent already present
state world. introduce two separate mutex constraints, one
includes add state change one includes preadd. example
constraints mutex state changes follows:
xadd
pack1

truck1,t

xpreadd
pack1

truck1,t

+ xmaintain
pack1

truck1,t

+ xdel
pack1

truck1,t

+ xpredel
pack1

truck1,t

1

+ xmaintain
pack1

truck1,t

+ xdel
pack1

truck1,t

+ xpredel
pack1

truck1,t

1

state fluent change another state correct state changes
occurred previously. Hence, fluent deleted, propagated, used preconditions
step added propagated step 1. example:
xpreadd
pack1

predel
maintain
truck1,t + xpack1 truck1,t + xpack1 truck1,t
add
maintain
xpreadd
pack1 truck1,t1 + xpack1 truck1,t1 + xpack1 truck1,t1

925



fiVan den Briel, & Kambhampati

t=0
xadd
pack1
xadd
truck1
xadd
truck2

loc1,0

t=1
yload truck1 loc1,1
xadd
pack1 truck1,1
xpredel
pack1 loc1,1
xpreadd
truck1 loc1,1

loc1,0

xmaintain
truck2

loc1,0

t=2
ydrive truck1 loc1 loc2,2
xmaintain
pack1 truck1,2
xadd
truck1
xpredel
truck1

loc2,2

t=3
yunload truck1 loc2,3
xadd
pack1 loc2,3
xpredel
pack1 truck1,3
xpreadd
truck1 loc2,3

loc1,2

loc1,1

Table 1: Solution simple logistics example. displayed variables value 1
variables value 0.

simple problem total 107 variables (41 action 66 state change)
91 constraints. However, planning graph analysis fixes 53 variables (28 action 25 state
change) zero. substituting values applying presolve techniques
built ILOG CPLEX solver, problem 13 variables 17 constraints.
solution example given Table 1. Note that, actions
actively delete f , nothing ensures xmaintain
true whenever f
f,t
true preceding state (for example, see fluent truck2 loc1). Since negative
preconditions allowed, option letting xmaintain
false
f,t
true cannot cause actions become executable be.
miss solutions constraints (4) ensure goal fluents satisfied,
therefore forcing xmaintain
true whenever helps us generate plan.
f,t

5. Experimental Results
First compare Optiplan original state change model, check
Optiplan performed IPC 2004.
Optiplan original state change formulation implemented two different
languages. Optiplan implemented C++ using Concert Technology, set
libraries allow embed ILOG CPLEX optimizers (ILOG Inc., 2002),
original state change model implemented AMPL (Fourer, Gay, & Kernighan, 1993),
modeling language mathematical programming. order compare
formulations produced two implementations, written output
file using MPS format. MPS standard data format often used transferring
linear integer linear programming problems different applications.
MPS file, contains IP formulation planning problem, written, read
solved ILOG CPLEX 8.1 Pentium 2.67 GHz 1.00 GB RAM.
Table 3 shows encoding size two implementations, encoding size
characterized number variables number constraints formulation.
encoding size applying ILOG CPLEX presolve given. Presolve
problem reduction technique (Brearley, Mitra, & Williams, 1975) helps linear
programming problems simplifying, reducing eliminating redundancies. short,
926

fiOptiplan: Unifying IP-based Graph-based Planning

Problem
bw-sussman
bw-12step
bw-large-a
att-log0
log-easy
log-a

State change model
presolve
presolve
#Var. #Cons. #Var. #Cons.
486
878
196
347
3900
7372
1663
3105
6084
11628
2645
5022
1932
3175
25
35
24921
41457
1348
2168
50259
85324
3654
6168

Optiplan
presolve
presolve
#Var. #Cons. #Var. #Cons.
407
593
105
143
3534
4998
868
1025
5639
8690
1800
2096
117
149
0
0
2534
3029
437
592
5746
7480
1479
2313

Table 2: Encoding size original state change formulation Optiplan
ILOG CPLEX presolve. #Var. #Cons. give number variables
constraints respectively.

Problem
bw-sussman
bw-12step
bw-large-a
bw-large-b
att-log0
att-log1
att-log2
att-log3
att-log4
att-loga
rocket-a
rocket-b
log-easy
log-a
log-b
log-c

#Var.
196
1663
2645
6331
25
114
249
2151
2147
2915
1532
1610
1348
3654
4255
5457

State change model
#Cons. #Nodes
347
0
3105
19
5022
2
12053
14
35
0
164
0
371
10
3686
15
3676
12
4968
975
2653
517
2787
191
2168
43
6168
600
6989
325
9111
970

Time
0.01
4.28
8.45
581.92
0.01
0.03
0.07
0.64
0.71
173.56
32.44
9.90
0.96
145.31
96.47
771.36

#Var.
105
868
1800
4780
0
29
81
181
360
1479
991
1071
437
1479
1718
2413

Optiplan
#Cons. #Nodes
143
0
1025
37
2096
0
5454
10
0
0
35
0
99
0
228
0
507
0
2312
19
1644
78
1788
24
592
0
2313
19
2620
187
3784
37

Time
0.01
1.65
0.72
72.58
0.01
0.01
0.01
0.03
0.04
2.71
5.48
3.12
0.04
2.66
14.06
16.07

Table 3: Performance encoding size original state change formulation Optiplan. #Var. #Cons. give number variables constraints
ILOG CPLEX presolve, #Nodes give number nodes explored
branch-and-bound finding first feasible solution.

927

fiVan den Briel, & Kambhampati

presolve tries remove redundant constraints fixed variables formulation,
aggregate (substitute out) variables possible.
encoding size presolve, actual encoding size problem,
see significant use planning graphs is. Optiplan, instantiates
fluents actions reachable relevant planning graph
analysis, produces encodings cases one order magnitude smaller
encodings produced original state change model, instantiates ground
fluents actions. Although difference encoding size reduces substantially
applying presolve, planning graph analysis still finds redundancies presolve fails
detect. Consequently, encodings produced Optiplan still smaller
encodings produced original state change model.
performance (and encoding size presolve) Optiplan original
state change model given Table 3. Performance measured time find
first feasible solution. results show overall effectiveness using planning graph
analysis. problems Optiplan generates smaller encodings performs
better encodings generated state change model.
5.1 IPC Results
Optiplan participated propositional domains optimal track IPC 2004.
track, planners could either minimize number actions, BFHSP Semsyn;
minimize makespan, CPT, HSP*a, Optiplan, Satplan04, TP-4; minimize
metric.
IPC results makespan optimal planners given Figure 2. results
evaluated competition organizers looking runtime plan quality graphs.
Also, planners compared estimating asymptotic runtime
analyzing solution quality performance. seven competition domains,
Optiplan judged second best four them. quite remarkable integer
programming hitherto considered competitive planning.
Optiplan reached second place Optical Telegraph Philosopher domains.
domains Optiplan one order magnitude slower Satplan04,
clearly outperforms participating planners. Pipesworld Tankage domain,
Optiplan awarded second place together Satplan04, Satellite domain
Optiplan, CPT, Semsyn tied second place. domains Optiplan
perform well. Airport domain, Optiplan solves first 17 problems
problem 19, takes time so. Pipesworld Notankage
PSR domains, Optiplan slowest solves fewest number problems
among participating planners.
looking domains problems Optiplan difficulty scaling, notice
problems lead large IP encodings. Since size encoding
function plan length, Optiplan often fails solve problems long solution plans.
One way resolve issue de-link encoding size solution length,
done recent work (van den Briel, Vossen, & Kambhampati,
2005). fact, year following IPC4 developed novel IP encodings (1)
928

fiOptiplan: Unifying IP-based Graph-based Planning

model transitions individual fluents separate loosely coupled network flow
problems, (2) control encoding length generalizing notion parallelism.

6. Conclusions
Optiplan planning system performs significantly better original state change
model Vossen colleagues (1999). performed respectably IPC4, still
lags behind SAT- CSP-based planners, Blackbox(Chaff), Satplan04(Siege),
GP-CSP. believe, however, performance gap IP techniques
inferior SAT CSP, rather reflection types IP formulations
tried far. Specifically, encodings tried
tailored strengths IP solvers (Chandru & Hooker, 1999).
experience Optiplan encouraged us continue working improved IP
formulations AI planning. recent work (van den Briel, Vossen, & Kambhampati,
2005) model fluents loosely coupled network flow problems control encoding
length generalizing notion parallelism. resulting IP encodings solved
within branch-and-cut algorithm yield impressive results. Also, new approach
shown highly competitive state-of-the-art SAT-based planners.

References
Blum, A., & Furst, M. (1995). Fast planning planning graph analysis. Proceedings
14th International Joint Conference Artificial Intelligence (IJCAI-95), pp.
16361642.
Bockmayr, A., & Dimopoulos, Y. (1998). Mixed integer programming models planning problems. Working notes CP-98 Constraint Problem Reformulation
Workshop.
Bockmayr, A., & Dimopoulos, Y. (1999). Integer programs valid inequalities planning problems. Proceedings European Conference Planning (ECP-99),
pp. 239251. Springer-Verlag.
Brearley, A., Mitra, G., & Williams, H. (1975). Analysis mathematical programming
problems prior applying simplex algorithm. Mathematical Programming, 8,
5483.
Bylander, T. (1997). linear programming heuristic optimal planning. AAAI97/IAAI-97 Proceedings, pp. 694699.
Chandru, V., & Hooker, J. (1999). Optimization Methods Logical Inference. John Wiley
& Sons, New York.
Dimopoulos, Y. (2001). Improved integer programming models heuristic search
AI planning. Proceedings European Conference Planning (ECP-01), pp.
301313. Springer-Verlag.
929

fiVan den Briel, & Kambhampati

10000

10000

1000

1000

100
Time sec.

Time sec.

100
10
Optiplan

1

10
1
Optiplan

Satplan04
0.1

0.1

CPT

0.01

0.01
0

5

10

15

20

25

30

35

40

45

Satplan04
CPT

TP4

0

50

5

10

10000

10000

1000

1000

100

100

Time sec.

Time sec.

15

20

25

30

35

Satellite problem nr.

Airport problem nr.

10
Optiplan

1

10
1

Satplan04
0.1

Optiplan
0.1

CPT

Satplan04

TP4

CPT

0.01

0.01
0

5

10

15

20

25

30

35

40

45

50

0

5

10

20

25

30

1000

1000

100

100

10

Time sec.

10000

Optiplan
Satplan04

1

HSPS-A
3

4

5

6

7

8

9

10

11

12 13

0

14

5

Satplan04

CPT

TP4

10

15

20

Philosophers problem nr.

Optical telegraph problem nr.

10000
Optiplan

1000

Satplan04
HSPS-A

100

TP4
CPT

10
1
0.1
0.01
0

50

Optiplan
HSPS-A

0.01

0.01
2

45

1
0.1

TP4

1

40

10

CPT
0.1

0

35

Pipesworld tankge problem nr.

10000

Time sec.

Time sec.

Pipesworld notankage problem nr.

15

5

10

15

20

25

30

35

40

45

50

PSR problem nr.

Figure 2: IPC 2004 results makespan optimal planners.

930

25

fiOptiplan: Unifying IP-based Graph-based Planning

Dimopoulos, Y., & Gerevini, A. (2002). Temporal planning mixed integer programming. Proceeding AIPS Workshop Planning Temporal Domains,
pp. 28.
Do, M., & Kambhampati, S. (2001). Planning constraint satisfaction: Solving planning graph compiling CSP. Artificial Intelligence, 132 (2), 151182.
Fourer, R., Gay, D., & Kernighan, B. (1993). AMPL: Modeling Language Mathematical Programming. Duxbury Press, Belmont, CA.
ILOG Inc., Mountain View, CA (2002). ILOG CPLEX 8.0 users manual.
Kambhampati, S. (1997). Challenges bridging plan synthesis paradigms. Proceedings
16th International Joint Conference Artificial Intelligence (IJCAI-97), pp.
4449.
Kautz, H., & Selman, B. (1992). Planning satisfiability. Proceedings European
Conference Artificial Intelligence (ECAI).
Kautz, H., & Selman, B. (1999). Blackbox: Unifying sat-based graph-based planning.
Proceedings 18th International Joint Conference Artificial Intelligence
(IJCAI-99), pp. 318325.
Kautz, H., & Walser, J. (1999). State-space planning integer optimization. AAAI99/IAAI-99 Proceedings, pp. 526533.
van den Briel, M., Vossen, T., & Kambhampati, S. (2005). Reviving integer programming approaches AI planning: branch-and-cut framework. Proceedings
International Conference Automated Planning Scheduling (ICAPS-05), pp.
310319.
Vossen, T., Ball, M., Lotem, A., & Nau, D. (1999). use integer programming
models AI planning. Proceedings 18th International Joint Conference
Artificial Intelligence (IJCAI-99), pp. 304309.
Wolfman, S., & Weld, D. (1999). LPSAT engine application resource planning. Proceedings 18th International Joint Conference Artificial Intelligence (IJCAI-99), pp. 310317.
Wolsey, L. (1998). Integer Programming. Wiley-Interscience Series Discrete Mathematics
Optimization. John Wiley & Sons, New York.

931


