journal artificial intelligence

submitted published

engineering note
mgpt probabilistic planner heuristic search
blai bonet

bonet ldc usb

departamento de computacion
universidad simon bolvar venezuela

hector geffner

hector geffner upf edu

icrea universitat pompeu fabra
paseo de circunvalacion barcelona spain

abstract
describe version gpt planner used probabilistic track th
international competition ipc version called mgpt solves markov
decision processes specified ppddl language extracting different classes
lower bounds along heuristic search lower bounds
extracted deterministic relaxations alternative probabilistic effects
action mapped different independent deterministic actions heuristic search
use lower bounds focusing updates delivering consistent
value function states reachable initial state greedy policy

introduction
mgpt planner heuristic search solving markov decision processes mdps
specified high level language ppddl mgpt captures fragment
functionality gpt system handles non determinism incomplete information
qualitative probabilistic forms including pomdps conformant
bonet geffner
mgpt supports several admissible heuristic functions lower bounds
combined generate wide range solvers main lrtdp
hdp heuristic search solving mdps make use lower bounds
computing consistent value function v function bellman residuals bounded
user provided parameter states reachable given initial state
greedy policy v bonet geffner b
lower bounds derived solving relaxations input since solving relaxations heuristic search implemented
stackable software components created sequence computing complex heuristic functions simpler ones


divide two groups deliver consistent value functions
respect user provided parameter select actions real time first

c

ai access foundation rights reserved

fibonet geffner

class compute consistent value function v states reachable
initial state greedy policy v v
following subsection give definitions admissible consistent value functions greedy partial proper policies present implemented
mgpt
consistent value functions greedy partial proper policies
value function v admissible non overestimating e value v
state lower bound optimal expected cost starting v consistent
state bellman residual



x


def



r fiv min c
p r v

aa



less equal denotes actions applicable c
cost applying action p r probabilistic transition function v
consistent say v consistent
state reachable initial state policy exists trajectory
sn sn p sk sk sk k n words
state reached positive probability zero steps
policy
known greedy policy v value function v defined


x
def


v argmin c
p r v

aa



optimal v consistent states sufficiently small yet since goal
optimal policy respect initial state states reachable
sufficient v admissible consistent states reachable
v
partial policy policy doesnt need defined states closed
respect state defined states reachable
proper respect goal state reached every state reachable
finally proper proper respect states
compute consistent value functions
first group mgpt implements value iteration vi labeled realtime dynamic programming lrtdp heuristic dynamic programming hdp
value iteration bertsekas applied states reached
given initial state available operators yields consistent value function
mgpts vi serves bottom line reference comparison

undiscounted probabilistic conditions neeeded order
vi finish consistent value function bertsekas



fimgpt probabilistic planner heuristic search

labeled real time dynamic programming bonet geffner b heuristicsearch implements labeling scheme top rtdp barto
bradtke singh improve convergence lrtdp works performing simulated
trials start initial state end solved states selecting actions according
greedy policy v successor states according corresponding transition
probabilities initially v input heuristic function solved states
goal states time action picked state value updated
making consistent value successors end trial labeling
procedure called checks whether states labeled solved state solved
value value descendents consistent ends
initial state labeled solved point states reachable initial state
greedy policy v consistent labeling mechanism guarantees
v proper partial policy respect
heuristic dynamic programming bonet geffner second heuristic search
supported mgpt solving mdps hdp performs systematic depth first
searches set states reachable initial state greedy policy
v looking inconsistent states updating values top search
labeling scheme tarjans strongly connected components procedure tarjan
identifies states solved need revisited initial
value function given heuristic function ends initial state
solved lrtdp labeling mechanism guarantees v proper respect

real time action selection
second class attempt solve given mdp rather select
actions real time limited amount processing without offering guarantees
quality resulting policies group include extension
action selection asp bonet loerincs geffner
probabilistic domains basically rtdp lookahead asp rtdp
performs value function updates states cannot get trapped loop thus
although policy delivered asp suboptimal proper policy e policy
guaranteed reach goal state

heuristics
assume initial value function given heuristic function
provides good cost estimates particular lrtdp hdp expect heuristic
admissible described pearl informative admissible heuristics
obtained solving suitable relaxations input two relaxations
supported mgpt min min relaxation strips relaxation first defines
deterministic shortest path original state space second used define
deterministic shortest path atom space thus first solved
atoms refer propositional symbols used representation language ppddl case
define number atoms polynomial size input size
state space general exponential number atoms



fibonet geffner

time polynomial number states shortest path defined second
solved time polynomial number atoms methods yield lower bounds
expected cost goal given state yet bounds produced min min
relaxation stronger produced strips relaxation
min min state relaxation
idea behind min min relaxation transform input probabilistic
described bellman equations


x
def



v min c
p r v

aa



deterministic shortest path bellman equations form

vmin


def


min c min vmin
p



aa

level representation language min min relaxation built transforming probabilistic operator form
h p pn n



precondition ith probabilistic effect probability
pi set independent deterministic operators form
oi h

n



thus min min relaxation one actually choose convenient non deterministic effect operator hence cost relaxation lower bound
expected cost original probabilistic
min min relaxation deterministic solved means
standard path finding example solved dijkstras
ida deterministic version lrtdp e labeled lrta korf
mgpt provides two methods computing min min heuristic relaxation
min min ida uses ida min min lrtdp uses lrtdp versions
lazy sense heuristic values states computed needed
planner requires
strips relaxation
strips relaxation turn converts deterministic obtained min min
relaxation strips obtains lower bounds original mdp
computing lower bounds resulting strips methods developed
classical e g bonet geffner haslum geffner hoffmann nebel
edelkamp nguyen kambhampati methods run polynomial
time number atoms yet unlike min min relaxation require casting minmin relaxation strips format conversion conversion adl strips
gazen knoblock may require exponential time space see


fimgpt probabilistic planner heuristic search

mgpt strips relaxation obtained directly original first
transforming probabilistic operator form
h prec p add del pn addn deln



prec addi deli conjunctions literals represents precondition ith
add list ith delete list operator respectively pi probabilities sum
order take operators form disjunctive preconditions conditional
effects quantifiers removed described gazen knoblock
operators form strips relaxation generated splitting
operators n independent strips operators form
oi h prec addi deli

n



following heuristics implemented mgpt upon strips relaxation
first two lower bounds optimal cost strips relaxation hence
optimal expected cost original mdp third one necessarily lower bound
cost
hm heuristics h haslum geffner heuristics recursively
approximate cost achieving set atoms c initial state cost
achieving costly subset size c computed shortestpath graph nodes standing sets atoms
values hm estimate cost reaching goal state use
option h k mgpt refer hm heuristic k
pattern database heuristics patterndb edelkamp compute optimal costs
relaxations strips defined multi valued variables
implicit e g location block blocksworld domain
implicit multi valued variable whose possible values table top
block heuristic precomputed beginning
provides lower bound cost arbitrary state goal pattern
database computed projecting strips respect set atoms
define multi valued variables solving resulting
optimally dijkstras multiple pattern databases combined
taking max sum latter case pattern database referred
additive use additive pattern databases defined haslum bonet
geffner constraints original preserved
projection something often stronger heuristics patterndb k refers
pattern database heuristic defined k multi valued variables
heuristic implements heuristic function used planner hoffmann nebel computed building called relaxed graph
finding plan heuristic number operators plan
conditions required adding two pattern databases remains admissible
sufficient condition b sets b used build projections
respectively



fibonet geffner

relaxed graph version graph constructed graphplan
blum furst delete lists ignored shown computing
heuristic done polynomial time size input
hoffmann nebel heuristic however informative non admissible
shown heuristics plugged directly
used compute informative heuristics example patterndb
heuristic used within ida solve min min relaxation gives stronger
heuristic patterndb heuristic thus mgpt implements heuristics
stackable software components element stack used solve elements


implementation
section gives details implementation mgpt together examples
use mgpt system implemented c upon preliminary parser offered
organizers ipc
hash tables
perhaps important component modern search planners internal
representation states hash tables since mgpt uses different search
hash tables solve given instance e g informative heuristics computed
less informative ones good internal representations hash table implementation
critical good performance
grounding atoms operators state represented ordered list
atoms hold true state state appear associated different
data multiple hash tables simultaneously thus instead multiples copies
mgpt implements system wide state hash table stores representation
states referenced hash tables entries tables simply contain reference
state hash table way planner saves time space
another issue large impact performance average number collisions
hash table two points relevant keeping number collisions low
hashing function size hash table former seen
cryptographic hashing functions md behave well even though slower
traditional choices latter mgpt uses hash tables whose size equal
large prime number cormen leiserson rivest
heuristics
mgpt implemented subclass abstract class
whose members reference cases reference hash table
parameter similarly heuristic mgpt implemented subclass
abstract heuristic class whose members reference function
maps states non negative values simple heuristics constant zero function
straightforward others min min lrtdp implemented class whose members
addition references hash table lrtdp


fimgpt probabilistic planner heuristic search

examples
main parameters call mgpt specifies
use h heuristic specifies heuristic function e epsilon
specifies threshold consistency check typical call looks
mgpt lrtdp h h e domain
instructs mgpt use lrtdp h heuristic
domain files specified
h heuristic admissible weak following example shows
compute min min lrtdp heuristic h base heuristic
mgpt lrtdp h h min min lrtdp e domain
pipe symbol used instruct planner heuristics computed
heuristics
another possibility use mgpt reactive planner decisions taken
line respect heuristic function improved time example
mgpt asp h domain
uses asp heuristic
mgpt asp h zero min min ida domain
uses asp min min ida heuristic computed constant zero
heuristic combinations heuristics possible mgpt accepts
parameters control initial hash size weight heuristic function values dead end
states verbosity level lookahead settings asp etc

competition
competition suite consisted probabilistic domains named blocksworld explodingblocksworld boxworld fileworld tireworld towers hanoise zeno blocksworld
exploding blocksworld variations standard blocksworld domain classical boxworld logistics transportation domain fileworld file folder domain
uncertainty present initial situation destination
file set tireworld towers hanoise variations classical tireworld domain
towers hanoi zeno traveling domain fuel resource
domains come two variations goal oriented version goal
achieved certainty minimizing expected costs reward oriented version
involves rewards mgpt planner handles first type tasks
competition used lrtdp patterndb heuristic
parameter weight w heuristic function cases
patterndb heuristic poor planner switched automatically asp
heuristic



fibonet geffner

name
blocksworld
blocksworld
blocksworld
blocksworld
blocksworld
blocksworld
exploding bw
boxworld c b
boxworld c b
boxworld c b
fileworld
towers hanoise
tireworld g
tireworld r
zeno

runs
















failed
















successful
















time
















reward
















table mgpt planner competition table shows
name number runs number failed successful runs see text
time reward averages dash means mgpt able solve
times milliseconds


competition held client server model planner evaluated
number runs supervision server planner initiated
session connecting server interacted exchanging messages
run consisted actions sent planner whose effects transmitted back
server planner thus current state maintained
planner server
table shows mgpt competition
runs executed table shows number runs number failed runs
e finished without reaching goal state number successful runs e
finished goal states time reward averages per run
blocksworld blocksworld xx means xx blocks boxworld
boxworld cxx byy means xx cities yy boxes
seen table mgpt solve exploding bw larger instances
blocksworld boxworld failed approximately half instances
tireworld g difficulties encountered mgpt solving often
much probabilities involved domains particular
encodings basic used mgpt try solve
competition format reward presentation cost straightforward
go one format



fimgpt probabilistic planner heuristic search

computing value function residuals relevant states reachable
initial state optimal policy mgpt computes admissible heuristic
function solving min min relaxation strips relaxation
faced many instances neither relaxations could
solved give detailed explanation encountered mgpt
different domains worth noting many difficulties would surface
strips planner well even probabilities ignored
blocksworld exploding blocksworld operator encodings preconditions
containing universally quantified negative literals clear
predicate example
action pick block
parameters top block bottom
precondition top bottom
forall b block holding b
top top bottom
forall b block top b top
effect decrease reward
probabilistic
holding top top top bottom
bottom table
top top bottom
top top table


complex encoding standard makes atom heuristics almost useless mgpt could solve instances blocks
blocks exploding blocksworld mgpt unable
solve parser incomplete parse complex constructs
boxworld encoding contains drive truck operator moves truck
intended destination probability one three wrong destinations
probability encoding specifies unintended effects means
nested conditional effects form
action drive truck
parameters truck src city dst city
precondition truck city src drive src dst
effect truck city src
probabilistic
forall c city
wrong drive src c
forall c city
wrong drive src c
forall c city
wrong drive src c
probabilistic
truck city c
truck city c
truck city c
truck city dst



fibonet geffner

strips relaxation planner converts adl style operators strips
suffers exponential blow domain cities
thousand operators grounded adl operator set included
cities
fileworld domain files need filed one different
folders exact destination determined probabilistically optimal policy
proper policy must prescribe action states
relevant consequence millions relevant states
need stored hash table task compute proper policy
patterndb heuristic informative revealed analysis
values stored pattern database thus mgpt switched automatically
asp heuristic
towers hanoise blocksworld domain encoding complex operators disjunctions universally quantified negative literals preconditions complex conditional effects yet prevented mgpt
solving domain bug code implements conditional
effects surface domains
tireworld two versions goal version called tireworld g
reward version called tireworld r domain contains multiple dead ends
locations car gets flat tire spare tire available
dead ends unavoidable e proper policy trials
reward version end successfully since requirement reach goal
position rather objective maximize accumulated reward mgpt treated
versions goal deal directly reward


conclusions
mgpt planner entered probabilistic competition combines heuristicsearch methods obtaining lower bounds deterministic relaxations
obtained competition mixed difficulties
selection domains encodings match capabilities mgpt
mgpt tries compute proper solutions heuristics derived strips relaxations
described domains could solved due number relevant
states others due complexity strips relaxations
definition good benchmarks mdp solvers crucial define
constitutes solution bottom line assessing performance classical
example solutions plans bottom line given blind search
progress field measured distance bottom line
probabilistic setting difficult clear means
solve however needs defined way otherwise performance
comparisons meaningful indeed classical setting one longer compares
optimal non optimal planners since types planners different one
provides guarantees apply solutions provides guarantees



fimgpt probabilistic planner heuristic search

apply one solution probabilistic setting even subtle
different types guarantees example restrict class mdps
constitute simplest generalization classical setting task reaching
goal certainty minimizing expected number steps given initial
state methods yield solutions policies ensure goal
reached certainty finite number steps necessarily optimal methods
guarantees types methods necessary practice yet crucial
make distinction among identify useful benchmarks class
methods yield optimal policies least policies finite expected costs standard
dynamic programming methods value iteration provide useful bottom line reference
assessing performance case believe useful benchmarks need defined
taking account types tasks aim solve
types guarantees provide solutions
gpt mgpt available download http www ldc usb bonet
acknowledgements
mgpt built upon parser developed john asmuth rutgers university
hakan younes carnegie mellon university thank david e smith comments helped us improve note

references
barto bradtke singh learning act real time dynamic programming artificial intelligence
bertsekas dynamic programming optimal control vols athena scientific
blum furst fast graph analysis artificial
intelligence
bonet b geffner h incomplete information heuristic search
belief space chien kambhampati knoblock c eds proc th
international conf artificial intelligence scheduling pp
breckenridge co aaai press
bonet b geffner h heuristic search artificial intelligence

bonet b geffner h faster heuristic search
uncertainty full feedback gottlob g ed proc th international joint
conf artificial intelligence pp acapulco mexico morgan kaufmann
bonet b geffner h b labeled rtdp improving convergence real time
dynamic programming giunchiglia e muscettola n nau eds proc
th international conf automated scheduling pp trento
italy aaai press



fibonet geffner

bonet b loerincs g geffner h robust fast action selection mechanism
kuipers b webber b eds proc th national conf
artificial intelligence pp providence ri aaai press mit press
cormen leiserson c rivest r introduction mit press
edelkamp pattern databases cesta ed proc th
european conf pp toledo spain springer lncs
gazen b knoblock c combining expressiveness ucpop
efficiency graphplan steel alami r eds proc th european conf
pp toulouse france springer lncs
haslum p bonet b geffner h admissible heuristics domainindependent veloso kambhampati eds proc national
conf artificial intelligence pp pittsburgh pa aaai press mit
press
haslum p geffner h admissible heuristic optimal chien
kambhampati knoblock c eds proc th international conf artificial
intelligence scheduling pp breckenridge co aaai press
hoffmann j nebel b system fast plan generation
heuristic search journal artificial intelligence
korf r real time heuristic search artificial intelligence
nguyen x kambhampati extracting effective admissible state space
heuristics graph kautz h porter b eds proc th
national conf artificial intelligence pp austin tx aaai press
mit press
pearl j heuristics morgan kaufmann
tarjan r e depth first search linear graph siam journal
computing




