Journal Artificial Intelligence Research 24 (2005) 685-758

Submitted 03/05; published 11/05

Ignoring Delete Lists Works:
Local Search Topology Planning Benchmarks
Jorg Hoffmann

hoffmann@mpi-sb.mpg.de

Max Planck Institute Computer Science,
Stuhlsatzenhausweg 85,
66123 Saarbrucken
Germany

Abstract
1998 2004, planning community seen vast progress terms
sizes benchmark examples domain-independent planners tackle successfully.
key technique behind progress use heuristic functions based relaxing
planning task hand, relaxation assume delete lists empty.
unprecedented success methods, many commonly used benchmark examples,
calls understanding classes domains methods well suited for.
investigation hand, derive formal background understanding. perform case study covering range 30 commonly used STRIPS ADL
benchmark domains, including examples used first four international planning
competitions. prove connections domain structure local search topology
heuristic cost surface properties idealized version heuristic functions
used modern planners. idealized heuristic function called h+ , differs
practically used functions returns length optimal relaxed plan,
NP-hard compute. identify several key characteristics topology h+ , concerning existence/non-existence unrecognized dead ends, well
existence/non-existence constant upper bounds difficulty escaping local minima
benches. distinctions divide (set all) planning domains taxonomy
classes varying h+ topology. turns out, many 30 investigated domains lie
classes relatively easy topology. particularly, 12 domains lie classes
FFs search algorithm, provided h+ , polynomial solving mechanism.
present results relating h+ approximation implemented FF.
behavior regarding dead ends provably same. summarize results empirical investigation showing that, many domains, topological qualities h+
largely inherited approximation. overall investigation gives rare example
successful analysis connections typical-case problem structure, search
performance. theoretical investigation gives hints topological phenomena might automatically recognizable domain analysis techniques. outline
preliminary steps made direction.

1. Introduction
1998 2004, one strongest trends planning community
towards heuristic planners, specifically towards use heuristic distance (in
cases, goal distance) estimation functions. best runtime results, progressing far beyond
sizes benchmark examples previous domain-independent planners could tackle
successfully, achieved based upon technique phrased ignoring delete lists.
c
2005
AI Access Foundation. rights reserved.

fiHoffmann

There, heuristic function derived considering relaxation planning task
hand, relaxation assume delete lists (i.e. negative effects
available planning operators) empty. search, may forward backward,
state space plan space, heuristic value search state framework (an
estimate of) difficulty extending state solution using relaxed operators,
difficulty defined number (relaxed) actions needed.
number real actions needed extend search state solution least
high number relaxed actions needed. optimal (shortest) relaxed solutions
can, principle, used derive admissible heuristic functions. However, first
proved Bylander (1994), deciding bounded plan existence, i.e., existence plan
given number actions, NP-hard even delete lists.1
Thus much hope find optimal relaxed plans (i.e., optimal relaxed solutionextensions search states) fast. Instead, one approximate length optimal
relaxed plan search state. Techniques kind first, independently, proposed
McDermott (1996) Bonet, Loerincs, Geffner (1997), developed planners
Unpop (McDermott, 1996, 1999), HSP1 (Bonet et al., 1997). planners
perform forward state space search guided approximation relaxed goal distance.
Unpop approximates distance backchaining goals, HSP1 approximates
distance forward value iteration technique.
1st international planning competition, IPC-1 (McDermott, 2000), hosted
AIPS-1998, HSP1 compared well four competitors. inspired development HSP-r HSP2 (Bonet & Geffner, 1999, 2001b, 2001a), GRT (Refanidis &
Vlahavas, 1999, 2001), AltAlt (Nguyen & Kambhampati, 2000; Srivastava, Nguyen, Kambhampati, Do, Nambiar, Nie, Nigenda, & Zimmermann, 2001), well (Hoffmann,
2000; Hoffmann & Nebel, 2001a; Hoffmann, 2001a). HSP-r avoids heuristic re-computations
changing search direction. HSP2 implements various HSP versions configurable hybrid system. GRT avoids heuristic re-computations changing heuristic
direction (the direction relaxed plans computed). AltAlt uses planning
graph extract heuristic values. uses modified technique approximating optimal
relaxed plan length (namely, computing necessarily optimal relaxed plan,
done polynomial time), well new pruning search techniques. inspired integration heuristic search engines Mips (Edelkamp & Helmert, 2001)
STAN4 (Fox & Long, 2001), using elaborated variations FFs relaxed plan length
estimation technique.
2nd international planning competition, IPC-2 (Bacchus, 2001), hosted AIPS2000, heuristic planners dramatically outperformed approaches runtime-wise,
scaling benchmark examples far beyond reach previous, e.g., Graphplan-based
(Blum & Furst, 1995, 1997), systems. caused trend towards heuristic planners
still increase. Various researchers extended relaxed plan distance estimation techniques
temporal numeric settings (Do & Kambhampati, 2001; Hoffmann, 2002, 2003a;
Edelkamp, 2003b). Others adapted use partial order plan-space search (Nguyen
1. parallel planning, bound number parallel time steps needed, deciding bounded
plan existence easy without delete lists. However, heuristic functions based observation
generally found provide useful search guidance practice (see, example, Haslum &
Geffner, 2000; Bonet & Geffner, 2001b).

686

fiWhere Ignoring Delete Lists Works

& Kambhampati, 2001; Younes & Simmons, 2002), developed variations provide
new means heuristic guidance (Onaindia, Sapena, Sebastia, & Marzal, 2001; Sebastia,
Onaindia, & Marzal, 2001), modified take exclusion relations planning graph
account (Gerevini & Serina, 2002; Gerevini, Serina, Saetti, & Spinoni, 2003).
3rd international planning competition, IPC-3 (Long & Fox, 2003), hosted
AIPS-2002, 11 domain-independent competing systems, 7 using relaxed plan
distance estimations one form. 1st prize winner LPG (Gerevini & Serina,
2002; Gerevini, Saetti, & Serina, 2003) uses, amongst heuristics, relaxed planning
technique estimate difficulty sub-goal achievement planning graph.
4th international planning competition, IPC-4 (Hoffmann & Edelkamp, 2005; Edelkamp,
Hoffmann, Englert, Liporace, Thiebaux, & Trug, 2005), hosted ICAPS-2004, 13
competing sub-optimal systems, 12 using relaxed plan based heuristics.
two 1st prize winners category: Fast-Downward (Helmert, 2004; Helmert & Richter,
2004) SGPlan (Chen & Wah, 2003; Chen, Hsu, & Wah, 2004). latter uses
numeric version sub-process. One version former combines FFs heuristic
estimates new heuristic function based causal graph analysis (Helmert, 2004).
investigation hand, derive formal background classes domains methods kind described well suited for. make two simplifying
assumptions. First, consider forward state space search only, used by, example,
Unpop, HSP, Mips, FF, Fast-Downward. forward state space search, one starts
initial state explores space reachable states goal state found.
state transitions follow sequential planning framework, single action
applied time.2 Assuming forward search makes investigation easier since
search natural simple framework. second simplifying assumption
idealize matters consider heuristic value given optimal relaxed plan
length (the length shortest sequential relaxed plan) search state s; denote
value h+ (s). assumption, see many provable
connections domain structure heuristic quality. course, simplifying assumptions restrict relevance results practical planners. said
section, Section 7. Another, benign, restriction make
consider solvable tasks only. common restriction AI Planning, particularly
competitions, main focus good planners finding plans.
specifically, main focus investigation hand characterize kinds
domains (relaxed-plan based) heuristic planners find plans fast.
common knowledge behavior heuristic search methods (may
global local, i.e., without backtracking mechanisms) depends crucially
quality underlying heuristic function. has, example, studied
SAT community, example Frank, Cheeseman, Stutz (1997). work,
authors empirically investigate properties local search topology, i.e., topological
properties sizes local minima etc., SAT instances standard heuristic
function. adapt Frank et al.s definitions AI planning. difference Frank et
al., take analytical approach prove properties valid across
2. principle, parallel forward search possible, too. best authors knowledge,
published work implementation this, time writing. main difficulty is,
presumably, high branching factor.

687

fiHoffmann

certain ranges, namely domains, example problem instances. investigate range
30 commonly used STRIPS ADL benchmark domains including examples used
first four international planning competitions. identify several key characteristics
topology respective search spaces h+ . characteristics following.
1. 24 benchmark domains, unrecognized dead ends, i.e., states
goal unreachable relaxed plan.
2. 17 24 benchmark domains, maximal exit distance local
minima constantly bounded, i.e., one always escape local minima (regions
neighbors higher heuristic value) within number steps
constant across instances domain, regardless size (in fact, 13
domains local minima all).
3. 12 17 benchmark domains, maximal exit distance benches
constantly bounded, i.e., one always escape benches (regions states
heuristic value) within number steps constant across
instances domain, regardless size (in 6 domains bound 1, one
domain even 0).
Beside positive results proving characteristic qualities h+ function,
investigation provides (parameterized) counter-examples negative cases.
results divide investigated domains (more generally, possible planning domains)
meaningful taxonomy classes differ terms topological behavior
respect h+ . Many 30 investigated domains lie relatively easy classes, i.e., classes
h+ provably high-quality heuristic. particularly, 12 domains
properties lie classes FFs search algorithm polynomial solving
mechanism, idealizing assumption FFs approximative heuristic function
identifies real h+ distances. FFs search algorithm, called enforced hill-climbing, tries
escape local minima benches means breadth-first search. Breadth-first search
exponential search depth. local minima benches always
escaped within constant number steps case 12 domains
effort spent search polynomially bounded. way, results provide
non-trivial insights typical-case problem structure (in benchmarks), possible
effects search performance. Examples successful theoretical investigations kind
extremely rare AI literature.
give reader feeling looking at, Figure 1 shows two visualized
state spaces. shown tasks instances two domains easiest classes
taxonomy, Gripper Logistics. graph nodes states, edges state
transitions (action applications), height given h+ value.3 pictures,
initial state somewhere left top part. goal states are, course, states
minimal zero h+ value. Gripper picture speaks itself. Logistics topology
less extreme, still state space forms one big valley bottom
goal states.
3. h+ values here, empirical investigation (Hoffmann, 2001b, 2003b) preceding theoretical
analysis, computed iterative deepening forward search space relaxed action sequences.

688

fiWhere Ignoring Delete Lists Works

(a)

(b)

Figure 1: Visualized state space h+ (a) Gripper (b) Logistics instance.

course, FFs approximation h+ , refer hF F , always identify
real h+ values, priori evident relevance theoretical results
h+ FFs efficiency practice. Additionally, forward searching planners
use enforced hill-climbing, topological results striking
impact. Finally, importantly, several competitive planners even
perform forward search, use additional/new techniques heuristic function
explicitly aimed identifying better information relaxed plans. Prominent systems
former kind HSP-r LPG, prominent systems latter kind LPG
Fast-Downward.
relevance results performance FF, practical performance
coincides quite well them. concretely, behavior h+ respect dead
ends provably hF F . Moreover, large-scale empirical investigation
(contained Hoffmann, 2003b) shown that, many domains, topology h+
largely preserved hF F . include section containing brief summary results.
relevance topological results forward search algorithms enforced
hill-climbing, performance planners using search paradigms enhanced
heuristics, discussed Section 7.
remark topological investigation specifically intended identify
properties relevant enforced hill-climbing. theoretical investigation preceded
empirical investigation (Hoffmann, 2001b, 2003b) measured kinds
topological parameters, including, example, size diameter local minima, benches,
structures so-called valley regions. turned topology
parameters showed interesting behavior across significant number domains
maximal exit distance parameters considered investigation hand. This, fact,
came surprise us invented enforced hill-climbing became clear
689

fiHoffmann

many planning benchmarks share topological properties favoring precisely
particular search algorithm.
Observe proved results worst-case nature, i.e., heuristic search using
+
h show good behavior example suite domain even domain lies
difficult class taxonomy given particular example instances test
suite emphasize worst cases possible domain. relevant,
discuss issue regards example suites used competitions.
employed proof methods give hints topological phenomena might
automatically detectable using general domain analysis techniques. extra section,
report first (not yet successful) attempt made that.
proofs individual planning domains are, cases, overly difficult,
full details domains extremely space consuming. details (except
5 IPC-4 domains), i.e., PDDL-like definitions domains well fully detailed
proofs, looked long (138 pages) technical report (Hoffmann, 2003c)
forms online appendix article.4 article provides proof sketches,
much better suited get overall understanding investigation results.
Since even proof sketches sometimes hard read, moved appendix;
another appendix provides brief descriptions domains. main body text
gives results outline main proof arguments used obtain them.
paper organized follows. Section 2 provides necessary background, i.e.
straightforward formal framework STRIPS ADL domains, overview
investigated domains, definitions local search topology. Section 3 presents
core lemmas underlying many proofs single domains, illustrates lemmas
application small example. Section 4 gives results brief proof outline,
shows resulting planning domain taxonomy. Section 5 presents results relating
h+ hF F , Section 6 reports first attempt design domain analysis techniques
automatically detecting h+ topological phenomena. Section 7 concludes article
brief discussion contributions future work. Appendix contains
proof sketches individual domains, Appendix B contains domain descriptions.

2. Background
Background necessary planning framework, investigated domains, local
search topology.
2.1 Planning Framework
enable theoretical proofs properties planning domains rather single tasks,
defined formal framework STRIPS ADL domains, formalizing straightforward manner way domains usually dealt community. outline
rather lengthy definitions, refer reader TR (Hoffmann, 2003c) details.
follows, sets mean finite sets unless explicitly said otherwise.
4. remark TR longer version paper hand. TRs overall structure
presentation angle different, intended source details needed.

690

fiWhere Ignoring Delete Lists Works

planning domain defined terms set predicates, set operators,
possibly infinite set instances. logical constructs domain based
set predicates. fact predicate applied tuple objects. operators
(k-ary, k number operator parameters) functions (infinite) set
objects (infinite) set STRIPS ADL actions. STRIPS action
triple (pre(a), add(a), del(a)): precondition, conjunction facts; add list,
fact set; delete list, fact set. ADL action pair (pre(a), E(a))
precondition pre(a) first order logical formula without free variables, E(a)
set effects e form (con(e), add(e), del(e)) con(e), effect condition,
formula without free variables, add(e) (the effects add list) well del(e) (the
effects delete list) fact sets. add list action/effect contains fact p,
say action/effect achieves p.
instance domain defined terms set objects, initial state, goal
condition. initial state set facts, goal condition formula without free
variables (in STRIPS case, conjunction facts). facts contained
initial state assumed true, facts contained assumed false,
i.e., usual apply closed-world assumption. instance domain constitutes,
together domains operators, planning task (A, I, G) action set
result applying operators instances objects (i.e., object tuples
appropriate lengths), initial state goal condition G instance.
identify instances respective planning tasks.
state set facts. logical formula holds state state model
formula according standard definition first order logic (where logical atom,
fact, holds iff contained state). result Result(s, hai) applying action
sequence consisting single STRIPS ADL action state defined follows.
actions precondition hold s, Result(s, hai) undefined. Otherwise,
Result(s, hai) obtained including add effects, (thereafter) removing
delete effects ADL action, add effects add(e) included
(delete effects del(e) removed) respective effect condition con(e) holds
s. result applying sequence ha1 , . . . , consisting one action
state defined iterative application single actions obvious manner:
apply a1 s, apply a2 Result(s, ha1 i), on.
plan, solution, task (A, I, G) sequence actions P that,
successively applied I, yields goal state, i.e., state G holds. (We use
standard notation , set, denote set sequences elements
.) many proofs need notion optimality. plan P task (A, I, G)
optimal plan (A, I, G) contains fewer actions P .
Note that, announced introduction, definition, particular definition
plan optimality, stays within forward state space search framework plans
simple sequences actions. Note ignoring delete lists simplifies task
formulas negation free. fixed domain, tasks polynomially normalized
property: compute negation normal form formulas (negations
front facts), introduce negated fact B new fact not-B make sure
true state iff B false (Gazen & Knoblock, 1997). pre-process done in,
691

fiHoffmann

example, FF. investigation hand, considered normalized versions
domains.5
consider domains, IPC-4 collection, feature derived predicates. predicates affected effects operators, truth value
instead derived values other, basic, predicates, via set derivation
rules. derivation rule form (x) P (x) P derived predicate
(a formula) rules antecedent, using free variables x. obvious idea
that, (x) holds, P (x) concluded. little detail, semantics
defined follows. initial state, whenever action applied, first
derived predicate instances (derived facts) assumed false, derivation rules
applied fixpoint occurs. derived facts could concluded
said false (this called negation failure). Derived predicates used
predicate operator preconditions, effect conditions,
goal condition. However, ensure unique fixpoint rule application,
use derived predicates derivation rule antecedents restricted (in context
IPC-4) positive use sense predicates appear negated
negation normal form rule antecedent (Hoffmann & Edelkamp, 2005).
make ignoring delete lists simplification, one needs derived facts
used positively operator preconditions, effect conditions, goal condition
(otherwise derived predicates can, example, used model negated preconditions etc.). Due negation failure semantics derived predicates, isnt
simple compilation negations pure ADL case. approach take here,
implemented in, example, version treats derived predicates
(Thiebaux, Hoffmann, & Nebel, 2003, 2005), simply ignore (replace true) negated
derived predicates (the negation normal form of) operators goal (see below,
Section 2.3).
2.2 Domains Overview
said before, case study covers total 30 commonly used STRIPS ADL benchmark domains. include examples first four international competitions,
plus 7 domains used literature. Brief descriptions domains looked
Appendix B, full formal definitions domains (except 5 IPC-4 domains)
TR (Hoffmann, 2003c). Note that, defining domain, one must amongst
things decide exactly instances are. Naturally, abstracted
known example suites. cases abstraction obvious, less obvious
cases respective subsection Appendix B includes explanatory remarks.
Here, provide brief overview 30 analyzed domains. domains categorized three groups according semantics, high level abstraction.
categorization not, way, related topological characterization derive
later. use give overview structure.
5. Ignoring delete lists normalized domains comes relaxation that, basically, allows (the
translated) facts take truth values time.

692

fiWhere Ignoring Delete Lists Works

1. Transportation domains. domains locations, objects
must transported, vehicles means transportation.6 Operators mostly either move vehicle, load (unload) object onto (from) vehicle. domains differ terms various constraints. important one that,
many domains, vehicles move instantaneously two locations,
domains movable links locations form arbitrary road maps.
13 transportation domains collection look at. Logistics classical transportation domain, trucks/airplanes transport objects within/between
cities. Gripper robot two gripper hands transports number balls (one
time hand) one room another. Ferry single ferry transports
cars one time. Driverlog trucks need drivers board order move,
location links form bi-directional road maps (which different trucks
drivers). Briefcaseworld briefcase moves, conditional effects, objects along
inside it. Grid robot transports keys grid-like road map
positions locked must opened keys matching shapes. MiconicSTRIPS elevator transports passengers, using explicit actions board/deboard
passengers. Miconic-SIMPLE Miconic-STRIPS, passengers board/deboard
conditional effects action stops elevator floor.
Miconic-ADL Miconic-SIMPLE, various constraints must obeyed (for
example, VIPs first). Zenotravel airplanes use fuel items replenished
one one using refuel operator. Mprime arbitrary road map, trucks use
non-replenishable fuel items, fuel transferred locations. Mystery
Mprime, without possibility transfer fuel. Airport inbound
outbound planes must moved safely across road map airport.
2. Construction domains. generally closely related transportation domains above. construction domains common, roughly,
complex object must built individual parts. 6
domains collection look at. Blocksworld-arm classical construction
domain, blocks picked up/put stacked onto/unstacked
means robot arm. Blocksworld-no-arm above, blocks
moved around directly block block / table block /
block table. Depots combination Blocksworld-arm Logistics,
objects must transported locations stacked onto
other. Freecell encoding solitaire card game comes Microsoft
Windows (the complex object constructed final position cards).
Hanoi encoding classical Towers Hanoi problem. Assembly complex
object must assembled together parts, might need
assembled beforehand.
3. domains. 11 domains collection whose semantics
quite fit either groups. Simple-Tsp trivial STRIPS version
6. term transportation domains suggested, example, Long Fox (2000) Helmert
(2003). transportation benchmarks generally closely related groups
domains overviewed below, sometimes discuss transportation domains rather generic
level.

693

fiHoffmann

TSP problem, move operator applied two locations.
Movie order watch movie, one must buy snacks, set counter video
zero, rewind tape. Tireworld number flat tires must replaced,
involves various working steps (like removing flat tire putting new
one). Fridge number fridges, broken compressors must replaced,
involves various working steps (like loosening/fastening screws hold
compressor). Schedule objects must processed (painted, example)
number machines. Satellite satellites must take images (of phenomena space),
using appropriate instruments. Rovers rovers must navigate along road map, take
soil/rock samples well images, communicate resulting data lander.
Pipesworld oil derivatives must propagated pipeline network. PSR
lines must re-supplied faulty electricity network. Dining-Philosophers
deadlock situation Dining-Philosophers problem, translated ADL
automata-based Promela language (Edelkamp, 2003a), must found. OpticalTelegraph similar Dining-Philosophers, considering encoding telegraph
communication system.
2.3 Local Search Topology
Remember consider solvable tasks, since main focus investigation
characterize kinds domains heuristic planners find plans fast.
discussion unsolvable tasks Section 7.
Given planning task (A, I, G). state space (S, ) graph states
reachable initial state, set state transitions, i.e., set
pairs (s, s0 ) states action leads s0 executed
s. goal distance gd(s) state length shortest path (S, )
goal state, gd(s) = path. latter case, dead end;
discuss states directly below. heuristic function h : 7 N {}.7 heuristic
return indicate state hand might dead end.
Given STRIPS action = (pre(a), add(a), del(a)), relaxation a+
(pre(a), add(a), ). Given ADL action = (pre(a), E(a)), relaxation a+
(pre(a), E(a)+ ) E(a)+ E(a) except delete lists empty.
set actions, relaxation A+ A+ := {a+ | A}. action sequence
+
+
ha1 , . . . , relaxed plan (A, I, G) ha+
1 , . . . , plan (A , I, G). that,
+

state s, h (s) = min{n | P = ha1 , . . . , , P relaxed plan (A, s, G)},
minimum empty set .
presence derived predicates, said additionally relax planning
task ignoring (replacing true) negated derived predicates negation normal
forms preconditions, effect conditions, goal condition. Note that,
additional simplification, happen h+ (s) 0 although goal state,
simplification might relax goal condition itself. Indeed, happens
PSR domain. domains consider here, derived predicates either used
used positively, h+ (s) = 0 iff goal state.
7. article focuses mainly h+ heuristic, keep topology definitions
depend specific heuristic used somewhat general.

694

fiWhere Ignoring Delete Lists Works

One phenomenon clearly relevant performance heuristic state space
search dead end states s, gd(s) = . heuristic function h return h(s) = .
Taking indication dead end, obvious idea remove
search space (this done in, example, HSP FF). technique adequate
h completeness preserving sense h(s) = gd(s) = S.
completeness-preserving heuristic, dead end state called recognized h(s) =
unrecognized otherwise. Note h+ completeness preserving. task solved
even ignoring delete lists, task unsolvable. assume
heuristic look completeness preserving. respect dead ends,
planning state space falls one following four classes. state space called:
1. Undirected, if, (s, s0 ) , (s0 , s) .
2. Harmless, exists (s, s0 ) (s0 , s) 6 , and, S, gd(s) < .
3. Recognized, exists gd(s) = , and, S, gd(s) =
h(s) = .
4. Unrecognized, exists gd(s) = h(s) < .
first class, dead ends everything undone.
second class, things undone, single-directed state transitions
harm, sense dead end states. third class,
dead end states, recognized heuristic function.
critical case heuristic search class four, search algorithm run dead
end without noticing it. particularly relevant if, potentially, large regions
state space consist unrecognized dead end states. capture this, define depth
unrecognized dead end number states s0 s0 unrecognized dead
end, s0 reachable path moves unrecognized dead ends.
investigation determines, 30 benchmark domains looked at, exactly
four dead end classes instances domain belong. domains
turns unrecognized dead ends, construct parameterized
examples showing unrecognized dead ends arbitrarily deep. several
domains, individual instances fall different classes. case associate
overall domain worst-case class, i.e., class highest index above.
example, Miconic-ADL, additional constraints obeyed
transportation passengers state space harmless Miconic-SIMPLE.
constraints on, example, possible direction travel access floors
given, unrecognized dead ends arise. avoid clumsy language, henceforth,
say state space harmless/recognized/unrecognized, mean falls
respective class, class it.
get definitions general topological phenomena, i.e., relevant properties search space surface. adapt definitions given SAT Frank et al.
(1997). difference SAT framework there, planning formalism here,
lies possibly single-directed state transitions planning. search spaces considered Frank et al., state transitions traversed directions. Single-directed
695

fiHoffmann

state transitions important impact search space topology, enabling,
example, existence dead ends.8
base entity state space topology Frank et al. name plateaus.
regions equivalent reachability aspects, look point
view heuristic function. l N {}, plateau P level l maximal subset
induced subgraph (S, ) strongly connected, h(s) = l
P .9 Plateaus differ terms possibilities leaving heuristic level, i.e.,
reaching exit. plateau P level l, exit state reachable P ,
h(s) = l exists state s0 , (s, s0 ) , h(s0 ) < h(s). Based behavior
respect exits, distinguish five classes plateaus. need notion
flat paths. paths (S, ) value h remains constant.
1. recognized dead end plateau P level l = .
2. local minimum plateau P level 0 < l < exit reachable
flat path.
3. bench plateau P level 0 < l < , least one exit reachable
P flat path, least one state P exit.
4. contour plateau P level 0 < l < consists entirely exits.
5. global minimum plateau P level 0.
plateau belongs exactly one classes. Intuitively, roles different
kinds plateaus play heuristic search following. Recognized dead ends
ignored completeness-preserving heuristic function. Local minima difficult
neighbors look worse, clear direction move next. Benches
potentially easier, one step without temporarily worsening
heuristic value. contours, one step immediately.10
main difficulty heuristic search deal local minima
benches. cases, search algorithm must (eventually) find path exit
order get closer goal (as far heuristic function informed
closer goal not). difficult find exit assessed
variety different parameters. size (number states) diameter (maximum distance
two states) local minimum/the bench, number nearby exit
states, name important ones. benchmarks considered, mentioned
introduction, empirically found (or few) interesting observations
made parameters (Hoffmann, 2001b, 2003b).
8. One can, course, introduce backtracking mechanisms search space, always giving
planner possibility retract last step. affect relevant topological differences
search spaces instead domains with/without dead ends, one gets domains backtracking
necessary/not necessary.
9. difference undirected case require states plateau strongly connected
undirected state transitions trivially fulfilled set connected states.
10. differences undirected case lie plateaus level , allow exits
lie plateaus themselves. latter minor technical device obtain compact
terminology.

696

fiWhere Ignoring Delete Lists Works

one frequently observe interesting properties distance nearest
exit state. distance dist(s, s0 ) two states s, s0 usual graph
distance, i.e., length shortest path s0 (S, ),
path. exit distance ed(s) search state distance nearest exit, i.e.:
ed(s) = min{d | length path (S, ) state s0 s.t. h(s0 ) = h(s),
exists state s00 s.t. (s0 , s00 ) , h(s00 ) < h(s0 ) },
where, before, minimum empty set . Note require
path definition flat, i.e., may that, order reach s0 , temporarily
increase h+ value. want definition capture possible
escape routes state state space, including states lie local minima.
maximal local minimum exit distance, mlmed(S, ), state space (S, )
maximum exit distances states local minima, 0
states. maximal bench exit distance, mbed(S, ), state space (S, ) maximum
exit distances states benches, 0 states. find
that, many considered domains, constant upper bounds mlmed(S, )
and/or mbed(S, ) h+ , i.e., bounds valid irrespectively (size the)
instance chosen.
following implication relevant subsequent investigation.
Proposition 1 Given solvable task (A, I, G), state space (S, ) completenesspreserving heuristic h, h(s) = 0 gd(s) = 0 S. exists unrecognized
dead end S, mlmed(S, ) = .
Proof: Let unrecognized dead end, let s0 state reachable
h value s0 minimal. s0 unrecognized dead end, (in particular,
considered reachable itself), since h(s0 ) = 0 gd(s0 ) = 0 h(s0 ) > 0.
have, since h value s0 minimal among states reachable s,
h(s00 ) h(s0 ) states s00 reachable s0 . Thus plateau s0 lies local
minimum exits reachable, particular flat paths. shows s0
infinite exit distance.
2
Proposition 1 says that, every region unrecognized dead ends, local
minimum, given h(s) = 0 gd(s) = 0.11 definitions, unrecognized
dead end state yields infinite local minimum exit distance. makes sense define
things way (arbitrarily deep) unrecognized dead end worse local
minimum: escaped all.
11. Remember latter untrue h+ domain features derived predicates
appear negated negation normal form goal condition. even then, argument
proposition, every region unrecognized dead ends would contain global minimum consisting
non-solution states. could defined fake-global minima local minima, decided
order overly complicate topological definitions, since detail
seem important. said before, one 30 domains h+ (s) = 0 gd(s) = 0
anyway.

697

fiHoffmann

3. Core Lemmas
many investigated domains, intuitively similar patterns problem structure cause
characteristic qualities h+ . common structure generalized
captured concise definitions lemmas. lemmas formulate sufficient criteria implying (the state space of) planning task certain topological properties. Proofs
domains proceed, possible, applying lemmas arbitrary instances.
several domains lemmas applied immediately (due syntactic details
domain definitions), similar proof arguments suffice show desired topological
properties.
restrict STRIPS tasks lemmas. Appropriate extensions ADL
and/or derived predicates probably possible least certain cases,
investigated detail extensions likely rather complicated notationally,
simpler STRIPS case suffices transport ideas.

initial state:
at(V, L1 ), at(O1 , L1 ), at(O2 , L2 )
goal:
at(O1 , L2 ), at(O2 , L1 )
actions:
name
precondition
move(l, l0 )
at(V, l)
load(o, l)
at(V, l), at(o, l)
unload(o, l) at(V, l), in(o, V )

add list
at(V, l0 )
in(o, V )
at(o, l)

delete list
at(V, l)
at(o, l)
in(o, V )

Figure 2: simple STRIPS transportation task.
Throughout section, assume given STRIPS task (A, I, G). illustrative example definitions lemmas, use simple transportation task
defined Figure 2. follows, three separate sections, concerned dead
ends, local minima, benches, respectively.
definitions lemmas following syntactical, sense
make use informations computed efficiently (for example, inconsistencies
facts). discuss this, focus exclusively role definitions
lemmas tools proving h+ topology. role definitions lemmas
tools automatically detecting h+ topology discussed Section 6.
3.1 Dead Ends
first focus criteria sufficient non-existence dead ends. starting point
reformulated version simple result mentioned by, example, Koehler Hoffmann
(2000). need notion inconsistency. Two facts inconsistent
reachable state contains them. set facts F inconsistent another set
698

fiWhere Ignoring Delete Lists Works

facts F 0 fact F inconsistent least one fact F 0 .12 action
invertible if:
(1) add(a) inconsistent pre(a);
(2) del(a) pre(a);
(3) action
(a) pre(a) (pre(a) add(a)) \ del(a),
(b) add(a) = del(a),
(c) del(a) = add(a).
intentions behind requirements following. (1) (2) ensure
effects occur, (3a) ensures applicable, (3b) (3c) ensure
undoes effects. example, actions illustrative task Figure 2
invertible. example, = move(l, l0 ) action inverted = move(l0 , l). see that,
simply insert definitions: add(a) = {at(V, l0 )} inconsistent pre(a) = {at(V, l)};
del(a) = {at(V, l)} = pre(a); pre(a) = {at(V, l0 )} = add(a); add(a) = {at(V, l)} = del(a);
del(a) = {at(V, l0 )} = add(a). Similarly easily, one sees load(o, l) unload(o, l)
invert other. Examples benchmark domains invertible actions Blocksworld
(in variants), Logistics, Gripper.
Lemma 1 [Koehler & Hoffmann, 2000] Given STRIPS planning task (A, I, G).
actions invertible, state space task undirected.
Proof: state applicable action a, applicable Result(s, hai) due
condition (3a) invertibility. Conditions (1) (2) make sure effects fact
appear (condition (1) requires fact add list inconsistent least one
fact precondition), conditions (3b) (3c) make sure undoes exactly
effects.
2
remark that, contrast one may think first sight, task
undirected state space even actions invertible sense. Imagine,
example, action del(a) = {p} pre(a) = {p0 }, and, due domain
semantics, p0 true p true. means delete effect always appears;
however, detected simple syntax check, del(a) pre(a), used
definition above.
next provide new criterion weaker broadly applicable
Lemma 1, implies non-existence dead ends. criterion based
weaker version invertibility, two alternative properties whose combination
make action safe.
make action lead dead end, already sufficient inverse action
re-achieves least deleted, delete facts true
12. may seem natural define inconsistency fact sets symmetrical fashion, demanding
every fact F inconsistent every fact F 0 . context here, definition would
stronger need.

699

fiHoffmann

before. is, given state applicable, applying Result(s, hai) leads
us back state s0 satisfies s0 s. Formally, action least invertible
action that:
(1) pre(a) (pre(a) add(a)) \ del(a),
(2) add(a) del(a),
(3) del(a) inconsistent pre(a).
Condition (1) ensures, before, applicable Result(s, hai). Condition
(2) ensures re-achieves every fact deleted a. Condition (3) ensures
facts deleted true anyway. Note invertible action
least invertible. Conditions (1) (2) obviously given. condition (3),
del(a) = add(a) (condition (3c) invertibility), add(a) inconsistent pre(a)
(condition (1) invertibility), del(a) inconsistent pre(a). invertible
stronger least invertible; chose name least latter illustrate
that, definition invertibility, potentially re-achieves facts
original state s.
example, consider happens modify move(l, l0 ) action Figure 2
include visited(l0 ) fact add list. resulting action longer invertible
move(l0 , l) delete visited(l0 ). apply, state s, move(l, l0 ) move(l0 , l)
sequence, gets us state s0 identical except
includes visited(l) visited(l0 ), may true before. Move actions
kind form Simple-Tsp domain. least invertible sense:
pre(move(l0 , l)) = {at(V, l0 )} = add(move(l, l0 )); add(move(l0 , l)) = {at(V, l), visited(l)}
{at(V, l)} = del(move(l, l0 )); del(move(l, l0 )) = {at(V, l0 )} inconsistent {at(V, l)} =
pre(move(l, l0 )).
Another property implying action lead dead ends this.
action must applied (because add effects remain true), deletes
nothing preconditions, action needs inverted. Formally,
action static add effects if:
[

add(a)

del(a0 ) = .

a0

action relevant delete effects, if:
del(a) (G

[

pre(a0 )) 6= .

a6=a0



del(a) (G a6=a0 pre(a0 )) = , say relevant delete effects,
property actually interested in. illustrative task Figure 2,
imagine disallow unloading object initial location, loading object
goal location. remaining unload actions (unload(O1 , L2 ) unload(O2 , L1 ))
static add effects action delete goal position object relevant
delete effects action needs object vehicle respective
unload goal location. Actions characteristics are, example,
700

fiWhere Ignoring Delete Lists Works

actions make passengers get lift Miconic-STRIPS (a passenger get
lift his/her origin floor, get lift his/her destination
floor). Another example contained Tireworld domain, action
inflates flat wheel: de-flating action add effects static;
action goal needs wheel flat relevant delete effects.
Lemma 2 Given solvable STRIPS planning task (A, I, G). holds actions
either
1. least invertible,
2. static add effects relevant delete effects,
state space task harmless.
Proof: short, reachable state = Result(I, ha1 , . . . , i) plan constructed
inverting ha1 , . . . , (applying respective inverse actions inverse order),
executing arbitrary plan (A, I, G) thereafter. processes, actions
(at least) invertible skipped prerequisite static add effects
relevant delete effects.
detail, proof argument proceeds follows. reachable state =
Result(I, ha1 , . . . , i) S, identify solution P (A, s, G). Let hp1 , . . . , pm
solution (A, I, G) (which exists (A, I, G) solvable prerequisite). construct
P algorithm shown Figure 3.
:=
:= n . . . 1
ai least invertible ai
ai 6 apply ai endif
else := {ai }
endif
endfor
:= 1 . . .
pi 6 apply pi endif
endfor
Figure 3: Constructing plans tasks actions either least invertible,
static add effects relevant delete effects.
algorithm, serves kind memory set actions could
inverted. need prove preconditions applied actions fulfilled
state applied, goals true upon termination. Let us start
first loop. denote si := result(I, ha1 , . . . , ai i) state executing
701

fiHoffmann

ith action path s, s0i state first loop starts value i.
prove:
[
[
s0i (si (G
add(a)
pre(a)))
aMi

aA\Mi

Mi denotes current state set. proceed backward induction i.
= n, got s0i = si Mi = , equation trivially true. assume
equation true 1. prove equation holds 1. ai least
invertible, action applied, s0i1 = s0i , Mi1 = Mi {ai }. Concerning
left hand side expression right hand side equation, observe ai

prerequisite delete fact G aA\Mi1 pre(a) (Mi1 contains ai ),
relevant facts si1 already true s0i . Concerning right hand side
expression right, observe facts add(ai ) never deleted

prerequisite, aMi1 add(a) contained s0i . assume ai least invertible
ai . got Mi1 = Mi . Assume ai applied, i.e., ai 6 Mi . applicable
preconditions contained si , element Mi . resulting state
s0i1 , facts ai deleted si1 added, facts deleted
true si1 anyway; also, none add effects actions Mi deleted,
equation fulfilled. Finally, ai applied, ai Mi , ai static add effects
applied before, add effects contained s0i , ai delete effects empty.
Inserting = 0 equation proved, get
s0 (I (G

[

pre(a)))

aA\M0

[

add(a)

aM0

second loop starts s0 . start solution plan, excluding actions
set M0 , state including initial facts contained goal
precondition action M0 . state additionally contains add effects
actions M0 , add effects deleted action, clear
simply skip actions M0 achieve goal.
2
example illustrate proof, consider reachable state Tireworld domain.
Every action invertible, except action inflates wheel. Say, proof,
state reached action sequence ha1 , . . . , i. algorithm Figure 3
is, undo everything done, applying respective ai actions, except
inflating actions ai . latter stored set . gets us state
identical initial state, except already inflated flat
wheels (those corresponding actions ). state, algorithm executes
arbitrary solution, skipping previously applied inflating actions (in ).
3.2 Local Minima
define important kind relationship role action real task
role relaxed task. Combining definition notions least
invertible actions, (no) relevant delete effects, yields criterion sufficient
non-existence local minima h+ (or, equivalently, 0 upper bound
maximal local minimum exit distance). criterion directly applied 7
702

fiWhere Ignoring Delete Lists Works

30 investigated domains, applied slight modifications 2 domains.
Many individual proofs make use similar, albeit somewhat complicated,
proof arguments.
key property behind lack local minima h+ is, time,
every action good solving real task good solving relaxed task.
Formally, action respected relaxation if:
reachable state starts optimal plan (A, s, G),
optimal relaxed plan (A, s, G) contains a.
Note one assume relaxed plan start a, since relaxation
better apply action earlier.
actions illustrative task Figure 2 respected relaxation. Consider move(l, l0 ) actions, example. If, state s, optimal plan starts
move(l, l0 ), must good reason this. Either a) l0 object
yet transported, b) object truck must transported l0 .
cases, relaxed plan must transport object, chance
without moving l0 point. Similarly, optimal plan starts load(o, l)
action, means must transported somewhere else, relaxed plan
get around loading it. Finally, optimal plan starts unload(o, l) action,
means l goal location o, relaxed plan include
action.
Similar arguments applied many transportation domains.
argument regarding move actions becomes little complicated non-trivial
road maps, unlike illustrative example two locations
reachable single step other. Say road map (any) directed graph,
modify move action Figure 2 add precondition fact
demanding existence edge l l0 . move actions still respected
relaxation, ignoring delete lists affect shape road map.
optimal real path location l location l0 coincides optimal relaxed path
movements l l0 (even though result executing path different).
there, claim follows argument above, namely, optimal
plans moves l l0 object provides reason so.
transportation domain features additional constraints on, side effects of, move
actions, may respected relaxation. give example below,
formulating main lemma regarding local minima h+ .
Note exist local minima even actions respected relaxation.
Consider following transportation task, featuring single-directional edges road
map graph. argued above, actions respected relaxation. vehicle
two objects o1 , o2 initially l; o1 must go l1 o2 must go l2 ; edge l
l1 single-directed edge l l2 single-directed; l1 l2 ,
path n bi-directional (undirected) edges. optimal relaxed plan state
where, initial state, o1 o2 loaded, length 4: move l l1 l2 ,
unload o1 o2 l1 l2 , respectively. However, one moved, s, either l1
l2 , optimal relaxed plan length goes n + 2, since entire path l1
703

fiHoffmann

l2 must traversed. lies local minimum, given n > 2; note that, setting
n arbitrarily high values, get local minimum arbitrarily large exit distance.
turns preventing example, precisely, making use notions
invertibility relevant delete effects, introduced above, suffices get rid local
minima h+ .
Lemma 3 Given solvable STRIPS task (A, I, G), state space (S, )
contain unrecognized dead ends. action
1. respected relaxation,
2. least invertible relevant delete effects,
local minima (S, ) evaluation h+ .
Proof: states gd(s) = local minima prerequisite, h+ (s) = .
prove that, every reachable state 0 < gd(s) 6= , action starts
optimal plan (A, s, G), h+ (Result(s, hai)) h+ (s). proves lemma:
iterating argument, obtain path goal state s0 , value h+
increase path. means exit reachable flat path
h(s0 ) = 0 < h(s) point path h+ value becomes lower h(s), thus
lie local minimum.
Let reachable state 0 < gd(s) 6= . Let action starts
optimal plan (A, s, G). denote s0 := Result(s, hai). action respected
relaxation, optimal relaxed plan P + (s) (A, s, G) starts a.
Case (A), removing P + (s) yields relaxed plan (A, s0 , G). h+ (s0 ) <
+
h (s) follows, finished. case, particular, relevant delete
effects: facts deletes needed action goal, P + (s)
without achieves goal starting s0 (where already applied).
Case (B), assume removing P + (s) yield relaxed plan s0 . Then,
said before, relevant delete effects, must thus least
invertible. is, action pre(a) (pre(a) add(a)) \ del(a)
add(a) del(a). action guaranteed applicable s0 , re-achieves
delete effects. Denote P + (s0 ) action sequence results replacing, P + (s),
a. P + (s0 ) relaxed plan (A, s0 , G). seen follows. Observe
that, definition, P + (s) without relaxed plan Result(s, ha+ i) (we abbreviate
notation somewhat improve readability). desired property follows
Result(s0 , ha+ i) superset Result(s, ha+ i): Result(s, ha+ i) = add(a),
s0 = (s add(a)) \ del(a), add(a) del(a). P + (s0 ) relaxed plan (A, s0 , G),
yielding h+ (s0 ) h+ (s).
2
proof Lemma 3 demonstrates along lines, typically, proof arguments
investigation proceed. Given state s, consider action starts optimal
plan s, consider optimal relaxed plan P + (that contains a, ideally). Then,
determine P + modified obtain relaxed plan state results
execution. technique forms basis literally proofs except concerned
dead ends. Note second prerequisite Lemma 3 fulfilled planning
704

fiWhere Ignoring Delete Lists Works

tasks qualifying undirectedness harmlessness criteria given Lemmas 1 2.
Note that, said above, proved state space
illustrative example Figure 2 undirected, contain local minima
h+ .
Domains actions respected relaxation are, example, STRIPS
transportation domains Logistics, Gripper, Ferry, Miconic-STRIPS. cases,
respective proof arguments similar said above. instructive
look examples action respected relaxation.
transportation domain, can, example, happen due fuel usage side effect
moving. Concretely, Mystery domain, applying move action deletes fuel unit
start location (the location move starts). fuel running low
locations, (real) plan may move along fuel-rich deviations road map.
relaxed plan need always move along shortest connections
map because, there, actions delete fuel units.
Formulated somewhat generally, relaxed plans take short-cuts dont
work reality. short-cuts disjoint (in starting actions) real solution
paths, local minima may arise even actions (at least) invertible.
discussed transportation case, short-cuts correspond intuitive manner
one tends think short-cuts (on road map, namely). case
general, i.e., kinds domains. Consider Blocksworld-arm state depicted
Figure 4.

C
B

C



B

Figure 4: local minimum state Blocksworld-arm. goal B table,
C B.

depicted state, denoted s, B table, arm holds C.
goal B table, C B.13 optimal plan put C
table, unstack B put table, pickup C stack
onto B. optimal relaxed plan s, however, stack C onto B immediately,
unstack B A, put B table. short-cut
relaxed plan put C table, stacking C onto B
delete fact declares Bs surface unoccupied. result, lies local
13. Usually, Blocksworld goals demanding block table. example,
done sake simplicity: one could introduce one block demand B
goal.

705

fiHoffmann

minimum h+ .14 reason, intuitively, h+ yield local minima
many domains, vicious short-cuts example dont happen.
3.3 Benches
could find nice general sufficient criterion implying upper bounds maximal
exit distance local minima except special case local
minima thus 0 upper bound maximal local minimum exit distance.
did, however, find simple proof argument determining upper bound maximal
exit distance benches, tasks qualify application Lemma 3. proof
argument works, sometimes slight modifications, 7 domains Lemma 3
directly applied domains, maximal bench exit distance bounded
1 (bounded 0, one case).
proof argument based observing that, many domains, actions
delete effects irrelevant (for relaxed plan, least) action
applied optimal solution path. Formally, action relaxed-plan relevant
delete effects if:
reachable state starts optimal plan (A, s, G),

optimal relaxed plan ha, a1 , . . . , (A, s, G) del(a) (G ni=1 pre(ai )) = .
If, reachable state starts optimal plan (A, s, G),

optimal relaxed plan ha, a1 , . . . , (A, s, G) del(a) (G ni=1 pre(ai )) = ,
say relaxed-plan relevant delete effects, property
actually interested in. notation, relaxed-plan relevant delete effects,
starts optimal plan s, relaxed plan Result(s, hai) constructed
sequence ha1 , . . . , i, i.e., skipping relaxed plan s. Thus h+
value decreases Result(s, hai). Note n set 0 results goal
state s. Note that, definition, action relaxed-plan relevant delete
effects respected relaxation; action respected relaxation,
claim anything h+ anyway. Note finally that, assuming action
respected relaxation, relevant delete effects, i.e., delete
goal precondition another action, relaxed-plan relevant delete
effects sense definition.
Consider illustrative example Figure 2. Say state
load(o, l) starts optimal plan. means yet transported, location
l0 6= l. particular, means at(o, l) goal, follows action
whose delete effect at(o, l) relevant delete effects (no action
at(o, l) precondition). Further, say unload(o, l) starts optimal plan s.
means l goal location o. applying action, goal
achieved, action need refer again, particular action require
inside vehicle, delete effect unload(o, l). action neither
14. h+ (s) = 3. h+ value after, s, putting C table 4 (any relaxed plan
apply two actions two goals). h+ value stacking, s, C onto B still 3 (the
relaxed plan unstack C B, unstack B A, put B), successor state
unstack C B again, going back s.

706

fiWhere Ignoring Delete Lists Works

relaxed-plan relevant delete effects. contrast, consider move(l, l0 ) action,
deletes at(V, l). Say state O1 loaded V initial
state task. move(L1 , L2 ) starts optimal plan s, relaxed plan
Result(s, hmove(L1 , L2 )i) include action move(L2 , L1 ), moving back L2
L1 order able transport O2 . delete effect move(L1 , L2 ), namely
at(V, L1 ), relaxed-plan relevant.
If, task satisfying prerequisites Lemma 3, optimal starting action
relaxed-plan relevant delete effects, one apply case (A) proof Lemma 3,
obtain smaller h+ value. bound maximal exit distance benches,
need identify maximum number steps happen.
Lemma 4 Given solvable STRIPS task (A, I, G) satisfies prerequisites
Lemma 3. Let constant that, every non dead-end state S,
optimal plan ha1 , . . . , d-th action, ad , relaxed-plan relevant delete effects. mbed(S, ) 1.
Proof: Let reachable state 0 < gd(s) 6= . Let ha1 , . . . , optimal plan
(A, s, G), ad relaxed-plan relevant delete effects. Denote, 0 n,
si := Result(s, ha1 , . . . , ai i). argumentation Lemma 3, h+ (si ) h+ (s)
i. Consider state sd1 . prerequisite, optimal relaxed plan

0
(A, sd1 , G) form , a01 , . . . , a0m i, del(ad ) (G
i=1 pre(ai )) = .
0
0
+
+
then, obviously, ha1 , . . . , relaxed plan sd , h (sd ) h (sd1 ) 1.
distance sd1 1, lemma follows.
2
Lemma 4 directly applied 5 7 domains qualify Lemma 3.
proof argument can, somewhat general version, applied 2 domains
well namely, Ferry Gripper, loading object deletes space vehicle
one domain namely, Miconic-SIMPLE, uses simple ADL constructs.
domains proved upper bound maximal exit distance
benches (and/or upper bound maximal exit distance local minima),
proof arguments (a lot, sometimes) complicated. Reconsidering illustrative
example, stated load unload actions relaxed-plan relevant delete
effects, move actions do. Now, obviously, since two locations accessible
single move, optimal plan applies one move action
row, i.e., optimal plan first second action load/unload.
Lemma 4 tells us maximal exit distance benches bounded 1.
similar argument applied transportation domains every pair
locations connected via single move (as in, example, Logistics). generally,
(the standard encoding of) transportation domain constraints (regarding,
example, fuel), undirected road map graph, exit distance bounded
diameter road map graph, i.e., maximum distance two locations
(nodes) graph. worst thing solution plan might traverse
entire road map loading/unloading object.15
15. directed road map graphs, explained above, local minima arise. technically, Lemma 3
applied, Lemma 4 applied either.

707

fiHoffmann

4. Planning Domain Taxonomy
list proved results, brief explanations obtained results.
summarize results form planning domain taxonomy.
group positive results prove non-existence topological
phenomena problematic heuristic search together single theorems.
negative results shown separately sketching counter examples. consider dead
ends, local minima, benches order. Remember that, respect dead ends,
problematic case heuristic search unrecognized dead ends, c.f.
Section 2.3.
Theorem 1 state space solvable instance
1. Blocksworld-arm, Blocksworld-no-arm, Briefcaseworld, Depots, Driverlog, Ferry,
Fridge, Gripper, Hanoi, Logistics undirected,
2. Grid, Miconic-SIMPLE, Miconic-STRIPS, Movie, Pipesworld, PSR, Satellite,
Simple-Tsp, Tireworld, Zenotravel harmless,
3. Dining-Philosophers, Optical-Telegraph, Rovers, Schedule recognized evaluation h+ .
Blocksworld-arm, Blocksworld-no-arm, Driverlog, Ferry, Gripper, Hanoi, Logistics, Lemma 1 directly applied. Briefcaseworld, Depots, Fridge, due
subtleties actions invertible syntactical sense, easy show
every action inverse counterpart. Movie, Miconic-STRIPS, Simple-Tsp,
Tireworld, Lemma 2 directly applied, Grid Miconic-SIMPLE similar proof
arguments used Lemma 2 suffice. Pipesworld, PSR, Satellite, Zenotravel,
easy-to-see individual domain properties prove absence dead ends. domains dead ends recognized h+ , individual domain properties exploited
proofs somewhat involved. example, Rovers plan state
if, soil/rock samples images need taken, rover
job, communicate gathered data lander.
chance run dead end take soil/rock sample rover reach
lander (the soil/rock sample available once). then, relaxed plan
state either.
6 domains mentioned Theorem 1 (Airport, Assembly, Freecell, MiconicADL, Mprime, Mystery), easy construct arbitrarily deep unrecognized dead ends
(arbitrarily long paths unrecognized dead ends). example, Mystery Mprime
relaxed plan still achieve goal situations much fuel consumed
already; Airport, two planes block others paths may move across
relaxed plan.
positive results regarding local minima these.
Theorem 2 h+ , maximal local minimum exit distance state space
solvable instance
708

fiWhere Ignoring Delete Lists Works

1. Blocksworld-no-arm, Briefcaseworld, Ferry, Fridge, Grid, Gripper, Hanoi, Logistics,
Miconic-SIMPLE, Miconic-STRIPS, Movie, Simple-Tsp, Tireworld 0,
2. Zenotravel 2, Satellite 4, Schedule 5, DiningPhilosophers 31.
Ferry, Gripper, Logistics, Miconic-STRIPS, Movie, Simple-Tsp, Tireworld,
Lemma 3 applied. Fridge Miconic-SIMPLE, actions adhere syntactically definitions invertibility (no) relevant delete effects, similar
semantics. Lemma 3 directly applied, similar arguments suffice: easy
see actions respected relaxation, proof Lemma 3 individually adapted take account particular properties regarding invertibility
relevant delete effects. (For example, passenger gets lift Miconic-SIMPLE,
delete effect passenger longer inside lift, matter
since passenger reached destination.) Blocksworld-no-arm, Briefcaseworld,
Grid, rather individual (and sometimes quite involved) arguments prove absence
local minima h+ . proof method is, cases, consider state
identify flat path state better h+ value. example, Grid done
moving along path locations contained relaxed plan s, key
picked up/put down, lock opened (this simplified description,
actual procedure quite complicated). Hanoi, one prove optimal relaxed
solution length state equal number discs yet final
goal position. suffices optimal plan moves disc away final position. Note that, thus, Hanoi state spaces h+ sequence benches decreasing
exponentially diameter size.
Zenotravel, Satellite, Schedule, proofs proceed identifying constant
number steps suffices execute one action optimal relaxed plan state
s, and, without deleting relevant add effects, re-achieve relevant facts
deleted a. Dining-Philosophers (as well Optical-Telegraph), due subtleties
PDDL encoding was, said, obtained automatic compilation
automata-based Promela language (Edelkamp, 2003a) h+ loosely connected
goal distance: relaxation, automaton (for example, philosopher) always
block 3 actions. bound Dining-Philosophers follows
rather constant restrictive domain structure, constant number process
transitions, namely 6, always suffices block one philosopher. proved bound
derived this, considering 4 planning actions needed process
transition, certain additional actions may needed due subtleties
PDDL encoding (where process two internal states). remark
bound valid even trivial heuristic function returning number yet
un-blocked philosophers. fact, proof h+ viewed corollary proof
heuristic function; get back end section. finally remark
highest exit distance h+ could actually construct Dining-Philosophers
15. conjecture (tight) upper bound.
Satellite, Schedule, Zenotravel, proved upper bounds tight.
Dining-Philosophers, Satellite, Schedule, Zenotravel, bounds valid nondead end state s. So, beside bound local minimum exit distance, results
709

fiHoffmann

provide bound bench exit distance, re-used
section.
Airport, Assembly, Freecell, Miconic-ADL, Mprime, Mystery, stated
unrecognized dead ends, Proposition 1 local minimum exit distance
domains unbounded. domains mentioned Theorem 2, i.e.,
Blocksworld-arm, Depots, Driverlog, Optical-Telegraph, Pipesworld, PSR, Rovers, one
construct local minima arbitrarily large exit distances. complicated
example Optical-Telegraph, where, difference Dining-Philosophers, one construct
situations number process state transitions needed block one process
arbitrarily high. Optical-Telegraph basically version Dining-Philosophers
complicated philosophers, freedom next. freedom enables
situations whole row philosophers table must perform two transitions
order block one philosopher. Details Appendix A.2. simpler example
Blocksworld-arm (as well Depots, Blocksworld-arm situations embedded).
Consider following situation. n blocks b1 , . . . , bn initially form stack
bi bi+1 bn table. goal build stack top
another block bn+1 , i.e., goal stack b1 , . . . , bn , bn+1 . Reaching, initial state,
state better h+ value involves disassembling entire stack b1 , . . . , bn .
disassembling process, h+ increases. Note basically extended version
illustrative example Figure 4.
interesting side remark, note proved topological difference
Blocksworld-arm Blocksworld-no-arm: latter, local minima
h+ , former, exit distance arbitrarily large.
intriguing, quite clear general message learn it. One might
interpret telling us, formal way, encoding details significant impact
topology, search performance. FF, example, much efficient
Blocksworld-no-arm Blocksworld-arm. noted, however, two
domains differ semantically, namely plans Blocksworld-no-arm half
long plans Blocksworld-arm. practical point view, would interesting
explore Blocksworld observation generalized encoding methods trying
model domain way making best suited h+ . said
Section 7.
positive results regarding benches these.
Theorem 3 h+ , maximal bench exit distance state space solvable
instance Simple-Tsp 0, Ferry 1, Gripper 1, Logistics
1, Miconic-SIMPLE 1, Miconic-STRIPS 1, Movie 1,
Zenotravel 2, Satellite 4, Schedule 5, Tireworld
6, Dining-Philosophers 31.
Simple-Tsp, Ferry, Gripper, Logistics, Miconic-STRIPS, Movie, Tireworld,
Lemma 4 directly applied. Determining actions (no) relaxed-plan relevant delete effects easy domains; Tireworld somewhat complicated
see when, latest, action applied optimal plan. MiconicSIMPLE, similar arguments Lemma 4 suffice. Zenotravel, Satellite, Schedule,
Dining-Philosophers, respective bounds shown already.
710

fiWhere Ignoring Delete Lists Works

Note that, Simple-Tsp, proved local minima exit
distance 0. implies h+ is, fact, identical real goal distance: entire
state space consists contours global minima.
topological distinctions divide planning domains taxonomy classes
differ terms behavior state spaces respect h+ . visualization
taxonomy, results 30 investigated domains, given Figure 5.

Blocksworldarm
Depots
Driverlog

Pipesworld
PSR

Rovers
OpticalTelegraph

Mystery
Mprime
MiconicADL
Freecell
Assembly
Airport

mbed <= c

mlmed <= c

Hanoi [0]
Blocksworldnoarm [0]
Fridge [0]
Grid [0]
Briefcaseworld [0]

Logistics [0,1]
Ferry [0,1]
Gripper [0,1]
undirected

Tireworld [0,6]
Satellite [4,4]
Zenotravel [2,2]
MiconicSIMPLE [0,1]
MiconicSTRIPS [0,1]
Movie [0,1]
SimpleTsp [0,0]
harmless

DiningPhil. [31,31]
Schedule [5,5]

recognized

unrecognized

Figure 5: planning domain taxonomy, overviewing results.
taxonomy, shown Figure 5, two dimensions. x-axis corresponds
four dead end classes. y-axis corresponds existence non-existence constant
upper bounds local minimum exit distance, bench exit distance. Note
visualization makes simplifying assumption domains bounded
bench exit distance subset ones bounded local minimum exit distance.
assumption justified general, holds true specific collection domains.
Also, question whether bound difficulty escaping benches
seem relevant when, anyway, arbitrarily difficult escape local minima.16
specific bounds proved individual domains given parentheses, local minimum
exit distance bound preceding bench exit distance bound cases both.
bottom right corner taxonomy crossed domain belong
respective classes.17
16. Similarly, benches arbitrarily large relevant local minima
small non-existent. sense respective results Briefcaseworld, Fridge, Grid, Blocksworldno-arm, Hanoi moderately important. Still constitute interesting properties
domains.
17. Proposition 1, existence unrecognized dead ends implies non-existence constant upper
bounds local minimum exit distance, given states gd(s) 6= 0 h+ (s) = 0.
states exist, domain features derived predicates appear negated negation

711

fiHoffmann

Figure 5 suggests h+ -approximating heuristic planners fast
many common benchmark domains lie easy regions taxonomy.
concretely, described introduction, provided h+ function, FFs
search algorithm enforced hill-climbing polynomial domains located lowermost classes taxonomy (i.e., domains constant bounds maximal
exit distances). empirical perspective, distinction lines taxonomy
coincide quite well practical performance FF. excels 11 12 domains
belong lowermost classes taxonomy (the difficult domain DiningPhilosophers, whose upper bound exceptionally high). 5 middle domains (no
local minima potentially large benches) performs well, scale
comfortably easier domains. complex domains: Blocksworld-arm,
Depots, Driverlog, Optical-Telegraph, Pipesworld, PSR amongst challenging domains FF. Mprime Mystery, performs bad
planners. Freecell Miconic-ADL, among top performing planners, often
runs unrecognized dead ends larger instances (for example, larger Freecell
instances used AIPS-2000). Airport, Assembly Rovers, performs pretty well
respective competition example suites; however, domains competition suites
hardly explore worst-cases domain topology (details Appendix A).
discuss detail relation taxonomy empirical performance heuristic planners make use h+ approximation one
way. One observation definitely made planners
trouble solving instances domains extreme h+ properties.
Simple-Tsp, Ferry, Gripper, Logistics, Miconic-SIMPLE, Miconic-STRIPS, Movie,
extent Zenotravel, planners scale comfortably. particular,
scale much comfortably domains typically
domains, least without additional (for example, goal ordering) techniques.
next section, treat connection taxonomy FFs performance
analytical way, relating properties h+ properties FFs approximation
h+ , called hF F . so, remarks relation taxonomy
complexity theory order. question whether provable relation, i.e.,
relation distinction lines taxonomy, complexity deciding
plan existence respective domains. able construct NP-hard domain
(a domain deciding plan existence NP-hard) h+ yield local
minima; maximal bench exit distance domain is, however, unbounded. tried,
able come NP-hard domain constant bounds
maximal exit distances. remains open question whether domain exists
not. answer yes, lowermost classes taxonomy form group
domains worst-case hard, typically easy solve (at least far

normal form goal condition. even then, presence unrecognized dead ends
would fake-global minima, i.e., global minima consisting non-solution states, fact consisting
unrecognized dead ends.

712

fiWhere Ignoring Delete Lists Works

reflected hitherto benchmarks). answer no, identified
large polynomial sub-class planning.18
Talking polynomial sub-classes, intriguing observation made
trivial heuristic function returning, state s, number goals true
s. Lets call function hG . little thinking, one realizes that, fact,
12 domains proved constant bounds maximal exit distances h+
constant bounds hG . hand, remaining 18 30
domains (except Miconic-ADL) easy see constant bounds hG .
Logistics, example, clearly maximum number steps needed achieve one
goal 12: 4 steps (move, load, move, unload) within packages origin city,
origin city destination city, within destination city. DiningPhilosophers, example, upper bound h+ was, said, proved corollary
upper bound hG . Blocksworld, example, clearly take arbitrarily many
steps achieve one goal, namely block must moved buried beneath n
blocks need moved.
observation appears rather significant first sight, probably
important, neither theory practice. one thing, coincidence that,
here, set domains constant bounds h+ set
domains constant bounds hG . simple counter example general
case graph-search domain, task find path two nodes
directed graph, using obvious at-predicate connected-predicate based encoding.
There, h+ equal real goal distance (since one never needs move back),
hG can, clearly, arbitrarily bad. another thing, domains Logistics
constant exit distance bounds hG , bounds large practically useful.
example, h+ , needs look 2 steps forward breadth-first
search iteration enforced hill-climbing, Logistics instance. hG , breadth-first
searches depth 12 would needed. So, most, observation regarding hG
noteworthy statement current planning benchmarks. remains open question
whether (coincidental) correspondence bounds h+ , hG ,
investigated 30 domains, exploited for, e.g., detecting bounds automatically.

5. Relating h+ hF F
discussion relating h+ hF F structured two separate sections. first one
briefly discusses provable relations h+ hF F . second section summarizes
results large-scale empirical investigation aimed identifying extent
topological properties h+ , benchmarks, get preserved hF F .
5.1 Provable Relations h+ hF F
One thing easy observe behavior h+ hF F provably
respect dead ends, i.e., heuristics return cases.
simply heuristics return state iff relaxed plan s.
18. Presumably, prove latter, one would need characterize class purely syntactic manner
level PDDL definitions, since h+ derived directly PDDL syntax. authors wild
guess going work, answer yes.

713

fiHoffmann

h+ follows definition. hF F follows completeness, relative
relaxation, algorithm computes relaxed plans (Hoffmann & Nebel, 2001a).
algorithm relaxed version Graphplan (Blum & Furst, 1995, 1997). state s,
runs Graphplan task initial state, delete lists actions
empty. Without delete lists, Graphplan guaranteed terminate polynomial time.
Graphplan terminates unsuccessfully, hF F (s) set . Otherwise, number
actions returned plan taken heuristic value hF F (s) state.19 Graphplan
complete algorithm terminates successfully plan
hF F set iff relaxed plan s. follows dead end classes
benchmarks h+ hF F .
relaxed plans found Graphplan (just general STRIPS) property
optimal terms number parallel time steps, terms
number actions. So, general, hF F h+ (even P NP).
uses following heuristic techniques action choice relaxed Graphplan, aiming
minimizing number selected actions (Hoffmann & Nebel, 2001a). First, fact
achieved NOOP (a dummy action propagating fact time step time
step + 1 Graphplans planning graph), NOOP selected. guarantees
every non-NOOP action selected (of course, selected NOOP actions
counted relaxed plan). Second, NOOP available action
minimal precondition weight chosen, weight defined summedup indices first layers appearance (in planning graph) precondition
facts. Third, actions selected parallel time step assumed linearized
order selection; action selected a0 assumed achieve fact
p add(a) pre(a0 ) even a0 selected parallel time step.
two restrictive sub-classes STRIPS hF F provably
h+ . first demands every fact one achiever.
Proposition 2 Let (A, I, G) STRIPS planning task that, facts p,
one action p add(a). Then, states task, h+ (s) = hF F (s).
Proof: proposition follows observation that, running relaxed Graphplan, choice points action selection; choice points always
empty unary case. implies actions selected Graphplan
contained relaxed plan. detail, latter proved induction
regression steps relaxed Graphplan. Let state relaxed
plan. top level regression, actions selected support goals
contained s. goals need supported relaxed plan,
actions so. holds true preconditions selected
actions: p pre(a) s, supporter must present relaxed plan,
supporter selected relaxed Graphplan. Iterating argument, get
desired property. claim follows because, proved Hoffmann Nebel
(2001a), relaxed Graphplan selects every action once.
2
19. Note estimate sequential relaxed plan length. length planning graph built
Graphplan corresponds optimal length parallel relaxed plan, admissible heuristic estimate.
However, indicated before, heuristic functions generally found provide useful
search guidance practice (see, example, Haslum & Geffner, 2000; Bonet & Geffner, 2001b).

714

fiWhere Ignoring Delete Lists Works

second sub-class STRIPS demands one goal,
one precondition per action.
Proposition 3 Let (A, I, G) STRIPS planning task |G| 1 and, A,
|pre(a)| 1. Then, states task, h+ (s) = hF F (s).
Proof: given restrictions, relaxed planning comes finding paths
graph nodes facts, edge p p0 iff action
pre(a) = p add(a) = p0 (empty preconditions modelled special fact
node assumed always true). state relaxed plan iff makes fact node
true path goal node. Relaxed Graphplan identifies shortest
path.
2
prerequisites Propositions 2 3 maximally generous, i.e., relaxing one
requirements, one loses h+ (s) = hF F (s) property. obtain sub-optimal relaxed
plans Graphplan, i.e., construct cases h+ (s) 6= hF F (s), suffices one
fact two achievers, either two goal facts one action two preconditions.
following example. facts g1 , g2 , p, p0 . goal {g1 , g2 },
current state empty. actions shown Figure 6.
name
opg1
opg2 -p
opg2 -p0
opp
opp0

=
=
=
=
=

(pre,

add,

del)

({p},
({p},
({p0 },
(,
(,

{g1 },
{g2 },
{g2 },
{p},
{p0 },

)
)
)
)
)

Figure 6: Actions example task hF F 6= h+ .
optimal relaxed plan hopp, opg1 , opg2 -pi. However, Graphplan might choose
achieve g2 opg2 -p0 , ending (parallel) relaxed plan h{opp, opp0 }, {opg1 ,
opg2 -p0 }i. Note action single precondition, single fact
one achiever, two goals. similar example constructed
case one goal one action two preconditions.
Obviously, syntax allowed either Propositions 2 3 far restrictive
adequate formulating practical domains.20 investigate whether
interesting situations h+ hF F same; intuition
case.
different question whether provable relations h+ hF F (some
of) 30 benchmark domains considered h+ investigation. investigate
question detail note investigation would involve constructing detailed
20. remark syntax identified Proposition 3 sub-class tractable class STRIPS
planning identified Bylander (1994). Bylanders class, constant number g goal facts allowed,
g greater 1; preconditions may positive negative.

715

fiHoffmann

arguments individual domains, clearly beyond scope paper.
None domains captured either Propositions 2 3. results
easy obtain following. Simple-TSP, Movie, Miconic-STRIPS, h+ hF F
same. follows extremely simple structure domains,
finding step-optimal relaxed plans Graphplan always results relaxed plans
optimal number actions. However, even slightly complicated domains
Ferry, Gripper, Logistics, Miconic-SIMPLE, Zenotravel, one easily construct states
Graphplans relaxed plans may unnecessarily long. Miconic-STRIPS
happen single vehicle (the lift), capacity restrictions
(on number loaded objects, i.e., passengers). several vehicles transportable
objects, occur Logistics Zenotravel (as well Driverlog, Depots, Mprime,
Mystery, Rovers), difference h+ hF F become arbitrarily large.
imagine n objects must transported l l0 , n vehicles available
l. parallel relaxed planning, makes difference single vehicle transports
objects, one different vehicle selected per individual object. particular, even
FFs action choice heuristics relaxed Graphplan, hF F may 2n + 1 well 3n.21
Ferry Gripper, single vehicle (with capacity restrictions),
may upper bound difference h+ hF F ;
check detail.
spite above, authors personal experience developing that,
least relatively simply structured domains many different operators/different
ways achieve facts, relaxed plans found relaxed Graphplan typically pretty
close optimal. are, presumably, following two reasons this. First,
employed action choice heuristics. example, Grid domain, relaxed plan may
choose pick key k sole purpose dropping picking
another key k0 pickup-and-lose action (c.f. Appendix B.12). happen
selecting actions minimal precondition weight (the pickup-and-lose action
higher weight pickup action unless one already holds k considered state).
Second, many published benchmark instance suites quite restricted. Logistics,
example, situation outlined above, n objects n vehicles waiting location l,
happen trucks single truck city. airplanes,
published benchmark instances usually these, n
small.
5.2 Empirical Relations h+ hF F
large-scale empirical investigation (Hoffmann, 2003b), turned hF F typically
preserves quality h+ . investigation aimed verifying, domains
h+ positive topological property (for example, yielding local minima),
extent property inherited hF F . considered 20 benchmark domains,
namely domains paper hand, except 10 IPC-3 IPC-4 domains.
21. One could circumvent particular phenomenon by, selecting action relaxed Graphplan,
employing minimization summed weight preconditions actions selected far.
topic future work explore effect FFs performance.

716

fiWhere Ignoring Delete Lists Works

Note that, latter 10 domains, three, namely Dining-Philosophers, Satellite,
Zenotravel, positive topological properties.
experimental approach take samples state spaces (a technique adapted
work Frank et al., 1997). precisely, method following.
domain, random generator used produce large set example instances.
instances grouped together according values domain parameters, i.e.,
input parameters generator (for example, number floors number passengers
Miconic-SIMPLE). Then, single instance, 100 states sampled, i.e., 100
random sequences actions executed initial state, sequence length
chosen randomly interval 0 2 times FFs plan length.22
resulting state s, exit distance ed(s) computed breadth-first search, another
search determined whether located valley, i.e., whether path
goal state hF F value decreased monotonically.23 maximal exit
distance instance approximated maximum exit distances
sample states. every group instances, mean number states valleys,
mean maximal exit distance, computed. results visualized plotting
values scaling domain parameters. give examples directly below,
summarizing overall results.
results experiment strongly suggested hF F typically preserves quality
h+ , considered benchmark domains. 13 domains h+ provably yields
local minima, almost sample states located valleys except 2 domains,
namely Grid Hanoi. precisely, 11 domains experiment considered
total 230 groups random instances; one groups, 5.0% sample states
lay valleys, another group 2.2%, another eight groups 1.0%,
remaining 220 groups single valley state found. maximal
exit distance benches, tested instances domains bound
h+ , single sample state exit distance larger bound, namely
exit distance 2 instead 1 Logistics domain.24
Blocksworld-no-arm
Gripper
Hanoi
Tireworld

0.0
0.0
0.0
0.0

0.0
0.0
0.0
0.0

0.0
0.0
96.0
0.0

0.1
0.0
100.0
0.0

0.0
0.0
100.0
0.0

Figure 7: Percentage sample states valleys. Mean values linear increase
respective domain parameter.
Figure 7 provides results regarding sample states valleys, considered
domains local minima (and thus valleys) h+ , in22. tried sampling strategies found make much difference terms
obtained results.
23. Intuitively, local minimum lies bottom valley. used valleys experiment since
may hard find local minimum state sampling.
24. authors guess results similar empirical investigation Dining-Philosophers, Satellite,
Zenotravel would similar, i.e., sampled maximal exit distances would hardly increase
upper bounds proved h+ .

717

fiHoffmann

stances characterized single domain parameter (Movie Simple-Tsp left
since hF F provably h+ ). Blocksworld-no-arm, parameter
number blocks (plus randomization initial goal states); Gripper
number balls transported; Hanoi number discs; Tireworld
number flat tires. domain, left right table entries correspond
linear increase domain parameter (2 . . . 11 blocks, 1 . . . 100 balls, 3 . . . 10 discs,
1 . . . 5 tires, respectively). Obviously, domain behave Hanoi
h+ isnt useful heuristic anyway, yielding large benches, c.f. Section 4.
Blocksworld-no-arm
Gripper
Hanoi
Tireworld

0.3
1.0
6.0
6.0

1.8
1.0
23.0
6.0

2.8
1.0
12.0
6.0

3.8
1.0
2.0
6.0

3.7
1.0
2.0
2.0

Figure 8: Sampled maximal exit distance. Mean values linear increase respective
domain parameter.
Figure 8 shows results regarding sampled maximal exit distance domains
characterized single domain parameter. Gripper Tireworld, sampled values
respect bound valid h+ (in largest Tireworld example, sampling
find maximum state rather large state space). comparison, sampled values
Blocksworld-no-arm, bound h+ , show clear increase. Again,
behavior Hanoi odd.
Figure 9 shows (part of) results domain characterized one
domain parameter, namely Logistics. domains least two domain parameters,
experimental method run one experiment pair them. experiment,
parameters except respective pair set fixed value. data could
visualized 3-dimensional plots ones Figure 9. figure, parameters
scaled number cities number objects (packages) transported;
parameter range 1 . . . 9 cases. City size number airplanes
fixed 3. parameter value combination, 10 random instances generated (and
100 states sampled per instance). valley states found, except 3 cities
9 objects, 2 1000 sample states located valley. 5 cities
3 objects, single instance one sample state exit distance 2, rather bound
1 valid h+ single bound violation found entire experiment.25
indicated before, Grid domain was, Hanoi, domain
experiment suggested major difference topologies h+ hF F . Large
fractions sample states, 62.4%, located valleys. clear
tendency increase percentage, increasing grid size increasing
number keys transported.
all, experiment confirmed that, Blocksworld-no-arm, Briefcaseworld, Ferry, Fridge, Gripper, Logistics, Miconic-SIMPLE, Tireworld domains, hF F
25. decrease mean sampled maximal exit distance large parameter values suggests
becomes harder, sampling, find maximum states rather large state spaces.

718

fiWhere Ignoring Delete Lists Works

Z

Z

1

2

0.5

1

0

0
9

9

7
1

7
1

5

3
X

5

3


5


5

3
7

X

9 1

(a)

3
7

9 1

(b)

Figure 9: Mean sampled valley percentage (a) maximal exit distance (b) Logistics,
scaling cities (x-axis) objects (y-axis).
largely preserves quality h+ (no local minima and/or constant bound maximal exit distance benches). Remember Miconic-STRIPS, Movie, Simple-Tsp
three domains this, provably, applies.

6. Towards Automatically Detecting h+ Phenomena
lemmas presented Section 3 provide natural starting point investigations
domain analysis techniques trying detect topological phenomena automatically.
domain analysis techniques would useful configuring hybrid systems, i.e.,
automatic selection heuristic functions likely well-suited solving given
planning task. Further, techniques would useful avoiding need re-do
h+ investigation every single new planning domain. Finally, basis
analysis techniques one may able compute good lower bounds h+ ,
informative admissible heuristic function. discussion points contained
Section 7.
question addressed if, extent, how, application
lemmas Section 3 automated, i.e., one automatically check
whether prerequisites satisfied given STRIPS task. section hand,
present preliminary attempt made that. attempt
successful, believe investigation value showing one achieve
simple analysis techniques, weak points would needed improved
upon order obtain better results.
Invertible (or least invertible) actions, actions irrelevant delete/static add
effects, syntactically defined Section 3 thus easy detect. difficulty
find inconsistencies facts. hard planning itself,
several approximation techniques literature (for example, Blum & Furst, 1995, 1997;
Fox & Long, 1998; Gerevini & Schubert, 2000, 2001; Rintanen, 2000), tend work
well, least current benchmarks. challenge find syntactical
characterizations actions respected relaxation, actions
719

fiHoffmann

relaxed-plan relevant delete effects. Now, many domains phenomena
occur, example Ferry, Gripper, Logistics, Miconic-STRIPS, Movie, Simple-Tsp,
Tireworld, intuitively one looks domains causes phenomena
seem similar. getting actual syntax domain descriptions,
individual details different becomes difficult get hold
common ground. seem simple syntactical definition captures
behavior actions domains; least find syntactical
definition. Instead, tried reason additive structure domains,
possible interactions delete effects. (The intuition that, domains
simple h+ topology, interactions arent harmful.) captured
additive structure domain/of instance data structure called fact generation
trees. next subsection describes data structure basic properties,
subsection gives results extreme case h+ topology, subsection outlines
somewhat advanced analysis technique developed.
6.1 Fact Generation Trees
fact generation tree, short FGT, planning instance basically AND/OR tree
results regression search starting goals, ignoring delete effects
actions. Tree nodes labelled facts actions alternatingly. Fact nodes
nodes represent choice achieving actions action nodes nodes
preconditions represent sets facts must achieved together. assume goal
achievement action, known from, example, description UCPOP (Penberthy &
Weld, 1992). action root (AND) node FGT, top level goals form
sons. Obviously, sons fact node actions achieve fact,
sons action node precondition facts action. (For sake
simplicity, stayed pure STRIPS framework investigation.) Tree structures
kind were, example, described used Nebel, Dimopoulos, Koehler (1997)
work automatically detecting irrelevant facts operators. Note FGT
take account interactions may arise trying achieve facts
node together. effect ignoring delete lists, FGT treats
facts completely separately.
terminate FGT applying following two rules.
1. Say inserted action node N (a) labeled action a. fact
p pre(a) fact node labeled p occurs path root node
N (a), N (a) pruned.
2. Say inserted, son action node N (a), fact node N (p) labeled
fact p. action a0 p pre(a0 ), action node labeled
a0 occurs path root node N (a), N (p) pruned.
Intuitively, rules disallow generation branches FGT would redundant relaxed plan. Formally, call relaxed plan non-redundant strict subsequence still relaxed plan (i.e., action omitted). Every non-redundant
relaxed plan, every (not necessarily reachable) state, embedded connected,
rooted, non-redundant sub-tree FGT built way described above.
720

fiWhere Ignoring Delete Lists Works

precise introducing illustrative example Figure 10, use
throughout section.

E

E

== 1 EUR

mv E


+= 1 EUR

B

C


1 EUR


mv B

mv C

B

C

mv C

mv B



Figure 10: Sketch FGT illustrative example.
example, task reach location E. available actions moves along
(bi-directional) graph edges obvious encoding using predicate, except
move E, requires additional precondition possession
1 EUR. acquire 1 EUR add effect action moves
C. main part Figure 10 shows FGT example, picture top left
corner illustrates example showing road map graph indication role
1 EUR constructs. root node, i.e., artificial goal-achievement action,
included figure, simplicity. Due termination rule 1, (for example) moving
E included son fact node labeled (the precondition E
root node). Due termination rule 2, son action node labeled
mv C (at already occurs precondition mv E above).
Every action non-redundant relaxed plan (to arbitrary state) achieves
unique needed fact achieved preceding action, needed
goal precondition subsequent action.26 overly difficult prove
one thus embed relaxed plan FGT processing relaxed plan
back front, associating action corresponding node needed
fact added action, starting goal facts. resulting sub-tree connected
rooted sense actions associated consecutive nodes, starting
root node. sub-tree non-redundant sense that, every node,
26. observation made by, example, Hoffmann Nebel (2001b), used detect
actions participate non-redundant relaxed plan, thus need
considered heuristic computations done planners HSP.

721

fiHoffmann

one son gets associated action. Termination rule 1 valid since fact needed
end relaxed plan needed start. Termination rule 2 valid
since every needed fact least one representative node corresponding subtree. illustration, consider different locations graph underlying example
Figure 10. one located, example, 1 EUR,
entire FGT except mv C node corresponds sub-tree non-redundant
relaxed plan. sub-tree obtained follows. relaxed plan mv B, mv B
D, mv C, mv E. needed facts added actions B, D, 1
EUR, E, respectively. Starting goal fact E, first mv E gets
associated respective action node. fact nodes 1 EUR
preconditions action dealt become open, mv B well
mv C get associated respective node respective needed fact.
consequence mv B action, fact node B becomes open, mv B gets
associated action node it. process stops. If, current state,
one is, example, located C 1 EUR, process selects sub-tree
consists mv C mv E nodes only.
Every non-redundant relaxed plan instance, particular every optimal relaxed
plan instance, corresponds sub-tree FGT. FGT summary
possible relaxed plans sense, idea examine FGT harmful interactions
conflicts potential appear relaxed plan. hope able draw
conclusions non-existence/restricted form conflicts topological properties
h+ . next outline extreme case analysis kind, namely one postulates
absence conflicts FGT. Note that, difference situation
illustrative example, general FGT contain action/fact labels multiple nodes.
worst-case size FGT exponential size instance description. So,
design practically usable domain analysis techniques, one would need approximate
FGT, instead building completely. aspect treated follows,
objective (only) find implications FGT structure h+ topology
first place.
6.2 Interaction-free Planning Tasks
Think conflict situation one part (non-redundant) relaxed plan
hinder execution/success another part relaxed plan.
conflicts, every (non-redundant) relaxed plan executable reality, implying
h+ equal real goal distance (which course implies local minima
etc). investigated 30 benchmark domains, case (only) Simple-Tsp,
use motivating example.
define three kinds conflicts FGT. call two action nodes, labeled
actions a0 , allied participate together non-redundant sub-tree, i.e.,
occur together embedding relaxed plan, descendants
other. (This case iff paths root node a0 separate
node.) first kind conflicts given pair allied action nodes labeled a0 ,
deletes precondition a0 . Second kind conflicts, pair action nodes labeled
a0 , descendant a0 , deletes precondition a0 added
722

fiWhere Ignoring Delete Lists Works

action path a0 . Third kind, action node labeled a,
deletes goal fact added action path respective root
node.
conflicts FGT, call task interaction-free. relatively
easy see that, without conflicts, every non-redundant relaxed plan (for every nonredundant sub-tree FGT) execution order works reality. h+
equals goal distance interaction-free tasks.
illustrative example Figure 10, conflict FGT
nodes mv C mv E nodes allied, mv C deletes
precondition mv E. Note conflict indeed capture reason
h+ equal goal distance example. order able move
E, one first move C get 1 EUR. latter deletes
precondition former. relaxation, move C, one
located C time, relaxed plan needs one step less
achieve goal (from states move C yet done).
example domain interaction-free tasks graph-search domain mentioned earlier, tasks demand find path two nodes directed
graph, using obvious at-predicate connected-predicate based encoding. (Our
illustrative example becomes instance domain one removes 1 EUR
constructs.) even come purely syntactic criterion captures
example domain.
Proposition 4 Let (A, I, G) STRIPS planning task
1. |G| 1,
2. A: |pre(a)| 1,
3. A: del(a) pre(a).
(A, I, G) interaction-free.
Proof: Due prerequisites 1 2, nodes FGT one son.
implies allied action nodes. Together prerequisite 3
termination rule 1, implies action node delete goal fact, precondition
fact ancestor node.
2
Instances graph-search domain fulfill prerequisites Proposition 4
static connected facts removed prior planning. Note syntax identified
Proposition 4 subset syntax identified Proposition 3, thus tasks
hF F identical h+ , and, since h+ identical real goal distance, plan existence
decided polynomial time. Intuitively, captured syntax
express graph-search domain: plans task qualifying Proposition 4
correspond exactly paths graph nodes facts, edges go
preconditions add effects. true relaxed plans.
instances Simple-Tsp domain interaction-free. conflicts
FGT pairs actions achieving different visited goals. example, say
723

fiHoffmann

three locations visit, l1 , l2 , l3 . action nodes mv l1 l2 mv l1
l3 allied since achieve goals visited l2 visited l3 participate
root node. actions mutually delete precondition, l1 ,
constitute conflict FGT. appear together relaxed plan,
relaxed plan executable reality (unless relaxed plan happens move back
l1 between). Observe, however, execution of, example, mv l1 l2 , one
replace mv l1 l3 mv l2 l3 repair conflict relaxed plan.
conflicts Simple-Tsp FGTs behave way.
general, say conflict allied action nodes a0 repaired
action a00 pre(a00 ) (pre(a) add(a)) \ del(a) (thus a00 executed
a), add(a00 ) add(a0 ) (thus a00 achieves a0 achieved). Similar
repairable cases identified two kinds conflicts. conflicts
FGT repaired, non-redundant relaxed plan relaxed plan
length executable reality, h+ equals goal distance.
case Simple-Tsp domain.
made preliminary implementation FGT analysis techniques.
implementation correctly detects Simple-Tsp instances (as well graph-search
instances), h+ equals goal distance. Simple-Tsp, less 18 locations analysis
takes split seconds; 18 locations, runtime taken explodes fairly
quickly.
6.3 Advanced Analysis
results encouraging, techniques applicability h+ topology
detect clearly far severely restricted. turns extremely difficult find
less restrictive implications FGT structure h+ topology, i.e., sufficient criteria
weaker topological properties. best could come criterion implies
non-existence local minima h+ , holds true Movie domain
extremely simple Logistics instances.
idea behind criterion following. imply non-existence local
minima h+ , suffices know that, every state s, starting action
optimal solution h+ (Result(s, hai)) h+ (s). Say considering planning
task actions (at least) invertible. Let state starting action
optimal solution s. optimal relaxed plan contains a,
done argument used Lemma 3. Else, let P + optimal relaxed plan
contain a. P + embedded sub-tree FGT.
delete leaf nodes sub-tree facts P + assumes true state
execution P + relaxed plan Result(s, hai) done, too. case left
open delete leaf node sub-tree occupied P + . Observe
matter (or repairable) conflicts sub-tree.
Then, P + executable reality, P + optimal plan s, starting action
P + falls first case done again. get following sufficient
criterion:
724

fiWhere Ignoring Delete Lists Works

local minima h+ actions holds least
invertible, non-redundant sub-trees FGT contain a, either
delete leaf sub-tree, sub-tree contain conflicts.
test criterion, one needs consider (redundant) sub-tree FGT
branches left start nodes labeled a. sub-tree
contains conflict, deletes fact occurring sub-tree, criterion
apply. Otherwise, test succeeds actions, proved local
minima h+ .
Reconsider illustrative example Figure 10, said conflict
FGT nodes mv C mv E. sub-tree
contain one nodes conflict-free. mv C mv E violate
criterion. Neither mv B D, mv C D, mv B violate criterion, since
none actions deletes fact occurring anywhere else precondition.
However, mv B mv B sub-tree looked entire FGT including
conflict, actions delete fact occurs FGT. criterion
apply illustrative example. Note mv B mv B never start
optimal plan really could left considerations; unclear
detect automatically, general way.
remark side order here. action appear FGT, then,
difference one may think first sight, imply appear
optimal plan. FGT termination rules, adequate relaxed planning,
restrictive real planning. following example. facts g1 , g2 ,
p. goal {g1 , g2 }, current state {g1 }. actions shown Figure 11.
name
opp
opg2
opg1

=
=
=

(pre,

add,

del)

({g1 },
(,
({p},

{p},
{g2 },
{g1 },

)
{g1 })
)

Figure 11: Actions example task FGT contain action (opp,
namely) needed reality.
optimal plan hopp, opg2 , opg1 i: order able re-achieve g1
applying opg2 , must achieve p first. However, opp appear FGT.
location FGT node N labeled opp could inserted
son precondition node p opg1 , inserted son g1 . N pruned
termination rule 1, opp g1 precondition, g1 appears path
root node N . Note that, indeed, opp never part relaxed plan
achieving p good re-achieving g1 deleted actions necessary
reach goals.
implementation criterion given easily within split seconds proves
non-existence local minima Movie instances, regardless size instance.
725

fiHoffmann

technique not, however, work domain tried, except Logistics
instances single city, two locations it, single truck,
single package transported. Note even simpler small
illustrative example used Section 3, two objects need transported.
open question better results achieved, i.e., state spaces
recognized feature local minima h+ . feeling backward
chaining approach domain analysis promising. But, successful, analysis
technique probably invest much effort analyzing way
goals achieved, many steps, rather crude
FGT approximation. information available goals achieved,
maybe would possible discover non-trivial cases actions respected
relaxation.27 detecting actions relaxed-plan relevant delete effects,
yet completely unclear us could accomplished.

7. Discussion
derived formal background understanding classes domains relaxed plan-based heuristic methods, wide-spread methods modern planning
landscape time writing, well suited for. formal approach taken
identify characteristics local search topology heuristic cost surface
idealized heuristic function h+ , forward searching framework. 30 commonly used
benchmark domains including competition examples, i.e., basically STRIPS
ADL benchmark domains used field time writing, proved
relevant topological properties are. results coincide well runtime behavior
FF. Indeed, empirical results suggest quality h+ often preserved FFs
approximation it.
results interesting give rare example successful theoretical
analysis connections typical-case problem structure, search performance.
practical point view, results provide clear picture strengths
weaknesses h+ lie, form good basis embarking improving heuristic
weak cases. Approaches kind already appeared literature (Fox &
Long, 2001; Gerevini et al., 2003). particularly, Fast-Downwards heuristic function
(Helmert, 2004) motivated observations regarding unrecognized dead ends h+
Mystery domain, large benches transportation domains non-trivial road
maps.
Regarding relevance topological results forward search algorithms
enforced hill-climbing, note things non-existence unrecognized dead
ends non-existence local minima certainly useful heuristic search
algorithm, albeit form provable polynomiality result.28 generally,
relevance topological results performance planners using search
27. remark easy find even trivial syntactical restrictions actions are,
general, respected relaxation. example, even every fact added single action,
one construct cases non-respected actions. One case example Figure 11,
opp respected relaxation.
28. Except case heuristic function identifies precise goal distances, case
h+ 1 30 domains, namely, Simple-Tsp domain.

726

fiWhere Ignoring Delete Lists Works

paradigms, enhanced heuristics, LPG Fast-Downward, matter needing investigation. One thing certainly clear that, easiest classes
taxonomy, particularly domains state space local minima h+ , benches escaped single step, planner using approximation
h+ likely work quite well. Indeed thats one observes practice. intuition
author topology h+ plays large role efficiency planners
generally, i.e., domains. Proving disproving beyond scope
paper. case, investigation provides nice theoretical background
proved results idealized setting, results used starting point
investigations tailored individual systems FF.
investigation considers solvable planning tasks only, well justified
focus set international planning competitions. Turning focus unsolvable tasks,
one realizes much techniques results become useless. search space
solution, difference heuristic function make lies states
infinite heuristic value, i.e., states recognized dead ends. means
interesting question remaining kinds dead end states
relaxed plan. results herein tell us this? domains
identified unrecognized dead ends, results tell us relaxed plans generous
approximation.29 domains, things look hopeful. Still, results
relative solvable instances. Whether h+ detect many dead end states
unsolvable tasks depend reasons states. dead
ends unsolvable tasks may caused reasons solvable tasks,
since assumptions making tasks solvable given. Note many
benchmarks (for example, Blocksworld Logistics) unsolvable instances
standard definition. extent, makes existence non-existence
unrecognized dead ends choice domain designer extending domain definition.
Exploring issues detail topic future work.
Talking future work, biggest drawback research current form is,
obviously, needs re-done every single new planning domain. would
desirable, turns hard, come generic ideally, automatic
methods determine topological properties domain. outlined
attempt made develop automatic methods, based analyzing properties fact
generation trees. presented first promising results, regarding applicability
domains complexity one would able handle, methods yet far
weak. left future research answer question approaches
topic work better practice. said, intuition better
approaches, based intelligent backchaining-style reasoning goals
achieved domain. But, time writing, pure speculation.
Beside easening burden proofs hand, benefits automatic domain analysis techniques would twofold. First, ambitious long-term vision domainindependent planning arsenal complementary heuristics, combine
hybrid system automatically configured best suit given arbitrary
planning task. contribution made towards vision results hand
29. Unsurprisingly, seeing deciding plan existence NP-hard in, example, Mystery, Mprime, MiconicADL, Freecell (Helmert, 2003).

727

fiHoffmann

clear picture strengths h+ lie; able automatically configure hybrid system, one would need multiple heuristics different strengths weaknesses
(i.e., heuristics high quality different classes domains), well ability
determine automatically heuristic likely work best. (At least approach could cost-effective, beside much insightful, trying
possible combinations techniques.)
Another benefit enhanced domain analysis techniques might lie ability
generate high-quality admissible heuristic function sequential planning. many domains, optimal relaxed plans mostly consist actions easy human
see (or one set similar actions) must contained optimal
relaxed plan (for example, loading unloading actions cant avoided
transportation task). number actions state could provide good lower
bound value h+ . Note phenomenon actions must contained
every relaxed plan stronger version notion actions respected
relaxation. promising approach seems try detect former sufficient
approximation latter.
Since observed arbitrarily deep local minima h+ Blocksworldarm, none Blocksworld-no-arm, one might try come encoding methods
trying model domain way making best suited h+ . Since Blocksworld-no-arm
basically version Blocksworld-arm possible pairs consecutive actions
(pickup-stack, unstack-stack, unstack-putdown) replaced macro-actions, good
(but somewhat obvious) heuristic modeling probably choose domain granularity
high level abstraction possible. insightful heuristics may obtained
considering h+ topology planning benchmarks enriched automatically
detected macro actions (Botea, Muller, & Schaeffer, 2004, 2005).
Apart above, important future direction adaption formal
framework, theoretical analysis methods, temporal numeric settings
dealt modern planning benchmarks modern planning systems. needed
adaptations straightforward numeric framework used Metric-FF (Hoffmann,
2003a). temporal planning, objective function estimated heuristic
number actions needed complete partial plan, adaptation framework
probably straightforward well. If, however, makespan estimated heuristic,
said article apply. most, setting
analysis techniques could relevant search uses estimation remaining action
steps secondary heuristic.

Acknowledgments
would thank Drew McDermott, Fahiem Bacchus, Maria Fox, Derek Long
responses various questions concerning definitions of/intentions behind
competition domains. thank anonymous reviewers, whose comments helped
improve paper.

728

fiWhere Ignoring Delete Lists Works

Appendix A. Proof Sketches
list proof sketches sections concerning dead ends, local minima, benches,
order.
A.1 Dead Ends
Theorem 1 state space solvable instance
1. Blocksworld-arm, Blocksworld-no-arm, Briefcaseworld, Depots, Driverlog, Ferry,
Fridge, Gripper, Hanoi, Logistics undirected,
2. Grid, Miconic-SIMPLE, Miconic-STRIPS, Movie, Pipesworld, PSR, Satellite,
Simple-Tsp, Tireworld, Zenotravel harmless,
3. Dining-Philosophers, Optical-Telegraph, Rovers, Schedule recognized evaluation h+ .
proofs simple applications Lemma 1 2. said, descriptions
domains looked Appendix B.
Proof Sketch: [Theorem 1]
actions Blocksworld-arm, Blocksworld-no-arm, Driverlog, Ferry, Gripper, Hanoi,
Logistics instances invertible, apply Lemma 1 finished.
inverse actions obvious ones cases, stacking/unstacking block onto/from
block, loading/unloading object onto/from vehicle, moving l
l0 /moving l0 l (in case Driverlog, latter always done
underlying road map bi-directional, c.f. Appendix B.8). Briefcaseworld, Depots,
Fridge domains, actions strictly obey definition invertible
(neither least invertible), still invert obvious way,
i.e., every state applicable action action Result(s, ha, ai) = s.
Movie, actions getting snacks irrelevant delete effects static add effects,
rewinding movie resetting counter least invertible. Simple-Tsp action
moving l l0 least invertible moving back. Tireworld, working steps
inverse one, except inflating wheel. irrelevant delete effects
static add effects. Miconic-STRIPS, moving lift invertible, boarding passenger
least invertible, departing passenger irrelevant delete effects static add
effects. four domains, Lemma 2 thus applied. Miconic-SIMPLE
Grid domains, actions strictly adhere relevant definitions, similar
arguments Lemma 2 prove non-existence dead ends. Miconic-SIMPLE, moving
lift invertible. Letting passengers lift inverted,
actions need applied (similar static add effects),
interfere anything else (similar irrelevant deletes). Grid, actions
inverse action, except opening lock. latter action excludes actions opening
lock (similar irrelevant deletes), lock needs opened once,
locks closed (static add effects). Zenotravel Satellite, facts
re-achieved sometimes one apply several actions so. Zenotravel,
729

fiHoffmann

flying airplane l l0 , get back l0 one might refuel airplane
top flying back. Satellite, switching instrument on, one might recalibrate it, always done involve several actions (turning satellite
right direction applying actual calibration action). Pipesworld,
push action inverted respective pop action, vice versa. state space
undirected since pushs/pops non-unitary pipeline segments split two parts.
PSR, dead end states since one always reach goal state waiting,
necessary, opening breakers, bringing (non-breaker) devices goal
position, closing needed breakers.
Dining-Philosophers, dead ends arise process (a philosopher) initiated impossible reading writing command (from/to empty/a full queue)
queue contents updated, actions applicable. (The derived
predicate rules determine process blocked apply case, since
require read/write command initiated yet.) Obviously, applicable
actions relaxed plan either. states, goal reached
traversing individual process state transitions philosophers one fork, try
take other.
Optical-Telegraph, dead ends arise two kinds situations. First, process
initiated impossible reading writing command, similarly Dining-Philosophers,
applicable actions thus relaxed plan. second possibility
two processes pair may take different decisions go next communication sequence: one may decide stop data exchange, may decide
send receive data. situation, least one processes state
two transitions available, already activated one transitions,
might already initiated respective write/read command. write/read command
impossible (since process took different decision), actions
applicable process. derived predicate blocking rules apply
process, never apply process states one available transition.
neither real relaxed plan exist state. reachable states,
goal reached traversing individual process state transitions pairs
communicating processes occupy one control channel, try write other.
Rovers, plan state if, soil/rock samples images
need taken, rover job, communicate
gathered data lander. chance run dead end take soil/rock
sample rover reach lander (the soil/rock sample available once).
then, relaxed plan state either.
Schedule, state gd(s) < solved applying, object
turn, certain sequence working steps. sequence applied object
follows preconditions needed action fulfilled, must
case cold (a do-roll action applied previously,
making hot). operator make cold again, i.e., operator adds respective
fact. Thus relaxed plan either.
2
Note worst cases Theorem 1 occur, i.e., domains whose instances
harmless, directed state transitions, domains whose instances
730

fiWhere Ignoring Delete Lists Works

recognized, dead ends. remark dead ends Dining-Philosophers
Optical-Telegraph due seem bugs encoding queues
(whose contents arent always updated correctly) blocked situations (whose rules
detection seem incomplete). Modifying operators straightforward way
fix (apparent) bugs, one gets dead-end free (harmless) state spaces.
domains mentioned Theorem 1 Airport, Assembly, Freecell, MiconicADL, Mprime, Mystery. domains, one construct arbitrarily deep
unrecognized dead ends. Airport, unrecognized dead ends arise two planes move
towards line segments, possibility changing direction.
deadlock situations arent recognized relaxed planning since, relaxation,
free space left two planes remains free, used navigate planes
across other. dead end becomes arbitrarily deep when, independently
deadlock situation, planes still moved. remark that, reality
IPC-4 example instances deadlock situations rarely occur. Airplanes
movable along standard paths serve avoid deadlocks main connecting
routes airport. places airport deadlocks occur,
reality IPC-4 example instances, near parking areas, space
dense, airplanes need move directions airport segment.
deadlocks occur all, i.e., planes move target positions one
without hindering other, h+ delivers exact goal distance.
presumably reason heuristic planners performed well IPC-4 Airport
test suites. performance would probably become worse one use (unrealistic)
instances excessively many potential deadlock situations.
Assembly, unrecognized dead ends arise several objects stuck due
complex ordering constraints, imply solution plan would need go
cyclic assembly pattern. details rather complicated, interested reader
referred TR (Hoffmann, 2003c). proved that, unless ordering constraints
Assembly instance potential yield cyclic situation, dead
ends all. one IPC-1 competition instances, ordering constraints
potential. helps explain efficient test suite
(it solves even largest task within half second search time, finding plan 112
steps).
Freecell, unrecognized dead ends arise, example, one cautious
enough moving cards free cells. relaxed plan still achieve goal
single free cell, using cell intermediate store cards. reality,
however, moving card free cell occupies space (by deleting availability
free cell), thus exclude possibilities reaching goal. Thus moving card
free cell lead unrecognized dead end state. unrecognized dead end
arbitrarily deep cards still moved around independently deadlock
situation.
Miconic-ADL, unrecognized dead ends arise problem constraint violated,
violation goes unrecognized relaxed plan. example two passengers
p1 p2 lift, p1 transported downwards, p2 access
p1 destination floor, p2 destination floor p1 s. state dead end
one let p1 get first p2 access respective floor
731

fiHoffmann

neither one let p2 get first afterwards, lift would need drive upwards,
cant p1 board. relaxation, one stop destination floors
simultaneously at-facts deleted. unrecognized dead end becomes
arbitrarily deep several passengers moved around reaching p1
destination floor.
Mystery, unrecognized dead ends arise fuel scarce, vehicle makes suboptimal moves. relaxed plan achieve goal long relevant locations
still accessible least once. may suffice reality. dead end becomes arbitrarily deep additional objects transported independently problematic
situation. Mprime behaves similarly. difference Mystery example that,
avoid possibility transferring fuel items problematic locations, one must make
sure enough fuel enable transportation additional objects.
A.2 Local Minima
Theorem 2 h+ , maximal local minimum exit distance state space
solvable instance
1. Blocksworld-no-arm, Briefcaseworld, Ferry, Fridge, Grid, Gripper, Hanoi, Logistics,
Miconic-SIMPLE, Miconic-STRIPS, Movie, Simple-Tsp, Tireworld 0,
2. Zenotravel 2, Satellite 4, Schedule 5, DiningPhilosophers 31.
present proof sketch Theorem 2 terms three groups domains
similar proofs. Note domains maximal local minimum exit distance 0
domains local minima all. first focus domains
Lemma 3, slight extensions it, applied.
Proof Sketch: [Theorem 2, Ferry, Fridge, Gripper, Logistics, Miconic-SIMPLE, MiconicSTRIPS, Movie, Simple-Tsp, Tireworld]
Theorem 1, none listed domains contains dead ends. said proof
sketch theorem, actions Ferry, Gripper, Logistics, Miconic-STRIPS, Movie,
Simple-Tsp, Tireworld domains either least invertible, irrelevant delete
effects. Lemma 3 suffices show actions respected relaxation.
cases, except driving/flying actions Logistics, easy see
optimal starting action something avoided relaxed plan. (For
example, relaxed plan avoid load/unload objects onto/from vehicles,
avoid missing working steps Tireworld.) optimal starting action
Logistics drives truck/flies airplane location l, object must either
loaded unloaded l, relaxed plan choice apply action
moves transportation vehicle (of kind) there. vehicles equally good, except
clever choice, i.e., vehicle already carries objects unloaded
l. then, move one vehicles optimal relaxed plan will,
vehicles equally good relaxation. (In Ferry, Gripper, Miconic-STRIPS,
732

fiWhere Ignoring Delete Lists Works

single vehicle, makes moving actions domains easier
reason about.)
Fridge Miconic-SIMPLE domains, actions adhere strictly
definitions invertibility irrelevant delete effects. proof Theorem 1
shown similar semantics, i.e., either inverted, delete
facts longer needed applied. Furthermore, actions
domains respected relaxation. Fridge, missing working steps must
done relaxed plan. Miconic-SIMPLE, lift moves trivially respected, lift
stops respected since clever choices reality coincide clever choices relaxed
plan.
2
next four domains, local minima either, proofs
sophisticated make use rather individual properties respective domains.
cases proved path goal h+ increase.
Proof Sketch: [Theorem 2, Blocksworld-no-arm, Briefcaseworld, Grid, Hanoi]
Theorem 1, none domains contains dead ends. Blocksworld-no-arm,
optimal starting action stacks block goal position, starts
optimal relaxed plan (because better thing achieve goal
immediately); relaxed plan, replaced inverse counterpart form
relaxed plan successor state. action state s, one
optimal plan starts putting block b must moved order access block
block c onto table, yielding state s0 . relaxed plan
s0 constructed relaxed plan P + by, taking account various case
distinctions, replacing move actions regarding b P + number
move actions. case distinctions kind action P + uses move b
away c one action a0 must contained P + . a0 moves b table
replace a0 P + action moves b back onto c, finished. Else,
must distinguish cases b required c goal,
block. cases, make successful use fact b moved
position position within single action, enabling us exchange actions
P + quite flexibly.
Briefcaseworld, actions inverted. Actions put objects briefcase
trivially respected relaxation. state optimal plan starts
take-out action, optimal relaxed plan used successor state, since
taking object delete important facts. state optimal plan
starts move action l l0 , P + relaxed plan s, relaxed plan
successor state constructed replacing moves l l00 , l00 6= l0 , P + ,
moves l0 l00 .
Grid, rather complex procedure applied identify flat path state
better h+ value. state s, let P + optimal relaxed plan s, let
first unlock action P + , putdown unlock action. Identifying flat
path state s0 applied suffices, unlocking deletes facts
irrelevant lock open, deletes putting key irrelevant
locks must opened. selected action uses key k
733

fiHoffmann

position p. P + contains sequence actions moving p. Moving along path defined
actions increase h+ since actions contained relaxed plan,
inverted. k already held s, apply a. hand
empty s, key held, one use P + identify flat path state
one hold appropriate key k. hand empty, P + must contain
sequence actions moving location k picked up. key
held, P + must contain sequences actions moving locations series
keys picked put down, key series ends picking k.
Hanoi, proved optimal relaxed solution length state equal
number discs yet final goal position proceeding
smallest largest disc, respective goal achieved single action.
optimal plan moves disc away final position, h+ increase optimal
solution paths.
2
finally consider four domains local minima, one always
escape within constant number steps. cases, prove upper bound
distance non-dead end state state s0 h+ (s0 ) < h+ (s). immediately
implies 1 upper bound maximal local minimum exit distance (it
implies 1 upper bound maximal bench exit distance; results
re-used Appendix A.3).
Dining-Philosophers, h+ loosely connected goal distance, bound,
holds even trivial heuristic function returning number yet un-blocked
philosophers, follows rather constant restrictive domain structure.
three domains, proofs proceed follows. reachable state s, identify constant
number steps suffices execute one action optimal relaxed plan s, and,
without deleting relevant add effects, re-achieve relevant facts deleted
a. Then, state s0 h+ (s0 ) < h+ (s) reached.
Proof Sketch: [Theorem 2, Dining-Philosophers, Satellite, Schedule, Zenotravel]
Theorem 1, dead ends Dining-Philosophers recognized. non
dead end state s, shortest relaxed plan blocks processes (philosophers)
yet blocked. individual process, 3 steps needed relaxation,
block process always suffices activate state transition, initiate read/write
command, queue update. update, queue empty full,
read/write impossible sense blocking rules apply. (With this,
process block relaxation, h+ value fairly loosely correlated
true goal distance.) Thus, reach state lower h+ value, obviously always
suffices block one process. prove upper bound determining constant
bound number steps needed that. bound exists because, beside
fact philosopher processes constant interfere respective
two neighbors table, philosophers fixed order try pick
forks: always first try pick fork right, fork left.
restricts possible combinations internal states neighbored philosophers.
detail, philosopher blocked iff tries pick fork
table. philosopher p, refer pL ps neighbor philosopher left side.
734

fiWhere Ignoring Delete Lists Works

description 5 different states philosopher process Appendix B.7. Let
non dead end state. Let p philosopher blocked (if p exists,
goal state nothing prove). prove desired upper bound
exhaustive case distinction states p pL. state {1, . . . , 5}
p, consider state iL {1, . . . , 5} pL. combination iL
possible, nothing. Else, determine number k process state transitions
leads state either: p blocked pL still blocked blocked
s; pL blocked blocked s. cases,
make distinctions internal state pLs left neighbor pLL. worst case, k = 6,
occurs = 3, i.e., p holds adjacent forks. Then, pL either
state iL = 1 iL = 4 (which means, pL cant hold fork pL p since
held p). iL = 4, pL blocked s; pL put left fork, getting
state 1 pL blocked since waits pick right fork, held p. iL = 1
distinguish two cases state pLL. = 3 (p holds
adjacent forks), iL = 1 (pL waits pick fork p pL); pL
blocked. Case A, state pLL 0, 2, 3, pLL holds fork pLL
pL. go p 3 4, 4 1, 1 2, go pL 1 2.
Then, p pL blocked since wait pick fork left. Case B,
state pLL 1 4, fork pLL pL table, pLL
blocked. go pLL 4 1 (if 4), 1 2. that, pLL holds
fork pLL pL; case apply sequence, getting us
state pLL possibly blocked, p pL definitely blocked.
always need 6 process state transitions block one philosopher.
process state transitions take 4 planning actions each, makes 24 planning
steps. planning steps needed due subtleties PDDL encoding.
Subtlety A, process may already decided go state, yet arrived
i.e., respective transition activated read/write command initiated,
communication channel/queue occupied transition yet complete.
2 steps needed reach next internal state (update queue wrap
transition). Subtlety B, blocked state process must activate outgoing
transition. worst case described above, p, pL, pLL may require 2
steps induced subtlety A; p pL require step induced subtlety B.
get (at most) 32 planning actions. effect last action, one process
becomes blocked, upper bound exit distance 31.
Theorem 1, dead ends Satellite. Let reachable state.
determine upper bound distance state s0 h+ (s0 ) < h+ (s),
one look optimal relaxed plan P + s, distinguish four cases regarding
existence applicable actions different types P + . action type, constant
number steps suffices re-achieve deleted facts application action.
worst case, = 5, arises switch-on action applied. Switching instrument
deletes instruments calibration. re-achieve this, one must turn satellite
calibrate it. another turn taking image, state lower h+ value reached.
Theorem 1, dead ends Schedule recognized. Let non-dead
end state. determine upper bound distance state s0
h+ (s0 ) < h+ (s), one look optimal relaxed plan P + distinguish seven
735

fiHoffmann

cases regarding kinds applicable actions P + contains. worst case, = 6,
arises do-roll action available (and applicable) P + . One needs
apply time-step, do-lathe action achieve desired effects do-roll, another time
step, do-polish do-grind action re-achieve previous surface condition, another
time step, do-immersion-paint action re-achieve previous color.
Theorem 1, dead ends Zenotravel. reachable state s, determine
desired constant d, distinguishing two cases job. relaxed plan P +
contains applicable boarding, departing, refueling action, applying action
leads state lower h+ value. Else, P + starts flying action, better
state reached executing flight, refueling once, boarding departing
person. get = 3.
2
Note proved bound Dining-Philosophers holds even take heuristic
function trivial one returns number yet un-blocked philosophers.
extremely cumbersome figure exactly worst-case exit distance DiningPhilosophers h+ so, one consider combinations possible states
neighbored processes, possible developments lot action steps, rather
un-intuitive PDDL encoding made automated translation machinery. highest
exit distance could actually construct Dining-Philosophers 15. conjecture
(tight) upper bound.
Satellite, Schedule, Zenotravel, proved upper bounds tight.
Dining-Philosophers, Satellite, Schedule, Zenotravel, bounds valid nondead end state s. So, beside bound local minimum exit distance, results
provide bound bench exit distance; re-use Appendix A.3.
Blocksworld-arm, Depots, Driverlog, Optical-Telegraph, Pipesworld, PSR, Rovers,
one construct local minima arbitrarily large exit distances. Blocksworld-arm,
example situation n blocks b1 , . . . , bn initially form stack bi
bi+1 bn table, goal build stack top
another block bn+1 , i.e., goal stack b1 , . . . , bn , bn+1 . Reaching, initial state,
state better h+ value, involves disassembling entire stack b1 , . . . , bn .
disassembling process, h+ increases. example used Depots.
Driverlog, local minima arise due different road maps trucks drivers,
example, takes one step drive location l another location l0 , n
steps walk. relaxed plan, driver drive truck goal
staying is, reality, driver walk way back.
Optical-Telegraph, treated easily reconsidering DiningPhilosophers domain, proved constant upper bound above. reason
Optical-Telegraph basically permissive version Dining-Philosophers,
philosophers choose fork pick first, and, hold forks,
fork want put first. Consider configuration depicted Figure 12.
configuration reachable given automata underlying Dining-Philosophers,
reachable given automata underlying Optical-Telegraph.
Figure 12, Nietzsche holds adjacent forks, Kant holds none tries
get access fork right. Nietzsche Kant, arbitrarily
many philosophers hold one fork each, trying access other.
736

fiWhere Ignoring Delete Lists Works

Kant

Nietzsche

Figure 12: unreachable situation Dining-Philosophers, unbounded local
minimum h+ would arise. Arrows indicate pickup-requests.

non-blocked philosopher Nietzsche, put forks again.
PDDL encoding this, world state Nietzsche activated transition
putting right (or left) fork, h+ value 2: relaxation, suffices
initiate write command, update queue contents. write command
initiated, however, h+ goes 3 transition become non-activated;
relaxed plan update queue contents, wrap transition, activate
(same) transition again. Reaching state h+ value 1 involves propagating
forks entire sequence philosophers Nietzsche Kant, either
right hand side, left hand side. example, say Nietzsche puts forks
picks right fork. philosopher left Nietzsche pick
requested fork (or Nietzsche pick gets us back started).
resulting state, situation before, except philosopher
Nietzsche-role sits one position left. iterating procedure
around left side table, Kant pick requested fork, request get
other, giving us goal state philosophers blocked. state h+ value 1
one Kant yet activated transition request fork.
configuration Figure 12 reachable Dining-Philosophers domain
used IPC-4, because, there, philosopher pick fork left hand
side first done Figure 12 philosophers Nietzsche Kant
Nietzsches left hand side. said, Optical-Telegraph philosophers
freedom choice, situation reachable. detail, described
Appendix B.22, Optical-Telegraph n pairs communicating processes.
pairs arranged cycle, pair control channel. Internally,
two processes within pair go fairly long, heavily interactive, sequence
operations, implementing possibility exchange data two stations.
737

fiHoffmann

operations begin, processes occupy (write into) one
control channel. is, one processes occupies channel, waits signal
process, indicating second control channel occupied well.
data exchange terminated, control channels get released (read)
arbitrary order. overall system blocked iff process pairs state
occupied one control channel, waiting occupy other. Thus,
process pairs correspond exactly philosophers choose fork pick (put
down) first, Figure 12 provides example arbitrarily high exit distance
local minimum state. Precisely, local minimum state one Nietzsche
process pair occupied channels, process blocked second
channel activated transition sending occupied-the-other-one signal:
state, h+ value 2 (all processes except active one blocked).
Pipesworld, consider situation several areas form circle unitary
connections. local minimum state s, single goal batch g go area a;
g currently segment adjacent a, contains batch b, areas empty.
shortest plan push b segment (not s) adjacent a, propagate
batches around circle g pushed a. shortest relaxed plan
is, however, push b push g side i.e., g used
push goal area. Reaching nearest state h+ value 1 requires n 1
steps n areas circle, path h+ value increases. Note
example uses neither tankage restrictions, interface restrictions, non-unitary
pipeline segments.
PSR, deep local minimum given n breakers feed individual goal line,
way breaker feed breakers goal line without breaker
closed, breakers connected faulty line. one
breakers closed. h+ value state 1 (close single open breaker) since
unsatisfied goal condition (beside supplying line fed open breaker)
one postulating breaker affected; condition negated derived predicate,
thus ignored relaxation. applicable action state wait.
that, breakers open, shortest relaxed plan close all, yielding
h+ value n. Obviously, nearest state h+ value 0 least n steps away.30
Rovers, local minima arise taking image deletes calibration
camera. example this. n waypoints w1 , . . . , wn connected line
(i.e., wi1 connected wi ), lander w1 , one rover camera c must used
take two images w1 , c calibrated (only) wn . rover w1 ,
c calibrated, relaxed plan take two images communicate two
data pieces. taking one image, one navigate way wn , calibrate
c, get back. Note example makes use road map arbitrarily large
diameter, diameter Rovers instance longest way rover must travel
order get one waypoint another. general, distance state better
h+ value bounded 3d + 2 diameter instance (see details
TR). road map diameter IPC-3 Rovers instances varies around 1 6.
30. remark counter-example remains valid IPC-4 SIMPLE-ADL STRIPS formulations
PSR, use different encoding derived predicates, using negation formulate
goal breaker affected.

738

fiWhere Ignoring Delete Lists Works

Airport, Assembly, Freecell, Miconic-ADL, Mprime, Mystery domains,
seen Appendix A.1 contain unrecognized dead ends, so, Proposition 1,
local minimum exit distance domains unbounded. Assembly,
TR describes detail, initial state instance path goal
h+ decreases monotonically, unless complex interactions ordering
constraints present instance. None IPC-1 instances features complex
interactions. Assuming FFs search algorithm sticks monotonically decreasing
paths, gives another indication system efficient example
suite.
A.3 Benches
Theorem 3 h+ , maximal bench exit distance state space solvable
instance Simple-Tsp 0, Ferry 1, Gripper 1, Logistics
1, Miconic-SIMPLE 1, Miconic-STRIPS 1, Movie 1,
Zenotravel 2, Satellite 4, Schedule 5, Tireworld
6, Dining-Philosophers 31.
before, subdivide proof sketch Theorem 3 groups domains
similar proofs. first consider transportation-type domains. them, Lemma 4,
similar proof arguments, applied.
Proof Sketch: [Theorem 3, Ferry, Gripper, Logistics, Miconic-SIMPLE, Miconic-STRIPS]
proofs Theorems 1 2 shown that, domains, actions
respected relaxation, and, domains except Miconic-SIMPLE,
actions either invertible, relevant delete effects. determine upper bound
exit distance benches, thus apply Lemma 4. requires us show
that, state s, optimal plan + 1th action relaxedplan relevant delete effects. Miconic-SIMPLE, seen actions,
adhering syntactic conditions invertibility (no) relevant delete effects,
similar semantics; proof technique applied there.
(transportation-type) domains consideration, argument is, roughly,
load-type unload-type actions relaxed-plan relevant delete effects,
move-type actions need applied row locations
immediately accessible other. implies upper bound 1 maximal
exit distance. Concretely, say reachable state Logistics instance, starts
optimal plan s, P + optimal relaxed plan starts a, applying
yields state s0 . loading (unloading) action, delete at(in-) fact transported object; object loaded respective location
(unloaded respective vehicle) optimal relaxed plan P + ,
relaxed-plan relevant delete effects, exit. Otherwise, drives flies vehicle
v l l0 , s0 exit optimal plan s0 starts loading (unloading)
package (from) v. Miconic-STRIPS Miconic-SIMPLE, arguments
apply. Ferry, arguments remain valid except that, optimal start action
state boards car, action deletes available free space
739

fiHoffmann

ferry. then, relaxed plan P + contains actions move ferry
location l, debark car l (otherwise would point boarding
car). Placing actions front P + , removing a, yields relaxed plan
state results applying s. similar argument applied prove
claim Gripper, gripper hands hold one ball time. (Note
argument Ferry Gripper uses somewhat weaker notion relaxed-plan relevant
delete effects, effects, undone actions contained
relaxed plan.)
2
Next come non-transportation domains Lemma 4 applied.
Proof Sketch: [Theorem 3, Movie, Simple-Tsp, Tireworld]
proofs Theorems 1 2 shown domains actions
respected relaxation, either least invertible, irrelevant delete effects.
apply Lemma 4 cases.
Movie, actions no, therefore relaxed-plan relevant, delete effects,
single exception rewinding movie (which deletes counter zero).
Obviously, optimal plan rewinds movie twice row. Thus, = 1 desired
upper bound.
Simple-Tsp, = 0 suffices. Say reachable state one location
l. optimal plan starts action visiting yet unvisited location l0 . optimal
relaxed plan start a, visit remaining unvisited location l00
move l0 l00 . latter actions require preconditions deleted a,
every action relaxed-plan relevant delete effects.
Tireworld, lowest constant upper bound = 6. non-final working steps
(like jacking hub flat wheel on) need undone later on, i.e.,
relaxed-plan relevant delete effects. final working steps (like jacking hub)
need undone, i.e., relaxed-plan relevant delete effects. longest
sequence non-final working steps optimal plan row following
6-step one: open boot (it must closed again), fetch wrench jack (they
must put away again), loose nuts hub thats got flat wheel (the nuts must
tightened again), jack respective hub (it must jacked again), undo
nuts (they must done again). resulting state, one remove flat
wheel, needs undone.
2
remaining domains Theorem 3 claims constant upper bound
maximal bench exit distance, seen Appendix A.2 upper bounds
distance reachable state state s0 h+ (s0 ) < h+ (s). upper
bounds trivially imply upper bounds maximal bench exit distance.
Proof Sketch: [Theorem 3, Dining-Philosophers, Satellite, Schedule, Zenotravel]
Follows directly proof Theorem 2.

2

domains, except last four, one easily construct examples
bench exit distance equal proved upper bound. Satellite, Schedule,
740

fiWhere Ignoring Delete Lists Works

Zenotravel, open question whether tighter bounds bench exit
distance local minimum exit distance; seem particularly relevant,
though. (For Dining-Philosophers, said may even bound
local minimum exit distance tight.)
Blocksworld-no-arm, Briefcaseworld, Fridge, Grid, Hanoi domains, Theorem 2 proves local minima. important know whether
arbitrarily difficult escape benches. answer yes cases. Blocksworldno-arm, example one already used Blocksworld-arm Depots
(to show bounds local minimum exit distances). n blocks
b1 , . . . , bn initially form stack bi bi+1 bn table, goal
build stack top another block bn+1 , i.e., goal stack b1 , . . . , bn , bn+1 .
shortest relaxed plan initial state n steps long (remove stack top
bn , move bn onto bn+1 ). nearest state h+ value n 1 one bn
already stacked onto bn+1 . state n steps away initial state.
Briefcaseworld, bench exit distance becomes large many objects must
taken briefcase relaxation, point taking objects out, since
moving briefcase delete at-facts. Consider state n objects
o1 , . . . , inside briefcase location l, goal o1 , . . . , l
briefcase another location l0 . h+ (s) = 1: moving briefcase l0 suffices
relaxation. nearest goal state, h+ = 0, n + 1 steps away: one must take
objects moving l0 .
Fridge, single fridge compressor held n screws, exit distance
initial state n + 1. reach better state, one must: stop fridge (which must
turned back relaxed plan); unfasten n screws (which must fastened
relaxed plan); remove broken compressor (which needs undone
deletes fact broken compressor attached fridge).31
Grid, consider instances robot located n1 grid (a line) without
locked locations, robot starts leftmost location, shall transport key
rightmost location left end. initial value h+ n + 2 (walk
key, pick up, put at-facts deleted), value get
better robot actually picked key.
Hanoi, seen h+ always equal number discs yet
goal position. Thus maximal bench exit distance grows exponentially
number discs. initial state instance n discs, takes 2n1 steps
move first (i.e., largest) disc goal position.
9 domains local minimum exit distance arbitrarily large,
relevant whether bench exit distance bounded not. Escaping bench
might planner better ending huge local minimum. remark that,
example, Driverlog, Rovers, Mprime, Mystery, one easily construct examples
large bench exit distances, defining road maps large diameters i.e., using
basically example used Grid domain.
31. fact, one easily prove n + 1 upper bound bench exit distance, Fridge
instances compressors held n screws (details TR).

741

fiHoffmann

Appendix B. Domain Descriptions
following list brief descriptions 30 investigated domains. explain
overall idea behind domain, available operators, initial states
goals are. cases set instances obvious; restrictions, any, explained.
remark that, points, domain semantics seem bit odd (for example,
Zenotravel, difference flying zooming plane zooming consumes
fuel). odd points are, presumably, domain bugs overlooked
respective domain designers. corrected bugs as, all, investigation
meant determine properties benchmarks used community.
domains listed alphabetical order.
B.1 Airport
Airport domain, planner safely navigate ingoing outgoing traffic,
given point time, across airport. main problem constraint planes
must endanger other, come close others running
engines. constraint modeled letting plane block segments
engines currently endanger. Planes enter blocked areas. five operators.
plane moved one airport segment another, plane facing right
direction, planes get endangered action. Similarly, plane pushed
back cause trouble. One start engines plane, let plane
take off, let plane settle parking position. initial state specifies current
positions orientations planes, goal specifies planes outbound (have
take off), inbound parking positions.
B.2 Assembly
Assembly domain, complex object must constructed assembling parts
together, obeying certain ordering constraints. parts might need
assembled way beforehand. parts transient, means
must integrated temporarily. collection machines, resources,
might needed working steps. four operators. available resource
committed object, deleting resources availability. Releasing resource
object inverse action. available object x assembled object y,
x either part transient part y, resources requires committed
y, objects assemble order x already incorporated
y. effect, x incorporated longer available, becomes available
parts except x already incorporated, transient part incorporated.
incorporated object x removed y, resources requires committed
y, and, given x transient part (a part y), objects remove order
(an assemble order) x incorporated (not incorporated). effect, x available
longer incorporated, becomes available parts incorporated,
transient parts except x incorporated. instances, part-of relation
forms tree goal make root object tree available. Also,
742

fiWhere Ignoring Delete Lists Works

assemble remove order constraints consistent (cycle-free). restrictions hold
true AIPS-1998 competition examples.
B.3 Briefcaseworld
Briefcaseworld, number portables must transported, transportation
done via conditional effects move actions. three operators. Putting
portable location done portable briefcase respective
location, portable yet inside. Taking portable done inside.
move applied two locations, achieves, beside is-at-fact
briefcase, respective at-facts portables inside (i.e., portables inside
moved along conditional effects). goal briefcase, subset
portables, goal locations.
B.4 Blocksworld-no-arm
Blocksworld-no-arm variant widely known Blocksworld domain. three
operators. One move block table onto another block. One move block
another block table. One move block another block onto third
block. initial state instance specifies initial positions blocks, goal
state specifies (consistent, i.e., cycle-free) set facts.
B.5 Blocksworld-arm
instances Blocksworld-arm Blocksworld-no-arm. difference blocks moved via single robot arm hold one block time.
four operators. One pickup block table. One put block,
arm holding, onto table. One unstack block
block. Finally, one stack block, arm holding, onto block.
B.6 Depots
Depots domain kind mixture Logistics Blocksworld-arm.
set locations, set trucks, set pallets, set hoists, set crates.
trucks transport crates locations, hoists used stack crates onto
crates, onto pallets. six operators, move truck (different)
locations, load crate held hoist onto truck location, unload
crate hoist truck location, lift crate hoist surface (a
pallet crate) location, drop crate held hoist onto surface
location. hoist hold one crate time. crates initially arranged
arbitrary stacks, bottom crate stack standing pallet. goal
arrange crates arbitrary stacks (possibly) pallets,
involve transporting crates locations (as pallets moved).
743

fiHoffmann

B.7 Dining-Philosophers
Dining-Philosophers encoding well-known Dining-Philosophers problem,
task planner find deadlock situation arises every philosopher
taken single fork. PDDL domain created automatic translation
automata-based Promela language. automata referred processes.
Promela, philosopher finite automaton/process works follows.
start state, state 0, transition puts right fork onto table (this initialization
step), getting state 1. loop four states. state 1 state
2, philosopher takes right fork. 2 3, takes left fork, 3 4
puts right fork, state 4 puts left fork gets back state
1. process communicates neighbors communication
channel, queue, either contains fork, empty (if one adjacent philosophers
currently holding fork).
PDDL encoding, process state transition broken four actions.
first action activates chosen transition. second action initiates write read
command needed queue, deleting activation transition setting flags
queue update. third action updates, possible, queue contents. update
possible write command shall done full queue (a queue already contains
fork), read command shall done empty queue. fourth action wraps
process state transition up, re-setting flags.
Derived predicates used model conditions process blocked.
rules require outgoing transitions current state process blocked.
transition blocked activated, would need perform impossible queue
write/read operation sense impossible write/read operation yet
initiated.32 applying planning action initiating impossible write/read
command, blocking rules dont apply anymore resulting state dead end
planning tasks state space (but blocking situation process network,
according derived predicate rules modeling blocking).
remark that, IPC-4, version Dining-Philosophers modeled
process blocking via additional planning operators, derived predicates. chose
consider other, above, domain version since constitutes natural concise
formulation, since planners IPC-4 scaled version without
derived predicates.
B.8 Driverlog
Driverlog variation Logistics, drivers needed trucks,
drivers trucks move along arbitrary (bi-directional) road maps. road maps
drivers trucks different. operators load/unload object onto/from
truck location, board/disembark driver onto/from truck location, walk
32. one outgoing transition activated time, process never become blocked
state one outgoing state transition. appears bug translation
Promela PDDL intuitive requirement would activated transition needs
blocked, outgoing transition need activated order blocked. Note
that, Dining-Philosophers, every automaton state one outgoing transition.

744

fiWhere Ignoring Delete Lists Works

driver location another one, drive truck driver location
another one. preconditions effects loading/unloading objects obvious
ones. driver board truck truck empty; effect, truck longer
empty (as well driven driver). Disembarking driver inverse action.
order walk driver l l0 , must path l l0 . order drive
truck l l0 , link l l0 (and must driver
truck). Paths links form arbitrary (in particular, potentially different) graphs
locations, restriction undirected, i.e., truck driver
move l l0 move back. restriction imposed Driverlog
instances generated IPC-3 generator.
B.9 Ferry
Ferry, single ferry used transport cars locations, one time.
three operators. One sail ferry two locations. One board car onto
ferry location, deletes empty-ferry fact (plus adding car
ferry deleting car location). One debark car ferry
location, achieves empty-ferry (plus adding car location
deleting car ferry). goal subset cars goal
locations.
B.10 Freecell
Freecell domain STRIPS formulation widely known solitaire card game
comes Microsoft Windows. number cards different suits initially
arranged random stacks number columns. cards must put home.
suit cards, separate home column, cards suit must
stacked increasing order card value. number free cells. cards
moved around according certain rules. card clear card top
it. clear card put free cell (if already there), free cell holds
one card time. clear card moved onto empty column. clear card
c put home last card put home suit one preceding c. c
c0 clear cards differently colored suits, one stack c top c0 c0
free cell, cs card value one less card value c0 (so stacks
built columns, decreasing order card value, alternating colors). goal
reached topmost cards suits put home.
B.11 Fridge
Fridge, one must replace broken compressor fridge. this, one must remove
compressor; involves unfastening screws hold compressor,
turn involves first switching fridge off. goal new compressor attached
fridge, screws fastened, fridge switched back on. origin domain
STRIPS formulation. consider adaptation allows arbitrary number
fridges screws, compressor fastened (arbitrary, least one)
number screws. adaptation involves ADL precondition: compressor
745

fiHoffmann

removed screws unfastened. six operators. One stop/start fridge.
One unfasten/fasten screw from/to compressor attached fridge; so,
fridge needs turned off, compressor needs attached, screw must fit
compressor. Finally, one remove/attach compressor from/to fridge. Removing
compressor requires fridge turned off, none screws fit
compressor fastened. effect, compressor longer attached fridge,
fridge compressor free. Attaching compressor requires fridge
turned off, compressor fits fridge. effect, compressor attached,
compressor fridge longer free.
B.12 Grid
Grid, robot must move along positions arranged grid-like reachability
relation. positions locked, keys different shapes open them.
goal keys goal positions. five operators. One
move position p position p0 , requires (apart obvious preconditions)
p p0 connected, p0 open (not locked). One pick key
position, requires arm empty (one hold one key time),
effects one holds key, arm longer empty, key
longer position. Putting key position inverse action. One
abbreviate two previous actions pickup-and-lose keys k k0
position; this, one must hold k, directly exchanged k0 , i.e., effects
one holds k k0 position. Finally, one unlock position p0 one
position p connected p0 , holds key shape locked
position p0 ; add effect p0 open, delete effect position longer
locked. instances specify initial locations keys, locked positions,
robot, well shapes keys locked positions. goal specifies
positions subset keys. robot always starts open position.
make significant difference: robot allowed start locked position,
local minima h+ .33 Otherwise none, c.f. Theorem 2. Intuitively, makes
sense let robot located open positions only; restriction holds true
published benchmark examples.
B.13 Gripper
Gripper, task transport number balls one location another.
three operators. One move locations. One pick ball location
hand; apart obvious preconditions requires hand empty;
effects obvious ones (the ball hand longer room) plus
hand longer empty. One drop ball location hand, inverts
effects picking action. always exactly two locations, two gripper
hands. Instances thus differ terms number balls. severe restrictions
hold true AIPS-1998 instances. remark adding locations and/or hands
33. Moving away locked initial position lead need applying several steps re-open
position. relaxed plan initial state realize this, since ignores delete
initial at-fact.

746

fiWhere Ignoring Delete Lists Works

affect topological properties h+ , fact proof arguments given
Theorems 1, 2, 3 remain valid case.
B.14 Hanoi
Hanoi domain STRIPS encoding classical Towers Hanoi problem.
n discs d1 , . . . , dn , three pegs p1 , p2 , p3 . single operator moves
object x object onto object z (the operator parameters grounded
discs well pegs). preconditions move x y, x clear, z
clear, x smaller z. effects x z clear, x
longer z longer clear. semantics Towers Hanoi encoded via
smaller relation. relation holds obvious way discs, discs
smaller pegs (the pegs smaller anything moved).
instances differ terms number n discs must transferred p1
p3 .
B.15 Logistics
Logistics classical transportation domain, objects must transported within
cities using trucks, different cities using airplanes. six operators,
drive truck two locations within city, fly airplane two airports,
load (unload) object onto (from) truck location, load (unload) object
onto (from) airplane airport. operators obvious preconditions
effects (the complicated operator moving truck, whose precondition
requires locations within city). always least one city,
city non-zero number locations one airport. arbitrary
number objects, airplanes (which located airports). goal
subset objects goal locations.
B.16 Miconic-ADL
Miconic-ADL ADL formulation complex elevator control problem occurring
real-world application planning (Koehler & Schuster, 2000). number passengers
waiting number floors transported lift, obeying variety constraints.
always least one floor, arbitrary number passengers,
given origin destination floor. three operators. lift move
floor f floor f f (transitively) f, vice versa moving downwards.
lift stop floor. floor f, conditional effects
stopping action passengers waiting f boarded, passengers wanting get
f depart. goal serve passengers, i.e., bring destination
floor. constraints must obeyed following.
cases, passenger p access floor f; lift stop f
p boarded.
passengers VIPs; long served, lift stop
floors VIP getting off.
747

fiHoffmann

passengers must transported non-stop, i.e., boarded, lift
make intermediate stops stopping destination floor.
passengers travel alone, others attend them; one former
kind boarded, must least one latter kind.
groups B passengers allowed people
groups boarded simultaneously.
passengers transported direction travel, i.e.,
need go (down), then, boarded, lift move
downwards (upwards).
constraints formulated means complex first order preconditions
operators.
B.17 Miconic-SIMPLE
Miconic-SIMPLE domain Miconic-ADL described above, except
constraints all.
B.18 Miconic-STRIPS
Miconic-STRIPS domain almost Miconic-SIMPLE domain, see above.
difference boarding departing passengers done conditional
effects stopping operator, explicitly separate STRIPS operators. One board
passenger floor. precondition (current) floor passengers origin,
effect passenger boarded. One let passenger depart
floor. preconditions (current) floor passengers destination
passenger boarded, effects passenger served longer
boarded.
B.19 Movie
Movie, task prepare watching movie. seven different operators.
One rewind tape, adds tape rewound, deletes counter
zero. One reset counter, effect counter zero. One
get five different kinds snacks, (add) effect one respective
snack. Instances differ terms number items sort
snacks. goal always one snack sort, tape rewound,
counter zero.
B.20 Mprime
Mprime transportation kind domain, objects must transported
locations means vehicles, vehicles use non-replenishable fuel. instance,
set L locations, set objects, set V vehicles.
sets F fuel numbers space numbers. location initially certain fuel
748

fiWhere Ignoring Delete Lists Works

number number fuel items available location vehicle certain
space number number objects vehicle carry time. operators
move vehicles locations, load (unload) objects onto (from) vehicles,
transfer fuel units locations. move location l location l0
made l l0 connected (where connection relation arbitrary graph),
least one fuel unit available l (l fuel number lower neighbor).
effect move, respective vehicle located l0 , amount fuel l
decreased one unit, i.e., l assigned next lower fuel number. similar fashion,
object loaded onto vehicle space that, effect available
space decreases. Unloading object frees space again. transfer operator
transfer one fuel unit location l location l0 , l l0 connected, l
least two fuel units left. result applying operator, ls fuel number decreases
one, l0 fuel number increases one. Note way re-gain fuel items
(one transfer around one obtain new ones). goal transport
subset objects goal locations.
B.21 Mystery
Mystery exactly Mprime domain described above, except
operator transfer fuel items.
B.22 Optical-Telegraph
Dining-Philosophers domain described Appendix B.7, Optical-Telegraph
PDDL compilation problem originally formulated automata-based Promela
language. mechanics PDDL compilation Dining-Philosophers,
using derived predicates detect blocked situations. problem involves n pairs communicating processes, pair featuring process. pair go
fairly long, heavily interactive, sequence operations, implementing possibility exchange data two stations. data exchanged, various initializing
steps must taken, ensure processes working synchronously. importantly,
process writes token control channel (queue) beginning
sequence, reads token end. causes deadlock situation
n control channels, accessed two processes.
precisely, process pairs arranged cycle, pair control channel. overall system blocked iff process pairs state
occupied (written into) one control channel, waiting occupy other.
sense, Optical-Telegraph viewed version Dining-Philosophers
internal states philosophers complicated. particular, philosophers
(process pairs) choose order pick forks (occupy control
channels). turns out, see Appendix A.2, latter important impact
topology h+ .
remark that, IPC-4, version Optical-Telegraph modeled
process blocking via additional planning operators, derived predicates. chose
consider other, above, domain version since constitutes natural concise
749

fiHoffmann

formulation, since planners IPC-4 scaled version without
derived predicates.
B.23 Pipesworld
Pipesworld, units oil derivatives, called batches, must propagated
pipeline network. network consists areas connected pipe segments different
length. pipes completely filled batches times, one pushes batch
one end pipe, last batch currently pipe comes end.
interface restrictions concerning types oil derivatives allowed
adjacent inside pipe, tankage restrictions concerning
number batches (of derivative type) stored point time
individual areas.
available planning operator push batch pipe. IPC4 encoding domain, look here, non-unitary pipe segments (pipes
containing one batch) operator split two parts, start finish
action (in order reduce number operator parameters needed correctly update
pipe contents). Also, pipe segments encoded directed fashion, making necessary
distinguish (symmetrical) push pop actions. initial state specifies
current batch positions etc., goal specifies batches brought
areas.
B.24 PSR
PSR domain, used IPC-4, task re-supply given set lines faulty
electricity network. nodes network breakers, feed electricity
network, devices, switches used change network
configuration. edges network lines, connecting two three nodes.
breakers devices open closed. open, disconnect
lines adjacent them. breakers closed, feed electricity adjacent
lines. lines faulty. goal ensure none breakers
affected, i.e., feeds electricity faulty line, transitive connections
network. Also, goal requires given set lines (transitively) fed
electricity breaker.
transitive network semantics, determining breaker feeds electricity
line, breaker affected, modeled means various derived predicates (with
recursive rule antecedents enable computation transitive closure). three
planning operators. One open device breaker currently closed, one
inverse closing action. actions require precondition breaker
currently affected. latter untrue, i.e., breaker currently affected,
available action wait. effect open breakers affected.
remark that, IPC-4, different version PSR, formulated
pure STRIPS without derived predicates. version constitutes, however, relatively
superficial pre-compiled form domain (Hoffmann & Edelkamp, 2005; Edelkamp et al.,
2005). included IPC-4 order provide pure STRIPS planners
750

fiWhere Ignoring Delete Lists Works

domain formulation could tackle (the pre-compilation necessary order enable
formulation pure STRIPS).
B.25 Rovers
Rovers, number rovers must navigate road map waypoints, take rock
soil samples well images, communicate data number landers.
nine available operators following. One navigate rover one waypoint
another this, waypoints must connected rover. One sample
soil/rock rover waypoint using store so, rover must
(empty) store equipped soil/rock analysis, must soil/rock sample
waypoint; effect one soil/rock analysis, store full, soil/rock
sample longer waypoint. One empty full store dropping store. One
calibrate camera waypoint using objective, one take image
objective mode camera waypoint. operators, object must
visible waypoint, camera must board rover equipped
imaging. calibrate camera, object must calibration target it;
effect operator calibration camera. take image, camera must
calibrated, support required mode. effects one image data,
camera longer calibrated. Finally, three operators
rover communicate soil/rock/image data lander. so, landers waypoint
must visible rover; effect data communicated.
instances restricted visibility connectivity waypoints
bi-directional waypoint w visible waypoint w0 holds true vice
versa; rover move w w0 move back. Another restriction
camera initially calibrated (this serves make sure that, reachable state,
calibrated camera least one calibration target). restrictions imposed
Rovers instances generated IPC-3 generator.
B.26 Satellite
Satellite, satellites need take images different directions, certain modes, using
appropriate instruments. number satellites, number directions, number
instruments, number modes. following five operators. One
turn satellite direction another one; preconditions effects obvious
ones, action applied pair directions (no connectivity constraints).
One switch instrument board satellite, satellite power available;
effect, instrument power longer calibrated, satellite
power available. One switch instrument board satellite, instrument
power; effect, satellite power available, instrument anymore.
One calibrate instrument board satellite direction, satellite points
direction, instrument power, direction calibration target
instrument. effect calibration camera. Finally, one take
image instrument board satellite direction mode. so,
satellite must point direction, camera must support mode, power,
calibrated; effect one image direction mode.
751

fiHoffmann

goal images number direction/mode pairs; also, satellites
goal requirement point specified direction. initial states
satellite (but instrument) power available, instrument calibrated.
former restriction makes sure satellite power run one instrument
time; latter restriction makes sure that, reachable state, calibrated instrument
least one calibration target. restrictions imposed Satellite instances
generated IPC-3 generator.

B.27 Schedule
Schedule, collection objects must processed number machines, applying
working steps change objects shape, surface condition, color; one drill
holes varying widths varying orientations. nine operators. Eight
describe working steps object machine. Amongst things, operators
preconditions require scheduled elsewhere machine busy,
operators effect scheduled, machine busy. ninth
operator time step, whose effect object scheduled, machine
busy, longer. One apply do-roll action object o, makes cylindrical
hot (no longer cold, see below), deleting surface conditions, colors,
holes might have. One apply do-lathe o, making cylindrical rough
surface, deleting colors might painted before. One apply
do-polish cold, giving polished surface. One apply do-grind o,
giving smooth surface colors. One apply do-punch o, width w
orientation o, cold, resulting hole w o, rough surface. One
apply do-drill-press o, cold, making hole width w orientation
(changing none os properties except making hole). cold, one
apply do-spray-paint color c, deleting surface conditions might have.
Finally, one apply do-immersion-paint o, changing none os properties except
color. Note operator change os temperature, except do-roll
makes hot; that, made cold (this reason dead
ends arise, c.f. Theorem 1). Initially, objects cold, shape
surface condition specified. objects painted initially, object
none several holes. goal condition, objects required
cylindrical shape (the shape produced machines),
need surface condition, must painted, object required
arbitrary number holes.

B.28 Simple-Tsp
Simple-Tsp trivial version TSP problem. single operator move
locations. applied two (different) locations, effect
(besides obvious ones) destination location visited. instances specify
number locations must visited, starting one them.
752

fiWhere Ignoring Delete Lists Works

B.29 Tireworld
Tireworld, one must replace number flat tires. involves collection objects
must used appropriate working steps. Briefly summarized, situation
follows. thirteen operators. boot either opened closed;
initially closed shall end. pump, wrench, jack
fetched put away (from/into boot); initially boot
shall put back end. spare wheels initially inflated, inflated
using pump (the add effect wheel inflated, delete effect
longer not-inflated). hub fastened nuts; loosened tightened,
using wrench, respective hub ground. jack used either
jack jack hub. hub jacked up, one undo (loose) nuts,
up; nuts undone, one remove respective wheel, put one.
optimal solution plan this: open boot; fetch tools; inflate spare wheels; loosen
nuts; turn jack hub, undo nuts, remove flat wheel, put spare
wheel, nuts, jack hub again; tighten nuts; put away tools;
close boot.
B.30 Zenotravel
Zenotravel transportation domain variant vehicles (called aircrafts) use fuel
units replenished using refueling operator. number cities,
number aircrafts, number persons, number different possible fuel levels.
fuel levels encode natural numbers next predicate next(f,f0 ) true iff f0
next higher fuel level f. task transport subset persons
initial locations goal locations. following five operators. One
board/debark person onto/from aircraft city; obvious preconditions effects. One fly aircraft city different city, decreasing
aircrafts fuel level f f0 ; f must aircrafts current fuel level, f0 must
next lower level. One zoom aircraft; exactly flying it, except
zooming uses fuel aircrafts fuel level decreased two units. Finally,
one refuel aircraft city fuel level f fuel level f0 . conditions
f aircrafts current fuel level, f0 next higher level. Thus aircrafts
refueled city, steps one unit.

References
Bacchus, F. (2001). AIPS00 planning competition. AI Magazine, 22 (3), 4756.
Biundo, S., & Fox, M. (Eds.). (1999). Recent Advances AI Planning. 5th European
Conference Planning (ECP99), Lecture Notes Artificial Intelligence, Durham,
UK. Springer-Verlag.
Blum, A. L., & Furst, M. L. (1995). Fast planning planning graph analysis.
Mellish, S. (Ed.), Proceedings 14th International Joint Conference Artificial
Intelligence (IJCAI-95), pp. 16361642, Montreal, Canada. Morgan Kaufmann.
753

fiHoffmann

Blum, A. L., & Furst, M. L. (1997). Fast planning planning graph analysis. Artificial
Intelligence, 90 (1-2), 279298.
Bonet, B., & Geffner, H. (1999). Planning heuristic search: New results.. Biundo, &
Fox (Biundo & Fox, 1999), pp. 6072.
Bonet, B., & Geffner, H. (2001a). Heuristic search planner 2.0. AI Magazine, 22 (3),
7780.
Bonet, B., & Geffner, H. (2001b). Planning heuristic search. Artificial Intelligence,
129 (12), 533.
Bonet, B., Loerincs, G., & Geffner, H. (1997). robust fast action selection mechanism
planning. Kuipers, B. J., & Webber, B. (Eds.), Proceedings 14th National
Conference American Association Artificial Intelligence (AAAI-97), pp.
714719, Portland, OR. MIT Press.
Botea, A., Muller, M., & Schaeffer, J. (2004). Using component abstraction automatic
generation macro-actions.. Koenig et al. (Koenig, Zilberstein, & Koehler, 2004),
pp. 181190.
Botea, A., Muller, M., & Schaeffer, J. (2005). Learning partial-order macros solutions.
Biundo, S., Myers, K., & Rajan, K. (Eds.), Proceedings 15th International
Conference Automated Planning Scheduling (ICAPS-05), pp. 231240, Monterey, CA, USA. Morgan Kaufmann.
Brazdil, P., & Jorge, A. (Eds.)., EPIA-01 (2001). Proceedings 10th Portuguese Conference Artificial Intelligence (EPIA-01), Porto, Portugal. Springer-Verlag.
Bylander, T. (1994). computational complexity propositional STRIPS planning.
Artificial Intelligence, 69 (12), 165204.
Cesta, A., & Borrajo, D. (Eds.). (2001). Recent Advances AI Planning. 6th European
Conference Planning (ECP01), Lecture Notes Artificial Intelligence, Toledo,
Spain. Springer-Verlag.
Chen, Y., Hsu, C., & Wah, B. (2004). SGPlan: Subgoal partitioning resolution
planning.. Edelkamp et al. (Edelkamp, Hoffmann, Littman, & Younes, 2004).
Chen, Y., & Wah, B. (2003). Automated planning scheduling using calculus variations
discrete space.. Giunchiglia et al. (Giunchiglia, Muscettola, & Nau, 2003), pp.
211.
Chien, S., Kambhampati, R., & Knoblock, C. (Eds.)., AIPS-00 (2000). Proceedings
5th International Conference Artificial Intelligence Planning Systems (AIPS-00),
Breckenridge, CO. AAAI Press, Menlo Park.
Do, M. B., & Kambhampati, S. (2001). Sapa: domain-independent heuristic metric
temporal planner.. Cesta, & Borrajo (Cesta & Borrajo, 2001), pp. 109120.
Edelkamp, S. (2003a). Promela planning. Ball, T., & Rajamani, S. (Eds.), Proceedings
10th International SPIN Workshop Model Checking Software (SPIN-03),
pp. 197212, Portland, OR. Springer-Verlag.
Edelkamp, S. (2003b). Taming numbers durations model checking integrated
planning system. Journal Artificial Intelligence Research, 20, 195238.
754

fiWhere Ignoring Delete Lists Works

Edelkamp, S., & Helmert, M. (2001). MIPS: model checking integrated planning system.
AI Magazine, 22 (3), 6771.
Edelkamp, S., Hoffmann, J., Englert, R., Liporace, F., Thiebaux, S., & Trug, S. (2005).
Engineering benchmarks planning: domains used deterministic part
IPC-4. Journal Artificial Intelligence Research. Submitted.
Edelkamp, S., Hoffmann, J., Littman, M., & Younes, H. (Eds.)., IPC-04 (2004). Proceedings
4th International Planning Competition, Whistler, BC, Canada. JPL.
Fox, M., & Long, D. (1998). automatic inference state invariants TIM. Journal
Artificial Intelligence Research, 9, 367421.
Fox, M., & Long, D. (2001). STAN4: hybrid planning strategy based subproblem
abstraction. AI Magazine, 22 (3), 8184.
Frank, J., Cheeseman, P., & Stutz, J. (1997). gravity fails: Local search topology.
Journal Artificial Intelligence Research, 7, 249281.
Gazen, B. C., & Knoblock, C. (1997). Combining expressiveness UCPOP
efficiency Graphplan.. Steel, & Alami (Steel & Alami, 1997), pp. 221233.
Gerevini, A., & Schubert, L. (2000). Inferring state constraints DISCOPLAN: new
results.. Kautz, & Porter (Kautz & Porter, 2000), pp. 761767.
Gerevini, A., & Schubert, L. (2001). DISCOPLAN: efficient on-line system computing
planning domain invariants.. Cesta, & Borrajo (Cesta & Borrajo, 2001), pp. 433
436.
Gerevini, A., Saetti, A., & Serina, I. (2003). Planning stochastic local search
temporal action graphs. Journal Artificial Intelligence Research, 20, 239290.
Gerevini, A., & Serina, I. (2002). LPG: planner based local search planning graphs
action costs.. Ghallab et al. (Ghallab, Hertzberg, & Traverso, 2002), pp.
1322.
Gerevini, A., Serina, I., Saetti, A., & Spinoni, S. (2003). Local search techniques temporal
planning LPG.. Giunchiglia et al. (Giunchiglia et al., 2003). Accepted
publication.
Ghallab, M., Hertzberg, J., & Traverso, P. (Eds.)., AIPS-02 (2002). Proceedings 6th
International Conference Artificial Intelligence Planning Scheduling (AIPS02), Toulouse, France. Morgan Kaufmann.
Giunchiglia, E., Muscettola, N., & Nau, D. (Eds.)., ICAPS-03 (2003). Proceedings
13th International Conference Automated Planning Scheduling (ICAPS-03),
Trento, Italy. Morgan Kaufmann.
Haslum, P., & Geffner, H. (2000). Admissible heuristics optimal planning.. Chien
et al. (Chien, Kambhampati, & Knoblock, 2000), pp. 140149.
Helmert, M. (2003). Complexity results standard benchmark domains planning.
Artificial Intelligence, 143, 219262.
Helmert, M. (2004). planning heuristic based causal graph analysis.. Koenig et al.
(Koenig et al., 2004), pp. 161170.
755

fiHoffmann

Helmert, M., & Richter, S. (2004). Fast downward making use causal dependencies
problem representation.. Edelkamp et al. (Edelkamp et al., 2004).
Hoffmann, J. (2000). heuristic domain independent planning use enforced
hill-climbing algorithm. Ras, Z. W., & Ohsuga, S. (Eds.), Proceedings 12th
International Symposium Methodologies Intelligent Systems (ISMIS-00), pp.
216227, Charlotte, NC. Springer-Verlag.
Hoffmann, J. (2001a). FF: fast-forward planning system. AI Magazine, 22 (3),
5762.
Hoffmann, J. (2001b). Local search topology planning benchmarks: empirical analysis.. Nebel (Nebel, 2001), pp. 453458.
Hoffmann, J. (2002). Extending numerical state variables. Harmelen, F. V. (Ed.),
Proceedings 15th European Conference Artificial Intelligence (ECAI-02), pp.
571575, Lyon, France. Wiley.
Hoffmann, J. (2003a). Metric-FF planning system: Translating ignoring delete lists
numeric state variables. Journal Artificial Intelligence Research, 20, 291341.
Hoffmann, J. (2003b). Utilizing Problem Structure Planning: Local Search Approach,
Vol. 2854 Lecture Notes Artificial Intelligence. Springer-Verlag.
Hoffmann, J. (2003c).
ignoring delete lists works: Local search topology planning benchmarks.
Tech. rep. 185, Albert-Ludwigs-Universitat,
Institut fur Informatik, Freiburg, Germany.
Available http://www.mpiinf.mpg.de/hoffmann/papers/jair05report.ps.gz.
Hoffmann, J., & Edelkamp, S. (2005). deterministic part IPC-4: overview. Journal
Artificial Intelligence Research. appear.
Hoffmann, J., & Nebel, B. (2001a). planning system: Fast plan generation
heuristic search. Journal Artificial Intelligence Research, 14, 253302.
Hoffmann, J., & Nebel, B. (2001b). RIFO revisited: Detecting relaxed irrelevance.. Cesta,
& Borrajo (Cesta & Borrajo, 2001), pp. 325336.
Kautz, H. A., & Porter, B. (Eds.)., AAAI-00 (2000). Proceedings 17th National
Conference American Association Artificial Intelligence (AAAI-00), Austin,
TX. MIT Press.
Koehler, J., & Hoffmann, J. (2000). reasonable forced goal orderings use
agenda-driven planning algorithm. Journal Artificial Intelligence Research,
12, 338386.
Koehler, J., & Schuster, K. (2000). Elevator control planning problem.. Chien et al.
(Chien et al., 2000), pp. 331338.
Koenig, S., Zilberstein, S., & Koehler, J. (Eds.)., ICAPS-04 (2004). Proceedings
14th International Conference Automated Planning Scheduling (ICAPS-04),
Whistler, Canada. Morgan Kaufmann.
Long, D., & Fox, M. (2000). Automatic synthesis use generic types planning..
Chien et al. (Chien et al., 2000), pp. 196205.
756

fiWhere Ignoring Delete Lists Works

Long, D., & Fox, M. (2003). 3rd international planning competition: Results
analysis. Journal Artificial Intelligence Research, 20, 159.
McDermott, D. (1996). heuristic estimator means-ends analysis planning. Drabble, B. (Ed.), Proceedings 3rd International Conference Artificial Intelligence
Planning Systems (AIPS-96), pp. 142149. AAAI Press, Menlo Park.
McDermott, D. (2000). 1998 AI planning systems competition. AI Magazine,
21 (2), 3555.
McDermott, D. V. (1999). Using regression-match graphs control search planning.
Artificial Intelligence, 109 (1-2), 111159.
Nebel, B. (Ed.)., IJCAI-01 (2001). Proceedings 17th International Joint Conference
Artificial Intelligence (IJCAI-01), Seattle, Washington, USA. Morgan Kaufmann.
Nebel, B., Dimopoulos, Y., & Koehler, J. (1997). Ignoring irrelevant facts operators
plan generation.. Steel, & Alami (Steel & Alami, 1997), pp. 338350.
Nguyen, X., & Kambhampati, S. (2000). Extracting effective admissible heuristics
planning graph.. Kautz, & Porter (Kautz & Porter, 2000), pp. 798805.
Nguyen, X., & Kambhampati, S. (2001). Reviving partial order planning.. Nebel (Nebel,
2001), pp. 459464.
Onaindia, E., Sapena, O., Sebastia, L., & Marzal, E. (2001). Simplanner: executionmonitoring system replanning dynamic worlds.. Brazdil, & Jorge (Brazdil &
Jorge, 2001), pp. 393400.
Penberthy, J. S., & Weld, D. S. (1992). UCPOP: sound, complete, partial order planner
ADL. Nebel, B., Swartout, W., & Rich, C. (Eds.), Principles Knowledge
Representation Reasoning: Proceedings 3rd International Conference (KR92), pp. 103114, Cambridge, MA. Morgan Kaufmann.
Refanidis, I., & Vlahavas, I. (1999). GRT: domain independent heuristic STRIPS
worlds based greedy regression tables.. Biundo, & Fox (Biundo & Fox, 1999),
pp. 4759.
Refanidis, I., & Vlahavas, I. (2001). GRT planning system: Backward heuristic construction forward state-space planning. Journal Artificial Intelligence Research,
15, 115161.
Rintanen, J. (2000). iterative algorithm synthesizing invariants.. Kautz, & Porter
(Kautz & Porter, 2000), pp. 806811.
Sebastia, L., Onaindia, E., & Marzal, E. (2001). Stella: optimal sequential parallel
planner.. Brazdil, & Jorge (Brazdil & Jorge, 2001), pp. 409416.
Srivastava, B., Nguyen, X., Kambhampati, S., Do, M. B., Nambiar, U., Nie, Z., Nigenda, R.,
& Zimmermann, T. (2001). Altalt: Combining graphplan heuristic state search.
AI Magazine, 22 (3), 8890.
Steel, S., & Alami, R. (Eds.). (1997). Recent Advances AI Planning. 4th European Conference Planning (ECP97), Vol. 1348 Lecture Notes Artificial Intelligence,
Toulouse, France. Springer-Verlag.
757

fiHoffmann

Thiebaux, S., Hoffmann, J., & Nebel, B. (2003). defence PDDL axioms. Gottlob, G.
(Ed.), Proceedings 18th International Joint Conference Artificial Intelligence
(IJCAI-03), pp. 961966, Acapulco, Mexico. Morgan Kaufmann.
Thiebaux, S., Hoffmann, J., & Nebel, B. (2005). defence PDDL axioms. Artificial
Intelligence. appear.
Younes, H., & Simmons, R. (2002). role ground actions refinement planning..
Ghallab et al. (Ghallab et al., 2002), pp. 5461.

758


