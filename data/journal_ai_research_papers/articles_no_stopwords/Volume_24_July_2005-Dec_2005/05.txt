Journal Artificial Intelligence Research 24 (2005) 641-684

Submitted 04/05; published 11/05

Binary Encodings Non-binary Constraint Satisfaction
Problems: Algorithms Experimental Results
Nikolaos Samaras

samaras@uom.gr

Department Applied Informatics
University Macedonia, Greece

Kostas Stergiou

konsterg@aegean.gr

Department Information Communication Systems Engineering
University Aegean, Greece

Abstract
non-binary Constraint Satisfaction Problem (CSP) solved directly using extended versions binary techniques. Alternatively, non-binary problem translated equivalent binary one. case, generally accepted translated
problem solved applying well-established techniques binary CSPs.
paper evaluate applicability latter approach. demonstrate use
standard techniques binary CSPs encodings non-binary problems problematic
results models rarely competitive non-binary representation.
overcome this, propose specialized arc consistency search algorithms binary encodings, evaluate theoretically empirically. consider three
binary representations; hidden variable encoding, dual encoding, double
encoding. Theoretical empirical results show that, certain classes non-binary
constraints, binary encodings competitive option, many cases, better one
non-binary representation.

1. Introduction
Constraint Satisfaction Problems (CSPs) appear many real-life applications
scheduling, resource allocation, timetabling, vehicle routing, frequency allocation, etc.
CSPs naturally eciently modelled using non-binary (or n-ary) constraints
may involve arbitrary number variables. well known non-binary CSP
converted equivalent binary one. well-known translations
dual encoding (Dechter & Pearl, 1989) hidden variable encoding (Rossi, Petrie, &
Dhar, 1990). ability translate non-binary CSP binary often used
past justication restricting attention binary CSPs. Implicitly, assumption faced non-binary CSP simply convert
binary one, apply well-known generic techniques solving binary equivalent.
paper show assumption awed generic techniques
binary CSPs suitable binary encodings non-binary problems.
past years, theoretical empirical studies eciency
binary encodings comparisons binary encodings non-binary representation (Bacchus & van Beek, 1998; Stergiou & Walsh, 1999; Mamoulis & Stergiou, 2001;
Smith, 2002; Bacchus, Chen, van Beek, & Walsh, 2002). Theoretical results showed
c
2005
AI Access Foundation. rights reserved.

fiSamaras & Stergiou

converting non-binary CSPs binary equivalents potentially ecient way
solve certain classes non-binary problems. However, (limited) empirical studies
cases appears true, Conways game Life (Smith,
2002) notable exception. various reasons this. many cases,
extensive space requirements binary encodings make infeasible. Also,
many non-binary problems utilize ecient specialized propagators certain constraints, algorithm developed Regin (1994) all-dierent constraint.
Converting constraints binary clearly impractical. Another reason,
overlooked, (if all) experimental studies use well-known generic local
consistency search algorithms encodings. way fail exploit
structure constraints encodings, ending inecient algorithms.
make binary encodings realistic choice modelling solving non-binary CSPs,
need algorithms utilize structural properties. Finally, important point
use binary encoding necessarily mean convert
non-binary constraints problem binary, commonly perceived.
selective constraints encode, based properties arity tightness,
get ecient hybrid models.
address issues, show use specialized arc consistency search
algorithms binary encodings non-binary CSPs lead ecient models. consider three encodings; dual, hidden variable, double encoding. latter,
basically conjunction two encodings, received little attention
may well turn signicant practice. aim study
twofold. First, present ecient algorithms binary encodings analyze
theoretically experimentally. Second, importantly, investigate
use algorithms help solve non-binary problems eciently. Towards
aims, make following contributions:
describe simple algorithm enforces arc consistency hidden variable
encoding arbitrary non-binary CSP O(ekdk ) time complexity, e
number constraints, k maximum arity constraints,
maximum domain size. gives O(d) improvement compared asymptotic
complexity generic arc consistency algorithm. improved complexity
complexity optimal generalized arc consistency algorithm
non-binary representation problem. identify property arc
consistency algorithm hidden variable encoding make run faster,
arc inconsistent problems, generalized arc consistency algorithm.
consider search algorithms maintain local consistencies search
hidden variable encoding. show that, maintaining arc consistency,
generalizations forward checking non-binary CSPs emulated
corresponding forward checking algorithms run hidden variable encoding
instantiate original variables (i.e. variables initial non-binary
problem). show algorithm corresponding algorithm nonbinary constraints following relationships: 1) visit number
search tree nodes, 2) asymptotic cost within polynomial
bound other.
642

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

describe specialized algorithm dual encoding achieves arc consistency
O(e3 dk ) worst-case time complexity. signicantly lower O(e2 d2k )
complexity generic arc consistency algorithm. improvement complexity
bound stems observation constraints dual encoding specic
structure; namely piecewise functional (Van Hentenryck, Deville, & Teng,
1992). Apart applying arc consistency dual encoding non-binary
CSP, algorithm used specialized ltering algorithm certain
classes non-binary constraints.
adapt various search algorithms run double encoding compare
theoretically similar algorithms hidden variable encoding non-binary
representation. Search algorithms operate double encoding exploit
advantages hidden variable dual encoding. example, show
that, certain conditions, asymptotic cost maintaining arc consistency
algorithm double encoding polynomially worse asymptotic
cost corresponding algorithm non-binary representation (and hidden
variable encoding), exponentially better.
Finally, make extensive empirical study various domains. consider
random problems well structured ones, crossword puzzle generation, conguration, frequency assignment. study consists two parts. rst
part, give experimental results demonstrate advantages specialized
algorithms binary encodings compared generic algorithms. example,
specialized arc consistency algorithm dual encoding orders magnitude faster generic arc consistency algorithm. second part show
use binary encodings oer signicant benets solving certain classes
non-binary CSPs. example, solving dual encoding conguration
problems orders magnitudes ecient solving non-binary
representation. Also, empirical results frequency assignment - problems
demonstrate binary encoding benecial even non-binary constraints
intentionally specied.

paper structured follows. Section 2 give necessary denitions
background. Section 3 describe specialized arc consistency algorithm hidden
variable encoding. demonstrate extensions forward checking
non-binary CSPs emulated binary forward checking algorithms run
hidden variable encoding. Section 4 explain complexity arc consistency
dual encoding improved describe specialized arc consistency algorithm.
Section 5 discusses algorithms double encoding. Section 6 present experimental
results random structured problems demonstrate usefulness proposed
algorithms. draw conclusions regarding applicability encodings,
based theoretical experimental results. Section 7 discusses related work. Finally,
Section 8 conclude.
643

fiSamaras & Stergiou

2. Background
section give necessary denitions CSPs, describe hidden variable,
dual, double encodings non-binary CSPs.
2.1 Basic Definitions
Constraint Satisfaction Problem (CSP), P , dened tuple (X, D, C), where:
X = {x1 , . . . , xn } nite set n variables.
= {Din (x1 ), . . . , Din (xn )} set initial domains. variable xi X,
Din (xi ) initial nite domain possible values. CSP algorithms remove
values domains variables value assignments propagation.
variable xi , denote D(xi ) current domain xi time consists
values removed Din (xi ). assume every xi X,
total ordering <d dened Din (xi ).
C = {c1 , . . . , ce } set e constraints. constraint ci
pair (vars(ci ), rel(ci )), 1) vars(ci ) = {xj1 , . . . , xjk }
X called constraint scheme, 2) rel(ci ) subset
Din (xj1 )x . . . xDin (xjk ) species allowed combinations
ables vars(ci ).

C dened
ordered subset
Cartesian product
values vari-

size vars(ci ) called arity constraint ci . Constraints arity 2 called
binary. Constraints arity greater 2 called non-binary (or n-ary). tuple
rel(ci ) ordered list values (a1 , . . . , ak ) aj Din (xj ),j = 1, . . . , k.
tuple = (a1 , . . . , ak ) valid aj , j 1, . . . , k, aj D(xj ). is, tuple valid
values tuple present domains corresponding variables.
process veries whether given tuple allowed constraint ci called
consistency check. constraint either dened extensionally set allowed (or
disallowed) tuples intensionally predicate arithmetic function. binary CSP
represented graph (called constraint graph) nodes correspond variables
edges correspond constraints. non-binary CSP represented constraint
hyper-graph constraints correspond hyper-edges connecting two nodes.
assignment value variable xi denoted (xi , a). tuple =
(a1 , . . . , ak ) viewed set value variable assignments {(x1 , a1 ), . . . , (xk , ak )}.
set variables tuple dened denoted vars( ).
subset vars vars( ), [vars ] denotes sub-tuple includes assignments
variables vars . two tuples rel(ci ) ordered lexicographic
ordering <lex . ordering, <lex exists subset {x1 , . . . , xj } ci
[x1 , . . . , xj ] = [x1 , . . . , xj ] [xj+1 ] <lex [xj+1 ]. assignment consistent,
constraints ci , vars(ci ) vars( ), [vars(ci )] rel(ci ). solution CSP
(X, D, C) consistent assignment variables X. exists solution
given CSP, say CSP soluble. Otherwise, insoluble.
basic way solving CSPs using backtracking search. seen
traversal search tree comprises possible assignments values variables.
644

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

level tree corresponds variable. node search tree corresponds
tuple (i.e. assignment values variables). root tree corresponds
empty tuple, rst level nodes correspond 1-tuples (an assignment value
one variable), second level nodes correspond 2-tuples (assignment values two
variables generated extending rst level 1-tuples) etc. stage search
tree traversal, variables already assigned called past variables.
recently assigned variable called current variable. variables
assigned yet called future variables.
rest paper use notation n number variables
CSP, e number constraints problem, maximum domain size
variables, k maximum arity constraints.
2.1.1 Arc Consistency
important concept CSPs concept local consistency. Local consistencies
properties applied CSP, using (typically) polynomial algorithms, remove
inconsistent values either prior search. Arc consistency commonly
used local consistency property existing constraint programming engines.
give denition arc consistency.
Definition 2.1 value D(xj ) consistent constraint ci , xj vars(ci )
rel(ci ) [xj ] = valid. case say support
ci . constraint ci Arc Consistent (AC) variable xj vars(ci ), D(xj ),
exists support ci . CSP (X, D, C) arc consistent empty
domain constraints C arc consistent.
Arc consistency enforced CSP removing unsupported values
domains variables. enforcing arc consistency (or local consistency property
general) CSP P , mean applying algorithm yields new CSP
arc consistent (or property A) set solutions P .
denition arc consistency applies constraints arity. distinguish
binary non-binary cases, use term arc consistency (AC) refer
property arc consistency binary constraints only. non-binary constraints
use term Generalized Arc Consistency (GAC).
usefulness AC processing recognized early, result, various AC
algorithms binary constraints proposed literature (e.g. AC-3 Mackworth, 1977, AC-4 Mohr & Henderson, 1986, AC-5 Van Hentenryck et al., 1992, AC-7
Bessiere et al., 1995, AC-2001 Bessiere & Regin, 2001, AC3.1 Zhang & Yap, 2001).
extended non-binary case (e.g. GAC-4 Mohr & Masini,
1988, GAC-Schema Bessiere & Regin, 1996a, GAC-2001 Bessiere & Regin, 2001).
AC enforced binary CSP O(ed2 ) optimal worst-case time complexity.
worst-case complexity enforcing GAC non-binary CSP O(ekdk ) (Bessiere & Regin,
1996a).
paper use algorithms AC-2001 GAC-2001 theoretical empirical
comparisons specialized algorithms encodings. restrictive,
sense generic AC (and GAC) algorithm used instead.
645

fiSamaras & Stergiou

Following Debruyne & Bessiere (2001), call local consistency property stronger
B problem enforcing deletes least values B, strictly
stronger stronger least one problem deletes values
B. call equivalent B delete values problems. Similarly,
call search algorithm stronger search algorithm B every problem visits
search tree nodes B, strictly stronger stronger
least one problem visits less nodes B. equivalent B visit
nodes problems.
Following Bacchus et al. (2002), asymptotic cost (or cost hereafter) search
algorithm determined worst-case number nodes algorithm
visit solve CSP, worst-case time complexity algorithm node1 .
paper Bacchus et al. (2002), use measure set asymptotic bounds
relative performance various algorithms. example, two algorithms
B always visit nodes enforces property node exponentially
higher complexity property enforced B, say algorithm
exponentially greater cost algorithm B.
2.1.2 Functional Piecewise Functional Constraints
specialized AC algorithms hidden variable dual encoding
describe Sections 3 4 exploit structural properties encodings.
explain detail later, binary constraints hidden variable encoding one-way
functional, binary constraints dual encoding piecewise functional.
dene concepts.
Definition 2.2 binary constraint c, vars(c) = {xi , xj }, functional respect
D(xi ) D(xj ) D(xi ) (resp. b D(xj )) exists one value
b D(xj ) (resp. D(xi )) b support c (resp. support b).
example functional constraint xi = xj . binary constraint one-way functional
functionality property holds respect one variables involved
constraint.
Informally, piecewise functional constraint variables xi , xj constraint
domains xi xj partitioned groups group D(xi )
supported one group D(xj ), vice versa. give formal denition,
rst dene concept piecewise decomposition.
Definition 2.3 (Van Hentenryck et al., 1992) Let c binary constraint vars(c) =
{xi , xj }. partitions = {s1 , . . . , sm } D(xi ) = {s1 , . . . , sm } D(xj )
piecewise decomposition D(xi ) D(xj ) respect c sl S,sl ,
following property holds: either sl , b sl , (a, b) rel(c), sl , b sl ,
(a, b)
/ rel(c).
1. paper Bacchus et al. (2002) cost applying variable ordering heuristic node
taken account. theoretically compare search algorithms paper assume
use variable ordering, take cost account.

646

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

Definition 2.4 (Van Hentenryck et al., 1992) binary constraint c, vars(c) =
{xi , xj }, piecewise functional respect D(xi ) D(xj ) exists piecewise
decomposition = {s1 , . . . , sm } D(xi ) = {s1 , . . . , sm } D(xj ) respect
c sl (resp. sl ), exists one sl (resp. sl S),
sl , b sl (a, b) rel(c).
Example piecewise functional constraints modulo (x2 MOD x3 = a) integer
division (x2 DIV x3 = a) constraints.
2.2 Binary Encodings
two well-known methods transforming non-binary CSP binary one;
dual graph encoding hidden variable encoding. encode non-binary
constraints variables domains valid tuples constraints. is,
building binary encoding non-binary constraint store extensional representation
constraint (the set allowed tuples). third method double encoding
combines two.
2.2.1 Dual Encoding
dual encoding (originally called dual graph encoding) inspired work relational
databases. dual encoding (DE) (Dechter & Pearl, 1989) variables swapped
constraints vice versa. constraint c original non-binary CSP represented variable call dual variable denote vc . refer variables
original non-binary CSP original variables. domain dual variable vc
consists set allowed tuples original constraint c. Binary constraints
two dual variables vc vc exist vars(c) vars(c ) = . is, constraints c
c share one original variables. common vars set original variables
common c c tuple D(vc ) supported constraint vc
vc exists tuple D(vc ) [common vars] = [common vars].

v c1

v c4

(0,0,1) (0,1,0)

(0,0,0) (0,1,1)

(1,0,0)

(1,0,1)

(0,0,1) (1,0,0)

(0,1,0) (1,0,0)

(1,1,1)

(1,1,0) (1,1,1)
v c3

v c2

Figure 1: Dual encoding non-binary CSP.
647

fiSamaras & Stergiou

Consider following example six variables 0-1 domains, four constraints:
c1 : x1 + x2 + x6 = 1, c2 : x1 x3 + x4 = 1, c3 : x4 + x5 x6 1, c4 : x2 + x5
x6 = 0. DE represents problem 4 dual variables, one constraint.
domains dual variables tuples satisfy respective constraint.
example, dual variable vc3 associated third constraint domain
{(0, 1, 0), (1, 0, 0), (1, 1, 0), (1, 1, 1)} tuples values (x4 , x5 , x6 )
satisfy x4 + x5 x6 1. second example, dual variable vc4 associated
last constraint domain {(0, 0, 0), (0, 1, 1), (1, 0, 1)}. vc3 vc4
compatibility constraint ensure two original variables common, x5 x6 ,
values. constraint allows pairs tuples agree
second third elements (i.e. (1, 0, 0) vc3 (0, 0, 0) vc4 , (1, 1, 1) vc3
(0, 1, 1) vc4 ). DE problem shown Figure 1.
rest paper, sometimes denote cvi non-binary constraint
encoded dual variable vi . original variable xj vars(cvi ), pos(xj , cvi )
denote position xj cvi . instance, given constraint cvi variables x1 , x2 , x3 ,
pos(x2 , cvi ) = 2.
2.2.2 Hidden Variable Encoding
hidden variable encoding (HVE) inspired work philosopher Peirce (1933).
According Rossi et al. (1990), Peirce rst showed binary relations
expressive power non-binary relations.
HVE (Rossi et al., 1990), set variables consists original variables
non-binary CSP plus set dual variables. dual encoding, dual
variable vc corresponds constraint c original problem. domain dual
variable consists tuples satisfy original constraint. every dual variable
vc , binary constraint vc original variables xi
xi vars(c). tuple D(vc ) supported constraint vc xi
exists value D(xi ) [xi ] = a.
Consider previous example six variables 0-1 domains, four constraints:
c1 : x1 + x2 + x6 = 1, c2 : x1 x3 + x4 = 1, c3 : x4 + x5 x6 1, c4 : x2 + x5 x6 = 0.
HVE are, addition original six variables, four dual variables.
DE, domains variables tuples satisfy respective constraint.
compatibility constraints dual variable vc original variables
contained constraint c. example, constraints vc3 x4 ,
vc3 x5 vc3 x6 , variables involved constraint c3 .
compatibility constraint cv3 x4 relation true rst element
tuple assigned cv3 equals value x4 . HVE shown Figure 2.
2.2.3 Double Encoding
double encoding (Stergiou & Walsh, 1999) combines hidden variable dual
encoding. HVE, set variables double encoding consists
variables original non-binary CSP plus dual variables. every dual variable
vc , binary constraint vc original variables xi involved
corresponding non-binary constraint c. DE, binary constraints
648

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

v c1

v c4

(0,0,1) (0,1,0)

(0,0,0) (0,1,1)

(1,0,0)

(1,0,1)

x1 0 1

x2 0 1

x3 0 1

x4 0 1

(0,0,1) (1,0,0)

x5

01

x6

01

(0,1,0) (1,0,0)

(1,1,1)

(1,1,0) (1,1,1)
v c3

v c2

Figure 2: Hidden variable encoding non-binary CSP.
two dual variables vc vc non-binary constraints c c share one
original variables.

3. Algorithms Hidden Variable Encoding
section discuss specialized algorithms HVE. rst describe simple
AC algorithm HVE worst-case time complexity optimal
GAC algorithm non-binary representation. Appendix A, show
arc consistent CSP proposed AC algorithm performs exactly number
consistency checks corresponding GAC algorithm. arc inconsistent problems
show AC algorithm HVE detect inconsistency earlier thus
perform fewer consistency checks GAC algorithm.
consider search algorithms HVE maintain local consistencies
search. show that, maintaining arc consistency, generalizations forward
checking non-binary CSPs emulated corresponding binary forward checking
algorithms HVE instantiate original variables.
3.1 Arc Consistency
proved AC HVE equivalent GAC non-binary problem
(Stergiou & Walsh, 1999). Since HVE binary CSP, one obvious way apply AC
using generic AC algorithm. However, results redundant processing
asymptotic time complexity worse O(ekdk ). precise, HVE problem
kary constraints ek binary constraints dual original variables.
constraint, AC enforced O(ddk ) worst-case time complexity.
whole problem complexity O(ekdk+1 ).
Instead, describe simple AC algorithm operates HVE
achieves worst-case time complexity optimal GAC algorithm applied
non-binary representation. achieve slightly modifying GAC algorithm
649

fiSamaras & Stergiou

Bessiere Regin (2001) (GAC-2001). Figure 3 sketch AC algorithm
HVE, call HAC (Hidden AC).
function HAC
1:
Q
2:
dual variable vj
3:
variable xi xi vars(cvj )
4:
Revise(xi , vj ) = RU E
5:
D(xi ) empty return INCONSISTENCY
6:
put Q dual variable vl xi vars(cvl )
7:
return P ropagation
function P ropagation
8:
Q empty
9:
pop dual variable vj Q
10:
unassigned variable xi xi vars(cvj )
11:
Revise(xi , vj ) = RU E
12:
D(xi ) empty return INCONSISTENCY
13:
put Q dual variable vl xi vars(cvl )
14: return CONSISTENCY
function Revise(xi , vj )
15: DELETION FALSE
16:
value D(xi )
17:
currentSupportxi,a,vj valid
18:
( D(vj )) >lex currentSupportxi,a,vj , [xi ] = valid
19:
currentSupportxi,a,vj
20:
else
21:
remove D(xi )
22:
vl xi vars(cvl )
23:
remove D(vl ) tuple [xi ] =
24:
D(vl ) empty return INCONSISTENCY
25:
DELETION TRUE
26: return DELETION
Figure 3: HAC: AC algorithm hidden variable encoding.
HAC algorithm uses stack (or queue) dual variables propagate value deletions, works follows. initialization phase iterates dual variable
vj (line 2). every original variable xi constrained vj algorithm revises
constraint vj xi . done calling function Revise (line 4).
revision, value D(xi ) look tuple domain vj supports
it. AC-2001, store currentSupportxi,a,vj : recent tuple found
D(vj ) supports value variable xi 2 . tuple deleted D(vj )
2. assume, without loss generality, algorithm looks supports checking tuples
lexicographic order.

650

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

know supported. Otherwise, look new supporting tuple starting
tuple immediately currentSupportxi ,a,vj . tuple found
removed D(xi ) (line 21). case, tuples include value removed
domains dual variables constrained xi (lines 2223).
dual variables already stack added it3 . Then, dual variables
removed stack sequentially. dual variable vj removed
stack, algorithm revises constraint vj original variable xi constrained vj . algorithm terminates values domain deleted,
case problem arc consistent, stack becomes empty, case
problem arc consistent.
main dierence HAC GAC-2001 GAC-2001 include
lines 2224. is, even non-binary constraints given extension, GAC2001 remove tuples become invalid lists allowed tuples.
result, two algorithms check validity tuple (in lines 17 18) dierent
ways. Later section explain detail. Apart dierence,
important aects run times, two algorithms essentially
same. move HAC GAC-2001 removing lines 2224 substituting
references dual variables references corresponding constraints. example,
currentSupportxi,a,vj corresponds currentSupportxi,a,cvj GAC-2001, i.e. last tuple
constraint cvj supports value variable xi . Note implementation
GAC-2001, propagation constraint-based. is, algorithm utilizes stack
constraints perform propagation value deletions.
3.1.1 Complexities
give upper bound number consistency checks performed HAC
worst-case. Function Revise(xi , vj ) called kd times dual variable
vj , every deletion value domain xi , xi one k original
variables constrained vj . call Revise(xi , vj ) algorithm performs
checks (one value D(xi )) see currentSupportxi,a,vj valid (line 17).
currentSupportxi,a,vj valid, HAC tries nd new supporting tuple D(vj ).
check tuple contains assignment (xi , a) supports need check
valid. tuple valid one values removed domain
corresponding variable. means tuple removed
domain dual variable. Therefore, checking validity tuple done
constant time looking domain dual variable. algorithm needs
check support dk1 , maximum, tuples contain assignment (xi , a).
Since HAC stores currentSupportxi,a,vj , call Revise(xi , vj ) value
D(xi ), checks tuples checked before. words,
check dk1 tuples value xi . overall, worst
case, dk1 checks plus checks test validity current support.
kd values upper bound checks performed HAC make one dual variable AC
3. Note dual variables already stack never added it. sense, stack
implemented set.

651

fiSamaras & Stergiou

O(kd(d + dk1 ))=O(kdk ). e dual variables worst-case complexity bound O(ekdk ),
complexity GAC non-binary representation.
asymptotic space complexity HAC algorithm dominated O(edk )
space needed store domains dual variables. algorithm requires O(nde)
space store current supports. Since space required grows exponentially
arity constraints, reasonable assume HVE (and binary
encodings) cannot practical constraints large arity, unless constraints
tight.
mentioned, consistency check non-binary representation done dierent
way HVE. Assume GAC-2001 looks support value ai D(xi )
constraint c, vars(c) = {x1 , . . . , xk } xi vars(c). tuple = (a1 , . . . , ak )
supports ai [xi ] = ai valid. check valid, GAC-2001 check
values a1 , . . . , ak (except ai ) still domains variables x1 , . . . , xk . Therefore,
worst case, consistency check GAC-2001 involves k 1 operations. contrast,
HAC checks validity tuple constant time looking domain
corresponding dual variable see tuple still there. However, means
algorithm update (usually) large domains dual variables value
deletion original variable. aects run times algorithms dierent
problems settings.
Appendix show HAC complexity,
performs exactly number consistency checks GAC-2001 arc consistent
problems. show arc inconsistent problems dierence
number checks favor HVE.
3.2 Search Algorithms
Search algorithms maintain local consistencies widely used CSP solving.
extended non-binary case. example, maintaining arc consistency
(MAC) forward checking (FC). shown non-binary version MAC
(MGAC) applied non-binary CSP equivalent MAC applied HVE
CSP original variables instantiated variable orderings used
(Stergiou & Walsh, 1999). show that, MGAC, non-binary extensions FC
emulated equivalent algorithms run HVE.
FC (Haralick & Elliot, 1980) rst generalized handle non-binary constraints
Van Hentenryck (1989). According denition Van Hentenryck (1989), forward
checking performed k-1 variables k-ary constraint assigned
remaining variable unassigned. algorithm called nFC0 paper Bessiere,
Meseguer, Freuder, & Larrosa (2002) more, stronger, generalizations FC
non-binary constraints introduced. generalizations dier
extent look-ahead perform variable instantiation. Algorithm nFC1 applies
one pass GAC constraint constraint projection involving current variable
exactly one future variable4 . Algorithm nFC2 applies GAC set constraints
involving current variable least one future variable, one pass. Algorithm nFC3
applies GAC set constraints involving current variable least one future
4. One pass means constraint processed once.

652

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

variable. Algorithm nFC4 applies GAC set constraints involving least one
past variable least one future variable, one pass. Algorithm nFC5,
strongest version, applies GAC set constraints involving least one past variable
least one future variable. generalizations reduce simple FC applied
binary constraints.
show various versions nFC equivalent, terms visited nodes,
binary versions FC run HVE problem. holds
assumption binary algorithms assign original variables use
variable value ordering heuristics, static dynamic, non-binary counterparts.
Note algorithm nds consistent assignment original variables,
assignments propagated dual variables, domains dual
variables reduced singletons. is, domain dual variable vc
contain single tuple consistent assignments original variables
constrained vc . Therefore, algorithm proceed assign dual variables
backtrack-free manner.
equivalence nFC1 version FC HVE, called FC+ (Bacchus
& van Beek, 1998), proved Bessiere et al. (2002). FC+ specialized forward
checking algorithm HVE. operates standard binary FC except
domain dual variable pruned, FC+ removes adjacent original variables
value longer supported.
Algorithms nFC2-nFC5 equivalent algorithms operate HVE.
call algorithms hFC2hFC5. example, hFC5 enforce AC set dual
variables, original variables connected them, dual variable connected
least one past original variable least one future original variable. Note
nFC0 natural equivalent algorithm HVE. emulate HVE
get inecient awkward algorithm. following, hFC0 refer standard
binary FC algorithm hFC1 refer FC+.

Proposition 3.1 non-binary CSP, xed variable value ordering, algorithm nFCi, i= 2, . . . 5, equivalent algorithm hFCi operates hidden variable
encoding problem.
Proof: prove nFC5, strongest among generalized FC algorithms.
proof versions similar. need prove node
search tree algorithms nFC5 hFC5 delete exactly values
domains original variables. Assume node, instantiating current
variable, nFC5 deletes value future variable xi . exists constraint
c including xi least one past variable, value xi supporting tuple c.
HVE, hFC5 tries make vc (the dual variable corresponding c) AC
remove tuples assign xi . Hence, hFC5 delete domain xi .
opposite case, hFC5 deletes value original variable xi means
tuples including assignment removed domains dual variables
include xi least one past variable. non-binary representation problem,
assignment xi supporting tuples constraints involve xi
least one past variable. Therefore, nFC5 delete domain xi . 2
653

fiSamaras & Stergiou

Algorithms nFC2nFC5 equivalent node visits corresponding algorithms hFC2hFC5, asymptotic cost. holds
condition non-binary algorithms use GAC-2001 (or optimal algorithm)
enforce GAC, HVE versions use algorithm HAC.
Proposition 3.2 non-binary CSP, xed variable value ordering, algorithm nFCi, i= 2, . . . 5, asymptotic cost algorithm hFCi operates
hidden variable encoding problem.
Proof: Section 3.1 showed enforce AC HVE non-binary
CSP worst-case complexity GAC non-binary representation
problem. Since algorithm nFCi enforces GAC part problem
algorithm hFCi enforces AC, visit nodes search tree, follows
two algorithm asymptotic cost. 2
paper Bessiere et al. (2002), detailed discussion complexities algorithms nFC0nFC5 made. worst-case complexity nFC2 nFC3 one node
O(|Cc,f |(k 1)dk1 ), |Cc,f | number constraints involving current variable least one future variable. complexity hFC3 hFC4.
worst-case complexity nFC4 nFC5 one node O(|Cp,f |(k 1)dk1 ), |Cp,f |
number constraints involving least one past variable least one future
variable. complexity hFC4 hFC5.
Assuming nodes(algi ) set search tree nodes visited search algorithm
algi following holds.
Corollary 3.1 Given hidden variable encoding CSP xed variable value
ordering schemes, following relations hold:
1. nodes(hFC1) nodes(hFC0)
2. nodes(hFC2) nodes(hFC1)
3. nodes(hFC5) nodes(hFC3) nodes(hFC2)
4. nodes(hFC5) nodes(hFC4) nodes(hFC2)
5. nodes(MAC) nodes(hFC5)
Proof: proof 1 straightforward, see paper Bacchus & van Beek (1998).
Proof 2-4 straightforward consequence Proposition 3.1 Corollary 2
paper Bessiere et al. (2002) hierarchy algorithms nFC0-nFC5 node visits
given. easy see 5 holds since hFC5 applies AC part CSP,
MAC applies whole problem. Therefore, MAC prune least many
values hFC5 given node search tree. Since variable value
ordering heuristics used, means MAC visit number
nodes hFC5. 2
Note paper Bacchus & van Beek (1998) experimental results show differences FC HVE FC non-binary representation. However,
654

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

algorithms compared FC+ nFC0, equivalent. Also,
proved hFC0 exponentially greater cost nFC0, vice versa
(Bacchus et al., 2002). However, algorithms equivalent. proved Proposition 3.2, result Bacchus et al. (2002) hold comparing equivalent
algorithms.
far showed solving non-binary CSP directly many ways equivalent
solving using HVE, assuming original variables instantiated.
natural question whether search techniques inapplicable
non-binary case, applied encoding. answer ability search
algorithm operates encoding instantiate dual variables. equivalent
non-binary representation would imply instantiating values one variables
simultaneously. implement algorithm would modify standard search
algorithms heuristics devise new ones. hand, HVE algorithm
instantiates dual variables easily implemented.

4. Algorithms Dual Encoding
section turn attention DE describe specialized AC algorithm
signicantly lower complexity generic algorithm.
4.1 Arc Consistency
know AC DE strictly stronger GAC non-binary representation
AC HVE (Stergiou & Walsh, 1999). Since DE binary CSP, one obvious
way apply AC using generic AC algorithm. domain size dual variable
corresponding kary constraint dk worst case. Therefore, apply
optimal AC algorithm enforce AC one dual constraint O(d2k ) worstcase complexity. DE CSP e constraints maximum arity k
e(e 1)/2 binary constraints (when pairs dual variables share one
original variables). Therefore, enforce AC DE CSP O(e2 d2k ) worstcase complexity. signicantly expensive compared O(ekdk ) complexity
bound GAC non-binary representation AC HVE.
high complexity bound, AC processing DE considered impractical, except
perhaps tight constraints.
However, show AC applied DE much eciently.
precise enforce AC DE non-binary CSP O(e3 dk ) worst-case time
complexity. improvement asymptotic complexity achieved exploiting
structure DE; namely, fact constraints DE piecewise
functional.
Consider binary constraint dual variables vi vj . create piecewise
decomposition tuples domain either dual variable groups
tuples group supported group tuples variable.
non-binary constraints corresponding two dual variables share f original variables
x1 , . . . , xf domain size d, partition tuples vi vj df groups.
tuple group includes sub-tuple form (a1 , . . . , af ), a1
D(x1 ), . . . , af D(xf ). tuple supported tuples group
655

fiSamaras & Stergiou

variable, tuple includes sub-tuple (a1 , . . . , af ).The tuples
belonging supports tuple since tuple contain
sub-tuple (a1 , . . . , af ). words, group tuples variable vi
supported corresponding group variable vj tuples groups
values original variables common two encoded non-binary
constraints. Therefore, constraints DE piecewise functional.
Example 4.1 Assume two dual variables v1 v2 . v1 encodes constraint
(x1 , x2 , x3 ), v2 encodes constraint (x1 , x4 , x5 ), original variables
x1 , . . . , x5 domain {0, 1, 2}. partition tuples dual variable
3 groups. rst group include tuples form (0, , ), second include tuples form (1, , ), third include tuples form (2, , ).
star () means corresponding original variable take value. group
supported corresponding group variable. Note tuples
variable vi partitioned dierent groups according constraint involves vi .
instance, another dual variable v3 encoding constraint (x6 , x7 , x3 )
partition tuples D(v1 ) according constraint v1 v3 groups
form (, , 0), (, , 1), (, , 2).
Van Hentenryck, Deville & Teng (1992) shown AC achieved
set binary piecewise functional constraints O(ed) worst-case time complexity,
improvement O(d) compared O(ed2 ) complexity arbitrary binary constraints
(Van Hentenryck et al., 1992). Since showed constraints DE piecewise
functional, result Van Hentenryck et al. (1992) means improve
O(e2 d2k ) complexity AC DE.
Figure 4 sketch AC-3 AC algorithm specically designed DE,
call PW-AC (PieceWise Arc Consistency). show, algorithm
worst-case time complexity O(e3 dk ). complexity bound achieved
AC-5 algorithm Van Hentenryck et al. (1992), specialization piecewise
functional constraints, necessary adaptations operate DE.
AC algorithms, PW-AC uses stack (or queue) propagate deletions domains
variables. stack processes groups piecewise decompositions, instead variables
constraints usual AC algorithms. use following notation:
S(vi , vj ) = {s1 (vi , vj ), . . . , sm (vi , vj )} denotes piecewise decomposition D(vi )
respect constraint vi vj . sl (vi , vj ), l = 1, . . . , m,
group partition.
sup(sl (vi , vj )) denotes group S(vj , vi ) support group sl (vi , vj )
S(vi , vj ). discussed, group unique.
counter(sl (vi , vj )) holds number valid tuples belong group sl (vi , vj )
decomposition S(vi , vj ). is, time value counter(sl (vi , vj )) gives
current cardinality group.
GroupOf (S(vi , vj ), ) function returns group S(vi , vj ) tuple
belongs. implement function, constraint dual variables vi
656

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

function P W AC
1:
Q
2:
initialize group counters 0
3:
variable vi
4:
variable vj constrained vi
5:
tuple D(vi )
6:
counter(GroupOf (S(vi , vj ), )) counter(GroupOf (S(vi , vj ), )) + 1
7:
variable vi
8:
variable vj constrained vi
9:
group sl (vi , vj )
10:
counter(sl (vi , vj )) = 0
11:
put sl (vi , vj ) Q
12: return P ropagation
function P ropagation
13: Q empty
14:
pop group sl (vi , vj ) Q
15:

16:
Revise(vi , vj , sl (vi , vj ))
17:
D(vj ) empty return INCONSISTENCY
18:
group sl (vj , vk ) put sl (vj , vk ) Q
19: return CONSISTENCY
function Revise(vi , vj , sl (vi , vj ))
20: tuple D(vj ) sup(sl (vi , vj ))
21:
remove D(vj )
22:
group sl (vj , vk ) includes
23:
counter(sl (vj , vk )) counter(sl (vj , vk )) 1
24:
counter(sl (vj , vk )) = 0
25:
add sl (vj , vk )
26: return
Figure 4: PW-AC. AC algorithm dual encoding.

vj store original variables shared non-binary constraints cvi
cvj . Also, original variable xl store pos(xl , cvi ) pos(xl , cvj ).
way GroupOf function takes constant time.
set contains groups counter reduced 0 call
function Revise. is, groups tuples belonging
deleted.
algorithm works follows. initialization phase, group count
number tuples contains (lines 36). Then, variable vi iterate
657

fiSamaras & Stergiou

variables vj constrained vi . group sl (vi , vj ) S(vi , vj ), check
sl (vi , vj ) empty (line 10). empty, added stack propagation.
next phase, function P ropagation called delete unsupported tuples
propagate deletions (line 12). previous phase nished, stack
contain number groups 0 cardinality. group sl (vi , vj ) must
remove tuples belonging group sup(sl (vi , vj )) since lost support.
done successively removing group sl (vi , vj ) stack calling function
Revise. Since group sup(sl (vi , vj )) lost support, tuple D(xj ) belongs
sup(sl (vi , vj )) deleted (lines 2021). Apart sup(sl (vi , vj )), tuple may belong
groups D(vj ) partitioned respect constraints vj
variables. Since deleted, counters groups must updated (i.e. reduced
one). done lines 2223. implementation use function GroupOf
access relevant groups. counter group becomes 0 group
added stack propagation (lines 2425 18). process stops either
stack domain variable becomes empty. former case, DE AC,
latter not.
following example illustrates advantage algorithm PW-AC generic
AC algorithm employed DE, AC HVE (or GAC non-binary representation).
Example 4.2 Consider three constraints c1 , c2 , c3 part CSP, vars(c1 ) =
{x0 , x1 , x3 }, vars(c2 ) = {x2 , x3 , x4 }, vars(c3 ) = {x2 , x4 , x5 }. Assume point
domains variables DE problem shown Figure 5 (disregarding
original variables depicted dashed lines). Assume try enforce AC

x 2x 3x 4

x 0x 1x 3

vc1

0,0,0
0,1,0
0,1,3
1,0,1
1,0,2

vc2

0,0,0
0,1,1
0,2,1
0,3,1
1,1,0
1,2,0
1,3,0

x2

x 2x 4x 5

0,1
1,0,0
0,1,0

vc3

0,1
x4

Figure 5: Dual encoding non-binary CSP.
DE using algorithm AC-20015 . algorithm discover rst tuple D(vc2 )
support D(vc3 ) (there tuple x2 = 0 x4 = 0) delete it.
deletion, rst two tuples D(vc1 ) lose support D(vc2 )
AC-2001 must therefore look new supports. two tuples D(vc1 )
algorithm check 6 remaining tuples D(vc2 ) discovering
support. result two tuples deleted. Algorithm PW-AC,
hand, set counter group rst tuple D(vc2 ) belongs (according
partition S(vc2 , vc3 )) 0 deletes tuple. result call function
5. Note construct similar examples generic AC algorithm.

658

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

Revise automatic deletion rst two tuples D(vc1 ), saving total 2 6
checks.
consider HVE problem. Applying AC HVE eect
values 0 1 x2 x4 supported D(vc2 ) D(vc3 ). Therefore
propagation variables, result two tuples D(vc1 )
deleted. Similarly, propagation apply GAC non-binary
representation problem.
Note theoretical results regarding DE presented rest paper
hold AC-5 algorithm Van Hentenryck et al. (1992) adapted used DE
instead PW-AC. two algorithms similarities (e.g. use function
access group decomposition certain tuple belongs to, though implemented
dierently), basic operation dierent. algorithm Van Hentenryck et al.
(1992), instantiation AC-5, handles queue triples (vi , vj , a) implement
constraint propagation, vi vj two variables involved constraint
value removed D(vj ). PW-AC utilizes queue piecewise
decompositions. data structures used algorithms dierent. PW-AC
checks updates counters perform propagation which, explain below, requires
space exponential number common variables non-binary constraints.
algorithm Van Hentenryck et al. (1992) utilizes complicated data structure
requires space exponential arity non-binary constraints. noted,
however, PW-AC specically designed DE. is, operation, data
structures, way checks consistency based fact domains
dual variables consist tuples original constraints extensionally stored.
hand, algorithm Van Hentenryck et al. (1992) generic, sense
adapted operate piecewise functional constraint.
4.1.1 Complexities
PW-AC algorithm consists two phases. initialization phase set group
counters, main phase delete unsupported tuples propagate deletions.
analyze time complexity PW-AC. Note complexity analysis
measure operations, incrementing decrementing counter, since PW-AC
perform consistency checks usual sense.
Proposition 4.1 worst-case time complexity algorithm PW-AC O(e3 dk ).
Proof: assume constraint dual encoding, non-binary constraints corresponding two dual variables vi vj share f original variables
x1 , . . . , xf domain size d. means piecewise decomposition consists
df groups. Obviously, f equal k 1, k maximum arity
constraints. initialization phase lines 36 iterate constraints,
constraint variables vi vj , iterate tuples D(vi ).
done O(e2 dk ) asymptotic time complexity. Then, empty groups inserted
Q (lines 711). requires e2 df operations worst case. initialization,
function P ropagation called. group inserted Q (and later removed)
becomes empty. means loop P ropagation executed
659

fiSamaras & Stergiou

df times constraint, e2 df times total. maximum
number times function Revise called (once every iteration loop). cost
function Revise computed follows: Assuming Revise called group sl (vi , vj ),
iterate (at most) dkf tuples group sup(sl (vi , vj )) (line 20). iteration
remove tuple (line 21) update counters groups belongs
(lines 2223). e groups (in case vj constrained dual
variables). Therefore, iteration costs O(e), result, call Revise costs
O(edkf ). Since Revise called e2 df times, complexity PW-AC, including
initialization step, O(e2 dk + e2 df + e2 df edkf )=O(e3 dk ). 2
Note PW-AC easily used incrementally search. case,
initialization phase executed once. asymptotic space complexity PWAC, AC algorithm binary encoding, dominated O(edk ) space need
store allowed tuples non-binary constraints. Algorithm PW-AC requires
O(e2 df ) space store counters groups, O(e2 df ) space stack,
O(f e2 ) space fast implementation function GroupOf .

5. Algorithms Double Encoding
double encoding rarely used experiments binary encodings, although
combines features HVE DE, therefore may exploit advantages
worlds. precise, double encoding oers following interesting potential:
search algorithms deploy dynamic variable ordering heuristics assign values
original variables, constraint propagation implemented constraints
dual variables achieve higher pruning. section rst briey discuss
AC applied double encoding. show various search algorithms
adapted operate double encoding.
5.1 Arc Consistency
AC enforced double encoding using algorithm PW-AC addition
time value original variable xi loses supports adjacent dual
variable, deleted D(xi ). Alternatively, use generic AC algorithm,
AC-2001. Note AC algorithm applied double encoding enforce various
levels consistency depending constraints uses propagation dual
variables. is, propagation either done directly constraints
dual variables, indirectly constraints dual original variables.
example, use constraints dual original variables get
level consistency AC HVE. propagation dual variables
performed using constraints DE get level consistency AC
DE, dual variables, prune domains original variables.
between, option use dierent constraints propagation dierent parts
problem. next example shows, AC double encoding achieve
high level consistency compared non-binary representation. Sections 6.2 6.3
show profound eect practice.
660

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

Example 5.1 Consider problem Figure 6. Applying AC constraint
two dual variables determine problem insoluble. However,
problem non-binary representation GAC, singleton (generalized)
arc consistent (SGAC), high level consistency. CSP SGAC
applying GAC problem induced instantiation single variable,
domain wipeout (Debruyne & Bessiere, 2001; Prosser, Stergiou, & Walsh, 2000).

x1
x 0x 1x 2x 3

0
x0

0,1

0
x4

x 1x 2x 3x 4

x2
vc1

0, 0, 0, 0
0, 0, 1, 1
0, 1, 0, 1
0, 1, 1, 0

0,1

0, 0, 1, 0
0, 1, 0, 0
1, 0, 0, 0
1, 1, 1, 0

vc2

0,1
x3

Figure 6: Double encoding problem AC double encoding SGAC
non-binary representation.

5.2 Search Algorithms
Various search algorithms double encoding dened, depending variables
instantiated constraints used propagation. restrict
algorithms instantiate original variables perform propagation
using constraints dual variables. Intuitively interesting class
algorithms combine nice features non-binary representation
HVE (small domain sizes), DE (strong propagation).
rst show FC versions HVE discussed Section 3.2 adapted
yield algorithms run double encoding. call algorithms dFC0dFC5.
algorithm dFCi (i = 0, . . . , 5) instantiates original variables enforces AC
exactly set variables double encoding corresponding algorithm hFCi
HVE. example, dFC5 enforce AC set dual variables, original
variables connected them, dual variable connected least one past
original variable least one future original variable. dierence algorithm
dFCi (i = 2, . . . , 5) hFCi former exploit constraints dual
variables enforce higher level consistency latter. surprisingly,
results stronger algorithms.
Proposition 5.1 non-binary CSP, xed variable value ordering, algorithm dFCi (i= 2, . . . , 5) strictly stronger respective algorithm hFCi.
Proof: easy see value pruned hFCi HVE
pruned dFCi double encoding. straightforward consequence
fact 1) double encoding subsumes HVE, 2) algorithms dFCi hFCi
enforce AC set variables. Algorithm dFCi strictly stronger hFCi
661

fiSamaras & Stergiou

because, exploiting constraints dual variables, prune values
hFCi. Consider, instance, problem two constraints c1 c2 , vars(c1 ) =
{x1 , x2 , x3 , x4 } vars(c2 ) = {x1 , x2 , x3 , x5 }. variables xi , = 1, . . . , 5, domains
{0, 1}. allowed tuples constraints rel(c1 ) = {(0, 0, 1, 0), (0, 1, 0, 1), (1, 1, 0, 1)}
rel(c2 ) = {(0, 0, 0, 0), (0, 1, 1, 1), (1, 0, 0, 0)}. x1 given value 0 HVE
algorithms hFC2hFC5 prune tuples (1, 1, 0, 1) (1, 0, 0, 0) domains dual
variables vc1 vc2 respectively. pruning performed. double
encoding, variable assignment, algorithms dFC2dFC5, cause
domain wipe-out two dual variables. 2
Corollary 5.1 non-binary CSP, xed variable value ordering, algorithm
dFCi (i= 2 . . . 5) strictly stronger respective algorithm nFCi (i=2 . . . 5).
Proof: Straightforward consequence Propositions 5.1 3.1. 2
easy see algorithm hFC0 (i.e. simple binary FC) equivalent dFC0.
holds algorithms hFC1 dFC1. various versions FC, MAC
algorithm adapted run double encoding original variables
instantiated, propagation implemented constraints dual
variables. easy see algorithm strictly stronger corresponding
algorithm HVE (the proof similar proof Proposition 5.1). interestingly, show MAC algorithm double encoding can, most,
polynomially greater cost corresponding MAC algorithm HVE, while,
hand, exponentially better.
Proposition 5.2 non-binary CSP, xed variable value ordering,
MAC algorithm hidden variable encoding instantiates original variables
exponentially greater cost corresponding MAC algorithm double
encoding.
Proof: prove this, use Example 14 paper Bacchus et al. (2002).
example CSP 4n + 2 variables, x1 , . . . , x4n+2 , domain
{1, . . . , n}, 2n + 1 constraints:
c1 : (x1 + x2 mod 2) = (x3 + x4 mod 2)
c2 : (x3 + x4 mod 2) = (x5 + x6 mod 2)
...
c2n : (x4n1 + x4n mod 2) = (x4n+1 + x4n+2 mod 2)
c2n+1 : (x4n+1 + x4n+2 mod 2) = (x1 + x2 mod 2)
Assume variables assigned lexicographic order double encoding. x1
x2 assigned values (x1 + x2 mod 2) = 0 enforcing AC prune
tuples D(vc1 ) (x3 + x4 mod 2) = 0. turn prune D(vc2 )
tuples (x5 + x6 mod 2) = 1. Continuing way, AC propagation prune
D(vc2n+1 ) values (x1 + x2 mod 2) = 0. deletions propagated
vc1 , D(vc1 ) become empty. similar way, enforcing AC assignments
662

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

x1 x2 , (x1 + x2 mod 2) = 1, leaves D(vc1 ) empty. Therefore, CSP
insoluble. MAC double encoding needs instantiate two variables discover this,
visit O(n2 ) nodes. hand, explained Bacchus et al. (2002), MAC
HVE needs visit O(nlog(n) ) nodes conclude problem insoluble. Finally,
note that, node, asymptotic costs MAC double encoding (using PWAC) MAC HVE polynomially related. Therefore, MAC HVE
exponentially worse MAC double encoding. 2
corollary Proposition 5.2 MAC double encoding exponentially smaller cost MGAC non-binary representation.
Proposition 5.3 non-binary CSP, xed variable value ordering,
MAC algorithm double encoding instantiates original variables
polynomially greater cost corresponding MAC algorithm hidden
variable encoding.
Proof: prove need show two things: 1) number node visits made
MAC double encoding polynomial factor greater number
node visits made MAC HVE, 2) node, worst-case cost MAC
double encoding polynomial factor greater worst-case cost AC
HVE. former true since MAC double encoding strictly stronger
MAC HVE. latter established considering worst case complexities
algorithms node. MAC HVE costs O(ekdk ) node, MAC
double encoding use PW-AC enforce AC, costs O(e3 dk ). Therefore,
polynomial dierence. 2
similar way, prove relationship Proposition 5.3 holds
algorithm dFCi (i= 2 . . . 5) corresponding algorithm hFCi. corollary Proposition 5.3 MAC double encoding polynomially greater cost
MGAC non-binary representation. important note Proposition 5.3
holds algorithm PW-AC used enforce AC double encoding. use
generic algorithm, AC-2001, get exponential dierences favor MAC
HVE. Finally, regarding relationship node visits among algorithms
double encoding, following.
Proposition 5.4 Given double encoding CSP xed variable value ordering schemes, following relations hold:
1. nodes(dFC1) nodes(dFC0)
2. nodes(dFC2) nodes(dFC1)
3. nodes(dFC5) nodes(dFC3) nodes(dFC2)
4. nodes(dFC5) nodes(dFC4) nodes(dFC2)
5. nodes(dMAC) nodes(dFC5)
Proof: proof simple based comparing size subsets
problem algorithm enforces AC. 2
663

fiSamaras & Stergiou

6. Experimental Results
section make empirical study algorithms binary encodings. empirical
study organized two parts:
rst part (Subsections 6.1 6.2) evaluate improvements oered
specialized algorithms compared generic ones. time compare
eciency algorithms run binary encodings non-binary counterparts. comparison give us better understanding encoding
non-binary problem binary one pays o, encoding preferable.
empirical investigation use randomly generated problems, random problems
added structure, benchmark crossword puzzle generation problems. Random
problems allow us relate performance algorithms certain parameters,
tightness, constraint graph density, domain size. Crossword puzzles
standard benchmarks comparing binary non-binary constraint models, allow us evaluate performance algorithms problems include
constraints high arity.
second part (Subsection 6.3) , investigate usefulness binary encodings
realistic problem settings. study use problems domains
conguration frequency assignment compare performance MAC
algorithms run encodings MGAC algorithm non-binary representation.
algorithms implemented C. experiments run PC 3.06
GHz Pentium 4 processor 1 GB RAM. experiments, algorithms use
dom/deg heuristic (Bessiere & Regin, 1996b) dynamic variable ordering lexicographic value ordering.
6.0.1 Random Problems
Random instances generated using extended model B described Bessiere
et al. (2002). summarize generation method, random non-binary CSP dened
following input parameters:
n - number variables
- uniform domain size
k - uniform arity constraints
p - density (%) percentage generated graph, i.e. ratio existing constraints
number possible sets k variables
q - uniform looseness (%) percentage constraints, i.e. ratio allowed
tuples dk total tuples constraint
constraints allowed tuples generated following uniform distribution.
made sure generated graphs connected. following, class non-binary
664

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

CSPs denoted tuple form < n, d, k, p, q >. use star () case
one parameters varied. example, tuple < 50, 20, 3, 10, > stands
class problems 50 variables, domain size 20, arity 3, graph density 10%,
varying constraint looseness.
6.0.2 Crossword Puzzles
Crossword puzzle generation problems used evaluation algorithms
heuristics CSPs (Ginsberg, Frank, Halpin, & Torrance, 1990; Beacham, Chen, Sillito, &
van Beek, 2001) binary encodings non-binary problems (Bacchus & van Beek, 1998;
Stergiou & Walsh, 1999). crossword puzzle generation try construct puzzles
given number words given grid lled words. problem
represented either non-binary binary CSP straightforward way.
non-binary representation variable letter lled nonbinary constraint set k variables form word puzzle. domain
variable consists low case letters English alphabet giving domain
size 26. allowed tuples constraint words k letters
dictionary used. compared 26k possible combinations letters,
means constraints tight. DE variable word
length k puzzle possible values variable words k
letters dictionary. gives variables large domains (up 4072 values
Unix dictionary used experiments). binary constraints
variables intersect (i.e. common letter). HVE
original variables well set dual variables, one non-binary constraint.
6.1 Hidden Variable Encoding
rst empirical study investigated performance two MAC algorithms
operate HVE, compared MGAC-2001, counterpart nonbinary representation. two MAC algorithms HVE MHAC-2001,
stands MAC HVE instantiates original variables, MHAC-2001-f ull
MAC algorithm may instantiate variable (dual original) according
heuristic choice. stated names, three algorithms use AC-2001 (GAC-2001)
enforce AC. Although run experiments various versions FC,
include results since algorithms inecient hard problems (especially hard
crossword puzzles). However, qualitative comparison FC-based algorithms
HVE non-binary representation similar comparison regarding MACbased algorithms.
6.1.1 Random Problems
Table 1 shows performance, measured cpu time, algorithms classes
randomly generated CSPs. classes hard phase transition region. Classes 1,
2, 3, 4 sparse, 5 dense. include results MHAC-2001-f ull
experiments showed algorithm similar behavior MHAC-2001.
reason that, nature constraints, dom/deg heuristic almost
665

fiSamaras & Stergiou

always selects original variables instantiation. rare cases heuristic
selected dual variables, resulted large increase cpu time.
class
MGAC-2001 MHAC-2001
1: < 30, 6, 3, 1.847, 50 >
2.08
1.90
2: < 75, 5, 3, 0.177, 41 >
4.09
3.41
3: < 50, 20, 3, 0.3, 5 >
64.15
28.10
4: < 50, 10, 5, 0.001, 0.5 >
74.72
22.53
5: < 20, 10, 3, 5, 40 >
5.75
8.15
Table 1: Comparison algorithms MGAC-2001 MHAC-2001 random classes
problems. Classes 1 2 taken paper Bessiere et al. (2002). give
average run times (in seconds) 100 instances class. winning
time instance given bold. follow rest paper.

Table 1 see MHAC-2001 performs better MGAC-2001
sparse problems. general, 3-ary classes tried density less 3% 4%
relative run time performance MHAC-2001 compared MGAC-2001 ranged
equal around 2-3 times faster. sparse class 4, includes
problems 5-ary constraints, MHAC-2001 considerably ecient MGAC2001. due fact sparse problems relatively large domain sizes
hard region located low constraint looseness (i.e. small domains dual variables)
operations required revision dual variables. Another factor
contributing dominance binary algorithm class 4 larger arity
constraints. non-binary algorithm requires operations check validity
tuples tuples large arity, explained Section 3.1.
density graph increases (class 5), overhead revising domains
dual variables restoring failed instantiations slows MHAC-2001,
result outperformed MGAC-2001. denser classes ones reported,
phase transition region point half tuples allowed,
cases non-binary algorithm performs even better.
6.1.2 Crossword Puzzles
Table 2 demonstrates performance search algorithms various crossword puzzles.
used benchmark puzzles papers Ginsberg et al. (1990) Beacham et al.
(2001). Four puzzles (15.06, 15.10, 19.03, 19.04) could solved algorithms
within 2 hours cpu time. Also, two puzzles (19.05 19.10) arc inconsistent.
cases GAC discovered inconsistency slower AC HVE (around 3:1 time
dierence 19.05 10:1 19.10) latter method discovered early domain
wipe-out dual variable.
rest puzzles observe MHAC-2001 performs better MGAC2001 hard instances. hard insoluble puzzles MHAC-2001 3 times
faster MGAC-2001. mainly due large arity constraints
666

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

puzzle
15.02
15.04*
15.07
19.02
19.08
66
77*
88*
1010*

n
80
76
74
118
134
12
14
16
20

e MGAC-2001 MHAC-2001 MHAC-2001-f ull
191
3.70
3.58

193
40.84
38.88
29.75
193
94.65
46.36
44m
296
34.62
35.08

291


5.45
36
9.39
5.07
5.49
49
14m
8m
12m
64
6m
2m
5m
100
11.81
11.85
15.39

Table 2: Comparison (in cpu time) algorithms HVE algorithms
non-binary representation crossword puzzles. n number words e
number blanks. times seconds except followed
(minutes). dash () placed wherever algorithm manage nd
solution within 2 hours cpu time. Problems marked (*) insoluble.
include problems reasonably hard least one algorithm
time solvable within 2 hours least one algorithm.

classes6 . Another interesting observation signicant dierences
performance methods may instantiate dual variables instantiate
original ones. many cases MAC-2001-f ull managed nd (dierent) solution
MHAC-2001 MGAC-2001 earlier. hand, MAC-2001-f ull subject
thrashing instances methods terminate. fact insoluble
puzzles MAC-2001-f ull better MHAC-2001 shows performance
largely dependent variable ordering scheme. many cases MAC-2001-f ull visited
less nodes MHAC-2001. However, reected similar time performance
dierence dual variable instantiated MAC-2001-f ull work
original one instantiated. instantiate automatically original
variable xi constrained dual variable propagate changes dual
variables containing xi .
6.2 Dual Double Encodings
empirical study investigated performance algorithms DE double
encoding. tried answer following three questions: 1) ecient specialized
algorithms compared generic algorithms? 2) use specialized algorithm
make DE eective option solving non-binary CSPs? 3) take advantage
theoretical properties double encoding practice? answer questions,
run experiments random structured problems evaluate benets oered
specialized algorithm PW-AC maintaining AC search. compared
6. Puzzles 66-1010 correspond square grids blank squares.

667

fiSamaras & Stergiou

performance two MAC algorithms; one uses AC-2001 enforce AC (MAC2001), another uses PW-AC enforce AC (MAC-PW-AC). compared
algorithms algorithm maintains GAC non-binary representation
using GAC-2001 (MGAC-2001), MAC algorithms maintain AC double
encoding using PW-AC (algorithm MAC-PW-ACd) AC-2001 (algorithm MAC-2001d).
6.2.1 Random Problems
rst give indicative results comparison various algorithms using
random problems. Figure 7 compares time required enforce AC DE
GAC non-binary representation, Figures 8-10 compare algorithms
maintain consistencies.
Figure 7 shows average cpu times (in msecs) PW-AC AC-2001 take
enforce AC DE 100 random CSPs 50 variables domain size 30, ternary
constraints, 0.3 graph density (58 constraints). include average time GAC2001 takes enforce GAC non-binary representation generated instances.
looseness constraints varied starting point instances GAC
GAC AC DE delete values. signicant dierence
performance PW-AC compared AC-2001 constantly rises looseness
constraints becomes higher. expected, since number allowed tuples
constraint grows, AC-2001 takes time nd supports. GAC-2001 faster
PW-AC (up one order magnitude) looseness low, dierence
becomes smaller looseness grows.
Figure 8 shows cpu times relatively sparse class problems 30 variables
40 ternary constraints (p = 1). Figure 9 shows cpu times node visits denser class
30 variables 203 ternary constraints (p = 5). Along x-axis vary domain
size variables. data points show average cpu times (in secs) 100 instances
taken hard phase transition region.
make following observations: 1) MAC-PW-AC MAC-PW-ACd signicantly faster (one order magnitude) MAC-2001 MAC-2001d, respectively,
classes problems. 2) classes, non-binary representation preferable DE (MGAC-2001 two orders magnitude faster denser class).
sparser class, MAC double encoding (i.e. algorithm MAC-PW-ACd) competitive
MGAC-2001 small domain sizes, considerably faster larger domain sizes.
eect domain size relative performance algorithms mainly due
run time advantage PW-AC compared GAC-2001, higher consistency
level achieved double encoding7 . run time advantage PW-AC explained
considering that, domain size increases, GAC-2001 check increasing number
tuples supports; operation costly counter updates PW-AC.
denser class MGAC-2001 constantly faster algorithms domain
sizes. surprising considering O(e3 dk ) O(ekdk ) complexities PW-AC
GAC-2001 (i.e. factor e becomes signicant).
Figure 10 compare algorithms MGAC-2001 MAC-PW-ACd (the faster among
algorithms encodings) class problems 20 variables 48 4-ary
7. verified looking node visits two algorithms.

668

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

10000

10000
cpu time (secs)

1000
cpu time (msecs)

100000

AC-2001
PW-AC
GAC-2001

100

10

1

1000
100
10
1

0.1

0.1
0

0.005

0.01

0.015
q

0.02

0.025

0.03

0

100000

10

15

20

25

Figure 8: < 30, , 3, 1, > CSPs.
100000

MAC-2001
MAC-AC2001d
MAC-PW-AC
MAC-PW-ACd
MGAC-2001

MGAC-2001
MAC-PW-ACd

10000
cpu time (secs)

10000

5



Figure 7: < 50, 30, 3, 0.3, > CSPs.

cpu time (secs)

MAC-2001
MAC-2001d
MAC-PW-AC
MGAC-2001
MAC-PW-ACd

1000
100
10

1000

100

10

1
0.1

1
0

5

10


15

20

0

5

10

15

20

25



Figure 9: < 30, , 3, 5, > CSPs.

Figure 10: < 20, , 4, 1, > CSPs.

constraints. algorithms encodings competitive class
problems. see MGAC-2001 ecient small domain sizes,
larger domain sizes MAC-PW-ACd one order magnitude faster. However,
denser classes problems results reversed.
experiments random problems conjecture double encoding
preferred model sparse problems, provided ecient algorithm
PW-AC used propagation. CSPs medium high density non-binary
representation preferable encodings.
Random Problems Added Structure experiments ternary CSPs
detect advantage DE compared non-binary representation
(and consequently HVE). MAC DE rarely better MGAC-2001 (only
cases tight constraints large domain sizes), despite use PW-AC
propagation. Also, MAC-PW-ACd competitive often faster MGAC2001 sparse random problems, result reversed density increases. basic
reason results randomly generated problems (especially ones ternary
constraints) get many pairs non-binary constraints share one original
variable. known (see Bacchus et al., 2002 example) pair
constraints, ltering achieved AC DE ltering achieved
GAC non-binary representation (and AC HVE). Therefore, AC DE
looses much ltering power.
669

fiSamaras & Stergiou

validate conjecture, experimented generation model structure
added purely random problems. precise, experimented problems
clique variables embedded randomly generated instance. ternary problems
two constraints clique may share one two variables. decided random.
4-ary problems two constraints clique may share one, two, three variables.
Again, decided random. Table 3 compares performance various MAC
algorithms < 30, 10, 3, 5, > < 20, 10, 4, 1, > problems type. second
class include results MAC-PW-ACd, far best algorithm
problems, MGAC-2001.
arity clique size MGAC-2001 MAC-2001 MAC-PW-AC MAC-2001d MAC-PW-ACd
3
0
633.50
45303.76
9205.95
7549.61
1362.31
3
10
874.07
21007.45
5349.55
3078.45
421.07
3
20
1121.39
1932.49
389.22
392.08
65.81
3
30
1598.87
374.03
48.22
102.30
5.02
4
0
90.11
106.04
4
10
247.18
61.12
4
20
8348.92
322.86
Table 3: Average cpu times MAC algorithms DE double encoding
MGAC non-binary representation random problems embedded
cliques. times seconds. number gives average 50 instances
around phase transition region.
see, comparative results algorithms vary according size
embedded clique. clique embedded (clique size=0) MGAC-2001
faster algorithms binary encodings. clique size grows, binary
encodings, especially double, become ecient. double encoding
eective DE clique sizes. large clique covers variables, MAC
double encoding many orders magnitude faster MGAC-2001. huge
dierence caused presence many constraints share one variable
non-binary representation. cases ltering constraints dual
variables strong. However, much advantage lost generic algorithms
used encodings. Similar results occur denser problems generation
model used.
6.2.2 Crossword Puzzles
Table 4 compares cpu times two MAC algorithms DE MGAC
non-binary representation using various benchmark crossword puzzles. include
results MAC double encoding since particular representation crossword
puzzle generation problems impractical. reason pair dual
variables involved constraint, two variables one original variable
common (i.e. letter two words intersect). explained previously,
670

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

degrades ltering achieved constraints dual variables. constraints
double encoding redundant since ltering achieved
constraints dual original variables.

puzzle
15.02
15.04*
15.07
15.09
19.01
19.02
19.08
21.02
21.03
21.08
21.09
66
77*
88*
99*
1010*

n
80
76
74
82
128
118
134
130
130
150
144
12
14
16
18
20

e MGAC-2001 MAC-2001 MAC-PW-AC
191
3.98
164.04
13.70
193
40.84
895.29
140.65
193
94.65


187
0.43


301
1.50


296
34.62

1028.17
291

33.01
7.76
295
2.29
77.51
11.82
295
345.96
273.87
40.57
365


9.96
366


8.87
36
9.39
98.49
6.04
49
14m

12m
64
6m

9m
81


128.92
100
11.81
474.54
22.78

Table 4: Comparison (in cpu time) MAC algorithms DE MGAC
non-binary representation crossword puzzles. times seconds except
followed (minutes). cpu limit 2 hours. Problems marked
(*) insoluble. include problems reasonably hard either
MGAC-2001 MAC-PW-AC time solvable within 2 hours
least one algorithm.

data Table 4 clearly see MAC-PW-AC signicantly faster
MAC-2001 instances. speedup oered use PW-AC makes MAC
DE competitive MGAC many cases using generic algorithm
DE results clear advantage favor MGAC. Also, instances (e.g. puzzles
21.03, 21.08, 21.09), use PW-AC makes MAC DE considerably faster
MGAC. However, still instances MGAC (and consequently MHAC)
nds solution (or proves insolubility) fast, MAC DE thrashes, vice versa.
Note, 4 10 hard 2121 puzzles tried solved
algorithm within time limit two hours. MAC-PW-AC managed solve 4
instances relatively fast, two algorithms solved 2 within
cpu limit.
671

fiSamaras & Stergiou

6.3 Experiments Realistic Problems
next sections present experimental results conguration frequency assignment problems. aim experiments investigate usefulness binary
encodings realistic structured domains. focus dual double encodings
promising binary encodings strong propagation oer.
6.3.1 Configuration
Conguration area CSP technology particularly eective. conguration problem viewed trying specify product dened set attributes,
attribute values combined predened ways. problems
modelled CSPs, variables correspond attributes, domains variables
correspond possible values attributes, constraints specify predened
ways values combined. many conguration problems constraints
expressed extensionally lists allowed (or disallowed) combinations values. Alternatively, constraints expressed rules easily transformed
extensional representation. Consider following example adapted paper
Subbarayan, Jensen, Hadzic, Andersen, Hulgaard & Moller (2004).
Example 6.1 conguration T-shirt requires specify size (small,
medium, large), print (Men Black - MIB Save Whales - STW),
color (black, white, red). following constraints: 1) small size chosen
STW print cannot selected. 2) MIB print chosen black color
chosen well, STW print chosen black color cannot selected.
conguration problem modelled CSP three variables {x1 , x2 , x3 } representing size, print, color respectively. domains variables D(x1 ) =
{small, medium, large}, D(x2 ) = {M IB, ST W }, D(x3 ) = {black, white, red}.
rst constraint binary constraint variables x1 x2 following allowed
tuples: {< small, IB >, < medium, IB >, < medium, ST W >, < large, IB >, <
large, ST W >}. second constraint binary constraint variables x2 x3
following allowed tuples: {< IB, black >, < ST W, white >, < ST W, red >}.
practice, many solvers conguration problems able interact user
that, apart meeting given specications, users choices values certain
attributes satised. study use conguration instances compare
non-binary representation binary encodings structured realistic problems. Although
would interesting investigate applicability binary encodings interactive
congurator, work outside scope paper.
run experiments problems taken CLib, library benchmark conguration problems (CLib, 2005). rst thing noticed encoding problems
binary non-binary CSPs trivially solvable algorithms without
backtracking. closer look structure CLibss problems revealed reason;
constraint graphs consist various unconnected components. component consists
or, cases, single variable. result, problems split independent subproblems trivially solved algorithms. order obtain dicult
instances benchmarking, made graphs connected adding randomness.
672

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

problems extended adding 6 variables 8-10 constraints
graph became connected8 . Table 5 shows total number variables
constraints modied problems. added constraints arity 2, 3, 4 (chosen
random) variables posted selected random, making
sure resulting graph connected. looseness added constraint
set random, nally, allowed tuples constraint chosen random
according looseness.

problem n

e arity dom

machine
fx
fs
esvs
bike

22
21
18
20
28

30
24
29
33
43

4
5
6
5
6

9
44
51
61
37

MGAC-2001
MAC-PW-AC MAC-PW-ACd
nodes - time
nodes - time
nodes - time
535874 - 13.83
813 - 0.37
3367 - 1.64
193372 - 4.10
92 - 0.01
70 - 0.01
618654 - 30.43
41 - 0.03
193 - 0.05
9960160 - 332.52
7384 - 3.09
64263 - 29.86
21098334 - 501.85 16890 - 12.23 112957 - 87.77

Table 5: Comparison algorithms conguration problems. arity dom
maximum constraint arity maximum domain size problem. Run times
given seconds.

Table 5 gives average run times node visits algorithms MGAC-2001
non-binary representation, MAC-PW-AC DE, MAC-PW-ACd double
encoding. benchmarks repeatedly generated instances using
model described above. generated instance solved three algorithms
stored instance hard least one algorithm. Otherwise, discarded.
instance considered hard least one algorithm took one second
solve it. Table 5 reports averages rst 50 hard instances generated
benchmark. is, run 250 hard instances total. Note binary encodings
constraints original problem (even binary ones) encoded dual variables.
experimental results Table 5 show signicant advantage favor
binary encodings compared non-binary representation, node visits run
times. DE clearly ecient model. MAC-PW-AC DE
three orders magnitude faster MGAC-2001 non-binary representation.
single instance among 250 instances MGAC-2001 faster
MAC-PW-AC. double encoding much ecient non-binary
representation. main factor contributing performance encodings
strong propagation achieved constraints dual variables,
reected numbers node visits. number reasons, related
structure conguration problems, justify strong performance
encodings:
8. Experiments showed minimum additions need made order get hard
problems without altering structure problems much.

673

fiSamaras & Stergiou

constraint graphs sparse. typical conguration problems since,
usually, attribute product specication dependencies
attributes.
constraints high arity tight. Moreover, value variables
large domain sizes (typically one) supporting tuple constraints
variables participate.
intersecting non-binary constraints one original variable
common. explained, demonstrated empirically Section 6.2,
signicant impact propagation power AC dual double encodings.
Note prole conguration problems, analyzed above, agrees conjectures made based results random problems. is, dual double
encodings suitable sparse problems tight constraints, intersecting constraints may share one variable.
6.3.2 Frequency Assignment
Frequency assignment important problem radiocommunication industry.
problem radio communications network given region consisting
set transmitters. transmitter position region, frequency spectrum,
certain power, directional distribution. aim assign values
properties transmitters certain criteria satised. various
types frequency assignment problems. study consider version radio
link frequency assignment problem (RLFA). problem given set links
{L1 , . . . , Ln }, consisting transmitter receiver. link must assigned
frequency given set F . time total interference receivers must
reduced acceptable level using frequencies possible. problems
typically optimization problems purposes study treat
satisfaction problems.
RLFA problem modelled CSP transmitter corresponds
variable. domain variable consists frequencies assigned
corresponding transmitter. interferences transmitters modelled
binary constraints form |xi xj | > s, xi xj variables 0
required frequency separation. constraint restricts frequencies two
transmitters simultaneously assigned, way interference
minimized. realistic assumption closer two frequencies
greater interference them. binary model used extensively
represent RLFA problems, numerous solution methods (CSP-based other)
proposed. Also, RLFA widely used benchmark test new algorithms
binary constraints (mainly AC algorithms).
argued standard binary model frequency assignment problems
fails capture important aspects real problems, multiple interferences,
resulting non-optimal frequency assignments (Jeavons, Dunkin, & Bater, 1998; Watkins,
Hurley, & Smith, 1998; Bater, 2000; Hodge, Hurley, & Smith, 2002). consequence,
eorts introduce expressive methods utilize non-binary
674

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

constraints frequency assignment (e.g. Bater, 2000; Hodge et al., 2002). many
types non-binary constraints considered. following ones received
attention:
co-channel constraints - e.g., frequencies assigned n transmitters equal.
adjacent-channel constraints - e.g., frequencies assigned n transmitters
least one frequency apart.
separation constraints - e.g., frequencies assigned n transmitters least
frequencies apart.
Obviously, separation constraints generalize adjacent-channel constraints. rst
two types constraints typically loose third tight. Separation
constraints used densely constrained areas (representing conurbations region)
large number links closely situated. cases, large separations
frequencies transmitters must imposed, resulting tight constraints.
consider richer type separation constraints: frequencies assigned set n
transmitters least frequencies apart n transmitters among least
(> s) frequencies apart others. Note non-binary constraints
equivalently decomposed clique binary constraints (without introducing
dual variables) resulting however weaker propagation. example adjacent-channel
constraints. Others cannot equivalently expressed set binary constraints unless
binary encoding used. example, co-channel constraints. noted Hodge et al.
(2002), non-binary constraints low arity utilized practice.
shown many cases constraints sucient achieve low interferences.
Constraints higher arity may oer improvements quality solutions, tend
slow solution process extend solving large real problems becomes
infeasible.
empirical study presented interested comparing models RLFAtype problems non-binary constraints corresponding binary encodings
devising new ecient methods solving RLFA problems. Since available RLFA
benchmarks follow standard binary approach, test algorithms generated nonbinary problems placing variables, corresponding links, grid following typical
RLFA structure. is, problems consist several groups closely situated variables
plus constraints connect groups. example, structures depicted
Figure 11. corresponds constraint graph binary RLFA problem
typically consists set cliques (or near-cliques) binary constraints small number
constraints connecting various cliques (e.g. benchmarks Cabon, De Givry,
Lobjois, Schiex, & Warners, 1999). binary encodings considered
double since dual variables large domains, makes DE inecient.
Indicative results experiments run depicted Table 6. experiments
posted low-arity (i.e. 3-ary 5-ary) separation constraints, shown Figure 11,
compared performance algorithm MGAC-2001 non-binary model
problems performance MAC-PW-ACd double encoding problems.
tried two implementations MGAC-2001; one utilizes specialized propagators
675

fiSamaras & Stergiou

a) prob1

b) prob2

c) prob3

Figure 11: Examples RLFA problems non-binary separation constraints.

separation constraints (written functions), another operates extensional
representation constraints. rst implementation generally faster,
results MGAC-2001 presented refer intentional implementation. double
encoding built translating separation constraints lists allowed tuples
preprocessing step.

problem
prob1
prob1
prob1
prob2
prob2
prob2
prob3
prob3
prob3
prob4
prob4
prob4
prob5
prob5
prob5

(easiest)
(median)
(hardest)
(easiest)
(median)
(hardest)
(easiest)
(median)
(hardest)
(easiest)
(median)
(hardest)
(easiest)
(median)
(hardest)

n
48
48
48
44
44
44
54
54
54
68
68
68
100
100
100

e arity
25
25
25
21
21
21
24
24
24
38
38
38
58
58
58

4
4
4
4
4
4
5
5
5
5
5
5
5
5
5

MGAC-2001
MAC-PW-ACd
nodes - time
nodes - time
583 - 1.51
48 - 0.36
18161268 - 39518.71
50 - 0.34


56474 - 26.46
172071 - 219.06
304676 - 169.01
305588 - 504.06
53654514 - 4220.21 68771412 - 24133.45
103 - 13.45
0 - 6.42
2134 - 14.14
2569 - 53.18
4194 - 115.12
0 - 5.64
70 - 1.21
72 - 7.24

90 - 8.34


294 - 5.29
0 - 2.42
96106 - 522.64
99 - 2.81

104 - 13.45

Table 6: Comparison algorithms RLFA problems separation constraints. arity
maximum constraint arity. Run times given seconds. dash ()
placed wherever algorithm nish run within 12 hours cpu time.

676

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

Table 6 reports results total 50 instances created using dierent constraint
graph topologies. variables domains 20 25 values. number allowed
tuples constraints varied around 50 tight constraints several thousands looser ones, according frequency separation imposed parameters
separation constraints. parameters set random constraint,
making sure loose constraints generated. example, 4-ary basic
separation constraint variables domain size 20, least 3 (giving 7920 allowed
tuples) 5 (giving 120 allowed tuples).
prob1, prob2, prob3 refer problems topologies shown Figure 11.
prob4 consists three groups variables, similar ones prob3, arranged
chain-like structure. Finally, instances prob5 consist randomly generated groups
variables; one 8-10 variables 3-5 3-ary 5-ary constraints. groups
interconnected according topological distance (i.e. constraints posted
variables nearby groups). instances prob1-prob4 xed topology.
topology set instances created changing type constraints. example,
two instances topology prob1 may dier type separation constraints
(basic richer) include. Also, frequency separations imposed
constraint may dier. Instances prob5 may dier constraint graph topology.
report node visits run times easiest, median, hardest instance
topology, respect performance MGAC9 . hardest instances
encoding non-binary representation (except prob3), easiest
median instances sometimes dierent.
Table 6 see substantial dierences favor
double encoding. Many instances solvable double encoding
little backtracking MGAC-2001 thrashed. mainly due large number
interleaved constraints sharing one variable, boosts propagation
double encoding. performance algorithms seems heavily dependent
topology problems. example, instances prob2 non-binary representation
much ecient double encoding. seems particular class
problems heuristic choices misled propagation achieved double encoding.
able come satisfactory explanation occurred
particular topology.
Finally, investigate eect presence loose constraints higher arity
has, run experiments 8-ary adjacent-channel constraints posted
variables apart graph, addition separation constraints.
case using double encoding model constraints problems infeasible
due spatial requirements. example, trying generate allowed tuples
single 8-ary adjacent-channel constraint consumed memory system. Therefore,
compared algorithm MGAC-2001 non-binary model MAC algorithm
runs hybrid model tight separation constraints modelled using
double encoding loose adjacent-channel constraints kept intentional nonbinary representation. Table 7 reports results total 30 instances created using
9. create instances varied type constraints values parameters
non-trivial problems generated. consider trivial problems arc inconsistent solvable
backtracking.

677

fiSamaras & Stergiou

problem
prob1
prob1
prob1
prob2
prob2
prob2
prob5
prob5
prob5

(easiest)
(median)
(hardest)
(easiest)
(median)
(hardest)
(easiest)
(median)
(hardest)

n
48
48
48
44
44
44
100
100
100

e arity
25
25
25
21
21
21
58
58
58

8
8
8
8
8
8
8
8
8

MGAC-2001
MAC-hybrid
nodes - time
nodes - time
106 - 20.88
50 - 47.60
5078 - 1201.98
84 - 195.43


647 - 192.64
1019 - 308.84
80245 - 17690.12



76 - 45.92
0 - 22.19
22785 - 3230.47
99 - 78.41

18447 - 4233.50

Table 7: Comparison algorithms RLFA problems separation adjacentchannel constraints. MAC-hybrid corresponds MAC algorithm runs
hybrid model.

graph topologies prob1, prob2 prob5 addition four 8-ary adjacent-channel
constraints instance. hybrid model ecient instances prob1
prob5 strong propagation achieved binary encoding tight
constraints. non-binary model better instances prob2 seems
propagation binary encoding results bad heuristic choices.
6.4 Discussion
section summarize results experimental studies draw conclusions regarding applicability encodings, based theoretical experimental
analysis.
Hidden Variable Encoding theoretical results suggested, empirical results conrmed, solving problems HVE using algorithms instantiate original variables
essentially analogous solving non-binary representation directly. commonly
used algorithms non-binary problems applied, adjustments, HVE,
vice versa. algorithms used, HVE oers (moderate) computational
savings compared non-binary representation, especially sparse problems.
savings due ability AC algorithm HVE detect inconsistencies earlier corresponding GAC algorithm non-binary representation. Therefore,
conjecture HVE applicable sparse non-binary problems constraints
extensionally specied. cases, HVE either less ecient run times
non-binary representation (e.g. dense problems), building HVE adds space
overheads justied marginal gains search eort. Additionally,
enough empirical evidence suggest essential dierence search
algorithms HVE non-binary representation, i.e. ability former
branch dual variables, make HVE signicantly ecient class
678

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

problems. This, coupled fact benets gained instantiating dual
variables maximized double encoding used instead HVE, limits
applicability algorithms.
Dual Double Encodings DE double encoding advantage
strong ltering constraints dual variables. showed
advantage exploited low cost specialized algorithm, PW-AC, make
DE competitive often signicantly better non-binary representation
several sparse CSPs, crossword puzzle generation conguration problems.
dense CSPs, DE pay either spatial requirements make use
infeasible, case, advantages oered outweighed overhead
updating domains dual variables. holds CSPs containing constraints
large arity unless tight (as crossword puzzles).
Algorithms double encoding demonstrate especially promising performance.
many non-binary constraints share one variable present
problem MAC double encoding exploit benets variable
ordering heuristic, borrowed non-binary representation, stronger ltering,
borrowed DE, outperform representations. demonstrated
problems structure (random frequency assignment - like).
case still-life problem, explains success double encoding10 .
addition, double encoding oers interesting potential hybrid models certain
constraints encoded binary others kept non-binary representation
based certain properties constraints. precise benet encoding
constraints either naturally specied extension, relatively low arity
tight. demonstrated various domains. notably, frequency assignment problems double encoding (or hybrid one) payed cases,
although constraints problems naturally dened intentionally.

7. Related Work
Although, DE proposed 1989 (Dechter & Pearl, 1989) HVE 1990 (Rossi
et al., 1990), rst substantial eort towards evaluating eciency carried
1998 (Bacchus & van Beek, 1998). work, Bacchus van Beek compared theoretically empirically FC algorithm two encodings FC non-binary
CSPs. Also, introduced FC+, specialized algorithm HVE. algorithms
compared Bacchus van Beek simplest versions FC; hFC0 hFC1 (i.e.
FC+) HVE, nFC0 non-binary representation. extend work
studying various recent advanced versions FC.
Following Bacchus van Beek (1998), Stergiou Walsh made theoretical
empirical study AC encodings (Stergiou & Walsh, 1999). proved AC
HVE equivalent GAC non-binary representation, AC DE
stronger. small experimental study included paper Stergiou & Walsh (1999),
MAC HVE, DE, double encoding compared MGAC non-binary
10. Although title Smiths paper (2002) refers DE, model still-life problem used
based double encoding.

679

fiSamaras & Stergiou

representation crossword puzzles Golomb rulers problems. Results showed
advantage non-binary representation HVE, important note
MAC algorithms used generic inecient algorithms enforce AC.
Smith, Stergiou & Walsh (2000) performed extensive experimental comparison
MAC HVE double encoding, MGAC non-binary model
Golomb rulers problem. However, MAC algorithms encodings used generic
algorithm enforce AC. result outperformed MGAC non-binary
model.
Beacham et al. (2001) compared performances dierent models, heuristics,
algorithms CSPs using crossword puzzle generation problems benchmarks. Among
models compared HVE, DE non-binary representation.
again, algorithms applied encodings generic algorithms.
example, two implemented algorithms DE MAC uses AC-3
propagation MAC uses AC-7. algorithms suer high complexity AC propagation. demonstrated, use algorithm PW-AC propagation
signicantly enhance performance MAC crossword puzzle problems.
Bacchus et al. (2002) presented extensive theoretical study DE HVE.
Among results, polynomial bounds placed relative performance FC
MAC two encodings non-binary representation, shown
polynomial bound exists. example, shown FC HVE (i.e. hFC0
terminology use) never polynomial factor worse FC DE,
FC DE exponentially worse FC HVE. Also, FC non-binary
representation (i.e. nFC0 terminology use) exponentially worse FC
HVE, vice versa. add results analyzing performance various
advanced algorithms HVE double encoding.
Smith modelled problem nding maximum density stable pattern still-life
Conways game Life using MAC double encoding remarkable success,
compared constraint programming integer programming approaches (Smith,
2002). MAC algorithm implemented using Table constraint ILOG Solver.
constraint implements generic AC algorithm Bessiere & Regin (1996a),
expensive used DE high time complexity. believe
results presented Smith improved MAC-PW-AC used instead.

8. Conclusion
paper studied three binary translations non-binary CSPs; hidden variable
encoding, dual encoding, double encoding. showed common perception standard algorithms binary CSPs used encodings non-binary
CSPs suers aws. Namely, standard algorithms exploit structure encodings, end inecient. address problem, proposed specialized arc
consistency search algorithms encodings, evaluated theoretically
empirically. showed arc consistency enforced hidden variable
encoding non-binary CSP worst-case time complexity generalized arc
consistency non-binary representation. showed structure constraints
dual encoding exploited achieve much lower time complexity
680

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

generic algorithm. Empirical results demonstrated use specialized algorithm
makes dual encoding signicantly ecient. showed generalized search
algorithms non-binary CSPs relatively easily adjusted operate hidden
variable encoding. showed various algorithms double encoding
designed. algorithms exploit properties double encoding (strong ltering branching original variables) achieve good results certain problems.
Empirical results random structured problems showed that, certain classes
non-binary constraints, using binary encodings competitive option, many cases,
better one solving non-binary representation.

Acknowledgements
would thank Panagiotis Karagiannis, Nikos Mamoulis, Toby Walsh
help various stages work. would thank anonymous reviewers
earlier version paper useful comments suggestions.

Appendix
explained, main dierence AC algorithm HVE corresponding GAC algorithm fact AC algorithm update domains
dual variables well original ones. incurs time overhead,
show, deleting values dual variables help propagation discover domain wipe-outs
arc inconsistent problems faster.
Proposition 8.1 Let P non-binary CSP. Assume generalized arc consistency applied P , domain wipeout resulting problem. Enforcing arc
consistency hidden variable encoding P using HAC requires number
consistency checks enforcing generalized arc consistency P using GAC-2001, assuming two algorithms follow ordering variables values looking
supports propagating deletions.
Proof: First, consider domain wipeout variable (original dual) occurs
two algorithms add constraints (dual variables) stack remove
revision exactly order. Therefore, need show
value deleted variable revision constraint nds new support
constraint operations require number checks
representations. Assume non-binary version algorithm value deleted
domain variable xi support constraint c. |T |
number allowed tuples c determining lack support require |T |
currentSupportxi,a,c checks, one tuples c checked yet.
value deleted nds new support , > currentSupportxi,a,c ,
currentSupportxi,a,c checks performed. HVE, xi processed
order non-binary version require |T | currentSupportxi,a,vc
currentSupportxi,a,vc checks depending case. Obviously, currentSupportxi ,a,c
currentSupportxi ,a,vc since tuple c corresponds value vc ,
therefore, number checks performed representations. 2
681

fiSamaras & Stergiou

Proposition 8.2 Let P non-binary CSP. Assume application generalized
arc consistency P results domain wipeout. Algorithm HAC applied hidden
variable encoding P discovers domain wipeout number
consistency checks algorithm GAC-2001 non-binary representation, assuming
two algorithms follow ordering variables values looking supports
propagating deletions.
Proof: CSP, arc inconsistency detected domain variable wiped
applying AC. HVE non-binary CSP, arc inconsistency detected
domain original variable wiped (crucially) domain dual
variable wiped out. second possibility make AC algorithm operates
HVE ecient corresponding GAC algorithm. prove consider
arc inconsistent non-binary problem. Assume domain original variable xi
wiped processing constraint c encoded dual variable vc
HVE. point function Revise called xi c arguments,
inconsistency according Proposition 8.1 GAC algorithm
AC algorithm HVE perform number consistency checks. Assume
j values left D(xi ) call Revise. function Revise
unsuccessfully look support j values. |T | number allowed
tuples c then, value D(xi ), require |T | currentSupportxi,a,c checks
GAC algorithm |T | currentSupportxi ,a,vc checks AC algorithm. Since
|T | currentSupportxi ,a,c = |T | currentSupportxi,a,vc , two algorithms perform
number consistency checks detect domain wipeout.
following example demonstrates HAC may discover inconsistency less
checks. Consider problem variables x1 , x2 , x3 , x4 domains {0, 1}, {0, 1},
{0, . . . , 9}, {0, 1}, respectively. two constraints, c1 c2 , vars(c1 ) =
{x1 , x2 , x3 } vars(c2 ) = {x1 , x2 , x4 } respectively. Value 0 x2 supported c1
tuples include assignment (x1 , 1). Value 0 x1 supported c2 tuples
include assignment (x2 , 0). Constraint c2 allows tuples include assignment
(x2 , 0). Values 0, . . . , 9 x3 supported c1 tuples include (x2 , 0) tuples
include (x2 , 1). assume variable x1 instantiated 0, means
deletion 1 D(x1 ) must propagated. HVE, rst delete
tuples include value (x1 , 1) dual variables vc1 vc2 . Then, add dual
variables vc1 vc2 stack, remove them, revise original variables connected
them. Assuming vc1 removed rst, value 0 x2 support vc1
deleted. result, delete tuples dual variable vc2 include
pair (x2 , 0). means domain vc2 wiped out. non-binary
representation, proceed similar way perform number checks
0 deleted x2 . deletion algorithm look supports c1
value 1 x2 values x3 . involve checks avoided HVE.
inconsistency discovered later process constraint c2 nd
value 1 x2 support c2 resulting domain wipeout x2 . 2

682

fiBinary Encodings Non-binary CSPs: Algorithms & Experimental Results

References
Bacchus, F., Chen, X., van Beek, P., & Walsh, T. (2002). Binary vs. Non-binary CSPs.
Artificial Intelligence, 140, 137.
Bacchus, F., & van Beek, P. (1998). Conversion Non-binary Binary
Constraint Satisfaction Problems. Proceedings AAAI98, pp. 310318.
Bater, J. (2000). Non-binary (Higher-Order) Modelling Solution Techniques Frequency Assignment Mobile Communications Networks. Ph.D. thesis, University
London.
Beacham, A., Chen, X., Sillito, J., & van Beek, P. (2001). Constraint programming lessons
learned crossword puzzles. Proceedings 14th Canadian Conference
AI.
Bessiere, C., Freuder, E., & Regin, J. (1995). Using Inference Reduce Arc Consistency
Computation. Proceedings IJCAI95, pp. 592599.
Bessiere, C., Meseguer, P., Freuder, E., & Larrosa, J. (2002). Forward Checking
Non-binary Constraint Satisfaction. Artificial Intelligence, 141, 205224.
Bessiere, C., & Regin, J. (1996a). Arc Consistency General Constraint Networks: Preliminary Results. Proceedings IJCAI97, pp. 398404.
Bessiere, C., & Regin, J. (1996b). MAC Combined Heuristics: Two Reasons Forsake
FC (and CBJ?) Hard Problems. Proceedings CP96, pp. 6175.
Bessiere, C., & Regin, J. (2001). Rening Basic Constraint Propagation Algorithm.
Proceedings IJCAI2001, pp. 309315.
Cabon, B., De Givry, S., Lobjois, L., Schiex, T., & Warners, J. (1999). Radio Link Frequency
Assignment. Constraints, 4, 7989.
CLib (2005). Conguration Benchmarks Library (http://www.itu.dk/doi/VeCoS/clib/),
Maintained VeCoS group, IT-University Copenhagen.
Debruyne, R., & Bessiere, C. (2001). Domain Filtering Consistencies. Journal Artificial
Intelligence Research, 14, 205230.
Dechter, R., & Pearl, J. (1989). Tree Clustering Constraint Networks. Artificial Intelligence, 38, 353366.
Ginsberg, M., Frank, M., Halpin, M., & Torrance, M. (1990). Search Lessons Learned
Crossword Puzzles. Proceedings AAAI-90, pp. 210215.
Haralick, R., & Elliot, G. (1980). Increasing Tree Search Eciency Constraint Satisfaction Problems. Artificial Intelligence, 14, 263313.
Hodge, L., Hurley, S., & Smith, D. (2002). Higher-Order Constraint Techniques
Frequency Assignment Problem. Tech. rep., University Cardi.
Jeavons, P., Dunkin, N., & Bater, J. (1998). Higher Order Constraints Necessary
Model Frequency Assignment Problems. ECAI98 Workshop Non-binary
constraints.
Mackworth, A. (1977). Consistency Networks Relations. Artificial Intelligence, 99118.
683

fiSamaras & Stergiou

Mamoulis, N., & Stergiou, K. (2001). Solving Non-Binary CSPs using Hidden Variable
Encoding. Proceedings CP-2001, pp. 168182.
Mohr, R., & Henderson, T. (1986). Arc Path Consistency Revisited. Artificial Intelligence, 28, 225233.
Mohr, R., & Masini, G. (1988). Good Old Discrete Relaxation. Proceedings ECAI-88,
pp. 651656.
Peirce, C. (1933) Collected Papers Vol. III. Cited F. Rossi, C. Petrie, V. Dhar 1989.
Prosser, P., Stergiou, K., & Walsh, T. (2000). Singleton Consistencies. Proceedings
CP-2000, pp. 353368.
Regin, J. (1994). Filtering Algorithm Constraints Dierence CSPs. Proceedings
AAAI-94, pp. 362367.
Rossi, F., Petrie, C., & Dhar, V. (1990). Equivalence Constraint Satisfaction
Problems. Proceedings ECAI-90, pp. 550556.
Smith, B. (2002). Dual Graph Translation Problem Life. Proceedings
CP-02, pp. 402414.
Smith, B., Stergiou, K., & Walsh, T. (2000). Using Auxiliary Variables Implied Constraints Model Non-binary Problems. Proceedings AAAI2000, pp. 182187.
Stergiou, K., & Walsh, T. (1999). Encodings Non-Binary Constraint Satisfaction Problems. Proceedings AAAI99, pp. 163168.
Subbarayan, S., Jensen, R., Hadzic, T., Andersen, H., Hulgaard, H., & Moller, J. (2004).
Comparing two Implementations Complete Backtrack-Free Interactive Congurator. Proceedings CP-04 Workshop CSP Techniques Immediate
Application, pp. 97111.
Van Hentenryck, P. (Ed.). (1989). Constraint Satisfaction Logic Programming. MIT
Press.
Van Hentenryck, P., Deville, Y., & Teng, C. (1992). Generic Arc Consistency Algorithm
Specializations. Artificial Intelligence, 57, 291321.
Watkins, W., Hurley, S., & Smith, D. (1998). Area Coverage Frequency Assignment: Evaluation Models Area Coverage. Tech. rep., University Glamorgan. presented
INFORMS-98.
Zhang, Y., & Yap, R. (2001). Making AC-3 Optimal Algorithm. Proceedings
IJCAI2001, pp. 316321.

684


