journal artificial intelligence

submitted published

ignoring delete lists works
local search topology benchmarks
jorg hoffmann

hoffmann mpi sb mpg de

max planck institute computer science
stuhlsatzenhausweg
saarbrucken
germany

abstract
community seen vast progress terms
sizes benchmark examples domain independent planners tackle successfully
key technique behind progress use heuristic functions relaxing
task hand relaxation assume delete lists empty
unprecedented success methods many commonly used benchmark examples
calls understanding classes domains methods well suited
investigation hand derive formal background understanding perform case study covering range commonly used strips adl
benchmark domains including examples used first four international
competitions prove connections domain structure local search topology
heuristic cost surface properties idealized version heuristic functions
used modern planners idealized heuristic function called h differs
practically used functions returns length optimal relaxed plan
np hard compute identify several key characteristics topology h concerning existence non existence unrecognized dead ends well
existence non existence constant upper bounds difficulty escaping local minima
benches distinctions divide set domains taxonomy
classes varying h topology turns many investigated domains lie
classes relatively easy topology particularly domains lie classes
ffs search provided h polynomial solving mechanism
present relating h approximation implemented
behavior regarding dead ends provably summarize empirical investigation showing many domains topological qualities h
largely inherited approximation overall investigation gives rare example
successful analysis connections typical case structure search
performance theoretical investigation gives hints topological phenomena might automatically recognizable domain analysis techniques outline
preliminary steps made direction

introduction
one strongest trends community
towards heuristic planners specifically towards use heuristic distance
cases goal distance estimation functions best runtime progressing far beyond
sizes benchmark examples previous domain independent planners could tackle
successfully achieved upon technique phrased ignoring delete lists
c

ai access foundation rights reserved

fihoffmann

heuristic function derived considering relaxation task
hand relaxation assume delete lists e negative effects
available operators empty search may forward backward
state space plan space heuristic value search state framework
estimate difficulty extending state solution relaxed operators
difficulty defined number relaxed actions needed
number real actions needed extend search state solution least
high number relaxed actions needed optimal shortest relaxed solutions
principle used derive admissible heuristic functions however first
proved bylander deciding bounded plan existence e existence plan
given number actions np hard even delete lists
thus much hope optimal relaxed plans e optimal relaxed solutionextensions search states fast instead one approximate length optimal
relaxed plan search state techniques kind first independently proposed
mcdermott bonet loerincs geffner developed planners
unpop mcdermott hsp bonet et al planners
perform forward state space search guided approximation relaxed goal distance
unpop approximates distance backchaining goals hsp approximates
distance forward value iteration technique
st international competition ipc mcdermott hosted
aips hsp compared well four competitors inspired development hsp r hsp bonet geffner b grt refanidis
vlahavas altalt nguyen kambhampati srivastava nguyen kambhampati nambiar nie nigenda zimmermann well hoffmann
hoffmann nebel hoffmann hsp r avoids heuristic computations
changing search direction hsp implements hsp versions configurable hybrid system grt avoids heuristic computations changing heuristic
direction direction relaxed plans computed altalt uses
graph extract heuristic values uses modified technique approximating optimal
relaxed plan length namely computing necessarily optimal relaxed plan
done polynomial time well pruning search techniques inspired integration heuristic search engines mips edelkamp helmert
stan fox long elaborated variations ffs relaxed plan length
estimation technique
nd international competition ipc bacchus hosted aips heuristic planners dramatically outperformed approaches runtime wise
scaling benchmark examples far beyond reach previous e g graphplan
blum furst systems caused trend towards heuristic planners
still increase researchers extended relaxed plan distance estimation techniques
temporal numeric settings kambhampati hoffmann
edelkamp b others adapted use partial order plan space search nguyen
parallel bound number parallel time steps needed deciding bounded
plan existence easy without delete lists however heuristic functions observation
generally found provide useful search guidance practice see example haslum
geffner bonet geffner b



fiwhere ignoring delete lists works

kambhampati younes simmons developed variations provide
means heuristic guidance onaindia sapena sebastia marzal sebastia
onaindia marzal modified take exclusion relations graph
account gerevini serina gerevini serina saetti spinoni
rd international competition ipc long fox hosted
aips domain independent competing systems relaxed plan
distance estimations one form st prize winner lpg gerevini serina
gerevini saetti serina uses amongst heuristics relaxed
technique estimate difficulty sub goal achievement graph
th international competition ipc hoffmann edelkamp edelkamp
hoffmann englert liporace thiebaux trug hosted icaps
competing sub optimal systems relaxed plan heuristics
two st prize winners category fast downward helmert helmert richter
sgplan chen wah chen hsu wah latter uses
numeric version sub process one version former combines ffs heuristic
estimates heuristic function causal graph analysis helmert
investigation hand derive formal background classes domains methods kind described well suited make two simplifying
assumptions first consider forward state space search used example
unpop hsp mips fast downward forward state space search one starts
initial state explores space reachable states goal state found
state transitions follow sequential framework single action
applied time assuming forward search makes investigation easier since
search natural simple framework second simplifying assumption
idealize matters consider heuristic value given optimal relaxed plan
length length shortest sequential relaxed plan search state denote
value h assumption see many provable
connections domain structure heuristic quality course simplifying assumptions restrict relevance practical planners said
section section another benign restriction make
consider solvable tasks common restriction ai particularly
competitions main focus good planners finding plans
specifically main focus investigation hand characterize kinds
domains relaxed plan heuristic planners plans fast
common knowledge behavior heuristic search methods may
global local e without backtracking mechanisms depends crucially
quality underlying heuristic function example studied
sat community example frank cheeseman stutz work
authors empirically investigate properties local search topology e topological
properties sizes local minima etc sat instances standard heuristic
function adapt frank et al definitions ai difference frank et
al take analytical prove properties valid across
principle parallel forward search possible best authors knowledge
published work implementation time writing main difficulty
presumably high branching factor



fihoffmann

certain ranges namely domains example instances investigate range
commonly used strips adl benchmark domains including examples used
first four international competitions identify several key characteristics
topology respective search spaces h characteristics following
benchmark domains unrecognized dead ends e states
goal unreachable relaxed plan
benchmark domains maximal exit distance local
minima constantly bounded e one escape local minima regions
neighbors higher heuristic value within number steps
constant across instances domain regardless size fact
domains local minima
benchmark domains maximal exit distance benches
constantly bounded e one escape benches regions states
heuristic value within number steps constant across
instances domain regardless size domains bound one
domain even
beside positive proving characteristic qualities h function
investigation provides parameterized counter examples negative cases
divide investigated domains generally possible domains
meaningful taxonomy classes differ terms topological behavior
respect h many investigated domains lie relatively easy classes e classes
h provably high quality heuristic particularly domains
properties lie classes ffs search polynomial solving
mechanism idealizing assumption ffs approximative heuristic function
identifies real h distances ffs search called enforced hill climbing tries
escape local minima benches means breadth first search breadth first search
exponential search depth local minima benches
escaped within constant number steps case domains
effort spent search polynomially bounded way provide
non trivial insights typical case structure benchmarks possible
effects search performance examples successful theoretical investigations kind
extremely rare ai literature
give reader feeling looking figure shows two visualized
state spaces shown tasks instances two domains easiest classes
taxonomy gripper logistics graph nodes states edges state
transitions action applications height given h value pictures
initial state somewhere left top part goal states course states
minimal zero h value gripper picture speaks logistics topology
less extreme still state space forms one big valley bottom
goal states
h values empirical investigation hoffmann b b preceding theoretical
analysis computed iterative deepening forward search space relaxed action sequences



fiwhere ignoring delete lists works



b

figure visualized state space h gripper b logistics instance

course ffs approximation h refer hf f identify
real h values priori evident relevance theoretical
h ffs efficiency practice additionally forward searching planners
use enforced hill climbing topological striking
impact finally importantly several competitive planners even
perform forward search use additional techniques heuristic function
explicitly aimed identifying better information relaxed plans prominent systems
former kind hsp r lpg prominent systems latter kind lpg
fast downward
relevance performance practical performance
coincides quite well concretely behavior h respect dead
ends provably hf f moreover large scale empirical investigation
contained hoffmann b shown many domains topology h
largely preserved hf f include section containing brief summary
relevance topological forward search enforced
hill climbing performance planners search paradigms enhanced
heuristics discussed section
remark topological investigation specifically intended identify
properties relevant enforced hill climbing theoretical investigation preceded
empirical investigation hoffmann b b measured kinds
topological parameters including example size diameter local minima benches
structures called valley regions turned topology
parameters showed interesting behavior across significant number domains
maximal exit distance parameters considered investigation hand fact
came surprise us invented enforced hill climbing became clear


fihoffmann

many benchmarks share topological properties favoring precisely
particular search
observe proved worst case nature e heuristic search

h good behavior example suite domain even domain lies
difficult class taxonomy given particular example instances test
suite emphasize worst cases possible domain relevant
discuss issue regards example suites used competitions
employed proof methods give hints topological phenomena might
automatically detectable general domain analysis techniques extra section
report first yet successful attempt made
proofs individual domains cases overly difficult
full details domains extremely space consuming details except
ipc domains e pddl definitions domains well fully detailed
proofs looked long technical report hoffmann c
forms online appendix article article provides proof sketches
much better suited get overall understanding investigation
since even proof sketches sometimes hard read moved appendix
another appendix provides brief descriptions domains main body text
gives outline main proof arguments used obtain
organized follows section provides necessary background e
straightforward formal framework strips adl domains overview
investigated domains definitions local search topology section presents
core lemmas underlying many proofs single domains illustrates lemmas
application small example section gives brief proof outline
shows resulting domain taxonomy section presents relating
h hf f section reports first attempt design domain analysis techniques
automatically detecting h topological phenomena section concludes article
brief discussion contributions future work appendix contains
proof sketches individual domains appendix b contains domain descriptions

background
background necessary framework investigated domains local
search topology
framework
enable theoretical proofs properties domains rather single tasks
defined formal framework strips adl domains formalizing straightforward manner way domains usually dealt community outline
rather lengthy definitions refer reader tr hoffmann c details
follows sets mean finite sets unless explicitly said otherwise
remark tr longer version hand trs overall structure
presentation angle different intended source details needed



fiwhere ignoring delete lists works

domain defined terms set predicates set operators
possibly infinite set instances logical constructs domain
set predicates fact predicate applied tuple objects operators
k ary k number operator parameters functions infinite set
objects infinite set strips adl actions strips action
triple pre add del precondition conjunction facts add list
fact set delete list fact set adl action pair pre e
precondition pre first order logical formula without free variables e
set effects e form con e add e del e con e effect condition
formula without free variables add e effects add list well del e
effects delete list fact sets add list action effect contains fact p
say action effect achieves p
instance domain defined terms set objects initial state goal
condition initial state set facts goal condition formula without free
variables strips case conjunction facts facts contained
initial state assumed true facts contained assumed false
e usual apply closed world assumption instance domain constitutes
together domains operators task g action set
applying operators instances objects e object tuples
appropriate lengths initial state goal condition g instance
identify instances respective tasks
state set facts logical formula holds state state model
formula according standard definition first order logic logical atom
fact holds iff contained state hai applying action
sequence consisting single strips adl action state defined follows
actions precondition hold hai undefined otherwise
hai obtained including add effects thereafter removing
delete effects adl action add effects add e included
delete effects del e removed respective effect condition con e holds
applying sequence ha consisting one action
state defined iterative application single actions obvious manner
apply apply ha
plan solution task g sequence actions p
successively applied yields goal state e state g holds use
standard notation set denote set sequences elements
many proofs need notion optimality plan p task g
optimal plan g contains fewer actions p
note announced introduction definition particular definition
plan optimality stays within forward state space search framework plans
simple sequences actions note ignoring delete lists simplifies task
formulas negation free fixed domain tasks polynomially normalized
property compute negation normal form formulas negations
front facts introduce negated fact b fact b make sure
true state iff b false gazen knoblock pre process done


fihoffmann

example investigation hand considered normalized versions
domains
consider domains ipc collection feature derived predicates predicates affected effects operators truth value
instead derived values basic predicates via set derivation
rules derivation rule form x p x p derived predicate
formula rules antecedent free variables x obvious idea
x holds p x concluded little detail semantics
defined follows initial state whenever action applied first
derived predicate instances derived facts assumed false derivation rules
applied fixpoint occurs derived facts could concluded
said false called negation failure derived predicates used
predicate operator preconditions effect conditions
goal condition however ensure unique fixpoint rule application
use derived predicates derivation rule antecedents restricted context
ipc positive use sense predicates appear negated
negation normal form rule antecedent hoffmann edelkamp
make ignoring delete lists simplification one needs derived facts
used positively operator preconditions effect conditions goal condition
otherwise derived predicates example used model negated preconditions etc due negation failure semantics derived predicates isnt
simple compilation negations pure adl case take
implemented example version treats derived predicates
thiebaux hoffmann nebel simply ignore replace true negated
derived predicates negation normal form operators goal see
section
domains overview
said case study covers total commonly used strips adl benchmark domains include examples first four international competitions
plus domains used literature brief descriptions domains looked
appendix b full formal definitions domains except ipc domains
tr hoffmann c note defining domain one must amongst
things decide exactly instances naturally abstracted
known example suites cases abstraction obvious less obvious
cases respective subsection appendix b includes explanatory remarks
provide brief overview analyzed domains domains categorized three groups according semantics high level abstraction
categorization way related topological characterization derive
later use give overview structure
ignoring delete lists normalized domains comes relaxation basically allows
translated facts take truth values time



fiwhere ignoring delete lists works

transportation domains domains locations objects
must transported vehicles means transportation operators mostly move vehicle load unload object onto vehicle domains differ terms constraints important one
many domains vehicles move instantaneously two locations
domains movable links locations form arbitrary road maps
transportation domains collection look logistics classical transportation domain trucks airplanes transport objects within
cities gripper robot two gripper hands transports number balls one
time hand one room another ferry single ferry transports
cars one time driverlog trucks need drivers board order move
location links form bi directional road maps different trucks
drivers briefcaseworld briefcase moves conditional effects objects along
inside grid robot transports keys grid road map
positions locked must opened keys matching shapes miconicstrips elevator transports passengers explicit actions board deboard
passengers miconic simple miconic strips passengers board deboard
conditional effects action stops elevator floor
miconic adl miconic simple constraints must obeyed
example vips first zenotravel airplanes use fuel items replenished
one one refuel operator mprime arbitrary road map trucks use
non replenishable fuel items fuel transferred locations mystery
mprime without possibility transfer fuel airport inbound
outbound planes must moved safely across road map airport
construction domains generally closely related transportation domains construction domains common roughly
complex object must built individual parts
domains collection look blocksworld arm classical construction
domain blocks picked put stacked onto unstacked
means robot arm blocksworld arm blocks
moved around directly block block table block
block table depots combination blocksworld arm logistics
objects must transported locations stacked onto
freecell encoding solitaire card game comes microsoft
windows complex object constructed final position cards
hanoi encoding classical towers hanoi assembly complex
object must assembled together parts might need
assembled beforehand
domains domains collection whose semantics
quite fit groups simple tsp trivial strips version
term transportation domains suggested example long fox helmert
transportation benchmarks generally closely related groups
domains overviewed sometimes discuss transportation domains rather generic
level



fihoffmann

tsp move operator applied two locations
movie order watch movie one must buy snacks set counter video
zero rewind tape tireworld number flat tires must replaced
involves working steps removing flat tire putting
one fridge number fridges broken compressors must replaced
involves working steps loosening fastening screws hold
compressor schedule objects must processed painted example
number machines satellite satellites must take images phenomena space
appropriate instruments rovers rovers must navigate along road map take
soil rock samples well images communicate resulting data lander
pipesworld oil derivatives must propagated pipeline network psr
lines must supplied faulty electricity network dining philosophers
deadlock situation dining philosophers translated adl
automata promela language edelkamp must found opticaltelegraph similar dining philosophers considering encoding telegraph
communication system
local search topology
remember consider solvable tasks since main focus investigation
characterize kinds domains heuristic planners plans fast
discussion unsolvable tasks section
given task g state space graph states
reachable initial state set state transitions e set
pairs states action leads executed
goal distance gd state length shortest path
goal state gd path latter case dead end
discuss states directly heuristic function h n heuristic
return indicate state hand might dead end
given strips action pre add del relaxation
pre add given adl action pre e relaxation
pre e e e except delete lists empty
set actions relaxation action sequence


ha relaxed plan g ha
plan g


state h min n p ha p relaxed plan g
minimum empty set
presence derived predicates said additionally relax
task ignoring replacing true negated derived predicates negation normal
forms preconditions effect conditions goal condition note
additional simplification happen h although goal state
simplification might relax goal condition indeed happens
psr domain domains consider derived predicates used
used positively h iff goal state
article focuses mainly h heuristic keep topology definitions
depend specific heuristic used somewhat general



fiwhere ignoring delete lists works

one phenomenon clearly relevant performance heuristic state space
search dead end states gd heuristic function h return h
taking indication dead end obvious idea remove
search space done example hsp technique adequate
h completeness preserving sense h gd
completeness preserving heuristic dead end state called recognized h
unrecognized otherwise note h completeness preserving task solved
even ignoring delete lists task unsolvable assume
heuristic look completeness preserving respect dead ends
state space falls one following four classes state space called
undirected
harmless exists gd
recognized exists gd gd
h
unrecognized exists gd h
first class dead ends everything undone
second class things undone single directed state transitions
harm sense dead end states third class
dead end states recognized heuristic function
critical case heuristic search class four search run dead
end without noticing particularly relevant potentially large regions
state space consist unrecognized dead end states capture define depth
unrecognized dead end number states unrecognized dead
end reachable path moves unrecognized dead ends
investigation determines benchmark domains looked exactly
four dead end classes instances domain belong domains
turns unrecognized dead ends construct parameterized
examples showing unrecognized dead ends arbitrarily deep several
domains individual instances fall different classes case associate
overall domain worst case class e class highest index
example miconic adl additional constraints obeyed
transportation passengers state space harmless miconic simple
constraints example possible direction travel access floors
given unrecognized dead ends arise avoid clumsy language henceforth
say state space harmless recognized unrecognized mean falls
respective class class
get definitions general topological phenomena e relevant properties search space surface adapt definitions given sat frank et al
difference sat framework formalism
lies possibly single directed state transitions search spaces considered frank et al state transitions traversed directions single directed


fihoffmann

state transitions important impact search space topology enabling
example existence dead ends
base entity state space topology frank et al name plateaus
regions equivalent reachability aspects look point
view heuristic function l n plateau p level l maximal subset
induced subgraph strongly connected h l
p plateaus differ terms possibilities leaving heuristic level e
reaching exit plateau p level l exit state reachable p
h l exists state h h behavior
respect exits distinguish five classes plateaus need notion
flat paths paths value h remains constant
recognized dead end plateau p level l
local minimum plateau p level l exit reachable
flat path
bench plateau p level l least one exit reachable
p flat path least one state p exit
contour plateau p level l consists entirely exits
global minimum plateau p level
plateau belongs exactly one classes intuitively roles different
kinds plateaus play heuristic search following recognized dead ends
ignored completeness preserving heuristic function local minima difficult
neighbors look worse clear direction move next benches
potentially easier one step without temporarily worsening
heuristic value contours one step immediately
main difficulty heuristic search deal local minima
benches cases search must eventually path exit
order get closer goal far heuristic function informed
closer goal difficult exit assessed
variety different parameters size number states diameter maximum distance
two states local minimum bench number nearby exit
states name important ones benchmarks considered mentioned
introduction empirically found interesting observations
made parameters hoffmann b b
one course introduce backtracking mechanisms search space giving
planner possibility retract last step affect relevant topological differences
search spaces instead domains without dead ends one gets domains backtracking
necessary necessary
difference undirected case require states plateau strongly connected
undirected state transitions trivially fulfilled set connected states
differences undirected case lie plateaus level allow exits
lie plateaus latter minor technical device obtain compact
terminology



fiwhere ignoring delete lists works

one frequently observe interesting properties distance nearest
exit state distance dist two states usual graph
distance e length shortest path
path exit distance ed search state distance nearest exit e
ed min length path state h h
exists state h h
minimum empty set note require
path definition flat e may order reach temporarily
increase h value want definition capture possible
escape routes state state space including states lie local minima
maximal local minimum exit distance mlmed state space
maximum exit distances states local minima
states maximal bench exit distance mbed state space maximum
exit distances states benches states
many considered domains constant upper bounds mlmed
mbed h e bounds valid irrespectively size
instance chosen
following implication relevant subsequent investigation
proposition given solvable task g state space completenesspreserving heuristic h h gd exists unrecognized
dead end mlmed
proof let unrecognized dead end let state reachable
h value minimal unrecognized dead end particular
considered reachable since h gd h
since h value minimal among states reachable
h h states reachable thus plateau lies local
minimum exits reachable particular flat paths shows
infinite exit distance

proposition says every region unrecognized dead ends local
minimum given h gd definitions unrecognized
dead end state yields infinite local minimum exit distance makes sense define
things way arbitrarily deep unrecognized dead end worse local
minimum escaped
remember latter untrue h domain features derived predicates
appear negated negation normal form goal condition even argument
proposition every region unrecognized dead ends would contain global minimum consisting
non solution states could defined fake global minima local minima decided
order overly complicate topological definitions since detail
seem important said one domains h gd
anyway



fihoffmann

core lemmas
many investigated domains intuitively similar patterns structure cause
characteristic qualities h common structure generalized
captured concise definitions lemmas lemmas formulate sufficient criteria implying state space task certain topological properties proofs
domains proceed possible applying lemmas arbitrary instances
several domains lemmas applied immediately due syntactic details
domain definitions similar proof arguments suffice desired topological
properties
restrict strips tasks lemmas appropriate extensions adl
derived predicates probably possible least certain cases
investigated detail extensions likely rather complicated notationally
simpler strips case suffices transport ideas

initial state
v l l l
goal
l l
actions
name
precondition
move l l
v l
load l
v l l
unload l v l v

add list
v l
v
l

delete list
v l
l
v

figure simple strips transportation task
throughout section assume given strips task g illustrative example definitions lemmas use simple transportation task
defined figure follows three separate sections concerned dead
ends local minima benches respectively
definitions lemmas following syntactical sense
make use informations computed efficiently example inconsistencies
facts discuss focus exclusively role definitions
lemmas tools proving h topology role definitions lemmas
tools automatically detecting h topology discussed section
dead ends
first focus criteria sufficient non existence dead ends starting point
reformulated version simple mentioned example koehler hoffmann
need notion inconsistency two facts inconsistent
reachable state contains set facts f inconsistent another set


fiwhere ignoring delete lists works

facts f fact f inconsistent least one fact f action
invertible
add inconsistent pre
del pre
action
pre pre add del
b add del
c del add
intentions behind requirements following ensure
effects occur ensures applicable b c ensure
undoes effects example actions illustrative task figure
invertible example move l l action inverted move l l see
simply insert definitions add v l inconsistent pre v l
del v l pre pre v l add add v l del
del v l add similarly easily one sees load l unload l
invert examples benchmark domains invertible actions blocksworld
variants logistics gripper
lemma koehler hoffmann given strips task g
actions invertible state space task undirected
proof state applicable action applicable hai due
condition invertibility conditions make sure effects fact
appear condition requires fact add list inconsistent least one
fact precondition conditions b c make sure undoes exactly
effects

remark contrast one may think first sight task
undirected state space even actions invertible sense imagine
example action del p pre p due domain
semantics p true p true means delete effect appears
however detected simple syntax check del pre used
definition
next provide criterion weaker broadly applicable
lemma implies non existence dead ends criterion
weaker version invertibility two alternative properties whose combination
make action safe
make action lead dead end already sufficient inverse action
achieves least deleted delete facts true
may seem natural define inconsistency fact sets symmetrical fashion demanding
every fact f inconsistent every fact f context definition would
stronger need



fihoffmann

given state applicable applying hai leads
us back state satisfies formally action least invertible
action
pre pre add del
add del
del inconsistent pre
condition ensures applicable hai condition
ensures achieves every fact deleted condition ensures
facts deleted true anyway note invertible action
least invertible conditions obviously given condition
del add condition c invertibility add inconsistent pre
condition invertibility del inconsistent pre invertible
stronger least invertible chose name least latter illustrate
definition invertibility potentially achieves facts
original state
example consider happens modify move l l action figure
include visited l fact add list resulting action longer invertible
move l l delete visited l apply state move l l move l l
sequence gets us state identical except
includes visited l visited l may true move actions
kind form simple tsp domain least invertible sense
pre move l l v l add move l l add move l l v l visited l
v l del move l l del move l l v l inconsistent v l
pre move l l
another property implying action lead dead ends
action must applied add effects remain true deletes
nothing preconditions action needs inverted formally
action static add effects


add

del



action relevant delete effects
del g



pre





del g pre say relevant delete effects
property actually interested illustrative task figure
imagine disallow unloading object initial location loading object
goal location remaining unload actions unload l unload l
static add effects action delete goal position object relevant
delete effects action needs object vehicle respective
unload goal location actions characteristics example


fiwhere ignoring delete lists works

actions make passengers get lift miconic strips passenger get
lift origin floor get lift destination
floor another example contained tireworld domain action
inflates flat wheel de flating action add effects static
action goal needs wheel flat relevant delete effects
lemma given solvable strips task g holds actions

least invertible
static add effects relevant delete effects
state space task harmless
proof short reachable state ha plan constructed
inverting ha applying respective inverse actions inverse order
executing arbitrary plan g thereafter processes actions
least invertible skipped prerequisite static add effects
relevant delete effects
detail proof argument proceeds follows reachable state
ha identify solution p g let hp pm
solution g exists g solvable prerequisite construct
p shown figure

n
ai least invertible ai
ai apply ai endif
else ai
endif
endfor

pi apply pi endif
endfor
figure constructing plans tasks actions least invertible
static add effects relevant delete effects
serves kind memory set actions could
inverted need prove preconditions applied actions fulfilled
state applied goals true upon termination let us start
first loop denote si ha ai state executing


fihoffmann

ith action path state first loop starts value
prove


si g
add
pre
ami

aa mi

mi denotes current state set proceed backward induction
n got si mi equation trivially true assume
equation true prove equation holds ai least
invertible action applied mi mi ai concerning
left hand side expression right hand side equation observe ai

prerequisite delete fact g aa mi pre mi contains ai
relevant facts si already true concerning right hand side
expression right observe facts add ai never deleted

prerequisite ami add contained assume ai least invertible
ai got mi mi assume ai applied e ai mi applicable
preconditions contained si element mi resulting state
facts ai deleted si added facts deleted
true si anyway none add effects actions mi deleted
equation fulfilled finally ai applied ai mi ai static add effects
applied add effects contained ai delete effects empty
inserting equation proved get
g



pre

aa



add



second loop starts start solution plan excluding actions
set state including initial facts contained goal
precondition action state additionally contains add effects
actions add effects deleted action clear
simply skip actions achieve goal

example illustrate proof consider reachable state tireworld domain
every action invertible except action inflates wheel say proof
state reached action sequence ha figure
undo everything done applying respective ai actions except
inflating actions ai latter stored set gets us state
identical initial state except already inflated flat
wheels corresponding actions state executes
arbitrary solution skipping previously applied inflating actions
local minima
define important kind relationship role action real task
role relaxed task combining definition notions least
invertible actions relevant delete effects yields criterion sufficient
non existence local minima h equivalently upper bound
maximal local minimum exit distance criterion directly applied


fiwhere ignoring delete lists works

investigated domains applied slight modifications domains
many individual proofs make use similar albeit somewhat complicated
proof arguments
key property behind lack local minima h time
every action good solving real task good solving relaxed task
formally action respected relaxation
reachable state starts optimal plan g
optimal relaxed plan g contains
note one assume relaxed plan start since relaxation
better apply action earlier
actions illustrative task figure respected relaxation consider move l l actions example state optimal plan starts
move l l must good reason l object
yet transported b object truck must transported l
cases relaxed plan must transport object chance
without moving l point similarly optimal plan starts load l
action means must transported somewhere else relaxed plan
get around loading finally optimal plan starts unload l action
means l goal location relaxed plan include
action
similar arguments applied many transportation domains
argument regarding move actions becomes little complicated non trivial
road maps unlike illustrative example two locations
reachable single step say road map directed graph
modify move action figure add precondition fact
demanding existence edge l l move actions still respected
relaxation ignoring delete lists affect shape road map
optimal real path location l location l coincides optimal relaxed path
movements l l even though executing path different
claim follows argument namely optimal
plans moves l l object provides reason
transportation domain features additional constraints side effects move
actions may respected relaxation give example
formulating main lemma regarding local minima h
note exist local minima even actions respected relaxation
consider following transportation task featuring single directional edges road
map graph argued actions respected relaxation vehicle
two objects initially l must go l must go l edge l
l single directed edge l l single directed l l
path n bi directional undirected edges optimal relaxed plan state
initial state loaded length move l l l
unload l l respectively however one moved l
l optimal relaxed plan length goes n since entire path l


fihoffmann

l must traversed lies local minimum given n note setting
n arbitrarily high values get local minimum arbitrarily large exit distance
turns preventing example precisely making use notions
invertibility relevant delete effects introduced suffices get rid local
minima h
lemma given solvable strips task g state space
contain unrecognized dead ends action
respected relaxation
least invertible relevant delete effects
local minima evaluation h
proof states gd local minima prerequisite h
prove every reachable state gd action starts
optimal plan g h hai h proves lemma
iterating argument obtain path goal state value h
increase path means exit reachable flat path
h h point path h value becomes lower h thus
lie local minimum
let reachable state gd let action starts
optimal plan g denote hai action respected
relaxation optimal relaxed plan p g starts
case removing p yields relaxed plan g h

h follows finished case particular relevant delete
effects facts deletes needed action goal p
without achieves goal starting already applied
case b assume removing p yield relaxed plan
said relevant delete effects must thus least
invertible action pre pre add del
add del action guaranteed applicable achieves
delete effects denote p action sequence replacing p
p relaxed plan g seen follows observe
definition p without relaxed plan ha abbreviate
notation somewhat improve readability desired property follows
ha superset ha ha add
add del add del p relaxed plan g
yielding h h

proof lemma demonstrates along lines typically proof arguments
investigation proceed given state consider action starts optimal
plan consider optimal relaxed plan p contains ideally
determine p modified obtain relaxed plan state
execution technique forms basis literally proofs except concerned
dead ends note second prerequisite lemma fulfilled


fiwhere ignoring delete lists works

tasks qualifying undirectedness harmlessness criteria given lemmas
note said proved state space
illustrative example figure undirected contain local minima
h
domains actions respected relaxation example strips
transportation domains logistics gripper ferry miconic strips cases
respective proof arguments similar said instructive
look examples action respected relaxation
transportation domain example happen due fuel usage side effect
moving concretely mystery domain applying move action deletes fuel unit
start location location move starts fuel running low
locations real plan may move along fuel rich deviations road map
relaxed plan need move along shortest connections
map actions delete fuel units
formulated somewhat generally relaxed plans take short cuts dont
work reality short cuts disjoint starting actions real solution
paths local minima may arise even actions least invertible
discussed transportation case short cuts correspond intuitive manner
one tends think short cuts road map namely case
general e kinds domains consider blocksworld arm state depicted
figure

c
b

c



b

figure local minimum state blocksworld arm goal b table
c b

depicted state denoted b table arm holds c
goal b table c b optimal plan put c
table unstack b put table pickup c stack
onto b optimal relaxed plan however stack c onto b immediately
unstack b put b table short cut
relaxed plan put c table stacking c onto b
delete fact declares bs surface unoccupied lies local
usually blocksworld goals demanding block table example
done sake simplicity one could introduce one block demand b
goal



fihoffmann

minimum h reason intuitively h yield local minima
many domains vicious short cuts example dont happen
benches
could nice general sufficient criterion implying upper bounds maximal
exit distance local minima except special case local
minima thus upper bound maximal local minimum exit distance
however simple proof argument determining upper bound maximal
exit distance benches tasks qualify application lemma proof
argument works sometimes slight modifications domains lemma
directly applied domains maximal bench exit distance bounded
bounded one case
proof argument observing many domains actions
delete effects irrelevant relaxed plan least action
applied optimal solution path formally action relaxed plan relevant
delete effects
reachable state starts optimal plan g

optimal relaxed plan ha g del g ni pre ai
reachable state starts optimal plan g

optimal relaxed plan ha g del g ni pre ai
say relaxed plan relevant delete effects property
actually interested notation relaxed plan relevant delete effects
starts optimal plan relaxed plan hai constructed
sequence ha e skipping relaxed plan thus h
value decreases hai note n set goal
state note definition action relaxed plan relevant delete
effects respected relaxation action respected relaxation
claim anything h anyway note finally assuming action
respected relaxation relevant delete effects e delete
goal precondition another action relaxed plan relevant delete
effects sense definition
consider illustrative example figure say state
load l starts optimal plan means yet transported location
l l particular means l goal follows action
whose delete effect l relevant delete effects action
l precondition say unload l starts optimal plan
means l goal location applying action goal
achieved action need refer particular action require
inside vehicle delete effect unload l action neither
h h value putting c table relaxed plan
apply two actions two goals h value stacking c onto b still
relaxed plan unstack c b unstack b put b successor state
unstack c b going back



fiwhere ignoring delete lists works

relaxed plan relevant delete effects contrast consider move l l action
deletes v l say state loaded v initial
state task move l l starts optimal plan relaxed plan
hmove l l include action move l l moving back l
l order able transport delete effect move l l namely
v l relaxed plan relevant
task satisfying prerequisites lemma optimal starting action
relaxed plan relevant delete effects one apply case proof lemma
obtain smaller h value bound maximal exit distance benches
need identify maximum number steps happen
lemma given solvable strips task g satisfies prerequisites
lemma let constant every non dead end state
optimal plan ha th action ad relaxed plan relevant delete effects mbed
proof let reachable state gd let ha optimal plan
g ad relaxed plan relevant delete effects denote n
si ha ai argumentation lemma h si h
consider state sd prerequisite optimal relaxed plan


sd g form del ad g
pre ai




obviously ha relaxed plan sd h sd h sd
distance sd lemma follows

lemma directly applied domains qualify lemma
proof argument somewhat general version applied domains
well namely ferry gripper loading object deletes space vehicle
one domain namely miconic simple uses simple adl constructs
domains proved upper bound maximal exit distance
benches upper bound maximal exit distance local minima
proof arguments lot sometimes complicated reconsidering illustrative
example stated load unload actions relaxed plan relevant delete
effects move actions obviously since two locations accessible
single move optimal plan applies one move action
row e optimal plan first second action load unload
lemma tells us maximal exit distance benches bounded
similar argument applied transportation domains every pair
locations connected via single move example logistics generally
standard encoding transportation domain constraints regarding
example fuel undirected road map graph exit distance bounded
diameter road map graph e maximum distance two locations
nodes graph worst thing solution plan might traverse
entire road map loading unloading object
directed road map graphs explained local minima arise technically lemma
applied lemma applied



fihoffmann

domain taxonomy
list proved brief explanations obtained
summarize form domain taxonomy
group positive prove non existence topological
phenomena problematic heuristic search together single theorems
negative shown separately sketching counter examples consider dead
ends local minima benches order remember respect dead ends
problematic case heuristic search unrecognized dead ends c f
section
theorem state space solvable instance
blocksworld arm blocksworld arm briefcaseworld depots driverlog ferry
fridge gripper hanoi logistics undirected
grid miconic simple miconic strips movie pipesworld psr satellite
simple tsp tireworld zenotravel harmless
dining philosophers optical telegraph rovers schedule recognized evaluation h
blocksworld arm blocksworld arm driverlog ferry gripper hanoi logistics lemma directly applied briefcaseworld depots fridge due
subtleties actions invertible syntactical sense easy
every action inverse counterpart movie miconic strips simple tsp
tireworld lemma directly applied grid miconic simple similar proof
arguments used lemma suffice pipesworld psr satellite zenotravel
easy see individual domain properties prove absence dead ends domains dead ends recognized h individual domain properties exploited
proofs somewhat involved example rovers plan state
soil rock samples images need taken rover
job communicate gathered data lander
chance run dead end take soil rock sample rover reach
lander soil rock sample available relaxed plan
state
domains mentioned theorem airport assembly freecell miconicadl mprime mystery easy construct arbitrarily deep unrecognized dead ends
arbitrarily long paths unrecognized dead ends example mystery mprime
relaxed plan still achieve goal situations much fuel consumed
already airport two planes block others paths may move across
relaxed plan
positive regarding local minima
theorem h maximal local minimum exit distance state space
solvable instance


fiwhere ignoring delete lists works

blocksworld arm briefcaseworld ferry fridge grid gripper hanoi logistics
miconic simple miconic strips movie simple tsp tireworld
zenotravel satellite schedule diningphilosophers
ferry gripper logistics miconic strips movie simple tsp tireworld
lemma applied fridge miconic simple actions adhere syntactically definitions invertibility relevant delete effects similar
semantics lemma directly applied similar arguments suffice easy
see actions respected relaxation proof lemma individually adapted take account particular properties regarding invertibility
relevant delete effects example passenger gets lift miconic simple
delete effect passenger longer inside lift matter
since passenger reached destination blocksworld arm briefcaseworld
grid rather individual sometimes quite involved arguments prove absence
local minima h proof method cases consider state
identify flat path state better h value example grid done
moving along path locations contained relaxed plan key
picked put lock opened simplified description
actual procedure quite complicated hanoi one prove optimal relaxed
solution length state equal number discs yet final
goal position suffices optimal plan moves disc away final position note thus hanoi state spaces h sequence benches decreasing
exponentially diameter size
zenotravel satellite schedule proofs proceed identifying constant
number steps suffices execute one action optimal relaxed plan state
without deleting relevant add effects achieve relevant facts
deleted dining philosophers well optical telegraph due subtleties
pddl encoding said obtained automatic compilation
automata promela language edelkamp h loosely connected
goal distance relaxation automaton example philosopher
block actions bound dining philosophers follows
rather constant restrictive domain structure constant number process
transitions namely suffices block one philosopher proved bound
derived considering actions needed process
transition certain additional actions may needed due subtleties
pddl encoding process two internal states remark
bound valid even trivial heuristic function returning number yet
un blocked philosophers fact proof h viewed corollary proof
heuristic function get back end section finally remark
highest exit distance h could actually construct dining philosophers
conjecture tight upper bound
satellite schedule zenotravel proved upper bounds tight
dining philosophers satellite schedule zenotravel bounds valid nondead end state beside bound local minimum exit distance


fihoffmann

provide bound bench exit distance used
section
airport assembly freecell miconic adl mprime mystery stated
unrecognized dead ends proposition local minimum exit distance
domains unbounded domains mentioned theorem e
blocksworld arm depots driverlog optical telegraph pipesworld psr rovers one
construct local minima arbitrarily large exit distances complicated
example optical telegraph difference dining philosophers one construct
situations number process state transitions needed block one process
arbitrarily high optical telegraph basically version dining philosophers
complicated philosophers freedom next freedom enables
situations whole row philosophers table must perform two transitions
order block one philosopher details appendix simpler example
blocksworld arm well depots blocksworld arm situations embedded
consider following situation n blocks b bn initially form stack
bi bi bn table goal build stack top
another block bn e goal stack b bn bn reaching initial state
state better h value involves disassembling entire stack b bn
disassembling process h increases note basically extended version
illustrative example figure
interesting side remark note proved topological difference
blocksworld arm blocksworld arm latter local minima
h former exit distance arbitrarily large
intriguing quite clear general message learn one might
interpret telling us formal way encoding details significant impact
topology search performance example much efficient
blocksworld arm blocksworld arm noted however two
domains differ semantically namely plans blocksworld arm half
long plans blocksworld arm practical point view would interesting
explore blocksworld observation generalized encoding methods trying
model domain way making best suited h said
section
positive regarding benches
theorem h maximal bench exit distance state space solvable
instance simple tsp ferry gripper logistics
miconic simple miconic strips movie
zenotravel satellite schedule tireworld
dining philosophers
simple tsp ferry gripper logistics miconic strips movie tireworld
lemma directly applied determining actions relaxed plan relevant delete effects easy domains tireworld somewhat complicated
see latest action applied optimal plan miconicsimple similar arguments lemma suffice zenotravel satellite schedule
dining philosophers respective bounds shown already


fiwhere ignoring delete lists works

note simple tsp proved local minima exit
distance implies h fact identical real goal distance entire
state space consists contours global minima
topological distinctions divide domains taxonomy classes
differ terms behavior state spaces respect h visualization
taxonomy investigated domains given figure

blocksworldarm
depots
driverlog

pipesworld
psr

rovers
opticaltelegraph

mystery
mprime
miconicadl
freecell
assembly
airport

mbed c

mlmed c

hanoi
blocksworldnoarm
fridge
grid
briefcaseworld

logistics
ferry
gripper
undirected

tireworld
satellite
zenotravel
miconicsimple
miconicstrips
movie
simpletsp
harmless

diningphil
schedule

recognized

unrecognized

figure domain taxonomy overviewing
taxonomy shown figure two dimensions x axis corresponds
four dead end classes axis corresponds existence non existence constant
upper bounds local minimum exit distance bench exit distance note
visualization makes simplifying assumption domains bounded
bench exit distance subset ones bounded local minimum exit distance
assumption justified general holds true specific collection domains
question whether bound difficulty escaping benches
seem relevant anyway arbitrarily difficult escape local minima
specific bounds proved individual domains given parentheses local minimum
exit distance bound preceding bench exit distance bound cases
bottom right corner taxonomy crossed domain belong
respective classes
similarly benches arbitrarily large relevant local minima
small non existent sense respective briefcaseworld fridge grid blocksworldno arm hanoi moderately important still constitute interesting properties
domains
proposition existence unrecognized dead ends implies non existence constant upper
bounds local minimum exit distance given states gd h
states exist domain features derived predicates appear negated negation



fihoffmann

figure suggests h approximating heuristic planners fast
many common benchmark domains lie easy regions taxonomy
concretely described introduction provided h function ffs
search enforced hill climbing polynomial domains located lowermost classes taxonomy e domains constant bounds maximal
exit distances empirical perspective distinction lines taxonomy
coincide quite well practical performance excels domains
belong lowermost classes taxonomy difficult domain diningphilosophers whose upper bound exceptionally high middle domains
local minima potentially large benches performs well scale
comfortably easier domains complex domains blocksworld arm
depots driverlog optical telegraph pipesworld psr amongst challenging domains mprime mystery performs bad
planners freecell miconic adl among top performing planners often
runs unrecognized dead ends larger instances example larger freecell
instances used aips airport assembly rovers performs pretty well
respective competition example suites however domains competition suites
hardly explore worst cases domain topology details appendix
discuss detail relation taxonomy empirical performance heuristic planners make use h approximation one
way one observation definitely made planners
trouble solving instances domains extreme h properties
simple tsp ferry gripper logistics miconic simple miconic strips movie
extent zenotravel planners scale comfortably particular
scale much comfortably domains typically
domains least without additional example goal ordering techniques
next section treat connection taxonomy ffs performance
analytical way relating properties h properties ffs approximation
h called hf f remarks relation taxonomy
complexity theory order question whether provable relation e
relation distinction lines taxonomy complexity deciding
plan existence respective domains able construct np hard domain
domain deciding plan existence np hard h yield local
minima maximal bench exit distance domain however unbounded tried
able come np hard domain constant bounds
maximal exit distances remains open question whether domain exists
answer yes lowermost classes taxonomy form group
domains worst case hard typically easy solve least far

normal form goal condition even presence unrecognized dead ends
would fake global minima e global minima consisting non solution states fact consisting
unrecognized dead ends



fiwhere ignoring delete lists works

reflected hitherto benchmarks answer identified
large polynomial sub class
talking polynomial sub classes intriguing observation made
trivial heuristic function returning state number goals true
lets call function hg little thinking one realizes fact
domains proved constant bounds maximal exit distances h
constant bounds hg hand remaining
domains except miconic adl easy see constant bounds hg
logistics example clearly maximum number steps needed achieve one
goal steps move load move unload within packages origin city
origin city destination city within destination city diningphilosophers example upper bound h said proved corollary
upper bound hg blocksworld example clearly take arbitrarily many
steps achieve one goal namely block must moved buried beneath n
blocks need moved
observation appears rather significant first sight probably
important neither theory practice one thing coincidence
set domains constant bounds h set
domains constant bounds hg simple counter example general
case graph search domain task path two nodes
directed graph obvious predicate connected predicate encoding
h equal real goal distance since one never needs move back
hg clearly arbitrarily bad another thing domains logistics
constant exit distance bounds hg bounds large practically useful
example h needs look steps forward breadth first
search iteration enforced hill climbing logistics instance hg breadth first
searches depth would needed observation regarding hg
noteworthy statement current benchmarks remains open question
whether coincidental correspondence bounds h hg
investigated domains exploited e g detecting bounds automatically

relating h hf f
discussion relating h hf f structured two separate sections first one
briefly discusses provable relations h hf f second section summarizes
large scale empirical investigation aimed identifying extent
topological properties h benchmarks get preserved hf f
provable relations h hf f
one thing easy observe behavior h hf f provably
respect dead ends e heuristics return cases
simply heuristics return state iff relaxed plan
presumably prove latter one would need characterize class purely syntactic manner
level pddl definitions since h derived directly pddl syntax authors wild
guess going work answer yes



fihoffmann

h follows definition hf f follows completeness relative
relaxation computes relaxed plans hoffmann nebel
relaxed version graphplan blum furst state
runs graphplan task initial state delete lists actions
empty without delete lists graphplan guaranteed terminate polynomial time
graphplan terminates unsuccessfully hf f set otherwise number
actions returned plan taken heuristic value hf f state graphplan
complete terminates successfully plan
hf f set iff relaxed plan follows dead end classes
benchmarks h hf f
relaxed plans found graphplan general strips property
optimal terms number parallel time steps terms
number actions general hf f h even p np
uses following heuristic techniques action choice relaxed graphplan aiming
minimizing number selected actions hoffmann nebel first fact
achieved noop dummy action propagating fact time step time
step graphplans graph noop selected guarantees
every non noop action selected course selected noop actions
counted relaxed plan second noop available action
minimal precondition weight chosen weight defined summedup indices first layers appearance graph precondition
facts third actions selected parallel time step assumed linearized
order selection action selected assumed achieve fact
p add pre even selected parallel time step
two restrictive sub classes strips hf f provably
h first demands every fact one achiever
proposition let g strips task facts p
one action p add states task h hf f
proof proposition follows observation running relaxed graphplan choice points action selection choice points
empty unary case implies actions selected graphplan
contained relaxed plan detail latter proved induction
regression steps relaxed graphplan let state relaxed
plan top level regression actions selected support goals
contained goals need supported relaxed plan
actions holds true preconditions selected
actions p pre supporter must present relaxed plan
supporter selected relaxed graphplan iterating argument get
desired property claim follows proved hoffmann nebel
relaxed graphplan selects every action

note estimate sequential relaxed plan length length graph built
graphplan corresponds optimal length parallel relaxed plan admissible heuristic estimate
however indicated heuristic functions generally found provide useful
search guidance practice see example haslum geffner bonet geffner b



fiwhere ignoring delete lists works

second sub class strips demands one goal
one precondition per action
proposition let g strips task g
pre states task h hf f
proof given restrictions relaxed comes finding paths
graph nodes facts edge p p iff action
pre p add p empty preconditions modelled special fact
node assumed true state relaxed plan iff makes fact node
true path goal node relaxed graphplan identifies shortest
path

prerequisites propositions maximally generous e relaxing one
requirements one loses h hf f property obtain sub optimal relaxed
plans graphplan e construct cases h hf f suffices one
fact two achievers two goal facts one action two preconditions
following example facts g g p p goal g g
current state empty actions shown figure
name
opg
opg p
opg p
opp
opp







pre

add

del

p
p
p



g
g
g
p
p







figure actions example task hf f h
optimal relaxed plan hopp opg opg pi however graphplan might choose
achieve g opg p ending parallel relaxed plan h opp opp opg
opg p note action single precondition single fact
one achiever two goals similar example constructed
case one goal one action two preconditions
obviously syntax allowed propositions far restrictive
adequate formulating practical domains investigate whether
interesting situations h hf f intuition
case
different question whether provable relations h hf f
benchmark domains considered h investigation investigate
question detail note investigation would involve constructing detailed
remark syntax identified proposition sub class tractable class strips
identified bylander bylanders class constant number g goal facts allowed
g greater preconditions may positive negative



fihoffmann

arguments individual domains clearly beyond scope
none domains captured propositions
easy obtain following simple tsp movie miconic strips h hf f
follows extremely simple structure domains
finding step optimal relaxed plans graphplan relaxed plans
optimal number actions however even slightly complicated domains
ferry gripper logistics miconic simple zenotravel one easily construct states
graphplans relaxed plans may unnecessarily long miconic strips
happen single vehicle lift capacity restrictions
number loaded objects e passengers several vehicles transportable
objects occur logistics zenotravel well driverlog depots mprime
mystery rovers difference h hf f become arbitrarily large
imagine n objects must transported l l n vehicles available
l parallel relaxed makes difference single vehicle transports
objects one different vehicle selected per individual object particular even
ffs action choice heuristics relaxed graphplan hf f may n well n
ferry gripper single vehicle capacity restrictions
may upper bound difference h hf f
check detail
spite authors personal experience developing
least relatively simply structured domains many different operators different
ways achieve facts relaxed plans found relaxed graphplan typically pretty
close optimal presumably following two reasons first
employed action choice heuristics example grid domain relaxed plan may
choose pick key k sole purpose dropping picking
another key k pickup lose action c f appendix b happen
selecting actions minimal precondition weight pickup lose action
higher weight pickup action unless one already holds k considered state
second many published benchmark instance suites quite restricted logistics
example situation outlined n objects n vehicles waiting location l
happen trucks single truck city airplanes
published benchmark instances usually n
small
empirical relations h hf f
large scale empirical investigation hoffmann b turned hf f typically
preserves quality h investigation aimed verifying domains
h positive topological property example yielding local minima
extent property inherited hf f considered benchmark domains
namely domains hand except ipc ipc domains
one could circumvent particular phenomenon selecting action relaxed graphplan
employing minimization summed weight preconditions actions selected far
topic future work explore effect ffs performance



fiwhere ignoring delete lists works

note latter domains three namely dining philosophers satellite
zenotravel positive topological properties
experimental take samples state spaces technique adapted
work frank et al precisely method following
domain random generator used produce large set example instances
instances grouped together according values domain parameters e
input parameters generator example number floors number passengers
miconic simple single instance states sampled e
random sequences actions executed initial state sequence length
chosen randomly interval times ffs plan length
resulting state exit distance ed computed breadth first search another
search determined whether located valley e whether path
goal state hf f value decreased monotonically maximal exit
distance instance approximated maximum exit distances
sample states every group instances mean number states valleys
mean maximal exit distance computed visualized plotting
values scaling domain parameters give examples directly
summarizing overall
experiment strongly suggested hf f typically preserves quality
h considered benchmark domains domains h provably yields
local minima almost sample states located valleys except domains
namely grid hanoi precisely domains experiment considered
total groups random instances one groups sample states
lay valleys another group another eight groups
remaining groups single valley state found maximal
exit distance benches tested instances domains bound
h single sample state exit distance larger bound namely
exit distance instead logistics domain
blocksworld arm
gripper
hanoi
tireworld


























figure percentage sample states valleys mean values linear increase
respective domain parameter
figure provides regarding sample states valleys considered
domains local minima thus valleys h tried sampling strategies found make much difference terms
obtained
intuitively local minimum lies bottom valley used valleys experiment since
may hard local minimum state sampling
authors guess similar empirical investigation dining philosophers satellite
zenotravel would similar e sampled maximal exit distances would hardly increase
upper bounds proved h



fihoffmann

stances characterized single domain parameter movie simple tsp left
since hf f provably h blocksworld arm parameter
number blocks plus randomization initial goal states gripper
number balls transported hanoi number discs tireworld
number flat tires domain left right table entries correspond
linear increase domain parameter blocks balls discs
tires respectively obviously domain behave hanoi
h isnt useful heuristic anyway yielding large benches c f section
blocksworld arm
gripper
hanoi
tireworld


























figure sampled maximal exit distance mean values linear increase respective
domain parameter
figure shows regarding sampled maximal exit distance domains
characterized single domain parameter gripper tireworld sampled values
respect bound valid h largest tireworld example sampling
maximum state rather large state space comparison sampled values
blocksworld arm bound h clear increase
behavior hanoi odd
figure shows part domain characterized one
domain parameter namely logistics domains least two domain parameters
experimental method run one experiment pair experiment
parameters except respective pair set fixed value data could
visualized dimensional plots ones figure figure parameters
scaled number cities number objects packages transported
parameter range cases city size number airplanes
fixed parameter value combination random instances generated
states sampled per instance valley states found except cities
objects sample states located valley cities
objects single instance one sample state exit distance rather bound
valid h single bound violation found entire experiment
indicated grid domain hanoi domain
experiment suggested major difference topologies h hf f large
fractions sample states located valleys clear
tendency increase percentage increasing grid size increasing
number keys transported
experiment confirmed blocksworld arm briefcaseworld ferry fridge gripper logistics miconic simple tireworld domains hf f
decrease mean sampled maximal exit distance large parameter values suggests
becomes harder sampling maximum states rather large state spaces



fiwhere ignoring delete lists works

z

z

























x














x










b

figure mean sampled valley percentage maximal exit distance b logistics
scaling cities x axis objects axis
largely preserves quality h local minima constant bound maximal exit distance benches remember miconic strips movie simple tsp
three domains provably applies

towards automatically detecting h phenomena
lemmas presented section provide natural starting point investigations
domain analysis techniques trying detect topological phenomena automatically
domain analysis techniques would useful configuring hybrid systems e
automatic selection heuristic functions likely well suited solving given
task techniques would useful avoiding need
h investigation every single domain finally basis
analysis techniques one may able compute good lower bounds h
informative admissible heuristic function discussion points contained
section
question addressed extent application
lemmas section automated e one automatically check
whether prerequisites satisfied given strips task section hand
present preliminary attempt made attempt
successful believe investigation value showing one achieve
simple analysis techniques weak points would needed improved
upon order obtain better
invertible least invertible actions actions irrelevant delete static add
effects syntactically defined section thus easy detect difficulty
inconsistencies facts hard
several approximation techniques literature example blum furst
fox long gerevini schubert rintanen tend work
well least current benchmarks challenge syntactical
characterizations actions respected relaxation actions


fihoffmann

relaxed plan relevant delete effects many domains phenomena
occur example ferry gripper logistics miconic strips movie simple tsp
tireworld intuitively one looks domains causes phenomena
seem similar getting actual syntax domain descriptions
individual details different becomes difficult get hold
common ground seem simple syntactical definition captures
behavior actions domains least syntactical
definition instead tried reason additive structure domains
possible interactions delete effects intuition domains
simple h topology interactions arent harmful captured
additive structure domain instance data structure called fact generation
trees next subsection describes data structure basic properties
subsection gives extreme case h topology subsection outlines
somewhat advanced analysis technique developed
fact generation trees
fact generation tree short fgt instance basically tree
regression search starting goals ignoring delete effects
actions tree nodes labelled facts actions alternatingly fact nodes
nodes represent choice achieving actions action nodes nodes
preconditions represent sets facts must achieved together assume goal
achievement action known example description ucpop penberthy
weld action root node fgt top level goals form
sons obviously sons fact node actions achieve fact
sons action node precondition facts action sake
simplicity stayed pure strips framework investigation tree structures
kind example described used nebel dimopoulos koehler
work automatically detecting irrelevant facts operators note fgt
take account interactions may arise trying achieve facts
node together effect ignoring delete lists fgt treats
facts completely separately
terminate fgt applying following two rules
say inserted action node n labeled action fact
p pre fact node labeled p occurs path root node
n n pruned
say inserted son action node n fact node n p labeled
fact p action p pre action node labeled
occurs path root node n n p pruned
intuitively rules disallow generation branches fgt would redundant relaxed plan formally call relaxed plan non redundant strict subsequence still relaxed plan e action omitted every non redundant
relaxed plan every necessarily reachable state embedded connected
rooted non redundant sub tree fgt built way described


fiwhere ignoring delete lists works

precise introducing illustrative example figure use
throughout section

e

e

eur

mv e


eur

b

c


eur


mv b

mv c

b

c

mv c

mv b



figure sketch fgt illustrative example
example task reach location e available actions moves along
bi directional graph edges obvious encoding predicate except
move e requires additional precondition possession
eur acquire eur add effect action moves
c main part figure shows fgt example picture top left
corner illustrates example showing road map graph indication role
eur constructs root node e artificial goal achievement action
included figure simplicity due termination rule example moving
e included son fact node labeled precondition e
root node due termination rule son action node labeled
mv c already occurs precondition mv e
every action non redundant relaxed plan arbitrary state achieves
unique needed fact achieved preceding action needed
goal precondition subsequent action overly difficult prove
one thus embed relaxed plan fgt processing relaxed plan
back front associating action corresponding node needed
fact added action starting goal facts resulting sub tree connected
rooted sense actions associated consecutive nodes starting
root node sub tree non redundant sense every node
observation made example hoffmann nebel b used detect
actions participate non redundant relaxed plan thus need
considered heuristic computations done planners hsp



fihoffmann

one son gets associated action termination rule valid since fact needed
end relaxed plan needed start termination rule valid
since every needed fact least one representative node corresponding subtree illustration consider different locations graph underlying example
figure one located example eur
entire fgt except mv c node corresponds sub tree non redundant
relaxed plan sub tree obtained follows relaxed plan mv b mv b
mv c mv e needed facts added actions b
eur e respectively starting goal fact e first mv e gets
associated respective action node fact nodes eur
preconditions action dealt become open mv b well
mv c get associated respective node respective needed fact
consequence mv b action fact node b becomes open mv b gets
associated action node process stops current state
one example located c eur process selects sub tree
consists mv c mv e nodes
every non redundant relaxed plan instance particular every optimal relaxed
plan instance corresponds sub tree fgt fgt summary
possible relaxed plans sense idea examine fgt harmful interactions
conflicts potential appear relaxed plan hope able draw
conclusions non existence restricted form conflicts topological properties
h next outline extreme case analysis kind namely one postulates
absence conflicts fgt note difference situation
illustrative example general fgt contain action fact labels multiple nodes
worst case size fgt exponential size instance description
design practically usable domain analysis techniques one would need approximate
fgt instead building completely aspect treated follows
objective implications fgt structure h topology
first place
interaction free tasks
think conflict situation one part non redundant relaxed plan
hinder execution success another part relaxed plan
conflicts every non redundant relaxed plan executable reality implying
h equal real goal distance course implies local minima
etc investigated benchmark domains case simple tsp
use motivating example
define three kinds conflicts fgt call two action nodes labeled
actions allied participate together non redundant sub tree e
occur together embedding relaxed plan descendants
case iff paths root node separate
node first kind conflicts given pair allied action nodes labeled
deletes precondition second kind conflicts pair action nodes labeled
descendant deletes precondition added


fiwhere ignoring delete lists works

action path third kind action node labeled
deletes goal fact added action path respective root
node
conflicts fgt call task interaction free relatively
easy see without conflicts every non redundant relaxed plan every nonredundant sub tree fgt execution order works reality h
equals goal distance interaction free tasks
illustrative example figure conflict fgt
nodes mv c mv e nodes allied mv c deletes
precondition mv e note conflict indeed capture reason
h equal goal distance example order able move
e one first move c get eur latter deletes
precondition former relaxation move c one
located c time relaxed plan needs one step less
achieve goal states move c yet done
example domain interaction free tasks graph search domain mentioned earlier tasks demand path two nodes directed
graph obvious predicate connected predicate encoding
illustrative example becomes instance domain one removes eur
constructs even come purely syntactic criterion captures
example domain
proposition let g strips task
g
pre
del pre
g interaction free
proof due prerequisites nodes fgt one son
implies allied action nodes together prerequisite
termination rule implies action node delete goal fact precondition
fact ancestor node

instances graph search domain fulfill prerequisites proposition
static connected facts removed prior note syntax identified
proposition subset syntax identified proposition thus tasks
hf f identical h since h identical real goal distance plan existence
decided polynomial time intuitively captured syntax
express graph search domain plans task qualifying proposition
correspond exactly paths graph nodes facts edges go
preconditions add effects true relaxed plans
instances simple tsp domain interaction free conflicts
fgt pairs actions achieving different visited goals example say


fihoffmann

three locations visit l l l action nodes mv l l mv l
l allied since achieve goals visited l visited l participate
root node actions mutually delete precondition l
constitute conflict fgt appear together relaxed plan
relaxed plan executable reality unless relaxed plan happens move back
l observe however execution example mv l l one
replace mv l l mv l l repair conflict relaxed plan
conflicts simple tsp fgts behave way
general say conflict allied action nodes repaired
action pre pre add del thus executed
add add thus achieves achieved similar
repairable cases identified two kinds conflicts conflicts
fgt repaired non redundant relaxed plan relaxed plan
length executable reality h equals goal distance
case simple tsp domain
made preliminary implementation fgt analysis techniques
implementation correctly detects simple tsp instances well graph search
instances h equals goal distance simple tsp less locations analysis
takes split seconds locations runtime taken explodes fairly
quickly
advanced analysis
encouraging techniques applicability h topology
detect clearly far severely restricted turns extremely difficult
less restrictive implications fgt structure h topology e sufficient criteria
weaker topological properties best could come criterion implies
non existence local minima h holds true movie domain
extremely simple logistics instances
idea behind criterion following imply non existence local
minima h suffices know every state starting action
optimal solution h hai h say considering
task actions least invertible let state starting action
optimal solution optimal relaxed plan contains
done argument used lemma else let p optimal relaxed plan
contain p embedded sub tree fgt
delete leaf nodes sub tree facts p assumes true state
execution p relaxed plan hai done case left
open delete leaf node sub tree occupied p observe
matter repairable conflicts sub tree
p executable reality p optimal plan starting action
p falls first case done get following sufficient
criterion


fiwhere ignoring delete lists works

local minima h actions holds least
invertible non redundant sub trees fgt contain
delete leaf sub tree sub tree contain conflicts
test criterion one needs consider redundant sub tree fgt
branches left start nodes labeled sub tree
contains conflict deletes fact occurring sub tree criterion
apply otherwise test succeeds actions proved local
minima h
reconsider illustrative example figure said conflict
fgt nodes mv c mv e sub tree
contain one nodes conflict free mv c mv e violate
criterion neither mv b mv c mv b violate criterion since
none actions deletes fact occurring anywhere else precondition
however mv b mv b sub tree looked entire fgt including
conflict actions delete fact occurs fgt criterion
apply illustrative example note mv b mv b never start
optimal plan really could left considerations unclear
detect automatically general way
remark side order action appear fgt
difference one may think first sight imply appear
optimal plan fgt termination rules adequate relaxed
restrictive real following example facts g g
p goal g g current state g actions shown figure
name
opp
opg
opg





pre

add

del

g

p

p
g
g


g


figure actions example task fgt contain action opp
namely needed reality
optimal plan hopp opg opg order able achieve g
applying opg must achieve p first however opp appear fgt
location fgt node n labeled opp could inserted
son precondition node p opg inserted son g n pruned
termination rule opp g precondition g appears path
root node n note indeed opp never part relaxed plan
achieving p good achieving g deleted actions necessary
reach goals
implementation criterion given easily within split seconds proves
non existence local minima movie instances regardless size instance


fihoffmann

technique however work domain tried except logistics
instances single city two locations single truck
single package transported note even simpler small
illustrative example used section two objects need transported
open question better achieved e state spaces
recognized feature local minima h feeling backward
chaining domain analysis promising successful analysis
technique probably invest much effort analyzing way
goals achieved many steps rather crude
fgt approximation information available goals achieved
maybe would possible discover non trivial cases actions respected
relaxation detecting actions relaxed plan relevant delete effects
yet completely unclear us could accomplished

discussion
derived formal background understanding classes domains relaxed plan heuristic methods wide spread methods modern
landscape time writing well suited formal taken
identify characteristics local search topology heuristic cost surface
idealized heuristic function h forward searching framework commonly used
benchmark domains including competition examples e basically strips
adl benchmark domains used field time writing proved
relevant topological properties coincide well runtime behavior
indeed empirical suggest quality h often preserved ffs
approximation
interesting give rare example successful theoretical
analysis connections typical case structure search performance
practical point view provide clear picture strengths
weaknesses h lie form good basis embarking improving heuristic
weak cases approaches kind already appeared literature fox
long gerevini et al particularly fast downwards heuristic function
helmert motivated observations regarding unrecognized dead ends h
mystery domain large benches transportation domains non trivial road
maps
regarding relevance topological forward search
enforced hill climbing note things non existence unrecognized dead
ends non existence local minima certainly useful heuristic search
albeit form provable polynomiality generally
relevance topological performance planners search
remark easy even trivial syntactical restrictions actions
general respected relaxation example even every fact added single action
one construct cases non respected actions one case example figure
opp respected relaxation
except case heuristic function identifies precise goal distances case
h domains namely simple tsp domain



fiwhere ignoring delete lists works

paradigms enhanced heuristics lpg fast downward matter needing investigation one thing certainly clear easiest classes
taxonomy particularly domains state space local minima h benches escaped single step planner approximation
h likely work quite well indeed thats one observes practice intuition
author topology h plays large role efficiency planners
generally e domains proving disproving beyond scope
case investigation provides nice theoretical background
proved idealized setting used starting point
investigations tailored individual systems
investigation considers solvable tasks well justified
focus set international competitions turning focus unsolvable tasks
one realizes much techniques become useless search space
solution difference heuristic function make lies states
infinite heuristic value e states recognized dead ends means
interesting question remaining kinds dead end states
relaxed plan herein tell us domains
identified unrecognized dead ends tell us relaxed plans generous
approximation domains things look hopeful still
relative solvable instances whether h detect many dead end states
unsolvable tasks depend reasons states dead
ends unsolvable tasks may caused reasons solvable tasks
since assumptions making tasks solvable given note many
benchmarks example blocksworld logistics unsolvable instances
standard definition extent makes existence non existence
unrecognized dead ends choice domain designer extending domain definition
exploring issues detail topic future work
talking future work biggest drawback current form
obviously needs done every single domain would
desirable turns hard come generic ideally automatic
methods determine topological properties domain outlined
attempt made develop automatic methods analyzing properties fact
generation trees presented first promising regarding applicability
domains complexity one would able handle methods yet far
weak left future answer question approaches
topic work better practice said intuition better
approaches intelligent backchaining style reasoning goals
achieved domain time writing pure speculation
beside easening burden proofs hand benefits automatic domain analysis techniques would twofold first ambitious long term vision domainindependent arsenal complementary heuristics combine
hybrid system automatically configured best suit given arbitrary
task contribution made towards vision hand
unsurprisingly seeing deciding plan existence np hard example mystery mprime miconicadl freecell helmert



fihoffmann

clear picture strengths h lie able automatically configure hybrid system one would need multiple heuristics different strengths weaknesses
e heuristics high quality different classes domains well ability
determine automatically heuristic likely work best least could cost effective beside much insightful trying
possible combinations techniques
another benefit enhanced domain analysis techniques might lie ability
generate high quality admissible heuristic function sequential many domains optimal relaxed plans mostly consist actions easy human
see one set similar actions must contained optimal
relaxed plan example loading unloading actions cant avoided
transportation task number actions state could provide good lower
bound value h note phenomenon actions must contained
every relaxed plan stronger version notion actions respected
relaxation promising seems try detect former sufficient
approximation latter
since observed arbitrarily deep local minima h blocksworldarm none blocksworld arm one might try come encoding methods
trying model domain way making best suited h since blocksworld arm
basically version blocksworld arm possible pairs consecutive actions
pickup stack unstack stack unstack putdown replaced macro actions good
somewhat obvious heuristic modeling probably choose domain granularity
high level abstraction possible insightful heuristics may obtained
considering h topology benchmarks enriched automatically
detected macro actions botea muller schaeffer
apart important future direction adaption formal
framework theoretical analysis methods temporal numeric settings
dealt modern benchmarks modern systems needed
adaptations straightforward numeric framework used metric hoffmann
temporal objective function estimated heuristic
number actions needed complete partial plan adaptation framework
probably straightforward well however makespan estimated heuristic
said article apply setting
analysis techniques could relevant search uses estimation remaining action
steps secondary heuristic

acknowledgments
would thank drew mcdermott fahiem bacchus maria fox derek long
responses questions concerning definitions intentions behind
competition domains thank anonymous reviewers whose comments helped
improve



fiwhere ignoring delete lists works

appendix proof sketches
list proof sketches sections concerning dead ends local minima benches
order
dead ends
theorem state space solvable instance
blocksworld arm blocksworld arm briefcaseworld depots driverlog ferry
fridge gripper hanoi logistics undirected
grid miconic simple miconic strips movie pipesworld psr satellite
simple tsp tireworld zenotravel harmless
dining philosophers optical telegraph rovers schedule recognized evaluation h
proofs simple applications lemma said descriptions
domains looked appendix b
proof sketch theorem
actions blocksworld arm blocksworld arm driverlog ferry gripper hanoi
logistics instances invertible apply lemma finished
inverse actions obvious ones cases stacking unstacking block onto
block loading unloading object onto vehicle moving l
l moving l l case driverlog latter done
underlying road map bi directional c f appendix b briefcaseworld depots
fridge domains actions strictly obey definition invertible
neither least invertible still invert obvious way
e every state applicable action action ha ai
movie actions getting snacks irrelevant delete effects static add effects
rewinding movie resetting counter least invertible simple tsp action
moving l l least invertible moving back tireworld working steps
inverse one except inflating wheel irrelevant delete effects
static add effects miconic strips moving lift invertible boarding passenger
least invertible departing passenger irrelevant delete effects static add
effects four domains lemma thus applied miconic simple
grid domains actions strictly adhere relevant definitions similar
arguments lemma prove non existence dead ends miconic simple moving
lift invertible letting passengers lift inverted
actions need applied similar static add effects
interfere anything else similar irrelevant deletes grid actions
inverse action except opening lock latter action excludes actions opening
lock similar irrelevant deletes lock needs opened
locks closed static add effects zenotravel satellite facts
achieved sometimes one apply several actions zenotravel


fihoffmann

flying airplane l l get back l one might refuel airplane
top flying back satellite switching instrument one might recalibrate done involve several actions turning satellite
right direction applying actual calibration action pipesworld
push action inverted respective pop action vice versa state space
undirected since pushs pops non unitary pipeline segments split two parts
psr dead end states since one reach goal state waiting
necessary opening breakers bringing non breaker devices goal
position closing needed breakers
dining philosophers dead ends arise process philosopher initiated impossible reading writing command empty full queue
queue contents updated actions applicable derived
predicate rules determine process blocked apply case since
require read write command initiated yet obviously applicable
actions relaxed plan states goal reached
traversing individual process state transitions philosophers one fork try
take
optical telegraph dead ends arise two kinds situations first process
initiated impossible reading writing command similarly dining philosophers
applicable actions thus relaxed plan second possibility
two processes pair may take different decisions go next communication sequence one may decide stop data exchange may decide
send receive data situation least one processes state
two transitions available already activated one transitions
might already initiated respective write read command write read command
impossible since process took different decision actions
applicable process derived predicate blocking rules apply
process never apply process states one available transition
neither real relaxed plan exist state reachable states
goal reached traversing individual process state transitions pairs
communicating processes occupy one control channel try write
rovers plan state soil rock samples images
need taken rover job communicate
gathered data lander chance run dead end take soil rock
sample rover reach lander soil rock sample available
relaxed plan state
schedule state gd solved applying object
turn certain sequence working steps sequence applied object
follows preconditions needed action fulfilled must
case cold roll action applied previously
making hot operator make cold e operator adds respective
fact thus relaxed plan

note worst cases theorem occur e domains whose instances
harmless directed state transitions domains whose instances


fiwhere ignoring delete lists works

recognized dead ends remark dead ends dining philosophers
optical telegraph due seem bugs encoding queues
whose contents arent updated correctly blocked situations whose rules
detection seem incomplete modifying operators straightforward way
fix apparent bugs one gets dead end free harmless state spaces
domains mentioned theorem airport assembly freecell miconicadl mprime mystery domains one construct arbitrarily deep
unrecognized dead ends airport unrecognized dead ends arise two planes move
towards line segments possibility changing direction
deadlock situations arent recognized relaxed since relaxation
free space left two planes remains free used navigate planes
across dead end becomes arbitrarily deep independently
deadlock situation planes still moved remark reality
ipc example instances deadlock situations rarely occur airplanes
movable along standard paths serve avoid deadlocks main connecting
routes airport places airport deadlocks occur
reality ipc example instances near parking areas space
dense airplanes need move directions airport segment
deadlocks occur e planes move target positions one
without hindering h delivers exact goal distance
presumably reason heuristic planners performed well ipc airport
test suites performance would probably become worse one use unrealistic
instances excessively many potential deadlock situations
assembly unrecognized dead ends arise several objects stuck due
complex ordering constraints imply solution plan would need go
cyclic assembly pattern details rather complicated interested reader
referred tr hoffmann c proved unless ordering constraints
assembly instance potential yield cyclic situation dead
ends one ipc competition instances ordering constraints
potential helps explain efficient test suite
solves even largest task within half second search time finding plan
steps
freecell unrecognized dead ends arise example one cautious
enough moving cards free cells relaxed plan still achieve goal
single free cell cell intermediate store cards reality
however moving card free cell occupies space deleting availability
free cell thus exclude possibilities reaching goal thus moving card
free cell lead unrecognized dead end state unrecognized dead end
arbitrarily deep cards still moved around independently deadlock
situation
miconic adl unrecognized dead ends arise constraint violated
violation goes unrecognized relaxed plan example two passengers
p p lift p transported downwards p access
p destination floor p destination floor p state dead end
one let p get first p access respective floor


fihoffmann

neither one let p get first afterwards lift would need drive upwards
cant p board relaxation one stop destination floors
simultaneously facts deleted unrecognized dead end becomes
arbitrarily deep several passengers moved around reaching p
destination floor
mystery unrecognized dead ends arise fuel scarce vehicle makes suboptimal moves relaxed plan achieve goal long relevant locations
still accessible least may suffice reality dead end becomes arbitrarily deep additional objects transported independently problematic
situation mprime behaves similarly difference mystery example
avoid possibility transferring fuel items problematic locations one must make
sure enough fuel enable transportation additional objects
local minima
theorem h maximal local minimum exit distance state space
solvable instance
blocksworld arm briefcaseworld ferry fridge grid gripper hanoi logistics
miconic simple miconic strips movie simple tsp tireworld
zenotravel satellite schedule diningphilosophers
present proof sketch theorem terms three groups domains
similar proofs note domains maximal local minimum exit distance
domains local minima first focus domains
lemma slight extensions applied
proof sketch theorem ferry fridge gripper logistics miconic simple miconicstrips movie simple tsp tireworld
theorem none listed domains contains dead ends said proof
sketch theorem actions ferry gripper logistics miconic strips movie
simple tsp tireworld domains least invertible irrelevant delete
effects lemma suffices actions respected relaxation
cases except driving flying actions logistics easy see
optimal starting action something avoided relaxed plan
example relaxed plan avoid load unload objects onto vehicles
avoid missing working steps tireworld optimal starting action
logistics drives truck flies airplane location l object must
loaded unloaded l relaxed plan choice apply action
moves transportation vehicle kind vehicles equally good except
clever choice e vehicle already carries objects unloaded
l move one vehicles optimal relaxed plan
vehicles equally good relaxation ferry gripper miconic strips


fiwhere ignoring delete lists works

single vehicle makes moving actions domains easier
reason
fridge miconic simple domains actions adhere strictly
definitions invertibility irrelevant delete effects proof theorem
shown similar semantics e inverted delete
facts longer needed applied furthermore actions
domains respected relaxation fridge missing working steps must
done relaxed plan miconic simple lift moves trivially respected lift
stops respected since clever choices reality coincide clever choices relaxed
plan

next four domains local minima proofs
sophisticated make use rather individual properties respective domains
cases proved path goal h increase
proof sketch theorem blocksworld arm briefcaseworld grid hanoi
theorem none domains contains dead ends blocksworld arm
optimal starting action stacks block goal position starts
optimal relaxed plan better thing achieve goal
immediately relaxed plan replaced inverse counterpart form
relaxed plan successor state action state one
optimal plan starts putting block b must moved order access block
block c onto table yielding state relaxed plan
constructed relaxed plan p taking account case
distinctions replacing move actions regarding b p number
move actions case distinctions kind action p uses move b
away c one action must contained p moves b table
replace p action moves b back onto c finished else
must distinguish cases b required c goal
block cases make successful use fact b moved
position position within single action enabling us exchange actions
p quite flexibly
briefcaseworld actions inverted actions put objects briefcase
trivially respected relaxation state optimal plan starts
take action optimal relaxed plan used successor state since
taking object delete important facts state optimal plan
starts move action l l p relaxed plan relaxed plan
successor state constructed replacing moves l l l l p
moves l l
grid rather complex procedure applied identify flat path state
better h value state let p optimal relaxed plan let
first unlock action p putdown unlock action identifying flat
path state applied suffices unlocking deletes facts
irrelevant lock open deletes putting key irrelevant
locks must opened selected action uses key k


fihoffmann

position p p contains sequence actions moving p moving along path defined
actions increase h since actions contained relaxed plan
inverted k already held apply hand
empty key held one use p identify flat path state
one hold appropriate key k hand empty p must contain
sequence actions moving location k picked key
held p must contain sequences actions moving locations series
keys picked put key series ends picking k
hanoi proved optimal relaxed solution length state equal
number discs yet final goal position proceeding
smallest largest disc respective goal achieved single action
optimal plan moves disc away final position h increase optimal
solution paths

finally consider four domains local minima one
escape within constant number steps cases prove upper bound
distance non dead end state state h h immediately
implies upper bound maximal local minimum exit distance
implies upper bound maximal bench exit distance
used appendix
dining philosophers h loosely connected goal distance bound
holds even trivial heuristic function returning number yet un blocked
philosophers follows rather constant restrictive domain structure
three domains proofs proceed follows reachable state identify constant
number steps suffices execute one action optimal relaxed plan
without deleting relevant add effects achieve relevant facts deleted
state h h reached
proof sketch theorem dining philosophers satellite schedule zenotravel
theorem dead ends dining philosophers recognized non
dead end state shortest relaxed plan blocks processes philosophers
yet blocked individual process steps needed relaxation
block process suffices activate state transition initiate read write
command queue update update queue empty full
read write impossible sense blocking rules apply
process block relaxation h value fairly loosely correlated
true goal distance thus reach state lower h value obviously
suffices block one process prove upper bound determining constant
bound number steps needed bound exists beside
fact philosopher processes constant interfere respective
two neighbors table philosophers fixed order try pick
forks first try pick fork right fork left
restricts possible combinations internal states neighbored philosophers
detail philosopher blocked iff tries pick fork
table philosopher p refer pl ps neighbor philosopher left side


fiwhere ignoring delete lists works

description different states philosopher process appendix b let
non dead end state let p philosopher blocked p exists
goal state nothing prove prove desired upper bound
exhaustive case distinction states p pl state
p consider state il pl combination il
possible nothing else determine number k process state transitions
leads state p blocked pl still blocked blocked
pl blocked blocked cases
make distinctions internal state pls left neighbor pll worst case k
occurs e p holds adjacent forks pl
state il il means pl cant hold fork pl p since
held p il pl blocked pl put left fork getting
state pl blocked since waits pick right fork held p il
distinguish two cases state pll p holds
adjacent forks il pl waits pick fork p pl pl
blocked case state pll pll holds fork pll
pl go p go pl
p pl blocked since wait pick fork left case b
state pll fork pll pl table pll
blocked go pll pll holds
fork pll pl case apply sequence getting us
state pll possibly blocked p pl definitely blocked
need process state transitions block one philosopher
process state transitions take actions makes
steps steps needed due subtleties pddl encoding
subtlety process may already decided go state yet arrived
e respective transition activated read write command initiated
communication channel queue occupied transition yet complete
steps needed reach next internal state update queue wrap
transition subtlety b blocked state process must activate outgoing
transition worst case described p pl pll may require
steps induced subtlety p pl require step induced subtlety b
get actions effect last action one process
becomes blocked upper bound exit distance
theorem dead ends satellite let reachable state
determine upper bound distance state h h
one look optimal relaxed plan p distinguish four cases regarding
existence applicable actions different types p action type constant
number steps suffices achieve deleted facts application action
worst case arises switch action applied switching instrument
deletes instruments calibration achieve one must turn satellite
calibrate another turn taking image state lower h value reached
theorem dead ends schedule recognized let non dead
end state determine upper bound distance state
h h one look optimal relaxed plan p distinguish seven


fihoffmann

cases regarding kinds applicable actions p contains worst case
arises roll action available applicable p one needs
apply time step lathe action achieve desired effects roll another time
step polish grind action achieve previous surface condition another
time step immersion paint action achieve previous color
theorem dead ends zenotravel reachable state determine
desired constant distinguishing two cases job relaxed plan p
contains applicable boarding departing refueling action applying action
leads state lower h value else p starts flying action better
state reached executing flight refueling boarding departing
person get

note proved bound dining philosophers holds even take heuristic
function trivial one returns number yet un blocked philosophers
extremely cumbersome figure exactly worst case exit distance diningphilosophers h one consider combinations possible states
neighbored processes possible developments lot action steps rather
un intuitive pddl encoding made automated translation machinery highest
exit distance could actually construct dining philosophers conjecture
tight upper bound
satellite schedule zenotravel proved upper bounds tight
dining philosophers satellite schedule zenotravel bounds valid nondead end state beside bound local minimum exit distance
provide bound bench exit distance use appendix
blocksworld arm depots driverlog optical telegraph pipesworld psr rovers
one construct local minima arbitrarily large exit distances blocksworld arm
example situation n blocks b bn initially form stack bi
bi bn table goal build stack top
another block bn e goal stack b bn bn reaching initial state
state better h value involves disassembling entire stack b bn
disassembling process h increases example used depots
driverlog local minima arise due different road maps trucks drivers
example takes one step drive location l another location l n
steps walk relaxed plan driver drive truck goal
staying reality driver walk way back
optical telegraph treated easily reconsidering diningphilosophers domain proved constant upper bound reason
optical telegraph basically permissive version dining philosophers
philosophers choose fork pick first hold forks
fork want put first consider configuration depicted figure
configuration reachable given automata underlying dining philosophers
reachable given automata underlying optical telegraph
figure nietzsche holds adjacent forks kant holds none tries
get access fork right nietzsche kant arbitrarily
many philosophers hold one fork trying access


fiwhere ignoring delete lists works

kant

nietzsche

figure unreachable situation dining philosophers unbounded local
minimum h would arise arrows indicate pickup requests

non blocked philosopher nietzsche put forks
pddl encoding world state nietzsche activated transition
putting right left fork h value relaxation suffices
initiate write command update queue contents write command
initiated however h goes transition become non activated
relaxed plan update queue contents wrap transition activate
transition reaching state h value involves propagating
forks entire sequence philosophers nietzsche kant
right hand side left hand side example say nietzsche puts forks
picks right fork philosopher left nietzsche pick
requested fork nietzsche pick gets us back started
resulting state situation except philosopher
nietzsche role sits one position left iterating procedure
around left side table kant pick requested fork request get
giving us goal state philosophers blocked state h value
one kant yet activated transition request fork
configuration figure reachable dining philosophers domain
used ipc philosopher pick fork left hand
side first done figure philosophers nietzsche kant
nietzsches left hand side said optical telegraph philosophers
freedom choice situation reachable detail described
appendix b optical telegraph n pairs communicating processes
pairs arranged cycle pair control channel internally
two processes within pair go fairly long heavily interactive sequence
operations implementing possibility exchange data two stations


fihoffmann

operations begin processes occupy write one
control channel one processes occupies channel waits signal
process indicating second control channel occupied well
data exchange terminated control channels get released read
arbitrary order overall system blocked iff process pairs state
occupied one control channel waiting occupy thus
process pairs correspond exactly philosophers choose fork pick put
first figure provides example arbitrarily high exit distance
local minimum state precisely local minimum state one nietzsche
process pair occupied channels process blocked second
channel activated transition sending occupied one signal
state h value processes except active one blocked
pipesworld consider situation several areas form circle unitary
connections local minimum state single goal batch g go area
g currently segment adjacent contains batch b areas empty
shortest plan push b segment adjacent propagate
batches around circle g pushed shortest relaxed plan
however push b push g side e g used
push goal area reaching nearest state h value requires n
steps n areas circle path h value increases note
example uses neither tankage restrictions interface restrictions non unitary
pipeline segments
psr deep local minimum given n breakers feed individual goal line
way breaker feed breakers goal line without breaker
closed breakers connected faulty line one
breakers closed h value state close single open breaker since
unsatisfied goal condition beside supplying line fed open breaker
one postulating breaker affected condition negated derived predicate
thus ignored relaxation applicable action state wait
breakers open shortest relaxed plan close yielding
h value n obviously nearest state h value least n steps away
rovers local minima arise taking image deletes calibration
camera example n waypoints w wn connected line
e wi connected wi lander w one rover camera c must used
take two images w c calibrated wn rover w
c calibrated relaxed plan take two images communicate two
data pieces taking one image one navigate way wn calibrate
c get back note example makes use road map arbitrarily large
diameter diameter rovers instance longest way rover must travel
order get one waypoint another general distance state better
h value bounded diameter instance see details
tr road map diameter ipc rovers instances varies around
remark counter example remains valid ipc simple adl strips formulations
psr use different encoding derived predicates negation formulate
goal breaker affected



fiwhere ignoring delete lists works

airport assembly freecell miconic adl mprime mystery domains
seen appendix contain unrecognized dead ends proposition
local minimum exit distance domains unbounded assembly
tr describes detail initial state instance path goal
h decreases monotonically unless complex interactions ordering
constraints present instance none ipc instances features complex
interactions assuming ffs search sticks monotonically decreasing
paths gives another indication system efficient example
suite
benches
theorem h maximal bench exit distance state space solvable
instance simple tsp ferry gripper logistics
miconic simple miconic strips movie
zenotravel satellite schedule tireworld
dining philosophers
subdivide proof sketch theorem groups domains
similar proofs first consider transportation type domains lemma
similar proof arguments applied
proof sketch theorem ferry gripper logistics miconic simple miconic strips
proofs theorems shown domains actions
respected relaxation domains except miconic simple
actions invertible relevant delete effects determine upper bound
exit distance benches thus apply lemma requires us
state optimal plan th action relaxedplan relevant delete effects miconic simple seen actions
adhering syntactic conditions invertibility relevant delete effects
similar semantics proof technique applied
transportation type domains consideration argument roughly
load type unload type actions relaxed plan relevant delete effects
move type actions need applied row locations
immediately accessible implies upper bound maximal
exit distance concretely say reachable state logistics instance starts
optimal plan p optimal relaxed plan starts applying
yields state loading unloading action delete fact transported object object loaded respective location
unloaded respective vehicle optimal relaxed plan p
relaxed plan relevant delete effects exit otherwise drives flies vehicle
v l l exit optimal plan starts loading unloading
package v miconic strips miconic simple arguments
apply ferry arguments remain valid except optimal start action
state boards car action deletes available free space


fihoffmann

ferry relaxed plan p contains actions move ferry
location l debark car l otherwise would point boarding
car placing actions front p removing yields relaxed plan
state applying similar argument applied prove
claim gripper gripper hands hold one ball time note
argument ferry gripper uses somewhat weaker notion relaxed plan relevant
delete effects effects undone actions contained
relaxed plan

next come non transportation domains lemma applied
proof sketch theorem movie simple tsp tireworld
proofs theorems shown domains actions
respected relaxation least invertible irrelevant delete effects
apply lemma cases
movie actions therefore relaxed plan relevant delete effects
single exception rewinding movie deletes counter zero
obviously optimal plan rewinds movie twice row thus desired
upper bound
simple tsp suffices say reachable state one location
l optimal plan starts action visiting yet unvisited location l optimal
relaxed plan start visit remaining unvisited location l
move l l latter actions require preconditions deleted
every action relaxed plan relevant delete effects
tireworld lowest constant upper bound non final working steps
jacking hub flat wheel need undone later e
relaxed plan relevant delete effects final working steps jacking hub
need undone e relaxed plan relevant delete effects longest
sequence non final working steps optimal plan row following
step one open boot must closed fetch wrench jack
must put away loose nuts hub thats got flat wheel nuts must
tightened jack respective hub must jacked undo
nuts must done resulting state one remove flat
wheel needs undone

remaining domains theorem claims constant upper bound
maximal bench exit distance seen appendix upper bounds
distance reachable state state h h upper
bounds trivially imply upper bounds maximal bench exit distance
proof sketch theorem dining philosophers satellite schedule zenotravel
follows directly proof theorem



domains except last four one easily construct examples
bench exit distance equal proved upper bound satellite schedule


fiwhere ignoring delete lists works

zenotravel open question whether tighter bounds bench exit
distance local minimum exit distance seem particularly relevant
though dining philosophers said may even bound
local minimum exit distance tight
blocksworld arm briefcaseworld fridge grid hanoi domains theorem proves local minima important know whether
arbitrarily difficult escape benches answer yes cases blocksworldno arm example one already used blocksworld arm depots
bounds local minimum exit distances n blocks
b bn initially form stack bi bi bn table goal
build stack top another block bn e goal stack b bn bn
shortest relaxed plan initial state n steps long remove stack top
bn move bn onto bn nearest state h value n one bn
already stacked onto bn state n steps away initial state
briefcaseworld bench exit distance becomes large many objects must
taken briefcase relaxation point taking objects since
moving briefcase delete facts consider state n objects
inside briefcase location l goal l
briefcase another location l h moving briefcase l suffices
relaxation nearest goal state h n steps away one must take
objects moving l
fridge single fridge compressor held n screws exit distance
initial state n reach better state one must stop fridge must
turned back relaxed plan unfasten n screws must fastened
relaxed plan remove broken compressor needs undone
deletes fact broken compressor attached fridge
grid consider instances robot located n grid line without
locked locations robot starts leftmost location shall transport key
rightmost location left end initial value h n walk
key pick put facts deleted value get
better robot actually picked key
hanoi seen h equal number discs yet
goal position thus maximal bench exit distance grows exponentially
number discs initial state instance n discs takes n steps
move first e largest disc goal position
domains local minimum exit distance arbitrarily large
relevant whether bench exit distance bounded escaping bench
might planner better ending huge local minimum remark
example driverlog rovers mprime mystery one easily construct examples
large bench exit distances defining road maps large diameters e
basically example used grid domain
fact one easily prove n upper bound bench exit distance fridge
instances compressors held n screws details tr



fihoffmann

appendix b domain descriptions
following list brief descriptions investigated domains explain
overall idea behind domain available operators initial states
goals cases set instances obvious restrictions explained
remark points domain semantics seem bit odd example
zenotravel difference flying zooming plane zooming consumes
fuel odd points presumably domain bugs overlooked
respective domain designers corrected bugs investigation
meant determine properties benchmarks used community
domains listed alphabetical order
b airport
airport domain planner safely navigate ingoing outgoing traffic
given point time across airport main constraint planes
must endanger come close others running
engines constraint modeled letting plane block segments
engines currently endanger planes enter blocked areas five operators
plane moved one airport segment another plane facing right
direction planes get endangered action similarly plane pushed
back cause trouble one start engines plane let plane
take let plane settle parking position initial state specifies current
positions orientations planes goal specifies planes outbound
take inbound parking positions
b assembly
assembly domain complex object must constructed assembling parts
together obeying certain ordering constraints parts might need
assembled way beforehand parts transient means
must integrated temporarily collection machines resources
might needed working steps four operators available resource
committed object deleting resources availability releasing resource
object inverse action available object x assembled object
x part transient part resources requires committed
objects assemble order x already incorporated
effect x incorporated longer available becomes available
parts except x already incorporated transient part incorporated
incorporated object x removed resources requires committed
given x transient part part objects remove order
assemble order x incorporated incorporated effect x available
longer incorporated becomes available parts incorporated
transient parts except x incorporated instances part relation
forms tree goal make root object tree available


fiwhere ignoring delete lists works

assemble remove order constraints consistent cycle free restrictions hold
true aips competition examples
b briefcaseworld
briefcaseworld number portables must transported transportation
done via conditional effects move actions three operators putting
portable location done portable briefcase respective
location portable yet inside taking portable done inside
move applied two locations achieves beside fact
briefcase respective facts portables inside e portables inside
moved along conditional effects goal briefcase subset
portables goal locations
b blocksworld arm
blocksworld arm variant widely known blocksworld domain three
operators one move block table onto another block one move block
another block table one move block another block onto third
block initial state instance specifies initial positions blocks goal
state specifies consistent e cycle free set facts
b blocksworld arm
instances blocksworld arm blocksworld arm difference blocks moved via single robot arm hold one block time
four operators one pickup block table one put block
arm holding onto table one unstack block
block finally one stack block arm holding onto block
b depots
depots domain kind mixture logistics blocksworld arm
set locations set trucks set pallets set hoists set crates
trucks transport crates locations hoists used stack crates onto
crates onto pallets six operators move truck different
locations load crate held hoist onto truck location unload
crate hoist truck location lift crate hoist surface
pallet crate location drop crate held hoist onto surface
location hoist hold one crate time crates initially arranged
arbitrary stacks bottom crate stack standing pallet goal
arrange crates arbitrary stacks possibly pallets
involve transporting crates locations pallets moved


fihoffmann

b dining philosophers
dining philosophers encoding well known dining philosophers
task planner deadlock situation arises every philosopher
taken single fork pddl domain created automatic translation
automata promela language automata referred processes
promela philosopher finite automaton process works follows
start state state transition puts right fork onto table initialization
step getting state loop four states state state
philosopher takes right fork takes left fork
puts right fork state puts left fork gets back state
process communicates neighbors communication
channel queue contains fork empty one adjacent philosophers
currently holding fork
pddl encoding process state transition broken four actions
first action activates chosen transition second action initiates write read
command needed queue deleting activation transition setting flags
queue update third action updates possible queue contents update
possible write command shall done full queue queue already contains
fork read command shall done empty queue fourth action wraps
process state transition setting flags
derived predicates used model conditions process blocked
rules require outgoing transitions current state process blocked
transition blocked activated would need perform impossible queue
write read operation sense impossible write read operation yet
initiated applying action initiating impossible write read
command blocking rules dont apply anymore resulting state dead end
tasks state space blocking situation process network
according derived predicate rules modeling blocking
remark ipc version dining philosophers modeled
process blocking via additional operators derived predicates chose
consider domain version since constitutes natural concise
formulation since planners ipc scaled version without
derived predicates
b driverlog
driverlog variation logistics drivers needed trucks
drivers trucks move along arbitrary bi directional road maps road maps
drivers trucks different operators load unload object onto
truck location board disembark driver onto truck location walk
one outgoing transition activated time process never become blocked
state one outgoing state transition appears bug translation
promela pddl intuitive requirement would activated transition needs
blocked outgoing transition need activated order blocked note
dining philosophers every automaton state one outgoing transition



fiwhere ignoring delete lists works

driver location another one drive truck driver location
another one preconditions effects loading unloading objects obvious
ones driver board truck truck empty effect truck longer
empty well driven driver disembarking driver inverse action
order walk driver l l must path l l order drive
truck l l link l l must driver
truck paths links form arbitrary particular potentially different graphs
locations restriction undirected e truck driver
move l l move back restriction imposed driverlog
instances generated ipc generator
b ferry
ferry single ferry used transport cars locations one time
three operators one sail ferry two locations one board car onto
ferry location deletes empty ferry fact plus adding car
ferry deleting car location one debark car ferry
location achieves empty ferry plus adding car location
deleting car ferry goal subset cars goal
locations
b freecell
freecell domain strips formulation widely known solitaire card game
comes microsoft windows number cards different suits initially
arranged random stacks number columns cards must put home
suit cards separate home column cards suit must
stacked increasing order card value number free cells cards
moved around according certain rules card clear card top
clear card put free cell already free cell holds
one card time clear card moved onto empty column clear card
c put home last card put home suit one preceding c c
c clear cards differently colored suits one stack c top c c
free cell cs card value one less card value c stacks
built columns decreasing order card value alternating colors goal
reached topmost cards suits put home
b fridge
fridge one must replace broken compressor fridge one must remove
compressor involves unfastening screws hold compressor
turn involves first switching fridge goal compressor attached
fridge screws fastened fridge switched back origin domain
strips formulation consider adaptation allows arbitrary number
fridges screws compressor fastened arbitrary least one
number screws adaptation involves adl precondition compressor


fihoffmann

removed screws unfastened six operators one stop start fridge
one unfasten fasten screw compressor attached fridge
fridge needs turned compressor needs attached screw must fit
compressor finally one remove attach compressor fridge removing
compressor requires fridge turned none screws fit
compressor fastened effect compressor longer attached fridge
fridge compressor free attaching compressor requires fridge
turned compressor fits fridge effect compressor attached
compressor fridge longer free
b grid
grid robot must move along positions arranged grid reachability
relation positions locked keys different shapes open
goal keys goal positions five operators one
move position p position p requires apart obvious preconditions
p p connected p open locked one pick key
position requires arm empty one hold one key time
effects one holds key arm longer empty key
longer position putting key position inverse action one
abbreviate two previous actions pickup lose keys k k
position one must hold k directly exchanged k e effects
one holds k k position finally one unlock position p one
position p connected p holds key shape locked
position p add effect p open delete effect position longer
locked instances specify initial locations keys locked positions
robot well shapes keys locked positions goal specifies
positions subset keys robot starts open position
make significant difference robot allowed start locked position
local minima h otherwise none c f theorem intuitively makes
sense let robot located open positions restriction holds true
published benchmark examples
b gripper
gripper task transport number balls one location another
three operators one move locations one pick ball location
hand apart obvious preconditions requires hand empty
effects obvious ones ball hand longer room plus
hand longer empty one drop ball location hand inverts
effects picking action exactly two locations two gripper
hands instances thus differ terms number balls severe restrictions
hold true aips instances remark adding locations hands
moving away locked initial position lead need applying several steps open
position relaxed plan initial state realize since ignores delete
initial fact



fiwhere ignoring delete lists works

affect topological properties h fact proof arguments given
theorems remain valid case
b hanoi
hanoi domain strips encoding classical towers hanoi
n discs dn three pegs p p p single operator moves
object x object onto object z operator parameters grounded
discs well pegs preconditions move x x clear z
clear x smaller z effects x z clear x
longer z longer clear semantics towers hanoi encoded via
smaller relation relation holds obvious way discs discs
smaller pegs pegs smaller anything moved
instances differ terms number n discs must transferred p
p
b logistics
logistics classical transportation domain objects must transported within
cities trucks different cities airplanes six operators
drive truck two locations within city fly airplane two airports
load unload object onto truck location load unload object
onto airplane airport operators obvious preconditions
effects complicated operator moving truck whose precondition
requires locations within city least one city
city non zero number locations one airport arbitrary
number objects airplanes located airports goal
subset objects goal locations
b miconic adl
miconic adl adl formulation complex elevator control occurring
real world application koehler schuster number passengers
waiting number floors transported lift obeying variety constraints
least one floor arbitrary number passengers
given origin destination floor three operators lift move
floor f floor f f transitively f vice versa moving downwards
lift stop floor floor f conditional effects
stopping action passengers waiting f boarded passengers wanting get
f depart goal serve passengers e bring destination
floor constraints must obeyed following
cases passenger p access floor f lift stop f
p boarded
passengers vips long served lift stop
floors vip getting


fihoffmann

passengers must transported non stop e boarded lift
make intermediate stops stopping destination floor
passengers travel alone others attend one former
kind boarded must least one latter kind
groups b passengers allowed people
groups boarded simultaneously
passengers transported direction travel e
need go boarded lift move
downwards upwards
constraints formulated means complex first order preconditions
operators
b miconic simple
miconic simple domain miconic adl described except
constraints
b miconic strips
miconic strips domain almost miconic simple domain see
difference boarding departing passengers done conditional
effects stopping operator explicitly separate strips operators one board
passenger floor precondition current floor passengers origin
effect passenger boarded one let passenger depart
floor preconditions current floor passengers destination
passenger boarded effects passenger served longer
boarded
b movie
movie task prepare watching movie seven different operators
one rewind tape adds tape rewound deletes counter
zero one reset counter effect counter zero one
get five different kinds snacks add effect one respective
snack instances differ terms number items sort
snacks goal one snack sort tape rewound
counter zero
b mprime
mprime transportation kind domain objects must transported
locations means vehicles vehicles use non replenishable fuel instance
set l locations set objects set v vehicles
sets f fuel numbers space numbers location initially certain fuel


fiwhere ignoring delete lists works

number number fuel items available location vehicle certain
space number number objects vehicle carry time operators
move vehicles locations load unload objects onto vehicles
transfer fuel units locations move location l location l
made l l connected connection relation arbitrary graph
least one fuel unit available l l fuel number lower neighbor
effect move respective vehicle located l amount fuel l
decreased one unit e l assigned next lower fuel number similar fashion
object loaded onto vehicle space effect available
space decreases unloading object frees space transfer operator
transfer one fuel unit location l location l l l connected l
least two fuel units left applying operator ls fuel number decreases
one l fuel number increases one note way gain fuel items
one transfer around one obtain ones goal transport
subset objects goal locations
b mystery
mystery exactly mprime domain described except
operator transfer fuel items
b optical telegraph
dining philosophers domain described appendix b optical telegraph
pddl compilation originally formulated automata promela
language mechanics pddl compilation dining philosophers
derived predicates detect blocked situations involves n pairs communicating processes pair featuring process pair go
fairly long heavily interactive sequence operations implementing possibility exchange data two stations data exchanged initializing
steps must taken ensure processes working synchronously importantly
process writes token control channel queue beginning
sequence reads token end causes deadlock situation
n control channels accessed two processes
precisely process pairs arranged cycle pair control channel overall system blocked iff process pairs state
occupied written one control channel waiting occupy
sense optical telegraph viewed version dining philosophers
internal states philosophers complicated particular philosophers
process pairs choose order pick forks occupy control
channels turns see appendix latter important impact
topology h
remark ipc version optical telegraph modeled
process blocking via additional operators derived predicates chose
consider domain version since constitutes natural concise


fihoffmann

formulation since planners ipc scaled version without
derived predicates
b pipesworld
pipesworld units oil derivatives called batches must propagated
pipeline network network consists areas connected pipe segments different
length pipes completely filled batches times one pushes batch
one end pipe last batch currently pipe comes end
interface restrictions concerning types oil derivatives allowed
adjacent inside pipe tankage restrictions concerning
number batches derivative type stored point time
individual areas
available operator push batch pipe ipc encoding domain look non unitary pipe segments pipes
containing one batch operator split two parts start finish
action order reduce number operator parameters needed correctly update
pipe contents pipe segments encoded directed fashion making necessary
distinguish symmetrical push pop actions initial state specifies
current batch positions etc goal specifies batches brought
areas
b psr
psr domain used ipc task supply given set lines faulty
electricity network nodes network breakers feed electricity
network devices switches used change network
configuration edges network lines connecting two three nodes
breakers devices open closed open disconnect
lines adjacent breakers closed feed electricity adjacent
lines lines faulty goal ensure none breakers
affected e feeds electricity faulty line transitive connections
network goal requires given set lines transitively fed
electricity breaker
transitive network semantics determining breaker feeds electricity
line breaker affected modeled means derived predicates
recursive rule antecedents enable computation transitive closure three
operators one open device breaker currently closed one
inverse closing action actions require precondition breaker
currently affected latter untrue e breaker currently affected
available action wait effect open breakers affected
remark ipc different version psr formulated
pure strips without derived predicates version constitutes however relatively
superficial pre compiled form domain hoffmann edelkamp edelkamp et al
included ipc order provide pure strips planners


fiwhere ignoring delete lists works

domain formulation could tackle pre compilation necessary order enable
formulation pure strips
b rovers
rovers number rovers must navigate road map waypoints take rock
soil samples well images communicate data number landers
nine available operators following one navigate rover one waypoint
another waypoints must connected rover one sample
soil rock rover waypoint store rover must
empty store equipped soil rock analysis must soil rock sample
waypoint effect one soil rock analysis store full soil rock
sample longer waypoint one empty full store dropping store one
calibrate camera waypoint objective one take image
objective mode camera waypoint operators object must
visible waypoint camera must board rover equipped
imaging calibrate camera object must calibration target
effect operator calibration camera take image camera must
calibrated support required mode effects one image data
camera longer calibrated finally three operators
rover communicate soil rock image data lander landers waypoint
must visible rover effect data communicated
instances restricted visibility connectivity waypoints
bi directional waypoint w visible waypoint w holds true vice
versa rover move w w move back another restriction
camera initially calibrated serves make sure reachable state
calibrated camera least one calibration target restrictions imposed
rovers instances generated ipc generator
b satellite
satellite satellites need take images different directions certain modes
appropriate instruments number satellites number directions number
instruments number modes following five operators one
turn satellite direction another one preconditions effects obvious
ones action applied pair directions connectivity constraints
one switch instrument board satellite satellite power available
effect instrument power longer calibrated satellite
power available one switch instrument board satellite instrument
power effect satellite power available instrument anymore
one calibrate instrument board satellite direction satellite points
direction instrument power direction calibration target
instrument effect calibration camera finally one take
image instrument board satellite direction mode
satellite must point direction camera must support mode power
calibrated effect one image direction mode


fihoffmann

goal images number direction mode pairs satellites
goal requirement point specified direction initial states
satellite instrument power available instrument calibrated
former restriction makes sure satellite power run one instrument
time latter restriction makes sure reachable state calibrated instrument
least one calibration target restrictions imposed satellite instances
generated ipc generator

b schedule
schedule collection objects must processed number machines applying
working steps change objects shape surface condition color one drill
holes varying widths varying orientations nine operators eight
describe working steps object machine amongst things operators
preconditions require scheduled elsewhere machine busy
operators effect scheduled machine busy ninth
operator time step whose effect object scheduled machine
busy longer one apply roll action object makes cylindrical
hot longer cold see deleting surface conditions colors
holes might one apply lathe making cylindrical rough
surface deleting colors might painted one apply
polish cold giving polished surface one apply grind
giving smooth surface colors one apply punch width w
orientation cold resulting hole w rough surface one
apply drill press cold making hole width w orientation
changing none os properties except making hole cold one
apply spray paint color c deleting surface conditions might
finally one apply immersion paint changing none os properties except
color note operator change os temperature except roll
makes hot made cold reason dead
ends arise c f theorem initially objects cold shape
surface condition specified objects painted initially object
none several holes goal condition objects required
cylindrical shape shape produced machines
need surface condition must painted object required
arbitrary number holes

b simple tsp
simple tsp trivial version tsp single operator move
locations applied two different locations effect
besides obvious ones destination location visited instances specify
number locations must visited starting one


fiwhere ignoring delete lists works

b tireworld
tireworld one must replace number flat tires involves collection objects
must used appropriate working steps briefly summarized situation
follows thirteen operators boot opened closed
initially closed shall end pump wrench jack
fetched put away boot initially boot
shall put back end spare wheels initially inflated inflated
pump add effect wheel inflated delete effect
longer inflated hub fastened nuts loosened tightened
wrench respective hub ground jack used
jack jack hub hub jacked one undo loose nuts
nuts undone one remove respective wheel put one
optimal solution plan open boot fetch tools inflate spare wheels loosen
nuts turn jack hub undo nuts remove flat wheel put spare
wheel nuts jack hub tighten nuts put away tools
close boot
b zenotravel
zenotravel transportation domain variant vehicles called aircrafts use fuel
units replenished refueling operator number cities
number aircrafts number persons number different possible fuel levels
fuel levels encode natural numbers next predicate next f f true iff f
next higher fuel level f task transport subset persons
initial locations goal locations following five operators one
board debark person onto aircraft city obvious preconditions effects one fly aircraft city different city decreasing
aircrafts fuel level f f f must aircrafts current fuel level f must
next lower level one zoom aircraft exactly flying except
zooming uses fuel aircrafts fuel level decreased two units finally
one refuel aircraft city fuel level f fuel level f conditions
f aircrafts current fuel level f next higher level thus aircrafts
refueled city steps one unit

references
bacchus f aips competition ai magazine
biundo fox eds recent advances ai th european
conference ecp lecture notes artificial intelligence durham
uk springer verlag
blum l furst l fast graph analysis
mellish ed proceedings th international joint conference artificial
intelligence ijcai pp montreal canada morgan kaufmann


fihoffmann

blum l furst l fast graph analysis artificial
intelligence
bonet b geffner h heuristic search biundo
fox biundo fox pp
bonet b geffner h heuristic search planner ai magazine

bonet b geffner h b heuristic search artificial intelligence

bonet b loerincs g geffner h robust fast action selection mechanism
kuipers b j webber b eds proceedings th national
conference american association artificial intelligence aaai pp
portland mit press
botea muller schaeffer j component abstraction automatic
generation macro actions koenig et al koenig zilberstein koehler
pp
botea muller schaeffer j learning partial order macros solutions
biundo myers k rajan k eds proceedings th international
conference automated scheduling icaps pp monterey ca usa morgan kaufmann
brazdil p jorge eds epia proceedings th portuguese conference artificial intelligence epia porto portugal springer verlag
bylander computational complexity propositional strips
artificial intelligence
cesta borrajo eds recent advances ai th european
conference ecp lecture notes artificial intelligence toledo
spain springer verlag
chen hsu c wah b sgplan subgoal partitioning resolution
edelkamp et al edelkamp hoffmann littman younes
chen wah b automated scheduling calculus variations
discrete space giunchiglia et al giunchiglia muscettola nau pp

chien kambhampati r knoblock c eds aips proceedings
th international conference artificial intelligence systems aips
breckenridge co aaai press menlo park
b kambhampati sapa domain independent heuristic metric
temporal planner cesta borrajo cesta borrajo pp
edelkamp promela ball rajamani eds proceedings
th international spin workshop model checking software spin
pp portland springer verlag
edelkamp b taming numbers durations model checking integrated
system journal artificial intelligence


fiwhere ignoring delete lists works

edelkamp helmert mips model checking integrated system
ai magazine
edelkamp hoffmann j englert r liporace f thiebaux trug
engineering benchmarks domains used deterministic part
ipc journal artificial intelligence submitted
edelkamp hoffmann j littman younes h eds ipc proceedings
th international competition whistler bc canada jpl
fox long automatic inference state invariants tim journal
artificial intelligence
fox long stan hybrid strategy subproblem
abstraction ai magazine
frank j cheeseman p stutz j gravity fails local search topology
journal artificial intelligence
gazen b c knoblock c combining expressiveness ucpop
efficiency graphplan steel alami steel alami pp
gerevini schubert l inferring state constraints discoplan
kautz porter kautz porter pp
gerevini schubert l discoplan efficient line system computing
domain invariants cesta borrajo cesta borrajo pp

gerevini saetti serina stochastic local search
temporal action graphs journal artificial intelligence
gerevini serina lpg planner local search graphs
action costs ghallab et al ghallab hertzberg traverso pp

gerevini serina saetti spinoni local search techniques temporal
lpg giunchiglia et al giunchiglia et al accepted
publication
ghallab hertzberg j traverso p eds aips proceedings th
international conference artificial intelligence scheduling aips toulouse france morgan kaufmann
giunchiglia e muscettola n nau eds icaps proceedings
th international conference automated scheduling icaps
trento italy morgan kaufmann
haslum p geffner h admissible heuristics optimal chien
et al chien kambhampati knoblock pp
helmert complexity standard benchmark domains
artificial intelligence
helmert heuristic causal graph analysis koenig et al
koenig et al pp


fihoffmann

helmert richter fast downward making use causal dependencies
representation edelkamp et al edelkamp et al
hoffmann j heuristic domain independent use enforced
hill climbing ras z w ohsuga eds proceedings th
international symposium methodologies intelligent systems ismis pp
charlotte nc springer verlag
hoffmann j fast forward system ai magazine

hoffmann j b local search topology benchmarks empirical analysis nebel nebel pp
hoffmann j extending numerical state variables harmelen f v ed
proceedings th european conference artificial intelligence ecai pp
lyon france wiley
hoffmann j metric system translating ignoring delete lists
numeric state variables journal artificial intelligence
hoffmann j b utilizing structure local search
vol lecture notes artificial intelligence springer verlag
hoffmann j c
ignoring delete lists works local search topology benchmarks
tech rep albert ludwigs universitat
institut fur informatik freiburg germany
available http www mpiinf mpg de hoffmann papers jair report ps gz
hoffmann j edelkamp deterministic part ipc overview journal
artificial intelligence appear
hoffmann j nebel b system fast plan generation
heuristic search journal artificial intelligence
hoffmann j nebel b b rifo revisited detecting relaxed irrelevance cesta
borrajo cesta borrajo pp
kautz h porter b eds aaai proceedings th national
conference american association artificial intelligence aaai austin
tx mit press
koehler j hoffmann j reasonable forced goal orderings use
agenda driven journal artificial intelligence

koehler j schuster k elevator control chien et al
chien et al pp
koenig zilberstein koehler j eds icaps proceedings
th international conference automated scheduling icaps
whistler canada morgan kaufmann
long fox automatic synthesis use generic types
chien et al chien et al pp


fiwhere ignoring delete lists works

long fox rd international competition
analysis journal artificial intelligence
mcdermott heuristic estimator means ends analysis drabble b ed proceedings rd international conference artificial intelligence
systems aips pp aaai press menlo park
mcdermott ai systems competition ai magazine

mcdermott v regression match graphs control search
artificial intelligence
nebel b ed ijcai proceedings th international joint conference
artificial intelligence ijcai seattle washington usa morgan kaufmann
nebel b dimopoulos koehler j ignoring irrelevant facts operators
plan generation steel alami steel alami pp
nguyen x kambhampati extracting effective admissible heuristics
graph kautz porter kautz porter pp
nguyen x kambhampati reviving partial order nebel nebel
pp
onaindia e sapena sebastia l marzal e simplanner executionmonitoring system replanning dynamic worlds brazdil jorge brazdil
jorge pp
penberthy j weld ucpop sound complete partial order planner
adl nebel b swartout w rich c eds principles knowledge
representation reasoning proceedings rd international conference kr pp cambridge morgan kaufmann
refanidis vlahavas grt domain independent heuristic strips
worlds greedy regression tables biundo fox biundo fox
pp
refanidis vlahavas grt system backward heuristic construction forward state space journal artificial intelligence

rintanen j iterative synthesizing invariants kautz porter
kautz porter pp
sebastia l onaindia e marzal e stella optimal sequential parallel
planner brazdil jorge brazdil jorge pp
srivastava b nguyen x kambhampati b nambiar u nie z nigenda r
zimmermann altalt combining graphplan heuristic state search
ai magazine
steel alami r eds recent advances ai th european conference ecp vol lecture notes artificial intelligence
toulouse france springer verlag


fihoffmann

thiebaux hoffmann j nebel b defence pddl axioms gottlob g
ed proceedings th international joint conference artificial intelligence
ijcai pp acapulco mexico morgan kaufmann
thiebaux hoffmann j nebel b defence pddl axioms artificial
intelligence appear
younes h simmons r role ground actions refinement
ghallab et al ghallab et al pp




