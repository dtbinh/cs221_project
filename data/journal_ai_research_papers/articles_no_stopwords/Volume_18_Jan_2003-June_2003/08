Journal Artificial Intelligence Research 18 (2003) 315-349

Submitted 10/02; published 4/03

Structure Complexity Planning Unary Operators
Ronen I. Brafman
Carmel Domshlak

brafman@cs.bgu.ac.il
dcarmel@cs.bgu.ac.il

Department Computer Science
Ben-Gurion University
P.O. Box 653, 84105 Beer-Sheva, Israel

Abstract
Unary operator domains i.e., domains operators single effect arise
naturally many control problems. general form, problem strips planning unary operator domains known hard general strips planning
problem pspace-complete. However, unary operator domains induce natural
structure, called domains causal graph. graph relates preconditions
effect domain operator. Causal graphs exploited Williams Nayak
order analyze plan generation one controllers NASAs Deep-Space One
spacecraft. There, utilized fact graph acyclic, serialization
ordering subgoal obtained quickly. paper conduct comprehensive study relationship structure domains causal graph
complexity planning domain. positive side, show non-trivial
polynomial time plan generation algorithm exists domains whose causal graph induces
polytree constant bound node indegree. negative side, show
even plan existence hard graph directed-path singly connected DAG.
generally, show number paths causal graph closely related
complexity planning associated domain. Finally relate results
question complexity planning serializable subgoals.

1. Introduction
One first well formulated problems addressed AI researchers planning
problem. Simply stated, involves generation sequence system transformations,
taken given set system transformations (called actions plan operators), whose
combined effect move system given initial state one set
desired goal states. planning problem known intractable general (Chapman,
1987), tractable algorithms exist restrictive classes problems only.
discouraging fact deterred planning researchers. Indeed, many researchers believe
real-world problems properties, structure, could exploited, either
implicitly explicitly. paper attempt understand relationship
structure complexity planning problems action changes value
single variable.
study relation structure complexity class problems
must identify set parameters characterize it. case planning, number
problem properties studied past (which review detail
Section 6). properties mostly syntactical, i.e., involve restriction
operators, e.g., type number preconditions effects operators have.
c
2003
AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiBrafman & Domshlak

example, Bylander (1994) showed strips planning domains operator
restricted positive preconditions one postcondition tractable. Backstrom
Klein (1991b) considered other, global types syntactical restrictions, using
refined model two types preconditions considered: prevail conditions,
variable values required prior execution operator
affected operator, preconditions, affected operator.
example, shown operators single effect, two operators
effect, variable affected one context (of prevail conditions)
planning problem solved polynomial time. However, restrictions
strict, difficult find reasonable domains satisfying them.
paper concentrate global properties unary operator domains;
properties capture interactions different planning operators.
tool use study properties domains causal graph. causal graph
directed graph whose nodes stand domain propositions. edge (p, q) appears
causal graph operator changes value q prevail
condition involving p. problem structure introduced Knoblock (1994)
context automatically generating abstractions planning. Subsequently, Jonsson
Backstrom (1998b) introduced 3S class planning problems unary operators,
characterized acyclicity causal graph, restrictions
operator set. shown determining plan existence class problems
polynomial, plan generation provably intractable.
Complexity results unary operators would theoretical interest alone one
could supply interesting problems unary operators used. One interesting
application problem arises determination dominance relationship
different outcomes CP-net (Boutilier, Brafman, Hoos, & Poole, 1999).
problem reducible strips planning unary operators.
Another example, greater interest planning community, planning-based
reactive control system commands NASA Deep Space One autonomous spacecraft (Pell, Bernard, Chien, Gat, Muscettola, Nayak, Wagner, & Williams, 1997; Williams
& Nayak, 1996, 1997). system hailed Weld (1999) recent survey AI
planning one exciting recent developments area planning. Naturally, complete system (Pell et al., 1997) complex, however, configuration
planning execution subsystem particular interest us. context controlling Deep-Space One, Williams Nayak (1996, 1997) present reactive planner, Burton,
generates single control action main engine subsystem spacecraft,
compensates anomalies every step. Given high-level goal (for example, thrust
one engines), Burton continually tries transition system toward state
satisfies desired goal. particularly relevant us Burtons task
described strips planning problem operator affects single variable (hardware component) Williams Nayak (1997) argue physical hardware
usually case state variable commanded separately. However, Burton
based two additional important restrictions: First, planner explicitly supplied
serialization order satisfiable set goal. Second, operators must reversible.
One reasons cited designing Burton reactive planner generates
single action time potential intractability generating whole plans. Indeed,
316

fiStructure Complexity Planning Unary Operators

Williams Nayak pessimistic prospects generating whole plans quickly
even Burton, i.e., problem instances serializable sub-goals single-effect
operators. results show, pessimism fully justified.
work continues study planning unary operators. apparently easier
problem fact hard general strips planning problem (Bylander, 1994). However, obtain finer distinctions positive results pay closer attention
causal structure domain. example, easy show causal
graph tree, easy determine serializability ordering set sub-goals,
consequently, obtain plan polynomial time. paper analyze relationship domains causal graph complexity plan generation plan
existence. particular prove following results:
causal graph forms polytree (the induced undirected graph acyclic),
node indegree bounded constant, plan existence plan generation
polynomial.
causal graph directed-path singly connected (there one directed
path pair nodes), plan existence np-complete.
general, plan generation problems acyclic causal graphs provably
intractable, i.e., problem requires exponential time. corresponding claim
derived previous result Jonsson Backstrom (1998b). However,
show complexity plan generation problems bounded
function number paths within causal graph.
Note complexity problems polytree causal graphs unbounded
node indegree remains open problem still shown whether solved
polynomial time, np-complete.
Finally, relate results old open question: difficult generate
plans problems serializable subgoals (Korf, 1987)? question stated
Bylander (1992), different hypotheses raised different researchers. Here,
present clear, though somewhat disappointing answer: First, results suggest even
underlying causal graph problem acyclic (and thus problem known
serializable), finding serialization ordering problem subgoals may hard.
Second, show even actual serialization ordering subgoals known,
solving problem necessarily easy.
rest paper organized follows: Section 2 first introduce
basic formalism used paper, discuss, motivate illustrate notion causal
graph. Sections 3 4 present results relation form
causal graph complexity planning problem. Section 5 discuss
sub-goal serializability issue impact results it. Section 6 describe
related work complexity planning, connect work previous
results. summarize Section 7. Finally, Appendix provides short review
POP algorithm (Penberthy & Weld, 1992), Appendix B provides proofs.
317

fiBrafman & Domshlak

2. Basic Formalism Causal Graphs
paper consider propositional planning problems, using propositional
strips negative goals formalism (Bylander, 1994), positive negative
preconditions allowed. Following Backstrom Klein (1991b), distinguish
preconditions prevail conditions. former case variable involved changes
value operator executed, latter case value change.
post-condition operator expresses state variables changes values
variables executing operator. pre-condition specifies
values changed variables must operator executed. prevail
condition specifies unchanged variables must specific value
execution operator values are. Hence, prevail conditions,
visa, needed order apply operator, Enter-USA,
values change operator applied. Finally, assume operator
applicable pre- prevail conditions satisfied.
Formally, assume problem instance given quadruple = hV, , Init, Goali,
where:
V = {v1 , . . . , vn } set propositional state variables, one associated
binary domain D(vi ). domain D(vi ) variable vi induces extended domain
D+ (vi ) = D(vi ) {u}, u denotes unspecified value.
Init initial, fully specified state, i.e. Init D(v1 ) . . . D(vn ).
Goal set possible goal states. assume set specified partial
assignment V, thus Goal D+ (v1 ) . . . D+ (vn ).
= {A1 , . . . , } finite set operators form hpre, post, prvi,
pre, post, prv D+ (v1 ) . . . D+ (vn ) denote pre-, post-, prevail condition,
respectively. follows, pre(A), post(A), prv(A) denote corresponding conditions operator A, pre(A)[i], post(A)[i], prv(A)[i]
corresponding values variable vi .
every vi V, must either pre(A)[i] = u prv(A)[i] = u. Further,
post(A)[i] 6= u pre(A)[i] 6= u, case post(A)[i] 6= pre(A)[i].
paper analyse planning problems unary operators. Therefore,
follows, assume that, operator , that:
1. exists variable vi V, pre(A)[i] 6= u,
2. variable vj V {vi }, pre(A)[j] = u.
Note specifying pre- postconditions case propositional variables
redundant, use simplify presentation. Likewise, assumption
post(A) 6= u implies pre(A) 6= u different usual strips formalism, requires
exponential time translation general. However, case unary operators,
translation takes linear time.
318

fiStructure Complexity Planning Unary Operators

2.1 Causal Graphs
Causal graphs used Williams Nayak (1997) tool describing structure
planning domains unary operators. represent dependence relation
state variables domain. causal graph G directed graph whose nodes
correspond state variables. edge p q appears causal graph
operator changes value q prevail condition involving
value p. Hence immediate predecessors q G variables
affect ability change value q. problem structure introduced
Knoblock (1994) context automatic generation abstractions planning.
causal graph intuitive model easily constructed given planning problem.
Causal graphs graphical structure derived given
planning problem, effectively exploited solving it. instance, graphs
operators literals (and variables/propositions) represented nodes,
edges represent prevail preconditions introduced Etzioni (1993) Smith
Peot (1993). particular, problem space graphs Etzioni (1993) operator graphs
Smith Peot (1993) proposed mechanisms reduce number threats
arise total-order partial-order planning, respectively. However,
paper focus causal graphs, since shown especially informative
operators unary (Jonsson & Backstrom, 1998b; Williams & Nayak, 1997).
Causal graphs important potential role design autonomous industrial
systems, argued demonstrated Williams Nayak (1997): Unary operators
natural manipulated objects hardware components, since basic control
actions systems change state single hardware component. applicability
control actions state depends state affected component
well state related hardware components. naturally gives rise
planning domain unary operators. Moreover, since state variables correspond
hardware components, induced causal graph typically see prevail
dependencies variables usually implicitly entailed inter-composition
hardware components. Thus, causal graph domains resembles structure
relationships systems hardware components. resemblance
important practical ramifications system design given relationship causal
graph structure complexity plan generation: enables system designer
consider effect hardware design systems ability autonomously generate
control sequences.
case point planning problem studied Williams Nayak (1997),
number important features: operators unary reversible, causal
graph acyclic. Williams Nayak argued acyclic connectivity frequently occurs
designed systems. However, requirement operators reversible seems
us restrictive, important impact complexity problem.
case Burton planner (Williams & Nayak, 1997), good reasons make
assumption. Burtons reactive nature precludes extensive deliberation consequences
operators. Thus leaves open possibility operators may degrade systems
capabilities, leading dead-ends. case, restriction reversible operators
319

fiBrafman & Domshlak

required order achieve reliable system. show later, certain cases,
complete plans generated efficiently even operators reversible.
Williams Nayaks work another interesting aspect, noted Weld (1999).
long time, researchers known planning problems serializable subgoals
likely easier solve. Williams Nayak recognized spacecraft configuration task serializable (many real-world problems not), and, importantly,
developed fast algorithm computing correct order based fact
underlying causal graph acyclic. However, algorithm makes heavy use
fact operators reversible. Informally, reversibility implies solve
subgoals one one long consistent topological order causal
graph without taking account global considerations: side-effect always
undone. Without assumption operator reversibility, relatively easy show
Williams Nayaks algorithm works causal graph forms directed chain.
Even causal graph tree, although problem easy, one must take care
choice subgoal achieve next operators reversible. show
later, structure causal graph complicated directed tree
either problem hard or, not, sophisticated algorithm required.
Finally, note existence reversible operators might make problem seem
easier actually is. paper present example propositional planning
problem unary operators, acyclic causal graph, totally reversible operators,
minimal solution exponentially long size problems description.
2.2 Example
order illustrate notion causal graph, consider following example, inspired
work Williams Nayak (1997) controlling main engine subsystem
Cassini spacecraft, general, valve driver circuitry, particular.
valve V L (on/off) controlled valve driver V LD (open/close), safety
control unit SCU (safe/unsafe). driver controls exactly one valve, safety
control unit control several valves. Commands driver sent via driver
control unit, consist two switches, l r , either off.
activating states l r described below. valve reacts (by state change)
command driver (i) instruction actually involve state change
(i.e., open valve reopened), (ii) safety control unit indicates
manipulating valve safe. addition, valve closed safety control unit
indicates unsafe situation. simplicity presentation, Table 1 presents operator
set controlling valves valve drivers only. dashed boxes stand driver
control units, two switches each.
suppose valves V L1 V L2 , drivers V LD1 V LD2 , respectively, controlled shared safety control unit SCU . Given operator set
Table 1, causal graph controlling subsystem presented Figure 1.

3. Polytree Causal Graphs
Starting section, show how, bounding structural complexity causal
graph, bound complexity plan generation. Recall use propositional
320

fiStructure Complexity Planning Unary Operators

Affected component
V LD
VL

pre
close
open

f


post
open
close
f

f

prv
Sl = 1 Sr = 0
Sl = 0 Sr = 1
V LD = close SCU = saf e
V LD = open SCU = saf e
SCU = unsaf e

Table 1: subset operator set valve circuitry controller example.
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _




S1r

S1l




EE
ww
E

_ _ _ _ _EEE_ _ _ _ _ _www_w _ _ _ _
EE
w
w
E"
{ww

V LD1

GG
G#

SCU

HH
HH
HH
HH
H#



S2r
S2l G
G

G



_ _ _ _ _GGG_G _ _ _ _ _ yy_y _ _ _ _



w
ww
ww
w
w
w{ w

V LD2

GG
GG
GG
GG
G#

V L1

yy
|yy

vv
vv
v
vv
v{ v

V L2

Figure 1: Causal graph example.
language (binary variables) describe state world, operator described
prevail conditions, single precondition, single effect (or post-condition).
precondition effect two literals, one negation other.
causal graph forms polytree single path every pair nodes
induced undirected graph1 , i.e., induced undirected graph tree. example,
causal graph presented Figure 1 forms polytree. class problems present
planning algorithm polynomial indegree nodes causal graph
bounded constant. argue assumption reasonable prevail dependencies reflect inter-composition controlled hardware components (Williams &
Nayak, 1997).
Given propositional planning instance polytree causal graph, we:
1. Provide general upper bound number times variable may required
change value valid, irreducible plan.
2. Using general upper bound, provide polynomial time procedure, called determinemax-sequence, that, given variable v, determines actual maximal number
times v change value valid, irreducible plan.
3. Provide preprocessing algorithm that: (a) determines whether plan
given problem instance class exists, (b) performs substantial amount
1. graphs known singly connected DAGs.

321

fiBrafman & Domshlak

preprocessing subsequent step plan generating. algorithm based
top-down execution determine-max-sequence variables given
problem instance.
4. answer plan existence check positive run particular deterministic instance POP algorithm2 (Penberthy & Weld, 1992), called pop-pcg,
generates required plan using information provided preprocessing
algorithm, without backtracking, linear time.
Informally, process based following properties planning problems
polytree causal graph. First, bound achieved step 1 necessary steps 2-3,
main steps technique. itself, bound valid
polytree, wider class directed-path singly connected causal graphs. However,
steps 2-3 valid polytree causal graphs only, following properties
form dependence relation variables:
(i) Given variable v V, changing value parent (immediate predecessor)
w pred(v) require changes neither parents v,
predecessors causal graph.
(ii) number times variable v able change value along valid
plan given problem instance depends directly numbers pred(v),
actual ordering value changes pred(v).
(iii) (i) follows possible orderings value changes pred(v)
legal. addition, shown chosing ordering value changes
pred(v) affect ability change value variable except v.
(iv) crucial part process (steps 2-3) basically finding right ordering
right number value changes pred(v) variable v V. synchronizing
changes vs parents appropriately, increase number possible
changes v.
start notation. First, valid plan P given planning instance
called irreducible subplan P 0 P plan , following sense:
Removal subset (not necessarily subsequent) actions P makes resulting
plan either illegal, initial state Init, goal state one states
specified Goal. notion irreducible plans introduced Kambhampati (1995),
exploited admissible pruning partial plans search3 .
2. short review POP algorithm, corresponding formalism provided Appendix A.
familiar algorithm, note one slight technical change, stemming use unary
operators. POP uses two fictitious actions A0 capture initial goal state, respectively.
Here, replace actions set actions, single effect. (fictitious) action
setting initial value variable vi denoted A0i fictitious action whose precondition
goal value variable vi denoted Ai .
3. Irreducible plans called (Kambhampati, 1995) minimal plans. However, decided change
name concept order prevent ambiguity minimal irreducible minimal
optimal.

322

fiStructure Complexity Planning Unary Operators

Now, given planning instance , let P set irreducible plans .
denote MaxReq(v) maximal number times variable v V changes value
course execution irreducible plan . Formally, let Req(P, v) number
times v changes value course execution plan P . Then,
MaxReq(v) = max{Req(P, v)}
P P

Observe that, planning problem unary operators, variable must change
value required change immediate successors causal
graph (in order satisfy necessary prevail conditions), order
obtain value requested goal. Thus, variables V, MaxReq(v) satisfies:
X
MaxReq(v) 1 +
MaxReq(u)
(1)
succ(v)

succ(v) denotes immediate successors v corresponding causal graph.
Adopting terminology (Domshlak & Shimony, 2003; Shimony & Domshlak, 2002),
directed acyclic graph G directed-path singly connected if, every pair nodes s, G,
one directed path t. following lemma shows causal
graph forms directed-path singly connected DAG bound MaxReq(v) n.
Clearly, polytrees directed-path singly connected DAGs, vice versa.
Lemma 1 solvable problem instance directed-path singly connected causal
graph n variables, variable v, MaxReq(v) n.
Proof: proof induction n. n = 1 obvious MaxReq(v) 1.
suppose |V| = n 1 v V,
MaxReq(v) n 1
Let 0 problem instance |V 0 | = n. Suppose variables V 0 =
{v1 , . . . vn } topologically ordered based domains causal graph. Clearly, vn
leaf node (i.e., succ (vn ) = ). denote problem instance obtained
removing vn domain, corresponding variable set V. According Eq. 1,
immediate predecessor v vn causal graph,
newMaxReq(v) MaxReq(v) + newMaxReq(vn ) MaxReq(v) + 1
newMaxReq(v) denotes MaxReq(v) respect 0 . Generally, since causal
graph directed-path singly connected, variable v V 0 ,

MaxReq(v) + 1, path v vn
newMaxReq(v)
(2)
MaxReq(v),
otherwise
thus, v V 0 , holds
newMaxReq(v) n

323

fiBrafman & Domshlak

Recall MaxReq(v) stands upper bound number value changes v
may required valid, irreducible plan. However, maximal achievable number
value changes v, denoted MaxPoss(v) greater less MaxReq(v).
example, v predecessors causal graph, two operators affecting
v differently, MaxPoss(v) = .
denote upper bound feasible number value changes v may
required valid, irreducible plan FMaxReq(v). Informally,
MaxPoss(v) value changes v required MaxReq(v) value changes
v required, thus
FMaxReq(v) = min(MaxPoss(v), MaxReq(v))

(3)

Determining FMaxReq(v) variables requires explicit examination given problem instance. Recall restrict causal graph form polytree.
simplify presentation, assume goal values specified state variables,
i.e. Goal D(v1 ) . . . D(vn ). Later show assumption affect
generality algorithm. Denote v 0 v initial goal values v ,
v set operators affecting v. First examine root variables
causal graph, analyze rest variables.
Denote pred(v) immediate predecessors v causal graph. pred(v) = ,
+
+

two operators
v , Av v : Av v postcondition,

Av reverse effect. Since operators prevail condition,
v
+
Av presented , applied one another infinite number
+
times. Therefore, Eq. 3, FMaxReq(v) = n. v 6= {A
v , Av } two cases:
initial goal values v same, cannot change value v
reconstruct later, thus FMaxReq(v) = 0. Alternatively, initial goal
values v different v = {A+
v } achieve goal value v
thus FMaxReq(v) = 1. Otherwise, goal value v unachievable, thus
given problem instance unsolvable. Table 2 summarize analysis.

v0
v0

=

v

6=

v

v

{Av , A+
v}
otherwise
+
{A
v , Av }
+
{Av }
otherwise

FMaxReq(v)
n
0
n
1
solution

Table 2: FMaxReq(v) values root variables causal graph.
consider variable v presented internal node causal graph:
pred(v) = {w1 , . . . , wk } =
6 . Observe number possible value changes v depends
on:
1. initial goal values v, i.e., v 0 v .
324

fiStructure Complexity Planning Unary Operators

2. set operators affecting v, i.e., v .
3. maximally possible (but still reasonable) number times predecessors v
change values, i.e., FMaxReq(w1 ), . . . , FMaxReq(wk ).
4. actual scheduling value changes predecessors v.
last point crucial means order determine FMaxReq(v) find
particular scheduling value changes pred(v) allows maximal number
value changes v. corresponding interleaving sequence vs values, starting
finishing v 0 v respectively, FMaxReq(v) value changes called maximal
denoted (v) (|(v)| = FMaxReq(v) + 1).
Lemma 1, 1 k, FMaxReq(wi ) n, thus number different
orderings value changes pred(v) exponential n. instance, when,
1 k, FMaxReq(wi ) = n, number different orderings expressed
as:


k1
n
YX
n 1 ni + 1
2nk
j
j1
i=1 j=1

correctness expression left side inequality shown Lemma 4
(see Appendix B, p. 347). Clearly, cannot check orderings naive manner.
Following, provide algorithm determines (v) time polynomial n.
clarity presentation want distinguish different elements
maximal sequence (v). Since variables binary, denote initial value v, v 0 ,
bv opposite value wv (black/white). Similarly, bi wi stand
corresponding values variable vi . so, think operators
described language. Likewise, sequentially number appearances
value v (v). example, biv stands ith appearance value bv along
(v). illustrate notation, suppose D(v) = {true, f alse}, initial value v
v 0 = true, FMaxReq(v) = 4. Then, have:
bv true
wv f alse
(v) = b1v wv1 b2v wv2 b3v
First, every variable v, every operator v extended set operators
explicitly specify prevail values parents v causal graph: |pred(v)| = k,
prevail condition specified terms 0 k 0 k parents4
0
v, extended set 2kk operators, operator extends
instantiation previously unspecified parents v. example, consider variable v
pred(v) = {u, w}, operator
= {pre : {bv }, post : {wv }, prv : {bu }},
4. every parent wj v, prv(A)[j] = u.

325

fiBrafman & Domshlak

prevail condition involve w. operator extended pair
operators:
A0 = {pre : {bv }, post : {wv }, prv : {bu , bw }}
A00 = {pre : {bv }, post : {wv }, prv : {bu , ww }}

corresponding possible values w. follows, refer operator set
resulting compilation ./ . Note that, assumption constantly
bounded maximal indegree causal graph, compiling ./ takes polynomial
+1 , thus |./ | = O(n2+1 ).
time, since, every variable v, |./
v |2
Given maximal sequences (w1 ), . . . , (wk ) operator set ./
v construct
0
directed graph (denoted Ge (v)) captures (and only) feasible sequences of,
n, value changes v, value change annotated corresponding
assignment pred(v). Although number captured sequences exponential
n, size G0e (v) polynomial n. respect graph, problem finding
maximal sequence (v) reduced problem finding longest path given
node arbitrary node directed acyclic graph.
graph G0e (v) created three incremental steps. first step, given
maximal sequences (w1 ), . . . , (wk ) operator set ./
v construct directed labeled
graph G(v) capturing information sequences assignments pred(v)
enable n less value flips v. graph G(v) defined follows:
1. G(v) consist nodes,

n, ((n = 2j) (v 0 = v ))
((n = 2j + 1) (v 0 6= v )), j N
=

n 1, otherwise
2. G(v) forms 2-colored multichain, i.e., (i) nodes graph colored black
white, starting black; (ii) two subsequent nodes
color; (iii) 1 1, edges node node + 1.
Observe construction G(v) promises color last node
consistent v .
3. nodes G(v) denoted precisely elements maximal sequence
(v), i.e., biv stands ith black node G(v).
4. Suppose operators ./
v change value v bv wv .

case, i, edges biv wvi , |./
v | edges wv
bi+1
v . edges labeled prevail conditions corresponding operators,
i.e., k-tuple values w1 , . . . , wk . tuple denoted l(e) (label
edge e) component, corresponding predecessor wi , denoted l(e)wi .
formal definition G(v) relatively complicated, thus provide demonstrating
example: Suppose given problem instance 5 variables, consider
326

fiStructure Complexity Planning Unary Operators

variable v pred(v) = {u, w}, v 0 = bv , v = wv . Recall every operator
./ presented three-tuple hpre, post, prvi pre-, post-, prevail conditions
operator respectively. Suppose that:
1
2
(u) = b1u wu1
(w) = b1w ww
b2w ww
1
Av = {pre : {bv }, post : {wv }, prv : {bu , ww }}
./
A2 = {pre : {wv }, post : {bv }, prv : {bu , bw }}
v =
v3
Av = {pre : {wv }, post : {bv }, prv : {wu , ww }}

case, graph G(v) presented Figure 2.
bu bw
bu ww /
b1v

wv1

bu bw

$
:

bu ww /
b2v

wv2

$

3 bu ww /

: bv

wv3

wu ww

wu ww

Figure 2: Example graph G(v).
constructed graph G(v) captures information potentially possible executions operators ./
v provide us MaxReq(v) less value changes v.
path, started source node G(v), uniquely corresponds execution.
Although number alternative executions may exponential n, graphical representation compact: number edges G(v) O(n |./
v |). Note
information number times operator ./

executed
v
captured G(v). following two steps add information indirectly exploit
find maximal sequence (v).
second step construction, expand G(v) respect maximal sequences (w1 ), . . . , (wk ) follows: edge e G(v) (which definition corresponds
operator ./
v ), replaced set edges labels correspond
possible assignments elements (w1 ), . . . , (wk ) l(e) (i.e., prv(A)). Likewise,
add dummy source node sv , edge sv original source node G(v)
labeled tuple first elements (w1 ), . . . , (wk ) (= initial values w1 , . . . , wk ).
Similarly, add dummy target node tv , edge original target node
G(v) tv labeled tuple last elements (w1 ), . . . , (wk ) (= goal values
w1 , . . . , wk ). denote extended graph G0 (v), Figure 3 illustrates G0 (v)
example above.
extended graph G0 (v) viewed projection maximal sequences (wi ),
1 k, graph G(v). edge G(v) may replaced O(nk ) edges G0 (v),
thus number edges G0 (v) O(nk+1 |./
v |).
easy see paths G0 (v) starting sv relevant. example,
G0 (v) above, operator instance prevailed b1u b2w performed operator
2 . Thus, faced problem finding longest
instance prevailed b1u ww
feasible path sv node G0 (v), label consistent v .
following (last) step provides reduction problem finding longest feasible path
sv v -colored node G0 (v) known problem finding longest path
327

fiBrafman & Domshlak

b1u b1w

b1u b1w
1
b1u ww

sv

b1u b1w

/ b1
v
2
b1u ww

&

b1u b2w
1
8 wv
1 w1
wu
w

%
2
9 bH v

1
b1u ww

2
b1u ww

1 w2
wu
w

&

b1u b2w
2
8 wv

%
3
9 bH v

1 w1
wu
w

1
b1u ww

&

3
8 wv

1 w2
wu
w

/ tv

2
b1u ww

1 w2
wu
w

Figure 3: Example graph G0 (v).
directed acyclic graph. Let graph G0e (v) edges G0 (v) nodes, let
edges defined allowed pairs immediately subsequent edges G0 (v): (e, e0 )
allowed if, 1 k, either l(e)wi = l(e0 )wi l(e0 )wi appears l(e)wi (wi ).
construction variant called edge graph known graph theory; addition
case exclusion non-allowed edges it. Clearly, G0e (v) constructed
2
time polynomial size G0 (v), number edges G0e (v) O(n2k+2 |./
v | ).
b1u b1w

b1 b1

2
wu1 ww

2
wu1 ww

u /w J
// JJ
// JJJ
// JJJJ
// JJJ
J
//
JJ
JJ
//
$
$
//
/
1
1
1
2
1
1
1
1
2
/
_
_
_
_
/
bu bw //
b1u ww
bu ww
bu ww
bu bw //
//77
77 /
JJ
7
//77
//
u:
JJ
77 //
7 /
u
//77
//77
JJ
u
/
/
77 /
7 /
JJ
// 77
// 77
u
J$
/
/
7
7
7
7
u
// 7
// 7
//
77 //
7
7
7
1
1
2
/
/
7
7
7
bu bw
wu1 ww
77 //
7 //
// 77
// 77
II
u:
77//
7 //
II
u
// 77
// 77
II
uu
77//
7 //
// 77
// 77
II
uu
u
/
/
7
7
7
7
I$
u
//
//

u

// w1 w1
// w1 w1
2
1 w2
1 w2
b1u ww
b
b
u wJ
u w
// u w
// u w
JJ
JJ
JJ
//
JJ
JJ ///
JJ /
JJ /
JJ /
J$
$

Figure 4: Example graph G0e (v).
Figure 4 presents G0e (v) example. dashed edges present longest path
dummy source node node corresponds value change v v
(from bv wv ). longest path G0e (v) describes maximal sequence value changes
(v), length actually FMaxReq(v) + 1. example, (v) = b1v wv1 b2v wv2 ,
FMaxReq(v) = 3. Note v 0 = v empty path acceptable since,
general, v change value. case FMaxReq(v) = 0 (v)
consist one element corresponds initial (= goal) value v.
Observe longest path G0e (v) describes (v) actual sequence
j
invocations operators ./
v provides (v). denote {A(bv )}
j
{A(wv )} sequences operator instances effects corresponding elements
sequences {bjv } {wvj } ({bjv } {wvj } = (v)) vs values, respectively.
follows, address sequences operator instances one sequence operator
328

fiStructure Complexity Planning Unary Operators

Procedure forward-check ()
1. Topologically sort variables V based causal graph.
2. variable v V, call determine-max-sequence(, v), respecting
ordering.
3. one calls determine-max-sequence return failure, return failure.
Otherwise return success.
Procedure determine-max-sequence (, v)
1. pred(v) =
(a) v 0 6= v A+
v 6 v , return failure.
(b) Otherwise, determine (v) according rules Table 2, return success.
2. Otherwise, pred(v) = {w1 , . . . , wk }
(a) Construct G(v) (based v 0 , v , ./
v ).
(b) Construct G0 (v) (from G(v), based (w1 ), . . . (wk )).
(c) Construct G0e (v) (from G0 (v), based (w1 ), . . . (wk )).
(d) Determine longest path G0e (v) node corresponding v -ended value
change, derive (v) corresponding sequence operators it.
(e) v 0 6= v FMaxReq(v) = 0, return failure. Otherwise, return success.
Figure 5: forward-check algorithm
FMaxReq(v)

instances v = {A(vi )}i=2

vi

=




, A(vi ) vi effect,
i+1

bv 2 ,

2

w ,
v

= 2k + 1

kN

= 2k

Procedure forward-check Figure 5 summarizes presented approach. Note
finding set longest paths node nodes directed acyclic graph
done time linear size graph (Wiest & Levy, 1969). Therefore,
time complexity call determine-max-sequence procedure variable v
2
bounded size constructed graph G0e (v) thus O(n2k+2 |./
v | ). forwardcheck calls determine-max-sequence n times. Therefore, maximal node indegree
bounded constant , overall complexity algorithm O(|V|2+3 22+2 ),
i.e., polynomial size problem description.
Theorem 1 given problem instance polytree causal graph solvable
if, v V, forward-check succeeds constructing maximal sequence (v).
forward-check fails least one calls determine-maxsequence procedure fails. turn, call determine-max-sequence variable v
329

fiBrafman & Domshlak

Algorithm: pop-pcg (hA, O, Li, agenda, )
1. Termination: agenda empty, return hA, O, Li
2. Goal selection: Let hi , Aneed rightmost pair agenda (by definition,
Aneed one pre/prevail conditions Aneed ).
3. Operator selection:
(a) Aneed 6= Ai (i = ij ) Aadd = A(ij ) {A0i }.
(b) Otherwise:
i. Let = max { j | A(ij ) A}.
ii. vi consistent im (both associated color {b, w})
Aadd = A(im ), else Aadd = A(im+1 ).


4. Plan updating: Let L = L {Aadd Aneed }, let = {Aadd < Aneed }.
Aadd newly instantiated, = {Aadd } = {A0i < Aadd < Ai }
(otherwise remain unchanged).
5. Update goal set: Let agenda = agenda - {hi , Aneed i}. Aadd newly instantiated,
pre/prevail conditions Q, add hQ, Aadd agenda.
6. Threat prevention: Aadd = A(ij ), j > 1, then, A, s.t. ij1 belongs
prevail conditions A, add {A < A(ij )} O.
7. Recursive invocation: pop-pcg(hA, O, Li, agenda, ), agenda topologically ordered (based causal graph respect precondition part
pair).
Figure 6: pop-pcg algorithm
fails initial goal values v different way
change value v even once. Thus, forward-check fails, plan exists.
prove opposite direction proceed follows: define pop-pcg algorithm
(POP polytree causal graphs) show succeed without backtracking
forward-check succeeds.5 pop-pcg described detail Figure 6, works
follows: First, let us expand sequence operator instances A(i1 ) (A(b1i ))
stand dummy operator A0i . (Recall now, operators
form A(ij ) j > 1 defined.) algorithm maintains goal agenda sorted based
causal graph structure: parent variables appear descendents.
point, next agenda item selected; requires achieving value vi add
corresponding operator plan desired effect (step 3a). Actually, would
ready accept plans possible redundant steps, omit next step 3b
algorithm assuming goal value variable v last element
5. short review POP algorithm, corresponding formalism, description initial
call algorithm, refer reader Appendix A.

330

fiStructure Complexity Planning Unary Operators

maximal sequence (v). However, would plan irreducible, careful
decision really required number value changes variable required.
decision captured step 3b analysis value changes variable vi
found necessary previous iterations algorithm order satisfy
predecessors vi causal graph. Note agenda sorted respect
reverse topological ordering causal graph, thus operator affecting vi selected
agenda operator affecting predecessor vi causal graph
appear agenda end algorithm. threats arise pop-pcg,
ordering constraints consistent.
Lemma 2 forward-check successful pop-pcg return valid plan.
Proof:

lemma follow following claims:

1. every agenda item, exists operator effect.
2. threats output pop-pcg.
3. ordering constraints consistent.
4. agenda empty polynomial number steps.
proof see Appendix B, p. 343.
Recall that, simplicity presentation, assumed goal values specified
state variables (single goal state), i.e. Goal D(v1 ) . . . D(vn ). show
presented approach, minor modifications, works set possible goal states
well, set specified partial assignment V, i.e. Goal D+ (v1 ). . .D+ (vn ).
Note latter assumption widely accepted planning literature.
First, modifications done processing variables specified Goal.
Now, variable v, v specified Goal, modifications
follows:
1. graph G(v) consist exactly n nodes. correct since (i) according
Lemma 1, n changes v sufficient, (ii) value change v
last value change.
2. changes construction G0 (v) G0e (v).
3. procedure determine-max-sequence:
(a) step 2d, determine longest path dummy source node
node graph.
(b) step 2e, always return success.
Again, correct since value change v last value change, and,
particular, v may remain unchanged plan given problem.
Finally, pop-pcg algorithm starts null plan contains end operator
Ai vi specified Goal.
331

fiBrafman & Domshlak

4. Directed-Path Singly Connected General DAGs
section analyze planning complexity face complicated causal graphs.
First, show causal graph directed-path singly connected even plan
existence np-complete. Second, show general causal graphs situation
even worse. Finally, characterize important parameter causal graph affecting
planning complexity, allows us extend class problems np.
Theorem 2 Plan existence strips planning problems unary operators directedpath singly connected causal graph np-complete.
Proof:

proof see Appendix B, p. 346.

Note node indegree causal graph problem created proof
Theorem 2 bounded 6. hardness directed-path singly connected causal graphs
maximal indegree lower 6 thus open.
directed-path singly connected structure causal graph turns crucial
guaranteeing reasonable solution times. show, solvable propositional planning problems arbitrary acyclic (DAG) causal graph minimal
solutions exponential size. Analysis class problems points reason
provable intractability. allows us characterize important parameter causal
graph affecting planning complexity extend class problems np.
However, restricted problems still np-complete.
Theorem 3 Plan generation general strips planning problems unary operators
acyclic causal graph provably intractable, i.e. harder np.
theorem follows Theorem 5.4 (Jonsson & Backstrom, 1998b), shows
plan generation 3S problem class provably intractable. point
upper bound MinPlanSize, presented Eq. 5, exponential size input
case. First, show example upper bound achieved,
present analysis reasons intractability.
following example shows exponential upper bound achieved.
used proof Theorem 5.4 (Jonsson & Backstrom, 1998b), originally
presented different context Backstrom Nebel (1995). Consider propositional
planning problem |V| = n, where, 1 n, D(vi ) = {0, 1} pred(vi ) =
{v1 , . . . vi1 }. operator set consist 2n operators {A1 , A01 , . . . , A0n }
pre(Ai )[j] =

post(A0i )[j]


=

0 j =
u otherwise


1
pre(A0i )[j] = post(Ai )[j] =
u

0
0
1
prv(Ai )[j] = prv(Ai )[j] =

u
332

j =
otherwise
j < 1
j = 1
otherwise

fiStructure Complexity Planning Unary Operators

easy see causal graph problem forms DAG (see Figure 7),
instance planning problem initial state h0, . . . , 0i goal state
h0, . . . , 0, 1i unique minimal solution length 2n 1 corresponding Hamilton
path state space.
PQRS
WVUT
V1

PQRS
/ WVUT
V2

'

...

4

PQRS
WVUT
Vn1

&
PQRS
/ WVUT
Vn
7

Figure 7: Causal graph proof Theorem 3
show escalation complexity parametrized form
causal graph.
Lemma 3 solvable problem instance acyclic causal graph n variables, variable v, that:
MaxReq(vi ) 1 +

n
X

(vi , vj )

j=i+1

(vi , vj ) denotes total number different, necessary disjoint, paths vi
vj , variables ordered via topological sort causal graph.
Proof: proof induction i. = n obvious MaxReq(vn ) 1.
assume lemma holds > k, prove = k. Without loss
generality, assume succ(vk ) 6= . Otherwise, simply MaxReq(vk ) 1.
proof straightforward:
Eq. 1

MaxReq(vk )



X

1 +

MaxReq(vik )

vik succ(vk )
I.H.



X

1 + |succ(vk )| +

vik succ(vk )

=

1+

n
X

n
X

(vik , vj ) =

j=ik +1

(vk , vj )

j=k+1


Lemma 3 entails upper bound MinPlanSize() general planning problem
unary operators acyclic causal graph depends number different paths
nodes causal graph. immediate conclusion significant
class problems acyclic causal graph planning np. Let DAG
called max--connected number different directed paths every two nodes
graph bounded .
333

fiBrafman & Domshlak

Theorem 4 Plan generation strips planning problems unary operators max-connected causal graph np-complete polynomially bounded.
Proof: Membership np straightforward: variables given problem
considered topological ordering induced causal graph, Lemma 3 follows
that, variable vi , MaxReq(vi ) n. turn, follows MinPlanSize()
n2 , thus, polynomially bounded, guess minimal plan
could verified polynomial time.
hardness follows Theorem 2 shows even causal graph max-1connected (directed-path singly connected), plan existence (and thus plan generation)
hard.

5. Serializable Subgoals
set subgoals defined serializable (Korf, 1987) exists ordering among
subgoals subgoals always solved sequentially without ever violating
previously solved subgoal order. Naturally, collections subgoals
serializable sometimes may necessary interleave plans achieving different goals.
However, problem instance serially decomposable, possible design set
macro-operators respect subgoals serializable (Korf, 1985).
problem instance serially decomposable exists ordering state
variables effect operator state variable depends
state variable previous state variables ordering. Unfortunately, Bylander (1992)
shows determining serial decomposability problem pspace-complete.
One major open problem put forth Bylander context is: problem
known serially decomposable, difficult determine whether given instance
solvable? far know, work direction done Chalasani
et al. (1991), serial decomposability general permutation problem
considered. particular, showed problem np, unknown
whether np-hard. Recently, complementary results Bylanders question
presented Koehler Hoffmann (2000). results shed light question:
problem instance based unary operator domain whose causal graph acyclic
serially decomposable. Therefore, concluded finding solution serially
decomposable problems may require exponential time (i.e., problem exptime).
However, Bylanders question plan existence. case, Theorem 3
apply, apply np-hardness result (for directed-path singly-connected
graphs), since addresses plan existence well.
Weld (1999) hypothesized that: (1) underlying causal graph planning
problem acyclic, serialization ordering subgoals problem obvious;
(2) Serialized subgoals could solved extremely quickly backtracking required
them. Although first observation sounds intuitive, results suggest
rarely true. acyclicity causal graph implies serializability,
cases structure provide us sufficient information actual serialization
ordering. Even causal graph directed tree one must think first choosing
334

fiStructure Complexity Planning Unary Operators

ordering. Likewise, results imply causal graph form
undirected tree determining subgoal ordering np-complete, causal graph
directed-path singly connected, problem even complex.
second observation always true either. problem important
determine serialization ordering subgoals, exact strategies
achieving them. showed, certain cases, problem n serializable subgoals
requires exponentially long solution. domain variables binary,
situation even worse corresponding complexity results derived
computational analysis Domshlak Dinitz (2001).

6. Connection Related Work Planning Complexity
idea analyzing exploiting structural properties new classical planning,
last years number important results emerged. Generating plans
context strips representation language shown Bylander (1994)
pspace-complete. Despite fact, existence many successful planning systems,
especially recent years, demonstrates planning possible practical wide list
domains. Bylander argues large gap theoretical hardness planning
practical success stems use domain-dependent problem analysis
algorithms. Consequently, various authors explored existence constrained
problem classes planning easier.
section shortly overview major, previous results complexity
planning, discuss relationship results presented paper.
detailed presentation previous results discussed refer reader
original papers.
6.1 Local Syntactical Restrictions
seminal paper, Bylander (1994) presents number complexity results propositional planning, analyzing different planning problems based type formulas used,
number type (positive/negative) operator pre- postconditions, etc. work
Bylander extended interesting, complementary results Erol al. (1995).
example, Bylander shows propositional planning domains operator
restricted positive preconditions one postcondition tractable. Generally, extremely severe restrictions operators required guarantee tractability,
even membership np. Note Bylander (1994) Erol et al. (1995) focuses local
syntactical properties operators, i.e., properties single operators.
syntactic restriction pose planning problems paper
unarity operators. Determining plan existence this, apparently easier class
problems shown Bylander hard general propositional planning, i.e.
pspace-complete. Note result entail Theorem 3, since
planning problems unary operators may induce causal graphs cycles. Therefore,
none results entailed results presented Bylander (1994) Erol et
al. (1995).
335

fiBrafman & Domshlak

6.2 Global Syntactical Restrictions
Backstrom Klein (1991a, 1991b), and, subsequently, Backstrom Nebel (1995),
consider types restrictions, using refined model (the SAS formalism)
which:
1. state variables multi-valued,
2. Two types preconditions considered: prevail conditions, variable
values required prior execution operator affected
operator, preconditions, affected operator.
general, four different restrictions considered works:
(P) Post-uniqueness: effect one operator achieves effect.
words, desired effects determine operators used plan. Formally,
problem instance post-unique if, vi V x D(vi ),
one operator post(A)[i] = x.
(S) Single-valuedness: one value state variable appears prevail
conditions operators. instance, certain operator requires light
(as prevail condition), operator use prevail condition
light off. Formally, problem instance single-valued iff exist
two operators A, A0 vi V prv(A)[i] 6= u, prv(A0 )[i] 6= u,
prv(A)[i] 6= prv(A0 )[i].
(U) Unariness: operator affects one state variable.
(B) Binariness: state variables exactly two possible values, i.e. state variables
propositional.
four properties syntactical. However, properties P differ
properties U B fact global nature: Post-uniqueness singlevaluedness restrict form operators, global property whole set
operators. Backstrom Nebel (1995) showed US (unariness single-valuedness)
extreme problem class plan generation polynomial. 6
problems analyzed paper belong problem class UB, definition. already mentioned, even determining plan existence class problems
pspace-complete. consider problem class PUB. Backstrom Nebel (1995)
showed that: (i) PUB instances exponentially long minimal solutions, thus plan
generation PUB requires exponential time; (ii) existence bounded length plans
PUB strongly np-hard; (iii) complexity general plan existence PUB still
open question. Informally means strengthening restrictions UB PUB
reduce complexity significantly, least practical point view.
Proposition 1 Every UB problem instance tree causal graph either post-unique,
transformed equivalent post-unique problem instance (low) polynomial
time. Thus, TreeUB PUB.
6. thorough analysis complexity SAS planning, refer Backstrom Nebel (1995).

336

fiStructure Complexity Planning Unary Operators

Proof: Consider UB problem tree causal graph, suppose postunique. means exist variable v V, D(v) = {v 0 , v 00 },
exist two operators A1 , A2 v change value v v 0 v 00 , prv(A1 ) 6=
prv(A2 ).
assumption causal graph forms tree follows |pred(v)| 1.
pred(v) = , easy see existence pair operators
simply impossible. Therefore, let pred(v) = {w}, D(w) = {w0 , w00 }. Without loss
generality assume prv(A1 )[w] = {w0 }, prv(A2 )[w] = {w00 }. Otherwise, if, instance,
prv(A1 )[w] = u, easy see A2 redundant operator.
Observe case, prevail dependence v w redundant: replace
pair operators A1 , A2 single operator changes value v
v 0 v 00 without prevail condition. replacement A1 , A2 brings us
equivalent problem instance operator set v post-unique. way
continue process iteratively problematic variables v arrive postunique problem instance.

Proposition 2 UB problem instances tree causal graph singlevalued, thus TreeUB 6 UBS.
Proof: proof Proposition 2 straightforward: Consider variable v V, D(v) =
{v 0 , v 00 }, succ(v) = {u, w}. case value change u
prevailed v 0 , value change w prevailed v 00 . Therefore, restricting
causal graphs even trees entail single-valuedness.7
Propositions 1 2 show TreeUB polynomial subclass PUB
entailed tractability results Backstrom Nebel (1995).
Proposition 3 UB problem instances polytree causal graph neither single-valued, post-unique.
Proof: proof straightforward: Consider planning problem polytree causal
graph, exist variable v V pred(v) = {u, w}, following
operator set v :
pre
v0
v0
v 00
v 00

post
v 00
v 00
v0
v0

prv
{u0 , w00 }
{u00 , w0 }
{u0 , w0 }
{u00 , w00 }

Clearly, problem instance v neither single-valued, postunique, since (i) one operator achieving value v, (ii)
values u (and values w) appear prevail conditions operators v . Note
7. Using simple construction technique proof Proposition 1 shown restricting
causal graphs directed chains entails single-valuedness. However, case restrictive.

337

fiBrafman & Domshlak

maximal indegree polytree minimal, i.e. equal 2. Thus,
proposition valid polytree tree.
Proposition 3 follows Theorems 1 4 introduce new polynomial
np-easy subclasses UB problem class, respectively.
6.3 Structural Restrictions Propositional Planning
Jonsson Backstrom (1998b) present 3S class planning problems. class
closely related problems examined paper, since defines special subclass
problems binary variables, unary operators acyclic causal graphs. 3S problem
class defined posing additional, relatively severe, restrictions problems
operator set: variable v 3S problem instance required either (i) static,
i.e., unchangeable; (ii) symmetrically reversible, i.e., operator affecting v,
exist operator A0 affecting v prevail conditions opposite effect;
(iii) splitting. formal definition splitting property refer Jonsson
Backstrom (1998b). Informally, binary variable v splitting problem
instance split three, well-defined subproblems solved independently.
class planning problems shown plan existence determined
polynomial time, plan generation provably intractable, since instances
3S exponentially long minimal solutions. particular, problem instance
used proof Theorem 3 3S.
complexity analysis Jnonsson Backstrom (1998b) somewhat unique
research complexity propositional planning, since, best knowledge,
attempt exploit syntactical restrictions operator set,
structural restrictions interaction variables. analysis
seen continuing direction looking structural restrictions only.
believe eliminating marginal effect problem structure problems (potential) hardness allow us understand better connection component
interactions topology, potential complexity problem.
6.4 Structural Restrictions Multi-valued Formalisms
variables longer propositional, additional properties problems
identified, and, possibly, exploited. particular, additional internal structures
problem analysed.
Jonsson Backstrom (1998a) analyze different properties multi-valued problem
structure, called domain transition graph. structure defined
state variable problem, describes possible transitions different values
variable. domain transition graph state variable v directed labeled
graph Gv = (V, E), V associated vs set possible values, D(v),
(x, A, y) E operator applied state v = x,
application results state v = holds.
Jonsson Backstrom identify sets structural restrictions domain transition
graphs make planning instances tractable. Roughly, properties following:
(1) problem domain interference-safe, i.e., operator either unary irreplace338

fiStructure Complexity Planning Unary Operators

able respect every variable affects. operator irreplaceable respect
variable v removal edges Gv stem disconnects
weakly connected component Gv . (2) every variable v, graph Gv , restricted
set values appear prevail conditions operators, acyclic. (3)
sequence operators annotating path x domain transition graph v,
stronger shortest sequences connecting x y. Here, sequence A1 , . . . , Ak
stronger A01 , . . . , A0l subsequence Ai1 , . . . , Ail A1 , . . . , Ak
every 1 j l, prevail conditions A0j subset prevail conditions Aij .
Jonsson Backstrom present map computational complexity problems
different restrictions, displaying frontier tractable intractable cases.
domain transition graph combines structures influence many operators
particular variable. Therefore, provide us global picture operator
set alone. Hence, spite fact domain transition graphs capture relationship different variables, allow us express structural properties
address interactions variables (e.g., see property (2) above).
Observe domain transition graphs informative case propositional planning, since distinguish variables changed
one direction variables changed directions. Although
property domain transition graphs allows distinguish polynomial
planning positive postconditions, pspace-complete planning
positive negative postconditions (Bylander, 1994), seems helpful
hierarchical refinement propositional planning complexity. hand,
priori reason causal graphs informative multi-valued
case. Exploiting properties causal graphs, together properties domain
transition graphs, seems natural direction extend work presented paper.
recent work Domshlak Dinitz (2001) multi-entity off-line coordination
seen investigating connections structure causal graph, together
properties domain transition graphs, complexity corresponding
problems case multi-valued domains. best knowledge,
work done respect mixed structural analysis, lot work
remains done. instance, combining various properties domain transition
graphs studied Jonsson Backstrom (1998a), properties problems
causal graph direction research.

7. Summary Future Work
shown form causal graph strips planning problems unary
operators important factor determining computational complexity plan generation. particular, shown polynomial time algorithm exists
problem polytree causal graph node indegree bounded constant.
generally, result shows planning polytree causal graphs (what
often referred Bayes nets literature as) locally exponential, i.e., exponential maximal number parents node. Note hardware-control planning
problems maximal node indegree expected small, since prevail dependencies
variables reflect direct interconnections corresponding hard339

fiBrafman & Domshlak

ware components. Likewise shown problem directed-path singly
connected causal graph maximal plan length low order polynomial, problem
np-complete. generally, shown relation number paths variables causal graph computational complexity corresponding
planning problem. Finally presented impact results question
complexity planning problems serializable subgoals, connected work
previous results planning complexity.
work leaves number open questions respect purely syntactical,
mixture structural syntactical restrictions planning problems unary
operators. former case, one important directions analysis
causal graphs constantly bounded node indegree. turns complexity analysis class problems helpful understanding various computational
properties CP-nets (Boutilier et al., 1999). Although provided partial answer
question, general picture worst-case complexity class problems
clear. example, indegree causal graph known bounded
2, structural property causal graph, even clear whether
problem subclass np.
latter case, various syntactical restrictions analysed together form
causal graph. example, one may interested computational properties
problems acyclic causal graphs, restriction every operator
prevail conditions, bounded constant. This, well many
related questions respect various special cases planning unary operators
interest future work.

Acknowledgments
preliminary version paper appeared Sixth International Conference Artificial Intelligence Planning Scheduling, April, 2002. would thank three
anonymous reviewers extremely helpful comments. Ronen Brafman supported
part Paul Ivanier Center Robotics Research Production Management.

340

fiStructure Complexity Planning Unary Operators

Appendix A. Short Review POP, Causal Links Threats
represent plan tuple: hA, O, Li, set unary operators, set
ordering constraints A, L set causal links. example, = {A1 , A2 , A3 }
might set {A1 < A3 , A2 < A3 }. constraints specify plan
A3 necessarily last operator, commit particular order A1 A2 .
Naturally, set ordering constraints must consistent, i.e., must exist

total order satisfying them. causal link form Ap Ac , Ap Ac
operators possible value propositional variable vi . denotes fact
Ap produces (i.e., postcondition) vi = consumed Ac (i.e., used
satisfy pre- prevail-condition Ac ). Causal links help us detect whether one operator
interferes work done enable execution operator Ac .
case, said constitute threat one A0c causal links. Formally, suppose


hA, O, Li plan, Ap Ac causal link L. Let different operator A.


say threatens Ap Ac following two criteria satisfied:
{Ap < < Ac } consistent,
effect.
partial order plan P contains threats, possible goal
achieved (or all) total order plans consistent P ordering constraints.
prevent this, plan generator must check threats remove adding one
two possible ordering constraints: < Ap (demotion) Ac < (promotion).
tutorial introduction POP algorithms found (Weld, 1994). POP
regressive framework partial order planning starts null plan continuously updates inserting new actions removing threats. process continues
precondition prevail conditions every operator plan supported
causal link threats exist. first argument POP plan second
argument agenda goals need supported causal links. item
agenda represented pair hi , Ai either pre- prevail condition plan
action A. last argument POP whole collection operators defined
planning instance. initial call POP contains null plan, specially initialized
agenda, operator set given problem.
paper introduce specialized, deterministic POP algorithm starts
planning process using variant null plan encodes planning problem.
particular, planning instance v1 , . . . , vn goal corresponding null
plan exactly 2n dummy unary operators, = {A01 , . . . , A0n , A1 , . . . , }, n ordering
constraints, = {{A01 < A1 }, . . . , {A0n < }}, causal links, L = {}. every
vi V, A0i corresponding start operator - neither pre- prevail conditions,
effect specifies value variable vi initial state, denoted
vi0 . Similarly, Ai end operator - effect, prevail conditions,
precondition set value vi goal state, turn denoted vi .8
8. Actually, goal state may specify values variables, thus number end
operators less n. However, clarity presentation, leave definition null
plan.

341

fiBrafman & Domshlak

description null plan modified Weld (1994) better suit
restriction unary operators. Likewise, initial call POP algorithm contains
agenda {hv1 , A1 i, . . . , hvn , i}.

342

fiStructure Complexity Planning Unary Operators

Appendix B. Proofs Auxiliary Results
Lemma 2 forward-check successful pop-pcg return valid plan.
Proof:

lemma follow following claims:

1. every agenda item, exists operator effect.
2. threats output pop-pcg.
3. ordering constraints consistent.
4. agenda empty polynomial number steps.
(1+4) first claim follows success forward-check procedure.
forward-check implies ij (vi ) operator instance A(ij )
{A0i }. Therefore, ij (vi ) existence appropriate Aadd promised.
Assume contrary ij 6 (vi ) and, without loss generality, assume
first iteration happens. so, variable u succ(vi ),
edge labeled ij graph G0 (u), created forward-check.
follows Aneed cannot ij prevail condition, thus Aneed affect
variable vi itself. case either Aneed = A(ij+1 ) Aneed = Ai .
Consider former case: Aneed = A(ij+1 ) ij+1 previously selected
agenda. assumption means ij+1 (vi ), contradicts assumption
ij 6 (vi ) since ij predecessor ij+1 (vi ).
consider last option Aneed = Ai . Aadd = A(ij ) goal value
variable vi consistent ij , A(ij1 ) (see Step 3(b)ii). A(ij1 )
ij1 previously selected agenda. assumption means
ij1 (vi ). However, contradicts assumption ij 6 (vi ) since (vi ),
definition, terminates node consistent goal value vi .
addition, since shown operators added
{A0i , Ai }, 1 n, agenda empty O(n2 ) steps.


(2) Suppose operator threatens Ap Ac , i.e.,
{Ap < < Ac } consistent,
effect.
given variable vi , pop-pcg forces operators affecting vi follows (Step 4):
A0i A(i1 ) < A(i2 ) < . . . < A(ix ),

x FMaxReq(vi )

(4)

Thus Ac operator prevail condition. Note Ap
affect variable vi . (1) already showed = ij (vi ).
case = A(il ), l > j. However, ij prevail condition Ac ordering
constraint {Ac < A(ij+1 )} added Step 6. Eq. 4, follows
343

fiBrafman & Domshlak

{A(il ) < A(ij+1 ), A(ij+1 ) < A(il )}, l > j, implied {Ap < < Ac },
contradicts assumption {Ap < < Ac } consistent.
(3) ordering constraints consistent two operators Ai Aj
implies {{Ai < Aj }, {Aj < Ai }}. follows, Ai used denote arbitrary
operator affecting variable vi .
First note ordering constraint added Step 4 Step 6 either
operators affecting variable operators affecting variable child
(with respect causal graph). particular, Ai < Aj added Step 4 either
vi = vj vi pred(vj ), whereas Ai < Aj added Step 6 vj pred(vi ).
Assume, contrary implies Ai < Aj Aj < Ai . argument
above, know a, possibly empty, path vi vj undirected
graph induced causal graph. structural assumption, know
undirected path vi vj unique, thus situation follows:
two chains operators
: Ai = A1i0 < . . . < Axi00 < A1i1 < . . . < Axi11 < . . . . . . < A1im < . . . < Aximm = Aj
: Ai = A1i0 > . . . > Ayi00 > A1i1 > . . . > Ayi11 > . . . . . . > A1im > . . . > Ayimm = Aj

that, 0 k m, xk 1 yk 1. corresponding unique undirected
path vi vj is:
vi = vi0 vi1 . . . vim1 vim = vj
Without loss generality, internal elements disjoint. Otherwise,
operator B belongs internal parts reduce
chains deduce Ai < B Ai > B.
proof consistency follows:
(a) prove exist least one least
one internal element.
(b) show useful property , exploited (c).
(c) show 0 k m, Axikk Ayikk different except x0 = y0 = 1.
Note (a) together (c) contradicts assumption Aximm = Ayimm .
(a) Assume, contrary, contain internal elements.
so, algorithm actually adds ordering constraints Ai < Aj Aj < Ai .
vi vj variable Ai < Aj stem Step 4
Ai precondition Aj effect. However, definition forwardcheck, Aj role w.r.t. Ai thus impossible Aj < Ai
added O. Alternatively, vi parent vj Ai < Aj stem Step 4
Ai prevail condition Aj effect. Suppose Ai = A(bji ) thus
bji prv(Aj ). turn, Aj < Ai added Step 6 Aj precondition
Ai prevail condition. bji prv(Aj ) Ai = A(wij ), contradicts
344

fiStructure Complexity Planning Unary Operators

assumption Ai = A(bji ). Alternatively, assume Ai = A(wij )
situation completely symmetric, thus result same. Hence proved
either contain least one internal element. particular means
next last elements different fact exploited later
proof.
(b) Consider subchains consist operators affecting one particular variable. subchain, i.e. 0 k m, 1 j xk 1, ordering
j
j+1
constraint Ajik < Aj+1
ik stem Step 4 Aik precondition Aik
effect. Thus, post(Ajik ) = pre(Aj+1
ik ). Similarly, subchains , 0 k
j
2 j yk , post(Aik ) = pre(Aj1
ik ). follows denote property
local monotonicity.
(c) First suppose either x0 > 1 y0 > 1, both. Consider following sequence:
: Ayi00 < Ayi00 1 < . . . < A1i0 = A1i0 < ... < Axi00
local monotonicity, construction forward-check, fact || 2
0
follows post(Ayi0 ) appears post(Axi00 ) maximal sequence vi0 . Continuing
1

next variable vi1 claim post(Ayi1 ) appear post(Axi11 ) vi1 .
(i) vi0 parent vi1 Axi00 < A1i1 stem Step 4 Axi00
prevail condition A1i1 effect. turn, Ayi00 > A1i1 stem Step 6
prevail condition A1i1 precondition Ayi00 . relation
Axi00 Ayi00 , construction G0e (vi1 ) forward-check, follows post(A1i1 )
appears post(A1i1 ) (vi1 ). Subsequently, local monotonicity follows
post(Ayi11 ) appears post(Axi11 ) (vi1 ).
(ii) Similarly, vi1 parent vi0 Ayi00 > A1i1 stem Step 4
A1i1 prevail condition Ayi00 effect, Axi00 < A1i1 stem Step 6
prevail condition Axi00 precondition A1i1 . relation
Axi00 Ayi00 , construction G0e (vi1 ) forward-check, follows post(A1i1 )
appears post(A1i1 ) (vi1 ), again, local monotonicity follows
post(Ayi11 ) appears post(Axi11 ) (vi1 ).
Alternatively, x0 = y0 = 1 Axi00 = Ayi00 = Ai . (a) immediately follows
A1i1 6= A1i1 , analysis similar shows post(Ayi11 ) appears
post(Axi11 ) (vi1 ).
established post(Ayi11 ) appears post(Axi11 ) (vi1 ), apparent
inductive argument allow us show k > 0 post(Ayikk )
appears post(Axikk ) (vik ). Note particular means operators
Axikk Ayikk different, contradicts assumption Aximm = Ayimm .

345

fiBrafman & Domshlak

Theorem 2
Plan existence strips planning problems unary operators
directed-path singly connected causal graph np-complete.
Proof: First show membership np. Let MinPlanSize() denote size
minimal plan problem instance . Using MaxReq property state variables,
following upper bound MinPlanSize() straightforward Lemma 1:
X
MinPlanSize()
MaxReq(v) n2
(5)
vV

Thus, guess minimal solution given solvable problem, verify low
polynomial time.
proof hardness polynomial reduction 3-sat corresponding
propositional plan generation problem directed-path singly connected causal graph.
3-sat problem finding satisfying assignment propositional formula conjunctive normal form conjunct (clause) three literals.
Let F = C1 . . .Cn propositional formula belonging 3-SAT, let X1 , . . . , Xm
variables used F. equivalent propositional planning problem directedpath singly connected causal graph constructed follows: variable set V =
{X1 , X1 , . . . , Xm , Xm } {C1 , . . . , Cn }. variables Xi Xi predecessors
causal graph, thus pred(Xi ) = pred(Xi ) = {}. turn, 1 n, pred(Ci ) =
{Xi1 , Xi1 , Xi2 , Xi2 , Xi3 , Xi3 }, Xi1 , Xi2 , Xi3 variables participate
ith clause F. Finally, Init Goal consist false true assignments
variables V, respectively.
Let every operator presented three-tuple h{pre}, {post}, {prv}i pre, post,
prevail conditions respectively. Then, corresponding operator set specified
follows:
Xi

={

h{f }, {t}, {}i }

Xi

={

h{f }, {t}, {}i }

Ci

={

h{f }, {t}, {1i }i, h{f }, {t}, {2i }i, h{f }, {t}, {3i }i



ji (1 j 3) corresponds truth assignment variable Xij satisfies
ith clause F. Let Ci = (X1 X2 X8 ). 1i = {X1 = t, X1 = f }, 2i = {X2 =
f, X2 = t}, 3i = {X8 = t, X8 = f }.
illustrate proposed reduction consider following example. Formula F consist
3 clauses: (x1 x2 x3 ) (x1 x2 x4 ) (x2 x3 x4 ). causal graph
corresponding planning problem follows:
@ABC
GFED
@ABC
@ABC
GFED
GFED
@ABC
@ABC
@ABC
GFED
@ABC
GFED
x2 F GFED
x3
x1 F GFED
x4
x
x1
x3
::
- F 2 :
--
;
{
H

::
-- FFF
- F :
{; {; H x8 x8 x8
:

;
{
:
F
F
H

:
-FF
{;
-

x8 x8
:
F
:::
-{; {; x8 x8 H H
F
:
:


;
{
8
x

F
-H
F :

F : {; {; {; x8 x8 x8
H
FFFF :::
-:
F
8
x
H

;
{
x8
FFF ::
-H

{; x8 {; x8 F x8 F: :
FF:: -
H

;
{
--
8
x
F : H
FF::-
{;
F# { x {; x8 x8
F#
{ x
@ABC
GFED
@ABC
GFED
@ABC
GFED
C1
C2
C3
346

@ABC
GFED
x4
x8 8x



fiStructure Complexity Planning Unary Operators

propositional planning problem single-effect operators underlying
directed-path singly connected causal graph. Clearly, Goal reachable ( solvable)
satisfying assignment F found. Thus, plan existence propositional
planning problems directed-path singly connected causal graphs np-complete.

Lemma 4 Given k ordered sequences 1 , , k n elements each, number [k]
different merges 1 , , k , preserving orderings induced 1 , , k elements, given by:


k1
n
YX
n 1 ni + 1
[k] =
(6)
j1
j
i=1 j=1

Proof: Considering merge operation k sequences iterative merge ,
2 k, already merged sequences 1 , . . . , i1 , easy see (k)
expressed as:
(
[k 1] [n(k 1), n] , k > 1
[k] =
(7)
1,
k=1
S[x, y] stands number different, order preserving merges two ordered
sequences sizes x (without loss generality, assume x y).
consider process merging two ordered sequences 0 , || | 0 |, as:
(i) partition 0 j sub-sequences,
(ii) partition l sub-sequences, j 1 l j + 1,
(iii) interleaving order preserving concatenation sub-sequences 0 .
First, observe 0 partitioned 1 j | 0 | sub-sequences. Second,
0 |1
j, numbers different partitions corresponding steps (i) (ii) |j1


||+1
, respectively. Finally, given pair partitions 0 , exist exactly
j
one possible interleaving order preserving concatenation step (iii). Therefore,
have:



X
y1 x+1
S(x, y) =
(8)
j1
j
j=1

combining Eq. 7 Eq. 8, arrive Eq. 6.

347

fiBrafman & Domshlak

References
Backstrom, C., & Klein, I. (1991a). Parallel non-binary planning polynomial time.
Proceedings Twelfth International Joint Conference Artificial Intelligence, pp.
268273, Sydney, Australia. Morgan Kaufmann Publishers.
Backstrom, C., & Klein, I. (1991b). Planning polynomial time: SAS-PUBS class.
Computational Intelligence, 7 (3), 181197.
Backstrom, C., & Nebel, B. (1995). Complexity results SAS+ planning. Computational
Intelligence, 11 (4), 625655.
Boutilier, C., Brafman, R., Hoos, H., & Poole, D. (1999). Reasoning conditional ceteris
paribus preference statements. Proceedings Fifteenth Annual Conference
Uncertainty Artificial Intelligence, pp. 7180. Morgan Kaufmann Publishers.
Bylander, T. (1992). Complexity results serial decomposability. Proceedings
Tenth National Conference Artificial Intelligence, pp. 729734, San Jose, CL. AAAI
Press.
Bylander, T. (1994). computational complexity propositional STRIPS planning.
Artificial Intelligence, 69 (1-2), 165204.
Chalasani, P., Etzioni, O., & Mount, J. (1991). Integrating efficient model-learning
problem-solving algorithms permutation environments. Proceedings Second
International Conference Principles Knowledge Representation Reasoning,
pp. 8998, Cambridge, MA. Morgan Kaufmann Publishers.
Chapman, D. (1987). Planning conjunctive goals. Artificial Intelligence, 32 (3), 333377.
Domshlak, C., & Dinitz, Y. (2001). Multi-agent off-line coordination: Structure complexity. Proceedings Sixth European Conference Planning, Toledo, Spain.
Domshlak, C., & Shimony, S. E. (2003). Efficient probabilistic reasoning Bayes nets
mutual exclusion context specific independence. Proceedings Sixteenth International FLAIRS Conference, Special Track Uncertain Reasoning, St.
Augustine, FL. AAAI Press. appear.
Erol, K., Nau, D. S., & Subrahmanian, V. S. (1995). Complexity, decidability undecidability results domain-independent planning. Artificial Intelligence, Special Issue
Planning, 76 (12), 7588.
Etzioni, O. (1993). Acquiring search-control knowledge via static analysis. Artificial Intelligence, 62 (2), 255301.
Jonsson, P., & Backstrom, C. (1998a). State-variable planning structural restrictions:
Algorithms complexity. Artificial Intelligence, 100 (12), 125176.
Jonsson, P., & Backstrom, C. (1998b). Tractable plan existence imply tractable
plan generation. Annals Mathematics Artificial Intelligence, 22 (3-4), 281296.
Kambhampati, S. (1995). Admissible pruning strategies based plan minimality planspace planning. Proceedings Fourteenth International Joint Conference
Artificial Intelligence, pp. 16271635, Montreal, Canada.
348

fiStructure Complexity Planning Unary Operators

Knoblock, C. (1994). Automatically generating abstractions planning. Artificial Intelligence, 68 (2), 243302.
Koehler, J., & Hoffmann, J. (2000). reasonable forced goal orderings use
agenda-driven planning algorithm. Journal Artificial Intelligence Research,
12, 338386.
Korf, R. (1985). Macro-operators: weak method learning. Artificial Intelligence, 26 (1),
3577.
Korf, R. (1987). Planning search: quantitative approach. Artificial Intelligence, 33 (1),
6588.
Pell, B., Bernard, D., Chien, S., Gat, E., Muscettola, N., Nayak, P., Wagner, M., & Williams,
B. (1997). autonomous spacecraft agent prototype. Proceedings First
International Conference Autonomous Agents, pp. 253261, Marina del Rey, CL.
ACM Press.
Penberthy, J. S., & Weld, D. S. (1992). UCPOP: sound, complete, partial order planner
ADL. Proceedings Third International Conference Principles Knowledge Representation Reasoning, pp. 103114, Cambridge, MA. Morgan Kaufmann
Publishers.
Shimony, S. E., & Domshlak, C. (2002). Complexity probabilistic reasoning (directedpath) singly connected (not polytree!) Bayes networks. submitted publication.
Smith, D., & Peot, M. (1993). Postponing threats partial-order planning. Proceedings
Eleventh National Conference Artificial Intelligence, pp. 500506, Washington,
D.C. AAAI Press.
Weld, D. S. (1994). introduction least commitment planning. AI Magazine, 15 (4),
2761.
Weld, D. S. (1999). Recent advances AI planning. AI Magazine, 20 (2), 93123.
Wiest, J. D., & Levy, F. K. (1969). Management Guide PERT/CPM. Prentice Hall.
Williams, B., & Nayak, P. (1996). model-based approach reactive self-configuring systems. Proceedings Thirteenth National Conference Artificial Intelligence,
pp. 971977, Portland, OR. AAAI Press.
Williams, B., & Nayak, P. (1997). reactive planner model-based executive.
Proceedings Fifteenth International Joint Conference Artificial Intelligence,
pp. 11781185, Nagoya, Japan.

349


