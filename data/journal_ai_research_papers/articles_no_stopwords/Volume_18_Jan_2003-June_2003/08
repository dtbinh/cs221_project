journal artificial intelligence

submitted published

structure complexity unary operators
ronen brafman
carmel domshlak

brafman cs bgu ac il
dcarmel cs bgu ac il

department computer science
ben gurion university
p box beer sheva israel

abstract
unary operator domains e domains operators single effect arise
naturally many control general form strips unary operator domains known hard general strips
pspace complete however unary operator domains induce natural
structure called domains causal graph graph relates preconditions
effect domain operator causal graphs exploited williams nayak
order analyze plan generation one controllers nasas deep space one
spacecraft utilized fact graph acyclic serialization
ordering subgoal obtained quickly conduct comprehensive study relationship structure domains causal graph
complexity domain positive side non trivial
polynomial time plan generation exists domains whose causal graph induces
polytree constant bound node indegree negative side
even plan existence hard graph directed path singly connected dag
generally number paths causal graph closely related
complexity associated domain finally relate
question complexity serializable subgoals

introduction
one first well formulated addressed ai researchers
simply stated involves generation sequence system transformations
taken given set system transformations called actions plan operators whose
combined effect move system given initial state one set
desired goal states known intractable general chapman
tractable exist restrictive classes
discouraging fact deterred researchers indeed many researchers believe
real world properties structure could exploited
implicitly explicitly attempt understand relationship
structure complexity action changes value
single variable
study relation structure complexity class
must identify set parameters characterize case number
properties studied past review detail
section properties mostly syntactical e involve restriction
operators e g type number preconditions effects operators
c

ai access foundation morgan kaufmann publishers rights reserved

fibrafman domshlak

example bylander showed strips domains operator
restricted positive preconditions one postcondition tractable backstrom
klein b considered global types syntactical restrictions
refined model two types preconditions considered prevail conditions
variable values required prior execution operator
affected operator preconditions affected operator
example shown operators single effect two operators
effect variable affected one context prevail conditions
solved polynomial time however restrictions
strict difficult reasonable domains satisfying
concentrate global properties unary operator domains
properties capture interactions different operators
tool use study properties domains causal graph causal graph
directed graph whose nodes stand domain propositions edge p q appears
causal graph operator changes value q prevail
condition involving p structure introduced knoblock
context automatically generating abstractions subsequently jonsson
backstrom b introduced class unary operators
characterized acyclicity causal graph restrictions
operator set shown determining plan existence class
polynomial plan generation provably intractable
complexity unary operators would theoretical interest alone one
could supply interesting unary operators used one interesting
application arises determination dominance relationship
different outcomes cp net boutilier brafman hoos poole
reducible strips unary operators
another example greater interest community
reactive control system commands nasa deep space one autonomous spacecraft pell bernard chien gat muscettola nayak wagner williams williams
nayak system hailed weld recent survey ai
one exciting recent developments area naturally complete system pell et al complex however configuration
execution subsystem particular interest us context controlling deep space one williams nayak present reactive planner burton
generates single control action main engine subsystem spacecraft
compensates anomalies every step given high level goal example thrust
one engines burton continually tries transition system toward state
satisfies desired goal particularly relevant us burtons task
described strips operator affects single variable hardware component williams nayak argue physical hardware
usually case state variable commanded separately however burton
two additional important restrictions first planner explicitly supplied
serialization order satisfiable set goal second operators must reversible
one reasons cited designing burton reactive planner generates
single action time potential intractability generating whole plans indeed


fistructure complexity unary operators

williams nayak pessimistic prospects generating whole plans quickly
even burton e instances serializable sub goals single effect
operators pessimism fully justified
work continues study unary operators apparently easier
fact hard general strips bylander however obtain finer distinctions positive pay closer attention
causal structure domain example easy causal
graph tree easy determine serializability ordering set sub goals
consequently obtain plan polynomial time analyze relationship domains causal graph complexity plan generation plan
existence particular prove following
causal graph forms polytree induced undirected graph acyclic
node indegree bounded constant plan existence plan generation
polynomial
causal graph directed path singly connected one directed
path pair nodes plan existence np complete
general plan generation acyclic causal graphs provably
intractable e requires exponential time corresponding claim
derived previous jonsson backstrom b however
complexity plan generation bounded
function number paths within causal graph
note complexity polytree causal graphs unbounded
node indegree remains open still shown whether solved
polynomial time np complete
finally relate old open question difficult generate
plans serializable subgoals korf question stated
bylander different hypotheses raised different researchers
present clear though somewhat disappointing answer first suggest even
underlying causal graph acyclic thus known
serializable finding serialization ordering subgoals may hard
second even actual serialization ordering subgoals known
solving necessarily easy
rest organized follows section first introduce
basic formalism used discuss motivate illustrate notion causal
graph sections present relation form
causal graph complexity section discuss
sub goal serializability issue impact section describe
related work complexity connect work previous
summarize section finally appendix provides short review
pop penberthy weld appendix b provides proofs


fibrafman domshlak

basic formalism causal graphs
consider propositional propositional
strips negative goals formalism bylander positive negative
preconditions allowed following backstrom klein b distinguish
preconditions prevail conditions former case variable involved changes
value operator executed latter case value change
post condition operator expresses state variables changes values
variables executing operator pre condition specifies
values changed variables must operator executed prevail
condition specifies unchanged variables must specific value
execution operator values hence prevail conditions
visa needed order apply operator enter usa
values change operator applied finally assume operator
applicable pre prevail conditions satisfied
formally assume instance given quadruple hv init goali

v v vn set propositional state variables one associated
binary domain vi domain vi variable vi induces extended domain
vi vi u u denotes unspecified value
init initial fully specified state e init v vn
goal set possible goal states assume set specified partial
assignment v thus goal v vn
finite set operators form hpre post prvi
pre post prv v vn denote pre post prevail condition
respectively follows pre post prv denote corresponding conditions operator pre post prv
corresponding values variable vi
every vi v must pre u prv u
post u pre u case post pre
analyse unary operators therefore
follows assume operator
exists variable vi v pre u
variable vj v vi pre j u
note specifying pre postconditions case propositional variables
redundant use simplify presentation likewise assumption
post u implies pre u different usual strips formalism requires
exponential time translation general however case unary operators
translation takes linear time


fistructure complexity unary operators

causal graphs
causal graphs used williams nayak tool describing structure
domains unary operators represent dependence relation
state variables domain causal graph g directed graph whose nodes
correspond state variables edge p q appears causal graph
operator changes value q prevail condition involving
value p hence immediate predecessors q g variables
affect ability change value q structure introduced
knoblock context automatic generation abstractions
causal graph intuitive model easily constructed given
causal graphs graphical structure derived given
effectively exploited solving instance graphs
operators literals variables propositions represented nodes
edges represent prevail preconditions introduced etzioni smith
peot particular space graphs etzioni operator graphs
smith peot proposed mechanisms reduce number threats
arise total order partial order respectively however
focus causal graphs since shown especially informative
operators unary jonsson backstrom b williams nayak
causal graphs important potential role design autonomous industrial
systems argued demonstrated williams nayak unary operators
natural manipulated objects hardware components since basic control
actions systems change state single hardware component applicability
control actions state depends state affected component
well state related hardware components naturally gives rise
domain unary operators moreover since state variables correspond
hardware components induced causal graph typically see prevail
dependencies variables usually implicitly entailed inter composition
hardware components thus causal graph domains resembles structure
relationships systems hardware components resemblance
important practical ramifications system design given relationship causal
graph structure complexity plan generation enables system designer
consider effect hardware design systems ability autonomously generate
control sequences
case point studied williams nayak
number important features operators unary reversible causal
graph acyclic williams nayak argued acyclic connectivity frequently occurs
designed systems however requirement operators reversible seems
us restrictive important impact complexity
case burton planner williams nayak good reasons make
assumption burtons reactive nature precludes extensive deliberation consequences
operators thus leaves open possibility operators may degrade systems
capabilities leading dead ends case restriction reversible operators


fibrafman domshlak

required order achieve reliable system later certain cases
complete plans generated efficiently even operators reversible
williams nayaks work another interesting aspect noted weld
long time researchers known serializable subgoals
likely easier solve williams nayak recognized spacecraft configuration task serializable many real world importantly
developed fast computing correct order fact
underlying causal graph acyclic however makes heavy use
fact operators reversible informally reversibility implies solve
subgoals one one long consistent topological order causal
graph without taking account global considerations side effect
undone without assumption operator reversibility relatively easy
williams nayaks works causal graph forms directed chain
even causal graph tree although easy one must take care
choice subgoal achieve next operators reversible
later structure causal graph complicated directed tree
hard sophisticated required
finally note existence reversible operators might make seem
easier actually present example propositional
unary operators acyclic causal graph totally reversible operators
minimal solution exponentially long size description
example
order illustrate notion causal graph consider following example inspired
work williams nayak controlling main engine subsystem
cassini spacecraft general valve driver circuitry particular
valve v l controlled valve driver v ld open close safety
control unit scu safe unsafe driver controls exactly one valve safety
control unit control several valves commands driver sent via driver
control unit consist two switches l r
activating states l r described valve reacts state change
command driver instruction actually involve state change
e open valve reopened ii safety control unit indicates
manipulating valve safe addition valve closed safety control unit
indicates unsafe situation simplicity presentation table presents operator
set controlling valves valve drivers dashed boxes stand driver
control units two switches
suppose valves v l v l drivers v ld v ld respectively controlled shared safety control unit scu given operator set
table causal graph controlling subsystem presented figure

polytree causal graphs
starting section bounding structural complexity causal
graph bound complexity plan generation recall use propositional


fistructure complexity unary operators

affected component
v ld
vl

pre
close
open

f


post
open
close
f

f

prv
sl sr
sl sr
v ld close scu saf e
v ld open scu saf e
scu unsaf e

table subset operator set valve circuitry controller example







r

l




ee
ww
e

eee www w
ee
w
w
e
ww

v ld

gg
g

scu

hh
hh
hh
hh
h



r
l g
g

g



ggg g yy



w
ww
ww
w
w
w w

v ld

gg
gg
gg
gg
g

v l

yy
yy

vv
vv
v
vv
v v

v l

figure causal graph example
language binary variables describe state world operator described
prevail conditions single precondition single effect post condition
precondition effect two literals one negation
causal graph forms polytree single path every pair nodes
induced undirected graph e induced undirected graph tree example
causal graph presented figure forms polytree class present
polynomial indegree nodes causal graph
bounded constant argue assumption reasonable prevail dependencies reflect inter composition controlled hardware components williams
nayak
given propositional instance polytree causal graph
provide general upper bound number times variable may required
change value valid irreducible plan
general upper bound provide polynomial time procedure called determinemax sequence given variable v determines actual maximal number
times v change value valid irreducible plan
provide preprocessing determines whether plan
given instance class exists b performs substantial amount
graphs known singly connected dags



fibrafman domshlak

preprocessing subsequent step plan generating
top execution determine max sequence variables given
instance
answer plan existence check positive run particular deterministic instance pop penberthy weld called pop pcg
generates required plan information provided preprocessing
without backtracking linear time
informally process following properties
polytree causal graph first bound achieved step necessary steps
main steps technique bound valid
polytree wider class directed path singly connected causal graphs however
steps valid polytree causal graphs following properties
form dependence relation variables
given variable v v changing value parent immediate predecessor
w pred v require changes neither parents v
predecessors causal graph
ii number times variable v able change value along valid
plan given instance depends directly numbers pred v
actual ordering value changes pred v
iii follows possible orderings value changes pred v
legal addition shown chosing ordering value changes
pred v affect ability change value variable except v
iv crucial part process steps basically finding right ordering
right number value changes pred v variable v v synchronizing
changes vs parents appropriately increase number possible
changes v
start notation first valid plan p given instance
called irreducible subplan p p plan following sense
removal subset necessarily subsequent actions p makes resulting
plan illegal initial state init goal state one states
specified goal notion irreducible plans introduced kambhampati
exploited admissible pruning partial plans search
short review pop corresponding formalism provided appendix
familiar note one slight technical change stemming use unary
operators pop uses two fictitious actions capture initial goal state respectively
replace actions set actions single effect fictitious action
setting initial value variable vi denoted fictitious action whose precondition
goal value variable vi denoted ai
irreducible plans called kambhampati minimal plans however decided change
name concept order prevent ambiguity minimal irreducible minimal
optimal



fistructure complexity unary operators

given instance let p set irreducible plans
denote maxreq v maximal number times variable v v changes value
course execution irreducible plan formally let req p v number
times v changes value course execution plan p
maxreq v max req p v
p p

observe unary operators variable must change
value required change immediate successors causal
graph order satisfy necessary prevail conditions order
obtain value requested goal thus variables v maxreq v satisfies
x
maxreq v
maxreq u

succ v

succ v denotes immediate successors v corresponding causal graph
adopting terminology domshlak shimony shimony domshlak
directed acyclic graph g directed path singly connected every pair nodes g
one directed path following lemma shows causal
graph forms directed path singly connected dag bound maxreq v n
clearly polytrees directed path singly connected dags vice versa
lemma solvable instance directed path singly connected causal
graph n variables variable v maxreq v n
proof proof induction n n obvious maxreq v
suppose v n v v
maxreq v n
let instance v n suppose variables v
v vn topologically ordered domains causal graph clearly vn
leaf node e succ vn denote instance obtained
removing vn domain corresponding variable set v according eq
immediate predecessor v vn causal graph
newmaxreq v maxreq v newmaxreq vn maxreq v
newmaxreq v denotes maxreq v respect generally since causal
graph directed path singly connected variable v v

maxreq v path v vn
newmaxreq v

maxreq v
otherwise
thus v v holds
newmaxreq v n



fibrafman domshlak

recall maxreq v stands upper bound number value changes v
may required valid irreducible plan however maximal achievable number
value changes v denoted maxposs v greater less maxreq v
example v predecessors causal graph two operators affecting
v differently maxposs v
denote upper bound feasible number value changes v may
required valid irreducible plan fmaxreq v informally
maxposs v value changes v required maxreq v value changes
v required thus
fmaxreq v min maxposs v maxreq v



determining fmaxreq v variables requires explicit examination given instance recall restrict causal graph form polytree
simplify presentation assume goal values specified state variables
e goal v vn later assumption affect
generality denote v v initial goal values v
v set operators affecting v first examine root variables
causal graph analyze rest variables
denote pred v immediate predecessors v causal graph pred v



two operators
v av v av v postcondition

av reverse effect since operators prevail condition
v

av presented applied one another infinite number

times therefore eq fmaxreq v n v
v av two cases
initial goal values v cannot change value v
reconstruct later thus fmaxreq v alternatively initial goal
values v different v
v achieve goal value v
thus fmaxreq v otherwise goal value v unachievable thus
given instance unsolvable table summarize analysis

v
v



v



v

v

av
v
otherwise


v av

av
otherwise

fmaxreq v
n

n

solution

table fmaxreq v values root variables causal graph
consider variable v presented internal node causal graph
pred v w wk
observe number possible value changes v depends

initial goal values v e v v


fistructure complexity unary operators

set operators affecting v e v
maximally possible still reasonable number times predecessors v
change values e fmaxreq w fmaxreq wk
actual scheduling value changes predecessors v
last point crucial means order determine fmaxreq v
particular scheduling value changes pred v allows maximal number
value changes v corresponding interleaving sequence vs values starting
finishing v v respectively fmaxreq v value changes called maximal
denoted v v fmaxreq v
lemma k fmaxreq wi n thus number different
orderings value changes pred v exponential n instance
k fmaxreq wi n number different orderings expressed



k
n
yx
n ni
nk
j
j
j

correctness expression left side inequality shown lemma
see appendix b p clearly cannot check orderings naive manner
following provide determines v time polynomial n
clarity presentation want distinguish different elements
maximal sequence v since variables binary denote initial value v v
bv opposite value wv black white similarly bi wi stand
corresponding values variable vi think operators
described language likewise sequentially number appearances
value v v example biv stands ith appearance value bv along
v illustrate notation suppose v true f alse initial value v
v true fmaxreq v
bv true
wv f alse
v b v wv b v wv b v
first every variable v every operator v extended set operators
explicitly specify prevail values parents v causal graph pred v k
prevail condition specified terms k k parents

v extended set kk operators operator extends
instantiation previously unspecified parents v example consider variable v
pred v u w operator
pre bv post wv prv bu
every parent wj v prv j u



fibrafman domshlak

prevail condition involve w operator extended pair
operators
pre bv post wv prv bu bw
pre bv post wv prv bu ww

corresponding possible values w follows refer operator set
resulting compilation note assumption constantly
bounded maximal indegree causal graph compiling takes polynomial
thus n
time since every variable v
v
given maximal sequences w wk operator set
v construct

directed graph denoted ge v captures feasible sequences
n value changes v value change annotated corresponding
assignment pred v although number captured sequences exponential
n size g e v polynomial n respect graph finding
maximal sequence v reduced finding longest path given
node arbitrary node directed acyclic graph
graph g e v created three incremental steps first step given
maximal sequences w wk operator set
v construct directed labeled
graph g v capturing information sequences assignments pred v
enable n less value flips v graph g v defined follows
g v consist nodes

n n j v v
n j v v j n


n otherwise
g v forms colored multichain e nodes graph colored black
white starting black ii two subsequent nodes
color iii edges node node
observe construction g v promises color last node
consistent v
nodes g v denoted precisely elements maximal sequence
v e biv stands ith black node g v
suppose operators
v change value v bv wv

case edges biv wvi
v edges wv
bi
v edges labeled prevail conditions corresponding operators
e k tuple values w wk tuple denoted l e label
edge e component corresponding predecessor wi denoted l e wi
formal definition g v relatively complicated thus provide demonstrating
example suppose given instance variables consider


fistructure complexity unary operators

variable v pred v u w v bv v wv recall every operator
presented three tuple hpre post prvi pre post prevail conditions
operator respectively suppose


u b u wu
w b w ww
b w ww

av pre bv post wv prv bu ww

pre wv post bv prv bu bw
v
v
av pre wv post bv prv wu ww

case graph g v presented figure
bu bw
bu ww
b v

wv

bu bw




bu ww
b v

wv



bu ww

bv

wv

wu ww

wu ww

figure example graph g v
constructed graph g v captures information potentially possible executions operators
v provide us maxreq v less value changes v
path started source node g v uniquely corresponds execution
although number alternative executions may exponential n graphical representation compact number edges g v n
v note
information number times operator

executed
v
captured g v following two steps add information indirectly exploit
maximal sequence v
second step construction expand g v respect maximal sequences w wk follows edge e g v definition corresponds
operator
v replaced set edges labels correspond
possible assignments elements w wk l e e prv likewise
add dummy source node sv edge sv original source node g v
labeled tuple first elements w wk initial values w wk
similarly add dummy target node tv edge original target node
g v tv labeled tuple last elements w wk goal values
w wk denote extended graph g v figure illustrates g v
example
extended graph g v viewed projection maximal sequences wi
k graph g v edge g v may replaced nk edges g v
thus number edges g v nk
v
easy see paths g v starting sv relevant example
g v operator instance prevailed b u b w performed operator
thus faced finding longest
instance prevailed b u ww
feasible path sv node g v label consistent v
following last step provides reduction finding longest feasible path
sv v colored node g v known finding longest path


fibrafman domshlak

b u b w

b u b w

b u ww

sv

b u b w

b
v

b u ww



b u b w

wv
w
wu
w



bh v


b u ww


b u ww

w
wu
w



b u b w

wv



bh v

w
wu
w


b u ww




wv

w
wu
w

tv


b u ww

w
wu
w

figure example graph g v
directed acyclic graph let graph g e v edges g v nodes let
edges defined allowed pairs immediately subsequent edges g v e e
allowed k l e wi l e wi l e wi appears l e wi wi
construction variant called edge graph known graph theory addition
case exclusion non allowed edges clearly g e v constructed

time polynomial size g v number edges g e v n k
v
b u b w

b b


wu ww


wu ww

u w j
jj
jjj
jjjj
jjj
j

jj
jj




















bu bw
b u ww
bu ww
bu ww
bu bw


jj



u
jj


u


jj
u




jj


u
j






u















bu bw
wu ww




ii
u


ii
u


ii
uu




ii
uu
u







u



u

w w
w w

w
w
b u ww
b
b
u wj
u w
u w
u w
jj
jj
jj

jj
jj
jj
jj
jj
j


figure example graph g e v
figure presents g e v example dashed edges present longest path
dummy source node node corresponds value change v v
bv wv longest path g e v describes maximal sequence value changes
v length actually fmaxreq v example v b v wv b v wv
fmaxreq v note v v empty path acceptable since
general v change value case fmaxreq v v
consist one element corresponds initial goal value v
observe longest path g e v describes v actual sequence
j
invocations operators
v provides v denote bv
j
wv sequences operator instances effects corresponding elements
sequences bjv wvj bjv wvj v vs values respectively
follows address sequences operator instances one sequence operator


fistructure complexity unary operators

procedure forward check
topologically sort variables v causal graph
variable v v call determine max sequence v respecting
ordering
one calls determine max sequence return failure return failure
otherwise return success
procedure determine max sequence v
pred v
v v
v v return failure
b otherwise determine v according rules table return success
otherwise pred v w wk
construct g v v v
v
b construct g v g v w wk
c construct g e v g v w wk
determine longest path g e v node corresponding v ended value
change derive v corresponding sequence operators
e v v fmaxreq v return failure otherwise return success
figure forward check
fmaxreq v

instances v vi

vi






vi vi effect


bv



w
v

k

kn

k

procedure forward check figure summarizes presented note
finding set longest paths node nodes directed acyclic graph
done time linear size graph wiest levy therefore
time complexity call determine max sequence procedure variable v

bounded size constructed graph g e v thus n k
v forwardcheck calls determine max sequence n times therefore maximal node indegree
bounded constant overall complexity v
e polynomial size description
theorem given instance polytree causal graph solvable
v v forward check succeeds constructing maximal sequence v
forward check fails least one calls determine maxsequence procedure fails turn call determine max sequence variable v


fibrafman domshlak

pop pcg ha li agenda
termination agenda empty return ha li
goal selection let hi aneed rightmost pair agenda definition
aneed one pre prevail conditions aneed
operator selection
aneed ai ij aadd ij
b otherwise
let max j ij
ii vi consistent im associated color b w
aadd im else aadd im


plan updating let l l aadd aneed let aadd aneed
aadd newly instantiated aadd aadd ai
otherwise remain unchanged
update goal set let agenda agenda hi aneed aadd newly instantiated
pre prevail conditions q add hq aadd agenda
threat prevention aadd ij j ij belongs
prevail conditions add ij
recursive invocation pop pcg ha li agenda agenda topologically ordered causal graph respect precondition part
pair
figure pop pcg
fails initial goal values v different way
change value v even thus forward check fails plan exists
prove opposite direction proceed follows define pop pcg
pop polytree causal graphs succeed without backtracking
forward check succeeds pop pcg described detail figure works
follows first let us expand sequence operator instances b
stand dummy operator recall operators
form ij j defined maintains goal agenda sorted
causal graph structure parent variables appear descendents
point next agenda item selected requires achieving value vi add
corresponding operator plan desired effect step actually would
ready accept plans possible redundant steps omit next step b
assuming goal value variable v last element
short review pop corresponding formalism description initial
call refer reader appendix



fistructure complexity unary operators

maximal sequence v however would plan irreducible careful
decision really required number value changes variable required
decision captured step b analysis value changes variable vi
found necessary previous iterations order satisfy
predecessors vi causal graph note agenda sorted respect
reverse topological ordering causal graph thus operator affecting vi selected
agenda operator affecting predecessor vi causal graph
appear agenda end threats arise pop pcg
ordering constraints consistent
lemma forward check successful pop pcg return valid plan
proof

lemma follow following claims

every agenda item exists operator effect
threats output pop pcg
ordering constraints consistent
agenda empty polynomial number steps
proof see appendix b p
recall simplicity presentation assumed goal values specified
state variables single goal state e goal v vn
presented minor modifications works set possible goal states
well set specified partial assignment v e goal v vn
note latter assumption widely accepted literature
first modifications done processing variables specified goal
variable v v specified goal modifications
follows
graph g v consist exactly n nodes correct since according
lemma n changes v sufficient ii value change v
last value change
changes construction g v g e v
procedure determine max sequence
step determine longest path dummy source node
node graph
b step e return success
correct since value change v last value change
particular v may remain unchanged plan given
finally pop pcg starts null plan contains end operator
ai vi specified goal


fibrafman domshlak

directed path singly connected general dags
section analyze complexity face complicated causal graphs
first causal graph directed path singly connected even plan
existence np complete second general causal graphs situation
even worse finally characterize important parameter causal graph affecting
complexity allows us extend class np
theorem plan existence strips unary operators directedpath singly connected causal graph np complete
proof

proof see appendix b p

note node indegree causal graph created proof
theorem bounded hardness directed path singly connected causal graphs
maximal indegree lower thus open
directed path singly connected structure causal graph turns crucial
guaranteeing reasonable solution times solvable propositional arbitrary acyclic dag causal graph minimal
solutions exponential size analysis class points reason
provable intractability allows us characterize important parameter causal
graph affecting complexity extend class np
however restricted still np complete
theorem plan generation general strips unary operators
acyclic causal graph provably intractable e harder np
theorem follows theorem jonsson backstrom b shows
plan generation class provably intractable point
upper bound minplansize presented eq exponential size input
case first example upper bound achieved
present analysis reasons intractability
following example shows exponential upper bound achieved
used proof theorem jonsson backstrom b originally
presented different context backstrom nebel consider propositional
v n n vi pred vi
v vi operator set consist n operators n
pre ai j

post j




j
u otherwise



pre j post ai j
u




prv ai j prv ai j

u


j
otherwise
j
j
otherwise

fistructure complexity unary operators

easy see causal graph forms dag see figure
instance initial state h goal state
h unique minimal solution length n corresponding hamilton
path state space
pqrs
wvut
v

pqrs
wvut
v







pqrs
wvut
vn


pqrs
wvut
vn


figure causal graph proof theorem
escalation complexity parametrized form
causal graph
lemma solvable instance acyclic causal graph n variables variable v
maxreq vi

n
x

vi vj

j

vi vj denotes total number different necessary disjoint paths vi
vj variables ordered via topological sort causal graph
proof proof induction n obvious maxreq vn
assume lemma holds k prove k without loss
generality assume succ vk otherwise simply maxreq vk
proof straightforward
eq

maxreq vk



x



maxreq vik

vik succ vk
h



x

succ vk

vik succ vk





n
x

n
x

vik vj

j ik

vk vj

j k


lemma entails upper bound minplansize general
unary operators acyclic causal graph depends number different paths
nodes causal graph immediate conclusion significant
class acyclic causal graph np let dag
called max connected number different directed paths every two nodes
graph bounded


fibrafman domshlak

theorem plan generation strips unary operators max connected causal graph np complete polynomially bounded
proof membership np straightforward variables given
considered topological ordering induced causal graph lemma follows
variable vi maxreq vi n turn follows minplansize
n thus polynomially bounded guess minimal plan
could verified polynomial time
hardness follows theorem shows even causal graph max connected directed path singly connected plan existence thus plan generation
hard

serializable subgoals
set subgoals defined serializable korf exists ordering among
subgoals subgoals solved sequentially without ever violating
previously solved subgoal order naturally collections subgoals
serializable sometimes may necessary interleave plans achieving different goals
however instance serially decomposable possible design set
macro operators respect subgoals serializable korf
instance serially decomposable exists ordering state
variables effect operator state variable depends
state variable previous state variables ordering unfortunately bylander
shows determining serial decomposability pspace complete
one major open put forth bylander context
known serially decomposable difficult determine whether given instance
solvable far know work direction done chalasani
et al serial decomposability general permutation
considered particular showed np unknown
whether np hard recently complementary bylanders question
presented koehler hoffmann shed light question
instance unary operator domain whose causal graph acyclic
serially decomposable therefore concluded finding solution serially
decomposable may require exponential time e exptime
however bylanders question plan existence case theorem
apply apply np hardness directed path singly connected
graphs since addresses plan existence well
weld hypothesized underlying causal graph
acyclic serialization ordering subgoals obvious
serialized subgoals could solved extremely quickly backtracking required
although first observation sounds intuitive suggest
rarely true acyclicity causal graph implies serializability
cases structure provide us sufficient information actual serialization
ordering even causal graph directed tree one must think first choosing


fistructure complexity unary operators

ordering likewise imply causal graph form
undirected tree determining subgoal ordering np complete causal graph
directed path singly connected even complex
second observation true important
determine serialization ordering subgoals exact strategies
achieving showed certain cases n serializable subgoals
requires exponentially long solution domain variables binary
situation even worse corresponding complexity derived
computational analysis domshlak dinitz

connection related work complexity
idea analyzing exploiting structural properties classical
last years number important emerged generating plans
context strips representation language shown bylander
pspace complete despite fact existence many successful systems
especially recent years demonstrates possible practical wide list
domains bylander argues large gap theoretical hardness
practical success stems use domain dependent analysis
consequently authors explored existence constrained
classes easier
section shortly overview major previous complexity
discuss relationship presented
detailed presentation previous discussed refer reader
original papers
local syntactical restrictions
seminal bylander presents number complexity propositional analyzing different type formulas used
number type positive negative operator pre postconditions etc work
bylander extended interesting complementary erol al
example bylander shows propositional domains operator
restricted positive preconditions one postcondition tractable generally extremely severe restrictions operators required guarantee tractability
even membership np note bylander erol et al focuses local
syntactical properties operators e properties single operators
syntactic restriction pose
unarity operators determining plan existence apparently easier class
shown bylander hard general propositional e
pspace complete note entail theorem since
unary operators may induce causal graphs cycles therefore
none entailed presented bylander erol et
al


fibrafman domshlak

global syntactical restrictions
backstrom klein b subsequently backstrom nebel
consider types restrictions refined model sas formalism

state variables multi valued
two types preconditions considered prevail conditions variable
values required prior execution operator affected
operator preconditions affected operator
general four different restrictions considered works
p post uniqueness effect one operator achieves effect
words desired effects determine operators used plan formally
instance post unique vi v x vi
one operator post x
single valuedness one value state variable appears prevail
conditions operators instance certain operator requires light
prevail condition operator use prevail condition
light formally instance single valued iff exist
two operators vi v prv u prv u
prv prv
u unariness operator affects one state variable
b binariness state variables exactly two possible values e state variables
propositional
four properties syntactical however properties p differ
properties u b fact global nature post uniqueness singlevaluedness restrict form operators global property whole set
operators backstrom nebel showed us unariness single valuedness
extreme class plan generation polynomial
analyzed belong class ub definition already mentioned even determining plan existence class
pspace complete consider class pub backstrom nebel
showed pub instances exponentially long minimal solutions thus plan
generation pub requires exponential time ii existence bounded length plans
pub strongly np hard iii complexity general plan existence pub still
open question informally means strengthening restrictions ub pub
reduce complexity significantly least practical point view
proposition every ub instance tree causal graph post unique
transformed equivalent post unique instance low polynomial
time thus treeub pub
thorough analysis complexity sas refer backstrom nebel



fistructure complexity unary operators

proof consider ub tree causal graph suppose postunique means exist variable v v v v v
exist two operators v change value v v v prv
prv
assumption causal graph forms tree follows pred v
pred v easy see existence pair operators
simply impossible therefore let pred v w w w w without loss
generality assume prv w w prv w w otherwise instance
prv w u easy see redundant operator
observe case prevail dependence v w redundant replace
pair operators single operator changes value v
v v without prevail condition replacement brings us
equivalent instance operator set v post unique way
continue process iteratively problematic variables v arrive postunique instance

proposition ub instances tree causal graph singlevalued thus treeub ubs
proof proof proposition straightforward consider variable v v v
v v succ v u w case value change u
prevailed v value change w prevailed v therefore restricting
causal graphs even trees entail single valuedness
propositions treeub polynomial subclass pub
entailed tractability backstrom nebel
proposition ub instances polytree causal graph neither single valued post unique
proof proof straightforward consider polytree causal
graph exist variable v v pred v u w following
operator set v
pre
v
v
v
v

post
v
v
v
v

prv
u w
u w
u w
u w

clearly instance v neither single valued postunique since one operator achieving value v ii
values u values w appear prevail conditions operators v note
simple construction technique proof proposition shown restricting
causal graphs directed chains entails single valuedness however case restrictive



fibrafman domshlak

maximal indegree polytree minimal e equal thus
proposition valid polytree tree
proposition follows theorems introduce polynomial
np easy subclasses ub class respectively
structural restrictions propositional
jonsson backstrom b present class class
closely related examined since defines special subclass
binary variables unary operators acyclic causal graphs
class defined posing additional relatively severe restrictions
operator set variable v instance required static
e unchangeable ii symmetrically reversible e operator affecting v
exist operator affecting v prevail conditions opposite effect
iii splitting formal definition splitting property refer jonsson
backstrom b informally binary variable v splitting
instance split three well defined subproblems solved independently
class shown plan existence determined
polynomial time plan generation provably intractable since instances
exponentially long minimal solutions particular instance
used proof theorem
complexity analysis jnonsson backstrom b somewhat unique
complexity propositional since best knowledge
attempt exploit syntactical restrictions operator set
structural restrictions interaction variables analysis
seen continuing direction looking structural restrictions
believe eliminating marginal effect structure potential hardness allow us understand better connection component
interactions topology potential complexity
structural restrictions multi valued formalisms
variables longer propositional additional properties
identified possibly exploited particular additional internal structures
analysed
jonsson backstrom analyze different properties multi valued
structure called domain transition graph structure defined
state variable describes possible transitions different values
variable domain transition graph state variable v directed labeled
graph gv v e v associated vs set possible values v
x e operator applied state v x
application state v holds
jonsson backstrom identify sets structural restrictions domain transition
graphs make instances tractable roughly properties following
domain interference safe e operator unary irreplace

fistructure complexity unary operators

able respect every variable affects operator irreplaceable respect
variable v removal edges gv stem disconnects
weakly connected component gv every variable v graph gv restricted
set values appear prevail conditions operators acyclic
sequence operators annotating path x domain transition graph v
stronger shortest sequences connecting x sequence ak
stronger l subsequence ai ail ak
every j l prevail conditions j subset prevail conditions aij
jonsson backstrom present map computational complexity
different restrictions displaying frontier tractable intractable cases
domain transition graph combines structures influence many operators
particular variable therefore provide us global picture operator
set alone hence spite fact domain transition graphs capture relationship different variables allow us express structural properties
address interactions variables e g see property
observe domain transition graphs informative case propositional since distinguish variables changed
one direction variables changed directions although
property domain transition graphs allows distinguish polynomial
positive postconditions pspace complete
positive negative postconditions bylander seems helpful
hierarchical refinement propositional complexity hand
priori reason causal graphs informative multi valued
case exploiting properties causal graphs together properties domain
transition graphs seems natural direction extend work presented
recent work domshlak dinitz multi entity line coordination
seen investigating connections structure causal graph together
properties domain transition graphs complexity corresponding
case multi valued domains best knowledge
work done respect mixed structural analysis lot work
remains done instance combining properties domain transition
graphs studied jonsson backstrom properties
causal graph direction

summary future work
shown form causal graph strips unary
operators important factor determining computational complexity plan generation particular shown polynomial time exists
polytree causal graph node indegree bounded constant
generally shows polytree causal graphs
often referred bayes nets literature locally exponential e exponential maximal number parents node note hardware control
maximal node indegree expected small since prevail dependencies
variables reflect direct interconnections corresponding hard

fibrafman domshlak

ware components likewise shown directed path singly
connected causal graph maximal plan length low order polynomial
np complete generally shown relation number paths variables causal graph computational complexity corresponding
finally presented impact question
complexity serializable subgoals connected work
previous complexity
work leaves number open questions respect purely syntactical
mixture structural syntactical restrictions unary
operators former case one important directions analysis
causal graphs constantly bounded node indegree turns complexity analysis class helpful understanding computational
properties cp nets boutilier et al although provided partial answer
question general picture worst case complexity class
clear example indegree causal graph known bounded
structural property causal graph even clear whether
subclass np
latter case syntactical restrictions analysed together form
causal graph example one may interested computational properties
acyclic causal graphs restriction every operator
prevail conditions bounded constant well many
related questions respect special cases unary operators
interest future work

acknowledgments
preliminary version appeared sixth international conference artificial intelligence scheduling april would thank three
anonymous reviewers extremely helpful comments ronen brafman supported
part paul ivanier center robotics production management



fistructure complexity unary operators

appendix short review pop causal links threats
represent plan tuple ha li set unary operators set
ordering constraints l set causal links example
might set constraints specify plan
necessarily last operator commit particular order
naturally set ordering constraints must consistent e must exist

total order satisfying causal link form ap ac ap ac
operators possible value propositional variable vi denotes fact
ap produces e postcondition vi consumed ac e used
satisfy pre prevail condition ac causal links help us detect whether one operator
interferes work done enable execution operator ac
case said constitute threat one c causal links formally suppose


ha li plan ap ac causal link l let different operator


say threatens ap ac following two criteria satisfied
ap ac consistent
effect
partial order plan p contains threats possible goal
achieved total order plans consistent p ordering constraints
prevent plan generator must check threats remove adding one
two possible ordering constraints ap demotion ac promotion
tutorial introduction pop found weld pop
regressive framework partial order starts null plan continuously updates inserting actions removing threats process continues
precondition prevail conditions every operator plan supported
causal link threats exist first argument pop plan second
argument agenda goals need supported causal links item
agenda represented pair hi ai pre prevail condition plan
action last argument pop whole collection operators defined
instance initial call pop contains null plan specially initialized
agenda operator set given
introduce specialized deterministic pop starts
process variant null plan encodes
particular instance v vn goal corresponding null
plan exactly n dummy unary operators n n ordering
constraints n causal links l every
vi v corresponding start operator neither pre prevail conditions
effect specifies value variable vi initial state denoted
vi similarly ai end operator effect prevail conditions
precondition set value vi goal state turn denoted vi
actually goal state may specify values variables thus number end
operators less n however clarity presentation leave definition null
plan



fibrafman domshlak

description null plan modified weld better suit
restriction unary operators likewise initial call pop contains
agenda hv hvn



fistructure complexity unary operators

appendix b proofs auxiliary
lemma forward check successful pop pcg return valid plan
proof

lemma follow following claims

every agenda item exists operator effect
threats output pop pcg
ordering constraints consistent
agenda empty polynomial number steps
first claim follows success forward check procedure
forward check implies ij vi operator instance ij
therefore ij vi existence appropriate aadd promised
assume contrary ij vi without loss generality assume
first iteration happens variable u succ vi
edge labeled ij graph g u created forward check
follows aneed cannot ij prevail condition thus aneed affect
variable vi case aneed ij aneed ai
consider former case aneed ij ij previously selected
agenda assumption means ij vi contradicts assumption
ij vi since ij predecessor ij vi
consider last option aneed ai aadd ij goal value
variable vi consistent ij ij see step b ii ij
ij previously selected agenda assumption means
ij vi however contradicts assumption ij vi since vi
definition terminates node consistent goal value vi
addition since shown operators added
ai n agenda empty n steps


suppose operator threatens ap ac e
ap ac consistent
effect
given variable vi pop pcg forces operators affecting vi follows step
ix

x fmaxreq vi



thus ac operator prevail condition note ap
affect variable vi already showed ij vi
case il l j however ij prevail condition ac ordering
constraint ac ij added step eq follows


fibrafman domshlak

il ij ij il l j implied ap ac
contradicts assumption ap ac consistent
ordering constraints consistent two operators ai aj
implies ai aj aj ai follows ai used denote arbitrary
operator affecting variable vi
first note ordering constraint added step step
operators affecting variable operators affecting variable child
respect causal graph particular ai aj added step
vi vj vi pred vj whereas ai aj added step vj pred vi
assume contrary implies ai aj aj ai argument
know possibly empty path vi vj undirected
graph induced causal graph structural assumption know
undirected path vi vj unique thus situation follows
two chains operators
ai axi axi im aximm aj
ai ayi ayi im ayimm aj

k xk yk corresponding unique undirected
path vi vj
vi vi vi vim vim vj
without loss generality internal elements disjoint otherwise
operator b belongs internal parts reduce
chains deduce ai b ai b
proof consistency follows
prove exist least one least
one internal element
b useful property exploited c
c k axikk ayikk different except x
note together c contradicts assumption aximm ayimm
assume contrary contain internal elements
actually adds ordering constraints ai aj aj ai
vi vj variable ai aj stem step
ai precondition aj effect however definition forwardcheck aj role w r ai thus impossible aj ai
added alternatively vi parent vj ai aj stem step
ai prevail condition aj effect suppose ai bji thus
bji prv aj turn aj ai added step aj precondition
ai prevail condition bji prv aj ai wij contradicts


fistructure complexity unary operators

assumption ai bji alternatively assume ai wij
situation completely symmetric thus hence proved
contain least one internal element particular means
next last elements different fact exploited later
proof
b consider subchains consist operators affecting one particular variable subchain e k j xk ordering
j
j
constraint ajik aj
ik stem step aik precondition aik
effect thus post ajik pre aj
ik similarly subchains k
j
j yk post aik pre aj
ik follows denote property
local monotonicity
c first suppose x consider following sequence
ayi ayi axi
local monotonicity construction forward check fact

follows post ayi appears post axi maximal sequence vi continuing


next variable vi claim post ayi appear post axi vi
vi parent vi axi stem step axi
prevail condition effect turn ayi stem step
prevail condition precondition ayi relation
axi ayi construction g e vi forward check follows post
appears post vi subsequently local monotonicity follows
post ayi appears post axi vi
ii similarly vi parent vi ayi stem step
prevail condition ayi effect axi stem step
prevail condition axi precondition relation
axi ayi construction g e vi forward check follows post
appears post vi local monotonicity follows
post ayi appears post axi vi
alternatively x axi ayi ai immediately follows
analysis similar shows post ayi appears
post axi vi
established post ayi appears post axi vi apparent
inductive argument allow us k post ayikk
appears post axikk vik note particular means operators
axikk ayikk different contradicts assumption aximm ayimm



fibrafman domshlak

theorem
plan existence strips unary operators
directed path singly connected causal graph np complete
proof first membership np let minplansize denote size
minimal plan instance maxreq property state variables
following upper bound minplansize straightforward lemma
x
minplansize
maxreq v n

vv

thus guess minimal solution given solvable verify low
polynomial time
proof hardness polynomial reduction sat corresponding
propositional plan generation directed path singly connected causal graph
sat finding satisfying assignment propositional formula conjunctive normal form conjunct clause three literals
let f c cn propositional formula belonging sat let x xm
variables used f equivalent propositional directedpath singly connected causal graph constructed follows variable set v
x x xm xm c cn variables xi xi predecessors
causal graph thus pred xi pred xi turn n pred ci
xi xi xi xi xi xi xi xi xi variables participate
ith clause f finally init goal consist false true assignments
variables v respectively
let every operator presented three tuple h pre post prv pre post
prevail conditions respectively corresponding operator set specified
follows
xi



h f

xi



h f

ci



h f h f h f



ji j corresponds truth assignment variable xij satisfies
ith clause f let ci x x x x x f x
f x x x f
illustrate proposed reduction consider following example formula f consist
clauses x x x x x x x x x causal graph
corresponding follows
abc
gfed
abc
abc
gfed
gfed
abc
abc
abc
gfed
abc
gfed
x f gfed
x
x f gfed
x
x
x
x

f



h


fff
f
h x x x





f
f
h






x x

f

x x h h
f







x

f
h
f

f x x x
h
ffff

f

x
h



x
fff
h

x x f x f

h





x
f h


f x x x
f
x
abc
gfed
abc
gfed
abc
gfed
c
c
c


abc
gfed
x
x x



fistructure complexity unary operators

propositional single effect operators underlying
directed path singly connected causal graph clearly goal reachable solvable
satisfying assignment f found thus plan existence propositional
directed path singly connected causal graphs np complete

lemma given k ordered sequences k n elements number k
different merges k preserving orderings induced k elements given


k
n
yx
n ni
k

j
j
j

proof considering merge operation k sequences iterative merge
k already merged sequences easy see k
expressed

k n k n k
k


k
x stands number different order preserving merges two ordered
sequences sizes x without loss generality assume x
consider process merging two ordered sequences
partition j sub sequences
ii partition l sub sequences j l j
iii interleaving order preserving concatenation sub sequences
first observe partitioned j sub sequences second

j numbers different partitions corresponding steps ii j



respectively finally given pair partitions exist exactly
j
one possible interleaving order preserving concatenation step iii therefore




x
x
x

j
j
j

combining eq eq arrive eq



fibrafman domshlak

references
backstrom c klein parallel non binary polynomial time
proceedings twelfth international joint conference artificial intelligence pp
sydney australia morgan kaufmann publishers
backstrom c klein b polynomial time sas pubs class
computational intelligence
backstrom c nebel b complexity sas computational
intelligence
boutilier c brafman r hoos h poole reasoning conditional ceteris
paribus preference statements proceedings fifteenth annual conference
uncertainty artificial intelligence pp morgan kaufmann publishers
bylander complexity serial decomposability proceedings
tenth national conference artificial intelligence pp san jose cl aaai
press
bylander computational complexity propositional strips
artificial intelligence
chalasani p etzioni mount j integrating efficient model learning
solving permutation environments proceedings second
international conference principles knowledge representation reasoning
pp cambridge morgan kaufmann publishers
chapman conjunctive goals artificial intelligence
domshlak c dinitz multi agent line coordination structure complexity proceedings sixth european conference toledo spain
domshlak c shimony e efficient probabilistic reasoning bayes nets
mutual exclusion context specific independence proceedings sixteenth international flairs conference special track uncertain reasoning st
augustine fl aaai press appear
erol k nau subrahmanian v complexity decidability undecidability domain independent artificial intelligence special issue

etzioni acquiring search control knowledge via static analysis artificial intelligence
jonsson p backstrom c state variable structural restrictions
complexity artificial intelligence
jonsson p backstrom c b tractable plan existence imply tractable
plan generation annals mathematics artificial intelligence
kambhampati admissible pruning strategies plan minimality planspace proceedings fourteenth international joint conference
artificial intelligence pp montreal canada


fistructure complexity unary operators

knoblock c automatically generating abstractions artificial intelligence
koehler j hoffmann j reasonable forced goal orderings use
agenda driven journal artificial intelligence

korf r macro operators weak method learning artificial intelligence

korf r search quantitative artificial intelligence

pell b bernard chien gat e muscettola n nayak p wagner williams
b autonomous spacecraft agent prototype proceedings first
international conference autonomous agents pp marina del rey cl
acm press
penberthy j weld ucpop sound complete partial order planner
adl proceedings third international conference principles knowledge representation reasoning pp cambridge morgan kaufmann
publishers
shimony e domshlak c complexity probabilistic reasoning directedpath singly connected polytree bayes networks submitted publication
smith peot postponing threats partial order proceedings
eleventh national conference artificial intelligence pp washington
c aaai press
weld introduction least commitment ai magazine

weld recent advances ai ai magazine
wiest j levy f k management guide pert cpm prentice hall
williams b nayak p model reactive self configuring systems proceedings thirteenth national conference artificial intelligence
pp portland aaai press
williams b nayak p reactive planner model executive
proceedings fifteenth international joint conference artificial intelligence
pp nagoya japan




