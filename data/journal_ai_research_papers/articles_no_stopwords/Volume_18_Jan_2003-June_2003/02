journal artificial intelligence

submitted published

learning order bdd variables verification
orna grumberg
shlomi livne
shaul markovitch

orna cs technion ac il
slivne cs technion ac il
shaulm cs technion ac il

computer science department
technion israel institute technology
haifa israel

abstract
size complexity software hardware systems significantly increased
past years harder guarantee correct behavior one
successful methods automated verification finite state systems model
checking current model checking systems use binary decision diagrams bdds
representation tested model verification process properties
generally bdds allow canonical compact representation boolean function given
order variables compact bdd better performance one gets
verifier however finding optimal order bdd np complete
therefore several heuristic methods expert knowledge developed
variable ordering
propose alternative variable ordering gains
ordering experience training uses learned knowledge finding
good orders methodology offline learning pair precedence classifiers
training learning variable pair permutation likely
lead good order training model number training sequences evaluated
every training model variable pair permutation tagged performance
evaluated orders tagged permutations passed feature extractor
given examples classifier creation given model
order requested ordering consults precedence classifier constructs
pair precedence table used create order
integrated smv one widely used verification systems preliminary empirical evaluation methodology real benchmark
shows performance better random ordering competitive
existing use expert knowledge believe sub domains
alu caches etc system prove even valuable features
ability learn sub domain knowledge something ordering

introduction
size complexity software hardware systems significantly increased
past years harder guarantee correct behavior thus formal
methods preferably computerized needed task
one successful methods automated verification finite state systems
temporal logic model checking clarke emerson sistla queille sifakis
temporal logics suitable formalisms describing behavior program time
model checking procedure receives finite state model system specification
c

ai access foundation morgan kaufmann publishers rights reserved

figrumberg livne markovitch

written temporal logic formula returns yes model satisfies formula
meaning system behaves according specification otherwise returns
along counter example demonstrates bad behavior
model checking successful finding subtle errors systems
currently recognized hardware industry important component
development phase designs however model checking procedures often suffer
high space requirements needed holding transition relation intermediate

one promising solutions use binary decision diagrams bdds akers bryant basic data structure model checking
bdds canonical representations boolean functions often concise size
conciseness yields efficiency computation time since straightforward
represent transition relation intermediate boolean functions bdds
particularly suitable model checking today existing industrial bdd verifiers ibms rulebase beer ben david eisner landver motorolas
verdict kaufmann pixley used many companies development
infrastructure
size bdd given function sensitive ordering variables
bdd however finding optimal ordering yields smallest bdd given
function np complete bollig wegener therefore several heuristic
expert knowledge developed variable ordering
hope reducing bdd size unfortunately spite resources invested
produce good enough variable orders reason may
general rules used domain specific knowledge exploited
goal develop learning techniques acquiring
domain specific knowledge variable ordering assume availability one
training training used line acquisition ordering experience
used ordering variables previously unseen model
first present method converting ordering learning task concept
learning concept set ordered variable pairs right
order examples ordered pairs variables given training model
statistical method tagging examples evaluated training orders present
set variable pair features standard concept learning
apply decision tree learning generate decision tree training model used
unseen model combine trees generate partial order used
generating required order present extension learns
context precedence relations
integrated smv mcmillan backbone
many verification systems empirical evaluation methodology real benchmark
hardware designs shows performance much better random ordering
competitive existing use expert knowledge
section contains background model checking section presents main
empirical evaluation section shows context conclusions
presented section


filearning order bdd variables verification

background
model checking introduced clarke emerson queille sifakis
early presented automatically reason
temporal properties finite state systems exploring state space use binary
decision diagrams bdds represent finite state systems perform symbolic state
traversal called symbolic model checking use bdds greatly extended
capacity model checkers states routinely verified
bdds introduced akers compact representations boolean functions bryant proposed ordered binary decision diagrams obdds canonical
representations boolean functions showed computing boolean
operations efficiently obdds
following subsection gives overview finite state systems represented
symbolic model checking bdds described variable ordering
defined existing static variable ordering reviewed finally
brief description machine learning used ordering given
finite state machines symbolic model checking
finite state systems fsm described defining set possible states
system transition relation states state typically describes values
components e g latches digital circuits component represented
state variable let v v v vn set variables system let k vi
set possible values variable v state system described
assigning values variables v set possible states
sa kv kv kvn
state written function true state
vn


vi cj

cj kvi value vi state set states described function
disjunction functions represent states
figure shows bit counter state bit counter described
tuple gives assignment variables v v v example tuple h
represents state v v v corresponding boolean expression
state v v v
order describe system need specify transition relation
transition relation describes possible transitions system state thus
described pairs states hpresent state next statei next state system state
transition present state variables v represent present state
variables variable vi v define corresponding next state variable
vi v v denote set next state variables
example valid transition bit counter h h
boolean function represents transition v v v
v v v transition relation represented


figrumberg livne markovitch

v

v

v

figure bit counter
present state
v v
v

























next state
v v v

























table bit counter transition relation table
boolean function disjunction boolean functions transitions
table shows transition relation bit counter
alternative method describing transition relation state variable
define valid next states form known partitioned transition relation
transition relation described set functions instead one one
variable variable vi boolean function ti v vi defines next value vi vi given
current state system v
synchronous systems simultaneous transition system
components transition relation

vn


ti v vi

model checking common use partitioned transition relation form representation since usually compact memory requirements thus allows handling
larger systems bit counter next state boolean functions given
stands boolean operator xor

v v v v
v v v v v
v v v v v v


filearning order bdd variables verification

binary decision diagrams
binary decision diagram bdd dag directed acyclic graph representation
boolean function bdd composed two sink nodes several non sink nodes
two sink nodes labeled represent corresponding boolean values non sink
node labeled boolean variable v two outgoing edges labeled
else non sink node represents boolean function corresponding
edge v boolean function corresponding edge v
ordered binary decision diagram obdd bdd constraint
variables ordered every root sink path obdd visits variables
ascending order
reduced ordered binary decision diagram robdd obdd node
represents distinct logic function representation canonical bdd representation
compact representation possible given boolean function variable
ordering
v

v

v

v

v

v

v
v
v






















































v
v
v





















b

v

v



v



v

v
v
v
v



v



v
v
v

















































c

















figure bit counter transition relation b partitioned transition relation c

figure b shows obdd robdd respectively representations
transition relation function bit counter dashed lines edges
solid lines edges robdds two leaf nodes one one
drew several times enhance readability robdds use complement
edges produces even compact representation use complement
edges reasons readability figure c shows obdd robdd
representations partitioned transition relation bit counter variable
order v v v v v v used representations variable ordering
model checking place next state variable v adjacent present state variable v


figrumberg livne markovitch

rest document refer robdds bdds unless explicitly state
otherwise
bollig wegener proved finding optimal variable ordering npcomplete order optimal yields bdd smallest number
nodes bryant pointed variable ordering greatly influences size
bdd showed boolean function one variable ordering may yield bdd
exponential number variables different ordering may yield bdd
polynomial size
v

v

v

v

v

v

v

v










b

figure robdds function f v v v v v v v v
figure gives example effect variable ordering bdd size function f v v v v v v v v variable ordering v v v v
b variable ordering v v v v
developed variable ordering exact ishiura
sawada yajima drechsler drechsler slobodova friedman supowit
optimal order use method similar
dynamic programming pruning optimal order due complexity
exact practical small cases one usually
turn heuristic methods heuristic methods roughly divided two
groups
static ordering aziz tasiran brayton butler ross rohit kapur
chung hajj patel fujii ootomo hori jain adams fujita
fujita fujisawa kawato malik wang brayton sangiovanni vincentelli
touati savoj lin brayton sangiovanni vincetelli try
good ordering constructing bdd
topological structure verified system
dynamic ordering rudell meinel slobodova bollig lobbing wegener meinel slobodova meinel somenzi theobald ishiura
et al bern meinel slobodova fujita kukimoto brayton
mercer kapur ross zhuang benten cheung drechsler becker


filearning order bdd variables verification

gockel panda somenzi panda somenzi plessier
given bdd variable order reorder variables hope finding
smaller bdd
model checking procedures variable ordering central component initial
phase model checking system translated bdd representation static
ordering used order built stage greatly influences memory usage
whole computation however since model checking keeps producing eliminating
bdds variable order changed dynamically order effect size
current bdds dynamic ordering used order achieve goal applied
model checking procedure whenever size bdds reaches certain threshold
since work introduces static ordering machine learning
next subsection presents review existing static
developed combinational circuits e whose outputs depend
current inputs inputs previous cycles described hardware
terminology order simplify description describe terminology
used far
static ordering
static ordering try initial good order bdd
extract topological data model use data determine order
convert model described set next state functions directed
graph known model connectivity graph vertices graph variables
boolean operations gates variable vertex represents variable gate vertex
represents function edges ni nj graph ni
variable gate vertex nj gate vertex edge ni nj placed
function represented ni operand e immediate subfunction function
represented nj divide static four groups differ
way use graph information
graph search
method suggested malik et al assigns vertex level metric orders
variables decreasing level value level vertices edges set
zero level every vertex v set level vi maxvj vi vj level vj
method resembles bfs breadth first search originates nodes
edges progresses backwards model fujita et al proposed executing
dfs depth first search vertices edges progressing backwards
variables added post order form
malik et al fujita et al designed cases one
function represented bdd hardly ever case model checking
butler et al adapted fujita et al multiple starting
points multiple vertices edges heuristic guides
select first vertex vertex represents function depends
maximum number variables heuristic guides search advance backwards


figrumberg livne markovitch

inner vertex vertex leads maximum number different variables
tie breaking heuristic fujita fujisawa matsunaga enhanced
advises selecting case tie vertex maximum number edges
dfs methods append variables variable order another dfs
relies interleaving variables order fujii et al
adds variable variable precedes dfs order
graph evaluation
graph evaluation use model graph evaluate model variables
perform guided search evaluation values minato et al propagate
values backward graph starting vertices edges whose value
set vertices boolean operations values edges summed
value obtained divided equally edges done recursively
vertex variable reached variable vertices propagated values accumulated
variable evaluation value order constructed iteratively adding variable
highest value removing graph updating values
chung et al proposed two frameworks first framework composed two sweeps first sweep vertex assigned value values set
propagating starts variable vertices edges advances
forward edges vertices graph second sweep guided
dfs initiated vertices edges executed search executed backward
graph guided maximal value means order traversal
among vertex ancestors according assigned value number heuristics
compute values vertices proposed
level sets value variables input edges zero value
vertices set maximal vertex value inputs plus one
fanout propagates two values graph one boolean value
boolean operation vertex values summed passed along rather
computed according boolean operation vertex initial values
variables input edges value set number edges
variable
second framework proposed chung et al shortest distance
pair variables computed total distance variable computed sum
distances variables variable lowest total distance selected
first variable next variable selected closest variable last ordered
variable ties broken according distance previous ordered variables
graph evaluation try order variables variable
influences next state functions first differ
methodology use order variables order
variables substantially influence next state functions placed higher
variable order toward beginning order place
variables according proximity previously ordered variables


filearning order bdd variables verification

decomposition
decomposition break model parts solve
two different first finding good order part second
finding order parts order constructed combining solutions
two
malik et al extended adapted finite state machines fsm
toutai et al model decomposed next state functions
considered separately variables next state function ordered
according malik et al next state functions ordered cost function
ordered functions many overlapping variables adjacent
variable order obtained adding variables next state functions according
order parts removing variables already exist
aziz et al decomposes model different way model
hierarchical composition constructed joining number internal parts
pass information among usually less communication among parts
within variables internal part tend depend highly one another
uses process communication graph pcg hierarchical
structure model communication parts pcg vertex
internal part edge j connects vertex vertex j part j depends
bit part pcg parallel edges j one bit value j depends
upon alternatively edges could weighted
given order parts upper bound bdd size model computed computation size parts amount communication
heuristics guided upper bound applied order determine
order parts order variables part decided one previous
ordering
sample
sample static jain et al real static
sense create order information extracted model
description sample perform tests parts model building transition
relations reachable states part number orders evaluated good
orders merged create complete order model sampling use
traditional order candidate orders parts candidate
orders checked sampling
summary
majority graph search graph evaluation developed
adapted symbolic model checking
developed context combinational circuits others developed
simple case one function symbolic model checking rarely combinational
outputs almost depend inputs previous cycles
one function display adapting existing conform needs


figrumberg livne markovitch

symbolic model checking degrees success adapted
heuristic apply simple rule logical reasoning behind
decomposition heuristic provide theoretical upper bound
however bounds use rarely realistic require much smaller
bdds decomposing model parts solving
ordering part graph search thus inherit drawbacks

despite efforts invested many
developed static ordering yet satisfactory produced bdds
large manipulate dynamic ordering must applied one
approaches generality utilize domain specific knowledge
domain specific knowledge essential solving majority complex
difficult retrieve next subsection discuss machine learning methods
acquiring domain specific knowledge ordering tasks
learning order elements
learning order elements done first trying induce partial order
used generating total order context partial order usually called
preference predicate preference predicate induction set tagged pairs
elements binary tag identifies preferred element broos branting
present method inducing preference predicate nearest neighbor classification
distance untagged pair tagged pair computed sum
distances corresponding elements closest tagged pair selected
preferred element untagged pair one matching preferred element
tagged pair
utgoff saxena represent pair b concatenated feature vector
ha b bn preference predicate decision tree induced examples
utgoff clouse represent preference predicate polynomial let
ha b hb bn pair elements represented feature vectors let
w wn set weights preference predicate p defined follows
p b



n

wi ai bi
otherwise

p

example represents linear constraint weights found solving set
constraints
cohen schapire singer extended mechanism allowing
preference function instead ai bi expressions present
two methods generating total order induced preference predicate
methods use preference predicate construct graph nodes elements
ordered directed edge placed two elements precedence
relation two inferring order graph given first defines
node degree equals sum outgoing edges minus sum
incoming edges order constructed selecting node greatest


filearning order bdd variables verification

degree removing edges graph second constructs order
two stages first stage strongly connected components graph
found ordered according dependencies second
stage elements component ordered first

learning static variable ordering
producing good variable order requires extensive understanding bdds relation
model represent knowledge manually inserted human expert
however task complex large therefore rarely done existing
static ordering use relatively simple heuristic rules expert
knowledge rules look model structure compose ordering since
rules applied variables general thus limited
ability produce good orders alternatively try build program
automatically acquires specific knowledge ordering experience section
present
first step building learning deciding knowledge wish
acquire ordering experience existing ordering demonstrate
precedence relation variables key consideration order creation
graph search search graph evaluation try place
variable variables
influence next state value generally variable order
n
n variables yields precedence pairs precedence pair v vj denotes variable
vi precede vj variable order example variable order b c yields
precedence pairs b c b c b c
task learning precedence pairs transformed concept learning
task concept learning task defined
universe x concept learned
concept c subset items x want learn usually marked
associated boolean characteristic function f c
set examples pairs form hx f c x x x
set features functions x allow generalization
many learning tasks difficult transform format listed
already clear discussion general concept wish
learn set variable pairs first precede second variable
ordering
precisely define universe concept learned set
pairs h vi vj vi vj ordered variable pair comprised v vj
variables model since expect pairs preferred order
define ternary instead binary concept ternary concept following
classes
practice need small subset precedence pairs constructing total order



figrumberg livne markovitch

c class h vi vj preferable place v prior vj
order get good initial order
c class h vi vj preferable place v vj order
get good initial order
c class h vi vj placing vi vj likely lead
good variable order placing v vj
following subsections describe learning concept
framework
start description general framework learning goal
variable orders yield bdds small number nodes given training
model first generates set orders variables define utility
function u variable orders following orders used initial order
building bdd representation model bdd denoted bdd includes
partitioned transition relation set initial states utility u
generated order defined reversely proportional number nodes
bdd constructed order
subset consists variable pairs appear together next state
function selected example extractor possible variable pairs call
pairs interacting variable pairs example next x z z
interacting variable pair example tagger tags selected ordered pairs
one classes c c c evaluated orders tagged pairs
forwarded feature extractor model computes pair
feature vector learner id quinlan decision tree generator uses
tagged feature vectors create pair precedence classifier
several training used manner construct different pair precedence
classifiers solving unseen pair precedence classifiers used
ordering create variable order
learning framework creating pair precedence classifier training model
given figure complete data flow displayed figure following subsections
describe greater detail components framework
training sequence generator
goal training sequence generator produce orders high variance quality
exploited tagger see subsection simplest strategy generating
sequences producing random orders indeed strategy used
experiments described one potential
domains good orders bad orders rare case random generator
necessarily produce sequences desired diversity quality
use smv mcmillan system purpose



filearning order bdd variables verification

input training model
output precedence classifier
create sample orders
use smv evaluate utility sample order bdd size
interacting variable pairs training model
evaluated sampled orders tag ordered pair
interacting variable pair
transform tagged pair tagged feature vector
create classifier tagged feature vectors
figure training model precedence classifier construction

training
order
smv

training
model

evaluated
orders

tagged
pairs

example

feature
extractor

tagger

bdd

example

interacting
variable
pairs

learner

extractor

real
model

ordering


classifier

tagged
feature
vectors

order

figure data flow

alternative actively try producing orders good orders
bad therefore creating large diversity quality one way producing
good order taking orders dynamic ordering process
another option existing static ordering one interesting idea
try bootstrap process adaptive ordering
training examples thus resulting progressively diverse input


figrumberg livne markovitch

example extractor
given set n variables extract n n example ordered pairs training
actually use ordered pairs examples
two main reasons selective examples use
example carries computational costs associated tagging feature extraction
added computation induction procedure
noisy examples known harmful effect induction process
process selecting subset examples tagged set untagged
examples called selective sampling two common ways performing selective
sampling one automatic methods use general metrics selecting
informative examples lindenbaum markovitch rusakov way
domain specific heuristics potential example informative
work use second consider function f variables
represented within bdd n variables n number nodes used
represent f depends relative order variables means changing
order n variables would influence bdd representation
function f
bdd representation model checked consists initial states
model next state functions variables since bdd representation
initial states typically small take account therefore looking
examples consider next state functions usually function defined
subset model variables thus order pair variables v vj
appear together next state function less likely affect quality
generated order therefore filter pairs
example tagger
ordered variable pair vi vj tagged belonging c preferable
place vi vj let v v vn set variables given model let
set possible orderings v let vi vj set vi precedes
vj ordered variable pair vi vj defined preferable vj vi
average u ovj vi average u ovi vj
since feasible evaluate possible orders sample space possible
orders evaluate partition samples two sets averages
estimate real averages replace term smaller definition
significantly smaller determined unpaired test tests
significance given confidence difference averages two samples
two populations
precisely variable pair v vj set sampled orders partitioned two subsets svi vj ovi vj svj vi ovj vi unpaired test
predetermined confidence level used check averages set utilities differ
significantly ordered pair corresponding set smaller average


filearning order bdd variables verification

tagged ordered pair tagged meaning belong
c c respectively otherwise average difference significant
ordered pairs tagged meaning belong c
elaborative could use value weight important particular order weights could solve conflicts ordering process scheme
would require however method incorporate weights induction one
method trying induce continues function instead ternary function
feature extractor
want generalize training future unseen cannot represent
pairs variable names rather use representation used
across induction require examples represented
feature vectors
process constructing appropriate feature set crucial part applying
learning common knowledge engineering process
domain expert comes set features might relevant role
induction combination features relevant
specific
come set features variable pairs features extracted
model connectivity graph attributes inspired traditional
static ordering attributes categorized three groups
variable attributes defined single variable try capture characteristics
model one example variable dependence attribute equals
number variables variable depends attribute inspired
value used butler et al guide dfs search higher value indicates
larger portion variables needed determine variables
next state value thus higher value may indicate variable location
lower order another example variable dependency takes
complementary view variable dependence attribute equals number
variables depend given variable higher value may indicate
variable placed higher variable order
symmetric pair attributes defined variable pair v vj attributes try
capture strength bond two variables well
pair variables model example pair minimal distance
measures shortest path variables model connectivity graph
shorter path indicate stronger bond variables distance
ordering framework chung et al uses similar feature order variables
another example pair mutual dependency counts number variables
whose next state function depends v vj
non symmetric pair attributes try capture relationship two variables example pair dependency ratio ratio variabledependency values two variables ratio relatively high low may
indicate relative order two pair ns distance evaluates influence one


figrumberg livne markovitch

variable next state value measuring distance
variables subgraph represents next state function
complete list attributes found appendix
induction
feature extraction phase data represented set tagged feature vectors
type representation used produce classifiers many induction
including decision trees hunt marin stone friedman quinlan
breiman frieman olshen stone neural networks widrow hoff parker
rumelhart mcclelland nearest neighbor cover hart duda
hart decided use decision tree classifiers relatively fast
learning fast classification fast classification especially important since wish
competitive ordering number variable pairs need
classify large
decision trees researched thoroughly last decade producing many
valuable extensions one extension enables decision tree give
classification items associate classification confidence estimation used variant allow conflict resolution described
section
ordering
outcome learning process described last four subsections set decision
trees one training model
could generate one tree union generated samples one advantage
multiple tree expect examples model
consistent allowing generating compact trees contrast set examples coming
different likely noisy yielding large tree addition multiple tree
version allows us voting scheme ordering process described
given model first extracts interacting variable pairs
classifiers applied feature vector representations pairs
classifier classifications pairs gathered form precedence table
tables merged one table order creation uses merged
precedence table construct variable order following subsections describe
components greater detail figure shows data flow ordering
building precedence table
build precedence table given classifier asks two questions
interacting variable pair vi vj
vi vj
vj vi


filearning order bdd variables verification

pair
precedence
classifier
pair
precedence

real

pair

feature



extractor

extractor

classifier

pair

pair

tree

table

pair

pair

tree

table

merger

merged
pair
precedence
classifier

pair

pair

tree

table

table

order
creation


variable
order

figure ordering data flow











vi v j



yes
yes
yes
unknown
unknown
unknown

vj vi

yes
unknown

yes
unknown

yes
unknown

vi vj order
unknown
v j vi
unknown
v vj
unknown
unknown
unknown
unknown
unknown

table pair order table
two agree pair order set agreed order disagree order
set unknown table summarizes possible answers two questions
resulting pair order
merging
constructing pair precedence tables training classifiers merge
tables voting scheme variable pair v vj count number tables
vote vi vj number tables vote vj vi decide pair
order according majority ignoring unknown votes
assuming majority vote chooses order v vj confidence vote
conf v v conf v v
computed vote vii vjj vote vjjvii vote vi vj number tables vote


figrumberg livne markovitch

vi vj conf vi vj sum confidence values votes vote v j vi
conf vj vi defined similarly value turns lower set
minimal value
cycle resolution
order build total strict order merged table table must contain
cycle however guarantee therefore
apply cycle resolution makes table cycle free
precedence table seen directed graph nodes variables
weighted edge vi vj vi vj many possible ways
eliminate cycles directed graph one reasonable bias removing least number
edges known minimum feedback arc set proven np hard
karp approximation exist even naor schieber
sudan costly purposes
use instead simple greedy solve constraints
edges gathered list sorted decreasing order according weights
e confidence graph initialized hold variable vertices list
edges traversed edge added close cycle
pair precedence ordering
stage hold acyclic merged precedence table last step
ordering process convert partial order represented table total order
done topological ordering stage finds minimal
variables e variables constrained follow unordered variable
set select variable vadd maximal fan add last ordered
variable add variables larger v add appear
constraint unordered variable desirable place
interacting variables near pair precedence ordering ppo
listed figure figure lists selection v add ppo
one possible change ordering process delay cycle resolution last
stage call version cycle resolution demand modified
perform cycle resolution merged table instead works
merged table may contain cycles table contains cycle must
reach stage variables ordered minimal variables
case performs cycle resolution continues ordering
process
experiments
performed empirical evaluation ppo
iscas brglez bryan kozminski benchmark iscas benchmark circuits
used empirically evaluate many deal aspects
circuit design chamberlain wahba borrione nakamura takagi kimura
watanabe long iyer abramovici iyer abramovici konuk
larrabee discovered circuits insensitive initial


filearning order bdd variables verification

input merged pair precedence table
output variable order
let v set variables
let v v v v v v
let v v v v v v

vc vi bef ore vi v af ter vi v
vn c v v c
vc
vmin vi vc af ter vi vc
b vadd argmaxvi vmin bef ore vi vc
c order order vadd



b

vc vc vadd
e vi vc
af ter vi vc bef ore vi vc
order order vi vc vc vi
add vn c end variable list
one exists select one
b add variable order

figure pair precedence ordering
ordering means entire sample initial orders yielded model bdds similar
sizes eliminated circuits set remaining circuits selected
number variables smv handle ended following
five circuits numbers
parentheses stand number variables model
began offline learning session three smaller
used training generated random
orders extracted examples described previous section
induced three precedence classifiers form decision trees
number selected since proved sufficiently large real application
used anytime training sequences generated
long user willing wait offline learner alternative would
keep aside validation set would used testing systems performance
training could stopped learning curve flattens
tested two larger
three learned decision trees used generate merged precedence table


figrumberg livne markovitch

pair
merged
table

minimal
elements
unordered
variables


minimal

filter
maximal

maximal
minimal
elements

selected
element
select
one

variable
order

figure pair precedence ordering v add selection

ppo cycle resolution demand compared random
addition compared two advanced graph search
static ordering dfs append fujita et al interleave
fujii et al used adaptation multiple
starting points butler et al expanded version includes tie breaking
rule fujita et al random taken variable orders
two run times every model performance
ordering measured number nodes model bdds partitioned
transition relation initial states
table figure obtained table shows model
ppo outperformed random order model ppo outperformed random order
ppo vs random





x

random
ppo



bdd nodes











model



figure comparative histogram ppo vs random



filearning order bdd variables verification

model



random
average
std




ppo
average
std




table comparative table ppo vs random
comparison two static given figure
learning training becomes competitive
existing ordering written experts




x

append
interleave
ppo





bdd nodes











model



figure comparative histogram ppo vs static
evaluate utility learned knowledge would compare performance ordering process without learned knowledge ordering without
learned knowledge equivalent random ordering comparison
random ordering reveals learner indeed induced meaningful knowledge learning process method much stable random
ordering indicated comparing standard deviation large variance
random ordering indeed exploited tagging procedure explained section small variance obtained random ordering
explain improvement obtained ppo much smaller
circuit sophisticated training sequence generator described
section might successful circuit
comparison hand crafted may look disappointing first look
since learning system better existing recall
however comparing automated learning process human expertise
works empirical machine learning make comparisons performance
learning common compare performance learning


figrumberg livne markovitch

human expert expert system since cases clear handcrafted would outperform automated learning processes since hardly
learning systems built solve bdd variable ordering
could make common comparison learning systems

learning context precedence static ordering
precedence relation one key considerations used traditional static ordering
another key consideration clustering variables subsequent
ordering try place highly interacting variables near
effect variable clustering bdd seen simple example given
figure function switching two variables v v increases bdd size
nodes function orders variables two clusters
v v v v kept together yield minimal bdd representation variable
orders yield less compact bdd thus function key consideration
compliance clustering precedence taken account
variable distance
discussion leads hypothesis distance variables important factor considering alternative orders one way obtain distance information
learning distance function pairs variables however two

target distance function well defined across example
train small absolute distance function likely applicable
large
information absolute distances variables sufficient construct
good ordering absolute distance uniquely define
order variables fact defines two possible orders one
reverse
example figure demonstrates order reverse yield bdds
significantly different size bdds figure represents two
functions f b c e b c c f b c e b
c c e absolute distance variables orders clearly
however upper bdd approximately double size lower one
wanted check whether realistic examples reverse orders yield bdds
significantly different size tested iscas benchmarks
created variable orders model order compared
quality quality reversed order found many cases one order
exceptionally good reversed one exceptionally bad thus learning
absolute distance sufficient information needed
conclude inherent learning utilizing absolute
distances still clustering key consideration pursued suggest


filearning order bdd variables verification

f



f

b
c

e
























f

e
f


c
b
















b

figure robdds functions f b c e b c c
f b c e b c c e

alternatively learning relative distance determines variables v vj vk
vj vk closer vi given vi precedes two
remainder section describes method learning utilizing context
precedence infer relative distance variables
context precedence
context precedence relation triplet v vj vk given vi precedes vj vk
variable vj come variable vk thus context precedence relation adds
context pair ordering decisions
pair precedence learning define universe set pairs h v vj vk
vi vj vk variables model universe divided three classes
c c c examples classes drawn way pair
precedence framework applied minor changes work context precedence
relations minor changes described
example tagger
variable triplet vi vj vk tagged c given vi precedes vj vk
preferable place vj vk e vi vj vk pair precedence learning use
set evaluated variable orders tagging set orders partitioned
three subsets depending three variables first given partition defined
vi example test order v j vk test described section


figrumberg livne markovitch

reduce number noisy examples use partition yields
significant test
feature extractor
attributes triplet vi vj vk computed attributes two pairs
vi vj vi vk attribute value division subtraction two corresponding
attribute values two pair attributes
precisely assume pair v vj attributes f vi vj fn vi vj
pair vi vk attributes f vi vk fn vi vk triple vi vj vk
attributes f vi vj f vi vk fn vi vj fn vi vk fl vi vk
corresponding attributes subtracted instead divided
example consider attribute f l pair minimal distance see section
fl vi vj fl vi vk greater shortest path v vj larger
shortest path vi vk attribute indicate v k appear
closer vi
similarly fl pair mutual dependency fl vi vj fl vi vk indicates
number variables whose next state function depends v vj greater
depending vi vk may indicate preferable keep v
vj close together
ordering
outcome learning phase set decision trees one model
case context free pairs subsection describe ways use
trees ordering
building context precedence table
case pair precedence table size n n number
variables produce one table context variable table
perform inconsistency elimination similar described section however
ask classifier two questions v j vk vk vj add context variable
vi query
pair precedence ordering context precedence filtering
ordering uses pair precedence table way ppo however often found case ppo several
minimal variables even employing maximal fanout filter use contextbased precedence table reduce size set minimal elements use
variables already ordered sequence context variables look associated tables set minimal elements contains pair variables constrained
vj vk one tables eliminate vk set figure lists code
added ppo accepts variable set v add previously
selected randomly returns one variable call ppo cpf
figure lists selection vadd ppocpf


filearning order bdd variables verification

input set candidate variables added v add merged context precedence
table
output variable added
let v vi vj hvi vj vi vi vj vj vi vj v

b vadd
vi vadd af ter vi vinorder vadd

b vadd


select randomly one variable v add
else select randomly one variable v add

figure pair precedence ordering context precedence filtering
context
merged
table

pair
merged
table

minimal
elements
unordered
variables


minimal

filter
maximal

maximal
minimal
elements

filter
context
constrained

unconstrained
minimal
elements

selected
element
select
one

variable
order

figure pair precedence ordering context precedence filtering v add selection

experiments
evaluated performance ppo cpf performing line learning
training followed ordering test shown figure
comparison performance ppo two expert

p p cp f outperforms two tested
context precedence relations add valuable information
tested effect resources invested learning phase performance since learning examples tagged evaluated training
orders since evaluation training orders resource consuming operation used number orders resource estimator figure shows
learning curves shows system performance changes
according offline resources consumed number training orders evaluated
without testing random order system knowledge build
precedence classifiers thus performance equivalent random ordering


figrumberg livne markovitch





x

append
interleave
ppo
cpf
ppo





bdd nodes











model



figure comparative histogram ordering




x








bdd nodes























number examples









figure learning curves ppo cpf two testing

tagging orders noisy improves performance
degrades performance forty orders sufficient generate stable tagging
yields improved classifiers therefore improved ordering quality

discussion
work described presents general framework machine learning
methods solve static variable ordering method assumes availability


filearning order bdd variables verification

training training model learning generates set
random orders evaluates building associated bdds ordered pair
interacting variables tagged good example appears frequently
highly valued orders ordered pairs converted feature representations
given associated tags induction ordering
variables unseen model resulting classifiers one model used
determine ordering variable pairs present extension method
learns context ordering
empirically tested real performance significantly
better random ordering meaning able acquire useful ordering
knowledge slightly better existing static ordering handcrafted experts significant compare applications learning
systems domains would surely appreciate induction produces
classifier performance comparable expert system built medical
expert chess learning program able learn evaluation function
equivalent power function produced expert similarly appreciated
therefore claim ability learning achieve
good manually designed indicates strong learning capabilities
learning expect get better performance testing
similar training verification domain expect get
good testing training come family similar
several occasions similar enough considered family
different versions design development reduced
versions design respect different property designs
similar functionality alus arbiters pipelines bus controllers unfortunately
due difficulty obtaining suitable real experiments ended
experimenting training testing related expect achieve
much better related
compared previous work machine learning precedence relations resemble utgoff saxena ordering construct
total order elements finding precedence relation essence
cohen schapire singer specifically second ordering cohen schapire singer uses topological ordering create
order initially finds precedence graph connected components
ordering topological ordering finds order connected
component however since quality final order determined sum constraints adhered topological orders theoretically quality found
bdd variable ordering topological orders quality
thus developed topological ordering takes consideration features
recognized true variable orders bdds
work differs previous introduces notion contextbased precedence concept able create ordering
produces best
several directions extending work described one
current empirical evaluation small number spite extensive


figrumberg livne markovitch

search efforts able large set suitable examples majority
known examples simple compared real industry producing small
model bdd representations little variance currently process
approaching companies use model checking way hope obtain additional
real preferably families designs described
attributes variable pairs partially substantive
field static could information base contextbased variable attributes thus attributes variable
pairs nevertheless believe human experts field may information
lead development better attributes development attributes
help capture better way context precedence concept
given current immediate question whether concept precedence
pairs context non context extended triplets quadruples etc precedence relations take account larger part model thus may possess valuable
information extension however could carry high cost learning even
worse ordering
framework solving static variable ordering shown valuable
model checking model checking one field verification bdds used
bdds used verification simulation equivalence checking
applied well unaware special static variable ordering
fields exist variable attributes
added
interesting future direction generalization framework
ordering ordering set objects common sub task solving
common tackling evaluate object
utility function order objects according utilities
taken example heuristic search many however
much easier determine relative order two objects give object global
utility value works applied learning ordering techniques utility
cohen et al described section section
applied ordering method evaluating training orders available
set meaningful pair features defined
believe presented contributes field
machine learning field formal verification machine learning presents
methodology learning order elements methodology applied
kinds ordering formal verification presents learning
techniques variable ordering finding good variable ordering techniques one
key field

appendix variable pair attributes
following definitions symbols used attribute description
n vi next state function variable v
vi vj indicate variable vi depends variable vj value vj ns vi


filearning order bdd variables verification

vi vj indicate variable vi interacts variable vj vi vj vj vi
variables number variables model
variable attributes
attributes computed vi
variable dependence number variables upon v depends vj vi vj
variable dependency number variables depend v vj vj vi
variable dependency size sum function sizes depend v

p

vj vi

vk n vj

variable dependency average size
average function size dependent v

p
vj vi

vk n vj

vj vj vi

variable dependence dependency ratio proportion number vari
ables vi depends number variables depend

vj vi vj
vj vj vi

variable interaction number variables interacting v vj vi vj
variable dependence percentage
percentage model variables v de
pends

vj vi vj
variables

variable dependency percentage
percentage model variables depend v

vj vj vi
variables

variable interaction percentage
percentage model variables interacting v

vj vi vj
variables

variable pair attributes
attributes computed hvi vj
symmetric attributes
pair minimal distance minimal distance v vj model graph
pair minimal distance eval minimal distance v vj model
graph divided number times appears
pair minimal dependency number variables depend pair
minimal distance
pair minimal dependency eval minimal distance v vj model
graph divided number variables depend minimal distance


figrumberg livne markovitch

pair minimal connection class minimal distance v vj connection class operators applied two variables divided
classes operator connected two variables minimal distance
class extracted
pair minimal maximal maximal sized ns v k connecting pair minimal distance
pair minimal maximal eval minimal distance v vj model
graph divided maximal sized ns v k connecting pair minimal distance
pair sum distance sum distances v vj model graph
pair dependency ns size sum ns v k sizes dependent vi
p
vj vk vi vk vj vl n vk

pair sum distance dependency ratio sum distances v vj
model graph divided sum ns vk sizes dependent vi vj
pair mutual dependence number variables v vj depend
vk vi vk vj vk
pair mutual dependency number variables depend v vj
vk vk vi vk vj
pair mutual interaction number variables interact v vj
vk vi vk vi vk

pair mutual ns dependency v depends vj vj depends vi vi vj vj vi
non symmetric attributes computed pair hv vj relevance vi
pair ns distance distance v vj ns vi
pair dependence ratio ratio number variables
v depends
number variables v j depends

vl vi vl
vm vj vm

pair dependency ratio ratio number variables
depend
vi number variable depend v j

vl vl vi
vm vm vj

pair interaction ratio ratio number variables interact
vl vi vl
vm vj vm

vi number variables interact v j

pair dependence flag number variables v depends
compared
number variables vj depends

vl vi vl
vm vj vm



pair interaction flag number variables interact v compared


number variables vj interacts



vl vi vl
vm vj vm



filearning order bdd variables verification

references
akers binary decision diagrams ieee transactions computers c

aziz tasiran brayton r bdd variable ordering interacting finite
state machines proceedings st design automation conference dac pp
san diego california
beer ben david eisner c landver rulebase industry oriented
formal verification tool proceedings rd design automation conference
dac pp las vegas nevada ieee computer society press
bern j meinel c slobodova efficient obdd boolean manipulation cad beyond current limits proceedings nd design automation
conference dac pp san francisco california
bollig b lobbing wegener simulated annealing improve variable orderings obdds proceedings international workshop logic synthesis
pp b granlibakken california
bollig b wegener improving variable ordering obdds np complete
ieee transactions computers
breiman l frieman j h olshen r stone c j classification
regression trees wadsworth publishing company belmont california u
brglez f bryan kozminski k combinational profiles sequential benchmark circuits proceedings international symposium circuits systems
pp portland oregon
broos p branting k compositional instance learning proceedings
th national conference artificial intelligence pp menlo park
california aaai press
bryant r graph boolean function manipulation ieee transactions computers c
butler k ross e rohit kapur r heuristics compute
variable orderings efficient manipulation ordered binary decision diagrams
proceedings th design automation conference dac pp san francisco california
chamberlain r parallel logic simulation vlsi systems proceedings
nd design automation conference dac pp san francisco california
chung p hajj patel j efficient variable ordering heuristics shared
robdd proceedings international symposium circuits systems
pp chicago illinois
clarke e emerson f sistla p automatic verification finite
state concurrent systems temporal logic specifications acm transactions
programming languages systems


figrumberg livne markovitch

cohen w w schapire r e singer learning order things journal
artificial intelligence
cover hart p e nearest neighbor pattern classification ieee transactions information theory
drechsler r becker b gockel n genetic variable ordering
obdds ieee proceedings computers digital techniques
drechsler r drechsler n slobodova fast exact minimization bdds
proceedings th design automation conference dac pp san
francisco california
duda r hart p e pattern classification scene analysis john wiley
sons york
even g naor j schieber b sudan approximating minimum feedback
sets multi cuts directed graphs algorithmica
friedman j recursive partitioning decision rule nonparametric classification
ieee transactions computers c
friedman j supowit k j finding optimal variable ordering binary
decision diagrams proceedings th design automation conference dac
pp miami beach florida
fujii h ootomo g hori c interleaving variable ordering methods
ordered binary decision diagrams proceedings ieee acm international
conference computer aided design pp santa clara california
fujita fujisawa h kawato n evaluation improvements boolean
comparison method binary decision diagrams proceedings international conference computer aided design pp santa clara california
fujita fujisawa h matsunaga variable ordering ordered
binary decision diagrams evaluation ieee transactions computer aided
design integrated circuits systems
fujita kukimoto brayton r bdd minimization truth table permutations proceedings international workshop logic synthesis pp
lake tahoe california
hunt e marin j stone p experiments induction academic press
york
ishiura n sawada h yajima minimization binary decision diagrams
exchanges variables proceedings international conference
computer aided design pp santa clara california
iyer abramovici fire fault independent combinational redundancy
identification ieee transactions vlsi systems
jain j adams w fujita sampling schemes computing variable orderings proceedings international conference computer aided design pp
san jose california


filearning order bdd variables verification

karp r reducibility among combinatorial miller r thatcher
j eds complexity computer computations pp york plenum
press
kaufmann pixley c intertwined development formal verification
x bus model proceedings international conference computer design
vlsi computers processors iccd pp austin texas
konuk h larrabee r explorations sequential atpg boolean satisfiability proceedings th ieee vlsi test symposium pp
lindenbaum markovitch rusakov selective sampling nearest
neighbor classifiers proceedings sixteenth national confernce artificial
intelligence pp orlando florida
long iyer abramovici identifying sequentially untestable faults
illegal states proceedings th ieee vlsi test symposium pp
los alamitos california
malik wang brayton r sangiovanni vincentelli logic verification
binary decision diagrams logic synthesis environment proceedings
international conference computer aided design pp santa clara california
mcmillan k symbolic model checking state explosion kluwer academic publisher
meinel c slobodova speeding variable ordering obdds proceedings international conference computer aided design pp austin
texas
meinel c slobodova sample method minimization obdds proceedings conference current trends theory practice informatics
vol lecture notes computer science pp springer verlag
york
meinel c somenzi f theobald linear sifting decison diagrams
proceedings th design automation conference dac pp anaheim
california
mercer r kapur r ross e functional approaches generating
orderings efficient symbolic representations proceedings th design
automation conference dac
minato ishiura n yajima shared binary decision diagrams attributed edges efficient boolean function manipulation proceedings th
design automation conference dac pp orlando florida
nakamura k takagi k kimura watanabe k waiting false path analysis
sequential logic circuits performance optimization proceedings international conference computer aided design pp san jose california
panda somenzi f variables neighbourhood proceedings international conference computer aided design pp san
jose california


figrumberg livne markovitch

panda somenzi f plessier b f symmetry detection dynamic variable
ordering decision diagrams proceedings international conference
computer aided design pp san jose california
parker b learning logic tech rep tr center computational
economics management science mit cambridge
queille j sifakis j specification verification concurrent systems
cesar dezani ciancaglini montanari u eds proceedings th
international symposium programming vol lecture notes computer
science pp springer verlag york
quinlan j r discovering rules induction large collections examples
expert systems micro electronic age pp edinburgh university
press
quinlan j r induction decision trees machine learning
rudell r dynamic variable ordering ordered binary decision diagrams
proceedings international conference computer aided design pp
santa clara california
rumelhart e mcclelland j l parallel distibuted processing exploration
microstructure cognition vol mit press
touati h savoj h lin b brayton r sangiovanni vincetelli implicit
state enumeration finite state machines bdds proceedings international conference computer aided design pp santa clara california
utgoff p clouse j two kinds training information evaluation function
learning proceedings ninth national conference artificial intelligence
pp anaheim california
utgoff p e saxena learning preference predicate proceedings
fourth international workshop machine learning pp irvine california
wahba borrione design error diagnosis sequential circuits lecture
notes computer science
widrow b hoff e adaptive switching circuits ire wescon
convention record pp york
zhuang n benten cheung p improved variable ordering bdds
novel genetic proceedings international symposium circuits
systems vol pp atlanta georgia




