journal artificial intelligence

submitted published

searching best solutions graphical
natalia flerova

nflerova uci edu

university california irvine
irvine ca usa

radu marinescu

radu marinescu ie ibm com

ibm ireland

rina dechter

dechter uci edu

university california irvine
irvine ca usa

abstract
focuses finding best solutions combinatorial optimization
best first depth first branch bound search specifically present extending well known best task first time prove desirable
properties including soundness completeness optimal efficiency maintained since bestfirst require extensive memory extend memory efficient depth first branch
bound best task
adapt optimization tasks graphical e g weighted csp
mpe bayesian networks provide complexity analysis empirical evaluation experiments confirm theory best first largely superior memory available
depth first branch bound robust competitive
related schemes recently developed best task

introduction
usual aim combinatorial optimization optimal solution minimum maximum
objective function however many applications desirable obtain single
optimal solution set first best solutions integer motivated
many real life domains task arises instance finding likely
haplotype pedigree presented finding probable assignment bayesian
network encodes genetic information fishelson dovgolevsky geiger practice data often corrupted missing makes single optimal solution unreliable
possible increase confidence answer finding set best solutions
choosing final solution expert help obtaining additional genetic data
examples best tasks arise procurement auction probabilistic expert systems certain constraints often cannot directly incorporated model
make infeasibly complex vague formalize e g idiosyncratic
preferences human user thus domains may practical first several
good solutions relaxed pick one satisfies additional constraints
post processing manner additionally sometimes set diverse assignments approximately
cost required reliable communication network design finally context
summation graphical probability evidence partition function
approximation derived summing likely tuples
c

ai access foundation rights reserved

fif lerova arinescu echter

finding best solutions well studied one earliest
influential works belongs lawler provided general scheme extends
optimization best task idea compute next best solution successively
finding single optimal solution slightly different reformulation original
excludes solutions generated far extended improved
years still one primary strategies finding best solutions approaches
direct trying avoid repeated computation inherent lawlers scheme two earlier
works relevant provide highest challenge work nilsson
aljazzar leue
nilsson proposed junction tree message passing scheme iteratively finds
best solutions claimed best runtime complexity among best schemes
graphical analysis section shows indeed nilssons scheme second
best worst case time complexity bf section however
practice scheme feasible large induced width
recent work aljazzar leue proposed called k search style
scheme finding k shortest paths interleaved breadth first search used
specialized data structure unclear straightforwardly extended
graphical point leave future work
one popular approximate approaches solving optimization
lp relaxation wainwright jordan best extension
fromer globerson guarantee exact solutions quite efficient practice
discuss previous works section
main focus lies optimization context graphical bayesian networks markov networks constraint networks however developed
used general purpose tasks finding shortest paths graph
graph exploiting solving optimization tasks graphical developed
past decades often characterized inference type
e g message passing schemes variable elimination search type e g search
recursive conditioning earlier works e g flerova dechter rollon extended
inference schemes represented bucket elimination dechter
task finding best solutions however due large memory requirements variable
elimination including bucket elimination cannot used practice finding exact
solutions combinatorial optimization tasks graph dense depth first branch
bound dfbnb best first search bfs flexible trade space time
work explores question solving best solutions task heuristic search schemes
contribution lies extending heuristic best solutions task describe general purpose best variants depth first branch bound best first search
specifically yielding bb respectively analyze properties inherits desirable properties dechter pearl
significantly optimally efficient compared alternative exact search scheme
discuss size search space explored bb extend best graphical exploring search space
evaluate resulting benchmarks instances total
examine impact number solutions behaviour particular


fis earching b est olutions g raphical odels

observe runtime schemes except depth first branch bound
exploring tree scales much better worst case theoretical analysis
suggests
search exact bucket elimination heuristic scheme
call bf highly efficient easier suffers severely memory issues
denser graphs far schemes approximate mini bucket heuristics finally compare schemes efficient
lp relaxation fromer globerson batra showing competitiveness even superiority large values providing optimality guarantees
organized follows section provide relevant background section
presents extension best first search best task particular define
extension finding best solutions prove main properties
section describes bb extension depth first branch bound
solving best task section discuss adaptation two newly proposed best
search search spaces graphical including hybrid method
bf incorporates variable elimination heuristic search section elaborates
related work contrasts methods section presents empirical evaluation
best schemes section concludes

background
begin formally defining graphical framework providing background
heuristic search
graphical
denote variables upper case letters e g x z values variables lower case
letters e g x z sets variables denoted upper case letters bold e g x z
assignment x x xn xn abbreviated x x xn
denote functions letters f g h etc set functions bypf function f
scope x xr denoted fs p
summation
p operator xx defines sum
possible values variables x namely x x xn xn minimization minxx
maximization maxxx operators defined similar manner note use terms elimination
p
marginalization interchangeably
convenience sometimes use minx maxx x
p
denote minxx maxxx xx
graphical model collection local functions subsets variables conveys probabilistic deterministic preferential information whose structure described graph
graph captures independencies irrelevance information inherent model useful
interpreting modeled data significantly exploited reasoning
set local functions combined variety ways generate global function whose
scope set variables
n
efinition graphical model graphical model tuple hx f
x x xn finite set variables

dn set respective finite domains values


fif lerova arinescu echter

f f fr set non negative real valued discrete functions defined scopes
variables si x called local functions
n
n
q p

combination operator e g
product sum
graphical model represents
global function whose scope x combination
n
local functions rj fj
n
p
n
qand dsi n weighted constraint satisfaction wcsps

pi xi pai bayesian network probabilities p
defined relative directed acyclic graph g x set xi xik parents
pai xi e xij edge pointing xij xi illustration consider
bayesian network variables whose directed acyclic graph dag given figure
common optimization task bayesian network probable explanation
mpe known maximum posteriori hypothesis map goal compute
optimal value
r


c max
fj xsj
x

j

optimizing configuration


x argmax
x

r


fj xsj

j

related task typical wcsp
min sum namely computing minimal cost
p
p assignment min sum c minx j fj x optimizing configuration x argminx j fj x
historically task sometimes referred energy q
minimization equivalent

mpe map task following sense cmax
maxx j fj x solution mpe





p cmax exp cmin cmin solution min sum cmin
minx j gj x j gj x log fj x
graphical model defines primal graph captures dependencies
variables variables vertices edge connects two vertices whose variables appear
scope function important property graphical model characterizing
complexity reasoning tasks induced width ordered graph pair g
g undirected graph x xn ordering nodes width node
number nodes neighbors precede ordering width graph along
ordering maximum width nodes induced ordered graph obtained
ordered graph follows nodes processed last first node xj
processed preceding neighbors connected width ordered induced graph along
ordering called induced width along denoted w induced width
graph denoted w minimal induced width orderings abusing notation
sometimes use w denote induced width along particular ordering meaning
clear context
figure b depicts primal graph bayesian network figure figures c
induced graphs primal graph figure respectively along orderings
communities map refers task optimizing partial assignment variables however
use map mpe interchangeable referring optimal full variable assignment



fis earching b est olutions g raphical odels

p





b

e

c





c

e

b





c



p b

b

c

b

c

p c

e

e

p e b c





p b



b

figure dag bayesian network b primal graph called moral graph
c induced graph along e c b induced graph along
b c e example gogate

e c b b c e dashed lines figure c represent
induced edges namely edges absent moral graph introduced
induced graph see induced width along ordering w induced
width along ordering w respectively
heuristic search
analysis focuses best first search bfs whose behaviour task finding single
optimal solution well understood assuming minimization task best first search expands
node best e smallest value heuristic evaluation function maintains graph
explored paths list closed expanded nodes frontier open nodes bfs chooses
open node n smallest value heuristic evaluation function f n expands
generating successors succ n places closed places succ n open
popular variant best first search uses heuristic evaluation function f n g n h n
g n cost path root n h n heuristic function estimates
optimal cost go h n n goal node heuristic function called admissible
never overestimates minimization true minimal cost reach goal h n namely
n h n h n heuristic called consistent monotonic every node n every
successor n n following inequality holds h n c n n h n h n consistent
values evaluation function f n along path non decreasing known
regardless tie breaking rule expands node n reachable strictly c bounded path
root node referred surely expanded dechter pearl
path c bounded relative f n f n c c cost optimal
solution
search number attractive properties nillson pearl dechter pearl



fif lerova arinescu echter

soundness completeness terminates optimal solution
h consistent explores set nodes n f n c surely
expands nodes n f n c
optimal efficiency consistent heuristic h consistent node surely expanded must expanded sound complete search
heuristic information
optimal efficiency node expansions heuristic function consistent
searching graph expands node time nodes expansion
found shortest path
dominance given two heuristic functions h h n h n h n expand
every node surely expanded ai uses heuristic hi
although best first search known best terms number nodes expanded dechter pearl requires exponential memory worst case
popular alternative depth first branch bound dfbnb whose attractive feature compared best first search executed linear memory yet
search space graph exploit memory improve performance flexibly trading space
time depth first branch bound expands nodes depth first manner maintaining cost
best solution found far upper bound u b cost optimal solution
heuristic evaluation function current node n greater equal upper bound
node pruned subtree never explored worst case depth first branch
bound explores entire search space best case first solution found optimal
case performance good bfs however solution depth unbound depth first
search might follow infinite branch never terminate search space graph
dfbnb may expand nodes numerous time unless uses caching checks duplicates
search graphical
search provide way systematically enumerate possible assignments given
graphical model optimization graphical naturally presented
task finding optimal cost path appropriate search space
simplest variant search space called search tree level corresponds
variable original nodes correspond partial variable assignments
arc weights derived input functions size search tree bounded
k n n number variables k maximum domain size
throughout section going illustrate concepts example
six variables b c e f six pairwise functions primal graph shown figure
figure b displays search tree corresponding lexicographical ordering
earch paces
search trees blind decomposition encoded graphical therefore inefficient exploit independencies model search spaces


fis earching b est olutions g raphical odels

primal
graph

b search tree along ordering b c e f

figure example variables b c e f pairwise functions
graphical introduced better capture structure dechter mateescu search space defined relative pseudo tree primal graph
captures decomposition figure shows pseudo tree example
efinition pseudo tree undirected graph g v e directed rooted tree
v e every arc g included e back arc namely connects node
ancestor arcs e may included e
given graphical model hx primal graph g pseudo tree g
search tree st contains alternating levels nodes structure
underlying pseudo tree root node st node labelled variable
root children node xi nodes labelled value assignments hxi xi
simply hxi children node hxi xi nodes labelled children
xi representing conditionally independent subproblems tree corresponding
pseudo tree figure shown figure b arcs nodes xi hxi xi
search tree annotated weights derived cost functions f
efinition arc weight weight w xi xi arc xi hxi xi combination e
sum wcsp product mpe functions whose scope includes xi fully
assigned along path root node corresponding hxi xi evaluated values
along path
identical subproblems identified context namely partial instantiation
ancestors separates subproblem rest graph merged
yielding search graph dechter mateescu merging context mergeable
nodes yields context minimal search graph denoted ct example seen
figure c size context minimal search graph shown exponential
induced width g along pseudo tree dechter mateescu
solution tree ct subtree contains root node ct
internal node n children internal node n
exactly one children every tip node e nodes children
terminal node cost solution tree product mpe sum wcsp weights
associated arcs
node n ct associated value v n capturing optimal solution cost
conditioned subproblem rooted n assuming mpe map shown v n


fif lerova arinescu echter












b

b













c



b
c

e



f







c

e








f

f





e

c









f

f





pseudo tree









f

f



e








f

f





b search tree












b

b







c

c




c

e









c

c










e




e




e

e




















f

f

f

f



















c context minimal search graph

figure search spaces graphical

computed recursively values ns successors nodes maximization
nodes multiplication wcsps v n nodes updated minimization
summation respectively dechter mateescu
next provide overview depth first branch bound best first search
explore search spaces marinescu dechter b otten dechter
schemes use heuristics generated mini bucket elimination scheme
soft arc consistency schemes marinescu dechter b schiex darwiche dechter choi gogate otten composite ihler flerova dechter otten
customary heuristic search literature defining search
assume without loss generality minimization task e min sum optimization


fis earching b est olutions g raphical odels

aobf exploring search tree marinescu dechter b



































input graphical model hx pseudo tree rooted x heuristic function h
output optimal solution
create root node labelled x let g explored search space
initialize v h best partial solution tree g
solved
select non terminal tip node n node break
n node labeled xi
forall xi xi
create child n hxi xi
n terminal
mark n solved
succ n succ n n
else n node labeled hxi xi
forall successor xj xi
create child n xj
succ n succ n n
initialize v n h n nodes
add nodes explores search space g g succ n
let n

let p node descendants g still
p
p node
v p minksucc p w p k v k
mark best successor k ancestors p k arg minksucc p w p k v k
maintaining previously marked successor still best
mark p solved best marked successor solved
else p
p node
v p ksucc p v k
mark arcs successors
mark p solved children solved
p changes value p marked solved
add parents p p one successors marked arc
recompute following marked arcs root
return hv

b est f irst earch
state art version best first search search spaces graphical
best first search aobf marinescu dechter b aobf
variant ao nillson explores context minimal search graph
aobf described simplicity present traversing
search tree aobf maintains explicated part search space g keeps
track current best partial solution tree interleaves iteratively top node expansion
step lines selects non terminal tip node generates children g
bottom cost revision step lines updates values internal nodes
childrens values newly generated child node terminal marked solved line


fif lerova arinescu echter

bottom phase nodes least one solved child nodes
children solved marked solved marks arc best
child node minimum achieved line following backward
step best partial solution tree recomputed line aobf terminates root
node marked solved heuristic used admissible point termination
optimal solution cost v root node search space
extending explore context minimal search graph straightforward done follows expanding non terminal node lines aobf
generate corresponding children already present explicated search
space g rather links identical nodes g easily recognized
contexts marinescu dechter b
heorem complexity marinescu dechter b aobf traversing context
minimal graph time space complexity n k w n number
variable w induced width pseudo tree k bounds domain size
epth f irst b ranch b ound
depth first branch bound aobb marinescu dechter
traverses search space depth first rather best first manner keeping
track current upper bound minimal solution cost
simplicity present variant explores
search tree aobb described interleaves forward node expansion lines
backward cost revision propagation step lines updates node values capturing
current best solution subproblem rooted node search terminates
optimal solution found node n pruned lines current upper bound
higher nodes heuristic lower bound computed recursively procedure described


worst case aobb explores entire search space namely n k w nodes assuming
context minimal search graph practice however aobb likely expand
nodes aobf heuristic empirical performance aobb depends heavily
order solutions encountered namely quickly finds
close optimal solution use upper bound pruning
ini b ucket h euristics
search presented aobf aobb often use mini bucket
known mbe heuristic h n mini bucket elimination mbe dechter rish
approximate version exact variable elimination called bucket elimination
dechter mbe bounds space time complexity full bucket elimination exponential induced width w given variable ordering
associates variable xi bucket contains functions defined variable
higher index variables large buckets partitioned smaller subsets called minibuckets containing distinct variables parameter called bound
processes buckets last first lines mini buckets
variable processed separately assuming min sum mbe calculates sum


fis earching b est olutions g raphical odels

aobb exploring search tree marinescu dechter b
















input graphical model hx pseudo tree rooted x heuristic function h
output optimal solution
create root node labelled x let stack created expanded nodes op en
initialize v best partial solution tree rooted u b
op en
select top node n open
n node labeled xi
foreach xi xi
add child n labeled hxi xi list successors n
initialize v n best partial solution tree rooted n n
n node labelled hxi xi
foreach ancestor k n
recursively evaluate cost partial solution tree rooted k heuristic function
h assign cost f k see
evaluated partial solution better current upper bound k e g f k v k
prune subtree current tip node n
else



foreach successor xj xi
add child n labeled xj list successors n
initialize v n best partial solution tree rooted n n



















add successors n top open
list successors node n empty
node n root node
return solution v n n
else
p node
v p v p v n p p n
else p node
value better old one e g v p c p n v n minimization
v p w p n v n p p hxi xi
remove n list successors p
move one level n p

functions mini bucket eliminates variable min operator line
function placed appropriate lower bucket line mbe generates bound lower
minimization upper maximization optimal value higher values take computational resources yield accurate bounds large enough e w mbe
coincides full bucket elimination
heorem complexity dechter rish given graphical model variable ordering
induced width w bound parameter time mini bucket


mbe nk min w space complexity nk min w n number
variables k maximum domains size
mini bucket elimination viewed message passing leaves root along minibucket tree mini bucket tree graphical model mini buckets nodes bucketx


fif lerova arinescu echter

recursive computation heuristic evaluation function






function evalpartialsolutiontree n h n
input partial solution subtree n rooted node n heuristic function h n
output heuristic evaluation function f n
succ n
n node
return
else



return h n










else
n node
let k kl children n
p
return li evalpartialsolutiontree ki h ki
else n node
let k child n
return w n k evalpartialsolutiontree k h k

mini bucket elimination

















input model hx ordering parameter
output approximate solution ordered augmented buckets
initialize partition functions f bucket bucketn bucketi contains functions
whose highest variable xi
backward pass
p n downto
let h hj functions original intermediate bucketp let sj scopes
xp instantiated xp xp
assign xp xp hi put resulting function appropriate bucket
else
generate partitioning
foreach qk q
p
generate message function hkb hkb minxp xp ji hi
add hkb bucket xb largest index variable scope hkb
forward pass
assign value variable ordering combination functions bucket
minimal
return function computed bucket first variable corresponding assignment

child buckety function hxy generated bucketx variable x eliminated
placed buckety therefore every vertex root one parent possibly
several child vertices note mini bucket tree corresponds pseudo tree minibuckets variables combined form call augmented buckets corresponding
variable nodes dechter mateescu
mini bucket elimination often used generate heuristics search graphical
formulated search spaces kask dechter b extended
search marinescu dechter


fis earching b est olutions g raphical odels

efinition mbe heuristic search space marinescu dechter given
ordered set augmented buckets b x b xn generated mini bucket
along bucket tree given node n search tree static minibucket heuristic function h n computed follows
n node labeled hxp xp
x
h n
hkj
hkj b xp b xp xpq

namely sum intermediate functions hkj satisfy following two properties
generated buckets b xk xk descendant xp bucket tree
reside bucket b xp bucket b xp xpq b xp b xpq correspond ancestors xp xpq xp
n node labeled xp
h n

min

msucc p

w n h

children n labeled values xp xp
established necessary background turn main part
presenting contributions beginning extension best first search best task
customary heuristic search literature without loss generality assume
remaining min sum optimization

best first search finding best solutions
extending best first search section particular popular version mbest task fairly straightforward suggested example charniak shimony
instead stopping finding optimal solution continues exploring search
space reporting next discovered solutions obtained
solutions indeed best found decreasing order optimality
particular second solution reported second best solution general ith solution
discovered ith best
definition
best tree search variant denoted assumes consistent heuristic
solves best optimization general search graph later
extended general admissible heuristics
scheme expands nodes order increasing value f usual manner
keeps lists created nodes open expanded nodes closed usual maintaining
search tree denoted r beginning start node picks node smallest
evaluation function f n open puts closed line node goal
solution reported lines otherwise node expanded children created lines
may encounter node multiple times maintain


fif lerova arinescu echter

exploring graph assuming consistent heuristic















input implicit directed search graph g n e start node set goal nodes goals
consistent heuristic evaluation function h n parameter
output best solutions
initialize open closed tree r counts current solution searched
open f h
make root r

open empty
return solutions found far
remove node denoted n open minimum f break ties arbitrarily favour goal nodes
deeper nodes put closed
n goal node
output current solution obtained tracing back pointers n pointers assigned step
denote solution soli

return
else



















else
expand node n generating children ch
foreach n ch
n already appears open closed times
discard node n
else
compute current path cost g n g n c n n
compute evaluation function f n g n h n
attach pointer n back n r
insert n right place open f n
return set best solutions found

copies open closed lists combined line separate paths copy
explored search tree lines nodes encountered beyond times discarded line
denote ci ith best solution cost n cost ith best solution going node
n n heuristic evaluation function estimating n gi n hi n estimates
ith best costs n n goal respectively
heuristic consistent whenever reaches node seen
search space graph tree exists possibility path improving
previously discovered ones therefore lines revised following way
account possibility better path n discovered

n appears already times union open closed

g n strictly smaller gm n current best path n

keep n pointer n put n back open

discard earlier subtree rooted n
figure shows example finding shortest paths toy
left hand side figure shows graph variables edges together


fis earching b est olutions g raphical odels




h



h b



order
nodes expanded



h c

b



c

b f

h

c
c
















c

c f





f

f


h f

h e

e

f


f
e
f f


g

h g

g
f


g

f
f

f e


g

f

f


g
f

nodes closed

graph

b trace

figure example left graph heuristic values h n node
right trace finding best solutions evaluation function f n
node white nodes closed grey one created discarded

admissible heuristic functions node note heuristic consistent example
h h c c c start node g goal node right side figure
present trace evaluation function copy nodes created
time rd solution found white nodes closed grey one node g
created never put open expands nodes open increasing order
evaluation functions assume ties broken favour deeper nodes first
discovers solution c f g cost c next solution c e g
cost c found third solutions b f g cost c note
two copies node e f four copies g created goal node g
discarded bound total number copies particular node
n
heorem given graphical model hx f n variables whose domain size
bounded k worst case time space complexity exploring search tree
k n
proof worst case would explore entire search tree whose size k n section since underlying search space tree never encounter
nodes thus nodes duplicated


fif lerova arinescu echter

properties
section extend desirable properties listed section best case
simplicity without loss generality assume throughout search graph accommodates
least distinct solutions
heorem given optimization task implicit directed search graph g integer
parameter guided admissible heuristic following properties
soundness completeness terminates best solutions generated order
costs
optimal efficiency consistent heuristic node surely expanded
must expanded search traversing g guaranteed
best solutions heuristic information
optimal efficiency node expansions expands node times
heuristic consistent ith path found node ith best path
dominance given two heuristic functions h h every n h n h n
expand every node surely expanded heuristic hi
prove properties sections
oundness c ompleteness
maintains copies node discards rest next
restriction compromise completeness
p roposition node discarded lead best solutions
proof consider consistent heuristic first described moment
discovered node n th time copies n reside open closed
maintains distinct paths let th path
prove theorem node n discovered th time cost cnew newly
discovered path th best namely better costs already discovered
cnew cm therefore eliminated th path node n guaranteed worse
remaining ones thus part potential best optimal solutions
might passing node n
heuristic consistent modified replace worst previously
discovered paths newly found cost latter better place
copy open thus safe bound number copies
clear along particular solution path evaluation function nodes
bounded paths cost c heuristic admissible
p roposition following true regarding
solution path forall n f n c
precisely defined section



fis earching b est olutions g raphical odels

unless already discovered node n resides
open
therefore long discover must node open f n
c
proof f n g n h n since h n c n due admissibility c n
actual cost n goal node along conclude f n g n h n c
reachable path root leaf open unless nodes along path
expanded closed
follows easily
follows immediately proposition stated similarly nilsson
p roposition necessary condition node expansion node n expanded
searching ith best solution satisfies f n ci
clear
p roposition sufficient condition node expansion every node n open
f n ci must expanded ith best solution found
soundness completeness follows quite immediately
heorem soundness completeness generates best solutions
order namely ith solution generated ith best solution
proof let us assume contradiction case let ith generated solution path
first one generated according best first order namely ith solution
generated cost c c ci however selected goal ti along
evaluation function f ti gi ti c proposition
node n open whose evaluation function ci thus n selected
expansion instead ti contradiction therefore follows
mpact h euristic trength
performance improves accurate heuristic
p roposition consider two heuristic functions h h let us denote uses heuristic h one heuristic h heuristic h
informed h namely every node n h n h n expand
every node expanded finding j th solution
j assuming tie breaking rule
proof since h informed h h n h n every non goal node n let us
assume expands non terminal node n finding j th best solution
cost cj node n expanded means point open b evaluation
function satisfies f n g n h n cj proposition consider current path
start node n node n path selected point expansion thus


fif lerova arinescu echter

search space

search space
c cm

ci


cm
c

search space
explored
compared

figure schematic representation search spaces explored de
pending cost cm

evaluation functions nodes bounded cost j th best solution
f n cj since h n h n every node n along path evaluation functions
according heuristic h n obey
f n g n h n g n h n cj



thus node n must expanded
consider case exact heuristic easy
heorem h h exact heuristic generates solutions j optimal
paths j
proof since h exact f values open expanded sequence values c c
generated nodes evaluation function f c definition
ci cm

optimal paths since h h f c must paths second
best notice solutions costs
h h complexity clearly linear number nodes evaluation
however cost function small range values may
function f cm
avoid exponential frontier
exponential number solution paths cost cm
chose tie breaking rule expanding deeper nodes first yielding number node expansions
bounded n n bounds solution length clearly

heorem access
favour deeper
p h h tie breaking rule
th
nodes expands n ni nodes ni length optimal solution
path clearly n n



fis earching b est olutions g raphical odels

figure graph g represents instance constructed appending branch leading goal node node n

c onsistent h euristic
uses consistent heuristic several useful properties
optimal efficiency consistent heuristic known optimally efficient
consistent heuristic dechter pearl namely extends search
paths root uses heuristic information expand every node
surely expanded e expand every n f n c extend notion
nodes surely expanded best case
bounded
p roposition expand node n reachable strictly cm
path root regardless tie breaking rule set nodes referred surely
expanded
bounded path n n n start node
proof let us consider strictly cm

clearly expanded beginning search children including node n placed
node n must expanded finding mth best
open since f n cm

solution proposition children including n turn placed open true
nodes including n

heorem optimal efficiency search guaranteed best
solutions explores search space consistent heuristic
expand node surely expanded namely expand every node
e f n c n
lies path dominated cm

proof idea similar work dechter pearl namely
expand node n surely expanded miss one best
solutions applied slightly modified
proof let us consider search graph g consistent heuristic h assume
node n surely expanded finding j th best solution let b
uses heuristic h guaranteed best solutions let assume
node n expanded b consistency heuristic allows us better characterize
nodes expanded
create graph g see figure adding goal node
h connecting n edge cost c h n cj


fif lerova arinescu echter

maxn sj f n sj set nodes surely expanded finding
j th solution possible heuristic h admissible graph g dechter
pearl since cj c construction evaluation function
goal node

f g h g n c g n h n f n cj cj



means reachable path whose cost strictly bounded cj
guarantees expand proposition discovering solution cost cj
hand b expand node n original still expand
thus reach node discover solution cost cj returning true
set best solutions modified contradiction theorem follows
p roposition heuristic function employed consistent values evaluation function f sequence expanded nodes non decreasing
proof straightforward extension nilsson
proof let node n expanded immediately n n already open time
n expanded node selection rule follows f n f n n
open must added expansion n e child n
case cost getting n start node g n g n c n n
evaluation function node n f n g n h n g n c n n h n since h n
consistent h n c n n h n f n g n h n namely f n f n
heuristic function consistent stronger condition proposition
heorem consistent heuristic function

expands nodes n f n cm

never expands nodes evaluation function f n cm

expands nodes f n cm subject tie breaking rule
node n never expanded
proof assume exists node n f n cm
situation arise node n never open list otherwise would
expanded according proposition implies parent node n search
space let us denote node p never expanded however similarly done
thus
proof proposition easy f p f n consequently f p cm
node p must never open otherwise would expanded clearly true
ancestors n start node since node clearly open beginning
search initial assumption incorrect property follows
follow directly proposition

figure provides schematic summary search space explored consistent heuristic


fis earching b est olutions g raphical odels


n f n cm


search space
explored





n f n cm



n f n cm


figure nodes explored consistent heuristic
optimal efficiency node expansions whenever node n selected expansion
first time already found shortest path node extend
property follows
heorem given consistent heuristic h selects node n expansion
ith time g n gi n namely found ith best path start node n
proof induction basic step theorem holds nillson assume
holds th expansion node n let us consider ith case inductive step
already expanded node n times due inductive hypothesis already
found distinct best paths node n let us assume cost newly found
solution path greater ith optimal one e gi n gi n exists different
undiscovered path n cost g n gi n gi n proposition exists
open node n obviously node n must located start node node
n denoting c n n c n n c nk n heuristic consistency easily
follows h n c n n h n evaluation function node n along path
f n g n h n g n c n n h n seeing cost path
n g n g n c conclude f n f n however contradicts
assumption node n expanded ith time node n theorem follows
mpact r equired b est olutions
sequence sizes search spaces explored function obviously monotonically increasing denoting j versions
search respectively j best solutions make following straightforward characterization
p roposition given search graph consistent heuristic
node expanded expanded j j use tie breaking
rule


fif lerova arinescu echter

set j nodes defined j n ci f n cj surely expanded
j surely expanded
cj ci difference number nodes expanded j determined
tie breaking rule
proof follows trivially theorem larger discrepancy respective costs cj ci yields larger difference search spaces explored j
difference however depends granularity values sequence
observed evaluation functions increase related arc costs weights search
graph ci cj c search space explored j differ
frontier nodes satisfying f n c figure represents schematically search spaces explored


depth first branch bound finding best solutions
along valuable properties inherits disadvantages exponential space
complexity makes infeasible many applications alternative
searching depth first branch bound dfbnb implemented linear
space necessary therefore often practical dfbnb finds optimal solution
exploring search space depth first manner maintains cost u best
solution encountered far prunes search nodes whose lower bounding evaluation function
f n g n h n larger u extending dfbnb best task straightforward
describe next
bb
bb depth first branch bound extension best task explores
search tree presented usual maintains lists open
closed nodes maintains sorted list candidate nodes contains best
solutions found far nodes open organized last first manner order
facilitate depth first exploration search space e open stack step bb
expands next node n open line goal node complete solution found
line stored candidate list line sorted line
best solutions maintained lines
main modification depth first branch bound extended best task
pruning condition let u u um denote costs best solutions
encountered thus far um upper bound used pruning solutions discovered pruning takes place bb expands current node n generates children
lines computes evaluation function line prunes subproblem n
iff f n um lines easy see terminates outputs
best solutions
heorem bb sound complete best solutions task
proof bb explores search space systematically solutions
c
skipped ones satisfying f n um see step since um cm



fis earching b est olutions g raphical odels

bb exploring graph assuming consistent heuristic




























input implicit directed search graph g n e start node n set goal nodes goals
heuristic function h n parameter number desired solutions
output best solutions
initialize open closed tree r sorted list candidate upperbound
counts current solution searched
put start node n open g n f n h n
assign n root r
open empty
remove top node open denoted n put closed
n goal node
soli solution obtained tracing back pointers n n pointers assigned step
ci cost soli
place solution soli candidate
sort candidate increasing order solution costs
size candidate list
um cost mth element candidate
keep first elements candidate discard rest
else
expand node n generating children succ n
forall n succ n
attach pointer n back n r
g n g n c n n
f n g n h n
f n um
place n open
else
discard n
return solutions candidate list

therefore path cannot lead newly discovered
best solution cost implies f n cm
best cost

n
heorem given graphical model hx f worst case time complexity
bb explores search tree k n log n number variables
k domain size number required solutions space complexity n
proof worst case bb would explore entire search tree size k n maintaining
candidate list introduces additional time overhead log since search tree
yields caching bb uses space linear number variables
characterization search space explored bb
already shown superior exact search finding mbest solutions heuristic consistent theorem particular bb must expand

nodes surely expanded namely set nodes n f n cm
theorem pruning condition clear


fif lerova arinescu echter

p roposition given consistent heuristic bb must expand node set n f n
instances bb expands nodes satisfying f n c
cm

several sources overhead bb discussed next
bb vs bb
pruning bb occur upper bound current mth best solution assigned
valid value e solutions found absence determinism solutions
consistent time takes arbitrary solutions depth first manner n
n length solution graphical n coincides number variables
contains determinism may difficult even single solution means
bb search may exhaustive quite time
mpact olution rder
difference number nodes expanded bb bb depends greatly variance
solution costs solutions cost u um however
situation unlikely therefore conditions bbs node expansions impacted
u j non increasing sequence
order solutions discovered let um

th
upper bounds best solution point bb uncovered j th solution
j
initially um
j
p roposition discovery j th j th solutions set nodes
j
u j u j
expanded bb included sj n f n um
cm


proof discovering j th j th solutions bb expands nodes satisfying
j
j
n f n um
hence j cj um
j th solution found replaces
j
th
previous bound solution um cj k th upper bound k yielding
j
j
u j u j
way cm
um
um


rdering overhead
need keep list sorted solutions candidate list implies log overhead
solution discovered total number solutions encountered termination
hard characterize
c aching overhead
overhead related caching arises bb explores search graph uses caching
version explicitly presented stores best partial solutions
fully explored subproblems subset partial set discovered uses
whenever subproblem encountered order implement caching mbb requires store list length node cached moreover cached partial
solutions need sorted yields log time overhead per cached node


fis earching b est olutions g raphical odels

adapting bb graphical
main task best solutions optimization tasks graphical therefore
adapt best search bb explore search space
graphical yielding aobf aobb respectively describe
hybrid bf combining bucket elimination
aobf best first search best solutions graphical
extension aobf section best task seems fairly straightforward
principle aobf aobf continues searching discovering first solution
required number best solutions obtained actual implementation requires several
modifications discuss next
easy extend aobfs bottom node values updates corresponding arc marking
mechanism best task therefore order keep track current best partial solution
tree searching ith best solution adopt naive maintains explicitly
list open containing entire partial solution trees nodes sorted ascending order
heuristic evaluation costs presents pseudo code simple scheme explores
search tree generates solutions one one order costs step
removes next partial solution tree open line complete
solution added list solutions along cost lines otherwise
expands tip node n generating successors line newly generated node
n added separately yielding partial solution tree lines whose cost
recursively evaluated aobb line partial trees
placed open line search stops solutions found
note maintenance open list containing explicit partial solution subtrees
source significant additional overhead become apparent empirical evaluation
section thus question whether performance aobf improved open
therefore rich topic future work
properties section extended aobf particular maobf admissible heuristic sound complete terminating best solutions
generated order costs aobf optimal terms number nodes expanded
compared explores search space
consistent heuristic function
heorem aobf complexity complexity aobf traversing
h
search tree context minimal search graph time space k deg
h depth underlying pseudo tree k maximum domain size deg bounds
degree nodes pseudo tree pseudo tree balanced internal node
exactly deg child nodes time space complexity k n n number
variables
real complexity bound aobf comes cost function appears however
maintaining open list brute force manner lend easily effective way
enumerating partial solution subtrees therefore search space partial solution
subtrees actually exponential n detailed proof theorem given appendix


fif lerova arinescu echter

aobf exploring search tree



































input graphical model hx pseudo tree rooted x heuristic function h parameter
output best solutions
create root node labelled x let g explored search space partial solution tree
initialize op en counts current solution searched
op en
select top partial solution tree remove open
complete solution
hf

continue
select non terminal tip node n
expand node n
n node labeled xi
forall xi xi
create child n labeled hxi xi
succ n succ n n
else n node labeled hxi xi
forall successor xj xi
create child n labeled xj
succ n succ n n
g g succ n
generate partial solution trees
l
forall n succ n initialize v n h n
n node
forall n succ n
create partial solution tree n
l l
else n node
create partial solution tree succ n
forall l
recursively evaluate assign f cost partial solution tree heuristic
function h see
place open keeping sorted ascending order costs f
return best solutions found

aobb branch bound best solutions graphical
aobb extends branch bound search aobb section
best task main difference aobb aobb value function computed
node aobb tracks costs best partial solutions solved subproblem thus extends node value v n solution tree n rooted n aobb ordered
sets length denoted v n n respectively v n v n vm n
ordered set costs best solutions subproblem rooted n n
n set corresponding solution trees extension arises due
n tm
depth first manner search space exploration aobb conjunction decomposition therefore due decomposition aobb needs completely solve


fis earching b est olutions g raphical odels

aobb exploring search tree

















input graphical model hx pseudo tree rooted x heuristic function h parameter
output best solutions
initialize
create root node labeled x let stack created expanded nodes op en
initialize v set bounds best solutions set best partial solution trees rooted
u b sorted list didat e
op en
select top node n open
expand
n node labeled xi
foreach xi xi
add child n labeled hxi xi list succ n containing successors n
initialize v n set best partial solution trees rooted n n
n node labeled hxi xi
let p ancestor n
recursively evaluate assign f p cost partial solution tree rooted p heuristic h
see
vm p f p vm p
prune subtree current tip node n
else
foreach successor xj xi
add child n labeled xj list succ n containing successors n
initialize v n set best partial solution trees rooted n n



























remove n open add succ n top open
propagate
list successors node n empty
n root node
return set solutions rooted n costs n v n
else
update ancestors n nodes p bottom
p node
combine set partial solution trees subproblem rooted p p set partial
solution trees rooted n n costs v p v n see
assign resulting set costs set best partial solution trees respectively v p
p
else p node
foreach solution cost vi n set v n
update cost weight arc creating set costs v n
vi n c p n vi n
merge sets partial solutions v n v p sets partial solution trees rooted p n
p n keeping best elements
assign merging respectively v p p
remove n list successors p
move one level n p
return v

subproblems rooted children n node n even single solution
subproblem n acquired unlike bb case consequently bottom phase
sets costs propagated updated aobf hand maintains
set partial solution trees


fif lerova arinescu echter

combining sets costs partial solution trees














function combine v n v p n n
input input sorted sets costs v n v p corresponding partial solution trees n p number
required solutions
output set costs best combined solutions v p corresponding partial solution trees p
initialize
sorted list open initially empty contains potential cost combinations
v p p
k number partial solutions already assembled total
search possible combinations
open v n v p
k op en empty
remove top node v open v svi n vj p
vk p v

p ti n tj p
vi n vj p op en
put vi n vj p op en



vi n vj p op en
put vi n vj p op en



k k



return v p p



unlike aobf discovers solutions one one order costs aobb pseudocode reports entire set solutions termination aobb interleaves forward node expansion lines backward propagation cost revision step
lines updates node values search terminates node n pruned lines
current upper bound mth solution n vm n lower nodes evaluation
functions f n computed recursively aobb bottom
propagation phase node partial solutions subproblems rooted nodes
children combined line parent node p v p p
updated incorporate possibly better partial solutions rooted child node n lines

c haracterizing n ode p rocessing overhead
addition increase explored search space bb experiences compared bb
due reduced pruning section search introduces additional overhead maobb propagation set costs partial solution trees leads increase
memory factor per node processing partial solutions nodes
introduces additional overhead
heorem aobb exploring search tree time overhead
deg log per node k per node deg bounds degree
pseudo tree k largest domain size assuming k deg log total worst case time
complexity n k h deg log space complexity mn time complexity

aobb exploring search graph n k w deg log space complexity

mn k w


fis earching b est olutions g raphical odels

merging sets costs partial solution trees





















function merge v n v p n p
input input sorted cost sets v n v p sets corresponding partial solution trees n p
number required solutions
output v p merged set best solution costs p set corresponding partial solution trees
initialize
v p
p
j indices cost sets
k index resulting array
merge two sorted sets
k
vi p vj n
vk p vi p

tk p ti p

k k
else
vk p vj n

tk p tj n
j j
k k
return v p p

proof combining sets current best partial solutions introduces overheard
log resulting time overhead per node deg log merging two
sorted sets costs done steps node k children
resulting overhead k assuming k deg log complexity dominated
processing nodes worst case tree version aobb called aobb tree
would explore complete search space size n k h h bounds depth pseudo

tree graph version called aobb graph would visit space size n k w
w induced width pseudo tree space complexity aobb tree follows
need propagate sets partial solutions length n time overhead
aobb trees graphs space complexity aobbgraph explained need store partial solutions cached node

bf
known exact heuristics graphical generated bucket elimination
described section therefore first compile exact heuristics along
ordering apply aobf work point
exact heuristics resulting called bf worst case analysis
yields best worst case complexity compared known
best graphical


fif lerova arinescu echter

heorem time complexity bf nk w nm n number
variables k largest domain size w induced width desired
number solutions space complexity nk w nm
proof bes time complexity nk w space complexity nk w dechter
since compiles exact heuristic function exact heuristic expands nodes
f n cj searching ith solution breaks ties favour
deeper nodes expand nodes solution paths path length n yielding total
time space complexity step equal n

related work
distinguish several primary approaches employed earlier best exact
mentioned already introduction note original works include space
complexity analysis bounds provided often
first influential introduced lawler aimed use theshelf optimization schemes best solutions lawler showed extend given optimization
best task step seeks best solution formulation
original excludes solutions already discovered scheme improved years still one primary strategies finding best solutions
time space complexity lawlers scheme nmt n n respectively
n n time space complexity finding single best solution example
use aobf underlying optimization use lawlers method yields time


complexity n mk w log n space complexity nk w log n
hamacher queyranne built upon lawlers work used building blocks first second best solutions two best solutions generated
formulated second best solution best solution
second best solution becomes overall third best solution
procedure repeated time complexity n space complexity
n n n respectively time space finding second best
solution complexity method bounded lawler seeing
lawlers scheme used finding second best task aobf

two best solutions obtain time complexity mnk w log n space complexity

nk w log n
nilsson applied lawlers method join tree top reuses computations previous iterations scheme called max flow uses
message passing junction tree calculate initial max marginal functions cluster
e g probability values probable assignments task yielding best solution note
step equivalent running bucket elimination subsequent solutions recovered conditioning search consult generated function time complexity analysis
nilsson p c mp r pm log pm p number cliques joint
tree c size largest clique r size largest residual e number
variables cluster neighbouring clusters space complexity bounded
p c p size separator clusters applied buckettree nilssons scheme time space complexity nk w mn k log mn


nk w nk w respectively since bucket tree p n cliques whose size bounded


fis earching b est olutions g raphical odels



c k w residual cluster r k domain single variable
thus better time complexity schemes mentioned far except
bf
two works de campos et al build upon nilssons extending solving mbest map task genetic de campos gamez moral probability trees
de campos gamez moral respectively schemes approximate authors
provide theoretical analysis complexity
fairly recently yanover weiss developed iterative scheme belief propagation called bmmf iteration bmmf uses loopy belief propagation solve two
obtained restricting values certain variables applied junction tree

induced width w whose largest cluster size bounded k w exact
time complexity mnk w space complexity nk w mnk applied
loopy graph bmmf guaranteed exact solutions
another lawlers idea uses optimization via lp relaxation wainwright
jordan formulated fromer globerson method called spanning tree
inequalities partitioning enumerating solutions stripes partitions search
space systematically excluding previously determined assignments step
constraints added lp optimization solved via shelf lp solver
general approximate however trees junction trees exact
underlying lp solver reports solutions within time limit pesteelars extension
scheme batra solves lp relaxation message passing
unlike conventional lp solvers exploits structure graph complexity
lp hard characterize usual graph parameters
another extends variable elimination dynamic programming schemes directly
obtain best solutions recent flerova et al extended bucket elimination mini bucket elimination best solutions task yielding exact scheme called
elim opt approximate version called mbe opt respectively work embeds
best optimization task within semi ring framework time space complexities


elim opt bounded log mnk w mnk w respectively
two related dynamic programming ideas seroussi golmard elliot
seroussi golmard extract solutions directly propagating best partial
solutions along junction tree given junction tree p cliques largest cluster size c separator
size bounded branching degree deg time complexity p
c deg space complexity p adapted bucket tree


time complexity nk w deg space complexity mnk w elliot propagates
best partial solutions along representation called valued acyclic graph known
smooth deterministic decomposable negation normal form sd dnnf darwiche

time complexity elliots nk w log deg space complexity

mnk w
several methods focus search schemes obtaining multiple optimal solution k shortest
paths task ksp survey see eppstein majority
assume entire search graph available memory thus directly applicable
recent exception aljazzar leue whose k finds k shortest paths
search fly thus potentially useful graphical
interleaves search implicit graph g dijkstras spe

fif lerova arinescu echter

bf


nk w

aobf


nk w

log n



mn

nk w





nilsson



mn log mn k

elim opt


gosh et al

elliot



yanover weiss

aobb


hamacher queyranne

mnk w

mnk w







mnk w

log

log deg

mnk w

mnk w deg log



mnk w



log n

aljazzar leue


nk w w log nk





seroussi golmard
nk w deg

lawler

n mk w

tree
k n

bb tree

k n log

figure time complexity comparison exact best specified bucket tree
parent node graph better complexity children parameters
n number variables k largest domain size w induced width deg degree
join bucket tree highlighted

cific path graph structure denoted p g p g directed graph vertices correspond
edges graph g given consistent heuristic k applied

search graph time space nk w w log n k
recently gosh et al introduced best first search generating ordered solutions explicit trees graphs time complexity
bounded mnk w applied context minimal search graph space
complexity bounded nk w number candidate solutions generated
stored hard quantify usual graph parameters however
explores space complete solutions seem practical graphical
requires entire search space fully explicated memory attempting generate even second best solution contrast generate best
solutions traversing space partial solutions


fis earching b est olutions g raphical odels

figure provides visual comparison worst case time complexity bounds
discussed schemes form directed graph node corresponds
parent graph better complexity child assume analysis
n k
see best emerging scheme far worst case performance goes bf
however since requires compiling exact heuristics often infeasible see
elim opt appears relatively good time complexity superior example maobb search however showed previous work flerova et al quite limited
empirically note worst case analysis often fails capture practical performance good worst case performance require much memory
ignores power cost function bounding performance

experimental evaluation
experiments consist two parts evaluation best search benchmarks
recent uai pascal competitions comparison schemes previously developed randomly generated networks whose parameters structure
restricted due limitations available implementations competing schemes
defer discussion second part experiments section concentrating
evaluation best search schemes
overview methodology
used benchmarks except binary grids came real world domains
pedigrees
binary grids
wcsp
promedas
proteins
segmentation
pedigrees benchmark pedigree used uai competition arise
domain genetic linkage analysis associated task haplotyping
haplotype sequence alleles different loci inherited individual one parent
two haplotypes maternal paternal individual constitute individuals genotype
genotypes measured standard procedures list unordered pairs
alleles one pair locus maximum likelihood haplotype consists finding
joint haplotype configuration members pedigree maximizes probability
data shown given pedigree data haplotyping equivalent
computing probable explanation bayesian network represents pedigree see
fishelson geiger details
http graphmod ics uci edu group repository



fif lerova arinescu echter

benchmark
pedigrees
grids
wcsp
promedas
proteins
segmentation

inst







n







k







w







ht







table benchmark parameters inst number instances n number variables k domain
size w induced width ht pseudo tree height

binary grid networks nodes corresponding
binary variables arranged n n square functions defined pairs
variables generated uniformly randomly
wcsp wcsp benchmark includes random binary wcsps scheduling
spot benchmark radio link frequency assignment providing large variety
parameters
protein side chain prediction pdb networks correspond side chain conformation prediction tasks protein folding yanover schueler furman weiss
resulting instances relatively nodes large variable domains generally rendering
instances complex
promedas chain segmentation binary probabilistic networks
come set used probabilistic inference challenge promedas instances bayesian network model developed expert systems medical diagnosis
wemmenhove mooij wiegerinck leisink kappen neijt segmentation common
benchmark used computer vision modeling task image segmentation mpe
namely assigning label every pixel image pixels label share
certain characteristics
table describes benchmark parameters inst number instances n number variables k maximum domain size w induced width ordering used ht pseudo tree height
induced width one crucial parameters indicating difficulty
difference induced width mini bucket bound signifies strength
heuristic bound considerably smaller induced width heuristic
weak bound equal greater induced width yields exact heuristic
turn yields much faster search clearly large number variables high domain size large
pseudo tree height suggest harder
lgorithms
distinguish bf tree bb tree exploring regular
search tree modifications explore search tree denoted aobf tree
aobb tree consider variant aobf explores search graph
aobf graph implement aobb search graph
http graphmod ics uci edu repos mpe grids
http www cs huji ac il project pascal archive mpe tgz



fis earching b est olutions g raphical odels

overhead due book keeping looked prohibitive used aobf representative
graph search see proved indeed cost effective
guided pre compiled mini bucket heuristics described section used bounds
ranging however hard computing mini bucket heuristic
larger bounds proved infeasible actual range bounds varies among benchmarks
among instances within benchmark restricted static variable ordering
computed min fill heuristic kjrulff schemes used pseudo
tree implementation bb bf aobf break ties lexicographically
aobb solves independent subproblems rooted node increasing
order lower bound heuristic estimates
implemented c bit experiments run ghz
quad core processor memory limit set gb per time limit hours
report cpu time seconds number nodes expanded search uniformity
consider task throughout maximization product known
probable explanation task mpe map focus complete exact solutions thus
report found less solutions best first schemes
optimality solutions proved branch bound schemes
g oals e mpirical e valuation
address following aspects
comparing best first depth first branch bound approaches
impact decomposition search performance
scalability number required solutions
comparison earlier proposed
main trends behavior
tables present raw form runtime
seconds number expanded nodes select instances benchmark selected
best illustrate prevailing trends benchmark two values
bound corresponding cases relatively weak strong heuristics note ibound impact bf since calculates exact heuristic three
values number solutions equal ordinary optimization
order see bigger picture figures bar charts representing
benchmark median runtime number instances solved particular
strength heuristic bound axis logarithmic scale
numbers bars indicate actual values median time seconds number
solved instances respectively important note figures account harder
instances bound yield exact heuristic acknowledge median
times strictly comparable since calculated varied number instances solved
however metric robust outliers gives us intuition
relative success addition tables benchmark
number instances given best terms runtime terms
number expanded nodes several best counts towards
score


fif lerova arinescu echter

instance
n k w h

bound

aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

oom
oom
oom
timeout
timeout


oom
oom
oom







number solutions

nodes
oom
oom
oom
timeout
timeout


oom
oom
oom







aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

oom
oom
oom
oot


oom
oom
oom
oom




oom

oom
oom
oom
oot


oom
oom
oom
oom




oom

oom
oom
oom
oot


oom
oom
oom
oom




oom

aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

oom
oom
oom
timeout


oom
oom
oom


timeout


oom

oom
oom
oom
timeout
oot
oom
oom
oom
oom
timeout


oom

oom
oom
oom
timeout
oot
oom
oom
oom
oom
timeout


oom








time

wcsp







myciel g wcsp







satellite ac wcsp







wcsp







aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf













nodes


oom











time













oom












time

nodes
oom
oom
oom
timeout
timeout


oom
oom
oom



















oom











table wcsp cpu time seconds number nodes expanded timeout stands
exceeding time limit hours oom indicates gb memory bold
highlight best time number nodes parameters n number
variables k domain size w induced width h pseudo tree height

next provide elaboration interpretation
wcsp
table shows two values bound select instances chosen best illustrate
common trends seen across wcsp benchmark figure presents median time
number solved instances table shows bound
number instances schemes best runtime best number
expanded nodes many instances benchmark mini bucket elimination
large bounds infeasible thus present small medium bounds


fis earching b est olutions g raphical odels

bf
aobf tree

aobf graph
tree
































solved instances

wcsps












bb tree
aobb tree











aobf graph
tree



bf
aobf tree












































median time
wcsps



bb tree
aobb tree


















figure median time number solved instances select values wcsps
bound numbers bars actual values time sec instances total
instances benchmark discarded instances due exact heuristic

bf suggested theory whenever bf run memory
efficient scheme see example table wcsp wcsp however calculation
exact heuristic feasible easier instances figure shows solve


fif lerova arinescu echter



solved
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

wcsps inst n
k w ht bound





bt bn bt bn bt bn bt bn bt bn




































table number instances best runtime bt best number
expanded nodes bn wcsps instances exact heuristics table
accounts remaining bound

wcsp instances seen table two instances bf demonstrated best
runtime among schemes
aobb tree number small values aobb tree superior mbb tree terms runtime number expanded nodes example wcsp
aobb tree requires seconds solve expands nodes
runtime bb tree seconds expands nodes however
majority instances aobb tree slower schemes seen figure moreover
aobb tree scales poorly number solutions often
worst runtime largest explored search space among schemes e g wcsp
striking decrease performance grows consistent across benchmarks
explained need combine sets partial solutions nodes described
earlier overhead connected decomposition accounts larger time per
node ratio aobb tree compared schemes example table instance
myciel g wcsp aobb tree expands less nodes bb tree
runtime larger nevertheless aobb tree benefits since space efficient
often scheme able solutions harder instances
especially heuristic weak see myciel g wcsp satellite ac wcsp
respectively
bb tree figure see bb tree solves almost number
aobb tree considerably better median time
aobf tree aobf graph unsurprisingly best first search often run
space feasible branch bound wcsp myciel g wcsp
aobf schemes overall inferior solving figure shows
least number schemes run memory much often tree
believe due overhead maintaining open list partial solution trees opposed
open list individual nodes tree whenever aobf schemes manage
solutions example instance wcsp aobf graph explores smallest


fis earching b est olutions g raphical odels

search space among schemes except bf time aobf tree sometimes
expands nodes compared aobf graph tree
would normally expect since tree traverses search space inherently larger
one however important remember though better space efficiency
schemes often observed guaranteed many factors tie breaking
nodes value evaluation function impact performance maobf tree aobf tree aobf graph almost median time number
solved seen figure
tree three best first tree overall best figure see
solves instances schemes values median runtime
close bf table proves bound scheme fastest among
schemes largest number instances showing best runtime instances depending
explained part relatively reduced overhead maintaining search space
open list memory compared example aobf schemes
p edigrees
table displays select instances pedigree benchmark two bounds
overall difference greatly diminishes heuristic
strength increases figure shows median time number solved instances select
values number instances schemes best runtime
best number expanded nodes bound presented table
bf bf often superior especially
schemes use lower values bound e g pedigree ms large bounds thus
accurate heuristics difference much smaller moreover sometimes bf
slower schemes due time required calculate exact heuristic e g pedigree
table shows bf overall fastest see pedigree benchmark
quite successful evident many instances solved see figure
aobb tree low values aobb tree slightly superior
solving number instances see figure hand median time
largest fails solve instances table see aobb tree
slowest e g pedigree ms yet instance pedigree scheme
one solution
bb tree expected bb tree inferior best first search schemes unless latter
run memory case wcsp scheme often faster aobb tree
example pedigree values bar charts bb tree second
worst median time values solves number
aobf schemes aobf unsuccessful pedigree benchmark
often run memory even e g pedigree instances
report solution aobf tree faster aobf graph though difference usually
large
tree saw wcsps pedigree instances tree faster two
aobf schemes seen figure values moreover superior harder instances


fif lerova arinescu echter

instance
n k w h

bound

pedigree






time




pedigree







pedigree







pedigree






nodes

number solutions

time
nodes
oom
oom
oom
timeout
timeout
oom
oom
oom




timeout
oom


nodes
oom
oom
oom
timeout
timeout
oom
oom
oom




timeout
oom
time

aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

oom
oom
oom
timeout


oom
oom
oom






oom

aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

oom
oom
oom
timeout




oom
oom









oom
oom
oom
timeout
oot


oom
oom




timeout



oom
oom
oom
timeout
oot


oom
oom




timeout



aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

oom
oom








oom
oom









oom
oom




oom
oom





oom
oom




timeout


oom
oom




oom



aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf











oom
oom




oom
oom

























oom
oom




oom
oom





oom
oom


timeout


oom
oom




timeout





table pedigrees cpu time seconds number nodes expanded timeout stands
exceeding time limit hours oom indicates gb memory bold
highlight best time number nodes parameters n number
variables k domain size w induced width h pseudo tree height

infeasible aobf schemes bf e g pedigree shown figure
solves instances ms best second best depending
number solutions however median time tree considerably larger
bf bound latter solves single instance less
b inary g rids
table shows select instances grid networks domain figure shows
median runtime number solved instances table presents number
instances best bound trends


fis earching b est olutions g raphical odels

aobf graph
tree

bb tree
aobb tree



bf
aobf tree















bb tree
aobb tree





























aobf graph
tree









bf
aobf tree


































solved instances
pedigrees











































median time
pedigrees





figure median time number solved instances select values pedigrees bound numbers bars actual values time sec instances
total instances benchmark discarded instances due exact heuristic

behavior observed wcsp pedigree benchmarks noticed grid benchmark
well particular aobb tree successful small even solving
instances seen figure shows worse number
solutions largest median time bb tree smaller median time ms still


fif lerova arinescu echter



solved
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

pedigrees inst n
k w ht bound





bt bn bt bn bt bn bt bn bt bn




































table number instances best runtime bt best number
expanded nodes bn pedigrees instances exact heuristics table
accounts remaining bound

considerably slower best first schemes tree presents best compromise
small medium running time relatively large number solved instances table
shows majority grid instances fastest two aobf schemes
quite similar solving almost number instances ms little
difference median runtimes shown figure consistently inferior
schemes except bf often runs memory main difference
grid benchmark compared previously discussed domains lies behaviour mbf bound high even though expands less nodes many bf
slower schemes due large time required compute exact heuristic
example grid runtime bf seconds even
aobb tree known slow terminates seconds time instance
bf explores smallest search space values
p romedas
table shows promedas benchmark figure presents median time number solved instances benchmark table shows bound number
instances schemes best runtime best number expanded nodes
significant fraction instances solved especially low
medium bounds unlike benchmarks aobb tree solves instances
small ms quite successful solving one instance less best
scheme value bb tree moreover sometimes aobb tree scheme
report solutions especially weak heuristic e g chain fg chain fg
bf runs memory instances seen table overall variance
performance significant promedas previously discussed benchmarks example see figure tree bb tree aobb tree solve
instances bf aobf schemes
solve instances table demonstrates tree often fastest



fis earching b est olutions g raphical odels

instance
n k w h



bound

aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

oom
oom






oom
oom
oom
oom
oom
timeout


oom
oom

number solutions

time
nodes
oom
oom






oom
oom
oom
oom
oom
timeout


oom
oom

aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

oom
oom
oom
timeout


oom
oom





oom
oom
oom
timeout




oom
oom









oom
oom
oom
timeout
timeout


oom
oom




timeout



aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

oom
oom
oom
timeout


oom
oom
oom
oom






oom
oom

oom
oom
oom
timeout


oom
oom
oom
oom






oom
oom

oom
oom
oom
timeout


oom
oom
oom
oom






oom
oom

aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

oom
oom
oom
timeout




oom
oom









oom
oom
oom
timeout
timeout


oom
oom









oom
oom
oom
timeout
timeout


oom
oom




timeout






time



































nodes


time

nodes
oom
oom




timeout
oom
oom
oom
oom
oom
timeout


oom
oom

table grids cpu time seconds number nodes expanded timeout stands
exceeding time limit hours oom indicates gb memory bold
highlight best time number nodes parameters n number
variables k domain size w induced width h pseudo tree height

p rotein
table shows select protein instances respectively figure table
summary benchmark fairly difficult due large domain size
heuristic calculation feasible higher bounds particular bf
considerable calculating exact heuristic even low bounds relatively easy
instances solved note instances pdb ctk pdb dlw bound yields exact heuristic
aobf tree aobf graph fail solutions within memory limit
majority instances e g pdb b v pdb cxy much difference
runtimes exception aobb tree example pdb b v


fif lerova arinescu echter

aobf graph
tree

bb tree
aobb tree


bf
aobf tree










bb tree
aobb tree















aobf graph
tree



bf
aobf tree

























































median time
grids






























solved instances

grids



















figure median time number solved instances select values
grids bound numbers bars actual values time sec instances
total instances benchmark discarded instances due exact heuristic

aobb tree requires seconds solutions runtimes
range seconds except bf runs memory however
slow performance aobb tree easier feasible
compensated fact many instances scheme report solution solving


fis earching b est olutions g raphical odels



solved
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

grids inst n
k w ht bound





bt bn bt bn bt bn bt bn bt bn




































table number instances best runtime bt best number
expanded nodes bn grids instances exact heuristics table
accounts remaining bound

instances considerable amount figure table shows aobbtree best terms time space overwhelming majority
values except
egmentation
table shows select instances segmentation benchmark two bounds
namely figure table present summary
unlike wcsp benchmark chose display relatively low bounds calculating heuristic larger infeasible low induced width
wished avoid displaying obtained exact heuristics main peculiarity
benchmark striking success bf overall solves many instances usually
superior tree bb tree seen figure moreover runtime superior
schemes true instances table illustrated
table heuristic weak aobb tree fairly successful example finding
solutions values binary infeasible scheme except
bf however usual aobb tree overall slowest schemes
best first vs depth first branch bound best solutions
let us consider data presented tables figures order summarize
observations contrast performance best first depth first branch bound schemes
among best first search schemes tree successful often effective
armed good heuristic requires less space best first schemes
already noted bf shows good segmentation benchmark best
terms median runtime solving least number
schemes however benchmarks calculation exact heuristic often
infeasible


fif lerova arinescu echter

instance
n k w h

bound









chain fg










chain fg


time

chain fg

chain fg








nodes

aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

oom
oom






oom
oom
oom






oom

aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

oom
oom
oom




oom
oom
oom






oom

aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

number solutions

time
nodes
oom
oom






oom
oom
oom






oom


time









nodes
oom
oom



oom
oom
oom



oom

oom
oom
oom
oot

oom
oom
oom



oom

oom
oom
oom
oot


oom
oom
oom
oom




oom

oom
oom
oom
timeout

oom
oom
oom



oom

oom
oom
oom
timeout


oom
oom
oom






oom

oom
oom
oom
timeout
timeout
oom
oom
oom






oom

oom
oom
oom
timeout


oom
oom
oom




timeout
oom

oom
oom
oom
timeout


oom
oom
oom
oom


timeout
oom

oom
oom
oom
timeout


oom
oom
oom
oom


timeout
oom













table promedas cpu time seconds number nodes expanded timeout stands
exceeding time limit hours oom indicates gb memory bold
highlight best time number nodes parameters n number
variables k domain size w induced width h pseudo tree height

two aobf schemes overall inferior due prohibitively large memory solving
fewer instances believe non trivial extension aobf
single solution best task straightforward hard represent multiple
partial solution trees efficient manner order efficient aobf implementation
one needs quickly identify partial solution subtree select extend next searching k th solution finding k th best solution aobf solution uses
arc marking mechanism efficiently represent current best partial solution subtree
search easy extend case searching best solutions therefore
shown section aobf implements naive mechanism par

fis earching b est olutions g raphical odels

bf
aobf tree



aobf graph
tree

bb tree
aobb tree







aobf graph
tree

bb tree
aobb tree




























solved instances

promedas



















bf
aobf tree





























































median time
promedas





















figure median time number solved instances summary select values
promedas bound numbers bars actual values time sec
instances total instances benchmark discarded instances due exact heuristic


tial solution trees represented explicitly memory simple representation however incurs
considerable computational overhead searching best solutions indeed
revealed experiments efficient implementation aobf left future work


fif lerova arinescu echter



solved
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

promedas inst n
k w ht bound





bt bn bt bn bt bn bt bn bt bn




































table number instances best runtime bt best number
expanded nodes bn promedas instances exact heuristics
table accounts remaining bound

unsurprisingly branch bound robust terms memory
dominate tree best first schemes many benchmarks terms number
instances solved however tend considerably larger median time expand
nodes particular aobb tree scale well number solutions large
values runtime increases drastically unlike aobf whose inferior performance
attributed specifics implementation depth first aobb suffers issues inherent
solving best depth first manner describes aobb needs
merge best partial solution internal node hurts performance significantly
cannot avoided unless algorithmic fundamentally changed
see way overcome limitation
overall whenever calculation exact heuristic feasible bf
choice otherwise tree superior relatively easy maobb tree best scheme hard memory intensive instances superiority best first
whenever memory available expected one hand intuition derived
knowledge task finding single solution hand theoretical
section
scalability number required solutions
figures present plots showing runtime seconds number expanded nodes
function number solutions log scale two instances benchmark
figure displays wcsp pedigree benchmarks figure grids promedas
figure proteins segmentation lower values axis preferable row
contains two instances benchmarks specific value bound runtime plots
shown ones containing expanded nodes examples chosen best
illustrate prevailing tendencies
note theoretical analysis suggests runtime bf best among

scale since worst case complexity nk w mn theoretical
complexity best first search schemes aobf tree tree linear number


fis earching b est olutions g raphical odels

instance
n k w h

pdb b v



pdb cxy



bound


time









pdb ctj







pdb dlw









aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

nodes
oom
oom













oom





oom

number solutions

nodes
oom
oom






oom










oom
time

oom
oom





oom
oom
oom






oom






















oom
oom










oom
oom




oom
oom






time

nodes
oom
oom












oom




timeout
oom

oom
oom



oom
oom



oom



oom
oom
oom






oom

oom
oom

oom
oom

oom
oom
oom







































oom
oom




oom
oom





































oom
oom


oot

oom
oom


oot


table protein cpu time seconds number nodes expanded timeout stands
exceeding time limit hours oom indicates gb memory bold
highlight best time number nodes parameters n number
variables k domain size w induced width h pseudo tree height

solutions bb tree overhead due best task factor log
aobb tree log deg deg degree pseudo tree observed
compared schemes runtime bf indeed rises quite slowly number
solutions increases even reaches runtime tree scales well
behaviour bb tree depends lot benchmarks pedigrees protein runtime
changes little instances number solutions grows benchmarks
runtime tends significantly larger aobf tree aobfgraph often provide solutions even alternatively run memory
slightly increases clearly successful practice


fif lerova arinescu echter

bf
aobf tree



aobf graph
tree

bb tree
aobb tree























median time
protein




























solved instances
protein















bb tree
aobb tree












aobf graph
tree



bf
aobf tree





























































figure median time number solved instances select values
protein bound numbers bars actual values time sec instances
total instances benchmark discarded instances due exact heuristic

discussed runtime number expanded nodes aobb tree increase
drastically gets larger


fis earching b est olutions g raphical odels



solved
aobf tree
aobf graph
tree
bb tree
aobb tree
bf


bt bn








protein inst n
k w ht bound



bt bn bt bn bt bn























bt bn








table number instances best runtime bt best
number expanded nodes bn protein instances exact heuristics
table accounts remaining bound

comparison competing
compare methods number previously developed schemes described details
section stripes pesteelars nilssons implementations
schemes provided dhruv batra first two approaches ideas lp relaxations approximate known often exact solutions though provide
guarantees optimality nilssons exact message passing scheme operating
junction tree first set experiments tree benchmark
stilars older version pesteelars however scheme
consistently inferior two lp schemes considered two
benchmarks following collectively refer competing schemes
r andomly g enerated b enchmarks
available us code lp nilssons approaches developed run restricted inputs could applied benchmarks used bulk evaluation described concluded implementing competing codes work general
input would time consuming would provide additional insights thus chose
compare competitors benchmarks acceptable
competing schemes
specifically comparison performed following three benchmarks random trees
random binary grids random graphs submodular potentials call submodular
graphs remainder section table shows parameters benchmarks
instances generated following manner first vector logarithmically spaced integers generated serving number variables instances
binary grids benchmarks value used generate two number
variables edges variables generated uniformly randomly making
sure end graph tree grid loopy graph depending benchmark edge
define binary potential vertex unary potential exponential form f e


fif lerova arinescu echter

instance
n k w h

bound









binary



oom
oom
oom
timeout

















aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

oom
oom
oom
timeout

















oom
oom
oom
timeout

















aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

oom
oom
oom
timeout






oom









oom
oom
oom
timeout




oom
oom









aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

oom
oom
oom
timeout




oom
oom









oom
oom
oom
timeout




oom
oom










time

binary

binary

aobf tree
aobf graph
tree
bb tree
aobb tree
bf
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

number solutions

nodes
oom
oom
oom
timeout






oom



















binary







nodes

time


time

nodes
oom
oom
oom
timeout




oom
oom





















oom
oom
oom
timeout
oot

oom
oom


oot

oom
oom
oom
timeout
oot

oom
oom


oot


oom
oom
oom
timeout
oot


oom
oom









table segmentation cpu time seconds number nodes expanded timeout
stands exceeding time limit hours oom indicates gb memory
bold highlight best time number nodes parameters n number
variables k domain size w induced width h pseudo tree height

real number sampled uniform distribution third benchmark potentials modified submodular random trees best optimization lp
guaranteed tight graphs submodular potentials lp optimization
tight best extension arbitrary loopy graphs including grids
provide guarantees
c ompeting lgorithms p erformance
table shows runtimes select instances random tree benchmark mbest search schemes competing lp schemes stilars pesteelars stripes


fis earching b est olutions g raphical odels

bf
aobf tree

aobf graph
tree

bb tree
aobb tree




























bb tree
aobb tree
















aobf graph
tree







solved instances
segmentation







bf
aobf tree

























































median time
segmentation















figure median time number solved instances select values
segmentation bound numbers bars actual values time sec
instances total instances benchmark discarded due exact heuristic

observed benchmarks stilars inferior two schemes
therefore excluded remainder evaluation instead tables
random binary grids submodular graphs benchmarks added
comparison nilssons max flow table time limit set hour
memory limit gb schemes behavior quite consistent across instances


fif lerova arinescu echter

time vs wcsps bwt ac wcsp

time vs wcsps queen wcsp











time sec

time sec



















number solutions

aobf tree
aobf graph



e

tree
bb tree





aobb tree
bf



aobf tree
aobf graph

nodes vs wcsps bwt ac wcsp



e



number solutions
tree
bb tree

aobb tree
bf

nodes vs wcsps queen wcsp







nodes

nodes





















number solutions

aobf tree
aobf graph

tree
bb tree





aobb tree
bf

aobf tree
aobf graph

tree
bb tree



aobb tree
bf

time vs pedigrees pedigree

time vs pedigrees pedigree













time sec



time sec



number solutions

















number solutions

aobf tree
aobf graph

tree
bb tree





aobb tree
bf

aobf tree
aobf graph

nodes vs pedigrees pedigree
e



number solutions
tree
bb tree



aobb tree
bf

nodes vs pedigrees pedigree









nodes





nodes



e
















number solutions

aobf tree
aobf graph

tree
bb tree





aobb tree
bf



number solutions

aobf tree
aobf graph

tree
bb tree



aobb tree
bf

figure cpu time seconds number expanded nodes function number solutions wcsp pedigrees gb hours



fis earching b est olutions g raphical odels

time vs grids

time vs grids
















time sec

time sec











number solutions

aobf tree
aobf graph

tree
bb tree



aobb tree
bf

aobf tree
aobf graph

nodes vs grids











tree
bb tree

aobb tree
bf



e



nodes

nodes













number solutions

aobf tree
aobf graph

tree
bb tree



aobb tree
bf





number solutions

aobf tree
aobf graph

time vs promedas chain fg

tree
bb tree

aobb tree
bf

time vs promedas chain fg












time sec

time sec



nodes vs grids



e



number solutions



















aobf tree
aobf graph

e



number solutions
tree
bb tree



aobb tree
bf



aobf tree
aobf graph

nodes vs promedas chain fg


e



tree
bb tree

aobb tree
bf

nodes vs promedas chain fg


nodes





nodes





number solutions















number solutions

aobf tree
aobf graph

tree
bb tree





aobb tree
bf



number solutions

aobf tree
aobf graph

tree
bb tree



aobb tree
bf

figure cpu time seconds number expanded nodes function number solutions grids promedas gb hours



fif lerova arinescu echter

time vs protein pdb

time vs protein pdb b v


















time sec

time sec













number solutions

aobf tree
aobf graph

tree
bb tree



aobb tree
bf

aobf tree
aobf graph

nodes vs protein pdb

aobb tree
bf






nodes

nodes




















number solutions

aobf tree
aobf graph

tree
bb tree



aobb tree
bf





number solutions

aobf tree
aobf graph

tree
bb tree

aobb tree
bf

time vs segmentation binary

time vs segmentation binary













time sec

time sec

tree
bb tree



e























number solutions

aobf tree
aobf graph

tree
bb tree



aobb tree
bf





number solutions

aobf tree
aobf graph

tree
bb tree

aobb tree
bf

time vs segmentation binary

time vs segmentation binary













time sec

time sec



nodes vs protein pdb b v



e



number solutions

















number solutions

aobf tree
aobf graph

tree
bb tree





aobb tree
bf



number solutions

aobf tree
aobf graph

tree
bb tree



aobb tree
bf

figure cpu time seconds number expanded nodes function number solutions protein segmentation gb hours



fis earching b est olutions g raphical odels



solved
aobf tree
aobf graph
tree
bb tree
aobb tree
bf

segmentation inst n
k w ht bound





bt bn bt bn bt bn bt bn bt bn




































table number instances best runtime bt best number expanded nodes bn segmentation instances exact heuristics
table accounts remaining bound

benchmark
random trees
random binary grids
random submodular graphs

inst




n




k




w




ht




table benchmark parameters inst number instances n number variables k domain
size w induced width ht pseudo tree height

stilars nilssons schemes dominated two competing schemes
terms runtime stripes pesteelars sometimes faster schemes
e g tree nnodes ps k however three benchmark scale rather poorly
almost inferior provided latter report
occasional exception aobb tree tends slow large
pesteelars stripes superior search schemes
largest networks variables grid nnodes ps k
infeasible overall five best proved superiority
considered competing schemes majority instances often better runtime especially
guaranteeing solution optimality

conclusion
work finding best solutions graphical focused iterative
schemes lawlers idea dynamic programming e g variable elimination treeclustering showed first time combinatorial optimization defined graphical
traditional heuristic search paradigms directly applicable often superior
specifically extended best first depth first branch bound search solve
best optimization task presenting bb respectively showed properties extend particular proved superior


fif lerova arinescu echter

instance

tree nnodes ps k



tree nnodes ps k



tree nnodes ps k





bound k


time
time

















aobf tree
aobf graph
tree
bb tree
aobb tree
stilars
stripes
pesteelars


time










time










time









aobf tree
aobf graph
tree
bb tree
aobb tree
stilars
stripes
pesteelars





































oom
oom


timeout




aobf tree
aobf graph
tree
bb tree
aobb tree
stilars
stripes
pesteelars

oom
oom







oom
oom







oom
oom


timeout




oom
oom


timeout




oom
oom


timeout

timeout
timeout

table random trees bound timeout time oom memory gb hour
search scheme best task analyzed overhead caused
need multiple solutions introduced bf hybrid variable elimination
best first search scheme showed best worst case time complexity among
best graphical known us
evaluated schemes empirically observed decomposition
search space significantly boosts performance traditional heuristic search schemes
cost effective best search least current implementation
expected best first schemes dominate branch bound whenever sufficient
space available fail memory intensive compared schemes
previously developed three approximate schemes lp relaxation performing message passing junction tree showed schemes
often dominate competing schemes known efficient terms runtime especially
required number solutions large moreover scheme guarantee solution optimality

acknowledgement
work sponsored part nsf grants iis iis united
states air force contract fa c darpa ppaml program



fis earching b est olutions g raphical odels

instance

grid nnodes ps k



grid nnodes ps k



grid nnodes ps k






time
random binary grid

bound


time
time


time

aobf tree
aobf graph
tree
bb tree
aobb tree
nilsson
stripes
pesteelars

oom
oom







oom
oom







oom
oom







oom
oom







aobf tree
aobf graph
tree
bb tree
aobb tree
nilsson
stripes
pesteelars

oom
oom







oom
oom







oom
oom







oom
oom




timeout
timeout

aobf tree
aobf graph
tree
bb tree
aobb tree
nilsson
stripes
pesteelars

oom
oom
oom
timeout
timeout
oom



oom
oom
oom
timeout
timeout
oom



oom
oom
oom
timeout
timeout
oom



oom
oom
oom
timeout
timeout
oom
timeout
timeout

table random binary grids bound timeout time oom memory gb
hour



fif lerova arinescu echter

instance

gen nnodes ps k



gen nnodes ps k



gen nnodes ps k





bound


time
time


















time









aobf tree
aobf graph
tree
bb tree
aobb tree
nilsson
stripes
pesteelars


time









aobf tree
aobf graph
tree
bb tree
aobb tree
nilsson
stripes
pesteelars

oom
oom







oom
oom







oom
oom







oom
oom







aobf tree
aobf graph
tree
bb tree
aobb tree
nilsson
stripes
pesteelars

oom
oom
oom
timeout
timeout
oom



oom
oom
oom
timeout
timeout
oom



oom
oom
oom
timeout
timeout
oom



oom
oom
oom
timeout
timeout
oom



table random loopy graphs submodular potentials bound timeout time
oom memory gb hour



fis earching b est olutions g raphical odels

figure example search tree layers nodes

appendix proof theorem
let st search tree relative pseudo tree depth h n number
variables k maximum domain size deg maximum degree nodes
define partial solution subtree subtree st contains root
st non terminal node n contains exactly one child node n
n non terminal node n contains child nodes n n j n
leaf tip node doesnt successors
nodes st grouped layers h layers ith layer denoted
li h contains nodes whose variables depth together
children assume root depth illustration figure depicts
search tree layers example l ha ha
denote tior set partial solution subtrees whose leaf nodes nodes li
similarly tian set partial solution subtrees whose leaf nodes nodes li
partial solution subtree whose leaf nodes nodes belonging nd layer
highlighted figure namely ha b c
l emma given tior tian extension
number leaf nodes
proof let number leaf nodes definition nodes
extended exactly one child node follows leaf nodes
l emma given tior number leaf nodes denoted mi deg
proof induction mi deg assume p
first extend lemma
mp deg p let tp
p
number leaf nodes namely mp next extend tpor since
mp leaf nodes deg child nodes follows mp
number leaf nodes mp mp deg deg p deg deg p
proof theorem consider number partial solution subtrees n contained st


fif lerova arinescu echter

n

h
x

nior nian





nior


tior nian tian respectively

easy see extended single partial solution subtree
given ti


ti leaf nodes deg child nodes therefore

nior ni



given tior extended k partial solution subtrees tian
leaf nodes exactly one child node k
bounds domain size lemmas
nian nior k deg





equations well n rewrite equation follows
n k
k k deg
k deg k deg

deg





k deg
k

h deg h

deg h
deg

k deg

h deg h





thus worst case number partial solution subtrees need stored open
h
h
n k deg therefore time space complexity aobf follows k deg
pseudo tree balanced namely internal node exactly deg child nodes
time space complexity bound k n since n deg h

references
aljazzar h leue k heuristic search finding k shortest paths
artificial intelligence
batra efficient message passing best map uncertainty
artificial intelligence
charniak e shimony cost abduction map explanation artificial intelligence
darwiche decomposable negation normal form journal acm jacm

darwiche dechter r choi gogate v otten l
probablistic inference evaluation uai web report
http graphmod ics uci edu uai evaluation report
uncertainty artificial intelligence applications workshop


fis earching b est olutions g raphical odels

de campos l gamez j moral partial abductive inference bayesian belief
networks genetic pattern recognition letters
de campos l gamez j moral partial abductive inference bayesian networks probability trees enterprise information systems v pp springer
dechter r bucket elimination unifying framework reasoning artificial intelligence

dechter r mateescu r search spaces graphical artificial intelligence
dechter r rish mini buckets general scheme bounded inference journal
acm
dechter r reasoning probabilistic deterministic graphical exact synthesis lectures artificial intelligence machine learning
dechter r pearl j generalized best first search strategies optimality
journal acm jacm
dijkstra e w note two connexion graphs numerische mathematik

elliott p extracting k best solutions valued acyclic graph masters
thesis massachusetts institute technology
eppstein finding k shortest paths proceedings th symposium foundations computer science pp ieee comput soc press
fishelson geiger exact genetic linkage computations general pedigrees
international conference intelligent systems molecular biology ismb pp
fishelson dovgolevsky n geiger maximum likelihood haplotyping
general pedigrees human heredity
flerova n dechter r rollon e bucket mini bucket schemes best solutions
graphical graph structures knowledge representation reasoning
workshop
fromer globerson lp view best map advances neural
information processing systems
ghosh p sharma chakrabarti p dasgupta p generating ordered
solutions explicit structures journal artificial intelligence jair

gogate v g sampling probabilistic graphical determinism
dissertation ph thesis university california irvine
hamacher h queyranne k best solutions combinatorial optimization
annals operations
ihler flerova n dechter r otten l join graph cost shifting schemes
arxiv preprint arxiv
kask k dechter r branch bound mini bucket heuristics ijcai vol
pp


fif lerova arinescu echter

kask k dechter r b mini bucket heuristics improved search proceedings
fifteenth conference uncertainty artificial intelligence pp morgan
kaufmann publishers inc
kjrulff u triangulation graphsalgorithms giving small total state space tech report
r
lawler e procedure computing k best solutions discrete optimization
application shortest path management science
marinescu r dechter r branch bound search combinatorial optimization graphical artificial intelligence
marinescu r dechter r b memory intensive search combinatorial optimization graphical artificial intelligence
marinescu r dechter r branch bound graphical international joint conference artificial intelligence vol p lawrence erlbaum
associates ltd
nillson n j principles artificial intelligence tioga palo alto ca
nilsson efficient finding probable configurations probabilistic expert systems statistics computing
nilsson n principles artificial intelligence springer verlag
otten l dechter r anytime depth first search combinatorial optimization socs
pearl j heuristics intelligent search strategies addison wesley
schiex arc consistency soft constraints international conference principles
practice constraint programming cp
seroussi b golmard j directly finding k probable configurations bayesian networks international journal approximate reasoning

wainwright j jordan variational inference graphical view
marginal polytope proceedings annual allerton congerence communication
control computing vol pp citeseer
wemmenhove b mooij j wiegerinck w leisink kappen h j neijt j p
inference promedas medical expert system artificial intelligence medicine pp
springer
yanover c weiss finding probable configurations loopy belief
propagation advances neural information processing systems mit press
yanover c schueler furman weiss minimizing learning energy functions
side chain prediction journal computational biology




