Journal Artificial Intelligence Research 55 (2016) 603-652

Submitted 07/15; published 03/16

Large-Scale Election Campaigns:
Combinatorial Shift Bribery
Robert Bredereck

robert.bredereck@tu-berlin.de

TU Berlin,
Berlin, Germany

Piotr Faliszewski

faliszew@agh.edu.pl

AGH University Science Technology,
Krakow, Poland

Rolf Niedermeier
Nimrod Talmon

rolf.niedermeier@tu-berlin.de
nimrodtalmon77@gmail.com

TU Berlin,
Berlin, Germany

Abstract
study complexity combinatorial variant Shift Bribery problem
elections. standard Shift Bribery problem, given election
voter preference order set candidates outside agent,
briber, pay voter rank bribers favorite candidate given number
positions higher. goal ensure victory bribers preferred candidate.
combinatorial variant problem, introduced paper, models settings
possible affect position preferred candidate multiple votes, either positively
negatively, single bribery action. variant problem particularly
interesting context large-scale campaign management problems (which,
technical side, modeled bribery problems). show that, general, combinatorial variant problem highly intractable; specifically, NP-hard, hard
parameterized sense, hard approximate. Nevertheless, provide parameterized
algorithms approximation algorithms natural restricted cases.

1. Introduction
study computational complexity election campaign management case
campaign actions (such airing TV advertisement, launching web-based campaign, organizing meetings voters) may large-scale effects affect multiple
voters. Further, interested settings actions positive effects (for example, voters may choose rank promoted candidate higher
find arguments presented given advertisement appealing) well negative ones
(for example, voters find advertisement aggressive). Thus,
setting, two major issues faced campaign manager (a) choosing actions
c
2016
AI Access Foundation. rights reserved.

fiBredereck, Faliszewski, Niedermeier, & Talmon

positively affect many voters possible (b) balancing negative effects
campaigning actions (for example, concentrating negative effects voters
disregard promoted candidate anyway).
research falls within field computational social choice, subarea multiagent
systems. use standard election model, given set C candidates
collection V voters, represented preference order (that is, ranking
candidates preferred one least preferred one). assume
know preferences voters. perfect knowledge impossible
practice, assumption convenient simplification models fact may
(approximate) information preelection polls sources.
consider two voting rules, Plurality rule (where pick candidate
ranked first voters) Borda rule (where candidate c gets
voter v many points candidates v prefers c to, pick
candidate points). rules chosen Plurality rule
widespread rule practice Borda rule well-studied
context campaign management.
Within computational social choice, term campaign management (introduced
Elkind, Faliszewski, & Slinko, 2009; Elkind & Faliszewski, 2010) alternative name
bribery family problems (introduced Faliszewski, Hemaspaandra, & Hemaspaandra, 2009a) cases one focuses modeling actions available election
campaigns: result money spent campaign manager, voters change
votes. paper study campaign management Shift Bribery
problem (Elkind et al., 2009; Elkind & Faliszewski, 2010; Bredereck, Chen, Faliszewski,
Nichterlein, & Niedermeier, 2014a; Bredereck, Faliszewski, Niedermeier, & Talmon, 2016).
Shift Bribery candidate p want win, voter v
price v (i) voter willing shift p forward positions preference
order1 , ask lowest cost ensuring p winner (see Section 1.1
references campaign management problems).
Shift Bribery problem one major drawback model campaign management. incapable capturing large-scale effects campaign actions. particular,
one puts forward TV spot promoting given candidate, voters react
positively rank candidate higher, oblivious it, react
negatively, ranking candidate lower. Shift Bribery cannot model correlated
effects. paper introduce study Combinatorial Shift Bribery problem, allowing campaign actions effects, positive negative, whole groups
voters.
interested understanding realistic model campaign management
affects complexity problem. Indeed, Shift Bribery is, computationally,
well-behaved problem. example, Plurality rule solvable polynomial time
Borda rule NP-complete (Elkind et al., 2009), polynomial-time
2-approximation algorithm (Elkind et al., 2009; Elkind & Faliszewski, 2010)
fixed-parameter (FPT) algorithms, either exact capable finding solutions arbitrarily
close optimal ones (Bredereck et al., 2014a). work, ask extent
1. course, price necessarily reflect direct money transfer voter, rather cost
convincing voter change mind.

604

fiCombinatorial Shift Bribery

retain good computational properties allow large-scale effects.
results surprising positively negatively:
1. Combinatorial Shift Bribery becomes NP-complete W[1]-hard even
Plurality rule, even restrictive choice parameters, even correlated
effects particular campaign actions limited two voters. Moreover,
hardness results imply good, general approximation algorithms exist
allow negative effects campaign actions.
2. spite above, still possible derive relatively good (approximation)
algorithms, Plurality rule Borda rule, provided
restrict effects campaign actions positive either
involve voters each, involve groups consecutive voters (with respect
ordering voters might correspond, example, time).
results summarized Table 1 Section 4. generality problem
combinatorial nature natural obtain many hardness results. Yet,
extent strength surprising, fact find nontrivial landscape
tractable cases.
1.1 Related Work
work builds top two main research ideas. First, studying campaign management/bribery problems, and, second, studying combinatorial variants election
problems.
study computational complexity bribery elections initiated
Faliszewski et al. (2009a), continued number researchers (Faliszewski, Hemaspaandra, Hemaspaandra, & Rothe, 2009b; Hazon, Lin, & Kraus, 2013; Mattei, Goldsmith,
& Klapper, 2012a; Mattei, Pini, Rossi, & Venable, 2012b). Elkind et al. (2009) Elkind
Faliszewski (2010) realized formalism election bribery problems useful
point view planning election campaigns. particular, defined
Swap Bribery problem restricted variant, Shift Bribery. former possible, given price, swap two adjacent candidates given vote. latter,
allowed shift preferred candidate forward. Various problems, modeling
different flavors campaign management, studied, including, example,
possibility alter number approved/ranked candidates (Baumeister, Faliszewski,
Lang, & Rothe, 2012; Faliszewski, Reisch, Rothe, & Schend, 2014; Schlotter, Faliszewski,
& Elkind, 2011). Different (positive) applications bribery problems include, example,
Margin Victory problem, goal briber prevent candidate winning. possible low cost, suggests election
could tampered (Cary, 2011; Magrino, Rivest, Shen, & Wagner, 2011; Xia,
2012; Reisch, Rothe, & Schend, 2014).
point view, related works Elkind et al. (2009), Elkind
Faliszewski (2010), Bredereck et al. (2014a, 2016), Dorn Schlotter (2012).
former ones study Shift Bribery, generalize (parameterized complexity
Shift Bribery studied Bredereck et al., 2014a, Shift Bribery multiwinner
605

fiBredereck, Faliszewski, Niedermeier, & Talmon

elections studied Bredereck et al., 2016), whereas work Dorn Schlotter
(2012) pioneers use parameterized complexity analysis (swap) bribery problems.
work largely inspired Bulteau, Chen, Faliszewski, Niedermeier,
Talmon (2015) Chen, Faliszewski, Niedermeier, Talmon (2015), introduced
studied combinatorial variants election control. Election control well-studied
topic computational social choice, initiated Bartholdi, Tovey, Trick (1992)
studied numerous researchers (we point readers Faliszewski, Hemaspaandra,
& Hemaspaandra, 2010; Faliszewski & Rothe, 2015, detailed account). Briefly put,
control problems model attempts changing election results changing structure. standard types control include adding, deleting, partitioning candidates
voters. Control problems, especially related adding deleting voters, quite
relevant issues campaign management, and, indeed, Section 5 show connection Combinatorial Shift Bribery (combinatorial) control adding
voters (Bulteau et al., 2015).
idea combinatorial shift bribery somewhat related problem lobbying
multiple referenda, introduced Christian, Fellows, Rosamond, Slinko (2007)
(parameterized study provided Bredereck, Chen, Hartung, Kratsch, Niedermeier,
Suchy, & Woeginger, 2014b; probabilistic variant studied, parameterized
sense, Binkele-Raible, Erdelyi, Fernau, Goldsmith, Mattei, & Rothe, 2014). There,
number yes/no elections goal ensure election
majority voters vote yes. single lobbying action convince one voter
vote yes elections. combinatorial shift bribery single election
single action affect multiple voters, whereas lobbying problem multiple
elections action affects one voter.
stress use term combinatorial variants election problems
different one used well-established line work regarding combinatorial
candidate spaces (see Lang & Xia, 2015, works, example, Boutilier, Brafman,
Hoos, & Poole, 2004; Conitzer, Lang, & Xia, 2009; Mattei et al., 2012b). work use
term combinatorial refer combinations voters affected bribery
action.
1.2 Organization Paper
providing preliminaries Section 2, give formal definition Combinatorial Shift Bribery problem Section 3. Section 4 give overview
results. shed light connections Combinatorial Shift Bribery
problem Combinatorial Control Section 5. Then, Section 6, present
series strong hardness results covering classes shift actions restrictive sets parameters (for example, many results already apply case two
candidates). Section 7, develop several exact algorithms special cases Combinatorial Shift Bribery, Section 8 describe approximation algorithms
Combinatorial Shift Bribery. proofs available appendices
(either given proof relies ideas already presented proofs, oras
case Theorem 9when proof particularly involved). end conclusions
Section 9.
606

fiCombinatorial Shift Bribery

2. Preliminaries
section, briefly describe model elections, define two voting rules
study, review basic concepts parameterized complexity.
2.1 Elections
election E = (C, V ) consists set C = {c1 , . . . , cm } candidates collection
V = (v1 , . . . , vn ) voters. voter represented preference order, is,
linear ranking candidates preferred one least preferred one;
use voters preference orders interchangeably. example, C = {c1 , c2 , c3 },
voter v1 may preference order v1 : c1 c2 c3 indicate likes c1 best,
c2 , c3 (for clarity, treat voters females candidates males).
assume arbitrary (but fixed) canonical order set candidates (for example, one could order candidates lexicographically names).


subset C candidates, writing within preference order means listing

didates canonical order, writing means listing reverse
order.
2.2 Voting Rules
voting rule R function that, given election E = (C, V ), outputs set R(E) C
(tied) election winners. candidate c R(E) said R-winner
election E. consider two election rules, Plurality rule Borda rule.
assign points candidates output highest score. Plurality
rule, candidate receives one point voter ranks first. Borda
rule, candidate receives points voter prefers candidate exactly
ones.
use nonunique-winner model. is, candidates selected given
voting rule viewed equally successful winners (in practice, course, one use
sort tie-breaking rule resolve situation, disregarding ties simplifies
analysis; however, interested reader consult papers effects tie-breaking
complexity election problems, e.g. Obraztsova & Elkind, 2011; Obraztsova, Elkind,
& Hazon, 2011).
2.3 Parameterized Complexity
assume familiarity standard notions regarding algorithms complexity theory,
briefly review notions regarding parameterized complexity theory (Downey & Fellows,
2013; Flum & Grohe, 2006; Niedermeier, 2006).
parameterized complexity theory measure complexity given problem
respect input size particular parameter problem. Typical
parameters election problems include number candidates, number voters,
solution size (for example, number campaign actions one perform; see
Betzler, Bredereck, Chen, & Niedermeier, 2012, survey parameterized complexity
voting). say parameterized problem fixed-parameter tractable (is FPT)
algorithm given input instance parameter k solves problem
607

fiBredereck, Faliszewski, Niedermeier, & Talmon

g(k)|I|O(1) time, g computable function |I| length encoding
I. hierarchy hardness classes parameterized problems,
two important levels formed classes W[1] W[2]. convenient
way defining classes appropriate reduction notion complete
problems. Specifically, say parameterized problem reduces parameterized
problem B two computable functions, h h0 , following properties:
given instance parameter k, h(I) outputs FPT time (i.e., time g(k)|I|O(1)
computable function g) instance 0 B parameter k 0 h0 (k),
yes-instance 0 yes-instance B. words, h
many-one reduction B allowed run FPT time, required
output instance whose parameter upper-bounded function input instances
parameter.
class W[1] defined class problems parameterically reduce
Clique problem, W[2] class problems parameterically reduce Set
Cover problem, problems parameterized solution size (that is,
value h definitions).
Clique
Input: undirected graph G = (V (G), E(G)) integer h.
Question: set H h vertices edge
pair vertices H?
Set Cover
Input: universe set X, family subsets X, integer h.
Question: subset 0 h subsets whose union gives X?
sometimes consider special variants problems describe detail
within relevant proofs.
parameterized problem contained class XP algorithm that, given
instance parameter k, solves time |I|g(k) , g computable
function. holds FPT W[1] W[2] XP. point readers interested
details regarding parameterized complexity theory (and design parameterized
algorithms) textbooks Downey Fellows (2013), Flum Grohe (2006),
Niedermeier (2006).

3. Combinatorial Shift Bribery Problem
section first define Combinatorial Shift Bribery problem full
generality and, then, describe simplify remainder
study.
3.1 Definition
Let R voting rule. definition R-Combinatorial Shift Bribery somewhat involved, therefore first define necessary components. given election
E = (C, V ) preferred candidate p C. goal ensure p R-winner
election. end, number possible actions choose from.
608

fiCombinatorial Shift Bribery

Let := |C| number candidates E let n := |V | number
voters. shift action f n-dimensional vector (possibly negative) integers,
f = (f (1) , . . . , f (n) ). R-Combinatorial Shift Bribery given family F =
(f1 , . . . , f ) shift actions. particular shift action models possible campaigning
action, airing TV spot organizing meeting voters. components
given shift action measure effects action particular voters. given
subset F 0 F available shift actions, define effect F 0 voter vi (1 n)
P
(i)
E (i) (F 0 ) = fj F 0 fj . Further, shift action fj (1 j ) comes nonnegative
integer cost w(fj ) application.
voter vi (1 n) individual threshold function : Z Z describing
shift actions affect voter. require (0) = 0 nondecreasing.
Let F 0 collection shift actions. applying shift actions F 0 , voter vi
(1 n) shifts preferred candidate p > 0 positions forward (a) E (i) (F 0 ) > 0,
(b) (t) E (i) (F 0 ) < (t + 1). shift > 0 positions back (a) E (i) (F 0 ) < 0,
(b) (t) E (i) (F 0 ) > (t 1).
Finally, given nonnegative integer B, budget.PWe ask existence
collection F 0 F available shift actions total cost fj F 0 w(fj ) B
applying p R-winner given election. case,
say F 0 successful. Consider following example.
Example 1. Consider election below, set candidates C = {a, b, c, p},
collection voters V = (v1 , v2 , v3 ), p preferred candidate. three
available shift actions, unit cost (i.e., w(f1 ) = w(f2 ) = w(f3 ) = 1).
election
v1 : c b p
v2 : b c p
v3 : p b c

shift actions

2
6
0

4 0 2

0
3
0
f1

f2

f3

threshold functions that:
1. 1 (1) = 4, 1 (0) = 0, 1 (1) = 6, 1 (2) = 100.
2. 2 (0) = 0, 2 (1) = 2, 2 (2) = 2 (3) = 100.
3. 3 (3) = 3 (2) = 100, 3 (1) = 3, 3 (0) = 0.
use Borda rule. Candidates a, b, c, p have, respectively, 4, 6, 4, 4 points.
easy see applying single shift action ensure ps victory. However,
applying shift actions F 0 = {f2 , f3 } results p winner. total effect
two shift actions (6, 2, 3). According threshold functions, means p
shifted forward one position v1 v2 , shifted back one position v3 .
shifts, modified election looks follows:
609

fiBredereck, Faliszewski, Niedermeier, & Talmon

v10
v20
v30

election
:cpba
:bapc
:apbc

is, apply shift actions F 0 = {f2 , f3 }, candidate c
3 points, candidates 5 points each. Thus, a, b, p tied winners
F 0 indeed successful set shift actions.
4
Formally, given voting rule R, define R-Combinatorial Shift Bribery
problem follows:
R-Combinatorial Shift Bribery
Input: election E = (C, V ), C = {c1 , . . . , cm } set candidates
V = (v1 , . . . , vn ) collection voters, set F = {f1 , . . . , f } shift
actions costs w(f1 ), . . . , w(f ), threshold functions 1 , . . . , n , nonnegative integer budget B. One candidates designated preferred
candidate p.
Question: subset F 0 F shift actions total cost B
apply shift actions F 0 candidate p R-winner
resulting election?
definition quite complicated, captures important features campaigning. example, use threshold functions allows us model voters
unwilling change position preferred candidate beyond certain range, irrespective strength campaign. fact different shift actions different
costs models fact particular actions (for example, airing TV spots organizing
meetings) may come different costs.
3.2 Relation Standard Shift Bribery
necessary comment relation Combinatorial Shift Bribery
problem non-combinatorial variant, Shift Bribery (Elkind et al., 2009; Elkind &
Faliszewski, 2010).
non-combinatorial variant Shift Bribery problem defined similarly
combinatorial one, voters threshold functions instead
collection shift actions costs, voter vi shift-bribery price
function . cost shifting preferred candidate forward positions vi
preference order (t) (only forward shifts allowed). require (0) = 0
functions nondecreasing. Formally, following definition (R
voting rule).
R-Shift Bribery
Input: election E = (C, V ), C = {c1 , . . . , cm } set candidates V = (v1 , . . . , vn ) collection voters, collection (1 , . . . , n )
shift-bribery price functions, nonnegative integer budget B. One
610

fiCombinatorial Shift Bribery

candidates designated preferred candidate p.
Question:
vector (s1 , . . . , sn ) natural numbers (a)
Pn
i=1 (si ) B (b) voter vi shift p forward si positions,
p R-winner resulting election?
intuitively seems R-Shift Bribery simpler combinatorial
cousin, making observation formal requires care.
Proposition 1. Let R voting rule. holds R-Shift Bribery many-one reduces
R-Combinatorial Shift Bribery polynomial time.
Proof. Consider instance R-Shift Bribery election E = (C, V ),
C = {c1 , . . . , cm } V = (v1 , . . . , vn ), collection shift-bribery price functions
(v1 , . . . , vn ), budget B. Without loss generality, take c1 preferred
candidate denote p. form instance R-Combinatorial Shift
Bribery election, budget, preferred candidate,
shift actions, costs, voters threshold functions constructed

Pt
mj
,
follows: voter vi , set threshold function (t) = j=1 2
number positions possible shift preferred candidate
forward vi preference order, create shift action fi,t zero effect
voters vi , effect 2mt ; cost
P fi,t w(fi,t ) = (t) (t 1).
sequence (s1 , . . . , sn ) ni=1 (si ) B p R-winner
election voter vi shift p forward si positions,
solution constructed instance Combinatorial Shift Bribery: vi ,
use shift actions fi,1 , . . . , fi,si , total bribery cost Shift
Bribery instance and, implementing shifts, vi preferred candidate
shifted exactly si positions.
assume constructed Combinatorial Shift Bribery instance yesinstance. Consider subset F 0 shift actions whose total cost B
ensure p R-winner election (and recall shift action used
once). voter vi V , define si largest integer shift
actions fi,1 , . . . , fi,si belong F 0 . Let us fix voter vi . claim applying
shift actions F 0 (in Combinatorial Shift Bribery instance), preferred
candidate shifted forward exactly si positions. definition si , immediate
shifted forward least si positions. shifted forward
positions
following reason: shift actions fi,1 , . . . , fi,si total effect
P mj
vi equal sj=1
2
, equal (si ). definition, shift action fi,si +1
F 0 . sum remaining shift actions effect vi smaller than:

X
j=si +2

mj

2

=

ms
2
X

2j = 2msi 1 1.

j=0

However, (si + 1) (si ) = 2msi 1 . means even used shift actions
aside fi,si +1 , vi preference order still would shift p exactly si positions.
conclusion, means implementing shift actions F 0 ensures
voter vi shift p forward exactly si positions. Further, vi
611

fiBredereck, Faliszewski, Niedermeier, & Talmon

w(fi,1 ) + + w(fi,si ) = (si ). Therefore, sequence (s1 , . . . , sn ) witnesses
input instance Shift Bribery yes-instance total cost shifts
B (as combinatorial instance) ensure p winner (as
combinatorial instance).
Since reduction clearly runs polynomial time, proof complete.
construction proof somewhat involved, especially one takes
account simply shows Combinatorial Shift Bribery problem indeed
generalizes much simpler, non-combinatorial, one. Nonetheless, somewhat contrived
use threshold functions seems necessary. Indeed, Combinatorial Shift
Bribery problem restricted shift actions positive entries exactly one
voter each, used simple linear threshold functions, would obtain Shift
Bribery case convex price functions (Bredereck et al., 2014a).
general variant Shift Bribery problem which, example, NP-hardness
results Elkind et al. (2009) hold (as shown Bredereck et al., 2014a), nonetheless
general one.
3.3 General Hardness Result
turns Combinatorial Shift Bribery problem, defined Section 3.1
above, general allows following, sweeping, hardness result.2
Theorem 2. Plurality rule Borda rule, Combinatorial Shift
Bribery NP-hard even five voters two candidates budget constraints.
Borda rule, Combinatorial Shift Bribery NP-hard three voters
four candidates.
Proof. reduce following (weakly NP-hard) variant Subset Sum problem
(it simple exercise show NP-hardness reduction classic Subset
Sum problem):
Subset Sum (Zero Variant)
Input: set := {a1 , . . . , } integers.
P
Question: nonempty set A0 ai A0 ai = 0?
Given instance = {a1 , . . . , } Subset Sum (Zero Variant), construct
instance Plurality-Combinatorial Shift Bribery two candidates. Since
Plurality rule Borda rule coincide elections two candidates, hardness
result transfers Borda-Combinatorial Shift Bribery (and, fact, almost
natural voting rules).
construct following election:
2. Note, however, prove weak NP-hardness. is, result may hold assume
occurring numbers encoded unary. contrary, hardness proofs paper give
strong hardness results independent number encoding issues.

612

fiCombinatorial Shift Bribery

election
v1 : p
v2 : p
v3 : p
v4 : p
v5 : p

shift actions



a1





a1









1 ... 1




0
0




0
0


f1

...

fn

is, element ai A, set F shift actions contains one shift action
effect ai v1 , effect ai v2 , effect 1 v3 , effect two voters.
voter threshold functions follows. Candidate p shifted last position
v1 v2 effect voters negative (that is, 1 (1) = 2 (1) = 1).
Candidate p shifted top position third voter effect positive (that
is, 3 (1) = 1). set cost shift action one set budget
n. Thus budget allows us pick combination shift actions.
direction, let A0 non-empty subset whose element-wise sum equals
zero. applying F 0 := {fi | ai A0 }, p winner: Since A0 sums zero,
effect first two voters. effect third voter positive, A0
non-empty. Thus p preferred three five voters wins election.
direction, let F 0 F subset shift actions makes p winner.
Then, F 0 must non-empty p win initial election. claim
element-wise
sum A0 := {ai | F 0 } zero. sake contradiction, assume
P
ai A0 ai 6= 0. sum negative, would negative effect
first voter, would preferred three voters five, would win election.
sum positive, would effect second voter taking
role first one.
Using similar idea, show reduce Subset Sum (Zero Variant)
Borda-Combinatorial Shift Bribery three voters four candidates. Given
input before, construct following instance:
election
v1 : p d1 d2 d3
v2 : p d1 d2 d3
v3 : d1 d2 d3 p

shift actions



3a1
3an




3a1 . . . 3an




3
3


f1

...

fn

is, element ai A, F contains one shift action effect 3ai v1 ,
effect 3ai v2 , effect 3 v3 . voter vi threshold function
(t) = t. effect, p shifted last position first second voter
effect voters negative, shifted top position third vote
effect positive. shift action unit cost, set budget
n (i.e., pick combination shift actions).
613

fiBredereck, Faliszewski, Niedermeier, & Talmon

Observe d1 original winner election obtains seven points whereas
p obtains six points.
direction, let A0 non-empty subset whose element-wise sum equals
zero. apply shift actions F 0 := {fi | ai A0 } p becomes winner: Since A0 sums
zero, effect first two voters. effect third voter positive
A0 non-empty. Thus, p preferred candidate voters
wins election.
direction, let F 0 F subset shift actions makes p winner.
Then, F 0 must non-empty p win initial election. show
element-wise
sum A0 := {ai | F 0 } zero. sake contradiction assume
P
ai A0 ai 6= 0. sum negative, would negative effect
first voter p would obtain six points, whereas d1 would obtain seven. sum
positive, would effect roles first second voter
switched.
Effectively, Theorem 2 shows studying large-scale effects campaign actions
full-fledged R-Combinatorial Shift Bribery problem leads hopelessly
intractable problem: hardness even elections fixed number
candidates fixed number voters.
3.4 Restricted Variants Combinatorial Shift Bribery
Given hardness results Theorem 2, throughout remainder paper
focus restricted variants Combinatorial Shift Bribery problem. assume
individual threshold functions identity functions (that is, voter
integer t, holds (t) = t), assume shift action unit
cost, consider restricted types shift actions. assumptions require
additional discussion.
restrictions threshold functions costs shift actions seem
basic and, fact, even satisfied instances built proof Theorem 2. reason assuming that, one hand, seems beyond point
study instances involved Theorem 2, and, hand,
interact restrictions, leading tractable cases. But, important
consequences.
First, using identity threshold functions means model societies prone
propaganda. identity threshold functions cannot differentiate voters
less responsive actions. Second, assuming every shift action
unit cost models settings costs particular campaign actions similar
enough small differences irrelevant; actual number actions
choose perform sufficiently good approximation real cost. true,
example, case organizing meetings voters, often comparable
prices. likely case shift actions model actions airing TV
spots: spot similar cost produce/broadcast. greatest disadvantage
assuming unit costs longer model mixed campaigns use actions
several different types (meetings voters, TV spots, web campaigns, etc.).
614

fiCombinatorial Shift Bribery

restrictions types allowed shift actions even greater impact
nature campaigns study. study following classes shift actions:
Unrestricted Shift Actions. put restrictions allowed shift actions;
models general (and, naturally, least tractable) setting.
Bounded-Effect Shift Actions. consider parameter require
shift action f = (f (1) , . . . , f (n) ) holds j (1 j n),
|f (j) | . still general setting, assume campaigning
action limited impact voter.
Unit-Effect Shift Actions. class bounded-effect shift actions = 1.
given voter, applying given shift action either leave preferred candidate
p unaffected shift p one position down.
Interval Shift Actions. subclass unit-effect shift actions never affect
voters negatively, shift action interval voters
affected positively (the interval respect order voters
input collection V ). class shift actions models campaigns associated
time window certain voters reached, campaigns local given
neighborhoods3 (for example, include putting multiple posters, organizing
meetings, etc.). speak 1z -interval shift actions mean interval shift actions
shift action affects z voters.
Unit-Effect Two Voters Shift Actions. subclass unit-effect shift actions
affect two voters most. focus shift actions affect voters
positively, denoted (+1, +1)-shift actions, affect one voter positively
one voter negatively, denoted (+1, 1)-shift actions. reason studying
families model particularly natural types election campaigns,
rather establish limits tractability problem. example,
consider (+1, 1)-shift actions understand intractable shift actions
negative effects; (+1, 1)-shift actions simplest shift actions type
may useful campaign (one would never deliberately use shift action
affects preferred candidate negatively).

Figure 1 presents difference bounded-effect shift actions, unit-effect shift
actions, unit-effect two voters shift actions, interval shift actions graphically.
discuss next section, type allowed shift actions huge impact
computational complexity problem.
3. neighborhood scenario, take simplified view society voters lives line.
course, would natural take two-dimensional neighborhoods account. view
interesting direction future research, time consider simple settings
possible. time window scenario, natural ordering voters point time
cast votes affected campaign.

615

fiBredereck, Faliszewski, Niedermeier, & Talmon

2

2
1

1

1
2

1
1

1

1

1

1

1

= 2; = 5
1

1

1

2

Unit-Effect
1

1

1
z
1
1

(+1, 1)

1
1

(+1, +1)

1

1z

Figure 1: Restrictions shift actions. visualize (from left right, top bottom):
shift action maximum effect = 2 single shift action maximum number
= 5 voters affected single shift action; unit-effect shift action; shift action
effect +1 one voter effect 1 another voter (+1, 1); shift action
effect +1 two voters (+1, +1); shift action effect +1 interval
size z 1z . intended interpretation voters listed vertically, top
bottom.

4. Overview Results
provide high-level overview results. turns even rather strong
restrictions place (that is, restrictions defined Section 3.4), Combinatorial Shift
Bribery computationally hard settings. present quest
understanding border tractability intractability Combinatorial Shift
Bribery. end, employ following techniques ideas.
1. seek regular complexity results (NP-hardness results) parameterized
complexity results (FPT algorithms, W[1]-hardness W[2]-hardness results,
XP algorithms).
2. consider structural restrictions sets available shift actions.
3. seek approximation algorithms inapproximability results (that is, approximation hardness results).
616

fiCombinatorial Shift Bribery

parameterized complexity results, consider following parameters: (a)
number n voters, (b) number candidates, (c) budget B, (d)
maximum effect single shift action, (e) maximum number voters affected
single shift action.
discussions (in)approximability Combinatorial Shift Bribery regard
task minimizing cost ensuring preferred candidates victory. means
that, example, 2-approximation algorithm decide possible ensure
preferred candidates victory all, and, so, output successful set shift
actions total cost twice high optimal one.
summarize results Table 1. results show Combinatorial Shift
Bribery highly intractable. Theorems 5, 6, 7, show problem computationally hard (in terms NP-hardness, W[2]-hardness, inapproximability even FPT
algorithms) Plurality rule Borda rule, even various restricted
forms unit-effect shift actions, even two candidates. means that, essence,
problem hard natural voting rules, since two candidates natural voting rules
boil Plurality rule.
Further, Theorem 8 Theorem 11 show problems W[1]-hard even
take number candidates budget joint parameter, even extremely
restricted shift actions. problem remains hard (for case Borda rule)
parameterized number voters (Theorem 9). contrary, case
Plurality parameterization number voters obtain tractability.
obtain several approximability results. essence, results possible
cases shift actions negative results. intuitive reason fact
shift actions negative effects, computationally hard check
whether preferred candidate win even without restrictions budget.
approximation algorithms based results non-combinatorial
variant problem, due Elkind et al. (2009) Elkind Faliszewski (2010).
Either use non-combinatorial algorithms directly, subroutines algorithms,
derive results plugging Combinatorial Shift Bribery-specific blocks
framework developed Elkind et al. (2009) Elkind Faliszewski (2010).

5. Connection Combinatorial Control
study combinatorial variants problems modeling ways affecting election results
initiated Bulteau et al. (2015), considered combinatorial control adding voters
(Combinatorial-CCAV) Plurality rule Condorcet rule. turns
Plurality rule reduce problem (Combinatorial) CCAV
(Combinatorial) Shift Bribery. non-combinatorial variants problems
give much since problems easily seen polynomial-time solvable.
However, strong hardness results Plurality-Combinatorial-CCAV
transfer case Plurality-Combinatorial Shift Bribery. Formally, PluralityCombinatorial-CCAV defined follows (Bulteau et al., 2015).
Plurality-Combinatorial-CCAV
Input: set C candidates preferred candidate p C, collection V
617

fiBredereck, Faliszewski, Niedermeier, & Talmon

Table 1: Overview results. show exact algorithms approximation algorithms Plurality-Combinatorial Shift Bribery Borda-Combinatorial
Shift Bribery, different restrictions shift actions (see Figure 1). Results marked
follow work Elkind et al. (2009), follow work Bredereck
et al. (2014a), follow work Elkind Faliszewski (2010), follow
work Bredereck et al. (2016). Note variants XP
parameterized budget B (Observation 1).
shift actions

regular
Shift Bribery
(convex prices)

rule

exact complexity

approximability

Plurality

poly.-time solvable (O)



Borda

NP-complete(O),
FPT B (),
W[1]-hard n ()

unit effect

2-approximable
poly. time (,O),
FPT-approximation
scheme n ()

W[2]-h B even

inapproximable even

= 2 (Thm. 5),

FPT-time B even

XP n (Prop. 12)

= 2 (Thm. 6)

Plurality

FPT n (Thm. 13)



Borda

W[1]-hard n (Thm. 9)



inapproximable even
FPT-time n (Cor. 10)

(+1, 1)
NP-h even = 2 (Thm. 7),


W[1]-h B
combined (Thm. 8)

Plurality
(+1, +1)

1z -intervals



inapproximable
even = 2 (Thm. 7)

FPT n (Thm 13)



W[1]-h B

2-approximable

combined (Thm. 8)

poly. time (Thm. 15)

Plurality

FPT n (Thm. 13)

Borda





W[1]-h B (Thm. 11)

618

z-approximable
poly. time (Thm. 14)
2z-approximable
poly. time (Thm. 14)
2-approximable
mz time (Thm. 16)

fiCombinatorial Shift Bribery

registered voters (having preference orders C), collection W unregistered voters (having preference orders C), bundling function : W 2W
(for w W holds w (w)), budget k.
Question: collection W 0 W
k voters p

0
winner modified election (C, V w0 W 0 (w ))?
Intuitively, unregistered voter w W , bundle, (w) (given explicitly
input), add w election (for example, somehow convincing
vote), voters bundle join election (for example, people choose
vote influence friend).
Theorem 3. Plurality-Combinatorial-CCAV polynomial-time many-one reducible
Plurality-Combinatorial Shift Bribery. instance Plurality-CombinatorialCCAV candidates, reduction outputs instance Plurality-Combinatorial
Shift Bribery + 1 candidates.
Proof. Consider input instance Plurality-Combinatorial-CCAV candidate set
C, collection registered voters V , collection unregistered voters W , bundling function
, preferred candidate p C, limit k number voters add.
form instance Plurality-Combinatorial Shift Bribery, follows.
form candidate set C 0 = C {d}, new candidate. form
set voters V 0 following way.
1. voter v V , include v V 0 , preference orders extended rank
last.
2. voter w W ranks p first, include V 0 two voters, xw ,
preference order form p , x0w , preference order form
p .
3. voter w W ranks candidate c C \ {p} first, include
V 0 voter xw preference order p c , voter x0w preference order
p .
4. include 4|W ||C| voters V 0 preference orders achieve
following effects: (a) c C score s(c) election (C, V ), c ranked first
4|W | + s(c) voters V 0 , (b) ranked first exactly 2|W | voters V 0 .
achieve effects, c C \ {p} include 4|W | voters rank c first,
include 3|W | voters rank p first, include |W | voters rank first.
voter w W , introduce shift action fw following effects:
(w), w0 ranks p first fw effect 1 xw0 (but x0w0 ) w0 ranks
candidate C \ {p} first, fw effect 1 xw0 effect +1 x0w0 (all
entries zeros). finishes construction. provide proof correctness
following example reduction.

w0

Example 2. Consider following input Plurality-Combinatorial-CCAV,
preferred candidate p budget k 1.
619

fiBredereck, Faliszewski, Niedermeier, & Talmon

registered voters
v1 : p

unregistered voters
w1 : p

bundling function
(w1 ) = {w1 , w3 }

v2 : p

w2 : p

(w2 ) = {w2 }

v3 : p

w3 : p

(w3 ) = {w2 , w3 }

construct following input Plurality-Combinatorial Shift Bribery; notice
number entries shift action 33.
election
v1 : p
v2 : p
v3 : p
xw1 : p
x0w1 : p
xw2 : p
x0w2 : p
xw3 : p
x0w3 : p
12 dummies :
9 dummies : p
3 dummies :

shift actions

0
0
0

0 0 0

0 0 0


1 0 0


0 0 0

0 1 1


0 1 1


1 0 1

0 0 0


0 0 0


0 0 0
0
0
0
fw1

fw2

fw3

Note adding voter w1 input election Plurality-Combinatorial-CCAV
results p winner election. Correspondingly, applying shift action fw1 results
p winner input election Plurality-Combinatorial Shift Bribery. 4
see correctness construction, note applying shift action corresponding bundle voter w W effect differences scores
candidates C adding bundle (w) original control instance.
specifically, disregarding score now, following.
w0 (w) ranks p first, increase score p one,
w0 (w) ranks candidate c C \ {p} first, increase score
c one. Further, score candidate never grow beyond 4|W | PluralityCombinatorial Shift Bribery instance score p never fall 4|W |.
Therefore, never prevent p winner.
Thus, reduction correct. Furthermore, reduction computed polynomial time outputs Plurality-Combinatorial Shift Bribery instance one
candidate input Plurality-Combinatorial-CCAV instance. observe output instance uses unit-effect shift actions affect twice
many voters largest bundle input instance.
620

fiCombinatorial Shift Bribery

Based proof Theorem 3 results Bulteau et al. (2015), obtain
following result.
Corollary 4. Plurality-Combinatorial Shift Bribery W [2]-hard respect
budget B even = 3, W [1]-hard respect B even shift actions unit
effect 6 voters, NP-hard even shift actions unit effects
4 voters.
Proof. result follows applying reduction proof Theorem 3
Plurality-Combinatorial-CCAV instances produced reductions Theorems 2, 1,
4 Bulteau et al. (2015), respectively.

6. Hardness Results
results previous section show bound hit hard instances
Combinatorial Shift Bribery even restricted setting. section explore
restrictive hard settings are. results organized type shift actions
allowed.
6.1 Results General Unit-Effect Shift Actions
start considering unit-effect shift actions. allowed effects positive only,
obtain NP-hardness W[2]-hardness parameterizing budget B.
allow negative unit-effects, problem gets even harder go beyond
hope approximation algorithm, even approximation algorithm allowed
run FPT time parameterizing budget B. Quite strikingly, results hold
even two candidates.
Theorem 5. Plurality rule Borda rule, Combinatorial Shift
Bribery NP-hard W[2]-hard parameter budget B, even two candidates
even shift action effects either +1 0 voter.
Proof. provide parameterized reduction Set Cover (recall Section 2.3). Let
(S, X, h) instance Set Cover, = {S1 , . . . , Sm } family subsets
universe X = {x1 , . . . , xn }, h number sets use cover X.
construct instance Plurality-Combinatorial Shift Bribery two candidates. Note that, since Borda rule Plurality rule coincide elections two
candidates, hardness result transfers Borda-Combinatorial Shift Bribery.
construction follows. p candidates.
element xi X create element voter vi preference order p. Create another set
n dummy voters preference order p. set F shift actions contains
set Sj function fj effect +1 element voters corresponding
elements set (that is, fj [i] = 1 xi Sj fj [i] = 0 otherwise). Finally,
set B := h. finishes construction. Clearly, reduction computed
polynomial time. Consider following example applying reduction.
Example 3. Let input Set Cover X = {x1 , x2 , x3 , x4 , x5 } =
{S1 , S2 , S3 }, S1 = {1, 2, 5}, S2 = {2, 3}, S3 = {3, 4}, h = 2. construct
following input Plurality-Combinatorial Shift Bribery.
621

fiBredereck, Faliszewski, Niedermeier, & Talmon

election
v1 : p
v2 : p
v3 : p
v4 : p
v5 : p
5 dummies : p

shift actions

0
0
1

1 1 0


0 1 1


0 0 1

1 0 0

0

0

0

f1

f2

f3

Note {S1 , S3 } set cover, and, analogously, choosing f1 f3 results p
winner election.
4
remains show set cover size h successful
set shift actions size h.
part, assume set cover 0 size h. Then, applying
0
F = {fj | Sj 0 } makes p win election: Since 0 set cover, p preferred
candidate n element voters and, hence, winner election.
part, assume set shift actions F 0 F size h
whose application makes p win election. Then, p must preferred candidate
element voters bribed election shift action effect dummy
voter. Since n element voters n dummy voters, 0 := {Sj | fj F 0 } set
cover. Finally, since B = h, 0 size h.
Allowing negative (but unit) effects voters, adapt reduction
Theorem 5 show strong inapproximability result. inapproximability result follows
since corresponding reduction, yes-instances, correct solutions use
exact given budget.
Theorem 6. Unless W[2] = FPT, Combinatorial Shift Bribery inapproximable (in
FPT time parameter B) Plurality rule Borda rule, even two
candidates unit-effect shift actions.
Proof. modify reduction Theorem 5 show inapproximability result.
Let (S, X, h) Set Cover instance = {S1 , . . . , Sm } X = {x1 , . . . , xn }.
Without loss generality, assume |S| > h. construct instance PluralityCombinatorial Shift Bribery two candidates follows. (Since two
candidates only, proof applies case Borda-Combinatorial Shift Bribery
well.)
|S|
element xi X, create |S| element voters vi1 , . . . , vi , preference
order p, set Sj create set voter vj0 preference order p d.
Create |S| |X| + |S| 2h dummy voters, preference order p. set F
shift actions contains, set Sj , shift action fj effect 1
element voter corresponding element set effect 1 set voter
corresponding set. Finally, set B := h. completes construction,
clearly computable polynomial time.
622

fiCombinatorial Shift Bribery

Next, show successful set shift actions size h
set cover size h.
part, assume set cover 0 size h. Then, F 0 =
{fj | Sj 0 } successful set shift actions: since 0 set cover, p
preferred candidate |S| |X| element voters preferred candidate
least |S| h set voters (corresponding sets set cover). Moreover,
preferred candidate |S| |X| + |S| 2h dummy voters preferred
candidate h set voters (corresponding sets set cover). Hence,
either p wins p tie winners.
part, assume successful set shift actions F 0 F
size h. Then, p must preferred candidate element voters
bribed election: element voter p, would least
|S| 1 element voters p (the element voters corresponding
element). Thus would total |S|(|X| 1) element voters |S| set
voters prefer p, least |S| |X| + |S| 2h dummy voters |S| element voters
prefer d. Since assumed |S| > h, would mean p winner. Thus,
must 0 := {Sj | fj F 0 } set cover, and, due budget constraint,
follows |S 0 | h.
Finally, show Plurality-Combinatorial Shift Bribery inapproximable
even FPT time parameterized budget. Assume, sake contradiction, successful set shift actions F 0 F |F 0 | > B exists. Then, bribed
election, least |S| |X| + |S| 2h dummy voters |F 0 | h + 1 set voters prefer d,
|S| |X| element voters |S| (h + 1) set voters prefer p. Thus,
unique winner. Hence, successful bribery action must optimal respect
budget FPT-algorithm Plurality-Combinatorial Shift Bribery (parameterized budget) would solve W[2]-hard problem Set Cover (parameterized
solution size) FPT time; contradiction assumption FPT 6= W[2].
6.2 Results Shift Actions Unit Effect Two Voters
previous section limit number voters affected shift action.
focus case unit-effect shift action affect two voters. First show Combinatorial Shift Bribery remains NP-hard hard
approximate (+1, 1)-shift actions. provide parameterized hardness results
(+1, 1) (+1, +1)-shift actions. proof relatively similar one
Theorem 6 defer Appendix A.
Theorem 7. Unless P = NP, Combinatorial Shift Bribery inapproximable (in
polynomial time) Plurality rule Borda rule, even two candidates
(+1, 1)-shift actions.
opposed Theorem 6, result yield W[2]-hardness parameter budget B. proof uses reduction Set Cover
value budget size universe set X. insist parameterized
hardness unit effects two voters, accept larger sets candidates.
However, increase large: show W[1]-hardness Combinatorial
Shift Bribery jointly parameterized budget number candidates.
623

fiBredereck, Faliszewski, Niedermeier, & Talmon

Theorem 8. Plurality rule Borda rule, Combinatorial Shift
Bribery W[1]-hard combined parameter (m, B), even either
(+1, 1)-shift actions (+1, +1)-shift actions.
Proof. four cases consider. begin Plurality rule (+1, +1)-shift
actions.
Plurality Rule (+1, +1)-Shift Actions. describe parameterized reduction W[1]-hard Clique problem, parameterized solution size, PluralityCombinatorial Shift Bribery (+1, +1)-shift actions, parameterized (m, B).
Let (G, h) instance Clique V (G) = {u1 , . . . , un0 } E(G) = {e1 , . . . , em0 }.
create following instance Plurality-Combinatorial Shift Bribery. set
candidates {p} D, = {d1 , . . . , dh1 }. vertex ui V (G), cre

ate vertex voter vi preference order p. Moreover, create n0 2h dummy


voters preference order p each. edge {ui , uj } E(G), create
shift action f{ui ,uj } effect 1 vertex voters vi vj , effect 0

voters. Finally, set budget B := h2 . completes construction,
computable polynomial time. Consider following example.
Example 4. following graph, looking clique size h = 3.
u2

u3

u5

u4

u1

u7

u6

construct following input Plurality-Combinatorial Shift Bribery.
election
v1 : d1 d2 p
v2 : d1 d2 p
v3 : d1 d2 p
v4 : d1 d2 p
v5 : d1 d2 p
v6 : d1 d2 p
v7 : d1 d2 p
1 dummy : p d1 d2

shift actions

1
1
1

1 0 0


0 0 0

0 1 0


0 0 1


0 0 0

0 0 0

0
0
0


1

0


0

0


0


0

1

0


0

0


0

0


1


1

0

0


0

0


0

0


1


0

1

0

fu1 ,u2

fu1 ,u7

fu5 ,u6

fu5 ,u7

fu1 ,u4

fu1 ,u5

Note (v1 , v5 , v7 ) form clique size 3 input graph Clique, and, accordingly, applying set shift actions {fu1 ,u5 , fu1 ,u7 , fu5 ,u7 } results p winner
election Plurality-Combinatorial Shift Bribery.
4
624

fiCombinatorial Shift Bribery

Without loss generality, assume d1 ranked first (arbitrary fixed)


order D. Observe n0 vertex voters h dummy voters rank d1 first.
n0 h dummy voters rank p first. Hence, make p win election,
one needs h additional voters rank p first (and, effect, rank d1 first).
remains show constructed instance contains successful set shift actions F 0 size h (G, h) contains clique size h.
part, let H V (G) set h vertices forming clique let E 0 E(G)
set edges vertices H. Then, observe F 0 = {f{ui ,uj } |
{ui , uj } E 0 } successful set shift actions: vertex voter vi corresponding
clique vertex ui H, candidate p shifted h 1 positions forward. means that,
total, h vertex voters rank p first p ties winner election.
part, let F 0 successful set shift actions. Since dummy voters
affected shift action, follows order make p winner election,
p must shifted top position least h vertex voters. is, total, p must
shifted h (h 1) positions forward. Since F 0 size B = h2 = h (h 1)/2

shift action affects two vertex voters, F 0 must size exactly h2 affecting

exactly h vertex voters. construction, implies h2 edges G incident
exactly h different vertices possible h vertices form clique.
finishes proof Plurality rule (+1, +1)-shift actions.
remaining cases proof quite similar (although, technically, involved)
present Appendix B.
quite natural consider Combinatorial Shift Bribery different
perspective. Instead asking happens small number candidates, might
ask complexity Combinatorial Shift Bribery small number voters
(see, example, Brandt, Harrenstein, Kardel, & Seedig, 2013; Chen et al., 2015,
motivation looking elections voters interesting). case
obtain hardness Borda rule. Indeed, later show PluralityCombinatorial Shift Bribery FPT parameter number voters. proof
next theorem quite involved available Appendix C.
Theorem 9. Borda-Combinatorial Shift Bribery W[1]-hard respect number n voters, even (+1, 1)-shift actions budget constraints.
proof Theorem 9 reduce Strongly Regular Multicolored
Clique problem, and, importantly, impose budget constraints. Thus, follows approximation algorithm Borda-Combinatorial Shift Bribery (running FPT time parameterized number voters) would yield FPT algorithm Strongly Regular Multicolored Clique parameterized
solution size. effect, following corollary.
Corollary 10. Unless W[1] = FPT, Borda-Combinatorial Shift Bribery inapproximable even FPT-time parameter n, even (+1, 1)-shift actions.
results Theorem 9 Corollary 10 compare interestingly
non-combinatorial variant Borda-Shift Bribery. recently, complexity
Borda-Shift Bribery parameterized number voters unknown. Eventually
625

fiBredereck, Faliszewski, Niedermeier, & Talmon

(in different paper, submitting one journal publication) shown
problem W[1]-hard (Bredereck et al., 2016), far simpler proof
one used here. Nonetheless, Theorem 9 Corollary 10 still carry significant value.
Earlier, Bredereck et al. (2014a) shown FPT approximation scheme
Borda-Shift Bribery parameterized number voters, Corollary 10 shows
result generalize combinatorial setting.
6.3 Results Interval Shift Actions
conclude discussion hardness results considering Combinatorial Shift
Bribery interval shift actions. previous section allowed shift actions
non-zero effects two voters each, two voters could chosen arbitrarily. show hardness result case positively affect multiple
voters, voters form consecutive interval input election.
Theorem 11. Plurality rule Borda rule, Combinatorial Shift
Bribery NP-hard even interval shift actions.
Proof. consider Plurality rule first give many-one reduction following
variant strongly NP-hard Numerical Matching Target Sums problem.
Numerical Matching Target Sums
Input: Three sets integers = {a1 , . . . , }, B = {b1 , . . . , bt }, X =
{x1 , . . . , xt }, (1) numbers encoded unary, (2) 3t numbers
distinct, (3) two numbers B sum
number X.
Question: elements B paired [t]
sum ith pair exactly xi ?
standard variant problem, presented classic text Garey
Johnson (1979), restrictions integers sets A, B, X.
assume numbers encoded unary problem strongly NPhard. Further, Hulett, Will, Woeginger (2008) shown problem remains
NP-hard case 3t integers distinct. Finally, see third
restriction change complexity problem suffices consider following
transformation: Given instance (A, B, X) Numerical Matching Target
Sums, add 2 max(A B X) + 1 integer B X. produces
equivalent instance two numbers, B, sum
number X.
Plurality Rule. Let (A, B, X) instance Numerical Matching
Target Sums let denote largest integer B X. create instance
Plurality-Combinatorial Shift Bribery follows. set candidates is:
C := {p, d, ca1 , . . . , cat , cb1 , . . . , cbt , cx1 , . . . , cxt }.
create following voters.
626

fiCombinatorial Shift Bribery

1. pair integers ai x` X, introduce:
(a) One voter preference order

cai p C \ {p, cai },
(b) ai voters preference order

cx` p C \ {p, cx` },
(c) 2y (ai + 1) voters preference order

p C \ {p, d}.
voters called (ai , x` )-voters exactly 2y them.
pair (ai , x` ), construct shift action faxi` effect 1 exactly set (ai , x` )
voters.
2. pair integers bj B x` X, introduce:
(a) One voter preference order

cbj p C \ {p, cbj },
(b) bj voters preference order

cx` p C \ {p, cx` },
(c) 2y (bj + 1) voters preference order

p C \ {p, d}.
voters called (bj , x` )-voters exactly 2y them.
pair (bj , x` ), construct shift action fbxj` effect 1 exactly set (bj , x` )
voters.
3. Let q := 4ty. create sufficiently many dummy voters ensure that, altogether,
candidates following scores:
(a) p q points,
(b) i, cai cbi q + 4ty + 1 points each,
(c) ` [t], cx` q + 4ty + x` points.
shift action affects dummy voters.
627

fiBredereck, Faliszewski, Niedermeier, & Talmon

Finally, set budget B := 2t. completes reduction. easy see
computable polynomial time (because numbers encoded unary)
order voters shift action effects consecutive interval z := 2y
voters.
remains show constructed instance Plurality-Combinatorial Shift
Bribery contains successful set F 0 shift actions size 2t (A, B, X)
yes-instance Numerical Matching Target Sums.
part, let := {(ai1 , bj1 ), . . . , (ait , bjt )} solution Numerical Matching Target Sums, is, set integer pairs integer B
occurs exactly ai` + bj` = x` holds ` [t]. Observe
F 0 := {faxi` , fbxj` | (ai` , bj` ) S} successful set shift actions. Since integer
`

`

B occurs exactly (some pair of) S, candidate cai candidate cbj
loses one point. Since ai` + bj` = x` ` [t], candidate cx` loses x` points.
construction, p gains 4ty points set shift actions size 2t. Thus, p wins
election.
part, let F 0 successful set shift actions size 2t (if
successful action smaller size could extend size 2t shift actions
negative effects). applying shift actions F 0 , p gains 4ty points.
make p winner election, candidate cai candidate cbj needs lose one
point, candidate cx` needs lose x` points. Thus, ai exactly
x`
x`
one fai F 0 bj B exactly one fbj F 0 . Since integers
B X distinct two integers B sum
integer X, x` X least one shift action faxi` effect ai`
`
voters prefer cxl , one shift action fbxj` effect bj` voters prefer cx` . Since
`
candidates cx` |F 0 | = 2t, follows exactly two shift actions
effect voters preferring cx` . Since cx` lose least x` points, holds
ai` + bj` x` . fact, pigeonhole principle, holds ai` + bj` x` . Hence,
successful set 2t shift actions, solution Numerical
Matching Target Sums instance.
Borda Rule. Borda rule, almost reduction works. Specifically,
still exists integer q set requirements required
proof Plurality rule hold Borda rule (with respect different
q). Importantly, since p second position preference profiles
voters, holds score differences, applying shift actions, similar
Plurality rule Borda rule. Thus, proof correctness Plurality rule
transfers Borda rule.

Throughout section shown number hardness results
restrictive assumptions regarding available shift actions. following sections
seek positive algorithmic results.
628

fiCombinatorial Shift Bribery

7. Exact Algorithms
spite pessimism looming previous section, section show two
exact FPT XP algorithms R-Combinatorial Shift Bribery. Then, Section 8,
present several efficient approximation algorithms.
begin observing R-Combinatorial Shift Bribery solved polynomial time, provided assume budget B constant. reason
need choose B shift actions available ones, number shift
actions available upper-bounded input size.
Observation 1. Plurality-Combinatorial Shift Bribery Borda-Combinatorial Shift Bribery XP parameterized budget B.
restrict instances contain bounded-effect shift actions,
show R-Combinatorial Shift Bribery solved polynomial time, provided
number n voters treated constant.
Proposition 12. maximum effect every shift action upper-bounded universal constant, Plurality-Combinatorial Shift Bribery Borda-Combinatorial Shift Bribery XP parameterized number n voters.
Proof. Let value bounding, component-wise, effect shift action. First,
observe (2 + 1)n types different shift actions. Second, observe
one knows budget spent type shift actions, one easily check
whether corresponding set shift actions makes p winner election. Thus use
following algorithm: try possibilities distributing budget B among
(2 + 1)n types shift actions check whether one makes p winner.
so, accept. Otherwise reject.
Proposition 12 holds even shift action comes individual cost
voter individual threshold function, can, given budget, always
select cheapest set shift actions given type. Further, expressing problem
integer linear program (ILP) using famous result Lenstra (1983),
Plurality rule strengthen XP-membership FPT-membership.
Theorem 13. bounded-effect shift actions (where treat bound universal
constant), Plurality-Combinatorial Shift Bribery FPT parameterized
number n voters.
Proof. Given instance Plurality-Combinatorial Shift Bribery n voters,
algorithm proceeds follows. First, guess subset voters
guarantee p ranked first (there 2n guesses try). guessed set voters,
test whether p would winner election p shifted top position
guessed voters ranked first remaining voters. guessed
subset V 0 voters test positive, check whether possible ensure
(by applying shift actions whose cost exceed budget) voters V 0
rank p first. follows.
Let universal constant bounding, component-wise, effect shift action.
Observe (2+1)n types different shift actions. shift action
629

fiBredereck, Faliszewski, Niedermeier, & Talmon

type z, introduce variable xz denoting number times shift action type z
present solution. voter vi , denote svi (p) position p original
preference order vi . voter vi V 0 , add following constraint:
P

P

x
svi (p).
z
[,]
{z:fz effect vi }
ensures p indeed shifted top position vi preference list. add
budget constraint:
X
xz B,
ensuring solution respects budget. Finally, shift action type z add
constraint ensuring use many shift actions type z available
input. finishes description ILP. result Lenstra (1983),
solve ILP FPT time, (2 + 1)n integer variables.
Roughly speaking, Theorem 13 reason Theorem 9 apply
Plurality rule. setting, Plurality-Combinatorial Shift Bribery tractable.
Note Theorem 13 applies case shift action unit cost,
i.e., case focus paper. Nonetheless, believe possible
lift Theorem 13 case shift action individual cost, applying
ideas Bredereck, Faliszewski, Niedermeier, Skowron, Talmon (2015a).

8. Approximation Algorithms
explore possibility finding approximate solutions Combinatorial Shift
Bribery. focus approximating cost shift actions necessary ensure ps
victory (for example, 2-approximate algorithm finds solution ensures ps victory
whenever possible, uses twice many shift actions necessary).
Theorems 6 7, know cannot hope find approximate algorithms
cases Combinatorial Shift Bribery shift actions negative effects.
Thus, section, focus unit-effect shift actions positive effects.
simplifies situation always check possible ensure ps victory:
suffices apply available shift actions check p winner (indeed,
able perform check heart inapproximability results Section 6).
approximation algorithms proceed either directly invoking algorithms
non-combinatorial variant Shift Bribery Elkind et al. (2009) Elkind
Faliszewski (2010), plugging algorithms framework. start
former approach describe latter.
Theorem 14. shift action effects either 0 1 voter, PluralityCombinatorial Shift Bribery -approximated polynomial-time BordaCombinatorial Shift Bribery 2-approximated polynomial time, denotes maximum number voters affected shift action.
Proof. general idea approximation algorithms split shift action
affects 0 voters 0 shift actions, affecting single voter only. effect
630

fiCombinatorial Shift Bribery

construct non-combinatorial instance Shift Bribery solve exactly,
case Plurality rule, 2-approximately, case Borda rule.
Specifically, construction goes follows. Let (i) denote number shift actions
affecting voter i. Given instance Combinatorial Shift Bribery, form
instance Shift Bribery identical, except instead shift actions,
price functions voters: set price function voter
j (i), shifting p j positions costs j, j > (i), shifting p j positions
costs (2B + 1)j (where B total number shift actions available; note
exponential function (2B + 1)j ensures price functions convex
easily identify situations one shifts p (i) positions).4
describe use construction case Plurality rule
case Borda rule.
Plurality Rule. first translate input instance non-combinatorial
Plurality-Shift Bribery instance described above. Then, apply known, exact,
polynomial-time algorithm Plurality-Shift Bribery (Elkind et al., 2009)
instance. Let cost solution found non-combinatorial instance.
> B, impossible ensure ps victory combinatorial instance (because
number available shift actions insufficient).
B, obtain solution F Plurality-Combinatorial Shift Bribery
instance follows. voter v (non-combinatorial) bribed election
ranks p first, select shift actions combinatorial instance v ranks p first.
Note |F | F indeed (combinatorial) solution.
sake contradiction, assume successful set shift actions F 0
size smaller |F |/. However, easy see set shift actions would
correspond bribery cost smaller non-combinatorial instance. Since
cost optimal solution non-combinatorial instance, contradiction.
Borda Rule. case Borda-Combinatorial Shift Bribery follows analogously, instead using polynomial-time exact algorithm non-combinatorial
instance, use 2-approximation algorithm Borda-Shift Bribery (Elkind et al.,
2009; Elkind & Faliszewski, 2010). Let cost solution found. > 2B,
impossible ensure ps victory.
Otherwise, obtain solution F combinatorial instance, vote v
non-combinatorial solution shifts p positions, include shift actions
affect voter. |F | s, F correct solution combinatorial
instance.
existed solution F 0 combinatorial instance used less |F |/(2)
shift functions, would solution non-combinatorial instance
cost smaller |F |/2 s/2. Since used 2-approximate algorithm noncombinatorial instance, impossible.
mention might possible improve approximation ratio given Theorem 14, least Borda rule. idea might cast problem variant
4. Strictly speaking, need ensure price functions convex, variant
Shift Bribery generalize paper, stick consistency.

631

fiBredereck, Faliszewski, Niedermeier, & Talmon

Set Multicover problem, generalization Set Cover problem
element covering requirement. Then, one could use approximation algorithm Set Multicover problem (for example, one suggested Rajagopalan
& Vazirani, 1998) plug 2-approximation algorithm Elkind Faliszewski
(2010).
achieve better approximation guarantees Borda rule,
restrict allowed shift actions. obtain results use framework Elkind
Faliszewski (2010). essence, shown following: given variant
Shift Bribery, either Plurality rule Borda rule, one provide
function computes obtain highest number points preferred
candidate given budget B, 2-approximation algorithm variant
Shift Bribery.5 Note get-most-points-for-p algorithm solve Shift
Bribery. maximizes score p, ensure candidate receives
higher score. Indeed, optimal solution might increase score p smaller extent,
expense dangerous opponents.
Theorem 15. Borda-Combinatorial Shift Bribery 2-approximable polynomial
time (+1, +1)-shift actions.
Proof. discussion preceding theorem statement, suffices provide function
given instance Combinatorial Shift Bribery budget B finds set
shift actions obtain highest possible number points preferred candidate
p without exceeding budget.
general idea achieving compute maximum b-matching auxiliary
multigraph (multigraphs allow multiple edges vertices). b-matching
multigraph G function b : V (G) N (called covering function) edge-induced
subgraph G vertex u degree b(u). known b-matching
computed polynomial time (Gabow, 1983).
construct auxiliary multigraph G follows. voter vi create vertex
ui . shift action effect 1 voter ui effect 1 voter uj , create edge
{ui , uj }. Then, define covering function b b(ui ) number positions
p shifted forward preference order voter vi (that is, position p
preference order voter vi ).
G b-matching size least B, corresponds set shift actions
increase score p 2B, highest gain possible. G b-matching
size k < B, take shift actions corresponding edges b-matching
(these shift actions maximize number points p gain shift actions
move p within two votes) greedily select shift actions pushes p forward
one vote, use budget (at point, every shift action affect p single
vote only). Thus function computes highest point gain possible p, given
budget.
Next, consider interval shift actions. is, fix order voters
restrict shift action effect voters comprise intervals. (In fact,
5. fact, result applies scoring rules, paper focus Plurality rule
Borda rule only.

632

fiCombinatorial Shift Bribery

could allow holes inside intervals.) Unfortunately, algorithm requires XP
time parameterization length longest interval.
Theorem 16. Plurality rule Borda rule, Combinatorial Shift
Bribery 2-approximated XP-time interval shift actions, provided take
, upper bound number voters affected shift action, parameter.
Proof. per discussion preceding Theorem 15, suffices describe find set
shift actions maximize number points preferred candidate p gains
given budget.
end, use dynamic programming algorithm. Consider input
Combinatorial Shift Bribery election E = (C, V ), preferred candidate p,
budget B spend increasing ps score. Let := |C| n := |V |.
V = (v1 , . . . , vn ). algorithm uses following table partial results. numbers x, y, s0 , . . . , s1 table entry:
[x, y, s0 , s1 , . . . , s1 ]
denotes maximum number additional points candidate p gain voters v1 , . . . , vx condition (1) exactly shift actions used,
affects voters set {v1 , . . . , vx }, (2) {0, ..., 1},
candidate p shifted position si preference order voter vxi . is, iterate
voters store effect applied shift actions last voters.
size table n B m+1 .
algorithm almost Plurality rule Borda rule.
difference computing scores candidates. Let z, 0 z 1, denote
position p preference order voter (position 0 means p ranked
first). Then, score(z) mean score p gains voter. Plurality
rule score(z) = 1 z = 0 score(z) = 0 otherwise. Borda rule
score(zi ) = zi 1. set voters vector z1 , . . . , zt (for [n] zi
{0, . . . , 1}) denotes positions p preference orders voters,
write score(z1 , . . . , zt ) mean score p gains voters. is:
score(z1 , . . . , zt ) =

X

score(zi ).

i[t]

Given preparation, ready describe algorithm (jointly Plurality
rule Borda rule).
Initialization. initialize entries [, y, s0 , s1 , . . . , s1 ] table follows.
check whether set shift actions effects voters
(v1 , . . . , v ) applying set shift actions moves candidate p positions s0 , . . . , s1 preference orders voters v1 , . . . , v , respectively.
exists, set [, y, s0 , s1 , . . . , s1 ] score(s0 , s1 , . . . , s1 ). Otherwise, set
[, y, s0 , s1 , . . . , s1 ] . (We explain check set shift actions exists
end proof.)
633

fiBredereck, Faliszewski, Niedermeier, & Talmon

Recursion Step. compute table entries [x, y, s0 , s1 , . . . , s1 ] x > , one
compute subsets shift actions (for [y]) whose last affected voter vx , ensure
together yi shift actions whose last affected voter set {v1 , . . . , vx1 }that
j, 0 j 1, p shifted position sj preference order vxj .
specifically, update phase compute x, < x n, y, 0
B, vector (s0 , . . . , s1 ) {0, . . . , 1} table entry [x, y, s0 , s1 , . . . , s1 ]
follows. say vector (s0 , s1 , . . . , s1 ) {0, . . . , m} (x, i)-realizable
(0 y), set shift actions whose last affected voter vx
j, 0 j 1, shifts candidate p sj positions preference
order voter vxj . write R(x, i) denote set vectors {0, . . . , 1}
(x, i)-realizable (we describe compute R(x, i) later). Then, compute
[x, y, s0 , s1 , . . . , s1 ] follows:
[x, y, s0 , s1 , . . . , s1 ] = max{T [x 1, i, , s0 s1 , . . . , s1 s1 , ]
+ score(s0 , s1 , . . . , s1 ) score(s1 s1 , . . . , s1 s1 ) |
0 y, 0 1, (s0 , s1 , . . . , s1 ) R(x, i)}
Informally, realizable total effect shift actions whose last affected voter
vx , number points candidate p gains number additional points
candidate p gains shift actions last affected voter (v1 , . . . , vx1 )
plus number additional points candidate p gains shift actions
last affected voter vx (to avoid double counting, expressed difference
middle line formula).
next show compute R(x, i). try every vector (s0 , . . . , s1 ) {0, . . . ,

1} check (x, i)-realizable. Perhaps easiest way
formulate problem integer linear program (ILP) constant number
variables.
Let (s0 , . . . , s1 ) vector want check (x, i)-realizable.
subset Q {0, . . . , 1}, say shift action type Q affects exactly
voters vxi Q. subset Q, introduce integer variable xQ ,
denoting number shift actions type Q used (x, i)-realization vector.
solve following ILP:
X

xQ =

(1)

xQ{0} =

(2)

Q{0,...,1}

X
Q{1,...,1}

X

j : 0 j 1

xQ = sj

(3)

jQ

(Note middle constraint ensures last affected voter vx .) Since
number variables ILP 2 , follows famous result Lenstra (1983)
ILP solved XP time respect parameter (indeed, even
FPT time). Using ILP without middle constraint, check
vectors (s0 , . . . , s1 ) use initialization step.
634

fiCombinatorial Shift Bribery

Coming back dynamic program, clear finding obtain maximum score p respecting budget found taking maximum
table entries [n, B 0 , s0 , s1 , . . . , s1 ], possible values B 0 , 0 B 0 B,
(s0 , s1 , . . . , s1 ) {0, . . . , 1} .
section showed indeed possible achieve approximation
algorithms special cases Combinatorial Shift Bribery problem,
settings algorithms efficient quite restrictive. means
practice one might want seek good heuristics use algorithms guidance
initial search.

9. Conclusion
defined combinatorial variant Shift Bribery problem (Elkind et al., 2009;
Elkind & Faliszewski, 2010; Bredereck et al., 2014a) studied computational
complexity. motivation research desire understand computational
difficulty imposed correlated, large-scale effects campaign actions. respect,
work motivated combinatorial study election control, studied Bulteau et al.
(2015) Chen et al. (2015). found even various restricted special
cases numerous parameterizations, Combinatorial Shift Bribery problem
highly intractable worst case. Nonetheless, found initial positive results,
mainly form approximation algorithms. Interestingly, approximation results
quite strongly rely results non-combinatorial Shift Bribery.
number research directions motivated work. example, Plurality-Combinatorial Shift Bribery Borda-Combinatorial Shift
Bribery solved polynomial-time (+1, +1) shift actions interval actions
assumption number candidates constant?
generally, results suggest studying restrictions problem.
example, since parameterizing number available shift actions immediately gives
fixed-parameter tractability results, natural question whether natural parameterizations exist could lead positive results.
Naturally, one might consider voting rules well. interesting Condorcetconsistent rules, Copeland rule, since rules tend behave rather differently
scoring rules. mention results hold voting rules:
specifically, Theorem 2, Theorem 5, Theorem 6, Theorem 7 hold voting rules
theorems hold elections two candidates, voting rules
behave elections two candidates; Observation 1 Theorem 12
basically brute-force algorithms results hold voting rules well;
statements regarding Borda rule Theorem 14, Theorem 15, Theorem 16 hold
scoring rules, since underlying 2-approximation algorithm Elkind Faliszewski
(2010) works scoring rules.
Further, might interesting consider domain restrictions regarding voters
preferences (for example, single-crossing seems particularly natural context interval
shift actions, since means shift action affects voters somewhat similar
preferences), well-demonstrated restricting domain voters lead
635

fiBredereck, Faliszewski, Niedermeier, & Talmon

tractability (see Theorem 10 Bulteau et al., 2015, example combinatorial
control setting). However, pursuing direction would require careful discussion
shift actions applied. example, allow single-crossing election cease
single-crossing bribery?
Acknowledgments
Robert Bredereck supported DFG project PAWS (NI 369/10). Nimrod Talmon supported DFG Research Training Group Methods Discrete Structures (GRK 1408) currently Weizmann Institute Science. Piotr Faliszewski
supported DFG project PAWS (NI 369/10) AGH University grant
11.11.230.124 (statutory research).
preliminary short version work presented 2015 International
Conference Autonomous Agents Multiagent Systems (AAMAS 15) (Bredereck,
Faliszewski, Niedermeier, & Talmon, 2015b).

Appendix A. Proof Theorem 7
Theorem 7. Unless P = NP, Combinatorial Shift Bribery inapproximable (in
polynomial time) Plurality rule Borda rule, even two candidates
(+1, 1)-shift actions.
Proof. give many-one reduction Set Cover. Let (S, X, h) Set Cover
instance, = {S1 , . . . , Sm } X = {x1 , . . . , xn } (we assume every element
belongs least one set). construct instance Plurality-Combinatorial Shift
Bribery. set budget B := |X|. candidate set {p, d}, p
preferred candidate. element voter vi element xi , preference
order p. set voter vjS set Sj , preference order p d.
|X| + |S| 2h 1 dummy voters, preference order p. element
xi set Sj , xi Sj construct shift action fji effect +1 vi
effect 1 vjS . completes construction. easy see computable
polynomial time.
Next, show successful set shift actions (note size
set important, is, allow infinite budget) set cover
size h.
part, assume set cover 0 size h. show
build successful set shift actions. start F 0 = element xi ,
choose arbitrary set Sj 0 contains xi add corresponding function
fji F 0 . applying F 0 , observe p becomes winner: |X| element voters
|S| h set voters prefer p |X| + |S| 2h 1 dummy voters h set voters prefer d.
part, assume successful set shift actions F 0 F .
Let h0 number applying shift actions F 0 , p preferred
exactly |S| h0 set voters (that is, shift actions F 0 correspond h0 sets S). p
winner, majority voters (i.e., least |X| + |S| h voters) must prefer p. Thus,
applying F 0 , least X (h h0 ) element voters prefer p. means
collection h0 sets jointly cover least |X| (h h0 ) elements. Since every
636

fiCombinatorial Shift Bribery

element belongs set, extend collection set cover adding
h h0 sets (in worst case, one set uncovered element). proves
set cover (S, X, h) completes part.
Note argumentation made assumptions regarding size F 0 .
Hence, finding solution Plurality-Combinatorial Shift Bribery instance,
including approximate solutions approximation factor, implies finding set cover
size h. means unless P = NP, Plurality-Combinatorial Shift Bribery
inapproximable polynomial time.

Appendix B. Remaining Cases Proof Theorem 8
Theorem 7. Unless P = NP, Combinatorial Shift Bribery inapproximable (in
polynomial time) Plurality rule Borda rule, even two candidates
(+1, 1)-shift actions.
Borda Rule (+1, +1)-Shift Actions. slightly modify reduction used Plurality rule (+1, +1)-shift actions. Specifically, describe parameterized reduction W[1]-hard Clique problem, parameterized solution
size, Borda-Combinatorial Shift Bribery (+1, +1)-shift actions, parameterized
(m, B).
Let (G, h) instance Clique V (G) = {u1 , . . . , un0 } E(G) = {e1 , . . . , em0 }.
create instance Borda-Combinatorial Shift Bribery follows. set
candidates {p} D, = {d1 , . . . , dh1 }. create following voters.
1. vertex ui V (G), create corresponding vertex voter vi preference
order:
d1 dh1 p.
2. create n0 2h dummy voters, preference order:
p d2 dh1 d1 .
3. create h dummy voters, preference order:
dh1 p d2 dh2 d1 .
4. create n0 h dummy voters, preference order:
p d1 dh1 .
5. create n0 h dummy voters, preference order:
d1 p d2 dh1 .
edge {ui , uj } E(G), create shift action f{ui ,uj } effect 1 vertex

voters vi vj effect 0 voters. Finally, set budget B := h2 .
completes construction, computable polynomial time.
637

fiBredereck, Faliszewski, Niedermeier, & Talmon

proof correctness follows lines proof Plurality rule
(+1, +1)-shift actions, instead counting number approvals, need compute
Borda scores candidates. Indeed, reason additional dummy
voters.
particular, construction ensures d1 original winner election
difference Borda score p Borda score d1 exactly h2 .
Furthermore, shift action increase score p two. Hence, make
p co-winner one must increase score p h(h 1) decrease score d1 h.
possible shift actions correspond edges clique size h.
Plurality Rule (+1, 1)-Shift Actions. still reduce W[1]hard Clique problem, parameterized solution size, reduction bit
involved.
Let (G, h) Clique instance graph G n0 := |V (G)| vertices
0
:= |E(G)| edges. construct Plurality-Combinatorial Shift Bribery instance
follows. Let set candidates {p, d} D, := {d1 , . . . , dh1 }, create
following voters:
1. vertex vi , create
preference order:

h
3



(h)
vertex voters vi1 , . . . , vi 3 corresponding vi ,
d1 dh1 p.

2. edge ej = {vi1 , vi2 }, create corresponding edge voter wj preference
order:
p d1 dh1 .


3. Create 2 h2 + (n0 2h) h3 m0 dummy voters, preference order:
p d1 dh1 .
edge ej = {vi1 , vi2 }, construct 2

h
3



shift actions, denoted

( h)
(h)
fe1j ,vi , . . . , fej3,vi1 fe1j ,vi , . . . , fej3,vi2 ,
2

1

h
3

], (a) fezj ,vi effect +1 viz1 effect 1 wj , (b)
1

fezj ,vi effect +1 viz2 effect 1 wj . Finally, set budget B := 2 h2 h3 .
2
completes construction. easy see computable polynomial time
parameterized reduction.
Observe that, initially, edge voters dummy
voters prefer
p, vertex


h
h
0
voters prefer d1 . Therefore, initial score p 2 2 + (n 2h) 3 , initial score

d1 n0 h3 . assume, without loss generality, means d1
winner election (instances satisfying assumption solved constant
time).
remains show constructed instance contains successful set shift actions F 0 size h (G, h) contains clique size B. general
z [



638

fiCombinatorial Shift Bribery

idea choose shift actions corresponding edges connecting nodes
h-size clique, ensure p becomes preferred candidate h h3

additional vertex voters, making d1 preferred candidate h2 additional
edge voters.
Formally, part, let H V (G) set h vertices forming clique let
E 0 E(G) set edges connecting vertices H. choose following set
shift actions:

h
0
0
z
z
]}.
F = {fej ,vi , fej ,vi | ej = {vi1 , vi2 } E , z [
1
2
3
show F 0 successful set
shift actions. end, observe vertex
h
z
0
voter vi vi V z [ 3 ], candidate p shifted h 1 positions forward, therefore

p becomes preferred candidate voters. means h h3 additional vertex
voters prefer p (and, thus, prefer d1 anymore). Furthermore, p shifted backwards
voters {wj | ej E 0 }, is, d1 becomes preferred candidate


h
h
0
2 edge voters p remains preferred candidate 2 edge voters. Thus,
p tie winners.
part, let F 0 successful set shift actions.
p winner
make

election, p must shifted top position least h h3 h2 vertex voters (no
type voters affected positively). pigeonhole
principle, vertex

h
voters correspond least h different vertices (there 3 voters corresponding

vertex). effect, least h2 edge voters must effected negatively d1 becomes
preferred candidate.
Thus, make p win election p must shifted

top



position least h h3 vertex voters. implies |F 0 | (h1)h h3 = 2 h2 h3 = B
and, hence, |F 0 | = B. Itfollows p shifted backwards making d1 preferred
candidate exactly h2 edge voters p must shifted top position

exactly h h3 vertex voters corresponding exactly h different vertices. construction,
implies h vertices form clique, done.
Borda Rule (+1, 1)-Shift Actions. Borda rule, reduction is,
again, bit involved, main idea Plurality rule.
Let (G, h) instance Clique graph G n0 := |V (G)| vertices
0
:= |E(G)| edges. construct Borda-Combinatorial Shift Bribery instance
follows. set candidates {p, d} D, := {d1 , . . . , dh1 }, create
following voters:

(h)
1. vertex vi , create h3 vertex voters vi1 , . . . , vi 3 corresponding vi ,
preference order:


p.
2. edge ej = {vi1 , vi2 }, create corresponding edge voter wj preference
order:
d1 dh2 p dh1 .



h
h 2
0 h
0
0
2 + (n 3 + )(h 1) ( 3 h )
3. Let L :=
. Without loss generality,
h1
assume L integer (this requires simple modifications input clique
639

fiBredereck, Faliszewski, Niedermeier, & Talmon

instance only). create L dummy voters, preference order:
p dh1 d1 .
edge ej = {vi1 , vi2 }, construct 2

h
3



shift actions, denoted

(h)
( h)
fe1j ,vi , . . . , fej3,vi1 fe1j ,vi , . . . , fej3,vi2 ,
1

2

h
3

], (a) fezj ,vi effect +1 viz1 effect 1 wj , (b)
1

fezj ,vi effect +1 viz2 effect 1 wj . Finally, set budget B := 2 h2 h3 .
2
completes construction. easy see computable polynomial time.
proof correctness follows lines proof correctness Plurality
rule and, thus, omitted.
z [



Appendix C. Proof Theorem 9
Theorem 9. Borda-Combinatorial Shift Bribery W[1]-hard respect number n voters, even (+1, 1)-shift actions budget constraints.
Proof. reduce following W[1]-hard problem (Mathieson & Szeider, 2012, Lemma
3.2).
Strongly Regular Multicolored Clique
Input: Two integers, h, undirected graph G = (V, E),
vertex one h colors [h], vertex adjacent exactly
vertices color different own.
Question: exist clique size h containing one vertex
color class?
Given instance Strongly Regular Multicolored Clique, construct
instance Combinatorial Shift Bribery, Borda rule. general idea
reduction follows. set important candidates consists preferred
candidate p candidates correspond edges. technical reasons,
edge e = {v, v 0 }, introduce two candidates, e1 e2 ; one associated
touching vertex v associated touching vertex v 0 . (In fact,
introduce edge candidates vertex candidates, use
ensure correct structure election appropriate bribery behavior.) build two
groups voters, vertex-selecting voters edge-electing voters. first group
implements picking vertices clique (one vertex color), second
group implements picking edges (one edge pair colors). ensure given
set shift actions chance successful, must hold h vertices
h
2 edges picked. Importantly, holds even unbribed election.
make sure p wins election picked voters edges correspond clique (with vertices color). end, define voters
two numbers, , that:
640

fiCombinatorial Shift Bribery

1. h vertices picked vertex-selecting voters, different color.
vertex-selecting voters give points edge candidate associated
touching one selected vertices, + 1 points edge candidates.
means picking vertex decrease score edge candidates
edges touch vertex.

2. h2 edges picked edge-selecting voters, one edge pair colors.
edge-selecting voters give + 1 points edge candidate corresponds
picked edge, points remaining edge candidates. means that,
picking edge, increase score candidates corresponding it.
3. Candidate p gets + + 1 points, irrespective shift actions apply.
Note unbribed election every candidate gets + + 2 points p
always gets + + 1 points. Thus challenge ensure every candidate gets
+ + 1 points. description, possible pick vertices
edges correspond size h clique (of vertices different colors). Indeed,
selected edge e touch two selected vertices, e1 e2 would receive
+ 1 points edge-selecting candidates least one would receive + 1
points vertex-selecting voters. effect, p would winner.
Without loss generality, assume edges vertices selected unbribed
election form clique (otherwise would trivial solution input
problem could output fixed yes-instances Borda-Combinatorial Shift
Bribery).
Construction. formally describe reduction, give example
applying simple instance, finally show correctness reduction.
illustrate aspects correctness proof using example.
Candidates. set candidates somewhat involved. important candidates
preferred candidate p sets edge candidates, E1 E2 , defined below.
Let E(G) = {e1 , . . . , e } set edges graph G. create two edge-candidate
sets: E 1 = {e11 , . . . , e1 } E 2 = {e21 , . . . , e2 }. [h], let ni number
vertices G color let V = {v1i , . . . , vni } set vertices.
color vertex vji V , define neighborhood vji follows:
0

N (vji ) := {e1` | e` = {vji , vji 0 } E < i0 }
0

{e2` | e` = {vji , vji 0 } E > i0 }.
(This, perhaps bit strange way using color numbers pick edge candidates either
E 1 E 2 , implementing fact edge e E(G) two candidates, e1
e2 , associated touching different endpoints e.)
technical reasons need candidates follows. adjust scores
candidates, introduce single dummy candidate d. create two
candidate sets E 0 = {e01 , . . . , e0 } E 3 = {e31 , . . . , e3 } act guards
edge-selecting voters. V create two candidate sets U := {uij | vji V }
641

fiBredereck, Faliszewski, Niedermeier, & Talmon



U 0i = {u0ij | vji V } U := 1ih U U 0 := 1ih U 0i act guards
vertex-selecting voters.
final set candidates C := U U 0 E 0 E 1 E 2 E 3 {p, d}.
Vertex-Selecting Voters. describe vertex-selecting voters. color
vertex vji , define following parts preference orders (for j = 1, assume
uij1 u0ij1 uini u0ini respectively):

A(vji ) : uij N (vji ) u0ij ,

B(vji ) : uij1 N (vji ) u0ij1 .
color create three pairs voters. voters first pair, wi wi0 ,
following preference orders:


wi : p A(v1i ) A(v2i ) A(v3i ) A(vni ) Ri ,


wi0 : Ri B(v1i ) B(vni ) B(vni 1 ) B(v2i ) p,
Ri set remaining candidates, is, Ri := C \ ({p} U U 0i N (v1i )
N (vni )). voters second pair, qi qi0 , preference orders
reverse wi reverse wi0 , respectively. Finally, voters last pair, qi
qi0 , preference orders:


qi : C \ ({d} N (v1i )) N (v1i ),

qi0 : N (v1i ) C \ ({d} N (v1i )) d.
effect, first two pairs voters jointly give 2(|C| 1) points candidates.
last pair gives |C| 1 points candidates N (v1i ) |C| points
candidates (except d, receives less |C| 1 points).
Let := h(2(|C|1)+|C|)1. Altogether, vertex-selecting voters give following
scores candidates: candidates N (v11 )N (v12 ) N (v1h ) receive points
candidates, except d, receive + 1 points (d receives less points). Thus,
unbribed election v11 , . . . , v1h selected vertices.
color i, introduce (ni 1) ((h 1) + 2) shift actions effect 1
voter wi effect +1 voter wi0 . understand number shift
actions comes from, note that: (1) vertex vji , |N (vji )| = (h 1) (each
vertex connected vertices color different own), (2) A(vji )
B(vji ) candidates N (vji ) surrounded two vertex candidates, (3)
integer, 1 ni 1, applying t((h 1) + 2) shift actions effect
candidates N (v1i ) gain one point (i.e., v1i ceases selected), candidates
) lose one point (i.e., v
N (vt+1
t+1 becomes selected), candidate changes
score (later argue applying numbers shift actions multiples
((h 1) + 2) cannot ensure ps victory).
642

fiCombinatorial Shift Bribery

Edge-Selecting Voters. edge-selecting voters, need following additional
notation. Let Ex,y denote set candidates representing edges vertices
color x color y, is,
q{0,1,2,3}

Ex,y := {e`

| e` = {vjx , vjy0 } E}.

write nx,y denote number edges vertices color x color y.
idx,y
z refer index z-th edge vertices color x y. example,
e3 , e7 e57 three edges vertices colors 1 2, n1,2 = 3,
1,2
1,2
id1,2
1 = 3, id2 = 7, id3 = 57.
pair {x, y} distinct colors edge eidx,y
, introduce following
j
x,y
parts preference orders (for j = nx,y , assume idj+1 = idx,y
1 ):
R(eidx,y
) : e0idx,y e1idx,y e2idx,y e3idx,y ,
j
):
S(eidx,y
j

j

j

j

e0idx,y
j+1

e1idx,y
j

e2idx,y
j





j



e3idx,y .
j+1

pair {x, y} distinct colors introduce three pairs voters. voters
0 , following preference orders:
first pair, wx,y wx,y

wx,y : R(eidx,y
) p R(eidx,y
) R(eidx,y
) R(eidx,y
) Rx,y ,
nx,y
1
2
3

0
) S(eidx,y
) S(eidx,y
) S(eidx,y
) p,
wx,y
: Rx,y S(eidx,y
nx,y
n
1
2
1
x,y

Rx,y set remaining candidates, is, Rx,y := C \ ({p} Ex,y ).
0 , preference orders reverse w
voters second pair, qx,y qx,y
x,y
0
0 ,
reverse wx,y , respectively. Finally, voters last pair, qx,y qx,y
following preference orders:

qx,y : e1idx,y e2idx,y C \ ({d, e1idx,y , e2idx,y }),
1
1
1
1
12
0
2
1
qx,y : C \ ({d, eidx,y , eidx,y }) eidx,y eidx,y d.
1

1

1

1

first two pairs voters jointly give 2(|C| 1) points candidates.
last pair gives |C| points e1idx,y e2idx,y , |C| 1 points candidates
1
1
(except d, receives
less

|C|

1
points).

Let := 3 h2 (|C| 1). Altogether, pair distinct colors {x, y}, edgeselecting voters give + 1 points candidates e1idx,y e2idx,y . candidates receive
1
1
points (except d, receives less points). Thus unbribed election
selected edges exactly first edges pair colors (that is, edges
form eidx,y
, pair distinct colors {x, y}).
1
pair {x, y} distinct colors, create 4(nx,y 1) shift actions effect 1
0 . intuition behind shift actions similar
voter wx,y effect +1 voter wx,y
case vertex-selecting voters. make following observations: (1)
edge eidx,y four candidates listed R(eidx,y ) four candidates listed S(eidx,y ),
`
`
`
(2) integer, 1 nx,y 1, apply 4t shift actions, candidates
643

fiBredereck, Faliszewski, Niedermeier, & Talmon

v11

v12

e3

e1

v21

e4

e2

v22

e5

e6
v13

v23

V 1 = {v11 , v21 }, V 2 = {v12 , v22 }, V 3 = {v13 , v23 }, h = 3, = 1
Figure 2: 3-colored graph six vertices vertex adjacent one vertex
color classes V 1 , V 2 V 3 , own.
ceases selected), candidates e1idx,y e2idx,y
e1idx,y e2idx,y lose one point (edge eidx,y
1
1

t+1

1

t+1

gain one point (edge eidx,y
becomes selected), scores candidates remain
t+1
unchanged (we later argue apply number shift actions
multiple 4, p certainly winner resulting election).
conclude construction, set budget B := (that is, use many
shift actions like). easy verify reduction computable polynomial
time introduce number voters function h (thus,
parameterized reduction). proving correctness construction, consider
following example (we refer correctness proof well).
Example 5. Consider Strongly Regular Multicolored Clique instance (d, h, G)
= 1, h = 3, graph G Figure 2. construction produces following set
candidates:
C := U U 0 E 0 E 1 E 2 E 3 {p, d},

01 02 02 03 03
U = {u11 , u12 , u21 , u22 , u31 , u32 }, U 0 = {u01
1 , u2 , u1 , u2 , u1 , u2 }


E = {ei1 , ei2 , . . . , ei6 }, 0 3.
Furthermore, have:
N (v11 ) := {e11 , e12 },

N (v21 ) := {e13 , e16 },

N (v12 ) := {e23 , e14 },

N (v22 ) := {e21 , e15 },

N (v13 ) := {e22 , e25 },

N (v23 ) := {e24 , e26 }.
644

fiCombinatorial Shift Bribery

vertex-selecting group voters, create following voters. color
i, create two voters wi wi0 :

1
1
1
1
01
w1 : p u11 e11 e12 u01
1 u2 e3 e6 u2 R ,


1
1
1
01
w10 : R1 u12 e11 e12 u01
2 u1 e3 e6 u1 p,

2
2
2
1
02
w2 : p u21 e23 e14 u02
1 u2 e1 e5 u2 R ,


2
2
1
02
w20 : R2 u22 e23 e14 u02
2 u1 e1 e5 u1 p,

3
3
2
2
03
w3 : p u31 e22 e25 u03
1 u2 e4 e6 u2 R ,


3
2
2
03
w30 : R3 u32 e22 e25 u03
2 u1 e4 e6 u1 p,
Ri := C \ ({p} U U 0i N (v1i ) N (vni )), 1 3. voters
add voter reversed preferences. (This means that, far, candidates obtain
total score.) finish group voters creating color two voters,
qi qi0 , preference orders:


qi : C \ ({d} N (v1i )) N (v1i ),

qi0 : N (v1i ) C \ ({d} N (v1i )) d.
ensures color i, candidates N (v1i ) get points,
candidates get + 1 points (except gets points). create 4 shift actions
effect 1 voter wi effect +1 voter wi0 .
edge-selecting second group voters, recall Ex,y denotes set candidates representing edges vertices color x color y. Specifically, have:
E1,2 :={e01 , e11 , e21 , e31 e03 , e13 , e23 , e33 },
E1,3 :={e02 , e12 , e22 , e32 e06 , e16 , e26 , e36 },
E2,3 :={e04 , e14 , e24 , e34 e05 , e15 , e25 , e35 }.
0 , follows:
pair {x, y} distinct colors create two voters, wx,y wx,y


w1,2 : e01 e11 e21 e31 p e03 e13 e23 e33 R1,2 ,

0
w1,2
: R1,2 e01 e13 e23 e31 e03 e11 e21 e33 p,

w1,3 : e02 e12 e22 e32 p e06 e16 e26 e36 R1,3 ,

0
w1,3
: R1,3 e02 e16 e26 e32 e06 e12 e22 e36 p,

w2,3 : e04 e14 e24 e34 p e05 e15 e25 e35 R2,3 ,

0
w2,3
: R2,3 e04 e15 e25 e34 e05 e14 e24 e35 p,
Rx,y := C \ ({p} E[x, y]). voters add voter reversed
0
preferences. Further, pair {x, y} distinct colors, add two voters qx,y qx,y
645

fiBredereck, Faliszewski, Niedermeier, & Talmon

follows:

qx,y : e1idx,y e2idx,y C \ ({d, e1idx,y , e2idx,y }),
1
1
1
1
12
1
2
0
qx,y : C \ ({d, eidx,y , eidx,y }) eidx,y eidx,y d.
1

1

1

1

Altogether, pair {x, y} distinct colors, candidates e1idx,y e2idx,y get +1 points
1
1
candidates get points (except d, gets less points). pair {x, y}
distinct colors, create 4 shift actions effect 1 voter wx,y effect +1
0 .
voter wx,y
4
Properties Construction. discuss several properties construction.
properties play significant rule showing correctness reduction.
illustrate arguments, come back example time time. begin
looking scores candidates.
Lemma 1. following claims hold:
1. unbribed election, every candidate receives + + 2 points every
candidate {p} U U 0 E 0 E 3 receives exactly + + 1.
2. every bribed election, score p exactly + + 1.
3. applying successful set shift actions, score p + + 1
scores candidates + + 1.
Proof. easy see first claim holds based discussion give
throughout construction. second claim holds (a) applying every shift
action decreases one score p one vote increases one another vote
(there sufficiently shift actions whole instance applying shift
action always moves p within two votes shift action acts). last claim
follows directly second one.
(Lemma)
Let us consider process selecting vertices. description vertexselecting voters said that, initially, color vertex v1i selected,
integer t, 1 ni 1, apply t((h 1) + 2) shift actions affect voters wi wi0 ,

v1i ceases selected vt+1
becomes selected. argue apply
number shift actions divisible ((h 1) + 2), p winner
resulting election.
see case, recall preference orders voter wi wi0
exactly (h 1) candidates E 1 E 2 pair candidates {uij , u0ij }.
Furthermore, p passes candidate uij preference order voter wi (increasing
uij score one), must pass candidate uij preference order voter wi0
(decreasing uij score one). Otherwise, uij would end score + + 2 and,
1, p would winner (there possibilities influence score uij
shifting p preference lists wi wi0 ). Hence, p passes candidate u0ij
candidates uij u0ij preference lists wi wi0 . This, however,
means p winner election, number applied shift actions
646

fiCombinatorial Shift Bribery

Unbribed voters w2 w20 :


2
2
2
1
02
w2 : p u21 e23 e14 u02
1 u2 e1 e5 u2 R


2
2
1
02
w20 : R2 u22 e23 e14 u02
2 u1 e1 e5 u1 p
Applying two shift actions effect -1 w2 +1 w20 :
+1 +1

2
2
2
1
02
w2 : u21 e23 p e14 u02
1 u2 e1 e5 u2 R
2
-1
-1


2 e2 p e1 u02
w20 : R2 u22 e23 e14 u02

u
2
1
1
5
1
+2
Applying (h 1) + 2 = 4 shift actions effect -1 w2 +1 w20 :
+1 +1 +1 +1

2
2
2
1
02
w2 : u21 e23 e14 u02
1 p u2 e1 e5 u2 R
4
-1
-1
-1
-1

2
0
2
2 e2 e1 u02
w2 : R u2 e23 e14 u02

p

u
2
1
1
5
1
+4
Figure 3: Illustration bribery actions affecting first voter group running example
(Example 5). Note that, unbribed election, every candidate U U 0 obtains
+ + 1 points total. color one type shift actions
affects voter wi wi0 : shift actions effect 1 voter wi effect +1
voter wi0 . shift action affect voter first group. Applying
multiple ((h 1) + 2) shift actions effect 1 voter wi effect +1 voter wi0
ensures candidates U U 0i receive + + 1 points total, whereas
applying number shift actions implies candidate U
receives + + 2 points and, hence, p cannot win. illustrate color 2
running example.
effects voters wi wi0 multiple ((h 1) + 2) (p passes candidate uij ,
candidate u0ij , h candidates between). Figure 3 provides illustration
reasoning.
next discuss selecting edges. case vertex-selecting voters, description construction argued (a) initially pair {x, y} distinct
colors, edge eidx,y
selected (b) applying 4t, 1 nx,y 1, shift actions
1
0 , e x,y ceases selected e x,y becomes selected.
affect voters wx,y wx,y
id1
idt+1
argue used number shift actions multiple four,
p certainly would winner election.
0
see case, note designed preference orders wx,y wx,y
candidates e0idx,y e3idx,y , j {2, . . . , nx,y }, follow p vote wx,y
j

j

0 . effect, apply shift action affects
order precede p wx,y

647

fiBredereck, Faliszewski, Niedermeier, & Talmon

0 :
Unbribed voters w2,3 w2,3


w2,3 : e04 e14 e24 e34 p e05 e15 e25 e35 R2,3

0 :R2,3 e0 e1 e2 e3 e0 e1 e2 e3 p
w2,3
4
5
5
4
5
4
4
5
0 :
Applying two shift actions effect -1 w2,3 +1 w2,3
+1 +1

w2,3 : e04 e14 e24 e34 e05 e15 p e25 e35 R2,3
2
-1
-1



0
2,3
0
1
2
3
0
1
2
w2,3 :R e4 e5 e5 e4 e5 e4 p e4 e35
+2
0 :
Applying four shift actions effect -1 w2,3 +1 w2,3
+1 +1 +1 +1

w2,3 : e04 e14 e24 e34 e05 e15 e25 e35 p R2,3
4
-1
-1
-1
-1

0 :R2,3 e0 e1 e2 e3 p e0 e1 e2 e3
w2,3
4
5
5
4
5
4
4
5
+4

Figure 4: Illustration bribery actions affecting second voter group running
example. Note unbribed election, every candidate E 0 E 4 obtains +
+ 1 points total. pair colors x one type shift
0 : shift actions effect 1 voter w
actions affects voter wx,y wx,y
x,y
0 . shift action affect voter second
effect +1 voter wx,y
group. Applying multiple 4 shift actions effect 1 voter wx,y effect +1
0
ensures candidates E 0 E 4 receive + + 1 points
voter wx,y
voters, whereas applying number shift actions implies
candidate E 0 receives + + 2 points and, hence, p cannot win. illustrate
color pair 2 3 running example.
0
voters wx,y wx,y
number times multiple four, one
candidates obtains + + 2 points. Since way affect score
candidates, Lemma 1, case p cannot winner. illustrate effect
Figure 4.

Solution Example 5. complete correctness proof, let us illustrate
solution example.
unbribed election selects vertex v11 , v12 , v13 edges e1 , e2 e4 . Hence,
example, candidate e24 receives + +2 points p (who receives + +1 points)
winner.
applying four shift actions effect 1 w2 effect +1 w20 , select v22
instead v12 vertex color 2 clique (as depicted bottom Figure 3).
648

fiCombinatorial Shift Bribery

0 , select e
applying four shift actions effect 1 w2,3 effect +1 w2,3
5
instead e4 edge color 2 color 3 clique (as depicted
bottom Figure 4). Now, candidate {e11 , e12 , e21 , e22 , e15 , e25 } receives + 1 points
edge-selecting voters, points vertex-selecting voters. Every
candidate receives + 1 points vertex-selecting voters
points edge-selecting voters. Hence, p (with + + 1 points) winner.
solution corresponds left 3-colored triangle Figure 2.

Correctness. remains show successful set shift actions
constructed Borda-Combinatorial Shift Bribery instance
h-colored clique graph G.
part, assume h-colored clique H V (G). Without loss
generality, let H = {vz11 , . . . , vzhh } let EH := {{v, v 0 } | v, v 0 H}. Furthermore, let zx,y
denote index edge Ex,y representing edge EH vertex
EH .
color x vertex color y. is, zx,y = j eidx,y
j
easy verify following set shift actions successful:
1. color [h], include (zi 1)((h 1) + 2) shift actions effects
voters wi wi0 .
2. pair {x, y} distinct colors, include 4(zx,y 1) shift actions effects
0 .
voters wx,y wx,y
words, select vertices edges corresponding clique. effect,
scores candidates + + 1 (except d, receives lower score). p
among tied winners.
part, assume successful set shift actions consider
election applying shift actions. construction, know edge-selecting
voters pick exactly one edge pair distinct colors. Hence graph induced
edges contains vertices h different colors. graph contains h
vertices, graph must h-colored clique (this graph cannot contain fewer
h vertices). sake contradiction, let us assume graph contains
h vertices. Thus two selected edges, ej ej 0 , incident two different vertices,
vi ej vi0 ej 0 , color. construction (and way vertex-selecting
voters work), least one sets N (vi ) N (vi0 ) candidates set receive
+ 1 points vertex-selecting voters. However, since ej ej 0 selected
edge-selecting voters, voters give + 1 points candidates e1j , e2j ,
e1j 0 , e2j 0 . Hence, least one candidates receives + + 2 points total and,
Lemma 1, p winner. contradiction, graph induced
selected edges must h-colored clique.

References
Bartholdi, III, J. J., Tovey, C. A., & Trick, M. A. (1992). hard control
election. Mathematical Computer Modelling, 16 (89), 2740.
649

fiBredereck, Faliszewski, Niedermeier, & Talmon

Baumeister, D., Faliszewski, P., Lang, J., & Rothe, J. (2012). Campaigns lazy voters:
Truncated ballots. Proceedings 11th International Conference Autonomous
Agents Multiagent Systems (AAMAS 12), pp. 577584. IFAAMAS.
Betzler, N., Bredereck, R., Chen, J., & Niedermeier, R. (2012). Studies computational
aspects votinga parameterized complexity perspective. Multivariate Algorithmic Revolution Beyond, Vol. 7370 LNCS, pp. 318363. Springer.
Binkele-Raible, D., Erdelyi, G., Fernau, H., Goldsmith, J., Mattei, N., & Rothe, J. (2014).
complexity probabilistic lobbying. Discrete Optimization, 11, 121.
Boutilier, C., Brafman, R. I., Hoos, C. D. H. H., & Poole, D. (2004). CP-nets: tool
representing reasoning conditional ceteris paribus preference statements.
Journal Artificial Intelligence Research, 21, 135191.
Brandt, F., Harrenstein, P., Kardel, K., & Seedig, H. G. (2013). takes few:
hardness voting constant number agents. Proceedings 12th International Conference Autonomous Agents Multiagent Systems (AAMAS 13),
pp. 375382. IFAAMAS.
Bredereck, R., Chen, J., Faliszewski, P., Nichterlein, A., & Niedermeier, R. (2014a). Prices
matter parameterized complexity shift bribery. Proceedings 28th
AAAI Conference Artificial Intelligence (AAAI 14), pp. 13981404. AAAI Press.
Bredereck, R., Chen, J., Hartung, S., Kratsch, S., Niedermeier, R., Suchy, O., & Woeginger,
G. (2014b). multivariate complexity analysis lobbying multiple referenda.
Journal Artificial Intelligence Research, 50, 409446.
Bredereck, R., Faliszewski, P., Niedermeier, R., Skowron, P., & Talmon, N. (2015a). Elections candidates: Prices, weights, covering problems. Fourth
International Conference Algorithmic Decision Theory (ADT 2015), Vol. 9346
LNCS, pp. 414431. Springer.
Bredereck, R., Faliszewski, P., Niedermeier, R., & Talmon, N. (2015b). Large-scale election campaigns: Combinatorial shift bribery. Proceedings 14th International
Conference Autonomous Agents Multiagent Systems (AAMAS15), pp. 6775.
Bredereck, R., Faliszewski, P., Niedermeier, R., & Talmon, N. (2016). Complexity shift
bribery committee elections. Proceedings Twenty-Ninth AAAI Conference
Artificial Intelligence (AAAI 16).
Bulteau, L., Chen, J., Faliszewski, P., Niedermeier, R., & Talmon, N. (2015). Combinatorial
voter control elections. Theoretical Computer Science, 589, 99120.
Cary, D. (2011). Estimating margin victory instant-runoff voting. Presented
2011 Electronic Voting Technology Workshop/Workshop Trustworthy Elections.
Chen, J., Faliszewski, P., Niedermeier, R., & Talmon, N. (2015). Elections voters: Candidate control easy. Proceedings 29th AAAI Conference
Artificial Intelligence (AAAI 15), pp. 20452051.
Christian, R., Fellows, M. R., Rosamond, F. A., & Slinko, A. (2007). complexity
lobbying multiple referenda. Review Economic Design, 11 (3), 217224.
650

fiCombinatorial Shift Bribery

Conitzer, V., Lang, J., & Xia, L. (2009). hard control sequential elections via
agenda?. Proceedings 21st International Joint Conference Artificial
Intelligence (IJCAI 10), pp. 103108. AAAI Press.
Dorn, B., & Schlotter, I. (2012). Multivariate complexity analysis swap bribery. Algorithmica, 64 (1), 126151.
Downey, R. G., & Fellows, M. R. (2013). Fundamentals Parameterized Complexity.
Springer.
Elkind, E., & Faliszewski, P. (2010). Approximation algorithms campaign management.
Proceedings 6th International Workshop Internet Network Economics
(WINE 10), Vol. 6484 LNCS, pp. 473482. Springer.
Elkind, E., Faliszewski, P., & Slinko, A. (2009). Swap bribery. Proceedings 2nd
International Symposium Algorithmic Game Theory (SAGT 09), Vol. 5814
LNCS, pp. 299310. Springer.
Faliszewski, P., Hemaspaandra, E., & Hemaspaandra, L. (2010). Using complexity protect
elections. Communications ACM, 53 (11), 7482.
Faliszewski, P., Hemaspaandra, E., & Hemaspaandra, L. A. (2009a). hard bribery
elections?. Journal Artificial Intelligence Research, 35, 485532.
Faliszewski, P., Hemaspaandra, E., Hemaspaandra, L. A., & Rothe, J. (2009b). Llull
Copeland voting computationally resist bribery constructive control. Journal
Artificial Intelligence Research, 35, 275341.
Faliszewski, P., Reisch, Y., Rothe, J., & Schend, L. (2014). Complexity manipulation,
bribery, campaign management Bucklin Fallback voting. Proceedings
13th International Conference Autonomous Agents Multiagent Systems
(AAMAS 14), pp. 13571358. IFAAMAS.
Faliszewski, P., & Rothe, J. (2015). Control bribery voting. Brandt, F., Conitzer,
V., Endriss, U., Lang, J., & Procaccia, A. D. (Eds.), Handbook Computational
Social Choice, chap. 7. Cambridge University Press.
Flum, J., & Grohe, M. (2006). Parameterized Complexity Theory. Springer.
Gabow, H. N. (1983). efficient reduction technique degree-constrained subgraph
bidirected network flow problems. Proceedings 15th Annual ACM Symposium
Theory Computing (STOC 83), pp. 448456. ACM.
Garey, M. R., & Johnson, D. S. (1979). Computers Intractability: Guide Theory
NP-Completeness. Freeman.
Hazon, N., Lin, R., & Kraus, S. (2013). change groups collective decision?.
Proceedings 23rd International Joint Conference Artificial Intelligence
(IJCAI 13), pp. 198205. AAAI Press.
Hulett, H., Will, T. G., & Woeginger, G. J. (2008). Multigraph realizations degree
sequences: Maximization easy, minimization hard. Operations Research Letters,
36 (5), 594596.
651

fiBredereck, Faliszewski, Niedermeier, & Talmon

Lang, J., & Xia, L. (2015). Voting combinatorial domains. Brandt, F., Conitzer, V.,
Endriss, U., Lang, J., & Procaccia, A. D. (Eds.), Handbook Computational Social
Choice, chap. 9. Cambridge University Press.
Lenstra, H. W. (1983). Integer programming fixed number variables. Mathematics
Operations Research, 8 (4), 538548.
Magrino, T., Rivest, R., Shen, E., & Wagner, D. (2011). Computing margin victory IRV elections. Presented 2011 Electronic Voting Technology Workshop/Workshop Trustworthy Elections.
Mathieson, L., & Szeider, S. (2012). Editing graphs satisfy degree constraints: parameterized approach. Journal Computer System Sciences, 78 (1), 179191.
Mattei, N., Goldsmith, J., & Klapper, A. (2012a). complexity bribery manipulation tournaments uncertain information. Proceedings 25th International Florida Artificial Intelligence Research Society Conference (FLAIRS 12),
pp. 549554. AAAI Press.
Mattei, N., Pini, M., Rossi, F., & Venable, K. (2012b). Bribery voting combinatorial
domains easy. Proceedings 11th International Conference Autonomous
Agents Multiagent Systems (AAMAS 12), pp. 14071408. IFAAMAS.
Niedermeier, R. (2006). Invitation Fixed-Parameter Algorithms. Oxford University Press.
Obraztsova, S., & Elkind, E. (2011). complexity voting manipulation
randomized tie-breaking. Proceedings 22nd International Joint Conference
Artificial Intelligence (IJCAI 11), pp. 319324. AAAI Press.
Obraztsova, S., Elkind, E., & Hazon, N. (2011). Ties matter: Complexity voting manipulation revisited. Proceedings 10th International Conference Autonomous
Agents Multiagent Systems (AAMAS 11), pp. 7178.
Rajagopalan, S., & Vazirani, V. V. (1998). Primal-dual RNC approximation algorithms
set cover covering integer programs. SIAM Journal Computing, 28 (2),
525540.
Reisch, Y., Rothe, J., & Schend, L. (2014). margin victory Schulze, Cup,
Copeland elections: Complexity regular exact variants. Proceedings
Seventh European Starting AI Researcher Symposium (STAIRS-2014), pp. 250259.
IOS Press.
Schlotter, I., Faliszewski, P., & Elkind, E. (2011). Campaign management approvaldriven voting rules. Proceedings 25th AAAI Conference Artificial Intelligence (AAAI 11), pp. 726731. AAAI Press.
Xia, L. (2012). Computing margin victory various voting rules. Proceedings
13th ACM Conference Electronic Commerce (EC 12), pp. 982999. ACM
Press.

652


