Journal Artificial Intelligence Research 55 (2016) 889-952

Submitted 9/15; published 4/16

Searching Best Solutions Graphical Models
Natalia Flerova

NFLEROVA @ UCI . EDU

University California, Irvine
Irvine, CA 92697, USA

Radu Marinescu

RADU . MARINESCU @ IE . IBM . COM

IBM Research Ireland

Rina Dechter

DECHTER @ UCI . EDU

University California, Irvine
Irvine, CA 92697, USA

Abstract
paper focuses finding best solutions combinatorial optimization problems
using best-first depth-first branch bound search. Specifically, present new algorithm mA*, extending well-known A* m-best task, first time prove desirable
properties, including soundness, completeness optimal efficiency, maintained. Since bestfirst algorithms require extensive memory, extend memory-efficient depth-first branch
bound m-best task.
adapt algorithms optimization tasks graphical models (e.g., Weighted CSP
MPE Bayesian networks), provide complexity analysis empirical evaluation. experiments confirm theory best-first approach largely superior memory available,
depth-first branch bound robust. show algorithms competitive
related schemes recently developed m-best task.

1. Introduction
usual aim combinatorial optimization find optimal solution, minimum maximum,
objective function. However, many applications desirable obtain single
optimal solution, set first best solutions integer m. motivated
many real-life domains, task arises. instance, problem finding likely
haplotype pedigree presented finding probable assignment Bayesian
network encodes genetic information (Fishelson, Dovgolevsky, & Geiger, 2005). practice data often corrupted missing, makes single optimal solution unreliable.
possible increase confidence answer finding set best solutions
choosing final solution expert help obtaining additional genetic data.
examples m-best tasks arise procurement auction problems probabilistic expert systems, certain constraints often cannot directly incorporated model, either
make problem infeasibly complex vague formalize (e.g. idiosyncratic
preferences human user). Thus domains may practical first find several
good solutions relaxed problem pick one satisfies additional constraints
post-processing manner. Additionally, sometimes set diverse assignments approximately
cost required, reliable communication network design. Finally, context
summation problem graphical models, probability evidence partition function,
approximation derived summing likely tuples.
c
2016
AI Access Foundation. rights reserved.

fiF LEROVA , ARINESCU , & ECHTER

problem finding best solutions well studied. One earliest
influential works belongs Lawler (1972). provided general scheme extends
optimization algorithm m-best task. idea compute next best solution successively
finding single optimal solution slightly different reformulation original problem
excludes solutions generated far. approach extended improved
years still one primary strategies finding best solutions. approaches
direct, trying avoid repeated computation inherent Lawlers scheme. Two earlier
works relevant provide highest challenge work Nilsson (1998)
Aljazzar Leue (2011).
Nilsson proposed junction-tree based message-passing scheme iteratively finds
best solutions. claimed best runtime complexity among m-best schemes
graphical models. analysis (Section 6) shows indeed Nilssons scheme second
best worst case time complexity algorithm BE+m-BF (Section 5.3). However,
practice scheme feasible problems large induced width.
recent work Aljazzar Leue proposed algorithm called K*, A* search-style
scheme finding k shortest paths interleaved breadth-first search. used
specialized data structure unclear approach straightforwardly extended
graphical models, point leave future work.
One popular approximate approaches solving optimization problems based
LP-relaxation problem (Wainwright & Jordan, 2003). m-best extension approach
(Fromer & Globerson, 2009) guarantee exact solutions, quite efficient practice.
discuss previous works Section 6.
main focus lies optimization context graphical models, Bayesian networks, Markov networks constraint networks. However, algorithms developed
used general purpose tasks, finding shortest paths graph. Various
graph-exploiting algorithms solving optimization tasks graphical models developed
past decades. algorithms often characterized either inference type
(e.g., message-passing schemes, variable elimination) search type (e.g., AND/OR search
recursive-conditioning). earlier works, (e.g., Flerova, Dechter, & Rollon, 2011), extended
inference schemes represented bucket elimination algorithm (BE) (Dechter, 1999, 2013)
task finding best solutions. However, due large memory requirements, variable
elimination algorithms, including bucket elimination, cannot used practice finding exact
solutions combinatorial optimization tasks problems graph dense. Depth-first branch
bound (DFBnB) best-first search (BFS) flexible trade space time.
work explores question solving best solutions task using heuristic search schemes.
contribution lies extending heuristic algorithms best solutions task. describe general purpose m-best variants depth-first branch bound best-first search,
specifically A*, yielding algorithms m-BB m-A* respectively, analyze properties. show m-A* inherits A*s desirable properties (Dechter & Pearl, 1985),
significantly optimally efficient compared alternative exact search-based scheme.
discuss size search space explored m-BB. extend new m-best algorithms graphical models exploring AND/OR search space.
evaluate resulting algorithms 6 benchmarks 300 instances total,
examine impact number solutions algorithms behaviour. particular,
890

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

observe runtime schemes (except depth-first branch bound
exploring AND/OR tree) scales much better worst case theoretical analysis
suggests.
show m-A* search using exact bucket elimination heuristic (a scheme
call BE+m-BF) highly efficient easier problems suffers severely memory issues
denser graphs, far A*-based schemes using approximate mini-bucket heuristics. Finally, compare schemes efficient algorithms based
LP-relaxation (Fromer & Globerson, 2009; Batra, 2012), showing competitiveness even superiority large values (m 10), providing optimality guarantees.
paper organized follows. Section 2 provide relevant background. Section 3
presents extension best-first search m-best task. particular, define m-A*,
extension A* algorithm finding best solutions (3.1), prove main properties (3.2).
Section 4 describes algorithm m-BB, extension depth-first branch bound algorithm
solving m-best task. Section 5 discuss adaptation two newly proposed m-best
search algorithms AND/OR search spaces graphical models, including hybrid method
BE+m-BF incorporates variable elimination heuristic search. Section 6 elaborates
related work contrasts methods. Section 7 presents empirical evaluation
m-best schemes Section 8 concludes.

2. Background
begin formally defining graphical models framework providing background
heuristic search.
2.1 Graphical Models
denote variables upper-case letters (e.g., X, Y, Z) values variables lower-case
letters (e.g., x, y, z). Sets variables denoted upper-case letters bold (e.g. X, Y, Z).
assignment (X1 = x1 , . . . , Xn = xn ) abbreviated x = (x1 , . . . , xn ).
denote functions letters f, g, h etc., set functions byPF. function f
scope S1 = {X1 , . . . , Xr } denoted fS1 . P
summation
P operator xX defines sum
possible values variables X, namely x1 X1 , . . . , xn Xn . Minimization minxX
maximization maxxX operators defined similar manner. Note use terms elimination
P
marginalization interchangeably.
convenience sometimes use minx (maxx , x )
P
denote minxX (maxxX , xX ).
graphical model collection local functions subsets variables conveys probabilistic, deterministic, preferential information, whose structure described graph.
graph captures independencies irrelevance information inherent model, useful
interpreting modeled data and, significantly, exploited reasoning algorithms.
set local functions combined variety ways generate global function, whose
scope set variables.
N
EFINITION 1 (Graphical model). graphical model 4-tuple = hX, D, F, i:
1. X = {X1 , . . . , Xn } finite set variables;

2. = {D1 , . . . , Dn } set respective finite domains values;
891

fiF LEROVA , ARINESCU , & ECHTER

3. F = {f1 , . . . , fr } set non-negative real-valued discrete functions, defined scopes
variables Si X. called local functions.
N
N
Q P
4.
combination operator, e.g.,
{ , } (product, sum)
graphical model represents
global function, whose scope X combination
N
local functions: rj=1 fj .
N
P
N
= Qand : DSi N Weighted Constraint Satisfaction Problems (WCSPs).
=
= Pi (Xi | pai ) Bayesian network. probabilities P
defined relative directed acyclic graph G X, set Xi1 , . . . , Xik parents
pai Xi , i.e. Xij edge pointing Xij Xi . illustration, consider
Bayesian network 5 variables whose directed acyclic graph (DAG) given Figure 1(a).
common optimization task Bayesian network probable explanation
(MPE) known maximum posteriori hypothesis (MAP),1 goal compute
optimal value
r


C = max
fj (xSj )
x

j=1

optimizing configuration


x = argmax
x

r


fj (xSj )

j=1

related task, typical WCSP,
min-sum, namely computing minimal cost
P
P assignment (min-sum): C = minx j fj (x) optimizing configuration x = argminx j fj (x).
Historically task sometimes referred energy Q
minimization. equivalent

MPE/MAP task following sense: Cmax
= maxx j fj (x) solution MPE




problem,
P Cmax = exp (Cmin ), Cmin solution min-sum problem Cmin =
minx j gj (x) j, gj (x) = log (fj (x)).
graphical model defines primal graph captures dependencies problems
variables. variables vertices. edge connects two vertices whose variables appear
scope function. important property graphical model, characterizing
complexity reasoning tasks induced width. ordered graph pair (G, o)
G undirected graph, = (X1 , . . . , Xn ) ordering nodes. width node
number nodes neighbors precede ordering. width graph along
ordering maximum width nodes. induced ordered graph obtained
ordered graph follows: nodes processed last first based o; node Xj
processed, preceding neighbors connected. width ordered induced graph along
ordering called induced width along denoted w (o). induced width
graph, denoted w , minimal induced width orderings. Abusing notation
sometimes use w denote induced width along particular ordering, meaning
clear context.
Figure 1(b) depicts primal graph Bayesian network Figure 1(a). Figures 1(c)
1(d) show induced graphs primal graph Figure 1(a) respectively along orderings
1. communities MAP refers task optimizing partial assignment variables. However,
paper use MAP MPE interchangeable, referring optimal full variable assignment.

892

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

P (A)





B

E

C





C

E

B





(c)

(d)

P (B|A)

B

C

B

C

P (C|A)

E

E

P (E|B, C)





P (D|A, B)

(a)

(b)

Figure 1: (a) DAG Bayesian network, (b) primal graph (also called moral graph),
(c) induced graph along = (A, E, D, C, B), (d) induced graph along
= (A, B, C, D, E), example Gogate (2009).

= (A, E, D, C, B) o0 = (A, B, C, D, E). dashed lines Figure 1(c) represent
induced edges, namely edges absent moral graph, introduced
induced graph. see induced width along ordering w (o) = 4 induced
width along ordering o0 w (o0 ) = 2, respectively.
2.2 Heuristic Search
analysis focuses best-first search (BFS), whose behaviour task finding single
optimal solution well understood. Assuming minimization task, best-first search always expands
node best (i.e., smallest) value heuristic evaluation function. maintains graph
explored paths, list CLOSED expanded nodes frontier OPEN nodes. BFS chooses
OPEN node n smallest value heuristic evaluation function f (n), expands
generating successors succ(n), places CLOSED, places succ(n) OPEN.
popular variant best-first search, A*, uses heuristic evaluation function f (n) = g(n) + h(n),
g(n) cost path root n, h(n) heuristic function estimates
optimal cost go h (n) n goal node. heuristic function called admissible
never overestimates (for minimization) true minimal cost reach goal h (n). Namely,
n h(n) h (n). heuristic called consistent monotonic, every node n every
successor n0 n following inequality holds: h(n) c(n, n0 ) + h(n0 ). h(n) consistent,
values evaluation function f (n) along path non-decreasing. known
regardless tie-breaking rule A* expands node n reachable strictly C -bounded path
root, node referred surely expanded A* (Dechter & Pearl, 1985).
path C -bounded relative f , n : f (n) < C , C cost optimal
solution.
A* search number attractive properties (Nillson, 1980; Pearl, 1984; Dechter & Pearl,
1985):
893

fiF LEROVA , ARINESCU , & ECHTER

Soundness completeness: A* terminates optimal solution.
h consistent, A* explores set nodes = {n|f (n) C } surely
expands nodes = {n|f (n) < C }.
Optimal efficiency consistent heuristic: h consistent, node surely expanded A* must expanded sound complete search algorithm using
heuristic information.
Optimal efficiency node expansions: heuristic function consistent, A*,
searching graph, expands node once, time nodes expansion
A* found shortest path it.
Dominance: Given two heuristic functions h1 h2 , s.t. n h1 (n) < h2 (n), A1 expand
every node surely expanded A2 , Ai uses heuristic hi .
Although best-first search known best algorithm terms number nodes expanded (Dechter & Pearl, 1985), requires exponential memory worst-case.
popular alternative depth-first branch bound (DFBnB), whose attractive feature, compared best-first search, executed linear memory. Yet,
search space graph, exploit memory improve performance flexibly trading space
time. Depth-first branch bound expands nodes depth-first manner, maintaining cost
best solution found far upper bound U B cost optimal solution.
heuristic evaluation function current node n greater equal upper bound,
node pruned subtree never explored. worst case depth-first branch
bound explores entire search space. best case first solution found optimal,
case performance good BFS. However, solution depth unbound, depth-first
search might follow infinite branch never terminate. Also, search space graph,
DFBnB may expand nodes numerous time, unless uses caching checks duplicates.
2.3 Search Graphical Models
Search algorithms provide way systematically enumerate possible assignments given
graphical model. Optimization problems graphical models naturally presented
task finding optimal cost path appropriate search space.
simplest variant search space so-called search tree. level corresponds
variable original problem. nodes correspond partial variable assignments
arc weights derived problems input functions. size search tree bounded
O(k n ), n number variables k maximum domain size.
Throughout section going illustrate concepts using example problem
six variables {A, B, C, D, E, F } six pairwise functions. primal graph shown Figure
2(a). Figure 2(b) displays search tree corresponding lexicographical ordering.
2.3.1 AND/OR EARCH PACES
search trees blind problem decomposition encoded graphical models therefore inefficient. exploit independencies model. AND/OR search spaces
894

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

(a) Primal
graph

(b) search tree along ordering A, B, C, D, E, F

Figure 2: example problem 6 variables {A, B, C, D, E, F } 5 pairwise functions.
graphical models introduced better capture problem structure (Dechter & Mateescu, 2007). AND/OR search space defined relative pseudo tree primal graph
captures problem decomposition. Figure 3(a) shows pseudo tree example problem.
EFINITION 2. pseudo tree undirected graph G = (V, E) directed rooted tree =
(V, E 0 ), every arc G included E 0 back-arc , namely connects node
ancestor . arcs E 0 may included E.
Given graphical model = hX, D, primal graph G pseudo tree G,
AND/OR search tree ST contains alternating levels nodes. structure based
underlying pseudo tree . root node ST node labelled variable
root . children node Xi nodes labelled value assignments hXi , xi
(or simply hxi i). children node hXi , xi nodes labelled children
Xi , representing conditionally independent subproblems. AND/OR tree corresponding
pseudo tree Figure 3(a) shown Figure 3(b). arcs nodes Xi hXi , xi
AND/OR search tree annotated weights derived cost functions F:
EFINITION 3 (arc weight). weight w(Xi , xi ) arc (Xi , hXi , xi i) combination (i.e.
sum WCSP product MPE) functions, whose scope includes Xi fully
assigned along path root node corresponding hXi , xi i, evaluated values
along path.
identical subproblems identified context (namely, partial instantiation
ancestors separates subproblem rest problem graph), merged,
yielding AND/OR search graph (Dechter & Mateescu, 2007). Merging context-mergeable
nodes yields context-minimal AND/OR search graph, denoted CT . example seen
Figure 3(c). size context-minimal AND/OR search graph shown exponential
induced width G along pseudo tree (Dechter & Mateescu, 2007).
solution tree CT subtree that: (1) contains root node CT ; (2)
internal node n , children ; (3) internal node n ,
exactly one children ; (4) every tip node (i.e., nodes children)
terminal node. cost solution tree product, MPE sum WCSP, weights
associated arcs.
node n CT associated value v(n) capturing optimal solution cost
conditioned subproblem rooted n. Assuming MPE/MAP problem, shown v(n)
895

fiF LEROVA , ARINESCU , & ECHTER






0

1



B

B



0

1

0

1



C



B
C

E



F



0



C

E
1

0

1



F

F

0

0 1 0 1 0 1 0 1

E

C

1

0

1



F

F

0

0 1 0 1 0 1 0 1

(a) Pseudo tree

1

0

1



F

F

0

E
1

0

1



F

F

0 1 0 1 0 1 0 1

0 1 0 1 0 1 0 1

(b) AND/OR search tree






0

1



B

B



0

1

C

C




C

E

0

1

0

0

C

C
1

0

1

0

1

E
1

0

E
1

0

E

E
1

0

1

0

1











F

F

F

F



0 1

0 1

0 1

0 1

0 1

0 1

0 1

0 1

(c) Context-minimal AND/OR search graph

Figure 3: AND/OR search spaces graphical models.

computed recursively based values ns successors: nodes maximization,
nodes multiplication. WCSPs, v(n) nodes updated minimization
summation, respectively (Dechter & Mateescu, 2007).
next provide overview depth-first branch bound best-first search algorithms,
explore AND/OR search spaces (Marinescu & Dechter, 2009b, 2009a; Otten & Dechter, 2011).
schemes use heuristics generated either mini-bucket elimination scheme (2.3.4)
soft arc-consistency schemes (Marinescu & Dechter, 2009a, 2009b; Schiex, 2000; Darwiche, Dechter, Choi, Gogate, & Otten, 2008) composite (Ihler, Flerova, Dechter, & Otten,
2012). customary heuristic search literature, defining search algorithms
assume without loss generality minimization task (i.e., min-sum optimization problem).
896

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

Algorithm 1: AOBF exploring AND/OR search tree (Marinescu & Dechter, 2009b)

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23

24
25
26
27
28
29
30
31
32

Input: graphical model = hX, D, Fi, pseudo tree rooted X1 , heuristic function h()
Output: Optimal solution
Create root node labelled X1 let G (explored search space) = {s};
Initialize v(s) = h(s) best partial solution tree G;
SOLVED
Select non-terminal tip node n . node break;
n node labeled Xi
forall xi D(Xi )
Create child n0 = hXi , xi i;
n TERMINAL
Mark n0 SOLVED;
succ(n) succ(n) n0 ;
else n node labeled hXi , xi
forall successor Xj Xi
Create child n0 = Xj ;
succ(n) succ(n) n0 ;
Initialize v(n0 ) = h(n0 ) new nodes;
Add new nodes explores search space G G {succ(n)};
Let {n};
6=
Let p node descendants G still S;
{p};
p node
v(p) = minksucc(p) (w(p, k) + v(k));
Mark best successor k ancestors p, k = arg minksucc(p) (w(p, k) + v(k))
(maintaining previously marked successor still best);
Mark p SOLVED best marked successor solved;
else p
P node
v(p) = ksucc(p) v(k);
Mark arcs successors;
Mark p SOLVED children SOLVED;
p changes value p marked SOLVED
Add parents p p one successors marked arc;
Recompute following marked arcs root s;
return hv(s), i;

2.3.2 B EST-F IRST AND/OR EARCH
state-of-the-art version best-first search AND/OR search spaces graphical models
Best-First AND/OR search algorithm (AOBF) (Marinescu & Dechter, 2009b). AOBF
variant AO* (Nillson, 1980) explores context-minimal AND/OR search graph.
AOBF described Algorithm 1. simplicity, present algorithm traversing
AND/OR search tree. AOBF maintains explicated part search space G keeps
track current best partial solution tree . interleaves iteratively top-down node expansion
step (lines 4-16), selects non-terminal tip node generates children G,
bottom-up cost revision step (lines 17-30), updates values internal nodes based
childrens values. newly generated child node terminal marked solved (line 9).
897

fiF LEROVA , ARINESCU , & ECHTER

bottom-up phase, nodes least one solved child nodes
children solved marked solved. algorithm marks arc best
child node minimum achieved (line 23). Following backward
step, new best partial solution tree recomputed (line 31). AOBF terminates root
node marked solved. heuristic used admissible, point termination
optimal solution cost v(s), root node search space.
Extending algorithm explore context-minimal AND/OR search graph straightforward done follows. expanding non-terminal node lines 11-14, AOBF
generate corresponding children already present explicated search
space G rather links them. identical nodes G easily recognized based
contexts (Marinescu & Dechter, 2009b).
HEOREM 1 (complexity, Marinescu & Dechter, 2009b). Algorithm AOBF traversing context
minimal AND/OR graph time space complexity O(n k w ), n number
variable problem, w induced width pseudo tree k bounds domain size.
2.3.3 EPTH -F IRST AND/OR B RANCH B OUND
depth-first AND/OR Branch Bound (AOBB) (Marinescu & Dechter, 2009a) algorithm
traverses AND/OR search space depth-first rather best-first manner, keeping
track current upper bound minimal solution cost.
simplicity, present variant algorithm explores AND/OR
search tree. AOBB described Algorithm 2 interleaves forward node expansion (lines 4-17)
backward cost revision (or propagation) step (lines 19-29) updates node values (capturing
current best solution subproblem rooted node), search terminates
optimal solution found. node n pruned (lines 12-13) current upper bound
higher nodes heuristic lower bound, computed recursively using procedure described
Algorithm 3.

worst case, AOBB explores entire search space, namely O(n k w ) nodes (assuming
context-minimal AND/OR search graph). practice, however, AOBB likely expand
nodes AOBF using heuristic, empirical performance AOBB depends heavily
order solutions encountered, namely quickly algorithm finds
close optimal solution use upper bound pruning.
2.3.4 INI -B UCKET H EURISTICS
AND/OR search algorithms presented (AOBF AOBB) often use mini-bucket
(also known MBE) heuristic h(n). Mini-Bucket Elimination MBE (Dechter & Rish, 2003)
approximate version exact variable elimination algorithm called bucket elimination (BE)
(Dechter, 1999). MBE (Algorithm 4) bounds space time complexity full bucket elimination (which exponential induced width w ). Given variable ordering, algorithm
associates variable Xi bucket contains functions defined variable,
higher index variables. Large buckets partitioned smaller subsets, called minibuckets, containing distinct variables. parameter called i-bound.
algorithm processes buckets last first (lines 2-10 Algorithm 4). mini-buckets
variable processed separately. Assuming min-sum problem, MBE calculates sum
898

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

Algorithm 2: AOBB exploring AND/OR search tree (Marinescu & Dechter, 2009b)

1
2
3
4
5
6
7
8
9
10
11

12
13

Input: graphical model = hX, D, Fi, pseudo tree rooted X1 , heuristic function h();
Output: Optimal solution
Create root node labelled X1 let stack created expanded nodes OP EN {s};
Initialize v(s) best partial solution tree rooted (s) ; U B ;
OP EN 6=
Select top node n OPEN;
n node labeled Xi
foreach xi D(Xi )
Add child n0 labeled hXi , xi list successors n;
Initialize v(n0 ) = 0, best partial solution tree rooted n (n0 ) = ;
n node labelled hXi , xi
foreach ancestor k n
Recursively evaluate cost partial solution tree rooted k, based heuristic function
h(), assign cost f (k); // see Algorithm 3
evaluated partial solution better current upper bound k (e.g. f (k) v(k)
Prune subtree current tip node n;
else

14

foreach successor Xj Xi
Add child n0 labeled Xj list successors n;
Initialize v(n0 ) , best partial solution tree rooted n, (n0 ) ;

15
16
17

18
19
20
21
22
23
24
25
26
27

28
29

Add successors n top OPEN;
list successors node n empty
node n root node
return solution: v(n), (n) ;
else
p node
v(p) v(p) + v(n), (p) (p) (n);
else p node
new value better old one, e.g. v(p) > (c(p, n) + v(n)) minimization
v(p) w(p, n) + v(n), (p) (p) hxi , Xi i;
Remove n list successors p;
Move one level up: n p;

functions mini-bucket eliminates variable using min operator (line 9).
new function placed appropriate lower bucket (line 10). MBE generates bound (lower
minimization upper maximization) optimal value. Higher values take computational resources, yield accurate bounds. large enough (i.e., w ), MBE
coincides full Bucket Elimination.
HEOREM 2 (complexity, Dechter & Rish, 2003). Given graphical model variable ordering
induced width w (o) i-bound parameter i, time mini-bucket algorithm


MBE(i) O(nk min(i,w (o))+1 ) space complexity O(nk min(i,w (o)) ), n number
problem variables k maximum domains size.
Mini-bucket elimination viewed message passing leaves root along minibucket tree. mini-bucket tree graphical model mini-buckets nodes. BucketX
899

fiF LEROVA , ARINESCU , & ECHTER

Algorithm 3: Recursive computation heuristic evaluation function
1

2
3
4

function evalPartialSolutionTree(T (n), h(n))
Input: Partial solution subtree (n) rooted node n, heuristic function h(n);
Output: Heuristic evaluation function f (T (n));
succ(n) ==
n node
return 0;
else

5

return h(n);

6
7
8
9
10
11
12
13

else
n node
let k1 , . . . , kl children n;
P
return li=1 evalPartialSolutionTree(T (ki ), h(ki ));
else n node
let k child n;
return w(n, k) + evalPartialSolutionTree(T (k), h(k));

Algorithm 4: Mini-Bucket Elimination

1

2
3
4
5
6
7
8
9
10

11

12

Input: model = hX, D, Fi, ordering o, parameter
Output: Approximate solution M, ordered augmented buckets
Initialize: Partition functions F Bucket1 , . . . , Bucketn , Bucketi contains functions
whose highest variable Xi .
// Backward pass
p n downto 1
Let h1 , . . . , hj functions (original intermediate) Bucketp ; let S1 , . . . , Sj scopes;
Xp instantiated (Xp = xp )
Assign Xp = xp hi put resulting function appropriate bucket;
else
Generate i-partitioning;
foreach Qk Q0
P
Generate message function hkb : hkb = minxp Xp ji=1 hi ;
Add hkb bucket Xb , largest-index variable scope(hkb );
// Forward pass
Assign value variable ordering combination functions bucket
minimal;
return function computed bucket first variable corresponding assignment;

child BucketY function hXY generated BucketX variable X eliminated,
placed BucketY . Therefore, every vertex root one parent possibly
several child vertices. Note mini-bucket tree corresponds pseudo tree, minibuckets variables combined form call augmented buckets, corresponding
variable nodes (Dechter & Mateescu, 2007).
Mini-bucket elimination often used generate heuristics search algorithms graphical
models, formulated search spaces Kask Dechter (1999a, 1999b) extended
AND/OR search Marinescu Dechter (2005).
900

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

EFINITION 4 (MBE heuristic AND/OR search space, Marinescu & Dechter, 2005). Given
ordered set augmented buckets {B(X1 ), . . . , B(Xn )} generated Mini-Bucket algorithm
BE(i) along bucket tree , given node n AND/OR search tree, static minibucket heuristic function h(n) computed follows:
1. n node, labeled hXp , xp i, then:
X
h(n) =
hkj
hkj {B(Xp )B(Xp1 ...Xpq )}

Namely, sum intermediate functions hkj satisfy following two properties:
generated buckets B(Xk ), Xk descendant Xp bucket tree
reside bucket B(Xp ) bucket B(Xp1 . . . Xpq ) = {B(Xp1 ), . . . , B(Xpq )} correspond ancestors {Xp1 ), . . . , Xpq } Xp
2. n node, labeled Xp , then:
h(n) =

min

msucc(p)

(w(n, m) + h(m))

children n labeled values xp Xp .
established necessary background, turn main part paper,
presenting contributions, beginning extension best-first search m-best task.
customary heuristic search literature without loss generality, assume
remaining paper min-sum optimization problem.

3. Best-First Search Finding Best Solutions
Extending best-first search (Section 2.2) particular popular version, A*, mbest task fairly straightforward suggested, example, Charniak Shimony (1994).
Instead stopping finding optimal solution, algorithm continues exploring search
space, reporting next discovered solutions obtained. show
solutions indeed best found decreasing order optimality.
particular, second solution reported second best solution and, general, ith solution
discovered ith best.
3.1 m-A*: Definition
m-best tree-search variant A* denoted m-A* (Algorithm 5, assumes consistent heuristic)
solves m-best optimization problem general search graph. show later
extended general admissible heuristics.
scheme expands nodes order increasing value f usual A* manner.
keeps lists created nodes OPEN expanded nodes CLOSED, usual, maintaining
search tree, denoted r. Beginning start node s, m-A* picks node smallest
evaluation function f (n) OPEN puts CLOSED (line 7). node goal, new
solution reported (lines 8-13). Otherwise, node expanded children created (lines
15-23). algorithm may encounter node multiple times maintain
901

fiF LEROVA , ARINESCU , & ECHTER

Algorithm 5: m-A* exploring graph, assuming consistent heuristic

1
2
3
4
5
6
7

8
9

10
11

Input: implicit directed search graph G = (N, E), start node set goal nodes Goals,
consistent heuristic evaluation function h(n), parameter
Output: best solutions
Initialize: OPEN=, CLOSED=, tree r = , = 1 (i counts current solution searched for)
OPEN {s}; f (s) = h(s);
Make root r;

OPEN empty
return solutions found far;
Remove node, denoted n, OPEN minimum f (break ties arbitrarily, favour goal nodes
deeper nodes) put CLOSED;
n goal node
Output current solution obtained tracing back pointers n (pointers assigned step
22); denote solution Soli ;
=
return;
else

12

+ 1;

13
14
15
16
17
18
19
20
21
22
23

24

else
Expand node n, generating children Ch ;
foreach n0 Ch
n0 already appears OPEN CLOSED times
Discard node n0 ;
else
Compute current path cost g(n0 ) = g(n) + c(n, n0 );
Compute evaluation function f (n0 ) = g(n0 ) + h(n0 ) ;
Attach pointer n0 back n r;
Insert n0 right place OPEN based f (n0 );
return set best solutions found

copies OPEN CLOSED lists combined (line 17), separate paths copy
explored search tree (lines 22-23). Nodes encountered beyond times discarded (line 18).
denote Ci ith best solution cost, (n) cost ith best solution going node
n, (n) heuristic evaluation function estimating (n) gi (n) hi (n) estimates
ith best costs n n goal, respectively.
heuristic consistent, whenever algorithm reaches node seen (if
search space graph tree), exists possibility new path improving
previously discovered ones. Therefore, lines 17-18 revised following way
account possibility better path n0 discovered:
17
n0 appears already times union OPEN CLOSED
18
g(n0 ) strictly smaller gm (n0 ), current m-best path n0
19
Keep n0 pointer n put n back OPEN
20
Discard earlier subtree rooted n
Figure 4 shows example m-A* finding = 3 shortest paths toy problem.
left hand side Figure 4 shows problem graph 7 variables 8 edges, together
902

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS


3

h(A) = 5

2

h(B) = 4



order
nodes expanded

#1

h(C) = 2

B

#5

C

B f =6

h(D) = 3

C2
C3

1

2

#8



D2

4

#2

m=3
C1 = 8

C f =4

= 10
= 10

#3
D1 f = 6

f =8

2
h(F ) = 1

h(E) = 1

E

F
3

#10 f = 9 #9
E2
F2 f = 8

3
G

h(G) = 0

G4
f = 12

#12
G3

#7 f = 6 #4
F1

f = 8 E1

#11
G2

f = 10

f = 10

#6
G1
f =8

nodes CLOSED

(a) Problem graph

(b) Trace m-A*

Figure 4: Example problem. left: problem graph heuristic values h(n) node.
right: trace m-A* finding = 3 best solutions evaluation function f (n)
node. White nodes CLOSED, grey one created, discarded.

admissible heuristic functions node. Note heuristic consistent. example,
h(A) > h(C) + c(A, C). start node, G goal node. right side Figure
present trace m-A*, evaluation function copy nodes created
time 3rd solution found. white nodes CLOSED, grey one (node G4 )
created, never put OPEN. algorithm expands nodes OPEN increasing order
evaluation functions. assume ties broken favour deeper nodes. First, m-A*
discovers solution C F G cost C1 = 8, next solution C E G
cost C1 = 10 found. third solutions B F G cost C1 = 10. Note
two copies node D, E F four copies G created. goal node G4
discarded, bound total number copies particular node = 3.
N
HEOREM 3. Given graphical model = hX, D, F, n variables whose domain size
bounded k, worst case time space complexity m-A* exploring search tree
O(k n ).
Proof. worst case m-A* would explore entire search tree, whose size O(k n ) (Section 2.3). Since underlying search space tree, algorithm never encounter
nodes once, thus nodes duplicated.
903

fiF LEROVA , ARINESCU , & ECHTER

3.2 Properties m-A*
section extend desirable properties A*, listed Section 2.2, m-best case.
simplicity without loss generality, assume throughout search graph accommodates
least distinct solutions.
HEOREM 4. Given optimization task, implicit directed search graph G integer
parameter 1, m-A* guided admissible heuristic following properties:
1. Soundness completeness: m-A* terminates best solutions generated order
costs.
2. Optimal efficiency consistent heuristic: node surely expanded2 m-A*
must expanded search algorithm traversing G guaranteed find
best solutions heuristic information.
3. Optimal efficiency node expansions: m-A* expands node times
heuristic consistent. ith path found node ith best path.
4. Dominance: Given two heuristic functions h1 h2 , every n h1 (n) < h2 (n),
m-A*1 expand every node surely expanded m-A*2 , m-A*i using heuristic hi .
prove properties m-A* Sections 3.2.1-3.2.2.
3.2.1 OUNDNESS C OMPLETENESS
Algorithm m-A* maintains copies node discards rest. next show
restriction compromise completeness.
P ROPOSITION 1. node discarded m-A* lead m-best solutions.
Proof. Consider consistent heuristic first (as described Algorithm 5). moment
m-A* discovered node n (m + 1)th time, copies n reside OPEN CLOSED
algorithm maintains distinct paths each. Let (m + 1)th path.
prove Theorem 10, node n discovered (m + 1)th time, cost Cnew newly
discovered path new (m + 1)th best, namely better costs already discovered:
Cnew Cm . Therefore, eliminated (m + 1)th path node n guaranteed worse
remaining ones thus part potential m-best optimal solutions
might passing node n.
heuristic consistent, m-A* modified replace worst previously
discovered paths newly found new , cost latter better place new
copy OPEN. Thus, again, safe bound number copies m.
clear along particular solution path evaluation function nodes
bounded paths cost C(), heuristic admissible.
P ROPOSITION 2. following true regarding m-A*:
1. solution path , forall n , f (n) C().
2. precisely defined Section 3.2.3

904

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

2. Unless already discovered m-A*, always node n resides
OPEN.
3. Therefore, long m-A* discover must node OPEN f (n)
C().
Proof. 1. f (n) = g (n) + h(n) since h(n) c (n, t) due admissibility, c (n, t)
actual cost n goal node along , conclude f (n) g (n) + h(n) = C().
2. reachable path root always leaf OPEN unless nodes along path
expanded CLOSED.
3. Follows easily 1 2.
follows immediately Proposition 2 (stated similarly Nilsson, 1982) that:
P ROPOSITION 3. [Necessary condition node expansion] node n expanded m-A*
searching ith best solution (1 m) satisfies f (n) Ci .
clear
P ROPOSITION 4. [Sufficient condition node expansion] Every node n OPEN,
f (n) < Ci , must expanded m-A* ith best solution found.
Soundness completeness m-A* follows quite immediately.
HEOREM 5 (soundness completeness). Algorithm m-A* generates m-best solutions
order, namely, ith solution generated ith best solution.
Proof. Let us assume contradiction case. Let ith generated solution path
first one generated according best-first order. Namely ith solution
generated cost C C > Ci . However, algorithm selected goal ti along
, evaluation function f (ti ) = gi (ti ) = C, while, based Proposition 2,
node n0 OPEN whose evaluation function Ci . Thus n0 selected
expansion instead ti . contradiction therefore result follows.
3.2.2 MPACT H EURISTIC TRENGTH
A*, performance m-A* improves accurate heuristic.
P ROPOSITION 5. Consider two heuristic functions h1 h2 . Let us denote m-A*1 algorithm uses heuristic h1 m-A*2 one using heuristic h2 . heuristic h1
informed h2 , namely every node n, h2 (n) < h1 (n), algorithm m-A*2 expand
every node expanded algorithm m-A*1 finding j th solution
j {1, 2, . . . , m}, assuming tie-breaking rule.
Proof. Since h1 informed h2 , h1 (n) > h2 (n) every non-goal node n. Let us
assume m-A*1 expands non-terminal node n finding j th best solution
cost Cj . node n expanded, means (a) point OPEN (b) evaluation
function satisfies f1 (n) = g(n) + h1 (n) Cj (Proposition 3). Consider current path
start node n. node n0 path selected point expansion thus
905

fiF LEROVA , ARINESCU , & ECHTER

m-A search space

search space
C1 Cm
algorithm
Ci


|Cm
C1 |

search space
explored m-A
compared

Figure 5: schematic representation search spaces explored m-A* algorithm, de
pending cost Cm

evaluation functions nodes bounded cost j th best solution:
f1 (n0 ) Cj . Since h1 (n0 ) > h2 (n0 ) every node n0 along path , evaluation functions
according heuristic h2 (n) obey:
f2 (n0 ) = g(n0 ) + h2 (n0 ) < g(n0 ) + h1 (n0 ) < Cj

(1)

thus node n0 must expanded m-A*2 .
Consider case exact heuristic. easy show that:
HEOREM 6. h = h exact heuristic, m-A* generates solutions j-optimal
paths 1 j m.
Proof. Since h exact, f values OPEN expanded sequence values C1 C2
. generated nodes evaluation function f = C definition
. . . Ci . . . Cm
1
optimal paths (since h = h ), f = C2 must paths second
best on. Notice solutions costs.
h = h , m-A*s complexity clearly linear number nodes evaluation
. However, cost function small range values, may
function f Cm
. avoid exponential frontier
exponential number solution paths cost Cm
chose tie-breaking rule expanding deeper nodes first, yielding number node expansions
bounded n, n bounds solution length. Clearly:

HEOREM 7. m-A* access
favour deeper
P h = h , then, using tie-breaking rule
th
nodes, expands #N = #Ni nodes, #Ni length optimal solution
path. Clearly, #N n.

906

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

Figure 6: graph G0 represents new problem instance constructed appending branch leading new goal node node n.

3.2.3 -A* C ONSISTENT H EURISTIC
m-A* uses consistent heuristic, several useful properties.
Optimal efficiency consistent heuristic. Algorithm A* known optimally efficient
consistent heuristic (Dechter & Pearl, 1985). Namely, algorithm extends search
paths root uses heuristic information A* expand every node
surely expanded A*, i.e., expand every n, f (n) < C . extend notion
nodes surely expanded A* m-best case:
-bounded
P ROPOSITION 6. Algorithm m-A* expand node n reachable strictly Cm
path root, regardless tie-breaking rule. set nodes referred surely
expanded m-A*.
-bounded path = {s, n , n , . . . n}. start node
Proof. Let us consider strictly Cm
1 2
clearly expanded beginning search children, including node n1 , placed
, node n must expanded m-A* finding mth best
OPEN. Since f (n1 ) < Cm
1
solution (Proposition 4), children, including n2 , turn placed OPEN. true
nodes , including n.

HEOREM 8 (m-optimal efficiency). search algorithm, guaranteed find m-best
solutions explores search space m-A* consistent heuristic,
expand node surely expanded m-A*. Namely expand every node
, i.e. f (n0 ) < C , n0 .
lies path dominated Cm

proof idea similar work Dechter Pearl (1985). Namely show
algorithm expand node n, surely expanded m-A*, miss one m-best
solutions, applied slightly modified problem:
Proof. Let us consider problem search graph G consistent heuristic h. Assume
node n surely expanded m-A* finding j th best solution. Let B algorithm
uses heuristic h guaranteed find best solutions. Let assume
node n expanded B. consistency heuristic allows us better characterize
nodes expanded m-A*.
create new problem graph G0 (see Figure 6) adding new goal node
h(t) = 0, connecting n edge cost c = h(n) + , = 0.5(Cj D)
907

fiF LEROVA , ARINESCU , & ECHTER

= maxn0 Sj f (n0 ), Sj set nodes surely expanded m-A* finding
j th solution. possible show heuristic h admissible graph G0 (Dechter &
Pearl, 1985). Since = 0.5(Cj D), C = 2. construction, evaluation function
new goal node is:

f (t) = g(t) + h(t) = g(n) + c = g(n) + h(n) + = f (n) + + = Cj < Cj

(2)

means reachable path whose cost strictly bounded Cj .
guarantees m-A* expand (Proposition 6), discovering solution cost Cj .
hand, algorithm B, expand node n original problem, still expand
thus reach node discover solution cost Cj , returning true
set best solutions modified problem. contradiction theorem follows.
P ROPOSITION 7. heuristic function employed m-A* consistent, values evaluation function f sequence expanded nodes non-decreasing.
proof straightforward extension result Nilsson (1980).
Proof. Let node n2 expanded immediately n1 . n2 already OPEN time
n1 expanded, node selection rule follows f (n1 ) f (n2 ). n2
OPEN, must added result expansion n1 , i.e., child n1 .
case cost getting n2 start node g(n2 ) = g(n1 ) + c(n1 , n2 )
evaluation function node n2 f (n2 ) = g(n2 ) + h(n2 ) = g(n1 ) + c(n1 , n2 ) + h(n2 ). Since h(n)
consistent, h(n1 ) c(n1 , n2 )+h(n2 ) f (n2 ) g(n1 )+h(n1 ). Namely, f (n2 ) f (n1 ).
heuristic function consistent, stronger condition Proposition 4:
HEOREM 9. Algorithm m-A* using consistent heuristic function:
;
1. expands nodes n f (n) < Cm
;
2. never expands nodes evaluation function f (n) > Cm

3. expands nodes f (n) = Cm , subject tie-breaking rule.
node n never expanded
Proof. 1. Assume exists node n f (n) < Cm
m-A*. situation arise node n never OPEN list, otherwise would
expanded, according Proposition 4. implies parent node n search
space (let us denote node p) never expanded. However, similarly done
. Thus
proof Proposition 7, easy show f (p) f (n) and, consequently f (p) < Cm
node p must never OPEN, otherwise would expanded. Clearly, true
ancestors n, start node s. Since node clearly OPEN beginning
search, initial assumption incorrect property follows.
2. 3. Follow directly Proposition 3.

Figure 7 provides schematic summary search space explored m-A* consistent heuristic.
908

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS


{n|f(n) < Cm
}

search space
explored m-A

*

*

{n|f (n) > Cm
}


{n|f (n) = Cm
}

Figure 7: nodes explored m-A* algorithm consistent heuristic.
Optimal efficiency node expansions. Whenever node n selected expansion
first time m-A*, algorithm already found shortest path node. extend
property follows:
HEOREM 10. Given consistent heuristic h, m-A* selects node n expansion
ith time, g(n) = gi (n), namely found ith best path start node n.
Proof. induction. = 1 (basic step) theorem holds (Nillson, 1980). Assume
holds (i 1)th expansion node n. Let us consider ith case, > 1 (inductive step).
already expanded node n (i 1) times due inductive hypothesis already
found (i 1) distinct best paths node n. Let us assume cost newly found
solution path greater ith optimal one, i.e. gi (n) > gi (n). Then, exists different,
undiscovered path n cost g (n) = gi (n) < gi (n). Proposition 2 exists
OPEN node n0 . Obviously, node n0 must located start node node
n. Denoting C (n0 , n) = c(n0 , n1 ) + + c(nk , n), heuristic consistency easily
follows h(n0 ) < C (n0 , n) + h(n) evaluation function node n0 along path
f (n0 ) = g (n0 ) + h(n0 ) < g (n0 ) + C (n0 , n) + h(n). Seeing cost path
n g (n) = g (n0 ) + C , conclude f (n0 ) < f (n). However, contradicts
assumption node n expanded ith time node n0 . theorem follows.
3.2.4 MPACT R EQUIRED B EST OLUTIONS
sequence sizes search spaces explored m-A* function obviously monotonically increasing m. Denoting j-A* i-A* versions m-A* algorithm
search respectively j best solutions, make following straightforward characterization:
P ROPOSITION 8. Given search graph consistent heuristic,
1. node expanded i-A* expanded j-A* < j use tie-breaking
rule.
909

fiF LEROVA , ARINESCU , & ECHTER

2. set S(i, j) nodes defined S(i, j) = {n|Ci < f (n) < Cj } surely expanded
j-A* surely expanded i-A*.
3. Cj = Ci , difference number nodes expanded i-A* j-A* determined
tie-breaking rule.
proof follows trivially Theorem 9. result, larger discrepancy respective costs Cj Ci yields larger difference search spaces explored j-A* i-A*.
difference, however, depends granularity values sequence
observed evaluation functions increase, related arc costs (or weights) search
graph. Ci = Cj = C, search space explored i-A* j-A* differ
frontier nodes satisfying f (n) = C. Figure 5 represents schematically search spaces explored
i-A* algorithm.

4. Depth-First Branch Bound Finding Best Solutions
Along valuable properties, m-A* inherits disadvantages A*: exponential space
complexity, makes algorithm infeasible many applications. alternative approach
searching using depth-first branch bound (DFBnB), implemented linear
space necessary therefore often practical. DFBnB finds optimal solution
exploring search space depth-first manner. algorithm maintains cost U best
solution encountered far prunes search nodes whose lower-bounding evaluation function
f (n) = g(n) + h(n) larger U . Extending DFBnB m-best task straightforward,
describe next.
4.1 m-BB Algorithm
Algorithm m-BB, depth-first branch bound extension m-best task, explores
search tree presented Algorithm 6. usual, algorithm maintains lists OPEN
CLOSED nodes. maintains sorted list CANDIDATE nodes contains best
solutions found far. Nodes OPEN organized last - first manner order
facilitate depth-first exploration search space (i.e., OPEN stack). step, m-BB
expands next node n OPEN (line 5). goal node, new complete solution found
(line 6) stored CANDIDATE list (line 7-9), re-sorted (line 10).
best solutions maintained (lines 11-13).
main modification depth-first branch bound, extended m-best task,
pruning condition. Let U1 U2 . . . Um denote costs best solutions
encountered thus far. Um upper bound used pruning. solutions discovered, pruning takes place. Algorithm m-BB expands current node n, generates children
(lines 15-17) computes evaluation function (line 18-19). prunes subproblem n
iff f (n) Um (lines 20-23). easy see algorithm terminates, outputs
m-best solutions problem.
HEOREM 11. Algorithm m-BB sound complete m-best solutions task.
Proof. Algorithm m-BB explores search space systematically. solutions
, C
skipped ones satisfying f (n) Um (see step 22). Since Um Cm

910

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

Algorithm 6: m-BB exploring graph, assuming consistent heuristic

1

2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23

24

Input: implicit directed search graph G = (N, E) start node n0 set goal nodes Goals.
heuristic function h(n). Parameter (the number desired solutions).
Output: best solutions
Initialize: OPEN=, CLOSED=, tree r = , sorted list CANDIDATE = , UpperBound = , = 1 (i
counts current solution searched for);
Put start node n0 OPEN, g(n0 ) = 0, f (n0 ) = h(n0 );
Assign n0 root r;
OPEN empty
Remove top node OPEN, denoted n, put CLOSED;
n goal node
soli solution obtained tracing back pointers n n0 (pointers assigned step 17);
Ci cost soli ;
Place solution soli CANDIDATE;
Sort CANDIDATE increasing order solution costs;
size CANDIDATE list
Um cost mth element CANDIDATE;
Keep first elements CANDIDATE, discard rest;
else
Expand node n, generating children succ(n);
forall n0 succ(n)
Attach pointer n0 back n r;
g(n0 ) = g(n) + c(n, n0 );
f (n0 ) = g(n0 ) + h(n0 );
f (n0 ) < Um
Place n0 OPEN;
else
Discard n0 ;
return solutions CANDIDATE list

therefore path cannot lead newly discovered
best solution cost, implies f (n) Cm
m-best cost.

N
HEOREM 12. Given graphical model = hX, D, F, i, worst case time complexity
m-BB explores search tree O(k n + log m), n number variables,
k domain size number required solutions. Space complexity O(n).
Proof. worst case m-BB would explore entire search tree size O(k n ). maintaining
CANDIDATE list introduces additional time overhead O(log m). Since search tree
yields caching, m-BB uses space linear number variables.
4.2 Characterization Search Space Explored m-BB
already shown m-A* superior exact search algorithm finding mbest solutions heuristic consistent (Theorem 8). particular, m-BB must expand
}.
nodes surely expanded m-A*, namely set nodes {n|f (n) < Cm
Theorem 8 pruning condition clear that:
911

fiF LEROVA , ARINESCU , & ECHTER

P ROPOSITION 9. Given consistent heuristic m-BB must expand node set {n|f (n) <
}. Also, instances m-BB expands nodes satisfying f (n) > C .
Cm

Several sources overhead m-BB discussed next.
4.2.1 -BB VS . BB
Pruning m-BB occur upper bound current mth best solution assigned
valid value, i.e., solutions found. absence determinism, solutions
consistent, time takes find arbitrary solutions depth-first manner O(m n),
n length solution (for graphical models n coincides number variables).
problem contains determinism may difficult find even single solution. means
m-BB search may exhaustive quite time.
4.2.2 MPACT OLUTION RDER
difference number nodes expanded BB m-BB depends greatly variance
solution costs. solutions cost, U1 = Um . However,
situation unlikely therefore conditions m-BBs node expansions impacted
1 , . . . , U j } non-increasing sequence
order solutions discovered. Let {Um

th
upper bounds best solution, point m-BB uncovered j th solution.
j
Initially Um
= , j {1, . . . , 1}.
P ROPOSITION 10. discovery (j 1)th j th solutions set nodes
j1
U j U j1 .
expanded m-BB included Sj = {n | f (n) Um
}, Cm


Proof. discovering (j 1)th j th solutions m-BB expands nodes satisfying
j1
j1
{n | f (n) Um
}, hence j : Cj Um
. j th solution found, either replaces
j
th
previous bound solution Um = Cj k th upper bound, k {1, . . . , 1}, yielding
j1
j
U j U j1 .
. Either way, Cm
= Um1
Um


4.2.3 RDERING OVERHEAD
need keep list sorted solutions (the CANDIDATE list) implies O(log m) overhead
new solution discovered. total number solutions encountered termination
hard characterize.
4.2.4 C ACHING OVERHEAD
overhead related caching arises m-BB explores search graph uses caching.
version algorithm (not explicitly presented) stores best partial solutions
fully explored subproblems (and subset partial set discovered) re-uses
results whenever subproblem encountered again. order implement caching, mBB requires store list length node cached. Moreover, cached partial
solutions need sorted, yields O(m log m) time overhead per cached node.
912

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

5. Adapting m-A* m-BB Graphical Models
main task find best solutions optimization tasks graphical models. Therefore,
adapt m-best search algorithms m-A* m-BB explore AND/OR search space
graphical models, yielding algorithms m-AOBF m-AOBB, respectively. describe
hybrid algorithm BE+m-BF, combining Bucket Elimination m-A*.
5.1 m-AOBF: Best-First AND/OR Search Best Solutions Graphical Models
extension algorithm AOBF (Section 2.3.2) m-best task seems fairly straightforward,
principle. m-AOBF AOBF continues searching discovering first solution,
required number best solutions obtained. actual implementation requires several
modifications discuss next.
easy extend AOBFs bottom-up node values updates corresponding arc marking
mechanism m-best task. Therefore, order keep track current best partial solution
tree searching ith best solution adopt naive approach maintains explicitly
list OPEN containing entire partial solution trees (not nodes), sorted ascending order
heuristic evaluation costs. Algorithm 7 presents pseudo-code simple scheme explores
AND/OR search tree generates solutions one one order costs. step,
algorithm removes next partial solution tree 0 OPEN (line 4). 0 complete
solution, added list solutions along cost (lines 5-8), otherwise algorithm
expands tip node n 0 , generating successors (line 10-17). newly generated node
n0 added 0 separately, yielding new partial solution tree 00 (lines 19-23), whose cost
recursively evaluated using Algorithm 3, AOBB (line 28). new partial trees
placed OPEN (line 29). Search stops solutions found.
note maintenance OPEN list containing explicit partial solution subtrees
source significant additional overhead become apparent empirical evaluation
Section 7. Thus, question whether performance m-AOBF improved open
therefore rich topic future work.
m-A* properties (Section 3.2) extended m-AOBF. particular, algorithm mAOBF admissible heuristic sound complete, terminating best solutions
generated order costs. m-AOBF optimal terms number nodes expanded
compared algorithm explores AND/OR search space
consistent heuristic function.
HEOREM 13 (m-AOBF complexity). complexity algorithm m-AOBF traversing either
h1
AND/OR search tree context minimal AND/OR search graph time space O(k deg ),
h depth underlying pseudo tree, k maximum domain size, deg bounds
degree nodes pseudo tree. pseudo tree balanced (each internal node
exactly deg child nodes), time space complexity O(k n ), n number
variables.
real complexity bound m-AOBF comes cost function. appears however
maintaining OPEN list brute force manner lend easily effective way
enumerating partial solution subtrees therefore search space partial solution
subtrees actually exponential n. detailed proof Theorem 13 given Appendix.
913

fiF LEROVA , ARINESCU , & ECHTER

Algorithm 7: m-AOBF exploring AND/OR search tree

1
2
3
4
5
6
7
8
9

10
11
12
13
14
15
16
17
18

19
20
21
22
23
24
25
26
27
28

29
30

Input: graphical model = hX, D, Fi, pseudo tree rooted X1 , heuristic function h(), parameter m;
Output: best solutions
Create root node labelled X1 , let G = {s} (explored search space) = {s} (partial solution tree);
Initialize ; OP EN {T }; = 1; (i counts current solution searched for);
OP EN 6=
Select top partial solution tree 0 remove OPEN;
0 complete solution
{hf (T 0 ), 0 i};
+ 1;
continue;
Select non-terminal tip node n 0 ;
// Expand node n
n node labeled Xi
forall xi D(Xi )
Create child n0 labeled hXi , xi i;
succ(n) succ(n) {n0 };
else n node labeled hXi , xi
forall successor Xj Xi
Create child n0 labeled Xj ;
succ(n) succ(n) {n0 };
G G {succ(n)};
// Generate new partial solution trees
L ;
forall n0 succ(n) Initialize v(n0 ) = h(n0 );
n node
forall n0 succ(n)
Create new partial solution tree 00 0 {n0 };
L L {T 00 };
else n node
Create new partial solution tree 00 0 {succ(n)};
forall 00 L
Recursively evaluate assign f (T 00 ) cost partial solution tree 00 , based heuristic
function h(); // see Algorithm 3
Place 00 OPEN, keeping sorted ascending order costs f (T 00 );
return best solutions found S;

5.2 m-AOBB: AND/OR Branch Bound Best Solutions Graphical Models
Algorithm m-AOBB extends AND/OR Branch Bound search (AOBB, Section 2.3.3)
m-best task. main difference AOBB m-AOBB value function computed
node. m-AOBB tracks costs best partial solutions solved subproblem. Thus extends node value v(n) solution tree (n) rooted n AOBB ordered
sets length m, denoted v(n) (n), respectively, v(n) = {v1 (n), . . . , vm (n)}
ordered set costs best solutions subproblem rooted n, (n) =
(n)} set corresponding solution trees. extension arises due
{T1 (n), . . . , Tm
depth-first manner search space exploration m-AOBB conjunction AND/OR decomposition. Therefore, due AND/OR decomposition m-AOBB needs completely solve
914

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

Algorithm 8: m-AOBB exploring AND/OR search tree

1
2

3
4
5
6
7
8
9
10
11
12
13
14

Input: graphical model = hX, D, Fi, pseudo tree rooted X1 , heuristic function h(), parameter m;
Output: best solutions
// INITIALIZE
Create root node labeled X1 let stack created expanded nodes OP EN = {s};
Initialize v(s) = (a set bounds best solutions s) set best partial solution trees rooted
(s) = ; U B = , sorted list DIDAT E = ;
OP EN 6=
Select top node n OPEN;
// EXPAND
n node labeled Xi
foreach xi D(Xi )
Add child n0 labeled hXi , xi list succ(n) containing successors n;
Initialize v(n0 ) = 0, set best partial solution trees rooted n (n0 ) = ;
n node labeled hXi , xi
Let p ancestor n;
Recursively evaluate assign f (p) cost partial solution tree rooted p, based heuristic h(); //
see Algorithm 3
vm (p) < f (p) vm (p)
Prune subtree current tip node n;
else
foreach successor Xj Xi
Add child n0 labeled Xj list succ(n) containing successors n;
Initialize v(n0 ) = , set best partial solution trees rooted n (n0 ) = ;

15
16
17

18
19
20
21
22
23
24
25

26

27
28
29

30

31
32
33
34

Remove n OPEN add succ(n) top OPEN;
// PROPAGATE
list successors node n empty
n root node
return set solutions rooted n costs: (n), v(n) ;
else
Update ancestors n, nodes p, bottom up:
p node
Combine set partial solution trees subproblem rooted p (p) set partial
solution trees rooted n (n) costs v(p) v(n); // see Algorithm 9
Assign resulting set costs set best partial solution trees respectively v(p)
(p);
else p node
foreach solution cost vi (n) set v(n)
Update cost weight arc, creating new set costs v 0 (n):
vi0 (n) = c(p, n) + vi (n);
Merge sets partial solutions v(n) v(p) sets partial solution trees rooted p n:
(p) (n), keeping best elements; //Algorithm 10
Assign results merging respectively v(p) (p);
Remove n list successors p;
Move one level up: n p;
return v(s) (s)

subproblems rooted children n0 node n, even single solution
subproblem n acquired (unlike m-BB case). Consequently, bottom-up phase
sets costs propagated updated. m-AOBF hand, maintains
set partial solution trees.
915

fiF LEROVA , ARINESCU , & ECHTER

Algorithm 9: Combining sets costs partial solution trees
1

2
3
4

5
6
7
8
9
10
11

function Combine(v(n), v(p), (n),T (n))
Input: Input sorted sets costs v(n), v(p), corresponding partial solution trees (n), (p), number
required solutions
Output: set costs best combined solutions v 0 (p), corresponding partial solution trees 0 (p)
// INITIALIZE
Sorted list OPEN, initially empty; //contains potential cost combinations
v 0 (p) ; 0 (p) ;
k = 1; //number partial solutions already assembled, total
// Search possible combinations
OPEN v1 (n) + v1 (p);
k < OP EN empty
Remove top node V OPEN, V = Svi (n) + vj (p);
vk0 (p) V ;
0
(p) Ti (n) Tj (p);
vi+1 (n) + vj (p) OP EN
Put vi+1 (n) + vj (p) OP EN ;

13

vi (n) + vj+1 (p) OP EN
Put vi (n) + vj+1 (p) OP EN ;

14

k k + 1;

15

return v 0 (p), (p);

12

Unlike m-AOBF discovers solutions one one order costs, m-AOBB (pseudocode Algorithm 8) reports entire set solutions once, termination. m-AOBB interleaves forward node expansion (lines 5-18) backward propagation (or cost revision) step
(lines 19-33) updates node values search terminates. node n pruned (lines 12-13)
current upper bound mth solution n, vm (n), lower nodes evaluation
functions f (n), computed recursively AOBB (Algorithm 3). bottom-up
propagation phase node partial solutions subproblems rooted nodes
children combined (line 24-26, Algorithm 9). parent node p v(p) (p)
updated incorporate new possibly better partial solutions rooted child node n (lines
27-31, Algorithm 10).
5.2.1 C HARACTERIZING N ODE P ROCESSING OVERHEAD
addition increase explored search space m-BB experiences compared BB
due reduced pruning (Section 4.2), AND/OR search introduces additional overhead mAOBB. propagation set costs partial solution trees leads increase
memory factor per node. Processing partial solutions nodes
introduces additional overhead.
HEOREM 14. Algorithm m-AOBB exploring AND/OR search tree time overhead
O(m deg log m) per node O(m k) per node, deg bounds degree
pseudo tree k largest domain size. Assuming k < deg log(m), total worst case time
complexity O(n k h deg log(m)) space complexity O(mn). time complexity

m-AOBB exploring AND/OR search graph O(n k w deg log(m)), space complexity

O(mn k w ).
916

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

Algorithm 10: Merging sets costs partial solution trees
1

2
3
4
5

6
7
8
9
10
11
12
13
14
15
16

17

function Merge(v(n),v(p),T (n),T (p))
Input: Input sorted cost sets v(n) v(p), sets corresponding partial solution trees (n) (p),
number required solutions
Output: v 0 (p), merged set best solution costs, 0 (p) set corresponding partial solution trees
// INITIALIZE
v 0 (p) ;
0 (p) ;
i, j 1; //indices cost sets
k 1; //index resulting array
// Merge two sorted sets
k
vi (p) vj (n)
vk0 (p) vi (p);
0
Tk (p) Ti (p);
+ 1;
k k + 1;
else
vk0 (p) vj (n);
0
Tk (p) Tj (n);
j j + 1;
k k + 1;
return v 0 (p) 0 (p);

Proof. Combining sets current m-best partial solutions (Algorithm 9) introduces overheard
O(m log(m)). resulting time overhead per node O(deg log(m)). Merging two
sorted sets costs (Algorithm 10) done O(m) steps. node O(k) children,
resulting overhead O(m k). Assuming k < deg log(m), complexity dominated
processing nodes. worst case, tree version m-AOBB, called m-AOBB-tree,
would explore complete search space size O(n k h ), h bounds depth pseudo

tree, graph version, called m-AOBB-graph, would visit space size O(n k w ),
w induced width pseudo tree. space complexity m-AOBB-tree follows
need propagate sets O(m) partial solutions length O(n). time overhead
m-AOBB AND/OR trees AND/OR graphs. space complexity m-AOBBgraph explained need store partial solutions cached node.

5.3 Algorithm BE+m-BF
known exact heuristics graphical models generated Bucket Elimination
(BE) algorithm described Section 2.3.4. therefore first compile exact heuristics along
ordering using apply m-A* (or m-AOBF, work point),
using exact heuristics. resulting algorithm called BE+m-BF. Worst-case analysis
algorithm show yields best worst-case complexity compared known
m-best algorithm graphical models.
917

fiF LEROVA , ARINESCU , & ECHTER

HEOREM 15. time complexity BE+m-BF O(nk w+1 + nm) n number
variables, k largest domain size, w induced width problem desired
number solutions. space complexity O(nk w + nm).
Proof. BEs time complexity O(nk w+1 ) space complexity O(nk w ) (Dechter, 1999).
Since compiles exact heuristic function, m-A* exact heuristic expands nodes
f (n) = Cj searching ith solution. algorithm breaks ties favour
deeper nodes, expand nodes solution paths. path length n, yielding total
time space complexity step algorithm equal O(n m).

6. Related Work
distinguish several primary approaches employed earlier m-best exact algorithms,
mentioned already Introduction. Note original works include space
complexity analysis bounds provided often own.
first influential approach introduced Lawler (1972). aimed use of-theshelf optimization schemes best solutions. Lawler showed extend given optimization
algorithm m-best task. step, algorithm seeks best solution re-formulation
original problem excludes solutions already discovered. scheme improved years still one primary strategies finding m-best solutions.
time space complexity Lawlers scheme O(nmT (n)) O(S(n)) respectively,
(n) S(n) time space complexity finding single best solution. example,
use AOBF underlying optimization algorithm, use Lawlers method yields time


complexity O(n2 mk w log n ) space complexity O(nk w log n ).
Hamacher Queyranne (1985) built upon Lawlers work used building blocks algorithms find first second best solutions. two best solutions generated,
new problem formulated second best solution best solution new problem.
Then, second best solution new problem becomes overall third best solution
procedure repeated. algorithm time complexity O(m T2 (n)) space complexity
O(S2 (n)), T2 (n) S2 (n) respectively time space finding second best
solution. complexity method always bounded Lawler, seeing
Lawlers scheme used algorithm finding second best task. Using m-AOBF

find two best solutions, obtain time complexity O(2mnk w log n ) space complexity

O(2nk w log n ).
Nilsson (1998) applied Lawlers method using join-tree algorithm. top algorithm reuses computations previous iterations. scheme, called max-flow algorithm, uses
message-passing junction tree calculate initial max-marginal functions cluster
(e.g. probability values probable assignments task) yielding best solution. Note
step equivalent running bucket-elimination algorithm. Subsequent solutions recovered conditioning search consult generated function. time complexity analysis
Nilsson (1998) O(2p|C| + 2mp|R| + pm log (pm)), p number cliques joint
tree, |C| size largest clique |R| size largest residual (i.e. number
variables cluster neighbouring clusters). space complexity bounded
O(p|C| + p(|S|)), |S| size separator clusters. applied buckettree, Nilssons scheme time space complexity O(2nk w+1 + mn(2k + log(mn))


O(nk w +1 + nk w ) respectively, since bucket tree p = n cliques, whose size bounded
918

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS



|C| = k w +1 residual cluster |R| = k (the domain single variable).
Thus algorithm better time complexity schemes mentioned far, except
BE+m-BF.
Two works de Campos et al. build upon Nilssons approach, extending solving mbest MAP task using genetic algorithms (de Campos, Gamez, & Moral, 1999) probability trees
(de Campos, Gamez, & Moral, 2004), respectively. schemes approximate authors
provide theoretical analysis complexity.
Fairly recently, Yanover Weiss (2004) developed iterative scheme based belief propagation, called BMMF. iteration BMMF uses Loopy Belief Propagation solve two new
problems obtained restricting values certain variables. applied junction tree

induced width w (whose largest cluster size bounded k w +1 ) exact algorithm
time complexity O(2mnk w+1 ) space complexity O(nk w + mnk). applied
loopy graph, BMMF guaranteed find exact solutions.
Another approach based Lawlers idea uses optimization via LP-relaxation (Wainwright
& Jordan, 2003), formulated Fromer Globerson (2009). method, called Spanning TRee
Inequalities Partitioning Enumerating Solutions, STRIPES, partitions search
space, systematically excluding previously determined assignments. step new
constraints added LP optimization problem, solved via off-the-shelf LP-solver.
general, algorithm approximate. However, trees junction-trees exact
underlying LP solver reports solutions within time limit. PESTEELARS extension
scheme Batra (2012) solves LP relaxation using message-passing approach that,
unlike conventional LP solvers, exploits structure problems graph. complexity
LP-based algorithm hard characterize using usual graph parameters.
Another approach extends variable elimination (or dynamic programming) schemes directly
obtain best solutions. recent paper (Flerova et al., 2011) extended bucket elimination mini-bucket elimination m-best solutions task, yielding exact scheme called
elim-m-opt approximate version called mbe-m-opt, respectively. work embeds
m-best optimization task within semi-ring framework. time space complexities


algorithm elim-m-opt bounded O(m log mnk w +1 ) O(mnk w ), respectively.
Two related dynamic programming based ideas Seroussi Golmard (1994) Elliot
(2007). Seroussi Golmard extract solutions directly, propagating best partial
solutions along junction tree. Given junction tree p cliques, largest cluster size |C|, separator
size bounded |S| branching degree deg, time complexity algorithm O(m2 p
|C| deg) space complexity O(m p |S|). Adapted bucket tree, algorithm


time complexity O(m2 nk w +1 deg) space complexity O(mnk w ). Elliot propagates
best partial solutions along representation called Valued And-Or Acyclic Graph, known
smooth deterministic decomposable negation normal form (sd-DNNF) (Darwiche, 2001).

time complexity Elliots algorithm O(nk w +1 log (m deg)) space complexity

O(mnk w +1 ).
Several methods focus search schemes obtaining multiple optimal solution k shortest
paths task (KSP). survey see paper Eppstein (1994). majority algorithms
assume entire search graph available memory thus directly applicable.
recent exception Aljazzar Leue (2011), whose K algorithm finds k shortest paths
search on-the-fly thus potentially useful graphical models. algorithm
interleaves A* search problems implicit graph G Dijkstras algorithm (1959) spe919

fiF LEROVA , ARINESCU , & ECHTER

BE+m-BF


O(nk w

m-AOBF


O(nk w

log n

+1

+ mn)

O(2nk w

)



Nilsson 1998

+1

+ mn(2 log(mn) + 2k))

elim-m-opt


Gosh et al. 2012

Elliot
2007


Yanover Weiss 2004

m-AOBB


Hamacher Queyranne

O(mnk w

O(mnk w

+1

+1



O(mnk w )

log m)

log (m deg))

O(mnk w

O(mnk w deg log m)



O(2mnk w

+1

log n

Aljazzar Leue 2011


O(nk w w log (nk) + m)

)

)

Seroussi Golmard 1994
O(m2 nk w+1 deg)

Lawler 1972

O(n2 mk w )

m-A*-tree
O(k n )

m-BB-tree

O(k n + log m)

Figure 8: Time complexity comparison exact m-best algorithms specified bucket tree.
parent node graph better complexity children. Problem parameters:
n - number variables, k - largest domain size, w - induced width, deg - degree
join (bucket) tree. algorithms highlighted.

cific path graph structure denoted P (G). P (G) directed graph, vertices correspond
edges problem graph G. Given consistent heuristic, K , applied AND/OR

search graph time space O(nk w w log(n k) + m).
recently, Gosh, et al., (2012) introduced best-first search algorithm generating ordered solutions explicit AND/OR trees graphs. time complexity algorithm
bounded O(mnk w ), applied context-minimal AND/OR search graph. space
complexity bounded O(s nk w+1 ), number candidate solutions generated
stored algorithm, hard quantify using usual graph parameters. However, approach,
explores space complete solutions, seem practical graphical models
requires entire AND/OR search space fully explicated memory attempting generate even second best solution. contrast, algorithms generate best
solutions traversing space partial solutions.
920

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

Figure 8 provides visual comparison worst-case time complexity bounds
discussed schemes form directed graph, node corresponds algorithm
parent graph better complexity child. assume analysis
n >> > k > 2.
see best emerging scheme, far worst-case performance goes BE+m-BF.
However, since requires compiling exact heuristics, often infeasible. see
algorithm elim-m-opt appears relatively good time complexity superior, example, mAOBB search. However, showed previous work (Flerova et al., 2011), quite limited
empirically. Note worst-case analysis often fails capture practical performance, either algorithms good worst-case performance require much memory,
ignores power cost function bounding performance.

7. Experimental Evaluation
experiments consist two parts: evaluation m-best search algorithms benchmarks
recent UAI Pascal2 competitions comparison schemes previously developed algorithms randomly generated networks, whose parameters structure
restricted due limitations available implementations competing schemes.
defer discussion second part experiments Section 7.5, concentrating
evaluation m-best search schemes only.
7.1 Overview Methodology
used 6 benchmarks, all, except binary grids, came real-world domains:
1. Pedigrees
2. Binary grids
3. WCSP
4. Promedas
5. Proteins
6. Segmentation
pedigrees benchmark (pedigree*) used UAI 2008 competition.3 arise
domain genetic linkage analysis associated task haplotyping.
haplotype sequence alleles different loci inherited individual one parent,
two haplotypes (maternal paternal) individual constitute individuals genotype.
genotypes measured standard procedures, result list unordered pairs
alleles, one pair locus. maximum likelihood haplotype problem consists finding
joint haplotype configuration members pedigree maximizes probability
data. shown that, given pedigree data, haplotyping problem equivalent
computing probable explanation Bayesian network represents pedigree (see
paper Fishelson Geiger (2002) details).
3. http://graphmod.ics.uci.edu/group/Repository

921

fiF LEROVA , ARINESCU , & ECHTER

Benchmark
Pedigrees
Grids
WCSP
Promedas
Proteins
Segmentation

# inst
13
32
61
86
72
47

n
581-1006
144-2500
25-1057
197-2113
15-242
222-234

k
3-7
2
2-100
2
18-81
2-21

w
16-39
15-90
5-287
5-120
5-16
15-18

hT
52-104
48-283
11-337
34-187
7-44
47-67

Table 1: Benchmark parameters: # inst - number instances, n - number variables, k - domain
size, w - induced width, hT - pseudo tree height.

binary grid networks (50-*, 75-* 90-*)4 nodes corresponding
binary variables arranged N N square functions defined pairs
variables generated uniformly randomly.
WCSP (*.wcsp) benchmark includes random binary WCSPs, scheduling problems
SPOT5 benchmark, radio link frequency assignment problems, providing large variety
problem parameters.
Protein side-chain prediction (pdb*) networks correspond side-chain conformation prediction tasks protein folding problem (Yanover, Schueler-Furman, & Weiss, 2008).
resulting instances relatively nodes, large variable domains, generally rendering
instances complex.
Promedas (or chain *) segmentation (* s.binary) probabilistic networks
come set problems used 2011 Probabilistic Inference Challenge.5 Promedas instances based Bayesian network model developed expert systems medical diagnosis
(Wemmenhove, Mooij, Wiegerinck, Leisink, Kappen, & Neijt, 2007). Segmentation common
benchmark used computer vision, modeling task image segmentation MPE problem,
namely assigning label every pixel image, pixels label share
certain characteristics.
Table 1 describes benchmark parameters: # inst - number instances, n - number variables, k - maximum domain size, w - induced width ordering used, hT - pseudo-tree height.
induced width one crucial parameters indicating difficulty problem,
difference induced width mini-bucket i-bound signifies strength
heuristic. i-bound considerably smaller induced width, heuristic
weak, i-bound equal greater induced width yields exact heuristic,
turn yields much faster search. Clearly, large number variables, high domain size large
pseudo tree height suggest harder problems.
7.1.1 LGORITHMS
distinguish 6 algorithms: BE+m-BF, m-A*-tree m-BB-tree exploring regular
search tree modifications explore AND/OR search tree, denoted m-AOBF-tree
m-AOBB-tree. consider variant m-AOBF explores AND/OR search graph
m-AOBF-graph. implement m-AOBB AND/OR search graph,
4. http://graphmod.ics.uci.edu/repos/mpe/grids/
5. http://www.cs.huji.ac.il/project/PASCAL/archive/mpe.tgz

922

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

overhead due book-keeping looked prohibitive. used m-AOBF representative AND/OR
graph search, see proved indeed cost-effective. algorithms
guided pre-compiled mini-bucket heuristics, described Section 2.3.4. used 10 i-bounds,
ranging 2 22. However, hard problems computing mini-bucket heuristic
larger i-bounds proved infeasible, actual range i-bounds varies among benchmarks
among instances within benchmark. algorithms restricted static variable ordering
computed using min-fill heuristic (Kjrulff, 1990). AND/OR schemes used pseudo
tree. implementation algorithms m-BB, m-BF m-AOBF break ties lexicographically,
algorithm m-AOBB solves independent subproblems rooted node increasing
order lower bound heuristic estimates.
algorithms implemented C++ (32-bit) experiments run 2.6GHz
quad-core processor. memory limit set 4 GB per problem, time limit 3 hours.
report CPU time (in seconds) number nodes expanded search. uniformity
consider task throughout maximization-product problem, known
Probable Explanation task (MPE MAP). focus complete exact solutions thus
report results algorithm found less solutions (for best-first schemes)
optimality solutions proved (for branch bound schemes).
7.1.2 G OALS E MPIRICAL E VALUATION
address following aspects:
1. Comparing best-first depth-first branch bound approaches
2. impact AND/OR decomposition search performance
3. Scalability algorithms number required solutions
4. Comparison earlier proposed algorithms
7.2 Main Trends Behavior Algorithms
Tables 2, 4, 6, 8, 10, 12 present algorithms raw results form runtime
seconds number expanded nodes select instances benchmark, selected
best illustrate prevailing trends. benchmark show results two values
i-bound, corresponding, cases, relatively weak strong heuristics. Note ibound impact BE+m-BF, since always calculates exact heuristic. show three
values number solutions m, equal 1 (ordinary optimization problem), 10 100.
order see bigger picture, Figures 9-14 show bar charts representing
benchmark median runtime number instances solved algorithm particular
strength heuristic (i-bound) {1, 2, 5, 10, 100}. y-axis logarithmic scale.
numbers bars indicate actual values median time seconds number
solved instances, respectively. important note figures account harder
instances, i-bound yield exact heuristic. acknowledge median
times strictly comparable since calculated varied number instances solved
algorithm. However, metric robust outliers gives us intuition
algorithms relative success. addition, Tables 3, 5, 7, 9, 11 13 show benchmark
number instances, given algorithm best terms runtime terms
number expanded nodes. several algorithms show best result, counts towards
score them.
923

fiF LEROVA , ARINESCU , & ECHTER

instance
(n,k,w ,h)

i-bound

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

OOM
OOM
OOM
Timeout
Timeout
0.05
6647
OOM
OOM
OOM
1269.0
348648825
22.99
2320223
0.05
6647

number solutions
m=10
nodes
OOM
OOM
OOM
Timeout
Timeout
0.06
6671
OOM
OOM
OOM
1275.65
348648869
164.72
12110559
0.06
6671

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

OOM
OOM
OOM
OOT
1461.76
46419482
OOM
OOM
OOM
OOM
151.49
33563300
107.03
4274313
OOM

OOM
OOM
OOM
OOT
2389.32
74629839
OOM
OOM
OOM
OOM
152.27
33609110
185.66
7245553
OOM

OOM
OOM
OOM
OOT
3321.47
83802828
OOM
OOM
OOM
OOM
148.08
36255491
251.98
8319419
OOM

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

OOM
OOM
OOM
Timeout
5760.25
14260410
OOM
OOM
OOM
793.56
2579416
Timeout
484.69
1530768
OOM

OOM
OOM
OOM
Timeout
OOT
OOM
OOM
OOM
OOM
Timeout
551.67
1995114
OOM

OOM
OOM
OOM
Timeout
OOT
OOM
OOM
OOM
OOM
Timeout
858.29
3507104
OOM

10.22

10.29

algorithm

m=1
time

503.wcsp

4

(144, 4, 9, 44)

8

myciel5g 3.wcsp

4

(47,2, 19, 46)

8

satellite01ac.wcsp

4

(79, 8, 19, 56)

8

29.wcsp

4

(83, 4, 18, 58)

8

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

10.23
11.59
12.96
1.81
0.0
0.05
0.09
0.02
0.17
0.02
0.0

nodes

464134
OOM
938812
2243619
87717
111
2347
1401
2098
37629
1577
111

time

11.58
12.89
2.63
0.0
0.05
0.09
0.02
0.17
0.33
0.0

464182
OOM
938869
2245137
147851
168
2395
1447
2155
38463
24239
168

m=100
time

nodes
OOM
OOM
OOM
Timeout
Timeout
0.06
6984
OOM
OOM
OOM
1255.46
348651775
8010.42
568148386
0.06
6984

11.57
12.77
115.3
0.01
0.08
0.13
0.02
0.25
79.38
0.01

464698
OOM
939508
2279587
9189667
739
2899
1482
2724
55125
6731546
739

Table 2: WCSP: CPU time (in seconds) number nodes expanded. Timeout stands
exceeding time limit 3 hours. OOM indicates 4GB memory. bold
highlight best time number nodes m. Parameters: n - number
variables, k - domain size, w - induced width, h - pseudo tree height.

next provide elaboration interpretation results.
7.2.1 WCSP
Table 2 shows results two values i-bound select instances chosen best illustrate
common trends seen across WCSP benchmark. Figure 9 presents median time
number solved instances algorithm i=16. Table 3 shows i-bound (i=16)
number instances schemes best runtime best number
expanded nodes. many problem instances benchmark mini-bucket elimination
large i-bounds infeasible, thus present results small medium i-bounds.
924

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

BE+m-BF
m-AOBF tree

m-AOBF graph
m-A* tree

1.94
0.01
0.04
0.08
0.05

1.71

10

100

6
3
3
2

3
3
2

3
3
2

3
3
2

2

Solved instances

WCSPs, i=16

3
3

4

5

6

6

m-BB tree
m-AOBB tree

5
5

5
5

5

6

m-AOBF graph
m-A* tree

6

BE+m-BF
m-AOBF tree
6

0.0
0.01
0.03
0.05

1.7
0.0
0.01
0.02
0.05

5


2

5
5

1

10-1

2.8

2.79

2.71
1.71
0.0
0.01
0.02
0.04

1.71
0.1

0.0
0.01
0.02
0.05

Median time
WCSPs, i=16

100

m-BB tree
m-AOBB tree
6.33

101

100

1

2

5



10

100

Figure 9: Median time number solved instances (out 49) select values WCSPs,
i-bound=16. Numbers bars - actual values time (sec) # instances. Total
instances benchmark: 61, discarded instances due exact heuristic: 12.

BE+m-BF. suggested theory, whenever BE+m-BF run memory,
efficient scheme. See example Table 2, 503.wcsp 29.wcsp. However, calculation
exact heuristic feasible easier instances and, Figure 9 shows, solve
925

fiF LEROVA , ARINESCU , & ECHTER

algorithm

solved
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

WCSPs: # inst=61, n=14-1058
k=2-100, w =6-287, hT =8-585, i-bound=16
m=1
m=2
m=5
m=10
m=100
#BT / #BN #BT / #BN #BT / #BN #BT / #BN #BT / #BN
43
43
43
43
43
1/2
1/1
0/1
1/1
0/0
1/2
0/2
0/2
0/2
0/3
5/1
4/3
5/3
4/3
5/2
1/0
2/0
1/0
1/0
0/0
1/2
2/0
0/0
0/0
0/0
2/1
2/1
2/1
2/1
2/1

Table 3: Number instances, algorithm best runtime (#BT) best number
expanded nodes (#BN), WCSPs. 61 instances 12 exact heuristics. table
accounts remaining 49, i-bound= 16 .

2 WCSP instances. seen Table 3, two instances BE+m-BF demonstrated best
runtime among schemes.
m-AOBB-tree. number problems small values m, m-AOBB-tree superior mBB-tree terms runtime number expanded nodes. example, 29.wcsp,
i=4, m=10 m-AOBB-tree requires 2.63 seconds solve problem expands 147851 nodes
runtime m-BB-tree 12.89 seconds expands 2245137 nodes. However,
majority instances m-AOBB-tree slower schemes, seen Figure 9. Moreover,
m-AOBB-tree scales poorly number solutions. = 100 often
worst runtime largest explored search space among schemes, e.g. i=8, 503.wcsp.
striking decrease performance grows consistent across various benchmarks
explained need combine sets partial solutions nodes described
earlier. overhead connected AND/OR decomposition accounts larger time per
node ratio m-AOBB-tree, compared schemes. example, Table 2 instance
myciel5g 3.wcsp, i=8, m=10 m=100 m-AOBB-tree expands less nodes m-BB-tree,
runtime larger. Nevertheless, m-AOBB-tree benefits. Since space efficient
algorithms, often scheme able find solutions harder instances,
especially heuristic weak, see myciel5g 3.wcsp i=4 satellite01ac.wcsp
i=4 i=8, respectively.
m-BB-tree. Figure 9 see m-BB-tree solves almost number problems
m-AOBB-tree considerably better median time.
m-AOBF-tree m-AOBF-graph. Unsurprisingly, best-first search algorithms often run
space problems feasible branch bound, 503.wcsp myciel5g 3.wcsp i=8.
m-AOBF-based schemes overall inferior algorithms, solving, Figure 9 shows,
least number problems. schemes run memory much often m-A*-tree.
believe due overhead maintaining OPEN list partial solution trees, opposed
OPEN list individual nodes m-A*-tree does. Whenever m-AOBF schemes manage
find solutions, example instance 29.wcsp, i=8, m-AOBF-graph explores smallest
926

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

search space among schemes, except BE+m-BF. time m-AOBF-tree sometimes
expands nodes compared m-AOBF-graph, m-A*-tree,
would normally expect, since m-A*-tree traverses search space, inherently larger
AND/OR one. However, important remember though better space efficiency
AND/OR schemes often observed, guaranteed. Many factors, tie breaking
nodes value evaluation function, impact performance mAOBF-tree. m-AOBF-tree m-AOBF-graph almost median time number
solved problems, seen Figure 9.
m-A*-tree. three best first algorithms m-A*-tree overall best. Figure 9 see
solves instances schemes values median runtime
close BE+m-BF. Table 3 proves i-bound=16 scheme fastest among
schemes largest number instances, showing best runtime 4-5 instances, depending
m. explained part relatively reduced overhead maintaining search space
OPEN list memory, compared example m-AOBF schemes.
7.2.2 P EDIGREES
Table 4 displays results select instances Pedigree benchmark two i-bounds each.
Overall, difference results algorithms greatly diminishes heuristic
strength increases. Figure 10 shows median time number solved instances select
values i=16. number instances schemes best runtime
best number expanded nodes i-bound presented Table 5.
BE+m-BF. BE+m-BF often superior algorithms, especially
schemes use lower values i-bound, e.g. pedigree23, i=12, ms. large i-bounds thus
accurate heuristics difference much smaller. Moreover, sometimes BE+m-BF
slower schemes, due time required calculate exact heuristic, e.g. pedigree23,
i=16. Table 5 shows BE+m-BF overall fastest. see Pedigree benchmark
algorithm quite successful, evident many instances solved (see Figure 10).
m-AOBB-tree. low values m-AOBB-tree slightly superior algorithms,
solving number instances, (see Figure 10). hand, median time
largest. fails solve instances m=100. Table 4 see m-AOBB-tree
slowest, (e.g., pedigree23, i=16, ms). Yet, instance pedigree33, i=12, m=1, scheme
one find solution.
m-BB-tree. expected, m-BB-tree inferior best-first search schemes unless latter
run memory. case WCSP, scheme often faster m-AOBB-tree,
example, pedigree30, i=16, values m. bar charts show m-BB-tree second
worst median time values m, solves number problems m=100.
m-AOBF schemes. m-AOBF algorithms unsuccessful Pedigree benchmark.
often run memory even = 1 (e.g. pedigree33, i=22). instances
report solution m-AOBF-tree faster m-AOBF-graph, though difference usually
large.
m-A*-tree. saw WCSPs, pedigree instances m-A*-tree faster two
m-AOBF schemes, seen Figure 10, values m. Moreover, superior harder instances
927

fiF LEROVA , ARINESCU , & ECHTER

instance
(n,k,w ,h)

i-bound

pedigree33

12

algorithm

m=1
time

(798, 4, 24, 132)
22

pedigree30

12

(1290, 5, 20, 105)

16

pedigree23

12

(403, 5, 21, 64)

16

pedigree20

12

(438, 5, 20, 65)
16

nodes

number solutions
m=10
time
nodes
OOM
OOM
OOM
Timeout
Timeout
OOM
OOM
OOM
1.55
77138
4.15
177397
Timeout
OOM

m=100
nodes
OOM
OOM
OOM
Timeout
Timeout
OOM
OOM
OOM
3.76
112422
21.48
655141
Timeout
OOM
time

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

OOM
OOM
OOM
Timeout
7814.77
145203641
OOM
OOM
OOM
1.32
73625
2.98
145717
2.88
70644
OOM

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

OOM
OOM
OOM
Timeout
2510.59
33453995
7.90
6423
OOM
OOM
65.43
4866388
84.28
12243789
594.36
6907399
7.90
6423

OOM
OOM
OOM
Timeout
OOT
7.99
7611
OOM
OOM
65.86
4867551
85.72
12298570
Timeout
7.99
7611

OOM
OOM
OOM
Timeout
OOT
9.22
23028
OOM
OOM
67.01
4882985
127.25
13027245
Timeout
9.22
23028

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

OOM
OOM
8.44
713664
23.0
4446224
32.11
831096
7.11
630
OOM
OOM
0.52
53862
4.5
837288
13.39
346145
7.11
630

OOM
OOM
715729
4676953
75355901
2482
OOM
OOM
55927
959931
50252107
2482

OOM
OOM
11.15
904802
35.46
6179124
Timeout
7.68
19297
OOM
OOM
1.17
85300
14.14
1641751
OOM
7.68
19297

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

27.0
34.23
88.85
24.95

24.94
27.32
54.46
24.95

OOM
OOM
2321986
7239379
4365855
491
OOM
OOM
2279192
5857301
2531322
491

8.46
24.56
1077.9
7.24

0.58
5.61
713.73
7.24

26.66
37.63
1019.76
24.99

24.93
29.14
970.61
24.99

OOM
OOM
2324701
7434961
63940515
3482
OOM
OOM
2281907
5946423
59333828
3482

OOM
OOM
2353927
9155747
Timeout
26.16
32643
OOM
OOM
25.97
2311133
40.2
6617200
Timeout
26.16
32643
27.47
66.81

Table 4: Pedigrees: CPU time (in seconds) number nodes expanded. Timeout stands
exceeding time limit 3 hours. OOM indicates 4GB memory. bold
highlight best time number nodes m.Parameters: n - number
variables, k - domain size, w - induced width, h - pseudo tree height.

infeasible m-AOBF schemes BE+m-BF, e.g. pedigree23, i=16. shown Figure 10,
solves 5 instances i=16, ms, best second best results, depending
number solutions. However, median time m-A*-tree considerably larger
BE+m-BF, i-bound latter solves single instance less.
7.2.3 B INARY G RIDS
Table 6 shows results select instances grid networks domain. Figure 11 shows
median runtime number solved instances i=18, Table 7 presents number
instances, algorithm best, i-bound. trends algorithms
928

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

m-AOBF graph
m-A* tree

m-BB tree
m-AOBB tree

842.17

BE+m-BF
m-AOBF tree

6.66

5.62

5.65

28.13

29.14

40.2

98.29

m-BB tree
m-AOBB tree
5
5
4

5
5
2

4

5
5
5

6
4

5
5

6

0.0

0.0
0.0

100

m-AOBF graph
m-A* tree

5
5
4

10



BE+m-BF
m-AOBF tree

10

100

0.0

5



0.0
0.0

2

0.0
0.0

1

0.0
0.0

10-1

0.0
0.0

100

0.0
0.0

Solved instances
Pedigrees, i=16

0.32
0.0
0.0

5

2

4

1

0.27
0.0
0.0

0.23
0.0
0.0

100

0.23
0.0
0.0

1.39

5.6

101

5.58

27.32

102

27.41

62.91

Median time
Pedigrees, i=16

280.27

103

Figure 10: Median time number solved instances (out 12) select values Pedigrees, i-bound=16. Numbers bars - actual values time (sec) # instances.
Total instances benchmark: 13 , discarded instances due exact heuristic: 1.

behavior observed WCSP Pedigree benchmarks noticed Grid benchmark
well. particular, m-AOBB-tree successful small, even solving
instances, seen Figure 11. shows worse results m=100 number
solutions largest median time. m-BB-tree smaller median time ms, still
929

fiF LEROVA , ARINESCU , & ECHTER

algorithm

solved
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

Pedigrees: # inst=13, n=335-1290
k=3-7, w =15-47, hT =52-204, i-bound=16
m=1
m=2
m=5
m=10
m=100
#BT / #BN #BT / #BN #BT / #BN #BT / #BN #BT / #BN
6
6
6
6
6
0/0
0/0
0/0
0/0
0/0
0/0
0/0
0/0
0/0
0/0
1/1
1/1
1/1
1/1
1/1
0/0
0/0
1/1
1/1
1/1
1/1
1/1
0/0
0/0
0/0
4/4
4/4
4/4
4/4
4/4

Table 5: Number instances, algorithm best runtime (#BT) best number
expanded nodes (#BN), Pedigrees. 13 instances 1 exact heuristics. table
accounts remaining 12, i-bound= 16 .

considerably slower best-first schemes. m-A*-tree presents best compromise
small medium running time relatively large number solved instances. Table 7
shows majority grid instances fastest algorithm. two m-AOBF schemes
results quite similar other, solving almost number instances ms little
difference median runtimes, shown Figure 11. consistently inferior
schemes except BE+m-BF, often runs memory. main difference
Grid benchmark compared previously discussed domains lies behaviour BE+mBF i-bound high. Even though expands less nodes, many problems BE+m-BF
slower schemes due large time required compute exact heuristic.
example, grid 75-19-5, i=18, m=10 runtime BE+m-BF 143.11 seconds, even
m-AOBB-tree, known slow, terminates 94.0 seconds. time, instance
BE+m-BF explores smallest search space values m.
7.2.4 P ROMEDAS
Table 8 shows results Promedas benchmark. Figure 12 presents median time number solved instances benchmark i=16. Table 9 shows i-bound number
instances schemes best runtime best number expanded nodes.
significant fraction instances solved algorithms, especially low
medium i-bounds. Unlike benchmarks, m-AOBB-tree solves instances
small ms, quite successful m=100, solving one instance less best
scheme value m, m-BB-tree. Moreover, sometimes m-AOBB-tree scheme
report solutions, especially weak heuristic, e.g. chain 50.fg chain 212.fg, i=12.
BE+m-BF runs memory instances, seen Table 8. Overall, variance
algorithms performance significant Promedas previously discussed benchmarks. example, see Figure 12, i=16 m-A*-tree, m-BB-tree m-AOBB-tree solve
25 33 instances [1, 10], BE+m-BF m-AOBF-based schemes
solve 4 8 instances. Table 9 demonstrates m-A*-tree often fastest
algorithms.
930

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

instance
(n,k,w ,h)

50-15-5

i-bound

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

OOM
OOM
8.83
866865
8.75
1967152
3.29
251502
OOM
OOM
OOM
OOM
OOM
Timeout
347.24
17332742
OOM
OOM

number solutions
m=10
time
nodes
OOM
OOM
11.97
1177549
11.91
2647393
34.28
2485393
OOM
OOM
OOM
OOM
OOM
Timeout
692.59
28676212
OOM
OOM

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

OOM
OOM
OOM
Timeout
3290939
289
OOM
OOM
51205
355700
85289
289

OOM
OOM
OOM
Timeout
368.18
16431707
18.47
1220
OOM
OOM
0.39
55783
1.83
421798
116.77
7505310
18.47
1220

OOM
OOM
OOM
Timeout
Timeout
18.67
9534
OOM
OOM
0.89
104621
4.92
892065
Timeout
18.67
9534

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

OOM
OOM
OOM
Timeout
347.24
17332742
OOM
OOM
OOM
OOM
1.3
153399
74.83
14968683
46.53
2450725
OOM
OOM

OOM
OOM
OOM
Timeout
692.59
28676212
OOM
OOM
OOM
OOM
1.88
211547
76.93
15403354
118.26
4940247
OOM
OOM

OOM
OOM
OOM
Timeout
2277.92
75442102
OOM
OOM
OOM
OOM
3.53
362344
85.42
16631321
563.22
18306275
OOM
OOM

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

OOM
OOM
OOM
Timeout
3591.1
119431966
143.11
361
OOM
OOM
14.3
1609506
16.27
4005082
39.66
1367955
143.11
361

OOM
OOM
OOM
Timeout
Timeout
143.11
2330
OOM
OOM
18.76
2029844
22.28
5320573
94.0
3480629
143.11
2330

OOM
OOM
OOM
Timeout
Timeout
144.11
16897
OOM
OOM
28.04
2995437
37.26
8191215
Timeout
144.11
16897

algorithm

m=1
time

10

(400, 2, 27, 99)
18

50-17-5
10

(289, 2, 22, 84)
18

90-20-5

10

(400, 2, 27, 99)

18

75-19-5

10

(361, 2, 25, 89)
18

82.95
18.45

0.35
1.39
1.79
18.45

nodes

m=100
time

nodes
OOM
OOM
20.22
1931039
22.06
4708311
Timeout
OOM
OOM
OOM
OOM
OOM
Timeout
2277.92
75442102
OOM
OOM

Table 6: Grids: CPU time (in seconds) number nodes expanded. Timeout stands
exceeding time limit 3 hours. OOM indicates 4GB memory. bold
highlight best time number nodes m. Parameters: n - number
variables, k - domain size, w - induced width, h - pseudo tree height.

7.2.5 P ROTEIN
Table 10 shows select Protein instances i=4 i=8, respectively. Figure 13 Table 11 show
summary results i=4. benchmark fairly difficult due large domain size
(up 81). heuristic calculation feasible higher i-bounds. particular, BE+m-BF
considerable problems calculating exact heuristic. Even low i-bounds relatively easy
instances solved. Note instances pdb1ctk pdb1dlw i-bound=8 yields exact heuristic.
m-AOBF-tree m-AOBF-graph fail find solutions within memory limit
majority instances, e.g., pdb1b2v pdb1cxy, i=4. much difference
runtimes algorithms, exception m-AOBB-tree. example, pdb1b2v, i=8,
931

fiF LEROVA , ARINESCU , & ECHTER

m-AOBF graph
m-A* tree

m-BB tree
m-AOBB tree
440.64

BE+m-BF
m-AOBF tree

37.26
0.16

10



100

m-BB tree
m-AOBB tree
13
15

13
15
18

13
15

13
15

19

m-AOBF graph
m-A* tree

19

BE+m-BF
m-AOBF tree

0.39

1.04
1.23
0.02

0.38

0.9
1.3
0.01

5

2

2.14
3.23
1.0

22.28

20.16
45.35

17.49
28.04
0.36

1

13
15
18

10-1

0.0

0.35

0.01

100

0.83
0.78

101

1.43
0.88

16.27
20.68

Median time
Grids, i=18

102

91.79

103

6
5
3
3

4

5
5

5
5
4

5

6
4

5

5

Solved instances

Grids, i=18

6

101

100

1

2

5



10

100

Figure 11: Median time number solved instances (out 31) select values
Grids, i-bound=18. Numbers bars - actual values time (sec) # instances.
Total instances benchmark: 32, discarded instances due exact heuristic: 1.

m-AOBB-tree requires 6.46 seconds find m=10 solutions, runtimes algorithms
range 0.03 0.09 seconds (except BE+m-BF runs memory). However,
slow performance m-AOBB-tree easier problems feasible algorithms
compensated fact many instances scheme report solution, solving
932

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

algorithm

solved
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

Grids: # inst=32, n=144-2500
k=2-2, w =15-74, hT =48-312, i-bound=18
m=1
m=2
m=5
m=10
m=100
#BT / #BN #BT / #BN #BT / #BN #BT / #BN #BT / #BN
12
12
13
13
14
0/0
0/0
0/0
0/0
0/0
0/0
0/1
0/2
0/1
0/3
8/2
8/2
8/6
9/6
7/6
1/0
1/0
0/0
1/0
2/2
7 / 10
7 / 10
5/5
5/5
2/2
5/7
5/6
6/5
6/6
6/4

Table 7: Number instances, algorithm best runtime (#BT) best number
expanded nodes (#BN), Grids. 32 instances 1 exact heuristics. table
accounts remaining 31, i-bound= 18 .

instances considerable amount [1, 10] (Figure 13). Table 11 shows m-AOBBtree best terms time space overwhelming majority problems
values except = 100.
7.2.6 EGMENTATION
Table 12 shows results select instances Segmentation benchmark two i-bounds,
namely i=4 i=12, Figure 14 Table 13 present summary results i=12.
Unlike WCSP, benchmark chose display relatively low i-bounds calculating heuristic larger infeasible, problems low induced width
wished avoid displaying results obtained exact heuristics. main peculiarity
benchmark striking success BE+m-BF. Overall solves many instances usually
superior m-A*-tree m-BB-tree, seen Figure 14. Moreover, runtime superior
schemes, true instances Table 12 illustrated results
Table 13. heuristic weak, m-AOBB-tree fairly successful, example, finding
solutions values 12 4 s.binary, i=4, infeasible scheme except
BE+m-BF. However, usual, m-AOBB-tree overall slowest schemes.
7.3 Best-first vs Depth-First Branch Bound Best Solutions
Let us consider data presented Tables 2-13 Figures 9-14 order summarize
observations contrast performance best-first depth-first branch bound schemes.
Among best-first search schemes m-A*-tree successful. often effective,
armed good heuristic, requires less space best-first schemes.
already noted, BE+m-BF shows good results Segmentation benchmark, best
algorithm terms median runtime, solving least number problems
schemes. However, benchmarks calculation exact heuristic often
infeasible.
933

fiF LEROVA , ARINESCU , & ECHTER

instance
(n,k,w ,h)

i-bound

16

(620, 2, 30, 64)

22

(676, 2, 30, 70)

chain 212.fg

12

16

12

(773, 2, 33, 79)
22

chain 50.fg

m=1
time

chain 107.fg

chain 141.fg

algorithm

12

661, 2, 36, 76)
22

nodes

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

OOM
OOM
7.89
919865
14.58
3139711
67.95
1398364
OOM
OOM
OOM
9.2
1093564
17.0
3861414
122.01
3214924
OOM

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

OOM
OOM
OOM
9553.91
1276222668
272.0
9878480
OOM
OOM
OOM
14.16
1261489
279.61
56821714
140.9
6490042
OOM

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

number solutions
m=10
time
nodes
OOM
OOM
18.89
2108122
35.15
7051974
229.49
5134280
OOM
OOM
OOM
20.83
2465364
42.36
9205755
418.46
11123810
OOM

m=100
time

44.61
102.6
627.94

56.59
100.45
855.84

nodes
OOM
OOM
4641627
18494630
13594667
OOM
OOM
OOM
6356871
19217427
21388619
OOM

OOM
OOM
OOM
OOT
25481595
OOM
OOM
OOM
3379926
87947802
14103095
OOM

OOM
OOM
OOM
OOT
2091.26
64400241
OOM
OOM
OOM
OOM
885.72
160581726
909.48
33842266
OOM

OOM
OOM
OOM
Timeout
49808550
OOM
OOM
OOM
1118792
15922806
11336657
OOM

OOM
OOM
OOM
Timeout
4206.07
111853485
OOM
OOM
OOM
33.87
3669711
141.66
27615033
1239.88
24717964
OOM

OOM
OOM
OOM
Timeout
Timeout
OOM
OOM
OOM
78.37
8186757
342.51
58246101
5032.11
86444575
OOM

OOM
OOM
OOM
Timeout
1404.27
33495406
OOM
OOM
OOM
53.87
5673948
91.15
18515503
Timeout
OOM

OOM
OOM
OOM
Timeout
3748.85
93992107
OOM
OOM
OOM
OOM
176.14
34915510
Timeout
OOM

OOM
OOM
OOM
Timeout
10070.0
245628104
OOM
OOM
OOM
OOM
447.46
85945673
Timeout
OOM

1772.8

9.91
78.08
584.83

721.67

38.48
460.15
315.2

Table 8: Promedas: CPU time (in seconds) number nodes expanded. Timeout stands
exceeding time limit 3 hours. OOM indicates 4GB memory. bold
highlight best time number nodes m. Parameters: n - number
variables, k - domain size, w - induced width, h - pseudo tree height.

two m-AOBF-based schemes overall inferior due prohibitively large memory, solving
fewer instances algorithms. believe non-trivial extension AOBF
single solution m-best task straightforward, hard represent multiple
partial solution trees efficient manner. order efficient m-AOBF implementation,
one needs quickly identify partial solution subtree select extend next, searching (k + 1)th solution finding k th best solution. AOBF (for 1 solution) uses
arc-marking mechanism efficiently represent current best partial solution subtree
search, easy extend case searching best solutions. Therefore,
shown Section 5.1, m-AOBF implements naive mechanism par934

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

BE+m-BF
m-AOBF tree

105

m-AOBF graph
m-A* tree

m-BB tree
m-AOBB tree

10



100

m-AOBF graph
m-A* tree

m-BB tree
m-AOBB tree
27
26
8

8

8

8

2

3

4
4

5

6

6

7

7
7

Solved instances

Promedas, i=16

101

8

17

26
27
30

28
27
32

28
27
33

BE+m-BF
m-AOBF tree

1.36
2.97
4.45
3.62

60.1
7.47
0.15
1.55
2.0

3.43
1.95
7.08
0.08

5

2

185.53

325.85

267.69
51.79

146.85
0.03

1

25
27
31

10-1

2.03
1.37

5.19
0.01
0.48
0.62

101

100

7.64

33.68

102

45.83

109.68

Median time
Promedas, i=16

103

1268.88

104

100

1

2

5



10

100

Figure 12: Median time number solved instances (out 86) summary select values
Promedas, i-bound=16. Numbers bars - actual values time (sec) #
instances. Total instances benchmark: 75, discarded instances due exact heuristic:
11.

tial solution trees represented explicitly memory. simple representation, however, incurs
considerable computational overhead searching best solutions, indeed
revealed experiments. efficient implementation m-AOBF left future work.
935

fiF LEROVA , ARINESCU , & ECHTER

algorithm

solved
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

Promedas: # inst=86, n=197-2113
k=2-2, w =5-120, hT =34-187, i-bound=16
m=1
m=2
m=5
m=10
m=100
#BT / #BN #BT / #BN #BT / #BN #BT / #BN #BT / #BN
42
42
45
44
46
0/0
0/0
0/0
0/0
0/0
0/1
0/2
0/2
0/3
0/2
22 / 17
21 / 17
18 / 17
18 / 15
9/9
1/0
1/0
1/0
2/0
10 / 5
4/8
4/8
3/5
4/8
2/7
8/7
8/6
8/6
8/5
8/6

Table 9: Number instances, algorithm best runtime (#BT) best number
expanded nodes (#BN), Promedas. 86 instances 11 exact heuristics.
table accounts remaining 75, i-bound= 16 .

Unsurprisingly, branch bound algorithms robust terms memory
dominate m-A*-tree best-first schemes many benchmarks terms number
instances solved. However, tend considerably larger median time expand
nodes. particular, m-AOBB-tree scale well number solutions large
values runtime increases drastically. Unlike m-AOBF, whose inferior performance
attributed specifics implementation, depth-first m-AOBB suffers issues inherent
solving m-best problem depth-first manner. Algorithm 10 describes, m-AOBB needs
merge best partial solution internal node, hurts performance significantly,
cannot avoided, unless algorithmic approach fundamentally changed.
see way overcome limitation.
Overall, whenever calculation exact heuristic feasible, BE+m-BF
algorithm choice. Otherwise, m-A*-tree superior relatively easy problems, mAOBB-tree best scheme hard memory intensive instances. superiority best-first
approach, whenever memory available, expected, based, one hand, intuition derived
knowledge task finding single solution, hand, theoretical
results Section 3.2.
7.4 Scalability Algorithms Number Required Solutions
Figures 15-17 present plots showing runtime seconds number expanded nodes
function number solutions (on log scale) two instances benchmark.
Figure 15 displays results WCSP Pedigree benchmarks, Figure 16 - Grids Promedas,
Figure 17 - Proteins Segmentation. Lower values (on y-axis) preferable. row
contains two instances benchmarks specific value i-bound, runtime plots
shown ones containing expanded nodes. examples chosen best
illustrate prevailing tendencies.
Note theoretical analysis suggests runtime BE+m-BF, best among

algorithms, scale since worst case complexity O(nk w + mn). theoretical
complexity best-first search schemes m-AOBF-tree m-A*-tree linear number
936

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

instance
(n,k,w ,h)

pdb1b2v

(133, 36, 13, 33)

pdb1cxy

(70, 81, 9, 19)

i-bound

m=1
time

4

8

4

8

pdb1ctj

4

(62, 81, 8, 21)

8

pdb1dlw

4

(84, 81, 8, 29)

algorithm

8

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

nodes
OOM
OOM

0.12
10.23
6.51
0.02
0.03
0.0
0.01
0.29

2508
948337
100584
OOM
95
95
139
2401
6563
OOM

number solutions
m=10
nodes
OOM
OOM
0.17
3186
11.09
1034645
35.14
827365
OOM
0.06
294
0.09
108
0.03
597
0.07
8861
6.46
256588
OOM
time

OOM
OOM
0.38
0.4

3708
51020
OOM
OOM
OOM
0.01
121
0.03
5791
0.66
7029
OOM

10.43
844.08
5.64
0.01
0.0
0.02
0.01
0.01
0.22
0.01

46.17
47.27
187.38
0.01

0.14
1.06
18.53
0.01

OOM
OOM
35400
76609260
74833
62
49
45
62
1118
3098
62
OOM
OOM
579108
6380302
1451906
294
OOM
OOM
6900
162913
154850
294

m=100
time

nodes
OOM
OOM

0.34
14.4
4462.0
0.42
0.64
0.15
0.5

6249
1404370
230849005
OOM
1956
135
3051
67330
Timeout
OOM

OOM
OOM
0.48
0.6

OOM
OOM
4434
73849

OOM

10854
191203
OOM
OOM
OOM
0.1
2870
0.27
53702
44.28
1335157
OOM

OOM
OOM

OOM
OOM

OOM
OOM
OOM
0.04
0.07
2.04

13.23
1039.96
18.29
0.02
0.07
0.11
0.03
0.03
2.32
0.02

46.26
47.33
544.55
0.05

0.18
1.09
157.01
0.05

480
11429
34567

43538
94422614
306054
265
302
74
265
5385
54324
265
OOM
OOM
579405
6391107
12759004
635
OOM
OOM
7240
167037
8632114
635

0.94
1.45

19.74
1325.84
157.43
0.07
0.42
0.75
0.08
0.15
71.86
0.07

46.49
50.72
0.39

0.52
1.86
0.39

65340
120786833
5307198
1050
1825
95
1057
31066
3273324
1050
OOM
OOM
582375
6762911
OOT
4265
OOM
OOM
10855
280189
OOT
4265

Table 10: Protein: CPU time (in seconds) number nodes expanded. Timeout stands
exceeding time limit 3 hours. OOM indicates 4GB memory. bold
highlight best time number nodes m. Parameters: n - number
variables, k - domain size, w - induced width, h - pseudo tree height.

solutions, m-BB-tree overhead due m-best task factor (m log m)
m-AOBB-tree (m log deg), deg degree pseudo tree. observed
compared schemes runtime BE+m-BF indeed rises quite slowly number
solutions increases, even reaches 100. runtime m-A*-tree scales well m.
behaviour m-BB-tree depends lot benchmarks. Pedigrees Protein runtime
changes little instances number solutions grows, benchmarks,
runtime m=100 tends significantly larger m=1. m-AOBF-tree m-AOBFgraph often provide solutions even m=1 or, alternatively, run memory
slightly increases (m [2, 10]). algorithms clearly successful practice.
937

fiF LEROVA , ARINESCU , & ECHTER

BE+m-BF
m-AOBF tree

105

m-AOBF graph
m-A* tree

m-BB tree
m-AOBB tree

1457.61

45.28

41.91

190.28
39.45

177.3
37.46

102

220.64

103

50.72

597.38

Median time
Protein, i=4

104

5

2

10



100

10
10

13
13

13
13

13
13

13
13

Solved instances
Protein, i=4

20

25

35

42
35
25

35

42

m-BB tree
m-AOBB tree

25

35
25

25

35

44

m-AOBF graph
m-A* tree

44

BE+m-BF
m-AOBF tree

0.14
0.38
0.67

2.95

2.89

0.03
0.19
0.39

1

0.01
0.17
0.32

2.87
0.01
0.14
0.27

2.84
0.01
0.13
0.25

100

3.39

101

100

1

2

5



6

6

6

6

6

101

10

100

Figure 13: Median time number solved instances (out 72) select values
Protein, i-bound=4. Numbers bars - actual values time (sec) # instances.
Total instances benchmark: 72, discarded instances due exact heuristic: 0.

discussed before, runtime number expanded nodes m-AOBB-tree increase
drastically gets larger.
938

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

algorithm

solved
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

m=1
#BT / #BN
26
8/3
1 / 10
11 / 9
8/1
21 / 22
6/4

Protein: # inst=72, n=15-242
k=18-81, w =5-16, hT =7-44, i-bound=4
m=2
m=5
m=10
#BT / #BN #BT / #BN #BT / #BN
26
27
27
7/1
7/1
7/0
2 / 12
2 / 12
1 / 13
9/9
12 / 9
14 / 10
9/2
8/3
6/3
21 / 21
18 / 19
17 / 17
6/2
5/2
5/2

m=100
#BT / #BN
34
5/0
1 / 10
17 / 13
11 / 10
3/3
6/2

Table 11: Number instances, algorithm best runtime (#BT) best
number expanded nodes (#BN), Protein. 72 instances 0 exact heuristics.
table accounts remaining 72, i-bound= 4 .

7.5 Comparison Competing Algorithms
compare methods number previously developed schemes described details
Section 6: STRIPES, PESTEELARS Nilssons algorithm. implementations
schemes provided Dhruv Batra. first two approaches based ideas LP relaxations approximate, known often find exact solutions, though provide
guarantees optimality. Nilssons algorithm exact message-passing scheme operating
junction tree. first set experiments (on tree benchmark) show results
STILARS algorithm, older version PESTEELARS algorithm. However, scheme
consistently inferior two LP-based schemes considered two
benchmarks. following, collectively refer 4 algorithms competing schemes.
7.5.1 R ANDOMLY G ENERATED B ENCHMARKS
available us code LP-based Nilssons approaches developed run restricted inputs only, could applied benchmarks used bulk evaluation described above. concluded re-implementing competing codes work general
input would time consuming would provide additional insights. Thus chose
compare algorithms competitors using benchmarks acceptable
competing schemes.
Specifically, comparison performed following three benchmarks: random trees,
random binary grids random graphs submodular potentials, call submodular
graphs remainder section. Table 14 shows parameters benchmarks.
instances generated following manner. First, vector 12 logarithmically spaced integers 10 103.5 generated, serving number variables instances.
binary grids benchmarks value used generate two problems number
variables. edges variables generated uniformly randomly, making
sure end graph tree, grid loopy graph, depending benchmark. edge
define binary potential vertex unary potential exponential form: f = e ,
939

fiF LEROVA , ARINESCU , & ECHTER

instance
(n,k,w ,h)

i-bound

4

(225, 2, 16, 48)

12

(227, 2, 16, 57)

7 9 s.binary

(234, 2, 16, 53)

OOM
OOM
OOM
Timeout
164.91
5653312
0.0
225
7.31
103327
10.47
1843
0.03
3754
0.04
8251
0.08
4158
0.0
225

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

OOM
OOM
OOM
Timeout
71.71
2733703
0.01
227
0.23
3338
0.33
799
0.01
585
0.05
10687
0.21
11076
0.01
227

OOM
OOM
OOM
Timeout
360.14
14906212
0.02
1365
3.75
46121
5.72
1827
0.09
9103
0.19
30119
14.28
1054628
0.02
1365

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

OOM
OOM
OOM
Timeout
127.17
3337949
0.01
234
8.85
122663
OOM
0.02
1978
0.03
4415
0.05
2750
0.01
234

OOM
OOM
OOM
Timeout
505.08
17976200
0.03
1337
OOM
OOM
0.06
4170
0.11
13357
10.54
806490
0.03
1337

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

OOM
OOM
OOM
Timeout
110.19
4227437
0.01
231
OOM
OOM
1.02
102671
2.07
428791
0.75
39170
0.01
231

OOM
OOM
OOM
Timeout
555.6
23302165
0.03
1615
OOM
OOM
1.17
115407
2.9
527967
11.99
809403
0.03
1615

m=1
time

12 4 s.binary

16 16 s.binary

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

number solutions
m=10
nodes
OOM
OOM
OOM
Timeout
505.82
18888321
0.02
1619
10.36
143333
OOM
0.06
5692
0.21
24349
1.62
118074
0.02
1619

algorithm

4

12

4

12

11 4 s.binary

4

(231, 2, 16, 57)

12

nodes

time

m=100
time

nodes
OOM
OOM
OOM
Timeout
4371.05
189179726
0.21
11194
OOM
OOM
0.3
18616
1.32
131571
489.57
40961080
0.21
11194

0.19

0.38
1.2
0.19

0.21

0.28
0.95
0.21

OOM
OOM
OOM
Timeout
OOT
11157
OOM
OOM
30542
141591
OOT
11157
OOM
OOM
OOM
Timeout
OOT
10212
OOM
OOM
15807
89675
OOT
10212

OOM
OOM
OOM
Timeout
OOT
0.28
14241
OOM
OOM
1.86
167983
7.1
1010155
8497.93
617227854
0.28
14241

Table 12: Segmentation: CPU time (in seconds) number nodes expanded. Timeout
stands exceeding time limit 3 hours. OOM indicates 4GB memory.
bold highlight best time number nodes m. Parameters: n - number
variables, k - domain size, w - induced width, h-pseudo tree height.

real number sampled uniform distribution. third benchmark potentials modified submodular. random trees m-best optimization LP
problem guaranteed tight, graphs submodular potentials LP optimization
problem tight, m-best extension not, arbitrary loopy graphs, including grids,
algorithms provide guarantees.
7.5.2 C OMPETING LGORITHMS P ERFORMANCE
Table 15 shows runtimes select instances random tree benchmark 5 mbest search schemes competing LP schemes STILARS, PESTEELARS STRIPES.
940

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

BE+m-BF
m-AOBF tree

m-AOBF graph
m-A* tree

m-BB tree
m-AOBB tree

105

1949.3

103

5

100

13

14
14

18

19

20

24

24
24
24

m-BB tree
m-AOBB tree

24

24
24
24

24
20

24

24
24
24

m-AOBF graph
m-A* tree

20
20

21
20

Solved instances
Segmentation, i=12

24

24
24
24

BE+m-BF
m-AOBF tree

101

10



24
24

2

0.02
0.31
0.4
0.03
0.08

1

10-1

0.01
0.22
0.26
0.02
0.04
0.7

0.01
0.15
0.2
0.01
0.03
0.04

100

3.94

101

0.17
1.1
1.55
0.17
0.65

102

0.0
0.08
0.1
0.01
0.01
0.03

Median time
Segmentation, i=12

104

1

2

5



10

100

Figure 14: Median time number solved instances (out 47) select values
Segmentation, i-bound=12. Numbers bars - actual values time (sec) #
instances. Total instances benchmark: 47, discarded due exact heuristic: 0.

observed benchmarks STILARS always inferior two schemes
therefore excluded remainder evaluation. Instead, Tables 16 17,
show results random binary grids submodular graphs benchmarks, added
comparison Nilssons max-flow algorithm. Table 15-17 time limit set 1 hour,
memory limit 3 GB. schemes behavior quite consistent across instances.
941

fiF LEROVA , ARINESCU , & ECHTER

Time vs m. WCSPs: bwt3ac.wcsp

Time vs m. WCSPs: queen5_5_3.wcsp

(45, 11, 16, 27), i=4

(25, 3, 18, 21), i=16

7

15

6

Time, sec

Time, sec

5
10

5

4
3
2
1

0

0

1.0

10.0

Number solutions

m-AOBF-tree
m-AOBF-graph

2.0

1e6

m-A*-tree
m-BB-tree

100.0

1.0

m-AOBB-tree
BE+m-BF

10.0

m-AOBF-tree
m-AOBF-graph

Nodes vs m. WCSPs: bwt3ac.wcsp
(45, 11, 16, 27), i=4
1.4

1e6

100.0

Number solutions
m-A*-tree
m-BB-tree

m-AOBB-tree
BE+m-BF

Nodes vs m. WCSPs: queen5_5_3.wcsp
(25, 3, 18, 21), i=16

1.2
1.5

1.0

Nodes

Nodes

0.8

1.0

0.6

0.5

0.4

0.0

0.0

0.2

1.0

10.0

Number solutions

m-AOBF-tree
m-AOBF-graph

m-A*-tree
m-BB-tree

100.0

1.0

m-AOBB-tree
BE+m-BF

m-AOBF-tree
m-AOBF-graph

m-A*-tree
m-BB-tree

100.0

m-AOBB-tree
BE+m-BF

Time vs m. Pedigrees: pedigree9

Time vs m. Pedigrees: pedigree30

(1290, 5, 20, 105), i=16

(1119, 7, 25, 123), i=22

1400

2000

1200

1500

Time, sec

1000

Time, sec

10.0

Number solutions

800

1000

600
400
200
0

500
0

1.0

10.0

Number solutions

m-AOBF-tree
m-AOBF-graph

m-A*-tree
m-BB-tree

100.0

1.0

m-AOBB-tree
BE+m-BF

m-AOBF-tree
m-AOBF-graph

Nodes vs m. Pedigrees: pedigree30
1e7

10.0

Number solutions
m-A*-tree
m-BB-tree

100.0

m-AOBB-tree
BE+m-BF

Nodes vs m. Pedigrees: pedigree9

(1290, 5, 20, 105), i=16

5

3

(1119, 7, 25, 123), i=22

Nodes

4

1.5

Nodes

2.0

1e7

1.0

2

0.5

1

0.0

0
1.0

10.0

Number solutions

m-AOBF-tree
m-AOBF-graph

m-A*-tree
m-BB-tree

100.0

1.0

m-AOBB-tree
BE+m-BF

10.0

Number solutions

m-AOBF-tree
m-AOBF-graph

m-A*-tree
m-BB-tree

100.0

m-AOBB-tree
BE+m-BF

Figure 15: CPU time seconds number expanded nodes function number solutions. WCSP Pedigrees, 4 GB, 3 hours.

942

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

Time vs m. Grids: 50-19-5

Time vs m. Grids: 75-18-5

(361, 2, 25, 93), i=18

(324, 2, 24, 85), i=18

40

3500
3000
2500
2000
1500
1000
500
0

Time, sec

Time, sec

30
20
10
0
1.0

10.0

100.0

Number solutions

m-AOBF-tree
m-AOBF-graph

m-A*-tree
m-BB-tree

1.0

m-AOBB-tree
BE+m-BF

m-AOBF-tree
m-AOBF-graph

Nodes vs m. Grids: 50-19-5
6

7
6
5
4
3
2
1
0

m-A*-tree
m-BB-tree

m-AOBB-tree
BE+m-BF

(324, 2, 24, 85), i=18

1e5

5

Nodes

Nodes

4
3
2
1
0

1.0

10.0

100.0

Number solutions

m-AOBF-tree
m-AOBF-graph

m-A*-tree
m-BB-tree

1.0

m-AOBB-tree
BE+m-BF

10.0

100.0

Number solutions

m-AOBF-tree
m-AOBF-graph

Time vs m. Promedas: or_chain_17.fg

m-A*-tree
m-BB-tree

m-AOBB-tree
BE+m-BF

Time vs m. Promedas: or_chain_212.fg
(773, 2, 33, 79), i=22

(531, 2, 19, 51), i=16

5000

10

4000

8

Time, sec

Time, sec

100.0

Nodes vs m. Grids: 75-18-5

(361, 2, 25, 93), i=18

8 1e8

10.0

Number solutions

3000

6

2000

4

1000

2
0

0
1.0

10.0

m-AOBF-tree
m-AOBF-graph

1e5

100.0

Number solutions
m-A*-tree
m-BB-tree

1.0

m-AOBB-tree
BE+m-BF

10.0

m-AOBF-tree
m-AOBF-graph

Nodes vs m. Promedas: or_chain_17.fg
(531, 2, 19, 51), i=16

1e8

0.6

m-A*-tree
m-BB-tree

m-AOBB-tree
BE+m-BF

Nodes vs m. Promedas: or_chain_212.fg
(773, 2, 33, 79), i=22

Nodes

0.8

3

Nodes

4

100.0

Number solutions

0.4

2
1

0.2

0

0.0
1.0

10.0

Number solutions

m-AOBF-tree
m-AOBF-graph

m-A*-tree
m-BB-tree

100.0

1.0

m-AOBB-tree
BE+m-BF

10.0

Number solutions

m-AOBF-tree
m-AOBF-graph

m-A*-tree
m-BB-tree

100.0

m-AOBB-tree
BE+m-BF

Figure 16: CPU time seconds number expanded nodes function number solutions. Grids Promedas, 4 GB, 3 hours.

943

fiF LEROVA , ARINESCU , & ECHTER

Time vs m. Protein: pdb1at0

Time vs m. Protein: pdb1b2v

(122, 81, 8, 25), i=4

(133, 36, 13, 33), i=8

800
700
600
500
400
300
200
100
0

7
6

Time, sec

Time, sec

5
4
3
2
1
0
1.0

10.0

100.0

Number solutions

m-AOBF-tree
m-AOBF-graph

m-A*-tree
m-BB-tree

1.0

m-AOBB-tree
BE+m-BF

m-AOBF-tree
m-AOBF-graph

Nodes vs m. Protein: pdb1at0

m-AOBB-tree
BE+m-BF

2.5
2.0

0.6

Nodes

Nodes

1.5

0.4

1.0

0.2

0.5

0.0

0.0
1.0

10.0

100.0

Number solutions

m-AOBF-tree
m-AOBF-graph

m-A*-tree
m-BB-tree

1.0

m-AOBB-tree
BE+m-BF

10.0

100.0

Number solutions

m-AOBF-tree
m-AOBF-graph

m-A*-tree
m-BB-tree

m-AOBB-tree
BE+m-BF

Time vs m. Segmentation: 10_16_s.binary

Time vs m. Segmentation: 7_29_s.binary

(230, 2, 15, 52), i=4

(234, 2, 15, 63), i=12

10000

8

8000

6

Time, sec

Time, sec

m-A*-tree
m-BB-tree

(133, 36, 13, 33), i=8

1e5

0.8

6000

4

4000

2

2000

0

0

1.0

10.0

100.0

Number solutions

m-AOBF-tree
m-AOBF-graph

m-A*-tree
m-BB-tree

1.0

m-AOBB-tree
BE+m-BF

10.0

100.0

Number solutions

m-AOBF-tree
m-AOBF-graph

m-A*-tree
m-BB-tree

m-AOBB-tree
BE+m-BF

Time vs m. Segmentation: 10_16_s.binary

Time vs m. Segmentation: 7_29_s.binary

(230, 2, 15, 52), i=4

(234, 2, 15, 63), i=12

10000

8

8000

6

Time, sec

Time, sec

100.0

Nodes vs m. Protein: pdb1b2v

(122, 81, 8, 25), i=4

1e7

10.0

Number solutions

6000

4

4000
2000

2

0

0
1.0

10.0

Number solutions

m-AOBF-tree
m-AOBF-graph

m-A*-tree
m-BB-tree

100.0

1.0

m-AOBB-tree
BE+m-BF

10.0

Number solutions

m-AOBF-tree
m-AOBF-graph

m-A*-tree
m-BB-tree

100.0

m-AOBB-tree
BE+m-BF

Figure 17: CPU time seconds number expanded nodes function number solutions. Protein Segmentation, 4 GB, 3 hours.

944

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

algorithm

solved
m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
BE+m-BF

Segmentation: # inst=47, n=222-234
k=2-21, w =15-18, hT =47-67, i-bound=12
m=1
m=2
m=5
m=10
m=100
#BT / #BN #BT / #BN #BT / #BN #BT / #BN #BT / #BN
23
23
23
23
23
0/5
0/0
0/0
0/0
0/0
0/5
0/7
0 / 11
0 / 15
0 / 14
15 / 0
11 / 0
12 / 0
11 / 0
3/0
7/0
5/0
3/0
2/0
0/0
0/0
3/0
0/0
0/0
0/0
21 / 19
20 / 17
22 / 13
24 / 9
24 / 10

Table 13: Number instances, algorithm best runtime (#BT) best number expanded nodes (#BN), Segmentation. 47 instances 0 exact heuristics.
table accounts remaining 47, i-bound= 12 .

Benchmark
Random trees
Random Binary Grids
Random submodular graphs

# inst
12
24
12

n
10-5994
16-3192
16-3192

k
2-4
2
2

w
1
6-79
4-74

hT
5-132
9-221
9-208

Table 14: Benchmark parameters: # inst - number instances, n - number variables, k - domain
size, w - induced width, hT - pseudo tree height.

STILARS Nilssons schemes always dominated two competing schemes
terms runtime. STRIPES PESTEELARS sometimes faster schemes
m=1, e.g. tree nnodes880 ps1 k4, however, three benchmark scale rather poorly
m. 5 almost always inferior algorithms, provided latter report
results, occasional exception m-AOBB-tree, tends slow large m.
problems PESTEELARS STRIPES superior search schemes
largest networks 1000 variables, grid nnodes3192 ps2 k2,
infeasible algorithms. Overall, five m-best algorithms proved superiority
considered competing schemes majority instances, often better runtime, especially
> 2, guaranteeing solution optimality.

8. Conclusion
work finding best solutions graphical models focused either iterative
schemes based Lawlers idea dynamic programming (e.g., variable-elimination treeclustering). showed first time combinatorial optimization defined graphical
models traditional heuristic search paradigms directly applicable, often superior.
Specifically, extended best-first depth-first branch bound search algorithms solve
m-best optimization task, presenting m-A* m-BB, respectively. showed properties A* extend m-A* algorithm and, particular, proved m-A* superior
945

fiF LEROVA , ARINESCU , & ECHTER

instance

tree nnodes245 ps1 k2

(245, 2, 2, 32)

tree nnodes880 ps1 k4

(880, 4, 2, 52)

tree nnodes5994 ps1 k4

(5994, 4, 2, 189)

algorithm

i-bound=4. k=2
m=5
m=10
time
time
0.05
0.09
0.08
0.13
0.01
0.02
0.02
0.03
0.06
14.14
7.93
33.3
0.4
0.88
0.51
1.32

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
STILARS
STRIPES
PESTEELARS

m=1
time
0.02
0.02
0.0
0.0
0.02
0.0
0.09
0.0

m=2
time
0.02
0.03
0.0
0.0
0.02
0.04
0.17
0.13

m=100
time
0.61
0.95
0.12
0.37
3045.25
1757.41
13.88
47.32

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
STILARS
STRIPES
PESTEELARS

0.3
0.48
0.08
0.1
1.17
0.0
5.67
0.0

0.46
0.76
0.17
0.3
1.37
0.11
11.26
0.87

1.06
1.8
0.24
0.54
52.36
28.19
28.09
6.13

1.9
3.28
0.48
1.23
927.12
81.21
56.41
9.26

OOM
OOM
3.67
14.38
Timeout
2440.22
607.01
79.0

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
STILARS
STRIPES
PESTEELARS

OOM
OOM
5.44
5.77
851.48
0.05
248.53
0.05

OOM
OOM
10.68
29.04
922.19
2.72
506.25
18.28

OOM
OOM
18.31
36.49
Timeout
64.48
1279.87
91.17

OOM
OOM
37.21
97.73
Timeout
250.36
2576.87
169.39

OOM
OOM
206.26
1112.2
Timeout
7325.4
Timeout
Timeout

Table 15: Random trees, i-bound=4. Timeout - time, OOM - memory. 3 GB, 1 hour.
search scheme m-best task. analyzed overhead algorithms caused
need find multiple solutions. introduced BE+m-BF, hybrid variable elimination
best-first search scheme showed best worst-case time complexity among
m-best algorithms graphical models known us.
evaluated schemes empirically. observed AND/OR decomposition
search space, significantly boosts performance traditional heuristic search schemes,
cost-effective m-best search algorithms, least current implementation.
expected, best-first schemes dominate branch bound algorithms whenever sufficient
space available, fail memory-intensive problems. compared schemes 4
previously developed algorithms: three approximate schemes based LP-relaxation problem algorithm performing message passing junction tree. showed schemes
often dominate competing schemes, known efficient, terms runtime, especially
required number solutions large. Moreover, scheme guarantee solution optimality.

Acknowledgement
work sponsored part NSF grants IIS-1065618 IIS-1254071, United
States Air Force Contract No. FA8750-14-C-0011 DARPA PPAML program.

946

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

instance

grid nnodes380 ps1 k2

(380, 2, 25, 379)

grid nnodes380 ps2 k2

(380, 2, 25, 61)

grid nnodes3192 ps2 k2

(3192, 2, 75, 217)

algorithm

m=2
time
Random binary grid

i-bound=20
m=5
m=10
time
time

m=25
time

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
Nilsson
STRIPES
PESTEELARS

OOM
OOM
0.49
0.56
55.93
112.5
5.06
4.63

OOM
OOM
0.53
0.64
106.34
772.49
46.57
13.4

OOM
OOM
0.58
0.71
202.65
1860.46
172.95
28.95

OOM
OOM
0.67
0.91
2027.66
5026.68
361.04
75.28

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
Nilsson
STRIPES
PESTEELARS

OOM
OOM
0.2
0.32
7.62
110.4
2.23
3.98

OOM
OOM
0.23
0.36
12.82
757.14
19.41
11.5

OOM
OOM
0.26
0.58
67.59
1820.45
38.54
24.34

OOM
OOM
0.36
0.95
1964.18
4985.0
Timeout
Timeout

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
Nilsson
STRIPES
PESTEELARS

OOM
OOM
OOM
Timeout
Timeout
OOM
123.45
26.86

OOM
OOM
OOM
Timeout
Timeout
OOM
658.05
81.27

OOM
OOM
OOM
Timeout
Timeout
OOM
3035.29
172.35

OOM
OOM
OOM
Timeout
Timeout
OOM
Timeout
Timeout

Table 16: Random binary grids, i-bound=20. Timeout - time, OOM - memory. 3 GB,
1 hour.

947

fiF LEROVA , ARINESCU , & ECHTER

instance

gen nnodes132 ps1 k2

(132, 2, 13, 34)

gen nnodes380 ps1 k2

(380, 2, 25, 61)

gen nnodes1122 ps1 k2

(1122, 2, 43, 112)

algorithm

i-bound=20
m=5
m=10
time
time
0.02
0.03
0.03
0.06
0.01
0.02
0.0
0.03
0.09
5.44
60.81
144.93
1.32
3.13
8.52
18.56

m=25
time
0.05
0.09
0.02
0.05
120.67
394.26
13.24
48.76

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
Nilsson
STRIPES
PESTEELARS

m=2
time
0.01
0.01
0.0
0.0
0.03
9.34
0.5
2.9

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
Nilsson
STRIPES
PESTEELARS

OOM
OOM
0.47
0.54
51.77
105.58
2.07
4.38

OOM
OOM
0.51
0.61
110.96
728.0
6.2
14.09

OOM
OOM
0.57
0.73
141.68
1753.98
13.21
29.96

OOM
OOM
0.72
1.03
2027.05
4817.09
76.0
75.04

m-AOBF tree
m-AOBF graph
m-A* tree
m-BB tree
m-AOBB tree
Nilsson
STRIPES
PESTEELARS

OOM
OOM
OOM
Timeout
Timeout
OOM
16.46
9.69

OOM
OOM
OOM
Timeout
Timeout
OOM
57.96
28.84

OOM
OOM
OOM
Timeout
Timeout
OOM
107.73
61.04

OOM
OOM
OOM
Timeout
Timeout
OOM
282.4
158.7

Table 17: Random loopy graphs submodular potentials, i-bound=20. Timeout - time,
OOM - memory. 3 GB, 1 hour.

948

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

Figure 18: Example AND/OR search tree 3 layers nodes.

Appendix A. Proof Theorem 13
Let ST AND/OR search tree relative pseudo tree depth h, n number
variables, k maximum domain size, deg maximum degree nodes .
Define partial solution subtree 0 subtree ST that: (1) 0 contains root
ST ; (2) non-terminal node n 0 , 0 contains exactly one child node n0
n; (3) non-terminal node n 0 0 contains child nodes n01 , . . . , n0j n;
(4) leaf tip node 0 doesnt successors 0 .
nodes ST grouped layers. h layers ith layer, denoted
Li , 1 h, contains nodes whose variables depth , together
children. assume root depth 1. illustration, Figure 18 depicts
AND/OR search tree 3 layers, example L1 = {A, hA, 0i, hA, 1i}.
denote TiOR set partial solution subtrees whose leaf nodes nodes Li .
Similarly, TiAN set partial solution subtrees whose leaf nodes nodes Li .
partial solution subtree 0 T2OR whose leaf nodes nodes belonging 2nd layer
highlighted Figure 18, namely 0 = {A, hA, 0i, B, C}.
L EMMA 1. Given 0 TiOR 00 TiAN 00 extension 0 , 0 00
number leaf nodes.
Proof. Let number leaf nodes 0 . definition, nodes
extended exactly one child node 00 . follows 00 leaf nodes.
L EMMA 2. Given 0 TiOR , number leaf nodes 0 , denoted mi , deg i1 .
Proof. show induction mi = deg i1 . = 1 m1 = 1. Assume = p 1,
. first extend 0 00 . Lemma 1, 00 0
mp1 = deg p2 , let 0 Tp1
p1
number leaf nodes, namely mp1 . Next, extend 00 000 TpOR . Since
mp1 leaf nodes 00 deg child nodes 000 , follows mp ,
number leaf nodes 000 mp = mp1 deg = deg p2 deg = deg p1 .
Proof Theorem 13 Consider number partial solution subtrees N contained ST :
949

fiF LEROVA , ARINESCU , & ECHTER

N=

h
X

(NiOR + NiAN )

(3)

i=1

NiOR


= |TiOR | NiAN = |TiAN |, respectively.
0
, easy see 0 extended single partial solution subtree
Given Ti1
00

Ti leaf nodes 0 deg child nodes 00 . Therefore:

NiOR = Ni1

(4)

Given 0 TiOR , 0 extended k partial solution subtrees 00 TiAN
leaf nodes 0 exactly one child node 00 k
bounds domain size. Lemmas 1 2, that:
NiAN = NiOR k deg

i1

(5)

Using Equations 4 5, well N1OR = 1, rewrite Equation 3 follows:
N = (1 + k)
+ (k + k deg+1 )
+ (k deg+1 + k deg

2 +deg+1

)
(6)

+ ...
+ (k deg
O(k

h2 +deg h3 +...+1

deg h 1
deg1

+ k deg

h1 +deg h2 +...+1

)

)

Thus, worst-case number partial solution subtrees need stored OPEN
h1
h1
N O(k deg ). Therefore, time space complexity m-AOBF follows O(k deg ).
pseudo tree balanced, namely internal node exactly deg child nodes,
time space complexity bound O(k n ), since n O(deg h1 ).

References
Aljazzar, H., & Leue, S. (2011). K : heuristic search algorithm finding k shortest paths.
Artificial Intelligence, 175(18), 21292154.
Batra, D. (2012). efficient message-passing algorithm M-best MAP problem. Uncertainty
Artificial Intelligence.
Charniak, E., & Shimony, S. (1994). Cost-based abduction MAP explanation. Artificial Intelligence, 66(2), 345374.
Darwiche, A. (2001). Decomposable negation normal form. Journal ACM (JACM), 48(4),
608647.
Darwiche, A., Dechter, R., Choi, A., Gogate, V., & Otten, L. (2008).
Results probablistic inference evaluation UAI08, web-report
http://graphmod.ics.uci.edu/uai08/Evaluation/Report.
In: Uncertainty Artificial Intelligence applications workshop.
950

fiS EARCHING B EST OLUTIONS G RAPHICAL ODELS

de Campos, L. M., Gamez, J. A., & Moral, S. (1999). Partial abductive inference bayesian belief
networks using genetic algorithm. Pattern Recognition Letters, 20(11), 12111217.
de Campos, L. M., Gamez, J. A., & Moral, S. (2004). Partial abductive inference bayesian networks using probability trees. Enterprise Information Systems V, pp. 146154. Springer.
Dechter, R. (1999). Bucket elimination: unifying framework reasoning. Artificial Intelligence,
113(1), 4185.
Dechter, R., & Mateescu, R. (2007). AND/OR search spaces graphical models. Artificial Intelligence, 171(2-3), 73106.
Dechter, R., & Rish, I. (2003). Mini-buckets: general scheme bounded inference. Journal
ACM, 50(2), 107153.
Dechter, R. (2013). Reasoning probabilistic deterministic graphical models: Exact algorithms. Synthesis Lectures Artificial Intelligence Machine Learning, 7(3), 1191.
Dechter, R., & Pearl, J. (1985). Generalized best-first search strategies optimality A*.
Journal ACM (JACM), 32(3), 505536.
Dijkstra, E. W. (1959). note two problems connexion graphs. Numerische mathematik,
1(1), 269271.
Elliott, P. (2007). Extracting K Best Solutions Valued And-Or Acyclic Graph. Masters
thesis, Massachusetts Institute Technology.
Eppstein, D. (1994). Finding k shortest paths. Proceedings 35th Symposium Foundations Computer Science, pp. 154165. IEEE Comput. Soc. Press.
Fishelson, M., & Geiger, D. (2002). Exact genetic linkage computations general pedigrees.
International Conference Intelligent Systems Molecular Biology (ISMB), pp. 189198.
Fishelson, M. a., Dovgolevsky, N., & Geiger, D. (2005). Maximum likelihood haplotyping
general pedigrees. Human Heredity, 59(1), 4160.
Flerova, N., Dechter, R., & Rollon, E. (2011). Bucket mini-bucket schemes best solutions
graphical models. Graph structures knowledge representation reasoning
workshop.
Fromer, M., & Globerson, A. (2009). lp view m-best map problem. Advances Neural
Information Processing Systems, 22, 567575.
Ghosh, P., Sharma, A., Chakrabarti, P., & Dasgupta, P. (2012). Algorithms generating ordered
solutions explicit AND/OR structures. Journal Artificial Intelligence (JAIR), 44(1),
275333.
Gogate, V. G. (2009). Sampling Algorithms Probabilistic Graphical Models Determinism
DISSERTATION. Ph.D. thesis, University California, Irvine.
Hamacher, H., & Queyranne, M. (1985). K best solutions combinatorial optimization problems.
Annals Operations Research, 4(1), 123143.
Ihler, A. T., Flerova, N., Dechter, R., & Otten, L. (2012). Join-graph based cost-shifting schemes.
arXiv preprint arXiv:1210.4878.
Kask, K., & Dechter, R. (1999a). Branch bound mini-bucket heuristics. IJCAI, Vol. 99,
pp. 426433.
951

fiF LEROVA , ARINESCU , & ECHTER

Kask, K., & Dechter, R. (1999b). Mini-bucket heuristics improved search. Proceedings
Fifteenth conference Uncertainty artificial intelligence, pp. 314323. Morgan
Kaufmann Publishers Inc.
Kjrulff, U. (1990). Triangulation graphsalgorithms giving small total state space. Tech. Report
R-90-09.
Lawler, E. (1972). procedure computing k best solutions discrete optimization problems
application shortest path problem. Management Science, 18(7), 401405.
Marinescu, R., & Dechter, R. (2009a). AND/OR Branch-and-Bound search combinatorial optimization graphical models. Artificial Intelligence, 173(16-17), 14571491.
Marinescu, R., & Dechter, R. (2009b). Memory intensive AND/OR search combinatorial optimization graphical models. Artificial Intelligence, 173(16-17), 14921524.
Marinescu, R., & Dechter, R. (2005). AND/OR branch-and-bound graphical models. International Joint Conference Artificial Intelligence, Vol. 19, p. 224. Lawrence Erlbaum
Associates Ltd.
Nillson, N. J. (1980). Principles Artificial Intelligence. Tioga, Palo Alto, CA.
Nilsson, D. (1998). efficient algorithm finding probable configurations probabilistic expert systems. Statistics Computing, 8(2), 159173.
Nilsson, N. (1982). Principles artificial intelligence. Springer Verlag.
Otten, L., & Dechter, R. (2011). Anytime AND/OR depth first search combinatorial optimization. SOCS.
Pearl, J. (1984). Heuristics: Intelligent Search Strategies. Addison-Wesley.
Schiex, T. (2000). Arc consistency soft constraints. International Conference Principles
Practice Constraint Programming (CP), 411424.
Seroussi, B., & Golmard, J. (1994). algorithm directly finding K probable configurations Bayesian networks. International Journal Approximate Reasoning, 11(3), 205
233.
Wainwright, M. J., & Jordan, M. I. (2003). Variational inference graphical models: view
marginal polytope. Proceedings Annual Allerton congerence communication
control computing, Vol. 41, pp. 961971. Citeseer.
Wemmenhove, B., Mooij, J. M., Wiegerinck, W., Leisink, M., Kappen, H. J., & Neijt, J. P. (2007).
Inference promedas medical expert system. Artificial intelligence medicine, pp.
456460. Springer.
Yanover, C., & Weiss, Y. (2004). Finding Probable Configurations Using Loopy Belief
Propagation. Advances Neural Information Processing Systems 16. MIT Press.
Yanover, C., Schueler-Furman, O., & Weiss, Y. (2008). Minimizing learning energy functions
side-chain prediction. Journal Computational Biology, 15(7), 899911.

952


