journal artificial intelligence

submitted published

parallel model diagnosis multi core computers
dietmar jannach
thomas schmitz

dietmar jannach tu dortmund de
thomas schmitz tu dortmund de

tu dortmund germany

kostyantyn shchekotykhin

kostyantyn shchekotykhin aau

alpen adria university klagenfurt austria

abstract
model diagnosis mbd principled domain independent way analyzing system examination behaving expected given abstract
description model systems components behavior functioning normally mbd techniques rely observations actual system behavior reason
possible causes discrepancies expected observed behavior due generality mbd successfully applied variety application
domains last decades
many application domains mbd testing different hypotheses reasons
failure computationally costly e g complex simulations system behavior performed work therefore propose different schemes
parallelizing diagnostic reasoning process order better exploit capabilities
modern multi core computers propose systematically evaluate parallelization
schemes reiters hitting set finding leading minimal diagnoses two different conflict detection techniques furthermore perform initial
experiments basic depth first search strategy assess potential parallelization
searching one single diagnosis finally test effects parallelizing direct
encodings diagnosis constraint solver

introduction
model diagnosis mbd subfield artificial intelligence concerned
automated determination possible causes system behaving expected
early days mbd diagnosed systems typically hardware artifacts
electronic circuits contrast earlier heuristic diagnosis approaches connected
symptoms possible causes e g expert rules buchanan shortliffe
mbd techniques rely abstract explicit representation model examined
system contain information systems structure e list
components connected well information behavior
components functioning correctly model available expected behavior outputs system given inputs thus calculated diagnosis
arises whenever expected behavior conflicts observed system behavior mbd
techniques core construct test hypotheses faultiness individual
components system finally diagnosis considered subset components
assumed faulty explain observed behavior system
reiter suggests formal logical characterization diagnosis
first principles proposed breadth first tree construction determine
c

ai access foundation rights reserved

fijannach schmitz shchekotykhin

diagnoses given due generality used knowledge representation
language suggested computation diagnoses mbd
later applied variety application hardware application
fields mbd example include diagnosis knowledge bases ontologies process
specifications feature user interface specifications user preference statements
types software artifacts including functional logic programs well
vhdl java spreadsheet programs felfernig friedrich jannach stumptner
mateis stumptner wieland wotawa jannach schmitz wotawa b
felfernig friedrich isak shchekotykhin teppan jannach console friedrich
dupre friedrich shchekotykhin stumptner wotawa friedrich
stumptner wotawa white benavides schmidt trinidad dougherty cortes
friedrich fugini mussi pernici tagni
several application fields search diagnoses requires repeated computations modified versions original model test different hypotheses
faultiness individual components several works original
converted constraint satisfaction csp number relaxed versions
original csp solved construct node search tree felfernig
et al jannach schmitz white et al depending application domain computation csp solutions check consistency however
computationally intensive actually represents costly operation
construction search tree similar arise underlying reasoning
techniques e g ontology debugging friedrich shchekotykhin used
current mbd sequential nature generate one node time
therefore exploit capabilities todays multi core computer processors
nowadays found even mobile devices propose schemes
parallelize diagnostic reasoning process better exploit available computing
resources modern computer hardware particular work comprises following
algorithmic contributions insights experimental evaluations
propose two parallel versions reiters sound complete hitting set
hs speed process finding diagnoses common
setting described mbd applications approaches
considered window parallelization schemes means limited number search nodes processed parallel point time
evaluate two different conflict detection techniques multi core setting
goal leading diagnoses set experiments multiple conflicts computed construction tree node novel
mergexplain method mxp shchekotykhin jannach schmitz
processing time therefore implicitly allocated conflict generation
demonstrate speedups achieved parallelization scenarios search one single diagnosis e g basic parallel
depth first strategy
measure improvements achieved parallel constraint solving
direct csp encoding diagnosis experiment


fiparallel model diagnosis multi core computers

illustrates parallelization underlying solvers particular
direct encoding advantageous
evaluate proposed parallelization schemes extensive set experiments following settings analyzed
standard benchmark diagnosis community
ii mutated csps constraint programming competition domain
csp spreadsheet debugging jannach schmitz
iii faulty owl ontologies used evaluation mbd debugging techniques
expressive ontologies shchekotykhin friedrich fleiss rodler
iv synthetically generated allow us vary characteristics
underlying diagnosis
parallelization techniques help achieve substantial
speedups diagnosis process across variety application scenarios b without
exploiting specific knowledge structure underlying diagnosis
c across different encodings application ontology
debugging cannot efficiently encoded sat
outline follows next section define main concepts
mbd introduce used compute diagnoses section present
systematically evaluate parallelization schemes reiters hs tree method
goal minimal diagnoses section report evaluations
implicitly allocate processing time conflict generation mxp
conflict detection section assess potential gains comparably simple
randomized depth first strategy hybrid technique finding one
single diagnosis experiments direct csp encoding reported
section section discuss previous works ends summary
outlook section

reiters diagnosis framework
section summarizes reiters diagnosis framework use basis
work
definitions
reiter formally characterized model diagnosis first order logic
main definitions summarized follows
definition diagnosable system diagnosable system described pair sd
comps sd system description set logical sentences comps represents
systems components finite set constants
connections components normal behavior components
described terms logical sentences normal behavior system components


fijannach schmitz shchekotykhin

usually described sd help distinguished negated unary predicate ab
meaning abnormal
diagnosis arises observation p obs systems input output
behavior expressed first order sentences deviates expected system behavior diagnosis corresponds subset systems components
assume behave abnormally faulty assumptions must consistent
observations words malfunctioning components
possible reason observations
definition diagnosis given diagnosis sd comps obs diagnosis
subset minimal set comps sd obs tab c c p u abpcq c p
compszu consistent
according definition interested minimal diagnoses e diagnoses
contain superfluous elements thus supersets diagnoses whenever use term diagnosis remainder therefore mean minimal
diagnosis whenever refer non minimal diagnoses explicitly mention fact
finding diagnoses theory done simply trying possible subsets
comps checking consistency observations reiter however
proposes efficient procedure concept conflicts
definition conflict conflict sd comps obs set tc ck u comps
sd obs abpc q abpck qu inconsistent
conflict corresponds subset components assumed behave normally
consistent observations conflict c considered minimal
proper subset c exists conflict
hitting set
reiter discusses relationship conflicts diagnoses claims
theorem set diagnoses collection minimal conflicts f
equivalent set h minimal hitting sets f
determine minimal hitting sets therefore diagnoses reiter proposes
breadth first search procedure construction hitting set tree hs tree whose
construction guided conflicts logic definition mbd
reiter conflicts computed calls theorem prover tp tp
component considered black box assumptions made
conflicts determined depending application scenario encoding
one however use specific quickxplain junker progression marques silva janota belov mergexplain shchekotykhin et al
guarantee computed conflict sets minimal
main principle hs tree create search tree node
labeled conflict represents diagnosis latter case node
expanded otherwise child node generated element nodes
given collection c subsets finite set hitting set c subset contains
least one element subset c corresponds set cover



fiparallel model diagnosis multi core computers

conflict outgoing edge labeled one component nodes conflict
subsequent expansions node components used label edges
path root tree current node assumed faulty newly
generated child node diagnosis labeled conflict
contain component already assumed faulty stage conflict
found node path labels represent diagnosis sense definition
example
following example hs tree quickxplain
qxp conflict detection technique combined locate fault specification
csp csp instance defined tuple pv cq v tv vn u
set variables td dn u set domains variables v
c tc ck u set constraints assignment subset x v set
pairs txv xvk dm yu vi p x variable dj p di value
domain variable assignment comprises exactly one variable value pair
variable x constraint ci p c defined list variables called scope
forbids allows certain simultaneous assignments variables scope
assignment satisfies constraint ci comprises assignment allowed ci
assignment solution satisfies constraints c
consider csp instance variables v ta b cu variable
domain u following set constraints defined
c b

c b c

c c

c b c

obviously solution exists diagnosis consists finding subsets
constraints whose definition faulty engineer modeled csp could
example made mistake writing c b c
eventually c added later correct engineer forgot remove
c given faulty definition two minimal conflicts exist namely ttc c c u
tc c uu determined help qxp given two conflicts
hs tree finally determine three minimal hitting sets ttc u tc c u
tc c uu diagnoses instance set diagnoses contains
true cause error definition c
let us review detail hs tree qxp combination works example illustrate tree construction figure logic definition
reiter hs tree starts check observations obs consistent
system description sd components comps application setting
corresponds check exists solution csp instance since
case qxp call made returns conflict tc c c u used
label root node tree element conflict child node
created conflict element used path label tree node consistency sd obs comps tested time however elements appear
comps constraints tc c u sd corresponds semantics logic constraints
working correctly e g abpc q pa bq obs empty example could partial value
assignment test case another scenario



fijannach schmitz shchekotykhin


c c c
c



c

c



c c


c

c c

c

c

c


figure example hs tree construction
labels path root node current node considered abnormal
csp diagnosis setting means check solution modified
version original csp remove constraints appear labels
path root current node
node c correspondingly considered abnormal removing c
csp however sufficient solution exists relaxed another call
qxp made returns conflict tc c u tc u therefore diagnosis
conflict used label node proceeds breadth first
style tests assuming tc u tc u individually faulty consistent
observations case means solution relaxed csp exists since tc u
diagnosis least one solution exists c removed csp definition
node marked expanded node correspond
diagnosis already known conflict tc c u reused overlap
nodes path label call p qxp required last tree level
nodes expanded closed marked tc u
already identified diagnosis previous level resulting diagnoses would
supersets tc u finally sets tc c u tc c u identified additional
diagnoses
discussion
soundness completeness according reiter breadth first construction scheme node closing rule ensure minimal diagnoses computed
end hs tree construction process set edge labels path
root tree node marked corresponds diagnosis
greiner smith wilkerson later identified potential reiters
cases conflicts returned p guaranteed minimal
extension hs dag directed acyclic graph structure
proposed solve
context work use methods return conflicts guaranteed minimal example according theorem work junker
given set formulas sound complete consistency checker qxp returns
reiter states theorem given set conflict sets f hs tree outputs
pruned tree set thpnq n node labeled u corresponds set h
minimal hitting sets f hpnq set arc labels path node n root



fiparallel model diagnosis multi core computers

minimal conflict conflict minimality guarantee turn means
combination hs tree qxp sound complete e returned
solutions actually minimal diagnoses diagnosis given set conflicts
missed holds computing multiple conflicts time mxp
shchekotykhin et al
simplify presentation parallelization approaches therefore rely
reiters original hs tree formulation extension deal hs dag structure
greiner et al possible
demand conflict generation complexity many mentioned
applications mbd practical conflicts computed demand
e tree construction cannot generally assume set minimal
conflicts given advance depending setting finding conflicts
therefore computationally intensive part diagnosis process
generally finding hitting sets collection sets known np hard
garey johnson moreover deciding additional diagnosis exists conflicts
computed demand np complete even propositional horn theories eiter
gottlob therefore number heuristics approximate thus incomplete
well specific diagnosis proposed years
discuss approaches later sections next section however focus
worst case application scenarios goal minimal diagnoses given
e focus complete
consider example debugging program specifications e g constraint
programs knowledge bases ontologies spreadsheets mbd techniques mentioned
application domains typically sufficient one minimal diagnosis work jannach schmitz example spreadsheet developer
presented ranked list sets formulas diagnoses represent possible
reasons certain test case failed developer inspect
individually provide additional information e g test cases narrow set
candidates one diagnosis computed presented developer would
guarantee true cause lead limited acceptance
diagnosis tool

parallel hs tree construction
section present two sound complete parallelization strategies reiters
hs tree method determine minimal diagnoses
non recursive hs tree
use non recursive version reiters sequential hs tree basis
implementation two parallelization strategies shows main loop
breadth first procedure uses list open nodes expanded central data
structure
takes diagnosis dp instance input returns set
diagnoses dp given tuple sd comps obs sd system


fijannach schmitz shchekotykhin

diagnose main loop
input diagnosis sd comps obs
set diagnoses










h paths h conflicts h
nodestoexpand xgeneraterootnode sd comps obs
nodestoexpand x
newnodes x
node head nodestoexpand
foreach c p node conflict
generatenode node c paths conflicts newnodes
nodestoexpand tail nodestoexpand newnodes
return

generatenode node generation logic
input existingnode expand conflict element c p comps
sets paths conflicts newnodes














newpathlabel existingnode pathlabel c
pe l p l newpathlabelq checkandaddpathppaths newpathlabelq
node node newpathlabel
p conflicts x newpathlabel h
node conflict
else
newconflicts checkconsistency sd comps obs node pathlabel
node conflict head newconflicts
node conflict h
newnodes newnodes xnodey
conflicts conflicts newconflicts
else
node pathlabel

description comps set components potentially faulty obs set
observations method generaterootnode creates initial node labeled
conflict empty path label within loop first element firstin first fifo list open nodes nodestoexpand taken current element
function generatenode called element nodes conflict
adds leaf nodes still explored global list
nodes appended remaining list open nodes main loop


fiparallel model diagnosis multi core computers

continues elements remain expansion generatenode
implements node generation logic includes reiters proposals conflict use
tree pruning management lists known conflicts paths diagnoses
method determines path label node checks path label
superset already found diagnosis
checkandaddpath adding path label redundancy
check
input previously explored paths newpathlabel explored
boolean stating newpathlabel added paths



e l p paths l newpathlabel
paths paths newpathlabel
return true



return false




function checkandaddpath used check node
already explored elsewhere tree function returns true path label
successfully inserted list known paths otherwise list known paths
remains unchanged node closed
nodes existing conflict reused one created call
consistency checker theorem prover tests node diagnosis
returns set minimal conflicts otherwise depending outcome node
added list nodestoexpand diagnosis stored note
return value instead modifies sets paths conflicts newnodes
passed parameters
level wise parallelization
first parallelization scheme examines nodes one tree level parallel proceeds
next level elements level processed example shown
figure would mean computations consistency checks theorem prover
calls required three first level nodes labeled tc u tc u tc u done
three parallel threads nodes next level explored threads
previous level finished
level wise parallelization lwp scheme breadth first character maintained parallelization computations generally feasible consistency
checks node done independently done nodes
level synchronization required make sure thread starts exploring
path already examination another thread
shows sequential adapted support
parallelization maintain list open nodes expanded
difference run expansion nodes parallel collect
limitation regarding search depth number diagnoses easily integrated
scheme



fijannach schmitz shchekotykhin

diagnoselw level wise parallelization
input diagnosis sd comps obs
set diagnoses











h conf licts h paths h
nodestoexpand xgeneraterootnode sd comps obs
nodestoexpand x
newnodes x
foreach node p nodestoexpand
foreach c p node conflict
computations parallel
threads execute generatenode node c paths conflicts newnodes
threads await
nodestoexpand newnodes

wait current level complete
prepare next level

return

nodes next level variable newnodes current level finished
overwrite list nodestoexpand list containing nodes next level
java api calls used pseudo code interpreted
follows statement threads execute takes function parameter schedules
execution pool threads given size thread pool e g size
generation first two nodes would done parallel next ones would
queued one threads finished mechanism ensure
number threads executed parallel less equal number hardware
threads cpus
statement threads await used synchronization blocks execution
subsequent code scheduled threads finished guarantee
path explored twice make sure two threads parallel add node
path label list known paths achieved declaring
function checkandaddpath critical section dijkstra means
two threads execute function parallel furthermore make access
global data structures e g already known conflicts diagnoses thread safe
e ensure two threads simultanuously manipulate
full parallelization
lwp situations computation conflict specific node
takes particularly long however means even nodes current
level finished many threads idle expansion hs tree cannot proceed
level completed shows proposed full parallelization fp
variant immediately schedules every expandable node execution
thereby avoids potential cpu idle times end level
controlling concurrency aspects comparably simple modern programming languages java
e g synchronized keyword



fiparallel model diagnosis multi core computers

diagnosefp full parallelization
input diagnosis sd comps obs
set diagnoses














h paths h conflicts h
nodestoexpand xgeneraterootnode sd comps obs
size lastsize
psizelastsizeq pthreads activethreads q
size lastsize
node nodestoexpand get lastsize
foreach c p node conflict
threads execute generatenodefp node c paths conflicts
nodestoexpand
lastsize size
wait
size nodestoexpand length
return

main loop slightly different basically monitors list
nodes expand whenever entries list observed e last observed
list size different current one retrieves recently added elements adds
thread queue execution returns diagnoses
elements added since last check threads active
fp search necessarily follow breadth first strategy anymore
non minimal diagnoses found process therefore whenever
diagnosis check set known diagnoses contains supersets
remove
updated generatenode method listed updating shared
data structures nodestoexpand conflicts make sure threads
interfere mutual exclusive section marked synchronized
keyword
compared lwp fp wait end level specific
node takes particularly long generate hand fp needs synchronization
threads cases last nodes level finished
time lwp could advantageous evaluate aspect section
properties
together corresponds implementation
hs tree reiter implements breadth first search strategy
point reiters hs tree since nodes stored list nodestoexpand
functions wait notify implement semantics pausing thread awaking paused
thread java programming language used avoid active waiting loops



fijannach schmitz shchekotykhin

generatenodefp extended node generation logic
input existingnode expand c p comps
sets paths conflicts nodestoexpand



















newpathlabel existingnode pathlabel c
pe l p l newpathlabelq checkandaddpathppaths newpathlabelq
node node newpathlabel
p conflicts x newpathlabel h
node conflict
else
newconflicts checkconsistency sd comps obs node pathlabel
node conflict head newconflicts
synchronized
node conflict h
nodestoexpand nodestoexpand xnodey
conflicts conflicts newconflicts
else e p newpathlabel
node pathlabel
p newpathlabel
z
notify

processed iteratively first first order see lines first
checks pruning rules ii reiter applied line rules state
node pruned exists diagnosis ii set labels
corresponding path tree subset set labels
path node pruning rule ii implemented pruning rule iii
reiters necessary since settings tp call guarantees return
minimal conflicts
finally point reiters hs tree description implemented lines
checks conflict reused
node label case reuse possible calls theorem prover tp
another minimal conflict conflict found node added list open nodes
nodestoexpand otherwise set node path labels added set diagnoses
corresponds situation reiters would mark node
hs tree symbol note label nodes done reiters
since simply store nodes expansion list
overall conclude hs tree implementation
properties reiters original hs tree namely hitting set
returned minimal soundness existing minimal hitting sets
found completeness


fiparallel model diagnosis multi core computers

level wise parallelization lwp
theorem level wise parallelization sound complete
proof proof fact lwp uses expansion pruning
techniques sequential main loop line applies
procedure original difference executions
done parallel level tree therefore difference
sequential lwp lies order nodes one level
labeled generated
let us assume two nodes n n tree sequential
hs tree process n n assuming neither n n correspond
diagnoses sequential would correspondingly first add child nodes
n queue open nodes later append child nodes n
parallelize computations needed generation n n lwp
happen computations n need longer n case
child nodes n placed queue first order nodes
subsequently processed however irrelevant computation minimal hitting
sets since neither labeling pruning rules influenced fact
labeling node n depends whether minimal conflict set f exists
hpnq x f h nodes level pruning rules
state node n pruned exists node n labeled
hpn q hpnq e supersets already found diagnoses pruned n n
level hpnq hpn q consequently pruning rule applied
hpnq hpn q therefore order nodes e nodes pruned irrelevant
minimal hitting set lost consequently lwp complete
soundness follows fact lwp constructs hitting sets
order increasing cardinality therefore lwp return minimal hitting sets even scenarios stop k diagnoses found
k n predefined constant n total number diagnoses

full parallelization fp
minimality hitting sets encountered search guaranteed fp
since schedules node processing immediately generation line
special treatment generatenodefp function ensures
supersets already found hitting sets added supersets newly found
hitting set removed thread safe manner lines due
change generatenodefp analysis soundness completeness
done two distinct cases
theorem full parallelization sound complete applied diagnoses
cardinality
proof fp stops hitting set exists e leaf nodes tree
labeled ii predefined cardinality tree depth reached
latter case every leaf node tree labeled minimal conflict


fijannach schmitz shchekotykhin

set case ii reduced removing branches tree labeled
minimal conflict branches irrelevant since contribute
minimal hitting sets higher cardinality therefore without loss generality limit
discussion case
according definition generatenodefp tree built pruning
rule done sequential hs tree consequence tree generated
fp must comprise least nodes tree generated sequential hstree procedure therefore according theorem work reiter
tree generated fp must comprise set leaf nodes labeled
set thpnq n node labeled u corresponds set h minimal hitting
sets moreover returned fp comprises minimal hitting sets
generatenodefp removes hitting sets h supersets hitting sets
consequently fp sound complete applied diagnoses
theorem full parallelization cannot guarantee completeness soundness
applied first k diagnoses e k n n total number
diagnoses
proof proof done constructing example fp returns least
one non minimal hitting set set thus violating definition instance
situation might occur fp applied one single diagnosis example
presented section let us assume generation node corresponding
path c delayed e g operating system scheduled another thread
execution first node correspondingly generated first case
would return non minimal hitting set tc c u diagnosis
note elements set returned fp case turned
diagnoses applying minimization inv quickxplain shchekotykhin
friedrich rodler fleiss adopts principles quickxplain
applies divide conquer strategy one minimal diagnosis given set
inconsistent constraints
given hitting set h diagnosis capable computing
minimal hitting set h h requiring op h h logp h h qqq calls theorem
prover tp first part h reflects computational costs determining whether
h minimal second part represents number subproblems must
considered divide conquer order minimal hitting set h
evaluation
determine performance improvements achieved forms
parallelization proposed conducted series experiments diagnosis
number different application domains specifically used electronic
circuit benchmarks dx competition synthetic track faulty descriptions
constraint satisfaction csps well domain ontology
debugging addition ran experiments synthetically created diagnosis
analyze impact varying different characteristics diagnosis


fiparallel model diagnosis multi core computers

evaluated implemented java unless noted otherwise generally
use wall clock times performance measure
main part focus dx competition
widely used benchmark
setups presented discussed appendix cases
dx competition follow similar trend achieved
experiments
section compare hs tree parallelization schemes lwp fp
sequential version goal diagnoses
dataset procedure
set experiments selected first five systems dx competition
synthetic track see table kurtoglu feldman system competition specifies scenarios injected faults resulting different faulty output values
used system description given input output values diagnosis
process additional information injected faults course ignored
converted constraint satisfaction experiments used
choco prudhomme fages lorca constraint solver qxp conflict
detection returns one minimal conflict called node construction
computation times required conflict identification strongly depend
order possibly faulty constraints shuffled constraints test repeated
tests times report wall clock times actual diagnosis task times
required input output independent hs tree construction scheme
relevant benchmarks parallel approaches used thread pool size
four
table shows characteristics systems terms number constraints
c variables v numbers injected faults f
numbers calculated diagnoses vary strongly different scenarios
system columns ranges values scenarios
columns indicate average number diagnoses average cardinality
seen search tree diagnosis become extremely broad
diagnoses average diagnosis size system c

table shows averaged searching minimal diagnoses first list
running times milliseconds sequential version seq improvements
lwp fp terms speedup efficiency respect sequential version
speedup sp computed sp tp wall time thread
sequential tp wall time p parallel threads used speedup
four hardware threads reasonable assumption standard desktop computers mobile
devices hardware used evaluation chapter laptop intel qm
cpu gb ram running windows four cores hyperthreading
evaluation server hardware cores reported later section
systems marked search depth limited actual number faults ensure
sequential terminates within reasonable time frame



fijannach schmitz shchekotykhin

system

l


c

c






v






f



























table characteristics selected dxc benchmarks
would therefore mean needed computation times halved speedup
theoretical optimum threads means time reduced
one quarter efficiency ep defined sp p compares speedup
theoretical optimum fastest system highlighted bold
system

l


c

seq qxp
ms






lwp qxp

e











fp qxp

e






table observed performance gains dxc benchmarks searching diagnoses

tests parallelization approaches outperform sequential furthermore differences sequential one parallel approaches statistically significant p tested scenarios
systems fp efficient lwp speedups range
e reduction running times scenarios
differences lwp fp statistically significant trend
observed efficiency fp higher complex reason
time needed node generation much larger absolute
numbers additional overhead times required thread synchronization
adding threads
use cases diagnosis process done powerful server architectures
often even cpu cores modern desktop computers order assess
extent threads help speed diagnosis process tested
different benchmarks server machine cpu cores test compared
fp threads sequential
dxc benchmark shown table tested systems
diagnosis process faster instead threads substantial speedups
could achieved compared sequential diagnosis corresponds


fiparallel model diagnosis multi core computers

runtime reduction one system utilization threads led
additional speedups threads fastest tested systems
efficiency however degrades threads used time needed
synchronization threads threads hardware actually cores
additional speedups tested systems reason
time threads busy conflict detection e g finding solutions csps
use almost processing power assigned
system

l


c

seq qxp
ms













e













fp qxp
e

e













e






table observed performance gains dxc benchmarks server hardware
threads

additional experiments
details additional experiments conducted compare proposed parallelization schemes sequential hs tree presented section
appendix significant speedups achieved constraint satisfaction section ontologies section appendix
furthermore contains analysis effects adding threads benchmarks
csps ontologies section presents simulation experiment
systematically varied different characteristics section
discussion
overall evaluations parallelization approaches help improve performance diagnosis process tested scenarios approaches
achieved speedups cases fp faster lwp however depending
specifics given setting lwp advantageous situations
e g time needed generate node small conflict generation time vary strongly cases synchronization overhead needed
fp higher cost waiting threads finish tested ontologies
section case four tested scenarios
although fp average faster lwp significantly better sequential
hs tree construction tested scenarios efficiency still far
optimum explained different effects example effect
false sharing happen memory two threads allocated block
bolosky scott every access memory block synchronized although
two threads really share memory another possible effect called cache


fijannach schmitz shchekotykhin

contention chandra guo kim solihin threads work different computing
cores share memory cache misses occur often depending
characteristics thus theoretical optimum cannot reached cases

parallel hs tree construction multiple conflicts per node
sequential parallel version hs tree theorem
prover tp call corresponds invocation qxp whenever node hs tree
created qxp searches exactly one conflict case none already known
conflicts reused strategy advantage call tp immediately
returns one conflict determined turn means parallel
execution threads immediately see conflict shared data structures
best case reuse constructing nodes
disadvantage computing one conflict time qxp search
conflicts restarted invocation recently proposed conflict detection
technique called mergexplain mxp shchekotykhin et al capable
computing multiple conflicts one call general idea mxp continue search
identification first conflict look additional conflicts remaining
constraints logical sentences divide conquer
combined sequential hs tree effect tree construction time initially spent conflict detection construction continues
next node exchange chances conflict available reuse increase
next nodes time identification conflicts less timeintensive smaller sets constraints investigated due divide conquer
mxp experimental evaluation benchmark shows
substantial performance improvements possible sequential hs tree scenario
goal leading diagnoses shchekotykhin et al
section explore benefits mxp parallel hs tree construction schemes proposed previous section mxp combination
multiple threads implicit effect cpu processing power devoted conflict generation individual threads need time complete construction
node contrast sequential version threads continue
work parallel
next section briefly review mxp report
empirical evaluation benchmark datasets section
background quickxplain mergexplain
shows qxp conflict detection technique junker applied
finding conflict diagnosis hs tree construction
qxp operates two sets constraints modified recursive calls
background theory b comprises constraints considered anymore
part conflict current stage beginning set contains sd obs
use term constraints original formulation qxp independent
underlying reasoning technique elements sets could general logical sentences well



fiparallel model diagnosis multi core computers

quickxplain qxp
input diagnosis sd comps obs set visitednodes elements
output set containing one minimal conflict cs c
b sd obs ab c c p visitednodes c abpcq c p compszvisitednodesu
isconsistent b c return conflict
else c h return h
return tc abpcq p getconflictpb b cqu







function getconflict b c
h isconsistent b return h
c return c
split c disjoint non empty sets c c
getconflict b c c c
getconflict b c
return

set nodes path current node hs tree visited nodes
set c represents set constraints search conflict
conflict c empty immediately returns otherwise getconflict called corresponds junkers qxp method minor difference
getconflict require strict partial order set constraints c
introduce variant qxp since cannot assume prior fault information
available would allow us generate order
rough idea qxp relax input set faulty constraints c partitioning
two sets c c c conflict continues partitioning c
next recursive call otherwise e last partitioning split conflicts c
conflicts left c extracts conflict sets c
c way qxp finally identifies individual constraints inconsistent
remaining consistent set constraints background theory
mxp builds ideas qxp computes multiple conflicts one call
exist general procedure shown initial consistency checks
method findconflicts called returns tuple xc c set
remaining consistent constraints set found conflicts function recursively
splits set c constraints two halves parts individually checked
consistency allows us exclude larger consistent subsets c search process
besides potentially identified conflicts calls findconflicts return two sets
constraints consistent c c q union two sets consistent
look conflict within c c background theory style qxp
details found earlier work depth
experimental analysis reported shchekotykhin et al


fijannach schmitz shchekotykhin

mergexplain mxp
input diagnosis sd comps obs set visitednodes elements
output set minimal conflicts
b sd obs ab c c p visitednodes c abpcq c p compszu

isconsistentpbq return solution
isconsistentpb cq return h
x findconflictspb cq
return tc abpcq p













function findconflicts b c returns tuple xc
isconsistent b c return xc hy
c return xh tcuy
split c disjoint non empty sets c c
xc findconflictspb c q
xc findconflictspb c q

isconsistentpc c bq
x getconflictpb c c c q
cs x getconflictpb x x c q
c c z tu p x
tcs u
return xc c

evaluation
section evaluate effects parallelizing diagnosis process use
mxp instead qxp calculate conflicts shchekotykhin et al
focus finding limited set five minimal diagnoses
implementation variants
mxp parallel tree construction implicitly means time allocated
conflict generation qxp proceeding next node
analyze extent use mxp beneficial tested three different strategies
mxp within full parallelization method fp
strategy configuration simply called mxp instead qxp node
generation whenever mxp finds conflict added global list known conflicts
used parallel threads thread executes mxp node
generation continues next node mxp returns
strategy strategy implements variant mxp slightly complex
mxp finds first conflict method immediately returns conflict
calling thread continue exploring additional nodes time background thread started continues search additional conflicts e completes
work mxp call addition whenever mxp finds conflict checks
already running node generation thread could reused conflict


fiparallel model diagnosis multi core computers

available beforehand case search conflicts thread
stopped conflict needed anymore strategy could theory
better cpu utilization wait mxp call finish
continue building hs tree however strategy leads higher synchronization
costs threads e g notify working threads newly identified conflicts
strategy finally parallelized conflict detection procedure whenever
set c constraints split two parts first recursive call findconflicts
queued execution thread pool second call executed current thread
calls finished continues
experimentally evaluated three configurations benchmark datasets
showed strategy lead measurable performance improvements
compared strategy additional communication costs seem higher
saved executing conflict detection process background
thread strategy applied combination strategies similar
experiments reported sequential hs tree construction shchekotykhin et al
additional performance gains could observed due higher synchronization
costs limited effectiveness strategies principle caused
nature benchmark strategies might advantageous
different settings following therefore report
applying strategy
dxc benchmark
dxc benchmarks shown table left side table shows
qxp right hand side shows mxp
speedups shown fp columns refer respective sequential
conflict detection technique
mxp instead qxp favorable sequential hs tree
reported work mxp shchekotykhin et al reduction
running times ranges speedups obtained fp
mxp comparable fp qxp range e lead
reduction running times speedups achieved addition
speedups sequential mxp could already achieve qxp
best printed bold face table mxp combination
fp consistently performs best overall fp combination mxp
faster sequential qxp tests indicate
parallelization method works well conflict detection techniques
complex qxp case return one conflict call
addition investing time conflict detection situations goal
leading diagnoses proves promising strategy
additional experiments discussion
ran additional experiments constraint ontology debugging detailed provided section


fijannach schmitz shchekotykhin

system

l


c

seq qxp
ms






fp qxp

e






seq mxp
ms






fp mxp

e






table observed performance gains dxc benchmarks qxp vs mxp

overall obtained embedding mxp sequential confirm
shchekotykhin et al mxp favorable qxp
small instances however observe allocating
time conflict detection mxp parallel processing setup help
speedup diagnosis process search number leading diagnoses bestperforming configuration across experiments full parallelization method
combination mxp setup led shortest computation times
tested scenarios dx benchmarks csps ontologies

parallelized depth first hybrid search
application domains mbd finding minimal diagnoses required
simply possible computational complexity application specific constraints allowed response times settings number
proposed years example try one minimal diagnoses
quickly diagnoses certain cardinality metodi stern kalech codish
feldman provan van gemund b de kleer cases
principle extended used diagnoses however optimized
task
instead analyzing heuristic stochastic approximative proposed literature individually respect potential parallelization
analyze next section parallelization helpful already simple class
depth first context investigate measurable improvements
achieved without domain specific heuristic finally propose
hybrid strategy combines depth first full parallel hs tree construction
conduct additional experiments assess strategy advantageous task
quickly finding one minimal diagnosis
parallel random depth first search
section introduces parallelized depth first search quickly one single
diagnosis different threads explore tree partially randomized form call
scheme parallel random depth first search prdfs


fiparallel model diagnosis multi core computers

description
shows main program recursive implementation prdfs similar
hs tree search diagnoses guided conflicts time however
greedily searches depth first manner diagnosis found
checked minimality diagnosis contain redundant elements
minimization non minimal diagnosis achieved calling method
inv quickxplain shchekotykhin et al simply trying remove one element
diagnosis checking resulting set still diagnosis
diagnoseprdfs parallelized random depth first search
input diagnosis sd comps obs
number mindiags diagnoses
set diagnoses









h conflicts h
rootnode getrootnode sd comps obs
nbthreads
threads execute expandprdfs rootnode mindiags conflicts
mindiags
wait
threads shutdownnow
return

idea parallelization start multiple threads
root node threads perform depth first search parallel pick
next conflict element explore randomized manner
logic expanding node shown first conflict
given node copied changes set constraints affect
threads long enough diagnoses found randomly chosen constraint
current nodes conflict used generate node expansion function
immediately called recursively node thereby implementing depth first
strategy identified diagnosis minimized added list known
diagnoses similar previous parallelization schemes access global lists
known conflicts made thread safe specified number diagnoses
found threads finished statement threads shutdownnow immediately stops
execution threads still running returned semantics
threads execute wait notify section
example
let us apply depth first method example section remember
two conflicts ttc c c u tc c uu partially expanded tree
seen figure


fijannach schmitz shchekotykhin

expandprdfs parallel random depth first node expansion
input existingnode expand number mindiags diagnoses
sets conflicts




















c existingnode conflict clone
copy existingnodes conflict
mindiags c
randomly pick constraint c c
c cztcu
newpathlabel existingnode pathlabel c
node node newpathlabel
p conflicts x newpathlabel h
node conflict
else
node conflict checkconsistency sd comps obs node pathlabel
node conflict h
conflict found
conflicts conflicts node conflict
recursive call implements depth first search strategy
expandprdfs node mindiags conflicts
else
diagnosis found
diagnosis minimize node pathlabel
diagnosis
mindiags
notify

example first root node created conflict tc c c u
found next random expansion would example pick conflict element c
generate node node conflict tc c u computed tc u
alone diagnosis since continues depth first manner
pick one label elements node e g c generate node
node consistency check succeeds conflict computed
found diagnosis found diagnosis tc c u however minimal contains
redundant element c function minimize called end
therefore remove redundant element obtain correct diagnosis tc u
used one thread example one parallel threads would
probably started expanding root node conflict element c node
case single element diagnosis tc u would identified already first
level adding parallel threads therefore help increase chances one
hitting set faster different parts hs tree explored parallel
instead random selection strategy elaborate schemes pick next nodes
possible e g application specific heuristics fault probabilities one could
better synchronize search efforts different threads avoid duplicate calculations conducted experiments variant used shared


fiparallel model diagnosis multi core computers


c c c
c





c

c

c c


c

c c

c

c

c

figure example hs tree construction prdfs
synchronized list open nodes avoid two threads generate identical sub tree
parallel however observe significantly better method
shown probably due synchronization overhead
discussion soundness completeness
every single thread depth first systematically explores full search space
conflicts returned theorem prover therefore existing diagnoses
found parameter mindiags equal higher number actually
existing diagnoses
whenever potentially non minimal diagnosis encountered minimization process ensures minimal diagnoses stored list diagnoses duplicate
addition diagnosis one threads last lines
prevented consider diagnoses equal contain set elements
set definition cannot contain element twice
overall designed one diagnoses quickly computation minimal diagnoses possible highly inefficient e g due
computational costs minimizing diagnoses
hybrid strategy
let us consider finding one minimal diagnosis one easily imagine
choice best parallelization strategy e breadth first depth first
depend specifics given setting actual size existing
diagnoses single element diagnosis exists exploring first level hs tree
breadth first might best choice see figure depth first strategy
might eventually include element non minimal diagnosis would
number additional calculations ensure minimality diagnosis
contrast smallest actually existing diagnosis cardinality e g five
breadth first scheme would fully explore first four hs tree levels
finding five element diagnosis depth first scheme contrast might quickly


fidiagnosis detected

jannach schmitz shchekotykhin

superset five element diagnosis e g six elements needs six
additional consistency checks remove redundant element diagnosis figure
b
diagnosis detected

diagnosis detected

breadth first strategy advantageous

b depth first strategy advantageous

figure two configurations different search strategies favorable
since cannot know cardinality diagnoses advance propose hybrid
strategy half threads adopt depth first strategy half uses
fully parallelized breadth first regime implement strategy
fp prdfs started parallel allowed use one
half defined share available threads coordination
two done help shared data structures contain known
conflicts diagnoses enough diagnoses e g one found running threads
terminated
returned
diagnosis detected
evaluation
evaluated different strategies efficiently finding one minimal diagnosis
set benchmark used previous sections experiment
setup identical except goal one arbitrary diagnosis
included additional depth first order measure potential benefits
parallelizing depth first search ran benchmarks prdfs threads
thread latter setup corresponds random depth first search
rdfs without parallelization
dxc benchmark
dxc benchmark shown table overall tested
systems approaches proposed help speed process
finding one single diagnosis evaluated scenarios least one
tested approaches statistically significantly faster sequential
scenarios finding one single diagnosis simple modest
significant speedups compared sequential obtained
comparing individual parallel following observations
made


fiparallel model diagnosis multi core computers

examples prdfs method faster breadth first search
implemented fp technique one benchmark system prdfs
even achieve speedup compared sequential corresponds runtime reduction
compared non parallel rdfs prdfs could achieve higher speedups
tested systems except simple one took ms even
sequential overall parallelization therefore advantageous
depth first strategies
performance hybrid strategy lies performances components prdfs fp tested systems systems closer
faster one two adopting hybrid strategy therefore represent good
choice structure known advance combines
ideas breadth first depth first search able quickly diagnosis
settings unknown characteristics

system

l


c

seq
ms






fp

e






rdfs
ms






prdfs

e






hybrid

e






table observed performance gains dxc benchmarks finding one diagnosis

additional experiments
detailed obtained additional experiments provided
appendix measurements include csps section ontologies
section well obtained systematically varying characteristics synthetic diagnosis section indicate applying
depth first parallelization strategy many cases advantageous csp
tests ontology simulation however reveal depending structure cases breadth first strategy
beneficial
discussion
experiments parallelization depth first search strategy prdfs
help reduce computation times search one single diagnosis
evaluated cases prdfs faster sequential counterpart
cases however obtained improvements quite small virtually non existent
explained follows


fijannach schmitz shchekotykhin

small scenarios parallel depth first search cannot significantly
faster non parallel variant creation first node parallelized therefore major fraction tree construction process parallelized

settings existing diagnoses size
parallel depth first searching threads therefore explore tree certain
depth none threads immediately return diagnosis much smaller
one determined another thread e g given diagnosis
diagnoses size threads explore tree least level
diagnosis likely diagnosis level therefore
setting thread much faster others
finally suspect cache contention correspondingly increased number cache misses leads general performance deterioration
overhead caused multiple threads
overall obtained speedups depend structure hybrid
technique represents good compromise cases faster sequential
breadth first search tested scenarios including csps ontologies synthetically created diagnosis presented section
efficient prdfs cases breadth first search better
depth first search

parallel direct csp encodings
alternative conflict guided diagnosis approaches reiters hitting set technique
called direct encodings become popular community recent
years feldman provan de kleer robert van gemund stern kalech feldman
provan metodi et al mencia marques silva menca previti
marques silva marques silva janota ignatiev morgado
general idea direct encodings generate specific representation diagnosis
instance knowledge representation language use theorem
prover e g sat solver constraint engine compute diagnoses directly
methods support generation one multiple diagnoses calling theorem prover
nica pill quaritsch wotawa made number experiments
compared conflict directed search direct encodings showed
several settings direct encoding advantageous
part goal evaluate whether parallelization search
process case inside constraint engine help improve efficiency
diagnostic reasoning process goal chapter therefore rather quantify
extent internal parallelization solver useful present
algorithmic contribution
direct encodings may possible mbd settings discussed



fiparallel model diagnosis multi core computers

gecode solver direct encodings
evaluation use gecode constraint solver schulte lagerkvist tack
particular use parallelization option gecode test effects diagnosis
running times chosen encoding similar one used nica
wotawa allows us make comparable obtained
previous works addition provided encoding represented language
supported multiple solvers
example
let us first general idea small example consider following csp
consisting integer variables b b c constraints x x x
defined
x b x b x c b b
let us assume programmer made mistake x actually c
b b given set expected observations test case mbd
applied considering constraints possibly faulty components
direct encoding given csp extended definition array ab
rab ab ab boolean variables encode whether corresponding constraint
considered faulty constraints rewritten follows
x ab pb q

x ab pb q

x ab pc b b q

observations encoded equality constraints bind values
observed variables example constraints would






order diagnosis cardinality additionally add constraint
ab ab ab
let solver search solution case x would identified
possible diagnosis e ab would set solver
parallelization gecode
direct encoding parallelization diagnosis process shown
reiters cannot done embedded underlying search
procedure however modern constraint solvers gecode tools many
solvers participated minizinc challenge stuckey feydy schutt tack
fischer internally implement parallelization strategies better utilize todays
multi core computer architectures michel see van hentenryck chu schulte
state art sat solver capable parallelization could used analysis well
adapted earlier work jannach schmitz



fijannach schmitz shchekotykhin

stuckey following therefore evaluate set experiments
solver internal parallelization techniques help speed diagnosis process
direct encoding used
gecode implements adaptive work stealing strategy chu et al parallelization general idea summarized follows soon thread finishes
processing nodes search tree steals nodes non idle threads
order decide thread work stolen adaptive strategy uses
balancing heuristics estimate density solutions particular part
search tree higher likelihood containing solution given branch
work stolen branch
encoding
evaluation use minizinc constraint modeling language language
processed different solvers allows us model diagnosis csps
shown
finding one diagnosis
single diagnosis given diagnosis sd comps obs generate
direct encoding minizinc follows
set components comps generate array ab ab abn
boolean variables
formula sdi p sd add constraint form
constraint abris psdi q
observation oj p obs model extended constraint
constraint oj
finally add search goal output statement
solve minimize sumpi nqpbool intpabrisqq
output ab
first statement last part solve minimize instructs solver search
single solution minimal number abnormal components e diagnosis
minimum cardinality second statement output projects assignments set
abnormal variables interested knowing components
faulty assignments variables irrelevant
finding diagnoses
encoding shown used quickly one diagnoses minimum cardinality however sufficient scenarios goal
diagnoses therefore propose following sound complete
repeatedly modifies constraint systematically identify diagnoses
contrast parallelization approaches presented previous sections propose
parallelization schemes rather rely existing ones implemented solver



fiparallel model diagnosis multi core computers

technically first searches diagnoses size increases
desired cardinality diagnoses step step

directdiag computation diagnoses direct encoding
input diagnosis sd comps obs maximum cardinality k
set diagnoses











h c h card
k comps k comps
generatemodel sd comps obs
card k
updatemodel card c
computediagnosespmq
c c generateconstraintsp q

card card
return

procedure shows main components direct diagnosis method used
connection parallel constraint solver diagnoses starts
generation minizinc model generatemodel described
difference search solutions given cardinality
details encoding search goals given
iteration modifies model updating cardinality
searched diagnoses furthermore adds constraints corresponding already
found diagnoses updatemodel updated model provided minizinc
interpreter constraint solver returns set solutions element p
corresponds diagnosis cardinality card
order exclude supersets already found diagnoses future iterations
generate constraint p formulas j l generateconstraints
constraint abrjs false abrls false
constraints ensure already found diagnosis supersets cannot found
added model next iteration main loop
continues diagnoses cardinalities k computed
changes encoding calculate diagnoses given size first instruct
solver search possible solutions provided constraint
addition keeping steps section replace lines step
achieved calling minizinc solutions flag



fijannach schmitz shchekotykhin

following statements
constraint sumpi nqpbool intpabrisqq card
solve satisfy
output ab
first statement constrains number abnormal variables true
certain value e given cardinality card second statement tells solver
variable assignments satisfy constraints last statement guarantees
solver considers solutions different different
respect assignments abnormal variables
soundness completeness implements iterative deepening guarantees minimality diagnoses specifically
constructs diagnoses order increasing cardinality limiting number ab
variables set true model computation starts card
means one ab variable true therefore diagnoses cardinality
e comprising one abnormal variable returned solver found
diagnosis add constraint requires least one abnormal variables
diagnosis false therefore neither diagnosis supersets found
subsequent iterations constraints implement pruning rule hs tree
finally repeatedly increases cardinality parameter card
one continues next iteration continues increment cardinality card becomes greater number components corresponds
largest possible cardinality diagnosis consequently given diagnosis
well sound complete constraint solver returns diagnoses

evaluation
evaluate speedups achieved parallelization direct encoding
used first five systems dxc synthetic track tested scenarios
gecode solver without parallelization parallel threads

evaluated two different configurations setup task one single
diagnosis minimum cardinality setup b iterative deepening procedure
section used diagnoses size actual error
setup shown table observe parallel
constraint solver pays except tiny overall search time
less ms furthermore adding worker threads beneficial larger
sizes speedup achieved complex test case
took seconds solve
pattern observed setup b detailed listed table
tiny internal parallelization gecode solver lead
performance improvements slightly slows whole process soon


fiparallel model diagnosis multi core computers

become complex parallelization pays observe speedup
complex tested cases corresponds runtime reduction

system

l


c

direct encoding
abs ms

e







e






table observed performance gains dxc benchmarks finding one diagnosis
direct encoding one column abs two four threads

system

l


c

direct encoding
abs ms

e







e






table observed performance gains dxc benchmarks finding diagnoses
direct encoding one column abs two four threads

summary remarks
overall experiments parallelization beneficial direct encoding
diagnosis employed particular non trivial
comparing absolute running times java implementation open source
solver choco optimized c implementation gecode generally appropriate benchmark gecode works faster absolute scale
note however true cases particular searching diagnoses size actual error complex system c even reiters
non parallelized hitting set much faster seconds direct
encoding iterative deepening seconds line observation
nica et al direct encodings best choice searching
diagnoses
first analysis run time behavior gecode shows larger
time spent solver iteration reconstruct internal structures
lead measurable performance degradation note work relied
minizinc encoding diagnosis independent specifics


fijannach schmitz shchekotykhin

underlying constraint engine implementation relies direct use api
specific csp solver might help address certain performance issues nevertheless
implementation must solver specific allow us switch solvers easily
possible minizinc

relation previous works
section explore works related first examine different
approaches computation diagnoses focus general methods
parallelizing search
computation diagnoses
computing minimal hitting sets given set conflicts computationally hard
already discussed section several approaches proposed years
deal issue approaches divided exhaustive approximate ones
former perform sound complete search minimal diagnoses whereas
latter improve computational efficiency exchange completeness e g search
one small set diagnoses
approximate approaches example stochastic search techniques
genetic li yunfei greedy stochastic search feldman et al b
greedy method proposed feldman et al b example uses two step
first phase random possibly non minimal diagnosis determined
modified dpll finds one random diagnosis
invocation due random selection propositional variables assignments
second step minimizes diagnosis returned dpll technique
repeatedly applying random modifications randomly chooses negative literal
denotes corresponding component faulty flips value positive
obtained candidate well diagnosis provided dpll
check whether candidate diagnosis case success obtained
diagnosis kept another random flip done otherwise negative literal labeled
failure another negative literal randomly selected stops
number failures greater predefined constant returns best diagnosis
found far
li yunfei genetic takes number conflict
sets input generates set bit vectors chromosomes every bit encodes
truth value atom ab predicate iteration applies
genetic operations mutation crossover etc obtain chromosomes subsequently obtained bit vectors evaluated hitting set fitting function
eliminates bad candidates stops predefined number iterations
returns best diagnosis
general approximate approaches directly comparable lwp
fp techniques since incomplete guarantee minimality returned
davis putnam logemann loveland



fiparallel model diagnosis multi core computers

hitting sets goal contrast improve performance time
maintaining completeness soundness property
another way finding approximate solutions use heuristic search approaches
example abreu van gemund proposed staccato applies
number heuristics pruning search space aggressive pruning techniques
better performance search however increase probability diagnoses found aggressiveness
heuristics varied input parameters depending application goals
recently cardoso abreu suggested distributed version staccato map reduce scheme dean ghemawat
therefore executed cluster servers recent focus
efficient computation one minimum cardinality minc diagnoses de kleer
distributed minimum cardinality scenario assumption possibly incomplete set conflicts already available input
beginning hitting set construction process application scenarios
address work finding conflicts considered computationally
expensive part assume know minimal conflicts advance
compute demand done works felfernig friedrich jannach
stumptner et al friedrich shchekotykhin williams ragno see
work pill quaritsch wotawa comparison conflict computation
approaches
exhaustive approaches often hs trees work wotawa
tree construction reduces number pruning steps presence nonminimal conflicts alternatively one use methods compute diagnoses without
explicit computation conflict sets e solving dual minimal hitting sets
satoh uno stern et al example suggest method explores
duality conflicts diagnoses uses symmetry guide search
approaches exploit structure underlying hierarchical autio
reiter tree structured stumptner wotawa distributed wotawa
pill similar hs tree consequently
parallelized similar way example consider set enumeration tree
se tree rymon similarly reiters hs tree
uses breadth first search specific expansion procedure implements pruning
node selection strategies lwp fp parallelization variant
used se tree comparable speedups expected
parallelization search
historically parallelization search approached three different ways
burns lemons ruml zhou
parallelization node processing applying type parallelization tree
expanded one single process computation labels evaluation
heuristics done parallel


fijannach schmitz shchekotykhin

ii window processing sets nodes called windows processed different threads parallel windows formed search
according predefined criteria
iii tree decomposition approaches different sub trees search tree assigned different processes ferguson korf brungger marzetta fukuda
nievergelt
principle three types parallelization applied form hs tree
generation
applying strategy mbd setting would mean parallelize process
conflict computation e g parallel variant qxp mxp tested
partially parallelized version mxp however lead performance
improvements compared single threaded evaluated benchmark
shchekotykhin et al experiments section however
mxp combination lwp fp thereby implicitly allocating cpu time
computation multiple conflicts construction single node advantageous well known conflict prime implicate computation junker
marques silva et al previti ignatiev morgado marques silva
contrast designed parallel execution computation multiple conflicts
strategy ii computing sets nodes windows parallel example applied
powley korf work windows determined different thresholds
heuristic function iterative deepening applying strategy hs tree
construction would mean categorize nodes expanded according
criterion e g probability finding diagnosis allocate different
groups individual threads absence window criteria lwp fp could
seen extreme cases window size one open node allocated one thread
processor experiments done throughout suggest independent
parallelization strategy lwp fp number parallel threads windows
exceed number physically available computing threads obtain best performance
finally iii strategy exploring different sub trees search different
processes example applied context mbd techniques binary
hs tree bhs pill quaritsch given set conflict sets bhs
method generates root node labels input set conflicts selects
one components occurring conflicts generates two child nodes
left node labeled conflicts comprising selected component right
node remaining ones consequently diagnosis tree decomposed two subtrees processed parallel main kind parallelization
conflicts often known advance computed search
anglano portinale suggested another ultimately
parallelized diagnosis structural characteristics
work first map given diagnosis behavioral petri net bpn
obtained bpn manually partitioned subnets every subnet provided
different parallel virtual machine pvm parallel processing relationship
work lwp fp parallelization schemes limited approaches
require manual decomposition step


fiparallel model diagnosis multi core computers

general parallelized versions domain independent search
applied mbd settings however mbd specifics make
application difficult instance pra method
variant hda discussed work burns et al use mechanism minimize
memory requirements retracting parts search tree forgotten parts
later generated required mbd setting generation nodes however
costly part applicability hda seems limited similarly
duplicate detection pbnf burns et al require existence
abstraction function partitions original search space blocks general mbd
settings however cannot assume function given
order improve performance therefore avoid parallel generation
duplicate nodes different threads plan investigate future work
promising starting point could work phillips likhachev
koenig authors suggest variant generates
independent nodes order reduce costs node generation two nodes considered
independent generation one node lead change heuristic
function node generation independent nodes done parallel
without risk repeated generation already known state main difficulty
adopting mbd formulation admissible heuristic required
evaluate independence nodes arbitrary diagnosis however
specific encoded csps williams ragno present
heuristic depends number unassigned variables particular search node
finally parallelization used literature speed processing
large search trees fit memory korf schultze instance suggest
extension hash delayed duplicate detection allows search
continue search parts search tree written read
hard drive methods theory used combination lwp fp
parallelization schemes case complex diagnosis plan explore use
externally saved search states context mbd part future works

summary
work propose systematically evaluate parallelization strategies
model diagnosis better exploit capabilities multi core computers
parallelization advantageous settings diagnosis approaches approaches include conflict driven search minimal
diagnoses different conflict detection techniques heuristic depth first search
order quickly determine single diagnosis main benefits parallelization
approaches applied independent underlying reasoning engine
variety diagnostic cannot efficiently represented sat csp
addition hs tree parallelization approaches
parallelization beneficial settings direct encoding possible
modern parallel solver engines available
evaluations furthermore shown speedups proposed parallelization methods vary according characteristics underlying diagnosis


fijannach schmitz shchekotykhin

future work plan explore techniques analyze characteristics order
predict advance parallelization method best suited one single
diagnoses given
regarding algorithmic enhancements furthermore plan investigate information underlying structure exploited achieve better distribution work parallel threads thereby avoid duplicate computations
furthermore plan explore usage parallel solving schemes dual e compute diagnoses directly without computation minimal conflicts satoh uno felfernig schubert zehentner stern et al
shchekotykhin et al
presented designed use modern multi core computers
today usually less dozen cores additional performance improvements obtain proposed techniques become smaller
adding cpus part future works therefore plan develop
utilize specialized environments support massive parallelization
context future topic could adaption parallel hs tree
construction gpu architectures gpus thousands computing cores
proved superior tasks parallelized suitable way campeotto
palu dovier fioretto pontelli example used gpu parallelize constraint solver however yet fully clear whether tree construction techniques
efficiently parallelized gpu many data structures shared across
nodes access synchronized

acknowledgements
significantly extends combines previous work jannach schmitz
shchekotykhin shchekotykhin et al
would thank hakan kjellerstrand gecode team support
thankful helpful comments suggestions made anonymous
reviewers jair dx dx aaai ijcai
work supported carinthian science fund kwf contract kwf austrian science fund fwf german foundation dfg contract numbers n ja project debugging
spreadsheet programs

appendix
appendix report additional experiments made different
benchmark well simulation experiments artificially created
instances
section contains lwp fp parallelization schemes proposed
section
section reports additional measurements regarding use mergexplain
within parallel diagnosis process see section


fiparallel model diagnosis multi core computers

section finally provides additional parallelization depth first
strategies discussed section
additional experiments lwp fp parallelization strategies
addition experiments dxc benchmark systems reported section
made additional experiments constraint satisfaction ontologies
artificial hitting set construction furthermore examined effects
increasing number available threads benchmarks csps ontologies
diagnosing constraint satisfaction
data sets procedure set experiments used number csp instances
cp solver competition lecoutre roussel van dongen
injected faults diagnosis created follows first generated
random solution original csp formulations solution randomly
picked variables stored value assignments served
test cases stored variable assignments correspond expected outcomes
constraints formulated correctly next manually inserted errors mutations
constraint formulations e g changing less operator
operator corresponds mutation software testing
diagnosis task consists identifying possibly faulty constraints partial
test cases addition benchmark csps converted number spreadsheet
diagnosis jannach schmitz csps test performance gains
realistic application settings
table shows characteristics including number injected faults f
number diagnoses average diagnosis size general selected
csps quite diverse respect size
measurement threads searching diagnoses given
table improvements could achieved instances exception
smallest mknap speedups achieved lwp fp statistically
significant improvements strong running time
reduction whereas others improvements modest average fp
faster lwp however fp consistently better lwp often
differences small
observed indicate performance gains depend number factors
including size conflicts computation times conflict detection
structure average fp faster lwp characteristics
settings seem considerable impact speedups obtained
different parallelization strategies
able sufficient number repetitions picked instances comparably small running
times
mutated csps downloaded http ls www cs tu dortmund de homepage hp
downloads jair csps zip



fijannach schmitz shchekotykhin

scenario
c
costasarray
domino
gracefulk p
mknap
queens
hospital payment
profit calculation
course
preservation model
revenue calculation

c












v












f






































table characteristics selected settings
scenario
c
costasarray
domino
gracefulk p
mknap
queens
hospital payment
profit calculation
course
preservation model
revenue calculation

seq qxp
ms












lwp qxp

e



















fp qxp

e












table csp benchmarks spreadsheets searching diagnoses
diagnosing ontologies
data sets procedure recent works mbd techniques used locate faults
description logic ontologies friedrich shchekotykhin shchekotykhin et al
shchekotykhin friedrich represented web ontology language
owl grau horrocks motik parsia patel schneider sattler testing
ontology developer similarly earlier felfernig friedrich
jannach stumptner zanker specify set positive negative test cases
test cases sets logical sentences must entailed ontology positive
entailed ontology negative addition ontology set
logical sentences consistent coherent baader calvanese mcguinness
nardi patel schneider diagnosis debugging context arises
one requirements fulfilled
work shchekotykhin et al two interactive debugging approaches
tested set faulty real world ontologies kalyanpur parsia horridge sirin


fiparallel model diagnosis multi core computers

two randomly modified large real world ontologies use dataset evaluate
performance gains applying parallelization schemes ontology debugging details different tested ontologies given table
characteristics described terms description logic dl used
formulate ontology number axioms concepts c properties p
individuals terms first order logic concepts properties correspond
unary binary predicates whereas individuals correspond constants every letter
dl name alchf pdq corresponds syntactic feature language e g
alchf pdq attributive concept language complement properties hierarchy
functional properties datatypes underlying description logic reasoner used
pellet sirin parsia grau kalyanpur katz manipulation knowledge bases diagnosis process accomplished owl api horridge
bechhofer
note considered ontology debugging different diagnosis settings discussed far cannot efficiently encoded csp sat
reason decision checking consistency concept
satisfiability ontologies given table exptime complete baader et al
set experiments therefore helps us explore benefits parallelization
settings computation conflict sets hard furthermore
application parallelization approaches ontology debugging demonstrates generality methods e methods applicable
wide range diagnosis require existence sound complete
consistency checking procedure
due generality reiters general correspondingly implementation diagnosis procedures technical integration owl dl reasoner
software framework relatively simple difference csp
instead calling chocos solve method inside theorem prover make call
pellet reasoner via owl api check consistency ontology
ontology
chemical
koala
sweet jpl
minitambis
university
economy
transportation
cton
opengalen propchains

dl
alchf pdq
alcon pdq
alchof pdq
alcn
soin pdq
alchpdq
alchpdq
shf
alchif pdq












c p
































table characteristics tested ontologies
obtained thread pool size four shown table
every case parallelization advantageous compared sequential
version cases obtained speedups substantial regarding comparison


fijannach schmitz shchekotykhin

lwp fp variants clear winner across test cases lwp seems
advantageous complex respect
computation times easily solved fp sometimes slightly
better clear correlation characteristics complexity
knowledge base terms size could identified within set benchmark

ontology
chemical
koala
sweet jpl
minitambis
university
economy
transportation
cton
opengalen propchains

seq qxp
ms










lwp qxp

e














fp qxp

e










table ontologies searching diagnoses

adding threads
constraint satisfaction table shows csp benchmarks
spreadsheets threads test utilizing threads
advantageous one small scenario however tested scenarios
computations threads pay indicates
choosing right degree parallelization depend characteristics diagnosis
diagnosis mknap example cannot sped
parallelization contains one single conflict found root node
contrast graceful k p benefits use threads
could achieve speedup scenario corresponds runtime reduction

ontologies diagnosing ontologies threads shown
table tested ontologies comparably simple debugging cases
threads payed cases best diagnosing
ontologies obtained threads used one ontology
threads even slower sequential indicates
effectiveness parallelization depends characteristics diagnosis
adding threads even slightly counterproductive
systematic variation characteristics
procedure better understand way characteristics influence
performance gains used suite artificially created hitting set construction


fiparallel model diagnosis multi core computers

scenario

seq qxp
ms
e
c

costasarray

domino

gracefulk p

mknap

queens

hospital payment

profit calculation

course

preservation model

revenue calculation















fp qxp
e

e

e












table observed performance gains csp benchmarks spreadsheets
server hardware threads
ontology
chemical
koala
sweet jpl
minitambis
university
economy
transportation

seq qxp
ms

















e

















fp qxp
e









e

















e








table observed performance gains ontologies server hardware
threads

following varying parameters number components cp number conflicts
cf average size conflicts cf given parameters used generator
produces set minimal conflicts desired characteristics generator
first creates given number components uses components generate
requested number conflicts
obtain realistic settings generated conflicts equal size rather
varied according gaussian distribution desired size mean similarly
components equally likely part conflict used gaussian
distribution assign component failure probabilities probability distributions could
used generation process well e g reflect specifics certain application
domain
since experiment conflicts known advance conflict detection within consistency check return one suitable conflict upon request
zero computation times unrealistic assumption conflict


fijannach schmitz shchekotykhin

detection actually costly part diagnosis process varied assumed
conflict computation times analyze effect relative performance gains
computation times simulated adding artificial active waiting times wt inside
consistency check shown ms table note consistency check called
conflict reused current node artificial waiting time applies
cases conflict determined
experiment repeated times different variations setting
factor random effects number diagnoses thus average well
however solve identical sets thus returned identical
sets diagnoses limited search depth experiments speed
benchmark process average running times reported table
varying computation times first varied assumed conflict computation times quite small diagnosis parallel threads table
first row assumed zero computation times shows long hs tree construction
alone needs improvements parallelization smaller case
overhead thread creation synchronization however soon add average
running time ms consistency check parallelization approaches
speedup corresponds runtime reduction increasing
assumed computation time lead better relative improvements pool
threads
varying conflict sizes average conflict size impacts breadth
hs tree next therefore varied average conflict size hypothesis larger
conflicts correspondingly broader hs trees better suited parallel processing
shown table confirm assumption fp slightly efficient
lwp average conflict sizes larger however lead strong additional
improvements threads
adding threads larger conflicts adding additional threads leads
improvements threads improvements corresponding running time reduction larger conflict sizes
cases even higher levels parallelization achieved
adding components finally varied complexity
adding components potentially faulty since left number
size conflicts unchanged adding components led diagnoses included
different components limited search depth experiment fewer
diagnoses found level search trees narrower
relative performance gains lower fewer components constraints
discussion simulation experiments demonstrate advantages parallelization
tests speedups lwp fp statistically significant
confirm performance gains depend different characteristics underlying
additional gains waiting end search level worker
threads finished typically led small improvements
redundant calculations however still occur particular conflicts
nodes determined parallel two worker threads return conflict


fiparallel model diagnosis multi core computers

cp cf wt seq
lwp
cf
ms ms

e
varying computation times wt












varying conflict sizes









varying numbers components









cp cf wt seq
lwp
cf
ms ms

e
adding threads instead










fp


e




















fp

e








table simulation
although without parallelization computing resources would left unused
anyway redundant calculations lead overall longer computation times small
thread synchronization overheads
additional experiments mxp conflict detection
section report additional obtained mergexplain
instead quickxplain conflict detection strategy described section
different experiments made set csps ontology debugging remember set experiments goal identify set leading
diagnoses
diagnosing constraint satisfaction
table shows searching five diagnoses csp spreadsheet
benchmarks mxp could help reduce running times tested
scenarios except smaller ones tiny scenario mknap simple
sequential qxp fastest alternative scenarios
however parallelization pays faster sequentially expanding search
tree best could achieved scenario costasarray fp
mxp reduced running times compared sequential qxp


fijannach schmitz shchekotykhin

corresponds speedup indicate fp works well
qxp mxp
scenario
c
costasarray
domino
gracefulk p
mknap
queens
hospital payment
profit calculation
course
preservation model
revenue calculation

seq qxp
ms












fp qxp

e












seq mxp
ms












fp mxp

e












table csp benchmarks spreadsheets qxp vs mxp
note one case costasarray see efficiency value larger one
means obtained speedup super linear happen special situations
search limited number diagnoses use fp method see
section assume generating one specific node takes particularly long e
computation conflict set requires considerable amount time case
sequential stuck node time fp method
continue generating nodes nodes sufficient limited
required number diagnoses lead efficiency value greater
theoretical optimum
diagnosing ontologies
shown table similar previous experiment mxp
combination fp pays cases except simple benchmark
additional experiments parallel depth first search
section report additional experiments made assess
effects parallelizing depth first search strategy described section set
experiments goal one single minimal diagnosis report
obtained constraint ontology debugging discuss
findings simulation experiment systematically varied
characteristics
diagnosing constraint satisfaction
searching single diagnosis csps spreadsheets shown
table parallelization generally shows good strategy speed


fiparallel model diagnosis multi core computers

ontology
chemical
koala
sweet jpl
minitambis
university
economy
transportation
cton
opengalen propchains

seq qxp
ms










fp qxp

e










seq mxp
ms










fp mxp

e










table ontologies qxp vs mxp
diagnosis process measured speedups except speedup rdfs first scenario
c statistically significant specific setting fp strategy
measurable effect strategies even modest performance deterioration
observed compared reiters sequential reason lies resulting
structure hs tree narrow conflicts size one
following detailed observations made comparing
tested csps fp advantageous compared rdfs prdfs
spreadsheets contrast rdfs prdfs better breadth first
fp three five cases
comparing rdfs prdfs observe parallelization
advantageous depth first strategies
however improvements seem depend underlying structure case hospital payment scenario speedup prdfs high
compared sequential corresponds runtime reduction
parallel strategy however consistently better
test cases
performance hybrid method lies performances
two components many tested scenarios

diagnosing ontologies
next evaluated search one diagnosis real world ontologies table
tested scenarios applying depth first strategy often pay compared
breadth first methods reason tested examples ontology debugging domain many cases single element diagnoses exist quickly
detected breadth first strategy furthermore absolute running times often comparably small parallelizing depth first strategy leads significant speedups
cases


fijannach schmitz shchekotykhin

scenario
c
costasarray
domino
gracefulk p
mknap
queens
hospital payment
profit calculation
course
preservation model
revenue calculation

seq
ms












fp

e












rdfs
ms












prdfs

e












hybrid

e












table csp benchmarks spreadsheets finding one diagnosis
ontology
chemical
koala
sweet jpl
minitambis
university
economy
transportation

seq
ms








fp

e








rdfs
ms








prdfs

e








hybrid

e








table observed performance gains ontologies finding one diagnosis
systematic variation characteristics
table finally shows simulation searching one single diagnosis
experiment used uniform probability distribution selecting components
conflicts obtain complex diagnosis summarized
follows
fp expected better sequential version hs tree
tested configurations
small contain comparably small conflicts
depth first strategy work well parallel sequential versions
even slower reiters original proposal except cases zero conflict
computation times assumed indicates costs hitting set minimization high
larger instances relying depth first strategy one single
diagnosis advantageous better fp additional test even


fiparallel model diagnosis multi core computers

cp cf wt
seq
cf
ms
ms
varying computation times wt











varying conflict sizes












varying numbers components











conflicts




fp

rdfs
ms

prdfs

e

hybrid

e



e



































































































table simulation finding one diagnosis
larger shown last line table reveals potential depth first
search
larger prdfs help obtain runtime
improvements compared rdfs
hybrid method works well single case zero computation times
represents good choice structure known
overall simulation experiments speedups achieved
different methods depend underlying structure search
one single diagnosis

references
abreu r van gemund j c low cost approximate minimal hitting set
application model diagnosis sara pp
anglano c portinale l parallel model diagnosis pvm europvm pp
autio k reiter r structural abstraction model diagnosis
ecai pp
baader f calvanese mcguinness nardi patel schneider p
description logic handbook theory implementation applications vol
bolosky w j scott l false sharing effect shared memory
performance sedms pp


fijannach schmitz shchekotykhin

brungger marzetta fukuda k nievergelt j parallel search bench
zram applications annals operations
buchanan b shortliffe e eds rule expert systems mycin experiments stanford heuristic programming project addison wesley reading

burns e lemons ruml w zhou r best first heuristic search
multicore machines journal artificial intelligence
campeotto f palu dovier fioretto f pontelli e exploring
use gpus constraint solving padl pp
cardoso n abreu r distributed diagnosis candidate generation epia pp
chandra guo f kim solihin predicting inter thread cache contention chip multi processor architecture hpca pp
chu g schulte c stuckey p j confidence work stealing parallel
constraint programming cp pp
console l friedrich g dupre model diagnosis meets error
diagnosis logic programs ijcai pp
de kleer j hitting set model diagnosis dx pp
dean j ghemawat mapreduce simplified data processing large clusters communications acm
dijkstra e w structure multiprogramming system communications acm
eiter gottlob g complexity logic abduction journal
acm
feldman provan g de kleer j robert van gemund solving
model diagnosis max sat solvers vice versa dx pp

feldman provan g van gemund b approximate model diagnosis
greedy stochastic search journal artifcial intelligence

felfernig friedrich g isak k shchekotykhin k teppan e jannach
automated debugging recommender user interface descriptions applied
intelligence
felfernig friedrich g jannach stumptner consistency diagnosis configuration knowledge bases artificial intelligence
felfernig friedrich g jannach stumptner zanker hierarchical
diagnosis large configurator knowledge bases ki pp
felfernig schubert zehentner c efficient diagnosis
inconsistent constraint sets artificial intelligence engineering design analysis
manufacturing


fiparallel model diagnosis multi core computers

felfernig friedrich g jannach stumptner et al consistency
diagnosis configuration knowledge bases ecai pp
ferguson c korf r e distributed tree search application alpha beta
pruning aaai pp
friedrich g shchekotykhin k general diagnosis method ontologies
iswc pp
friedrich g stumptner wotawa f model diagnosis hardware
designs artificial intelligence
friedrich g fugini mussi e pernici b tagni g exception handling
repair service processes ieee transactions software engineering

friedrich g shchekotykhin k general diagnosis method ontologies
iswc pp
garey r johnson computers intractability guide theory
np completeness w h freeman co
grau b c horrocks motik b parsia b patel schneider p sattler u
owl next step owl web semantics science services agents
world wide web
greiner r smith b wilkerson r w correction
reiters theory diagnosis artificial intelligence
horridge bechhofer owl api java api owl ontologies
semantic web journal
jannach schmitz model diagnosis spreadsheet programs
constraint debugging automated software engineering february
published online
jannach schmitz shchekotykhin k parallelized hitting set computation
model diagnosis aaai pp
junker u quickxplain preferred explanations relaxations overconstrained aaai pp
kalyanpur parsia b horridge sirin e finding justifications
owl dl entailments semantic web vol lecture notes computer
science pp
korf r e schultze p large scale parallel breadth first search aaai
pp
kurtoglu feldman third international diagnostic competition dxc
https sites google com site dxcompetition accessed
lecoutre c roussel van dongen r c cpai competition http
www cril univ artois fr cpai accessed
li l yunfei j computing minimal hitting sets genetic
dx pp


fijannach schmitz shchekotykhin

marques silva j janota ignatiev morgado efficient model
diagnosis maximum satisfiability ijcai pp
marques silva j janota belov minimal sets monotone predicates
boolean formulae computer aided verification pp
mateis c stumptner wieland wotawa f model debugging
java programs aadebug
mencia c marques silva j efficient relaxations constrained csps
ictai pp
menca c previti marques silva j literal mcs extraction
ijcai pp
metodi stern r kalech codish novel sat
model diagnosis journal artificial intelligence
michel l see van hentenryck p parallelizing constraint programs transparently cp pp
nica pill quaritsch wotawa f route success performance
comparison diagnosis ijcai pp
nica wotawa f condiag computing minimal diagnoses constraint
solver dx pp
phillips likhachev koenig pa se parallel slow expansions
icaps
pill quaritsch wotawa f conflicts diagnoses empirical
evaluation minimal hitting set dx pp
pill quaritsch optimizations boolean computing
minimal hitting sets ecai pp
powley c korf r e single agent parallel window search ieee transactions
pattern analysis machine intelligence
previti ignatiev morgado marques silva j prime compilation
non clausal formulae ijcai pp
prudhomme c fages j g lorca x choco documentation tasc inria
rennes lina cnrs umr cosling http www choco solver org
reiter r theory diagnosis first principles artificial intelligence

rymon r se tree prime implicant generation annals
mathematics artificial intelligence
satoh k uno enumerating minimally revised specifications dualization jsai pp
schulte c lagerkvist tack g gecode open free efficient constraint
solving toolkit http www gecode org accessed


fiparallel model diagnosis multi core computers

shchekotykhin k friedrich g fleiss p rodler p interactive ontology debugging two query strategies efficient fault localization journal web semantics

shchekotykhin k friedrich g query strategy sequential ontology
debugging iswc pp
shchekotykhin k jannach schmitz mergexplain fast computation
multiple conflicts diagnosis ijcai pp
shchekotykhin k friedrich g rodler p fleiss p sequential diagnosis
high cardinality faults knowledge bases direct diagnosis generation ecai
pp
sirin e parsia b grau b c kalyanpur katz pellet practical
owl dl reasoner web semantics science services agents world wide
web
stern r kalech feldman provan g exploring duality conflictdirected model diagnosis aaai pp
stuckey p j feydy schutt tack g fischer j minizinc challenge
ai magazine
stumptner wotawa f debugging functional programs ijcai pp

stumptner wotawa f diagnosing tree structured systems artificial
intelligence
white j benavides schmidt c trinidad p dougherty b cortes r
automated diagnosis feature model configurations journal systems
software
williams b c ragno r j conflict directed role model
embedded systems discrete applied mathematics
wotawa f variant reiters hitting set information processing
letters
wotawa f b debugging hardware designs value model applied
intelligence
wotawa f pill classification modeling issues distributed modelbased diagnosis ai communications




