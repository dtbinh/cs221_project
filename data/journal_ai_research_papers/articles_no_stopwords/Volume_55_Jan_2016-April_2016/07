Journal Artificial Intelligence Research 55 (2016) 835-887

Submitted 10/2015; published 04/2016

Parallel Model-Based Diagnosis Multi-Core Computers
Dietmar Jannach
Thomas Schmitz

dietmar.jannach@tu-dortmund.de
thomas.schmitz@tu-dortmund.de

TU Dortmund, Germany

Kostyantyn Shchekotykhin

kostyantyn.shchekotykhin@aau.at

Alpen-Adria University Klagenfurt, Austria

Abstract
Model-Based Diagnosis (MBD) principled domain-independent way analyzing system examination behaving expected. Given abstract
description (model) systems components behavior functioning normally, MBD techniques rely observations actual system behavior reason
possible causes discrepancies expected observed behavior. Due generality, MBD successfully applied variety application
domains last decades.
many application domains MBD, testing different hypotheses reasons
failure computationally costly, e.g., complex simulations system behavior performed. work, therefore propose different schemes
parallelizing diagnostic reasoning process order better exploit capabilities
modern multi-core computers. propose systematically evaluate parallelization
schemes Reiters hitting set algorithm finding leading minimal diagnoses using two different conflict detection techniques. Furthermore, perform initial
experiments basic depth-first search strategy assess potential parallelization
searching one single diagnosis. Finally, test effects parallelizing direct
encodings diagnosis problem constraint solver.

1. Introduction
Model-Based Diagnosis (MBD) subfield Artificial Intelligence concerned
automated determination possible causes system behaving expected.
early days MBD, diagnosed systems typically hardware artifacts
electronic circuits. contrast earlier heuristic diagnosis approaches connected
symptoms possible causes, e.g., expert rules (Buchanan & Shortliffe, 1984),
MBD techniques rely abstract explicit representation (model) examined
system. models contain information systems structure, i.e., list
components connected, well information behavior
components functioning correctly. model available, expected behavior (outputs) system given inputs thus calculated. diagnosis problem
arises whenever expected behavior conflicts observed system behavior. MBD
techniques core construct test hypotheses faultiness individual
components system. Finally, diagnosis considered subset components
that, assumed faulty, explain observed behavior system.
Reiter (1987) suggests formal logical characterization diagnosis problem
first principles proposed breadth-first tree construction algorithm determine
c
2016
AI Access Foundation. rights reserved.

fiJannach, Schmitz, & Shchekotykhin

diagnoses given problem. Due generality used knowledge-representation
language suggested algorithms computation diagnoses, MBD
later applied variety application problems hardware. application
fields MBD, example, include diagnosis knowledge bases ontologies, process
specifications, feature models, user interface specifications user preference statements,
various types software artifacts including functional logic programs well
VHDL, Java spreadsheet programs (Felfernig, Friedrich, Jannach, & Stumptner, 2004;
Mateis, Stumptner, Wieland, & Wotawa, 2000; Jannach & Schmitz, 2014; Wotawa, 2001b;
Felfernig, Friedrich, Isak, Shchekotykhin, Teppan, & Jannach, 2009; Console, Friedrich,
& Dupre, 1993; Friedrich & Shchekotykhin, 2005; Stumptner & Wotawa, 1999; Friedrich,
Stumptner, & Wotawa, 1999; White, Benavides, Schmidt, Trinidad, Dougherty, & Cortes,
2010; Friedrich, Fugini, Mussi, Pernici, & Tagni, 2010).
several application fields, search diagnoses requires repeated computations based modified versions original model test different hypotheses
faultiness individual components. several works original problem
converted Constraint Satisfaction Problem (CSP) number relaxed versions
original CSP solved construct new node search tree (Felfernig
et al., 2004; Jannach & Schmitz, 2014; White et al., 2010). Depending application domain, computation CSP solutions check consistency can, however,
computationally intensive actually represents costly operation
construction search tree. Similar problems arise underlying reasoning
techniques, e.g., ontology debugging (Friedrich & Shchekotykhin, 2005), used.
Current MBD algorithms sequential nature generate one node time.
Therefore, exploit capabilities todays multi-core computer processors,
nowadays found even mobile devices. paper, propose new schemes
parallelize diagnostic reasoning process better exploit available computing
resources modern computer hardware. particular, work comprises following
algorithmic contributions insights based experimental evaluations:
propose two parallel versions Reiters (1987) sound complete Hitting Set
(HS) algorithm speed process finding diagnoses, common
problem setting above-described MBD applications. approaches
considered window-based parallelization schemes, means limited number search nodes processed parallel point time.
evaluate two different conflict detection techniques multi-core setting,
goal find leading diagnoses. set experiments, multiple conflicts computed construction tree node using novel
MergeXplain method (MXP) (Shchekotykhin, Jannach, & Schmitz, 2015)
processing time therefore implicitly allocated conflict generation.
demonstrate speedups achieved parallelization scenarios search one single diagnosis, e.g., using basic parallel
depth-first strategy.
measure improvements achieved parallel constraint solving
using direct CSP-based encoding diagnosis problem. experiment
836

fiParallel Model-Based Diagnosis Multi-Core Computers

illustrates parallelization underlying solvers, particular using
direct encoding, advantageous.
evaluate proposed parallelization schemes extensive set experiments. following problem settings analyzed.
(i) Standard benchmark problems diagnosis research community;
(ii) Mutated CSPs Constraint Programming competition domain
CSP-based spreadsheet debugging (Jannach & Schmitz, 2014);
(iii) Faulty OWL ontologies used evaluation MBD-based debugging techniques
expressive ontologies (Shchekotykhin, Friedrich, Fleiss, & Rodler, 2012);
(iv) Synthetically generated problems allow us vary characteristics
underlying diagnosis problem.
results show using parallelization techniques help achieve substantial
speedups diagnosis process (a) across variety application scenarios, (b) without
exploiting specific knowledge structure underlying diagnosis problem,
(c) across different problem encodings, (d) application problems ontology
debugging cannot efficiently encoded SAT problems.
outline paper follows. next section, define main concepts
MBD introduce algorithm used compute diagnoses. Section 3, present
systematically evaluate parallelization schemes Reiters HS-tree method
goal find minimal diagnoses. Section 4, report results evaluations
implicitly allocate processing time conflict generation using MXP
conflict detection. Section 5 assess potential gains comparably simple
randomized depth-first strategy hybrid technique problem finding one
single diagnosis. results experiments direct CSP encoding reported
Section 6. Section 7 discuss previous works. paper ends summary
outlook Section 8.

2. Reiters Diagnosis Framework
section summarizes Reiters (1987) diagnosis framework use basis
work.
2.1 Definitions
Reiter (1987) formally characterized Model-Based Diagnosis using first-order logic.
main definitions summarized follows.
Definition 2.1. (Diagnosable System) diagnosable system described pair (SD,
Comps) SD system description (a set logical sentences) Comps represents
systems components (a finite set constants).
connections components normal behavior components
described terms logical sentences. normal behavior system components
837

fiJannach, Schmitz, & Shchekotykhin

usually described SD help distinguished negated unary predicate ab(.),
meaning abnormal.
diagnosis problem arises observation P Obs systems input-output
behavior (again expressed first-order sentences) deviates expected system behavior. diagnosis corresponds subset systems components
assume behave abnormally (be faulty) assumptions must consistent
observations. words, malfunctioning components
possible reason observations.
Definition 2.2. (Diagnosis) Given diagnosis problem (SD, Comps, Obs), diagnosis
subset minimal set Comps SD Obs tab(c)|c P u abpcq|c P
Compszu consistent.
According Definition 2.2, interested minimal diagnoses, i.e., diagnoses
contain superfluous elements thus supersets diagnoses. Whenever use term diagnosis remainder paper, therefore mean minimal
diagnosis. Whenever refer non-minimal diagnoses, explicitly mention fact.
Finding diagnoses theory done simply trying possible subsets
Comps checking consistency observations. Reiter (1987), however,
proposes efficient procedure based concept conflicts.
Definition 2.3. (Conflict) conflict (SD, Comps, Obs) set tc1 , ..., ck u Comps
SD Obs abpc1 q, ..., abpck qu inconsistent.
conflict corresponds subset components which, assumed behave normally,
consistent observations. conflict c considered minimal,
proper subset c exists conflict.
2.2 Hitting Set Algorithm
Reiter (1987) discusses relationship conflicts diagnoses claims
Theorem 4.4 set diagnoses collection (minimal) conflicts F
equivalent set H minimal hitting sets 1 F .
determine minimal hitting sets therefore diagnoses, Reiter proposes
breadth-first search procedure construction hitting set tree (HS-tree), whose
construction guided conflicts. logic-based definition MBD problem
(Reiter, 1987), conflicts computed calls Theorem Prover (TP). TP
component considered black box assumptions made
conflicts determined. Depending application scenario problem encoding,
one can, however, use specific algorithms QuickXplain (Junker, 2004), Progression (Marques-Silva, Janota, & Belov, 2013) MergeXplain (Shchekotykhin et al., 2015),
guarantee computed conflict sets minimal.
main principle HS-tree algorithm create search tree node
either labeled conflict represents diagnosis. latter case node
expanded. Otherwise, child node generated element nodes
1. Given collection C subsets finite set S, hitting set C subset contains
least one element subset C. corresponds set cover problem.

838

fiParallel Model-Based Diagnosis Multi-Core Computers

conflict outgoing edge labeled one component nodes conflict.
subsequent expansions node components used label edges
path root tree current node assumed faulty. newly
generated child node either diagnosis labeled conflict
contain component already assumed faulty stage. conflict
found node, path labels represent diagnosis sense Definition 2.2.
2.2.1 Example
following example show HS-tree algorithm QuickXplain
(QXP) conflict detection technique combined locate fault specification
CSP. CSP instance defined tuple pV, D, Cq, V tv1 , . . . , vn u
set variables, tD1 , . . . , Dn u set domains variables V ,
C tC1 , . . . , Ck u set constraints. assignment subset X V set
pairs txv1 , d1 y, . . . , xvk , dm yu vi P X variable dj P Di value
domain variable. assignment comprises exactly one variable-value pair
variable X. constraint Ci P C defined list variables S, called scope,
forbids allows certain simultaneous assignments variables scope.
assignment satisfies constraint Ci comprises assignment allowed Ci .
assignment solution satisfies constraints C.
Consider CSP instance variables V ta, b, cu variable
domain t1, 2, 3u following set constraints defined:
C1 : b,

C2 : b c,

C3 : c a,

C4 : b c

Obviously, solution exists diagnosis problem consists finding subsets
constraints whose definition faulty. engineer modeled CSP could,
example, made mistake writing C2, b c.
Eventually, C4 added later correct problem, engineer forgot remove
C2. Given faulty definition I, two minimal conflicts exist, namely ttC1, C2, C3u,
tC2, C4uu, determined help QXP. Given two conflicts,
HS-tree algorithm finally determine three minimal hitting sets ttC2u, tC1, C4u,
tC3, C4uu, diagnoses problem instance. set diagnoses contains
true cause error, definition C2.
Let us review detail HS-tree/QXP combination works example problem. illustrate tree construction Figure 1. logic-based definition
Reiter, HS-tree algorithm starts check observations Obs consistent
system description SD components Comps. application setting
corresponds check exists solution CSP instance.2 Since
case, QXP-call made, returns conflict tC1, C2, C3u, used
label root node ( 1 ) tree. element conflict, child node
created conflict element used path label. tree node, consistency SD, Obs, Comps tested; time, however, elements appear
2. Comps constraints tC1...C4u SD corresponds semantics/logic constraints
working correctly, e.g., ABpC1q _ pa bq. Obs empty example could partial value
assignment (test case) another scenario.

839

fiJannach, Schmitz, & Shchekotykhin

1
{C1,C2, C3}
C1

2

C2

C3

3

{C2,C4}
4

C2

{C2,C4}

C4

C4

C2
5

Figure 1: Example HS-tree construction.
labels path root node current node considered abnormal.
CSP diagnosis setting, means check solution modified
version original CSP remove constraints appear labels
path root current node.
node 2 , C1 correspondingly considered abnormal. removing C1
CSP is, however, sufficient solution exists relaxed problem, another call
QXP made, returns conflict tC2, C4u. tC1u therefore diagnosis
new conflict used label node 2 . algorithm proceeds breadth-first
style tests assuming tC2u tC3u individually faulty consistent
observations, case means solution relaxed CSP exists. Since tC2u
diagnosis least one solution exists C2 removed CSP definition
node marked 3 expanded. node 3 , correspond
diagnosis, already known conflict tC2, C4u reused overlap
nodes path label call P (QXP) required. last tree level,
nodes 4 5 expanded (closed marked 7) tC2u
already identified diagnosis previous level resulting diagnoses would
supersets tC2u. Finally, sets tC1, C4u tC3, C4u identified additional
diagnoses.
2.2.2 Discussion
Soundness Completeness According Reiter (1987), breadth-first construction scheme node closing rule ensure minimal diagnoses computed.
end HS-tree construction process, set edge labels path
root tree node marked 3 corresponds diagnosis.3
Greiner, Smith, Wilkerson (1989), later on, identified potential problem Reiters
algorithm cases conflicts returned P guaranteed minimal.
extension algorithm based HS-DAG (directed acyclic graph) structure
proposed solve problem.
context work, use methods return conflicts guaranteed minimal. example, according Theorem 1 work Junker (2004),
given set formulas sound complete consistency checker, QXP always returns
3. Reiter (1987) states Theorem 4.8 given set conflict sets F , HS-tree algorithm outputs
pruned tree set tHpnq|n node labeled 3u corresponds set H
minimal hitting sets F Hpnq set arc labels path node n root.

840

fiParallel Model-Based Diagnosis Multi-Core Computers

either minimal conflict conflict. minimality guarantee turn means
combination HS-tree algorithm QXP sound complete, i.e., returned
solutions actually (minimal) diagnoses diagnosis given set conflicts
missed. holds computing multiple conflicts time MXP
(Shchekotykhin et al., 2015).
simplify presentation parallelization approaches, therefore rely
Reiters original HS-tree formulation; extension deal HS-DAG structure
(Greiner et al., 1989) possible.
On-Demand Conflict Generation Complexity many above-mentioned
applications MBD practical problems, conflicts computed on-demand,
i.e., tree construction, cannot generally assume set minimal
conflicts given advance. Depending problem setting, finding conflicts
therefore computationally intensive part diagnosis process.
Generally, finding hitting sets collection sets known NP-hard problem
(Garey & Johnson, 1979). Moreover, deciding additional diagnosis exists conflicts
computed demand NP-complete even propositional Horn theories (Eiter &
Gottlob, 1995). Therefore, number heuristics-based, approximate thus incomplete,
well problem-specific diagnosis algorithms proposed years.
discuss approaches later sections. next section, we, however, focus
(worst-case) application scenarios goal find minimal diagnoses given
problem, i.e., focus complete algorithms.
Consider, example, problem debugging program specifications (e.g., constraint
programs, knowledge bases, ontologies, spreadsheets) MBD techniques mentioned
above. application domains, typically sufficient find one minimal diagnosis. work Jannach Schmitz (2014), example, spreadsheet developer
presented ranked list sets formulas (diagnoses) represent possible
reasons certain test case failed. developer either inspect
individually provide additional information (e.g., test cases) narrow set
candidates. one diagnosis computed presented, developer would
guarantee true cause problem, lead limited acceptance
diagnosis tool.

3. Parallel HS-Tree Construction
section present two sound complete parallelization strategies Reiters
HS-tree method determine minimal diagnoses.
3.1 Non-recursive HS-Tree Algorithm
use non-recursive version Reiters sequential HS-tree algorithm basis
implementation two parallelization strategies. Algorithm 1 shows main loop
breadth-first procedure, uses list open nodes expanded central data
structure.
algorithm takes diagnosis problem (DP) instance input returns set
diagnoses. DP given tuple (SD, Comps, Obs), SD system
841

fiJannach, Schmitz, & Shchekotykhin

Algorithm 1: diagnose: Main algorithm loop.
Input: diagnosis problem (SD, Comps, Obs)
Result: set diagnoses
1
2
3
4
5
6
7
8
9

H; paths H; conflicts H;
nodesToExpand = xgenerateRootNode(SD, Comps, Obs)y;
nodesToExpand x
newNodes = x y;
node = head(nodesToExpand) ;
foreach c P node.conflict
generateNode(node, c, , paths, conflicts, newNodes);
nodesToExpand = tail(nodesToExpand) newNodes;
return ;

Algorithm 2: generateNode: Node generation logic.
Input: existingNode expand, conflict element c P Comps,
sets , paths, conflicts, newNodes
1
2
3
4
5
6
7
8
9
10
11
12
13

newPathLabel = existingNode.pathLabel {c};
pE l P : l newPathLabelq ^ checkAndAddPathppaths, newPathLabelq
node = new Node(newPathLabel);
P conflicts : X newPathLabel H
node.conflict = S;
else
newConflicts = checkConsistency(SD, Comps, Obs, node.pathLabel);
node.conflict = head(newConflicts);
node.conflict H
newNodes = newNodes xnodey;
conflicts = conflicts newConflicts;
else
{node.pathLabel};

description, Comps set components potentially faulty Obs set
observations. method generateRootNode creates initial node, labeled
conflict empty path label. Within loop, first element firstin-first-out (FIFO) list open nodes nodesToExpand taken current element.
function generateNode (Algorithm 2) called element nodes conflict
adds new leaf nodes, still explored, global list. new
nodes appended () remaining list open nodes main loop,
842

fiParallel Model-Based Diagnosis Multi-Core Computers

continues elements remain expansion.4 Algorithm 2 (generateNode)
implements node generation logic, includes Reiters proposals conflict re-use,
tree pruning, management lists known conflicts, paths diagnoses.
method determines path label new node checks new path label
superset already found diagnosis.
Algorithm 3: checkAndAddPath: Adding new path label redundancy
check.
Input: previously explored paths, newPathLabel explored
Result: Boolean stating newPathLabel added paths

3

E l P paths : l newPathLabel
paths = paths newPathLabel;
return true;

4

return false;

1
2

function checkAndAddPath (Algorithm 3) used check node
already explored elsewhere tree. function returns true new path label
successfully inserted list known paths. Otherwise, list known paths
remains unchanged node closed.
new nodes, either existing conflict reused new one created call
consistency checker (Theorem Prover), tests new node diagnosis
returns set minimal conflicts otherwise. Depending outcome, new node
added list nodesToExpand diagnosis stored. Note Algorithm 2
return value instead modifies sets , paths, conflicts, newNodes,
passed parameters.
3.2 Level-Wise Parallelization
first parallelization scheme examines nodes one tree level parallel proceeds
next level elements level processed. example shown
Figure 1, would mean computations (consistency checks theorem prover
calls) required three first-level nodes labeled tC1u, tC2u, tC3u done
three parallel threads. nodes next level explored threads
previous level finished.
Using Level-Wise Parallelization (LWP) scheme, breadth-first character maintained. parallelization computations generally feasible consistency
checks node done independently done nodes
level. Synchronization required make sure thread starts exploring
path already examination another thread.
Algorithm 4 shows sequential Algorithm 1 adapted support
parallelization approach. Again, maintain list open nodes expanded.
difference run expansion nodes parallel collect
4. limitation regarding search depth number diagnoses find easily integrated
scheme.

843

fiJannach, Schmitz, & Shchekotykhin

Algorithm 4: diagnoseLW: Level-Wise Parallelization.
Input: diagnosis problem (SD, Comps, Obs)
Result: set diagnoses
1
2
3
4
5
6
7
8
9
10

H; conf licts H; paths = H;
nodesToExpand = xgenerateRootNode(SD, Comps, Obs)y;
nodesToExpand x
newNodes = x y;
foreach node P nodesToExpand
foreach c P node.conflict
// computations parallel
threads.execute(generateNode(node, c, , paths, conflicts, newNodes));
threads.await();
nodesToExpand = newNodes;

// Wait current level complete
// Prepare next level

return ;

nodes next level variable newNodes. current level finished,
overwrite list nodesToExpand list containing nodes next level.
Java-like API calls used pseudo-code Algorithm 4 interpreted
follows. statement threads.execute() takes function parameter schedules
execution pool threads given size. thread pool of, e.g., size 2,
generation first two nodes would done parallel next ones would
queued one threads finished. mechanism, ensure
number threads executed parallel less equal number hardware
threads CPUs.
statement threads.await() used synchronization blocks execution
subsequent code scheduled threads finished. guarantee
path explored twice, make sure two threads parallel add node
path label list known paths. achieved declaring
function checkAndAddPath critical section (Dijkstra, 1968), means
two threads execute function parallel. Furthermore, make access
global data structures (e.g., already known conflicts diagnoses) thread-safe,
i.e., ensure two threads simultanuously manipulate them.5
3.3 Full Parallelization
LWP, situations computation conflict specific node
takes particularly long. This, however, means even nodes current
level finished many threads idle, expansion HS-tree cannot proceed
level completed. Algorithm 5 shows proposed Full Parallelization (FP)
algorithm variant, immediately schedules every expandable node execution
thereby avoids potential CPU idle times end level.
5. Controlling concurrency aspects comparably simple modern programming languages Java,
e.g., using synchronized keyword.

844

fiParallel Model-Based Diagnosis Multi-Core Computers

Algorithm 5: diagnoseFP: Full Parallelization.
Input: diagnosis problem (SD, Comps, Obs)
Result: set diagnoses
1
2
3
4
5
6
7
8

9
10
11
12

H; paths H; conflicts H;
nodesToExpand = xgenerateRootNode(SD, Comps, Obs)y;
size = 1; lastSize = 0;
psizelastSizeq _ pthreads.activeThreads 0q
1 size lastSize
node = nodesToExpand.get[lastSize + i];
foreach c P node.conflict
threads.execute(generateNodeFP(node, c, , paths, conflicts,
nodesToExpand));
lastSize = size;
wait();
size = nodesToExpand.length();
return ;

main loop algorithm slightly different basically monitors list
nodes expand. Whenever new entries list observed, i.e., last observed
list size different current one, retrieves recently added elements adds
thread queue execution. algorithm returns diagnoses new
elements added since last check threads active.6
FP, search necessarily follow breadth-first strategy anymore
non-minimal diagnoses found process. Therefore, whenever find new
diagnosis d, check set known diagnoses contains supersets
remove .
updated generateNode method listed Algorithm 6. updating shared
data structures (nodesToExpand, conflicts, ), make sure threads
interfere other. mutual exclusive section marked synchronized
keyword.
compared LWP, FP wait end level specific
node takes particularly long generate. hand, FP needs synchronization
threads, cases last nodes level finished
time, LWP could advantageous. evaluate aspect Section 3.5.
3.4 Properties Algorithms
Algorithm 1 together Algorithms 2 3 corresponds implementation
HS-tree algorithm (Reiter, 1987). Algorithm 1 implements breadth-first search strategy
point (1) Reiters HS-tree algorithm since nodes stored list nodesToExpand
6. functions wait() notify() implement semantics pausing thread awaking paused
thread Java programming language used avoid active waiting loops.

845

fiJannach, Schmitz, & Shchekotykhin

Algorithm 6: generateNodeFP: Extended node generation logic.
Input: existingNode expand, c P Comps,
sets , paths, conflicts, nodesToExpand
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16

17

newPathLabel = existingNode.pathLabel {c};
pE l P : l newPathLabelq ^ checkAndAddPathppaths, newPathLabelq
node = new Node(newPathLabel);
P conflicts : X newPathLabel H
node.conflict = S;
else
newConflicts = checkConsistency(SD, Comps, Obs, node.pathLabel);
node.conflict = head(newConflicts);
synchronized
node.conflict H
nodesToExpand = nodesToExpand xnodey;
conflicts = conflicts newConflicts;
else E P : newPathLabel
{node.pathLabel};
P : newPathLabel
z d;
notify();

processed iteratively first-in-first-out order (see lines 5 8). Algorithm 2 first
checks pruning rules (i) (ii) Reiter applied line 2. rules state
node pruned (i) exists diagnosis (ii) set labels
corresponding path tree subset set labels
path node. Pruning rule (ii) implemented Algorithm 3. Pruning rule (iii)
Reiters algorithm necessary since settings TP -call guarantees return
minimal conflicts.
Finally, point (2) Reiters HS-tree algorithm description implemented lines
4-8 Algorithm 2. Here, algorithm checks conflict reused
node label. case reuse possible, algorithm calls theorem prover TP find
another minimal conflict. conflict found, node added list open nodes
nodesToExpand . Otherwise, set node path labels added set diagnoses.
corresponds situation Reiters algorithm would mark node
HS-tree 3 symbol. Note label nodes 7 done Reiters
algorithms since simply store nodes expansion list.
Overall, conclude HS-tree algorithm implementation (Algorithm 1
3) properties Reiters original HS-tree algorithm. Namely, hitting set
returned algorithm minimal (soundness) existing minimal hitting sets
found (completeness).
846

fiParallel Model-Based Diagnosis Multi-Core Computers

3.4.1 Level-Wise Parallelization (LWP)
Theorem 3.1. Level-Wise Parallelization sound complete.
Proof. proof based fact LWP uses expansion pruning
techniques sequential algorithm (Algorithms 2 3). main loop line 3 applies
procedure original algorithm difference executions
Algorithm 2 done parallel level tree. Therefore, difference
sequential algorithm LWP lies order nodes one level
labeled generated.
Let us assume two nodes n1 n2 tree sequential
HS-tree algorithm process n1 n2 . Assuming neither n1 n2 correspond
diagnoses, sequential Algorithm 1 would correspondingly first add child nodes
n1 queue open nodes later append child nodes n2 .
parallelize computations needed generation n1 n2 LWP,
happen computations n1 need longer n2 . case
child nodes n2 placed queue first. order nodes
subsequently processed is, however, irrelevant computation minimal hitting
sets, since neither labeling pruning rules influenced it. fact,
labeling node n depends whether minimal conflict set f exists
Hpnq X f H, nodes level. pruning rules
state node n pruned exists node n1 labeled 3
Hpn1 q Hpnq, i.e., supersets already found diagnoses pruned. n n1
level, |Hpnq| |Hpn1 q|. Consequently, pruning rule applied
Hpnq Hpn1 q. Therefore, order nodes, i.e., nodes pruned, irrelevant
minimal hitting set lost. Consequently, LWP complete.
Soundness algorithm follows fact LWP constructs hitting sets
always order increasing cardinality. Therefore, LWP always return minimal hitting sets even scenarios stop k diagnoses found,
1 k N predefined constant N total number diagnoses
problem.
3.4.2 Full Parallelization (FP)
minimality hitting sets encountered search guaranteed FP,
since algorithm schedules node processing immediately generation (line 8
Algorithm 5). special treatment generateNodeFP function ensures
supersets already found hitting sets added supersets newly found
hitting set removed thread-safe manner (lines 13 16 Algorithm 6). Due
change generateNodeFP, analysis soundness completeness
done two distinct cases.
Theorem 3.2. Full Parallelization sound complete, applied find diagnoses
cardinality.
Proof. FP stops either (i) hitting set exists, i.e., leaf nodes tree
labeled either 3 7, (ii) predefined cardinality (tree-depth) reached.
latter case, every leaf node tree labeled either 3, 7, minimal conflict
847

fiJannach, Schmitz, & Shchekotykhin

set. Case (ii) reduced (i) removing branches tree labeled
minimal conflict. branches irrelevant since contribute
minimal hitting sets higher cardinality. Therefore, without loss generality, limit
discussion case (i).
According definition generateNodeFP, tree built using pruning
rule done sequential HS-tree algorithm. consequence, tree generated
FP must comprise least nodes tree generated sequential HStree procedure. Therefore, according Theorem 4.8 work Reiter (1987)
tree generated FP must comprise set leaf nodes labeled 3
set tHpnq|n node labeled 3u corresponds set H minimal hitting
sets. Moreover, result returned FP comprises minimal hitting sets,
generateNodeFP removes hitting sets H supersets hitting sets.
Consequently, FP sound complete, applied find diagnoses.
Theorem 3.3. Full Parallelization cannot guarantee completeness soundness
applied find first k diagnoses, i.e. 1 k N , N total number
diagnoses problem.
Proof. proof done constructing example FP returns least
one non-minimal hitting set set , thus violating Definition 2.2. instance,
situation might occur FP applied find one single diagnosis example problem
presented Section 2.2.1. Let us assume generation node corresponding
path C2 delayed, e.g., operating system scheduled another thread
execution first, node 4 correspondingly generated first. case, algorithm
would return non-minimal hitting set tC1, C2u diagnosis.
Note elements set returned FP case turned
diagnoses applying minimization algorithm Inv-QuickXplain (Shchekotykhin,
Friedrich, Rodler, & Fleiss, 2014), algorithm adopts principles QuickXplain
applies divide-and-conquer strategy find one minimal diagnosis given set
inconsistent constraints.
Given hitting set H diagnosis problem, algorithm capable computing
minimal hitting set H 1 H requiring Op|H 1 |`|H 1 | logp|H|{|H 1 |qqq calls theorem
prover TP. first part, |H 1 |, reflects computational costs determining whether
H 1 minimal. second part represents number subproblems must
considered divide-and-conquer algorithm order find minimal hitting set H 1 .
3.5 Evaluation
determine performance improvements achieved various forms
parallelization proposed paper, conducted series experiments diagnosis
problems number different application domains. Specifically, used electronic
circuit benchmarks DX Competition 2011 Synthetic Track, faulty descriptions
Constraint Satisfaction Problems (CSPs), well problems domain ontology
debugging. addition, ran experiments synthetically created diagnosis problems
analyze impact varying different problem characteristics. diagnosis algorithms
848

fiParallel Model-Based Diagnosis Multi-Core Computers

evaluated paper implemented Java unless noted otherwise. Generally,
use wall clock times performance measure.
main part paper, focus results DX Competition
problems widely used benchmark. results problem
setups presented discussed appendix paper. cases,
results DX Competition problems follow similar trend achieved
experiments.
section compare HS-tree parallelization schemes LWP FP
sequential version algorithm, goal find diagnoses.
3.5.1 Dataset Procedure
set experiments, selected first five systems DX Competition 2011
Synthetic Track (see Table 1) (Kurtoglu & Feldman, 2011). system, competition specifies 20 scenarios injected faults resulting different faulty output values.
used system description given input output values diagnosis
process. additional information injected faults course ignored.
problems converted Constraint Satisfaction Problems. experiments used
Choco (Prudhomme, Fages, & Lorca, 2015) constraint solver QXP conflict
detection, returns one minimal conflict called node construction.
computation times required conflict identification strongly depend
order possibly faulty constraints, shuffled constraints test repeated
tests 100 times. report wall clock times actual diagnosis task; times
required input output independent HS-tree construction scheme
relevant benchmarks. parallel approaches, used thread pool size
four.7
Table 1 shows characteristics systems terms number constraints
(#C) problem variables (#V).8 numbers injected faults (#F)
numbers calculated diagnoses (#D) vary strongly different scenarios
system. columns show ranges values scenarios.
columns #D |D| indicate average number diagnoses average cardinality.
seen, search tree diagnosis become extremely broad
6,944 diagnoses average diagnosis size 3.38 system c432.
3.5.2 Results
Table 2 shows averaged results searching minimal diagnoses. first list
running times milliseconds sequential version (Seq.) improvements
LWP FP terms speedup efficiency respect sequential version.
Speedup Sp computed Sp T1 {Tp , T1 wall time using 1 thread (the
sequential algorithm) Tp wall time p parallel threads used. speedup
7. four hardware threads reasonable assumption standard desktop computers mobile
devices. hardware used evaluation chapter laptop Intel i7-3632QM
CPU, 16GB RAM, running Windows 8 four cores hyperthreading. results
evaluation server hardware 12 cores reported later Section.
8. systems marked *, search depth limited actual number faults ensure
sequential algorithm terminates within reasonable time frame.

849

fiJannach, Schmitz, & Shchekotykhin

System
74182
74L85
74283*
74181*
c432*

#C
21
35
38
67
162

#V
28
44
45
79
196

#F
4-5
1-3
2-4
3-6
2-5

#D
30 - 300
1 - 215
180 - 4,991
10 - 3,828
1 - 6,944

#D
139.0
66.4
1,232.7
877.8
1,069.3

|D|
4.66
3.13
4.42
4.53
3.38

Table 1: Characteristics selected DXC benchmarks.
2 would therefore mean needed computation times halved; speedup 4,
theoretical optimum using 4 threads, means time reduced
one quarter. efficiency Ep defined Sp {p compares speedup
theoretical optimum. fastest algorithm system highlighted bold.
System
74182
74L85
74283*
74181*
c432*

Seq.(QXP)
[ms]
65
209
371
21,695
85,024

LWP(QXP)
S4
E4
2.23
0.56
2.55
0.64
2.53
0.63
1.22
0.31
1.47
0.37

FP(QXP)
S4
E4
2.28 0.57
2.77 0.69
2.66 0.67
3.19 0.80
3.75 0.94

Table 2: Observed performance gains DXC benchmarks searching diagnoses.

tests, parallelization approaches outperform sequential algorithm. Furthermore, differences sequential algorithm one parallel approaches statistically significant (p 0.05) 95 100 tested scenarios.
systems, FP efficient LWP speedups range 2.28 3.75
(i.e., reduction running times 70%). 59 100 scenarios
differences LWP FP statistically significant. trend
observed efficiency FP higher complex problems. reason
problems time needed node generation much larger absolute
numbers additional overhead times required thread synchronization.
3.5.3 Adding Threads
use cases diagnosis process done powerful server architectures
often even CPU cores modern desktop computers. order assess
extent 4 threads help speed diagnosis process, tested
different benchmarks server machine 12 CPU cores. test compared
FP 4, 8, 10, 12 threads sequential algorithm.
results DXC benchmark problems shown Table 3. tested systems
diagnosis process faster using 8 instead 4 threads substantial speedups
5.20 could achieved compared sequential diagnosis, corresponds
850

fiParallel Model-Based Diagnosis Multi-Core Computers

runtime reduction 81%. one system, utilization 10 threads led
additional speedups. Using 12 threads fastest 3 5 tested systems.
efficiency, however, degrades threads used, time needed
synchronization threads. Using threads hardware actually cores
result additional speedups tested systems. reason
time threads busy conflict detection, e.g., finding solutions CSPs,
use almost 100% processing power assigned them.
System
74182
74L85
74283
74181*
c432*

Seq.(QXP)
[ms]
58
184
51,314
13,847
43,916

S4
2.09
2.53
3.04
3.45
3.43

E4
0.52
0.63
0.76
0.86
0.86

S8
2.43
3.29
4.38
5.20
4.77

FP(QXP)
E8
S10
E10
0.30 2.52 0.25
0.41 3.35 0.34
0.55 4.42 0.44
0.65 5.11 0.51
0.60 5.00 0.50

S12
2.54
3.38
4.50
5.19
4.74

E12
0.21
0.28
0.37
0.43
0.39

Table 3: Observed performance gains DXC benchmarks server 12 hardware
threads.

3.5.4 Additional Experiments
details additional experiments conducted compare proposed parallelization schemes sequential HS-Tree algorithm presented Section A.1
appendix. results show significant speedups achieved Constraint Satisfaction Problems (Section A.1.1) ontologies (Section A.1.2). appendix
furthermore contains analysis effects adding threads benchmarks
CSPs ontologies (Section A.1.3) presents results simulation experiment
systematically varied different problem characteristics (Section A.1.4).
3.5.5 Discussion
Overall, results evaluations show parallelization approaches help improve performance diagnosis process, tested scenarios approaches
achieved speedups. cases FP faster LWP. However, depending
specifics given problem setting, using LWP advantageous situations,
e.g., time needed generate node small conflict generation time vary strongly. cases synchronization overhead needed
FP higher cost waiting threads finish. tested ontologies
Section A.1.2, case four tested scenarios.
Although FP average faster LWP significantly better sequential
HS-tree construction approach, tested scenarios efficiency still far
optimum 1. explained different effects. example, effect
false sharing happen memory two threads allocated block
(Bolosky & Scott, 1993). every access memory block synchronized although
two threads really share memory. Another possible effect called cache
851

fiJannach, Schmitz, & Shchekotykhin

contention (Chandra, Guo, Kim, & Solihin, 2005). threads work different computing
cores share memory, cache misses occur often depending
problem characteristics thus theoretical optimum cannot reached cases.

4. Parallel HS-Tree Construction Multiple Conflicts Per Node
sequential parallel version HS-tree algorithm, Theorem
Prover TP call corresponds invocation QXP. Whenever new node HS-tree
created, QXP searches exactly one new conflict case none already known
conflicts reused. strategy advantage call TP immediately
returns one conflict determined. turn means parallel
execution threads immediately see new conflict shared data structures
can, best case, reuse constructing new nodes.
disadvantage computing one conflict time QXP search
conflicts restarted invocation. recently proposed new conflict detection
technique called MergeXplain (MXP) (Shchekotykhin et al., 2015), capable
computing multiple conflicts one call. general idea MXP continue search
identification first conflict look additional conflicts remaining
constraints (or logical sentences) divide-and-conquer approach.
combined sequential HS-tree algorithm, effect tree construction time initially spent conflict detection construction continues
next node. exchange, chances conflict available reuse increase
next nodes. time, identification conflicts less timeintensive smaller sets constraints investigated due divide-and-conquer
approach MXP. experimental evaluation various benchmark problems shows
substantial performance improvements possible sequential HS-tree scenario
goal find leading diagnoses (Shchekotykhin et al., 2015).
section, explore benefits using MXP parallel HS-tree construction schemes proposed previous section. using MXP combination
multiple threads, implicit effect CPU processing power devoted conflict generation individual threads need time complete construction
new node. contrast sequential version, threads continue
work parallel.
next section, briefly review MXP algorithm report
results empirical evaluation benchmark datasets (Section 4.2).
4.1 Background QuickXplain MergeXplain
Algorithm 7 shows QXP conflict detection technique Junker (2004) applied
problem finding conflict diagnosis problem HS-tree construction.
QXP operates two sets constraints9 modified recursive calls.
background theory B comprises constraints considered anymore
part conflict current stage. beginning, set contains SD, Obs,
9. use term constraints original formulation. QXP independent
underlying reasoning technique, elements sets could general logical sentences well.

852

fiParallel Model-Based Diagnosis Multi-Core Computers

Algorithm 7: QuickXplain (QXP)
Input: diagnosis problem (SD, Comps, Obs), set visitedNodes elements
Output: set containing one minimal conflict CS C
1 B SD Obs {ab(c)|c P visitedNodes}; C abpcq|c P CompszvisitedNodesu;
2 isConsistent(B C) return conflict;
3 else C H return H;
4 return tc| abpcq P getConflictpB, B, Cqu;
5
6
7
8
9
10

function getConflict (B, D, C)
H ^ isConsistent(B) return H;
|C| 1 return C;
Split C disjoint, non-empty sets C1 C2
D2 getConflict (B C1 , C1 , C2 )
D1 getConflict (B D2 , D2 , C1 )
return D1 D2 ;

set nodes path current node HS-tree (visited nodes).
set C represents set constraints search conflict.
conflict C empty, algorithm immediately returns. Otherwise getConflict called, corresponds Junkers QXP method minor difference
getConflict require strict partial order set constraints C.
introduce variant QXP since cannot always assume prior fault information
available would allow us generate order.
rough idea QXP relax input set faulty constraints C partitioning
two sets C1 C2 . C1 conflict, algorithm continues partitioning C1
next recursive call. Otherwise, i.e., last partitioning split conflicts C
conflicts left C1 , algorithm extracts conflict sets C1
C2 . way, QXP finally identifies individual constraints inconsistent
remaining consistent set constraints background theory.
MXP builds ideas QXP computes multiple conflicts one call (if
exist). general procedure shown Algorithm 8. initial consistency checks,
method findConflicts called, returns tuple xC 1 , y, C 1 set
remaining consistent constraints set found conflicts. function recursively
splits set C constraints two halves. parts individually checked
consistency, allows us exclude larger consistent subsets C search process.
Besides potentially identified conflicts, calls findConflicts return two sets
constraints consistent (C11 C21 q. union two sets consistent,
look conflict within C11 C11 (and background theory) style QXP.
details found earlier work, results in-depth
experimental analysis reported (Shchekotykhin et al., 2015).
853

fiJannach, Schmitz, & Shchekotykhin

Algorithm 8: MergeXplain (MXP)
Input: diagnosis problem (SD, Comps, Obs), set visitedNodes elements
Output: , set minimal conflicts
1 B SD Obs {ab(c)|c P visitedNodes}; C abpcq|c P Compszu;
2
isConsistentpBq return solution;
3 isConsistentpB Cq return H;
4 x , findConflictspB, Cq
5 return tc| abpcq P };
6
7
8
9
10
11
12
13
14
15
16
17

function findConflicts (B, C) returns tuple xC 1 ,
isConsistent(B C) return xC, Hy;
|C| 1 return xH, tCuy;
Split C disjoint, non-empty sets C1 C2
xC11 , 1 findConflictspB, C1 q
xC21 , 2 findConflictspB, C2 q
1 2 ;
isConsistentpC11 C21 Bq
X getConflictpB C21 , C21 , C11 q
CS X getConflictpB X, X, C21 q
C11 C11 z tu P X
tCS u
return xC11 C21 , y;

4.2 Evaluation
section evaluate effects parallelizing diagnosis process use
MXP instead QXP calculate conflicts. (Shchekotykhin et al., 2015)
focus finding limited set (five) minimal diagnoses.
4.2.1 Implementation Variants
Using MXP parallel tree construction implicitly means time allocated
conflict generation using QXP proceeding next node.
analyze extent use MXP beneficial tested three different strategies
using MXP within full parallelization method FP.
Strategy (1): configuration simply called MXP instead QXP node
generation. Whenever MXP finds conflict, added global list known conflicts
(re-)used parallel threads. thread executes MXP node
generation continues next node MXP returns.
Strategy (2): strategy implements variant MXP slightly complex.
MXP finds first conflict, method immediately returns conflict
calling thread continue exploring additional nodes. time, new background thread started continues search additional conflicts, i.e., completes
work MXP call. addition, whenever MXP finds new conflict checks
already running node generation thread could reused conflict
854

fiParallel Model-Based Diagnosis Multi-Core Computers

available beforehand. case, search conflicts thread
stopped new conflict needed anymore. Strategy (2) could theory result
better CPU utilization, wait MXP call finish
continue building HS-tree. However, strategy leads higher synchronization
costs threads, e.g., notify working threads newly identified conflicts.
Strategy (3): Finally, parallelized conflict detection procedure itself. Whenever
set C constraints split two parts, first recursive call findConflicts
queued execution thread pool second call executed current thread.
calls finished, algorithm continues.
experimentally evaluated three configurations benchmark datasets.
results showed Strategy (2) lead measurable performance improvements
compared Strategy (1). additional communication costs seem higher
saved executing conflict detection process background
thread. Strategy (3) applied combination strategies, similar
experiments reported sequential HS-tree construction (Shchekotykhin et al.,
2015), additional performance gains could observed due higher synchronization
costs. limited effectiveness Strategies (2) (3) principle caused
nature benchmark problems strategies might advantageous
different problem settings. following, therefore report results
applying Strategy (1).
4.2.2 Results DXC Benchmark Problems
results DXC benchmarks shown Table 4. left side table shows
results using QXP right hand side shows results MXP.
speedups shown FP columns refer respective sequential algorithms using
conflict detection technique.
Using MXP instead QXP favorable using sequential HS-tree algorithm
reported work MXP (Shchekotykhin et al., 2015). reduction
running times ranges 17% 44%. speedups obtained FP using
MXP comparable FP using QXP range 1.33 2.10, i.e., lead
reduction running times 52%. speedups achieved addition
speedups sequential algorithm using MXP could already achieve QXP.
best results printed bold face Table 4 using MXP combination
FP consistently performs best. Overall, using FP combination MXP
38% 76% faster sequential algorithm using QXP. tests indicate
parallelization method works well conflict detection techniques
complex QXP and, case, return one conflict call.
addition, investing time conflict detection situations goal find
leading diagnoses proves promising strategy.
4.2.3 Additional Experiments Discussion
ran additional experiments constraint problems ontology debugging problems. detailed results provided Section A.2.
855

fiJannach, Schmitz, & Shchekotykhin

System
74182
74L85
74283
74181
c432

Seq.(QXP)
[ms]
12
15
49
699
3,714

FP(QXP)
S4
E4
1.26 0.32
1.36 0.34
1.58 0.39
1.99 0.55
1.77 0.44

Seq.(MXP)
[ms]
10
12
35
394
2,888

FP(MXP)
S4
E4
1.52 0.38
1.33 0.33
1.48 0.37
2.10 0.53
1.72 0.43

Table 4: Observed performance gains DXC benchmarks (QXP vs MXP).

Overall, results obtained embedding MXP sequential algorithm confirm
results Shchekotykhin et al. (2015) using MXP favorable QXP
small problem instances. However, observe allocating
time conflict detection MXP parallel processing setup help
speedup diagnosis process search number leading diagnoses. bestperforming configuration across experiments using Full Parallelization method
combination MXP setup led shortest computation times 20
25 tested scenarios (DX benchmarks, CSPs, ontologies).

5. Parallelized Depth-First Hybrid Search
application domains MBD, finding minimal diagnoses either required
simply possible computational complexity application-specific constraints allowed response times. settings, number algorithms
proposed years, example try find one minimal diagnoses
quickly find diagnoses certain cardinality (Metodi, Stern, Kalech, & Codish, 2014;
Feldman, Provan, & van Gemund, 2010b; de Kleer, 2011). cases, algorithms
principle extended used find diagnoses. are, however, optimized
task.
Instead analyzing various heuristic, stochastic approximative algorithms proposed literature individually respect potential parallelization,
analyze next section parallelization helpful already simple class
depth-first algorithms. context, investigate measurable improvements
achieved without using (domain-specific) heuristic. Finally, propose
hybrid strategy combines depth-first full-parallel HS-tree construction
conduct additional experiments assess strategy advantageous task
quickly finding one minimal diagnosis.
5.1 Parallel Random Depth-First Search
section introduces parallelized depth-first search algorithm quickly find one single
diagnosis. different threads explore tree partially randomized form, call
scheme Parallel Random Depth-First Search (PRDFS).
856

fiParallel Model-Based Diagnosis Multi-Core Computers

5.1.1 Algorithm Description
Algorithm 9 shows main program recursive implementation PRDFS. Similar
HS-tree algorithm, search diagnoses guided conflicts. time, however,
algorithm greedily searches depth-first manner. diagnosis found,
checked minimality diagnosis contain redundant elements.
minimization non-minimal diagnosis achieved calling method
Inv-QuickXplain (Shchekotykhin et al., 2014) simply trying remove one element
diagnosis checking resulting set still diagnosis.
Algorithm 9: diagnosePRDFS: Parallelized random depth-first search.
Input: diagnosis problem (SD, Comps, Obs),
number minDiags diagnoses find
Result: set diagnoses
1
2
3
4
5
6
7
8

H; conflicts H;
rootNode = getRootNode(SD, Comps, Obs);
1 nbThreads
threads.execute(expandPRDFS(rootNode, minDiags, , conflicts));
|| minDiags
wait();
threads.shutdownNow();
return ;

idea parallelization approach algorithm start multiple threads
root node. threads perform depth-first search parallel, pick
next conflict element explore randomized manner.
logic expanding node shown Algorithm 10. First, conflict
given node copied, changes set constraints affect
threads. Then, long enough diagnoses found, randomly chosen constraint
current nodes conflict used generate new node. expansion function
immediately called recursively new node, thereby implementing depth-first
strategy. identified diagnosis minimized added list known
diagnoses. Similar previous parallelization schemes, access global lists
known conflicts made thread-safe. specified number diagnoses
found threads finished, statement threads.shutdownNow() immediately stops
execution threads still running results returned. semantics
threads.execute(), wait(), notify() Section 3.
5.1.2 Example
Let us apply depth-first method example Section 2.2.1. Remember
two conflicts problem ttC1, C2, C3u, tC2, C4uu. partially expanded tree
problem seen Figure 2.
857

fiJannach, Schmitz, & Shchekotykhin

Algorithm 10: expandPRDFS: Parallel random depth-first node expansion.
Input: existingNode expand, number minDiags diagnoses find,
sets conflicts
1
2
3
4
5
6
7
8
9
10
11
12

13
14
15
16
17
18

C = existingNode.conflict.clone();
// Copy existingNodes conflict
|| minDiags ^|C| 0
Randomly pick constraint c C
C Cztcu;
newPathLabel = existingNode.pathLabel {c};
node = new Node(newPathlabel);
P conflicts : X newPathLabel H
node.conflict = S;
else
node.conflict = checkConsistency(SD, Comps, Obs, node.pathLabel);
node.conflict H
// New conflict found
conflicts = conflicts node.conflict;
// Recursive call implements depth-first search strategy
expandPRDFS(node, minDiags, , conflicts);
else
// Diagnosis found
diagnosis = minimize(node.pathLabel);
{diagnosis};
|| minDiags
notify();

example, first root node 1 created conflict tC1, C2, C3u
found. Next, random expansion would, example, pick conflict element C1
generate node 2 . node, conflict tC2, C4u computed tC1u
alone diagnosis. Since algorithm continues depth-first manner,
pick one label elements node 2 , e.g., C2 generate node 3 .
node, consistency check succeeds, conflict computed algorithm
found diagnosis. found diagnosis tC1, C2u is, however, minimal contains
redundant element C1. function Minimize, called end Algorithm
10, therefore remove redundant element obtain correct diagnosis tC2u.
used one thread example, one parallel threads would
probably started expanding root node using conflict element C2 (node 4 ).
case, single element diagnosis tC2u would identified already first
level. Adding parallel threads therefore help increase chances find one
hitting set faster different parts HS-tree explored parallel.
Instead random selection strategy, elaborate schemes pick next nodes
possible, e.g., based application-specific heuristics fault probabilities. One could
better synchronize search efforts different threads avoid duplicate calculations. conducted experiments algorithm variant used shared
858

fiParallel Model-Based Diagnosis Multi-Core Computers

1
{C1,C2, C3}
C1

2

4

C2

C3

{C2,C4}
3

C2

{C2,C4}

C4

C2

C4

Figure 2: Example HS-tree construction PRDFS.
synchronized list open nodes avoid two threads generate identical sub-tree
parallel. did, however, observe significantly better results method
shown Algorithm 9 probably due synchronization overhead.
5.1.3 Discussion Soundness Completeness
Every single thread depth-first algorithm systematically explores full search space
based conflicts returned Theorem Prover. Therefore, existing diagnoses
found parameter minDiags equal higher number actually
existing diagnoses.
Whenever (potentially non-minimal) diagnosis encountered, minimization process ensures minimal diagnoses stored list diagnoses. duplicate
addition diagnosis one threads last lines algorithm
prevented consider diagnoses equal contain set elements
set definition cannot contain element twice.
Overall, algorithm designed find one diagnoses quickly. computation minimal diagnoses possible algorithm highly inefficient, e.g., due
computational costs minimizing diagnoses.
5.2 Hybrid Strategy
Let us consider problem finding one minimal diagnosis. One easily imagine
choice best parallelization strategy, i.e., breadth-first depth-first,
depend specifics given problem setting actual size existing
diagnoses. single-element diagnosis exists, exploring first level HS-tree
breadth-first approach might best choice (see Figure 3(a)). depth-first strategy
might eventually include element non-minimal diagnosis, would
number additional calculations ensure minimality diagnosis.
If, contrast, smallest actually existing diagnosis cardinality of, e.g., five,
breadth-first scheme would fully explore first four HS-tree levels
finding five-element diagnosis. depth-first scheme, contrast, might quickly find
859

fiDiagnosis detected

Jannach, Schmitz, & Shchekotykhin

superset five-element diagnosis, e.g., six elements, needs six
additional consistency checks remove redundant element diagnosis (Figure
3(b)).
Diagnosis detected

Diagnosis detected

(a) Breadth-first strategy advantageous.

(b) Depth-first strategy advantageous.

Figure 3: Two problem configurations different search strategies favorable.
Since cannot know cardinality diagnoses advance, propose hybrid
strategy, half threads adopt depth-first strategy half uses
fully parallelized breadth-first regime. implement strategy, Algorithms 5
(FP) 9 (PRDFS) started parallel algorithm allowed use one
half defined share available threads. coordination
two algorithms done help shared data structures contain known
conflicts diagnoses. enough diagnoses (e.g. one) found, running threads
terminated
results returned.
Diagnosis detected
5.3 Evaluation
evaluated different strategies efficiently finding one minimal diagnosis
set benchmark problems used previous sections. experiment
setup identical except goal find one arbitrary diagnosis
included additional depth-first algorithms. order measure potential benefits
parallelizing depth-first search, ran benchmarks PRDFS 4 threads
1 thread, latter setup corresponds Random Depth First Search
(RDFS) without parallelization.
5.3.1 Results DXC Benchmark Problems
results DXC benchmark problems shown Table 5. Overall, tested
systems, approaches proposed paper help speed process
finding one single diagnosis. 88 100 evaluated scenarios least one
tested approaches statistically significantly faster sequential algorithm.
12 scenarios, finding one single diagnosis simple modest
significant speedups compared sequential algorithm obtained.
comparing individual parallel algorithms, following observations
made:
860

fiParallel Model-Based Diagnosis Multi-Core Computers

examples, PRDFS method faster breadth-first search
implemented FP technique. one benchmark system, PRDFS approach
even achieve speedup 11 compared sequential algorithm, corresponds runtime reduction 91%.
compared non-parallel RDFS, PRDFS could achieve higher speedups
tested systems except simple one, took 16 ms even
sequential algorithm. Overall, parallelization therefore advantageous
depth-first strategies.
performance Hybrid strategy lies performances components PRDFS FP 4 5 tested systems. systems, closer
faster one two. Adopting hybrid strategy therefore represent good
choice structure problem known advance, combines
ideas breadth-first depth-first search able quickly find diagnosis
problem settings unknown characteristics.

System
74182
74L85
74283
74181
c432

Seq.
[ms]
16
13
54
691
2,789

FP
S4
E4
1.37 0.34
1.34 0.33
1.67 0.42
2.08 0.52
1.89 0.47

RDFS
[ms]
9
11
25
74
1,435

PRDFS
S4
E4
0.84 0.21
1.06 0.27
1.22 0.31
1.23 0.31
2.96 0.74

Hybrid
S4
E4
0.84 0.21
1.05 0.26
1.06 0.26
1.04 0.26
1.81 0.45

Table 5: Observed performance gains DXC benchmarks finding one diagnosis.

5.3.2 Additional Experiments
detailed results obtained additional experiments provided
appendix. measurements include results CSPs (Section A.3.1) ontologies
(Section A.3.2), well results obtained systematically varying characteristics synthetic diagnosis problems (Section A.3.3). results indicate applying
depth-first parallelization strategy many cases advantageous CSP problems.
tests ontology problems simulation results however reveal depending problem structure cases breadth-first strategy
beneficial.
5.3.3 Discussion
experiments show parallelization depth-first search strategy (PRDFS)
help reduce computation times search one single diagnosis.
evaluated cases, PRDFS faster sequential counterpart.
cases, however, obtained improvements quite small virtually non-existent,
explained follows.
861

fiJannach, Schmitz, & Shchekotykhin

small scenarios, parallel depth-first search cannot significantly
faster non-parallel variant creation first node parallelized. Therefore major fraction tree construction process parallelized
all.
problem settings existing diagnoses size.
parallel depth-first searching threads therefore explore tree certain
depth none threads immediately return diagnosis much smaller
one determined another thread. E.g., given diagnosis problem,
diagnoses size 5, threads explore tree least level 5 find
diagnosis likely find diagnosis level. Therefore,
setting thread much faster others.
Finally, suspect problems cache contention correspondingly increased number cache misses, leads general performance deterioration
overhead caused multiple threads.
Overall, obtained speedups depend problem structure. hybrid
technique represents good compromise cases faster sequential
breadth first search approach tested scenarios (including CSPs, ontologies, synthetically created diagnosis problems presented Section A.3). Also,
efficient PRDFS cases breadth first search better
depth first search.

6. Parallel Direct CSP Encodings
alternative conflict-guided diagnosis approaches Reiters hitting set technique,
so-called direct encodings become popular research community recent
years (Feldman, Provan, de Kleer, Robert, & van Gemund, 2010a; Stern, Kalech, Feldman,
& Provan, 2012; Metodi et al., 2014; Mencia & Marques-Silva, 2014; Menca, Previti, &
Marques-Silva, 2015; Marques-Silva, Janota, Ignatiev, & Morgado, 2015).10
general idea direct encodings generate specific representation diagnosis
problem instance knowledge representation language use theorem
prover (e.g., SAT solver constraint engine) compute diagnoses directly.
methods support generation one multiple diagnoses calling theorem prover
once. Nica, Pill, Quaritsch, Wotawa (2013) made number experiments
compared conflict-directed search direct encodings showed
several problem settings, using direct encoding advantageous.
part paper, goal evaluate whether parallelization search
process case inside constraint engine help improve efficiency
diagnostic reasoning process. goal chapter therefore rather quantify
extent internal parallelization solver useful present new
algorithmic contribution.
10. direct encodings may always possible MBD settings discussed above.

862

fiParallel Model-Based Diagnosis Multi-Core Computers

6.1 Using Gecode Solver Direct Encodings
evaluation use Gecode constraint solver (Schulte, Lagerkvist, & Tack, 2016).
particular, use parallelization option Gecode test effects diagnosis
running times.11 chosen problem encoding similar one used Nica
Wotawa (2012). allows us make results comparable obtained
previous works. addition, provided encoding represented language
supported multiple solvers.
6.1.1 Example
Let us first show general idea small example. Consider following CSP12
consisting integer variables a1, a2, b1, b2, c1 constraints X1 , X2 , X3
defined as:
X1 : b1 a1 2, X2 : b2 a2 3, X3 : c1 b1 b2.
Let us assume programmer made mistake X3 actually c1
b1 ` b2. Given set expected observations (a test case) a1 1, a2 6, d1 20, MBD
applied considering constraints possibly faulty components.
direct encoding given CSP extended definition array AB
rab1 , ab2 , ab3 boolean (0/1) variables encode whether corresponding constraint
considered faulty not. constraints rewritten follows:
X11 : ab1 _ pb1 a1 2q,

X21 : ab2 _ pb2 a2 3q,

X31 : ab3 _ pc1 b1 b2q.

observations encoded equality constraints bind values
observed variables. example, constraints would be:
O1 : a1 1,

O2 : a2 6,

O3 : d1 20

order find diagnosis cardinality 1, additionally add constraint
ab1 ` ab2 ` ab3 1
let solver search solution. case, X3 would identified
possible diagnosis, i.e., ab3 would set 1 solver.
6.1.2 Parallelization Approach Gecode
using direct encoding, parallelization diagnosis process, shown
Reiters approach, cannot done embedded underlying search
procedure. However, modern constraint solvers, Gecode, or-tools many
solvers participated MiniZinc Challenge (Stuckey, Feydy, Schutt, Tack,
& Fischer, 2014), internally implement parallelization strategies better utilize todays
multi-core computer architectures (Michel, See, & Van Hentenryck, 2007; Chu, Schulte, &
11. state-of-the-art SAT solver capable parallelization could used analysis well.
12. Adapted earlier work (Jannach & Schmitz, 2014).

863

fiJannach, Schmitz, & Shchekotykhin

Stuckey, 2009). following, therefore evaluate set experiments,
solver-internal parallelization techniques help speed diagnosis process
direct encoding used.13
Gecode implements adaptive work stealing strategy (Chu et al., 2009) parallelization. general idea summarized follows. soon thread finishes
processing nodes search tree, steals nodes non-idle threads.
order decide thread work stolen, adaptive strategy uses
balancing heuristics estimate density solutions particular part
search tree. higher likelihood containing solution given branch,
work stolen branch.
6.2 Problem Encoding
evaluation use MiniZinc constraint modeling language. language
processed different solvers allows us model diagnosis problems CSPs
shown above.
6.2.1 Finding One Diagnosis
find single diagnosis given diagnosis problem (SD, Comps, Obs), generate
direct encoding MiniZinc follows.
(1) set components Comps generate array ab = [ab1 , . . . , abn ]
boolean variables.
(2) formula sdi P SD add constraint form
constraint abris _ psdi q;
observation oj P Obs model extended constraint
constraint oj ;
(3) Finally, add search goal output statement:
solve minimize sumpi 1..nqpbool2intpabrisqq;
output[show(ab)];
first statement last part (solve minimize), instructs solver search
(single) solution minimal number abnormal components, i.e., diagnosis
minimum cardinality. second statement (output) projects assignments set
abnormal variables, interested knowing components
faulty. assignments problem variables irrelevant.
6.2.2 Finding Diagnoses
problem encoding shown used quickly find one/all diagnoses minimum cardinality. is, however, sufficient scenarios goal find
diagnoses problem. therefore propose following sound complete algorithm
repeatedly modifies constraint problem systematically identify diagnoses.
13. contrast parallelization approaches presented previous sections, propose
new parallelization schemes rather rely existing ones implemented solver.

864

fiParallel Model-Based Diagnosis Multi-Core Computers

Technically, algorithm first searches diagnoses size 1 increases
desired cardinality diagnoses step step.

Algorithm 11: directDiag: Computation diagnoses using direct encoding.
Input: diagnosis problem (SD, Comps, Obs), maximum cardinality k
Result: set diagnoses
1
2
3
4
5
6
7
8
9
10

H; C H; card 1;
k |Comps| k |Comps|;
= generateModel (SD, Comps, Obs);
card k
= updateModel (M, card , C);
1 computeDiagnosespMq;
C C generateConstraintsp1 q;
1 ;
card card ` 1;
return ;

Procedure Algorithm 10 shows main components direct diagnosis method used
connection parallel constraint solver find diagnoses. algorithm starts
generation MiniZinc model (generateModel) described above.
difference search solutions given cardinality;
details encoding search goals given below.
iteration, algorithm modifies model updating cardinality
searched diagnoses furthermore adds new constraints corresponding already
found diagnoses (updateModel). updated model provided MiniZinc
interpreter (constraint solver), returns set solutions 1 . element P 1
corresponds diagnosis cardinality card .
order exclude supersets already found diagnoses 1 future iterations,
generate constraint P 1 formulas j l (generateConstraints):
constraint abrjs false _ _ abrls false;
constraints ensure already found diagnosis supersets cannot found
again. added model next iteration main loop. algorithm
continues diagnoses cardinalities k computed.
Changes Encoding calculate diagnoses given size, first instruct
solver search possible solutions provided constraint problem.14
addition, keeping steps (1) (2) Section 6.2.1 replace lines step (3)
14. achieved calling MiniZinc --all-solutions flag.

865

fiJannach, Schmitz, & Shchekotykhin

following statements:
constraint sumpi 1..nqpbool2intpabrisqq card ;
solve satisfy;
output[show(ab)];
first statement constrains number abnormal variables true
certain value, i.e., given cardinality card. second statement tells solver find
variable assignments satisfy constraints. last statement guarantees
solver considers solutions different different
respect assignments abnormal variables.
Soundness Completeness Algorithm 10 implements iterative deepening approach guarantees minimality diagnoses . Specifically, algorithm
constructs diagnoses order increasing cardinality limiting number ab
variables set true model. computation starts card 1,
means one ab variable true. Therefore, diagnoses cardinality 1,
i.e., comprising one abnormal variable, returned solver. found
diagnosis add constraint requires least one abnormal variables
diagnosis false. Therefore, neither diagnosis supersets found
subsequent iterations. constraints implement pruning rule HS-tree
algorithm. Finally, Algorithm 10 repeatedly increases cardinality parameter card
one continues next iteration. algorithm continues increment cardinality card becomes greater number components, corresponds
largest possible cardinality diagnosis. Consequently, given diagnosis problem
well sound complete constraint solver, Algorithm 10 returns diagnoses
problem.
6.3 Evaluation
evaluate speedups achieved parallelization direct encoding,
used first five systems DXC Synthetic Track tested scenarios
using Gecode solver without parallelization 2 4 parallel threads.
6.3.1 Results
evaluated two different configurations. setup (A), task find one single
diagnosis minimum cardinality. setup (B), iterative deepening procedure
Section 6.2.2 used find diagnoses size actual error.
results setup (A) shown Table 6. observe using parallel
constraint solver pays except tiny problems overall search time
less 200 ms. Furthermore, adding worker threads beneficial larger
problem sizes speedup 1.25 achieved complex test case
took 1.5 seconds solve.
pattern observed setup (B). detailed results listed Table
7. tiny problems, internal parallelization Gecode solver lead
performance improvements slightly slows whole process. soon
866

fiParallel Model-Based Diagnosis Multi-Core Computers

problems become complex, parallelization pays observe speedup
1.55 complex tested cases, corresponds runtime reduction
35%.
System
74182
74L85
74283
74181
c432

Direct Encoding
Abs. [ms]
S2
E2
S4
27 0.85 0.42 0.79
30 0.89 0.44 0.79
32 0.85 0.43 0.79
200 1.04 0.52 1.15
1,399 1.17 0.58 1.25

E4
0.20
0.20
0.20
0.29
0.31

Table 6: Observed performance gains DXC benchmarks finding one diagnosis
direct encoding using one (column Abs.), two, four threads.

System
74182
74L85
74283
74181
c432

Direct Encoding
Abs. [ms]
S2
E2
S4
136 0.84 0.42 0.80
60 0.83 0.41 0.77
158 0.93 0.47 0.92
1,670 1.19 0.59 1.33
229,869 1.22 0.61 1.55

E4
0.20
0.19
0.23
0.33
0.39

Table 7: Observed performance gains DXC benchmarks finding diagnoses
direct encoding using one (column Abs.), two, four threads.

6.3.2 Summary Remarks
Overall, experiments show parallelization beneficial direct encoding
diagnosis problem employed, particular problems non-trivial.
Comparing absolute running times Java implementation using open source
solver Choco optimized C++ implementation Gecode generally appropriate benchmark problems, Gecode works faster absolute scale.
Note, however, true cases. particular searching diagnoses size actual error complex system c432, even Reiters
non-parallelized Hitting Set algorithm much faster (85 seconds) using direct
encoding based iterative deepening (230 seconds). line observation
Nica et al. (2013) direct encodings always best choice searching
diagnoses.
first analysis run-time behavior Gecode shows larger problem is,
time spent solver iteration reconstruct internal structures,
lead measurable performance degradation. Note work relied
MiniZinc encoding diagnosis problem independent specifics
867

fiJannach, Schmitz, & Shchekotykhin

underlying constraint engine. implementation relies direct use API
specific CSP solver might help address certain performance issues. Nevertheless,
implementation must solver-specific allow us switch solvers easily
possible MiniZinc..

7. Relation Previous Works
section explore works related approach. First examine different
approaches computation diagnoses. focus general methods
parallelizing search algorithms.
7.1 Computation Diagnoses
Computing minimal hitting sets given set conflicts computationally hard problem
already discussed Section 2.2.2 several approaches proposed years
deal issue. approaches divided exhaustive approximate ones.
former perform sound complete search minimal diagnoses, whereas
latter improve computational efficiency exchange completeness, e.g., search
one small set diagnoses.
Approximate approaches example based stochastic search techniques
genetic algorithms (Li & Yunfei, 2002) greedy stochastic search (Feldman et al., 2010b).
greedy method proposed Feldman et al. (2010b), example, uses two-step
approach. first phase, random possibly non-minimal diagnosis determined
modified DPLL15 algorithm. algorithm always finds one random diagnosis
invocation due random selection propositional variables assignments.
second step, algorithm minimizes diagnosis returned DPLL technique
repeatedly applying random modifications. randomly chooses negative literal
denotes corresponding component faulty flips value positive.
obtained candidate well diagnosis problem provided DPLL algorithm
check whether candidate diagnosis not. case success obtained
diagnosis kept another random flip done. Otherwise, negative literal labeled
failure another negative literal randomly selected. algorithm stops
number failures greater predefined constant returns best diagnosis
found far.
approach Li Yunfei (2002) genetic algorithm takes number conflict
sets input generates set bit-vectors (chromosomes), every bit encodes
truth value atom ab(.) predicate. iteration algorithm applies
genetic operations, mutation, crossover, etc., obtain new chromosomes. Subsequently, obtained bit-vectors evaluated hitting set fitting function
eliminates bad candidates. algorithm stops predefined number iterations
returns best diagnosis.
general, approximate approaches directly comparable LWP
FP techniques, since incomplete guarantee minimality returned
15. Davis-Putnam-Logemann-Loveland.

868

fiParallel Model-Based Diagnosis Multi-Core Computers

hitting sets. goal contrast improve performance time
maintaining completeness soundness property.
Another way finding approximate solutions use heuristic search approaches.
example, Abreu van Gemund (2009) proposed Staccato algorithm applies
number heuristics pruning search space. aggressive pruning techniques
result better performance search algorithms. However, increase probability diagnoses found. approach aggressiveness
heuristics varied input parameters depending application goals.
recently, Cardoso Abreu (2013) suggested distributed version Staccato algorithm, based Map-Reduce scheme (Dean & Ghemawat, 2008)
therefore executed cluster servers. recent algorithms focus
efficient computation one minimum cardinality (minc) diagnoses (de Kleer,
2011). distributed approach minimum cardinality scenario, assumption (possibly incomplete) set conflicts already available input
beginning hitting-set construction process. application scenarios
address work, finding conflicts considered computationally
expensive part assume know minimal conflicts advance
compute on-demand done works (Felfernig, Friedrich, Jannach,
Stumptner, et al., 2000; Friedrich & Shchekotykhin, 2005; Williams & Ragno, 2007); see
work Pill, Quaritsch, Wotawa (2011) comparison conflict computation
approaches.
Exhaustive approaches often based HS-trees work Wotawa (2001a)
tree construction algorithm reduces number pruning steps presence nonminimal conflicts. Alternatively, one use methods compute diagnoses without
explicit computation conflict sets, i.e., solving problem dual minimal hitting sets
(Satoh & Uno, 2005). Stern et al. (2012), example, suggest method explores
duality conflicts diagnoses uses symmetry guide search.
approaches exploit structure underlying problem, hierarchical (Autio
& Reiter, 1998), tree-structured (Stumptner & Wotawa, 2001), distributed (Wotawa &
Pill, 2013). algorithms similar HS-tree algorithm and, consequently,
parallelized similar way. example, consider Set-Enumeration Tree
(SE-tree) algorithm (Rymon, 1994). algorithm, similarly Reiters HS-tree approach,
uses breadth-first search specific expansion procedure implements pruning
node selection strategies. LWP FP parallelization variant
used SE-tree algorithm comparable speedups expected.
7.2 Parallelization Search Algorithms
Historically, parallelization search algorithms approached three different ways
(Burns, Lemons, Ruml, & Zhou, 2010):
(i) Parallelization node processing: applying type parallelization, tree
expanded one single process, computation labels evaluation
heuristics done parallel.
869

fiJannach, Schmitz, & Shchekotykhin

(ii) Window-based processing: approach, sets nodes, called windows, processed different threads parallel. windows formed search algorithm
according predefined criteria.
(iii) Tree decomposition approaches: Here, different sub-trees search tree assigned different processes (Ferguson & Korf, 1988; Brungger, Marzetta, Fukuda, &
Nievergelt, 1999).
principle, three types parallelization applied form HS-tree
generation problem.
Applying strategy (i) MBD problem setting would mean parallelize process
conflict computation, e.g., parallel variant QXP MXP. tested
partially parallelized version MXP, however lead performance
improvements compared single-threaded approach evaluated benchmark
problems (Shchekotykhin et al., 2015). experiments Section 4 however show
using MXP combination LWP FP thereby implicitly allocating CPU time
computation multiple conflicts construction single node advantageous. well-known conflict prime implicate computation algorithms (Junker,
2004; Marques-Silva et al., 2013; Previti, Ignatiev, Morgado, & Marques-Silva, 2015)
contrast designed parallel execution computation multiple conflicts.
Strategy (ii) computing sets nodes (windows) parallel example applied
Powley Korf (1991). work windows determined different thresholds
heuristic function Iterative Deepening A*. Applying strategy HS-tree
construction problem would mean categorize nodes expanded according
criterion, e.g., probability finding diagnosis, allocate different
groups individual threads. absence window criteria, LWP FP could
seen extreme cases window size one, open node allocated one thread
processor. experiments done throughout paper suggest independent
parallelization strategy (LWP FP) number parallel threads (windows)
exceed number physically available computing threads obtain best performance.
Finally (iii), strategy exploring different sub-trees search different
processes can, example, applied context MBD techniques using Binary
HS-Tree (BHS) algorithms (Pill & Quaritsch, 2012). Given set conflict sets, BHS
method generates root node labels input set conflicts. Then, selects
one components occurring conflicts generates two child nodes,
left node labeled conflicts comprising selected component right
node remaining ones. Consequently, diagnosis tree decomposed two subtrees processed parallel. main problem kind parallelization
conflicts often known advance computed search.
Anglano Portinale (1996) suggested another approach ultimately
parallelized diagnosis problem based structural problem characteristics.
work, first map given diagnosis problem Behavioral Petri Net (BPN). Then,
obtained BPN manually partitioned subnets every subnet provided
different Parallel Virtual Machine (PVM) parallel processing. relationship
work LWP FP parallelization schemes limited approaches
require manual problem decomposition step.
870

fiParallel Model-Based Diagnosis Multi-Core Computers

general, parallelized versions domain-independent search algorithms
applied MBD settings. However, MBD problem specifics make
application algorithms difficult. instance, PRA method
variant HDA discussed work Burns et al. (2010) use mechanism minimize
memory requirements retracting parts search tree. forgotten parts
later re-generated required. MBD setting, generation nodes however
costly part, applicability HDA seems limited. Similarly,
duplicate detection algorithms PBNF (Burns et al., 2010) require existence
abstraction function partitions original search space blocks. general MBD
settings, however cannot assume function given.
order improve performance therefore avoid parallel generation
duplicate nodes different threads, plan investigate future work.
promising starting point research could work Phillips, Likhachev,
Koenig (2014). authors suggest variant A* algorithm generates
independent nodes order reduce costs node generation. Two nodes considered
independent generation one node lead change heuristic
function node. generation independent nodes done parallel
without risk repeated generation already known state. main difficulty
adopting algorithm MBD formulation admissible heuristic required
evaluate independence nodes arbitrary diagnosis problems. However,
specific problems encoded CSPs, Williams Ragno (2007) present
heuristic depends number unassigned variables particular search node.
Finally, parallelization used literature speed processing
large search trees fit memory. Korf Schultze (2005), instance, suggest
extension hash-based delayed duplicate detection algorithm allows search
algorithm continue search parts search tree written read
hard drive. methods theory used combination LWP FP
parallelization schemes case complex diagnosis problems. plan explore use
(externally) saved search states context MBD part future works.

8. Summary
work, propose systematically evaluate various parallelization strategies
Model-Based Diagnosis better exploit capabilities multi-core computers. show
parallelization advantageous various problem settings diagnosis approaches. approaches include conflict-driven search minimal
diagnoses different conflict detection techniques (heuristic) depth-first search
order quickly determine single diagnosis. main benefits parallelization
approaches applied independent underlying reasoning engine
variety diagnostic problems cannot efficiently represented SAT CSP
problems. addition HS-tree based parallelization approaches, show
parallelization beneficial settings direct problem encoding possible
modern parallel solver engines available.
evaluations furthermore shown speedups proposed parallelization methods vary according characteristics underlying diagnosis problem.
871

fiJannach, Schmitz, & Shchekotykhin

future work, plan explore techniques analyze characteristics order
predict advance parallelization method best suited find one single
diagnoses given problem.
Regarding algorithmic enhancements, furthermore plan investigate information underlying problem structure exploited achieve better distribution work parallel threads thereby avoid duplicate computations.
Furthermore, plan explore usage parallel solving schemes dual algorithms, i.e., algorithms compute diagnoses directly without computation minimal conflicts (Satoh & Uno, 2005; Felfernig, Schubert, & Zehentner, 2012; Stern et al.,
2012; Shchekotykhin et al., 2014).
presented algorithms designed use modern multi-core computers
today usually less dozen cores. results show additional performance improvements obtain proposed techniques become smaller
adding CPUs. part future works therefore plan develop
algorithms utilize specialized environments support massive parallelization.
context, future topic research could adaption parallel HS-tree
construction GPU architectures. GPUs, thousands computing cores,
proved superior tasks parallelized suitable way. Campeotto,
Palu, Dovier, Fioretto, Pontelli (2014) example used GPU parallelize constraint solver. However, yet fully clear whether tree construction techniques
efficiently parallelized GPU, many data structures shared across
nodes access synchronized.

Acknowledgements
paper significantly extends combines previous work (Jannach, Schmitz, &
Shchekotykhin, 2015; Shchekotykhin et al., 2015).
would thank Hakan Kjellerstrand Gecode team support.
thankful various helpful comments suggestions made anonymous
reviewers JAIR, DX14, DX15, AAAI15, IJCAI15.
work supported Carinthian Science Fund (KWF) contract KWF3520/26767/38701, Austrian Science Fund (FWF) German Research Foundation (DFG) contract numbers 2144 N-15 JA 2095/4-1 (Project Debugging
Spreadsheet Programs).

Appendix A.
appendix report results additional experiments made different
benchmark problems well results simulation experiments artificially created
problem instances.
Section A.1 contains results LWP FP parallelization schemes proposed
Section 3.
Section A.2 reports additional measurements regarding use MergeXplain
within parallel diagnosis process, see Section 4.
872

fiParallel Model-Based Diagnosis Multi-Core Computers

Section A.3 finally provides additional results parallelization depth-first
strategies discussed Section 5.
A.1 Additional Experiments LWP FP Parallelization Strategies
addition experiments DXC benchmark systems reported Section 3.5,
made additional experiments Constraint Satisfaction Problems, ontologies,
artificial Hitting Set construction problems. Furthermore, examined effects
increasing number available threads benchmarks CSPs ontologies.
A.1.1 Diagnosing Constraint Satisfaction Problems
Data Sets Procedure set experiments used number CSP instances
2008 CP solver competition (Lecoutre, Roussel, & van Dongen, 2008)
injected faults.16 diagnosis problems created follows. first generated
random solution using original CSP formulations. solution, randomly
picked 10% variables stored value assignments, served
test cases. stored variable assignments correspond expected outcomes
constraints formulated correctly. Next, manually inserted errors (mutations)
constraint problem formulations17 , e.g., changing less operator
operator, corresponds mutation-based approach software testing.
diagnosis task consists identifying possibly faulty constraints using partial
test cases. addition benchmark CSPs converted number spreadsheet
diagnosis problems (Jannach & Schmitz, 2014) CSPs test performance gains
realistic application settings.
Table 8 shows problem characteristics including number injected faults (#F),
number diagnoses (#D), average diagnosis size (|D|). general, selected
CSPs quite diverse respect size.
Results measurement results using 4 threads searching diagnoses given
Table 9. Improvements could achieved problem instances. exception
smallest problem mknap-1-5 speedups achieved LWP FP statistically
significant. problems, improvements strong (with running time
reduction 50%), whereas others improvements modest. average, FP
faster LWP. However, FP consistently better LWP often
differences small.
observed results indicate performance gains depend number factors
including size conflicts, computation times conflict detection,
problem structure itself. average FP faster LWP, characteristics
problem settings seem considerable impact speedups obtained
different parallelization strategies.
16. able sufficient number repetitions, picked instances comparably small running
times.
17. mutated CSPs downloaded http://ls13-www.cs.tu-dortmund.de/homepage/hp_
downloads/jair/csps.zip.

873

fiJannach, Schmitz, & Shchekotykhin

Scenario
c8
costasArray-13
domino-100-100
gracefulK3-P2
mknap-1-5
queens-8
hospital payment
profit calculation
course planning
preservation model
revenue calculation

#C
523
87
100
60
7
28
38
28
457
701
93

#V
239
88
100
15
39
8
75
140
583
803
154

#F
8
2
3
4
1
15
4
5
2
1
4

#D
4
2
81
117
2
9
120
42
3024
22
1452

|D|
6.25
2.5
2
2.94
1
10.9
3.8
4.24
2
1
3

Table 8: Characteristics selected problem settings.
Scenario
c8
costasArray-13
domino-100-100
gracefulK3-P2
mknap-1-5
queens-8
hospital payment
profit calculation
course planning
preservation model
revenue calculation

Seq.(QXP)
[ms]
559
4,013
1,386
1,965
314
141
12,660
197
22,130
167
778

LWP(QXP)
S4
E4
1.10 0.27
2.16
0.54
3.08 0.77
2.75
0.69
1.03 0.26
1.57
0.39
1.64
0.41
1.71
0.43
2.58
0.65
1.46
0.37
2.81 0.70

FP(QXP)
S4
E4
1.07 0.27
2.58 0.65
3.05 0.76
2.99 0.75
1.02 0.25
1.65 0.41
1.73 0.43
2.00 0.50
2.61 0.65
1.48 0.37
2.58 0.64

Table 9: Results CSP benchmarks spreadsheets searching diagnoses.
A.1.2 Diagnosing Ontologies
Data Sets Procedure recent works, MBD techniques used locate faults
description logic ontologies (Friedrich & Shchekotykhin, 2005; Shchekotykhin et al., 2012;
Shchekotykhin & Friedrich, 2010), represented Web Ontology Language
(OWL) (Grau, Horrocks, Motik, Parsia, Patel-Schneider, & Sattler, 2008). testing
ontology, developer similarly earlier approach (Felfernig, Friedrich,
Jannach, Stumptner, & Zanker, 2001) specify set positive negative test cases.
test cases sets logical sentences must entailed ontology (positive)
entailed ontology (negative). addition, ontology itself, set
logical sentences, consistent coherent (Baader, Calvanese, McGuinness,
Nardi, & Patel-Schneider, 2010). diagnosis (debugging) problem context arises,
one requirements fulfilled.
work Shchekotykhin et al. (2012), two interactive debugging approaches
tested set faulty real-world ontologies (Kalyanpur, Parsia, Horridge, & Sirin, 2007)
874

fiParallel Model-Based Diagnosis Multi-Core Computers

two randomly modified large real-world ontologies. use dataset evaluate
performance gains applying parallelization schemes ontology debugging problem. details different tested ontologies given Table 10.
characteristics problems described terms description logic (DL) used
formulate ontology, number axioms (#A), concepts (#C), properties (#P),
individuals (#I). terms first-order logic, concepts properties correspond
unary binary predicates, whereas individuals correspond constants. Every letter
DL name, ALCHF pDq , corresponds syntactic feature language. E.g.,
ALCHF pDq Attributive concept Language Complement, properties Hierarchy,
Functional properties Datatypes. underlying description logic reasoner, used
Pellet (Sirin, Parsia, Grau, Kalyanpur, & Katz, 2007). manipulation knowledge bases diagnosis process accomplished OWL-API (Horridge &
Bechhofer, 2011).
Note considered ontology debugging problem different diagnosis settings discussed far cannot efficiently encoded CSP SAT problem.
reason decision problems, checking consistency concept
satisfiability, ontologies given Table 10 ExpTime-complete (Baader et al.,
2010). set experiments therefore helps us explore benefits parallelization
problem settings computation conflict sets hard. Furthermore,
application parallelization approaches ontology debugging problem demonstrates generality methods, i.e., show methods applicable
wide range diagnosis problems require existence sound complete
consistency checking procedure.
Due generality Reiters general approach and, correspondingly, implementation diagnosis procedures, technical integration OWL-DL reasoner
software framework relatively simple. difference CSP-based problems
instead calling Chocos solve() method inside Theorem Prover, make call
Pellet reasoner via OWL-API check consistency ontology.
Ontology
Chemical
Koala
Sweet-JPL
miniTambis
University
Economy
Transportation
Cton
Opengalen-no-propchains

DL
ALCHF pDq
ALCON pDq
ALCHOF pDq
ALCN
SOIN pDq
ALCHpDq
ALCHpDq
SHF
ALCHIF pDq

#A
144
44
2,579
173
49
1,781
1,300
33,203
9,664

#C/#P/#I
48/20/0
21/5/6
1,537/121/50
183/44/0
30/12/4
339/53/482
445/93/183
17,033/43/0
4,713/924/0

#D
6
10
13
48
90
864
1,782
15
110

|D|
1.67
2.3
1
3
3.67
7.17
8
4
4.13

Table 10: Characteristics tested ontologies.
Results obtained results using thread pool size four shown Table
11. Again, every case parallelization advantageous compared sequential
version cases obtained speedups substantial. Regarding comparison
875

fiJannach, Schmitz, & Shchekotykhin

LWP FP variants, clear winner across test cases. LWP seems
advantageous problems complex respect
computation times. problems easily solved, FP sometimes slightly
better. clear correlation problem characteristics complexity
knowledge base terms size could identified within set benchmark
problems.
Ontology
Chemical
Koala
Sweet-JPL
miniTambis
University
Economy
Transportation
Cton
Opengalen-no-propchains

Seq.(QXP)
[ms]
237
16
7
135
85
355
1,696
203
11,044

LWP(QXP)
S4
E4
1.44 0.36
1.42 0.36
1.47
0.37
1.43
0.36
1.66
0.41
2.20 0.55
2.72 0.68
1.27 0.32
1.59
0.40

FP(QXP)
S4
E4
1.33 0.33
1.27 0.32
1.55 0.39
1.46 0.37
1.68 0.42
1.90 0.48
2.33 0.58
1.22 0.30
1.86 0.47

Table 11: Results ontologies searching diagnoses.

A.1.3 Adding Threads
Constraint Satisfaction Problems Table 12 shows results CSP benchmarks
spreadsheets using 12 threads. test utilizing 4 threads
advantageous one small scenario. However, 7 11 tested scenarios
computations 8 threads pay off. indicates
choosing right degree parallelization depend characteristics diagnosis
problem. diagnosis mknap-1-5 problem, example, cannot sped
parallelization contains one single conflict found root node.
contrast, graceful-K3-P2 problem benefits use 12 threads
could achieve speedup 4.21 scenario, corresponds runtime reduction
76%.
Ontologies results diagnosing ontologies 12 threads shown
Table 13. tested ontologies, comparably simple debugging cases, using
4 threads payed 3 7 cases. best results diagnosing
3 ontologies obtained 8 threads used. one ontology using
4 threads even slower sequential algorithm. indicates
effectiveness parallelization depends characteristics diagnosis problem
adding threads even slightly counterproductive.
A.1.4 Systematic Variation Problem Characteristics
Procedure better understand way problem characteristics influence
performance gains, used suite artificially created hitting set construction problems
876

fiParallel Model-Based Diagnosis Multi-Core Computers

Scenario

Seq.(QXP)
[ms] S4
E4
c8
444 1.05 0.26
costasArray-13
3,854 2.69 0.67
domino-100-100
213 2.04 0.51
gracefulK3-P2
1,743 3.03 0.76
mknap-1-5
4,141 1.00 0.25
queens-8
86 1.18 0.30
hospital payment
11,728 1.60 0.40
profit calculation
81 1.53 0.38
course planning
15,323 2.31 0.58
preservation model
127 1.34 0.34
revenue calculation
460 2.39 0.60

S8
1.07
2.88
2.30
4.12
1.00
1.30
1.70
1.59
2.85
1.41
2.17

FP(QXP)
E8
S10
E10
S12
E12
0.13 1.08 0.11 1.07 0.09
0.36 2.84 0.28 2.80 0.23
0.29 2.22 0.22 2.00 0.17
0.51 4.18 0.42 4.21 0.35
0.13 1.00 0.10 1.00 0.08
0.16 1.24 0.12 1.19 0.10
0.21 1.51 0.15 1.36 0.11
0.20 1.51 0.15 1.44 0.12
0.36 2.84 0.28 2.73 0.23
0.18 1.41 0.14 1.43 0.12
0.27 1.96 0.20 1.85 0.15

Table 12: Observed performance gains CSP benchmarks spreadsheets
server 12 hardware threads.
Ontology
Chemical
Koala
Sweet-JPL
miniTambis
University
Economy
Transportation

Seq.(QXP)
[ms]
246
21
6
134
88
352
1,448

S4
1.37
1.07
1.09
1.47
1.53
1.48
1.74

E4
0.34
0.27
0.27
0.37
0.38
0.37
0.43

S8
1.29
1.02
1.13
1.49
1.64
0.90
1.23

FP(QXP)
E8
S10
0.16 1.30
0.13 1.03
0.14 1.08
0.19 1.47
0.21 1.56
0.11 0.76
0.15 1.07

E10
0.13
0.10
0.11
0.15
0.16
0.08
0.11

S12
1.32
0.99
1.02
1.45
1.56
0.71
1.09

E12
0.11
0.08
0.09
0.12
0.13
0.06
0.09

Table 13: Observed performance gains ontologies server 12 hardware
threads.

following varying parameters: number components (#Cp), number conflicts
(#Cf), average size conflicts (|Cf|). Given parameters, used problem generator
produces set minimal conflicts desired characteristics. generator
first creates given number components uses components generate
requested number conflicts.
obtain realistic settings, generated conflicts equal size rather
varied according Gaussian distribution desired size mean. Similarly,
components equally likely part conflict used Gaussian
distribution assign component failure probabilities. probability distributions could
used generation process well, e.g., reflect specifics certain application
domain.
Since experiment conflicts known advance, conflict detection algorithm within consistency check return one suitable conflict upon request.
zero computation times unrealistic assumption conflict
877

fiJannach, Schmitz, & Shchekotykhin

detection actually costly part diagnosis process, varied assumed
conflict computation times analyze effect relative performance gains.
computation times simulated adding artificial active waiting times (Wt) inside
consistency check (shown ms Table 14). Note consistency check called
conflict reused current node; artificial waiting time applies
cases new conflict determined.
experiment repeated 100 times different variations problem setting
factor random effects. number diagnoses #D thus average well.
algorithms had, however, solve identical sets problems thus returned identical
sets diagnoses. limited search depth 4 experiments speed
benchmark process. average running times reported Table 14.
Results Varying Computation Times First, varied assumed conflict computation times quite small diagnosis problem using 4 parallel threads (Table 14).
first row assumed zero computation times shows long HS-tree construction
alone needs. improvements parallelization smaller case
overhead thread creation synchronization. However, soon add average
running time 10ms consistency check, parallelization approaches result
speedup 3, corresponds runtime reduction 67%. increasing
assumed computation time lead better relative improvements using pool
4 threads.
Results Varying Conflict Sizes average conflict size impacts breadth
HS-tree. Next, therefore varied average conflict size. hypothesis larger
conflicts correspondingly broader HS-trees better suited parallel processing.
results shown Table 14 confirm assumption. FP always slightly efficient
LWP. Average conflict sizes larger 9 did, however, lead strong additional
improvements using 4 threads.
Results Adding Threads larger conflicts, adding additional threads leads
improvements. Using 8 threads results improvements 7.27 (corresponding running time reduction 85%) larger conflict sizes
cases even higher levels parallelization achieved.
Results Adding Components Finally, varied problem complexity
adding components potentially faulty. Since left number
size conflicts unchanged, adding components led diagnoses included
different components. limited search depth 4 experiment, fewer
diagnoses found level search trees narrower. result,
relative performance gains lower fewer components (constraints).
Discussion simulation experiments demonstrate advantages parallelization.
tests, speedups LWP FP statistically significant. results
confirm performance gains depend different characteristics underlying
problem. additional gains waiting end search level worker
threads finished typically led small improvements.
Redundant calculations can, however, still occur, particular conflicts
new nodes determined parallel two worker threads return conflict.
878

fiParallel Model-Based Diagnosis Multi-Core Computers

#Cp, #Cf, #D Wt Seq.
LWP
|Cf|
[ms] [ms]
S4
E4
Varying computation times Wt
50, 5, 4
25
0
23
2.26 0.56
50, 5, 4
25
10
483
2.98 0.75
50, 5, 4
25 100 3,223 2.83 0.71
Varying conflict sizes
50, 5, 6
99
10 1,672 3.62 0.91
50, 5, 9
214
10 3,531 3.80 0.95
50, 5, 12
278
10 4,605 3.83 0.96
Varying numbers components
50, 10, 9
201
10 3,516 3.79 0.95
75, 10, 9
105
10 2,223 3.52 0.88
100, 10, 9
97
10 2,419 3.13 0.78
#Cp, #Cf, #D Wt Seq.
LWP
I|Cf|
[ms] [ms]
S8
E8
Adding threads (8 instead 4)
50, 5, 6
99
10 1,672 6.40 0.80
50, 5, 9
214
10 3,531 7.10 0.89
50, 5, 12
278
10 4,605 7.25 0.91

FP
S4

E4

2.58
3.10
2.83

0.64
0.77
0.71

3.68
3.83
3.88

0.92
0.96
0.97

3.77 0.94
3.29 0.82
3.45 0.86
FP
S8
E8
6.50
7.15
7.27

0.81
0.89
0.91

Table 14: Simulation results.
Although without parallelization computing resources would left unused
anyway, redundant calculations lead overall longer computation times small
problems thread synchronization overheads.
A.2 Additional Experiments Using MXP Conflict Detection
section report additional results obtained using MergeXplain
instead QuickXplain conflict detection strategy described Section 4.2.
different experiments made using set CSPs ontology debugging problems. Remember set experiments goal identify set leading
diagnoses.
A.2.1 Diagnosing Constraint Satisfaction Problems
Table 15 shows results searching five diagnoses using CSP spreadsheet
benchmarks. MXP could help reduce running times tested
scenarios except smaller ones. tiny scenario mknap-1-5, simple
sequential algorithm using QXP fastest alternative. scenarios,
however, parallelization pays faster sequentially expanding search
tree. best result could achieved scenario costasArray-13, FP using
MXP reduced running times 83% compared sequential algorithm using QXP,
879

fiJannach, Schmitz, & Shchekotykhin

corresponds speedup 6. results indicate FP works well
QXP MXP.
Scenario
c8
costasArray-13
domino-100-100
gracefulK3-P2
mknap-1-5
queens-8
hospital payment
profit calculation
course planning
preservation model
revenue calculation

Seq.(QXP)
[ms]
455
2,601
53
528
19
75
1,885
33
1,522
411
48

FP(QXP)
S4
E4
1.03 0.26
3.66 0.91
1.26 0.32
2.67 0.67
0.99 0.25
1.55 0.39
1.17 0.29
1.92 0.48
0.99 0.25
1.50 0.37
1.21 0.30

Seq.(MXP)
[ms]
251
2,128
50
419
21
63
1,426
40
1,188
430
42

FP(MXP)
S4
E4
1.06 0.26
4.92 1.23
1.43 0.36
2.48 0.62
1.01 0.25
1.67 0.42
1.28 0.32
1.86 0.46
1.42 0.35
1.50 0.37
1.48 0.37

Table 15: Results CSP benchmarks spreadsheets (QXP vs MXP).
Note one case (costasArray-13) see efficiency value larger one,
means obtained speedup super-linear. happen special situations
search limited number diagnoses use FP method (see
Section A.3.1). Assume generating one specific node takes particularly long, i.e.,
computation conflict set requires considerable amount time. case,
sequential algorithm stuck node time, FP method
continue generating nodes. nodes sufficient find (limited)
required number diagnoses, lead efficiency value greater
theoretical optimum.
A.2.2 Diagnosing Ontologies
results shown Table 16. Similar previous experiment, using MXP
combination FP pays cases except simple benchmark problems.
A.3 Additional Experiments Parallel Depth-First Search
section, report results additional experiments made assess
effects parallelizing depth-first search strategy described Section 5.3. set
experiments goal find one single minimal diagnosis. report results
obtained constraint problems ontology debugging problems discuss
findings simulation experiment systematically varied problem
characteristics.
A.3.1 Diagnosing Constraint Satisfaction Problems
results searching single diagnosis CSPs spreadsheets shown
Table 17. Again, parallelization generally shows good strategy speed
880

fiParallel Model-Based Diagnosis Multi-Core Computers

Ontology
Chemical
Koala
Sweet-JPL
miniTambis
University
Economy
Transportation
Cton
Opengalen-no-propchains

Seq.(QXP)
[ms]
187
15
5
68
33
19
71
174
2,145

FP(QXP)
S4
E4
2.10 0.53
1.49 0.37
1.27 0.32
1.04 0.26
1.05 0.26
1.10 0.27
1.08 0.27
1.36 0.34
1.22 0.30

Seq.(MXP)
[ms]
144
13
4
56
26
14
53
154
1,748

FP(MXP)
S4
E4
1.94 0.48
1.27 0.32
1.05 0.26
1.08 0.27
1.02 0.26
1.00 0.25
1.10 0.27
1.33 0.33
1.35 0.34

Table 16: Results Ontologies (QXP vs MXP).
diagnosis process. measured speedups except speedup RDFS first scenario
c8 statistically significant. specific problem setting, FP strategy
measurable effect strategies even modest performance deterioration
observed compared Reiters sequential algorithm. reason lies resulting
structure HS-tree narrow conflicts size one.
following detailed observations made comparing algorithms.
tested CSPs, FP advantageous compared RDFS PRDFS.
spreadsheets, contrast, RDFS PRDFS better breadth-first
approach FP three five cases.
comparing RDFS PRDFS, observe parallelization
advantageous depth-first strategies.
Again, however, improvements seem depend underlying problem structure. case hospital payment scenario, speedup PRDFS high
3.1 compared sequential algorithm, corresponds runtime reduction
67%. parallel strategy is, however, consistently better
test cases.
performance Hybrid method lies performances
two components many, all, tested scenarios.

A.3.2 Diagnosing Ontologies
Next, evaluated search one diagnosis real-world ontologies (Table 18).
tested scenarios, applying depth-first strategy often pay compared
breadth-first methods. reason tested examples ontology debugging domain many cases single-element diagnoses exist, quickly
detected breadth-first strategy. Furthermore absolute running times often comparably small. Parallelizing depth-first strategy leads significant speedups
cases.
881

fiJannach, Schmitz, & Shchekotykhin

Scenario
c8
costasArray-13
domino-100-100
gracefulK3-P2
mknap-1-5
queens-8
hospital payment
profit calculation
course planning
preservation model
revenue calculation

Seq.
[ms]
462
1,996
57
372
166
72
263
99
3,072
182
152

FP
S4
E4
1.09 0.27
4.78 1.19
1.22 0.30
2.86 0.71
2.18 0.55
1.38 0.34
1.83 0.46
1.67 0.42
1.11 0.28
1.78 0.44
1.11 0.28

RDFS
[ms]
454
3,729
45
305
114
55
182
70
2,496
104
121

PRDFS
S4
E4
0.89 0.22
3.42 0.85
1.17 0.29
2.01 0.50
1.02 0.26
1.02 0.26
2.14 0.54
1.15 0.29
0.90 0.23
0.99 0.25
0.92 0.23

Hybrid
S4
E4
0.92 0.23
5.90 1.47
1.05 0.26
1.89 0.47
1.35 0.33
0.95 0.24
1.72 0.43
1.10 0.28
0.87 0.22
0.95 0.24
0.90 0.22

Table 17: Results CSP benchmarks spreadsheets finding one diagnosis.
Ontology
Chemical
Koala
Sweet-JPL
miniTambis
University
Economy
Transportation

Seq.
[ms]
73
10
3
58
29
17
65

FP
S4
E4
2.18 0.54
2.20 0.55
0.92 0.23
0.95 0.24
1.06 0.27
1.10 0.27
1.03 0.26

RDFS
[ms]
57
9
4
62
30
18
61

PRDFS
S4
E4
1.62 0.41
1.93 0.48
0.97 0.24
0.92 0.23
1.03 0.26
1.16 0.29
1.03 0.26

Hybrid
S4
E4
1.47 0.37
1.39 0.35
0.92 0.23
0.93 0.23
1.03 0.26
1.10 0.27
0.98 0.24

Table 18: Observed performance gains ontologies finding one diagnosis.
A.3.3 Systematic Variation Problem Characteristics
Table 19 finally shows simulation results searching one single diagnosis.
experiment used uniform probability distribution selecting components
conflicts obtain complex diagnosis problems. results summarized
follows.
FP expected better sequential version HS-tree algorithm
tested configurations.
small problems contain comparably small conflicts,
depth-first strategy work well. parallel sequential versions
even slower Reiters original proposal, except cases zero conflict
computation times assumed. indicates costs hitting set minimization high.
larger problem instances, relying depth-first strategy find one single
diagnosis advantageous better FP. additional test even
882

fiParallel Model-Based Diagnosis Multi-Core Computers

#Cp, #Cf, I|D| Wt
Seq.
I|Cf|
[ms]
[ms]
Varying computation times Wt
50, 5, 4
3.40
0
11
50, 5, 4
3.40
10
89
50, 5, 4
3.40 100
572
Varying conflict sizes
50, 5, 6
2.86
10
90
50, 5, 9
2.36
10
86
50, 5, 12
2.11
10
83
Varying numbers components
50, 10, 9
3.47
10
229
75, 10, 9
3.97
10
570
100, 10, 9 4.34
10
1,467
conflicts
100, 12, 9
5.00
10 26,870

FP

RDFS
[ms]

PRDFS
S4
E4

Hybrid
S4
E4

S4

E4

2.61
1.50
1.50

0.65
0.37
0.37

2
155
1,052

1.01
1.28
1.30

0.25
0.32
0.33

0.85
2.24
2.26

0.21
0.56
0.56

1.57
1.55
1.61

0.39
0.39
0.40

143
138
124

1.26
1.34
1.23

0.31
0.33
0.31

2.12
2.04
1.95

0.53
0.51
0.49

2.36
3.09
2.37

0.59
0.77
0.59

202
228
240

1.35
1.37
1.34

0.34
0.34
0.33

1.65
1.42
1.26

0.41
0.36
0.31

1.28

0.32

280

1.39

0.35

1.24

0.31

Table 19: Simulation results finding one diagnosis.
larger problem shown last line Table 19 reveals potential depth-first
search approach.
problems larger, PRDFS help obtain runtime
improvements compared RDFS.
Hybrid method works well single case zero computation times.
Again, represents good choice problem structure known.
Overall, simulation experiments show speedups achieved
different methods depend underlying problem structure search
one single diagnosis.

References
Abreu, R., & van Gemund, A. J. C. (2009). Low-Cost Approximate Minimal Hitting Set
Algorithm Application Model-Based Diagnosis. SARA09, pp. 29.
Anglano, C., & Portinale, L. (1996). Parallel model-based diagnosis using PVM. EuroPVM96, pp. 331334.
Autio, K., & Reiter, R. (1998). Structural Abstraction Model-Based Diagnosis.
ECAI98, pp. 269273.
Baader, F., Calvanese, D., McGuinness, D., Nardi, D., & Patel-Schneider, P. (2010).
Description Logic Handbook: Theory, Implementation Applications, Vol. 32.
Bolosky, W. J., & Scott, M. L. (1993). False Sharing Effect Shared Memory
Performance. SEDMS93, pp. 5771.
883

fiJannach, Schmitz, & Shchekotykhin

Brungger, A., Marzetta, A., Fukuda, K., & Nievergelt, J. (1999). parallel search bench
ZRAM applications. Annals Operations Research, 90 (0), 4563.
Buchanan, B., & Shortliffe, E. (Eds.). (1984). Rule-based Expert Systems: MYCIN Experiments Stanford Heuristic Programming Project. Addison-Wesley, Reading,
MA.
Burns, E., Lemons, S., Ruml, W., & Zhou, R. (2010). Best-First Heuristic Search
Multicore Machines. Journal Artificial Intelligence Research, 39, 689743.
Campeotto, F., Palu, A. D., Dovier, A., Fioretto, F., & Pontelli, E. (2014). Exploring
Use GPUs Constraint Solving. PADL14, pp. 152167.
Cardoso, N., & Abreu, R. (2013). Distributed Approach Diagnosis Candidate Generation. EPIA13, pp. 175186.
Chandra, D., Guo, F., Kim, S., & Solihin, Y. (2005). Predicting Inter-Thread Cache Contention Chip Multi-Processor Architecture. HPCA11, pp. 340351.
Chu, G., Schulte, C., & Stuckey, P. J. (2009). Confidence-Based Work Stealing Parallel
Constraint Programming. CP09, pp. 226241.
Console, L., Friedrich, G., & Dupre, D. T. (1993). Model-Based Diagnosis Meets Error
Diagnosis Logic Programs. IJCAI93, pp. 14941501.
de Kleer, J. (2011). Hitting set algorithms model-based diagnosis. DX11, pp. 100105.
Dean, J., & Ghemawat, S. (2008). MapReduce: Simplified Data Processing Large Clusters. Communications ACM, 51 (1), 107113.
Dijkstra, E. W. (1968). Structure THE-Multiprogramming System. Communications ACM, 11 (5), 341346.
Eiter, T., & Gottlob, G. (1995). Complexity Logic-Based Abduction. Journal
ACM, 42 (1), 342.
Feldman, A., Provan, G., de Kleer, J., Robert, S., & van Gemund, A. (2010a). Solving
model-based diagnosis problems max-sat solvers vice versa. DX10, pp.
185192.
Feldman, A., Provan, G., & van Gemund, A. (2010b). Approximate Model-Based Diagnosis
Using Greedy Stochastic Search. Journal Artifcial Intelligence Research, 38, 371
413.
Felfernig, A., Friedrich, G., Isak, K., Shchekotykhin, K. M., Teppan, E., & Jannach, D.
(2009). Automated debugging recommender user interface descriptions. Applied
Intelligence, 31 (1), 114.
Felfernig, A., Friedrich, G., Jannach, D., & Stumptner, M. (2004). Consistency-based diagnosis configuration knowledge bases. Artificial Intelligence, 152 (2), 213234.
Felfernig, A., Friedrich, G., Jannach, D., Stumptner, M., & Zanker, M. (2001). Hierarchical
diagnosis large configurator knowledge bases. KI01, pp. 185197.
Felfernig, A., Schubert, M., & Zehentner, C. (2012). efficient diagnosis algorithm
inconsistent constraint sets. Artificial Intelligence Engineering Design, Analysis
Manufacturing, 26 (1), 5362.
884

fiParallel Model-Based Diagnosis Multi-Core Computers

Felfernig, A., Friedrich, G., Jannach, D., Stumptner, M., et al. (2000). Consistency-based
diagnosis configuration knowledge bases. ECAI00, pp. 146150.
Ferguson, C., & Korf, R. E. (1988). Distributed tree search application alpha-beta
pruning. AAAI88, pp. 128132.
Friedrich, G., & Shchekotykhin, K. M. (2005). General Diagnosis Method Ontologies.
ISWC05, pp. 232246.
Friedrich, G., Stumptner, M., & Wotawa, F. (1999). Model-Based Diagnosis Hardware
Designs. Artificial Intelligence, 111 (1-2), 339.
Friedrich, G., Fugini, M., Mussi, E., Pernici, B., & Tagni, G. (2010). Exception handling
repair service-based processes. IEEE Transactions Software Engineering, 36 (2),
198215.
Friedrich, G., & Shchekotykhin, K. (2005). General Diagnosis Method Ontologies.
ISWC05, pp. 232246.
Garey, M. R., & Johnson, D. S. (1979). Computers Intractability: Guide Theory
NP-Completeness. W. H. Freeman & Co.
Grau, B. C., Horrocks, I., Motik, B., Parsia, B., Patel-Schneider, P., & Sattler, U. (2008).
OWL 2: next step OWL. Web Semantics: Science, Services Agents
World Wide Web, 6 (4), 309322.
Greiner, R., Smith, B. A., & Wilkerson, R. W. (1989). Correction Algorithm
Reiters Theory Diagnosis. Artificial Intelligence, 41 (1), 7988.
Horridge, M., & Bechhofer, S. (2011). OWL API: Java API OWL Ontologies.
Semantic Web Journal, 2 (1), 1121.
Jannach, D., & Schmitz, T. (2014). Model-based diagnosis spreadsheet programs:
constraint-based debugging approach. Automated Software Engineering, February
2014 (published online).
Jannach, D., Schmitz, T., & Shchekotykhin, K. (2015). Parallelized Hitting Set Computation
Model-Based Diagnosis. AAAI15, pp. 15031510.
Junker, U. (2004). QUICKXPLAIN: Preferred Explanations Relaxations OverConstrained Problems. AAAI04, pp. 167172.
Kalyanpur, A., Parsia, B., Horridge, M., & Sirin, E. (2007). Finding justifications
owl dl entailments. Semantic Web, Vol. 4825 Lecture Notes Computer
Science, pp. 267280.
Korf, R. E., & Schultze, P. (2005). Large-scale parallel breadth-first search. AAAI05,
pp. 13801385.
Kurtoglu, T., & Feldman, A. (2011). Third International Diagnostic Competition (DXC
11). https://sites.google.com/site/dxcompetition2011. Accessed: 2016-03-15.
Lecoutre, C., Roussel, O., & van Dongen, M. R. C. (2008). CPAI08 competition. http:
//www.cril.univ-artois.fr/CPAI08/. Accessed: 2016-03-15.
Li, L., & Yunfei, J. (2002). Computing Minimal Hitting Sets Genetic Algorithm.
DX02, pp. 14.
885

fiJannach, Schmitz, & Shchekotykhin

Marques-Silva, J., Janota, M., Ignatiev, A., & Morgado, A. (2015). Efficient Model Based
Diagnosis Maximum Satisfiability. IJCAI15, pp. 19661972.
Marques-Silva, J., Janota, M., & Belov, A. (2013). Minimal Sets Monotone Predicates
Boolean Formulae. Computer Aided Verification, pp. 592607.
Mateis, C., Stumptner, M., Wieland, D., & Wotawa, F. (2000). Model-Based Debugging
Java Programs. AADEBUG00.
Mencia, C., & Marques-Silva, J. (2014). Efficient Relaxations Over-constrained CSPs.
ICTAI14, pp. 725732.
Menca, C., Previti, A., & Marques-Silva, J. (2015). Literal-based MCS extraction.
IJCAI15, pp. 19731979.
Metodi, A., Stern, R., Kalech, M., & Codish, M. (2014). novel sat-based approach
model based diagnosis. Journal Artificial Intelligence Research, 51, 377411.
Michel, L., See, A., & Van Hentenryck, P. (2007). Parallelizing constraint programs transparently. CP07, pp. 514528.
Nica, I., Pill, I., Quaritsch, T., & Wotawa, F. (2013). route success: performance
comparison diagnosis algorithms. IJCAI13, pp. 10391045.
Nica, I., & Wotawa, F. (2012). ConDiag - computing minimal diagnoses using constraint
solver. DX12, pp. 185191.
Phillips, M., Likhachev, M., & Koenig, S. (2014). PA*SE: Parallel A* Slow Expansions.
ICAPS14.
Pill, I., Quaritsch, T., & Wotawa, F. (2011). conflicts diagnoses: empirical
evaluation minimal hitting set algorithms. DX11, pp. 203211.
Pill, I., & Quaritsch, T. (2012). Optimizations Boolean Approach Computing
Minimal Hitting Sets. ECAI12, pp. 648653.
Powley, C., & Korf, R. E. (1991). Single-agent parallel window search. IEEE Transactions
Pattern Analysis Machine Intelligence, 13 (5), 466477.
Previti, A., Ignatiev, A., Morgado, A., & Marques-Silva, J. (2015). Prime Compilation
Non-Clausal Formulae. IJCAI15, pp. 19801987.
Prudhomme, C., Fages, J.-G., & Lorca, X. (2015). Choco Documentation. TASC, INRIA
Rennes, LINA CNRS UMR 6241, COSLING S.A.S. http://www.choco-solver.org.
Reiter, R. (1987). Theory Diagnosis First Principles. Artificial Intelligence, 32 (1),
5795.
Rymon, R. (1994). SE-tree-based prime implicant generation algorithm. Annals
Mathematics Artificial Intelligence, 11 (1-4), 351365.
Satoh, K., & Uno, T. (2005). Enumerating Minimally Revised Specifications Using Dualization. JSAI05, pp. 182189.
Schulte, C., Lagerkvist, M., & Tack, G. (2016). GECODE - open, free, efficient constraint
solving toolkit. http://www.gecode.org. Accessed: 2016-03-15.
886

fiParallel Model-Based Diagnosis Multi-Core Computers

Shchekotykhin, K., Friedrich, G., Fleiss, P., & Rodler, P. (2012). Interactive ontology debugging: Two query strategies efficient fault localization. Journal Web Semantics,
1213, 88103.
Shchekotykhin, K. M., & Friedrich, G. (2010). Query strategy sequential ontology
debugging. ISWC10, pp. 696712.
Shchekotykhin, K., Jannach, D., & Schmitz, T. (2015). MergeXplain: Fast Computation
Multiple Conflicts Diagnosis. IJCAI15, pp. 32213228.
Shchekotykhin, K. M., Friedrich, G., Rodler, P., & Fleiss, P. (2014). Sequential diagnosis
high cardinality faults knowledge-bases direct diagnosis generation. ECAI14,
pp. 813818.
Sirin, E., Parsia, B., Grau, B. C., Kalyanpur, A., & Katz, Y. (2007). Pellet: Practical
OWL-DL Reasoner. Web Semantics: Science, Services Agents World Wide
Web, 5 (2), 51 53.
Stern, R., Kalech, M., Feldman, A., & Provan, G. (2012). Exploring Duality ConflictDirected Model-Based Diagnosis. AAAI12, pp. 828834.
Stuckey, P. J., Feydy, T., Schutt, A., Tack, G., & Fischer, J. (2014). MiniZinc Challenge
2008-2013. AI Magazine, 35 (2), 5560.
Stumptner, M., & Wotawa, F. (1999). Debugging functional programs. IJCAI99, pp.
10741079.
Stumptner, M., & Wotawa, F. (2001). Diagnosing Tree-Structured Systems. Artificial
Intelligence, 127 (1), 129.
White, J., Benavides, D., Schmidt, D. C., Trinidad, P., Dougherty, B., & Cortes, A. R.
(2010). Automated diagnosis feature model configurations. Journal Systems
Software, 83 (7), 10941107.
Williams, B. C., & Ragno, R. J. (2007). Conflict-directed A* role model-based
embedded systems. Discrete Applied Mathematics, 155 (12), 15621595.
Wotawa, F. (2001a). variant Reiters hitting-set algorithm. Information Processing
Letters, 79 (1), 4551.
Wotawa, F. (2001b). Debugging Hardware Designs Using Value-Based Model. Applied
Intelligence, 16 (1), 7192.
Wotawa, F., & Pill, I. (2013). classification modeling issues distributed modelbased diagnosis. AI Communications, 26 (1), 133143.

887


