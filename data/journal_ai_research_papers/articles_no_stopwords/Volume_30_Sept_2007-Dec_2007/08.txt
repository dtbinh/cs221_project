Journal Artificial Intelligence Research 30 (2007) 321359

Submitted 11/06; published 10/07

New Inference Rules Max-SAT
Chu Min Li

chu-min.li@u-picardie.fr

LaRIA, Universite de Picardie Jules Verne
33 Rue St. Leu, 80039 Amiens Cedex 01, France

Felip Manya

felip@iiia.csic.es

IIIA, Artificial Intelligence Research Institute
CSIC, Spanish National Research Council
Campus UAB, 08193 Bellaterra, Spain

Jordi Planes

jplanes@diei.udl.es

Computer Science Department, Universitat de Lleida
Jaume II, 69, 25001 Lleida, Spain

Abstract
Exact Max-SAT solvers, compared SAT solvers, apply little inference
node proof tree. Commonly used SAT inference rules unit propagation produce
simplified formula preserves satisfiability but, unfortunately, solving Max-SAT
problem simplified formula equivalent solving original formula.
paper, define number original inference rules that, besides applied
efficiently, transform Max-SAT instances equivalent Max-SAT instances
easier solve. soundness rules, seen refinements unit resolution
adapted Max-SAT, proved novel simple way via integer programming
transformation. aim finding powerful inference rules practice,
developed new Max-SAT solver, called MaxSatz, incorporates rules,
performed experimental investigation. results provide empirical evidence
MaxSatz competitive, least, random Max-2SAT, random Max-3SAT, MaxCut, Graph 3-coloring instances, well benchmarks Max-SAT
Evaluation 2006.

1. Introduction
recent years growing interest developing fast exact Max-SAT
solvers (Alber, Gramm, & Niedermeier, 2001; Alsinet, Manya, & Planes, 2003b, 2005;
de Givry, Larrosa, Meseguer, & Schiex, 2003; Li, Manya, & Planes, 2005; Xing & Zhang,
2004; Zhang, Shen, & Manya, 2003) due potential solve over-constrained NPhard problems encoded formalism Boolean CNF formulas. Nowadays, Max-SAT
solvers able solve lot instances beyond reach solvers developed
five years ago. Nevertheless, yet considerable gap difficulty
instances solved current SAT solvers instances solved best performing
Max-SAT solvers.
motivation behind work bridge gap complete SAT solvers
exact Max-SAT solvers investigating technology previously developed
SAT (Goldberg & Novikov, 2001; Li, 1999; Marques-Silva & Sakallah, 1999; Zhang, 1997;
Zhang, Madigan, Moskewicz, & Malik, 2001) extended incorporated Maxc
2007
AI Access Foundation. rights reserved.

fiLi, Manya & Planes

SAT. precisely, focus attention branch bound Max-SAT solvers based
Davis-Putnam-Logemann-Loveland (DPLL) procedure (Davis, Logemann, & Loveland,
1962; Davis & Putnam, 1960).
One main differences SAT solvers Max-SAT solvers former
make intensive use unit propagation node proof tree. Unit propagation,
highly powerful inference rule, transforms SAT instance satisfiability
equivalent SAT instance easier solve. Unfortunately, solving Max-SAT
problem is, general, equivalent solving ; i.e., number unsatisfied
clauses every truth assignment. example, apply
unit propagation CNF formula = {x1 , x1 x2 , x1 x2 , x1 x3 , x1 x3 },
obtain = {2, 2}, equivalent interpretation satisfying
x1 unsatisfies one clause two clauses . Therefore, want compute
optimal solution, cannot apply unit propagation SAT solvers.
proposed previous work (Li et al., 2005) use unit propagation compute
lower bounds branch bound Max-SAT solvers instead using unit propagation
simplify CNF formulas. approach, detect disjoint inconsistent subsets clauses
via unit propagation. turns number disjoint inconsistent subsets detected
underestimation number clauses become unsatisfied current
partial assignment extended complete assignment. underestimation plus
number clauses unsatisfied current partial assignment provides good performing
lower bound, captures lower bounds based inconsistency counts
state-of-the-art Max-SAT solvers implement (Alsinet, Manya, & Planes, 2003a; Alsinet
et al., 2003b; Borchers & Furman, 1999; Wallace & Freuder, 1996; Zhang et al., 2003),
well improved lower bounds (Alsinet, Manya, & Planes, 2004; Alsinet et al., 2005;
Xing & Zhang, 2004, 2005).
one hand, number disjoint inconsistent subsets detected conservative underestimation lower bound, since every inconsistent subset increases
lower bound one independently number clauses unsatisfied optimal
assignment. However, optimal assignment violate one clause inconsistent subset. Therefore, able improve lower bound based counting
number disjoint inconsistent subsets clauses.
hand, despite fact good quality lower bounds prune large parts
search space accelerate dramatically search optimal solution, whenever
lower bound reach best solution found far (upper bound), solver
continues exploring search space current node. search, solvers
often redetect inconsistencies computing lower bound different nodes.
Basically, problem lower bound computation methods simplify
CNF formula way unsatisfied clauses become explicit. Lower bounds
pruning technique.
overcome two problems, define set sound inference rules
transform Max-SAT instance Max-SAT instance easier solve.
Max-SAT, inference rule sound whenever equivalent.
Let us see example inference rule: Given Max-SAT instance contains
three clauses form l1 , l2 , l1 l2 , l1 , l2 literals, replace CNF
322

fiNew Inference Rules Max-SAT

formula
= ( {l1 , l2 , l1 l2 }) {2, l1 l2 }.
Note rule detects contradiction l1 , l2 , l1 l2 and, therefore, replaces
clauses empty clause. addition, rule adds clause l1 l2 ensure
equivalence . assignment containing either l1 = 0, l2 = 1,
l1 = 1, l2 = 0, l1 = 1, l2 = 1, number unsatisfied clauses {l1 , l2 , l1 l2 } 1,
assignment containing l1 = 0, l2 = 0, number unsatisfied clauses 2.
Note even assignment containing l1 = 0, l2 = 0 best assignment
subset {l1 , l2 , l1 l2 }, best whole formula. adding l1 l2 ,
rule ensures number unsatisfied clauses
l1 = 0, l2 = 0.
inference rule adds new clause l1 l2 , may contribute another contradiction detectable via unit propagation. case, rule allows increase
lower bound 2 instead 1. Moreover, rule makes explicit contradiction among
l1 , l2 , l1 l2 , contradiction need redetected current
node.
inference rules defined paper already known literature (Bansal & Raman, 1999; Niedermeier & Rossmanith, 2000), others original
Max-SAT. new rules inspired different unit resolution refinements applied
SAT, selected could applied natural efficient way.
sense, summarize work telling defined Max-SAT counterpart
SAT unit propagation.
aim finding powerful inference rules practice,
designed implemented new Max-SAT solver, called MaxSatz, incorporates
rules, well lower bound defined previous work (Li et al., 2005), performed
experimental investigation. results provide empirical evidence MaxSatz
competitive, least, random Max-2SAT, random Max-3SAT, Max-Cut, Graph
3-coloring instances, well benchmarks Max-SAT Evaluation 20061 .
structure paper follows. Section 2, give preliminary definitions. Section 3, describe basic branch bound Max-SAT solver. Section 4,
define inference rules prove soundness novel simple way via integer
programming transformation. give examples illustrate inference rules
may produce better quality lower bounds. Section 5, present implementation
inference rules MaxSatz. Section 6, describe main features MaxSatz.
Section 7, report experimental investigation. Section 8, present related
work. Section 9, present conclusions future work.

2. Preliminaries
propositional logic variable xi may take values 0 (for false) 1 (for true). literal li
variable xi negation xi . clause disjunction literals, CNF formula
conjunction clauses. length clause number literals. size
, denoted ||, sum length clauses.
1. http://www.iiia.csic.es/maxsat06

323

fiLi, Manya & Planes

assignment truth values propositional variables satisfies literal xi xi
takes value 1 satisfies literal xi xi takes value 0, satisfies clause
satisfies least one literal clause, satisfies CNF formula satisfies
clauses formula. empty clause, denoted 2, contains literals cannot
satisfied. assignment CNF formula complete variables occurring
assigned; otherwise, partial.
Max-SAT problem CNF formula problem finding assignment
values propositional variables minimizes number unsatisfied clauses (or
equivalently, maximizes number satisfied clauses). Max-SAT called MaxkSAT clauses k literals per clause. following, represent CNF
formula multiset clauses, since duplicated clauses allowed Max-SAT instance.
CNF formulas 1 2 equivalent 1 2 number unsatisfied
clauses every complete assignment 1 2 .

3. Basic Max-SAT Solver
space possible assignments CNF formula represented search
tree, internal nodes represent partial assignments leaf nodes represent complete
assignments. basic branch bound algorithm Max-SAT explores search tree
depth-first manner. every node, algorithm compares number clauses unsatisfied best complete assignment found far called upper bound (U B)
number clauses unsatisfied current partial assignment (#emptyClauses) plus
underestimation minimum number non-empty clauses become unsatisfied
extend current partial assignment complete assignment (underestimation).
sum #emptyClauses + underestimation lower bound (LB) minimum
number clauses unsatisfied complete assignment extended current partial
assignment. Obviously, LB U B, better solution cannot found point
search. case, algorithm prunes subtree current node backtracks
higher level search tree.
LB < U B, algorithm tries find possible better solution extending
current partial assignment instantiating one variable; leads creation
two branches current branch: left branch corresponds assigning new
variable false, right branch corresponds assigning new variable true.
case, formula associated left (right) branch obtained formula
current node deleting clauses containing literal x (x) removing
occurrences literal x (x); i.e., algorithm applies one-literal rule.
solution Max-SAT value U B takes exploring entire search
tree.
Figure 1 shows pseudo-code basic solver Max-SAT. use following
notations:
simplifyFormula() procedure simplifies applying sound inference rules.
#emptyClauses() function returns number empty clauses .
324

fiNew Inference Rules Max-SAT

Input: max-sat(, U B) : CNF formula upper bound U B
1: simplifyFormula();
2: = contains empty clauses
3:
return #emptyClauses();
4: end
5: LB #emptyClauses() + underestimation(, U B);
6: LB U B
7:
return U B;
8: end
9: x selectVariable();
10: U B min(U B, max-sat(x , U B));
11: return min(U B, max-sat(x , U B));
Output: minimal number unsatisfied clauses
Figure 1: basic branch bound algorithm Max-SAT
LB lower bound minimum number unsatisfied clauses current
partial assignment extended complete assignment. assume initial
value 0.
underestimation(, U B) function returns underestimation minimum
number non-empty clauses become unsatisfied current partial
assignment extended complete assignment.
U B upper bound number unsatisfied clauses optimal solution.
assume initial value total number clauses input formula.
selectVariable() function returns variable following heuristic.
x (x ) formula obtained applying one-literal rule using literal
x (x).
State-of-the-art Max-SAT solvers implement basic algorithm augmented powerful inference techniques, good quality lower bounds, clever variable selection heuristics,
efficient data structures.
recently defined (Li et al., 2005) lower bound computation method
underestimation lower bound number disjoint inconsistent subsets
detected using unit propagation. pseudo-code shown Figure 2.
Example 1 Let following CNF formula:
{x1 , x2 , x3 , x4 , x1 x2 x3 , x4 , x5 , x5 x2 , x5 x2 }.
approach able establish number disjoint inconsistent
subsets clauses least 3. Therefore, underestimation lower bound 3.
steps performed following ones:
325

fiLi, Manya & Planes

Input: underestimation(, U B) : CNF formula upper bound U B
1: underestimation 0;
2: apply one-literal rule unit clauses (unit propagation) empty
clause derived;
3: empty clause derived
4:
return underestimation;
5: end
6: without clauses used derive empty clause;
7: underestimation := underestimation + 1;
8: underestimation+#emptyClauses() U B
9:
return underestimation;
10: end
11: go 2;
Output: underestimation lower bound
Figure 2: Computation underestimation using unit propagation
1. = {x4 , x4 , x5 , x5 x2 , x5 x2 }, first inconsistent subset detected using unit
propagation {x1 , x2 , x3 , x1 x2 x3 }, underestimation = 1.
2. = {x5 , x5 x2 , x5 x2 }, second inconsistent subset detected using unit propagation
{x4 , x4 }, underestimation = 2.
3. = , third inconsistent subset detected using unit propagation {x5 , x5 x2 , x5
x2 }, underestimation = 3. Since empty, algorithm stops.

4. Inference Rules
define set inference rules considered paper. inspired different
unit resolution refinements applied SAT, selected could applied
natural efficient way. already known literature (Bansal &
Raman, 1999; Niedermeier & Rossmanith, 2000), others original Max-SAT.
presenting rules, define integer programming transformation CNF
formula used establish soundness rules. method proving soundness
novel Max-SAT, provides clear short proofs.
4.1 Integer Programming Transformation CNF Formula
Assume = {c1 , ..., cm } CNF formula clauses variables x1 , ..., xn .
Let ci (1 m) xi1 ... xik xik+1 ... xik+r . Note put positive literals
ci negative ones.
consider variables ci integer variables taking values 0 1, define
integer transformation ci
Ei (xi1 , ..., xik , xik+1 , ..., xik+r ) = (1 xi1 )...(1 xik )xik+1 ...xik+r
326

fiNew Inference Rules Max-SAT

Obviously, Ei value 0 iff least one variables xij (1 j k) instantiated
1 least one variables xis (k + 1 k + r) instantiated 0.
words, Ei =0 iff ci satisfied. Otherwise Ei =1.
literal l corresponds integer denoted l convenience. intention
correspondence literal l satisfied integer l 1 unsatisfied
integer l 0. l positive literal x, corresponding integer l x, l 1-x=1-l,
l negative literal x, l 1-x l x=1-(1-x)=1-l. Consequently, l=1-l
case.
generically write ci l1 l2 ... lk+r . integer programming transformation

Ei = (1 l1 )(1 l2 )...(1 lk+r ).
integer programming transformation CNF formula = {c1 , ..., cm }
variables x1 , ..., xn defined
E(x1 , ..., xn ) =


X

Ei

(1)

i=1

integer programming transformation used (Huang & Jin, 1997; Li & Huang,
2005) design local search procedure, called pseudo-Boolean formulation Boros
Hammer (2002). Here, extend empty clauses: ci empty, Ei =1.
Given assignment variables x1 , ..., xn , value E number
unsatisfied clauses . satisfies clauses , E = 0. Obviously, minimum
number unsatisfied clauses minimum value E.
Let 1 2 two CNF formulas, let E1 E2 integer programming
transformations. clear 1 2 equivalent if, if, E1 =E2 every
complete assignment 1 2 .
4.2 Inference Rules
next define inference rules prove soundness using previous integer
programming transformation. rest section, 1 , 2 denote CNF formulas,
E1 , E2 , E integer programming transformations. prove 1 2
equivalent, prove E1 = E2 .
Rule 1 (Bansal & Raman, 1999) 1 ={l1 l2 ... lk , l1 l2 ... lk } ,
2 ={l2 ... lk } equivalent 1 .
Proof 1
E1 = (1 l1 )(1 l2 )...(1 lk ) + l1 (1 l2 )...(1 lk ) + E
= (1 l2 )...(1 lk ) + E
= E2



General case resolution work Max-SAT (Bansal & Raman, 1999). Rule 1
establishes resolution works two clauses give strictly shorter resolvent.
327

fiLi, Manya & Planes

Rule 1 known literature replacement almost common clauses. pay
special attention case k=2, resolvent unit clause, case k=1,
resolvent empty clause. describe latter case following rule:
Rule 2 (Niedermeier & Rossmanith, 2000) 1 ={l, l} , 2 ={2} equivalent
1 .
Proof 2 E1 =1-l+ l+E =1+ E =E2



Rule 2, known complementary unit clause rule, used replace two
complementary unit clauses empty clause. new empty clause contributes
lower bounds search space current node incrementing number
unsatisfied clauses, incrementing underestimation, means
contradiction redetected again. practice, simple rule gives rise
considerable gains.
following rule complicated case:
Rule 3 1 ={l1 , l1 l2 , l2 } , 2 ={2, l1 l2 } equivalent 1 .
Proof 3
E1 = 1 l1 + l1 l2 + 1 l2 + E
= 1 + 1 l1 + l2 (l1 1) + E
= 1 + 1 l1 l2 (1 l1 ) + E
= 1 + (1 l1 )(1 l2 ) + E
= E2



Rule 3 replaces three clauses empty clause, adds new binary clause
keep equivalence 1 2 .
Pattern 1 considered compute underestimations Alsinet et al. (2004) Shen
Zhang (2004); captured method computing underestimations based
unit propagation (Li et al., 2005). Larrosa Heras mentioned (2005) existential
directional arc consistency (de Givry, Zytnicki, Heras, & Larrosa, 2005) capture
rule. Note underestimation computation methods Alsinet et al. Shen
Zhang add additional clause approach, detect contradictions.
Let us define rule generalizes Rule 2 Rule 3. presenting rule,
define lemma needed prove soundness.
Lemma 1 1 ={l1 , l1 l2 } 2 ={l2 , l2 l1 } , 1 2 equivalent.
Proof 4
E1 = 1 l1 + l1 (1 l2 ) + E
= 1 l1 + l1 l1 l2 + E
= 1 l2 + l2 l1 l2 + E
= 1 l2 + (1 l1 )l2 + E
= E2


328

fiNew Inference Rules Max-SAT

Rule 4 1 ={l1 , l1 l2 , l2 l3 , ..., lk lk+1 , lk+1 } , 2 ={2, l1 l2 , l2 l3 , ..., lk
lk+1 } equivalent 1 .
Proof 5 prove soundness rule induction k. k=1, 1 = {l1 , l1
l2 , l2 } . applying Rule 3, get {2, l1 l2 } , 2 k = 1. Therefore,
1 2 equivalent.
Assume Rule 4 sound k = n. Let us prove sound k = n + 1.
case:
1 = {l1 , l1 l2 , l2 l3 , ..., ln ln+1 , ln+1 ln+2 , ln+2 } .
applying Lemma 1 last two clauses 1 (before ), get
{l1 , l1 l2 , l2 l3 , ..., ln ln+1 , ln+1 , ln+1 ln+2 } .
applying induction hypothesis first n + 1 clauses previous CNF formula,
get
{2, l1 l2 , l2 l3 , ..., ln ln+1 , ln+1 ln+2 } ,
2 k = n + 1. Therefore, 1 2 equivalent rule sound.

Rule 4 original inference rule. captures linear unit resolution refutations
clauses resolvents used exactly once. rule simply adds empty clause,
eliminates two unit clauses binary clauses used refutation, adds new
binary clauses obtained negating literals eliminated binary clauses.
So, operations involved performed efficiently.
Rule 3 Rule 4 make explicit contradiction, need redetected
current subtree. So, lower bound computation becomes incremental. Moreover,
binary clauses added Rule 3 Rule 4 may contribute compute better quality
lower bounds either acting premises inference rule part
inconsistent subset clauses, illustrated following example.
Example 2 Let ={x1 , x1 x2 , x3 , x3 x2 , x4 , x1 x4 , x3 x4 }. Depending ordering
unit clauses propagated, unit propagation detects one following three
inconsistent subsets clauses: {x1 , x1 x2 , x3 , x3 x2 }, {x1 , x4 , x1 x4 }, {x3 , x4 , x3
x4 }. inconsistent subset detected removed, remaining set clauses
satisfiable. Without applying Rule 3 Rule 4, lower bound computed 1,
underestimation computed using unit propagation 1.
Note Rule 4 applied first inconsistent subset {x1 , x1 x2 , x3 , x3 x2 }.
Rule 4 applied, contradiction made explicit clauses x1 x2 x3 x2
added. So, becomes {2, x1 x2 , x3 x2 , x4 , x1 x4 , x3 x4 }. turns {2}
inconsistent set clauses detectable unit propagation. Therefore, lower bound
computed 2.
inconsistent subset {x1 , x4 , x1 x4 } detected, Rule 3 applied. Then,
contradiction made explicit clause x1 x4 added. So, becomes {2, x1 x4 , x1
x2 , x3 , x3 x2 , x3 x4 }. turns {2} inconsistent set clauses detectable
unit propagation. Therefore, lower bound computed 2.
329

fiLi, Manya & Planes

Similarly, inconsistent subset {x3 , x4 , x3 x4 } detected Rule 3 applied,
lower bound computed 2.
observe that, example, Rule 3 Rule 4 make explicit contradiction, allow improve lower bound.
Unit propagation needs least one unit clause detect contradiction. drawback
Rule 3 Rule 4 consume two unit clauses deriving one contradiction. possible situation that, branching, two unit clauses could allow
unit propagation derive two disjoint inconsistent subsets clauses, show
following example.
Example 3 Let ={x1 , x1 x2 , x1 x3 , x2 x3 x4 , x5 , x5 x6 , x5 x7 , x6 x7 x4 , x1 x5 }.
Rule 3 replaces x1 , x5 , x1 x5 empty clause x1 x5 . that, x4
selected next branching variable assigned 0, unit clause
contradiction detected via unit propagation. lower bound 1
situation. However, Rule 3 applied branching, two unit clauses
branching. case, propagation x1 allows detect inconsistent subset
{x1 , x1 x2 , x1 x3 , x2 x3 }, propagation x5 allows detect inconsistent
subset {x5 , x5 x6 , x5 x7 , x6 x7 }. So, lower bound computed branching 2.
one hand, Rule 3 Rule 4 add clauses contribute detect additional
conflicts. hand, application Rule 3 Rule 4 consumes two unit
clauses, cannot used detect conflicts. final effect two
factors empirically analyzed Section 7.
Finally, present two new rules capture unit resolution refutations
(i) exactly one unit clause consumed, (ii) unit clause used twice linear
derivation empty clause.
Rule 5 1 ={l1 , l1 l2 , l1 l3 , l2 l3 } , 2 ={2, l1 l2 l3 , l1 l2 l3 }
equivalent 1 .
Proof 6
E1 = 1 l1 + l1 (1 l2 ) + l1 (1 l3 ) + l2 l3 + E
= 1 l1 + l1 l1 l2 + l1 l1 l3 + l2 l3 + E
= 1 + l2 l3 l1 l2 l3 + l1 l1 l2 l1 l3 + l1 l2 l3 + E
= 1 + (1 l1 )l2 l3 + l1 (1 l2 l3 + l2 l3 ) + E
= 1 + (1 l1 )l2 l3 + l1 (1 l2 )(1 l3 ) + E
= E2



combine linear derivation Rule 5 obtain Rule 6:
Rule 6 1 ={l1 , l1 l2 , l2 l3 , ..., lk lk+1 , lk+1 lk+2 , lk+1 lk+3 , lk+2 lk+3 } ,
2 ={2, l1 l2 , l2 l3 , ..., lk lk+1 , lk+1 lk+2 lk+3 , lk+1 lk+2 lk+3 }
equivalent 1 .
330

fiNew Inference Rules Max-SAT

Proof 7 prove soundness rule induction k. k=1,
1 = {l1 , l1 l2 , l2 l3 , l2 l4 , l3 l4 } .
Lemma 1, get
Rule 5, get

{l1 l2 , l2 , l2 l3 , l2 l4 , l3 l4 } .
{l1 l2 , 2, l2 l3 l4 , l2 l3 l4 } ,

2 k = 1. Therefore, 1 2 equivalent.
Assume Rule 6 sound k = n. Let us prove sound k = n + 1.
case:
1 = {l1 , l1 l2 , l2 l3 , ..., ln+1 ln+2 , ln+2 ln+3 , ln+2 ln+4 , ln+3 ln+4 } .
Lemma 1, get
{l1 l2 , l2 , l2 l3 , ..., ln+1 ln+2 , ln+2 ln+3 , ln+2 ln+4 , ln+3 ln+4 } .
applying induction hypothesis, get
{l1 l2 , 2, l2 l3 , ..., ln+1 ln+2 , ln+2 ln+3 ln+4 , ln+2 ln+3 ln+4 } ,
2 k = n + 1. Therefore, 1 2 equivalent rule sound.

Similarly Rule 3 Rule 4, Rule 5 Rule 6 make explicit contradiction,
need redetected subsequent search. Therefore, lower bound computation becomes incremental. Moreover, add clauses improve
quality lower bound, illustrated following example.
Example 4 Let ={x1 , x1 x2 , x1 x3 , x2 x3 , x4 , x1 x4 , x2 x4 , x3 x4 }. Depending
ordering unit clauses propagated, unit propagation detect one
following inconsistent subsets: {x1 , x1 x2 , x1 x3 , x2 x3 }, {x4 , x1 x4 , x2 x4 , x1 x2 },
{x4 , x1 x4 , x3 x4 , x1 x3 }, Rule 5 applicable. Rule 5 applied, lower
bound computed using underestimation function Figure 2 1, since remaining
clauses satisfiable inconsistent subset clauses removed. Rule 5 allows
add two ternary clauses contributing another contradiction. example, Rule 5
applied {x1 , x1 x2 , x1 x3 , x2 x3 } adds clauses x1 x2 x3 x1 x2 x3 ,
which, remaining clauses ({x4 , x1 x4 , x2 x4 , x3 x4 }), give second
contradiction detectable via unit propagation. lower bound computed using Rule 5
2.
contrast Rule 3 Rule 4, Rule 5 Rule 6 consume exactly one unit clause
deriving empty clause. Since unit clause used derive conflict
via unit propagation, Rule 5 Rule 6 limit detection conflicts via
unit propagation.
331

fiLi, Manya & Planes

5. Implementation Inference Rules
section, describe implementation inference rules presented Section 4. suppose CNF formula loaded and, every literal , list clauses
containing constructed. application rule means clauses 1
removed CNF formula, new clauses 2 inserted formula,
lower bound increased 1. Note inference rules selected approach,
2 contains fewer literals fewer clauses 1 , new clauses 2 inserted
place removed clauses 1 inference rule applied. Therefore,
need dynamic memory management implementation faster.
Rule 1 k=2 Rule 2 applied using matching algorithm (see, e.g., Cormen,
Leiserson, Rivest, & Stein, 2001, efficient implementation) lists clauses.
first time complexity O(m), number clauses CNF
formula. second time complexity O(u), u number unit clauses
CNF formula. rules applied every node, lower bound computation application inference rules. Rule 1 (k=2) applied many times
possible derive unit clauses applying Rule 2.
implementation Rule 3, Rule 4, Rule 5, Rule 6 entirely based unit
propagation. Given CNF formula , unit propagation constructs implication graph
G (see, e.g., Beame, Kautz, & Sabharwal, 2003), applicability inference
rules detected. section, first describe construction implication graph,
describe determine applicability Rule 3, Rule 4, Rule 5, Rule 6.
Then, analyze complexity, termination (in)completeness application
rules. Finally discuss extension inference rules weighted Max-SAT
implementation.
5.1 Implication Graph
Given CNF formula , Figure 3 shows unit propagation constructs implication
graph whose nodes literals.
Note every node G corresponds different literal, considered
different literals. CNF formula contains several copies unit clause ,
algorithm adds one node label .
Example 5 Let ={x1 , x1 , x1 x2 , x1 x3 , x2 x3 x4 , x5 , x5 x6 , x5 x7 , x6 x7 x4 , x5 x8 }.
U nitP ropagation constructs implication graph Figure 4, add special
node 2 highlight contradiction.
G always acyclic every added edge connects new node. well known
time complexity unit propagation O(||), || size (see, e.g.,
Freeman, 1995).
associate clause c=1 2 ...k1 k node k node k added G
c. Note node k incoming edge c unit (k=1),
node one incoming edge c binary (k=2). G constructed,
G contains literal (i.e., unit propagation deduces contradiction),
easy identify nodes exists path G; i.e., clauses
332

fiNew Inference Rules Max-SAT

Input: U nitP ropagation() : CNF formula containing complementary unit
clauses literal
initialize G empty graph
add node labeled every literal unit clause c
repeat
1 , 2 , ..., k1 nodes G, c = 1 2 ... k1 k clause , k
node G,
add G node labeled k
add G directed edge node k every (1 < k)
end
nodes added literal nodes
G
Return G
Output: Implication graph G
Figure 3: Unit propagation constructing implication graphs

x2
x4

x1
x3
x6
x5

x4
x7
x8

Figure 4: Example implication graph

333

fiLi, Manya & Planes

x1
c1
x5
c5

x2
c2
x6
c6

x3
c3
x4
c7

x4
c4

Figure 5: Example implication graph
implying . clauses constitute inconsistent subset .
example, clauses x1 , x1 x2 , x1 x3 x2 x3 x4 imply x4 , clauses x5 , x5 x6 , x5 x7
x6 x7 x4 imply x4 . Clause x5 x8 contribute contradiction.
inconsistent subset {x1 , x1 x2 , x1 x3 , x2 x3 x4 , x5 , x5 x6 , x5 x7 , x6 x7 x4 }.
5.2 Applicability Rule 3, Rule 4, Rule 5, Rule 6
assume unit propagation deduces contradiction and, therefore, implication
graph G contains literal . Let set nodes
exists path , let set nodes exists path
, let S=S . clause associated node G, use S, ,
denote set clauses associated nodes S, , , respectively.
Lemma 2 Lemma 3 used detect applicability Rule 3, Rule 4, Rule 5,
Rule 6.
Lemma 2 Rule 3 Rule 4 applicable
1. (resp. ), one unit clause clauses binary,
2. nodes (resp. ) form implication chain starting unit clause ending
(resp. ),
3. empty.
Proof 8 Starting node corresponding unit clause (resp. ),
following parallel two implication chains, 1 Rule 3 Rule 4 writing
clause corresponding node.
Example 6 Let following CNF formula containing clauses c1 c7 : {c1 : x1 , c2 :
x1 x2 , c3 : x2 x3 , c4 : x3 x4 , c5 : x5 , c6 : x5 x6 , c7 : x6 x4 }. Unit propagation constructs implication graph shown Figure 5, contains complementary
literals x4 x4 .
Rule 4 applicable =x4 , ={x1 (c1 ), x2 (c2 ), x3 (c3 ), x4 (c4 )},
={x5 (c5 ), x6 (c6 ), x4 (c7 )}. easy verify three conditions Lemma 2
satisfied.
Remark: rewritten {c1 : x1 , c2 : x1 x2 , c3 : x2 x3 , c4 : x3 x4 , c7 :
x4 x6 , c6 : x6 x5 , c5 : x5 } compared 1 Rule 4.
334

fiNew Inference Rules Max-SAT

x1
c1

x2
c2

x3
c3
x4
c4

x4
c5

Figure 6: Example implication graph
application Rule 3 Rule 4 consists replacing every binary clause c
binary clause obtained negating every literal c, removing two unit clauses
, incrementing #emptyClauses() 1.
Lemma 3 Rule 5 Rule 6 applicable
1. S=S , one unit clause clauses binary; i.e.,
nodes S, except node corresponding unit clause, exactly one
incoming edge G.
2. non-empty contains k (k >0) nodes forming implication chain
form 1 2 k , k last node chain.
3. (S )-(S ) contains exactly three nodes : , , third one. Let k+1
third literal,
k+1 , G contains following implications
k k+1
k
k+1 , G contains following implications
k
k k+1
Proof 9 Assume, without loss generality, k+1 ; case k+1 symmetric. implication chain formed nodes corresponds clauses {1 ,
1 2 , . . . , k1 k }, which, together three clauses {k k+1 , k+1 , k }
corresponding k k+1 k , give 1 Rule 5 Rule 6.
Example 7 Let following CNF formula containing clauses c1 c5 : {c1 : x1 , c2 :
x1 x2 , c3 : x2 x3 , c4 : x2 x4 , c5 : x3 x4 }. Unit propagation constructs implication
graph shown Figure 6, contains complementary literals x4 x4 .
Sx4 ={x1 (c1 ), x2 (c2 ), x4 (c4 )} Sx4 ={x1 (c1 ), x2 (c2 ), x3 (c3 ), x4 (c5 )}.
nodes Sx4 Sx4 obviously form implication chain: x1 x2 . (Sx4 Sx4 )-(Sx4
Sx4 )={x3 (c3 ), x4 (c4 ), x4 (c5 )}. G contains x2 x3 x4 x2 x4 . Rule 6 applicable.
application Rule 5 Rule 6 consists removing unit clause
, replacing binary clause c binary clause obtained c
negating two literals c, replacing three binary clauses (S )-(S )
two ternary clauses, incrementing #emptyClauses() 1.
335

fiLi, Manya & Planes

5.3 Complexity, Termination, (In)Completeness Rule Applications
branch bound algorithm Max-SAT, combine application inference rules computation underestimation lower bound. Given CNF
formula , function underestimation uses unit propagation construct implication
graph G. G contains two nodes literal , G analyzed determine
whether inference rule applicable. rule applicable, applied
transformed equivalent Max-SAT instance. Otherwise, clauses contributing
contradiction removed , underestimation incremented 1.
procedure repeated unit propagation cannot derive contradictions. Finally,
removed clauses, except removed replaced due inference rule applications,
reinserted . underestimation, together new , returned.
well known unit propagation implemented time complexity linear
size (see, e.g., Freeman, 1995). complexity determining applicability
inference rules using Lemma 2 Lemma 3 linear size G, bounded
number literals , assume graph represented doubly-linked
lists. application inference rule obviously linear size G. So, whole
time complexity function underestimation inference rule applications O(d ||),
number contradictions function underestimation able detect
using unit propagation. Observe factor needed application
rules inserts new clauses place removed clauses.
Since every inference rule application reduces size , function underestimation
inference rule applications linear space complexity, always terminates. Recall
new clauses added inference rules stored place old ones.
data structures loading statically efficiently maintained.
proved inference rules sound. following example shows
application rules necessarily complete implementation, sense
possible applications inference rules necessarily done.
Example 8 Let ={x1 , x3 , x4 , x1 x3 x4 , x1 x2 , x2 }. Unit propagation may discover
inconsistent subset S={x1 , x3 , x4 , x1 x3 x4 }. case, inference rule applicable S. Then, underestimation lower bound incremented 1,
becomes {x1 x2 , x2 }. Unit propagation cannot detect contradictions , function underestimation stops reinserting {x1 , x3 , x4 , x1 x3 x4 } . value
1 returned, together unchanged . Note Rule 3 applicable subset
{x1 , x1 x2 , x2 } , applied.
Actually, function underestimation applies Rule 3 unit propagation detects
inconsistent subset {x1 , x1 x2 , x2 } instead {x1 , x3 , x4 , x1 x3 x4 }. detection
inconsistent subset depends ordering unit clauses propagated unit
propagation. example, inconsistent subset {x1 , x1 x2 , x2 } discovered unit
clause x2 propagated x3 x4 . study needed define orderings
unit clauses maximize application inference rules.
Observe algorithm deterministic, always computes lower bound
order clauses changed.
336

fiNew Inference Rules Max-SAT

5.4 Inference Rules Weighted Max-SAT
inference rules presented paper naturally extended weighted Max-SAT.
weighted Max-SAT, every clause associated weight problem consists
finding truth assignment sum weights unsatisfied clauses
minimum. example, weighted version Rule 3 could
Rule 7 1 ={(l1 , w1 ), (l1 l2 , w2 ), (l2 , w3 )} , 2 ={(2, w), (l1 l2 , w), (l1 , w1
w), (l1 l2 , w2 w), (l2 , w3 w)} equivalent 1
w1 , w2 w3 positive integers representing clause weight, w=min(w1 ,
w2 , w3 ). Mandatory clauses, satisfied optimal solution, specified
weight . Note w6=, -w= w=, optimal solution
found solver backtrack. Clauses weight 0 removed. Observe 1
rewritten 11 12 , 11 ={(l1 , w), (l1 l2 , w), (l2 , w)}, 12 ={(l1 , w1
w), (l1 l2 , w2 w), (l2 , w3 w)} . Then, weighted inference rule equivalent
unweighted version applied w times (unweighted) clauses 11 .
Similarly, weighted version Rule 4 could
Rule 8 1 ={(l1 , w1 ) (l1 l2 , w2 ), (l2 l3 , w3 ), . . . , (lk lk+1 , wk+1 ), (lk+1 , wk+2 )} ,
2 ={(2, w), (l1 l2 , w), (l2 l3 , w), . . . , (lk lk+1 , w), (l1 , w1 w), (l1 l2 , w2
w), (l2 l3 , w3 w), . . . , (lk lk+1 , wk+1 w), (lk+1 , wk+2 w)} equivalent 1
w=min(w1 , w2 , . . . , wk+2 ). Observe 1 rewritten 11 12 ,
11 ={(l1 , w) (l1 l2 , w), (l2 l3 , w), . . . , (lk lk+1 , w), (lk+1 , w)}, weighted version
Rule 4 equivalent unweighted Rule 4 applied w times (unweighted) clauses
11 .
current implementation inference rules naturally extended weighted
inference rules. inconsistent subformula detected rule applicable (clause
weights considered detection inconsistent subformula applicability rule, provided clauses weight 0 discarded), 11
12 separated computing minimal weight w clauses detected
inconsistent subformula, rule applied 11 . derived clauses clauses
12 used subsequent reasoning.

6. MaxSatz: New Max-SAT Solver
implemented new Max-SAT solver, called MaxSatz, incorporates lower
bound computation method based unit propagation defined Section 3, applies
inference rules defined Section 4. name MaxSatz comes fact
implementation algorithm incorporates technology developed
SAT solver Satz (Li & Anbulagan, 1997b, 1997a).
MaxSatz incorporates lower bound based unit propagation, applies Rule 1,
Rule 2, Rule 3, Rule 4, Rule 5, Rule 6. addition, MaxSatz applies following
techniques:
Pure literal rule: literal appears either positive polarity negative
polarity, delete clauses containing literal.
337

fiLi, Manya & Planes

Empty-Unit clause rule (Alsinet et al., 2003a): Let neg1(x) (pos1(x)) number
unit clauses x negative (positive). #emptyClauses() + neg1(x) U B,
assign x false. #emptyClauses() + pos1(x) U B, assign x
true.
Dominating Unit Clause (DUC) rule (Niedermeier & Rossmanith, 2000): number clauses literal x (x) appears greater neg1(x) (pos1(x)),
assign x false (true).
Variable selection heuristic: Let neg2(x) (pos2(x)) number binary clauses
x negative (positive), let neg3(x) (pos3(x)) number clauses
containing three literals x negative (positive). select
variable x (neg1(x)+4neg2(x)+neg3(x))*(pos1(x)+4pos2(x)+pos3(x))
largest. fact binary clauses counted four times
clauses determined empirically.
Value selection heuristic: Let x selected branching variable. neg1(x) + 4
neg2(x) + neg3(x) < pos1(x) + 4 pos2(x) + pos3(x), set x true. Otherwise set x
false. heuristics determined empirically.
paper, order compare inference rules defined, used three simplified versions MaxSatz:
MaxSat0: apply inference rule defined Section 4.
MaxSat12: applies rules 1 2, rules 3, 4, 5 6.
MaxSat1234: applies rules 1, 2, 3 4, rules 5 6.
Actually, MaxSatz corresponds MaxSat123456 terminology. MaxSat12 corresponds improved version solver U P (Li et al., 2005), using special ordering
propagating unit clauses unit propagation. MaxSat12 maintains two queues
unit propagation: Q1 Q2 . MaxSat12 starts search inconsistent subformula via unit propagation, Q1 contains unit clauses CNF formula
consideration (more recently derived unit clauses end Q1 ), Q2 empty.
unit clauses derived application unit propagation stored Q2 ,
unit propagation use unit clause Q1 unless Q2 empty. Intuitively,
ordering prefers unit clauses non-unit clauses starting application
unit propagation. way, derived inconsistent subset contains, general, less unit
clauses. unit clauses consumed contribute detect
inconsistent subsets. experimental results (Li, Manya, & Planes, 2006) show
search tree size MaxSat12 substantially smaller UP, MaxSat12
substantially faster UP. MaxSat0, Maxsat1234, MaxSatz use ordering
MaxSat12 propagating unit clauses unit propagation.
source code MaxSat0, MaxSat12, MaxSat1234, MaxSatz found
http://web.udl.es/usuaris/m4372594/jair-maxsatz-solvers.zip, http://www.laria.upicardie.fr/cli/maxsatz.tar.gz.
338

fiNew Inference Rules Max-SAT

7. Experimental Results
report experimental investigation performed unweighted Max-SAT order
evaluate inference rules defined Section 4, compare MaxSatz
best performing state-of-the-art solvers publicly available paper
submitted. experiments performed Linux Cluster processors 2 GHz
AMD Opteron 1 Gb RAM.
structure section follows. first describe solvers benchmarks
considered. Then, present experimental evaluation inference
rules. Finally, show experimental comparison MaxSatz solvers.
7.1 Solvers Benchmarks
MaxSatz compared following Max-SAT solvers:
BF2 (Borchers & Furman, 1999): branch bound Max-SAT solver uses
MOMS dynamic variable selection heuristic consider underestimations
computation lower bound. developed Borchers Furman
1999.
AGN3 (Alber et al., 2001): branch bound Max-2SAT solver. developed
Alber, Gramm Niedermeier 1998.
AMP4 (Alsinet et al., 2003b): branch bound Max-SAT solver based BF
incorporates lower bound better quality Jeroslow-Wang variable selection
heuristic (Jeroslow & Wang, 1990). developed Alsinet, Manya Planes
presented SAT-2003.
toolbar5 (de Givry et al., 2003; Larrosa & Heras, 2005): Max-SAT solver whose
inference inspired soft arc consistency properties implemented weighted CSP
solvers. developed de Givry, Larrosa, Meseguer Schiex first
presented CP-2003. used version 2.2 default parameters.
MaxSolver6 (Xing & Zhang, 2004): branch bound Max-SAT solver applies
number efficient inference rules. developed Xing Zhang presented
CP-2004. used second release solver.
Lazy7 (Alsinet et al., 2005): branch bound Max-SAT solver lazy data
structures static variable selection heuristic. developed Alsinet, Manya
Planes presented SAT-2005.
2.
3.
4.
5.
6.
7.

Downloaded October 2004 http://infohost.nmt.edu/borchers/satcodes.tar.gz
Downloaded October 2005 http://www-fs.informatik.uni-tuebingen.de/gramm/
Available http://web.udl.es/usuaris/m4372594/software.html
Downloaded October 2005 http://carlit.toulouse.inra.fr/cgi-bin/awki.cgi/ToolBarIntro
Downloaded October 2005 http://cic.cs.wustl.edu/maxsolver/
Available http://web.udl.es/usuaris/m4372594/software.html

339

fiLi, Manya & Planes

UP8 (Li et al., 2005): branch bound Max-SAT solver lower bound
computation method based unit propagation (cf. Section 3). developed
Li, Manya Planes presented CP-2005.
used benchmarks randomly generated Max-2SAT instances Max-3SAT instances, graph 3-coloring instances9 , well Max-Cut instances10 . considered
unweighted Max-SAT benchmarks submitted Max-SAT Evaluation 2006, including
Max-Cut, Max-Ones, Ramsey numbers, random Max-2SAT Max-3SAT instances.
generated Max-2SAT instances Max-3SAT instances using generator mwff.c
developed Bart Selman, allows duplicated clauses. Max-Cut, first
generated random graph edges every edge randomly selected among
set possible edges. graph connected, discarded. graph
connected, used encoding Shen Zhang (2005) encode Max-Cut
instance CNF: created, edge (xi , xj ), exactly two binary clauses (xi xj )
(xi xj ). collection binary clauses, Max-Cut instance
cut weight k iff Max-SAT instance assignment + k clauses
satisfied.
graph 3-coloring, first used Culbersons generator generate random kcolorable graph type IID (independent random edge assignment, variability=0)
k vertices fixed edge density. used Culbersons converter SAT standard conversion three colors generate Max-SAT instance: vertex xi
color j {1, 2, 3}, propositional variable xij defined meaning vertex
colored color j. vertex xi , four clauses added encode vertex
colored exactly one color: xi1 xi2 xi3 , xi1 xi2 , xi1 xi3 , xi2 xi3 ; and,
edge (xi , xj ), three clauses added encode vertex xi vertex xj
color: xi1 xj1 , xi2 xj2 , xi3 xj3 .
random Max-2SAT Max-3SAT instances, clauses entirely independent
structure. graph 3-coloring instances Max-Cut instances
used paper, clauses independent structure. example,
Max-Cut instance, every time clause xi xj , clause xi xj ;
satisfaction two clauses means corresponding edge cut.
graph 3-coloring instance, every time ternary clause xi1 xi2 xi3 encoding
vertex colored least color, three binary clauses xi1 xi2 , xi1 xi3 ,
xi2 xi3 encoding vertex cannot colored two colors. MaxCut instances contain binary clauses, graph 3-coloring instances contain ternary
clause every vertex graph. derive optimal cut optimal
assignment Max-SAT encoding Max-Cut instance, optimal assignment
Max-SAT encoding 3-coloring instance may assign one color vertices.
8. Available http://web.udl.es/usuaris/m4372594/software.html
9. Given undirected graph G = (V, E), V = {x1 , . . . , xn } set vertices E set
edges, set three colors, graph 3-coloring problem problem coloring every vertex
one three colors way that, edge (xi , xj ) E, vertex xi vertex xj
color.
10. Given undirected graph G = (V, E), let wxi ,xj weight associated edge (xi , xj ) E.
P
weighted Max-Cut problem find subset V W (S, S) = xi S,xj wxi ,xj
maximized, = V S. paper, set weight wxi ,xj = 1 edges.

340

fiNew Inference Rules Max-SAT

Max-Cut Ramsey numbers instances Max-SAT Evaluation 2006 contain different structures. example, underlying graphs Max-Cut instances
different origins fault diagnosis problems, coding theory problems, graph
clique problems. Max-2SAT Max-3SAT instances evaluation contain
duplicated clauses.
computed initial upper bound local search solver instance.
provide parameter solver except instance solved initial
upper bound. words, used default values parameters.
instances Max-SAT Evaluation 2006 solved conditions
evaluation; i.e., initial upper bound provided solvers, maximum time
allowed solve instance 30 minutes.
7.2 Evaluation Inference Rules
first experiment performed evaluate impact inference rules Section 4,
solved sets 100 random Max-2SAT instances 50 100 variables; number
clauses ranged 400 4500 50 variables, 400 1000 100 variables.
results obtained shown Figure 7. Along horizontal axis number
clauses, along vertical axis mean time (left plot), seconds, needed solve
instance set, mean number branches proof tree (right plot). Notice
use log scale represent run-time branches.
observe rules powerful Max-2SAT gain increases
number variables number clauses increase. 50 variables 1000
clauses (the clause variable ratio 20), MaxSatz 7.6 times faster MaxSat1234;
100 variables 1000 clauses (the clause variable ratio 10), MaxSatz 9.2
times faster MaxSat1234. search tree MaxSatz substantially smaller
MaxSat1234. Rule 5 Rule 6 powerful Rule 3 Rule 4
Max-2SAT. intuitive explanation MaxSatz MaxSat1234 detect many
inconsistent subsets clauses containing one unit clause subsets containing two unit
clauses, Rule 5 Rule 6 applied many times Rule 3 Rule 4
MaxSatz.
Recall that, one hand, every application Rule 3 Rule 4 consumes two
unit clauses produces one empty clause, limiting unit propagation detecting
conflicts subsequent search. hand, Rule 3 Rule 4 add clauses
may contribute detect conflicts. Depending number clauses (or
precisely, clause variable ratio) formula, two factors different
importance. relatively clauses, unit propagation relatively
easily derive contradiction unit clause, binary clauses added Rule 3
Rule 4 relatively important deriving additional conflicts improving lower
bound, explains search tree MaxSat1234 smaller search tree
MaxSat12 instances 100 variables less 600 clauses. contrary,
many clauses, unit propagation easily derives contradiction unit
clause, two unit clauses consumed Rule 3 Rule 4 would probably allow
derive two disjoint inconsistent subsets clauses. addition, binary clauses added
Rule 3 Rule 4 relatively less important deriving additional conflicts, considering
341

fiLi, Manya & Planes

large number clauses formula. case, search tree MaxSat1234
larger search tree MaxSat12. However, cases, MaxSat1234 faster
MaxSat12, meaning incremental lower bound computation due Rule 3
Rule 4 effective, since redetection many conflicts avoided thanks Rule 3
Rule 4.

Max-2SAT - 50 variables
1e+07

1000

1e+06

branches (log scale)

time (logscale)

Max-2SAT - 50 variables
10000

100
10
1
MaxSat0
MaxSat12
MaxSat1234
MaxSatz

0.1
0.01
1000

2000

3000

100000
10000
MaxSat0
MaxSat12
MaxSat1234
MaxSatz

1000
100

4000

1000

2000

number clauses

1000

1e+07

100
10
1

0.01
400

MaxSat0
MaxSat12
MaxSat1234
MaxSatz
500

600
700
800
number clauses

4000

Max-2SAT - 100 variables
1e+08
branches (log scale)

time (logscale)

Max-2SAT - 100 variables
10000

0.1

3000

number clauses

900

1e+06
100000
10000
MaxSat0
MaxSat12
MaxSat1234
MaxSatz

1000
100
400

1000

500

600
700
800
number clauses

900

1000

Figure 7: Comparison among MaxSat12, MaxSat1234 MaxSatz random Max-2SAT instances.

Rule 5 Rule 6 limit unit propagation detecting conflicts, since
application produces one empty clause consumes one unit clause, allows
derive one conflict case. added ternary clauses allow improve
lower bound, search tree MaxSatz substantially smaller search
tree MaxSat1234. incremental lower bound computation due Rule 5 Rule 6
contributes time performance MaxSatz. example, search tree
MaxSatz instances 50 variables 2000 clauses 11.5 times smaller
search tree MaxSat1234, MaxSatz 14 times faster MaxSat1234.
second experiment, solved random Max-3SAT instances instead random
Max-2SAT instances. solved instances 50 70 variables; number clauses
ranged 400 1200 50 variables, 500 1000 70 variables. results
obtained shown Figure 8.
342

fiNew Inference Rules Max-SAT

Max-3SAT - 50 variables

Max-3SAT - 50 variables
1e+07
branches (log scale)

time (log scale)

1000

100

10
MaxSat0
MaxSat12
MaxSat1234
MaxSatz

1

0.1
400

600

800
1000
number clauses

1e+06

100000

1000
400

1200

Max-3SAT - 70 variables

600
800
1000
number clauses

1200

Max-3SAT - 70 variables
1e+08
branches (log scale)

10000

time (logscale)

MaxSat0
MaxSat12
MaxSat1234
MaxSatz

10000

1000

100
MaxSat0
MaxSat12
MaxSat1234
MaxSatz

10

1
500

600

700
800
number clauses

900

1000

1e+07

1e+06
MaxSat0
MaxSat12
MaxSat1234
MaxSatz

100000

10000
500

600

700
800
number clauses

900

1000

Figure 8: Comparison among MaxSat12, MaxSat1234 MaxSatz random Max-3SAT instances.

Although rules involve ternary clauses, powerful Max-3SAT.
Similarly Max-2SAT, Rule 3 Rule 4 slightly improve lower bound
relatively clauses, improve lower bound number clauses
increases. improve time performance thanks incremental lower bound
computation allowed. gain increases number clauses increases.
example, problems 70 variables, number clauses 600, MaxSat1234
36% faster MaxSat12 and, number clauses 1000, gain 44%.
Rule 5 Rule 6 improve lower bound time performance MaxSatz.
gain increases number clauses increases.
third experiment considered Max-Cut problem graphs 50 vertices
number edges ranging 200 800. Figure 9 shows results comparing
inference rules Max-Cut instances. observe rules allow us solve
instances much faster. Similarly random Max-2SAT, Rule 3 Rule 4
improve lower bound many clauses, improve time performance
due incremental lower bound computation allowed. Rule 5 Rule 6
powerful Rule 3 Rule 4 instances, contain binary clauses
structure. addition, reduction tree size due Rule 5 Rule 6
contributes time performance MaxSatz incrementality lower
bound computation, random Max-2SAT. example, search tree MaxSatz
instances 800 edges 40 times smaller search tree MaxSat1234,
MaxSatz 47 times faster.
343

fiLi, Manya & Planes

Max-Cut - 50 nodes
1e+09

10000

1e+08
branches (log scale)

time (log scale)

Max-Cut - 50 nodes
100000

1000
100
10
1

MaxSat0
MaxSat12
MaxSat1234
MaxSatz

0.1
0.01
200

300

400
500
600
number edges

1e+07
1e+06
100000
10000

MaxSat0
MaxSat12
MaxSat1234
MaxSatz

1000
700

100
200

800

300

400
500
600
number edges

700

800

Figure 9: Experimental results Max-Cut

fourth experiment considered graph 3-coloring instances 24 60 vertices, density edges ranging 20% 90%. Figure 10 shows results
comparing inference rules graph 3-coloring instances. observe Rule 1
Rule 2 useful instances; tree size MaxSat0 MaxSat12 almost
same, MaxSat12 slower MaxSat0. contrary, rules
useful instances, especially allow reduce search tree size
deriving better lower bounds.

Graph 3-coloring 24 nodes

Graph 3-coloring 24 nodes
10000
Branches (log scale)

time (log scale)

0.1

0.01

0.001
MaxSat0
MaxSat12
MaxSat1234
MaxSatz

1e-04
20

30

40

50
60
% edges

70

1000

100
MaxSat0
MaxSat12
MaxSat1234
MaxSatz

10
80

90

20

30

Graph 3-coloring 60 nodes

50
60
% edges

70

80

90

80

90

Graph 3-coloring 60 nodes
1e+08
Branches (log scale)

10000

time (log scale)

40

1000

100
MaxSat0
MaxSat12
MaxSat1234
MaxSatz

10

1
20

30

40

50
60
% edges

70

1e+07

1e+06
MaxSat0
MaxSat12
MaxSat1234
MaxSatz

100000
80

90

20

30

40

50
60
% edges

Figure 10: Experimental results Graph 3-Coloring
344

70

fiNew Inference Rules Max-SAT

Note Rule 3 Rule 4 impact Rule 5 Rule 6 reducing
cost solving instances. probably due fact two unit clauses
needed detect contradiction, Rule 3 Rule 4 applied many times.
note instances 60 vertices become easier solve density
graph high.
fifth experiment, compared different inference rules benchmarks submitted Max-SAT Evaluation 2006. Solvers ran conditions
evaluation. Table 1, first column name benchmark set, second
column number instances set, rest columns display average
time, seconds, needed solver solve instance (the number solved instances
brackets). maximum time allowed solve instance 30 minutes.
clear MaxSat12 better MaxSat0, MaxSat1234 better MaxSat12,
MaxSatz better MaxSat1234. example, MaxSatz solves three MAXCUT
johnson instances within time limit, solvers solve two instances.
average time MaxSatz solve one three instances 44.46 seconds,
third instance needing time solved two instances.
Set Name
MAXCUT brock
MAXCUT c-fat
MAXCUT hamming
MAXCUT johnson
MAXCUT keller
MAXCUT p hat
MAXCUT san
MAXCUT sanr
MAXCUT max cut
MAXCUT SPINGLASS
MAXONE
RAMSEY
MAX2SAT 100VARS
MAX2SAT 140VARS
MAX2SAT 60VARS
MAX2SAT DISCARDED
MAX3SAT 40VARS
MAX3SAT 60VARS

#Instances
12
7
6
4
2
12
11
4
40
5
45
48
50
50
50
180
50
50

MaxSat0
471.01(10)
1.92 (5)
39.42(2)
14.91(2)
512.66(2)
72.16(9)
801.95(7)
323.67(3)
610.28(35)
0.22 (2)
0.03 (45)
8.93 (34)
95.01(50)
153.28(49)
1.35 (50)
126.98(162)
11.52(50)
167.17(50)

MaxSat12
277.12(12)
3.11 (5)
29.43(2)
8.57 (2)
213.64(2)
286.09(12)
305.75(7)
134.74(3)
481.48(40)
0.19 (2)
0.03 (45)
8.42 (34)
11.30(50)
51.76(50)
0.08 (50)
71.85(173)
3.33 (50)
72.72(50)

MaxSat1234
225.11(12)
2.84 (5)
29.48(2)
7.21 (2)
163.26(2)
226.24(12)
245.70(7)
107.76(3)
450.05(40)
0.15 (2)
0.03 (45)
7.80 (34)
8.14 (50)
34.14(50)
0.06 (50)
68.97(175)
2.52 (50)
52.14(50)

MaxSatz
14.01(12)
0.07(5)
171.30(3)
44.46(3)
6.82(2)
16.81(12)
258.65(11)
71.00(4)
7.18(40)
0.14(2)
0.03(45)
7.78(34)
1.25(50)
6.94(50)
0.02(50)
22.72(180)
1.92(50)
40.27(50)

Table 1: Evaluation rules benchmarks MAX-SAT Evaluation 2006.
7.3 Comparison MaxSatz Solvers
first experiment, performed compare MaxSatz state-of-the-art
Max-SAT solvers, solved sets 100 random Max-2SAT instances 50, 100 150
variables; number clauses ranged 400 4500 50 variables, 400
1000 100 variables, 300 650 150 variables. results solving
instances BF, AGN, AMP, Lazy, toolbar, MaxSolver, MaxSatz shown
Figure 11. Along horizontal axis number clauses, along vertical axis
mean time, seconds, needed solve instance set. solver needed
much time solve instances point, stopped corresponding point
shown figure. 50 variable instances, BF one point
figure (for 400 clauses); 100 variable instances, BF AMP one
345

fiLi, Manya & Planes

point figure (for 400 clauses). version MaxSolver used limits number
clauses 1000 instances solved. ran instances 1000 clauses.
see dramatic differences performance MaxSatz rest solvers
Figure 11. hardest instances, MaxSatz two orders magnitude faster
second best performing solvers (UP). instances, MaxSatz needs 1 second
solve instance solvers MaxSolver toolbar able solve
instances 10,000 seconds.
second experiment, solved random Max-3SAT instances instead random
Max-2SAT instances. results obtained shown Figure 12. consider
AGN solve Max-2SAT instances. solved instances 50, 70
100 variables; number clauses ranged 500 1200 50 variables, 500
1000 70 variables, 450 800 100 variables. 70 variables, AMP
one point figure (for 500 clauses) BF slow. 100 variables,
compared two best solvers. again, observe dramatic differences
performance profile MaxSatz rest solvers. Particularly remarkable
differences MaxSatz toolbar (the second best performing solver Max3SAT), see MaxSatz 1,000 times faster toolbar hardest
instances.
third experiment, considered Max-Cut problem graphs 50 vertices
number edges ranging 200 700. Figure 13 shows results obtained. BF
one point figure (for 200 edges). MaxSolver solved instances 500 edges
(1000 clauses). observe MaxSatz superior rest solvers.
fourth experiment, considered 3-coloring problem graphs 24
60 vertices, density edges ranging 20% 90%. AGN considered
solve Max-2SAT instances. 60 vertices, compared three
best solvers, MaxSolver different version limiting number clauses
instance solved. Figure 14 shows comparative results different solvers.
MaxSatz best performing solver, MaxSolver substantially better
rest solvers.

Max-Cut - 50 nodes
10000

time (log scale)

1000
100
BF
AMP
AGN
Lazy
toolbar
MaxSolver

MaxSatz

10
1
0.1

0.01
200 300 400 500 600 700
number edges

Figure 13: Experimental results Max-Cut
346

fiNew Inference Rules Max-SAT

Max-2SAT - 50 variables
10000

time (log scale)

1000
100
10

BF
AMP
AGN
Lazy
toolbar
MaxSolver

MaxSatz

1
0.1
0.01
0.001
1000 2000 3000 4000
number clauses
Max-2SAT - 100 variables
100000

time (log scale)

10000
1000
100

BF
AMP
AGN
Lazy
toolbar
MaxSolver

MaxSatz

10
1
0.1

0.01
400 500 600 700 800 900 1000
number clauses
Max-2SAT - 150 variables
100000
10000
time (log scale)

1000
100
10

BF
AMP
AGN
Lazy
toolbar
MaxSolver

MaxSatz

1
0.1
0.01
0.001
1e-04
300

400
500
600
number clauses

Figure 11: Experimental results 50-variable, 100-variable 150-variable random Max2SAT instances.

347

fiLi, Manya & Planes

Max-3SAT - 50 variables
10000

time (log scale)

1000
100
BF
AMP
Lazy
toolbar
MaxSolver

MaxSatz

10
1
0.1
600
800
1000
number clauses

1200

Max-3SAT - 70 variables

time (log scale)

10000

1000

100
AMP
Lazy
toolbar
MaxSolver

MaxSatz

10

1
500 600 700 800 900 1000
number clauses
Max-3SAT - 100 variables
100000

time (log scale)

10000
1000
100
10
1
0.1

toolbar
MaxSatz

0.01
500
600
700
number clauses

800

Figure 12: Experimental results 50-variable, 70-variable 100-variable random Max3SAT instances.

348

fiNew Inference Rules Max-SAT

Graph 3-coloring 24 nodes
10000

time (log scale)

1000
100
10
1

BF
AMP
Lazy
MaxSolver
toolbar

MaxSatz

0.1
0.01
0.001
1e-04

20 30 40 50 60 70 80 90
% edges
Graph 3-coloring 60 nodes
100000

time (log scale)

10000
1000
100
10

MaxSolver

MaxSatz

1

20 30 40 50 60 70 80 90
% edges

Figure 14: Experimental results Graph 3-Coloring

fifth experiment, compared Max-SAT solvers benchmarks submitted
Max-SAT Evaluation 2006. Solvers ran conditions evaluation.
Table 2, first column name benchmark set, second column
number instances set, rest columns display average time, seconds,
needed solver solve instance within time limit 30 minutes (the number
instances solved within time limit brackets). dash means corresponding
solver cannot solve set instances. clear MaxSatz best performing
solver sets.

8. Related Work
simplest method compute lower bound consists counting number
clauses unsatisfied current partial assignment (Borchers & Furman, 1999). One step
forward incorporate underestimation number clauses become
unsatisfied current partial assignment extended complete assignment.
basic method defined Wallace Freuder (1996):
349

fi#Instances
12
7
6
4
2
12
11
4
40
5
45
48
50
50
50
180
50
50

BF
(0)
6.06 (1)
(0)
(0)
(0)
605.44(2)
(0)
(0)
(0)
0.21 (1)
0.02 (21)
8.53 (30)
0.14 (10)
0.08 (10)
1.92 (3)
357.65(28)
170.49(22)
4.07 (16)

AMP
545.81(1)
1.95 (3)
636.04(1)
394.17(2)
197.15(1)
107.79(8)
563.19(1)
428.18(1)
(0)
0.13 (1)
0.03 (45)
38.44(30)
143.23(11)
91.93(12)
514.02(44)
439.54(76)
202.18(50)
168.00(25)

AGN
856.65(8)
32.70(5)
159.99(1)
92.90(2)
39.36(1)
16.11(8)
72.35(2)
909.32(3)
1742.79(3)
12.70(2)
185.69(30)
126.34(28)
6.34 (50)
99.70(108)
-

toolbar
470.23(12)
42.84(5)
145.84(2)
11.07(2)
255.39(2)
235.60(11)
568.09(7)
234.89(3)
736.34(18)
5.72 (2)
35.35(44)
4.14(27)
244.05(34)
262.30(26)
2.01 (50)
178.23(116)
10.19 (50)
361.95(43)

Lazy
159.28 (12)
13.23 (4)
265.35 (2)
13.50 (2)
348.75 (2)
259.33 (10)
956.54 (5)
410.53 (3)
1027.21 (7)
0.05 (1)
278.58 (26)
10.48 (25)
273.44 (22)
217.12 (17)
26.44 (50)
85.08 (87)
69.72 (50)
242.40 (28)

MaxSolver
380.09(2)
41.58(3)
(0)
1.34 (1)
(0)
14.00(8)
283.34(2)
138.32(1)
(0)
570.68(2)
0.06 (45)
0.20 (20)
532.47(16)
168.42(18)
81.82(50)
308.58(73)
66.34(49)
139.03(22)


629.85(9)
7.19 (5)
294.89(2)
29.42(2)
615.54(2)
140.23(9)
812.47(5)
538.10(3)
623.03(13)
0.86 (2)
0.31 (45)
19.65(25)
192.34(48)
75.57(39)
0.94 (50)
166.29(149)
60.50(50)
166.76(37)

Table 2: Experimental results benchmarks MAX-SAT Evaluation 2006.

MaxSatz
14.01(12)
0.07(5)
171.30(3)
44.46(3)
6.82 (2)
16.81(12)
258.65(11)
71.00(4)
7.18(40)
0.14(2)
0.03 (45)
7.78 (34)
1.25 (50)
6.94 (50)
0.02 (50)
22.72(180)
1.92(50)
40.27(50)

350

Li, Manya & Planes

Set Name
MAXCUT brock
MAXCUT c-fat
MAXCUT hamming
MAXCUT johnson
MAXCUT keller
MAXCUT DIMACS p hat
MAXCUT san
MAXCUT sanr
MAXCUT max cut
MAXCUT SPINGLASS
MAXONE
RAMSEY ram k
MAX2SAT 100VARS
MAX2SAT 140VARS
MAX2SAT 60VARS
MAX2SAT DISCARDED
MAX3SAT 40VARS
MAX3SAT 60VARS

fiNew Inference Rules Max-SAT

LB() = #emptyClauses() +
x

X

occurs

min(ic(x), ic(x))


CNF formula associated current partial assignment, ic(x) (ic(x))
inconsistency count x (x) number unit clauses contain x (x).
underestimation lower bound improved applying binary clauses
Directional Arc Consistency (DAC) count defined Wallace (1995) Max-CSP.
DAC count value variable x number variables inconsistent
value x. example, contains clauses x y, x y, x y, value
0 x inconsistent y. Note value 0 inconsistent x.
two inconsistencies disjoint cannot summed. Wallace defined direction
x y, inconsistency value 0 x counted. defining
direction every pair variables sharing constraint, one computes DAC count
values x checking variables direction x defined.
underestimation considering DAC count Wallace follows:

x

X

occurs

(min(ic(x), ic(x)) + min(dac(x), dac(x))


dac(x) (dac(x)) DAC count value 1(0) x. Wallace statically defined
directions, dac(x) dac(x) computed preprocessing step every
x need recomputed search. improved Larrosa, Meseguer
Schiex (1999) introducing reversible DAC, searches better directions
obtain better lower bound every node search tree. improvement DAC
counts additional incorporation inconsistencies contributed disjoint subsets
variables, based particular variable partitions (Larrosa & Meseguer, 2002).
Inconsistent DAC counts deal unit binary clauses. Lower bounds dealing
longer clauses include star rule (Shen & Zhang, 2004; Alsinet et al., 2004) (Li
et al., 2005).
star rule, underestimation lower bound number disjoint
inconsistent subformulas form {l1 , . . . , lk , l1 lk }. star rule, k = 1,
equivalent inconsistency counts Wallace Freuder.
subsumes inconsistent count method based unit clauses star rule.
effectiveness producing good lower bound illustrated following example:
let CNF formula containing clauses x1 , x1 x2 , x1 x3 , x2 x3 x4 , x5 , x5 x6 , x5
x7 , x6 x7 x4 . easily detects inconsistent subset 8 clauses 7 variables,
time linear size formula. Note subset detected
lower bounds described above, except variable partition based approach Larrosa
Meseguer (2002) case 7 variables partition.
mention two lower bound computation methods. One called LB4
defined Shen Zhang (2004). similar restricted Max-2SAT instances
using static variable ordering. Another based linear programming
defined Xing Zhang (2005).
Regin et al. (2001) suggested use arc consistency, instead unit propagation, detect
disjoint inconsistent subsets constraints weighted constraint networks. However,
351

fiLi, Manya & Planes

best knowledge, idea incorporated lower bound computation
method implemented Constraint Programming community.
good lower bound computation method dramatic impact performance
Max-SAT solver. Another approach speed Max-SAT solver consists applying
inference rules transform Max-SAT instance equivalent simpler Max-SAT
instance . Inference rules proven useful practice include: (i) pure
literal rule (Alsinet et al., 2003b; Xing & Zhang, 2004; Li et al., 2005; Zhang et al., 2003);
(ii) dominating unit clause rule, first proposed Niedermeier Rossmanith (2000),
later applied several solvers (Alsinet et al., 2004; Xing & Zhang, 2004; Li et al.,
2005); (iii) almost common clause rule, first proposed Bansal Raman (1999)
restated Rule 1 paper. rule extended weighted Max-SAT byAlsinet
et al. (2004); called neighborhood resolution Larrosa Heras (2005); used
preprocessing technique Alsinet et al. (2004), Shen Zhang (2005), Li et al. (2005);
(iv) complementary unit clause rule (Niedermeier & Rossmanith, 2000), restated Rule
2 paper; (v) coefficient-determining unit propagation rule (Xing & Zhang,
2005) based integer programming.
inference rules presented paper simplify Max-SAT formula allow
improve lower bound computation, since transform Max-SAT formula
simpler equivalent formula containing empty clauses. soundness
(i.e., fact transform formula equivalent one) proved several
ways, including (i) checking possible variable assignments, (ii) using integer programming
done Section 4, (iii) using soft local consistency techniques defined Weighted
Constraint Networks (WCN); Max-SAT defined subcase WCN variables
Boolean unit costs used.
Soft local consistency techniques WCN based two basic equivalence preserving
transformations called projection extension (Schiex, 2000; Cooper & Schiex, 2004).
Given Max-SAT instance, projection replaces two binary clauses x x
unit clause x, Rule 1 k=2. Extension inverse operation projection
replaces unit clause x two binary clauses x x selected variable
y. projection operation rather straightforward SAT Max-SAT instance,
extension operation ingenious. see this, note Rule 3 proved
applied extension followed projection:
l1 , l1 l2 , l2 = l1 l2 , l1 l2 , l1 l2 , l2
= l1 l2 , l2 , l2
= l1 l2 , 2
Lemma 1 proved using extension followed projection:
l1 , l1 l2 = l1 l2 , l1 l2 , l1 l2
= l1 l2 , l2
extension operation cannot used unguided way may cancel
previous projection. One way guide use define ordering variables
352

fiNew Inference Rules Max-SAT

enforce directional arc consistency (Cooper, 2003; Cooper & Schiex, 2004). Directional arc
consistency allows concentrate weights variables shifting weights
earlier variables later ones given ordering. example x1 < x2 given variable
ordering, one extend unit clause x1 x1 x2 , x1 x2 , cannot extend unit clause x2
x1 x2 , x1 x2 , allowing unit clauses concentrated variable x2 . Nevertheless,
define variable ordering efficiently exploit much possible power
soft arc consistency techniques lower bound computation remains open problem.
approach inference rules Max-SAT presented paper need
predefined ordering among variables, since rule applications combining several projection extension operations entirely guided unit propagation.
projection extension operations extended constraints involving
two variables achieve high-order consistency WCN (Cooper, 2005). MaxSAT instance, extended projection extension operations stated using Rule 1
k>2. two formulas 1 2 Rule 1, replacing 1 2 projection
2 1 extension. Given unit clause x three variables x, y, z, extension
unit clause x set three variables done follows : replacing x
x x y, x x x z, x z, x z x z.
Rule 5 proved applied extending four clauses 1 ternary clauses
three variables l1 , l2 l3 , applying projection operation obtain 2 .
Larrosa et al. (2007), based logical approach, independently parallel
work, defined implemented chain resolution rule cycle resolution rule
weighted Max-SAT. two rules extensions Rules 2-RES 3-RES presented,
independently parallel work (Heras & Larrosa, 2006).
chain resolution could stated follows:


(li , mi mi+1 )1ik ,




(li li+1 , ui+1 mi+1 )1i<k ,

(l1 , u1 ),
(li li+1 , mi+1 )1i<k ,
(li li+1 , ui+1 )1i<k ,
=



(l , u
mk+1 ),
(lk , uk+1 )


k k+1
(2, mk+1 )













where, 1ik+1, ui weight corresponding clause, mi =min(u1 , u2 , . . . , ui ),
variables literals different. weight mandatory clause denoted
, subtraction extended ui =. chain resolution rule
equivalent Rule 4 applied unweighted Max-SAT. main difference
chain resolution rule weighted version Rule 4 presented Section 5.4
chain resolution shifts part weight unit clause (l1 , m1 mk+1 ),
derived weighted version Rule 4, create unit clauses (li , mi mi+1 )1<ik ,
(l1 , m1 mk+1 ) becoming (l1 , m1 m2 ).
cycle resolution rule could stated follows:
353

fiLi, Manya & Planes



(li li+1 , ui )1i<k ,
(l1 lk , uk )



=

















(l1 li , mi1 mi )2ik ,
(li li+1 , ui mi )2i<k ,
(l1 li li+1 , mi )2i<k ,
(l1 li li+1 , mi )2i<k ,
(l1 lk , uk mk ),
(l1 , mk )

















subset binary clauses cyclic structure, cycle resolution rule allows
derive unit clause. Note detection cyclic structure appears rather timeconsuming applied every node search tree 2(k-2) new ternary
clauses inserted. So, Larrosa et al. apply cycle resolution rule practice
case k=3, similar Rule 5, applied unweighted Max-SAT.
cycle resolution rule applied unweighted Max-SAT k=3 replace Rule 5
Rule 6 MaxSatz, following differences compared Rule 5 Rule 6:
application Rule 5 Rule 6 entirely based inconsistent subformulas
detected unit propagation. detection applicability Rule 5 Rule 6
easy low overhead, since inconsistent subformulas always detected
MaxSatz compute lower bound (with without Rule 5 Rule 6). Every
application Rule 5 Rule 6 allows increment lower bound 1.
cycle resolution rule needs extra detection cyclic structure, allows
derive unit clause cyclic structure. derived unit clause could
used unit propagation, possibly could allow detect inconsistent
subformula increase lower bound 1.
would interesting future research topic implement cycle resolution rule
MaxSat1234 (i.e., MaxSatz without Rule 5 Rule 6) evaluate overhead detecting
cyclic structure usefulness unit clauses ternary clauses derived
using cycle resolution rule, compare implemented solver MaxSatz.
would interesting compare chain resolution rule cycle resolution rule
weighted inference rules presented Section 5.4.
general Max-SAT resolution rule, conclusions clausal
form, defined Larrosa Heras (2005). Independently, Bonet et al. (2006, 2007)
Heras Larrosa (2006) defined version rule conclusions clausal
form. Bonet et al. (2006, 2007) proved rule complete Max-SAT. Recently,
Ansotegui et al. (2007b, 2007a) shown Max-SAT resolution many-valued CNF
formulas provides logical framework global local consistency properties defined
WCN.

9. Conclusions Future Work
One main drawbacks state-of-the-art Max-SAT solvers lack suitable
inference techniques allow detect much contradictions possible simplify
formula node search tree. Existing approaches put emphasis
computing underestimations good quality, problem underestimations
354

fiNew Inference Rules Max-SAT

contradictions computed again. Furthermore, turns
U P , one currently best performing underestimations consisting detecting
disjoint inconsistent subsets clauses CNF formula via unit propagation, still
conservative. make computation lowers incremental improve
underestimation, defined number original inference rules Max-SAT that,
based derived contradictions unit propagation, transform Max-SAT instance
equivalent Max-SAT instance easier solve. rules carefully selected
taking account applied efficiently. Since rules based
contradiction detection, particularly useful hard Max-SAT instances
containing many contradictions.
aim finding powerful inference rules practice,
developed new Max-SAT solver, called MaxSatz, incorporates rules,
performed experimental investigation. results comparing MaxSatz inference
rules MaxSatz without inference rules provide empirical evidence usefulness
rules making lower bound computation incremental improving
quality lower bounds. results comparing MaxSatz large selection
solvers available time submitting paper provide empirical evidence
MaxSatz, least instances solved, faster solvers. observed gains
several orders magnitude hardest instances. Interestingly, benchmarks
used, second best solver generally different: Max-2SAT, toolbar Max3SAT, MaxSolver Max-Cut, MaxSolver graph 3-coloring. So, MaxSatz
robust rest solvers. worth mentioning MaxSatz, enhanced
lower bound based failed literal detection (Li et al., 2006), best performing
solver unweighted Max-SAT instances Max-SAT Evaluation 2006. second
third best performing solvers were, respectively, improved versions toolbar Lazy11 .
future work plan study orderings unit clauses unit propagation
maximize application inference rules, define new inference rules ternary
clauses. extending results paper weighted Max-SAT,
suitable modeling problems maximum clique, set covering combinatorial
auctions, well constraint satisfaction problems hard instances Model RB (Xu,
Boussemart, Hemery, & Lecoutre, 2005; Xu & Li, 2006). adapting results
paper partial Max-SAT solvers developed Argelich Manya (2005, 2006,
2007).

Acknowledgments
Research partially supported projects TIN2004-07933-C03-03 TIN2006-15662-C0202 funded Ministerio de Educacion Ciencia. first author partially supported National 973 Program China Grant No. 2005CB321900. second
author supported grant Ramon Cajal. Finally, would thank referees
detailed comments suggestions.
11. See http://www.iiia.csic.es/maxsat06 details. Note results Max-SAT Evaluation
2006 compared results paper obtained cluster
conditions.

355

fiLi, Manya & Planes

References
Alber, J., Gramm, J., & Niedermeier, R. (2001). Faster exact algorithms hard problems:
parameterized point view. Discrete Mathematics, 229 (13), 327.
Alsinet, T., Manya, F., & Planes, J. (2003a). Improved branch bound algorithms
Max-2-SAT weighted Max-2-SAT. Proceedings Catalonian Conference
Artificial Intelligence (CCIA-03), P. Mallorca, Spain, Vol. 100 Frontiers
Artificial Intelligence Applications, pp. 435442. IOS Press.
Alsinet, T., Manya, F., & Planes, J. (2003b). Improved branch bound algorithms
Max-SAT. Proceedings 6th International Conference Theory
Applications Satisfiability Testing (SAT-03), Portofino, Italy, pp. 408415.
Alsinet, T., Manya, F., & Planes, J. (2004). Max-SAT solver lazy data structures. Proceedings 9th Ibero-American Conference Artificial Intelligence
(IBERAMIA-04), Puebla, Mexico, LNCS 3315, pp. 334342. Springer.
Alsinet, T., Manya, F., & Planes, J. (2005). Improved exact solver weighted MaxSAT. Proceedings 8th International Conference Theory Applications
Satisfiability Testing (SAT-05), St. Andrews, Scotland, LNCS 3569, pp. 371377.
Springer.
Ansotegui, C., Bonet, M. L., Levy, J., & Manya, F. (2007a). Inference rules high-order
consistency weighted CSP. Proceedings 22nd National Conference
Artificial Intelligence (AAAI-07), Vancouver, Canada, pp. 167172. AAAI Press.
Ansotegui, C., Bonet, M. L., Levy, J., & Manya, F. (2007b). logic behind weighted CSP.
Proceedings 20th International Joint Conference Artificial Intelligence
(IJCAI-07), Hyderabad, India, pp. 3237. AAAI Press.
Argelich, J., & Manya, F. (2005). Solving over-constrained problems SAT technology.
Proceedings 8th International Conference Theory Applications
Satisfiability Testing (SAT-05), St. Andrews, Scotland, LNCS 3569, pp. 115. Springer.
Argelich, J., & Manya, F. (2006). Exact Max-SAT solvers over-constrained problems.
Journal Heuristics, 12 (45), 375392.
Argelich, J., & Manya, F. (2007). Partial Max-SAT solvers clause learning. Proceedings 10th International Conference Theory Applications Satisfiability
Testing (SAT-07), Lisbon, Portugal, LNCS 4501, pp. 2840. Springer.
Bansal, N., & Raman, V. (1999). Upper bounds MaxSat: improved. Proceedings 10th International Symposium Algorithms Computation (ISAAC-99),
Chennai, India, LNCS 1741, pp. 247260. Springer.
Beame, P., Kautz, H., & Sabharwal, A. (2003). Understanding power clause learning.
Proceedings 18th International Joint Conference Artificial Intelligence
(IJCAI-03), Acapulco, Mexico, pp. 9499. Morgan Kaufman.
Bonet, M. L., Levy, J., & Manya, F. (2006). complete calculus Max-SAT. Proceedings 9th International Conference Theory Applications Satisfiability
Testing (SAT-06), Seattle, USA, LNCS 4121, pp. 240251. Springer.
356

fiNew Inference Rules Max-SAT

Bonet, M. L., Levy, J., & Manya, F. (2007). Resolution Max-SAT. Artificial Intelligence,
171, 606618.
Borchers, B., & Furman, J. (1999). two-phase exact algorithm MAX-SAT weighted
MAX-SAT problems. Journal Combinatorial Optimization, 2, 299306.
Boros, E., & Hammer, P. (2002). Pseudo-Boolean optimization. Discrete Applied Mathematics, 123, 155225.
Cooper, M. C. (2003). Reduction operations fuzzy valued constraint satisfaction. Fuzzy
Sets Systems, 134, 311342.
Cooper, M. C. (2005). High-order consistency valued constraint satisfaction. Constraints,
10, 283305.
Cooper, M. C., & Schiex, T. (2004). Arc consistency soft constraints. Artificial Intelligence, 154 (12), 199227.
Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2001). Introduction Algorithms
(second edition). MIT Press.
Davis, M., Logemann, G., & Loveland, D. (1962). machine program theorem-proving.
Communications ACM, 5, 394397.
Davis, M., & Putnam, H. (1960). computing procedure quantification theory. Journal
ACM, 7 (3), 201215.
de Givry, S., Larrosa, J., Meseguer, P., & Schiex, T. (2003). Solving Max-SAT weighted
CSP. Proceedings 9th International Conference Principles Practice
Constraint Programming (CP-03), Kinsale, Ireland, LNCS 2833, pp. 363376.
Springer.
de Givry, S., Zytnicki, M., Heras, F., & Larrosa, J. (2005). Existential arc consistency: Getting closer full arc consistency weighted csps. Proceedings 19th International Joint Conference Artificial Intelligence (IJCAI-05), Edinburgh, Scotland,
pp. 8489.
Freeman, J. W. (1995). Improvements Propositional Satisfiability Search Algorithms.
Ph.D. thesis, Department Computer Information Science, University Pennsylvania, PA, USA.
Goldberg, E., & Novikov, Y. (2001). BerkMin: fast robust SAT solver. Proceedings
Design, Automation Test Europe (DATE-02), Paris, France, pp. 142149.
IEEE Computer Society.
Heras, F., & Larrosa, J. (2006). New inference rules efficient Max-SAT solving. Proceedings 21st National Conference Artificial Intelligence (AAAI-06), Boston,
USA. AAAI Press.
Huang, W. Q., & Jin, R. C. (1997). Solar: learning human algorithm solving
SAT. Science China (Series E), 27 (2), 179186.
Jeroslow, R. G., & Wang, J. (1990). Solving propositional satisfiability problems. Annals
Mathematics Artificial Intelligence, 1, 167187.
357

fiLi, Manya & Planes

Larrosa, J., & Heras, F. (2005). Resolution Max-SAT relation local consistency
weighted CSPs. Proceedings 19th International Joint Conference Artificial Intelligence (IJCAI-05), Edinburgh, Scotland, pp. 193198. Morgan Kaufmann.
Larrosa, J., Heras, F., & de Givry, S. (2007). logical approach efficient Max-SAT
solving. Artificial Intelligence, (in press).
Larrosa, J., & Meseguer, P. (2002). Partition-based lower bound Max-CSP. Constraints,
7 (34), 407419.
Larrosa, J., Meseguer, P., & Schiex, T. (1999). Maintaining reversible DAC Max-CSP.
Artificial Intelligence, 107 (1), 149163.
Li, C. M. (1999). constraint-based approach narrow search trees satisfiability.
Information Processing Letters, 71, 7580.
Li, C. M., & Anbulagan (1997a). Heuristics based unit propagation satisfiability
problems. Proceedings 15th International Joint Conference Artificial
Intelligence (IJCAI-97), Nagoya, Japan, pp. 366371. Morgan Kaufmann.
Li, C. M., & Anbulagan (1997b). Look-ahead versus look-back satisfiability problems.
Proceedings 3rd International Conference Principles Constraint Programming (CP-97), Linz, Austria, LNCS 1330, pp. 341355. Springer.
Li, C. M., & Huang, W. Q. (2005). Diversification determinism local search
satisfiability. Proceedings 8th International Conference Theory Applications Satisfiability Testing (SAT-05), St. Andrews, Scotland, LNCS 3569, pp.
158172. Springer.
Li, C. M., Manya, F., & Planes, J. (2005). Exploiting unit propagation compute lower
bounds branch bound Max-SAT solvers. Proceedings 11th International Conference Principles Practice Constraint Programming (CP-05),
Sitges, Spain, LNCS 3709, pp. 403414. Springer.
Li, C. M., Manya, F., & Planes, J. (2006). Detecting disjoint inconsistent subformulas
computing lower bounds Max-SAT. Proceedings 21st National Conference
Artificial Intelligence (AAAI-06), Boston, USA, pp. 8691. AAAI Press.
Marques-Silva, J. P., & Sakallah, K. A. (1999). GRASP: search algorithm propositional
satisfiability. IEEE Transactions Computers, 48 (5), 506521.
Niedermeier, R., & Rossmanith, P. (2000). New upper bounds maximum satisfiability.
Journal Algorithms, 36, 6388.
Regin, J. C., Petit, T., Bessiere, C., & Puget, J. F. (2001). New lower bounds constraint
violations over-constrained problems. 7th International Conference Principles Practice Constraint Programming (CP-01), Paphos, Cyprus, LNCS 2239,
pp. 332345. Springer.
Schiex, T. (2000). Arc consistency soft constraints. Proceedings 6th International Conference Principles Constraint Programming (CP-00), Singapore,
LNCS 1894, pp. 411424. Springer.
358

fiNew Inference Rules Max-SAT

Shen, H., & Zhang, H. (2004). Study lower bound functions max-2-sat. Proceedings
National Conference Artificial Intelligence (AAAI-04), San Jose, USA, pp.
185190. AAAI Press.
Shen, H., & Zhang, H. (2005). Improving exact algorithms max-2-sat. Annals Mathematics Artificial Intelligence, 44, 419436.
Wallace, R. J. (1995). Directed arc consistency preprocessing. Constraint Processing,
Selected Papers, LNCS 923, pp. 121137. Springer.
Wallace, R. J., & Freuder, E. (1996). Comparative studies constraint satisfaction
Davis-Putnam algorithms maximum satisfiability problems. Johnson, D., &
Trick, M. (Eds.), Cliques, Coloring Satisfiability, Vol. 26, pp. 587615. American
Mathematical Society.
Xing, Z., & Zhang, W. (2004). Efficient strategies (weighted) maximum satisfiability.
Proceedings 10th International Conference Principles Practice Constraint Programming (CP-04), Toronto, Canada, LNCS 3258, pp. 690705. Springer.
Xing, Z., & Zhang, W. (2005). efficient exact algorithm (weighted) maximum satisfiability. Artificial Intelligence, 164 (2), 4780.
Xu, K., Boussemart, F., Hemery, F., & Lecoutre, C. (2005). simple model generate
hard satisfiable instances. Proceedings 19th International Joint Conference
Artificial Intelligence (IJCAI-05), Edinburgh, Scotland, pp. 337342.
Xu, K., & Li, W. (2006). Many hard examples exact phase transitions. Theoretical
Computer Science, 355, 291302.
Zhang, H. (1997). SATO: efficient propositional prover. Proceedings Conference
Automated Deduction (CADE-97), pp. 272275.
Zhang, H., Shen, H., & Manya, F. (2003). Exact algorithms MAX-SAT. Electronic
Notes Theoretical Computer Science, 86 (1).
Zhang, L., Madigan, C., Moskewicz, M., & Malik, S. (2001). Efficient conflict driven learning
Boolean satisfiability solver. International Conference Computer Aided
Design (ICCAD-01), San Jose, USA, pp. 279285.

359


