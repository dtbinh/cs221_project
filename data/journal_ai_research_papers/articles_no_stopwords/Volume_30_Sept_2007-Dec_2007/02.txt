Journal Artificial Intelligence Research 30 (2007) 101-132

Submitted 10/05; published 9/07

Planning Spectrum One, Two, Three, Infinity
Marco Pistore

pistore@dit.unitn.it

Department Information Communication Technology
University Trento
Via Sommarive 14, 38050 Povo (Trento), Italy

Moshe Y. Vardi

vardi@cs.rice.edu

Department Computer Science
Rice University
6100 S. Main Street, Houston, Texas

Abstract
Linear Temporal Logic (LTL) widely used defining conditions execution
paths dynamic systems. case dynamic systems allow nondeterministic
evolutions, one specify, along LTL formula , paths
required satisfy formula. Two extreme cases universal interpretation A.,
requires formula satisfied execution paths, existential
interpretation E., requires formula satisfied execution path.
LTL applied definition goals planning problems nondeterministic
domains, two extreme cases restrictive. often impossible develop plans
achieve goal nondeterministic evolutions system, weak
require goal satisfied execution.
paper explore alternative interpretations LTL formula
extreme cases. define new language permits arbitrary combination
E quantifiers, thus allowing, instance, require finite execution
extended execution satisfying LTL formula (AE.),
finite execution whose extensions satisfy LTL formula (EA.). show
eight combinations path quantifiers relevant, corresponding alternation
quantifiers length one (A E), two (AE EA), three (AEA EAE),
infinity ((AE) (EA) ). present planning algorithm new language
based automata-theoretic approach, study complexity.

1. Introduction
automated task planning (Fikes & Nilsson, 1971; Penberthy & Weld, 1992; Ghallab, Nau,
& Traverso, 2004), given description dynamic domain basic actions
performed it, given goal defines success condition achieved, one
find suitable plan, is, description actions executed domain
order achieve goal. Classical planning concentrates called reachability
goals, is, goals define set final desired states reached. Quite often
practical applications require plans deal goals general sets
final states. Several planning approaches recently proposed, temporal logic
formulas used goal language, thus allowing goals define conditions
whole plan execution paths, i.e., sequences states resulting execution
plans (Bacchus & Kabanza, 1998, 2000; Calvanese, de Giacomo, & Vardi, 2002; Cerrito &
c
2007
AI Access Foundation. rights reserved.

fiPistore & Vardi

Mayer, 1998; Dal Lago, Pistore, & Traverso, 2002; de Giacomo & Vardi, 1999; Kvarnstrom
& Doherty, 2001; Pistore & Traverso, 2001). approaches use Linear Temporal
Logic (LTL) (Emerson, 1990) goal language. LTL allows one express reachability
goals (e.g., F q reach q), maintainability goals (e.g., G q maintain q), well goals
combine reachability maintainability requirements (e.g., F G q reach set
states q maintained), Boolean combinations goals.
planning nondeterministic domains (Cimatti, Pistore, Roveri, & Traverso, 2003;
Peot & Smith, 1992; Warren, 1976), actions allowed different outcomes,
possible know planning time different possible outcomes actually
take place. Nondeterminism action outcome necessary modeling realistic way
several practical domains, ranging robotics autonomous controllers two-player
games.1 instance, realistic robotic application one take account
actions pick object might result failure (e.g., object slips
robots hand). consequence nondeterminism execution plan may lead
one possible execution path. Therefore, one distinguish whether given
goal satisfied possible execution paths (in case speak strong
planning), possible execution paths (weak planning). case
LTL goal , strong planning corresponds interpreting formula universal
way, A., weak planning corresponds interpreting existential way,
E..
Weak strong plans two extreme ways satisfying LTL formula. nondeterministic planning domains, might impossible achieve goals strong way:
instance, robotic application might impossible fulfill given task objects
keep slipping robots hand. hand, weak plans unreliable,
since achieve goal overly optimistic assumptions outcomes
action executions.
case reachability goals, strong cyclic planning (Cimatti et al., 2003; Daniele,
Traverso, & Vardi, 1999) shown provide viable compromise weak
strong planning. Formally, plan strong cyclic possible partial execution
plan always extended execution reaches goal state. Strong cyclic
planning allows plans encode iterative trial-and-error strategies, pick
object succeed. execution strategies may loop forever case
action pick object continuously fails, failure achieving goal
unfair execution usually acceptable. Branching-time logics CTL CTL* allow
expressing goals take account nondeterminism. Indeed, Daniele et al. (1999)
show encode strong cyclic reachability goals CTL formulas. However, CTL
CTL* path quantifiers interleaved temporal operators, making difficult
extend encoding strong cyclic planning proposed Daniele et al. (1999) generic
temporal goals.
paper define new logic allows exploring different degrees
LTL formula satisfied exist strong goal A. weak goal
E.. consider logic formulas form ., LTL formula
path quantifier generalizes E quantifiers used strong weak planning.
1. See work Ghallab et al. (2004) deeper discussion fundamental role nondeterminism
planning problems practical applications.

102

fiThe Planning Spectrum One, Two, Three, Infinity

path quantifier (finite infinite) word alphabet {A, E}. path quantifier
seen definition two-player game selection outcome action
execution. Player (corresponding symbol A) chooses action outcomes order
make goal fail, player E (corresponding symbol E) chooses action outcomes
order satisfy goal . turn, active player controls outcome action
execution finite number actions passes control player.2
say plan satisfies goal . player E winning strategy, namely if,
possible moves player A, player E always able build execution path
satisfies LTL formula .
Different path quantifiers define different alternations turns players E.
instance, goal A. require formula satisfied independently
hostile player chooses outcomes actions, is, ask strong plan.
goal E. require formula satisfied action outcomes chosen
friendly player E, is, ask weak plan. goal AE. require
every plan execution led player extended player E successful execution
satisfies formula ; case reachability goal, corresponds asking
strong cyclic solution. goal EA. require that, initial set actions
controlled player E, guarantee formula satisfied independently
player choose outcome following actions. final example,
goal (AE) . = AEAEA . require formula satisfied executions
player E possibility controlling action outcome infinite number
times.
Path quantifiers define arbitrary combinations turns players E,
hence different degrees satisfying LTL goal. show, however, that, rather surprisingly, finite number alternatives exist strong weak planning:
eight canonical path quantifiers give rise plans different strength, every
path quantifier equivalent canonical one. canonical path quantifiers correspond
games length one (A E), two (AE EA), three (AEA EAE),
games defining infinite alternation players E ((AE) (EA) ).
show that, case reachability goals = F q, canonical path quantifiers
collapse. three different degrees solution possible, corresponding weak
(E. F q), strong (A. F q), strong cyclic (AE. F q) planning.
Finally, present planning algorithm new goal language study
complexity. algorithm based automata-theoretic approach (Emerson & Jutla,
1988; Kupferman, Vardi, & Wolper, 2000): planning domains goals represented
suitable automata, planning reduced problem checking whether given
automaton nonempty. proposed algorithm time complexity doubly
exponential size goal formula. known planning problem
2EXPTIME-complete goals form A. (Pnueli & Rosner, 1990), hence
complexity algorithm optimal.
structure paper follows. Section 2 present preliminaries
automata theory temporal logics. Section 3 define planning domains
plans. Section 4 define AE-LTL, new logic path quantifier, study basic
2. path quantifier finite word, player last turn chooses action outcome
rest infinite execution.

103

fiPistore & Vardi

properties. Section 5 present planning algorithm AE-LTL, Section 6
apply new logic particular cases reachability maintainability goals.
Section 7 make comparisons related works present concluding remarks.

2. Preliminaries
section introduces preliminaries automata theory temporal logics.
2.1 Automata Theory
Given nonempty alphabet , infinite word infinite sequence 0 , 1 , 2 , . . .
symbols . Finite state automata proposed finite structures accept
sets infinite words. paper, interested tree automata, namely finite
state automata recognize trees alphabet , rather words.
Definition 1 (tree) (leafless) tree subset N that:
root tree;
x N x ;
x , x N N, x ;
x (i+1) , x N N, x .
arity x number children, namely arity(x) = |{i : x }|. Let
N. Tree D-tree arity(x) x . -labelled tree pair (, ),
tree : . following, denote -labelled tree (, )
, let = dom( ).
Let -labelled tree. path p (possibly infinite) sequence x0 , x1 , . . . nodes
xi dom( ) xk+1 = xk ik+1 . following, denote P ( ) set
finite paths P ( ) set infinite paths . Given (finite infinite) path p,
denote (p) string (x0 ) (x1 ) , x0 , x1 , . . . sequence nodes
path p. say finite (resp. infinite) path p0 finite (resp. infinite) extension
finite path p sequence nodes p prefix sequence nodes p0 .
tree automaton automaton accepts sets trees. paper, consider
particular family tree automata, namely parity tree automata (Emerson & Jutla, 1991).
Definition 2 (parity tree automata) parity tree automaton parity index k
tuple = h, D, Q, q0 , , i, where:
finite, nonempty alphabet;
N finite set arities;
Q finite set states;
q0 Q initial state;
104

fiThe Planning Spectrum One, Two, Three, Infinity





: Q 2Q transition function, (q, , d) 2Q ;
: Q {0, . . . , k} parity mapping.
tree automaton accepts tree accepting run automaton tree.
Intuitively, parity tree automaton state q reading d-ary node
tree labeled , nondeterministically chooses d-tuple hq1 , . . . , qd (q, , d)
makes copies itself, one child node tree, state
i-th copy updated qi . run parity tree automaton accepting if, along every
infinite path, minimal priority visited infinitely often even number.
Definition 3 (tree acceptance) parity tree automaton = h, D, Q, q0 , , accepts -labelled D-tree exists accepting run r , namely exists
mapping r : Q that:
r() = q0 ;
x arity(x) = hr(x 0), . . . r(x (d1))i (r(x), (x), d);
along every infinite path x0 , x1 , . . .
infinitely many nodes xi even.

, minimal integer h (r(xi )) = h

tree automaton nonempty exists tree



accepted A.

Emerson Jutla (1991) shown emptiness parity tree automaton
decided time exponential parity index polynomial number
states.
Theorem 1 emptiness parity tree automaton n states index k
determined time nO(k) .
2.2 Temporal Logics
Formulas Linear Temporal Logic (LTL) (Emerson, 1990) built top set Prop
atomic propositions using standard Boolean operators, unary temporal operator
X (next), binary temporal operator U (until). following assume
fixed set atomic propositions Prop, define = 2Prop set subsets
Prop.
Definition 4 (LTL) LTL formulas Prop defined following grammar,
q Prop:
::= q | | | X | U
define following auxiliary operators: F = > U (eventually future )
G = F (always future ). LTL formulas interpreted infinite words
. following, write w |=LTL whenever infinite word w satisfies LTL
formula .
Definition 5 (LTL semantics) Let w = 0 , 1 , . . . infinite word let
LTL formula. define w, |=LTL , N, follows:
105

fiPistore & Vardi

w, |=LTL q iff q ;
w, |=LTL iff hold w, |=LTL ;
w, |=LTL 0 iff w, |=LTL w, |=LTL 0 ;
w, |=LTL X iff w, i+1 |=LTL ;
w, |=LTL U 0 iff j w, k |=LTL k < j
w, j |=LTL 0 .
say w satisfies , written w |=LTL , w, 0 |=LTL .
CTL* (Emerson, 1990) example branching-time logic. Path quantifiers
(for paths) E (for path) prefix arbitrary combinations linear time
operators.
Definition 6 (CTL*) CTL* formulas Prop defined following grammar,
q Prop:
::= q | | | | E
::= | | | X | U
CTL* formulas interpreted -labelled trees. following, write
whenever satisfies CTL* formula .



|=CTL*

Definition 7 (CTL* semantics) Let -labelled tree let CTL* formula.
define , x |=CTL* , x , follows:


, x |=CTL* q iff q (x);



, x |=CTL* iff hold , x |=CTL* ;



, x |=CTL* 0



, x |=CTL* iff , p |=CTL* holds infinite paths p = x0 , x1 , . . . x0 = x;



,x



iff

|=CTL* E iff
x0 = x;

, x |=CTL* , x |=CTL* 0 ;

,p

|=CTL* holds infinite path p = x0 , x1 , . . .

, p |=CTL* , p P ( ), defined follows:



, p |=CTL* iff p = x0 , x1 , . . . , x0 |=CTL* ;



, p |=CTL* iff hold , p |=CTL* ;



, p |=CTL* 0



, p |=CTL* X iff , p0 |=CTL* , p0 = x1 , x2 , . . . p = x0 , x1 , x2 , . . .;



, p |=CTL* U 0 iff j 0 , pk |=CTL* 0 k < j
, pj |=CTL* 0 , pi = xi , xi+1 , . . . p = x0 , x1 , . . ..

iff

, p |=CTL* , p |=CTL* 0 ;

106

fiThe Planning Spectrum One, Two, Three, Infinity

put_B_on_A


B

C

B


put_C_on_B
C

C
B


Figure 1: possible scenario blocks-world domain.
say



satisfies CTL* formula , written



|=CTL* ,

, |=CTL* .

following theorem states possible build tree automaton accepts
trees satisfying CTL* formula. tree automaton number states
doubly exponential parity index exponential length formula.
proof theorem given Emerson Jutla (1988).
Theorem 2 Let CTL* formula, let N finite set arities. One
build parity tree automaton AD
accepts exactly -labelled D-trees satisfy .
2
automaton AD
2
formula .

O(||)

states parity index 2O(||) , || length

3. Planning Domains Plans
(nondeterministic) planning domain (Cimatti et al., 2003) expressed terms
set states, one designated initial state, set actions, transition
function describing (the execution of) action leads one state possibly many
different states.
Definition 8 (planning domain) planning domain tuple = h, 0 , A, Ri where:
finite set states;
0 initial state;
finite set actions;
R : 2 transition relation.
require 0 0 R(, a).
assume states ordered, write R(, a) = h1 , 2 , . . . , n whenever
R(, a) = {1 , 2 , . . . , n } 1 < 2 < < n .
Example 1 Consider blocks-world domain consisting set blocks, initially
table, stacked top order build towers (see
Figure 1).
states domain possible configurations blocks: case
three blocks 13 states, corresponding blocks table (1 configuration),
2-block tower remaining block table (6 configurations), 3-block tower
(6 possible configurations). assume initially blocks table.
107

fiPistore & Vardi

actions domain put X , put X table, wait, X
two (different) blocks. Actions put X put X table possible
blocks top X (otherwise could pick X). addition, action
put X requires blocks top (otherwise could put X
top ).
assume outcome action put X nondeterministic: indeed, trying
put block top tower may fail, case tower destroyed. action
wait nondeterministic: possible table bumped towers
destroyed.
plan guides evolution planning domain issuing actions executed.
case nondeterministic domains, conditional plans (Cimatti et al., 2003; Pistore &
Traverso, 2001) required, is, next action issued plan may depend
outcome previous actions. consider general definition plans:
plan mapping sequence states, representing past history domain
evolution, action executed.
Definition 9 (plan) plan partial function : + * that:
(w ) = a, 0 R(, a) 0 ;
(w ) = a, 0 R(, a) iff w 0 dom();
w dom() w 6= , w dom();
() defined iff = 0 initial state domain.
conditions previous definition ensure plan defines action executed
exactly finite paths w + reached executing plan initial
state domain.
Example 2 possible plan blocks-world domain Example 1 represented Figure 2. remark importance plans action executed depends
whole sequence states corresponding past history evolution. Indeed,
according plan Figure 2, two different actions put C put C table
performed state block B top A, depending past history.
Since consider nondeterministic planning domains, execution action may
lead different outcomes. Therefore, execution plan planning domain
described (A)-labelled tree. Component label tree corresponds
state planning domain, component describes action executed
state.
Definition 10 (execution tree) execution tree domain plan
(A)-labelled tree defined follows:


() = (0 , a0 ) 0

initial state domain a0 = (0 );
108

fiThe Planning Spectrum One, Two, Three, Infinity

w

(w)

ABC

put B

B
ABC AC

put C B

B
ABC AC

C
B


B
ABC AC

C
B


B
AC

B
ABC AC

C
B


B
AC

put C table

history

put B table

ABC

wait
wait

Figure 2: plan blocks-world domain.
p = x0 , . . . , xn P ( ) (p) = (0 , a0 ) (1 , a1 ) (n , ), R(n , ) =
0
h00 , . . . , d1
i, every 0 < following conditions hold: xn dom( )
(xn i) = (i0 , a0i ) a0i = (0 1 n i0 ).
planning problem consists planning domain goal g defines set
desired behaviors. following, assume goal g defines set execution
trees, namely execution trees exhibit behaviors described goal (we say
execution trees satisfy goal).
Definition 11 (planning problem) planning problem pair (D, g),
planning domain g goal. solution planning problem (D, g) plan
execution tree satisfies goal g.

4. Logic Path Quantifiers
section define new logic based LTL extends
possibility defining conditions sets paths satisfy LTL property.
start motivating logic necessary defining planning goals.
Example 3 Consider blocks-world domain introduced previous section. Intuitively, plan Example 2 solution goal building tower consisting
blocks A, B, C destroying it. goal easily formulated LTL
109

fiPistore & Vardi

formula:
1 = F ((C B B table) F (C table B table table)).
Notice however that, due nondeterminism outcome actions, plan may
fail satisfy goal. possible, instance, action put C B fails
tower destroyed. case, plan proceeds performing wait actions, hence
tower never finished. Formally, plan solution goal requires
path execution structure satisfies LTL formula 1 .
Clearly, better ways achieve goal building tower destroying
it: fail building tower, rather giving up, restart building keep
trying succeed. strategy allows achieving goal paths:
keep destroying tower try build achieve goal.
see, logic path quantifiers going define allow us formalize
mean paths.
Consider following LTL formula:
2 = F G ((C B B table).
formula requires building tower maintaining it. case two possible
ways fail achieve goal. fail build tower; or, built, fail
maintain (remember wait action may nondeterministically lead destruction
tower). Similarly case formula 1 , planning goal requires satisfying
formula 2 paths execution tree unsatisfiable. hand, goal
requires satisfying paths weak; logic allows us demanding
paths satisfy formula.
Finally, consider following LTL formula:
3 = G F ((C B B table).
requires tower exists infinitely many time, i.e., tower gets destroyed,
rebuild it. Intuitively, goal admits plans achieve often, i.e.,
paths, 2 . again, path logic needed give formal meaning
paths.
order able represent planning goals discussed previous example,
consider logic formulas form ., LTL formula path
quantifier defines set infinite paths formula checked. Two
extreme cases path quantifier A, used denote must hold
paths, path quantifier E, used denote must hold paths.
general, path quantifier (finite infinite) word alphabet {A, E} defines
alternation selection two modalities corresponding E A. instance,
writing AE. require finite paths infinite extension satisfies
, writing EA. require extensions finite path satisfy .
path quantifier seen definition two-player game selection
paths satisfy LTL formula. Player (corresponding A) tries build
path satisfy LTL formula, player E (corresponding E) tries
110

fiThe Planning Spectrum One, Two, Three, Infinity

build path LTL formula holds. Different path quantifiers define different
alternations turns players E. game starts path consisting
initial state, and, turns, players E extend path finite
number nodes. case path quantifier finite word, player moves last
game extends finite path built far infinite path. formula satisfied
player E winning strategy, namely if, possible moves player A,
always able build path satisfies LTL formula.
Example 4 Let us consider three LTL formulas defined Example 3, let us see
path quantifiers introduced applied.
case formula 1 , plan presented Example 2 satisfies requirement E.1 :
path tower built destroyed. satisfies stronger
requirement EA.1 stresses fact that, case, tower built
destroyed, safely give control player A. Formula 1 satisfied
stronger way, however. Indeed, plan keeps trying build tower satisfies
requirement AE.1 , well requirement AEA.1 : player cannot reach state
satisfaction goal prevented.
Let us consider formula 2 . case, find plans satisfying AE.2 ,
plan satisfy requirement AEA.2 . Indeed, player simple strategy win,
gets control built tower: bump table. Similar considerations hold
formula 3 . case, find plans requirement AE.3 ,
requirement AEA.3 . case, however, plans exist requirement AEAEAE .3 :
player E gets control infinitely often, rebuild tower needed.
rest section give formal definition study basic properties
logic path quantifiers.
4.1 Finite Games
start considering games finite number moves, path quantifiers
corresponding finite words {A, E}.
Definition 12 (AE-LTL) AE-LTL formula pair g = ., LTL
formula {A, E}+ path quantifier.
following definition describes games corresponding finite path quantifiers.
Definition 13 (semantics AE-LTL) Let p finite path -labelled tree
Then:
p |= A. finite extensions p0 p holds p0 |= ..
p |= E. finite extension p0 p holds p0 |= ..
p |= A. infinite extensions p0 p holds

(p0 ) |=LTL .

p |= E. infinite extension p0 p holds
111

(p0 ) |=LTL .

.

fiPistore & Vardi

say -labelled tree satisfies AE-LTL formula g, write
p0 |= g, p0 = root .



|= g,

AE-LTL allows path quantifiers consisting arbitrary combination
Es. combination corresponds different set rules game
E. Theorem 4 show freedom definition path quantifier
needed. six path quantifiers sufficient capture possible games.
result based concept equivalent path quantifiers.
Consider formulas A. F p AE. F p. easy see two formulas equisatisfiable, i.e., tree satisfies A. F p satisfies AE. F p, vice-versa.
case, path quantifiers AE power, depends fact
use path quantifiers combination LTL formula F p. combine
two path quantifiers different LTL formulas, G p, possible find
trees satisfy latter path quantifier former. reason, cannot
consider two path quantifiers equivalent. Indeed, order two path quantifiers
equivalent, equi-satisfiable LTL formulas. intuition
formalized following definition.
Definition 14 (equivalent path quantifiers) Let 0 two path quantifiers.
say implies 0 , written
0 , -labelled trees LTL formulas
0
, |= . implies |= .. say equivalent 0 , written 0 ,
0
0

.
following lemma describes basic properties path quantifiers
equivalences among them. exploit results proof Theorem 4.
Lemma 3 Let , 0 {A, E} . following implications equivalences hold.
1. AA0 A0 EE0 E0 .
2. A0

0 0

E0 , 0 empty.

3. A0

AEA0 EAE0

E0 .

4. AEAE0 AE0 EAEA0 EA0 .
Proof. proof lemma, order prove 0
00 prove that, given
0
arbitrary tree arbitrary LTL formula , p |= . implies p |= 00 . every
finite path p . Indeed, p |= 0 . implies p |= 00 . finite paths p, easy
prove, induction , p |= 0 . implies p |= 00 . finite paths p.
following, refer proof technique prefix induction.
1. show that, every finite path p, p |= AA0 . p |= A0 .:
equivalence AA0 A0 follows prefix induction.
Let us assume p |= AA0 .. prove p |= A0 ., is, p0 |= 0 .
every finite3 extension p0 p. Since p |= AA0 ., Definition 13 know that,
3. assume 0 empty word. proof case 0 empty word similar.

112

fiThe Planning Spectrum One, Two, Three, Infinity

every finite extension p0 p, p0 |= A0 .. Hence, Definition 13, know
every finite extension p00 p0 , p00 |= 0 .. Since p0 finite extension p0 ,
conclude p0 |= 0 .. Therefore, p0 |= 0 . holds finite extensions p0
p.
Let us assume p |= A0 .. prove p |= AA0 ., is, finite
extensions p0 p, finite extensions p00 p0 , p00 |= 0 .. remark
finite path p00 finite extension p, therefore p00 |= 0 . holds since
p |= A0 ..
concludes proof equivalence AA0 A0 . proof
equivalence EE0 E0 similar.
2. Let us assume first 0 empty word. distinguish two cases, depending
first symbol 0 . 0 = A00 , prove AA00
A00 ,
0
00
already item 1 lemma. = E , show that,
every finite path p, p |= AE00 . p |= E00 .: A0
0 follows
00
prefix induction. Let us assume p |= AE .. Then, finite extensions p0
p exists finite4 extension p00 p0 p00 |= 0 .. Let us take p0 = p.
know finite extension p00 p p00 |= 0 ., is,
according Definition 13, p |= E0 ..
Let us assume 0 empty word. hypothesis, 0 6= ,
empty. distinguish two cases, depending last symbol . = 00A,
prove 00AA
00A, already item 1 lemma.
= 00 E, prove every finite path p, p |= EA. p |= E.:
00 EA
00 E follows prefix induction. Let us assume p |= EA..
Definition 13, exists finite extension p0 p that, every infinite
extension p00 p0 (p00 ) |=LTL . Let p00 infinite extension p0 .
know p00 infinite extension p, (p00 ) |=LTL . Then,
Definition 13 deduce p |= E..
concludes proof A0

0 . proof 0

E0 similar.

3. item 1 lemma know A0
AA0 item 2 know
0
0
AA
AEA . concludes proof A0
AEA0 . proof
EAE0
E0 similar.
4. item 3 lemma know (A)EAE0
(A)E0 . Moreover,
0
0
item 3, know A(E )
AEA(E ). Therefore, deduce AE0
0
0
AEAE . proof EA EAEA0 similar.

prove first main result paper: finite path quantifier
equivalent canonical path quantifier length three.
Theorem 4 finite path quantifier canonical finite path quantifier
0 {A, E,AE, EA,AEA, EAE}
4. assume 00 empty word. proof case 00 empty similar.

113

fiPistore & Vardi

0 . Moreover, following implications hold canonical finite
path quantifiers:
(1)
/o /o /o / AEA o/ /o /o / AE











/

/
/
/

EA
EAE /o /o o/ / E




Proof. first prove path quantifier equivalent canonical path
quantifier 0 . iterative application Lemma 3(1), obtain path quantifier
00 00 00 contain two adjacent E. Then, iterative
application Lemma 3(4), transform 00 equivalent path quantifier 0
length 3. canonical path quantifiers (1) precisely quantifiers
length 3 contain two adjacent E.
implications (1):


AEA EAE

E come Lemma 3(3);

AEA

EA AE

EAE come Lemma 3(2);

AEA

AE EA

EAE come Lemma 3(2).



remark Lemma 3 Theorem 4 depend usage LTL formula
. depend general observation
0 whenever player E select
game 0 set paths subset selected game .
4.2 Infinite Games
consider infinite games, namely path quantifiers consisting infinite words
alphabet {A, E}. see infinite games express finite path quantifiers
studied previous subsection, infinite games, corresponding infinite alternation two players E, cannot expressed
finite path quantifiers.
case infinite games, assume player E moves according strategy
suggests extend finite path. say |= ., infinite
game, winning strategy player E. strategy winning if, whenever
p infinite path obtained according i.e., allowing player play
arbitrary way requiring player E follows strategy p satisfies LTL
formula .
Definition 15 (strategy) strategy -labelled tree mapping : P ( )
P ( ) maps every finite path p one finite extensions (p).
Definition 16 (semantics AE-LTL) Let = 0 1 {A, E} infinite
path quantifier. infinite path p possible outcome game strategy
generating sequence it, namely, infinite sequence p0 , p1 , . . . finite paths
that:
pi finite prefixes p;
114

fiThe Planning Spectrum One, Two, Three, Infinity

p0 = root tree

;

= E pi+1 = (pi );
= pi+1 (arbitrary) extension pi .
denote P (, ) set infinite paths possible outcomes game
strategy . tree satisfies AE-LTL formula g = ., written |= g,
strategy (p) |=LTL paths p P (, ).
remark possible paths generating sequence stop growing, i.e.,
pi pi = pj j i. case, according previous
definition, infinite paths p extend pi possible outcomes.
next lemmas extend analysis equivalence among path quantifiers
infinite games.5 first lemma shows finite path quantifiers particular cases
infinite path quantifiers, namely, correspond infinite path quantifiers
end infinite sequence E.
Lemma 5 Let finite path quantifier. (A) (E) E.
Proof. prove (A) A. proof equivalence similar.
First, prove (A)
A. Let tree LTL formula
|= (A) .. Moreover, let strategy p P ((A) , ) satisfy .
order prove |= A. sufficient use strategy moves player
E, namely, whenever need prove p |= E0 . according Definition 13, take
p0 = (p) move prove p0 |= 0 .. way, infinite paths selected
Definition 13 coincide possible outcomes game (A) , hence satisfy
LTL formula .
concludes proof (A)
A. prove
(A) . distinguish
three cases.
Case = (A)n , n 0.
case, (Lemma 3(1)) (A) = (A) . Let tree
LTL formula. |= A. paths satisfy formula .
easy check |= (A) . paths satisfy formula .
sufficient conclude (A)nA (A)n (A) .
Case = E0 .
case, EA. Indeed, arbitrary path quantifier starts E
ends A. Lemma 3(1), collapse adjacent occurrences
E , thus obtaining (EA)n n > 0. Moreover, Lemma 3(4)
(EA)n EA.
Let tree LTL formula. |= EA.
finite path p infinite extensions p satisfy . Now, let
5. definitions implication equivalence relations (Definition 14) apply case
infinite path quantifiers.

115

fiPistore & Vardi

strategy () = p. every infinite path p P (E0 (A) , )
satisfies . Indeed, since player E first turn, possible outcomes
infinite extensions () = p.
concludes proof E0A

E0 (A) .

Case = (A)n E0 , n > 0.
Reasoning proof previous case, easy show AEA.
Let tree LTL formula. |= AEA.
every finite path p finite extension p0 p infinite
extensions p0 satisfy formula . Let strategy p0 = (p)
finite extension p infinite extensions p0 satisfy . every
infinite path p P ((A)n E0 (A) , ) satisfies . Indeed, let p0 , p1 , . . . , pn , pn+1 , . . .
generating sequence p. pn+1 = (pn ) p infinite extension pn+1 .
construction know p satisfies .
concludes proof (A)n E0A

(A)n E0 (A) .

Every finite path quantifier falls one three considered cases. Therefore,
conclude
(A) every finite path quantifier .

next lemma defines sufficient condition proving
useful proofs forthcoming lemmas.

0 . condition

Lemma 6 Let 0 two infinite path quantifiers. Let us assume -labelled
trees strategy strategy 0 P (0 , 0 ) P (, ).

0 .
Proof. Let us assume |= .. suitable strategy
p P (, ) satisfy LTL formula . Let 0 strategy P (0 , 0 )
P (, ). hypothesis, possible outcomes game 0 strategy 0 satisfy LTL
formula , hence |= 0 .. concludes proof
0 .

next lemma show games players E alternate infinitely
often equivalent one two games (AE) (EA) . is, assume
player extends path turn passes player.
Lemma 7 Let infinite path quantifier contains infinite number
infinite number E. (AE) (EA) .
Proof. Let = (A)m1 (E)n1 (A)m2 (E)n2 mi , ni > 0. show (AE) .
First, prove (AE)
. Let strategy tree let p infinite
path . show p P (, ) p P ((AE) , ). Lemma 6
sufficient proving (AE)
.
Let p0 , p1 , . . . generating sequence p according . Moreover, let p00 = ,
p02i+1 = pm1 +n1 ++mi1 +ni1 +mi p02i+2 = pm1 +n1 ++mi1 +ni1 +mi +1 . easy
check p00 , p01 , p02 , . . . valid generating sequence p according game (AE)
strategy . Indeed, extensions p00 p01 , p02 p03 , p04 p05 , . . . moves player A,
116

fiThe Planning Spectrum One, Two, Three, Infinity

hence arbitrary. Extensions p01 p02 , p03 p04 , . . . correspond extensions
pm1 pm1 +1 , pm1 +n1 +m2 pm1 +n1 +m2 +1 , . . . , moves player E hence
respect strategy .
prove
(AE) . Let strategy tree . define strategy
p P (, ). Lemma 6 sufficient proving
p P ((AE) , ),


(AE) .
= kp (p) kp = P|p| ni . is, strategy path
Let p finite path. (p)
i=1
p obtained applying kp times strategy . number times strategy applied
depends length |p| path p.
p possible
show that, p possible outcome game strategy ,

outcome game (AE) strategy . Let p0 , p1 , . . . generating sequence p

according (AE) .
p0 , p1 , ..., p1 , (p1 ), 2 (p1 ), ..., n1 (p1 ), p3 , ..., p3 ,
| {z } |
{z
} | {z }
m1 times

m2 times
n1 times
2
n2
(p3 ), (p3 ), ..., (p3 ), p5 , ..., p5 , ...

|

{z

n2 times

} | {z }
m3 times

valid generating sequence p according . extensions corresponding
occurrence symbol E consist application strategy hence valid
player E. Moreover, extension ni (p2i1 ) p2i+1 valid move player
p2i+1 extension ni (p2i1 ). Indeed, ni (p2i1 ) prefix p2i (and hence p2i+1 )
P|p2i1 |
2i1 ) = kp2i1 (p2i1 ) kp
since p2i = (p
2i1 =
x=1 nx ni , since |p2i1 | i.
conditions Definition 16 easily checked.
concludes proof (AE) = (A)m1 (E)n1 (A)m2 (E)n2 . proof
(EA) = (E)m1 (A)n1 (E)m2 (A)n2 similar.

next lemma contains auxiliary results path quantifiers.
Lemma 8 Let finite path quantifier 0 infinite path quantifier.
1. A0
2. (A)

0 0

E0 .

A0 E0

(E) .

Proof.
1. prove A0
0 . Let strategy tree let p infinite
path . show p P (0 , ) p P (A0 , ). Let p0 , p1 , . . .
generating sequence p according 0 . easy check
p0 , p1 , . . . , pi1 , pi , pi , pi+1 , . . ., length , valid generating sequence
p according A0 . Indeed, extension pi pi valid move player
A. concludes proof A0
0 .
prove 0
E0 . 0 = (E) , E0 = E(E) = (E) = 0 ,
E0
0 trivially true. 0 6= (E) , assume, without loss
generality, 0 = A00 . case, let strategy tree let p
117

fiPistore & Vardi

path . show p P (E0 , ) p P (0 , ). Let p0 , p1 , . . .
generating sequence p according E0 . easy check
p0 , p1 , . . . , pi , pi+2 , . . ., length , valid generating sequence p
according 0 . Indeed, extension pi pi+2 valid, corresponds
first symbol 0 assumed symbol A. concludes proof
0
E0 .
2. prove (A)

0 . proof 0

(E) similar.

Let strategy tree let p infinite path . show
p P ((A) , ) p P (0 , ). Let p0 , p1 , . . . generating sequence p
according 0 . easy check p0 , p1 , . . . valid generating sequence p according (A) . fact, (A) defines less restrictive
conditions generating sequences 0 .
sufficient conclude (A)

0 .



complete picture Theorem 4: finite infinite path quantifier
equivalent canonical path quantifier defines game consisting alternated moves
players E length one, two, three, infinity.
Theorem 9 finite infinite path quantifier canonical path quantifier
0 {A, E,AE, EA,AEA, EAE, (AE) , (EA) }
0 . Moreover, following implications hold canonical path
quantifiers:
(2)
/o /o /o / AEA /o /o /o / (AE) /o /o /o / AE









EA /o /o /o /








(EA)






/o /o o/ / EAE /o /o o/ / E

Proof. first prove path quantifier equivalent canonical path quantifier.
Theorem 4, true finite path quantifiers, consider infinite path
quantifiers.
Let infinite path quantifier. distinguish three cases:
contains infinite number infinite number E: then, Lemma 7,
equivalent one canonical games (AE) (EA) .
contains finite number A: case, ends infinite sequence E,
and, Lemma 5, 00 finite path quantifier 00 . Theorem 4, 00
equivalent canonical path quantifier, concludes proof
case.
contains finite number E: case similar previous one.
implications (2):
118

fiThe Planning Spectrum One, Two, Three, Infinity

(AE)
(AE) .

(EA) comes Lemma 8(1), taking empty word 0 =

AEA
(AE) , (AE)
8(2).

AE, EA

(EA) , (EA)

EAE come Lemmas 5

implications come Theorem 4.



4.3 Strictness Implications
conclude section showing arrows diagram Theorem 9
describe strict implications, namely, eight canonical path quantifiers different.
Let us consider following {i, p, q}-labelled binary tree, root labelled
node two children labelled p q:
'&%$
!"#
iM
qqq MMMMM
q
q
MMM
q
M&
qqq
()*+
/.-,
()*+
/.-,
p =xq
q
=

===
=


==
=

==

=




()*+
/.-,
/.-,
()*+
()*+
/.-,
()*+
/.-,
p.
q.
p.
q.
...
...
...
...








()*+
/.-,
/.-,
/.-,
()*+
/.-,
()*+
/.-,
/.-,
/.-,
()*+
/.-,
()*+
p ()*+
p
p ()*+
q
q
p
q
q ()*+

Let us consider following LTL formulas:
F p: player E satisfy formula moves least once, visiting p-labelled
node.
G F p: player E satisfy formula visit infinite number p-labelled
nodes, is, final move finite game, moves infinitely often
infinite game.
F G p: player E satisfy formula takes control game
certain point on, is, final move finite game.
G q: player E satisfy formula player never plays, since player
immediately visit q-labelled node.
X p: player E satisfy formula playing first turn moving left
child root node.
following graph shows formulas hold path quantifiers:
Fp

GFp

FGp

G q

/o o/ / AEA /o / (AE) /o o/ / AE


Xp




















EA /o o/ / (EA) /o o/ / EAE /o /o o/ / E
119

fiPistore & Vardi

5. Planning Algorithm AE-LTL
section present planning algorithm AE-LTL goals. start showing
build parity tree automaton accepts trees satisfy given AE-LTL
formula. show tree automaton adapted, accepts
trees correspond valid plans given planning domain. way, problem
checking whether exists plan given domain AE-LTL goal
reduced emptiness problem tree automata. Finally, study complexity
planning AE-LTL goals prove problem 2EXPTIME-complete.
5.1 Tree Automata AE-LTL Formulas
Berwanger, Gradel, Kreutzer (2003) shown AE-LTL formulas expressed directly CTL* formulas. reduction exploits equivalence expressive
power CTL* monadic path logic (Moller & Rabinovich, 1999). tree automaton
obtained AE-LTL formula using reduction Theorem 2. However,
translation proposed Berwanger et al. (2003) upper bound non-elementary
complexity, hence useful complexity analysis. paper describe
different, direct reduction better suited purposes.
-labelled tree satisfies formula . suitable subset paths
tree satisfy . subset paths chosen according . order
characterize suitable subsets paths, assume w-marking tree ,
use labels w define selected paths.
Definition 17 (w-marking) w-marking -labelled tree ({w, w})-labelled tree w dom( ) = dom(w ) and, whenever (x) = , w (x) = (, w)
w (x) = (, w).
exploit w-markings follows. associate AE-LTL formula . CTL*
formula [[.]] tree satisfies formula . wmarking satisfies [[.]].
Definition 18 (AE-LTL CTL*) Let . AE-LTL formula. CTL* formula
[[.]] defined follows:
[[A.]] =
[[E.]] = E
[[EA.]] = EF w A(F w )
[[AEA.]] = AG EF w A(F w )
[[AE.]] = AG EXG w A(F G w )
[[EAE.]] = EF AG EXG w A(F G w )
[[(AE) .]] = AG EF w A(G F w )
[[(EA) .]] = EF AG EF w A(G F w )
case path quantifiers E, direct translation CTL*
exploit w-marking. cases, CTL* formula [[.]] conjunction
120

fiThe Planning Spectrum One, Two, Three, Infinity

two sub-formulas. first one characterizes good markings according path
quantifier , second one guarantees paths selected according
marking satisfy LTL formula . case path quantifiers EA AEA, mark
w nodes that, reached, guarantee formula satisfied. selected
paths hence contain node labelled w (formula F w). case
path quantifiers AE EAE, mark w descendants node define
infinite path satisfies . selected paths hence that, certain node
on, continuously labelled w (formula F G w). case path quantifiers (AE)
(EA) , finally, mark w nodes player E wants reach according
strategy passing turn player A. selected paths hence
contain infinite number nodes labelled w (formula G F w), is, paths along
player E moves infinitely often.
Theorem 10 -labelled tree satisfies AE-LTL formula .
w-marking satisfies formula [[.]].
Proof. proof, consider cases = AEA, = AE = (AE) .
cases similar.
Assume tree satisfies .. show exists w-marking w
satisfies [[.]].
Case = AEA. According Definition 13, tree satisfies AEA., every
finite path p extended finite path p0 infinite extensions
p00 p0 satisfy . Let us mark w nodes w correspond
extension p0 path p. construction, marked tree satisfies AG EF w.
remains show marked tree satisfies A(F w ).
Let us consider path p00 tree satisfies F w, let us show p00
satisfies . Since p00 satisfies F w, know contains nodes marked w. Let
p0 finite prefix path p00 first node marked w. construction,
exists finite path p p0 finite extension p infinite
extensions p0 satisfy . consequence, p00 satisfies .
Case = AE. According Definition 13, tree satisfies AE.,
finite paths p infinite extension p satisfies . Therefore,
define mapping : P ( ) P ( ) associates finite path p infinite
extension m(p) satisfies . assume, without loss generality, that, p0
finite extension p prefix m(p), m(p0 ) = m(p). is,
far p0 extends finite path p along infinite path m(p) associates
p0 infinite path m(p).
every finite path p, let us mark w node w child p
along infinite path m(p). construction, marked tree satisfies AG EXG w.
remains show marked tree satisfies A(F G w ).
Let us consider path p00 tree satisfies F G w, let us show p00
satisfies . Since p00 satisfies F G w, know path p
descendants p along p00 marked w. order prove p00 satisfies
121

fiPistore & Vardi

show p00 = m(p). Assume contradiction m(p) 6= p00 let p0
longest common prefix m(p) p00 . observe p prefix p0 , hence
m(p) = m(p0 ). implies child node p0 along p00 marked w,
absurd, since definition p descendants p along p00 marked
w.
Case = (AE) . According Definition 16, tree satisfies (AE) .,
exists suitable strategy player E possible outcomes game
strategy satisfy . Let us mark w nodes w correspond
extension (p) finite path p. is, mark w nodes
reached move player E according strategy . marked
tree satisfies formula AG EF w, is, every finite path p extended
finite path p0 node corresponding p0 marked w. Indeed,
construction, sufficient take p0 = (p00 ) extension p00 p. remains
show marked tree satisfies A(G F w ).
Let us consider path p tree satisfies G F w, let us show p
satisfies . purpose, show p possible outcome game
strategy . remark that, given arbitrary finite prefix p0 p always possible
find finite extension p00 p0 (p00 ) prefix p. Indeed,
set paths P = {p : (p) finite prefix p} infinite, infinite nodes
marked w path p.
Now, let p0 , p1 , p2 , . . . sequence finite paths defined follows: p0 = ()
root three; p2k+1 shortest extension p2k (p2k+1 )
prefix p; p2k+2 = (p2k+1 ). easy check p0 , p1 , p2 , . . . generating
sequence p according (AE) . Hence, Definition 16, infinite path p
satisfies LTL formula .
concludes proof satisfies ., exists w-marking
satisfies [[.]].
Assume w-marked tree w satisfies [[.]]. show satisfies
..
Case = AEA. marked tree satisfies formula AG EF w. means
finite path p (AG) exists finite extension p0 final node
p0 marked w (EF w) . Let p00 infinite extension finite path p0 .
show p00 satisfies LTL formula . Clearly, p00 satisfies formula F w.
Since tree satisfies formula A(F w ), infinite paths satisfy F w
satisfy . Therefore, p00 satisfies LTL formula .
Case = AE. marked tree satisfies formula AG EXG w. Then,
finite path p (AG) exists infinite extension p0 that, certain
node on, nodes p0 marked w (EXG w). show that, p0
infinite extension finite path p, p0 satisfies LTL formula . Clearly,
p0 satisfies formula F G w. Since tree satisfies formula A(F G w ),
infinite paths satisfy F G w satisfy . Therefore, p0 satisfies LTL
formula .
122

fiThe Planning Spectrum One, Two, Three, Infinity

Case = (AE) . Let strategy that, every finite path p, node
corresponding (p) marked w. remark always possible define
strategy. fact, marked tree satisfies formula AG EF w, hence,
finite path p extended finite path p0 node corresponding
p0 marked w.
Let p possible outcome game strategy . prove p satisfies
LTL formula . Definition 16, infinite path p contains infinite set
nodes marked w: nodes reached move player E. Hence,
p satisfies formula G F w. Since tree satisfies formula A(G F w ),
infinite paths satisfy G F w satisfy . Therefore, path p satisfies LTL
formula .
concludes proof that, exists w-marking tree
|= ..



satisfies [[.]],


Kupferman (1999) defines extension CTL* existential quantification
atomic propositions (EGCTL*) examines complexity model checking satisfiability
new logic. remark AE-LTL seen subset EGCTL*. Indeed,
according Theorem 10, -labelled tree satisfies AE-LTL formula .
satisfies EGCTL* formula w.[[.]].
following definition show transform parity tree automaton
CTL* formula [[.]] parity tree automaton AE-LTL formula ..
transformation performed abstracting away information w-marking
input alphabet transition relation tree automaton.
Definition 19 Let = h{w, w}, D, Q, q0 , , parity tree automaton. parity
tree automaton Aw = h, D, Q, q0 , w , i, obtained abstracting away wmarking, defined follows: w (q, , d) = (q, (, w), d) (q, (, w), d).
Lemma 11 Let Aw two parity tree automata Definition 19. Aw accepts
exactly -labelled trees w-marking accepted A.
Proof. Let w ({w, w})-labelled tree let corresponding -labelled
tree, obtained abstracting away w-marking. show w accepted A,
accepted Aw . Let r : Q accepting run w A. r
accepting run Aw . Indeed, x , arity(x) = d, w (x) = (, m)
{w, w}, hr(x 0), . . . , r(x d1)i (r(x), (, m), d). (x) = ,
and, definition Aw , hr(x 0), . . . , r(x d1)i w (r(x), , d).
show that, -labelled tree accepted Aw , ({w, w})labelled tree w w-marking accepted A. Let r : Q
accepting run Aw . definition run, know x , arity(x) =
(x) = , hr(x 0), . . . , r(x d1)i w (r(x), , d). definition w ,
know hr(x 0), . . . , r(x d1)i (r(x), (, w), d) (r(x), (, w), d). Let us define
w (x) = (, w) hr(x 0), . . . , r(x d1)i (r(x), (, w), d), w (x) = (, w) otherwise.
easy check r accepting run w A.

123

fiPistore & Vardi

ingredients defining tree automaton accepts
trees satisfy given AE-LTL formula.
Definition 20 (tree automaton AE-LTL) Let N finite set arities,
let . AE-LTL formula. parity tree automaton AD
. obtained applying
transformation described Definition 19 parity automaton AD
[[.]] built according
Theorem 2.
Theorem 12 parity tree automaton AD
. accepts exactly -labelled D-trees
satisfy formula ..
Proof. Theorem 2, parity tree automaton AD
[[.]] accepts D-trees satisfy
CTL* formula [[.]]. Therefore, parity tree automaton AD
. accepts D-trees
satisfy formula . Lemma 11 Theorem 10.

parity tree automaton AD
. parity index exponential number
states doubly exponential length formula .
2
Proposition 13 parity tree automaton AD
. 2

O(||)

states parity index 2O(||) .

Proof. construction Definition 19 change number states
parity index automaton. Therefore, proposition follows Theorem 2.

5.2 Planning Algorithm
describe automaton AD
. exploited order build plan goal
. given domain.
start defining tree automaton accepts trees define valid
plans planning domain = h, 0 , A, Ri. recall that, according Definition 8,
transition relation R maps state action tuple next states
h1 , 2 , . . . , n = R(, a).
following assume finite set arities compatible domain
D, namely, R(, a) = h1 , . . . , A, D.
Definition 21 (tree automaton planning domain) Let = h, 0 , A, Ri
planning domain let set arities compatible domain D.

tree automaton AD
corresponding planning domain AD = hA, D, , 0 , , 0 i,
h1 , . . . , (, (, a), d) h1 , . . . , = R(, a) > 0, 0 () = 0
.
According Definition 10, (A)-labelled tree obtained plan
domain D. show converse true, namely, (A)-labelled tree
accepted tree automaton AD
induces plan.
Definition 22 (plan induced tree) Let (A)-labelled tree accepted automaton AD
. plan induced domain defined follows: (0 , 1 , . . . , n ) = finite path p (p) = (0 , a0 )
(1 , a1 ) (n , ) = .
124

fiThe Planning Spectrum One, Two, Three, Infinity

following lemma shows Definitions 10 22 define one-to-one correspondence valid plans planning domain trees accepted automaton
AD
D.
Lemma 14 Let tree accepted automaton AD
let corresponding
induced plan. valid plan domain D, execution tree corresponding
. Conversely, let plan domain let corresponding execution
structure. accepted automaton AD
plan induced .
Proof. lemma direct consequence Definitions 10 22.



define parity tree automaton accepts trees correspond
plans domain satisfy goal g = .. parity tree automaton obtained
combining suitable way tree automaton AE-LTL formula g (Definition 20)
tree automaton domain (Definition 21).
Definition 23 (instrumented tree automaton) Let set arities compatible planning domain D. Let AD
g = h, D, Q, q0 , , parity tree automaton accepts trees satisfy AE-LTL formula g. parity tree
automaton AD
D,g corresponding planning domain goal g defined follows:

AD,g = hA, D, Q, (q0 , 0 ), 0 , 0 i, h(q1 , 1 ), . . . , (qd , )i 0 ((q, ), (, a), d)
hq1 , . . . , qd (q, , d) h1 , . . . , = R(, a) > 0, 0 (q, ) = (q).
following lemmas show solutions planning problem (D, g) one-to-one
correspondence trees accepted tree automaton AD
D,g .
Lemma 15 Let (A)-labelled tree accepted automaton AD
D,g , let
plan induced domain D. plan solution planning problem
(D, g).
Proof. According Definition 11, prove execution tree corresponding
satisfies goal g. Lemma 14, amounts proving tree satisfies g.
construction, easy check (A)-labeled tree accepted AD
D,g ,

accepted Ag . Indeed, rD,g : Q accepting run AD
D,g ,

rg : Q accepting run Ag , rg (x) = q whenever rD,g = (q, )
.

Lemma 16 Let solution planning problem (D, g). execution tree
accepted automaton AD
D,g .
Proof. Let execution tree . Lemma 14 know accepted AD
D.
Moreover, definition solution planning problem, know accepted
AD
g . construction, easy check (A)-labeled tree accepted


AD AD
g , accepted AD,g . Indeed, let rD : accepting

run AD
let rg : Q accepting run Ag . rD,g : Q

accepting run AD,g , rD,g (x) = (q, ) rD (x) = rg (x) = q.

125

fiPistore & Vardi

consequence, checking whether goal g satisfied domain reduced
problem checking whether automaton AD
D,g nonempty.
Theorem 17 Let planning domain g AE-LTL formula. plan exists
goal g domain tree automaton AD
D,g nonempty.
Proposition 18 parity tree automaton AD
D,g domain = (, 0 , A, R) goal
g = . || 22

O(||)

states parity index 2O(||) .

Proof. consequence Proposition 13 definition automaton AD
D,g .
5.3 Complexity
study time complexity planning algorithm defined Subsection 5.2.
Given planning domain D, planning problem AE-LTL goals g = .
decided time doubly exponential size formula applying
Theorem 1 tree automaton AD
D,g .
Lemma 19 Let planning domain. existence plan AE-LTL goal g = .
O(||)
domain decided time 22
.
Proof. Theorem 17 existence plan goal g domain reduced
emptiness problem parity tree automaton AD
D,g . Proposition 18, parity tree
O(||)

2
automaton AD
|| states parity index 2O(||) . Since assume
D,g 2
domain fixed, Theorem 1, emptiness automaton AD
D,g decided time

22

O(||)

.



doubly exponential time bound tight. Indeed, realizability problem
LTL formula , known 2EXPTIME-complete (Pnueli & Rosner, 1990),
reduced planning problem goal A.. realizability problem one assumes
program environment alternate control evolution system.
precisely, execution 0 , 1 , . . . states decided program
even, environment odd. say given formula realizable
program executions satisfy independently actions
environment.
Theorem 20 Let planning domain. problem deciding existence plan
AE-LTL goal g = . domain 2EXPTIME-complete.
Proof. realizability formula reduced problem checking exis
tence plan goal A. planning domain = {init} ( {p, e}), init, {e}, R ,
with:
R(init, 0 ) = {( 0 , e)}
0

R(init, e) =

0

R((, p), ) = {( , e)}

R((, p), e) =

0

R((, e), e) = {( 0 , p) : 0 }

R((, e), ) =
126

fiThe Planning Spectrum One, Two, Three, Infinity

, 0 .
States (, p) program controls evolution actions 0 .
States (, e) environment controls evolution; nondeterministic action e performed state. Finally, state init used assign initial
move program.
Since realizability problem 2EXPTIME-complete size LTL formula
(Pnueli & Rosner, 1990), planning problem 2EXPTIME-hard size goal
g = .. 2EXPTIME-completeness follows Lemma 19.

remark that, case goals form E., algorithm better
complexity defined. case, plan exists E.
infinite sequence 0 , 1 , . . . states satisfies i+1 R(i , ai )
action ai . is, planning problem reduced model checking problem
LTL formula , problem known PSPACE-complete (Sistla & Clarke,
1985). conjecture that, canonical path quantifiers except E, doubly
exponential bound Theorem 20 tight.
remarks order complexity satisfiability validity problems
AE-LTL goals. problems PSPACE-complete. Indeed, AE-LTL formula
. satisfiable LTL formula satisfiable6 , latter problem
known PSPACE-complete (Sistla & Clarke, 1985). similar argument holds
validity.
complexity model checking problem AE-LTL recently addressed
Kupferman Vardi (2006). Kupferman Vardi introduce mCTL*, variant
CTL*, path quantifiers memoryful interpretation. show memoryful quantification express (with linear cost) semantics path quantifiers
AE-LTL. example, AE-LTL formula AE. expressed mCTL* formula
AG E . Kupferman Vardi show model checking problem new logic
EXPSPACE-complete, result holds subset mCTL* corresponds formulas AE.. Therefore, model checking problem AE-LTL finite
path quantifiers EXPSPACE-complete. best knowledge complexity
model checking AE-LTL formulas (AE) . (EA) . still open problem.

6. Two Specific Cases: Reachability Maintainability Goals
section consider two basic classes goals particularly relevant
field planning.
6.1 Reachability Goals
first class goals reachability goals corresponding LTL formula F q,
q propositional formula. literature planning concentrates
class goals, several works address problem defining plans
different strength kind goals (see, e.g., Cimatti et al., 2003 citations).
6. tree satisfies . paths satisfy , path satisfies seen
tree satisfies ..

127

fiPistore & Vardi

context AE-LTL, soon player E takes control, immediately achieve
reachability goal possible all. fact control given back player
goal achieved irrelevant. Therefore, significant path quantifiers
reachability goals A, E, AE.
Proposition 21 Let q propositional formula atomic propositions Prop. Then,
following results hold every labelled tree . |= E. F q iff |= EA. F q iff |= EAE. F q
iff |= (EA) . F q. Moreover |= AE. F q iff |= AEA. F q iff |= (AE) . F q.
Proof. prove |= AE. F q iff |= AEA. F q iff |= (AE) . F q. cases
similar.
Let us assume |= AE. F q. Moreover, let p finite path . know p
extended infinite path p0 (p0 ) |= F q. According semantics
LTL, (p0 ) |= F q means node x path p0 q (x). Clearly,
infinite paths contain node x satisfy LTL formula F q. Therefore,
finite extension p00 p infinite extensions p00 satisfy LTL
formula F q: sufficient take p00 finite extension p contains node x. Since
property holds every finite path p, conclude |= AEA. F q.
proven |= AE. F q implies |= AEA. F q. Theorem 9 know
AEA
(AE)
AE, hence |= AEA. F q implies |= (AE) . F q implies |= AE. F q.
concludes proof.

following diagram shows implications among significant path quantifiers
reachability goals:
(3)
/o /o /o / AE /o /o /o / E
remark three goals A. F q, E. F q, AE. F q correspond, respectively,
strong, weak, strong cyclic planning problems Cimatti et al. (2003).
6.2 Maintainability Goals
consider another particular case, namely maintainability goals G q, q
propositional formula. Maintainability goals properties complementary
properties reachability goals. case, soon player takes control,
violate maintainability goal possible all. fact player E take control
player hence irrelevant, interesting path quantifiers A, E,
EA.
Proposition 22 Let q propositional formula atomic propositions Prop. Then,
following results hold every labelled tree . |= A. G q iff |= AE. G q iff |=
AEA. G q iff |= (AE) . G q. Moreover |= EA. G q iff |= EAE. G q iff |= (EA) . G q.
Proof. proof similar proof Proposition 21.



following diagram shows implications among significant path quantifiers
maintainability goals:
/o /o /o / EA /o /o /o / E
128

fiThe Planning Spectrum One, Two, Three, Infinity

goals A. G q, E. G q, EA. G q correspond maintainability variants strong, weak,
strong cyclic planning problems. Indeed, correspond requiring condition q
maintained evolutions despite nondeterminism (A. G q), condition q maintained
evolutions (E. G q), possible reach state condition
q always maintained despite nondeterminism (EA. G p).

7. Related Works Concluding Remarks
paper defined AE-LTL, new temporal logic extends LTL
possibility declaring complex path quantifiers define different degrees
LTL formula satisfied computation tree. propose use AE-LTL formulas
expressing temporally extended goals nondeterministic planning domains.
defined planning algorithm AE-LTL goals based automata-theoretic
framework: existence plan reduced checking emptiness suitable parity
tree automaton. studied time complexity planning algorithm, proving
2EXPTIME-complete length AE-LTL formula.
field planning, several works use temporal logics defining goals.
approaches (Bacchus & Kabanza, 1998, 2000; Calvanese et al., 2002; Cerrito & Mayer,
1998; de Giacomo & Vardi, 1999; Kvarnstrom & Doherty, 2001) use linear temporal logics
goal language, able express conditions degree goal
satisfied respect nondeterminism execution. Notable exceptions
works described Pistore, Bettin, Traverso (2001), Pistore Traverso (2001)
Dal Lago et al. (2002). Pistore et al. (2001) Pistore Traverso (2001) use CTL
goal language, Dal Lago et al. (2002) define new branching time logic allows
expressing temporally extended goals deal explicitly failure recovery
goal achievement. goal languages, however, path quantifiers interleaved
temporal operators, hence rather different AE-LTL.
field temporal logics, work alternating temporal logic (ATL) (Alur,
Henzinger, & Kupferman, 2002) related work. ATL, path quantifiers
CTL CTL* replaced game quantifiers. Nevertheless, obvious way
expressed formulas form ., path quantifier LTL formula
ATL , expressive logic studied Alur et al. (2002). conjecture
logic ATL incomparable expressiveness.
comments order practical impact 2EXPTIME complexity
planning algorithm. First all, many planning problems expect
complex large domains, goals relatively simple (see, e.g., experimental
evaluation performed Pistore et al. (2001) case planning goals expressed CTL
formulas). cases, doubly exponential complexity algorithm size
formula may bottleneck. larger AE-LTL goals, doubly exponential time
complexity may feasible, noted worst-case complexity.
note improved algorithms plan synthesis active research area, including
analysis simpler LTL goals (Alur & La Torre, 2004) development improved
automata-theoretic algorithms (Kupferman & Vardi, 2005).
automata-theoretic framework used paper wider applicability AE-LTL goals. interesting direction future investigations application
129

fiPistore & Vardi

framework variants AE-LTL allow nesting path quantifiers,
goals combine AE-LTL propositional temporal operators. would allow,
instance, specify goals compose requirements different strength. simple
example goals (AE. F p)(A. G p), requires achieve condition p strong
cyclic way, maintaining condition q strong way. impossibility define kind
goals is, opinion, strongest limitation AE-LTL respect CTL
CTL*.
Another direction future investigations extension approach proposed
paper case planning partial observability (de Giacomo & Vardi, 1999),
one assumes agent executing plan observe part state
hence choices actions execute may depend part.
plan explore implementation issues and, particular, possibility
exploiting BDD-based symbolic techniques planning algorithm AE-LTL goals.
cases, techniques shown able deal effectively domains
goals significant complexity, despite exponential worst-case time complexity
problems (Bertoli, Cimatti, Pistore, Roveri, & Traverso, 2001; Pistore et al., 2001).

Acknowledgments
shorter version paper, without proofs, published Pistore Vardi
(2003). authors would thank Erich Gradel comments reduction
AE-LTL formulas CTL* formulas.

References
Alur, R., Henzinger, T., & Kupferman, O. (2002). Alternating-time temporal logic. Journal
ACM, 49 (5), 672713.
Alur, R., & La Torre, S. (2004). Deterministic generators games LTL fragments.
ACM Trans. Comput. Log., 5 (1), 125.
Bacchus, F., & Kabanza, F. (1998). Planning temporally extended goals. Ann.
Mathematics Artificial Intelligence, 22, 527.
Bacchus, F., & Kabanza, F. (2000). Using temporal logic express search control knowledge
planning. Artificial Intelligence, 116 (1-2), 123191.
Bertoli, P., Cimatti, A., Pistore, M., Roveri, M., & Traverso, P. (2001). MBP: Model
Based Planner. Proc. IJCAI01 workshop Planning Uncertainty
Incomplete Information.
Berwanger, D., Gradel, E., & Kreutzer, S. (2003). upon time West - Determinacy, definability, complexity path games. Prof. 10th Int. Conf Logic
Programming, Artificial Intelligence, Reasoning (LPAR03), pp. 229243.
Calvanese, D., de Giacomo, G., & Vardi, M. (2002). Reasoning actions planning
LTL action theories. Proc. 8th Int. Conf. Principles Knowledge
Representation Reasoning (KR02), pp. 593602.
130

fiThe Planning Spectrum One, Two, Three, Infinity

Cerrito, S., & Mayer, M. (1998). Bounded model search linear temporal logic
application planning. Proc. 2nd Int. Conf. Analytic Tableaux Related
Methods (TABLEAUX98), Vol. 1397 LNAI, pp. 124140. Springer Verlag.
Cimatti, A., Pistore, M., Roveri, M., & Traverso, P. (2003). Weak, strong, strong cyclic
planning via symbolic model checking.. Artificial Intelligence, 147 (1-2), 3584.
Dal Lago, U., Pistore, M., & Traverso, P. (2002). Planning language extended
goals. Proc. 18th National Conf. Artificial Intelligence (AAAI02). AAAI
Press.
Daniele, M., Traverso, P., & Vardi, M. (1999). Strong cyclic planning revisited. Proc.
5th European Conf. Planning (ECP99), Vol. 1809 LNAI, pp. 3548. Springer
Verlag.
de Giacomo, G., & Vardi, M. (1999). Automata-theoretic approach planning temporally extended goals. Proc. 5th European Conf. Planning (ECP99), Vol.
1809 LNAI, pp. 226238. Springer Verlag.
Emerson, E. A. (1990). Temporal modal logic. van Leeuwen, J. (Ed.), Handbook
Theoretical Computer Science, Volume B: Formal Models Semantics. Elsevier.
Emerson, E., & Jutla, C. (1988). complexity tree automata logics programs.
Proc. 29th IEEE Symp. Foundations Computer Science, pp. 328337.
Emerson, E., & Jutla, C. (1991). Tree automata, -calculus determinacy. Proc.
32nd IEEE Symp. Foundations Computer Science, pp. 368377.
Fikes, R., & Nilsson, N. (1971). STRIPS: new approach application theorem
proving problem solving. Artificial Intelligence, 2 (3-4), 189208.
Ghallab, M., Nau, D., & Traverso, P. (2004). Automated Planning: Theory Practice.
Elsevier.
Kupferman, O. (1999). Augmenting branching temporal logics existential quantification atomic propositions. Journal Logic Computation, 9 (2), 135147.
Kupferman, O., & Vardi, M. (2005). Safraless decision procedures. Proc. 46th IEEE
Symp. Foundations Computer Science (FOCS05), pp. 531542. IEEE Computer
Society.
Kupferman, O., & Vardi, M. (2006). Memoryful branching-time logic. Proc.
21th IEEE Symposium Logic Computer Science (LICS 2006). IEEE Computer
Society.
Kupferman, O., Vardi, M., & Wolper, P. (2000). automata-theoretic approach branching time model checking. Journal ACM, 47 (2).
Kvarnstrom, J., & Doherty, P. (2001). TALplanner: temporal logic based forward chaining
planner. Ann. Mathematics Artificial Intelligence, 30, 119169.
Moller, F., & Rabinovich, A. (1999). expressive power CTL*. Proc. 14th
Annual IEEE Symposium Logic Computer Science (LICS99), pp. 360369.
IEEE Computer Science Press.
131

fiPistore & Vardi

Penberthy, J., & Weld, D. (1992). UCPOP: sound, complete, partial order planner
ADL. Proc. 3rd Int. Conf. Principles Knowledge Representation
Reasoning (KR92).
Peot, M., & Smith, D. (1992). Conditional nonlinear planning. Proc. 1st Int. Conf.
AI Planning Systems (AIPS92), pp. 189197. Morgan Kaufmann Publisher.
Pistore, M., Bettin, R., & Traverso, P. (2001). Symbolic techniques planning
extended goals non-deterministic domains. Proc. 6th European Conf.
Planning (ECP01).
Pistore, M., & Traverso, P. (2001). Planning model checking extended goals nondeterministic domains. Proc. 17th Int. Joint Conf. Artificial Intelligence
(IJCAI01). AAAI Press.
Pistore, M., & Vardi, M. (2003). planning specturm one, two, three, infinity.
Proc. 18th IEEE Symposium Logic Computer Science (LICS 2003), pp.
234243.
Pnueli, A., & Rosner, R. (1990). Distributed reactive systems hard synthesize.
Proc. 31st IEEE Symp. Foundation Computer Science, pp. 746757.
Sistla, A., & Clarke, E. (1985). complexity propositional linear temporal logic.
Journal ACM, 32, 733749.
Warren, D. (1976). Generating conditional plans programs. Proc. Summer
Conf. Artificial Intelligence Simulation Behaviour (AISB76), pp. 344354.

132


