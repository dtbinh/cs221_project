journal artificial intelligence

submitted published

inference rules max sat
chu min li

chu min li u picardie fr

laria universite de picardie jules verne
rue st leu amiens cedex france

felip manya

felip iiia csic es

iiia artificial intelligence institute
csic spanish national council
campus uab bellaterra spain

jordi planes

jplanes diei udl es

computer science department universitat de lleida
jaume ii lleida spain

abstract
exact max sat solvers compared sat solvers apply little inference
node proof tree commonly used sat inference rules unit propagation produce
simplified formula preserves satisfiability unfortunately solving max sat
simplified formula equivalent solving original formula
define number original inference rules besides applied
efficiently transform max sat instances equivalent max sat instances
easier solve soundness rules seen refinements unit resolution
adapted max sat proved novel simple way via integer programming
transformation aim finding powerful inference rules practice
developed max sat solver called maxsatz incorporates rules
performed experimental investigation provide empirical evidence
maxsatz competitive least random max sat random max sat maxcut graph coloring instances well benchmarks max sat
evaluation

introduction
recent years growing interest developing fast exact max sat
solvers alber gramm niedermeier alsinet manya planes b
de givry larrosa meseguer schiex li manya planes xing zhang
zhang shen manya due potential solve constrained nphard encoded formalism boolean cnf formulas nowadays max sat
solvers able solve lot instances beyond reach solvers developed
five years ago nevertheless yet considerable gap difficulty
instances solved current sat solvers instances solved best performing
max sat solvers
motivation behind work bridge gap complete sat solvers
exact max sat solvers investigating technology previously developed
sat goldberg novikov li marques silva sakallah zhang
zhang madigan moskewicz malik extended incorporated maxc

ai access foundation rights reserved

fili manya planes

sat precisely focus attention branch bound max sat solvers
davis putnam logemann loveland dpll procedure davis logemann loveland
davis putnam
one main differences sat solvers max sat solvers former
make intensive use unit propagation node proof tree unit propagation
highly powerful inference rule transforms sat instance satisfiability
equivalent sat instance easier solve unfortunately solving max sat
general equivalent solving e number unsatisfied
clauses every truth assignment example apply
unit propagation cnf formula x x x x x x x x x
obtain equivalent interpretation satisfying
x unsatisfies one clause two clauses therefore want compute
optimal solution cannot apply unit propagation sat solvers
proposed previous work li et al use unit propagation compute
lower bounds branch bound max sat solvers instead unit propagation
simplify cnf formulas detect disjoint inconsistent subsets clauses
via unit propagation turns number disjoint inconsistent subsets detected
underestimation number clauses become unsatisfied current
partial assignment extended complete assignment underestimation plus
number clauses unsatisfied current partial assignment provides good performing
lower bound captures lower bounds inconsistency counts
state art max sat solvers implement alsinet manya planes alsinet
et al b borchers furman wallace freuder zhang et al
well improved lower bounds alsinet manya planes alsinet et al
xing zhang
one hand number disjoint inconsistent subsets detected conservative underestimation lower bound since every inconsistent subset increases
lower bound one independently number clauses unsatisfied optimal
assignment however optimal assignment violate one clause inconsistent subset therefore able improve lower bound counting
number disjoint inconsistent subsets clauses
hand despite fact good quality lower bounds prune large parts
search space accelerate dramatically search optimal solution whenever
lower bound reach best solution found far upper bound solver
continues exploring search space current node search solvers
often redetect inconsistencies computing lower bound different nodes
basically lower bound computation methods simplify
cnf formula way unsatisfied clauses become explicit lower bounds
pruning technique
overcome two define set sound inference rules
transform max sat instance max sat instance easier solve
max sat inference rule sound whenever equivalent
let us see example inference rule given max sat instance contains
three clauses form l l l l l l literals replace cnf


finew inference rules max sat

formula
l l l l l l
note rule detects contradiction l l l l therefore replaces
clauses empty clause addition rule adds clause l l ensure
equivalence assignment containing l l
l l l l number unsatisfied clauses l l l l
assignment containing l l number unsatisfied clauses
note even assignment containing l l best assignment
subset l l l l best whole formula adding l l
rule ensures number unsatisfied clauses
l l
inference rule adds clause l l may contribute another contradiction detectable via unit propagation case rule allows increase
lower bound instead moreover rule makes explicit contradiction among
l l l l contradiction need redetected current
node
inference rules defined already known literature bansal raman niedermeier rossmanith others original
max sat rules inspired different unit resolution refinements applied
sat selected could applied natural efficient way
sense summarize work telling defined max sat counterpart
sat unit propagation
aim finding powerful inference rules practice
designed implemented max sat solver called maxsatz incorporates
rules well lower bound defined previous work li et al performed
experimental investigation provide empirical evidence maxsatz
competitive least random max sat random max sat max cut graph
coloring instances well benchmarks max sat evaluation
structure follows section give preliminary definitions section describe basic branch bound max sat solver section
define inference rules prove soundness novel simple way via integer
programming transformation give examples illustrate inference rules
may produce better quality lower bounds section present implementation
inference rules maxsatz section describe main features maxsatz
section report experimental investigation section present related
work section present conclusions future work

preliminaries
propositional logic variable xi may take values false true literal li
variable xi negation xi clause disjunction literals cnf formula
conjunction clauses length clause number literals size
denoted sum length clauses
http www iiia csic es maxsat



fili manya planes

assignment truth values propositional variables satisfies literal xi xi
takes value satisfies literal xi xi takes value satisfies clause
satisfies least one literal clause satisfies cnf formula satisfies
clauses formula empty clause denoted contains literals cannot
satisfied assignment cnf formula complete variables occurring
assigned otherwise partial
max sat cnf formula finding assignment
values propositional variables minimizes number unsatisfied clauses
equivalently maximizes number satisfied clauses max sat called maxksat clauses k literals per clause following represent cnf
formula multiset clauses since duplicated clauses allowed max sat instance
cnf formulas equivalent number unsatisfied
clauses every complete assignment

basic max sat solver
space possible assignments cnf formula represented search
tree internal nodes represent partial assignments leaf nodes represent complete
assignments basic branch bound max sat explores search tree
depth first manner every node compares number clauses unsatisfied best complete assignment found far called upper bound u b
number clauses unsatisfied current partial assignment emptyclauses plus
underestimation minimum number non empty clauses become unsatisfied
extend current partial assignment complete assignment underestimation
sum emptyclauses underestimation lower bound lb minimum
number clauses unsatisfied complete assignment extended current partial
assignment obviously lb u b better solution cannot found point
search case prunes subtree current node backtracks
higher level search tree
lb u b tries possible better solution extending
current partial assignment instantiating one variable leads creation
two branches current branch left branch corresponds assigning
variable false right branch corresponds assigning variable true
case formula associated left right branch obtained formula
current node deleting clauses containing literal x x removing
occurrences literal x x e applies one literal rule
solution max sat value u b takes exploring entire search
tree
figure shows pseudo code basic solver max sat use following
notations
simplifyformula procedure simplifies applying sound inference rules
emptyclauses function returns number empty clauses


finew inference rules max sat

input max sat u b cnf formula upper bound u b
simplifyformula
contains empty clauses

return emptyclauses
end
lb emptyclauses underestimation u b
lb u b

return u b
end
x selectvariable
u b min u b max sat x u b
return min u b max sat x u b
output minimal number unsatisfied clauses
figure basic branch bound max sat
lb lower bound minimum number unsatisfied clauses current
partial assignment extended complete assignment assume initial
value
underestimation u b function returns underestimation minimum
number non empty clauses become unsatisfied current partial
assignment extended complete assignment
u b upper bound number unsatisfied clauses optimal solution
assume initial value total number clauses input formula
selectvariable function returns variable following heuristic
x x formula obtained applying one literal rule literal
x x
state art max sat solvers implement basic augmented powerful inference techniques good quality lower bounds clever variable selection heuristics
efficient data structures
recently defined li et al lower bound computation method
underestimation lower bound number disjoint inconsistent subsets
detected unit propagation pseudo code shown figure
example let following cnf formula
x x x x x x x x x x x x x
able establish number disjoint inconsistent
subsets clauses least therefore underestimation lower bound
steps performed following ones


fili manya planes

input underestimation u b cnf formula upper bound u b
underestimation
apply one literal rule unit clauses unit propagation empty
clause derived
empty clause derived

return underestimation
end
without clauses used derive empty clause
underestimation underestimation
underestimation emptyclauses u b

return underestimation
end
go
output underestimation lower bound
figure computation underestimation unit propagation
x x x x x x x first inconsistent subset detected unit
propagation x x x x x x underestimation
x x x x x second inconsistent subset detected unit propagation
x x underestimation
third inconsistent subset detected unit propagation x x x x
x underestimation since empty stops

inference rules
define set inference rules considered inspired different
unit resolution refinements applied sat selected could applied
natural efficient way already known literature bansal
raman niedermeier rossmanith others original max sat
presenting rules define integer programming transformation cnf
formula used establish soundness rules method proving soundness
novel max sat provides clear short proofs
integer programming transformation cnf formula
assume c cm cnf formula clauses variables x xn
let ci xi xik xik xik r note put positive literals
ci negative ones
consider variables ci integer variables taking values define
integer transformation ci
ei xi xik xik xik r xi xik xik xik r


finew inference rules max sat

obviously ei value iff least one variables xij j k instantiated
least one variables xis k k r instantiated
words ei iff ci satisfied otherwise ei
literal l corresponds integer denoted l convenience intention
correspondence literal l satisfied integer l unsatisfied
integer l l positive literal x corresponding integer l x l x l
l negative literal x l x l x x l consequently l l
case
generically write ci l l lk r integer programming transformation

ei l l lk r
integer programming transformation cnf formula c cm
variables x xn defined
e x xn


x

ei





integer programming transformation used huang jin li huang
design local search procedure called pseudo boolean formulation boros
hammer extend empty clauses ci empty ei
given assignment variables x xn value e number
unsatisfied clauses satisfies clauses e obviously minimum
number unsatisfied clauses minimum value e
let two cnf formulas let e e integer programming
transformations clear equivalent e e every
complete assignment
inference rules
next define inference rules prove soundness previous integer
programming transformation rest section denote cnf formulas
e e e integer programming transformations prove
equivalent prove e e
rule bansal raman l l lk l l lk
l lk equivalent
proof
e l l lk l l lk e
l lk e
e



general case resolution work max sat bansal raman rule
establishes resolution works two clauses give strictly shorter resolvent


fili manya planes

rule known literature replacement almost common clauses pay
special attention case k resolvent unit clause case k
resolvent empty clause describe latter case following rule
rule niedermeier rossmanith l l equivalent

proof e l l e e e



rule known complementary unit clause rule used replace two
complementary unit clauses empty clause empty clause contributes
lower bounds search space current node incrementing number
unsatisfied clauses incrementing underestimation means
contradiction redetected practice simple rule gives rise
considerable gains
following rule complicated case
rule l l l l l l equivalent
proof
e l l l l e
l l l e
l l l e
l l e
e



rule replaces three clauses empty clause adds binary clause
keep equivalence
pattern considered compute underestimations alsinet et al shen
zhang captured method computing underestimations
unit propagation li et al larrosa heras mentioned existential
directional arc consistency de givry zytnicki heras larrosa capture
rule note underestimation computation methods alsinet et al shen
zhang add additional clause detect contradictions
let us define rule generalizes rule rule presenting rule
define lemma needed prove soundness
lemma l l l l l l equivalent
proof
e l l l e
l l l l e
l l l l e
l l l e
e




finew inference rules max sat

rule l l l l l lk lk lk l l l l lk
lk equivalent
proof prove soundness rule induction k k l l
l l applying rule get l l k therefore
equivalent
assume rule sound k n let us prove sound k n
case
l l l l l ln ln ln ln ln
applying lemma last two clauses get
l l l l l ln ln ln ln ln
applying induction hypothesis first n clauses previous cnf formula
get
l l l l ln ln ln ln
k n therefore equivalent rule sound

rule original inference rule captures linear unit resolution refutations
clauses resolvents used exactly rule simply adds empty clause
eliminates two unit clauses binary clauses used refutation adds
binary clauses obtained negating literals eliminated binary clauses
operations involved performed efficiently
rule rule make explicit contradiction need redetected
current subtree lower bound computation becomes incremental moreover
binary clauses added rule rule may contribute compute better quality
lower bounds acting premises inference rule part
inconsistent subset clauses illustrated following example
example let x x x x x x x x x x x depending ordering
unit clauses propagated unit propagation detects one following three
inconsistent subsets clauses x x x x x x x x x x x x x
x inconsistent subset detected removed remaining set clauses
satisfiable without applying rule rule lower bound computed
underestimation computed unit propagation
note rule applied first inconsistent subset x x x x x x
rule applied contradiction made explicit clauses x x x x
added becomes x x x x x x x x x turns
inconsistent set clauses detectable unit propagation therefore lower bound
computed
inconsistent subset x x x x detected rule applied
contradiction made explicit clause x x added becomes x x x
x x x x x x turns inconsistent set clauses detectable
unit propagation therefore lower bound computed


fili manya planes

similarly inconsistent subset x x x x detected rule applied
lower bound computed
observe example rule rule make explicit contradiction allow improve lower bound
unit propagation needs least one unit clause detect contradiction drawback
rule rule consume two unit clauses deriving one contradiction possible situation branching two unit clauses could allow
unit propagation derive two disjoint inconsistent subsets clauses
following example
example let x x x x x x x x x x x x x x x x x x
rule replaces x x x x empty clause x x x
selected next branching variable assigned unit clause
contradiction detected via unit propagation lower bound
situation however rule applied branching two unit clauses
branching case propagation x allows detect inconsistent subset
x x x x x x x propagation x allows detect inconsistent
subset x x x x x x x lower bound computed branching
one hand rule rule add clauses contribute detect additional
conflicts hand application rule rule consumes two unit
clauses cannot used detect conflicts final effect two
factors empirically analyzed section
finally present two rules capture unit resolution refutations
exactly one unit clause consumed ii unit clause used twice linear
derivation empty clause
rule l l l l l l l l l l l l l
equivalent
proof
e l l l l l l l e
l l l l l l l l l e
l l l l l l l l l l l l l e
l l l l l l l l e
l l l l l l e
e



combine linear derivation rule obtain rule
rule l l l l l lk lk lk lk lk lk lk lk
l l l l lk lk lk lk lk lk lk lk
equivalent


finew inference rules max sat

proof prove soundness rule induction k k
l l l l l l l l l
lemma get
rule get

l l l l l l l l l
l l l l l l l l

k therefore equivalent
assume rule sound k n let us prove sound k n
case
l l l l l ln ln ln ln ln ln ln ln
lemma get
l l l l l ln ln ln ln ln ln ln ln
applying induction hypothesis get
l l l l ln ln ln ln ln ln ln ln
k n therefore equivalent rule sound

similarly rule rule rule rule make explicit contradiction
need redetected subsequent search therefore lower bound computation becomes incremental moreover add clauses improve
quality lower bound illustrated following example
example let x x x x x x x x x x x x x x depending
ordering unit clauses propagated unit propagation detect one
following inconsistent subsets x x x x x x x x x x x x x x
x x x x x x x rule applicable rule applied lower
bound computed underestimation function figure since remaining
clauses satisfiable inconsistent subset clauses removed rule allows
add two ternary clauses contributing another contradiction example rule
applied x x x x x x x adds clauses x x x x x x
remaining clauses x x x x x x x give second
contradiction detectable via unit propagation lower bound computed rule

contrast rule rule rule rule consume exactly one unit clause
deriving empty clause since unit clause used derive conflict
via unit propagation rule rule limit detection conflicts via
unit propagation


fili manya planes

implementation inference rules
section describe implementation inference rules presented section suppose cnf formula loaded every literal list clauses
containing constructed application rule means clauses
removed cnf formula clauses inserted formula
lower bound increased note inference rules selected
contains fewer literals fewer clauses clauses inserted
place removed clauses inference rule applied therefore
need dynamic memory management implementation faster
rule k rule applied matching see e g cormen
leiserson rivest stein efficient implementation lists clauses
first time complexity number clauses cnf
formula second time complexity u u number unit clauses
cnf formula rules applied every node lower bound computation application inference rules rule k applied many times
possible derive unit clauses applying rule
implementation rule rule rule rule entirely unit
propagation given cnf formula unit propagation constructs implication graph
g see e g beame kautz sabharwal applicability inference
rules detected section first describe construction implication graph
describe determine applicability rule rule rule rule
analyze complexity termination completeness application
rules finally discuss extension inference rules weighted max sat
implementation
implication graph
given cnf formula figure shows unit propagation constructs implication
graph whose nodes literals
note every node g corresponds different literal considered
different literals cnf formula contains several copies unit clause
adds one node label
example let x x x x x x x x x x x x x x x x x x x
u nitp ropagation constructs implication graph figure add special
node highlight contradiction
g acyclic every added edge connects node well known
time complexity unit propagation size see e g
freeman
associate clause c k k node k node k added g
c note node k incoming edge c unit k
node one incoming edge c binary k g constructed
g contains literal e unit propagation deduces contradiction
easy identify nodes exists path g e clauses


finew inference rules max sat

input u nitp ropagation cnf formula containing complementary unit
clauses literal
initialize g empty graph
add node labeled every literal unit clause c
repeat
k nodes g c k k clause k
node g
add g node labeled k
add g directed edge node k every k
end
nodes added literal nodes
g
return g
output implication graph g
figure unit propagation constructing implication graphs

x
x

x
x
x
x

x
x
x

figure example implication graph



fili manya planes

x
c
x
c

x
c
x
c

x
c
x
c

x
c

figure example implication graph
implying clauses constitute inconsistent subset
example clauses x x x x x x x x imply x clauses x x x x x
x x x imply x clause x x contribute contradiction
inconsistent subset x x x x x x x x x x x x x x x x
applicability rule rule rule rule
assume unit propagation deduces contradiction therefore implication
graph g contains literal let set nodes
exists path let set nodes exists path
let clause associated node g use
denote set clauses associated nodes respectively
lemma lemma used detect applicability rule rule rule
rule
lemma rule rule applicable
resp one unit clause clauses binary
nodes resp form implication chain starting unit clause ending
resp
empty
proof starting node corresponding unit clause resp
following parallel two implication chains rule rule writing
clause corresponding node
example let following cnf formula containing clauses c c c x c
x x c x x c x x c x c x x c x x unit propagation constructs implication graph shown figure contains complementary
literals x x
rule applicable x x c x c x c x c
x c x c x c easy verify three conditions lemma
satisfied
remark rewritten c x c x x c x x c x x c
x x c x x c x compared rule


finew inference rules max sat

x
c

x
c

x
c
x
c

x
c

figure example implication graph
application rule rule consists replacing every binary clause c
binary clause obtained negating every literal c removing two unit clauses
incrementing emptyclauses
lemma rule rule applicable
one unit clause clauses binary e
nodes except node corresponding unit clause exactly one
incoming edge g
non empty contains k k nodes forming implication chain
form k k last node chain
contains exactly three nodes third one let k
third literal
k g contains following implications
k k
k
k g contains following implications
k
k k
proof assume without loss generality k case k symmetric implication chain formed nodes corresponds clauses
k k together three clauses k k k k
corresponding k k k give rule rule
example let following cnf formula containing clauses c c c x c
x x c x x c x x c x x unit propagation constructs implication
graph shown figure contains complementary literals x x
sx x c x c x c sx x c x c x c x c
nodes sx sx obviously form implication chain x x sx sx sx
sx x c x c x c g contains x x x x x rule applicable
application rule rule consists removing unit clause
replacing binary clause c binary clause obtained c
negating two literals c replacing three binary clauses
two ternary clauses incrementing emptyclauses


fili manya planes

complexity termination completeness rule applications
branch bound max sat combine application inference rules computation underestimation lower bound given cnf
formula function underestimation uses unit propagation construct implication
graph g g contains two nodes literal g analyzed determine
whether inference rule applicable rule applicable applied
transformed equivalent max sat instance otherwise clauses contributing
contradiction removed underestimation incremented
procedure repeated unit propagation cannot derive contradictions finally
removed clauses except removed replaced due inference rule applications
reinserted underestimation together returned
well known unit propagation implemented time complexity linear
size see e g freeman complexity determining applicability
inference rules lemma lemma linear size g bounded
number literals assume graph represented doubly linked
lists application inference rule obviously linear size g whole
time complexity function underestimation inference rule applications
number contradictions function underestimation able detect
unit propagation observe factor needed application
rules inserts clauses place removed clauses
since every inference rule application reduces size function underestimation
inference rule applications linear space complexity terminates recall
clauses added inference rules stored place old ones
data structures loading statically efficiently maintained
proved inference rules sound following example shows
application rules necessarily complete implementation sense
possible applications inference rules necessarily done
example let x x x x x x x x x unit propagation may discover
inconsistent subset x x x x x x case inference rule applicable underestimation lower bound incremented
becomes x x x unit propagation cannot detect contradictions function underestimation stops reinserting x x x x x x value
returned together unchanged note rule applicable subset
x x x x applied
actually function underestimation applies rule unit propagation detects
inconsistent subset x x x x instead x x x x x x detection
inconsistent subset depends ordering unit clauses propagated unit
propagation example inconsistent subset x x x x discovered unit
clause x propagated x x study needed define orderings
unit clauses maximize application inference rules
observe deterministic computes lower bound
order clauses changed


finew inference rules max sat

inference rules weighted max sat
inference rules presented naturally extended weighted max sat
weighted max sat every clause associated weight consists
finding truth assignment sum weights unsatisfied clauses
minimum example weighted version rule could
rule l w l l w l w w l l w l w
w l l w w l w w equivalent
w w w positive integers representing clause weight w min w
w w mandatory clauses satisfied optimal solution specified
weight note w w w optimal solution
found solver backtrack clauses weight removed observe
rewritten l w l l w l w l w
w l l w w l w w weighted inference rule equivalent
unweighted version applied w times unweighted clauses
similarly weighted version rule could
rule l w l l w l l w lk lk wk lk wk
w l l w l l w lk lk w l w w l l w
w l l w w lk lk wk w lk wk w equivalent
w min w w wk observe rewritten
l w l l w l l w lk lk w lk w weighted version
rule equivalent unweighted rule applied w times unweighted clauses

current implementation inference rules naturally extended weighted
inference rules inconsistent subformula detected rule applicable clause
weights considered detection inconsistent subformula applicability rule provided clauses weight discarded
separated computing minimal weight w clauses detected
inconsistent subformula rule applied derived clauses clauses
used subsequent reasoning

maxsatz max sat solver
implemented max sat solver called maxsatz incorporates lower
bound computation method unit propagation defined section applies
inference rules defined section name maxsatz comes fact
implementation incorporates technology developed
sat solver satz li anbulagan b
maxsatz incorporates lower bound unit propagation applies rule
rule rule rule rule rule addition maxsatz applies following
techniques
pure literal rule literal appears positive polarity negative
polarity delete clauses containing literal


fili manya planes

empty unit clause rule alsinet et al let neg x pos x number
unit clauses x negative positive emptyclauses neg x u b
assign x false emptyclauses pos x u b assign x
true
dominating unit clause duc rule niedermeier rossmanith number clauses literal x x appears greater neg x pos x
assign x false true
variable selection heuristic let neg x pos x number binary clauses
x negative positive let neg x pos x number clauses
containing three literals x negative positive select
variable x neg x neg x neg x pos x pos x pos x
largest fact binary clauses counted four times
clauses determined empirically
value selection heuristic let x selected branching variable neg x
neg x neg x pos x pos x pos x set x true otherwise set x
false heuristics determined empirically
order compare inference rules defined used three simplified versions maxsatz
maxsat apply inference rule defined section
maxsat applies rules rules
maxsat applies rules rules
actually maxsatz corresponds maxsat terminology maxsat corresponds improved version solver u p li et al special ordering
propagating unit clauses unit propagation maxsat maintains two queues
unit propagation q q maxsat starts search inconsistent subformula via unit propagation q contains unit clauses cnf formula
consideration recently derived unit clauses end q q empty
unit clauses derived application unit propagation stored q
unit propagation use unit clause q unless q empty intuitively
ordering prefers unit clauses non unit clauses starting application
unit propagation way derived inconsistent subset contains general less unit
clauses unit clauses consumed contribute detect
inconsistent subsets experimental li manya planes
search tree size maxsat substantially smaller maxsat
substantially faster maxsat maxsat maxsatz use ordering
maxsat propagating unit clauses unit propagation
source code maxsat maxsat maxsat maxsatz found
http web udl es usuaris jair maxsatz solvers zip http www laria upicardie fr cli maxsatz tar gz


finew inference rules max sat

experimental
report experimental investigation performed unweighted max sat order
evaluate inference rules defined section compare maxsatz
best performing state art solvers publicly available
submitted experiments performed linux cluster processors ghz
amd opteron gb ram
structure section follows first describe solvers benchmarks
considered present experimental evaluation inference
rules finally experimental comparison maxsatz solvers
solvers benchmarks
maxsatz compared following max sat solvers
bf borchers furman branch bound max sat solver uses
moms dynamic variable selection heuristic consider underestimations
computation lower bound developed borchers furman

agn alber et al branch bound max sat solver developed
alber gramm niedermeier
amp alsinet et al b branch bound max sat solver bf
incorporates lower bound better quality jeroslow wang variable selection
heuristic jeroslow wang developed alsinet manya planes
presented sat
toolbar de givry et al larrosa heras max sat solver whose
inference inspired soft arc consistency properties implemented weighted csp
solvers developed de givry larrosa meseguer schiex first
presented cp used version default parameters
maxsolver xing zhang branch bound max sat solver applies
number efficient inference rules developed xing zhang presented
cp used second release solver
lazy alsinet et al branch bound max sat solver lazy data
structures static variable selection heuristic developed alsinet manya
planes presented sat







downloaded october http infohost nmt edu borchers satcodes tar gz
downloaded october http www fs informatik uni tuebingen de gramm
available http web udl es usuaris software html
downloaded october http carlit toulouse inra fr cgi bin awki cgi toolbarintro
downloaded october http cic cs wustl edu maxsolver
available http web udl es usuaris software html



fili manya planes

li et al branch bound max sat solver lower bound
computation method unit propagation cf section developed
li manya planes presented cp
used benchmarks randomly generated max sat instances max sat instances graph coloring instances well max cut instances considered
unweighted max sat benchmarks submitted max sat evaluation including
max cut max ones ramsey numbers random max sat max sat instances
generated max sat instances max sat instances generator mwff c
developed bart selman allows duplicated clauses max cut first
generated random graph edges every edge randomly selected among
set possible edges graph connected discarded graph
connected used encoding shen zhang encode max cut
instance cnf created edge xi xj exactly two binary clauses xi xj
xi xj collection binary clauses max cut instance
cut weight k iff max sat instance assignment k clauses
satisfied
graph coloring first used culbersons generator generate random kcolorable graph type iid independent random edge assignment variability
k vertices fixed edge density used culbersons converter sat standard conversion three colors generate max sat instance vertex xi
color j propositional variable xij defined meaning vertex
colored color j vertex xi four clauses added encode vertex
colored exactly one color xi xi xi xi xi xi xi xi xi
edge xi xj three clauses added encode vertex xi vertex xj
color xi xj xi xj xi xj
random max sat max sat instances clauses entirely independent
structure graph coloring instances max cut instances
used clauses independent structure example
max cut instance every time clause xi xj clause xi xj
satisfaction two clauses means corresponding edge cut
graph coloring instance every time ternary clause xi xi xi encoding
vertex colored least color three binary clauses xi xi xi xi
xi xi encoding vertex cannot colored two colors maxcut instances contain binary clauses graph coloring instances contain ternary
clause every vertex graph derive optimal cut optimal
assignment max sat encoding max cut instance optimal assignment
max sat encoding coloring instance may assign one color vertices
available http web udl es usuaris software html
given undirected graph g v e v x xn set vertices e set
edges set three colors graph coloring coloring every vertex
one three colors way edge xi xj e vertex xi vertex xj
color
given undirected graph g v e let wxi xj weight associated edge xi xj e
p
weighted max cut subset v w xi xj wxi xj
maximized v set weight wxi xj edges



finew inference rules max sat

max cut ramsey numbers instances max sat evaluation contain different structures example underlying graphs max cut instances
different origins fault diagnosis coding theory graph
clique max sat max sat instances evaluation contain
duplicated clauses
computed initial upper bound local search solver instance
provide parameter solver except instance solved initial
upper bound words used default values parameters
instances max sat evaluation solved conditions
evaluation e initial upper bound provided solvers maximum time
allowed solve instance minutes
evaluation inference rules
first experiment performed evaluate impact inference rules section
solved sets random max sat instances variables number
clauses ranged variables variables
obtained shown figure along horizontal axis number
clauses along vertical axis mean time left plot seconds needed solve
instance set mean number branches proof tree right plot notice
use log scale represent run time branches
observe rules powerful max sat gain increases
number variables number clauses increase variables
clauses clause variable ratio maxsatz times faster maxsat
variables clauses clause variable ratio maxsatz
times faster maxsat search tree maxsatz substantially smaller
maxsat rule rule powerful rule rule
max sat intuitive explanation maxsatz maxsat detect many
inconsistent subsets clauses containing one unit clause subsets containing two unit
clauses rule rule applied many times rule rule
maxsatz
recall one hand every application rule rule consumes two
unit clauses produces one empty clause limiting unit propagation detecting
conflicts subsequent search hand rule rule add clauses
may contribute detect conflicts depending number clauses
precisely clause variable ratio formula two factors different
importance relatively clauses unit propagation relatively
easily derive contradiction unit clause binary clauses added rule
rule relatively important deriving additional conflicts improving lower
bound explains search tree maxsat smaller search tree
maxsat instances variables less clauses contrary
many clauses unit propagation easily derives contradiction unit
clause two unit clauses consumed rule rule would probably allow
derive two disjoint inconsistent subsets clauses addition binary clauses added
rule rule relatively less important deriving additional conflicts considering


fili manya planes

large number clauses formula case search tree maxsat
larger search tree maxsat however cases maxsat faster
maxsat meaning incremental lower bound computation due rule
rule effective since redetection many conflicts avoided thanks rule
rule

max sat variables
e



e

branches log scale

time logscale

max sat variables





maxsat
maxsat
maxsat
maxsatz











maxsat
maxsat
maxsat
maxsatz










number clauses



e








maxsat
maxsat
maxsat
maxsatz





number clauses



max sat variables
e
branches log scale

time logscale

max sat variables






number clauses



e


maxsat
maxsat
maxsat
maxsatz












number clauses





figure comparison among maxsat maxsat maxsatz random max sat instances

rule rule limit unit propagation detecting conflicts since
application produces one empty clause consumes one unit clause allows
derive one conflict case added ternary clauses allow improve
lower bound search tree maxsatz substantially smaller search
tree maxsat incremental lower bound computation due rule rule
contributes time performance maxsatz example search tree
maxsatz instances variables clauses times smaller
search tree maxsat maxsatz times faster maxsat
second experiment solved random max sat instances instead random
max sat instances solved instances variables number clauses
ranged variables variables
obtained shown figure


finew inference rules max sat

max sat variables

max sat variables
e
branches log scale

time log scale






maxsat
maxsat
maxsat
maxsatz










number clauses

e








max sat variables




number clauses



max sat variables
e
branches log scale



time logscale

maxsat
maxsat
maxsat
maxsatz






maxsat
maxsat
maxsat
maxsatz










number clauses





e

e
maxsat
maxsat
maxsat
maxsatz










number clauses





figure comparison among maxsat maxsat maxsatz random max sat instances

although rules involve ternary clauses powerful max sat
similarly max sat rule rule slightly improve lower bound
relatively clauses improve lower bound number clauses
increases improve time performance thanks incremental lower bound
computation allowed gain increases number clauses increases
example variables number clauses maxsat
faster maxsat number clauses gain
rule rule improve lower bound time performance maxsatz
gain increases number clauses increases
third experiment considered max cut graphs vertices
number edges ranging figure shows comparing
inference rules max cut instances observe rules allow us solve
instances much faster similarly random max sat rule rule
improve lower bound many clauses improve time performance
due incremental lower bound computation allowed rule rule
powerful rule rule instances contain binary clauses
structure addition reduction tree size due rule rule
contributes time performance maxsatz incrementality lower
bound computation random max sat example search tree maxsatz
instances edges times smaller search tree maxsat
maxsatz times faster


fili manya planes

max cut nodes
e



e
branches log scale

time log scale

max cut nodes







maxsat
maxsat
maxsat
maxsatz










number edges

e
e



maxsat
maxsat
maxsat
maxsatz














number edges





figure experimental max cut

fourth experiment considered graph coloring instances vertices density edges ranging figure shows
comparing inference rules graph coloring instances observe rule
rule useful instances tree size maxsat maxsat almost
maxsat slower maxsat contrary rules
useful instances especially allow reduce search tree size
deriving better lower bounds

graph coloring nodes

graph coloring nodes

branches log scale

time log scale






maxsat
maxsat
maxsat
maxsatz

e








edges






maxsat
maxsat
maxsat
maxsatz










graph coloring nodes



edges











graph coloring nodes
e
branches log scale



time log scale






maxsat
maxsat
maxsat
maxsatz












edges



e

e
maxsat
maxsat
maxsat
maxsatz














edges

figure experimental graph coloring




finew inference rules max sat

note rule rule impact rule rule reducing
cost solving instances probably due fact two unit clauses
needed detect contradiction rule rule applied many times
note instances vertices become easier solve density
graph high
fifth experiment compared different inference rules benchmarks submitted max sat evaluation solvers ran conditions
evaluation table first column name benchmark set second
column number instances set rest columns display average
time seconds needed solver solve instance number solved instances
brackets maximum time allowed solve instance minutes
clear maxsat better maxsat maxsat better maxsat
maxsatz better maxsat example maxsatz solves three maxcut
johnson instances within time limit solvers solve two instances
average time maxsatz solve one three instances seconds
third instance needing time solved two instances
set name
maxcut brock
maxcut c fat
maxcut hamming
maxcut johnson
maxcut keller
maxcut p hat
maxcut san
maxcut sanr
maxcut max cut
maxcut spinglass
maxone
ramsey
max sat vars
max sat vars
max sat vars
max sat discarded
max sat vars
max sat vars

instances



















maxsat



















maxsat



















maxsat



















maxsatz



















table evaluation rules benchmarks max sat evaluation
comparison maxsatz solvers
first experiment performed compare maxsatz state art
max sat solvers solved sets random max sat instances
variables number clauses ranged variables
variables variables solving
instances bf agn amp lazy toolbar maxsolver maxsatz shown
figure along horizontal axis number clauses along vertical axis
mean time seconds needed solve instance set solver needed
much time solve instances point stopped corresponding point
shown figure variable instances bf one point
figure clauses variable instances bf amp one


fili manya planes

point figure clauses version maxsolver used limits number
clauses instances solved ran instances clauses
see dramatic differences performance maxsatz rest solvers
figure hardest instances maxsatz two orders magnitude faster
second best performing solvers instances maxsatz needs second
solve instance solvers maxsolver toolbar able solve
instances seconds
second experiment solved random max sat instances instead random
max sat instances obtained shown figure consider
agn solve max sat instances solved instances
variables number clauses ranged variables
variables variables variables amp
one point figure clauses bf slow variables
compared two best solvers observe dramatic differences
performance profile maxsatz rest solvers particularly remarkable
differences maxsatz toolbar second best performing solver max sat see maxsatz times faster toolbar hardest
instances
third experiment considered max cut graphs vertices
number edges ranging figure shows obtained bf
one point figure edges maxsolver solved instances edges
clauses observe maxsatz superior rest solvers
fourth experiment considered coloring graphs
vertices density edges ranging agn considered
solve max sat instances vertices compared three
best solvers maxsolver different version limiting number clauses
instance solved figure shows comparative different solvers
maxsatz best performing solver maxsolver substantially better
rest solvers

max cut nodes


time log scale



bf
amp
agn
lazy
toolbar
maxsolver

maxsatz







number edges

figure experimental max cut


finew inference rules max sat

max sat variables


time log scale





bf
amp
agn
lazy
toolbar
maxsolver

maxsatz






number clauses
max sat variables


time log scale





bf
amp
agn
lazy
toolbar
maxsolver

maxsatz







number clauses
max sat variables


time log scale





bf
amp
agn
lazy
toolbar
maxsolver

maxsatz





e





number clauses

figure experimental variable variable variable random max sat instances



fili manya planes

max sat variables


time log scale



bf
amp
lazy
toolbar
maxsolver

maxsatz







number clauses



max sat variables

time log scale






amp
lazy
toolbar
maxsolver

maxsatz





number clauses
max sat variables


time log scale








toolbar
maxsatz





number clauses



figure experimental variable variable variable random max sat instances



finew inference rules max sat

graph coloring nodes


time log scale






bf
amp
lazy
maxsolver
toolbar

maxsatz




e


edges
graph coloring nodes


time log scale






maxsolver

maxsatz




edges

figure experimental graph coloring

fifth experiment compared max sat solvers benchmarks submitted
max sat evaluation solvers ran conditions evaluation
table first column name benchmark set second column
number instances set rest columns display average time seconds
needed solver solve instance within time limit minutes number
instances solved within time limit brackets dash means corresponding
solver cannot solve set instances clear maxsatz best performing
solver sets

related work
simplest method compute lower bound consists counting number
clauses unsatisfied current partial assignment borchers furman one step
forward incorporate underestimation number clauses become
unsatisfied current partial assignment extended complete assignment
basic method defined wallace freuder


instances



















bf



















amp



















agn
















toolbar



















lazy



















maxsolver







































table experimental benchmarks max sat evaluation

maxsatz





















li manya planes

set name
maxcut brock
maxcut c fat
maxcut hamming
maxcut johnson
maxcut keller
maxcut dimacs p hat
maxcut san
maxcut sanr
maxcut max cut
maxcut spinglass
maxone
ramsey ram k
max sat vars
max sat vars
max sat vars
max sat discarded
max sat vars
max sat vars

finew inference rules max sat

lb emptyclauses
x

x

occurs

min ic x ic x


cnf formula associated current partial assignment ic x ic x
inconsistency count x x number unit clauses contain x x
underestimation lower bound improved applying binary clauses
directional arc consistency dac count defined wallace max csp
dac count value variable x number variables inconsistent
value x example contains clauses x x x value
x inconsistent note value inconsistent x
two inconsistencies disjoint cannot summed wallace defined direction
x inconsistency value x counted defining
direction every pair variables sharing constraint one computes dac count
values x checking variables direction x defined
underestimation considering dac count wallace follows

x

x

occurs

min ic x ic x min dac x dac x


dac x dac x dac count value x wallace statically defined
directions dac x dac x computed preprocessing step every
x need recomputed search improved larrosa meseguer
schiex introducing reversible dac searches better directions
obtain better lower bound every node search tree improvement dac
counts additional incorporation inconsistencies contributed disjoint subsets
variables particular variable partitions larrosa meseguer
inconsistent dac counts deal unit binary clauses lower bounds dealing
longer clauses include star rule shen zhang alsinet et al li
et al
star rule underestimation lower bound number disjoint
inconsistent subformulas form l lk l lk star rule k
equivalent inconsistency counts wallace freuder
subsumes inconsistent count method unit clauses star rule
effectiveness producing good lower bound illustrated following example
let cnf formula containing clauses x x x x x x x x x x x x
x x x x easily detects inconsistent subset clauses variables
time linear size formula note subset detected
lower bounds described except variable partition larrosa
meseguer case variables partition
mention two lower bound computation methods one called lb
defined shen zhang similar restricted max sat instances
static variable ordering another linear programming
defined xing zhang
regin et al suggested use arc consistency instead unit propagation detect
disjoint inconsistent subsets constraints weighted constraint networks however


fili manya planes

best knowledge idea incorporated lower bound computation
method implemented constraint programming community
good lower bound computation method dramatic impact performance
max sat solver another speed max sat solver consists applying
inference rules transform max sat instance equivalent simpler max sat
instance inference rules proven useful practice include pure
literal rule alsinet et al b xing zhang li et al zhang et al
ii dominating unit clause rule first proposed niedermeier rossmanith
later applied several solvers alsinet et al xing zhang li et al
iii almost common clause rule first proposed bansal raman
restated rule rule extended weighted max sat byalsinet
et al called neighborhood resolution larrosa heras used
preprocessing technique alsinet et al shen zhang li et al
iv complementary unit clause rule niedermeier rossmanith restated rule
v coefficient determining unit propagation rule xing zhang
integer programming
inference rules presented simplify max sat formula allow
improve lower bound computation since transform max sat formula
simpler equivalent formula containing empty clauses soundness
e fact transform formula equivalent one proved several
ways including checking possible variable assignments ii integer programming
done section iii soft local consistency techniques defined weighted
constraint networks wcn max sat defined subcase wcn variables
boolean unit costs used
soft local consistency techniques wcn two basic equivalence preserving
transformations called projection extension schiex cooper schiex
given max sat instance projection replaces two binary clauses x x
unit clause x rule k extension inverse operation projection
replaces unit clause x two binary clauses x x selected variable
projection operation rather straightforward sat max sat instance
extension operation ingenious see note rule proved
applied extension followed projection
l l l l l l l l l l l
l l l l
l l
lemma proved extension followed projection
l l l l l l l l l
l l l
extension operation cannot used unguided way may cancel
previous projection one way guide use define ordering variables


finew inference rules max sat

enforce directional arc consistency cooper cooper schiex directional arc
consistency allows concentrate weights variables shifting weights
earlier variables later ones given ordering example x x given variable
ordering one extend unit clause x x x x x cannot extend unit clause x
x x x x allowing unit clauses concentrated variable x nevertheless
define variable ordering efficiently exploit much possible power
soft arc consistency techniques lower bound computation remains open
inference rules max sat presented need
predefined ordering among variables since rule applications combining several projection extension operations entirely guided unit propagation
projection extension operations extended constraints involving
two variables achieve high order consistency wcn cooper maxsat instance extended projection extension operations stated rule
k two formulas rule replacing projection
extension given unit clause x three variables x z extension
unit clause x set three variables done follows replacing x
x x x x x z x z x z x z
rule proved applied extending four clauses ternary clauses
three variables l l l applying projection operation obtain
larrosa et al logical independently parallel
work defined implemented chain resolution rule cycle resolution rule
weighted max sat two rules extensions rules res res presented
independently parallel work heras larrosa
chain resolution could stated follows


li mi mi ik




li li ui mi k

l u
li li mi k
li li ui k




l u
mk
lk uk


k k
mk













ik ui weight corresponding clause mi min u u ui
variables literals different weight mandatory clause denoted
subtraction extended ui chain resolution rule
equivalent rule applied unweighted max sat main difference
chain resolution rule weighted version rule presented section
chain resolution shifts part weight unit clause l mk
derived weighted version rule create unit clauses li mi mi ik
l mk becoming l
cycle resolution rule could stated follows


fili manya planes



li li ui k
l lk uk





















l li mi mi ik
li li ui mi k
l li li mi k
l li li mi k
l lk uk mk
l mk

















subset binary clauses cyclic structure cycle resolution rule allows
derive unit clause note detection cyclic structure appears rather timeconsuming applied every node search tree k ternary
clauses inserted larrosa et al apply cycle resolution rule practice
case k similar rule applied unweighted max sat
cycle resolution rule applied unweighted max sat k replace rule
rule maxsatz following differences compared rule rule
application rule rule entirely inconsistent subformulas
detected unit propagation detection applicability rule rule
easy low overhead since inconsistent subformulas detected
maxsatz compute lower bound without rule rule every
application rule rule allows increment lower bound
cycle resolution rule needs extra detection cyclic structure allows
derive unit clause cyclic structure derived unit clause could
used unit propagation possibly could allow detect inconsistent
subformula increase lower bound
would interesting future topic implement cycle resolution rule
maxsat e maxsatz without rule rule evaluate overhead detecting
cyclic structure usefulness unit clauses ternary clauses derived
cycle resolution rule compare implemented solver maxsatz
would interesting compare chain resolution rule cycle resolution rule
weighted inference rules presented section
general max sat resolution rule conclusions clausal
form defined larrosa heras independently bonet et al
heras larrosa defined version rule conclusions clausal
form bonet et al proved rule complete max sat recently
ansotegui et al b shown max sat resolution many valued cnf
formulas provides logical framework global local consistency properties defined
wcn

conclusions future work
one main drawbacks state art max sat solvers lack suitable
inference techniques allow detect much contradictions possible simplify
formula node search tree existing approaches put emphasis
computing underestimations good quality underestimations


finew inference rules max sat

contradictions computed furthermore turns
u p one currently best performing underestimations consisting detecting
disjoint inconsistent subsets clauses cnf formula via unit propagation still
conservative make computation lowers incremental improve
underestimation defined number original inference rules max sat
derived contradictions unit propagation transform max sat instance
equivalent max sat instance easier solve rules carefully selected
taking account applied efficiently since rules
contradiction detection particularly useful hard max sat instances
containing many contradictions
aim finding powerful inference rules practice
developed max sat solver called maxsatz incorporates rules
performed experimental investigation comparing maxsatz inference
rules maxsatz without inference rules provide empirical evidence usefulness
rules making lower bound computation incremental improving
quality lower bounds comparing maxsatz large selection
solvers available time submitting provide empirical evidence
maxsatz least instances solved faster solvers observed gains
several orders magnitude hardest instances interestingly benchmarks
used second best solver generally different max sat toolbar max sat maxsolver max cut maxsolver graph coloring maxsatz
robust rest solvers worth mentioning maxsatz enhanced
lower bound failed literal detection li et al best performing
solver unweighted max sat instances max sat evaluation second
third best performing solvers respectively improved versions toolbar lazy
future work plan study orderings unit clauses unit propagation
maximize application inference rules define inference rules ternary
clauses extending weighted max sat
suitable modeling maximum clique set covering combinatorial
auctions well constraint satisfaction hard instances model rb xu
boussemart hemery lecoutre xu li adapting
partial max sat solvers developed argelich manya


acknowledgments
partially supported projects tin c tin c funded ministerio de educacion ciencia first author partially supported national program china grant cb second
author supported grant ramon cajal finally would thank referees
detailed comments suggestions
see http www iiia csic es maxsat details note max sat evaluation
compared obtained cluster
conditions



fili manya planes

references
alber j gramm j niedermeier r faster exact hard
parameterized point view discrete mathematics
alsinet manya f planes j improved branch bound
max sat weighted max sat proceedings catalonian conference
artificial intelligence ccia p mallorca spain vol frontiers
artificial intelligence applications pp ios press
alsinet manya f planes j b improved branch bound
max sat proceedings th international conference theory
applications satisfiability testing sat portofino italy pp
alsinet manya f planes j max sat solver lazy data structures proceedings th ibero american conference artificial intelligence
iberamia puebla mexico lncs pp springer
alsinet manya f planes j improved exact solver weighted maxsat proceedings th international conference theory applications
satisfiability testing sat st andrews scotland lncs pp
springer
ansotegui c bonet l levy j manya f inference rules high order
consistency weighted csp proceedings nd national conference
artificial intelligence aaai vancouver canada pp aaai press
ansotegui c bonet l levy j manya f b logic behind weighted csp
proceedings th international joint conference artificial intelligence
ijcai hyderabad india pp aaai press
argelich j manya f solving constrained sat technology
proceedings th international conference theory applications
satisfiability testing sat st andrews scotland lncs pp springer
argelich j manya f exact max sat solvers constrained
journal heuristics
argelich j manya f partial max sat solvers clause learning proceedings th international conference theory applications satisfiability
testing sat lisbon portugal lncs pp springer
bansal n raman v upper bounds maxsat improved proceedings th international symposium computation isaac
chennai india lncs pp springer
beame p kautz h sabharwal understanding power clause learning
proceedings th international joint conference artificial intelligence
ijcai acapulco mexico pp morgan kaufman
bonet l levy j manya f complete calculus max sat proceedings th international conference theory applications satisfiability
testing sat seattle usa lncs pp springer


finew inference rules max sat

bonet l levy j manya f resolution max sat artificial intelligence

borchers b furman j two phase exact max sat weighted
max sat journal combinatorial optimization
boros e hammer p pseudo boolean optimization discrete applied mathematics
cooper c reduction operations fuzzy valued constraint satisfaction fuzzy
sets systems
cooper c high order consistency valued constraint satisfaction constraints

cooper c schiex arc consistency soft constraints artificial intelligence
cormen h leiserson c e rivest r l stein c introduction
second edition mit press
davis logemann g loveland machine program theorem proving
communications acm
davis putnam h computing procedure quantification theory journal
acm
de givry larrosa j meseguer p schiex solving max sat weighted
csp proceedings th international conference principles practice
constraint programming cp kinsale ireland lncs pp
springer
de givry zytnicki heras f larrosa j existential arc consistency getting closer full arc consistency weighted csps proceedings th international joint conference artificial intelligence ijcai edinburgh scotland
pp
freeman j w improvements propositional satisfiability search
ph thesis department computer information science university pennsylvania pa usa
goldberg e novikov berkmin fast robust sat solver proceedings
design automation test europe date paris france pp
ieee computer society
heras f larrosa j inference rules efficient max sat solving proceedings st national conference artificial intelligence aaai boston
usa aaai press
huang w q jin r c solar learning human solving
sat science china series e
jeroslow r g wang j solving propositional satisfiability annals
mathematics artificial intelligence


fili manya planes

larrosa j heras f resolution max sat relation local consistency
weighted csps proceedings th international joint conference artificial intelligence ijcai edinburgh scotland pp morgan kaufmann
larrosa j heras f de givry logical efficient max sat
solving artificial intelligence press
larrosa j meseguer p partition lower bound max csp constraints

larrosa j meseguer p schiex maintaining reversible dac max csp
artificial intelligence
li c constraint narrow search trees satisfiability
information processing letters
li c anbulagan heuristics unit propagation satisfiability
proceedings th international joint conference artificial
intelligence ijcai nagoya japan pp morgan kaufmann
li c anbulagan b look ahead versus look back satisfiability
proceedings rd international conference principles constraint programming cp linz austria lncs pp springer
li c huang w q diversification determinism local search
satisfiability proceedings th international conference theory applications satisfiability testing sat st andrews scotland lncs pp
springer
li c manya f planes j exploiting unit propagation compute lower
bounds branch bound max sat solvers proceedings th international conference principles practice constraint programming cp
sitges spain lncs pp springer
li c manya f planes j detecting disjoint inconsistent subformulas
computing lower bounds max sat proceedings st national conference
artificial intelligence aaai boston usa pp aaai press
marques silva j p sakallah k grasp search propositional
satisfiability ieee transactions computers
niedermeier r rossmanith p upper bounds maximum satisfiability
journal
regin j c petit bessiere c puget j f lower bounds constraint
violations constrained th international conference principles practice constraint programming cp paphos cyprus lncs
pp springer
schiex arc consistency soft constraints proceedings th international conference principles constraint programming cp singapore
lncs pp springer


finew inference rules max sat

shen h zhang h study lower bound functions max sat proceedings
national conference artificial intelligence aaai san jose usa pp
aaai press
shen h zhang h improving exact max sat annals mathematics artificial intelligence
wallace r j directed arc consistency preprocessing constraint processing
selected papers lncs pp springer
wallace r j freuder e comparative studies constraint satisfaction
davis putnam maximum satisfiability johnson
trick eds cliques coloring satisfiability vol pp american
mathematical society
xing z zhang w efficient strategies weighted maximum satisfiability
proceedings th international conference principles practice constraint programming cp toronto canada lncs pp springer
xing z zhang w efficient exact weighted maximum satisfiability artificial intelligence
xu k boussemart f hemery f lecoutre c simple model generate
hard satisfiable instances proceedings th international joint conference
artificial intelligence ijcai edinburgh scotland pp
xu k li w many hard examples exact phase transitions theoretical
computer science
zhang h sato efficient propositional prover proceedings conference
automated deduction cade pp
zhang h shen h manya f exact max sat electronic
notes theoretical computer science
zhang l madigan c moskewicz malik efficient conflict driven learning
boolean satisfiability solver international conference computer aided
design iccad san jose usa pp




