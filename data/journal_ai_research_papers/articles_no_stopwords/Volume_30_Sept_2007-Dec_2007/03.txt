Journal Artificial Intelligence Research 30 (2007) 501-523

Submitted 06/07; published 12/07

Semantics Logic Programs Preferences
Sergio Greco

greco@deis.unical.it

DEIS, Universita della Calabria
via P. Bucci, 87030 Rende - Italy

Irina Trubitsyna

irina@deis.unical.it

DEIS, Universita della Calabria
via P. Bucci, 87030 Rende - Italy

Ester Zumpano

zumpano@deis.unical.it

DEIS, Universita della Calabria
via P. Bucci, 87030 Rende - Italy

Abstract
work contribution prioritized reasoning logic programming presence
preference relations involving atoms. technique, providing new interpretation
prioritized logic programs, inspired semantics Prioritized Logic Programming
enriched use structural information preference Answer Set Optimization Programming. Specifically, analysis logic program carried together
analysis preferences order determine choice order sets
comparable models. new semantics compared approaches known
literature complexity analysis performed, showing that, respect
similar approaches previously proposed, complexity computing preferred stable models increase.

1. Introduction
increased interest preferences witnessed extensive number proposals
systems preference handling (Grell, Konczak, & Schaub, 2005; Van Nieuwenborgh &
Vermeir, 2003; Wakaki, Inoue, Sakama, & Nitta, 2003, 2004). literature distinguishes
static dynamic preferences. Static preferences fixed time theory specified, i.e. external logic program, whereas dynamic preferences appear
within logic program determined fly. common form
preference consists specifying preference conditions among rules (Brewka, 1996; Brewka
& Eiter, 1999, 2000; Delgrande, Schaub, & Tompits, 2000a, 2000b, 2003; Gelfond & Son,
1997; Schauba & Wang, 2001; Van Nieuwenborgh & Vermeir, 2002, 2004; Wang, Zhou, &
Lin, 2000; Zhang & Foo, 1997), whereas, recent proposals admit expression
preference relations among atoms (Brewka, Niemela, & Truszczynski, 2003; Brewka, 2004;
Sakama & Inoue, 2000; Wakaki et al., 2003). sophisticated forms preferences
allow specification priorities conjunctions (disjunctions) literals (Brewka
et al., 2003; Delgrande et al., 2000a; Sakama & Inoue, 2000) numerical penalties
suboptimal options (Brewka, 2004).
work contribution prioritized reasoning logic programming presence
preference conditions involving atoms. particular, priorities applied following
natural ordering defined dependencies, proposed Answer Set Optimizac
2007
AI Access Foundation. rights reserved.

fiGreco, Trubitsyna, & Zumpano

tion (ASO) semantics (Brewka et al., 2003), comparison strategy, proposed
Preferred Stable Model (PSM) semantics (Sakama & Inoue, 2000), reviewed introducing concept comparable models. next example describes intuition
basis proposed approach.
Example 1 following prioritized program hP 1 , 1 i, inspired program presented
Brewka et al. (2003), describes different menus preferences among drinks
desserts:
P1 :

fish beef
red white
pie ice-cream
fish, white
beef, pie
fish, ice-cream

1 :

%1 : white > red fish
%2 : red > white beef
%3 : pie > ice-cream red

symbol denotes exclusive disjunction, i.e. body rule true exactly
one atom head true, whereas rule empty head defines constraint, i.e.
rule satisfied body false. first three rules P 1 select main
dish, drink dessert; last three rules constraints state feasible
solution cannot contain i) fish white ii) beef pie iii) fish ice-cream.
Prioritized rules 1 introduce preferences among drinks (%1 , %2 ) desserts (%3 ).
program P 1 three stable models: M1 = {fish, red, pie}, M2 = {beef, white,
ice-cream} M3 = {beef, red, ice-cream}. PSM returns M1 unique preferred model; whereas ASO technique, following natural ordering preference rules
(%1 %2 precede %3 ), derives M3 unique solution. Thus, two approaches
provide different results.
2
structure preference rules example suggests i) fish beef
alternative options main dish ii) choice drink depends selected main
dish precedes choice dessert. second conclusion based observation
%1 %2 provide opposite valuations choice drink define two different
classes models (menus), considered separately. words, model
M1 (associated menu containing fish) compared models
M2 M3 (associated menus containing beef). Consequently, M1 M3
preferred.
Observe example PSM semantics derives M1 preferred
model M1 preferable M3 (due presence rule %3 ), M3 preferable M2
(due presence rule %2 ) and, transitively, M1 preferable M2 .
worth noting use transitive closure makes comparison models much
complex two models cannot compared directly. hand ASO
semantics sensitive syntactic changes programs. fact illustrated means
following example.
Example 2 Consider prioritized program hP2 , 2 i, extension prioritized program defined Example 1:
502

fiOn Semantics Logic Programs Preferences

P2 :

fish beef
red white beer
pie ice-cream
fish, white
beef, pie
fish, ice-cream
beer

2 :

%b1 : beer > white > red fish
%b2 : beer > red > white beef
%b3 : pie > ice-cream red

program equivalent one reported Example 1 as, even contains additional choice (beer), option feasible, presence constraint beer.
set stable models associated program P2 , coincides reported
program P 1 Example 1, consists of: M1 = {fish, red, pie}, M2 = {beef,
white, ice-cream} M3 = {beef, red, ice-cream}. Considering set preference
rules, note preferences regarding choice drink beer best option,
stable model containing it. Intuitively, two problems hP 1 , 1 Example 1 hP2 , 2 equivalent must preferred models. ASO
semantics sensitive program change gives M1 M3 solution, whereas,
equivalent program Example 1, returned preferred model M3 only.
change occurs set preferred models PSM semantics.
2
Thus, paper present new semantics, inspired PSM ASO semantics, seems better capture intuitive meaning programs avoids
mentioned problems.
1.1 Contribution
paper provides new semantics prioritized logic programs enriching one proposed Sakama Inoue (2000) additional information gained structure
preference rules proposed Brewka et al. (2003). particular, new semantics
uses different preference relations among stable models introduces natural ordering
among preferences fixes order choices, basis stratification
preference program. decision determined set choices belonging
corresponding level provides subset models given input solution.
decision made, output subset becomes input set following decision
on. proposed semantics drives decision making process taking account catching
additional information regarding non comparable sets models partitioning set
models program looking alternative decisions. end concept
incomparability, taken account previous approaches, introduced.
paper presents detailed comparison approaches dealing preference
relations among atoms. Particular attention devoted PSM ASO semantics.
analysis complexity computing preferred answer sets performed, showing
that, w.r.t. previous proposals, PSM ASO semantics, complexity
computing preferred stable models increase.
503

fiGreco, Trubitsyna, & Zumpano

1.2 Plan Paper
rest paper organized follows: Section 2 preliminaries Disjunctive
Abductive Logic Programs, Prioritized Logic Programs Answer Set Optimization
semantics given; Section 3 new interpretation prioritized logic programs
presented; Section 4 complexity results provided; Section 5 comparison
presented semantics PSM ASO semantics performed, approaches,
known literature, briefly described; finally, Section 6 outlines conclusions.

2. Preliminaries
assume familiarity relational database theory, disjunctive logic programs, disjunctive deductive databases, (disjunctive) stable model semantics computational complexity (Eiter, Gottlob, & Mannila, 1997b; Gelfond & Lifschitz, 1988, 1991; Papadimitriou,
1994).
2.1 Background
(disjunctive) logic program finite set rules r form a1 ak b1 , ..., bm ,
c1 , ..., cn k + + n > 0, a1 , ..., ak , b1 , ..., bm , c1 , ..., cn atoms.
disjunction a1 ak , denoted head(r), called head r, conjunction
b1 , ..., bm , c1 , ..., cn , denoted body(r), called body r.
Herbrand Universe program P set constants appearing P 1 ,
Herbrand Base BP set ground atoms constructed predicates
appearing P constants . term (resp. atom, rule program)
ground variables occur it. rule r0 ground instance rule r, r0 obtained
r replacing every variable r constant ; ground(P) denotes
set ground instances rules P.
intuitive meaning previous disjunctive rule body(r) true, i.e.
b1 , ..., bm true c1 , ..., cn false, head(r) must true, i.e least one
a1 , ..., ak true (otherwise r satisfied). Rules empty head, called denials
constraints, used define constraints satisfied body false.
paper exclusive disjunction, denoted , used head; statement head(r) =
a1 ... ak true, exactly one a1 , ..., ak true, i.e. disjunctive rule form
a1 ak body shorthand rule a1 ak body (k (k 1)/2)
constraints form ai , aj , body 1 < j k. solution logic program P
given terms stable model (answer set) semantics (Gelfond & Lifschitz, 1988, 1991).
interpretation P model P satisfies rules ground(P).
minimal model semantics, defined positive P, assigns P set minimal models
MM(P), model P minimal, proper subset model P
(Minker, 1982). general disjunctive stable model semantics applies programs (unstratified) negation (Gelfond & Lifschitz, 1991). Disjunctive stable model
semantics generalizes stable model semantics, previously defined normal programs (Gelfond & Lifschitz, 1988). interpretation , denote P ground positive
program derived ground(P) i) removing rules contain negated atom
1. considering function free programs.

504

fiOn Semantics Logic Programs Preferences

body , ii) removing negated atoms remaining rules.
interpretation (disjunctive) stable model P MM(P ).
general P, stable model semantics assigns P set SM(P) stable models. well known stable models minimal models (i.e. SM(P) MM(P))
negation free programs, minimal stable model semantics coincide (i.e.
SM(P) = MM(P)).
2.2 Extended Abductive Programs
Given atom p(t), literal either p(t) strong negation p(t). extended
program program atoms replaced literals. semantics extended
disjunctive programs given terms stable models considering p p
different predicate symbols considering implicit constraint p(X), p(X) (Gelfond
& Lifschitz, 1991).
Abductive logic programming extension logic programming perform abductive
reasoning (Kakas, Kowalski, & Toni, 1992; Inoue & Sakama, 1998). abductive program
(ALP) pair hP, Ai, P extended program set literals called
abducibles. hP, Ai represented means extended program = P {g(t)
g 0 (t) | g(t) A} {g 0 (t) g(t) | g(t) A}.
Let ALP G ground atom denoting observation. Then, set
explanation G iff stable model = G ; stable
model A-minimal stable model N N A. Moreover,
minimal explanation (i.e. explanation 0 S) G iff { G}
consistent A-minimal stable model = (Inoue & Sakama, 1998).
shown given ALP P ground atom G denoting observation,
deciding whether exists A-minimal explanation G p3 -complete (Eiter,
Gottlob, & Leone, 1997a).
rest section briefly review two main approaches prioritizing reasoning refer to, i.e. Prioritized Logic Programs Answer Set Optimization, proposed,
respectively, Sakama Inoue (2000) Brewka et al. (2003).
2.3 Prioritized Logic Programs
(partial) preference relation among atoms defined follows: given two atoms e1
e2 , statement e1 e2 (called priority) means e1 higher priority e2 .
Moreover, e1 e2 e2 e3 , e1 e3 . priority statement e1 e2 states
a1 instance e1 a2 instance e2 preference relation a1 a2 holds.
prioritized logic program (PLP) pair hP, P disjunctive program
set priorities. denotes set priorities reflexively transitively
derived .
statement e1 e2 stands e1 e2 e2 6 e1 . Clearly, e1 e2 , sets
ground instantiations e1 e2 empty intersection.
Definition 1 Given prioritized logic program hP, i, relation w defined
stable models P follows. stable models M1 , M2 M3 P:
505

fiGreco, Trubitsyna, & Zumpano

1. M1 w M1 ,
2. M1 w M2 e1 M1 M2 , e2 M2 M1 (e1 e2 ) 6 e3
M2 M1 (e3 e1 ) ,
3. M1 w M2 M2 w M3 , M1 w M3 .
M1 w M2 M1 preferable M2 . Moreover, M1 w M2 M2 6w M1
M1 = M2 .
2
interpretation preferred stable model hP, stable model P
N w implies w N stable model N (equivalently, interpretation N
stable model P N = ). set preferred stable models hP,
denoted PSM(hP, i). Note relation 1 2 two PLPs hP, 1
hP, 2 imply PSM(hP, 2 i) PSM(hP, 1 i).
PLP priority relations used express priorities atoms, whereas priorities
general forms knowledge (conjunctive, disjunctive knowledge, rules, preconditions)
expressed simple rewriting preference program. instance, preference
rule precondition form (e1 e2 ) B expressed PLP e01 e02 ,
e01 e1 , B e02 e2 , B.
semantics prioritized programs proposed Sakama Inoue (2000)
denoted PSM semantics. sound complete procedure allows preferred answer
sets PLP program computed using generate test algorithm
proposed Wakaki et al. (2003). algorithm translates PLP program hP,
answer set program P single logic program [P, , S],
answer sets answer sets P preferable S. details found works
presenting semantics implementation (Sakama & Inoue, 2000; Wakaki et al.,
2004).
complexity answering queries PLP programs least one level
complexity answering queries standard programs (without preferences).
particular, let hP, prioritized logic program, i) deciding existence
preferred stable model p2 -hard; ii) deciding whether atom true (resp. all)
preferable stable model hP, p3 -hard (resp. p3 -hard). worth noting
original work (Sakama & Inoue, 2000) claimed complexity exactly one
level complexity standard programs, proof take account
transitivity property preference relation.
2.4 Answer Set Optimization
answer set optimization program, denoted ASO program, pair hP, i, P
disjunctive program, called Generating Program, Preference Program consisting
finite set rules form: a1 > > ak b1 , ..., bm , c1 , ..., cn bi cj
literals ai boolean combinations2 literals; literal either atom L
(strong) negation L. determines preference ordering answer sets described
generating program P.
2. boolean combination formula built atoms means disjunctions, conjunctions, default
negation.

506

fiOn Semantics Logic Programs Preferences

Definition 2 Let hP, ASO program = {%1 , ..., %n } answer
set P, induces satisfaction vector VS = (vS (%1 ), ..., vS (%n )) where:
vS (%j ) = I, %j Irrelevant S, i.e. i) body %j satisfied ii)
body %j satisfied, none atoms head %j satisfied S.
vS (%j ) = min{i | |= ai %j = a1 > > ak b1 , .., bm , c1 , .., cn }, otherwise. 2
comparison models assumed equal 1 (i.e., vS (%j ) =
equivalent vS (%j ) = 1).
Definition 3 Let S1 S2 two answer sets, i) VS1 VS2 vS1 (%i ) vS2 (%i )
every [1..n]; ii) VS1 < VS2 VS1 VS2 [1..n] vS1 (%i ) < vS2 (%i ).
cases S1 w S2 S1 = S2 3 , respectively.
set literals optimal model ASO program hP, answer set
P answer set 0 P 0 = S.
2
complexity ASO programs depends class generating programs.
disjunctive programs complexity answering queries ASO programs exactly
one level complexity answering queries standard programs (without preferences), i.e. i) deciding existence preferred stable model p2 -complete; ii) deciding
whether literal true (resp. all) preferable stable model hP, p3 -complete
(resp. p3 -complete).
strategy extended introducing meta-preferences among preference
rules: ranked ASO program sequence hP, 1 , ..., n consisting generating program
P sequence pairwise disjoint preference programs . rank rule %
1 n , denoted rank(%), unique integer % . Given two answer
sets S1 S2 , S1 wrank S2 every preference rule %0 vS1 (%0 ) vS2 (%0 )
hold, rule %00 rank(%00 ) < rank(%0 ) vS1 (%00 ) < vS2 (%00 ).
Moreover, procedure deriving natural ordering preference rules introduced.
Firstly, given preference program , dependency graph G() defined. atoms
appearing form vertex set G(). directed edge vertex b
vertex G() rule % appears head r b appears
body r. graph G() acyclic, natural ranking atoms
defined recursively follows: rank(a) = 0 every atom predecessors
G(); otherwise rank(a) maximum ranks predecessors G()
incremented 1. rank preference rule % defined maximum rank
atoms head.
standard semantics ASO programs, priorities examined together,
denoted ASO semantics. alternative semantics, priorities divided
strata following natural order, denoted RASO (ranked ASO) semantics.
3. original work (Brewka et al., 2003) symbols > used instead w =.

507

fiGreco, Trubitsyna, & Zumpano

3. Preferred Answer Sets
paper syntax similar one proposed Brewka et al. (2003) used. Given
two atoms a1 a2 , statement a2 > a1 means a2 higher priority a1 .
(partial) preference relation > among atoms defined follows.
Definition 4 prioritized program pair hP, P disjunctive program
set preference rules form:
a1 > a2 > > ak b1 , ..., bm , c1 , ..., cn
k > 1 a1 , ..., ak , b1 , ..., bm , c1 , ..., cn atoms.

(1)
2

following head body preference rule % denoted head(%)
body(%), respectively. ground prioritized program, denoted ground(hP, i) =
hground(P), ground()i prioritized program, rule r (P ) variables
replaced set ground instances, i.e set rules obtained replacing
variables constants.
Intuitively, preference rule % form (1) describes choice among a1 , ..., ak
(choice options) condition specified body %. head % introduces
preference order among atoms: ai preferred aj 1 < j k. %
applied body(%) true, body % specifies decisions precede
choice. instance, > c b states b true, preferred c.
preference rule exactly two atoms head called binary preference rule,
whereas preference rules empty bodies called preference facts. prioritized
program said binary form preference rules binary.
following example, presenting classical program proposed Brewka et al. (2003),
used running example.
Example 3 Consider prioritized program hP 3 , 3 whose stable models define
menus restaurant:
P 3:

fish beef
red white beer
pie ice-cream
beef, pie
fish, ice-cream

3 :

%1
%2
%3
%4

:
:
:
:

white > red > beer fish
red > white beef
beer > white beef
pie > ice-cream beer

first three rules P 3 select main dish, drink dessert; constraints
state feasible solution cannot contain beef pie fish ice-cream;
rules 3 introduce preferences among drinks desserts.
program P 3 six stable models:
M1 = {fish, white, pie}
M2 = {fish, red, pie}
M3 = {fish, beer, pie}

M4 = {beef, white, ice-cream}
M5 = {beef, red, ice-cream}
M6 = {beef, beer, ice-cream}

techniques proposed Sakama Inoue (2000) Brewka et al. (2003) select
stable models M1 M5 preferred ones, motivation different. Indeed,
PSM semantics states M1 w M2 w M3 w M6 w M4 M5 w M4 , whereas
508

fiOn Semantics Logic Programs Preferences

(R)ASO semantics states Mi w M2 w M3 , Mi w M6 Mi w M4 {1, 5}, i.e.
(R)ASO semantics models M1 M6 compared directly, whereas PSM
semantics models M1 M6 compared transitively.
2
presenting formal semantics programs, preliminary definitions
needed. preference rule form a1 > a2 > > ak body shorthand k 1
binary rules form ai > ai+1 body, [1..k 1] set preferences
established given transitive closure defined follows:
Definition 5 Given prioritized program hP, i, (ground) transitive closure
= 0 {a > c body1 , body2 | > b body1 b > c body2 6= c},
0 set binary preference rules derived ground().
2
Thus, defined set rules explicitly representing preference relations
among choice options. Section 4 show ground prioritized program
= hP, rewritten equivalent program = hP, contains
number rules polynomial size .
structure prioritized programs examined order establish precedence relation among choices made. instance, presence preference rule
> c b suggests selection b precedes choice c thus
establishes precedence relation {b} {a, c}. idea used Brewka
et al. (2003) determining natural ordering among preference rules. detail,
relational order among atoms appearing captured means corresponding dependency graph G(); stratification preference rules established
considering head atoms.
Unfortunately, natural ordering among preference rules established
corresponding dependency graph acyclic. Thus, presence two rules coffee >
tea pie pie > ice-cream coffee admit stratification ,
introduce two mutually dependent choices.
stratification algorithm proposed paper overcomes problem introducing concept collapsed graph, maps node options mutually
dependent choices.
Given (ground) prioritized program = hP, i, G = (V, E) denotes dependency
graph whose set nodes consists atoms P whereas arc b
labeled (resp. p) rule (resp. P) containing head b
body (resp. b either head body). body (preference) facts empty,
assume bodies contain built-in atom true, every fact
C
considered rule true. G denotes (acyclic) collapsed dependency graph derived
G replacing maximal sets mutual dependent nodes (i.e. nodes belonging
C
cycle) unique node. Clearly, node G associated set nodes
G .
C

node G possible assign level follows:
C

node G input degree zero, level(A) = 0;
509

fiGreco, Trubitsyna, & Zumpano

C

node G input degree greater zero,
C
C
level(A) = max{max{level(B)+1|(B, Z, ) G }, max{level(B)|(B, Z, p) G }}.
Observe function level assigns node maximum distance
node input degree zero. following definition introduces concept stratification
preference rules.
Definition 6 Stratification. Given (ground) prioritized program = hP, i,
partitioned h [0], [1], ..., [n]i subprograms (called strata)
C

atom , level(a) = level(A), node G associated a;
rule % , level(%) = max{ level(a) | Body(%) };
[i] = { % | % level(%) = } consists ground preference rules associated
level i.
2
partition h [0], [1], ..., [n]i called stratification.
definition stratification preference rules establishes order
preferences applied considering P . Moreover, assignment level
rule differs one proposed Brewka et al. (2003) two main aspects:
level atoms defined analyzing collapsed dependency graph level
rules established considering body atoms instead head atoms. detailed
comparison two approaches presented Section 5.
Example 4 Consider prioritized program hP 3 , 3 Example 3. transitive closure
3 consists binary preference rules %1,1 : white > red fish, %1,2 : red > beer
fish %1,3 : white > beer fish, derived %1 , rules %2 , %3 %4 . 3
stratified two strata 3 [1] = {%1,1 , %1,2 , %1,3 , %2 , %3 } 3 [2] = {%4 }.
2
structural analysis performed approach goes beyond stratification process
tries understand comparability models. end concepts conflicting
preferences comparable models introduced.
Two ground (binary) preferences form > b body1 b > body2
said conflicting. instance, preferences %1 : white > red fish
%2 : red > white beef Example 1 conflicting, whereas preferences %1
%02 : red > water beef not. set preferences said conflicting
contains two conflicting preference rules.
intuition basis approach clarified example. Suppose
two conflicting preferences %1 : > b c %2 : b > d. two conflicting
preferences %1 %2 specify preference b two different sets models,
b, characterized presence c d, respectively. Thus, c d, (and
atoms c depend) define alternative decisions. decision
made, associated solutions (models) longer comparable.
preference rule % said relevant stable model , % used
compare stable models, |= body() head
510

fiOn Semantics Logic Programs Preferences

atoms belongs . Given prioritized program hP, (ground) preference rule
% : > b body , set stable models, % relevant, SM(P, %) =
{M | SM(P) |= body (a b)}.
Definition 7 Comparable models. Let hP, prioritized program, M1 M2 two
stable models P h [0], ..., [n]i stratification ,
1. M1 M2 comparable [0];
2. M1 M2 comparable [i + 1] [1..n],
(a) comparable [i],
(b) exist two conflicting preference rules %1 , %2 [i]
M1 SM(P, 1 ) SM(P, 2 ) M2 SM(P, 2 ) SM(P, 1 ).
2
Observe that, second condition previous definition comparable models
states presence two conflicting preference rules given level identifies two
sets models, one two conflicting rules relevant. Two models,
appearing different sets considered separately next levels.
words, two stable models M1 M2 , relevant preferences conflicting rules
%1 : > b body1 %2 : b > body2 given level i, comparable levels
greater i, M1 SM(P, 1 ) SM(P, 2 ) M2 SM(P, 2 ) SM(P, 1 ),
M1 |= body1 (a b) body2 M2 |= body2 (a b) body1 .
Example 5 Consider stable models M3 = {fish, beer, pie}, M6 = {beef, beer,
ice-cream}, set preference rules 3 Example 4. stable models M3
M6 comparable 3 [0] definition, comparable 3 [1],
%1,3 relevant M3 (as M3 |= fish (white beer) beef), %3
relevant M6 (as M6 |= beef (white beer) fish), conflicting
preferences belong 3 [0].
2
Fact 1 Let hP, prioritized program without conflicting preferences h [0],
[1], ..., [n]i stratification . Then, two models M1 M2 comparable
[i], [0..n].
2
Proof. proof fact follows directly Definition 7.

2

basis Definition 7 declarative semantics prioritized logic programs
provided. new semantics, denoted PAS (Preferred Answer Sets), given
preferred stable models follows:
Definition 8 Preference Answer Sets. Given prioritized program hP, i,
relation w defined stable models P follows. pair stable models
M1 M2 P, h [0], [1], ..., [n]i stratification , M1 w M2
1. %1 : (e1 > e2 ) body1 [i] e1 M1 M2 , e2 M2 M1 ,
M1 M2 comparable [i], %1 relevant M1 M2 ,
511

fiGreco, Trubitsyna, & Zumpano

2. 6 %2 : (e3 > e4 ) body2 [j], j < i, e3 M2 M1 , e4 M1 M2
%2 relevant M1 M2 .
Moreover, M1 strictly preferable M2 (M1 = M2 ) M1 w M2 M2 6w M1 .

2

Note relation = could defined directly replacing condition j <
j Item 2 definition.
Definition 9 Preferred Answer Sets. interpretation preferred stable model
prioritized program hP, stable model P exist stable
model N N = . set preferred stable models hP, denoted
PAS(hP, i).
2
Note Definition 8 introduces preferences pairs models considering
additional information gained structure preference rules.
Example 6 Consider prioritized program hP3 , 3 Example 3 stratification
h3 [0], 3 [1]i presented Example 4.
models comparable [0] definition
owing %1,1 , %1,2 , %1,3 , M1 = M2 = M3 ;
owing %2 , %3 , M5 = M4 M6 = M4 ;
%1,3 %3 conflicting, models M1 M3 , %1,3 relevant, cannot
compared [1] models M4 M6 , %3 relevant.
Therefore, discussed Example 5, M3 M6 comparable 3 [1] and,
consequently, preferred models are: M1 , M5 M6 .
2
previous example stable model M6 considered good M5
beef main dish, best choice drink (red wine beer, respectively)
dessert (ice-cream). Observe ASO PSM semantics discard M6 .
already stated, ASO semantics deduces M1 M5 preferable M6 owing
%3 , PSM semantics states M1 preferable M3 M3 preferable
M6 , owing %1 , %3 .
b 3i
Example 7 Let hP 3 , 3 program Example 3, consider program hP 3 ,
b 3 derived 3 replacing %4


%04 : pie > ice-cream
b [0] = {%1,1 , %1,2 , %1,3 , %2 , %3 , %0 },
new ground preference program unique level
3
4
%1,1 , %1,2 %1,3 derived %1 , shown Example 4. Due %04 , following relations hold: Mi = Mj {1, 2, 3} j {4, 5, 6}. Therefore, M1
unique preferred model. result obtained PSM ASO semantics. 2
512

fiOn Semantics Logic Programs Preferences

4. Complexity
section provides results concerning computational complexity computing
preferred stable models answering queries PAS semantics. consider data
complexity input domain consists Herbrand universe (we assume
constants occurring occur P). Clearly, size Herbrand base BP
well sizes ground(P) ground() polynomial size .
following results demonstrate allowing preferences among atoms semantics proposed increases complexity expressivity language one level
polynomial hierarchy. Thus use additional information increase
computational complexity proposed approach respect mentioned
techniques (Brewka et al., 2003; Sakama & Inoue, 2000).
Proposition 1 Let = hP, prioritized program, exists program =
hP, equivalent hground(P), i) stratification computed
polynomial time, ii) hP, derived hground(P), polynomial time.
Proof. start considering program 0 = hground(P), 0 i, 0 binary
C
ground version . size graphs G0 G0 polynomial size 0
C
computed polynomial time. assignment levels nodes G0
done polynomial time, assignment levels atoms rules 0
done polynomial time.
Let h0 [0], ..., 0 [n]i stratification 0 . generate new ground prioritized
program hP, equivalent hground(P), size polynomial size 0 .
Initially, assign ground atom ai appearing head preference rule 0
unique index i. Let a1 , ..., ap (indexed) atoms appearing head rules 0 ,
P denotes program ground(P) P
P = {b(i, j, l) bodyi,j | ai > aj bodyi,j 0 [l] }
{b(i, j, l) b(i, k, l1), b(k, j, l2), l = max(l1, l2) | i, j, k [1..p], l1 , l2 [1..n]}
b new predicate symbol. Then, denotes new set ground preference rules
defined follows:
= {ai > aj b(i, j, l) | i, j [1..p] l [0..n] }
stratification obtained associating stratum l preference rules
whose body atom value level attribute equal l, [l] = {ai > aj
b(i, j, l) | ai > aj b(i, j, l) }.
order show equivalence hground(P), hP, i, observe
set stable models ground(P) P equivalent, i.e. SM(P)
stable model N SM(ground(P)) N = {b(i, j, l) | b(i, j, l) }
N SM(ground(P)) stable model SM(P) N =
{b(i, j, l) | b(i, j, l) }, rules ground(P) contain atoms form
b(i, j, l) bodies.
513

fiGreco, Trubitsyna, & Zumpano

Moreover, let N stable model ground(P) corresponding stable
model P (N ), ground preference rule ai > aj bodyi,j [l] whose
body true N , ground rule ai > aj b(i, j, l) [l] whose body true
vice versa. Therefore two sets [l] [l] equivalent, l [1..n].
Clearly, program hP, derived hground(P), polynomial time.
2
following, sake simplicity presentation, continue refer
program hP, stratification .
Proposition 2 Let hP, prioritized program, M1 M2 two stable models P,
h [0], [1], ..., [n]i stratification . problem checking whether,
given k n, M1 M2 comparable [0], ..., [k] solved polynomial time.
Proof. Obviously M1 M2 comparable [0]. Assuming M1 M2
comparable given level j < k, M1 M2 comparable level j + 1
two conflicting preference rules 1 = > b body1 2 = b > body2 [j]
M1 |= body1 (a b) body2 M2 |= body2 (a b) body1 . check
done polynomial time number rules [j] polynomial size
. Moreover, maximum value k bounded size (which bounded
set atoms BP ), global complexity polynomial.
2
Corollary 1 Let hP, prioritized program, M1 M2 two interpretations P.
problem checking whether M1 = M2 solved polynomial time.
Proof. Straightforward Definition 8 Proposition 2.

2

Lemma 1 Let hP, prioritized program interpretation P. problem
deciding whether preferred stable model hP, p2 .
Proof. Consider complementary problem deciding whether preferred
stable model hP, i. case sufficient first check stable model.
stable model sufficient guess interpretation N check i) N
stable model P ii) N = . check part i) (as well check
stable model) done means N P oracle problem deciding
whether interpretation stable model disjunctive program coN P-complete,
whereas check part ii) done polynomial time (see Corollary 1). Therefore,
complexity complementary problem N P N P and, consequently, complexity
original problem coN P N P .
2
Theorem 1 Let hP, prioritized program.
1. Deciding whether ground atom G true preferred stable models hP,
p3 -complete;
2. Deciding whether ground atom G true preferred stable models hP,
p3 -complete.
514

fiOn Semantics Logic Programs Preferences

Proof. Membership: first demonstrate deciding whether G true
preferred stable model hP, p3 . result suffices prove complementary problem, consisting deciding whether true preferred stable models,
p3 -complete.
show membership sufficient guess interpretation containing G
check whether preferred stable model. Lemma 1 problem deciding
whether preferred stable model p2 solved means p2
oracle.
Therefore, deciding whether exists preferred stable model containing G
p2
N P = p3 .
Hardness: Given abductive logic program consisting disjunctive program P
set abducibles (positive) atoms A, ground abductive logic program derived prom P

= ground(P) { g 0 (t) g(t) | g(t) ground(A) }
{ g 0 (t) g(t) | g(t) ground(A) }
Let
= { g 0 (t) > g(t) | g(t) ground(A) }
h, denotes prioritized program derived P A.
two stable models M, N SM(), w N respect means
preference p0 (u) > p(u) p0 (u) p(u) N exists
preference q 0 (v) > q(v) q 0 (v) N q(v) exists. implies
ground(A) N ground(A) and, consequently, preferred stable models
A-minimal.
Therefore, problem deciding whether h, A-minimal explanation
goal G equivalent deciding whether h, preferred stable model containing G.
Consequently, problem deciding whether A-minimal explanation G exists
p3 -complete, problem deciding whether preferred stable model h,
containing G exits p3 -hard, whereas problem deciding whether preferred
2
stable models hP, contain G p3 -hard.
Corollary 2 Let hP, disjunction-free, prioritized program. deciding
whether ground atom true (all) preferred stable models hP, p2 -complete
(p2 -complete).
Proof. complexity one level lower problem deciding whether interpretation stable model disjunction-free program polynomial.
2

5. Analysis Comparison
section compares semantics introduced PSM (R)ASO semantics
briefly discusses recently proposed semantics.
PSM semantics elegant compares pairs models basis
common preferences basis degree satisfaction. consider natural ordering preference rules and, cases, Example 1
3, compares (and consequently discards) models PAS approach
515

fiGreco, Trubitsyna, & Zumpano

comparable. interesting feature PSM technique application transitive
property order derive additional preference relations among problem solutions
new, immediately visible, preference relations captured. However, test
transitive property cannot performed direct comparison two models, lies
complex implementation.
(R)ASO technique powerful tool determines preferred models
evaluating degree satisfaction preference rules. Thus, compares two
models even absence common preferences; preference relation
two models established directly. detail, RASO technique considers
structure preference rules associating degree satisfaction choice options
introduces natural ordering among preferences. case PSM semantics,
(R)ASO semantics compares and, consequently, discards models
comparable using PAS technique. instance, program hP1 , 1 i, presented
Introduction, RASO discards M1 , second best option drink, even
unique possible choice presence fish.
specifically, preference relation w used PSM approach preorder
relation reflexive transitive; determines equivalent answer set classes
establishes partial preference order among mentioned classes. Consequently
preferred answer sets appearing preferred classes. noted
PSM semantics requires use transitive property order derive,
basis relations obtained direct comparison pairs models, new preference
relations. contrary, (R)ASO semantics uses strict preference relation
asymmetric require application transitive property
compare solutions.
PAS semantics, proposed here, compares two solutions basis common preferences introducing concept comparable models considering
refinement natural order among preference choices. Thus, seen extension PSM semantics uses additional information derived structure
preference rules, instead comparing models transitively, compares models
considering transitive closure (ground) preference rules.
novelty PAS semantics consideration structural information preference rules. introduces concept comparable models order avoid comparing
models (in opinion) compared associated alternative decisions. Moreover, proposes refinement natural order among preferences
order define order choices. RASO semantics establishes relational order among
atoms appearing means corresponding dependency graph G() cannot
treat case mutually dependent choices. stratification algorithm, proposed
C
paper, overcomes problem considering collapsed graph G , acyclic
construction sensitive syntactic changes. Moreover, RASO semantics
stratification preference rules established considering head atoms; whereas
PAS semantics levels assigned rules basis body atoms, following
intuition describe contexts choices. Thus, stratification proposed
always assigns preference facts first level level rule fixed looking
level body atoms.
advantages adopted approach clarified following example.
516

fiOn Semantics Logic Programs Preferences

Example 8 problem defined means prioritized program hP8 , 8 consists
selecting colors trousers shirt, black blue trousers (r1 )
white, yellow red shirts (r2 ) available. fashion consultant suggests blue
trousers better black ones (%1 ); white shirt better yellow shirt (%2 );
case black trousers white shirt preferred red one (%3 ). Moreover,
blue trousers go white shirt (c1 ) red shirt go blue
trousers (c2 ).
P8 :

r1
r2
c1
c2

:
:
:
:

black blue
white yellow red
blue, white
red, blue

8 :

%1 : blue > black
%2 : white > yellow
%3 : white > red black

program P8 four stable models: M1 = {black, white}, M2 = {black, yellow},
M3 = {blue, yellow} M4 = {black, red}. order define stratification
preference rules, RASO PAS semantics firstly assign level atoms: first level
blue, black yellow second level white red. second step
RASO approach, considering maximum level head atoms, assigns %1 first
level %2 %3 second level, whereas PAS defines level preferences
basis body atoms assigns %1 %2 first level %3 second level. Note
case order %2 relevant determining preferred models. fact,
RASO gives M3 , PAS returns M1 M3 preferred models.
2
formal comparison three semantics carried class
programs specific definition stratification significant. Moreover,
PSM semantics defined prioritized programs hP, consists
binary facts (preference rules rewritten preference facts), following
comparison carried considering programs whose preference rules consist
facts. class programs closure used PSM PAS semantics
coincide.
Given prioritized program hP, denote GSEM = (V, ESEM ) preference
graph stable models P, V = SM(P) denotes set stable models
P ESEM denotes preference relation = defined semantics SEM
{PSM, ASO, PAS}. particular, ESEM consists arcs (Mi , Mj ) Mi = Mj
holds SEM semantics. Therefore, comparison different semantics
performed analyzing corresponding preference graphs. stable model Mi preferred
SEM semantics arc (Mj , Mi ) GSEM .
following example shows relation PSM PAS semantics.
Example 9 Consider prioritized program hP 9 , 9
P 9 : fish beef pork chicken
white fish
red beef
beer pork
water chicken
517

9 : fish > beef
chicken > pork
red > white
red > water
beer > water

fiGreco, Trubitsyna, & Zumpano

program four stable models: M1 = {fish, white}, M2 = {beef, red}, M3 =
{pork, beer} M4 = {chicken, water}, whereas direct preference relations,
PSM semantics, follows: M1 w M2 , M2 w M1 , M3 w M4 , M4 w M3 M2 w M4 .
Consequently, graph GPSM consists four nodes (M1 , M2 , M3
M4 ) four arcs: M1 = M3 , M1 = M4 , M2 = M3 M2 = M4 . Therefore, preferred
models M1 M2 .
Regarding PAS semantics, relation M2 = M4 holds and, thus,
three preferred stable models, namely M1 M2 M3 .
2
Theorem 2 prioritized program hP, consists preference facts,
PSM(hP, i) PAS(hP, i).
Proof. Consider graphs GPSM = (V, EPSM ) GPAS = (V, EPAS ). graphs
acyclic EPAS EPSM . two graphs acyclic, adding edges
create cycles, number nodes without incoming edges decreases. Therefore, set
nodes without incoming edges GPAS contains nodes without incoming edges GPSM
and, consequently, PSM(hP, i) PAS(hP, i).
2
analyze relation ASO PAS semantics. First note that,
observed Introduction, ASO semantics sensitive syntax changes.
instance, prioritized program
abc

1 = > b > c
2 = b >

two preferred stable models: M1 = {a} M2 = {b}. However, program
01 = > b
001 = b > c
2 = b >

abc

derived rewriting rule 1 , M3 = {c} preferred model.
Thus, consider special class constraints sensitive syntactic
changes. Since every (ground) prioritized program = hP, i, partitioned n strata, n > 1, rewritten program = hP, i,
equivalent PAS semantics (as shown proof Proposition
1), may equivalent RASO semantics (as rules belong
unique stratum 0), continue consider programs = hP, consists
single stratum and, particular, facts.
Given prioritized program hP, consists facts, denote
+ = {a1 > > | ai > ai+1 [1..n-1] n maximum }
set preference rules obtained merging ground preference facts.
Lemma 2 Let hP, prioritized program consists preference facts
ground() = + . Then, ASO(hP, i) PAS(hP, i).
518

fiOn Semantics Logic Programs Preferences

Proof. Consider two graphs GASO = (V, EASO ) GPAS = (V, EPAS ). (M1 , M2 )
EPAS means M1 = M2 , i.e.
i) ground rule %1 : e1 > e2 e1 M1M2 , e2 M2M1 ,
ii) ground rule %2 : e3 > e4 , e3 M2 M1 e4 M1 M2 .
implies ground() = +
i) must ground rule 1 : > e1 > > e2 > +
e1 M1 M2 , e2 M2 M1 ,
ii) must ground rule 2 : > e3 > > e4 > + ,
e3 M2 M1 e4 M1 M2 .
Therefore, M1 = M2 respect ASO semantics, graph GASO contains arc (M1 , M2 ). Consequently, EPAS EASO , ASO(hP, + i) PAS(hP, + i). 2
find tight relation two semantics, consider restriction
+ obtained deleting atoms appear model ground
preference rules:
+

b = {a1 > > | ai > ai+1 [1..n-1] n maximum

SM(P) s.t. ai , ai+1 }

Theorem 3 Let hP, prioritized program consists preference
b + . Then, ASO(hP, i) = PAS(hP, i).
facts ground() =
b + derived +
Proof. ASO(hP, i) PAS(hP, i) derives Lemma 2,
deleting nodes appear model influence relation =
ASO semantics.
show ASO(hP, i) PAS(hP, i) consider relation ASO semantics.
M1 = M2 means
b + e1 M1 M2 ,
1. ground rule 1 : > e1 > > e2 >
e2 M2 M1 ,

2. ground rule 2 : > e3 > > e4 >
e3 M2 M1 e4 M1 M2 .

+ ,

b+
implies ground() =

1. must ground rule %1 : e1 > e2 e1 M1 M2 , e2
M2 M1 ,
2. ground rule %2 : e3 > e4 , e3 M2 M1 e4 M1 M2 .
519

fiGreco, Trubitsyna, & Zumpano

Therefore, M1 = M2 holds respect PAS semantics. Consequently,
EASO RPAS , ASO(hP, + i) PAS(hP, + i).
2
extension ASO semantics proposed Brewka (2004) Brewka,
Niemela, Truszczynski (2005). detail, Brewka (2004) provided preference
description language, allowing express complex preferences combining qualitative
quantitative penalty based preferences, whereas Brewka et al. (2005) proposed framework specify problem solutions (outcomes) preferences among them. latter
proposal combines ideas answer-set programming, answer-set optimization CPnets (Boutilier, Brafman, Domshlak, Hoos, & Poole, 2004). semantics
proposed paper different proposed Brewka (2004) Brewka
et al. (2005), cases returns different results (see Examples 2 4).

6. Approaches
Besides approaches managing preferences among atoms, works proposed
literature specify preferences among rules.
Early proposals expressing preferences rules focus Default Logic (Brewka & Eiter,
2000; Delgrande et al., 2000b; Rintanen, 1998), whereas recently emphasis
given logic programs. regard, different proposals developed
representing reasoning user preferences ordered logic programs (Delgrande et al., 2000a; Van Nieuwenborgh & Vermeir, 2002, 2004) preferred answer sets
extended logic programs (Brewka & Eiter, 1999). approaches propose
extension Gelfond Lifschitzs extended logic programming adding preference information (Delgrande et al., 2003; Wang et al., 2000; Zhang & Foo, 1997). proposals
attempt extend well founded semantics logic programs preferences (Brewka,
1996; Schauba & Wang, 2001), extension van-Gelders alternating fixpoint theory
logic programs priorities proposed Wang et al. (2000).
Gelfond Son (1997) proposed methodology reasoning prioritized
default language logic programming answer set semantics. approach
enables specification preferences among rules allows definition set
default rules must satisfied well second set default rules could
ignored.
Ordered logic programs introduced Delgrande et al. (2000a) extended
logic programs whose rules subject strict partial order static dynamic
preferences. approach fully prescriptive enforces ordering information
construction answer set. original program transformed second
extended logic program preferences taken account sense
answer sets obtained evaluating transformed theory correspond preferred
answer sets original theory.
Another methodology logic programs containing preferences set rules
translated logic programs stable model semantics proposed
Delgrande et al. (2003).
520

fiOn Semantics Logic Programs Preferences

7. Conclusions
paper case preferences involving atoms logic programming studied.
particular, behavior technique proposed Sakama Inoue (2000)
Brewka et al. (2003) analyzed semantics, interpreting preference rule
tool representing choice alternative options, proposed. Specifically,
proposed approach extends PSM semantics considering refinement natural
order among preferences introduces concept comparable models. Preferences
logic programs examined together order determine choice order sets
models compared.
new semantics compared PSM ASO semantics. Complexity analysis performed showing use additional information,
regarding preference order sets non comparable models, increase
complexity computing preferred stable models. Although semantics presented
complexity approaches proposed literature, advantage lies
fact seems better capture intuitive meaning prioritized programs
considering structural information preference rules.
Prioritized reasoning logic programming PAS semantics easily
implemented top deductive systems based stable model semantics
DeRes, DLV, Smodels (Cholewinski, Marek, & Truszczynski, 1996; Leone, Pfeifer, Faber,
Calimeri, & DellArmi, 2002; Syrjanen & Niemela, 2001). architecture system
prototype implementing prioritized reasoning (with different semantics) top
DLV system presented Caroprese, Trubitsyna, Zumpano (2007).

Acknowledgments
preliminary version papers presented Greco, Trubitsyna, Zumpano
(2006). authors would thank anonymous referees useful suggestions
Filippo Furfaro comments.

References
Boutilier, C., Brafman, R., Domshlak, C., Hoos, H., Poole, D. (2004). CP-nets: tool
representing reasoning conditional ceteris paribus preference statements.
Journal Artificial Intelligence Research, 21, 135-191.
Brewka, G. (1996). Well-Founded Semantics Extended Logic Programs Dynamic
Preferences. Journal Artificial Intelligence Research, 4, 19-36.
Brewka, G., Eiter, T. (1999). Preferred Answer Sets Extended Logic Programs. Artificial
Intelligence, 109(1-2), 297-356.
Brewka, G., Eiter, T. (2000). Prioritizing Default Logic. Intellectics Computational
Logic, Kluwer, 27-45.
Brewka, G. (2002). Logic programming ordered disjunction. Proceedings 18th National
Conference Artificial Intelligence (AAAI/IAAI), 100-105.
521

fiGreco, Trubitsyna, & Zumpano

Brewka, G., Niemela, I., Truszczynski, M. (2003). Answer Set Optimization. Proceedings
18th International Joint Conference Artificial Intelligence (IJCAI), 867-872.
Brewka, G. (2004). Complex Preferences Answer Set Optimization, Proceedings 9th
International Conference Principles Knowledge Representation Reasoning
(KR), 213-223.
Brewka, G., Niemela, I., Truszczynski, M. (2005). Prioritized Component Systems. Proceedings 20th National Conference Artificial Intelligence (AAAI), 596-601.
Caroprese, L., Trubitsyna, I., Zumpano, E. (2007). Implementing Prioritized Reasoning
Logic Programming. Proceedings International Conference Enterprice Information
Systems (ICEIS), 94-100.
Cholewinski, P., Marek, V. W., Truszczynski, M. (1996). Default Reasoning System DeReS.
Proceedings 5th International Conference Principles Knowledge Representation
Reasoning (KR), 518-528.
Delgrande, J., P., Schaub, T., Tompits, H. (2000). Logic Programs Compiled Preferences. Proceedings 14th European Conference Artificial Intelligence (ECAI), 464-468.
Delgrande, J., P., Schaub, T., Tompits, H. (2000). Compilation Brewka Eiters
Approach Prioritization. Proceedings European Workshop Logics Artificial
Intelligence (JELIA), 376-390.
Delgrande, J., P., Schaub, T., Tompits, H. (2003). Framework Compiling Preferences
Logic Programs. Theory Practice Logic Programming, 3(2), 129-187.
Eiter, T., Gottlob, G., Leone, N. (1997). Abduction Logic Programs: Semantics
Complexity. Theoretical Computer Science 189(1-2), 129177.
Eiter, T., Gottlob, G., Mannila, H. (1997). Disjunctive Datalog. ACM Transaction
Database Systems, 22(3), 364418, 1997.
Gelfond, M., Lifschitz, V. (1988). Stable Model Semantics Logic Programming,
Proceedings International Conference Logic Programming (ICLP), 10701080.
Gelfond, M., Lifschitz, V. (1991). Classical Negation Logic Programs Disjunctive
Databases, New Generation Computing, 9, 365385.
Gelfond, M., Son, T.C. (1997). Reasoning prioritized defaults. Proc. 3rd International
Workshop Logic Programming Knowledge Representation (LPKR), 164-223.
Greco, S., Trubitsyna, I., Zumpano, E. (2006). Semantics Logic Programs
Preferences. Proceedings 10th European Conference Logics Artificial Intelligence
(JELIA), 203-215.
Grell, S., Konczak, K., Schaub, T. (2005). nomore<: System Computing Preferred
Answer Sets. Proceedings 8th International. Conference Logic Programming
Nonmonotonic Reasoning (LPNMR), 394-398.
Janhunen, T., Niemela, I., Simons, P., You, J.-H. (2000). Unfolding partiality disjunctions stable model semantics, Proceedings 7th International Conference Principles Knowledge Representation Reasoning (KR), 411-419.
522

fiOn Semantics Logic Programs Preferences

Inoue, K., Sakama, S. (1998). Negation Failure Head. Journal Logic Programming, 35(1), 39-78.
Kakas, A. C., Kowalski, R. A., Toni, F. (1992). Abductive Logic Programming. Journal
Logic anc Computation, 2(6), 719-770.
Leone, N., Pfeifer, G., Faber, W., Calimeri, F., DellArmi, T., Eiter, T., Gottlob, G., Ianni,
G., Ielpa, G., Koch, K., Perri, S., Polleres, A. (2002). DLV System. Proceedings
8th European Conference Logics Artificial Intelligence (JELIA), 537-540, 2002.
Minker, J. (1982). Indefinite Data Bases Closed World Assumption, Proc. 6-th
Conf. Automated Deduction, 292-308, 1982.
Papadimitriou, C. H. (1994). Computational Complexity. Addison-Wesley.
Rintanen J. (1998). Complexity Prioritized Default Logics, Journal Artificial Intelligence Research, 9, 423-461.
Sakama, C., Inoue, K. (2000). Priorized logic programming application commonsense reasoning. Artificial Intelligence, 123, 185-222.
Schaub, T., Wang , K. (2001). Comparative Study Logic Programs Preference.
Proceedings 17th International Joint Conference Artificial Intelligence (IJCAI),
597-602.
Syrjanen, T., Niemela, I. (2001). Smodels System. Proceedings International Conference Logic Programming Nonmonotonic Reasoning (LPNMR), 434-438.
Van Nieuwenborgh, D., Vermeir, D. (2002). Preferred Answer Sets Ordered Logic
Programs. Proceedings 10th European Conference Logics Artificial Intelligence
(JELIA), 432-443.
Van Nieuwenborgh, D., Vermeir, D. (2002). Ordered Diagnosis, Proceedings 10th International Conference Logic Programming, Artificial Intelligence, Reasoning
(LPAR), 244-258.
Van Nieuwenborgh, D., Heymans, S., Vermeir, D. (2004). Programs Linearly Ordered Multiple Preferences. Proceedings International Conference Logic Programming (ICLP), 180-194.
Wakaki, T., Inoue, K., Sakama, C., Nitta, K. (2003). Computing Preferred Answer Sets
Answer Set Programming. Proceedings 10th International Conference Logic
Programming, Artificial Intelligence, Reasoning (LPAR), 259-273.
Wakaki, T., Inoue, K., Sakama, C., Nitta, K. (2004). PLP System. Proceedings 9th
European Conference Logics Artificial Intelligence (JELIA), 706-709.
Wang, K., Zhou, L., Lin, F. (2000). Alternating Fixpoint Theory Logic Programs
Priority. Proceedings First International Conference Computational Logic, 164-178.
Zhang, Y., Foo, N. (1997). Answer sets prioritized logic programs. Proceedings International Logic Programming Symposium (ILPS), 69-83.

523


