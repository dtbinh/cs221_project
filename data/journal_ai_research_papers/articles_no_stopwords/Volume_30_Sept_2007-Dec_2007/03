journal artificial intelligence

submitted published

semantics logic programs preferences
sergio greco

greco deis unical

deis universita della calabria
via p bucci rende italy

irina trubitsyna

irina deis unical

deis universita della calabria
via p bucci rende italy

ester zumpano

zumpano deis unical

deis universita della calabria
via p bucci rende italy

abstract
work contribution prioritized reasoning logic programming presence
preference relations involving atoms technique providing interpretation
prioritized logic programs inspired semantics prioritized logic programming
enriched use structural information preference answer set optimization programming specifically analysis logic program carried together
analysis preferences order determine choice order sets
comparable semantics compared approaches known
literature complexity analysis performed showing respect
similar approaches previously proposed complexity computing preferred stable increase

introduction
increased interest preferences witnessed extensive number proposals
systems preference handling grell konczak schaub van nieuwenborgh
vermeir wakaki inoue sakama nitta literature distinguishes
static dynamic preferences static preferences fixed time theory specified e external logic program whereas dynamic preferences appear
within logic program determined fly common form
preference consists specifying preference conditions among rules brewka brewka
eiter delgrande schaub tompits b gelfond son
schauba wang van nieuwenborgh vermeir wang zhou
lin zhang foo whereas recent proposals admit expression
preference relations among atoms brewka niemela truszczynski brewka
sakama inoue wakaki et al sophisticated forms preferences
allow specification priorities conjunctions disjunctions literals brewka
et al delgrande et al sakama inoue numerical penalties
suboptimal options brewka
work contribution prioritized reasoning logic programming presence
preference conditions involving atoms particular priorities applied following
natural ordering defined dependencies proposed answer set optimizac

ai access foundation rights reserved

figreco trubitsyna zumpano

tion aso semantics brewka et al comparison strategy proposed
preferred stable model psm semantics sakama inoue reviewed introducing concept comparable next example describes intuition
basis proposed
example following prioritized program hp inspired program presented
brewka et al describes different menus preferences among drinks
desserts
p

fish beef
red white
pie ice cream
fish white
beef pie
fish ice cream



white red fish
red white beef
pie ice cream red

symbol denotes exclusive disjunction e body rule true exactly
one atom head true whereas rule empty head defines constraint e
rule satisfied body false first three rules p select main
dish drink dessert last three rules constraints state feasible
solution cannot contain fish white ii beef pie iii fish ice cream
prioritized rules introduce preferences among drinks desserts
program p three stable fish red pie beef white
ice cream beef red ice cream psm returns unique preferred model whereas aso technique following natural ordering preference rules
precede derives unique solution thus two approaches
provide different

structure preference rules example suggests fish beef
alternative options main dish ii choice drink depends selected main
dish precedes choice dessert second conclusion observation
provide opposite valuations choice drink define two different
classes menus considered separately words model
associated menu containing fish compared
associated menus containing beef consequently
preferred
observe example psm semantics derives preferred
model preferable due presence rule preferable
due presence rule transitively preferable
worth noting use transitive closure makes comparison much
complex two cannot compared directly hand aso
semantics sensitive syntactic changes programs fact illustrated means
following example
example consider prioritized program hp extension prioritized program defined example


fion semantics logic programs preferences

p

fish beef
red white beer
pie ice cream
fish white
beef pie
fish ice cream
beer



b beer white red fish
b beer red white beef
b pie ice cream red

program equivalent one reported example even contains additional choice beer option feasible presence constraint beer
set stable associated program p coincides reported
program p example consists fish red pie beef
white ice cream beef red ice cream considering set preference
rules note preferences regarding choice drink beer best option
stable model containing intuitively two hp example hp equivalent must preferred aso
semantics sensitive program change gives solution whereas
equivalent program example returned preferred model
change occurs set preferred psm semantics

thus present semantics inspired psm aso semantics seems better capture intuitive meaning programs avoids
mentioned
contribution
provides semantics prioritized logic programs enriching one proposed sakama inoue additional information gained structure
preference rules proposed brewka et al particular semantics
uses different preference relations among stable introduces natural ordering
among preferences fixes order choices basis stratification
preference program decision determined set choices belonging
corresponding level provides subset given input solution
decision made output subset becomes input set following decision
proposed semantics drives decision making process taking account catching
additional information regarding non comparable sets partitioning set
program looking alternative decisions end concept
incomparability taken account previous approaches introduced
presents detailed comparison approaches dealing preference
relations among atoms particular attention devoted psm aso semantics
analysis complexity computing preferred answer sets performed showing
w r previous proposals psm aso semantics complexity
computing preferred stable increase


figreco trubitsyna zumpano

plan
rest organized follows section preliminaries disjunctive
abductive logic programs prioritized logic programs answer set optimization
semantics given section interpretation prioritized logic programs
presented section complexity provided section comparison
presented semantics psm aso semantics performed approaches
known literature briefly described finally section outlines conclusions

preliminaries
assume familiarity relational database theory disjunctive logic programs disjunctive deductive databases disjunctive stable model semantics computational complexity eiter gottlob mannila b gelfond lifschitz papadimitriou

background
disjunctive logic program finite set rules r form ak b bm
c cn k n ak b bm c cn atoms
disjunction ak denoted head r called head r conjunction
b bm c cn denoted body r called body r
herbrand universe program p set constants appearing p
herbrand base bp set ground atoms constructed predicates
appearing p constants term resp atom rule program
ground variables occur rule r ground instance rule r r obtained
r replacing every variable r constant ground p denotes
set ground instances rules p
intuitive meaning previous disjunctive rule body r true e
b bm true c cn false head r must true e least one
ak true otherwise r satisfied rules empty head called denials
constraints used define constraints satisfied body false
exclusive disjunction denoted used head statement head r
ak true exactly one ak true e disjunctive rule form
ak body shorthand rule ak body k k
constraints form ai aj body j k solution logic program p
given terms stable model answer set semantics gelfond lifschitz
interpretation p model p satisfies rules ground p
minimal model semantics defined positive p assigns p set minimal
mm p model p minimal proper subset model p
minker general disjunctive stable model semantics applies programs unstratified negation gelfond lifschitz disjunctive stable model
semantics generalizes stable model semantics previously defined normal programs gelfond lifschitz interpretation denote p ground positive
program derived ground p removing rules contain negated atom
considering function free programs



fion semantics logic programs preferences

body ii removing negated atoms remaining rules
interpretation disjunctive stable model p mm p
general p stable model semantics assigns p set sm p stable well known stable minimal e sm p mm p
negation free programs minimal stable model semantics coincide e
sm p mm p
extended abductive programs
given atom p literal p strong negation p extended
program program atoms replaced literals semantics extended
disjunctive programs given terms stable considering p p
different predicate symbols considering implicit constraint p x p x gelfond
lifschitz
abductive logic programming extension logic programming perform abductive
reasoning kakas kowalski toni inoue sakama abductive program
alp pair hp ai p extended program set literals called
abducibles hp ai represented means extended program p g
g g g g g
let alp g ground atom denoting observation set
explanation g iff stable model g stable
model minimal stable model n n moreover
minimal explanation e explanation g iff g
consistent minimal stable model inoue sakama
shown given alp p ground atom g denoting observation
deciding whether exists minimal explanation g p complete eiter
gottlob leone
rest section briefly review two main approaches prioritizing reasoning refer e prioritized logic programs answer set optimization proposed
respectively sakama inoue brewka et al
prioritized logic programs
partial preference relation among atoms defined follows given two atoms e
e statement e e called priority means e higher priority e
moreover e e e e e e priority statement e e states
instance e instance e preference relation holds
prioritized logic program plp pair hp p disjunctive program
set priorities denotes set priorities reflexively transitively
derived
statement e e stands e e e e clearly e e sets
ground instantiations e e empty intersection
definition given prioritized logic program hp relation w defined
stable p follows stable p


figreco trubitsyna zumpano

w
w e e e e e
e e
w w w
w preferable moreover w w


interpretation preferred stable model hp stable model p
n w implies w n stable model n equivalently interpretation n
stable model p n set preferred stable hp
denoted psm hp note relation two plps hp
hp imply psm hp psm hp
plp priority relations used express priorities atoms whereas priorities
general forms knowledge conjunctive disjunctive knowledge rules preconditions
expressed simple rewriting preference program instance preference
rule precondition form e e b expressed plp e e
e e b e e b
semantics prioritized programs proposed sakama inoue
denoted psm semantics sound complete procedure allows preferred answer
sets plp program computed generate test
proposed wakaki et al translates plp program hp
answer set program p single logic program p
answer sets answer sets p preferable details found works
presenting semantics implementation sakama inoue wakaki et al

complexity answering queries plp programs least one level
complexity answering queries standard programs without preferences
particular let hp prioritized logic program deciding existence
preferred stable model p hard ii deciding whether atom true resp
preferable stable model hp p hard resp p hard worth noting
original work sakama inoue claimed complexity exactly one
level complexity standard programs proof take account
transitivity property preference relation
answer set optimization
answer set optimization program denoted aso program pair hp p
disjunctive program called generating program preference program consisting
finite set rules form ak b bm c cn bi cj
literals ai boolean combinations literals literal atom l
strong negation l determines preference ordering answer sets described
generating program p
boolean combination formula built atoms means disjunctions conjunctions default
negation



fion semantics logic programs preferences

definition let hp aso program n answer
set p induces satisfaction vector vs vs vs n
vs j j irrelevant e body j satisfied ii
body j satisfied none atoms head j satisfied
vs j min ai j ak b bm c cn otherwise
comparison assumed equal e vs j
equivalent vs j
definition let two answer sets vs vs vs vs
every n ii vs vs vs vs n vs vs
cases w respectively
set literals optimal model aso program hp answer set
p answer set p

complexity aso programs depends class generating programs
disjunctive programs complexity answering queries aso programs exactly
one level complexity answering queries standard programs without preferences e deciding existence preferred stable model p complete ii deciding
whether literal true resp preferable stable model hp p complete
resp p complete
strategy extended introducing meta preferences among preference
rules ranked aso program sequence hp n consisting generating program
p sequence pairwise disjoint preference programs rank rule
n denoted rank unique integer given two answer
sets wrank every preference rule vs vs
hold rule rank rank vs vs
moreover procedure deriving natural ordering preference rules introduced
firstly given preference program dependency graph g defined atoms
appearing form vertex set g directed edge vertex b
vertex g rule appears head r b appears
body r graph g acyclic natural ranking atoms
defined recursively follows rank every atom predecessors
g otherwise rank maximum ranks predecessors g
incremented rank preference rule defined maximum rank
atoms head
standard semantics aso programs priorities examined together
denoted aso semantics alternative semantics priorities divided
strata following natural order denoted raso ranked aso semantics
original work brewka et al symbols used instead w



figreco trubitsyna zumpano

preferred answer sets
syntax similar one proposed brewka et al used given
two atoms statement means higher priority
partial preference relation among atoms defined follows
definition prioritized program pair hp p disjunctive program
set preference rules form
ak b bm c cn
k ak b bm c cn atoms




following head body preference rule denoted head
body respectively ground prioritized program denoted ground hp
hground p ground prioritized program rule r p variables
replaced set ground instances e set rules obtained replacing
variables constants
intuitively preference rule form describes choice among ak
choice options condition specified body head introduces
preference order among atoms ai preferred aj j k
applied body true body specifies decisions precede
choice instance c b states b true preferred c
preference rule exactly two atoms head called binary preference rule
whereas preference rules empty bodies called preference facts prioritized
program said binary form preference rules binary
following example presenting classical program proposed brewka et al
used running example
example consider prioritized program hp whose stable define
menus restaurant
p

fish beef
red white beer
pie ice cream
beef pie
fish ice cream













white red beer fish
red white beef
beer white beef
pie ice cream beer

first three rules p select main dish drink dessert constraints
state feasible solution cannot contain beef pie fish ice cream
rules introduce preferences among drinks desserts
program p six stable
fish white pie
fish red pie
fish beer pie

beef white ice cream
beef red ice cream
beef beer ice cream

techniques proposed sakama inoue brewka et al select
stable preferred ones motivation different indeed
psm semantics states w w w w w whereas


fion semantics logic programs preferences

r aso semantics states mi w w mi w mi w e
r aso semantics compared directly whereas psm
semantics compared transitively

presenting formal semantics programs preliminary definitions
needed preference rule form ak body shorthand k
binary rules form ai ai body k set preferences
established given transitive closure defined follows
definition given prioritized program hp ground transitive closure
c body body b body b c body c
set binary preference rules derived ground

thus defined set rules explicitly representing preference relations
among choice options section ground prioritized program
hp rewritten equivalent program hp contains
number rules polynomial size
structure prioritized programs examined order establish precedence relation among choices made instance presence preference rule
c b suggests selection b precedes choice c thus
establishes precedence relation b c idea used brewka
et al determining natural ordering among preference rules detail
relational order among atoms appearing captured means corresponding dependency graph g stratification preference rules established
considering head atoms
unfortunately natural ordering among preference rules established
corresponding dependency graph acyclic thus presence two rules coffee
tea pie pie ice cream coffee admit stratification
introduce two mutually dependent choices
stratification proposed overcomes introducing concept collapsed graph maps node options mutually
dependent choices
given ground prioritized program hp g v e denotes dependency
graph whose set nodes consists atoms p whereas arc b
labeled resp p rule resp p containing head b
body resp b head body body preference facts empty
assume bodies contain built atom true every fact
c
considered rule true g denotes acyclic collapsed dependency graph derived
g replacing maximal sets mutual dependent nodes e nodes belonging
c
cycle unique node clearly node g associated set nodes
g
c

node g possible assign level follows
c

node g input degree zero level


figreco trubitsyna zumpano

c

node g input degree greater zero
c
c
level max max level b b z g max level b b z p g
observe function level assigns node maximum distance
node input degree zero following definition introduces concept stratification
preference rules
definition stratification given ground prioritized program hp
partitioned h n subprograms called strata
c

atom level level node g associated
rule level max level body
level consists ground preference rules associated
level

partition h n called stratification
definition stratification preference rules establishes order
preferences applied considering p moreover assignment level
rule differs one proposed brewka et al two main aspects
level atoms defined analyzing collapsed dependency graph level
rules established considering body atoms instead head atoms detailed
comparison two approaches presented section
example consider prioritized program hp example transitive closure
consists binary preference rules white red fish red beer
fish white beer fish derived rules
stratified two strata

structural analysis performed goes beyond stratification process
tries understand comparability end concepts conflicting
preferences comparable introduced
two ground binary preferences form b body b body
said conflicting instance preferences white red fish
red white beef example conflicting whereas preferences
red water beef set preferences said conflicting
contains two conflicting preference rules
intuition basis clarified example suppose
two conflicting preferences b c b two conflicting
preferences specify preference b two different sets
b characterized presence c respectively thus c
atoms c depend define alternative decisions decision
made associated solutions longer comparable
preference rule said relevant stable model used
compare stable body head


fion semantics logic programs preferences

atoms belongs given prioritized program hp ground preference rule
b body set stable relevant sm p
sm p body b
definition comparable let hp prioritized program two
stable p h n stratification
comparable
comparable n
comparable
b exist two conflicting preference rules
sm p sm p sm p sm p

observe second condition previous definition comparable
states presence two conflicting preference rules given level identifies two
sets one two conflicting rules relevant two
appearing different sets considered separately next levels
words two stable relevant preferences conflicting rules
b body b body given level comparable levels
greater sm p sm p sm p sm p
body b body body b body
example consider stable fish beer pie beef beer
ice cream set preference rules example stable
comparable definition comparable
relevant fish white beer beef
relevant beef white beer fish conflicting
preferences belong

fact let hp prioritized program without conflicting preferences h
n stratification two comparable
n

proof proof fact follows directly definition



basis definition declarative semantics prioritized logic programs
provided semantics denoted pas preferred answer sets given
preferred stable follows
definition preference answer sets given prioritized program hp
relation w defined stable p follows pair stable
p h n stratification w
e e body e e
comparable relevant


figreco trubitsyna zumpano

e e body j j e e
relevant
moreover strictly preferable w w



note relation could defined directly replacing condition j
j item definition
definition preferred answer sets interpretation preferred stable model
prioritized program hp stable model p exist stable
model n n set preferred stable hp denoted
pas hp

note definition introduces preferences pairs considering
additional information gained structure preference rules
example consider prioritized program hp example stratification
h presented example
comparable definition
owing
owing
conflicting relevant cannot
compared relevant
therefore discussed example comparable
consequently preferred

previous example stable model considered good
beef main dish best choice drink red wine beer respectively
dessert ice cream observe aso psm semantics discard
already stated aso semantics deduces preferable owing
psm semantics states preferable preferable
owing
b
example let hp program example consider program hp
b derived replacing


pie ice cream
b
ground preference program unique level


derived shown example due following relations hold mi mj j therefore
unique preferred model obtained psm aso semantics


fion semantics logic programs preferences

complexity
section provides concerning computational complexity computing
preferred stable answering queries pas semantics consider data
complexity input domain consists herbrand universe assume
constants occurring occur p clearly size herbrand base bp
well sizes ground p ground polynomial size
following demonstrate allowing preferences among atoms semantics proposed increases complexity expressivity language one level
polynomial hierarchy thus use additional information increase
computational complexity proposed respect mentioned
techniques brewka et al sakama inoue
proposition let hp prioritized program exists program
hp equivalent hground p stratification computed
polynomial time ii hp derived hground p polynomial time
proof start considering program hground p binary
c
ground version size graphs g g polynomial size
c
computed polynomial time assignment levels nodes g
done polynomial time assignment levels atoms rules
done polynomial time
let h n stratification generate ground prioritized
program hp equivalent hground p size polynomial size
initially assign ground atom ai appearing head preference rule
unique index let ap indexed atoms appearing head rules
p denotes program ground p p
p b j l bodyi j ai aj bodyi j l
b j l b k l b k j l l max l l j k p l l n
b predicate symbol denotes set ground preference rules
defined follows
ai aj b j l j p l n
stratification obtained associating stratum l preference rules
whose body atom value level attribute equal l l ai aj
b j l ai aj b j l
order equivalence hground p hp observe
set stable ground p p equivalent e sm p
stable model n sm ground p n b j l b j l
n sm ground p stable model sm p n
b j l b j l rules ground p contain atoms form
b j l bodies


figreco trubitsyna zumpano

moreover let n stable model ground p corresponding stable
model p n ground preference rule ai aj bodyi j l whose
body true n ground rule ai aj b j l l whose body true
vice versa therefore two sets l l equivalent l n
clearly program hp derived hground p polynomial time

following sake simplicity presentation continue refer
program hp stratification
proposition let hp prioritized program two stable p
h n stratification checking whether
given k n comparable k solved polynomial time
proof obviously comparable assuming
comparable given level j k comparable level j
two conflicting preference rules b body b body j
body b body body b body check
done polynomial time number rules j polynomial size
moreover maximum value k bounded size bounded
set atoms bp global complexity polynomial

corollary let hp prioritized program two interpretations p
checking whether solved polynomial time
proof straightforward definition proposition



lemma let hp prioritized program interpretation p
deciding whether preferred stable model hp p
proof consider complementary deciding whether preferred
stable model hp case sufficient first check stable model
stable model sufficient guess interpretation n check n
stable model p ii n check part well check
stable model done means n p oracle deciding
whether interpretation stable model disjunctive program con p complete
whereas check part ii done polynomial time see corollary therefore
complexity complementary n p n p consequently complexity
original con p n p

theorem let hp prioritized program
deciding whether ground atom g true preferred stable hp
p complete
deciding whether ground atom g true preferred stable hp
p complete


fion semantics logic programs preferences

proof membership first demonstrate deciding whether g true
preferred stable model hp p suffices prove complementary consisting deciding whether true preferred stable
p complete
membership sufficient guess interpretation containing g
check whether preferred stable model lemma deciding
whether preferred stable model p solved means p
oracle
therefore deciding whether exists preferred stable model containing g
p
n p p
hardness given abductive logic program consisting disjunctive program p
set abducibles positive atoms ground abductive logic program derived prom p

ground p g g g ground
g g g ground
let
g g g ground
h denotes prioritized program derived p
two stable n sm w n respect means
preference p u p u p u p u n exists
preference q v q v q v n q v exists implies
ground n ground consequently preferred stable
minimal
therefore deciding whether h minimal explanation
goal g equivalent deciding whether h preferred stable model containing g
consequently deciding whether minimal explanation g exists
p complete deciding whether preferred stable model h
containing g exits p hard whereas deciding whether preferred

stable hp contain g p hard
corollary let hp disjunction free prioritized program deciding
whether ground atom true preferred stable hp p complete
p complete
proof complexity one level lower deciding whether interpretation stable model disjunction free program polynomial


analysis comparison
section compares semantics introduced psm r aso semantics
briefly discusses recently proposed semantics
psm semantics elegant compares pairs basis
common preferences basis degree satisfaction consider natural ordering preference rules cases example
compares consequently discards pas


figreco trubitsyna zumpano

comparable interesting feature psm technique application transitive
property order derive additional preference relations among solutions
immediately visible preference relations captured however test
transitive property cannot performed direct comparison two lies
complex implementation
r aso technique powerful tool determines preferred
evaluating degree satisfaction preference rules thus compares two
even absence common preferences preference relation
two established directly detail raso technique considers
structure preference rules associating degree satisfaction choice options
introduces natural ordering among preferences case psm semantics
r aso semantics compares consequently discards
comparable pas technique instance program hp presented
introduction raso discards second best option drink even
unique possible choice presence fish
specifically preference relation w used psm preorder
relation reflexive transitive determines equivalent answer set classes
establishes partial preference order among mentioned classes consequently
preferred answer sets appearing preferred classes noted
psm semantics requires use transitive property order derive
basis relations obtained direct comparison pairs preference
relations contrary r aso semantics uses strict preference relation
asymmetric require application transitive property
compare solutions
pas semantics proposed compares two solutions basis common preferences introducing concept comparable considering
refinement natural order among preference choices thus seen extension psm semantics uses additional information derived structure
preference rules instead comparing transitively compares
considering transitive closure ground preference rules
novelty pas semantics consideration structural information preference rules introduces concept comparable order avoid comparing
opinion compared associated alternative decisions moreover proposes refinement natural order among preferences
order define order choices raso semantics establishes relational order among
atoms appearing means corresponding dependency graph g cannot
treat case mutually dependent choices stratification proposed
c
overcomes considering collapsed graph g acyclic
construction sensitive syntactic changes moreover raso semantics
stratification preference rules established considering head atoms whereas
pas semantics levels assigned rules basis body atoms following
intuition describe contexts choices thus stratification proposed
assigns preference facts first level level rule fixed looking
level body atoms
advantages adopted clarified following example


fion semantics logic programs preferences

example defined means prioritized program hp consists
selecting colors trousers shirt black blue trousers r
white yellow red shirts r available fashion consultant suggests blue
trousers better black ones white shirt better yellow shirt
case black trousers white shirt preferred red one moreover
blue trousers go white shirt c red shirt go blue
trousers c
p

r
r
c
c






black blue
white yellow red
blue white
red blue



blue black
white yellow
white red black

program p four stable black white black yellow
blue yellow black red order define stratification
preference rules raso pas semantics firstly assign level atoms first level
blue black yellow second level white red second step
raso considering maximum level head atoms assigns first
level second level whereas pas defines level preferences
basis body atoms assigns first level second level note
case order relevant determining preferred fact
raso gives pas returns preferred

formal comparison three semantics carried class
programs specific definition stratification significant moreover
psm semantics defined prioritized programs hp consists
binary facts preference rules rewritten preference facts following
comparison carried considering programs whose preference rules consist
facts class programs closure used psm pas semantics
coincide
given prioritized program hp denote gsem v esem preference
graph stable p v sm p denotes set stable
p esem denotes preference relation defined semantics sem
psm aso pas particular esem consists arcs mi mj mi mj
holds sem semantics therefore comparison different semantics
performed analyzing corresponding preference graphs stable model mi preferred
sem semantics arc mj mi gsem
following example shows relation psm pas semantics
example consider prioritized program hp
p fish beef pork chicken
white fish
red beef
beer pork
water chicken


fish beef
chicken pork
red white
red water
beer water

figreco trubitsyna zumpano

program four stable fish white beef red
pork beer chicken water whereas direct preference relations
psm semantics follows w w w w w
consequently graph gpsm consists four nodes
four arcs therefore preferred

regarding pas semantics relation holds thus
three preferred stable namely

theorem prioritized program hp consists preference facts
psm hp pas hp
proof consider graphs gpsm v epsm gpas v epas graphs
acyclic epas epsm two graphs acyclic adding edges
create cycles number nodes without incoming edges decreases therefore set
nodes without incoming edges gpas contains nodes without incoming edges gpsm
consequently psm hp pas hp

analyze relation aso pas semantics first note
observed introduction aso semantics sensitive syntax changes
instance prioritized program
abc

b c
b

two preferred stable b however program
b
b c
b

abc

derived rewriting rule c preferred model
thus consider special class constraints sensitive syntactic
changes since every ground prioritized program hp partitioned n strata n rewritten program hp
equivalent pas semantics shown proof proposition
may equivalent raso semantics rules belong
unique stratum continue consider programs hp consists
single stratum particular facts
given prioritized program hp consists facts denote
ai ai n n maximum
set preference rules obtained merging ground preference facts
lemma let hp prioritized program consists preference facts
ground aso hp pas hp


fion semantics logic programs preferences

proof consider two graphs gaso v easo gpas v epas
epas means e
ground rule e e e e
ii ground rule e e e e
implies ground
must ground rule e e
e e
ii must ground rule e e
e e
therefore respect aso semantics graph gaso contains arc consequently epas easo aso hp pas hp
tight relation two semantics consider restriction
obtained deleting atoms appear model ground
preference rules


b ai ai n n maximum

sm p ai ai

theorem let hp prioritized program consists preference
b aso hp pas hp
facts ground
b derived
proof aso hp pas hp derives lemma
deleting nodes appear model influence relation
aso semantics
aso hp pas hp consider relation aso semantics
means
b e
ground rule e e
e

ground rule e e
e e



b
implies ground

must ground rule e e e e

ground rule e e e e


figreco trubitsyna zumpano

therefore holds respect pas semantics consequently
easo rpas aso hp pas hp

extension aso semantics proposed brewka brewka
niemela truszczynski detail brewka provided preference
description language allowing express complex preferences combining qualitative
quantitative penalty preferences whereas brewka et al proposed framework specify solutions outcomes preferences among latter
proposal combines ideas answer set programming answer set optimization cpnets boutilier brafman domshlak hoos poole semantics
proposed different proposed brewka brewka
et al cases returns different see examples

approaches
besides approaches managing preferences among atoms works proposed
literature specify preferences among rules
early proposals expressing preferences rules focus default logic brewka eiter
delgrande et al b rintanen whereas recently emphasis
given logic programs regard different proposals developed
representing reasoning user preferences ordered logic programs delgrande et al van nieuwenborgh vermeir preferred answer sets
extended logic programs brewka eiter approaches propose
extension gelfond lifschitzs extended logic programming adding preference information delgrande et al wang et al zhang foo proposals
attempt extend well founded semantics logic programs preferences brewka
schauba wang extension van gelders alternating fixpoint theory
logic programs priorities proposed wang et al
gelfond son proposed methodology reasoning prioritized
default language logic programming answer set semantics
enables specification preferences among rules allows definition set
default rules must satisfied well second set default rules could
ignored
ordered logic programs introduced delgrande et al extended
logic programs whose rules subject strict partial order static dynamic
preferences fully prescriptive enforces ordering information
construction answer set original program transformed second
extended logic program preferences taken account sense
answer sets obtained evaluating transformed theory correspond preferred
answer sets original theory
another methodology logic programs containing preferences set rules
translated logic programs stable model semantics proposed
delgrande et al


fion semantics logic programs preferences

conclusions
case preferences involving atoms logic programming studied
particular behavior technique proposed sakama inoue
brewka et al analyzed semantics interpreting preference rule
tool representing choice alternative options proposed specifically
proposed extends psm semantics considering refinement natural
order among preferences introduces concept comparable preferences
logic programs examined together order determine choice order sets
compared
semantics compared psm aso semantics complexity analysis performed showing use additional information
regarding preference order sets non comparable increase
complexity computing preferred stable although semantics presented
complexity approaches proposed literature advantage lies
fact seems better capture intuitive meaning prioritized programs
considering structural information preference rules
prioritized reasoning logic programming pas semantics easily
implemented top deductive systems stable model semantics
deres dlv smodels cholewinski marek truszczynski leone pfeifer faber
calimeri dellarmi syrjanen niemela architecture system
prototype implementing prioritized reasoning different semantics top
dlv system presented caroprese trubitsyna zumpano

acknowledgments
preliminary version papers presented greco trubitsyna zumpano
authors would thank anonymous referees useful suggestions
filippo furfaro comments

references
boutilier c brafman r domshlak c hoos h poole cp nets tool
representing reasoning conditional ceteris paribus preference statements
journal artificial intelligence
brewka g well founded semantics extended logic programs dynamic
preferences journal artificial intelligence
brewka g eiter preferred answer sets extended logic programs artificial
intelligence
brewka g eiter prioritizing default logic intellectics computational
logic kluwer
brewka g logic programming ordered disjunction proceedings th national
conference artificial intelligence aaai iaai


figreco trubitsyna zumpano

brewka g niemela truszczynski answer set optimization proceedings
th international joint conference artificial intelligence ijcai
brewka g complex preferences answer set optimization proceedings th
international conference principles knowledge representation reasoning
kr
brewka g niemela truszczynski prioritized component systems proceedings th national conference artificial intelligence aaai
caroprese l trubitsyna zumpano e implementing prioritized reasoning
logic programming proceedings international conference enterprice information
systems iceis
cholewinski p marek v w truszczynski default reasoning system deres
proceedings th international conference principles knowledge representation
reasoning kr
delgrande j p schaub tompits h logic programs compiled preferences proceedings th european conference artificial intelligence ecai
delgrande j p schaub tompits h compilation brewka eiters
prioritization proceedings european workshop logics artificial
intelligence jelia
delgrande j p schaub tompits h framework compiling preferences
logic programs theory practice logic programming
eiter gottlob g leone n abduction logic programs semantics
complexity theoretical computer science
eiter gottlob g mannila h disjunctive datalog acm transaction
database systems
gelfond lifschitz v stable model semantics logic programming
proceedings international conference logic programming iclp
gelfond lifschitz v classical negation logic programs disjunctive
databases generation computing
gelfond son c reasoning prioritized defaults proc rd international
workshop logic programming knowledge representation lpkr
greco trubitsyna zumpano e semantics logic programs
preferences proceedings th european conference logics artificial intelligence
jelia
grell konczak k schaub nomore system computing preferred
answer sets proceedings th international conference logic programming
nonmonotonic reasoning lpnmr
janhunen niemela simons p j h unfolding partiality disjunctions stable model semantics proceedings th international conference principles knowledge representation reasoning kr


fion semantics logic programs preferences

inoue k sakama negation failure head journal logic programming
kakas c kowalski r toni f abductive logic programming journal
logic anc computation
leone n pfeifer g faber w calimeri f dellarmi eiter gottlob g ianni
g ielpa g koch k perri polleres dlv system proceedings
th european conference logics artificial intelligence jelia
minker j indefinite data bases closed world assumption proc th
conf automated deduction
papadimitriou c h computational complexity addison wesley
rintanen j complexity prioritized default logics journal artificial intelligence
sakama c inoue k priorized logic programming application commonsense reasoning artificial intelligence
schaub wang k comparative study logic programs preference
proceedings th international joint conference artificial intelligence ijcai

syrjanen niemela smodels system proceedings international conference logic programming nonmonotonic reasoning lpnmr
van nieuwenborgh vermeir preferred answer sets ordered logic
programs proceedings th european conference logics artificial intelligence
jelia
van nieuwenborgh vermeir ordered diagnosis proceedings th international conference logic programming artificial intelligence reasoning
lpar
van nieuwenborgh heymans vermeir programs linearly ordered multiple preferences proceedings international conference logic programming iclp
wakaki inoue k sakama c nitta k computing preferred answer sets
answer set programming proceedings th international conference logic
programming artificial intelligence reasoning lpar
wakaki inoue k sakama c nitta k plp system proceedings th
european conference logics artificial intelligence jelia
wang k zhou l lin f alternating fixpoint theory logic programs
priority proceedings first international conference computational logic
zhang foo n answer sets prioritized logic programs proceedings international logic programming symposium ilps




