journal artificial intelligence

submitted published

spectrum one two three infinity
marco pistore

pistore dit unitn

department information communication technology
university trento
via sommarive povo trento italy

moshe vardi

vardi cs rice edu

department computer science
rice university
main street houston texas

abstract
linear temporal logic ltl widely used defining conditions execution
paths dynamic systems case dynamic systems allow nondeterministic
evolutions one specify along ltl formula paths
required satisfy formula two extreme cases universal interpretation
requires formula satisfied execution paths existential
interpretation e requires formula satisfied execution path
ltl applied definition goals nondeterministic
domains two extreme cases restrictive often impossible develop plans
achieve goal nondeterministic evolutions system weak
require goal satisfied execution
explore alternative interpretations ltl formula
extreme cases define language permits arbitrary combination
e quantifiers thus allowing instance require finite execution
extended execution satisfying ltl formula ae
finite execution whose extensions satisfy ltl formula ea
eight combinations path quantifiers relevant corresponding alternation
quantifiers length one e two ae ea three aea eae
infinity ae ea present language
automata theoretic study complexity

introduction
automated task fikes nilsson penberthy weld ghallab nau
traverso given description dynamic domain basic actions
performed given goal defines success condition achieved one
suitable plan description actions executed domain
order achieve goal classical concentrates called reachability
goals goals define set final desired states reached quite often
practical applications require plans deal goals general sets
final states several approaches recently proposed temporal logic
formulas used goal language thus allowing goals define conditions
whole plan execution paths e sequences states resulting execution
plans bacchus kabanza calvanese de giacomo vardi cerrito
c

ai access foundation rights reserved

fipistore vardi

mayer dal lago pistore traverso de giacomo vardi kvarnstrom
doherty pistore traverso approaches use linear temporal
logic ltl emerson goal language ltl allows one express reachability
goals e g f q reach q maintainability goals e g g q maintain q well goals
combine reachability maintainability requirements e g f g q reach set
states q maintained boolean combinations goals
nondeterministic domains cimatti pistore roveri traverso
peot smith warren actions allowed different outcomes
possible know time different possible outcomes actually
take place nondeterminism action outcome necessary modeling realistic way
several practical domains ranging robotics autonomous controllers two player
games instance realistic robotic application one take account
actions pick object might failure e g object slips
robots hand consequence nondeterminism execution plan may lead
one possible execution path therefore one distinguish whether given
goal satisfied possible execution paths case speak strong
possible execution paths weak case
ltl goal strong corresponds interpreting formula universal
way weak corresponds interpreting existential way
e
weak strong plans two extreme ways satisfying ltl formula nondeterministic domains might impossible achieve goals strong way
instance robotic application might impossible fulfill given task objects
keep slipping robots hand hand weak plans unreliable
since achieve goal overly optimistic assumptions outcomes
action executions
case reachability goals strong cyclic cimatti et al daniele
traverso vardi shown provide viable compromise weak
strong formally plan strong cyclic possible partial execution
plan extended execution reaches goal state strong cyclic
allows plans encode iterative trial error strategies pick
object succeed execution strategies may loop forever case
action pick object continuously fails failure achieving goal
unfair execution usually acceptable branching time logics ctl ctl allow
expressing goals take account nondeterminism indeed daniele et al
encode strong cyclic reachability goals ctl formulas however ctl
ctl path quantifiers interleaved temporal operators making difficult
extend encoding strong cyclic proposed daniele et al generic
temporal goals
define logic allows exploring different degrees
ltl formula satisfied exist strong goal weak goal
e consider logic formulas form ltl formula
path quantifier generalizes e quantifiers used strong weak
see work ghallab et al deeper discussion fundamental role nondeterminism
practical applications



fithe spectrum one two three infinity

path quantifier finite infinite word alphabet e path quantifier
seen definition two player game selection outcome action
execution player corresponding symbol chooses action outcomes order
make goal fail player e corresponding symbol e chooses action outcomes
order satisfy goal turn active player controls outcome action
execution finite number actions passes control player
say plan satisfies goal player e winning strategy namely
possible moves player player e able build execution path
satisfies ltl formula
different path quantifiers define different alternations turns players e
instance goal require formula satisfied independently
hostile player chooses outcomes actions ask strong plan
goal e require formula satisfied action outcomes chosen
friendly player e ask weak plan goal ae require
every plan execution led player extended player e successful execution
satisfies formula case reachability goal corresponds asking
strong cyclic solution goal ea require initial set actions
controlled player e guarantee formula satisfied independently
player choose outcome following actions final example
goal ae aeaea require formula satisfied executions
player e possibility controlling action outcome infinite number
times
path quantifiers define arbitrary combinations turns players e
hence different degrees satisfying ltl goal however rather surprisingly finite number alternatives exist strong weak
eight canonical path quantifiers give rise plans different strength every
path quantifier equivalent canonical one canonical path quantifiers correspond
games length one e two ae ea three aea eae
games defining infinite alternation players e ae ea
case reachability goals f q canonical path quantifiers
collapse three different degrees solution possible corresponding weak
e f q strong f q strong cyclic ae f q
finally present goal language study
complexity automata theoretic emerson jutla
kupferman vardi wolper domains goals represented
suitable automata reduced checking whether given
automaton nonempty proposed time complexity doubly
exponential size goal formula known
exptime complete goals form pnueli rosner hence
complexity optimal
structure follows section present preliminaries
automata theory temporal logics section define domains
plans section define ae ltl logic path quantifier study basic
path quantifier finite word player last turn chooses action outcome
rest infinite execution



fipistore vardi

properties section present ae ltl section
apply logic particular cases reachability maintainability goals
section make comparisons related works present concluding remarks

preliminaries
section introduces preliminaries automata theory temporal logics
automata theory
given nonempty alphabet infinite word infinite sequence
symbols finite state automata proposed finite structures accept
sets infinite words interested tree automata namely finite
state automata recognize trees alphabet rather words
definition tree leafless tree subset n
root tree
x n x
x x n n x
x x n n x
arity x number children namely arity x x let
n tree tree arity x x labelled tree pair
tree following denote labelled tree
let dom
let labelled tree path p possibly infinite sequence x x nodes
xi dom xk xk ik following denote p set
finite paths p set infinite paths given finite infinite path p
denote p string x x x x sequence nodes
path p say finite resp infinite path p finite resp infinite extension
finite path p sequence nodes p prefix sequence nodes p
tree automaton automaton accepts sets trees consider
particular family tree automata namely parity tree automata emerson jutla
definition parity tree automata parity tree automaton parity index k
tuple h q q
finite nonempty alphabet
n finite set arities
q finite set states
q q initial state


fithe spectrum one two three infinity





q q transition function q q
q k parity mapping
tree automaton accepts tree accepting run automaton tree
intuitively parity tree automaton state q reading ary node
tree labeled nondeterministically chooses tuple hq qd q
makes copies one child node tree state
th copy updated qi run parity tree automaton accepting along every
infinite path minimal priority visited infinitely often even number
definition tree acceptance parity tree automaton h q q accepts labelled tree exists accepting run r namely exists
mapping r q
r q
x arity x hr x r x r x x
along every infinite path x x
infinitely many nodes xi even

minimal integer h r xi h

tree automaton nonempty exists tree



accepted

emerson jutla shown emptiness parity tree automaton
decided time exponential parity index polynomial number
states
theorem emptiness parity tree automaton n states index k
determined time k
temporal logics
formulas linear temporal logic ltl emerson built top set prop
atomic propositions standard boolean operators unary temporal operator
x next binary temporal operator u following assume
fixed set atomic propositions prop define prop set subsets
prop
definition ltl ltl formulas prop defined following grammar
q prop
q x u
define following auxiliary operators f u eventually future
g f future ltl formulas interpreted infinite words
following write w ltl whenever infinite word w satisfies ltl
formula
definition ltl semantics let w infinite word let
ltl formula define w ltl n follows


fipistore vardi

w ltl q iff q
w ltl iff hold w ltl
w ltl iff w ltl w ltl
w ltl x iff w ltl
w ltl u iff j w k ltl k j
w j ltl
say w satisfies written w ltl w ltl
ctl emerson example branching time logic path quantifiers
paths e path prefix arbitrary combinations linear time
operators
definition ctl ctl formulas prop defined following grammar
q prop
q e
x u
ctl formulas interpreted labelled trees following write
whenever satisfies ctl formula



ctl

definition ctl semantics let labelled tree let ctl formula
define x ctl x follows


x ctl q iff q x



x ctl iff hold x ctl



x ctl



x ctl iff p ctl holds infinite paths p x x x x



x



iff

ctl e iff
x x

x ctl x ctl

p

ctl holds infinite path p x x

p ctl p p defined follows



p ctl iff p x x x ctl



p ctl iff hold p ctl



p ctl



p ctl x iff p ctl p x x p x x x



p ctl u iff j pk ctl k j
pj ctl pi xi xi p x x

iff

p ctl p ctl



fithe spectrum one two three infinity

put b


b

c

b


put c b
c

c
b


figure possible scenario blocks world domain
say



satisfies ctl formula written



ctl

ctl

following theorem states possible build tree automaton accepts
trees satisfying ctl formula tree automaton number states
doubly exponential parity index exponential length formula
proof theorem given emerson jutla
theorem let ctl formula let n finite set arities one
build parity tree automaton ad
accepts exactly labelled trees satisfy

automaton ad

formula



states parity index length

domains plans
nondeterministic domain cimatti et al expressed terms
set states one designated initial state set actions transition
function describing execution action leads one state possibly many
different states
definition domain domain tuple h ri
finite set states
initial state
finite set actions
r transition relation
require r
assume states ordered write r h n whenever
r n n
example consider blocks world domain consisting set blocks initially
table stacked top order build towers see
figure
states domain possible configurations blocks case
three blocks states corresponding blocks table configuration
block tower remaining block table configurations block tower
possible configurations assume initially blocks table


fipistore vardi

actions domain put x put x table wait x
two different blocks actions put x put x table possible
blocks top x otherwise could pick x addition action
put x requires blocks top otherwise could put x
top
assume outcome action put x nondeterministic indeed trying
put block top tower may fail case tower destroyed action
wait nondeterministic possible table bumped towers
destroyed
plan guides evolution domain issuing actions executed
case nondeterministic domains conditional plans cimatti et al pistore
traverso required next action issued plan may depend
outcome previous actions consider general definition plans
plan mapping sequence states representing past history domain
evolution action executed
definition plan plan partial function
w r
w r iff w dom
w dom w w dom
defined iff initial state domain
conditions previous definition ensure plan defines action executed
exactly finite paths w reached executing plan initial
state domain
example possible plan blocks world domain example represented figure remark importance plans action executed depends
whole sequence states corresponding past history evolution indeed
according plan figure two different actions put c put c table
performed state block b top depending past history
since consider nondeterministic domains execution action may
lead different outcomes therefore execution plan domain
described labelled tree component label tree corresponds
state domain component describes action executed
state
definition execution tree execution tree domain plan
labelled tree defined follows




initial state domain


fithe spectrum one two three infinity

w

w

abc

put b

b
abc ac

put c b

b
abc ac

c
b


b
abc ac

c
b


b
ac

b
abc ac

c
b


b
ac

put c table

history

put b table

abc

wait
wait

figure plan blocks world domain
p x xn p p n r n

h
every following conditions hold xn dom
xn n
consists domain goal g defines set
desired behaviors following assume goal g defines set execution
trees namely execution trees exhibit behaviors described goal say
execution trees satisfy goal
definition pair g
domain g goal solution g plan
execution tree satisfies goal g

logic path quantifiers
section define logic ltl extends
possibility defining conditions sets paths satisfy ltl property
start motivating logic necessary defining goals
example consider blocks world domain introduced previous section intuitively plan example solution goal building tower consisting
blocks b c destroying goal easily formulated ltl


fipistore vardi

formula
f c b b table f c table b table table
notice however due nondeterminism outcome actions plan may
fail satisfy goal possible instance action put c b fails
tower destroyed case plan proceeds performing wait actions hence
tower never finished formally plan solution goal requires
path execution structure satisfies ltl formula
clearly better ways achieve goal building tower destroying
fail building tower rather giving restart building keep
trying succeed strategy allows achieving goal paths
keep destroying tower try build achieve goal
see logic path quantifiers going define allow us formalize
mean paths
consider following ltl formula
f g c b b table
formula requires building tower maintaining case two possible
ways fail achieve goal fail build tower built fail
maintain remember wait action may nondeterministically lead destruction
tower similarly case formula goal requires satisfying
formula paths execution tree unsatisfiable hand goal
requires satisfying paths weak logic allows us demanding
paths satisfy formula
finally consider following ltl formula
g f c b b table
requires tower exists infinitely many time e tower gets destroyed
rebuild intuitively goal admits plans achieve often e
paths path logic needed give formal meaning
paths
order able represent goals discussed previous example
consider logic formulas form ltl formula path
quantifier defines set infinite paths formula checked two
extreme cases path quantifier used denote must hold
paths path quantifier e used denote must hold paths
general path quantifier finite infinite word alphabet e defines
alternation selection two modalities corresponding e instance
writing ae require finite paths infinite extension satisfies
writing ea require extensions finite path satisfy
path quantifier seen definition two player game selection
paths satisfy ltl formula player corresponding tries build
path satisfy ltl formula player e corresponding e tries


fithe spectrum one two three infinity

build path ltl formula holds different path quantifiers define different
alternations turns players e game starts path consisting
initial state turns players e extend path finite
number nodes case path quantifier finite word player moves last
game extends finite path built far infinite path formula satisfied
player e winning strategy namely possible moves player
able build path satisfies ltl formula
example let us consider three ltl formulas defined example let us see
path quantifiers introduced applied
case formula plan presented example satisfies requirement e
path tower built destroyed satisfies stronger
requirement ea stresses fact case tower built
destroyed safely give control player formula satisfied
stronger way however indeed plan keeps trying build tower satisfies
requirement ae well requirement aea player cannot reach state
satisfaction goal prevented
let us consider formula case plans satisfying ae
plan satisfy requirement aea indeed player simple strategy win
gets control built tower bump table similar considerations hold
formula case plans requirement ae
requirement aea case however plans exist requirement aeaeae
player e gets control infinitely often rebuild tower needed
rest section give formal definition study basic properties
logic path quantifiers
finite games
start considering games finite number moves path quantifiers
corresponding finite words e
definition ae ltl ae ltl formula pair g ltl
formula e path quantifier
following definition describes games corresponding finite path quantifiers
definition semantics ae ltl let p finite path labelled tree

p finite extensions p p holds p
p e finite extension p p holds p
p infinite extensions p p holds

p ltl

p e infinite extension p p holds


p ltl



fipistore vardi

say labelled tree satisfies ae ltl formula g write
p g p root



g

ae ltl allows path quantifiers consisting arbitrary combination
es combination corresponds different set rules game
e theorem freedom definition path quantifier
needed six path quantifiers sufficient capture possible games
concept equivalent path quantifiers
consider formulas f p ae f p easy see two formulas equisatisfiable e tree satisfies f p satisfies ae f p vice versa
case path quantifiers ae power depends fact
use path quantifiers combination ltl formula f p combine
two path quantifiers different ltl formulas g p possible
trees satisfy latter path quantifier former reason cannot
consider two path quantifiers equivalent indeed order two path quantifiers
equivalent equi satisfiable ltl formulas intuition
formalized following definition
definition equivalent path quantifiers let two path quantifiers
say implies written
labelled trees ltl formulas

implies say equivalent written




following lemma describes basic properties path quantifiers
equivalences among exploit proof theorem
lemma let e following implications equivalences hold
aa ee e




e empty



aea eae

e

aeae ae eaea ea
proof proof lemma order prove
prove given

arbitrary tree arbitrary ltl formula p implies p every
finite path p indeed p implies p finite paths p easy
prove induction p implies p finite paths p
following refer proof technique prefix induction
every finite path p p aa p
equivalence aa follows prefix induction
let us assume p aa prove p p
every finite extension p p since p aa definition know
assume empty word proof case empty word similar



fithe spectrum one two three infinity

every finite extension p p p hence definition know
every finite extension p p p since p finite extension p
conclude p therefore p holds finite extensions p
p
let us assume p prove p aa finite
extensions p p finite extensions p p p remark
finite path p finite extension p therefore p holds since
p
concludes proof equivalence aa proof
equivalence ee e similar
let us assume first empty word distinguish two cases depending
first symbol prove aa



already item lemma e
every finite path p p ae p e
follows

prefix induction let us assume p ae finite extensions p
p exists finite extension p p p let us take p p
know finite extension p p p
according definition p e
let us assume empty word hypothesis
empty distinguish two cases depending last symbol
prove aa
already item lemma
e prove every finite path p p ea p e
ea
e follows prefix induction let us assume p ea
definition exists finite extension p p every infinite
extension p p p ltl let p infinite extension p
know p infinite extension p p ltl
definition deduce p e
concludes proof

proof

e similar

item lemma know
aa item know


aa
aea concludes proof
aea proof
eae
e similar
item lemma know eae
e moreover


item know e
aea e therefore deduce ae


aeae proof ea eaea similar

prove first main finite path quantifier
equivalent canonical path quantifier length three
theorem finite path quantifier canonical finite path quantifier
e ae ea aea eae
assume empty word proof case empty similar



fipistore vardi

moreover following implications hold canonical finite
path quantifiers

aea ae

















ea
eae e




proof first prove path quantifier equivalent canonical path
quantifier iterative application lemma obtain path quantifier
contain two adjacent e iterative
application lemma transform equivalent path quantifier
length canonical path quantifiers precisely quantifiers
length contain two adjacent e
implications


aea eae

e come lemma

aea

ea ae

eae come lemma

aea

ae ea

eae come lemma



remark lemma theorem depend usage ltl formula
depend general observation
whenever player e select
game set paths subset selected game
infinite games
consider infinite games namely path quantifiers consisting infinite words
alphabet e see infinite games express finite path quantifiers
studied previous subsection infinite games corresponding infinite alternation two players e cannot expressed
finite path quantifiers
case infinite games assume player e moves according strategy
suggests extend finite path say infinite
game winning strategy player e strategy winning whenever
p infinite path obtained according e allowing player play
arbitrary way requiring player e follows strategy p satisfies ltl
formula
definition strategy strategy labelled tree mapping p
p maps every finite path p one finite extensions p
definition semantics ae ltl let e infinite
path quantifier infinite path p possible outcome game strategy
generating sequence namely infinite sequence p p finite paths

pi finite prefixes p


fithe spectrum one two three infinity

p root tree



e pi pi
pi arbitrary extension pi
denote p set infinite paths possible outcomes game
strategy tree satisfies ae ltl formula g written g
strategy p ltl paths p p
remark possible paths generating sequence stop growing e
pi pi pj j case according previous
definition infinite paths p extend pi possible outcomes
next lemmas extend analysis equivalence among path quantifiers
infinite games first lemma shows finite path quantifiers particular cases
infinite path quantifiers namely correspond infinite path quantifiers
end infinite sequence e
lemma let finite path quantifier e e
proof prove proof equivalence similar
first prove
let tree ltl formula
moreover let strategy p p satisfy
order prove sufficient use strategy moves player
e namely whenever need prove p e according definition take
p p move prove p way infinite paths selected
definition coincide possible outcomes game hence satisfy
ltl formula
concludes proof
prove
distinguish
three cases
case n n
case lemma let tree
ltl formula paths satisfy formula
easy check paths satisfy formula
sufficient conclude na n
case e
case ea indeed arbitrary path quantifier starts e
ends lemma collapse adjacent occurrences
e thus obtaining ea n n moreover lemma
ea n ea
let tree ltl formula ea
finite path p infinite extensions p satisfy let
definitions implication equivalence relations definition apply case
infinite path quantifiers



fipistore vardi

strategy p every infinite path p p e
satisfies indeed since player e first turn possible outcomes
infinite extensions p
concludes proof e

e

case n e n
reasoning proof previous case easy aea
let tree ltl formula aea
every finite path p finite extension p p infinite
extensions p satisfy formula let strategy p p
finite extension p infinite extensions p satisfy every
infinite path p p n e satisfies indeed let p p pn pn
generating sequence p pn pn p infinite extension pn
construction know p satisfies
concludes proof n e

n e

every finite path quantifier falls one three considered cases therefore
conclude
every finite path quantifier

next lemma defines sufficient condition proving
useful proofs forthcoming lemmas

condition

lemma let two infinite path quantifiers let us assume labelled
trees strategy strategy p p


proof let us assume suitable strategy
p p satisfy ltl formula let strategy p
p hypothesis possible outcomes game strategy satisfy ltl
formula hence concludes proof


next lemma games players e alternate infinitely
often equivalent one two games ae ea assume
player extends path turn passes player
lemma let infinite path quantifier contains infinite number
infinite number e ae ea
proof let e n e n mi ni ae
first prove ae
let strategy tree let p infinite
path p p p p ae lemma
sufficient proving ae

let p p generating sequence p according moreover let p
p pm n mi ni mi p pm n mi ni mi easy
check p p p valid generating sequence p according game ae
strategy indeed extensions p p p p p p moves player


fithe spectrum one two three infinity

hence arbitrary extensions p p p p correspond extensions
pm pm pm n pm n moves player e hence
respect strategy
prove
ae let strategy tree define strategy
p p lemma sufficient proving
p p ae


ae
kp p kp p p ni strategy path
let p finite path p

p obtained applying kp times strategy number times strategy applied
depends length p path p
p possible
p possible outcome game strategy

outcome game ae strategy let p p generating sequence p

according ae
p p p p p n p p p
z
z
z
times

times
n times

n
p p p p p



z

n times

z
times

valid generating sequence p according extensions corresponding
occurrence symbol e consist application strategy hence valid
player e moreover extension ni p p valid move player
p extension ni p indeed ni p prefix p hence p
p p
kp p kp
since p p

x nx ni since p
conditions definition easily checked
concludes proof ae e n e n proof
ea e n e n similar

next lemma contains auxiliary path quantifiers
lemma let finite path quantifier infinite path quantifier





e

e

e

proof
prove
let strategy tree let p infinite
path p p p p let p p
generating sequence p according easy check
p p pi pi pi pi length valid generating sequence
p according indeed extension pi pi valid move player
concludes proof

prove
e e e e e e
e
trivially true e assume without loss
generality case let strategy tree let p


fipistore vardi

path p p e p p let p p
generating sequence p according e easy check
p p pi pi length valid generating sequence p
according indeed extension pi pi valid corresponds
first symbol assumed symbol concludes proof

e
prove

proof

e similar

let strategy tree let p infinite path
p p p p let p p generating sequence p
according easy check p p valid generating sequence p according fact defines less restrictive
conditions generating sequences
sufficient conclude





complete picture theorem finite infinite path quantifier
equivalent canonical path quantifier defines game consisting alternated moves
players e length one two three infinity
theorem finite infinite path quantifier canonical path quantifier
e ae ea aea eae ae ea
moreover following implications hold canonical path
quantifiers

aea ae ae









ea








ea






eae e

proof first prove path quantifier equivalent canonical path quantifier
theorem true finite path quantifiers consider infinite path
quantifiers
let infinite path quantifier distinguish three cases
contains infinite number infinite number e lemma
equivalent one canonical games ae ea
contains finite number case ends infinite sequence e
lemma finite path quantifier theorem
equivalent canonical path quantifier concludes proof
case
contains finite number e case similar previous one
implications


fithe spectrum one two three infinity

ae
ae

ea comes lemma taking empty word

aea
ae ae


ae ea

ea ea

eae come lemmas

implications come theorem



strictness implications
conclude section showing arrows diagram theorem
describe strict implications namely eight canonical path quantifiers different
let us consider following p q labelled binary tree root labelled
node two children labelled p q


im
qqq mmmmm
q
q
mmm
q

qqq




p xq
q
























p
q
p
q

























p
p
p
q
q
p
q
q

let us consider following ltl formulas
f p player e satisfy formula moves least visiting p labelled
node
g f p player e satisfy formula visit infinite number p labelled
nodes final move finite game moves infinitely often
infinite game
f g p player e satisfy formula takes control game
certain point final move finite game
g q player e satisfy formula player never plays since player
immediately visit q labelled node
x p player e satisfy formula playing first turn moving left
child root node
following graph shows formulas hold path quantifiers
fp

gfp

fgp

g q

aea ae ae


xp




















ea ea eae e


fipistore vardi

ae ltl
section present ae ltl goals start showing
build parity tree automaton accepts trees satisfy given ae ltl
formula tree automaton adapted accepts
trees correspond valid plans given domain way
checking whether exists plan given domain ae ltl goal
reduced emptiness tree automata finally study complexity
ae ltl goals prove exptime complete
tree automata ae ltl formulas
berwanger gradel kreutzer shown ae ltl formulas expressed directly ctl formulas reduction exploits equivalence expressive
power ctl monadic path logic moller rabinovich tree automaton
obtained ae ltl formula reduction theorem however
translation proposed berwanger et al upper bound non elementary
complexity hence useful complexity analysis describe
different direct reduction better suited purposes
labelled tree satisfies formula suitable subset paths
tree satisfy subset paths chosen according order
characterize suitable subsets paths assume w marking tree
use labels w define selected paths
definition w marking w marking labelled tree w w labelled tree w dom dom w whenever x w x w
w x w
exploit w markings follows associate ae ltl formula ctl
formula tree satisfies formula wmarking satisfies
definition ae ltl ctl let ae ltl formula ctl formula
defined follows

e e
ea ef w f w
aea ag ef w f w
ae ag exg w f g w
eae ef ag exg w f g w
ae ag ef w g f w
ea ef ag ef w g f w
case path quantifiers e direct translation ctl
exploit w marking cases ctl formula conjunction


fithe spectrum one two three infinity

two sub formulas first one characterizes good markings according path
quantifier second one guarantees paths selected according
marking satisfy ltl formula case path quantifiers ea aea mark
w nodes reached guarantee formula satisfied selected
paths hence contain node labelled w formula f w case
path quantifiers ae eae mark w descendants node define
infinite path satisfies selected paths hence certain node
continuously labelled w formula f g w case path quantifiers ae
ea finally mark w nodes player e wants reach according
strategy passing turn player selected paths hence
contain infinite number nodes labelled w formula g f w paths along
player e moves infinitely often
theorem labelled tree satisfies ae ltl formula
w marking satisfies formula
proof proof consider cases aea ae ae
cases similar
assume tree satisfies exists w marking w
satisfies
case aea according definition tree satisfies aea every
finite path p extended finite path p infinite extensions
p p satisfy let us mark w nodes w correspond
extension p path p construction marked tree satisfies ag ef w
remains marked tree satisfies f w
let us consider path p tree satisfies f w let us p
satisfies since p satisfies f w know contains nodes marked w let
p finite prefix path p first node marked w construction
exists finite path p p finite extension p infinite
extensions p satisfy consequence p satisfies
case ae according definition tree satisfies ae
finite paths p infinite extension p satisfies therefore
define mapping p p associates finite path p infinite
extension p satisfies assume without loss generality p
finite extension p prefix p p p
far p extends finite path p along infinite path p associates
p infinite path p
every finite path p let us mark w node w child p
along infinite path p construction marked tree satisfies ag exg w
remains marked tree satisfies f g w
let us consider path p tree satisfies f g w let us p
satisfies since p satisfies f g w know path p
descendants p along p marked w order prove p satisfies


fipistore vardi

p p assume contradiction p p let p
longest common prefix p p observe p prefix p hence
p p implies child node p along p marked w
absurd since definition p descendants p along p marked
w
case ae according definition tree satisfies ae
exists suitable strategy player e possible outcomes game
strategy satisfy let us mark w nodes w correspond
extension p finite path p mark w nodes
reached move player e according strategy marked
tree satisfies formula ag ef w every finite path p extended
finite path p node corresponding p marked w indeed
construction sufficient take p p extension p p remains
marked tree satisfies g f w
let us consider path p tree satisfies g f w let us p
satisfies purpose p possible outcome game
strategy remark given arbitrary finite prefix p p possible
finite extension p p p prefix p indeed
set paths p p p finite prefix p infinite infinite nodes
marked w path p
let p p p sequence finite paths defined follows p
root three p k shortest extension p k p k
prefix p p k p k easy check p p p generating
sequence p according ae hence definition infinite path p
satisfies ltl formula
concludes proof satisfies exists w marking
satisfies
assume w marked tree w satisfies satisfies

case aea marked tree satisfies formula ag ef w means
finite path p ag exists finite extension p final node
p marked w ef w let p infinite extension finite path p
p satisfies ltl formula clearly p satisfies formula f w
since tree satisfies formula f w infinite paths satisfy f w
satisfy therefore p satisfies ltl formula
case ae marked tree satisfies formula ag exg w
finite path p ag exists infinite extension p certain
node nodes p marked w exg w p
infinite extension finite path p p satisfies ltl formula clearly
p satisfies formula f g w since tree satisfies formula f g w
infinite paths satisfy f g w satisfy therefore p satisfies ltl
formula


fithe spectrum one two three infinity

case ae let strategy every finite path p node
corresponding p marked w remark possible define
strategy fact marked tree satisfies formula ag ef w hence
finite path p extended finite path p node corresponding
p marked w
let p possible outcome game strategy prove p satisfies
ltl formula definition infinite path p contains infinite set
nodes marked w nodes reached move player e hence
p satisfies formula g f w since tree satisfies formula g f w
infinite paths satisfy g f w satisfy therefore path p satisfies ltl
formula
concludes proof exists w marking tree




satisfies


kupferman defines extension ctl existential quantification
atomic propositions egctl examines complexity model checking satisfiability
logic remark ae ltl seen subset egctl indeed
according theorem labelled tree satisfies ae ltl formula
satisfies egctl formula w
following definition transform parity tree automaton
ctl formula parity tree automaton ae ltl formula
transformation performed abstracting away information w marking
input alphabet transition relation tree automaton
definition let h w w q q parity tree automaton parity
tree automaton aw h q q w obtained abstracting away wmarking defined follows w q q w q w
lemma let aw two parity tree automata definition aw accepts
exactly labelled trees w marking accepted
proof let w w w labelled tree let corresponding labelled
tree obtained abstracting away w marking w accepted
accepted aw let r q accepting run w r
accepting run aw indeed x arity x w x
w w hr x r x r x x
definition aw hr x r x w r x
labelled tree accepted aw w w labelled tree w w marking accepted let r q
accepting run aw definition run know x arity x
x hr x r x w r x definition w
know hr x r x r x w r x w let us define
w x w hr x r x r x w w x w otherwise
easy check r accepting run w



fipistore vardi

ingredients defining tree automaton accepts
trees satisfy given ae ltl formula
definition tree automaton ae ltl let n finite set arities
let ae ltl formula parity tree automaton ad
obtained applying
transformation described definition parity automaton ad
built according
theorem
theorem parity tree automaton ad
accepts exactly labelled trees
satisfy formula
proof theorem parity tree automaton ad
accepts trees satisfy
ctl formula therefore parity tree automaton ad
accepts trees
satisfy formula lemma theorem

parity tree automaton ad
parity index exponential number
states doubly exponential length formula

proposition parity tree automaton ad




states parity index

proof construction definition change number states
parity index automaton therefore proposition follows theorem


describe automaton ad
exploited order build plan goal
given domain
start defining tree automaton accepts trees define valid
plans domain h ri recall according definition
transition relation r maps state action tuple next states
h n r
following assume finite set arities compatible domain
namely r h
definition tree automaton domain let h ri
domain let set arities compatible domain

tree automaton ad
corresponding domain ad ha
h h r

according definition labelled tree obtained plan
domain converse true namely labelled tree
accepted tree automaton ad
induces plan
definition plan induced tree let labelled tree accepted automaton ad
plan induced domain defined follows n finite path p p
n


fithe spectrum one two three infinity

following lemma shows definitions define one one correspondence valid plans domain trees accepted automaton
ad

lemma let tree accepted automaton ad
let corresponding
induced plan valid plan domain execution tree corresponding
conversely let plan domain let corresponding execution
structure accepted automaton ad
plan induced
proof lemma direct consequence definitions



define parity tree automaton accepts trees correspond
plans domain satisfy goal g parity tree automaton obtained
combining suitable way tree automaton ae ltl formula g definition
tree automaton domain definition
definition instrumented tree automaton let set arities compatible domain let ad
g h q q parity tree automaton accepts trees satisfy ae ltl formula g parity tree
automaton ad
g corresponding domain goal g defined follows

ad g ha q q h q qd q
hq qd q h r q q
following lemmas solutions g one one
correspondence trees accepted tree automaton ad
g
lemma let labelled tree accepted automaton ad
g let
plan induced domain plan solution
g
proof according definition prove execution tree corresponding
satisfies goal g lemma amounts proving tree satisfies g
construction easy check labeled tree accepted ad
g

accepted ag indeed rd g q accepting run ad
g

rg q accepting run ag rg x q whenever rd g q


lemma let solution g execution tree
accepted automaton ad
g
proof let execution tree lemma know accepted ad

moreover definition solution know accepted
ad
g construction easy check labeled tree accepted


ad ad
g accepted ad g indeed let rd accepting

run ad
let rg q accepting run ag rd g q

accepting run ad g rd g x q rd x rg x q



fipistore vardi

consequence checking whether goal g satisfied domain reduced
checking whether automaton ad
g nonempty
theorem let domain g ae ltl formula plan exists
goal g domain tree automaton ad
g nonempty
proposition parity tree automaton ad
g domain r goal
g



states parity index

proof consequence proposition definition automaton ad
g
complexity
study time complexity defined subsection
given domain ae ltl goals g
decided time doubly exponential size formula applying
theorem tree automaton ad
g
lemma let domain existence plan ae ltl goal g

domain decided time

proof theorem existence plan goal g domain reduced
emptiness parity tree automaton ad
g proposition parity tree



automaton ad
states parity index since assume
g
domain fixed theorem emptiness automaton ad
g decided time









doubly exponential time bound tight indeed realizability
ltl formula known exptime complete pnueli rosner
reduced goal realizability one assumes
program environment alternate control evolution system
precisely execution states decided program
even environment odd say given formula realizable
program executions satisfy independently actions
environment
theorem let domain deciding existence plan
ae ltl goal g domain exptime complete
proof realizability formula reduced checking exis
tence plan goal domain init p e init e r

r init e


r init e



r p e

r p e



r e e p

r e


fithe spectrum one two three infinity


states p program controls evolution actions
states e environment controls evolution nondeterministic action e performed state finally state init used assign initial
move program
since realizability exptime complete size ltl formula
pnueli rosner exptime hard size goal
g exptime completeness follows lemma

remark case goals form e better
complexity defined case plan exists e
infinite sequence states satisfies r ai
action ai reduced model checking
ltl formula known pspace complete sistla clarke
conjecture canonical path quantifiers except e doubly
exponential bound theorem tight
remarks order complexity satisfiability validity
ae ltl goals pspace complete indeed ae ltl formula
satisfiable ltl formula satisfiable latter
known pspace complete sistla clarke similar argument holds
validity
complexity model checking ae ltl recently addressed
kupferman vardi kupferman vardi introduce mctl variant
ctl path quantifiers memoryful interpretation memoryful quantification express linear cost semantics path quantifiers
ae ltl example ae ltl formula ae expressed mctl formula
ag e kupferman vardi model checking logic
expspace complete holds subset mctl corresponds formulas ae therefore model checking ae ltl finite
path quantifiers expspace complete best knowledge complexity
model checking ae ltl formulas ae ea still open

two specific cases reachability maintainability goals
section consider two basic classes goals particularly relevant
field
reachability goals
first class goals reachability goals corresponding ltl formula f q
q propositional formula literature concentrates
class goals several works address defining plans
different strength kind goals see e g cimatti et al citations
tree satisfies paths satisfy path satisfies seen
tree satisfies



fipistore vardi

context ae ltl soon player e takes control immediately achieve
reachability goal possible fact control given back player
goal achieved irrelevant therefore significant path quantifiers
reachability goals e ae
proposition let q propositional formula atomic propositions prop
following hold every labelled tree e f q iff ea f q iff eae f q
iff ea f q moreover ae f q iff aea f q iff ae f q
proof prove ae f q iff aea f q iff ae f q cases
similar
let us assume ae f q moreover let p finite path know p
extended infinite path p p f q according semantics
ltl p f q means node x path p q x clearly
infinite paths contain node x satisfy ltl formula f q therefore
finite extension p p infinite extensions p satisfy ltl
formula f q sufficient take p finite extension p contains node x since
property holds every finite path p conclude aea f q
proven ae f q implies aea f q theorem know
aea
ae
ae hence aea f q implies ae f q implies ae f q
concludes proof

following diagram shows implications among significant path quantifiers
reachability goals

ae e
remark three goals f q e f q ae f q correspond respectively
strong weak strong cyclic cimatti et al
maintainability goals
consider another particular case namely maintainability goals g q q
propositional formula maintainability goals properties complementary
properties reachability goals case soon player takes control
violate maintainability goal possible fact player e take control
player hence irrelevant interesting path quantifiers e
ea
proposition let q propositional formula atomic propositions prop
following hold every labelled tree g q iff ae g q iff
aea g q iff ae g q moreover ea g q iff eae g q iff ea g q
proof proof similar proof proposition



following diagram shows implications among significant path quantifiers
maintainability goals
ea e


fithe spectrum one two three infinity

goals g q e g q ea g q correspond maintainability variants strong weak
strong cyclic indeed correspond requiring condition q
maintained evolutions despite nondeterminism g q condition q maintained
evolutions e g q possible reach state condition
q maintained despite nondeterminism ea g p

related works concluding remarks
defined ae ltl temporal logic extends ltl
possibility declaring complex path quantifiers define different degrees
ltl formula satisfied computation tree propose use ae ltl formulas
expressing temporally extended goals nondeterministic domains
defined ae ltl goals automata theoretic
framework existence plan reduced checking emptiness suitable parity
tree automaton studied time complexity proving
exptime complete length ae ltl formula
field several works use temporal logics defining goals
approaches bacchus kabanza calvanese et al cerrito mayer
de giacomo vardi kvarnstrom doherty use linear temporal logics
goal language able express conditions degree goal
satisfied respect nondeterminism execution notable exceptions
works described pistore bettin traverso pistore traverso
dal lago et al pistore et al pistore traverso use ctl
goal language dal lago et al define branching time logic allows
expressing temporally extended goals deal explicitly failure recovery
goal achievement goal languages however path quantifiers interleaved
temporal operators hence rather different ae ltl
field temporal logics work alternating temporal logic atl alur
henzinger kupferman related work atl path quantifiers
ctl ctl replaced game quantifiers nevertheless obvious way
expressed formulas form path quantifier ltl formula
atl expressive logic studied alur et al conjecture
logic atl incomparable expressiveness
comments order practical impact exptime complexity
first many expect
complex large domains goals relatively simple see e g experimental
evaluation performed pistore et al case goals expressed ctl
formulas cases doubly exponential complexity size
formula may bottleneck larger ae ltl goals doubly exponential time
complexity may feasible noted worst case complexity
note improved plan synthesis active area including
analysis simpler ltl goals alur la torre development improved
automata theoretic kupferman vardi
automata theoretic framework used wider applicability ae ltl goals interesting direction future investigations application


fipistore vardi

framework variants ae ltl allow nesting path quantifiers
goals combine ae ltl propositional temporal operators would allow
instance specify goals compose requirements different strength simple
example goals ae f p g p requires achieve condition p strong
cyclic way maintaining condition q strong way impossibility define kind
goals opinion strongest limitation ae ltl respect ctl
ctl
another direction future investigations extension proposed
case partial observability de giacomo vardi
one assumes agent executing plan observe part state
hence choices actions execute may depend part
plan explore implementation issues particular possibility
exploiting bdd symbolic techniques ae ltl goals
cases techniques shown able deal effectively domains
goals significant complexity despite exponential worst case time complexity
bertoli cimatti pistore roveri traverso pistore et al

acknowledgments
shorter version without proofs published pistore vardi
authors would thank erich gradel comments reduction
ae ltl formulas ctl formulas

references
alur r henzinger kupferman alternating time temporal logic journal
acm
alur r la torre deterministic generators games ltl fragments
acm trans comput log
bacchus f kabanza f temporally extended goals ann
mathematics artificial intelligence
bacchus f kabanza f temporal logic express search control knowledge
artificial intelligence
bertoli p cimatti pistore roveri traverso p mbp model
planner proc ijcai workshop uncertainty
incomplete information
berwanger gradel e kreutzer upon time west determinacy definability complexity path games prof th int conf logic
programming artificial intelligence reasoning lpar pp
calvanese de giacomo g vardi reasoning actions
ltl action theories proc th int conf principles knowledge
representation reasoning kr pp


fithe spectrum one two three infinity

cerrito mayer bounded model search linear temporal logic
application proc nd int conf analytic tableaux related
methods tableaux vol lnai pp springer verlag
cimatti pistore roveri traverso p weak strong strong cyclic
via symbolic model checking artificial intelligence
dal lago u pistore traverso p language extended
goals proc th national conf artificial intelligence aaai aaai
press
daniele traverso p vardi strong cyclic revisited proc
th european conf ecp vol lnai pp springer
verlag
de giacomo g vardi automata theoretic temporally extended goals proc th european conf ecp vol
lnai pp springer verlag
emerson e temporal modal logic van leeuwen j ed handbook
theoretical computer science b formal semantics elsevier
emerson e jutla c complexity tree automata logics programs
proc th ieee symp foundations computer science pp
emerson e jutla c tree automata calculus determinacy proc
nd ieee symp foundations computer science pp
fikes r nilsson n strips application theorem
proving solving artificial intelligence
ghallab nau traverso p automated theory practice
elsevier
kupferman augmenting branching temporal logics existential quantification atomic propositions journal logic computation
kupferman vardi safraless decision procedures proc th ieee
symp foundations computer science focs pp ieee computer
society
kupferman vardi memoryful branching time logic proc
th ieee symposium logic computer science lics ieee computer
society
kupferman vardi wolper p automata theoretic branching time model checking journal acm
kvarnstrom j doherty p talplanner temporal logic forward chaining
planner ann mathematics artificial intelligence
moller f rabinovich expressive power ctl proc th
annual ieee symposium logic computer science lics pp
ieee computer science press


fipistore vardi

penberthy j weld ucpop sound complete partial order planner
adl proc rd int conf principles knowledge representation
reasoning kr
peot smith conditional nonlinear proc st int conf
ai systems aips pp morgan kaufmann publisher
pistore bettin r traverso p symbolic techniques
extended goals non deterministic domains proc th european conf
ecp
pistore traverso p model checking extended goals nondeterministic domains proc th int joint conf artificial intelligence
ijcai aaai press
pistore vardi specturm one two three infinity
proc th ieee symposium logic computer science lics pp

pnueli rosner r distributed reactive systems hard synthesize
proc st ieee symp foundation computer science pp
sistla clarke e complexity propositional linear temporal logic
journal acm
warren generating conditional plans programs proc summer
conf artificial intelligence simulation behaviour aisb pp




