Journal Artificial Intelligence Research 16 (2002) 1-58

Submitted 7/01; published 1/02

Fusions Description Logics
Abstract Description Systems
Franz Baader
Carsten Lutz

baader@cs.rwth-aachen.de
lutz@cs.rwth-aachen.de

Teaching Research Area Theoretical Computer Science,
RWTH Aachen, Ahornstrae 55, 52074 Aachen, Germany

Holger Sturm

holger.sturm@uni-konstanz.de

Fachbereich Philosophie, Universitat Konstanz,
78457 Konstanz, Germany

Frank Wolter

wolter@informatik.uni-leipzig.de

Institut fur Informatik, Universitat Leipzig,
Augustus-Platz 10-11, 04109 Leipzig, Germany

Abstract
Fusions simple way combining logics. normal modal logics, fusions
investigated detail. particular, known that, certain conditions, decidability transfers component logics fusion. Though description logics
closely related modal logics, necessarily normal. addition, ABox
reasoning description logics covered results modal logics.
paper, extend decidability transfer results normal modal logics
large class description logics. cover different description logics uniform way,
introduce abstract description systems, seen common generalization
description modal logics, show transfer results general setting.

1. Introduction
Knowledge representation systems based description logics (DL) used represent knowledge application domain structured formally well-understood
way (Brachman & Schmolze, 1985; Baader & Hollunder, 1991; Brachman, McGuinness,
Patel-Schneider, Alperin Resnick, & Borgida, 1991; Woods & Schmolze, 1992; Borgida,
1995; Horrocks, 1998). systems, important notions domain described concept descriptions, i.e., expressions built atomic concepts (unary
predicates) atomic roles (binary predicates) using concept constructors provided
description logic employed system. atomic concepts concept
descriptions represent sets individuals, whereas roles represent binary relations
individuals. example, using atomic concepts Woman Human, atomic
role child, concept women daughters (i.e., women
children women) represented description Woman u child.Woman,
concept mothers description Woman u child.Human. example,
used constructors concept conjunction (u), value restriction (R.C), existential restriction (R.C). DL literature, various constructors
considered. prominent example so-called number restrictions, available
almost DL systems. example, using number restrictions concept women
c
2002
AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiBaader, Lutz, Sturm, & Wolter

exactly two children represented concept description
Woman u ( 2child) u ( 2child).
knowledge base DL system consists terminological component (TBox)
assertional component (ABox). simplest form, TBox consists concept
definitions, assign names (abbreviations) complex descriptions. general TBox
formalisms allow so-called general concept inclusion axioms (GCIs) complex
descriptions. example, concept inclusion
Human u ( 3child) v entitled.Taxbreak
states people least three children entitled tax break. ABox
formalism consists concept assertions (stating individual belongs concept)
role assertions (stating two individuals related role). example,
assertions Woman(MARY), child(MARY, TOM), Human(TOM) state Mary woman,
child, Tom, human.
DL systems provide users various inference capabilities allow
deduce implicit knowledge explicitly represented knowledge. instance, subsumption problem concerned subconcept-superconcept relationships: C subsumed
(C v D) if, if, instances C instances D, i.e., first description always interpreted subset second description. example, concept
description Woman obviously subsumes concept description Woman u child.Woman.
concept description C satisfiable iff non-contradictory, i.e., interpreted
nonempty set. DLs allowing conjunction negation concepts, subsumption reduced (un)satisfiability: C v iff C u unsatisfiable. instance
checking problem consists deciding whether given individual instance given
concept. example, w.r.t. assertions above, MARY instance concept
description Woman u child.Human. ABox consistent iff non-contradictory,
i.e., model. DLs allowing negation concepts, instance problem
reduced (in)consistency ABoxes: instance C w.r.t. ABox iff A{C(i)}
inconsistent.
order ensure reasonable predictable behavior DL system, reasoning
DL employed system least decidable, preferably low
complexity. Consequently, expressive power DL question must restricted
appropriate way. imposed restrictions severe, however, important
notions application domain longer expressed. Investigating trade-off
expressivity DLs complexity inference problems thus
one important issues DL research (see, e.g., Levesque & Brachman,
1987; Nebel, 1988; Schmidt-Schau, 1989; Schmidt-Schau & Smolka, 1991; Nebel, 1990;
Donini, Lenzerini, Nardi, & Nutt, 1991, 1997; Donini, Hollunder, Lenzerini, Spaccamela,
Nardi, & Nutt, 1992; Schaerf, 1993; Donini, Lenzerini, Nardi, & Schaerf, 1994; De Giacomo
& Lenzerini, 1994a, 1994b, 1995; Calvanese, De Giacomo, & Lenzerini, 1999; Lutz, 1999;
Horrocks, Sattler, & Tobies, 2000).
paper investigates approach extending expressivity DLs (in many
cases) guarantees reasoning remains decidable: fusion DLs. order explain
2

fiFusions Description Logics Abstract Description Systems

difference usual union fusion DLs, let us consider simple
example. Assume DL D1 ALC, i.e., provides Boolean operators u, t,
additional concept constructors value restriction R.C existential restriction
R.C, DL D2 provides Boolean operators number restrictions
( nR) ( nR). application requires concept constructors DLs
expressing relevant concepts, one would usually consider union D1 D2 D1
D2 , allows unrestricted use constructors. example, concept
description C1 := (R.A) u (R.A) u ( 1R) legal D1 D2 description. Note
description unsatisfiable, due interaction constructors D1 D2 .
fusion D1 D2 D1 D2 prevents interactions imposing following restriction:
one assumes set role names partitioned two sets, one used
constructors D1 , another one used constructors D2 . Thus,
description C1 legal D1 D2 description since uses role R
existential restrictions (which D1 -constructors) number restriction
(which D2 -constructor). contrast, descriptions (R1 .A) u (R1 .A) u ( 1R2 )
(R1 .( 1R2 )) admissible D1 D2 since employ different roles D1 D2 -constructors. concepts must expressed require
constructors D1 D2 , ones D1 roles ones
D2 , one really need union D1 D2 ; fusion would sufficient.
advantage taking fusion instead union? Basically, union
two DLs one must design new reasoning methods, whereas reasoning fusion
reduced reasoning component DLs. Indeed, reasoning union may even
undecidable whereas reasoning fusion still decidable. example, consider
DLs (i) ALCF, extends basic DL ALC functional roles (features)
same-as constructor (agreement) chains functional roles (Hollunder & Nutt, 1990;
Baader, Burckert, Nebel, Nutt, & Smolka, 1993); (ii) ALC +,,t , extends ALC
transitive closure, composition, union roles (Baader, 1991; Schild, 1991).
DLs, subsumption concept descriptions known decidable (Hollunder & Nutt,
1990; Schild, 1991; Baader, 1991). However, union ALCF +,,t undecidable
subsumption problem (Baader et al., 1993). undecidability result depends fact
that, ALCF +,,t , role constructors transitive closure, composition, union
applied functional roles appear within same-as constructor.
allowed fusion ALCF ALC +,,t . course, failure certain undecidability proof
make fusion decidable.
know fusion decidable DLs decidable? Actually,
general dont, main reason writing paper. notion fusion introduced investigated modal logic, basically transfer results finite
axiomatizability, decidability, finite model property, etc. uni-modal logics (with one
pair box diamond operators) multi-modal logics (with several pairs, possibly satisfying different axioms). led rather general transfer results (see, e.g.,
Wolter, 1998; Kracht & Wolter, 1991; Fine & Schurz, 1996; Spaan, 1993; Gabbay, 1999
results concern decidability), sometimes restricted so-called normal
modal logics (Chellas, 1980). Since close relationship modal logics
DLs (Schild, 1991), clear transfer results apply DLs. question is, however, DLs exactly inference problems. First, DLs
3

fiBaader, Lutz, Sturm, & Wolter

allow constructors considered modal logics (e.g., same-as constructor
mentioned above). Second, DL constructors considered modal logics, qualified number restrictions ( nR.C), ( nR.C) (Hollunder & Baader, 1991),
correspond graded modalities (Van der Hoek & de Rijke, 1995), easily
shown non-normal. Third, transfer results decidability concerned
satisfiability problem (with without general inclusion axioms). ABoxes related
inference problems considered. ABoxes simulated modal logics allowing
so-called nominals, i.e., names individuals, within formulae (Prior, 1967; Gargov
& Goranko, 1993; Areces, Blackburn, & Marx, 2000). However, see below,
general transfer results apply modal logics nominals.
purpose paper clarify DLs decidability component DLs
transfers fusion. purpose, introduce so-called abstract description systems
(ADSs), seen common generalization description modal logics.
define fusion ADSs, state four theorems say conditions
decidability transfers component ADSs fusion. Two theorems
concerned inference w.r.t. general concept inclusion axioms two inference
without TBox axioms. cases, first formulate prove results
consistency problem ABoxes (more precisely, corresponding problem ADSs)
establish analogous results satisfiability problem concepts.
DL point view, four theorems shown paper concerned
following four decision problems:
(i) decidability consistency ABoxes w.r.t. TBox axioms (Theorem 17);
(ii) decidability satisfiability concepts w.r.t. TBox axioms; (Corollary 22);
(iii) decidability consistency ABoxes without TBox axioms (Theorem 29);
(iv) decidability satisfiability concepts without TBox axioms (Corollary 34).
theorems imply decidability consistency problem satisfiability
problem transfers fusion DLs considered literature. main exceptions (which satisfy prerequisites theorems)
(a) DLs propositionally closed, i.e., contain Boolean connectives;
(b) DLs allowing individuals (called nominals modal logic) concept descriptions;

(c) DLs explicitly allowing universal role negation roles.
Results modal logic problem (iv) usually require component modal logics
normal. Theorem 29 less restrictive, thus applies DLs allowing
constructors qualified number restrictions.

2. Description logics
defining abstract description systems next section, introduce main
features DLs must covered definition. purpose, first introduce
4

fiFusions Description Logics Abstract Description Systems

ALC, basic DL containing Boolean connectives, relevant inference problems.
Then, consider different possibilities extending ALC expressive DLs.
Definition 1 (ALC Syntax). Let NC , NR , NI countable pairwise disjoint sets
concept, role, individual names, respectively. set ALC concept descriptions
smallest set
1. every concept name concept description,
2. C concept descriptions R role name, following expressions concept descriptions:
C (negation), C u (conjunction), C (disjunction),
R.C (existential restriction), R.C (value restriction).
use > abbreviation abbreviation u (where
arbitrary concept name).
Let C concept descriptions. C v general concept inclusion axiom
(GCI). finite set axioms called TBox.
Let C concept description, R role name, i, j individual names. C(i)
concept assertion R(i, j) role assertion. finite set assertions called
ABox.
meaning ALC-concept descriptions, TBoxes, ABoxes defined
help set-theoretic semantics.
Definition 2 (ALC Semantics). ALC-interpretation pair (I , ),
nonempty set, domain interpretation, interpretation function.
interpretation function maps
concept name subset AI ,
role name R subset RI ,
individual name element iI different names mapped
different elements (unique name assumption).
role name R element define RI (a) := {b | (a, b) RI }.
interpretation function inductively extended complex concepts follows:
(C)I := \ C
(C u D)I := C DI
(C D)I := C DI
(R.C)I := {a | RI (a) C 6= }
(R.C)I := {a | RI (a) C }
interpretation model TBox iff satisfies C DI GCIs C v
. model ABox iff satisfies iI C concept assertions C(i)
(iI , j ) RI role assertions R(i, j) A. Finally, model ABox
relative TBox iff model ABox TBox.
5

fiBaader, Lutz, Sturm, & Wolter

Given semantics, formally define relevant inference problems.
Definition 3 (Inferences). Let C concept descriptions, individual name,
TBox, ABox. say C subsumes relative TBox (D vT C)
iff DI C models . concept description C satisfiable relative
TBox iff exists model C 6= . individual instance
C ABox relative TBox iff iI C models relative .
ABox consistent relative TBox iff exists model relative .
three inferences considered without reference TBox: C subsumes
(C satisfiable) iff C subsumes (C satisfiable) relative empty TBox,
instance C (A consistent) iff instance C (A consistent)
relative empty TBox.
restrict attention DLs propositionally closed (i.e., allow
Boolean operators conjunction, disjunction, negation). Consequently, subsumption
reduced (un)satisfiability since C vT iff C u unsatisfiable relative .
Conversely, (un)satisfiability reduced subsumption since C unsatisfiable relative
iff C vT . reason, irrelevant whether consider subsumption
satisfiability problem results concerning transfer decidability problems
component DLs fusion (informally called transfer results following).
Similarly, instance problem reduced (in)consistency problem vice
versa: instance C relative iff {C(i)} inconsistent relative ;
inconsistent relative iff instance relative ,
arbitrary individual name. Consequently, irrelevant whether consider instance
problem consistency problem transfer results.
Finally, satisfiability problem reduced consistency problem: C satisfiable relative iff ABox {C(i)} consistent relative , arbitrary
individual name. However, converse need true. obvious
implies transfer result satisfiability problem yield corresponding
transfer result consistency problem: decidability consistency problem
component DLs deduce decidability satisfiability problem
fusion. might less obvious transfer result consistency problem need
imply corresponding transfer result satisfiability problem: satisfiability
problems component DLs decidable, transfer result consistency
problem applied (since prerequisite transfer result, namely, decidability consistency problem component DLs, need satisfied). However,
show method used show transfer result consistency problem
applies satisfiability problem.
2.1 expressive DLs
several possibilities extending ALC order obtain expressive DL.
three prominent adding additional concept constructors, adding role constructors, formulating restrictions role interpretations. addition giving examples
extensions, introduce naming scheme obtained DLs. Additional
concept constructors indicated appending caligraphic letters language name,
role constructors symbols superscript, restrictions roles letters subscript.
6

fiFusions Description Logics Abstract Description Systems

start introducing restrictions role interpretations, since need refer
restrictions defining certain concept constructors.
2.1.1 Restrictions role interpretations
restrictions enforce interpretations roles satisfy certain properties,
functionality, transitivity, etc. consider three prominent examples:
1. Functional roles. one considers subset NF set role names NR ,
whose elements called features. interpretation must map features f NF
functional binary relations f , i.e., relations satisfying a, b, c.f (a, b)
f (a, c) b = c. sometimes treat functional relations partial functions,
write f (a) = b rather f (a, b). ALC extended features denoted
ALC f .
2. Transitive roles. one considers subset NR+ NR . Role names R NR+
called transitive roles. interpretation must map transitive roles R NR+
transitive binary relations RI . ALC extended transitive roles
denoted ALC R+ .
3. Role hierarchies. role inclusion axiom expression form R v
R, NR . finite set H role inclusion axioms called role hierarchy.
interpretation must satisfy RI R v H. ALC extended role
hierarchy H denoted ALC H(H) . H clear context irrelevant,
write ALCH instead ALC H(H) .
restrictions combined other. example, ALC HR+ ALC
role hierarchy transitive roles.
Transitive roles DLs first investigated Sattler (1996). Features introduced DLs Hollunder Nutt (1990) (under name attributes)
CLASSIC system (Brachman et al., 1991), cases conjunction feature agreements disagreements (see concept constructors below). Features without agreements
disagreements are, e.g., used DL SHIF (Horrocks & Sattler, 1999), albeit
expressive local way, functionality asserted hold certain individuals, necessarily whole model. According naming scheme, indicate
presence features DL letter f subscript.1
remark role hierarchies order: definition, H1 H2 different
role hierarchies, ALC H(H1 ) ALC H(H2 ) different DLs. DL literature,
usually one logic ALCH defined role hierarchies treated TBoxes, i.e.,
satisfiability subsumption defined relative TBoxes role hierarchies (see, e.g.,
Horrocks, 1998). purposes, however, convenient define one DL per role
hierarchy since distinct role hierarchies impose distinct restrictions interpretation
roles. advantages approach become clear later frames abstract
description systems introduced.
1. Note authors (e.g., Horrocks & Sattler, 1999) use appended F denote local features.
Following Hollunder Nutt (1990), use F denote DL allows feature agreements
(see below).

7

fiBaader, Lutz, Sturm, & Wolter

Name
Unqualified
number restrictions
Qualified
number restrictions
Nominals
Feature agreement
disagreement

Syntax
nR
nR
nR.C
nR.C

u1 u2
u1 u2

Semantics
{a | |RI (a)| n}
{a | |RI (a)| n}
{a | |RI (a) C | n}
{a | |RI (a) C | n}
|I | = 1
{a | b . uI1 (a) = b = uI2 (a)}
{a | b1 , b2 .
uI1 (a) = b1 6= b2 = uI2 (b1 )}

Symbol
N
Q

F

Figure 1: description logic concept constructors.
2.1.2 Concept constructors
Concept constructors take concept and/or role descriptions transform
complex concept descriptions. addition constructors available ALC, various
concept constructors considered DL literature. small collection
constructors found Figure 1, |S| denotes cardinality set S.
symbols rightmost column indicate naming scheme resulting DL.
mentioned name modifiers concept constructors written subscript,
appended language name. example, ALC HR+ extended qualified
number restrictions called ALCQHR+ . syntax extended DLs expected, i.e.,
constructors may arbitrarily combined. semantics obtained augmenting
semantics ALC appropriate conditions, found third
column Figure 1. Nominals feature (dis)agreements need explanation:
Nominals. consider set (names for) nominals, pairwise disjoint
sets NC , NR , NI . Elements often denoted (possibly
index). interpretation must map nominals singleton subsets .
intention underlying nominals stand elements , individual
names. However, since want use nominal (nullary) concept
constructor, must interpret set, namely singleton set consisting
individual denotes.
Feature (dis)agreements. ALCF extension ALC f feature agreements
disagreements. Beside additional concept constructors, ALCF uses feature
chains part (dis)agreement constructor. feature chain expression
form u = f1 fn . interpretation uI feature chain
composition partial functions f1I , . . . , fnI , composition read
left right.
DLs including nominals feature (dis)agreements additional concept constructors
restrictions role interpretations defined (and named) obvious way.
Number restriction available almost DL systems. DL ALCN (i.e., ALC
extended number restrictions) first treated Hollunder Nutt (1990),
ALCF. DL ALCQ first investigated Hollunder Baader (1991), ALCO
Schaerf (1994).
8

fiFusions Description Logics Abstract Description Systems

Name
Role composition

Syntax
R1 R2

Semantics
{(a, b) |
c . (a, c) R1I (c, b) R2I }
Role complement R
{(a, b) | (a, b)
/ RI }
Role conjunction
R1 u R2 {(a, b) | (a, b) R1I (a, b) R2I }
Role disjunction
R1 R2 {(a, b) | (a, b) R1I (a, b) R2I }
Inverse roles
R1
{(a, b) | (b, a) RI }
Transitive closure R+
{(a, b) | (a, b) (RI )+ }
Universal role
U

binary relation R, R+ denotes transitive closure R.

Symbol


u

1
+
U

Figure 2: description logic role constructors.
2.1.3 Role constructors
Role constructors allow us build complex role descriptions. collection role constructors found Figure 2. Again, rightmost column indicates naming scheme,
name modifiers role constructors written superscript separated
commas. example, ALCQ inverse roles transitive closure called ALCQ+,1 .
DLs admitting role constructors, set role descriptions defined inductively, analogously set concept descriptions. semantics role constructors given
third column Figure 2. concept descriptions, used extend
interpretation function role names role descriptions.
DL role constructors, role descriptions used wherever role names may
used corresponding DLs without role constructors. example,
(R1 u R3 ).C u (R2 R2 ).C
,u,t

ALC
-concept description. concept description unsatisfiable since R2 R2
equivalent universal role. Note role descriptions used within role
assertions ABox.
DL ALC ,t,+ first treated Baader (1991) (under name ALC trans ); Schild
(1991) shown DL notational variant propositional dynamic logic (PDL).
DLs Boolean operators roles investigated Lutz Sattler (2000).
inverse operator available system CRACK (Bresciani, Franconi, & Tessaris,
1995), reasoning DLs inverse roles was, example, investigated Calvanese
et al. (1998) Horrocks et al. (2000). universal role expressed using DLs
Boolean operators roles (see example), turn used simulate
general concept inclusion axioms within concept descriptions.
2.2 Restricting syntax
now, constructors could combined arbitrarily. Sometimes makes sense restrict
interaction constructors since reasoning restricted DL may easier
reasoning unrestricted DL. consider DLs imposing certain restrictions

9

fiBaader, Lutz, Sturm, & Wolter

1. roles may used inside certain concept constructors,
2. roles may used inside certain role constructors,
3. combination role constructors,
4. role constructors may used inside certain concept constructors.
example first case, consider fragment ALCQR+ transitive roles
may used existential universal restrictions, number restrictions (see,
e.g., Horrocks et al., 2000).
result taking fusion two DLs, obtain DLs whose set roles NR
partitioned. example, fusion ALCQ ALC 1 yields fragment ALCQ1
NR partitioned two sets, say NR1 NR2 . fragment, inverse role
constructor roles NR2 may used within qualified number restrictions,
roles NR1 may used inside inverse role constructor.2 Thus, DL
example first, second, fourth case.
consider DL ALCF introduced above, extend ALC f
feature (dis)agreement concept constructor, provides role composition constructor. However, role chains built using composition comprised exclusively
features non-functional roles may appear inside feature (dis)agreement. Hence,
ALCF example first, second, fourth case.
example third case, fragment ALC ,u role conjunction
may used inside role complement constructor considered Lutz Sattler
(2000).
restricted DLs, introduce explicit naming scheme. Note that,
paper, deal DLs combinability concept constructors
restricted since DLs would fit framework abstract
description systems introduced next section. example DL would
one atomic negation concepts, i.e., negation may applied concept
names (e.g., DL AL discussed Donini et al., 1997).

3. Abstract description systems
order define fusion DLs prove general results fusions DLs, one needs
formal definition description logics. Since exists wide variety DLs
different characteristics, introduce general formalization,
cover DLs considered literature, includes logics would usually
subsumed name DL.
3.1 Syntax semantics
syntax abstract description system given abstract description language,
determines set terms, term assertions, object assertions. setting,
concept descriptions represented terms built using abstract description
2. become clearer given formal definition fusion.

10

fiFusions Description Logics Abstract Description Systems

language. General inclusion axioms DLs represented term assertions ABox
assertions DLs represented object assertions.
Definition 4 (Abstract description language). abstract description language (ADL)
determined countably infinite set V set variables, countably infinite set X
object variables, (possibly infinite) countable set R relation symbols arity two,3
(possibly infinite) countable set F functions symbols f , equipped arities
nf . sets pairwise disjoint.
terms tj ADL built using follow syntax rules:
tj

x, t1 , t1 t2 , t1 t2 , f (t1 , . . . , tnf ),

x V , f F, Boolean operators , , different function
symbols F. term t, denote var(t) set set variables used t.
symbol > used abbreviation x x abbreviation x x (where
x set variable).
term assertions ADL
t1 v t2 , terms t1 , t2 ,
object assertions
R(a, b), a, b X R R;
(a : t), X term.
sets term object assertions together form set assertions ADL.
DL point view, set variables correspond concept names, object
variables individual names, relation symbols roles, Boolean operators well
function symbols correspond concept constructors. Thus, terms correspond
concept descriptions. example, let us view concept descriptions DL ALCN u ,
i.e., ALC extended number restrictions conjunction roles, terms ADL.
Value restrictions existential restrictions seen unary function symbols:
role description R, function symbols fR fR , take term tC
(corresponding concept description C) transform complex terms
fR (tC ) fR (tC ) (corresponding concept descriptions R.C R.C). Similarly,
number restrictions seen nullary function symbols: role description R
n N, function symbols fnR fnR . Hence, ALCN u -concept
description u (R1 u R2 ).(B u ( 2R1 )) corresponds term xA f(R1 uR2 ) ((xB
f(2R1 ) )). analyze connection ADLs DLs formally later on.
semantics abstract description systems defined based abstract description
models. models general semantic structures terms ADL
interpreted. already noted here, however, abstract description
system usually take account abstract description models available
language: allows selected subclass models. subclass determines
semantics system.
3. keep things simpler, restrict attention case binary predicates, i.e., roles DL.
However, results easily extended n-ary predicates.

11

fiBaader, Lutz, Sturm, & Wolter

Definition 5. Let L ADL Definition 4. abstract description model (ADM)
L form

E
W = W, F W = {f W | f F}, RW = {RW | R R} ,



W nonempty set, f W functions mapping every sequence X1 , . . . , Xnf
subsets W subset W , RW binary relations W .
Since ADMs interpret variables, need assignment assigns subset
W set variable, evaluate terms ADM. evaluate object
assertions, need additional assignment assigns element W object
variable.



Definition 6. Let L ADL W = W, F W , RW ADM L. assignment
W pair = (A1 , A2 ) A1 mapping set set variables V
2W , A2 injective4 mapping set object variables X W . Let W
ADM = (A1 , A2 ) assignment W. L-term t, inductively
associate value tW,A 2W follows:
xW,A := A1 (x) variables x V ,
t2W,A ,
, (t1 t2 )W,A := tW,A
tW,A
(t)W,A := W \ (t)W,A , (t1 t2 )W,A := tW,A
1
2
1
f (t1 , . . . , tnf )W,A := f W (tW,A
, . . . , tW,A
nf ).
1
x1 , . . . , xn set variables occurring t, often write tW (X1 , . . . , Xn )
shorthand tW,A , assignment xA
= Xi 1 n.
truth-relation |= hW, Ai assertions defined follows:
hW, Ai |= R(a, b) iff A2 (a)RW A2 (b),
hW, Ai |= : iff A2 (a) tW,A ,
.
tW,A
hW, Ai |= t1 v t2 iff tW,A
2
1
case say assertion satisfied hW, Ai. If, ADM W set
assertions , exists assignment W assertion satisfied
hW, Ai, W model .
two differences ADMs DL interpretations. First, DL interpretation, interpretation role names fixes interpretation function
symbols corresponding concept constructors involve roles (like value restrictions,
number restrictions, etc.). interpretation concept names corresponds assignment. Thus, DL model ADM together assignment, whereas ADM
alone corresponds called frame modal logics. Second, DL roles used
concept constructors may, course, occur role assertions. contrast, definition
ADMs per se enforce connection interpretation function
symbols interpretation relation symbols. connections can, however,
enforced restricting attention subclass possible ADMs ADL.
4. corresponds unique name assumption.

12

fiFusions Description Logics Abstract Description Systems

Definition 7. abstract description system (ADS) pair (L, M), L ADL
class ADMs L closed isomorphic copies.5
DL point view, choice class defines semantics
concept role constructors, allows us, e.g., incorporate restrictions role
interpretations. sense, ADS viewed determining (description) logic.
concrete, DL interpretation interpretation function symbols
determined interpretation role names. Thus one can, example, restrict
class models ADMs interpret certain role transitive relation
composition two roles. Another restriction realized choice
nominals (corresponding nullary function symbols) must interpreted
singleton sets.
Let us define reasoning problems abstract description systems. introduce
satisfiability sets assertions (with without term assertions), corresponds
consistency ABoxes (with without GCIs), satisfiability terms (with without
term assertions), corresponds satisfiability concept descriptions (with without
GCIs).
Definition 8. Given ADS (L, M), finite set assertions called satisfiable
(L, M) iff exists ADM W assignment W hW, Ai
satisfies assertions . term called satisfiable (L, M) iff {a : t} satisfiable
(L, M), arbitrary object variable.
satisfiability problem (L, M) concerned following question: given
finite set object assertions L, satisfiable (L, M).
relativized satisfiability problem (L, M) concerned following question: given finite set assertions L, satisfiable (L, M).
term satisfiability problem (L, M) concerned following question:
given term L, satisfiable (L, M).
relativized term satisfiability problem (L, M) concerned following
question: given term set term assertions L, {a : t} satisfiable
(L, M).
next section, define fusion two ADSs, show (relativized)
satisfiability decidable fusion (relativized) satisfiability component ADSs
decidable. transfer results hold, must restrict so-called local
ADSs.



Wp , RWp pairwise
Definition 9. Given family (Wp )pP
ADMs W
p = Wp , F

disjoint domains Wp , say W = W, F W , RW disjoint union (Wp )pP iff

W = pP Wp ,
5. Intuitively, means that, ADM W belongs M, ADMs differ w.r.t.
names elements domain W belong M.

13

fiBaader, Lutz, Sturm, & Wolter


f W (X1 , . . . , Xnf ) = pP f Wp (X1 Wp , . . . , Xnf Wp ) f F
X1 , . . . , Xnf W ,

RW = pP RWp R R.
ADS = (L, M) called local iff closed disjoint unions.
remainder section, first analyze connection ADSs DLs
detail, comment relationship modal logics.
3.2 Correspondence description logics
show DLs introduced Section 2 correspond ADSs. order this,
first need introduce frames, notion well-known modal logic. Let L one
DLs introduced Section 2.
Definition 10 (Frames). L-frame F pair (F , F ), F nonempty set,
called domain F, F interpretation function, maps
nominal singleton subset F F ,
role name R subset RF F F restrictions role
interpretations L satisfied. example, ALC R+ , R NR+ mapped
transitive binary relation.
interpretation function F inductively extended complex roles obvious
way, i.e., interpreting role constructors L according semantics given
Figure 2.
interpretation based frame F iff = F , RI = RF roles R NR ,
= F nominals .
frame viewed interpretation partial sense interpretation individual concept names fixed. Note (in contrast case
concept individual names) interpretation nominals already fixed frame.
reason that, interpret nominals frame,
treat set variables ADS side. would, however, variables
singleton sets may assigned. Since restriction possible
framework ADSs defined above, interpret nominals frame. consequence
correspond functions arity 0 ADS side.
Now, define abstract description system = (L, M) corresponding DL L.
straightforward translate syntax L abstract description language L.
Definition 11 (Corresponding ADL). Let L DL concept role constructors
well restrictions role interpretations introduced Section 2. corresponding
abstract description language L defined follows. every concept name L,
exists set variable xA L, every individual name L exists object
variable ai L. Let R set (possibly complex) role descriptions L. set
relation symbols L R, set function symbols L smallest set containing
1. every role description R R, unary function symbols fR fR ,
14

fiFusions Description Logics Abstract Description Systems

2. L provides unqualified number restrictions, then, every n N every role
description R R, function symbols fnR fnR arity 0,
3. L provides qualified number restrictions, then, every n N every role R R,
unary function symbols fnR
fnR
,


4. L provides nominals, then, every , function symbol arity 0,
5. L provides feature agreement disagreement, then, every pair feature chains
(u1 , u2 ), two function symbols fu1 u2 fu1 u2 arity 0.
L-concept description C, let tC denote representation C L-term,
defined obvious way: concept names translated set variables xA ,
concept constructors , u, mapped , , , respectively,
concept constructors translated corresponding function symbols. Obviously,
sets function relation symbols L may infinite.
example translation concept descriptions terms ADL already
given above: ALCN u -concept description u (R1 u R2 ).(B u ( 2R1 )) corresponds
term xA f(R1 uR2 ) ((xB f(2R1 ) )).
define set abstract description models corresponding DL L.
every L-frame, contains corresponding ADM.
Definition 12 (Corresponding
Let
F = (F , F ) frame. corresponding

ADM).

abstract description model W = W, F W , RW domain W := F . relation symbols
L role descriptions L, thus interpreted frame F.
relation symbol R R hence define RW := RF .
define F W , need define f W every nullary function symbol f L,
W
f (X) every unary function symbol f L every X . Let arbitrary
concept name. X F , let IX interpretation based F mapping
concept name X every concept name .6 define f W , make case
distinction according type f :
W (X) := (R.A)IX ,
1. fR

W (X) := (R.A)IX ,
fR

W := (nR)I , f W := (nR)I ,
2. fnR
nR
W (X) := (nR.A)IX , f W (X) := (nR.A)IX ,
3. fnR


nR

4. fIW := ,
5. fuW1 u2 = (u1 u2 )I , fuW1 u2 = (u1 u2 )I .
class ADMs thus obtained DL L obviously closed isomorphic copies since holds set L-frames (independently DL L
consider). Hence, tuple = (L, M) corresponding DL L indeed ADS.
example, let us view DL ALCN u ADS. ADL L corresponding
ALCN u already discussed. Thus, concentrate class ADMs induced
6. Taking empty set arbitrary.

15

fiBaader, Lutz, Sturm, & Wolter

frames ALCN u . Assume F frame, i.e., F consists
nonempty



domain interpretations RF role names R. ADM W = W, F W , RW induced
F defined follows. set W identical domain F. role description
yields relation symbol, interpreted W frame. example,
(R1 u R2 )W = R1F R2F . remains define interpretation function symbols.
illustrate two examples. First, consider (unary) function symbol f(R1 uR2 ) .
W
Given subset X W , function f(R
maps X
1 uR2 )
W
f(R
(X) := {w W | v X v (w, v) R1F R2F },
1 uR2 )

i.e., interpretation concept description (R1 u R2 ).A interpretations based
F interpreting X. Accordingly, value constant symbol f(2R) W
given interpretation ( 2R) interpretations based F.
easy show interpretation concept descriptions L coincides
interpretation corresponding terms = (L, M).



Lemma 13. Let F frame, W = W, F W , RW ADM corresponding F, =
(A1 , A2 ) assignment W, C concept description, let concept names
used C among A1 , . . . , Ak . interpretations based F AIi = A1 (xAi )
1 k,
C = tW,A
.
C
easy consequence lemma, close connection reasoning
DL L reasoning corresponding ADS. Given TBox ABox
DL L, define corresponding set S(T , A) assertions corresponding ADL
(L, M) obvious way, i.e., GCI C v yields term assertion tC v tD ,
role assertion R(i, j) yields object assertion R(ai , aj ), concept assertion
C(i) yields object assertion ai : tC .
Proposition 14. ABox consistent relative TBox L iff S(T , A)
satisfiable corresponding ADS.
treat non-relativized consistency explicitly since special case
relativized consistency TBox empty.
already mentioned above, transfer results require component ADSs
local. call DL L local iff ADS (L, M) corresponding L local. turns
DLs introduced Section 2 local.
Proposition 15. Let L one DLs introduced Section 2. Then, L local iff L
include following constructors: nominals, role complement, universal
role.
Proof. start direction, interesting since shows
ADSs corresponding DLs nominals, role complement, universal role
local. make case distinction according constructors L contains.
Nominals. Consider disjoint union W ADMs W1 W2 , assume
W1 W2 correspond frames DL nominals. definition
16

fiFusions Description Logics Abstract Description Systems

disjoint union, know W1 W2 = . nominal,
definition disjoint union implies fIW = fIW1 fIW2 . Since nominals
interpreted singleton sets W1 W2 , since domains W1 W2
disjoint, implies fIW set cardinality 2. Consequently, W cannot
correspond ADM induced frame DL nominals, since frames
interpret nominals singleton sets.
Universal role. Again, consider disjoint union W ADMs W1 W2 ,
assume W1 W2 correspond frames DL universal role. Let U
denote universal role, i.e., role name interpretation restricted
binary relation relating pair individuals domain. definition
disjoint union, U W = U W1 U W2 = W1 W1 W2 W2 6= W W .
Consequently, W cannot correspond ADM induced frame DL
universal role, since frame would interpret U W W .
Role complement. Again, consider disjoint union W ADMs W1 W2 ,
assume W1 W2 correspond frames DL role negation.
W
W
W
arbitrary role name R, R = R 1 R 2 = (W1 W1 \ RW1 ) (W2
W2 \ RW2 ) 6= (W1 W2 ) \ (RW1 RW2 ) = W \ RW .
remains prove direction. Assume L one DLs introduced
Section 2 allow nominals, role complements,
universal role.
Let

(Fp )pP family L-frames Fp = (Fp , Fp ) let Wp = Wp , F Wp , RWp
ADMs corresponding them. definition, Fp = Wp p P . Assume
domains (Wp )pP pairwise disjoint. must show disjoint union (Wp )pP
corresponds L-frame. purpose, define frame F = (F , F )
follows:
F :=



RF :=



pP

Fp

pP

RFp R NR .




Let W = W, F W , RW
ADM corresponding
F.WpBy Definition 12 (corW
responding ADM), W = pP Wp R = pP R
R NR .
induction structure complex roles, easy show holds
R R, i.e., complex role descriptions. example, consider role description


W
W
R1 R2 . induction, know R1W = pP R1 p R2W = pP R2 p . Since
sets (Wp )pP pairwise disjoint,
(R1 R2 )W = R1W R2W =

[

pP

Wp

R1



[

Wp

R2

pP

=

[

pP

Wp

R1

Wp

R2

=

[

(R1 R2 )Wp .

pP

Since RWp = RFp R R p P , obtain following fact:
() p P , Fp , role descriptions R R, following holds: RF (a) =
RFp (a); particular, RF (a) Fp .
17

fiBaader, Lutz, Sturm, & Wolter

remains show that, n 0, X1 , . . . , Xn W , function symbols f
arity n,
[
f W (X1 , . . . , Xn ) =
f Wp (X1 Wp , . . . , Xn Wp ).
pP

proved making case distinction according type f . treat two
cases exemplarily.

f = fu1 u2 . Since W = pP Wp sets Wp pairwise disjoint, fuW1 u2
disjoint union sets fuW1 u2 Wp p P . remains show fuW1 u2 Wp =
W

W

W

p
p
p
fu1 u
(p P ). definition fu1 u
, know fu1 u
iff Fp ,
2
2
2

F

F

F

F

u1 p (a) u2 p (a) defined, u1 p (a) = u2 p (a). (), case iff
Fp , uF1 (a) uF2 (a) defined uF1 (a) = uF2 (a), equivalent
fuW1 u2 Wp .

W (X)
f = fnR
. Since W = pP Wp sets Wp pairwise disjoint, fnR



W (X) W p P . remains show
disjoint union sets fnR
p

W

W

W (X) W = f p (X W ) (p P ). definition f p , know
fnR
p
p



nR
nR
W

p
fnR
(X Wp ) iff Fp |RFp (a) (X Wp )| n. (), case iff


W (X) W .
|RF (a) (X Wp )| n iff |RF (a) X| n, hence iff fnR
p




noted arguments similar ones used proof
direction show that, presence universal role role negation, function
symbols (e.g., fU ) may violate locality condition.
transfer results decidability developed paper apply fusions
local ADSs. Hence, direction proposition implies results
applicable fusions ADSs corresponding DLs incorporate nominals, role
complement, universal role.
3.3 Correspondence modal logics
paper concern fusions description logics modal logics. Nevertheless,
useful brief look relationship ADSs modal logic. Standard
modal languages regarded ADLs without relation symbols object variables
(just identify propositional formulas terms). Given ADL L, set L L-terms
called classical modal logic iff contains tautologies classical propositional logic
closed modus ponens, substitutions, regularity rule
x1 y1 , . . . , xnf ynf
f (x1 , . . . , xnf ) f (y1 , . . . , ynf )
function symbols f L. minimal classical modal logic language one
unary function symbol known logic E (see Chellas, 1980).
ADS (L, M) based L determines classical modal logic L taking valid
terms, i.e., defining
L iff tW,A = W W assignments W.
18

fiFusions Description Logics Abstract Description Systems

logic E determined ADS precisely one unary operator whose class
ADMs consists models. Chellas formulates completeness result (Theorem
9.8 Chellas, 1980) so-called minimal models (alias neighborhood-frames), are,
however, notational variant abstract description models one unary operator
(Dosen, 1988). classical modal logic L determined ADS decidable term
satisfiability problem, L decidable since L iff unsatisfiable.
classical modal logic L called normal iff additionally contains
f (x1 , . . . , xj1 , xj yj , xj+1 , . . . , xnf ) f (x1 , . . . , xj1 , xj , xj+1 , . . . , xnf )
f (x1 , . . . , xj1 , yj , xj+1 , . . . , xnf )

f (>, , . . . , ), f (, >, , . . . , ), . . . , f (, . . . , , >),
function symbols f j 1 j nf (Jonsson & Tarski, 1951; Jonsson &
Tarski, 1952; Goldblatt, 1989). definition normal modal logics assumes
formulas (terms) built using necessity (box) operators.7 work
necessity operators; corresponding possibility-operators definable putting
f 3 (x1 , . . . , xnf ) = f (x1 , . . . , xnf ).
minimal normal modal logic language one unary operator known K
(Chellas, 1980).
call function F : W n W normal iff 1 j n X1 , . . . , Xn , Yj W
F (X1 , . . . , Xj1 , Xj Yj , Xj+1 , . . . , Xn ) = F (X1 , . . . , Xj1 , Xj , Xj+1 , . . . , Xn )
F (X1 , . . . , Xj1 , Yj , Xj+1 , . . . , Xn ))

F (W, , . . . , ) = F (, W, , . . . , ) = = F (, . . . , , W ) = W.
Note unary function F normal iff F (W ) = W F (X ) = F (X) F (Y ),
X, W . function symbol f called normal ADS (L, M) iff functions
f W normal W M.
role R DL, function symbol fR normal corresponding
ADS. contrary, readily checked neither fnR
fnR
duals


3
3
fnR

f

normal.


nR
Obviously, ADS (L, M) determines normal modal logic iff function symbols
L normal (L, M). Completeness K respect Kripke semantics (Chellas,
1980) implies logic K determined ADS one unary operator whose
class ADMs consists models interpreting operator normal function.
7. Note authors define normal modal logics using possibility (diamond) operators, case
definitions duals introduced thus first sight look quite different.

19

fiBaader, Lutz, Sturm, & Wolter

4. Fusions abstract description systems
section, define fusion abstract description systems prove two transfer theorems decidability, one concerning satisfiability one concerning
relativized satisfiability.
Definition 16. fusion S1 S2 = (L1 L2 , M1 M2 ) two abstract description
systems S1 = (L1 , M1 ) S2 = (L2 , M2 )
disjoint sets function symbols F L1 G L2 ,
disjoint sets relation symbols R L1 Q L2 ,
sets set object variables
defined follows: L1 L2 ADL based
union F G function symbols L1 L2 ,
union R Q relation symbols L1 L2 ,
M1 M2 defined
E
E

E

{ W, F W G W , RW QW | W, F W , RW M1 W, G W , QW M2 }.
example, consider ADSs S1 S2 corresponding DLs ALCF
ALC +,,t introduced Section 2. concentrate function symbols provided
fusion. following, assume set role names employed ALCF
ALC +,,t disjoint.
ADS S1 based following function symbols: (i) unary functions symbol
fR fR every role name R ALCF, (ii) nullary functions symbols corresponding same-as constructor every pair chains functional roles
ALCF.
ADS S2 based following function symbols: (iii) unary functions symbol
fQ fQ every role description Q built role names ALC +,,t using
union, composition, transitive closure.
Since assumed set role names employed ALCF ALC +,,t disjoint,
sets function symbols disjoint. union sets provides us
symbols same-as constructor symbols value existential restrictions role descriptions involving union, composition, transitive closure.
However, role descriptions contain role names ALC +,,t , thus none
functional roles ALCF occurs descriptions. Thus, fusion ALCF
ALC +,,t yields strict fragment union ALCF +,,t .
4.1 Relativized satisfiability
prove transfer result decidability relativized satisfiability problem, show
yields corresponding transfer result relativized term satisfiability problem,
investigate transfer results extended ADSs correspond DLs
providing universal role.
20

fiFusions Description Logics Abstract Description Systems

4.1.1 transfer result
section concerned establishing following transfer theorem:
Theorem 17. Let S1 S2 local ADSs, suppose relativized satisfiability
problems S1 S2 decidable. relativized satisfiability problem S1 S2
decidable.
idea underlying proof theorem translate given set assertions
S1 S2 set assertions 1 S1 set assertions 2 S2
satisfiable S1 S2 iff 1 satisfiable S1 2 satisfiable S2 . first (naive)
idea obtain set (i = 1, 2) replace alien terms (i.e., subterms
starting function symbols belonging Si ) new set variables (the surrogate
variables introduced below). approach, satisfiability would fact imply
satisfiability sets , converse would true. difficulty arises
trying combine models 1 2 one . ensure two models
indeed combined, sets must contain additional assertions make sure
surrogate variables one model corresponding alien subterms
model interpreted compatible way. precise, (finitely many)
different ways adding assertions, one must try (if any) leads
satisfiable pair 1 2 .
proof Theorem 17, fix two local ADSs Si = (Li , Mi ), {1, 2},
L1 based set function symbols F relation symbols R, L2 based G
Q. Let L = L1 L2 = M1 M2 .
follows, use following notation: set assertions , denote
term() obj() set terms object names , respectively.
start explaining alien subterms set replaced new set
variables. L-term form h(t1 , . . . , tn ), h F G, reserve new variable
xt , called surrogate t. assume set surrogate variables
disjoint original sets variables. sketched above, idea underlying
introduction surrogate variables decision procedure S1 (S2 ) cannot deal
terms containing function symbols G (F). Thus, alien function symbols
must replaced applying procedure. precise, replace whole
alien subterm starting alien function symbol surrogate. example,
unary symbol f belongs F, unary symbol g belongs G, f (g(f (x)))
mixed L-term. obtain term L1 , replace subterm g(f (x)) surrogate,
yields f (xg(f (x)) ). Analogously, obtain term L2 , replace whole term
surrogate, yields xf (g(f (x))) . define replacement process
formally.
Definition 18. L-term without surrogate variables, denote sur1 (t) L1 -term
resulting occurrences terms g(t1 , . . . , tn ), g G, within
scope g 0 G replaced surrogate variable xg(t1 ,...,tn ) . set
terms, put sur1 () := {sur1 (t) | } define sur2 (t) well sur2 () accordingly.
Denote sub() set subterms terms , sub1 () variables
occurring well subterms alien terms (i.e., terms starting symbol
21

fiBaader, Lutz, Sturm, & Wolter

G) . formally, define
sub1 () := sub{t | xt var(sur1 ())} var().
Define sub2 () accordingly.
example, let f F unary g G binary. = f (g(x, f (g(x, y)))),
sur1 (t) = f (xg(x,f (g(x,y))) ). Note restriction within scope g 0 G
clarify top-most alien subterms replaced. term
example, sub1 ({t}) = {g(x, f (g(x, y))), f (g(x, y)), g(x, y), x, y}.
Note Boolean operators occurring terms shared function symbols
sense alien neither L1 L2 . Thus, sur1 (f (x)g(x, y)) = f (x)xg(x,y)
sur2 (f (x) g(x, y)) = xf (x) g(x, y).
course, replacing whole terms variables, information lost.
example, consider (inconsistent) assertion (R1 .((1 R2 )u(2 R2 )))(i) assume
R1 role one component fusion, R2 role component. Translated
abstract description language syntax, concept description R1 .((1 R2 ) u (2 R2 ))
yields term := fR1 (f(1 R2 ) f(2 R2 ) ), fR1 function symbol L1
two function symbols belong L2 . Now, sur1 (t) = fR1 (x y), x
surrogate f(1 R2 ) surrogate f(2 R2 ) . decision procedure
first ADS sees fR1 (x y), way know conjunction alien
subterms corresponding x unsatisfiable. fact, procedure x
arbitrary set variables, thus x satisfiable. avoid problem, introduce
so-called consistency set consisting types, type says relevant formula
whether formula negation supposed hold. sets 1 2
contain additional information basically ensures models satisfy
types. allow us merge models one .
Definition 19. Given finite set L-terms, define consistency set C()
C() := {tc | c }, type tc determined c defined
tc :=

^

{ | c}

^

{ | \ c}.

Given finite set assertions L, define subi () := subi (term()). abbreviate
C () := C(subi ()), {1, 2}.
example above,
sub1 (fR1 (f(1 R2 ) f(2 R2 ) ) = {f(1 R2 ) , f(2 R2 ) },
thus C 1 ({ai : fR1 (f(1 R2 ) f(2 R2 ) )}) consists 4 terms
f(1 R2 )
f(1 R2 )
f(1 R2 )
f(1 R2 )






f(2 R2 ) ,
f(2 R2 ) ,
f(2 R2 ) ,
f(2 R2 ) .
22

fiFusions Description Logics Abstract Description Systems

Given set terms , element tc consistency set C() indeed considered
type element e domain ADM w.r.t. . element e
belongs interpretations terms , complements
interpretations terms. Thus, c set terms e belongs,
e belongs interpretation tc belong interpretation
terms C(). case say e realizes type tc .
ready formulate theorem reduces relativized satisfiability
problem fusion two local ADSs relativized satisfiability component ADSs.
proof theorem found appendix.
Theorem 20. Let Si = (Li , Mi ), {1, 2}, two local ADSs L1 based
set function symbols F relation symbols R, L2 based G Q,
let L = L1 L2 = M1 M2 . finite set assertions L,
following equivalent:
1. satisfiable (L, M).
2. exist
(a) set C 1 (),
(b) every term object variable 6 obj(),
(c) every obj() term ta D,
union 1 following sets assertions L1 satisfiable
(L1 , M1 ):
W
(d) {at : sur1 (t) | D} {> v sur1 ( D)},
(e) {a : sur1 (ta ) | obj()},

(f ) {R(a, b) | R(a, b) , R R},
(g) {sur1 (t1 ) v sur1 (t2 ) | t1 v t2 } {a : sur1 (s) | (a : s) };
union 2 following sets assertions L2 satisfiable (L2 , M2 ):
W
(h) {at : sur2 (t) | D} {> v sur2 ( D)},
(i) {a : sur2 (ta ) | obj()},

(j) {Q(a, b) | Q(a, b) , Q Q}.
Intuitively, (2a) guesses set types (i.e., elements consistency set).
idea exactly types realized model (to constructed
showing (2 1) given showing (1 2)). Condition (2b) introduces
every type name object realizing type, (2c) guesses every object
variable occurring type D.
W Regarding (2d) (2h), one note set assertions {at : | D}{> v
D} states every type realized (i.e., object model
type) every object one types D. sets assertions (2d)
(2h) obtained set surrogation make digestible decision
procedures component logics.
23

fiBaader, Lutz, Sturm, & Wolter

assertions (2e) (2i) state (again surrogated versions) object
interpreting variable type ta . ensures that, models 1 2
(given showing (2 1)), objects interpreting type ta D.
Otherwise, models could combined common one .
sets (2f) (2j) obtained distributing relationship assertions
1 2 , depending relation symbol used assertion.
set (2g) contains (in surrogated version) term assertions form t1 v t2
membership assertions form : .
Condition 2 asymmetric two respects. First, guesses subset C 1 () rather
subset C 2 (). course arbitrary, could chosen index 2 instead
1 here. Second, set 2 neither contains assertions {sur2 (t1 ) v sur2 (t2 ) | t1 v
t2 } {a : sur2 (s) | (a : s) }. added assertions, theorem would
still true, would unnecessarily increase amount work done
combined decision procedure. fact, since assertions 1 2 enforce tight
coordination models 1 2 , fact membership assertions
term assertions satisfied models 1 implies satisfied
models 2 (see appendix details).
prove Theorem 17, must show Theorem 20 used construct
decision procedure relativized satisfiability S1 S2 decision procedures
component systems S1 S2 . given finite set assertions S1 S2 , set
C 1 () finite, thus finitely many sets (2a) choices types
object variables (2c). Consequently, enumerate check whether
one choices leads satisfiable sets 1 2 . definition sets
functions suri , assertions indeed assertions Li , thus satisfiability
algorithm (Li , Mi ) applied . proves Theorem 17.
Regarding complexity obtained decision procedure, costly step guessing
right set D. Since cardinality set sub1 () linear size ,
cardinality C 1 () exponential size (and element size quadratic
). Thus, doubly exponentially many different subsets chosen from. Since
cardinality chosen set may exponential size , size 1
2 may exponential (because big disjunction D). this,
following corollary follows.
Corollary 21. Let S1 S2 local ADSs, suppose relativized satisfiability
problems S1 S2 decidable ExpTime (PSpace). relativized satisfiability problem S1 S2 decidable 2ExpTime (ExpSpace).
p (n)

Proof. Assume size n. must consider 22 1 (for polynomial p1 )
p (n)
different sets (2a). set size 2p1 (n) thus 22 2 choices
(2c) (for polynomial p2 ). Overall, still leaves us doubly exponentially
many choices. assume relativized satisfiability problems S1 S2
decidable ExpTime. Since call procedures applied set assertions
p (n)
p (n)
exponential size, may take double exponential time, say 22 3 22 4 (for polynomials
p3 p4 ). Overall, thus time complexity
22

p1 (n)

22

p2 (n)

(22
24

p3 (n)

+ 22

p4 (n)

),

fiFusions Description Logics Abstract Description Systems

p(n)

clearly majorized 22
appropriate polynomial p. shows
membership 2ExpTime.
argument regarding space complexity similar. one must additionally
take account doubly exponentially many choices enumerated using
exponentially large counter.

4.1.2 relativized term satisfiability problem
statement Theorem 17 imply transfer result relativized term
satisfiability problem. problem decidability relativized term satisfiability
problem S1 S2 necessarily imply decidability relativized satisfiability
problem ADSs, thus prerequisite theorem apply satisfied.
However, consider statement Theorem 20, easy see theorem
yields transfer result relativized term satisfiability problem.
Corollary 22. Let S1 S2 local ADSs, suppose relativized term satisfiability problems S1 S2 decidable. relativized term satisfiability problem
S1 S2 decidable.
Proof. Consider satisfiability criterion Theorem 20. interested relativized term satisfiability, form {a : t} 0 , 0 set term
assertions. case, sets assertions 1 2 contain object assertions
involving relations. Now, assume form {a1 : t1 , . . . , : tn } 0i , 0i
set term assertions. Since two assertions form b : s1 , b : s2 equivalent
one assertion b : s1 s2 , may assume ai distinct other. Since Si
local, easy see following equivalent:
1. {a1 : t1 , . . . , : tn } 0i satisfiable Si .
2. {aj : tj } 0i satisfiable Si j = 1, . . . , n.
Since (1 2) trivial, enough show (2 1). Given models Wj Mi {aj :
tj } 0i (j = 1, . . . , n), disjoint union belongs Mi , clearly model
{a1 : t1 , . . . , : tn } 0i .
second condition checked applying term satisfiability test Si
n times.

4.1.3 Dealing universal role
stated (Proposition 15), ADSs corresponding DLs universal role
local, thus Theorem 17 cannot applied directly. Nevertheless, cases
theorem used obtain decidability result fusions DLs
universal role, provided provide universal role. (We comment
usefulness approach detail Section 5.4).
Definition 23. Given ADS = (L, M), denote U ADS obtained
1. extending L two function symbols fUS fUS ,
25

fiBaader, Lutz, Sturm, & Wolter




W
2. extending every ADM W = W, F W , RW unary functions fU

W ,
fU

W (X) = X = , f W (X) = W otherwise;
fU
US

W (X) = W X = W , f W (X) = otherwise.
fU
US


ADSs corresponding DL L, ADS U corresponds extension L
universal role, universal role used within value existential
restrictions.8 close connection relativized satisfiability problem
satisfiability problem U .
Proposition 24. local ADS, following conditions equivalent:
1. relativized (term) satisfiability problem decidable,
2. (term) satisfiability problem U decidable,
3. relativized (term) satisfiability problem U decidable.

Proof. restrict attention term satisfiability problem since equivalences
satisfiability problem proved similarly.
implication (3 2) trivial, (2 1) easy show. fact, satisfiable
relative term assertions {s1 v t1 , . . . , sn v tn } iff tfUS .((t1 s1 ). . .(tn sn ))
satisfiable U .
show (1 3), assume relativized term satisfiability problem
decidable. Let = (L, M) U = (LU , MU ). following, use fU
abbreviation fUS . Since replace equivalently term function symbol
fUS fU , may assume without loss generality fUS occur terms
LU .
Suppose set = {a : s} LU given, set term assertions.
want decide whether satisfiable model W MU . purpose, transform set assertions containing fU . idea underlying transformation
that, given model W MU , fU (t)W {W, }, depending whether tW = W
not. Consequently, replace fU (t) accordingly > , evaluation term
W change. However, satisfiability test model W (we
trying decide whether one exists), thus must guess right replacement.
term LU called U -term iff starts fU . set U -terms
occur (possibly subterms) denoted U . Set, inductively, function
8. Note necessary add universal role U set relation symbols since assertion
form U (a, b) trivially true. However, use universal role within (qualified) number
restrictions covered extension.

26

fiFusions Description Logics Abstract Description Systems

: U {, >} subterms terms :
x := x,
(t1 t2 ) := t1 t2 ,
(t1 t2 ) := t1 t2 ,
(t) := ,
(f (t1 , . . . , tn )) := f (t1 , . . . , tn ) f 6= fU arity n,
(fU (t)) := (fU (t)).
Thus, obtained replacing occurrences U -terms image
, i.e., >. Define, function ,
:= {t1 v t2 | t1 v t2 } {a : }
{> v | fU (t) U (fU (t)) = >}
{at : | fU (t) U (fU (t)) = },
mutually distinct new object variables. Note contain
function symbol fU , thus viewed set assertions S. addition, though
contains one membership assertion, contain assertions involving
relation symbols. Consequently, satisfiability checked using term
satisfiability test (see proof Corollary 22 above). Decidability relativized
term satisfiability problem U follows following claim:
Claim. satisfiable member MU iff exists mapping : U {, >}
satisfiable member M.

prove claim, firstff suppose satisfied assignment member
W = W, F W {fUW }, RW MU . Define setting (fU (t)) = > (fU (t))W,A =
W , (fU (t))
= otherwise.
Obviously, implies satisfied

W
W
assignment W, F , R , member M.
suppose satisfiable mapping . Take member W =

Conversely,

W
W

0
ffand assignment hW, Ai |= . Set W :=

W, F W , R W
W
W, F {fU }, R , prove, induction, terms occur :
()

0

tW ,A = (t )W,A .

critical case one = fU (s). First, assume (fU (s)) = (fU (s)) =
0
>. contains > v , thus W = (s )W,A = sW ,A , second identity
0
0
holds induction. However, sW ,A = W implies (fU (s))W ,A = W = >W,A . case
(fU (s)) = (fU (s)) = treated similarly. term assertion : ensures
(and thus induction s) interpreted whole domain. Consequently,
applying fU yields empty set.
Since hW, Ai |= , identity () implies hW0 , Ai |= . completes proof
claim, thus proposition.

normal modal logics, result stated proposition already shown
Goranko Passy (1992). proof technique used can, however, transfered
27

fiBaader, Lutz, Sturm, & Wolter

general situation since strongly depends normality modal
operators.
Using Proposition 24, obtain following corollary first transfer theorem.
Corollary 25. Let S1 , S2 local ADSs assume that, {1, 2}, relativized
(term) satisfiability problem Si decidable. relativized (term) satisfiability
problem S1U S2U decidable.
Proof. know Theorem 17 (Corollary 22) relativized (term) satisfiability
problem S1 S2 decidable. Hence, Proposition 24 yields relativized (term)
satisfiability problem (S1 S2 )U decidable. S1U S2U notational variant
(S1 S2 )U : function symbols fUS1 fUS2 replaced fUS1 S2 (and
analogously fUS1 S2 ) since three identical semantics.

4.2 Satisfiability
Note Theorem 17 yield transfer result unrelativized satisfiability
problem. course, relativized satisfiability problems S1 S2 decidable,
theorem implies satisfiability problem S1 S2 decidable (since
special case relativized satisfiability problem). However, able apply
theorem obtain decidability satisfiability problem fusion, component
ADSs must satisfy stronger requirement relativized satisfiability problemWis decidable. Indeed, set Theorem 20 contains term assertion (namely > v suri ( D))
even contain term assertions.
cases relativized satisfiability problem undecidable whereas
satisfiability problem still decidable. example, Theorem 17 cannot applied
fusion ALCF ALC +,,t since relativized satisfiability problem ALCF
already undecidable (Baader et al., 1993). However, satisfiability problem decidable
DLs.
4.2.1 Covering normal terms
formulate transfer result satisfiability problem, need introduce
additional notion, generalizes notion normal modal logic.
Definition 26 (Covering normal terms). Let (L, M) ADS f function
symbol L arity n. term tf (x) (with one variable x) covering normal term
f iff following holds W M:
tW
f (W ) = W
W
W
X, W , tW
f (X ) = tf (X) tf (Y ),

X, X1 , . . . , Yn W : X Xi = X Yi 1 n implies
W
W
W
tW
f (X) f (X1 , . . . , Xn ) = tf (X) f (Y1 , . . . , Yn ).

ADS (L, M) said covering normal terms iff one effectively determine
covering normal term tf every function symbol f L.
28

fiFusions Description Logics Abstract Description Systems

Intuitively, first two conditions state covering normal term behaves
value restriction (or box operator). Consider term fR (x), fR function
symbol corresponding value restriction constructor role R. fR (x)
obviously satisfies first two requirements covering normal terms. Note
second condition implies function induced tf monotonic, i.e., X implies
W
tW
f (X) tf (Y ). third condition specifies connection covering normal
term function symbol covers. respect elements tW
f (X), values
W
W
functions f (X1 , . . . , Xn ) f (Y1 , . . . , Yn ) agree provided arguments
agree X. easy see fR (x) covering normal term function symbols
corresponding value, existential, (qualified) number restrictions role R
(see Proposition 35 below).
Given covering normal terms tf function symbols f finite set function
symbols E, one construct term tE covering normal term elements
E.
Lemma 27. Suppose ADS (L, M) covering normal terms L based set
function symbols F . Denote tf covering normal term function symbol f ,
f F . Then, every finite set E F function symbols, term
tE (x) :=

^

tf (x)

f E

covering normal term f E.
4.2.2 Correspondence normal modal logics
following result shows ADS every function symbol normal
covering normal terms. Hence, notion covering normal terms generalizes notion
normality modal logics.
Proposition 28. Let (L, M) ADS, assume f normal function symbol
(L, M).
tf (x) := f (x, , . . . , ) f (, x, . . . , ) f (, . . . , , x)
covering normal term f . particular, f nullary (unary), tf (x) = >
(tf (x) = f (x)) covering normal term f .
Proof. first two conditions definition covering normal terms immediately
follow definition normal function symbols. Thus, concentrate third
condition. Assume, simplicity, f binary. Suppose W X, X1 , X2 , Y1 , Y2
W X Xi = X Yi = 1, 2, set F := f W . F (X X1 , X X2 ) =
F (X Y1 , X Y2 ). Since F normal, know
F (X X1 , X X2 ) = F (X, X) F (X, X2 ) F (X1 , X) F (X1 , X2 ),
F (X Y1 , X Y2 ) = F (X, X) F (X, Y2 ) F (Y1 , X) F (Y1 , Y2 ),
29

fiBaader, Lutz, Sturm, & Wolter

thus
F (X, X) F (X, X2 ) F (X1 , X) F (X1 , X2 ) =
F (X, X) F (X, Y2 ) F (Y1 , X) F (Y1 , Y2 ).
Since, normality F ,
F (X, X) F (X, X2 ) F (X1 , X) tW
f (X),
F (X, X) F (X, Y2 ) F (Y1 , X) tW
f (X),
W
implies tW
f (X) F (X1 , X2 ) = tf (X) F (Y1 , Y2 ).



4.2.3 transfer result
Using covering normal terms, formulate second transfer theorem,
concerned transfer decidability (non-relativized) satisfiability.
Theorem 29. Let S1 S2 local ADSs covering normal terms, suppose
satisfiability problems S1 S2 decidable. satisfiability problem
S1 S2 decidable.
proof Theorem 17, fix two local ADSs Si = (Li , Mi ), {1, 2},
L1 based set function symbols F relation symbols R, L2 based G
Q. Let L = L1 L2 = M1 M2 .
proof Theorem 29 follows general ideas proof Theorem 17.
are, however, notable differences way satisfiability S1 S2 reduced
satisfiability S1 S2 . Theorem 20 guess set types,
based set additional guesses, pair satisfiability problems 1 2
S1 S2 , respectively, generated. proof Theorem 29, need guess
D. Instead, compute right set. However, computation requires us solve
additional satisfiability problems fusion S1 S2 . Nevertheless, yields reduction
since alternation depth (i.e., number alternations function symbols S1
S2 ) decreases going input set additional mixed satisfiability
problems.
describe reduction detail, must introduce someWnew
notation. case relativized satisfiability, term assertions W
form > v suri ( D)
used assert elements theW domain belong suri ( D). Now, use
covering normal terms propagate suri ( D) terms certain depth.
set function symbols E, define E-depth dE (t) term inductively:
dE (xi ) = 0
dE (t) = dE (t)
dE (t1 t2 ) = dE (t1 t2 ) = max{dE (t1 ), dE (t2 )}
dE (f (t1 , . . . , tn )) = max{dE (t1 ), . . . , dE (tn )} + 1 f E
dE (f (t1 , . . . , tn )) = max{dE (t1 ), . . . , dE (tn )} f 6 E
30

fiFusions Description Logics Abstract Description Systems

finite set assertions,
dE () := max{dE (t) | term()}.
Put, term t(x) one variable x, t0 (x) := x, tm+1 (x) := t(tm (x)), t0 (x) := x,
tm+1 (x) := tm+1 (x) tm (x).
position formulate result reduces satisfiability fusion
two local ADSs covering normal terms satisfiability component ADSs.
Theorem 30. Let Si = (Li , Mi ), {1, 2}, two local ADSs covering normal
terms L1 based set function symbols F relation symbols R,
L2 based G Q, let L = L1 L2 = M1 M2 . Let finite set
object assertions L. Put := dF (), r := dG (), let c(x) (d(x)) covering
normal term function symbols F (G).
{1, 2}, denote set C () term satisfiable
(L, M). following three conditions equivalent:
1. satisfiable (L, M).
2. exist
every 1 object variable 6 obj()
every obj() term ta 1
union 1 following sets object assertions satisfiable
(L1 , M1 ):
W
{at : sur1 (t cm (sur1 ( 1 )) | 1 },
W
{a : sur1 (ta cm (sur1 ( 1 )) | obj()},
{R(a, b) | R(a, b) , R R},
{a : sur1 (s) | (a : s) };
union 2 following sets object assertions satisfiable (L2 , M2 ):
W
{at : sur2 (t dr (sur2 ( 1 )) | 1 },
W
{a : sur2 (ta dr (sur2 ( 1 )) | obj()},
{Q(a, b) | Q(a, b) , Q Q}.

3. condition (2) above, 1 replaced 2 .
sets theorem similarWto ones Theorem 20.
main difference
W term assertion > v suri ( D) longer there. Instead,
disjunction suri ( 1 ) directly inserted terms using covering normals
terms. already mentioned above, another difference set D,
guessed Theorem 20, replaced set 1 (2) 2 (3). Actually, guessing
set
W longer possible case. proof Theorem 30 need know
> v suri ( D) satisfiable Si (i.e., holds least one model Mi ).
way check effectively since algorithm relativized satisfiability
31

fiBaader, Lutz, Sturm, & Wolter

Si . Taking set ensures property satisfied (see proof appendix
details).
definition, set C () term satisfiable (L, M).
Recall term satisfiable iff {a : s} satisfiable (L, M) arbitrary
object variable a. Since elements C () still mixed terms (i.e., terms
fusion), computing set actually needs recursive call decision procedure
satisfiability (L, M). recursion well-founded since alternation depth decreases.
Definition 31. term L, denote a1 (s) a2 (s) 1-alternation
2-alternation depth s, respectively. say, a1 (s) length longest
sequence form (g1 , f2 , g3 , . . .)
g1 (. . . (f2 . . . (g3 . . .)))
gj G fj F appears s. 2-alternation depth a2 (s) defined exchanging
roles F G. Put a(s) := a1 (s) + a2 (s), call alternation depth.
finite set terms, a() maximum a(s) .
Thus, a1 (s) counts maximal number changes symbols first
second ADS, starting first symbol S2 (i.e., first symbol S2
counts change, even occur inside scope symbol S2 ).
2-alternation depth defined accordingly. alternation depth sums 1-
2-alternation depth.
Lemma 32. a(term()) > 0, a(C 1 ()) < a(term()) a(C 2 ()) < a(term()).
Proof. show that, a(term()) > 0, a(sub1 ()) < a(term())
a(sub2 ()) < a(term()), which, definition C , clearly implies lemma. First
note that, definition subi ,
ai (subj ()) ai (term()) i, j.

()

make case distinction follows:
1. a1 (term()) a2 (term()). want show a1 (sub2 ()) < a1 (term()),
since, (), implies a(sub2 ()) < a(term()). Assume contrary
a1 (sub2 ()) a1 (term()). () implies a1 (sub2 ()) = a1 (term()). Hence,
exists term sub2 () sequence (g1 , f2 , g3 , . . . ) function symbols
gi G, F length a1 (term()) g1 (. . . (f2 . . . (g3 . . .))) occurs s.
definition sub2 , implies existence term term() function
symbol f F f (. . . g1 (. . . (f2 . . . (g3 . . .)))) occurs t. Since length
(g1 , f2 , g3 , . . . ) a1 (term()), obviously yields a2 (term()) > a1 (term())
contradiction.
2. a1 (term()) a2 (term()). Similar previous case: exchange roles
a1 a2 , F G, sub1 sub2 .

32

fiFusions Description Logics Abstract Description Systems

prove Theorem 29, must show Theorem 30 used construct decision
procedure satisfiability S1 S2 decision procedures component
systems S1 S2 . Let us first consider problem computing sets 1 2 .
a((term()) = 0, consists Boolean combinations set variables.
case, C () consists set variables, , = 1, 2, computed using Boolean
reasoning. a(term()) > 0, Lemma 32 states {1, 2}
a(C ()) < a(term()). induction thus assume effectively
computed. Consequently, remains check Condition (i + 1) Theorem 30 {1, 2}.
Since finite, guess every object variable occurring type ta .
sets 1 2 obtained way indeed sets assertions L1 L2 , respectively.
Thus, satisfiability effectively checked using decision procedures S1
S2 . proves Theorem 29.
argument used shows Theorem 30 sufficient state
equivalence (1) (2) (as Theorem 20). fact, induction argument used
necessarily always apply computation 1 . cases, alternation
depth may decreases 1 , 2 . noted Theorem 20 could
formulated symmetric way. done since
necessary proving Theorem 17.
Regarding complexity combined decision procedure, must principle
consider complexity computing covering normal terms size terms.
examples DL, terms value restrictions, thus size
complexity computing linear. Here, assume polynomial bound both.
assumption, obtain complexity results case relativized
satisfiability. fact, complexity testing Condition (2) (3) Theorem 30 agrees
complexity testing Condition (2) Theorem 20: adds one exponential
complexity decision procedure single ADSs. order compute , need
exponentially many recursive calls procedure. Since recursion depth linear
size , end exponentially many tests Condition (2) (3).
Corollary 33. Let S1 S2 local ADSs covering normal terms, assume
covering normal terms computed polynomial time. satisfiability
problems S1 S2 decidable ExpTime (PSpace), satisfiability problem
S1 S2 decidable 2ExpTime (ExpSpace).
argument case relativized satisfiability, extend
transfer result term satisfiability.
Corollary 34. Let S1 S2 local ADSs covering normal terms, suppose
term satisfiability problems S1 S2 decidable. term satisfiability
problem S1 S2 decidable.

5. Fusions description logics
Given two DLs L1 L2 , fusion defined follows. translate
corresponding ADSs S1 S2 , build fusion S1 S2 . fusion L1 L2
L1 L2 DL corresponds S1 S2 . Since definition fusion
ADSs requires sets function symbols disjoint, must ensure ADSs
33

fiBaader, Lutz, Sturm, & Wolter

corresponding L1 L2 built disjoint sets function symbols. DLs
introduced Section 2, achieved assuming sets role names L1
L2 disjoint sets nominals L1 L2 disjoint. DL L1 L2
allows use concept role constructors DLs, restricted way.
Role descriptions either role descriptions L1 L2 . role descriptions
involving constructors names DLs. Concept descriptions may contain concept
constructors DLs; however, constructor Li may use role description
Li (i = 1, 2).
Let us illustrate restrictions two simple examples. fusion ALC + ALC 1
two DLs ALC + ALC 1 fragment ALC +,1 whose set role names
partitioned two sets NR1 NR2
transitive closure operator may applied names NR1 ;
inverse operator may applied names NR2 .
example, concept name, R NR1 Q NR2 , R+ .A u Q1 .A
concept description ALC + ALC 1 , R+ .A u R1 .A (Q1 )+ .A not.
Note that, although two source DLs disjoint sets role names, ALC + ALC 1
role names sets may used inside existential value restrictions since
concept constructors available DLs.
fusion ALCQ ALC R+ two DLs ALCQ ALC R+ fragment
ALCQR+ whose set role names NR (with transitive roles NR+ NR ) partitioned
two sets NR1 NR2 NR+ NR2 that, inside qualifying number restrictions,
role names NR1 may used. particular, means transitive roles
cannot occur within qualified number restrictions.
following, give examples illustrate usefulness transfer results
proved previous section. First, give example case satisfiability
relativized satisfiability. Subsequently, consider complex example
involving so-called concrete domains. Here, general transfer result used prove
decidability result recently proved designing specialized algorithm
fusion. Finally, give example demonstrates restriction
local ADSs really necessary.
5.1 Decidability transfer satisfiability
subsection, give example application Theorem 29
decidability result could obtained using Theorem 17.
Theorem 29 requires ADSs covering normal terms. is, however, satisfied
DLs yield local ADSs.
Proposition 35. Let L one DLs introduced Section 2, let corresponding
ADS = (L, M) local. covering normal terms, terms
computed linear time.
Proof. function symbols f L, term tf form fR (x) role
description R. semantics value restrictions implies terms form satisfy
34

fiFusions Description Logics Abstract Description Systems

first two properties Definition 26. completes proof function symbols
f arity 0 since third condition Definition 26 trivially satisfied. Thus,
nullary function symbols, fR (x) arbitrary role name R job.
remains show that, every unary function symbol f {fR , fR , fnR
, fnR
},


term fR (x) satisfies third property. immediate consequence
W (X) f W (Y ) = f W (X) f W (X )
fact that, function symbols f , fR
R
models W X, W .

following, consider two description logics ALCF ALC +,,t . Hollunder
Nutt (1990) show satisfiability ALCF-concept descriptions decidable.
true consistency ALCF-ABoxes (Lutz, 1999). Note, however, relativized
satisfiability ALCF-concept descriptions thus relativized ABox consistency
ALCF undecidable (Baader et al., 1993). ALC +,,t , decidability satisfiability
shown Baader (1991) Schild (1991).9 Decidability ABox consistency ALC +,,t
shown Chapter 7 (De Giacomo, 1995).
unrestricted combination ALCF +,,t two DLs undecidable. precise, satisfiability ALCF +,,t -concept descriptions (and thus consistency ALCF +,,t ABoxes) undecidable. follows undecidability relativized satisfiability
ALCF-concept descriptions fact role operators ALCF +,,t used
internalize TBoxes (Schild, 1991; Baader et al., 1993). contrast undecidability
ALCF +,,t , Theorem 29 immediately implies satisfiability concept descriptions
fusion ALCF ALC +,,t decidable.
Theorem 36. Satisfiability concept descriptions consistency ABoxes decidable
ALCF ALC +,,t , whereas satisfiability ALCF +,,t -concept descriptions already
undecidable.
Taking fusion thus yields decidable combination two DLs whose unrestricted
combination undecidable. price one pay fusion offers less expressivity unrestricted combination. concept f1 f2 u f1+ .C example
concept description ALCF +,,t allowed fusion ALCF ALC +,,t .
5.2 Decidability transfer relativized satisfiability
example application Corollary 22 (and thus Theorem 17), consider
DL ALC +,,u,t
. DL, satisfiability concept descriptions undecidable. However,
f
expressive fragment decidable relativized satisfiability problem obtained
building fusion two sublanguages ALC +,,t
ALC +,,t,u .
f
Theorem 37. Satisfiability ALC +,,u,t
-concept descriptions undecidable.
f
Undecidability shown reduction domino problem (Berger, 1966;
Knuth, 1973) (see, e.g., Baader & Sattler, 1999, undecidability proofs DLs using
reduction). main tasks solve reduction one express
grid one access points grid. One square grid expressed

N N

9. Note ALC +,,t notational variant test-free propositional dynamic logic (PDL) (Fischer &
Ladner, 1979).

35

fiBaader, Lutz, Sturm, & Wolter

description form (xyuyx).>, x, features. fact, description
expresses points belonging x x successor,
two successors coincide. Accessing point grid achieved
using role description (x y)+ .
Note undecidability result closely related known undecidability
IDPDL, i.e., deterministic propositional dynamic logic intersection (Harel, 1984).
However, undecidability proof IDPDL Harel (1984) uses test construct,
available ALC +,,u,t
.
f
Next, show relativized satisfiability two rather expressive sublanguages
ALC +,,u,t
decidable.
f
Theorem 38. Relativized satisfiability concept descriptions decidable ALC f+,,t
ALC +,,t,u .
Proof sketch. cases, TBoxes internalized described Schild (1991)
Baader et al. (1993). Thus, sufficient show decidability (unrelativized)
satisfiability.
, follows decidability DPDL (Ben-Ari, Halpern, & Pnueli,
ALC +,,t
f
1982), known correspondence PDL ALC +,,t (Schild, 1991), fact
non-functional roles simulated functional ones presence composition
transitive closure (Parikh, 1980).
ALC +,,t,u , decidability satisfiability follows decidability IPDL, i.e., PDL
intersection (Danecki, 1984).

Given theorem, Corollary 22 yields following decidability result.
Corollary 39. Relativized satisfiability concept descriptions decidable fusion
ALC f+,,t ALC +,,t,u .
5.3 concrete example
Description logics concrete domains introduced Baader Hanschke (1991)
order allow reference concrete objects numbers, time intervals, spatial
regions, etc. defining concepts. precise, Baader Hanschke (1991)
define extension ALC(D) ALC, concrete domain (see below).
suitable assumptions D, show satisfiability ALC(D) decidable. One
main problems extension DLs relativized satisfiability (and satisfiability DLs TBoxes internalized) usually undecidable (Baader & Hanschke,
1992) (though exceptions, see Lutz, 2001). reason, Haarslev et al. (2001)
introduce restricted way extending DLs concrete domains, show corresponding extension ALCN HR+ decidable relativized satisfiability problem.10
following, show result obtained easy consequence
10. precise, even show relativized ABox consistency decidable restricted
extension ALCN HR+ concrete domains. Here, restrict ourself satisfiability concepts
since ABoxes introduced Haarslev et al. (2001) allow use concrete individuals
predicate assertions individuals, covered object assertions ADSs
introduced present paper.

36

fiFusions Description Logics Abstract Description Systems

Theorem 17. Moreover, ALCN HR+ replaced arbitrary local DL
decidable relativized satisfiability problem.
Definition 40 (Concrete Domain). concrete domain pair (D , ),
nonempty set called domain, set predicate names. predicate
name P associated arity n n-ary predicate P nD . concrete
domain called admissible iff (1) set predicate names closed negation
contains name >D , (2) satisfiability problem finite conjunctions
predicates decidable.
Given concrete domain one predicates P (of arity n), one
define new concept constructor f1 , . . . , fn .P (predicate restriction), f1 , . . . , fn
concrete features.11 contrast abstract features considered now, concrete
features interpreted partial functions abstract domain concrete
domain . consider basic DL allows Boolean operators new
concept constructors only.
Definition 41 (B(D)). Let NC set concept names NFc set names
concrete features disjoint NC , let admissible concrete domain. Concepts
descriptions B(D) Boolean combinations concept names predicate restrictions, i.e., expressions form f1 , . . . , fn .P P n-ary predicate
f1 , . . . , fn NFc .
semantics B(D) defined follows. consider interpretation I,
nonempty domain , interprets concept names subsets concrete
features partial functions . Boolean operators interpreted
usual,
(f1 , . . . , fn .P )I = {a | x1 , . . . , xn .
fiI (a) = xi 1 n (x1 , . . . , xn ) P }.
Note concept descriptions interpreted subsets .
Thus, go ADS corresponding B(D), concrete domain explicit
part corresponding ADMs. used define interpretation function
symbols corresponding predicate restrictions. predicate restriction constructor
translated function symbol ff1 ,...,fn .P arity 0, and, ADM W corresponding
W
frame F,
defined (f1 , . . . , fn .P )I , interpretation based
1 ,...,fn .P
F maps concept names empty set.
Theorem 42. Let admissible concrete domain. Then, B(D) local
relativized satisfiability problem B(D)-concept descriptions decidable.
Proof. Given family (Wi )iI ADMs Wi corresponding frames pairwise
disjoint
domains (i I), first build union F frames: domain F

F
interprets concrete features obvious way, i.e., f F (x) := f (x)
iI
11. Note general framework introduced Baader Hanschke (1991) allows feature chains
predicate restrictions. Considering feature chains length one main restriction introduced
Haarslev et al. (2001).

37

fiBaader, Lutz, Sturm, & Wolter

x . Let W ADM induced F. ToSprove W fact disjoint union
Wi
W
(Wi )iI , remains show
= iI
. easy consequence
1 ,...,fn .P
1 ,...,fn .P
semantics predicate restriction constructor, interpretation concrete
features F, fact domains pairwise disjoint.
Decidability unrelativized satisfiability problem immediate consequence
decidability results ALC(D) given Baader Hanschke (1991). Since B(D)
simple DL contain concept constructors requiring generation
abstract individuals, easy see B(D)-concept description C0 satisfiable relative
TBox C1 v D1 , . . . , Cn v Dn iff satisfiable one-element interpretation.
TBox internalized simple way: C0 satisfiable relative
TBox C1 v D1 , . . . , Cn v Dn iff C0 u (C1 D1 ) u . . . u (Cn Dn ) satisfiable.

Given theorem, Corollary 22 yields following transfer result, shows
concrete domains restricted form predicate restrictions introduced
integrated local DL decidable relativized satisfiability problem without
losing decidability.
Corollary 43. Let admissible concrete domain L local DL
relativized satisfiability concept descriptions decidable. Then, relativized satisfiability
concept descriptions B(D) L decidable.
5.4 Non-local DLs
Proposition 15, DLs allowing nominals, universal role, role negation
local. follows decidability transfer theorems applicable fusions
DLs. following, try clarify reasons restricted applicability
theorems.
First, show DLs decidable satisfiability problem
fusion undecidable satisfiability problem. culprit case universal
role (or role negation).
Theorem 44. Satisfiability concept descriptions decidable ALC U ALCF,
undecidable fusion ALC U ALCF.
Proof. Decidability ALCF shown Hollunder Nutt (1990) ALC U
Baader et al. (1990) Goranko Passy (1992). Undecidability ALC U ALCF
(which identical ALCF U ) follows results Baader et al. (1993) fact
universal role used simulate TBoxes (see Proposition 24).

Note role negation used simulate universal role: replace U.C
R.C u R.C U.C R.C R.C. addition, decidability ALC known
decidable (Lutz & Sattler, 2000). Consequently, theorem holds replace
ALC U ALC .
noted example given theorem depends fact
one two DLs allows universal role becomes undecidable
universal role added. fact, Corollary 25 shows decidability transfer
DLs already provide universal role.
38

fiFusions Description Logics Abstract Description Systems

Concerning nominals, counterexample transfer decidability
presence. However, think unlikely general
transfer result case. fact, note DL L without nominals introduced
Section 2, fusion ALCO identical L extended nominals. Since (relativized)
satisfiability ALCO decidable, general transfer result case would imply
extension decidable provided L decidable. Consequently, would yield
general transfer result adding nominals.

6. Conclusion
Regarding related work, work closely related one presented
(Wolter, 1998). There, analogs Theorems 20 30 proved normal modal
logics within algebraic framework. present results extend ones Wolter
(1998) two directions. First, added object assertions, thus prove
transfer results ABox reasoning. Second, show transfer results satisfiability
non-normal modal logics long covering normal terms. allows us handle
non-normal concept constructors qualified number restrictions (graded modalities)
framework.
think introduction abstract description systems (ADSs) contribution right. ADSs abstract internal structure concept constructors
thus allow us treat vast range constructors uniform way. Nevertheless, model theoretic semantics provided ADSs less abstract algebraic
semantics employed Wolter (1998). closer usual semantics DLs, thus
easier comprehend people used semantics. results paper show
ADSs fact yield good level abstraction proving general results description logics. Recently, notion used proving general results
so-called E-connections representation formalisms description logics, modal spatial
logics, temporal logics (Kutz, Wolter, & Zakharyaschev, 2001). contrast fusions,
E-connection two domains merged connected means relations.
Regarding complexity, transfer results yield upper bounds. Basically,
show complexity algorithm fusion one exponent higher
ones components. believe complexity satisfiability
fusion ADSs indeed exponentially higher complexity satisfiability
component ADSs. However, yet matching lower bounds, i.e., know
example exponential increase complexity really happens.
Note Spaans results (1993) transfer NP PSpace decidability
component modal logics fusion restricted normal modal logics,
make additional assumptions algorithms used solve satisfiability problem
component logics. Nevertheless, many PSpace-complete description logics
easy see fusion PSpace-complete. sense, general techniques
reasoning fusion descriptions logics developed paper give rough
complexity estimate.

39

fiBaader, Lutz, Sturm, & Wolter

Appendix A. Proofs
appendix, give detailed proofs criteria (relativized) satisfiability
fusion local ADSs. Recall that, criteria, transfer theorems decidability
easily follow. deferred proofs theorems appendix since
rather technical.
A.1 Proof Theorem 20
prove theorem, need technical lemma. proof Theorem 20,
going merge models W1 M1 W2 M2 means bijective function b
domain W1 W1 onto domain W2 W2 way surrogates
suri (t), C 1 (), respected b sense
1

w sur1 (t)W1 ,A b(w) sur2 (t)W2 ,A

2

w W1 C 1 (). existence bijection equivalent condi1
1
2
2
tion cardinalities |sur1 (t)W1 ,A | sur1 (t)W1 ,A |sur2 (t)W2 ,A | sur2 (t)W2 ,A
coincide C 1 (): 6= t0 t, t0 C 1 (), contains conjunct

(equivalent to) negation conjunct t0 ; hence, t, t0 , suri (t)Wi ,A

suri (t0 )Wi ,A = {1, 2}, clearly yields equivalence. following
lemma used choose models way cardinality condition satisfied.
(We refer reader to, e.g., Gratzer, 1979 information cardinals.)
Lemma 45. Let (L, M) local ADS set assertions satisfiable (L, M).

exists aff cardinal that, cardinals 0 , exists model


W = W, F W , RW |W | = 0 assignment hW, Ai |=
|sW,A | {0, 0 } terms s.



Proof. assumption, exists ADM W0 = W0 , F W0 , RW0 assignment B = hB1 , B2 hW0 , Bi |= . Let = max{0 , |W0 |}.
show
Let 0 . Take 0 disjoint isomorphic copies hW , B1 i,

isWas required.

W
W = W , F , R
, < 0 , ffof hW0 , B1 i. (The first member list coincides
W0 .) Let W = W, F W , RW disjoint union W , < 0 , define
hW, = hA1 , A2 ii putting A2 (a) = B2 (a), X ,
[
A1 (x) =
B1 (x),
<0

x V . Note object variables interpreted W0 . follows
definitions term semantics disjoint unions
[
sW,A =
sW ,B ,
()
<0

terms s. Hence |W | = 0 hW, Ai |= . remains show |sW,A | {0, 0 }
every term s. Suppose |sW,A | =
6 0. Then, (), 0 |sW,A | 0 = 0 , means
0
W,A
= |s
|.

40

fiFusions Description Logics Abstract Description Systems





noted above, disjointness sets suri (t)Wi ,A suri (t0 )Wi ,A (for 6= t0 )
required order ensure existence bijection b. precisely, order

merge models W1 , W2 , sets suri (t)Wi ,A member relevant subset C 1 ()
must form partition Wi domain satisfies certain cardinality condition.
formalized following definition:
Definition 46. Let cardinal. set {X1 , . . . , Xn } called -partition set W
iff
1. |Xi | = , 1 n,
2. Xi Xj = whenever 6= j,

3. W = 1in Xi .
{X1 , . . . , Xn } -partition ADM W domain W iff -partition W .
proof, enforce Properties 1 3 hold appropriate constructions,
Property 2 holds definition C 1 ().
proving Theorem 20, repeat formulation.
Theorem 20. Let Si = (Li , Mi ), {1, 2}, two local ADSs L1 based
set function symbols F relation symbols R, L2 based G Q,
let L = L1 L2 = M1 M2 . finite set assertions L,
following equivalent:
1. satisfiable (L, M).
2. exist
(a) set C 1 (),
(b) every term object variable 6 obj(),
(c) every obj() term ta D,
union 1 following sets assertions L1 satisfiable
(L1 , M1 ):
W
(d) {at : sur1 (t) | D} {> v sur1 ( D)},
(e) {a : sur1 (ta ) | obj()},

(f ) {R(a, b) | R(a, b) , R R},
(g) {sur1 (t1 ) v sur1 (t2 ) | t1 v t2 } {a : sur1 (s) | (a : s) };
union 2 following sets assertions L2 satisfiable (L2 , M2 ):
W
(h) {at : sur2 (t) | D} {> v sur2 ( D)},
(i) {a : sur2 (ta ) | obj()},

(j) {Q(a, b) | Q(a, b) , Q Q}.
41

fiBaader, Lutz, Sturm, & Wolter

sur1 (s1 )W1 ,A

b

1

b

W1 ,A1

sur1 (s2 )

sur2 (s1 )W2 ,A

2

sur2 (s2 )W2 ,A

2

.
.
.

.
.
.

sur1 (sk )W1 ,A

.
.
.

b

1

sur2 (sk )W2 ,A

W1

2

W2
Figure 3: mapping b.

Proof. start direction (2) (1). Take set C 1 () satisfying
properties listed theorem. Take

cardinals

i1, 1ffff{1, 2}
Lemma

245 2for
ffff
1
2
(Li , Mi ), put = max{
1 , 2 },
take W1 , = A1 , A2 W2 , = A1 , A2

Wi Mi Wi , Ai |= {1, 2}. Lemma 45, {1, 2}

assume |Wi | = and, |suri (s)Wi ,A | {0, } D.

sets {suri (s)Wi ,A : D}
-partitions
WiWfor {0, 1} since (i)


D, (as : suri (s)) , (ii) Wi , |= > v suri ( D), (iii) s, s0 6= s0


implies suri (s)Wi ,A suri (s0 )Wi ,A definition C 1 . Moreover, obj(1 ) = obj(2 )
1
2
and, obj(1 ) D, A12 (a) sur1 (s)W1 ,A iff A22 (a) sur2 (s)W2 ,A .
Together fact A12 A22 injective, implies existence
bijection b W1 onto W2
1

2

{b(w) : w sur1 (t)W1 ,A } = sur2 (t)W2 ,A ,
D,

b(A12 (a)) = A22 (a),

obj(1 ). Figure 3, assumed = {s1 , . . . , sk }, illustrates
mapping b.



Define model W = W, (F G)W , (R Q)W putting
W = W1 ,
f W = f W1 , f F,
g G arity n Z1 , . . . , Zn W ,
g W (Z1 , . . . , Zn ) = b1 (g W2 (b(Z1 ), . . . , b(Zn ))),
b(Z) = {b(z) : z Z},
RW = RW1 , R R,
QW (x, y) iff QW2 (b(x), b(y)), Q Q.
42

fiFusions Description Logics Abstract Description Systems

Since M2 closed isomorphic copies, hard see W M1 M2 . Let
= A1 . prove implication (2) (1) theorem remains show
hW, Ai |= . end suffices prove following claim:
Claim. terms sub1 (),
2

1

tW,A = sur1 (t)W1 ,A = b1 (sur2 (t)W2 ,A ).
prove claim, let us show implies hW, Ai |= . First note that,
claim, obtain
1
tW,A = sur1 (t)W1 ,A term().
(1)
may proved induction construction term() terms sub1 ()
using booleans function symbols L1 , only. basis induction (i.e.,
equality members sub1 ()) stated claim induction step straightforward.
show hW, Ai |= consequence (1). Suppose R(a, b) .
R(a, b) 1 thus hW, Ai |= R(a, b). Similarly, Q(a, b) implies Q(a, b) 2
1
hW, Ai |= Q(a, b). Suppose (a : t) . (a : sur1 (t)) 1 A12 (a) sur1 (t)W1 ,A
implies, (1), A12 (a) tW,A . Hence hW, Ai |= (a : t). t1 v t2 ,
sur1 (t1 ) v sur1 (t2 ) 1 so, (1), tW,A
tW,A
. Hence hW, Ai |= t1 v t2 .
1
2
come proof claim. proved induction structure t.
Due following equalities holding sub1 (), suffices show tW,A =
1
sur1 (t)W1 ,A .
sur1 (t)W1 ,A

1

1

=

[

{sur1 (s)W1 ,A : D, conjunct s}

=

[

{b1 (sur2 (s)W2 ,A ) : D, conjunct s}

2

2

= b1 (sur2 (t)W2 ,A )
W
1
first equality holds since sur1 ( D)W1 ,A = W1 and, D, either
conjunct s. second equality true definition b validity
thirdWequality seen analogously validity first one considering
2
sur2 ( D)W2 ,A = W2 .
1

Hence let us show tW,A = sur1 (t)W1 ,A . induction start, let variable.
1
equation tW,A = sur1 (t)W1 ,A immediate consequence fact = A1 .
induction step, distinguish several cases:

= t1 . induction hypothesis, tW,A
= sur1 (t1 )W1 ,A1 . Hence, tW,A = W \ tW,A
=
1
1
1
1
W
,A
W
,A
1
1
W \ sur1 (t1 )
= sur1 (t)
(since W = W1 ).
= t1 t2 . induction hypothesis, tW,A
= sur1 (ti )W1 ,A1 {1, 2}. Hence,

1
1
1
tW,A = tW,A
tW,A
= sur1 (t1 )W1 ,A sur1 (t2 )W1 ,A = sur1 (t)W1 ,A .
1
2
= t1 t2 . Similar case.
43

fiBaader, Lutz, Sturm, & Wolter

1

= f (t1 , . . . , tn ). induction hypothesis, tW,A
= sur1 (ti )W1 ,A 1 n. Hence,

1
1
1
W,A
W,A
tW,A = f W (t1 , . . . , tn ) = f W (sur1 (t1 )W1 ,A , . . . , sur1 (tn )W1 ,A ) = sur1 (t)W1 ,A
(since f W = f W1 ).
= g(t1 , . . . , tn ). case, tW,A = b1 (g W2 (b(tW,A
), . . . , b(tW,A
))). Since,
n
1
2
2
1
W
,A
1
W
,A
1
2
equalities, sur1 (t)
= b (sur2 (t)
), remains show sur2 (t)W2 ,A =
2
2
2
g W2 (b(tW,A
), . . . , b(tW,A
)). Since sur2 (t)W2 ,A = g W2 (sur2 (t1 )W2 ,A , . . . , sur2 (tn )W2 ,A ),
n
1
2
amounts showing b(tW,A
) = sur2 (ti )W2 ,A 1 n. This, however,

follows induction hypothesis together equations.
concludes proof direction (2) (1).
remains prove direction (1) (2). Suppose hW, Ai |= , W
= hA1 , A2 i. Put
= {s C 1 () : sW,A 6= }.
Note fusion local ADLs local ADL again. Hence (L, M) local may
assume, Lemma 45, sets sW,A infinite.
Take new object name 6 obj() every let, obj(),
^
^
ta = {t sub1 () : A2 (a) tW,A } {t : sub1 (), A2 (a) 6 tW,A }.
prove set assertions 1 based D, ta , obj(), , D, satisfiable
(L1 , M1 ).
W
Let F W denote restriction (F G)W
symbols F.
R
Similarly,

1

W
W
W
1
restriction (RQ) symbols R. Set W1 = W, F , R
M1 , = A1 , A12 ,

A11 = A1 {xt 7 tW,A : = g(t1 , . . . , tk ) sub1 ()},
A12 (a) = A2 (a), obj(), A12 (as ) sW,A , D. Note choose
injective function A12 sW,A infinite. show induction
sur1 (t)W1 ,A1 = tW,A term().

(2)

Let = x variable. x surrogate, A11 (x) = A1 (x). induction
step, distinguish several cases:
inductive steps = t1 , = t1 t2 , = t1 t2 , = f (t1 , . . . , tn ), f F,
identical corresponding cases proof Equation 1, occurs
direction (2) implies (1) above.
= g(t1 , . . . , tn ), g G. sur1 (t) = xt . Hence A11 (xt ) = tW,A
equation proved.






Equation 2,
obtain
W1 , A1 |= 1 : prove W1 , A1 |= R(a, b) whenever

R(a, b) 1 W1 , A1 |= sur1 (t1 ) v sur1 (t2 ) whenever sur1 (t1 ) v sur1 (t2 ) 1 .
remaining formulas 1 left

theffreader. Suppose R(a, b) 1 . R(a, b)
hW, Ai |= R(a, b). Hence W1 , A1 |= R(a, b). Suppose sur1 (t1 ) v sur1 (t2 ) 1 .
44

fiFusions Description Logics Abstract Description Systems

t2W,A . Equation 2,
t1 v t2 . Hence hW, Ai |= t1 v t2 means tW,A
1



1
1
sur1 (t1 )W1 ,A sur1 (t2 )W1 ,A means W1 , A1 |= sur1 (t1 ) v sur1 (t2 ).
construction model M2 satisfying 2 similar left reader.

A.2 Proof Theorem 30
proof Theorem 17, fix two local ADSs Si = (Li , Mi ), {1, 2},
L1 based set function symbols F relation symbols R, L2 based
G Q. Let L = L1 L2 = M1 M2 . assume S1 S2 covering
normal terms.
Similarly done previous section, merge models means
1
bijections map points sets sur1 (t)W1 ,A points corresponding sets
2
sur2 (t)W2 ,A . finite set object assertions L, let () denote set
C () term satisfiable (L, M) (for {1, 2}). ensure
merging models succeeds, must enforce elements 1 () 2 ()
form -partitions (for appropriate ) models merged. 1 (),
captured following lemma. Explicitly stating dual lemma 2 ()
omitted brevity.
Lemma 47. Let finite set object assertions L, cardinal satisfying
conditions Lemma 45 (L, M) , 1 = 1 (). 0 ,
1. exists model W M1 assignment
{sur1 (s)W,A | 1 }
0 -partition W;
2. exists model W M2 assignment
{sur2 (s)W,A | 1 }
0 -partition W.
Proof. 1. definition 1 , 1 , find model Ws
assignment sWs ,As 6= . Since fusion two local ADSs local,
set models closed disjoint unions. Hence, exists model W1
assignment A1 sW1 ,A1 6= 1 . follows set
1 := D{as : | 1 } satisfiable
E (L, M). Lemma 45, thus exists model
0
0
0
0
W
W
W = W , (F G) , (R Q)
assignment A0 W0 , A0 |= 1
0

0

{sW ,A | 1 } 0 -partition W 0 . let W denote restriction W0 L1
define
0
0
A1 = A01 {xt 7 tW ,A | = g(t1 , . . . , tk ) sub1 ()}.
0

0

hW, Ai required. prove note sur1 (t)W,A = tW ,A term().
2. similar left reader.

45

fiBaader, Lutz, Sturm, & Wolter

repeat formulation theorem proved.
Theorem 30. Let Si = (Li , Mi ), {1, 2}, two local ADSs covering normal
terms L1 based set function symbols F relation symbols R,
L2 based G Q, let L = L1 L2 = M1 M2 . Let finite set
object assertions L. Put := dF (), r := dG (), let c(x) (d(x)) covering
normal term function symbols F (G).
{1, 2}, denote set C () term satisfiable
(L, M). following three conditions equivalent:
1. satisfiable (L, M).
2. exist
every 1 object variable 6 obj()
every obj() term ta 1
union 1 following sets object assertions satisfiable
(L1 , M1 ):
W
{at : sur1 (t cm (sur1 ( 1 )) | 1 },
W
{a : sur1 (ta cm (sur1 ( 1 )) | obj()},
{R(a, b) | R(a, b) , R R},
{a : sur1 (s) | (a : s) };
union 2 following sets object assertions satisfiable (L2 , M2 ):
W
{at : sur2 (t dr (sur2 ( 1 )) | 1 },
W
{a : sur2 (ta dr (sur2 ( 1 )) | obj()},
{Q(a, b) | Q(a, b) , Q Q}.

3. condition (2) above, 1 replaced 2 .
start proof direction (1) (2) (1) (3). proofs
dual
onlyff give proof (1) (2). Suppose hW, Ai |= ,

other,
W
W = W, (F G) , (R Q)W . Lemma 45, assume that, every 1 ,
|tW,A | infinite. Take new object name 6 obj() every 1 let,
obj(),
^
^
ta = {t sub1 () : A2 (a) tW,A } {t : sub1 (), A2 (a) 6 tW,A }.
prove set 1 assertions based ta , obj(), , 1 , satisfiable
(L1 , M1 ) (the proof rather similar proof direction (1) (2)
proof Theorem 20). Let F W (resp. G W ) denote restriction (F G)W symbols
F (resp. G). Similarly, RW
QW theffrestrictions
(R Q)ffW symbols
R Q, respectively. Set W1 = W, F W , RW M1 , A1 = A11 , A12 ,
A11 = A1 {xt 7 tW,A | = g(t1 , . . . , tk ) sub1 ()},
46

fiFusions Description Logics Abstract Description Systems

A12 (a) = A2 (a), obj(), A12 (at ) tW,A , 1 (we choose injective
function A12 since sets tW,A infinite).
corresponding part proof Theorem 20, show induction
sur1 (t)W1 ,A1 = tW,A term().



Let us see W1 , A1 |= 1 follows
R(a, b) 1

equation.

1 |= R(a, b). hW, Ai |=
R(a,
b)




hW,
Ai
|=
R(a,
b).
Hence
W
,


1 1ff
W
W
( 1 ) = > (by definition


).
Hence
W1 , |= sur1 ( 1 ) = > so,
1



W
definition cm , W1 , A1 |= (cm (sur1 ( 1 ))) = >. remains observe
A12 (a) sur1 (ta )W1 ,A1 obj(), A12 (a) sur1 (s)W1 ,A1 whenever (a : s) ,
A12 (at ) sur1 (t)W1 ,A1 1 .
construction model M2 satisfying 2 similar left reader.
remains show implications (2) (1) (3) (1). similar,
concentrate first. proof Theorem 20 possible construct
required model merging models 1 2 . situation different here.
possible W
merge models 1
W 2 one step, since know whether
satisfy sur1 ( 1 ) = > sur2 ( 1 ) = >,
W respectively. know
W
satisfy approximations : sur1 (s) cm (sur1 ( 1 )) : sur2 (s) dr (sur2 ( 1 )),
respectively, : . merge models type distinguish various
pieces models add new pieces well. define pieces need
technical claim. proof Theorem 17, take cardinals , {1, 2} Lemma 45
(Li , Mi ) put = max{1 , 2 }.
Claim 1. Suppose (2) holds.



(a) exist W1 = W1 , F W , RW M1 , assignment = hA1 , A2 W1 ,
sequence X0 , . . . , Xm subsets W1
[a1] A2 (a) Xm , obj(1 ),
[a2] hW1 , Ai |= 1 ,
[a3] Xn+1 Xn cW1 (Xn ), 0 n < m,
[a4] set {sur1 (s)W1 ,A Xm : 1 } -partition Xm ,
[a5] sets
{sur1 (s)W1 ,A (Xn Xn+1 ) : 1 }
-partitions Xn Xn+1 , 0 n < m.
[a6] |W1 X0 | = .



(b) exist W2 = W2 , G W , QW M2 , assignment B = hB1 , B2 i, sequence
Y0 , . . . , Yr subsets W2
[b1] B2 (a) Yr , obj(1 ),
[b2] hW2 , Bi |= 2 ,
47

fiBaader, Lutz, Sturm, & Wolter

A1 = W1 X0
A0 = X 0 X 1

..
.

..
.

Am2 = Xm2 Xm1
Am1 = Xm1 Xm
Xm

W1
Figure 4: sets Xi .

[b3] Yn+1 Yn dW2 (Yn ), 0 n < r,
[b4] set {sur2 (s)M,A Yr : 1 } -partition Yr ,
[b5] sets
{sur2 (s)M,A (Yn Yn+1 ) : 1 }
-partitions Yn Yn+1 , 0 n < r.
[b6] |W2 Y0 | = .
Figure 4 illustrates relation sets Xi . (We set Ai = Xi Xi+1 0 <
A1 = W
W1 X0 .) Intuitively, Xm set points know points
W1 sur1 ( 1 )W1 ,A far away. Xm1 possibly less far away,
Xm2 possibly even less far, W
Xi , < 1. Finally, members A1
even known whether sur1 ( 1 )W1 ,A not. Note object names
interpreted Xm . come formal construction sets Xi .
Proof Claim 1. prove (a). Part (b) proved
andffleft reader.

similarly
W

assumption Lemma 45, find ADM Wa = Wa , F , RWa M1 |Wa | =
assignment Aa = hAa1 , Aa2 hWa , Aa |= 1 .
Let
_
Zn = (cn (sur1 ( 1 )))Wa ,Aa ,
0
n m. Lemma
47 (1) take every n 1 n ADM

Wn = Wn , F Wn , RWn M1 assignments
n

{sur1 (s)Wn ,A : 1 }
48

fiFusions Description Logics Abstract Description Systems

-partitions Wn .



Take disjoint union W (with W = W, F W , RW ) Wn , 1 n m, Wa .
Define = hA1 , A2 W putting
[
A1 (x) = Aa1 (x)
Ai1 (x),
1im

set variables x A2 (b) = Aa2 (b), object variables b. Let, 0 n m,
[
Xn = Zn
Wi .
nim

show hW, Ai sets Xn , 0 n m, required.
[a1] hWa , Aa |= 1 A2 (b) = Aa2 (b) Zm b obj(1 ). Hence
A2 (b) Xm = Zm Wm b obj(1 ).
[a2] definition disjoint unions hWa , Aa |= 1 .
[a3] Firstly, have, definition cn since cW monotone (it distributes
intersections),
Zn+1 Zn cW (Zn ) Xn cW (Xn ).
(3)
Secondly, definition disjoint unions, first property covering normal
terms, since cW monotone
[
[
[
[
Wi
Wi
Wi cW (
Wi ) Xn cW Xn .
(4)
n+1im

nim

nim

nim

(3) (4) obtain
Xn+1 = Zn+1

[

Wi Xn cW Xn .

(5)

n+1im

[a4] show three properties Definition 46 satisfied. Since
{sur1 (s)Wm ,Am : 1 }
-partition Wm , |sur1 (s)Wm ,Am | = 1 . implies
Property 1 since sur1 (s)W,A Wm = sur1 (s)Wm ,Am , Wm Xm , |Xm | .
Property 2 immediate consequence definition 1 . Property 3,
show that, w Xm , w sW,A 1 . Fix w Xm .
distinguish two cases: firstly, assume w Wm . Then, fact {sur1 (s)Wm ,Am :
1 } -partition Wm , clear
W exists 1 required.
(sur ( )))Wa ,Aa . definition cm t,
Secondly, assume
w

Z
=
(c

1
1
W
w (sur1 ( 1 ))Wa ,Aa w sur1 (s)W,A 1 .
[a5] proof similar Property [a4].
49

fiBaader, Lutz, Sturm, & Wolter

[a6] definition.
finishes proof Claim 1.
Suppose
E

E

W1 = W1 , F W1 , RW1 , A, Xm , . . . , X0 W2 = W2 , G W2 , QW2 , B, Yr , . . . , Y0
satisfying properties listed Claim 1. may assume
(W1 Xm ) (W2 Yr ) = .
Using appropriate bijection b Xm onto Yr may assume Xm = Yr ,
A2 (a) = B2 (a) object variables obj(1 ),
sur1 (s)W1 ,A Xm = sur2 (s)W2 ,B Xm 1 .

(6)

follows fact object variables mapped A2 B2 Xm
Yr ([a1], [b1]), respectively, injectivity mappings A2 B2 , conditions
[a4] [b4] state {sur1 (s)W1 ,A Xm : 1 } {sur2 (s)W2 ,B Yr : 1 }
form -partitions Xm = Yr . abbreviations useful: set
Ai = Xi Xi+1 , 0 < m,
Bi = Yi Yi+1 , 0 < r,
A1 = W1 X0 , B1 = W2 Y0 .
far merged Xm -part W1 Yr -part W2 . remains take care
sets Ai , 1 < m, Bi , 1 < r: sets Ai merged new
models Wi M2 sets Bi merged new models Vi M1 . Thus,
final model obtained merging disjoint union W1 Wi , 1 <
disjoint union W2 Vi , 1 < r. Figure 5 illustrates merging.
figure, assume 1 = {s1 , . . . , sk }.
course, merging Ai , 0, new model Wi respect partition
{sur1 (t)W1 ,A Ai | 1 }
Ai . merging Bi , 0, new model Vi respect partition
{sur1 (t)W1 ,B Bi | 1 }
Bi . Note A1 B1 partition
care
take
E of. proceed



W
W
formal construction. find models W = Ai , G , Q
M2 assignments

iff

B = B1 , B2 , 1 1, that, 0 1,




sur2 (s)W ,B = sur1 (s)W1 ,A Ai 1 .
follows [a5], [a6], Lemma 47 (2).
50

(7)

fiFusions Description Logics Abstract Description Systems

Xm Am1

...

A0 A1 Vr1

...

V0 V1

sur1 (s1 )

.
.
.

...

...

...
Wm1 . . .

...
...

sur1 (sk )

Yr

W0 W1 Br1

B0 B1

sur2 (s1 )

.
.
.

...

.. .

sur2 (sk )
Figure 5: bijection.


E


find, using [b5], [b6], Lemma 47 (1), models Vi = Bi , F V , RV M1



assignments Ai = Ai1 , Ai2 , 1 r 1, that, 0 r 1,




sur1 (s)V ,A = sur2 (s)W2 ,B Bi 1 .
Let

(8)


E
0
0
W01 = W1 (W2 Yr ), F W1 , RW1 M1

disjoint union Vi , 1 < r, W1 , let

E
0
0
W02 = W2 (W1 Xm ), G W2 , QW2 M2
disjoint union Wi , 1 < m, W2 . assume Xm = Yr
domain ADMs
W1 W2 .

Define model W = W, (F G)W , (R Q)W based W = W1 W2 putting
0

RW = RW1 ,
0

F W = F W1 ,
0

QW = QW2 ,
0

G W = G W2 .
51

fiBaader, Lutz, Sturm, & Wolter

Define assignment C = hC1 , C2 W putting
C2 (a) = A2 (a)(= B2 (a)), obj(1 ).

C1 (x) = A1 (x) 1i<r Ai1 (x), set variables x term().

Notice C1 (x) = B1 (x) 1i<m B1i (x), set variables x term().
C1 (xt ) = A1 (xt )



C1 (xt ) = B1 (xt )



1i<r

Ai1 (xt ), = g(t1 , . . . , tk ) sub1 ().


1i<m B1 (xt ),

= f (t1 , . . . , tk ) sub1 ().

show hW, Ci |= . Firstly, however, make list relevant properties
hW, Ci:
Claim 2.
[c1] C2 (a) Xm = Yr , obj();
[c2] hW, Ci |= 1 2 ;
[c3] sur1 (t)W,C (X0 Y0 ) = sur2 (t)W,C (X0 Y0 ), 1 ;
[c4] sur1 (s)W,C (X0 Y0 ) = sur2 (s)W,C (X0 Y0 ), sub1 ();
[c5] Xn+1 Xn cW (Xn ), 0 n < m;
[c6] Yn+1 Yn dW (Yn ), 0 n < r;
[c7] g G arity l, 0 n < m, C1 , . . . , Cl W :
g W (C1 , . . . , Cl ) Xn = g W (C1 Xn , . . . , Cl Xn ) Xn ;
[c8] f F arity l, 0 n < r, C1 , . . . , Cl W :
f W (C1 , . . . , Cl ) Yn = f W (C1 Yn , . . . , Cl Yn ) Yn .
Proof Claim 2. [c1] follows [a1] [b1] construction hW, Ci. [c2] follows
[a2] [b2]. [c3] follows construction hW, Ci equations (6), (7),
(8). [c4] follows [c3]. [c5] [c6] follow [a3]

[b3], ffrespectively. remains
prove [c7] [c8]. [c7] follows fact W, GW disjoint union
structures based Xn W Xn , 0 n < m, [c8] dual [c7]. Claim 2
proved.
show hW, Ci |= . end first show following:
Claim 3. k1 , k2 0 k1 0 k2 r sub1 () dF (s) k1
dG (s) k2 have, Z {Xk1 , Yk2 },
Z sM,C = Z sur1 (s)M,C = Z sur2 (s)M,C .
52

fiFusions Description Logics Abstract Description Systems

Proof Claim 3. [c4] suffices prove first equation. proof induction
cardinal k1 + k2 . induction base k1 = k2 = 0 follows sur1 (s) = sur2 (s)
dF (s) = dG (s) = 0.
Suppose claim proved Xk , Yk0 k m, k 0 r k + k 0 < k1 + k2 .
prove claim Xk1 , Yk2 . proof induction construction terms
dF (s) k1 dG (s) k2 . boolean cases trivial.
Suppose = f (s1 , . . . , sl ) dF (s) k1 dG (s) k2 . show
following two statements:
(i) Xk1 sW,C = Xk1 sur1 (s)M,C .
(ii) Yk2 sW,C = Yk2 sur1 (s)M,C .
Consider (i) first. induction hypothesis yields
Xk1 1 sW,C
= Xk1 1 sur1 (si )W,C

1 l.
Xk1 1 cW (Xk1 1 ) sW,C = Xk1 1 cW (Xk1 1 ) f W (s1W,C , . . . , slW,C )
= Xk1 1 cW (Xk1 1 ) f W (sur1 (s1 )W,C , . . . , sur1 (sl )W,C )
= Xk1 1 cW (Xk1 1 ) sur1 (s)W,C .
second equation immediate consequence third property covering normal
terms given Definition 26. equation follows [c5], i.e. Xk1 Xk1 1
cW (Xk1 1 ). (i) proved.
(ii) Suppose first k2 = r. Yk2 = Xm claim proved
since Xm Xk1 and, induction hypothesis, Xk1 1 sW,C
= Xk1 1 sur1 (si )W,C ,

1 l.
Assume k2 < r. induction hypothesis,
Yk2 sW,C
= Yk2 sur2 (si )W,C ,

1 l. Hence
, . . . , Yk2 sW,C
) = f W (Yk2 sur2 (s1 )W,C , . . . , Yk2 sur2 (sl )W,C ).
f W (Yk2 sW,C
1
l
intersect sides equation Yk2 derive help [c8]:
Yk2 f W (sW,C
, . . . , sW,C
) = Yk2 f W (sur2 (s1 )W,C , . . . , sur2 (sl )W,C ).
1
l
means Yk2 sW,C = Yk2 sur2 (s)W,C , equation follows. statements
proved.
case = g(s1 , . . . , sl ) dual left reader. proved claim 3.
induction (c.f. proof Theorem 20 proof (1) corresponding
claim), obtain Claim 3:
Xm sW,C = Xm sur1 (s)M,C term().
53

(9)

fiBaader, Lutz, Sturm, & Wolter

Let us see hW, Ai |= follows (9). distinguish three cases: Suppose R(a, b)
. R(a, b) 1 therefore hW, Ci |= R(a, b). Similarly, Q(a, b) implies
Q(a, b) 2 hW, Ci |= Q(a, b). Suppose (a : t) . (a : sur1 (t)) 1 so,
[c2], C2 (a) sur1 (t)W,C implies, (9), C2 (a) tW,C . Hence hW, Ci |= (a : t).
finishes proof Theorem 30.

References
Areces, C., Blackburn, P., & Marx, M. (2000). computational complexity hybrid
temporal logics. Logic Journal IGPL, 8 (5), 653679.
Baader, F. (1991). Augmenting concept languages transitive closure roles: alternative terminological cycles. Proc. 12th Int. Joint Conf. Artificial
Intelligence (IJCAI91).
Baader, F., Burckert, H.-J., Hollunder, B., Nutt, W., & Siekmann, J. H. (1990). Concept
logics. Lloyd, J. W. (Ed.), Computational Logics, Symposium Proceedings, pp.
177201. Springer-Verlag.
Baader, F., Burckert, H.-J., Nebel, B., Nutt, W., & Smolka, G. (1993). expressivity
feature logics negation, functional uncertainty, sort equations. J. Logic,
Language Information, 2, 118.
Baader, F., & Hanschke, P. (1991). schema integrating concrete domains concept
languages. Proc. 12th Int. Joint Conf. Artificial Intelligence (IJCAI91),
pp. 452457.
Baader, F., & Hanschke, P. (1992). Extensions concept languages mechanical engineering application. Proc. 16th German Workshop Artificial Intelligence
(GWAI92), Vol. 671 Lecture Notes Computer Science, pp. 132143, Bonn (Germany). Springer-Verlag.
Baader, F., & Hollunder, B. (1991). terminological knowledge representation system
complete inference algorithm. Proc. Workshop Processing Declarative
Knowledge (PDK91), Vol. 567 Lecture Notes Artificial Intelligence, pp. 6786.
Springer-Verlag.
Baader, F., & Sattler, U. (1999). Expressive number restrictions description logics. J.
Logic Computation, 9 (3), 319350.
Ben-Ari, M., Halpern, J. Y., & Pnueli, A. (1982). Deterministic propositional dynamic logic:
Finite models, complexity, completeness. J. Computer System Sciences,
25, 402417.
Berger, R. (1966). undecidability dominoe problem. Mem. Amer. Math. Soc.,
66, 172.
Borgida, A. (1995). Description logics data management. IEEE Trans. Knowledge
Data Engineering, 7 (5), 671682.
Brachman, R. J., McGuinness, D. L., Patel-Schneider, P. F., Alperin Resnick, L., & Borgida,
A. (1991). Living CLASSIC: use KL-ONE-like language.
54

fiFusions Description Logics Abstract Description Systems

Sowa, J. F. (Ed.), Principles Semantic Networks, pp. 401456. Morgan Kaufmann,
Los Altos.
Brachman, R. J., & Schmolze, J. G. (1985). overview KL-ONE knowledge representation system. Cognitive Science, 9 (2), 171216.
Bresciani, P., Franconi, E., & Tessaris, S. (1995). Implementing testing expressive description logics: Preliminary report. Proc. 1995 Description Logic Workshop
(DL95), pp. 131139.
Calvanese, D., De Giacomo, G., & Lenzerini, M. (1999). Reasoning expressive description
logics fixpoints based automata infinite trees. Proc. 16th Int.
Joint Conf. Artificial Intelligence (IJCAI99), pp. 8489.
Calvanese, D., De Giacomo, G., & Rosati, R. (1998). note encoding inverse roles
functional restrictions ALC knowledge bases. Proc. 1998 Description Logic
Workshop (DL98), pp. 6971. CEUR Electronic Workshop Proceedings, http://ceurws.org/Vol-11/.
Chellas, B. F. (1980). Modal logic. Cambridge University Press, Cambridge, UK.
Danecki, R. (1984). Nondeterministic Propositional Dynamic Logic intersection
decidable. Proc. 5th Symp. Computation Theory, Vol. 208 Lecture
Notes Computer Science, pp. 3453. Springer-Verlag.
De Giacomo, G. (1995). Decidability Class-Based Knowledge Representation Formalisms.
Ph.D. thesis, Dipartimento di Informatica e Sistemistica, Universita di Roma La
Sapienza.
De Giacomo, G., & Lenzerini, M. (1994a). Boosting correspondence description
logics propositional dynamic logics. Proc. 12th Nat. Conf. Artificial
Intelligence (AAAI94), pp. 205212. AAAI Press/The MIT Press.
De Giacomo, G., & Lenzerini, M. (1994b). Concept language number restrictions
fixpoints, relationship -calculus. Proc. 11th Eur. Conf.
Artificial Intelligence (ECAI94), pp. 411415.
De Giacomo, G., & Lenzerini, M. (1995). Whats aggregate: Foundations description logics tuples sets. Proc. 14th Int. Joint Conf. Artificial
Intelligence (IJCAI95), pp. 801807.
Donini, F. M., Hollunder, B., Lenzerini, M., Spaccamela, A. M., Nardi, D., & Nutt, W.
(1992). complexity existential quantification concept languages. Artificial
Intelligence, 23, 309327.
Donini, F. M., Lenzerini, M., Nardi, D., & Nutt, W. (1991). Tractable concept languages.
Proc. 12th Int. Joint Conf. Artificial Intelligence (IJCAI91), pp. 458463,
Sydney (Australia).
Donini, F. M., Lenzerini, M., Nardi, D., & Nutt, W. (1997). complexity concept
languages. Information Computation, 134, 158.
Donini, F. M., Lenzerini, M., Nardi, D., & Schaerf, A. (1994). Deduction concept languages: subsumption instance checking. J. Logic Computation, 4 (4),
423452.
55

fiBaader, Lutz, Sturm, & Wolter

Dosen, K. (1988). Duality modal algebras neighbourhood frames. Studia
Logica, 48, 219234.
Fine, K., & Schurz, G. (1996). Transfer theorems stratified modal logics. Copeland,
J. (Ed.), Logic Reality: Essays Pure Applied Logic. Memory Arthur
Prior, pp. 169213. Oxford University Press.
Fischer, M. J., & Ladner, R. E. (1979). Propositional dynamic logic regular programs.
J. Computer System Sciences, 18, 194211.
Gabbay, D. M. (1999). Fibring Logics, Vol. 38 Oxford Logic Guides. Clarendon Press,
Oxford.
Gargov, G., & Goranko, V. (1993). Modal logic names. J. Philosophical Logic, 22,
607636.
Goldblatt, R. I. (1989). Varieties complex algebras. Annals Pure Applied Logic,
38, 173241.
Goranko, V., & Passy, S. (1992). Using universal modality: Gains questions. Journal
Logic Computation, 2 (1), 530.
Gratzer, G. (1979). Universal Algebra. Springer-Verlag, New York.
Haarslev, V., Moller, R., & Wessel, M. (2001). description logic ALCN HR+ extended
concrete domains: practically motivated approach. Proceedings International Joint Conference Automated Reasoning IJCAR01, Lecture Notes
Artificial Intelligence. Springer-Verlag.
Harel, D. (1984). Dynamic logic. Handbook Philosophical Logic, Vol. 2, pp. 497640.
D. Reidel, Dordrecht (Holland).
Hollunder, B., & Baader, F. (1991). Qualifying number restrictions concept languages.
Tech. rep. RR-91-03, Deutsches Forschungszentrum fur Kunstliche Intelligenz (DFKI),
Kaiserslautern (Germany). abridged version appeared Proc. 2nd Int.
Conf. Principles Knowledge Representation Reasoning (KR91).
Hollunder, B., & Nutt, W. (1990). Subsumption algorithms concept languages. Tech. rep.
RR-90-04, Deutsches Forschungszentrum fur Kunstliche Intelligenz (DFKI), Kaiserslautern (Germany).
Horrocks, I. (1998). Using expressive description logic: FaCT fiction?. Proc.
6th Int. Conf. Principles Knowledge Representation Reasoning (KR98),
pp. 636647.
Horrocks, I., & Sattler, U. (1999). description logic transitive inverse roles
role hierarchies. J. Logic Computation, 9 (3), 385410.
Horrocks, I., Sattler, U., & Tobies, S. (2000). Practical reasoning expressive description logics. J. Interest Group Pure Applied Logic, 8 (3), 239264.
Jonsson, B., & Tarski, A. (1951). Boolean algebras operators. I. American Journal
Mathematics, 73, 891939.
Jonsson, B., & Tarski, A. (1952). Boolean algebras operators. II. American Journal
Mathematics, 74, 127162.
56

fiFusions Description Logics Abstract Description Systems

Knuth, D. E. (1973). Art Computer Programming, Vol. 3. Addison-Wesley, Mass.
Kracht, M., & Wolter, F. (1991). Properties independently axiomatizable bimodal logics.
Journal Symbolic Logic, 56 (4), 14691485.
Kutz, O., Wolter, F., & Zakharyaschev, M. (2001). Connecting abstract description systems.
Submitted. Available http://www.informatik.uni-leipzig.de/wolter/.
Levesque, H. J., & Brachman, R. J. (1987). Expressiveness tractability knowledge
representation reasoning. Computational Intelligence, 3, 7893.
Lutz, C. (1999). Reasoning concrete domains. Dean, T. (Ed.), Proc. 16th
Int. Joint Conf. Artificial Intelligence (IJCAI99), pp. 9095, Stockholm, Sweden.
Morgan Kaufmann, Los Altos.
Lutz, C. (2001). Interval-based temporal reasoning general TBoxes. Proc.
17th Int. Joint Conf. Artificial Intelligence (IJCAI 2001), pp. 8994.
Lutz, C., & Sattler, U. (2000). Mary likes cats. Proc. 2000 Description
Logic Workshop (DL 2000), pp. 213226. CEUR Electronic Workshop Proceedings,
http://ceur-ws.org/Vol-33/.
Nebel, B. (1988). Computational complexity terminological reasoning BACK. Artificial
Intelligence, 34 (3), 371383.
Nebel, B. (1990). Terminological reasoning inherently intractable. Artificial Intelligence,
43, 235249.
Parikh, R. (1980). Propositional logics programs: Systems, models complexity.
Proc. 7th ACM SIGACT-SIGPLAN Symp. Principles Programming Languages (POPL80), pp. 186192, Las Vegas (USA).
Prior, A. N. (1967). Past, Present Future. Oxford University Press.
Sattler, U. (1996). concept language extended different kinds transitive roles.
Gorz, G., & Holldobler, S. (Eds.), Proc. 20th German Annual Conf. Artificial
Intelligence (KI96), No. 1137 Lecture Notes Artificial Intelligence, pp. 333345.
Springer-Verlag.
Schaerf, A. (1993). complexity instance checking problem concept languages
existential quantification. J. Intelligent Information Systems, 2, 265278.
Schaerf, A. (1994). Reasoning individuals concept languages. Data Knowledge
Engineering, 13 (2), 141176.
Schild, K. (1991). correspondence theory terminological logics: Preliminary report.
Proc. 12th Int. Joint Conf. Artificial Intelligence (IJCAI91), pp. 466471.
Schmidt-Schau, M. (1989). Subsumption KL-ONE undecidable. Brachman, R. J.,
Levesque, H. J., & Reiter, R. (Eds.), Proc. 1st Int. Conf. Principles
Knowledge Representation Reasoning (KR89), pp. 421431. Morgan Kaufmann,
Los Altos.
Schmidt-Schau, M., & Smolka, G. (1991). Attributive concept descriptions complements. Artificial Intelligence, 48 (1), 126.
57

fiBaader, Lutz, Sturm, & Wolter

Spaan, E. (1993). Complexity Modal Logics. Ph.D. thesis, Department Mathematics
Computer Science, University Amsterdam, Netherlands.
Van der Hoek, W., & de Rijke, M. (1995). Counting objects. J. Logic Computation,
5 (3), 325345.
Wolter, F. (1998). Fusions modal logics revisited. Kracht, M., de Rijke, M., Wansing, H., & Zakharyaschev, M. (Eds.), Advances Modal Logic, pp. 361379. CSLI
Publications.
Woods, W. A., & Schmolze, J. G. (1992). KL-ONE family. Lehmann, F. W. (Ed.),
Semantic Networks Artificial Intelligence, pp. 133178. Pergamon Press. Published
special issue Computers & Mathematics Applications, Volume 23, Number
29.

58


