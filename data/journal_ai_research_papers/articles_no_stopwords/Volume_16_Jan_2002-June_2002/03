journal artificial intelligence

submitted published

improving eciency inductive logic programming
use query packs
hendrik blockeel cs kuleuven ac

hendrik blockeel

katholieke universiteit leuven department computer science
celestijnenlaan b leuven belgium

luc dehaspe pharmadm com

luc dehaspe
pharmadm ambachtenlaan b leuven belgium

bart demoen
gerda janssens
jan ramon

bart demoen cs kuleuven ac
gerda janssens cs kuleuven ac
jan ramon cs kuleuven ac

katholieke universiteit leuven department computer science
celestijnenlaan b leuven belgium

henk vandecasteele pharmadm com

henk vandecasteele

pharmadm ambachtenlaan b leuven belgium

abstract

inductive logic programming relational learning powerful paradigm machine
learning data mining however order ilp become practically useful
eciency ilp systems must improve substantially end notion query pack
introduced structures sets similar queries furthermore mechanism described
executing query packs complexity analysis shows considerable eciency
improvements achieved use query pack execution mechanism
claim supported empirical obtained incorporating support query
pack execution two existing learning systems
introduction

many data mining employ extent generate test large
amounts partial complete hypotheses generated evaluated data
mining process evaluation usually involves testing hypothesis large data set
process typically linear size data set examples data mining
apriori agrawal et al decision tree quinlan
breiman et al inducing decision rules clark niblett etc
even though search hypothesis space seldom exhaustive practical
situations clever branch bound greedy search strategies employed number hypotheses generated evaluated approaches may still huge
especially true complex hypothesis space used often case inductive
logic programming ilp sheer size hypothesis space important
contribution high computational complexity ilp approaches computational complexity reduced however exploiting fact many
similarities hypotheses

c ai access foundation morgan kaufmann publishers rights reserved

fiblockeel dehaspe demoen janssens ramon vandecasteele
ilp systems build hypothesis one clause time search single clause
concerned rest word hypothesis
usually refer single clause clause search space typically structured
lattice clauses close one another lattice similar computations
involved evaluating similar well words many computations
performed evaluating one clause boils executing query
consisting body clause performed evaluating
next clause storing certain intermediate computation later use could
solution e g tabling xsb prolog engine chen warren may
infeasible practice memory requirements becomes feasible
search reorganised intermediate used shortly
computed achieved extent rearranging computations
best way removing redundancy however seems implement execution
strategy queries way much computation possible effectively
shared
discuss strategy executing sets queries organised called
query packs avoids redundant computations strategy presented adaptation standard prolog execution mechanism adapted execution mechanism
implemented ilprolog prolog system dedicated inductive logic programming several inductive logic programming systems implemented make use
dedicated engine implementations obtained experimental
showing cases speed order magnitude thus
work significantly contributes applicability inductive logic programming real
world data mining tasks addition believe may contribute state art
query optimisation relational databases indeed latter field lot
work optimisation individual queries relatively small sets queries much
less optimisation large groups similar queries understandably
get much attention advent data mining optimisation groups queries
relational databases seems interesting area believe techniques
similar ones proposed might relevant area
remainder structured follows section precisely describe
ilp setting work set section define notion
query pack indicate would executed standard prolog interpreter
computational redundancy causes describe execution mechanism
query packs makes possible avoid redundant computations would arise
queries pack run separately implemented making
small significant extensions wam standard prolog execution mechanism
section describe query pack execution strategy incorporated two
existing inductive logic programming tilde warmr section
present experimental illustrate speed systems achieve
query pack execution mechanism section discuss related work
section present conclusions directions future work



fiimproving efficiency ilp query packs
inductive logic programming

inductive logic programming muggleton de raedt situated intersection
machine learning data mining one hand logic programming
hand shares former fields goal finding patterns data patterns
used build predictive gain insight data logic programming
shares use clausal first order logic representation language data
hypotheses remainder text use basic notions logic
programming literals conjunctive queries variable substitutions use
prolog notation throughout introduction prolog logic programming
see bratko
inductive logic programming used many different purposes
statements found ilp papers consequently vary article consider called
learning interpretations setting de raedt dzeroski de raedt
argued elsewhere setting slightly less powerful standard
ilp setting e g learning recursive predicates sucient
practical purposes scales better blockeel et al
formulate learning task way covers number different
statements specifically consider detecting set conjunctive
queries instantiations certain variables query succeeds variables
called key variables grounding substitution called key instantiation
intuition example learning task uniquely identified single key
instantiation
link ilp systems learn clauses follows search performed
ilp system directed regularly evaluating candidate clauses let us denote
candidate clause head x
body x x represents vector variables
appearing head clause represents additional variables occur
body assume head single literal list examples given
example form head x substitution grounds x examples
may labelled e g positive negative essential setting
example represented fact head x learning definite horn clauses
consider tuple x notations used
intuitively positive negative examples given one wants clause
covers many positive examples possible covering negatives
whether single example head x covered clause determined
running query body x words evaluating clause boils
running number queries consisting body clause simplicity notation
often denote conjunctive query conjunction without symbol
less typical ilp settings ilp search horn clauses
rather general clauses e g claudien de raedt dehaspe frequent
patterns expressed conjunctive queries e g warmr dehaspe toivonen
settings handled well needed mapping
hypotheses queries allow evaluate hypotheses mapping
defined de raedt dehaspe claudien warmr trivial



fiblockeel dehaspe demoen janssens ramon vandecasteele
given set queries set examples e main task determine
queries q cover examples e e formalise notion
set

definition set set set queries deductive database
key k example set e
rs k e

f k jqi k e qi succeeds dg

similar learning interpretations setting defined de raedt
setting stated

given set conjunctive queries deductive database tuple k variables
occur query example set e
set rs k e e query q ground
instantiations k k e q succeeds
example assume ilp system learning definition grandfather wants evaluate following hypotheses

grandfather x parent x z parent z male x
grandfather x parent x z parent z female x

examples form grandfather gf gc gf gc constants hence
example uniquely identified ground substitution tuple x
setting set prolog queries equals f parent x z parent z
male x parent x z parent z female x g key k equals x
given query qi finding tuples x x r r
set defined equivalent finding grandfather x facts
example set predicted clause grandfather x qi

generality setting follows fact known
queries succeed examples statistics heuristics typical ilp systems
use readily obtained examples






discovery frequent patterns dehaspe toivonen query qi
number key instantiations succeeds needs counted e
f req qi jfk j k rgj r set
induction horn clauses muggleton quinlan b accuracy
clause h qi defined number examples body head hold
divided number examples body holds computed
jfkj k r dj hgj r set
jfkj k rgj
induction first order classification regression trees kramer blockeel
de raedt blockeel et al class entropy variance examples
covered covered query computed probability distribution
target variable computing distribution involves simple counts similar
ones



fiimproving efficiency ilp query packs
transforming grandfather clauses
grandfather x parent x z parent z male x
grandfather x parent x z parent z female x

set clearly computed collecting grounding k e
answers query grandfather k section queries literal
end another goal side effects collecting set
practice natural compute set double loop one examples
one queries one choice outer loop examples
outer loop queries outer loop used data mining systems
context decision trees see instance quinlan mehta et al
shall see redundancy removal propose uses examples
outer loop strategy approaches however given query key instantiation
interested whether query succeeds key instantiation implies
particular query succeeded example execution stopped
words computing set defined boils evaluating
query example interested existence success
evaluation computing one solution one query one example unnecessary
query packs

simplicity make abstraction existence keys following examples
relevant query interested whether succeeds
finding answer substitutions
given following set queries
p x
p x
p x
p x
p x


q x
q x b
q x
q x



x
x r

choose evaluate separately since interested one first
success query would evaluate prolog queries
p x
p x
p x
p x
p x


q x
q x b
q x x
q x x r

wrapper pruning primitive prevents unnecessary search
solutions definition prolog simply
goal call goal



fiblockeel dehaspe demoen janssens ramon vandecasteele
alternative way evaluate queries consists merging one nested
disjunction
p x



q x



q x b



q x x



r

set queries evaluated whole success one branch
disjunctive query corresponds success corresponding individual query
compared evaluation individual queries disjunctive query
advantage disadvantage
queries prefix p x evaluated individual
query disjunctive query goal p x evaluated depending
evaluation cost p lead arbitrary performance gains
usual prolog pruning primitives powerful enough prevent unnecessary backtracking branch disjunctive query succeeded
explained example

example example literals

contribute discussion

left



p x q x
p x r x

evaluating queries separately means evaluating
p x q x
p x r x

equivalently
p x q x
p x r x

corresponding disjunctive query
p x q x r x

try place pruning primitive disjunctive query end
branch
p x q x r x

scope first cut clearly large goal q x succeeded cut
prevent entering second branch means adding cut disjunctive
query leads wrong
disjunctive query
p x q x r x



fiimproving efficiency ilp query packs
correct query however branches still executed every
binding goal p x produces even branches succeeded already

combination advantage disjunctive query advantage
individual query pruning cut notion query pack syntactically query pack looks disjunctive query control construct
replaced control construct denoted query pack corresponding
disjunctive query
p x



q x



q x b



q x x



r

query pack represented tree figure query pack q
tree literals conjunctions literals nodes path root leaf
node represents conjunctive query q member q denoted q q
construct implicit branching points
p x


q x


q x b


q x c



q x x
r


r


figure query pack
intended procedural behaviour construct branch succeeded effectively pruned away pack evaluation query pack
current example pruning must recursive e branches subtree
query pack succeeded whole subtree must pruned evaluation
query pack terminates subtrees pruned remaining
queries fail example
semantics construct ecient implementation subject
rest section however clear already case
answers query needed pruning cannot performed disjunctive query
already sucient e query packs useful single success per query suces

ecient execution query packs
section meta interpreter given defines behaviour query packs
practice meta interpreter useful many cases meta interpreter
causes overhead use query packs compensate indeed previously
reported demoen et al blockeel indicate overhead involved
high level prolog implementation destroys eciency gain obtained redundancy
reduction moreover discussed section meta interpreter
desired time complexity shows desired procedural semantics



fiblockeel dehaspe demoen janssens ramon vandecasteele
implemented prolog desired performance prolog lacks
appropriate primitives
conclusion changes needed level prolog engine
requires extension wam warren abstract machine underlying
abstract machine prolog implementations extended wam provides
operator discussed permanently removes branches pack
need investigated anymore extended wam become basis prolog
engine dedicated inductive logic programming called ilprolog section continues
introduction basic terminology query packs explains high level
query pack execution works next meta interpreter query pack execution
given finally changes needed wam clarified
principles query packs execution

discuss query pack execution detail note following two points
pack execution pruning branch must survive backtracking executing
pack interested variable instantiations whether member
pack succeeds previous description interested binding
variable since branch bind one value query number collect
values practice side effect denoted section report success
starting point query pack execution mechanism usual prolog execution
query q given prolog program p backtracking prolog generate
solutions q giving possible instantiations q succeeds p
query pack consists conjunction literals set alternatives
alternative query pack note leaves query packs empty set
alternatives query pack q conj q denotes conjunction children q
denotes set alternatives set queries represented called root query
pack every query pack q path query packs starting root query
pack qroot ending query pack namely qroot q qn q
query packs path predecessors q every query pack set dependent
queries dependent queries q let qroot qi qin q path q
dependent queries q fconj qroot conj qi conj qin conj q conj qj
conj qjm conj ql j q qj qjm ql path q leaf ql g note
dependent queries qroot actually members query pack described
earlier

qroot root tree conj qroot
qroot contains query packs correspond trees

example query pack figure
p x set children

rooted sons root tree suppose query packs named
left right q q q q conj q equals q x children q
equals empty set conj q equals q x x dependent queries q equals
f p x q x x p x q x x r g

execution root query pack qroot aims finding queries set
dependent queries qroot succeed query pack executed ors usual
disjunctions backtracking occurs queries already succeeded many



fiimproving efficiency ilp query packs













execute qp pack q substitution f
next solution conj q

f

qchild children q

f
g

g

execute qp qchild success
children q
children q n fqchild g

children q empty set return success

return fail

g

figure query pack execution
successes detected avoid case soon query succeeds
corresponding part query pack longer considered backtracking realises reporting success queries query packs
predecessors query pack non root query pack q safely removed
queries depend e queries dependent queries q succeeded
leaf q empty set children success conj q sucient remove
non leaf q wait dependent queries report success equivalently
query packs children q report success
start evaluation root query pack set children every query
pack contains alternatives given query pack execution query
packs removed children sets thus values children q change
accordingly due backtracking query pack executed might case
fewer alternatives considered
execution query pack q defined execute qp q figure
imposes additional control usual prolog execution
usual prolog execution backtracking behaviour modelled loop
line generates possible solutions conjunction query pack
solutions found fail returned backtracking occur level
calling query pack
additional control manages children q solution necessary
children q executed important notice initial set children
query pack changed destructively execution firstly
leaf reached success returned line corresponding child removed
query pack line secondly query pack initially several children finally
ends empty set children line query pack removed line
fact children destructively removed implies due backtracking
query pack executed different alternatives
initially executed moreover returning success



fiblockeel dehaspe demoen janssens ramon vandecasteele
qp
ch

ch
ch

b qp
ch

f

q

g qp
ch

ch
ch

c q

q

ch
ch

e q

h q

q

j

q

figure query pack numbers qp query numbers q child numbers ch
example
backtracking current query pack conjunction conj q stopped branches
reported success
meta interpreter query packs

first implementation query pack execution meta interpreter
meta execute qp q meta interpreter uses following labelling representation
query pack

query pack number non leaf query packs tree numbered depth
first left right qp

query number leaf numbered left right original queries
numbered sequentially numbers leaves correspond q

child number non leaf query pack n children children numbered
n sequentially ch

consider query pack b c e f g h j note
atoms example could general arbitrary conjunctions non ground terms
labelling shown figure
labelled query pack q represented prolog term follows qf
father q



leaf

q represented term c leaf qpnbf chnb qnb c conj q
query pack number qf chnb child number q w r qf qnb
query number q



non leaf q represented term c cs qpnbf qpnb chnb totcs c
conj q cs list children q qpnbf query pack number qf qpnb query
pack number q chnb child number q w r qf totcs total number
children q query pack number father root query pack
assumed zero

qpnbf



fiimproving efficiency ilp query packs
example figure following representation prolog term
b c leaf leaf e leaf
f leaf
g h leaf leaf j leaf


execution meta interpreter solved facts asserted fact
solved qpnb chnb denotes child number chnb query pack number

succeeded facts asserted reaching leaf children
query pack succeeded meta interpreter executes children
solved fact asserted
note time complexity meta interpreter yet desired execution
query pack dependent number original children instead
number remaining yet unsuccessful children
qpnb

run querypack q preprocess q qlabeled
code preprocessing given appendix
retractall solved
meta execute qp qlabeled
solved
meta execute qp b
call
meta execute qp b
meta execute qp cs qpnbf qpnb childnb totcs corresponds non leaf query pack
handlechildren cs qpnb
solved qpnb totcs
assert solved qpnbf childnb
meta execute qp leaf qpnbf childnb querynb leaf corresponds end query
write succeed querynb nl
assert solved qpnbf childnb
handlechildren
handlechildren c qpnb childnb solved qpnb childnb
meta execute qp c fail
handlechildren cs qpnb childnb childnb childnb
handlechildren cs qpnb childnb
solved qpnb childnb totcs childnb totcs true

childnb childnb
solved qpnb childnb
solved qpnb childnb totcs




fiblockeel dehaspe demoen janssens ramon vandecasteele
wam extensions

fully exploit potential query pack shared computation avoidance unnecessary backtracking changes made level prolog engine
explanation assumes wam prolog engine kaci short explanation
execution disjunction prolog given first becomes easy see
newly introduced wam
assume body clause executed b c e assume
predicates several clauses moment execution reached first
clause c choice point stack looks figure choice points
activation disjunction b c choice points linked together
backtracking easily pop top one choice point contains pointer
next alternative tried disjunction choice point alternative pointer
shown points beginning second branch disjunction
alternatives b c exhausted second branch entered becomes
active situation shown figure b point alternative
disjunction choice point refers last alternative branch disjunction finally
e entered disjunction choice point already popped
b c e

b c e

b c e











e

b



c

choice points
entering c

b choice points
entering

c choice points
entering e

figure illustration execution disjunction wam
goal produces solution branches disjunction must tried
exactly want avoid query packs branch succeeded
never entered therefore adapt disjunction choice point become
choice point set point data structure contains references
alternative disjunction data structure named pack table figure
shows state execution reached c similar figure
choice point contains information first branch executed
execution proceeds two possibilities first branch succeeds fails
describe failing situation first branch explain happens success



fiimproving efficiency ilp query packs
second branch first branch solution backtracking updates alternative
choice point point next branch pack table situation
second branch entered shown b similar b suppose
branch goal succeeds entry pack table alternatives
adapted erasing second alternative branch backtracking occurs next
alternative branch choice point taken shown c
produces solution disjunction entered pack table
longer contain second alternative branch never entered pack
table actually arranged way entries really removed instead erased
cause overhead later
b c e

b c e

b c e













b



e

c

choice points
entering c

b choice points
entering first
branch succeed

c choice points
entering e succeeded

figure illustration execution pack disjunction wam
two issues must explained first pack table alternatives must
constructed runtime every time query pack entered evaluation done
emitting necessary instructions beginning code query pack
example code query pack b c e figure
finally example clear moment alternatives ordisjunction succeeded stop producing solutions computation
stopped general nested query packs means one pack table entry
next higher node erased recursive way recursive removal
entries pack tables done instruction query pack prune
implemented schema ilprolog section presents measurements
ilprolog

query packs
figure shows makes use pack execution mechanism compute
set r defined statement set queries typically



fiblockeel dehaspe demoen janssens ramon vandecasteele
construct pack table
call
query pack try
call b
call c
query pack prune
call
query pack prune
call e
query pack prune

figure abstract machine code b c e
set refinements given query e correspond whole hypothesis
space query pack q containing queries derived pack q constructed
adding report success literal leaf pack procedural task
report success k simply add k set r obviously specific
ilp system interested set could provide report success
predicate thus avoid overhead explicitly building set
evaluate set examples e pack q key k f

q q

q


leaf q f

add report success k q right conjunction leaf

increment q

g

c
evaluate pack k q

compile load c

example e e f

evaluate pack e

g
g
figure query packs compute set
note figure follows strategy running queries
single example moving next example could called examples
outer loop strategy opposed queries outer loop strategy used ilp
current implementation set implemented bit matrix indexed queries
examples implementation practically feasible typical computers time writing even
number queries pack multiplied number examples billion bound
holds current ilp applications



fiimproving efficiency ilp query packs
systems examples outer loop strategy important advantages processing
large data sets mainly due ability process eciently without data
main memory time mehta et al blockeel et al

computational complexity
estimate speedup factor achieved query pack execution two
steps first consider one level packs extend towards deeper packs
lower upper bounds speedup factor achieved executing
one level pack instead separate queries obtained follows pack containing
n queries qi bi let ti time needed compute first answer substitution
qi obtain failure otherwise let ti part ti spent within
part ti spent bi ts ti tp max ti ts
representing total time needed executing queries separately tp total time
needed executing pack introducing c ti roughly represents
ratio computational complexity shared part non shared part


c
ts
ti
ti

maxi ti


tp
maxi ti ti



p

p

p

p p

p
p

p



defining k ratio maximal ti average ti e

rewrite equation

since

p

ti
n

pmaxt nt


k



ts
tp





c

k
nc





max ti pi ti know k n leads following bounds


ts
tp



c

c
n



min c n



thus speedup factor bounded branching factor n
ratio c computational complexity shared part computational complexity
non shared part maximal speedup attained max ti ti n
k words ti queries approximately equal
multi level packs estimate eciency gain follows given query qi
let ti defined total time finding answer qi obtaining failure
instead ti define ti l time spent level l pack solving qi
counting root level denoting depth pack ti dl ti l
define ti l time spent level l deeper ti l dj l ti j depth
pack thus ti ti assume constant branching factor b pack
finally define tl ti l n n bd simplicity formulae implicitly
assume ranges n n number queries unless explicitly

p

p

p



p

fiblockeel dehaspe demoen janssens ramon vandecasteele
specified otherwise
tp

max ti


x





max ti


x
max
b

j



gj



xt





gj







j b index child root gj set indexes
queries belonging child define k maxi ti define k smallest
number maxi gj ti k tj tj gj ti b note k k b
follows
b
b
max ti k tj k bt

gj
j
j

p

x

x

allows us rewrite equation
tp

k k bt

xt






equality holds maxi gj ti equal gj reasoning continued
till lowest level pack yielding
tp

k bk b k bd

finally
tp

k bk b k bd



k

td

k





td

xt







bd td



kl b simplify comparison ts assuming
l kl kl dropped inequality becomes equality
maxima must equal
tp

bt b bd td



bd td





bd td



note ts
ts

bd bd bd bd td

clear speedup governed bd tk terms compare
bk tk terms worst case kk b latter become bk tk therefore
introduce rl follows

bm tk

rl km l k

k l b tk

p
p

r coecients tm dominates bm l tl strongly dominates
tl equal rl approximately l
similar c previous analysis define

p b
c p

b
l

l
k


k l



k

k

k

k



fiimproving efficiency ilp query packs
algebra gives

ts
tp



bd l cl r l rl
cl



needs hold l interpret follows certain level l cl roughly
ects speedup gained fact part till level l needs executed
r factors ect speedup obtained within parts pack
mechanism
inequality holds l hence best lower bound speedup factor maximizing right hand side note cl increases bd l decreases
monotonically l clear point cl becomes much larger
speedup factor roughly bd l obtained hand cl smaller
behaviour bd l cl crucial
bd l cl

tl tl b l
b

td b td bd l tl

conclusion similar one level pack l cl e
upper part pack till level l computations take place expensive
dominate computations level l even taking account latter
performed bd l times often speedup bd l expected cl
usually case l except near speedup roughly
estimated tl td maximum factors determine actual speedup
adapting ilp use query packs

section discuss execution method included ilp illustrate detail two existing ilp experimental
concerning actual eciency improvements yields presented next section

refinement single rule
many systems inductive logic programming use consists repeatedly
refining clauses systems could principle rewritten make use query
pack evaluation mechanism thus achieve significant eciency gain first
concrete decision tree induction discuss general case
induction decision trees

first discuss tilde blockeel de raedt
builds first order decision trees first order decision tree nodes contain literals
together conjunction literals nodes node e path
root node form query run example decide
subtree sorted building tree literal conjunction
literals put one node chosen follows given query corresponding path
root node generate refinements query refinement query



fiblockeel dehaspe demoen janssens ramon vandecasteele
formed adding one literals query evaluate refinements
relevant subset data computing e g information gain quinlan yielded
refinement choose best refinement put literals added
original clause form refinement node
point clear lot computational redundancy exists refinement
evaluated separately indeed refinements contain exactly literals except
added single refinement step organising refinements one query pack
obtain query pack essentially one level root immediately branches
leaves tilde lookahead facility used blockeel de raedt refinements
form lattice query pack may contain multiple though usually levels
note root packs may consist conjunction many literals giving
pack broom form literals root pack greater benefit
query pack execution expected

example assume node currently refined following query associated

circle c leftof c e e node covers examples
circle left object yet another object
query pack generated refinement could instance

circle c leftof c e

triangle f
circle h
small
large j
e k
l
c
e n

c p
leftof e q
leftof r
leftof c

evaluating pack backtracking root pack stick
broom happen instead refinement words
evaluating queries one one query prolog engine needs search
objects c e fulfilling constraint circle c leftof c
e executing pack search done
rule refinement

mentioned ilp consists repeatedly refining clauses could principle rewritten make use query pack evaluation mechanism thus achieve
significant eciency gain consider e g rule induction system performing search
refinement lattice progol muggleton since imposes certain order clauses considered refinement hard reorganise
computation level however taking one node list open nodes
producing refinements evaluation refinements involves executing
replaced pack execution case positive eciency gain
guaranteed principle one could perform several levels refinement stage
e subset original data set parent query succeeded decision tree
context examples sorted node refined



fiimproving efficiency ilp query packs
adding refinements queue part eciency lost
pack execution mechanism exploited larger extent two effects
dominant depend application first level refinements would
refined anyway point search clearly gain
executing two level pack otherwise may loss eciency instance
executing two level pack takes x times much time one level pack bring
eciency gain least x first level refinements would afterwards refined


level wise frequent pattern discovery
alternative family data mining scans refinement lattice breadthfirst manner queries whose frequency exceeds user defined threshold bestknown instance level wise apriori method finding frequent
item sets agrawal et al warmr dehaspe toivonen ilp variant
attribute value apriori
query packs warmr correspond hash trees item sets apriori used
store subgraph total refinement lattice level n paths root
level n subgraph correspond frequent patterns paths root
leaves depth n correspond candidates whose frequency computed
hash trees apriori query packs warmr exploit massive similarity
candidates make evaluation ecient essentially warmr starts
empty query pack iterates pack evaluation pack extension see
figure latter achieved adding potentially frequent refinements leaves
pack e adding another level total refinement lattice
experiments

goal experimental evaluation empirically investigate actual speedups
obtained implementing ilp systems use pack execution
mechanism moment implementations exist tilde warmr
systems hence used experiments implementations
available within ace data mining tool available academic use upon request
attempt quantify speedup packs w r separate execution queries thus
validating complexity analysis b total speedup yield
ilp system
data sets used experiments following



mutagenesis data set ilp benchmark data set introduced ilp community srinivasan et al consists structural descriptions
molecules classified mutagenic next standard mutagenesis data set consider versions example occurs n times

refinements found specialisations infrequent queries cannot frequent
pruned consequently
see http www cs kuleuven ac dtai ace



fiblockeel dehaspe demoen janssens ramon vandecasteele

circle b

triangle b

leftof b c b c leftof b c

expand

circle b

leftof b c

triangle b

b c

leftof b c

circle c triangle c circle c triangle c circle c triangle c
evaluate
circle b triangle b
b c

leftof b c

triangle c circle c triangle c

circle b

expand

b c
triangle c

triangle b
leftof b c

circle c

triangle c

leftof c leftof c c leftof c

figure sequence query packs warmr refinement left query
pack level pack right removal queries found infrequent
pack evaluation bottom left pack finally another level
added second query expansion step produce bottom right pack
iteration expansion evaluation continues pack empty
allows us easily generate data sets larger size average example
query complexity constant equal original data set



bongard data sets introduced ilp de raedt van laer called
bongard simplified version used bongard
pattern recognition number drawings shown containing
number elementary geometrical figures drawings classified according
relations hold figures use bongard generator
create data sets varying size

experiments run sun workstations sparc ultra mhz
tilde sparc ultra mhz warmr tilde warmr run
default settings except mentioned differently

tilde
consider three different ways tilde run ilprolog implementation
packs normal implementation tilde described blockeel de raedt
queries generated one one evaluated relevant
examples since queries represented terms evaluation query involves
meta call prolog



fiimproving efficiency ilp query packs
disjoint execution packs query pack executed queries pack
put beside one another e common parts shared queries
computational redundancy executing pack executing
queries one another main difference case queries
compiled
packed execution packs compiled query pack executed queries share
much possible
interesting information obtained comparing actual query evaluation time settings gives view eciency gain obtained
removal redundant computation abbreviate exec tables
b total execution time settings provides indication
much gained implementing packs ilp system taking effects account implementation computation heuristics via bit matrix use compiled
queries instead meta calls etc words net effect whole
implementation indicated net tables
first experiment used bongard varying size data sets
complexity target hypothesis tilde lookahead parameter
complexity target hypothesis small medium none latter case
examples random causes tilde grow ever larger trees attempt
good hypothesis size final tree typically depends size data
set lookahead parameter used control number levels pack contains
lookahead n packs depth n generated
table gives overview bongard total induction
time reported well pack execution mechanisms time needed
pack compilation pack execution note total time includes pack
compilation execution computations directly related packs
e g computation heuristics bitmatrix interpreted
follows
first table shows significant speedups obtained pack
mechanism net speedups factor obtained execution
times faster compared disjoint execution
observation complex target hypotheses greater speedups
obtained explained broom form packs tilde complex
target hypotheses correspond deep trees refinement node lower level
tree yields pack long clause branching accordance
previous analysis yield speedup closer branching factor b case
lookahead generally closer bl lookahead l although latter
much harder achieve note maximum branching factor occurring pack
included table column bf
finally deeper packs yield higher speedups effect larger complex
theories understandable considering following let us call clause
refined c lookahead l conjunctions l literals added clause
cases first l literals may fail immediately causes branch
pack almost execution time cutting away bl queries remember



fiblockeel dehaspe demoen janssens ramon vandecasteele
la

bf



























































































original














































disjoint
packed
comp exec total comp
simple target hypothesis
examples




















examples




















examples




















medium complexity target hypothesis
examples




















examples



















examples




















target hypothesis
examples

















examples




















examples


















total

speedup

exec

net

exec

























































































































































































































table timings tilde runs bongard data sets la lookahead setting bf
maximum branching factor reported times seconds total time needed
build tree time spent compilation respectively execution packs



fiimproving efficiency ilp query packs
la original
















disjoint
packed
total comp exec total comp
regression examples







classification examples







table timings tilde runs mutagenesis
ended prematurely

exec

speedup ratio
net
exec





















table indicates run

according analysis speedup limit approximate bl complexity
clause c dominates complexity rest pack early failing branches
pack cause actual situation approximate closer ideal case
run experiments mutagenesis data set table regression
classification setting query packs much larger bongard data set
higher branching factor lookahead largest packs
queries large packs significant amount time spent compiling pack
even clear net speedups obtained comparison execution times turned
infeasible disjoint execution setting pack structures consumed much
memory

warmr
used implementations

warmr consider following implementations
packs normal implementation warmr queries generated
examples queries evaluated one one
packs implementation first queries one level generated
put pack pack evaluated example
datasets

mutagenesis used mutagenesis dataset molecules example
repeated times make accurate timings possible better idea
effect larger datasets used three different language biases small language
one case relatively small pack system became slower timings indicate
due compilation time changes implementation relatively
simple compensated faster execution packs



fiblockeel dehaspe demoen janssens ramon vandecasteele

level










small

mutagenesis

medium

large

queries frequent queries frequent queries frequent











































table number queries mutagenesis experiment warmr
bias chosen generate limited number refinements e relatively
small branching factor search lattice allows us generate query packs
relatively deep narrow medium large use broader shallow packs
table summarises number queries number frequent queries found
level different languages

bongard use bongard experiments

warmr system
construct theory hence existence simple theory expected make much
difference


tables execution times warmr mutagenesis given maximal
search depth varying large language levels small language
total total execution time exec time needed test queries
examples table execution times warmr bongard given
discussion

execution time warmr large component used evaluate queries
caused fact warmr needs lot administrative work
particular theta subsumption tests done queries check wether query
equivalent another candidate query specialisation infrequent one
propositional case apriori tests simple
first order case require exponential time size queries course
larger datasets relative contribution administrative costs decrease
proportionally observed deeper levels costs less setting
packs one causes fact packs version uses memory
packs setting hence causes proportionally memory management
important numbers speedup factors execution
queries speedup factors query execution increase increasing depth



fiimproving efficiency ilp query packs

level










packs
packs ilprolog
total
exec
total
exec

























speedup ratio
net
exec










table warmr mutagenesis dataset small language

level







packs
packs ilprolog
total
exec
total
exec

















speedup ratio
net
exec







table warmr mutagenesis dataset medium language

level




packs
packs ilprolog
total
exec
total
exec










speedup ratio
net
exec




table warmr mutagenesis dataset large language



fiblockeel dehaspe demoen janssens ramon vandecasteele
level











packs
total
exec













table

packs ilprolog
total
exec





















warmr

speedup ratio
net
exec











bongard

packs contrast tilde larger packs yielded higher speedups first sight
found surprising however becomes less following observation made
refining pack pack adding level warmr prunes away branches
lead infrequent queries thus two effects adding level pack
one widening pack lowest level least first levels
pack typically leaves previous one second narrowing
pack whole pruning since speedup obtained packs largely
depends branching factor pack speedup factors expected decrease
narrowing effect stronger widening bottom effect
seen e g small mutagenesis experiment deepest levels queries
becoming less frequent mutagenesis experiment medium size language
query execution speedup factors larger number queries increases much faster
mutagenesis experiment large language total speedup large
language generates many queries time consuming part becomes
administration storage memory packs version much faster stores
queries trees requiring significantly less memory

comparison engines
implementing special purpose prolog engine different already existing ones
carries risk given level sophistication popular prolog engines useful check
whether engine performs comparably existing engines least
tasks consideration eciency gain obtained query pack execution
offset less ecient implementation engine
originally tilde warmr systems implemented masterprolog
attempt allow run platforms parts systems reimplemented kind generic prolog implementations specific prolog engines sicstus ilprolog easily derived low level standardisation
prolog made necessary given situation two questions answered



fiimproving efficiency ilp query packs
data set
la
bongard
bongard
bongard
bongard
bongard
bongard
bongard
bongard
bongard
table

masterprolog ilprolog original ilprolog packs






























compared engines times seconds several data sets
lookahead settings

ilprolog

move masterprolog prolog engines uence performance
negative way b performance loss reduce performance improvements due use packs
tilde warmr tuned fast execution masterprolog ilprolog sicstus makes comparison latter unfair therefore
report former engines table shows confirm
ilprolog competitive state art prolog engines

summary experimental
experiments confirm query pack execution much ecient
executing many highly similar queries separately b existing ilp systems use tilde
warmr examples use mechanism advantage achieving significant
speedups c although prolog engine needed achieve current state
development engine respect execution speed compete
state art engines experiments consistent complexity
analysis execution time packs
related work

implementation tilde related work mehta et al
first describe examples outer loop strategy decision tree induction
query pack execution mechanism described prolog execution point view
seen first order counterpart apriori mechanism counting item sets
agrawal et al
lines work eciency improvements ilp involves stochastic methods
trade certain amount optimality eciency e g evaluating clauses
sample data set instead full data set srinivasan exploring clause
search space random fashion srinivasan stochastically testing whether



fiblockeel dehaspe demoen janssens ramon vandecasteele
query succeeds example sebag rouveirol first entirely
orthogonal query pack execution easily combined
idea optimising sets queries instead individual queries existed
database community typical context considered earlier
multi query optimisation e g sellis database system needs
handle disjunctions conjunctive queries server may receive many queries
different clients brief time interval several queries expected compute
intermediary relations may ecient materialise relations
instead recomputed query data mining provides sense
context multi query optimisation multi query optimisation
time easier similarities among queries systematic one need
look promising given huge number queries may
generated
tsur et al describe ecient execution called query ocks
context query pack execution mechanism query ock execution mechanism inspired extent apriori set deductive database setting
main difference query packs query ocks described tsur et al
query packs hierarchically structured queries pack
structurally less similar queries ock ock represented single query
placeholders constants equal set queries obtained
instantiating placeholders constants flocks could used applications
consider
dekeyser paredaens describe work multi query optimisation context
relational databases consider tree structures multiple queries
combined main difference trees rooted one single table
queries select tuples whereas queries correspond joins multiple tables
dekeyser paredaens define cost measure trees well operators map trees
onto semantically equivalent less costly trees whereas considered
creation packs ecient top execution mechanism combining
approaches seems interesting topic
finally optimisation techniques ilp proposed exploit
program analysis santos costa et al blockeel et al propositional
data mining technology blockeel et al complementary pack
execution optimisation especially blockeel et al easily
combined pack mechanism techniques discussed santos costa et al
blockeel et al involve optimisations single query execution
extent upgraded pack setting future work
conclusions

lot redundancy computations performed ilp systems
identified source redundancy proposed method avoiding
execution query packs discussed query pack execution incorporated
ilp systems query pack execution mechanism implemented
prolog system called ilprolog dedicated data mining tasks two ilp systems



fiimproving efficiency ilp query packs
implemented make use mechanism experimentally evaluated
implementations experiments confirm large speedups
may obtained way conjecture query pack execution mechanism
incorporated ilp systems similar speedups expected
setting query pack execution introduced general
allows technique used kind task many queries executed
data long queries organised hierarchy
future work includes improvements ilprolog engine implementation techniques increase suitability engine handle large data sets
best case one might hope combine techniques known database optimisation
program analysis pack execution mechanism improve speed
ilp systems

acknowledgements
hendrik blockeel post doctoral fellow fund scientific fwo
flanders jan ramon funded flemish institute promotion scientific
industry iwt henk vandecasteele funded part fwo project
g query languages database mining authors thank luc de raedt
uence work ashwin srinivasan suggesting term query packs
anonymous reviewers useful comments kurt driessens proofreading
text work motivated part esprit project aladin
appendix preparing query meta interpreter

note following preprocessor assumes pack form b c
e f g h j already transformed form b
c e f g h j
preprocess b newb prevnode nodenr leafnr branchnr nodenr leafnr
preprocess b newb prevnode nodenr leafnr branchnr nodenr leafnr
preprocess querys nquerys prevnode nodenr branchnr length
prevnode nodenr leafnr branchnr nodenr leafnr
nodenr nodenr
preprocessbranches querys nquerys nodenr nodenr leafnr
nodenr leafnr length
preprocess leaf prevnode branchnr leafnr
prevnode nodenr leafnr branchnr nodenr leafnr leafnr leafnr
preprocessbranches nodenr leafnr branchnr nodenr leafnr branchnr
preprocessbranches queryjquerys newqueryjnewquerys prevnode
nodenr leafnr branchnr nodenr leafnr length preprocess query newquery
prevnode nodenr leafnr branchnr nodenr leafnr
branchnr branchnr
preprocessbranches querys newquerys prevnode
nodenr leafnr branchnr nodenr leafnr length



fiblockeel dehaspe demoen janssens ramon vandecasteele

references

agrawal r mannila h srikant r toivonen h verkamo fast discovery
association rules fayyad u piatetsky shapiro g smyth p uthurusamy
r eds advances knowledge discovery data mining pp mit
press
kaci h warren abstract machine tutorial reconstruction mit
press cambridge massachusetts
http www isg sfu ca hak documents wam html
blockeel h top induction first order logical decision trees ph thesis
department computer science katholieke universiteit leuven
http www cs kuleuven ac ml ps blockeel phd ps gz
blockeel h de raedt l lookahead discretization ilp proceedings
seventh international workshop inductive logic programming vol
lecture notes artificial intelligence pp springer verlag
blockeel h de raedt l top induction first order logical decision trees
artificial intelligence
blockeel h de raedt l jacobs n demoen b scaling inductive logic programming learning interpretations data mining knowledge discovery

blockeel h de raedt l ramon j top induction clustering trees
proceedings th international conference machine learning pp
http www cs kuleuven ac ml ps ml ps
blockeel h demoen b janssens g vandecasteele h van laer w two
advanced transformations improving eciency ilp system th
international conference inductive logic programming work progress reports
pp london uk
bongard pattern recognition spartan books
bratko prolog programming artificial intelligence addison wesley wokingham england nd edition
breiman l friedman j olshen r stone c classification regression
trees wadsworth belmont
chen w warren tabled evaluation delaying general logic programs journal acm http www cs sunysb edu sbprolog
clark p niblett cn machine learning
de raedt l logical settings concept learning artificial intelligence

de raedt l dehaspe l clausal discovery machine learning



fiimproving efficiency ilp query packs
de raedt l dzeroski first order jk clausal theories pac learnable
artificial intelligence
de raedt l van laer w inductive constraint logic jantke k p shinohara zeugmann eds proceedings sixth international workshop
algorithmic learning theory vol lecture notes artificial intelligence pp
springer verlag
dehaspe l toivonen h discovery frequent datalog patterns data mining
knowledge discovery
dekeyser paredaens j query pack trees multi query optimization tech
rep university antwerp ftp wins uia ac pub dekeyser qpt ps
demoen b janssens g vandecasteele h executing query flocks ilp
etalle ed proceedings eleventh benelux workshop logic programming
pp maastricht netherlands
kramer structural regression trees proceedings thirteenth national
conference artificial intelligence pp cambridge menlo park aaai
press mit press
mehta agrawal r rissanen j sliq fast scalable classifier data
mining proceedings fifth international conference extending database
technology
muggleton inverse entailment progol generation computing special
issue inductive logic programming
muggleton de raedt l inductive logic programming theory methods
journal logic programming
quinlan j r c programs machine learning morgan kaufmann series
machine learning morgan kaufmann
quinlan j b foil midterm report brazdil p ed proceedings th
european conference machine learning lecture notes artificial intelligence
springer verlag
santos costa v srinivasan camacho r note two simple transformations improving eciency ilp system proceedings tenth
international conference inductive logic programming vol lecture notes
artificial intelligence pp springer verlag
sebag rouveirol c tractable induction classification first order
logic via stochastic matching proceedings th international joint conference artificial intelligence morgan kaufmann
sellis multiple query optimization acm transactions database systems

srinivasan study two sampling methods analysing large datasets
ilp data mining knowledge discovery
srinivasan study two probabilistic methods searching large spaces
ilp tech rep prg tr oxford university computing laboratory



fiblockeel dehaspe demoen janssens ramon vandecasteele
srinivasan muggleton king r comparing use background knowledge inductive logic programming systems de raedt l ed proceedings
fifth international workshop inductive logic programming
tsur ullman j abiteboul clifton c motwani r nestorov rosenthal
query ocks generalization association rule mining proceedings
acm sigmod international conference management data sigmod
vol acm sigmod record pp york acm press




