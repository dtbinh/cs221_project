journal artificial intelligence

submitted published

dynamic control real time heuristic search
vadim bulitko

bulitko ualberta ca

department computing science university alberta
edmonton alberta g e canada

mitja lustrek

mitja lustrek ijs si

department intelligent systems jozef stefan institute
jamova ljubljana slovenia

jonathan schaeffer

jonathan cs ualberta ca

department computing science university alberta
edmonton alberta g e canada

yngvi bjornsson

yngvi ru

school computer science reykjavik university
kringlan reykjavik iceland

sverrir sigmundarson

sverrir sigmundarson landsbanki

landsbanki london branch beaufort house
st botolph street london ec qr great britain

abstract
real time heuristic search challenging type agent centered search agents
time per action bounded constant independent size common
imposes restrictions pathfinding modern computer games large number
units must plan paths simultaneously large maps common search e g
ida ara ad inherently real time may lose completeness constant
bound imposed per action time real time search retain completeness
frequently produce unacceptably suboptimal solutions extend classic
modern real time search automated mechanism dynamic depth subgoal
selection remain real time complete large computer game maps
paths within optimal average expanding roughly single state per action
nearly three fold improvement suboptimality existing state art
time fold improvement amount per action

introduction
study agent centered real time heuristic search koenig
distinctive property search agent must repeatedly plan execute actions
within constant time interval independent size solved
restriction severely limits range applicable heuristic search instance static
search hart nilsson raphael ida korf
stenz anytime ara likhachev gordon
thrun anytime ad likhachev ferguson gordon
stentz thrun cannot guarantee constant bound time per action lrta
c

ai access foundation rights reserved

fib ulitko l u strek chaeffer b j ornsson igmundarson

potentially low solution quality due need fill heuristic depressions korf
ishida
motivating example consider autonomous surveillance aircraft context disaster response kitano tadokoro noda matsubara takahashi shinjou shimada
surveying disaster site locating victims assessing damage aircraft ordered fly
particular location radio interference may make remote control unreliable thereby requiring
certain degree autonomy aircraft ai task presents two challenges first
due flight dynamics ai must control aircraft real time producing minimum number
actions per second second aircraft needs reach target location quickly due limited
fuel supply need rescue potential victims promptly
study simplified version captures two ai challenges abstracting away robot specific details specifically line work real time heuristic
search e g furcy koenig shimbo ishida koenig botea muller schaeffer hernandez meseguer b likhachev koenig sigmundarson
bjornsson koenig likhachev consider agent finite search graph
task traveling path current state given goal state within context measure
amount agent conducts per action length path traveled
start goal locations two measures antagonistic reducing amount per action leads suboptimal actions longer paths conversely shorter paths
require better actions obtained larger effort per action
use navigation grid world maps derived computer games testbed games
agent tasked go location map current location examples include
real time strategy games e g blizzard first person shooters e g id software
role playing games e g bioware corp size complexity game maps well
number simultaneously moving units maps continues increase every generation games nevertheless game unit agent must react quickly users command
regardless maps size complexity consequently game companies impose time peraction limit pathfinding instance bioware corp major game company
collaborate sets limit ms units computing paths time
search produce entire solution agent takes first action e g
hart et al lead increasing action delays map size increases numerous optimizations
suggested remedy decrease delays recent example deployed forthcoming computer game refer sturtevant real time search addresses
fundamentally different way instead computing complete possibly abstract solution first action taken real time search compute plan
first actions agent take usually done conducting lookahead search fixed
depth known search horizon search depth lookahead depth around agents
current state heuristic e estimate remaining travel cost select next
actions actions taken execution cycle repeats e g korf
since goal state reached local searches agent runs risks heading
dead end generally selecting suboptimal actions address real time
heuristic search update learn heuristic function experience existing
constant amount e lookahead search per action
tend waste cpu cycles heuristic function fairly accurate conversely plan
enough heuristic function particularly inaccurate additionally compute heuris

fidynamic c ontrol r eal ime h euristic earch

tic respect distant global goal state put unrealistic requirements heuristic
accuracy demonstrate
address making following three contributions first
propose two ways selecting lookahead search depth dynamically per action basis second
propose way selecting intermediate subgoals per action basis third apply
extensions classic lrta korf state art real time pr lrts bulitko
sturtevant lu yau demonstrate improvements performance resulting
state art real time search illustrate large computer game
maps paths within optimal expanding single state
action comparison previous state art pr lrts times slower per
action finding paths two three times suboptimal furthermore
dynamically controlled lrta pr lrts one two orders magnitude faster per action
weighted state art partial refinement pra sturtevant buro
finally unlike modern extensions used games provably
real time slow maps become larger
rest organized follows section formulate real time
heuristic search core lrta extended dynamic lookahead
subgoal selection section analyzes related section provides intuition dynamic
control search section describe two approaches dynamic lookahead selection one
induction decision tree classifiers section one precomputing depth
table state abstraction section section present selecting subgoals
dynamically section evaluates efficiency extensions domain pathfinding
conclude discussion applicability general
extends conference publication bulitko bjornsson lustrek schaeffer sigmundarson set features decision tree way selecting
subgoals additional real time heuristic search pr lrta extended dynamic
control numerous additional experiments detailed presentation

formulation
define heuristic search directed graph containing finite set states weighted
edges single state designated goal state every time step search agent single
current state vertex search graph takes action traversing edge current
state edge positive cost associated total cost edges traversed agent
start state arrives goal state called solution cost require
complete produce path start goal finite amount time path exists
order guarantee completeness real time heuristic search make assumption safe
explorability search namely costs finite goal state reachable
state agent possibly reach start state
formally discussed applicable heuristic search keep presentation focused intuitive well afford large scale empirical
evaluation use particular type heuristic search pathfinding grid worlds
rest however discuss applicability methods suggest
heuristic search section general section


fib ulitko l u strek chaeffer b j ornsson igmundarson

computer game map settings states vacant square grid cells cell connected
four cardinally e west north east south four diagonally neighboring cells outbound
edges vertex moves available corresponding cell rest

use terms action move interchangeably edge costs cardinal moves
diagonal moves agent plans next action considering states local search space
surrounding current position heuristic function simply heuristic estimates remaining
travel cost state goal used agent rank available actions select
promising one consider admissible heuristic functions
overestimate actual remaining cost goal agent modify heuristic function
state avoid getting stuck local minima heuristic function well improve action
selection experience
defining property real time heuristic search amount agent
per action upper bound depend size enforce property
setting real time cut amount action exceeds
cut discarded fast preferred guarantees agents quick reaction
goal specification changes environment measure mean time per action
terms cpu time well machine independent measure number states expanded
state called expanded successor states considered generated
search second performance measure study sub optimality defined ratio
solution cost found agent minimum solution cost ratios close one indicate
near optimal solutions
core real time heuristic search called learning realtime lrta korf shown figure operates follows long goal
state sglobal goal reached interleaves execution lines
generalized version added step line selecting search depth goal sgoal
individually execution step original uses fixed sglobal goal
searches line ply breadth first search duplicate detection used frontier states
precisely actions away current state frontier state value sum
cost shortest path denoted g estimated cost shortest path
sgoal e heuristic value h sgoal use standard path max technique mero
deal possible inconsistencies heuristic function computing g h values
g h values never decrease along branch lookahead tree state
minimizes sum identified sfrontier line heuristic value current state
updated line keep separate heuristic tables different goals finally take one step
towards promising frontier state sfrontier line

related
single agent real time heuristic search use fixed search depth notable
exceptions russell wefald proposed estimate utility expanding state use
control lookahead search line one needs estimate likely additional search
change actions estimated value inaccuracies estimates overhead metalevel control led reasonable unexciting benefits combinatorial puzzle pathfinding
additional relatively low branching factor combinatorial puzzles makes
difficult eliminate parts search space early likely occur grid

fidynamic c ontrol r eal ime h euristic earch

lrta sstart sglobal goal
sstart
sglobal goal

select search depth goal sgoal

expand successor states actions away generating frontier

frontier state sfrontier lowest g sfrontier h sfrontier sgoal

update h sgoal g sfrontier h sfrontier sgoal

change one step towards sfrontier
end
figure lrta dynamic control
pathfinding finally method adds substantial implementation complexity requires
non trivial changes underlying search contrast search depth
selection easily interfaced real time search search depth parameter
without modifying existing code
ishida observed lrta style tend get trapped local minima
heuristic function termed heuristic depressions proposed remedy switch limited
search heuristic depression detected use search
correct depression different two ways first
need mechanism decide switch real time search thus avoid
need hand tune control parameters ishidas control module instead employ automated
decide search horizon depth every action additionally spend extra
time filling heuristic values within heuristic depression estimates
bulitko showed optimal search depth selection highly beneficial realtime heuristic search linked benefits avoiding called lookahead pathologies
deeper lookahead leads worse moves suggest practical way selecting lookahead depth dynamically way proposed via use generalized definition
heuristic depressions bulitko proposed extends search horizon incrementally search finds way depression actions leading found
frontier state executed cap search horizon depth set user idea precomputing depth table heuristic values real time pathfinding first suggested lustrek
bulitko extends work follows introduce intermediate goals
ii propose alternative require map specific pre computation iii
extend evaluate state art addition classic lrta
long tradition search control two player search high performance game playing
programs games chess checkers rely extensively search decide actions
take search performed strict real time constraints programs typically
minutes seconds deliberating next action instead fixed depth lookahead strategy programs employ sophisticated search control mechanisms maximizing
quality action decisions within given time constraints search control techniques
coarsely divided three main categories move ordering search extensions reductions
time allotment one earlier works dynamic move ordering history heuristic technique schaeffer recent attempts include work training neural networks kocsis exist large variety techniques adjusting search horizon


fib ulitko l u strek chaeffer b j ornsson igmundarson

different branches within game tree interesting continuations explored deeply
less promising ones terminated prematurely whereas early techniques
static focus shifted towards dynamic control well machine learning
approaches automatic parameterization buro bjornsson marsland best
knowledge none techniques applied single agent real time search

intuition dynamic search control
observed literature common heuristic functions uniformly inaccurate pearl namely tend accurate closer goal state less accurate
farther away intuition fact follows heuristic functions usually ignore certain constraints search space instance manhattan distance heuristic sliding tile puzzle
would perfectly accurate tiles could pass likewise euclidian distance
map ignores obstacles closer state goal fewer constraints heuristic function
likely ignore accurate e closer optimal solution cost
heuristic likely
intuition motivates adaptive search control real time heuristic search first heuristic values inaccurate agent conduct deeper lookahead search compensate
inaccuracies maintain quality actions deeper lookaheads generally found
beneficial real time heuristic search korf though lookahead pathologies e detrimental
effects deeper lookaheads action quality observed well bulitko li greiner
levner bulitko b lustrek lustrek bulitko illustration consider
figure every state map shaded according minimum lookahead depth
lrta agent use select optimal action darker shades correspond deeper lookahead
depths notice many areas bright white indicating shallowest lookahead depth
one sufficient use intuition first control mechanism dynamic selection
lookahead depth section

figure partial grid world map computer game baldurs gate bioware corp
shades grey indicate optimal search depth values white representing one ply
completely black cells impassable obstacles e g walls


fidynamic c ontrol r eal ime h euristic earch

dynamic search depth selection helps eliminate wasted computation switching shallower
lookahead heuristic function fairly accurate unfortunately help
heuristic function grossly inaccurate instead calls deep lookahead order select
optimal action deep search tremendously increases time sometimes leads
violating real time cut time per move address issue section
propose second control mechanism dynamic selection subgoals idea straightforward
far goal leads grossly inaccurate heuristic values let us move goal closer
agent thereby improving heuristic accuracy computing heuristic function
respect intermediate thus nearby goal opposed distant global goal
final destination agent since intermediate goal closer global goal heuristic
values states around agent likely accurate thus search depth picked
first control mechanism likely shallower agent gets intermediate goal
next intermediate goal selected agent makes progress towards actual global goal

dynamic search depth selection
first define optimal search depth follows sglobal goal state pair true optimal action sglobal goal take edge lies optimal path sglobal goal
one optimal action sglobal goal known run series progressively
deeper lrta searches state shallowest search depth yields sglobal goal
optimal search depth sglobal goal may search depth forfeit lrta real time
property impractical compute thus following subsections present two
different practical approaches approximating optimal search depth equips lrta
dynamic search depth selection e realizing first part line figure first
uses decision tree classifier select search depth features agents
current state recent history second uses pre computed depth database
automatically built state abstraction
decision tree classifier
effective classifier needs input features useful predicting optimal search
depth efficiently computable agent real time features use
classifier selected compromise two considerations well domain independent features calculated properties states agent recently
visited well features gathered shallow pre search agents current state example
features distance state agent n steps ago estimate distance
agents goal number states visited pre search phase updated heuristics
appendix features listed rationale behind explained
classifier predicts optimal search depth current state optimal depth
shallowest search depth returns optimal action training classifier must thus label
training states optimal search depths however avoid pre computing optimal actions
make simplifying assumption deeper search yields better action consequently
training phase agent first conducts lookahead search pre defined maximum depth dmax
derive optimal action assumption choice maximum depth domain
dependent would typically set largest depth still guarantees search return
within acceptable real time requirement task hand series progressively


fib ulitko l u strek chaeffer b j ornsson igmundarson

shallower searches performed determine shallowest search depth ddt still returns
optimal action process given depth action returned differs
optimal action progression stopped enforces depths ddt dmax
agree best action important improving overall robustness classification
classifier must generalize large set states depth ddt set class label
vector features describing current state
classifier choosing lookahead depth lrta augmented
line figure overhead classifier consists time required collecting
features running classifier overhead negligible classifier
implemented handful nested conditional statements collecting features takes
somewhat time careful implementation overhead made negligible
well indeed four history features efficiently computed small constant time
keeping lookahead depth pre search small e g one two overhead collecting
pre search features usually dwarfed time phase e lookahead search
takes process gathering training data building classifier carried line
time overhead thus lesser concern
pattern database
nave would precompute optimal depth sgoal state pair
two first sgoal priori upper bounded independently
map size thereby forfeiting lrta real time property second pre computing sgoal
sgoal pairs sgoal states instance cell computer game map
prohibitive time space complexity solve first capping sgoal
fixed constant c henceforth called cap solve second automatically built abstraction original search space entire map partitioned regions
abstract states single search depth value pre computed pair abstract states run time single search depth value shared children abstract state pair figure
search depth values stored table refer pattern database pdb
short past pattern databases used store approximate heuristic values culberson
schaeffer important board features schaeffer work appears first
use pattern databases store search depth values
computing search depths abstract states speeds pre computation reduces memory
overhead important considerations commercial computer games use
previously published clique abstraction sturtevant buro preserves overall topology
map requires storing abstraction links explicitly clique abstraction works
finding fully connected subgraphs e cliques original graph abstracting states
within clique single abstract state two abstract states connected abstract
action single original action leads state first clique
state single clique figure costs abstract actions computed euclidean
distances average coordinates states cliques
typical grid world computer game maps single application clique abstraction reduces
number states factor two four average abstraction level five e
five applications abstraction procedure region contains one hundred original
alternative use regular rectangular tiles e g botea et al



fidynamic c ontrol r eal ime h euristic earch

figure single optimal lookahead depth value shared among children abstract state
memory efficient approximation true per ground state values figure

level original graph

level

level

figure two iterations clique abstraction procedure produce two abstract levels
ground level search graph
ground level states thus single search depth value shared among ten thousand
state pairs five level clique abstraction yields four orders magnitude reduction
memory two orders magnitude reduction pre computation time analyzed later
downside higher levels abstraction effectively make search depth selection less
less dynamic depth value shared among progressively states abstraction
level pattern database control parameter trades pre computation time pattern
database size line performance uses database
two alternatives storing optimal search depth store optimal action optimal
heuristic value combination abstraction real time search precludes indeed
sharing optimal action computed single ground level representative abstract region
among states region may cause agent run wall figure left likewise
sharing single heuristic value among states region leaves agent without sense


fib ulitko l u strek chaeffer b j ornsson igmundarson


g





























g

figure goal shown g agent abstract states four tiles separated dashed lines
diamonds indicate representative states tile left optimal actions shown
representative abstract tile applying optimal action agents tile
agents current location leads wall right optimal heuristic value h lower
left tiles representative state shared among states tile
agent preference among three legal actions shown
direction states vicinity would look equally close goal figure right
contrast sharing heuristic value among states within abstract state known pattern
optimal non real time search ida culberson schaeffer
case real time search agents alternative guaranteed reach
goal let alone minimize travel contrary sharing search depth among number
ground level states safe lrta complete search depth
compute single depth table per map line figure line state space abstracted times lines iterate pairs abstract states pair goal
representative ground level states sgoal e ground level states closest centroids regions picked optimal search depth value calculated dijkstras
dijkstra run ground level search space v e compute true
minimal distances state sgoal distances known successors
optimal action sgoal computed greedily optimal search depth sgoal
computed previously described capped c line resulting value stored pair
abstract states goal line figures optimal search depth values single
goal state grid world game map without abstraction respectively
run time lrta agent going state state sgoal takes search depth
depth table value pair goal goal images sgoal level
abstraction additional run time complexity minimal goal goal computed
small constant time overhead action
building pattern database dijkstras run v times graph v e
time complexity v v log v e sparse graphs e e v optimal
search depth computed v times time c lrta invocations total
brevity use v e mean sets vertices edges sizes e v e



fidynamic c ontrol r eal ime h euristic earch

buildpatterndatabase v e c
apply abstraction procedure times v e compute abstract space v e
pair states goal v v

select v representative v

select sgoal v representative goal v

compute c capped optimal search depth value state respect goal sgoal

store capped pair goal
end
figure pattern database construction
complexity bc b maximum degree v thus overall time complexity
v v log v e v bc space complexity lower store optimal search depth
values pairs abstract states v table lists bounds sparse graphs
table reduction complexity due state abstraction

time
space

abstraction
v log v
v

level abstraction
v v log v
v

reduction
v v
v v

discussion two approaches
selecting search depth pattern database two advantages first search depth values
stored pair abstract states optimal non abstract representatives unless
value capped states local search space visited heuristic values modified conditional optimality contrast classifier
optimal actions ever computed deeper searches merely assumed lead
better action assumption hold phenomenon known lookahead pathology found abstract graphs bulitko et al well grid pathfinding lustrek
bulitko second advantage need features current state recent
history pre search search depth retrieved depth table simply basis
current states identifier coordinates
decision tree classifier two advantages depth table first
classifier training need happen search space agent operates
long training maps used collect features build decision tree representative
run time maps run never seen maps e g user created maps
computer game second much smaller memory overhead method
classifier specified procedurally pattern database needs loaded memory
note approaches assume structure heuristic search
hand namely pattern database shares single search depth value across region
states works effectively states region indeed lookahead
depth best abstraction mechanism forms regions basis search
graph structure regard search depth empirical study clique abstraction


fib ulitko l u strek chaeffer b j ornsson igmundarson

seems right choice pathfinding however choice best abstraction technique
general heuristic search open question
similarly decision tree assumes states share similar feature values
share best search depth value appears hold large extent pathfinding domain
feature selection arbitrary heuristic search open question well

dynamic goal selection
two methods described allow agent select individual search depth state
however original lrta heuristic still computed respect global goal
sgoal illustrate figure map partitioned eight abstract states case
square tiles whose representative states shown diamonds optimal path
agent goal g shown well straight line distance heuristic ignore
wall agent goal lead agent south western direction lrta
search depth higher needed produce optimal action thus
cap value agent left suboptimal action spend long time
horizontal wall raising heuristic values spending large amounts time corners
heuristic depressions primary weakness real time heuristic search agents
example remedied dynamic search depth selection due cap













g







figure goal shown g agent abstract states eight tiles separated dashed
lines diamonds indicate ground level representative tile optimal path
shown entry points path abstract states marked circles

compute sintermediate goal goal sgoal
b compute capped optimal search depth value respect sintermediate goal
store sintermediate goal pair goal
figure switching sgoal sintermediate goal replaces lines figure


fidynamic c ontrol r eal ime h euristic earch

figure three maps used experiments
address issue switch intermediate goals pattern database construction well
line lrta operation example figure compute heuristic around
respect intermediate goal marked double border circle map consequently
eleven times shallower search depth needed optimal action towards next abstract state
right upper tile replaces lines figure figure line
compute intermediate goal sintermediate goal ground level state optimal path
sgoal enters next abstract state entry points marked circles figure
compared entry states centroids abstract states intermediate goals bulitko et al
found former superior terms performance note optimal path
easily available line run dijkstras section
intermediate goal computed line b computes capped optimal search depth
respect intermediate goal sintermediate goal depth computation done described
section search depth intermediate goal added pattern database
line run time agent executes lrta stored search depth computes
heuristic h respect stored goal e sgoal set sintermediate goal line figure
words search depth agents goal selected dynamically per action
works heuristic functions used practice tend become accurate states closer goal state therefore switching distant global goal nearby
intermediate goal makes heuristics around current state accurate leads shallower search depth necessary achieve optimal action
run quickly shallower search per move search depth cap reached less
frequently therefore search depth values actually optimal moves

empirical evaluation
section presents empirical evaluation dynamic control search
depth goals classic state art published avoid reexpanding states move via transposition table report sub optimality
solution found average amount computation per action expressed number
states expanded believe implemented way single
expanded state takes amount time case testbed code
optimized reason avoid clutter report cpu times
section used fixed tie breaking scheme real time


fib ulitko l u strek chaeffer b j ornsson igmundarson

use grid world maps computer game testbed game maps provide realistic
challenging environment real time search seen number recent publications e g nash daniel felner hernandez meseguer original maps
sized cells figure line sturtevant buro sturtevant
jansen experimented maps upscaled closer size
maps used modern computer games note three maps depicted figure
outdoor type maps ran preliminary experiments indoor type game maps e g one
shown figure trends similar decided focus larger outdoor maps
search defined three original size maps start
goal locations chosen randomly although constrained optimal solution paths cost
order generate difficult instances upscaled maps
upscaled well data point plots average
maps runs different legend entry used multiple points
legend entry represent alternative parameter instantiation
heuristic function used octile distance natural extension manhattan distance maps
diagonal actions enforce real time constraint disqualified parameter settings
caused expand states move points
excluded empirical evaluation maps known priori line order build
decision tree classifiers pattern databases
use following notation identify variants algorithmname
x x defined follows x denotes search depth control f fixed search
depth dt search depth selected dynamically decision tree oracle search depth
selected decision tree oracle see next section details pdb search depth
selected dynamically pattern databases denotes goal state selection g heuristic
computed respect single global goal pdb heuristic computed respect
intermediate goal pattern databases instance classic lrta lrta f g
empirical evaluation organized eight parts follows section describes six
compute heuristic respect global goal discusses performance
section describes five use intermediate goals section compares global
intermediate goals section studies effects path refinement without dynamic
control secton pits state art real time non real time
provide selection guide different time limits per
move section finally section considers issue amortizing line pattern database
build time line pathfinding
global goals
subsection describe following compute heuristic respect
single global goal e use intermediate goals
lrta f g learning real time korf action conducts breadthfirst search fixed depth around agents current state first move towards
best depth state taken heuristic agents previous state updated
korfs mini min rule used
instead lrta could used rta experiments showed grid pathfinding
significant performance difference two search depth beyond one indeed deeper searches



fidynamic c ontrol r eal ime h euristic earch

lrta dt g lrta search depth dynamically controlled decision
tree described section used following parameters dmax
history trace length n building decision tree classifier weka witten frank pruning factor set minimum number data items
per leaf original size maps upscaled ones opposed learning
tailor made classifier game map single common decision tree classifier built
data collected maps fold cross validation done
demonstrate ability classifier generalize across maps
lrta oracle g lrta search depth dynamically controlled
oracle oracle selects best search depth produce move given
lrta f g fixed lookahead depth dmax bulitko et al words
oracle acts perfect decision tree thus sets upper bound lrta dt g
performance oracle run dmax original size
maps proved prohibitively expensive compute upscaled maps note
practical real time used reference point experiments
lrta pdb g lrta search depth dynamically controlled
pattern database described section original size maps used abstraction
level depth cap c upscaled maps
used abstraction level depth cap c
considering size maps cap value means virtually capless search
k lrta f g variant lrta proposed koenig unlike original
lrta uses shaped lookahead search space updates heuristic values states
within dijkstras number states k lrta expands per move
took values
p lrta f g prioritized lrta variant lrta proposed rayner davison
bulitko anderson lu uses lookahead depth moves however
every state whose heuristic value updated neighbors put onto update queue
sorted magnitude update thus propagates heuristic function
updates space fashion prioritized sweeping moore atkeson
control parameter queue size set original
size maps upscaled maps
figure evaluate performance dynamic depth selection
original size maps see decision tree pattern database improve
significantly upon lrta expanding two three times fewer states generating
solutions comparable quality furthermore perform par current state art realtime search without abstraction seen compared k lrta f g
solutions generated acceptable quality domain e g suboptimal even
expanding states per action interest decision tree performs
likelihood multiple actions equally low g h cost high reducing distinction rta
lrta lrta agents learn repeated trials
experimented shaped lookahead found inferior breadth first lookahead deeper searches



fib ulitko l u strek chaeffer b j ornsson igmundarson

original size maps

realtime cutoff


lrta f g
lrta oracle g
lrta dt g
lrta pdb g
p lrta f g
k lrta f g

suboptimality times
















mean number states expanded per move





figure global goal original size maps
quite close theoretical best case seen compared lrta oracle g
shows features use although seemingly simplistic good job predicting
appropriate search depth
ran similar sets experiments upscaled maps however none global goal
generated solutions acceptable quality given real time cut solutions
suboptimal experimental upscaled maps provided
appendix b shows inherent limitations global goal approaches large search
spaces cannot compete equal footing abstraction methods brings us
intermediate goal selection methods
intermediate goals
section describe use intermediate goals search best
knowledge one previously published real time heuristic search
thus compare proposed given intermediate
goals increase performance significantly present
challenging upscaled maps full roster used section follows
pr lrta f g path refinement learning real time search bulitko et al
two components runs lrta fixed search depth global
goal abstract space abstraction level clique abstraction hierarchy refines
first move corridor constrained running original ground level map
constraining small set states collectively called corridor sturtevant buro
actually called pr lrts bulitko et al findings lustrek bulitko
modified refine single abstract action order reduce susceptibility lookahead pathologies
modification equivalent substituting lrts component lrta hence rest
call pr lrta



fidynamic c ontrol r eal ime h euristic earch

tunnel furcy speeds makes real time corridor size
independent map size bulitko sturtevant kazakevich heuristic
computed abstract space respect fixed global goal component
computes path current state intermediate goal qualifies pr lrta
enter section empirical evaluation control parameters follows abstraction
level lrta lookahead depth lrta heuristic
weight imposed g line figure
lrta f pdb lrta fixed search depth uses pattern database select
intermediate goals control parameters follows abstraction level
search depth
lrta pdb pdb lrta generalized dynamic search depth intermediate goal selection pattern databases presented sections control parameters follows abstraction level lookahead cap
c
pr lrta pdb g pr lrta whose lrta component equipped dynamic search depth uses global abstract goal respect computes abstract heuristic pattern database search depth constructed
abstraction level lrta component runs making component optimal lookahead cap allows used abstraction level
lookahead cap c
ran version pr lrta pdb g pattern database constructed abstraction level level lrta operates table used

pr lrta pdb pdb two database version pr lrta pdb g
except uses second database goal selection well depth selection used
table
table pr lrta pdb g pdb uses lrta abstraction level define corridor within
refines path dynamic depth goal selection performed
abstraction level
abstraction level




single abstraction pr lrta pdb g
abstract level lrta
dynamic depth selection
corridor constrained ground level

dual abstraction pr lrta pdb g pdb
dynamic depth goal selection
abstract level lrta
corridor constrained ground level

pattern database presented stores depth value intermediate
ground level goal pair abstract states present performance
intermediate goals sections analyze complexity pattern database
computation effects performance section


fib ulitko l u strek chaeffer b j ornsson igmundarson

upscaled maps

realtime cutoff


lrta f g
lrta f pdb



suboptimality times



















mean number states expanded per move





figure effects intermediate goals lrta f g versus lrta f pdb

global versus intermediate goals
sections presented global intermediate goals respectively
section compare across two groups include lrta pdb g increased
real time cut graphs section start baseline lrta fixed lookahead effects adding intermediate goal selection dramatic
lrta intermediate goals f pdb finds five times better solutions three orders
magnitude faster lrta global goals f g see figure believe
octile distance heuristic substantially accurate around goal consequently
lrta f pdb benefiting much better heuristic function
second experiment equip versions dynamic search depth control compare lrta pdb g lrta pdb pdb figure performance gap less
dramatic speed still around three orders magnitude suboptimality
advantage went five two times note increase real time
cut order magnitude get points plot
finally evaluate beneficial dynamic depth control dynamic goal control
comparing baseline lrta f g lrta pdb g lrta f pdb figure
clear dynamic goal selection much stronger addition baseline lrta dynamic
search depth selection dynamic depth selection sometimes actually performs worse fixed
depth evidenced data points lrta f g line happens primarily
high abstraction levels small caps optimal lookahead depth computed high
abstraction level depth value shared among many ground level states selected
depth value beneficial near entry point abstract state abstract state
large depth likely become inappropriate ground level states away
example optimal depth entry point worse moderate fixed depth


fidynamic c ontrol r eal ime h euristic earch

upscaled maps

realtime cutoff
lrta pdb g
lrta pdb pdb



suboptimality times

















mean number states expanded per move





figure effects intermediate goals lrta pdb g versus lrta pdb pdb
upscaled maps

realtime cutoff


lrta f g
lrta f pdb
lrta pdb g



suboptimality times



















mean number states expanded per move





figure dynamic search depth control versus dynamic goal control

ground level states far entry point small caps compound sometimes
preventing selection optimal depth even entry point
shown plot running e lrta pdb pdb leads marginal improvements best parameterizations lrta f pdb already expands
single state per move virtually times consequently benefit adding dynamic
depth control slight improvement suboptimality next section


fib ulitko l u strek chaeffer b j ornsson igmundarson

upscaled maps

realtime cutoff


lrta f pdb
lrta pdb pdb
pr lrta f g
pr lrta f pdb
pr lrta pdb pdb
pr lrta pdb g

suboptimality times

















mean number states expanded per move





figure effects path refinement lrta versus pr lrta
effects path refinement
path refinement denoted pr prefix run learning real time search lrta
abstract space refine path running ground level non pr run
real time search happens ground level space examine effects pathrefinement comparing lrta pr lrta note even statically controlled baseline
pr lrta f g uses intermediate goals refining abstract actions match
dynamic intermediate goal selection lrta thus compare four versions pr lrta f
g pdb g f pdb pdb pdb two versions lrta f pdb pdb pdb
found figure sake clarity high performance area
capping number states expanded per move suboptimality
best parameterizations lrta near optimal solutions expanding one state
per move virtually times astonishing performance one state expansion per
move corresponds search depth one fastest possible operation
framework thus lrta f pdb lrta pdb pdb virtually unbeatable terms
time hand pr lrta incurs overhead due path refinement
component e running corridor constrained pr lrta finds nearlyoptimal solutions incurs least five times higher cost per move dynamic control
pr lrta moderate performance gains
comparison existing state art
traditionally computer games used pathfinding needs stout map size
number simultaneously agents increase game developers even highly optimized
implementations insufficient variants use state abstraction
used sturtevant another way speeding introduce weight computing travel
cost state done f g h values make agent


fidynamic c ontrol r eal ime h euristic earch

greedy weight put h usually leads fewer states expanded price
suboptimal solutions section compare weighted korf
state art partial refinement pra sturtevant buro note neither
real time thus times per move map size specific
larger maps pra times per move increase compute
complete abstract path start goal states take first move instance
maps used pra expands states expensive move weighted
expands states classic expands states worst moves thus
include two comparison effectively remove real time cut
found table dynamically controlled lrta one two orders magnitude faster average time per move produces shorter paths existing stateof art real time pr lrta fastest weighted tried original
provably optimal solution quality pra nearly optimal argue hundreds
units simultaneously paths computer game lrta pdb pdb low time per move real time guarantees worth path length suboptimality e g
screen pixels versus optimal screen pixels

table comparison high performance best values bold standard errors
reported
parameters
pr lrta f g
lrta pdb pdb c

weighted f g h
pra

per move






suboptimality times






best solution quality time limit
section identify deliver best solution quality time limit
specifically impose hard limit time per move expressed number states
expanded exceeds limit even single move made
upscaled maps excluded consideration among remaining
select one highest solution quality e lowest suboptimality found
table expand least one state per move move leaving first row
empty lrta f pdb best choice time limit one
eight states expanded per move limit rises expensive optimal
become affordable note best choices dynamically controlled
time limit rises states point non real time pra takes ending domain
real time cross point specific map sizes larger
maps pra maximum time per move necessarily increase making
best choice progressively higher time per move limits


fib ulitko l u strek chaeffer b j ornsson igmundarson

table best solution quality strict limit time per move time
states expanded per move sake readability suboptimality shown
percentage e g
time limit













parameters
lrta f pdb
lrta f pdb
lrta f pdb
lrta f pdb
lrta f pdb
lrta f pdb
pr lrta pdb g c
pr lrta pdb g c
pr lrta pdb g c
pra


suboptimality












amortization pattern database build time
pattern database invests time computing pdb map section
study amortization line investment multiple instances pdb build
times ghz pentium cpu listed table single map consider lrta
pdb pdb cap c pattern databases built level average
solution suboptimality expanding states per move microseconds
closest statically controlled competitor pr lrta f g
suboptimality expanding average states per move microseconds thus lrta pdb pdb microseconds faster move consequently
moves necessary recoup line pdb build time hours move
taking microseconds lrta lower total run time first four hours
pathfinding computed recoup times parameterizations lrta pdb pdb
whose closest statically controlled competitor slower per move found table
demonstrate lrta pdb pdb recoups pdb build time first hours
pathfinding time note numbers highly implementation domain specific particular code building pdbs leaves substantial room optimization completeness
sake report detailed times appendix c

discussion empirical
section recap trends observed previous sections dynamic selection
lookahead decision tree pdb helps reduce time per move
well solution suboptimality section lrta becomes competitive
modern koenigs lrta however real time search global goals
scale well large maps


fidynamic c ontrol r eal ime h euristic earch

table pattern database average map computed intermediate goals database
size listed number abstract state pairs suboptimality per move
listed representative lrta pdb pdb cap c
abstraction level









size









time
est years
est months
est days
hours
hours
hour
minutes
minutes

per move






suboptimality times






table amortization pdb build times dynamically controlled lrta list
statically controlled pr lrta closest terms solution suboptimality
lrta pdb pdb
c
c
c
c
c
c
c
c

pr lrta f g









amortization moves









amortization run time
hours
hours
hours
hours
hours
hours
hours
hours

adding intermediate goals brings even classic lrta par previous state theart real time search pr lrta much stronger addition dynamic lookahead
depth selection section dynamic lookahead depth subgoals brings
improvements section details lrta equipped dynamic lookahead depth
subgoal selection expands barely state per move less solution suboptimality
better previous state art pr lrta pra
solution quality time per move believe trade offs makes appealing
practice aid practitioners provide selection guide section
makes clear lrta dynamic subgoal selection best time
per move severely limited speed advantage deliver state art pr lrta
allows recoup pdb build time several hours pathfinding

current limitations future work
project opens several interesting avenues future particular would worthwhile investigate performance dynamic environments e g
bridge gets destroyed real time strategy game goal moves away agent


fib ulitko l u strek chaeffer b j ornsson igmundarson

another area future application proposed general
heuristic search successful planners asp bonet
loerincs geffner hsp family bonet geffner hoffmann
sherpa koenig furcy bauer ldfs bonet geffner line recent
work likhachev koenig bonet geffner evaluate
proposed general strips style nevertheless believe
real time heuristic search may offer benefits wider range
indeed core heuristic search extended lrta previously applied general bonet et al extensions introduced may
beneficial effect similar way b lrta improved performance asp planner
subgoal selection long studied central part intermediate goal
depth table decision trees search depth selection induced sample trajectories space appear scalable general part
requires solving numerous ground level optimally pre computation
optimal search depth pdb conjecture still effective
instead computing optimal search depth optimal action one solve
relaxed use resulting action place idea deriving heuristic
guidance solving relaxed quite common heuristic search
community

conclusions
real time pathfinding non trivial must trade solution quality
amount per move two measures antagonistic thus interested
pareto optimal outperformed measures
classic lrta provides smooth trade curve parameterized lookahead depth since
introduction variety extensions proposed recent extension
pr lrts bulitko et al first application automatic state abstraction real time
search large scale empirical study pathfinding game maps pr lrts outperformed
many respect several antagonistic measures bulitko et al
employ automatic state abstraction instead pathrefinement pre compute pattern databases use select amount
intermediate goals dynamically per move several mechanisms dynamic control proposed used virtually existing real time search demonstration
equip classic lrta state art pr lrts dynamic control
resulting improvements substantial instance lrta equipped pdb control
lookahead intermediate goal selection significantly outperforms existing state art pr
lrts simultaneously per move solution quality furthermore average expands little one state per move minimum amount
lrta
compare favorably state art extension pra
presently popular industrial choices pathfinding computer games stout sturtevant
first per move time provably unaffected increase
map size second two orders magnitude faster one order magnitude
faster pra time per move improvements come price


fidynamic c ontrol r eal ime h euristic earch

suboptimality likely unnoticed computer game player scenarios thus appears
redefine state art real time search arena
well suited industrial applications

acknowledgments
sverrir sigmundarson school computer science reykjavik university
project appreciate consultation robert c holte detailed feedback anonymous
reviewers supported grants national science engineering council canada nserc albertas informatics circle excellence icore
slovenian ministry higher education science technology icelandic centre
rannis marie curie fellowship european community programme structuring
era contract number mirg ct special thanks nathan sturtevant
development support hog

appendix decision tree features
devised two different categories classifier features first consists features
agents recent history whereas second contains features sampled shallow pre search
agents current state thus collectively features two categories make predictions
agents recent history well current situation
first category four features listed table features computed
execution step aggregated recent states agent
done incremental fashion improved performance parameter n set user
controls long history aggregate use notation refer state agent
one step ago state two steps ago etc agent thus aggregates states
sn feature f provides rough estimate location agent relative goal
distance goal state affect required lookahead depth example heuristics
closer goal usually accurate feature makes possible classifier make
decisions deemed necessary features f known mobility f provide
measure much progress agent made towards reaching goal past steps
frequent state revisits may indicate heuristic depression deeper search usually beneficial
situations ishida feature f measure inaccuracies inconsistencies
heuristic around agent many heuristic updates may warrant deeper search
features second category listed table computed execution step phase starts shallow lookahead pre search performed gather
information nearby part search space types features category
coarsely divided features compute fraction states pre search lookahead
frontier satisfy property ii compare action chosen pre search previous
actions previous state taken last time current state visited iii
check heuristic estimates immediate successors current state feature f rough
measure density obstacles agents vicinity obstacles
beneficial deeper search might feature f indicator difficulty traversing
local area proportion high many states updated possibly suggesting heuristic
depression feature f pre search selects action might indicate


fib ulitko l u strek chaeffer b j ornsson igmundarson

table history classifier features
feature
f
f
f
f

description
initial heuristic estimate distance current state goal
hoctile sglobal goal
heuristic estimate distance current state state
agent n steps ago h sn
number distinct states agent visited last n steps
sn
p
total heuristic updates last n steps ni hafter update si
hbefore update si line figure
table pre search classifier features

feature
f
f
f

f
f
f
f

description
ratio actual number states pre search frontier expected
number states obstacles map
fraction frontier states updated heuristic value
boolean feature telling whether action chosen pre search
action chosen phase last time state visited
first time state visited feature false
boolean feature telling whether direction suggested pre search
direction agent took previous step
ratio current states heuristic best successor state suggested
pre search h sgoal h sgoal
boolean feature telling whether best action proposed pre search phase
would lead successor state updated heuristic value
boolean feature telling whether heuristic value current state larger
heuristic value best immediate successor found pre search

heuristic values part search space already mutually consistent thus
shallow lookahead needed applies feature f features f f compare current
state successor state suggested pre search

appendix b experiments upscaled maps global goals
empirical running global goal upscaled maps shown figure
lrta dt g shows significant improvement lrta f g making comparable
quality existing state art par p lrta f g slightly better
k lrta f g allowed expand states per move worth noting
lrta pdb g longer competitive fact make
real time cut states parameters combinations thus shown
plot reason lies fact simply difficult lrta
optimal move small lookahead depth instance abstraction level cap


fidynamic c ontrol r eal ime h euristic earch

c lrta pdb g suboptimality unfortunately lookahead depth hits cap
visited states expands average states per move
disqualifies cut
upscaled maps

realtime cutoff


lrta f g
lrta dt g
p lrta f g
k lrta f g



suboptimality times



















mean number states expanded per move





figure performance global goal upscaled maps
looking collectively small upscaled map lrta dt g demonstrates
excellent performance among global goal robust respect map
upscaling one efficient ones comparable k lrta f g
however within provided states cut limit none real time global goal
returned solutions would considered acceptable quality pathfinding indeed even
best solutions found approximately four times worse optimal

appendix c pattern database build times
order operate lrta pr lrta use lookahead depth intermediate goals controlled dynamically build pattern databases pattern database built line contains
single entry pair abstract states three types entries intermediate goal
ground level entry state next abstract state ii capped optimal lookahead depth
respect intermediate goal iii optimal lookahead depth respect global
goal running capped lookaheads e c need two databases
per map one containing intermediate goals one containing capped optimal lookahead depths
running effectively uncapped e c c need third
database lookahead depths global goals see appendix discussion tables
report build times lrta pdb pdb performance capped e
build two pattern databases tables report build times performance
effectively cap e built three pattern databases
finally interest speeding experiments fact compute pattern databases
pairs abstract states instead took advantage prior benchmark availability


fib ulitko l u strek chaeffer b j ornsson igmundarson

table pattern databases average map computed intermediate goals
database size listed number abstract state pairs suboptimality
per move listed lrta pdb pdb cap c
abstraction level









size









time
est years
est months
est days
hours
hours
hours
minutes
minutes

per move






suboptimality times






table pattern databases average map computed intermediate goals
database size listed number abstract state pairs suboptimality
per move listed lrta pdb pdb cap c
abstraction level









size









time
est years
est months
est days
hours
hours
hours
minutes
minutes

per move






suboptimality times






computed pdbs abstract goal states come play agents
solve thus times tables estimates possible pairs

appendix intermediate goals loops
shown korf original lrta complete lookahead depth
heuristic taken respect single global goal completeness guarantee lost one
uses intermediate goals e lrta f pdb lrta pdb pdb well pr lrta
counter parts indeed abstract tile dynamic goal control module guide
agent towards entry state tile b however way agent may stumble different
abstract tile c soon happens dynamic control module may select entry state tile
intermediate goal unsuspecting agent heads back everything repeats
combat loops equipped use intermediate goals state reentrance detector namely soon agent visits ground level state dynamic control
switches intermediate goal global goal additionally lookahead depth selected ideally lookahead depth optimal depth respect global goal


fidynamic c ontrol r eal ime h euristic earch

table pattern databases average map computed intermediate goals
database size listed number abstract state pairs suboptimality
per move listed lrta pdb pdb cap c
abstraction level









size









time
est years
est months
est days
hours
hours
hours
minutes
minutes

per move






suboptimality times






table pattern databases average map computed intermediate goals
database size listed number abstract state pairs suboptimality
per move listed lrta pdb pdb cap c
abstraction level









size









time
est years
est months
est days
hours
hours
hours
minutes
minutes

per move






suboptimality times






capped c unfortunately computing optimal lookahead depths global goals quite expensive
line tables given loops occur fairly infrequently normally compute
optimal lookahead depths global goals instead state visit detected switch
global goals simply set lookahead cap c saves line pdb computation time
sometimes causes agent conduct deeper search c plies really necessary
alternative solution investigated future progressively increase lookahead line visits detected e every time visit occurs lookahead depth
state increased certain number plies

exception practice cases c c setting lookahead depth c
would immediately disqualified provided reasonable real time cut consequently
two cap values invest large amount time computed effectively uncapped optimal lookahead depth
respect global goals



fib ulitko l u strek chaeffer b j ornsson igmundarson

table pattern databases average map computed global goals database
size listed number abstract state pairs suboptimality per move
listed lrta pdb pdb cap c
abstraction level









size









time
est years
est years
est years
days
days
days
hours
hours

per move






suboptimality times






table pattern databases average map computed global goals database
size listed number abstract state pairs suboptimality per move
listed lrta pdb g cap c
abstraction level









size









time
est years
est months
est days
hours
hours
hours
minutes
minutes



per move






suboptimality times






fidynamic c ontrol r eal ime h euristic earch

references
bioware corp baldurs gate published interplay http www bioware com bgate
november
bjornsson marsland learning extension parameters game tree search inf
sci
blizzard warcraft reign chaos http www blizzard com war
bonet b geffner h heuristic search artificial intelligence

bonet b geffner h learning depth first search unified heuristic search
deterministic non deterministic settings application mdps proceedings
international conference automated scheduling icaps pp
cumbria uk
bonet b loerincs g geffner h fast robust action selection mechanism
proceedings national conference artificial intelligence aaai pp
providence rhode island aaai press mit press
botea muller schaeffer j near optimal hierarchical path finding journal
game development
bulitko v lookahead pathologies meta level control real time heuristic search
proceedings th euromicro conference real time systems pp porto
portugal
bulitko v b lookahead pathologies meta level control real time heuristic search
proceedings th euromicro conference real time systems pp
bulitko v learning adaptive real time search tech rep http arxiv org abs cs ai
computer science repository corr
bulitko v bjornsson lustrek schaeffer j sigmundarson dynamic control path real time heuristic search proceedings international
conference automated scheduling icaps pp providence ri
bulitko v li l greiner r levner lookahead pathologies single agent search
proceedings international joint conference artificial intelligence ijcai pp
acapulco mexico
bulitko v sturtevant n kazakevich speeding learning real time search via
automatic state abstraction proceedings national conference artificial intelligence aaai pp pittsburgh pennsylvania
bulitko v sturtevant n lu j yau graph abstraction real time heuristic
search journal artificial intelligence jair
buro experiments multi probcut high quality evaluation function
othello van den herik h j iida h eds games ai pp u
maastricht
culberson j schaeffer j searching pattern databases csci canadian ai
conference advances artificial intelligence pp springer verlag


fib ulitko l u strek chaeffer b j ornsson igmundarson

culberson j schaeffer j pattern databases computational intelligence

dijkstra e w note two connexion graphs numerische mathematik

furcy itsa iterative tunneling search proceedings national
conference artificial intelligence aaai workshop heuristic search memory
heuristics applications boston massachusetts
furcy koenig speeding convergence real time search proceedings
national conference artificial intelligence aaai pp
hart p nilsson n raphael b formal basis heuristic determination
minimum cost paths ieee transactions systems science cybernetics
hernandez c meseguer p improving convergence lrta k proceedings
international joint conference artificial intelligence ijcai workshop
learning priori unknown dynamic domains edinburgh uk
hernandez c meseguer p b lrta k proceedings th international joint
conference artificial intelligence ijcai edinburgh uk
hernandez c meseguer p improving real time heuristic search initially unknown
maps proceedings international conference automated scheduling
icaps workshop games p providence rhode island
hoffmann j heuristic domain independent use enforced hillclimbing proceedings th international symposium methodologies
intelligent systems ismis pp
id software doom published id software http en wikipedia org wiki doom december
ishida moving target search intelligence proceedings national conference
artificial intelligence aaai pp
kitano h tadokoro noda matsubara h takahashi shinjou shimada
robocup rescue search rescue large scale disasters domain autonomous agents
man systems cybernetics pp
kocsis l learning search decisions ph thesis university maastricht
koenig comparison fast search methods real time situated agents proceedings international joint conference autonomous agents multiagent systems
aamas pp
koenig agent centered search ai magazine
koenig furcy bauer c heuristic search replanning proceedings
int conference artificial intelligence scheduling pp
koenig likhachev real time adaptive proceedings international
joint conference autonomous agents multiagent systems pp
korf r depth first iterative deepening optimal admissible tree search artificial
intelligence


fidynamic c ontrol r eal ime h euristic earch

korf r real time heuristic search artificial intelligence
korf r linear space best first search artificial intelligence
likhachev ferguson gordon g stentz thrun anytime dynamic
anytime replanning proceedings international conference automated
scheduling icaps
likhachev gordon g j thrun ara anytime provable bounds
sub optimality thrun saul l scholkopf b eds advances neural information processing systems mit press cambridge
likhachev koenig generalized framework lifelong proceedings international conference automated scheduling icaps
pp
lustrek pathology single agent search proceedings information society conference pp ljubljana slovenia
lustrek bulitko v lookahead pathology real time path finding proceedings
national conference artificial intelligence aaai workshop learning search
pp boston massachusetts
mero l heuristic search modifiable estimate artificial intelligence

moore atkeson c prioritized sweeping reinforcement learning less data
less time machine learning
nash daniel k felner k theta angle path grids
proceedings national conference artificial intelligence pp
pearl j heuristics addison wesley
rayner c davison k bulitko v anderson k lu j real time heuristic search
priority queue proceedings international joint conference artificial
intelligence ijcai pp hyderabad india
russell wefald e right thing studies limited rationality mit press
schaeffer j history heuristic alpha beta search enhancements practice ieee
transactions pattern analysis machine intelligence pami
schaeffer j search ideas chinook van den herik h j iida h eds games
ai pp u maastricht
shimbo ishida controlling learning process real time heuristic search
artificial intelligence
sigmundarson bjornsson value back propagation vs backtracking realtime search proceedings national conference artificial intelligence aaai
workshop learning search pp boston massachusetts usa
stenz focussed real time replanning proceedings
international joint conference artificial intelligence ijcai pp
stout b basics path game programming gems charles river
media


fib ulitko l u strek chaeffer b j ornsson igmundarson

sturtevant n memory efficient abstractions pathfinding proceedings third
conference artificial intelligence interactive digital entertainment pp stanford california
sturtevant n buro partial pathfinding map abstraction refinement
proceedings national conference artificial intelligence pp
sturtevant n jansen r analysis map abstraction refinement
proceedings th international symposium abstraction reformulation approximation whistler british columbia
witten h frank e data mining practical machine learning tools techniques
nd edition morgan kaufmann san fransisco




