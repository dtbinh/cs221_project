Journal Artificial Intelligence Research 32 (2008) 37-94

Submitted 08/07; published 05/08

Extended RDF Semantic Foundation
Rule Markup Languages
Anastasia Analyti

analyti@ics.forth.gr

Institute Computer Science, FORTH-ICS, Crete, Greece

Grigoris Antoniou

antoniou@ics.forth.gr

Institute Computer Science, FORTH-ICS, Crete, Greece
Department Computer Science, University Crete, Greece

Carlos Viegas Damasio

cd@di.fct.unl.pt

Centro de Inteligencia Artificial, Universidade Nova de Lisboa,
Caparica, Portugal

Gerd Wagner

G.Wagner@tu-cottbus.de

Institute Informatics, Brandenburg University
Technology Cottbus, Germany

Abstract
Ontologies automated reasoning building blocks Semantic Web initiative. Derivation rules included ontology define derived concepts, based
base concepts. example, rules allow define extension class property, based
complex relation extensions classes properties.
hand, inclusion negative information form negation-asfailure explicit negative information needed enable various forms reasoning.
paper, extend RDF graphs weak strong negation, well derivation
rules. ERDF stable model semantics extended framework (Extended RDF)
defined, extending RDF(S) semantics. distinctive feature theory, based
Partial Logic, truth falsity extensions properties classes
considered, allowing truth value gaps. framework supports closed-world
open-world reasoning explicit representation particular closed-world assumptions ERDF ontological categories total properties total classes.

1. Introduction
idea Semantic Web describe meaning web data way suitable
automated reasoning. means descriptive data (meta-data) machine readable form stored web used reasoning. Due distributed
world-wide nature, Web creates new problems knowledge representation research.
Berners-Lee (1998) identifies following fundamental theoretical problems: negation
contradictions, open-world versus closed-world assumptions, rule systems Semantic Web. time being, first two issues circumvented discarding
facilities introduce them, namely negation closed-world assumptions. Though
web ontology language OWL (McGuinness & van Harmelen, 2004), based Description Logics (DLs) (Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003),
includes form classical negation class complements, form limited.
c
2008
AI Access Foundation. rights reserved.

fiAnalyti, Antoniou, Damasio, & Wagner

because, achieve decidability, classes formed based specific class constructors
negation properties fully considered. Rules constitute next layer
ontology languages Semantic Web and, contrast DL, allow arbitrary interaction
variables body rules. widely recognized need rules Semantic Web, demonstrated Rule Markup Initiative1 , restarted discussion
fundamentals closed-world reasoning appropriate mechanisms implement
rule systems.
RDF(S)2 recommendation (Klyne & Carroll, 2004; Hayes, 2004) provides basic constructs defining web ontologies solid ground discuss issues.
RDF(S) special predicate logical language restricted existentially quantified conjunctions atomic formulas, involving binary predicates only. Due purpose,
RDF(S) number special features distinguish traditional logic languages:
1. uses special jargon, things universe discourse called resources, types called classes, binary predicates called properties.
binary relations set theory, properties domain range. Resources
classified help property rdf :type (for stating resource type
c, c class).
2. distinguishes special sort resources, called literal values, denotations
lexical representations strings, numbers, dates, basic datatypes.
3. Properties resources, is, properties elements universe discourse. Consequently, possible state properties properties, i.e., make statements predicates.
4. resources, except anonymous ones literal values, named help
globally unique reference schema, called Uniform Resource Identifier (URI)3 ,
developed Web.
5. RDF(S) comes non-standard model-theoretic semantics developed Pat Hayes
basis idea Christopher Menzel, allows self-application without
violating axiom foundation. example provable sentence stating
rdfs:Class, class classes, instance itself.
However, RDF(S) support negation rules. Wagner (1991) argues
database, knowledge representation system, needs two kinds negation, namely weak
negation (expressing negation-as-failure non-truth) strong negation (expressing
explicit negative information falsity) able deal partial information.
subsequent paper, Wagner (2003) makes point Semantic Web,
framework knowledge representation general. present paper, make
argument Semantic Web language RDF show extended
accommodate two negations Partial Logic (Herre, Jaspars, & Wagner, 1999),
well derivation rules. call new language Extended RDF denote ERDF.
1. http://www.ruleml.org/
2. RDF(S) stands Resource Description Framework (Schema).
3. http://gbiv.com/protocols/uri/rfc/rfc3986.html

38

fiExtended RDF Semantic Foundation Rule Markup Languages

model-theoretic semantics ERDF, called ERDF stable model semantics, developed
based Partial Logic (Herre et al., 1999).
Partial Logic, relating strong weak negation interpretation level allows
distinguish four categories properties classes. Partial properties properties p
may truth-value gaps truth-value clashes, p(x, y) possibly neither true
false, true false. Total properties properties p satisfy totalness,
p(x, y) true false (but possibly both). Coherent properties properties p
satisfy coherence, p(x, y) cannot true false. Classical properties total
coherent properties. classical properties p, classical logic law applies: p(x, y)
either true false. Partial, total, coherent, classical classes c defined similarly,
replacing p(x, y) rdf :type(x, c).
Partial logic allows distinguish properties (and classes) completely represented knowledge base not. classification
property completely represented owner knowledge base:
owner must know properties complete information
not. Clearly, case completely represented (closed ) property p, entailment
p(x, y) allows derive p(x, y), underlying completeness assumption
called Closed-World Assumption (CWA) AI literature.
completeness assumption closing partial property p default may
expressed ERDF means rule p(?x, ?y) p(?x, ?y) partial class
c, means rule rdf :type(?x, c) rdf :type(?x, c). derivation rules
called default closure rules. case total property p, default closure rules
applicable. because, considered interpretations satisfy p(x, y)
rest p(x, y)4 , preventing preferential entailment p(x, y). Thus, total
properties, Open-World Assumption (OWA) applies. Similarly first-order-logic,
order infer negated statements total properties, explicit negative information
supplied, along ordinary (positive) information.
example, consider ERDF knowledge base KB contains facts:
interestedIn(Anastasia, SemanticWeb)

interestedIn(Grigoris, Robotics)

indicating Anastasia interested SemanticWeb area Grigoris interested
Robotics area. Then, statement interestedIn(Anastasia, Robotics) satisfied
single intended model KB . Thus, KB entails interestedIn(Anastasia, Robotics).
Assume previous list areas interest complete Anastasia
Grigoris. Then, add knowledge base KB statement:
rdf :type(interestedIn, erdf :TotalProperty)
indicating interestedIn total property. case, open-world assumption made interestedIn KB entail interestedIn(Anastasia, Robotics),
longer. particular, intended model revised KB satisfies
interestedIn(Anastasia, Robotics). course, known Anastasia interested
Robotics interestedIn(Anastasia, Robotics) added KB .
Assume add KB following facts:
4. total properties p, Law Excluded Middle p(x, y)p(x, y) applies.

39

fiAnalyti, Antoniou, Damasio, & Wagner

hasCar (Anastasia, Suzuki )

hasCar (Grigoris, Volvo)

assume KB complete knowledge property hasCar , far concerns
elements Herbrand Universe KB . Then, default closure rule hasCar (?x , ?y)
hasCar (?x , ?y) safely added KB . result, hasCar (Anastasia, Volvo)
satisfied intended models KB . Thus, KB entails hasCar (Anastasia, Volvo).
previous example shows need supporting closed-world open-world
reasoning framework. Damasio et al. (2006) Analyti et al. (2004) provide
examples arguments need. Unfortunately, classical logic thus
OWL support open-world reasoning.
Specifically, paper:
1. extend RDF graphs ERDF graphs inclusion strong negation,
ERDF ontologies (or ERDF knowledge bases) inclusion general
derivation rules. ERDF graphs allow express existential positive negative
information, whereas general derivation rules allow inferences based formulas built
using connectives , , , , quantifiers , .
2. extend vocabulary RDF(S) terms erdf :TotalProperty
erdf :TotalClass, representing metaclasses total properties total classes,
open-world assumption applies.
3. extend RDFS interpretations ERDF interpretations including truth
falsity extensions properties classes. Particularly, consider coherent
ERDF interpretations (imposing coherence properties). Thus, paper,
total properties classes become synonymous classical properties classes.
4. extend RDF graphs ERDF formulas built positive triples, using
connectives , , , , quantifiers , . Then, define ERDF
entailment two ERDF formulas, extending RDFS entailment RDF
graphs.
5. define ERDF models, Herbrand interpretations, minimal Herbrand
models ERDF ontology. Since minimal Herbrand models ERDF
ontology intended, define stable models ERDF ontology. definition
stable model based intuition that:
(a) assertions stating property p class c total accepted,
ontology contains direct support form acceptable
rule sequence,
(b) assertions []p(s, o) []rdf :type(o, c) accepted, (i) ontology contains direct support form acceptable rule
sequence, (ii) property p class c total, respectively.
6. show stable model entailment ERDF ontologies extends ERDF entailment
ERDF graphs, thus extends RDFS entailment RDF graphs. Moreover, show properties total, (boolean) Herbrand model reasoning
stable model reasoning coincide. case, make open-world assumption
properties classes.
40

fiExtended RDF Semantic Foundation Rule Markup Languages

distinctive feature developed framework respect Partial Logic (Herre
et al., 1999) properties classes declared total selective basis,
extending RDF(S) new built-in classes providing support respective ontological categories. contrast, Partial Logic (Herre et al., 1999), choice partial
total taken complete set predicates. Thus, approach presented
is, respect, flexible general.
work extends conference paper (Analyti, Antoniou, Damasio, & Wagner, 2005)
(i) considering full RDFS model, (ii) providing detailed characterization
properties ERDF interpretations/models, Herbrand interpretations/models, finally
ERDF stable models, (iii) discussing decidability issues, (iv) providing formal proofs
lemmas propositions.
rest paper organized follows: Section 2, extend RDF graphs
ERDF graphs ERDF formulas. Section 3 defines ERDF interpretations ERDF
entailment. show ERDF entailment extends RDFS entailment. Section 4,
define ERDF ontologies Herbrand models ERDF ontology. Section 5,
define stable models ERDF ontology. Section 6 defines stable model entailment,
showing extends ERDF entailment. Section 7, provide brief sketch
ERDF/XML syntax. Decidability issues ERDF stable model semantics discussed
Section 8. Section 9 shows developed ERDF model theory seen
Tarski-style model theory. Section 10 reviews related work Section 11 concludes
paper, including future work. main definitions RDF(S) semantics reviewed
Appendix A. Appendix B includes proofs lemmas propositions, presented
paper.

2. Extending RDF Graphs Negative Information
section, extend RDF graphs ERDF graphs, adding strong negation. Moreover, extend RDF graphs ERDF formulas, built positive ERDF triples,
connectives , , , , , quantifiers , .
According RDF concepts (Klyne & Carroll, 2004; Hayes, 2004), URI references
used globally unique names web resources. RDF URI reference Unicode string represents absolute URI (with optional fragment identifier).
may represented qualified name, colon-separated two-part string consisting namespace prefix (an abbreviated name namespace URI) local
name. example, given namespace prefix ex defined stand namespace URI http://www.example.org/, qualified name ex:Riesling (which stands
http://www.example.org/Riesling) URI reference.
plain literal string s, sequence Unicode characters, pair
string language tag t, denoted s@t. typed literal pair string
datatype URI reference d, denoted sd. example, 27xsd:integer
typed literal.
(Web) vocabulary V set URI references and/or literals (plain typed).
denote set URI references URI, set plain literals PL, set
typed literals L, set literals LIT . holds: URI LIT = .
41

fiAnalyti, Antoniou, Damasio, & Wagner

formalization, consider set Var variable symbols, sets Var ,
URI, LIT pairwise disjoint. main text, variable symbols explicitly indicated,
examples, variable symbols prefixed question mark symbol ?.
RDF triple (Klyne & Carroll, 2004; Hayes, 2004) triple p o.,
URI Var , p URI, URI LIT Var , expressing subject related
object property p. RDF graph set RDF triples.
variable symbols appearing RDF graph called blank nodes, are, intuitively,
existentially quantified variables. paper, denote RDF triple p o.
p(s, o). extend notion RDF triple allow positive negative
information.
Definition 2.1 (ERDF triple) Let V vocabulary. positive ERDF triple V
(also called ERDF sentence atom) expression form p(s, o), s, V Var
called subject 5 object, respectively, p V URI called predicate property.
negative ERDF triple V strong negation p(s, o) positive ERDF triple
p(s, o) V . ERDF triple V (also called ERDF sentence literal ) positive
negative ERDF triple V .
example, ex:likes(ex:Gerd , ex:Riesling) positive ERDF triple, expressing
Gerd likes Riesling, ex:likes(ex:Carlos, ex:Riesling) negative ERDF triple, expressing Carlos dislikes Riesling. Note RDF triple positive ERDF
triple constraint subject triple literal. example,
ex:denotationOf (Grigoris, ex:Grigoris) valid ERDF triple valid RDF triple.
choice allowing literals appearing subject position based intuition
case naturally appear knowledge representation (as previous example). Prudhommeaux & Seaborne (2008) de Bruijn et al. (2005) consider literals
subject position RDF triples.
Based notion ERDF triple, define ERDF graphs ERDF formulas,
follows:
Definition 2.2 (ERDF graph) ERDF graph G set ERDF triples
vocabulary V . denote variables appearing G Var (G), set URI
references literals appearing G VG .
Note RDF graph set RDF triples (Klyne & Carroll, 2004; Hayes, 2004),
RDF graph ERDF graph.
Definition 2.3 (ERDF formula) Let V vocabulary. consider logical factors
{, , , , , , }, , , called strong negation, weak negation,
material implication, respectively. denote L(V ) smallest set contains
positive ERDF triples V closed respect following conditions:
F, G L(V ) {F, F, F G, F G, F G, xF, xF } L(V ), x Var .
ERDF formula V element L(V ). denote set variables appearing
5. Opposed pure RDF (Klyne & Carroll, 2004), allow literals subject position ERDF
triple.

42

fiExtended RDF Semantic Foundation Rule Markup Languages

F Var (F ), set free variables6 appearing F FVar (F ). Moreover,
denote set URI references literals appearing F VF .
example, let:
F = ?x ?y (rdf :type(?x, ex:Person) ex:hasChild (?y, ?x)) rdf :type(?z, ex:Person)
Then, F ERDF formula vocabulary V = {rdf :type, ex:Person, ex:hasChild }
Var (F ) = {?x, ?y, ?z} FVar (F ) = {?z}.
denote sublanguages L(V ) formed means subset logical
factors, L(V |S). example, L(V |{}) denotes set (positive negative) ERDF
triples V .

3. ERDF Interpretations
section, extend RDF(S) semantics allowing partial properties classes.
particular, define ERDF interpretations satisfaction ERDF formula, based
notion partial interpretation.
3.1 Partial Interpretations
define partial interpretation extension simple interpretation (Hayes, 2004),
property associated truth extension falsity
extension allowing partial properties. notation P(S), set, denotes
powerset S.
Definition 3.1 (Partial interpretation) partial interpretation vocabulary V
consists of:
non-empty set resources ResI , called domain universe I.
set properties P ropI .
vocabulary interpretation mapping IV 7 : V URI ResI P ropI .
property-truth extension mapping PT : P ropI P(ResI ResI ).
property-falsity extension mapping PF : P ropI P(ResI ResI ).
mapping ILI : V L ResI .
set literal values LV ResI , contains V PL.

define mapping: : V ResI P ropI , called denotation, that:
I(x) = IV (x), x V URI.
I(x) = x, x V PL.
I(x) = ILI (x), x V L.
6. Without loss generality, assume variable cannot free bound occurrences
F , one bound occurrence.
7. symbol IV , V stands Vocabulary.

43

fiAnalyti, Antoniou, Damasio, & Wagner

Note truth falsity extensions property p according partial interpretation I, P TI (p) P (p), sets pairs hsubject, objecti resources.
example, let:
V = {ex:Carlos, ex:Grigoris, ex:Riesling, ex:likes, ex:denotationOf , Grigorisxsd:string}

consider structure consists of:
set resources ResI = {C, G, R, l, d, Grigoris}.
set properties P ropI = {l, d}.
vocabulary interpretation mapping IV : V URI ResI P ropI that:
IV (ex:Carlos) = C, IV (ex:Grigoris) = G, IV (ex:Riesling) = R, IV (ex:likes) = l,
IV (ex:denotationOf ) = d.
property-truth extension mapping PT : P ropI P(ResI ResI ) that:
P TI (d) = {hGrigoris, Gi}.
property-falsity extension mapping PF : P ropI P(ResI ResI ) that:
P (l) = {hC, Ri}.
mapping ILI : V L ResI that: ILI (Grigorisxsd :string) = Grigoris.
set literal values LV = {Grigoris}.

easy see partial interpretation V , expressing that: (i) Grigoris
denotation Grigoris (ii) Carlos dislikes Riesling.
Definition 3.2 (Coherent partial interpretation) partial interpretation vocabulary V coherent iff x P ropI , PT (x) PF (x) = .
Coherent partial interpretations enforce constraint pair resources cannot
belong truth falsity extensions property (i.e., properties coherent). Intuitively, means ERDF triple cannot true false.
Continuing previous example, note coherent partial interpretation.
Consider partial interpretation J exactly I, except holds:
P TJ (l) = {hC, Ri} (expressing Carlos likes Riesling). Then, hC, Ri belongs
truth falsity extension l (i.e., hC, Ri P TJ (l) P FJ (l)). Thus, J coherent.
define satisfaction ERDF formula w.r.t. partial interpretation, need first
following auxiliary definition.
Definition 3.3 (Composition partial interpretation valuation) Let
partial interpretation vocabulary V let v partial function v : Var ResI
(called valuation). define: (i) [I + v](x) = v(x), x Var , (ii) [I + v](x) = I(x),
x V .
Definition 3.4 (Satisfaction ERDF formula w.r.t. partial interpretation
valuation) Let F, G ERDF formulas let partial interpretation
vocabulary V . Additionally, let v mapping v : Var (F ) ResI .
F = p(s, o) I, v |= F iff p V URI, s, V Var , I(p) P ropI ,
h[I + v](s), [I + v](o)i PT (I(p)).
44

fiExtended RDF Semantic Foundation Rule Markup Languages

F = p(s, o) I, v |= F iff p V URI, s, V Var , I(p) P ropI ,
h[I + v](s), [I + v](o)i PF (I(p)).
F = G I, v |= F iff VG V I, v 6|= G.
F = F1 F2 I, v |= F iff I, v |= F1 I, v |= F2 .
F = F1 F2 I, v |= F iff I, v |= F1 I, v |= F2 .
F = F1 F2 then8 I, v |= F iff I, v |= F1 F2 .
F = x G I, v |= F iff exists mapping u : Var (G) ResI u(y) = v(y),
Var (G) {x}, I, u |= G.
F = x G I, v |= F iff mappings u : Var (G) ResI u(y) = v(y),
Var (G) {x}, holds I, u |= G.
cases ERDF formulas treated following DeMorgan-style rewrite rules
expressing falsification compound ERDF formulas:
(F G) F G, (F G) F G, (F ) F, ( F ) F 9 ,
(x F ) x F, (x F ) x F, (F G) F G.

Continuing previous example, let v : {?x, ?y, ?z} ResI v(?x) = C,
v(?y) = R, v(?z) = G. holds:
I, v |= ex:likes(?x, ?y) ex:denotationOf (Grigorisxsd:string, ?z).
Definition 3.5 (Satisfaction ERDF formula w.r.t. partial interpretation)
Let F ERDF formula let partial interpretation vocabulary V . say
satisfies F , denoted |= F , iff every mapping v : Var (F ) ResI , holds
I, v |= F.
Continuing previous example, |= ?x ex:likes(ex:Carlos, ?x).
define ERDF graph satisfaction, extending satisfaction RDF graph
(Hayes, 2004) (see Appendix A).
Definition 3.6 (Satisfaction ERDF graph w.r.t. partial interpretation) Let
G ERDF graph let partial interpretation vocabulary V . Let v
mapping v : Var (G) ResI . define:
I, v |=GRAPH G iff G, I, v |= t.
satisfies ERDF graph G, denoted |=GRAPH G, iff exists mapping
v : Var (G) ResI I, v |=GRAPH G.
Intuitively, ERDF graph G represents existentially quantified conjunction
ERDF triples. Specifically, let G = {t1 , ..., tn } ERDF graph, let Var (G) =
{x1 , ..., xk }. Then, G represents ERDF formula formula(G) = ?x1 , ..., ?xk t1 ... tn .
shown following lemma.
8. Material implication logical relationship two ERDF formulas either first
non-true second true.
9. transformation expresses false F hold F holds.

45

fiAnalyti, Antoniou, Damasio, & Wagner

Lemma 3.1 Let G ERDF graph let partial interpretation vocabulary
V . holds: |=GRAPH G iff |= formula(G).
Following RDF terminology (Klyne & Carroll, 2004), variables ERDF
graph called blank nodes intuitively denote anonymous web resources.
example, consider ERDF graph:
G = {rdf :type(?x, ex:EuropeanCountry), rdf :type(?x, ex:EU member)}.
Then, G represents ERDF formula formula(G) =
?x (rdf :type(?x, ex:EuropeanCountry) rdf :type(?x, ex:EU member)),
expressing European country European Union member.
Notational Convention: Let G ERDF graph, let partial interpretation
vocabulary V , let v mapping v : Var (G) ResI . Due Lemma 3.1,
write (by abuse notation) I, v |= G |= G instead I, v |=GRAPH G
|=GRAPH G, respectively.
3.2 ERDF Interpretations Entailment
subsection, define ERDF interpretations entailment extension RDFS
interpretations entailment (Hayes, 2004). First, define vocabularies RDF,
RDFS, ERDF.
vocabulary RDF, VRDF , set URI references rdf : namespace (Hayes,
2004), shown Table 1. vocabulary RDFS, VRDF , set URI references
rdfs: namespace (Hayes, 2004), shown Table 1. vocabulary ERDF , VERDF ,
set URI references erdf : namespace. Specifically, set ERDF predefined
classes CERDF = {erdf :TotalClass, erdf :TotalProperty}. define VERDF = CERDF .
Intuitively, instances metaclass erdf :TotalClass classes c satisfy totalness,
meaning resource belongs truth falsity extension c. Similarly, instances
metaclass erdf :TotalProperty properties p satisfy totalness, meaning
pair resources belongs truth falsity extension p.
ready define ERDF interpretation vocabulary V extension
RDFS interpretation (Hayes, 2004) (see Appendix A), property
class associated truth extension falsity extension, allowing
partial properties partial classes. Additionally, ERDF interpretation gives
special semantics terms ERDF vocabulary.
Definition 3.7 (ERDF interpretation) ERDF interpretation vocabulary V
partial interpretation V VRDF VRDF VERDF , extended new ontological
categories ClsI ResI classes, TCls ClsI total classes, TProp P ropI
total properties, well class-truth extension mapping CT : ClsI P(ResI ),
class-falsity extension mapping CF : ClsI P(ResI ), that:
1. x CT (y) iff hx, yi PT (I(rdf :type)),
x CF (y) iff hx, yi PF (I(rdf :type)).
46

fiExtended RDF Semantic Foundation Rule Markup Languages

VRDF
rdf :type
rdf :Property
rdf :XMLLiteral
rdf :nil
rdf :List
rdf :Statement
rdf :subject
rdf :predicate
rdf :object
rdf :first
rdf :rest
rdf :Seq
rdf :Bag
rdf :Alt
rdf : i, {1, 2, ...}
rdf :value

VRDF
rdfs:domain
rdfs:range
rdfs:Resource
rdfs:Literal
rdfs:Datatype
rdfs:Class
rdfs:subClassOf
rdfs:subPropertyOf
rdfs:member
rdfs:Container
rdfs:ContainerMembershipProperty
rdfs:comment
rdfs:seeAlso
rdfs:isDefinedBy
rdfs:label

Table 1: vocabulary RDF RDFS
2. ontological categories defined
P ropI = CT (I(rdf :Property))
ResI = CT (I(rdfs:Resource))
TCls = CT (I(erdf :TotalClass))

follows:
ClsI = CT (I(rdfs:Class))
LV = CT (I(rdfs:Literal))
TProp = CT (I(erdf :TotalProperty)).

3. hx, yi PT (I(rdfs:domain)) hz, wi PT (x) z CT (y).
4. hx, yi PT (I(rdfs:range)) hz, wi PT (x) w CT (y).
5. x ClsI hx, I(rdfs:Resource)i PT (I(rdfs:subClassOf )).
6. hx, yi PT (I(rdfs:subClassOf )) x, ClsI , CT (x) CT (y),
CF (y) CF (x).
7. PT (I(rdfs:subClassOf )) reflexive transitive relation ClsI .
8. hx, yi PT (I(rdfs:subPropertyOf )) x, P ropI , PT (x) PT (y),
PF (y) PF (x).
9. PT (I(rdfs:subPropertyOf )) reflexive transitive relation P ropI .
10. x CT (I(rdfs:Datatype)) hx, I(rdfs:Literal)i PT (I(rdfs:subClassOf )).
11. x CT (I(rdfs:ContainerMembershipProperty))
hx, I(rdfs:member)i PT (I(rdfs:subPropertyOf )).
12. x TCls CT (x) CF (x) = ResI .
13. x TProp PT (x) PF (x) = ResI ResI .

47

fiAnalyti, Antoniou, Damasio, & Wagner

14. srdf :XMLLiteral V well-typed XML literal string,
ILI (srdf :XMLLiteral ) XML value s,
ILI (srdf :XMLLiteral ) CT (I(rdf :XMLLiteral )).
15. srdf :XMLLiteral V ill-typed XML literal string
ILI (srdf :XMLLiteral ) ResI LV ,
ILI (srdf :XMLLiteral ) CF (I(rdfs:Literal)).
16. satisfies RDF RDFS axiomatic triples (Hayes, 2004), shown Table 2 Table 3
Appendix A, respectively.
17. satisfies following triples, called ERDF axiomatic triples:
rdfs:subClassOf (erdf :TotalClass, rdfs:Class).
rdfs:subClassOf (erdf :TotalProperty, rdfs:Class).

Note RDFS intepretations (Hayes, 2004) imply two-valued interpretation
instances rdf :Property, longer case ERDF interpretations.
Specifically, let ERDF interpretation, let p CTI (I (rdf :Property)), let hx, yi
ResI ResI . may case neither hx, yi P TI (p) hx, yi P (p).
p(x, y) neither true false.
Semantic conditions ERDF interpretations may impose constraints truth
falsity extensions properties classes. Specifically, consider semantic condition 6
Definition 3.7 assume hx, yi PT (I(rdfs:subClassOf )). Then,
satisfy CT (x) CT (y) (as RDFS interpretation does), CF (y) CF (x).
latter true certain resource z belong truth
extension class certain z belong truth extension class
x. Thus, falsity extension contained falsity extension x. Similar
case semantic condition 8. Semantic conditions 12 13 represent definition
total classes total properties, respectively. Semantic condition 15 expresses
denotation ill-typed XML literal literal value. Therefore (see semantic condition 2), certain contained truth extension class rdfs:Literal.
Thus, contained falsity extension class rdfs:Literal.
Let coherent ERDF interpretation vocabulary V . Since I(rdf :type) P ropI ,
holds: x ClsI , CT (x) CF (x) = . Thus, properties classes coherent
ERDF interpretations coherent.
Convention: rest document, consider coherent ERDF interpretations.
means referring ERDF interpretation, implicitly mean coherent
one. Moreover, improve readability examples, ignore example
namespace ex:.
According RDFS semantics (Hayes, 2004), source RDFS-inconsistency
appearance ill-typed XML literal l RDF graph, combination
derivation RDF triple x rdf :type rdfs:Literal. RDF RDFS entailment
rules, x blank node allocated l10 . triple called XML clash.
10. RDF(S), literals allowed subject position RDF triples, whereas blank nodes are.
reason, RDF RDFS entailment rules applied RDF graph, literal
replaced unique blank node. way inferences drawn literal value denoted
literal, without concern restriction (Hayes, 2004).

48

fiExtended RDF Semantic Foundation Rule Markup Languages

understand this, note semantic condition 3 Definition A.3 (RDF interpretation,
Appendix A), follows denotation ill-typed XML literal cannot literal
value. Now, semantic conditions 1 2 Definition A.5 (RDFS interpretation,
Appendix A), follows denotation ill-typed XML literal cannot type
rdfs:Literal. Therefore, derivation XML clash RDF graph G
application RDF RDFS entailment rules, indicates RDFS
interpretation satisfies G.
ERDF graph ERDF-inconsistent11 , due appearance
ill-typed XML literal ERDF graph (in combination semantic condition 15
Definition 3.7), due additional semantic conditions coherent ERDF
interpretations.
example, let p, q, s, URI let G = {p(s, o), rdfs:subPropertyOf (p, q), q(s, o)}.
Then, G ERDF-inconsistent, since (coherent) ERDF interpretation satisfies G.
following proposition shows total properties total classes (coherent)
ERDF interpretations, weak negation strong negation coincide (boolean truth values).
Proposition 3.1 Let ERDF interpretation vocabulary V let V = V
VRDF VRDF VERDF . Then,
1. p, s, V I(p) TProp , holds:
|= p(s, o) iff |= p(s, o) (equivalently, |= p(s, o) p(s, o)).
2. x, c V I(c) TCls , holds:
|= rdf :type(x, c) iff |= rdf :type(x, c)
(equivalently, |= rdf :type(x, c) rdf :type(x, c)).
define ERDF entailment two ERDF formulas ERDF graphs.
Definition 3.8 (ERDF entailment) Let F, F ERDF formulas ERDF graphs.
say F ERDF-entails F (F |=ERDF F ) iff every ERDF interpretation I, |= F
|= F .
example, let:
F = ?x ?y (rdf :type(?x, Person) hasFather (?x, ?y)) rdf :type(John, Person).
Additionally, let F = ?y hasFather (John, ?y) rdf :type(hasFather , rdf :Property).
F |=ERDF F .
following proposition shows ERDF entailment extends RDFS entailment (Hayes,
2004) (see Appendix A) RDF graphs ERDF formulas. words, ERDF
entailment upward compatible RDFS entailment.
Proposition 3.2 Let G, G RDF graphs VG VERDF = VG VERDF = .
Then, G |=RDF G iff G |=ERDF G .
easily follows Proposition 3.2 RDF graph RDFS satisfiable iff
ERDF satisfiable. Thus, RDF graph ERDF-inconsistent due XML
clash.
11. Meaning (coherent) ERDF interpretation satisfies ERDF graph.

49

fiAnalyti, Antoniou, Damasio, & Wagner

4. ERDF Ontologies & Herbrand Interpretations
section, define ERDF ontology pair ERDF graph G set
P ERDF rules. ERDF rules considered derivation rules allow us
infer ontological information based declarations G. Moreover, define
Herbrand interpretations minimal Herbrand models ERDF ontology.
Definition 4.1 (ERDF rule, ERDF program) ERDF rule r vocabulary V
expression form: G F , F L(V ) {true} called condition
G L(V |{}) {false} called conclusion. assume bound variable F
appears free G. denote set variables set free variables r Var (r)
FVar (r)12 , respectively. Additionally, write Cond(r) = F Concl(r) = G.
ERDF program P set ERDF rules vocabulary V . denote set
URI references literals appearing P VP .
Recall L(V |{}) denotes set ERDF triples V . Therefore, conclusion
ERDF rule, unless false, either positive ERDF triple p(s, o) negative
ERDF triple p(s, o).
example, consider derivation rule r:
allRelated (?P, ?Q) ?p rdf :type(?p, ?P ) ?q (rdf :type(?q, ?Q) related (?p, ?q)),

Then, r ERDF rule, indicating two classes P Q, holds allRelated (P,
Q) instances p class P , instance q class Q
holds related (p, q). Note Var (r) = {?P, ?Q, ?p, ?q} FVar (r) = {?P, ?Q}.
Cond(r) = true Var (r) = {}, rule r called ERDF fact. Concl(r) =
false, rule r called ERDF constraint. assume every partial interpretation
every function v : Var ResI , holds I, v |= true, |= true, I, v 6|= false,
6|= false.
Intuitively, ERDF ontology combination (i) ERDF graph G containing
(implicitly existentially quantified) positive negative information, (ii) ERDF
program P containing derivation rules (whose free variables implicitly universally quantified).
Definition 4.2 (ERDF ontology) ERDF ontology (or ERDF knowledge base)
pair = hG, P i, G ERDF graph P ERDF program.
following definition defines models ERDF ontology.
Definition 4.3 (Satisfaction ERDF rule ERDF ontology) Let
ERDF interpretation vocabulary V .
say satisfies ERDF rule r, denoted |= r, iff mappings
v : Var (r) ResI I, v |= Cond(r), holds I, v |= Concl(r).
say satisfies ERDF ontology = hG, P (also, model O),
denoted |= O, iff |= G |= r, r P .
12. FVar (r) = FVar (F ) FVar (G).

50

fiExtended RDF Semantic Foundation Rule Markup Languages

paper, existentially quantified variables ERDF graphs handled skolemization, syntactic transformation commonly used automatic inference systems removing existentially quantified variables.
Definition 4.4 (Skolemization ERDF graph) Let G ERDF graph.
skolemization function G 1:1 mapping skG : Var (G) URI,
x Var (G), skG (x) artificial URI, denoted G:x. set skG (Var (G)) called
Skolem vocabulary G.
skolemization G, denoted sk(G), ground ERDF graph derived G
replacing variable x Var (G) skG (x).
Intuitively, Skolem vocabulary G (that is, skG (Var (G))) contains artificial URIs
giving arbitrary names anonymous entities whose existence asserted
use blank nodes G.
example, let: G = {rdf :type(?x, EuropeanCountry), rdf :type(?x, EU member)}.
Then,
sk(G) = {rdf :type(skG (?x), EuropeanCountry), rdf :type(skG (?x), EU member)}.

following proposition expresses skolemization ERDF graph
entailments original graph, provided contain URIs
skolemization vocabulary.
Proposition 4.1 Let G ERDF graph let F ERDF formula
VF skG (Var (G)) = . holds: G |=ERDF F iff sk(G) |=ERDF F .
define vocabulary ERDF ontology O.
Definition 4.5 (Vocabulary ERDF ontology) Let = hG, P ERDF ontology. vocabulary defined VO = Vsk(G) VP VRDF VRDF VERDF .

Note vocabulary ontology = hG, P contains skolemization vocabulary G.
Let = hG, P ERDF ontology. denote ResH
union VO set
XML values well-typed XML literals VO minus well-typed XML literals.
following definition defines Herbrand interpretations Herbrand models
ERDF ontology.
Definition 4.6 (Herbrand interpretation, Herbrand model ERDF ontology)
Let = hG, P ERDF ontology let ERDF interpretation VO . say
Herbrand interpretation iff:
ResI = ResH
O.
IV (x) = x, x VO URI.
ILI (x) = x, x typed literal VO well-typed XML literal,
ILI (x) XML value x, x well-typed XML literal VO .
51

fiAnalyti, Antoniou, Damasio, & Wagner

denote set Herbrand interpretations H (O).
Herbrand interpretation Herbrand model iff |= hsk(G), P i. denote
set Herbrand models MH (O).
Note Herbrand interpretation ERDF ontology I(x) = x,
x VO well-typed XML literal.
easy see every Herbrand model ERDF ontology model
O. Moreover, note every Herbrand interpretation ERDF ontology uniquely
identified (i) set properties (ii) property-truth property-falsity extension
mappings.
However, Herbrand models ERDF ontology desirable. example,
let p, s, URI, let G = {p(s, o)}, let = hG, i. Then, Herbrand model
|= p(o, s), whereas want p(o, s) satisfied intended
models O. p total property p(o, s) cannot derived
(negation-as-failure)13 .
define minimal Herbrand interpretations ERDF ontology O, need
define partial ordering Herbrand interpretations O.
Definition 4.7 (Herbrand interpretation ordering) Let = hG, P ERDF ontology. Let I, J H (O). say J extends I, denoted J (or J I), iff
P ropI P ropJ , p P ropI , holds PT (p) PT J (p) PF (p) PF J (p).

easy verify relation reflexive, transitive, antisymmetric. Thus,
partial ordering H (O).
intuition behind Definition 4.7 extending Herbrand interpretation,
extend truth falsity extension properties, thus (since rdf :type
property), classes.
following proposition expresses two Herbrand interpretations I, J ERDF
ontology incomparable, property-truth property-falsity extension total
property p w.r.t. J different.
Proposition 4.2 Let = hG, P ERDF ontology let I, J H (O). Let p
TProp TProp J . PT (p) 6= PT J (p) PF (p) 6= PF J (p) 6 J J 6 I.
Definition 4.8 (Minimal Herbrand interpretations) Let ERDF ontology
let H (O). define minimal(I) = {I | 6 J : J =
6 J I}.
define minimal Herbrand models O, as:
Mmin (O) = minimal(MH (O)).
However minimal Herbrand models give intended semantics ERDF rules.
ERDF rules derivation implication rules. Derivation rules
13. hand, p total property p(o, s)p(o, s) satisfied intended models.
Therefore, case, intended model satisfies p(o, s).

52

fiExtended RDF Semantic Foundation Rule Markup Languages

often identified implications. But, general, two different concepts.
implication expression logical formula language, derivation rule rather
meta-logical expression. logics, implication connective,
derivation rule concept. standard logics (such classical intuitionistic
logic), close relationship derivation rule (also called sequent)
corresponding implicational formula: models. non-monotonic
rules (e.g. negation-as-failure), longer case: intended models
rule are, general, intended models corresponding implication.
easy see help example. Consider rule p q whose model set,
according stable model semantics (Gelfond & Lifschitz, 1988, 1990; Herre & Wagner,
1997; Herre et al., 1999), {{p}}, is, entails p. hand, model set
corresponding implication q p, equivalent disjunction p q,
{{p}, {q}, {p, q}}; consequently, entail p.
Similarly, let = h, P i, P = {p(s, o) q(s, o)} p, q, s, URI.
minimal Herbrand models intended. particular, Mmin (O)
|= q(s, o) p(s, o), whereas want q(s, o) p(s, o) satisfied
intended models O, q total property q(s, o) cannot derived rule
(negation-as-failure).
define intended (stable) models ERDF ontology, need first define
grounding ERDF rules.
Definition 4.9 (Grounding ERDF program) Let V vocabulary let r
ERDF rule. denote [r]V set rules result r replace
variable x FVar (r) v(x), mappings v : FVar (r) V .
Let P ERDF program. define [P ]V =



rP [r]V .



Note rule variable naturally appear subject position ERDF triple.
Since variables instantiated literal, literal naturally appear subject
position ERDF triple grounded version ERDF program. case
supports choice allowing literals subject position ERDF triple.

5. ERDF Stable Models
section, define intended models ERDF ontology O, called stable models
O, based minimal Herbrand interpretations. particular, defining stable models
O, minimal interpretations set Herbrand interpretations satisfy
certain criteria considered.
Below, define stable models ERDF ontology, based coherent stable
models14 Partial Logic (Herre et al., 1999).
Definition 5.1 (ERDF stable model) Let = hG, P ERDF ontology let
H (O). say (ERDF) stable model iff chain
Herbrand interpretations O, I0 ... Ik+1 Ik = Ik+1 = and:
14. Note models extended logic programs equivalent (Herre et al., 1999) Answer Sets
answer set semantics (Gelfond & Lifschitz, 1990).

53

fiAnalyti, Antoniou, Damasio, & Wagner

1. I0 minimal({I H (O) | |= sk(G)}).
2. successor ordinals 0 < k + 1:
minimal({I H (O) | I1 |= Concl(r), r P[I1 ,M ] }),
P[I1 ,M ] = {r [P ]VO | |= Cond(r), H (O) s.t. I1 }.
set stable models denoted Mst (O).
Note I0 minimal Herbrand interpretation = hG, P satisfies sk(G),
Herbrand interpretations I1 , ..., Ik+1 correspond stratified sequence rule applications, applied rules remain applicable throughout generation stable
model . words, stable model generated bottom-up iterative application
rules ERDF program P , starting information ERDF graph G.
Thus, ERDF stable model semantics, refinement minimal model semantics, captures
intuition that:
Assertions rdf :type(p, erdf :TotalProperty) rdf :type(c, erdf :TotalClass)
accepted ontology contains direct support form
acceptable rule sequence (that corresponds proof).
Assertions p(s, o) p(s, o) accepted ontology contains
direct support form acceptable rule sequence,
rdf :type(p, erdf :TotalProperty) accepted.
Assertions rdf :type(o, c) rdf :type(o, c) accepted ontology
contains direct support form acceptable rule sequence,
rdf :type(c, erdf :TotalClass) accepted.
Wine Selection Example: Consider class Wine whose instances wines,
property likes(X, ) indicating person X likes object . Assume want
select wines dinner that, guest, table exactly one wine
he/she likes. Let class Guest indicate persons invited dinner
let class SelectedWine indicate wines chosen served. ERDF program
P describes wine selection problem following (commas , body
rules indicate conjunction ):
id(?x, ?x) rdf :type(?x, rdfs:Resource).
rdf :type(?y, SelectedWine) rdf :type(?x, Guest), rdf :type(?y, Wine), likes(?x, ?y),
?z (rdf :type(?z, SelectedWine), id(?z, ?y) likes(?x, ?z)).

Consider ERDF graph G, containing factual information:
G = { rdf :type(Carlos, Guest), rdf :type(Gerd , Guest), rdf :type(Riesling, Wine),
rdf :type(Retsina, Wine), rdf :type(Chardonnay, Wine), likes(Gerd , Riesling),
likes(Gerd , Retsina), likes(Carlos, Chardonnay), likes(Carlos, Retsina) }.

Then, according Definition 5.1, ERDF ontology = hG, P two stable models,
M1 M2 , that:
54

fiExtended RDF Semantic Foundation Rule Markup Languages

M1 |= rdf :type(Riesling, SelectedWine) rdf :type(Chardonnay, SelectedWine)
rdf :type(Retsina, SelectedWine).
M2 |= rdf :type(Retsina, SelectedWine) rdf :type(Riesling, SelectedWine)
rdf :type(Chardonnay, SelectedWine).

Note that, according stable model M1 , wines selected dinner Riesling
Chardonnay. because, (i) Gerd likes Riesling Chardonnay,
(ii) Carlos likes Chardonnay Riesling.
According stable model M2 , Retsina selected dinner. because,
Gerd Carlos Retsina.
Stable model M1 reached chain I0 M1 M1 , I0 single
Herbrand interpretation minimal({I H (O) | |= sk(G)}). verify this, note that:
P[I0 ,M1 ] = P[M1 ,M1 ] =
[id(?x, ?x) rdf :type(?x, rdfs:Resource)]VO
{rdf :type(Riesling, SelectedWine) rdf :type(Gerd , Guest),
rdf :type(Riesling, Wine), likes(Gerd , Riesling),
?z (rdf :type(?z, SelectedWine), id(?z , Riesling) likes(Gerd , ?z))}
{rdf :type(Chardonnay, SelectedWine) rdf :type(Carlos, Guest),
rdf :type(Chardonnay, Wine), likes(Carlos, Chardonnay),
?z (rdf :type(?z, SelectedWine), id(?z , Chardonnay) likes(Carlos, ?z))}.

Similarly, stable model M2 reached chain I0 M2 M2 . verify this,
note that:
P[I0 ,M2 ] = P[M2 ,M2 ] =
[id(?x, ?x) rdf :type(?x, rdfs:Resource)]VO
{rdf :type(Retsina, SelectedWine) rdf :type(Gerd , Guest),
rdf :type(Retsina, Wine), likes(Gerd , Retsina),
?z (rdf :type(?z, SelectedWine), id(?z, Retsina) likes(Gerd , ?z))}
{rdf :type(Retsina, SelectedWine) rdf :type(Carlos, Guest),
rdf :type(Retsina, Wine), likes(Carlos, Retsina),
?z (rdf :type(?z, SelectedWine), id(?z, Retsina) likes(Carlos, ?z))}.

Assume Retsina one selected wines,
match food. indicate this, add P ERDF constraint:
false rdf :type(Retsina, SelectedWine).
Then, M1 single model modified ontology.
easy verify ERDF ontology exactly O, without
ERDF constraints appearing O, Mst (O) Mst (O ). words, ERDF
constraints appearing ERDF ontology eliminate undesirable stable models.
Paper Assignment Example: Consider class Paper whose instances papers submitted conference, class Reviewer whose instances potential reviewers
55

fiAnalyti, Antoniou, Damasio, & Wagner

submitted papers, property conflict(R, P ) indicating conflict interest reviewer R paper P . Assume want assign papers
reviewers based following criteria: (i) paper assigned one reviewer,
(ii) reviewer assigned one paper, (iii) paper assigned reviewer,
conflict interest. assignment paper P reviewer R indicated
property assign(P, R). ERDF triple allAssigned (Paper , Reviewer ) indicates paper assigned one reviewer. ERDF program P describing
assignment papers following:
id(?x, ?x) true.
assign(?p, ?r) rdf :type(?p, Paper ), rdf :type(?p , Paper ), assign(?p , ?r), id(?p, ?p ).
assign(?p, ?r) rdf :type(?r, Reviewer ), rdf :type(?r , Reviewer ), assign(?p, ?r ), id(?r, ?r ).
assign(?p, ?r) conflict(?r, ?p).
assign(?p, ?r)
rdf :type(?r, Reviewer ), rdf :type(?p, Paper ), assign(?p, ?r).
allAssigned (Paper , Reviewer ) ?p (rdf :type(?p, Paper )
?r (rdf :type(?r, Reviewer ) assign(?p, ?r))).

Consider ERDF graph G, containing factual information:
G = { rdf :type(P 1, Paper ), rdf :type(P 2, Paper ), rdf :type(P 3, Paper ), rdf :type(R1, Reviewer ),
rdf :type(R2, Reviewer ), rdf :type(R3, Reviewer ), conflict(P 1, R3), conflict(P 2, R2),
conflict(P 3, R2) }.

Then, according Definition 5.1, ERDF ontology = hG, P four stable
models, denoted M1 , ..., M4 , that:
M1
M2
M3
M4

|=
|=
|=
|=

assign(P 1, R1) assign(P 2, R3) allAssigned (Paper , Reviewer ),
assign(P 1, R1) assign(P 3, R3) allAssigned (Paper , Reviewer ),
assign(P 1, R2) assign(P 2, R1) assign(P 3, R3) allAssigned (Paper , Reviewer ),
assign(P 1, R2) assign(P 2, R3) assign(P 3, R1) allAssigned (Paper , Reviewer ).

would note that, contrast previous examples, given ERDF
ontology = hG, P i, possible |minimal ({I H (O) | |= sk(G)})| > 1, due
declaration total properties total classes. Specifically, number
interpretations I0 item 1 Definition 5.1 one iff G contains ERDF triples
form rdf :type(p, erdf :TotalProperty) rdf :type(c, erdf :TotalClass). example, let
= hG, i, where:
G = {authorOf (John, book1 ), authorOf (Peter , book2 ), rdf :type(authorOf , erdf :TotalProperty)}.

Then, I0 , I0 minimal ({I H (O) | |= sk(G)}) that:
I0 |= authorOf (John, book2 ) I0 |= authorOf (John, book2 ).
Note I0 I0 stable models O. However, I0 satisfies authorOf (John, book2 ),
even though evidence John author book2 .
following proposition shows stable model ERDF ontology Herbrand model O.
56

fiExtended RDF Semantic Foundation Rule Markup Languages

Proposition 5.1 Let = hG, P ERDF ontology let Mst (O). holds
MH (O).
hand, properties total, Herbrand model ERDF ontology
= hG, P stable model O15 . Obviously, desirable result since,
case, open-world assumption made properties. Thus, preferential
entailment weak negation, properties. course, term stable model
descriptive, degenerative case.
Proposition 5.2 Let = hG, P ERDF ontology
rdfs:subClassOf (rdf :Property, erdf :TotalProperty) G. Then, Mst (O) = MH (O).
final note that, similarly stable models defined Gelfond & Lifschitz (1988, 1990)
Herre et al. (1999), ERDF stable models preserve Herbrand model satisfiability.
example, let = h, P i, P = {p(s, o) p(s, o)} p, s, URI. Then,
Mst (O) = , whereas Herbrand model satisfies p(s, o).

6. ERDF Stable Model Entailment & Stable Answers
section, define stable model entailment ERDF ontologies, showing extends ERDF entailment ERDF graphs. Moreover, define skeptical credulous
answers ERDF formula (query) F w.r.t. ERDF ontology O.
Definition 6.1 (Stable model entailment) Let = hG, P ERDF ontology
let F ERDF formula ERDF graph. say entails F (ERDF)
stable model semantics, denoted |=st F iff Mst (O), |= F .
example, let = h, P i, P = {p(s, o) q(s, o)} p, q, s, URI. Then,
|=st q(s, o) p(s, o).
Now, let G = {rdfs:subClassOf (rdf :Property, erdf :TotalProperty)} let P
previous example. Then, hG, P |=st q(s, o) p(s, o), hG, P 6|=st q(s, o)
hG, P 6|=st p(s, o). Note desirable result, since q total property
(and thus, open-world assumption made q).
another example, let p, s, URI, let G = {p(s, o)}, let P = {p(?x, ?y)
p(?x, ?y)}. Then, hG, P |=st p(o, s) p(o, s) (note P contains CWA p).
Now, let G = {rdf :type(p, erdf :TotalProperty), p(s, o)} let P previous
example. Then, hG, P |=st ?x ?y (p(?x, ?y) p(?x, ?y)) (see Proposition 3.1),
hG, P 6|=st p(o, s) hG, P 6|=st p(o, s). Indeed, CWA P affect
semantics p, since p total property.
EU Membership Example: Consider following ERDF program P , specifying
rules concluding country member state European Union (EU).
(r1 )
(r2 )

rdf :type(?x, EUMember)
rdf :type(?x, EUMember)

rdf :type(?x, AmericanCountry).
rdf :type(?x, EuropeanCountry),
rdf :type(?x, EUMember).

15. Note that, case, minimal({I H (O) | |= sk(G)}) minimal({I H (O) |
|= Concl(r), r P[M,M ] }).

57

fiAnalyti, Antoniou, Damasio, & Wagner

rather incomplete ERDF ontology = hG, P obtained including following
information ERDF graph G:
rdf :type(Russia, EUMember).
rdf :type(Austria, EUMember).
rdf :type(?x, EuropeanCountry).

rdf :type(Canada, AmericanCountry).
rdf :type(Italy, EuropeanCountry).
rdf :type(?x, EUMember).

Using stable model entailment O, concluded Austria member EU,
Russia Canada members EU, exists European Country
member EU. However, concluded Italy member EU, wrong statement. G contain complete
information European countries EU members (e.g., contain
rdf :type(Italy, EUMember)). Thus, incorrect information obtained closed-world
assumption expressed rule r2 . case rdf :type(EUMember, erdf :TotalClass)
added G (that is, open-world assumption made class EUMember)
rdf :type(Italy, EUMember) thus, rdf :type(Italy, EUMember) longer entailed.
because, stable model extended ERDF ontology satisfies
rdf :type(Italy, EUMember). Moreover, complete information European countries
members EU included G stable model conclusions
correct (the closed-world assumption correctly applied). Note that, case,
G include ERDF triple rdf :type(Italy, EUMember).
following proposition follows directly fact stable model
ERDF ontology ERDF interpretation.
Proposition 6.1 Let = hG, P ERDF ontology let F, F ERDF formulas.
|=st F F |=ERDF F |=st F .
ERDF graphs G, G , proved hG, |=st G iff G |=ERDF G (see
below). question arises whether result generalized replacing
ERDF graph G ERDF formula F . following example shows
case. Let G = {p(s, o)} let F = p(o, s), p, s, URI. hG, |=st F ,
whereas G 6|=ERDF F . However, G replaced ERDF d-formula F , defined
follows:
Definition 6.2 (ERDF d-formula) Let F ERDF formula. say F
ERDF d-formula iff (i) F disjunction existentially quantified conjunctions ERDF
triples, (ii) FVar (F ) = .
example, let:
F = (?x rdf :type(?x , Vertex ) rdf :type(?x , Red ))
(?x rdf :type(?x , Vertex ) rdf :type(?x , Blue)).
Then, F ERDF d-formula. easy see G ERDF graph formula(G)
ERDF d-formula.
58

fiExtended RDF Semantic Foundation Rule Markup Languages

Proposition 6.2 Let G ERDF graph let F ERDF formula
VF skG (Var (G)) = . holds:
1. F ERDF d-formula hG, |=st F G |=ERDF F .
2. G |=ERDF F hG, |=st F .
Let G ERDF graph let F ERDF d-formula ERDF graph
VF skG (Var (G)) = . direct consequence Proposition 6.2 that:
hG, |=st F iff G |=ERDF F .
following proposition direct consequence Proposition 3.2 Proposition
6.2, shows stable model entailment extends RDFS entailment RDF graphs
ERDF ontologies.
Proposition 6.3 Let G, G RDF graphs VG VERDF = , VG VERDF = ,
VG skG (Var (G)) = . holds: G |=RDF G iff hG, |=st G .
Recall Skolem vocabulary G (that is, skG (Var (G))) contains artificial URIs
giving arbitrary names anonymous entities whose existence asserted
use blank nodes G. Thus, condition VG skG (Var (G)) = Proposition 6.3
actually trivial.
Definition 6.3 (ERDF query, ERDF stable answers) Let = hG, P ERDF
ontology. (ERDF) query F ERDF formula. (ERDF) stable answers F
w.r.t. defined follows:

FVar (F ) = Mst (O) : |= F
yes
st

FVar (F ) = Mst (O) : 6|= F
Ans (F ) =

{v : FVar (F ) VO | Mst (O), |= v(F )}

FVar (F ) 6= ,

v(F ) formula F replacing free variables x F v(x).
example, let p, q, c, s, URI, let G = {p(s, o), rdf :type(s, c), rdf :type(o, c)},
let P = {q(?x, ?y) rdf :type(?x, c) rdf :type(?y, c) p(?x, ?y)}. Then, stable
answers F = q(?x, ?y) w.r.t. = hG, P Ans st
(F ) = {{?x = o, ?y = o}, {?x =
s, ?y = s}, {?x = o, ?y = s}}.
Let = hG, P i, q, s, URI, G = {rdf :type(p, erdf :TotalProperty), q(s, o)},
st
P = {p(?x, ?y) p(?x, ?y)}. Then, holds Ans st
(p(?x, ?y))= Ans (p(?x, ?y)) =
st
Ans (p(?x, ?y)) = . because, contrast example, p total
property. Thus, mappings v : {?x, ?y} VO , stable model
|= v(p(?x, ?y) p(?x, ?y)), another stable model
|= v(p(?x, ?y) p(?x, ?y)).
Consider ERDF ontology paper assignment example, Definition
st
5.1. Then, Ans st
(assign(P 1, R2)) =yes Ans (assign(P 2, R1)) =no. Though
st
Ans (assign(P 2, R1)) =no, assign(P 2, R1) satisfied stable models O, stable model (M3 ) satisfies assign(P 2, R1). Indeed answers
query assign(?x, ?y) w.r.t. stable models M3 M4 particular interest since
59

fiAnalyti, Antoniou, Damasio, & Wagner

M3 M4 satisfy allAssigned (Paper , Reviewer ), indicating desirable paper
assignment achieved.
following definition defines credulous stable answers query F w.r.t.
ERDF ontology O, answers F w.r.t. particular stable models O.
Definition 6.4 (Credulous ERDF stable answers) Let = hG, P ERDF ontology. credulous (ERDF) stable answers query F w.r.t. defined follows:

yes FVar (F ) = Mst (O) : |= F
st
FVar (F ) = Mst (O) : 6|= F
c-Ans (F ) =

{ans (F ) 6= | Mst (O)}
FVar (F ) 6= ,

ans (F ) = {v : FVar (F ) VO | |= v(F )}.

Continuing paper assignment example, consider query:
F = allAssigned (Paper , Reviewer ).
st
Then, although Ans st
(F ) =no, holds c-Ans (F ) =yes, indicating
least one desirable assignment papers P 1, P 2, P 3 reviewers R1, R2, R3.
Consider query F = allAssigned (Paper , Reviewer ) assign(?x , ?y). Then,

c-Ans st
(F ) = {{{?x = P 1, ?y = R2}, {?x = P 2, ?y = R1}, {?x = P 3, ?y = R3}},
{{?x = P 1, ?y = R2}, {?x = P 2, ?y = R3}, {?x = P 3, ?y = R1}}},

indicating possible desirable assignments papers. Obviously, credulous stable
answers query F provide alternative solutions, useful range
applications, alternative scenarios naturally appear.
Closing section, would indicate several differences ERDF stable
model semantics w.r.t. first-order logic (FOL). First, semantics domain closure assumption made. due fact domain every Herbrand interpretation
ERDF ontology ResH
, union vocabulary (VO )
set XML values well-typed XML literals VO minus well-typed XML literals.
implies quantified variables always range closed domain. understand
implications assumption, consider ERDF graph:
G = {rdf :type(x, c1) | x {c1, c2} V },

V = (VRDF {rdf : | }) VRDF VERDF . Additionally, consider ERDF
program:
P = { rdf :type(?x, c1) rdf :type(?x, rdfs:ContainerMembershipProperty).
rdf :type(?x, c2) true.}.

Let F = ?x rdf :type(?x, c2) rdf :type(?x, c1). holds hG, P |=st F . However,
G P 6|=F OL F . because, FOL model G P domain
variable assignment v:{?x} M, v |= rdf :type(?x, c2) M, v 6|=
rdf :type(?x, c1).
Another difference due fact definition ERDF stable model
semantics, minimal Herbrand interpretations considered. Let
60

fiExtended RDF Semantic Foundation Rule Markup Languages

G = {teaches(Anne, CS301 ), teaches(Peter , CS505 ), rdf :type(CS505 , GradCourse)}.

Let F = ?x teaches(Peter , ?x) rdf :type(?x, GradCourse). Then, hG, |=st F .
However, G 6|=F OL F . because, FOL model G domain
variable assignment v:{?x} M, v |= teaches(Peter , ?x) M, v 6|=
rdf :type(?x, GradCourse). words, FOL makes open-world assumption
teaches.
Consider G = G {rdf :type(teaches, erdf :TotalProperty)}. Then, similarly
FOL, holds = hG , 6|=st F . teaches total property. Thus,
stable model variable assignment v: {?x} ResH

M, v |= teaches(Peter , ?x) M, v 6|= rdf :type(?x, GradCourse). worlds,
open-world assumption made teaches, FOL. Thus, might exist course
taught Peter , even explicitly indicated G .
example shows that, contrast FOL, stable model entailment nonmonotonic.
Note previous ERDF graph G seen Description Logic A-Box
(Baader et al., 2003),
= {teaches(Anne, CS301), teaches(Peter , CS505), GradCourse(CS505)}
Consider T-Box = . Since Description Logics (DLs) fragments first-order
logic, holds L = hA, 6|=DL teaches.GradCourse(Peter ), meaning L
satisfy courses taught Peter graduate courses. interesting approach
supporting non-monotonic conclusions DLs taken Donini et al. (2002), DLs
minimal knowledge negation failure (MKNF-DLs) defined, extending DLs
two modal operators K, A. Intuitively, K expresses minimal knowledge expresses
weak negation. holds L |=MKNF-DL Kteaches.KGradCourse(Peter ), expressing
courses known taught Peter known graduate courses. Note
conclusion non-monotonic, thus cannot derived classical DLs. However,
compared theory, MKNF-DLs support rules closed-world assumptions
properties (i.e., p(?x, ?y) p(?x, ?y)).

7. XML-based Syntax ERDF
natural approach define XML syntax ERDF is: (i) follow RDF/XML
syntax (Beckett, 2004), much possible, (ii) extend suitable way,
necessary. Following approach, briefly present XML syntax ERDF.
Details going given subsequent paper.
Classes properties defined help rdfs:Class rdf:Property
elements RDF/XML syntax. Similarly, total classes total properties defined help erdf:TotalClass erdf:TotalProperty elements
ERDF/XML syntax.
Example 7.1 following ERDF/XML statements:
<rdf:Property rdf:about="#likes">
<rdfs:domain rdf:resource="#Person"/>
61

fiAnalyti, Antoniou, Damasio, & Wagner

</rdf:Property>
<erdf:TotalProperty rdf:about="#authorOf">
<rdfs:domain rdf:resource="#Person"/>
<rdfs:range rdf:resource="#Book"/>
</erdf:TotalProperty>

correspond ERDF graph:
G = { rdf :type(likes, rdf :Property), rdfs:domain(likes, Person),
rdf :type(authorOf , erdf :TotalProperty), rdfs:domain(authorOf , Person),
rdfs:range(authorOf , Book )}.

ERDF triples (and sets ERDF triples sharing subject term) encoded
means erdf:Description element. description contains non-empty list
(possibly negated) property-value slots subject term.
URI references, blank node identifiers, variables appear subject position
ERDF triple expressed values erdf:about attribute, using
SPARQL syntax (Prudhommeaux & Seaborne, 2008) blank node identifiers
variables. hand, literals appear subject position ERDF
triple expressed text content erdf:about subelement.
URI references, blank node identifiers, variables appear object position ERDF triple expressed values attributes rdf:resource,
rdf:nodeID, erdf:variable, respectively. hand, literals appear object position ERDF triple expressed text content
corresponding property subelement.
Example 7.2 following erdf:Description statements:
<erdf:Description erdf:about="#Gerd">
<ex:authorOf rdf:nodeID="x"/>
<ex:likes rdf:resource="#Chicken"/>
<ex:likes erdf:negationMode="Sneg" rdf:resource="#Pork"/>
</erdf:Description>
<erdf:Description>
<erdf:About rdf:datatype="&xsd;string">Grigoris</erdf:About>
<ex:denotationOf rdf:resource="#Grigoris"/>
</erdf:Description>

correspond ERDF graph:
G = { authorOf (Gerd , ?x ), likes(Gerd , Chicken), likes(Gerd , Pork ),
denotationOf (Grigorisxsd :string, Grigoris) }.

Now, order express ERDF rules XML, use rule markup language R2ML
(REWERSE Rule Markup Language) (Wagner, Giurca, & Lukichev, 2006, 2005),
general XML-based markup language representing derivation rules integrity
constraints. demonstrated following example:
62

fiExtended RDF Semantic Foundation Rule Markup Languages

Example 7.3 following erdf:DerivationRule statement:
<r2ml:DerivationRule r2ml:ruleID="R1">
<r2ml:conditions>
<erdf:Description erdf:about="?x">
<rdf:type rdf:resource="#MainDish"/>
</erdf:Description>
<erdf:Description erdf:about="?y">
<rdf:type rdf:resource="#Guest"/>
<ex:likes erdf:variable="x"/>
</erdf:Description>
<r2ml:NegationAsFailure>
<r2ml:ExistentiallyQuantifiedFormula>
<r2ml:GenericVariable r2ml:name="z" r2ml:class="#Guest"/>
<erdf:Description erdf:about="?z">
<ex:likes erdf:negationMode="Sneg" erdf:variable="x"/>
</erdf:Description>
</r2ml:ExistentiallyQuantifiedFormula>
</r2ml:NegationAsFailure>
</r2ml:conditions>
<r2ml:conclusion>
<erdf:Description erdf:about="?x">
<rdf:type rdf:resource="#SelectedMainDish"/>
</erdf:Description>
</r2ml:conclusion>
</r2ml:DerivationRule>

expresses main dish selected dinner, guest likes guest
dislikes it. Specifically, corresponds ERDF rule:
rdf :type(?x, SelectedMainDish) rdf :type(?x, MainDish), rdf :type(?y, Guest), likes(?y, ?x),
(?z rdf :type(?z, Guest), likes(?z, ?x)).

8. Undecidability ERDF Stable Model Semantics
main difficulty computation ERDF stable model semantics fact
VRDF infinite, thus vocabulary ERDF ontology infinite (note
{rdf : | } VRDF VO ). Due fact, satisfiability entailment
ERDF stable model semantics general undecidable.
proof undecidability exploits reduction unbounded tiling problem.
unbounded tiling problem consists placing tiles infinite grid, satisfying given set
constraints adjacent tiles. Specifically, unbounded tiling problem structure
= hT , H, V i, = {T1 , ..., Tn } finite set tile types H, V specify
tiles adjacent horizontally vertically, respectively. solution
tiling, is, total function : that: ( (i, j), (i + 1, j)) H
( (i, j), (i, j + 1)) V , i, j . existence solution given unbounded
tiling problem known undecidable (Berger, 1966).
Let = hT , H, V instance unbounded tiling problem, = {T1 , ..., Tn }.
construct ERDF ontology OD = hG, P ERDF formula FD
solution iff OD entail FD ERDF stable model semantics.
63

fiAnalyti, Antoniou, Damasio, & Wagner

Consider (i) class Tile whose instances tiles placed infinite grid, (ii)
property right(x , y) indicating tile right next tile x, (iii) property above(x , y)
indicating tile exactly tile x, (iv) class HasRight whose instances
tiles exists tile right next them, (v) class HasAbove whose instances
tiles exists tile exactly them, (vi) property Type(x, ),
indicating type tile x , (vii) property HConstraint(T, ), indicating
(T, ) H, (viii) property VConstraint(T, ), indicating (T, ) V .
Let G ERDF graph:
G=

{rdfs:subClassOf (rdfs:ContainerMembershipProperty, Tile),
rdfs:subClassOf (Tile, rdfs:ContainerMembershipProperty)}
{HConstraint(T, ) | (T, ) H} {VConstraint(T, ) | (T, ) V } .

Let P ERDF program, containing following rules (and constraints):
(1)

Type(?x, T1 ) rdf :type(?x, Tile), Type(?x, T2 ), ..., Type(?x, Tn ).
Type(?x, Ti ) rdf :type(?x, Tile), Type(?x, T1 ), ..., Type(?x, Ti1 ),
Type(?x, Ti+1 ), ..., Type(?x, Tn ), = 2, ..., n 1.
Type(?x, Tn ) rdf :type(?x, Tile), Type(?x, T1 ), ..., Type(?x, Tn1 ).

(2)

right(?x, ?y)
right(?x, ?y)




rdf :type(?x, Tile), rdf :type(?y, Tile), right(?x, ?y).
rdf :type(?x, Tile), rdf :type(?y, Tile), right(?x, ?y).

(3)

above(?x, ?y)
above(?x, ?y)




rdf :type(?x, Tile), rdf :type(?y, Tile), above(?x, ?y).
rdf :type(?x, Tile), rdf :type(?y, Tile), above(?x, ?y).

(4)

rdf :type(?x, HasRight) right(?x, ?y).
rdf :type(?x, HasAbove) above(?x, ?y).
false rdf :type(?x, Tile), rdf :type(?x, HasRight).
false rdf :type(?x, Tile), rdf :type(?x, HasAbove).
id (?x, ?x) rdf :type(?x, rdfs:Resource).
false right(?x, ?y), right(?x, ?y ), id (?y, ?y ).
false above(?x, ?y), above(?x, ?y ), id (?y, ?y ).

(5)

false right(?x, ?y), Type(?x, ?T ), Type(?y, ?T ), HConstraint(?T, ?T ).
false above(?x, ?y), Type(?x, ?T ), Type(?y, ?T ), VConstraint(?T, ?T ).

Note stable models OD = hG, P i, class Tile contains exactly
(infinite mumber) rdf : terms, . because, computing stable models
O, minimal models sk(G) considered (see Definition 5.1, Step 1). Thus,
tile infinite grid represented rdf : term, .
Intuitively, rule set (1) expresses tile exactly one associated type
. Rule set (2) expresses two tiles either horizontally adjacent grid
64

fiExtended RDF Semantic Foundation Rule Markup Languages

horizontally adjacent. Rule set (3) expresses two tiles either vertically adjacent
grid vertically adjacent. Rule set (4) expresses tile exactly
one tile right next exactly one tile right it. Rule set (5) expresses
types horizontally vertically adjacent tiles respect H V relations
D, respectively.
finalize reduction, define:
FD = ?x, ?y, ?x , ?y , ?x right(?x, ?y) above(?y, ?y ) right(?x , ?y ) above(?x , ?x )
id (?x, ?x ).

Formula FD expresses tile x that, starting x, move:
one step right one step one step left one step

meet tile x different x.
Proposition 8.1 Let instance unbounded tiling problem. holds:
1. solution iff OD {false FD } stable model.
2. solution iff OD 6|=st FD .
Since unbounded tiling problem undecidable (Berger, 1966), follows directly
Proposition 8.1 satisfiability entailment ERDF stable model semantics
general undecidable.
previous reduction shows problems remain undecidable ERDF ontology = hG, P i, even (i) body rule P form t1 , ..., tk , tk+1 , ..., tn ,
ti ERDF triple (ii) terms erdf :TotalClass erdf :TotalProperty
appear O, is, (VG VP ) VERDF = . Note since constraint false F
appears ERDF ontology replaced rule F ,
RDF, RDFS, ERDF axiomatic triple, presence constraints affect
decidability.
Future work concerns identification syntactic restrictions ERDF ontology
ERDF stable model entailment decidable.

9. ERDF Model Theory Tarski-style Model Theory
Tarski-style model theory limited classical first-order models, employed
semantics OWL. allows various extensions, relaxing bivalence assumption
(e.g., allowing partial models) allowing higher-order models. compatible
idea non-monotonic inference, simply considering models rule
intended, models satisfy certain criteria. Thus, stable model
semantics normal (generalized) extended logic programs (Gelfond & Lifschitz, 1988,
1990; Herre & Wagner, 1997; Herre et al., 1999) viewed Tarski-style modeltheoretic semantics non-monotonic derivation rules.
Tarski-style model theory triple hL, I, |=i that:
L set formulas, called language,
65

fiAnalyti, Antoniou, Damasio, & Wagner

set interpretations,
|= relation interpretations formulas, called model relation.
Tarski-style model theory hL, I, |=i, define:
notion derivation rule G F , F L called condition G L
called conclusion,
set derivation rules DRL = {G F | F, G L},
extension model relation |= include pairs interpretations
derivation rules,
standard model operator M(KB ) = {I | |= X, X KB }, KB
L DRL set formulas and/or derivation rules, called knowledge base.
Notice way define rules logics contain
implication connective. shows concept rule independent concept
implication.
Typically, knowledge representation theories, models knowledge base
intended models. Except standard model operator M, non-standard
model operators, provide models knowledge base, special
subset supposed capture intended models according semantics.
particularly important type intended model semantics obtained
basis information ordering , allows compare information content
two interpretations I1 , I2 I. Whenever I1 I2 , say I1 less informative
I2 . information model theory hL, I, |=, Tarski-style model theory, extended
information ordering .
information model theory, define number natural non-standard
model operators, minimal model operator:
Mmin (KB ) = minimal (M(KB ))
various refinements it, stable generated models (Gelfond & Lifschitz, 1988,
1990; Herre & Wagner, 1997; Herre et al., 1999).
given model operator Mx : P(L DRL ) P(I), knowledge base KB
L DRL , F L, define entailment relation:
KB |=x F

iff Mx (KB ), |= F

non-standard model operators, minimal stable models, entailment
relation typically non-monotonic, sense extension KB KB may
case KB entails F , KB entail F .
(ERDF) stable model theory seen Tarski-style model theory,
L = L(URI LIT ), set ERDF interpretations vocabulary V
URI LIT , model relation |= defined Definitions 3.5 4.3.
theory, intended model operator (Mst ) assigns ERDF ontology (possibly
empty) set stable models (Definition 5.1).
66

fiExtended RDF Semantic Foundation Rule Markup Languages

10. Related Work
section, briefly review extensions web ontology languages rules.
Ter Horst (2005b, 2004) generalizes RDF graphs generalized RDF graphs, allowing variables property position RDF triples. Additionally, author extends
RDFS semantics datatypes part OWL vocabulary, defining pD semantics, extends if-semantics RDFS weaker iff-semantics
D-entailment (Hayes, 2004) OWL Full (Patel-Schneider, Hayes, & Horrocks, 2004).
sound complete set entailment rules pD entailment presented.
subsequent work, ter Horst (2005a) considers extension previous framework inclusion rules form G G , G RDF graph without
blank nodes possibly variables G generalized RDF graph, possibly
blank nodes variables. Intuitively, rule variables universally quantified
front rule (like free variables rules) blank nodes head rule
correspond existentially quantified variables (this feature supported model).
Based set rules R datatype map D, R-entailment16 defined two
generalized RDF graphs G G (G |=R G ), set sound complete rules
R-entailment presented. relate work ter Horst (2005a), state
following proposition:
Let datatype map, containing rdf :XMLLiteral , let R set rules form
G G constraints: (i) terms appearing property position URIs, (ii)
G 6= {} blank node appears G , (iii) VR (VpOWL VERDF ) = , VpOWL
denotes part OWL vocabulary, included pD semantics. Let G, G RDF graphs
(VG VG ) (VpOWL VERDF ) = . based G R, define, simple
transformation, ERDF ontology G |=R G iff |=st G .

However, work, weak strong negation considered. Thus, closed-world
reasoning supported. Additionally, theory, condition rule ERDF
formula vocabulary V , (thus, involving logical factors , , , , , ,
), conjunction positive triples.
TRIPLE (Sintek & Decker, 2002) rule language Semantic Web
especially designed querying transforming RDF models (or contexts), supporting
RDF subset OWL Lite. syntax based F-Logic (Kifer, Lausen, & Wu,
1995) supports important fragment first-order logic. triple represented
statement form s[p o] sets statements, sharing subject s,
aggregated using molecules form s[p1 o1 ; p2 o2 ; ....]. variables must
explicitly quantified, either existentially universally. Arbitrary formulas used
body, head rules restricted atoms conjunctions molecules.
interesting relevant feature TRIPLE use models collect sets related
sentences. particular, part semantics RDF(S) vocabulary represented
pre-defined rules (and semantic conditions interpretations), grouped
together module. TRIPLE provides features path expressions, skolem model
terms, well model intersection difference. Finally, mentioned
queries models compiled XSB Prolog. TRIPLE uses Lloyd-Topor
transformations (Lloyd & Topor, 1984) take care first-order connectives
16. symbol appear explicitly notation R-entailement, reasons simplification.

67

fiAnalyti, Antoniou, Damasio, & Wagner

sentences supports weak negation well-founded semantics (Gelder, Ross, &
Schlipf, 1991). Strong negation used.
Flora-2 (Yang, Kifer, & Zhao, 2003) rule-based object-oriented knowledge base system reasoning semantic information Web. based F-logic (Kifer
et al., 1995) supports metaprogramming, non-monotonic multiple inheritance, logical database updates, encapsulation, dynamic modules, two kinds weak negation.
Specifically, supports Prolog negation well-founded negation (Gelder et al., 1991),
invocation corresponding operators \+ tnot XSB system (Rao,
Sagonas, Swift, Warren, & Freire, 1997). formal semantics non-monotonic multiple inheritance defined Yang & Kifer (2003a). addition, Flora-2 supports reification anonymous resources (Yang & Kifer, 2003b). particular, Flora-2, reified
statements ${s(p o)}$ objects. contrast, RDF(S), referred URI blank node x, associated following RDF triples:
rdf :type(x, rdf :Statement), rdf :subject(x, s), rdf :predicate(x, p), rdf :object(x, o).
RDF(S) model theory (and thus, theory), special semantics given reified
statements. Flora-2, anonymous resources handled skolemization (similarly
theory).
Notation 3 (N3) (Berners-Lee, Connolly, Kagal, Scharf, & Hendler, 2008) provides
human readable syntax RDF extends RDF adding numerous predefined constructs (built-ins) able express rules conveniently. Remarkably,
N3 contains built-in (log:definitiveDocument) making restricted completeness assumptions another built-in (log:notIncludes) expressing simple negation-as-failure
tests. addition constructs motivated use cases. However, N3
provide strong negation closed-world reasoning fully supported. N3 supported
CWM system17 , forward engine especially designed Semantic Web,
Euler system18 , backward engine relying loop checking techniques guarantee
termination.
Alferes et al. (2003) propose paraconsistent well-founded semantics explicit
negation (WFSXP )19 , appropriate semantics reasoning (possibly, contradictory) information Semantic Web. Supporting arguments include: (i) possible
reasoning, even presence contradiction, (ii) program transformation WFS,
(iii) polynomial time inference procedures. formal model theory explicitly
provided integrated logic.
DR-Prolog (Antoniou, Bikakis, & Wagner, 2004) DR-DEVICE (Bassiliades, Antoniou, & Vlahavas, 2004) two systems integrate RDFS ontologies rules (strict
defeasible), partially ordered superiority relation, based semantics
defeasible logic (Antoniou, Billington, Governatori, & Maher, 2001; Maher, 2002). Defeasible logic contains one kind negation (strong negation) object language20
allows reason presence contradiction incomplete information. supports
17. http://www.w3.org/2000/10/swap/doc/cwm.html.
18. http://www.agfa.com/w3c/euler/.
19. WFSXP (Alferes, Damasio, & Pereira, 1995) extension well-founded semantics explicit
negation (WFSX) extended logic programs (Pereira & Alferes, 1992) and, thus, wellfounded semantics (WFS) normal logic programs (Gelder et al., 1991).
20. However, defeasible logic, negation-as-failure easily simulated language ingredients.

68

fiExtended RDF Semantic Foundation Rule Markup Languages

monotonic non-monotonic rules, exceptions, default inheritance, preferences.
formal model theory explicitly provided integrated logic.
OWL-DL (McGuinness & van Harmelen, 2004) ontology representation language
Semantic Web, syntactic variant SHOIN (D) description logic
decidable fragment first-order logic (Horrocks & Patel-Schneider, 2003). However,
need extending expressive power OWL-DL rules initiated several studies,
including SWRL (Semantic Web Rule Language) proposal (Horrocks, Patel-Schneider,
Boley, Tabet, Grosof, & Dean, 2004). Horrocks & Patel-Schneider (2004) show
extension general undecidable. AL-log (Donini, Lenzerini, Nardi, & Schaerf, 1998)
one first efforts integrate Description Logics (safe) datalog rules,
achieving decidability. considers basic description logic ALC imposes constraint concept DL-atoms allowed appear body rules, whereas
heads rules always non DL-atoms. Additionally, variable appearing
concept DL atom body rule appear non DL-atom body
head rule. CARIN (Levy & Rousset, 1998) provides framework studying
effects combining description logic ALCN R (safe) datalog rules. CARIN,
concept role DL-atoms allowed body rules. shown
integration decidable rules non-recursive, certain combinations constructors
allowed DL component, rules role-safe (imposing constraint
variables role DL atoms body rules)21 . Motik et al. (2004) show
integration SHIQ(D) knowledge base L disjunctive datalog program P decidable, P DL-safe, is, variables rule occur least one non DL-atom
body rule. work, contrast AL-log CARIN, tableaux algorithm
employed query answering L translated disjunctive logic program DD(L)
combined P answering ground queries.
category works, entailment DL, extended rules,
based first-order logic. means DL component logic program
viewed set first-order logic statements. Thus, negation-as-failure, closed-worldassumptions, non-monotonic reasoning cannot supported. contrast, work
supports weak strong negation, allows closed-world open-world reasoning
selective basis.
different kind integration achieved Eiter et al. (2004a). work,
SHOIN (D) knowledge base L communicates extended logic program P (possibly
weak strong negation), DL-query atoms body rules.
particular, description logic component L used answering augmented,
input logic program, queries appearing (possibly weakly negated) DL-query
atoms, thus allowing flow knowledge P L vice-versa. answer set semantics hL, P defined, generalization answer set semantics (Gelfond
& Lifschitz, 1990) ordinary extended logic programs. similar kind integration
achieved Eiter et al. (2004b). work, SHOIN (D) knowledge base L communicates normal logic program P (possibly weak negation), DL-query
atoms body rules. well-founded semantics hL, P defined,
21. rule role-safe least one variables x, role DL atom R(x, y) body
rule, appears body atom base predicate, base predicate ordinary predicate
appears facts rule bodies.

69

fiAnalyti, Antoniou, Damasio, & Wagner

generalization well-founded semantics (Gelder et al., 1991) ordinary normal logic
programs. Obviously, works, derived information concerns non DLatoms (that possibly used input DL-query atoms). Thus, rule-based reasoning
supported non DL-atoms. contrast, work, properties classes appearing ERDF graphs freely appear heads bodies rules, allowing
even derivation metalevel statements subclass subproperty relationships,
property transitivity, property class totalness.
Rosati (1999) defines semantics disjunctive AL-log knowledge base, based
stable model semantics disjunctive databases (Gelfond & Lifschitz, 1991), extending
AL-log (Donini et al., 1998). disjunctive AL-log knowledge base integration
ALC knowledge base (safe) disjunctive logic program P allows concept
role DL-atoms body rules (along weak negation non DL-atoms).
safety condition enforces variable head rule appear
body rule. Additionally, constants P DL-individuals. Similarly
case, defining disjunctive AL-log semantics, grounded versions
rules considered (by instantiating variables DL individuals). However rule-based
reasoning supported non DL-atoms, DL-atoms body rules
mainly express constraints.
subsequent work, Rosati (2005) defines r-hybrid knowledge bases. r-hybrid
knowledge bases, DL-atoms allowed head rules DL component
SHOIN (D) knowledge base. Additionally, constants P necessarily DLindividuals. However, stronger safety condition imposed, rule variable
appear (positive) non DL-atom body rule. Additionally, weak negation
allowed non DL-atoms rule-based meta-reasoning supported. general,
say non DL-atoms, closed-world assumption made, DL-atoms
conform open-world assumption, SHOIN (D) fragment first-order logic.

11. Conclusions
paper, extended RDF graphs ERDF graphs allowing negative triples
representing explicit negative information. Then, proceeded defining ERDF
ontology ERDF graph complemented set derivation rules connectives
(weak negation), (strong negation), (material implication), , , , body
rule, strong negation head rule. Moreover, extended
RDF(S) vocabulary adding predefined vocabulary elements erdf :TotalProperty
erdf :TotalClass, representing metaclasses total properties total classes,
open-world assumption applies.
defined ERDF formulas, ERDF interpretations, ERDF entailment
ERDF formulas, showing conservatively extends RDFS entailment RDF graphs.
developed model-theoretic semantics ERDF ontologies, called ERDF stable
model semantics, showing stable model entailment extends ERDF entailment ERDF
graphs, thus extends RDFS entailment RDF graphs. ERDF stable model
semantics based Partial Logic and, particular, generalized definition stable
models (Herre & Wagner, 1997; Herre et al., 1999) (which extends answer set semantics
extended logic programs). shown classical (boolean) Herbrand model
70

fiExtended RDF Semantic Foundation Rule Markup Languages

reasoning special case semantics, properties total. case,
similarly classical logic, open-world assumption made properties classes
two negations (weak strong negation) collapse. Allowing (a) totality
properties classes declared selective basis (b) explicit representation
closed-world assumptions (as derivation rules) enables combination open-world
closed-world reasoning framework.
particular, total property p, open-world assumption applies, since
considered Herbrand interpretation I, computation ERDF stable models, satisfies
p(x, y)p(x, y), pair (x, y) ontology vocabulary terms. closed property p,
default closure rule form p(?x, ?y) p(?x, ?y) added, allows infer
falsity p(x, y), evidence p(x, y) holds. However, method
works partial properties. total property p, may happen stable
model, p(x, y) holds, even though evidence (see example
Section 5, Proposition 5.1). fact, p total property, existence
corresponding default closure rule affect ontology semantics.
main advantages ERDF summarized follows:
Tarski-style model theory, desirable feature logic languages
Semantic Web (Bry & Marchiori, 2005).
based Partial Logic (Herre et al., 1999), simplest conservative
extension classical logic supports weak strong negation. Partial
logic extends Answer Set Programming (ASP)22 (Gelfond & Lifschitz, 1990),
allowing logical factors , , , , , , body rule.
enables combination open-world (monotonic) closed-world (non-monotonic)
reasoning, framework.
extends RDFS ontologies derivation rules integrity constraints.
Satisfiability entailment ERDF stable model semantics general undecidable. subsequent paper, plan identify syntactic restrictions ERDF
ontologies guarantee decidability reasoning elaborate ERDF computability complexity issues.
work, consider coherent ERDF interpretations. However, due
Semantic Webs decentralized distributed nature, contradictory information frequent
(Schaffert, Bry, Besnard, Decker, Decker, Enguix, & Herzig, 2005). Though Partial Logic
allows truth-value clashes, handling inconsistency Semantic Web topic
deserves extended treatment, outside scope paper. future
plans consider general ERDF interpretations extend vocabulary ERDF
terms erdf :CoherentProperty erdf :CoherentClass, whose instances properties
classes satisfy coherence. Thus, coherence decided per property
22. ASP well-known accepted knowledge representation formalism allows (through credulous
reasoning) definition concepts ranging space choices. feature enables compact
representation search optimization problems (Eiter, Ianni, Polleres, & Schindlauer, 2006).

71

fiAnalyti, Antoniou, Damasio, & Wagner

per class basis. Admitting incoherent models interesting combination
second preference criterion minimal incoherence (Herre et al., 1999).
future work concerns support datatypes, including XSD datatypes,
extension predefined ERDF vocabulary adding useful constructs, possibly
accordance extensions ter Horst (2005b). plan formally define
ERDF/XML syntax, briefly presented Section 7. Moreover, plan implement
ERDF inference engine.
Finally, would mention success Semantic Web impossible without support modularity, encapsulation, information hiding, access control.
Modularity mechanisms syntactic restrictions merging knowledge bases Semantic Web explored Damasio et al. (2006). However, work, knowledge bases
expressed extended logic programs. future plans include extension ERDF
mechanisms allowing sharing knowledge different ERDF ontologies, along
lines proposed Damasio et al. (2006).

Acknowledgments
authors would thank reviewers valuable comments. research
partially funded European Commission Swiss Federal Office Education Science within 6th Framework Programme project REWERSE
num. 506779 (www.rewerse.net).

Appendix A: RDF(S) Semantics
self-containment, Appendix, review definitions simple, RDF,
RDFS interpretations, well definitions satisfaction RDF graph RDFS
entailment. details, see W3C Recommendation RDF semantics (Hayes, 2004).
Let URI denote set URI references, PL denote set plain literals, L
denote set typed literals, respectively. vocabulary V subset URI PL L.
vocabulary RDF, VRDF , vocabulary RDFS, VRDF , shown Table
1 (Section 3).
Definition A.1 (Simple interpretation) simple interpretation vocabulary V
consists of:
non-empty set resources ResI , called domain universe I.
set properties P ropI .
vocabulary interpretation mapping IV : V URI ResI P ropI .
property extension mapping PT : P ropI P(ResI ResI ).
mapping ILI : V L ResI .
set literal values LV ResI , contains V PL.

define mapping: : V ResI P ropI that:
I(x) = IV (x), x V URI.
72

fiExtended RDF Semantic Foundation Rule Markup Languages

I(x) = x, x V PL.
I(x) = ILI (x), x V L.

Definition A.2 (Satisfaction RDF graph w.r.t. simple interpretation) Let
G RDF graph let simple interpretation vocabulary V . Let v
mapping v : Var (G) ResI . x Var (G), define [I + v](x) = v(x). x V ,
define [I + v](x) = I(x). define:
I, v |= G iff p(s, o) G, holds that: p V, s, V Var , I(p) P ropI ,
h[I + v](s), [I + v](o)i PT (I(p)).
satisfies RDF graph G, denoted |= G, iff exists mapping v :
Var (G) ResI I, v |= G.
rdf :type(rdf :type, rdf :Property)
rdf :type(rdf :subject, rdf :Property)
rdf :type(rdf :predicate, rdf :Property)
rdf :type(rdf :object, rdf :Property)
rdf :type(rdf :f irst, rdf :Property)
rdf :type(rdf :rest, rdf :Property)
rdf :type(rdf :value, rdf :Property)
rdf :type(rdf : i, rdf :Property), {1, 2, ...}
rdf :type(rdf :nil, rdf :List)

Table 2: RDF axiomatic triples
Definition A.3 (RDF interpretation) RDF interpretation vocabulary V
simple interpretation V VRDF , satisfies following semantic conditions:
1. x P ropI iff hx, I(rdf :Property)i PT (I(rdf :type)).
2. srdf :XMLLiteral V well-typed XML literal string,
ILI (srdf :XMLLiteral ) XML value s,
ILI (srdf :XMLLiteral ) LV ,
hILI (srdf :XMLLiteral ), I(rdf :XMLLiteral )i PT (I(rdf :type)).
3. srdf :XMLLiteral V ill-typed XML literal string
ILI (srdf :XMLLiteral ) ResI LV ,
hILI (srdf :XMLLiteral ), I(rdf :XMLLiteral )i 6 PT (I(rdf :type)).
4. satisfies RDF axiomatic triples, shown Table 2.

Definition A.4 (RDF entailment) Let G, G RDF graphs. say G RDFentails G (G |=RDF G ) iff every RDF interpretation I, |= G |= G .
Definition A.5 (RDFS interpretation) RDFS interpretation vocabulary V
RDF interpretation V VRDF VRDF , extended new ontological category
ClsI ResI classes, well class extension mapping CT : ClsI P(ResI ),
that:
73

fiAnalyti, Antoniou, Damasio, & Wagner

rdfs:domain(rdf :type, rdfs:Resource)
rdfs:domain(rdfs:domain, rdf :Property)
rdfs:domain(rdfs:range, rdf :Property)
rdfs:domain(rdfs:subPropertyOf , rdf :Property)
rdfs:domain(rdfs:subClassOf , rdfs:Class)
rdfs:domain(rdf :subject, rdf :Statement)
rdfs:domain(rdf :predicate, rdf :Statement)
rdfs:domain(rdf :object, rdf :Statement)
rdfs:domain(rdfs:member, rdfs:Resource)
rdfs:domain(rdf :f irst, rdf :List)
rdfs:domain(rdf :rest, rdf :List)
rdfs:domain(rdfs:seeAlso, rdfs:Resource)
rdfs:domain(rdfs:isDef inedBy, rdfs:Resource)
rdfs:domain(rdfs:comment, rdfs:Resource)
rdfs:domain(rdfs:label, rdfs:Resource)
rdfs:domain(rdfs:value, rdfs:Resource)
rdfs:range(rdf :type, rdfs:Class)
rdfs:range(rdfs:domain, rdfs:Class)
rdfs:range(rdfs:range, rdfs:Class)
rdfs:range(rdfs:subPropertyOf , rdf :Property)
rdfs:range(rdfs:subClassOf , rdfs:Class)
rdfs:range(rdf :subject, rdfs:Resource)
rdfs:range(rdf :predicate, rdfs:Resource)
rdfs:range(rdf :object, rdfs:Resource)
rdfs:range(rdfs:member, rdfs:Resource)
rdfs:range(rdf :f irst, rdfs:Resource)
rdfs:range(rdf :rest, rdf :List)
rdfs:range(rdfs:seeAlso, rdfs:Resource)
rdfs:range(rdfs:isDef inedBy, rdfs:Resource)
rdfs:range(rdfs:comment, rdfs:Literal)
rdfs:range(rdfs:label, rdfs:Literal)
rdfs:range(rdf :value, rdfs:Resource)
rdfs:subClassOf (rdf :Alt, rdfs:Container)
rdfs:subClassOf (rdf :Bag, rdfs:Container)
rdfs:subClassOf (rdf :Seq, rdfs:Container)
rdfs:subClassOf (rdfs:ContainerMembershipProperty, rdf :Property)
rdfs:subPropertyOf (rdfs:isDef inedBy, rdfs:seeAlso)
rdf :type(rdf :XMLLiteral , rdfs:Datatype)
rdfs:subClassOf (rdf :XMLLiteral , rdfs:Literal)
rdfs:subClassOf (rdfs:Datatype, rdfs:Class)
rdf :type(rdf : i, rdfs:ContainerMembershipProperty), {1, 2, ...}
rdfs:domain(rdf : i, rdfs:Resource), {1, 2, ...}
rdfs:range(rdf : i, rdfs:Resource), {1, 2, ...}

Table 3: RDFS axiomatic triples

74

fiExtended RDF Semantic Foundation Rule Markup Languages

1. x CT (y) iff hx, yi PT (I(rdf :type)).
2. ontological categories defined follows:
ClsI = CT (I(rdfs:Class)),
ResI = CT (I(rdfs:Resource)),
LV = CT (I(rdfs:Literal)).
3. hx, yi PT (I(rdfs:domain)) hz, wi PT (x) z CT (y).
4. hx, yi PT (I(rdfs:range)) hz, wi PT (x) w CT (y).
5. x ClsI hx, I(rdfs:Resource)i PT (I(rdfs:subClassOf )).
6. hx, yi PT (I(rdfs:subClassOf )) x, ClsI , CT (x) CT (y).
7. PT (I(rdfs:subClassOf )) reflexive transitive relation ClsI .
8. hx, yi PT (I(rdfs:subPropertyOf )) x, P ropI , PT (x) PT (y).
9. PT (I(rdfs:subPropertyOf )) reflexive transitive relation P ropI .
10. x CT (I(rdfs:Datatype)) hx, I(rdfs:Literal)i PT (I(rdfs:subClassOf )).
11. x CT (I(rdfs:ContainerM embershipP roperty))
hx, I(rdfs:member)i PT (I(rdfs:subPropertyOf )).
12. satisfies RDFS axiomatic triples, shown Table 3.

Definition A.6 (RDFS entailment) Let G, G RDF graphs. say G RDFSentails G (G |=RDF G ) iff every RDFS interpretation I, |= G |= G .


Appendix B: Proofs
Appendix, prove lemmas propositions presented main paper.
addition, provide Lemma B.1, used proofs. reduce size
proofs, eliminated namespace URIs VRDF VRDF VERDF .
Lemma B.1 Let F ERDF formula let partial interpretation
vocabulary V . Let u, u mappings u, u : Var (F ) ResI u(x) = u (x),
x FVar (F ). holds: I, u |= F iff I, u |= F .
Proof: prove proposition induction. Without loss generality, assume
appears front positive ERDF triples. Otherwise apply transformation
rules Definition 3.4, get equivalent formula satisfies assumption.
Let F = p(s, o). holds: I, u |= F iff p V , s, V Var , I(p) P ropI ,
h[I + u](s), [I + u](o)i PT (I(p)) iff p V , s, V Var , I(p) P ropI , h[I +
u ](s), [I + u ](o)i PT (I(p)) iff I, u |= p(s, o).
Let F = p(s, o). holds: I, u |= F iff p V , s, V Var , I(p) P ropI ,
h[I + u](s), [I + u](o)i PF (I(p)) iff p V , s, V Var , I(p) P ropI ,
h[I + u ](s), [I + u ](o)i PF (I(p)) iff I, u |= p(s, o).
Assumption: Assume lemma holds subformulas F .
show lemma holds F .
Let F = G. holds: I, u |= F iff I, u |= G iff VG V I, u 6|= G iff VG V
I, u 6|= G iff I, u |= G iff I, u |= F .
75

fiAnalyti, Antoniou, Damasio, & Wagner

Let F = F1 F2 . holds: I, u |= F iff I, u |= F1 F2 iff I, u |= F1 I, u |= F2 iff
I, u |= F1 I, u |= F2 iff I, u |= F1 F2 iff I, u |= F .
Let F = x G. show (i) I, u |= F I, u |= F (ii) I, u |= F
I, u |= F .
(i) Let I, u |= F . Then, I, u |= xG. Thus, exists mapping u1 : Var (G) ResI
s.t. u1 (y) = u(y), Var (G) {x}, I, u1 |= G. Let u2 mapping u2 :
Var (G) ResI s.t. u2 (y) = u (y), Var (G) {x}, u2 (x) = u1 (x). Since u(z) =
u (z), z FVar (F ) x FVar (G), follows u1 (z) = u2 (z), z FVar (G).
Thus, I, u2 |= G. Therefore, exists mapping u2 : Var (G) ResI s.t. u2 (y) = u (y),
Var (G) {x}, I, u2 |= G. Thus, I, u |= x G, implies I, u |= F .
(ii) prove statement similarly (i) exchanging u u .
Let F = F1 F2 F = F1 F2 F = xG. prove, similarly
cases, I, u |= F iff I, u |= F .
Lemma 3.1. Let G ERDF graph let partial interpretation vocabulary
V . holds: |=GRAPH G iff |= formula(G).
Proof: Let G = {t1 , ..., tn } F = formula(G).
) Assume |=GRAPH G, show |= F . Since |=GRAPH G, follows
v : Var (G) ResI I, v |= ti , = 1, ..., n. Thus, v : Var (G) ResI
I, v |= t1 ...tn . implies u : Var (G) ResI I, u |= F . Since
FVar (F ) = , follows Lemma B.1 u : Var (G) ResI , holds I, u |= F .
Thus, |= F .
) Assume |= F , show |=GRAPH G. Since |= F , follows
v : Var (G) ResI holds I, v |= F . Thus, v : Var (G) ResI
I, v |= F . implies u : Var (G) ResI I, u |= t1 ...tn . Thus,
u : Var (G) ResI I, u |= ti , = 1, ..., n. Therefore, |=GRAPH G.
Proposition 3.1. Let ERDF interpretation vocabulary V let V =
V VRDF VRDF VERDF . Then,
1. p, s, V I(p) TProp , holds:
|= p(s, o) iff |= p(s, o) (equivalently, |= p(s, o) p(s, o)).
2. x, c V I(c) TCls , holds:
|= rdf :type(x, c) iff |= rdf :type(x, c)
(equivalently, |= rdf :type(x, c) rdf :type(x, c)).
Proof:
1) holds: |= p(s, o) iff 6|= p(s, o) iff hI(s), I(o)i 6 PT (p) iff (since p TProp )
hI(s), I(o)i PF (p) iff |= p(s, o). Therefore, |= p(s, o) iff |= p(s, o).
show |= p(s, o) p(s, o). holds |= p(s, o) |= p(s, o).
implies |= p(s, o) |= p(s, o), thus, |= p(s, o) p(s, o).
2) proof similar proof 1) replacing p(s, o) type(x, c) TProp
TCls .
Proposition 3.2. Let G, G RDF graphs VG VERDF = VG VERDF =
. Then, G |=RDF G iff G |=ERDF G .
76

fiExtended RDF Semantic Foundation Rule Markup Languages

Proof:
) Let G |=ERDF G . show G |=RDF G . particular, let RDFS
interpretation vocabulary V s.t. |= G, show |= G .
Since |= G, holds v : Var (G) ResI s.t. I, v |= G. goal construct
ERDF interpretation J V s.t. J |= G. consider 1-1 mapping res : VERDF R,
R set disjoint ResI . Additionally, let V = V VRDF VRDF VERDF .
Based mapping res, construct partial interpretation J V follows:
ResJ = ResI res(VERDF ).
JV (x) = IV (x), x (V VERDF ) URI JV (x) = res(x), x VERDF .
define mapping: ILJ : V L ResJ that: ILJ (x) = ILI (x).
define mapping: J : V ResJ that:
J(x) = JV (x), x V URI.
J(x) = x, x V PL.
J(x) = ILJ (x), x V L.
define mapping PT J : ResJ P(ResJ ResJ ) follows:
(PT1) x, y, z ResI hx, yi PT (z) hx, yi PT J (z).
(PT2) hres(TotalClass), J(Class)i PT J (J(subClassOf )).
(PT3) hres(TotalProperty), J(Property)i PT J (J(subClassOf )).
Starting derivations (PT1), (PT2), (PT3), following rules
applied recursively, fixpoint reached:
(PT4) hx, yi PT J (J(domain)) hz, wi PT J (x)
hz, yi PT J (J(type)).
(PT5) hx, yi PT J (J(range)) hz, wi PT J (x)
hw, yi PT J (J(type)).
(PT6) hx, J(Class)i PT J (J(type))
hx, J(Resource)i PT J (J(subClassOf )).
(PT7) hx, yi PT J (J(subClassOf )) hx, J(Class)i PT J (J(type)).
(PT8) hx, yi PT J (J(subClassOf )) hy, J(Class)i PT J (J(type)).
(PT9) hx, yi PT J (J(subClassOf )) hz, xi PT J (J(type))
hz, yi PT J (J(type)).
(PT10) hx, J(Class)i PT J (J(type)) hx, xi PT J (J(subClassOf )).
(PT11) hx, yi PT J (J(subClassOf )) hy, zi PT J (J(subClassOf ))
hx, zi PT J (J(subClassOf )).
(PT12) hx, yi PT J (J(subPropertyOf )) hx, J(Property)i PT J (J(type)).
(PT13) hx, yi PT J (J(subPropertyOf )) hy, J(Property)i PT J (J(type)).
(PT14) hx, yi PT J (J(subPropertyOf )) hz, wi PT J (x)
hz, wi PT J (y).
77

fiAnalyti, Antoniou, Damasio, & Wagner

(PT15) hx, J(Property)i PT J (J(type)) hx, xi PT J (J(subPropertyOf )).
(PT16) hx, yi PT J (J(subPropertyOf )) hy, zi PT J (J(subPropertyOf ))
hx, zi PT J (J(subPropertyOf )).
(PT17) hx, J(Datatype)i PT J (J(type))
hx, J(Literal)i PT J (J(subClassOf )).
(PT18) hx, J(ContainerM embershipP roperty)i PT J (J(type))
hx, J(member)i PT J (J(subPropertyOf )).
reaching fixpoint, nothing else contained PT J (x), x ResJ .
P ropJ = {x ResJ | hx, J(Property)} PT J (J(type))}.
mapping PT J : P ropJ P(ResJ ResJ ) defined follows:
PT J (x) = PT J (x), x P ropJ .
LV J = {x ResJ | hx, J(Literal)i PT J (J(type))}.
mapping PF J : P ropJ P(ResJ ResJ ) defined follows:
(PF1) srdf :XMLLiteral V ill-typed XML-Literal
hILJ (srdf :XMLLiteral ), J(Literal)i PF J (J(type)).
(PF2) hJ(TotalClass), J(TotalClass)i PT J (J(type))
x ResJ {J(TotalClass)}, hx, J(TotalClass)i PF J (J(type)).
(PF3) hJ(TotalProperty), J(TotalProperty)i PT J (J(type))
x, ResJ , hx, yi PF J (J(TotalProperty)).
Starting derivations (PF1), (PF2), (PF3), following rules
applied recursively, fixpoint reached:
(PF4) hx, yi PT J (J(subClassOf )) hz, yi PF J (J(type))
hz, xi PF J (type).
(PF5) hx, yi PT J (J(subPropertyOf )) hz, wi PF J (y)
hz, wi PF J (x).
reaching fixpoint, nothing else contained PF J (x), x P ropJ .
continue, prove following lemma:
Lemma: x, y, x ResJ , hx, yi PT J (z) iff hx, yi PT J (z).
Proof :
) hx, yi PT J (z), definition PT J , follows immediately
hx, yi PT J (z).
) Let hx, yi PT J (z). Then, definition PT J , follows holds (i)
z P ropI (ii) w ResJ , s.t. hw, zi PT J (J(subPropertyOf )).
(i) Assume z P ropI . Then, hz, I(Property)i PT (I(type)). implies
hz, J(Property)i PT (J(type)). (PT1), follows hz, J(v)i PT J (J(type)).
Therefore, z P ropJ . definition PT J , follows hx, yi PT J (z).
78

fiExtended RDF Semantic Foundation Rule Markup Languages

(ii) Assume w ResJ s.t. hw, zi PT J (J(subPropertyOf )). Then, (PT13),
follows hz, J(Property)i PT J (J(type)). Therefore, z P ropJ . definition
PT J , follows hx, yi PT J (z).
End Lemma
Though mentioned explicitly, Lemma used throughout rest
proof.
show J partial interpretation V , enough show V PL LV J .
Let x V PL. Then, x LV . Thus, hx, I(Literal)i PT (I(type)). Due (PT1),
implies hx, J(Literal)i PT J (J(type)). Thus, x LV J .
Now, extend J ontological categories:
ClsJ = {x ResJ | hx, J(Class)i PT J (J(type))},
TCls J = {x ResJ | hx, J(TotalClass)i PT J (J(type))},
TProp J = {x ResJ | hx, J(TotalProperty)i PT J (J(type))}.
define CT J , CF J : ClsJ P(ResJ ) follows:
x CT J (y) iff hx, yi PT J (J(type)),
x CF J (y) iff hx, yi PF J (J(type)).
show J ERDF interpretation V . Specifically, show
J satisfies semantic conditions Definition 3.7 (ERDF interpretation) Definition
3.2 (Coherent ERDF interpretation).
First, show J satisfies semantic condition 2 Definition 3.7. start
proving ResJ = CT J (J(Resource)). Obviously,
CT J (J(Resource)) ResJ . Thus, enough prove ResJ CT J (J(Resource)).
Let x ResJ . Then, distinguish following cases:
Case 1) x ResI . Since RDFS interpretation, holds hx, I(Resource)i
PT (I(type)). Thus, holds hx, J(Resource)i PT J (J(type)), implies x
CT J (J(Resource)).
Case 2) x res(VERDF ). definition PT J , follows
hx, J(Resource)i PT J (J(type)). Thus, hx, J(Resource)i PT J (J(type)), implies
x CT J (J(Resource)).
Thus, ResJ = CT J (J(Resource)).
Additionally, easy see holds P ropJ = CT J (J(Property)), ClsJ =
CT J (J(Class)), LV J = CT J (J(Literal)), TCls J = CT J (J(TotalClass)),
TProp J = CT J (J(TotalProperty)).
show J satisfies semantic condition 3 Definition 3.7. Let hx, yi
PT J (J(domain)) hz, wi PT J (x). Then, (PT4) definition CT J ,
follows z CT J (y).
show J satisfies semantic condition 4 Definition 3.7. Let hx, yi
PT J (J(range)) hz, wi PT J (x). Then, (PT5) definition CT J ,
follows w CT J (y).
show J satisfies semantic condition 5 Definition 3.7. Let x
ClsJ . Thus, holds: hx, J(Class)i PT J (J(type)). (PT6), follows
hx, J(Resource)i PT J (J(subClassOf )).
79

fiAnalyti, Antoniou, Damasio, & Wagner

show J satisfies semantic condition 6 Definition 3.7. Let hx, yi
PT J (J(subClassOf )). Then, (PT7), (PT8), definition CT J , follows
x, ClsJ .
Let hx, yi PT J (J(subClassOf )). show CT J (x) CT J (y). particular,
let z CT J (x). Then, (PT9) definition CT J , follows z CT J (y).
Let hx, yi PT J (J(subClassOf )). show CF J (y) CF J (x). particular,
let z CF J (y). Then, (PF4) definition CF J , follows z CF J (x).
similar manner, prove J satisfies semantic conditions 7, 8, 9,
10, 11 Definition 3.7.
continue rest proof, need make observations.
Consider mapping h : ResJ ResI , defined follows:

x ResI
x
I(Class)
x = res(TotalClass)
h(x) =

I(Property) x = res(TotalProperty)

Observation 1: hx, yi PT J (z) res(VERDF ) x = y.
Observation 2: x res(VERDF ) x P ropJ PT J (x) = .
Observation 3: hx, yi PT J (z) hh(x), h(y)i PT (h(z)).
Observation 4: x, y, z ResI hx, yi PT J (z) hx, yi PT (z)23 .
proof observations made induction. easy see observations
hold derivations (PT1), (PT2), (PT3). Assume observations
hold derivations obtained step k application fixpoint operator
PT J . Then, observations hold derivations obtained step k + 1.
show J satisfies semantic condition 12 Definition 3.7. Let x
TCls J . Thus, hx, J(TotalClass)i PT J (J(type)). Observation 1, follows x =
J(TotalClass). (PF2), follows CT J (J(TotalClass))CF J (J(TotalClass)) =
ResJ . Thus, CT J (x) CF J (x) = ResJ .
show J satisfies semantic condition 13 Definition 3.7. Let x
TProp J . Thus, hx, J(TotalProperty)i PT J (J(type)). Observation 1, follows
x = J(TotalProperty). (PF3), follows PT J (J(TotalProperty))
PF J (J(TotalProperty)) = ResJ ResJ . Thus, PT J (x) PF J (x) = ResJ ResJ .
show J satisfies semantic condition 14 Definition 3.7.
Let srdf :XMLLiteral well-typed XML-Literal V ILJ (srdf :XMLLiteral )
= ILI (srdf :XMLLiteral ) XML value s. Additionally, since RDFS
interpretation V , holds: hILI (srdf :XMLLiteral ), I(XMLLiteral )i PT (I(type)).
Therefore, (PT1), follows hILJ (srdf :XMLLiteral ), J(XMLLiteral )i
PT J (J(type)).
show J satisfies semantic condition 15 Definition 3.7. Let
srdf :XMLLiteral V s.t. well-typed XML literal string. Assume
ILJ (srdf :XMLLiteral ) LV J . Then, hILJ (srdf :XMLLiteral ), J(Literal)i
PT J (J(type)). Observation 4, follows hILJ (srdf :XMLLiteral ), J(Literal)i
PT (J(type)). Therefore, follows hILI (srdf :XMLLiteral ), I(Literal)i
23. Note Observation 3 implies Observation 4.

80

fiExtended RDF Semantic Foundation Rule Markup Languages

PT (I(type)). Thus, ILI (srdf :XMLLiteral ) LV , impossible since
RDFS interpretation V . Therefore, ILJ (srdf :XMLLiteral ) ResJ LV J .
Additionally, (PF1), follows hILJ (srdf :XMLLiteral ), J(Literal)i
PF J (J(type)).
J satisfies semantic condition 16 Definition 3.7, due (PT1). Finally, J satisfies
semantic condition 17, due (PT2) (PT3).
Thus, J ERDF interpretation V .
Now, show J coherent ERDF interpretation (Definition 3.2). Assume
case. Thus, z P ropJ s.t. PT J (z) PF J (z) 6= . Assume
hx, yi PT J (z) PF J (z), z. distinguish following cases:
Case 1) z res(VERDF ). Then, Observation 2, follows PT J (z) = ,
contradiction.
Case 2) res(VERDF ) z ResI . Then, holds:
(i) hz, res(TotalProperty)i PT J (J(subPropertyOf )),
(ii) hz, J(type)i PT J (J(subPropertyOf )) hx, yi PF J (J(type)).
Now, Observation 1 since z ResI , (i) impossible. Thus, hz, J(type)i
PT J (J(subPropertyOf )) hx, yi PF J (J(type)). implies
= res(TotalClass). Observation 1, follows x = res(TotalClass),
impossible since, due (PF2), hres(TotalClass), res(TotalClass)i 6 PF J (J(type)).
Case 3) x res(VERDF ) y, z ResI . Then, holds:
(i) hz, res(TotalProperty)i PT J (J(subPropertyOf )),
(ii) hz, J(type)i PT J (J(subPropertyOf )) hx, yi PF J (J(type)).
Now, Observation 1 since z ResI , (i) impossible. Thus, hz, J(type)i
PT J (J(subPropertyOf )) hx, yi PF J (J(type)). implies
= res(TotalClass), impossible, since ResI .
Case 4) x, y, z ResI . Then, x = ILJ (s), ill-typed XML-Literal
V , hz, J(type)i PT J (J(subPropertyOf )) hy, J(Literal)i PT J (J(subClassOf )).
Since hx, yi PT J (z), follows hx, yi PT J (J(type)). Since hy, J(Literal)i
PT J (J(subClassOf )), follows hx, J(Literal)i PT J (J(type)). Observation 4,
follows hILJ (s), J(Literal)i PT (J(type)). Therefore,
hILI (s), I(Literal)i PT (I(type)). implies ILI (s) LV , impossible since RDFS interpretation V .
Since cases lead contradiction, follows that:
z P ropJ , PT J (z) PF J (z) = .
show J, v |= G. Let p(s, o) G. Since I, v |= G, holds
p V , s, V Var . Note that, due (PT1), holds P ropI P ropJ . Since
p 6 VERDF , holds J(p) = I(p) P ropI P ropJ . Since s, 6 VERDF , holds
[I + v](s) = [J + v](s) [I + v](o) = [J + v](o). Since I, v |= G, holds h[I + v](s), [I +
v](o)i PT (I(p)). Thus, h[J + v](s), [J + v](o)i PT (J(p)). (PT1), follows
h[J + v](s), [J + v](o)i PT J (J(p)). Thus, J, v |= G, implies J |= G.
Since J ERDF interpretation G |=ERDF G , follows J |= G . Thus,
u : Var (G ) ResJ = ResI res(VERDF ) s.t. J, u |= G . define mapping
u : Var (G ) ResI follows:
81

fiAnalyti, Antoniou, Damasio, & Wagner


u(x) ResI
u(x)
I(Class)
u(x) = res(TotalClass)
u (x) =

I(Property) u(x) = res(TotalProperty)

show I, u |= G . Let p(s, o) G . Since J |= G VG VERDF = ,
follows p V VRDF VRDF , s, V VRDF VRDF Var , J(p)
P ropJ . Thus, hJ(p), J(type)i PT J (J(Property)), implies (since p 6 VERDF )
hI(p), I(type)i PT J (I(Property). Due Observation 4, follows hI(p), I(type)i
PT (I(Property). Thus, I(p) P ropI . Additionally, holds: h[J + u](s), [J + u](o)i
PT J (J(p)). want show h[I + u ](s), [I + u ](o)i PT (I(p)).
Case 1) holds: (i) Var (G ) u(s) 6 res(VERDF ) (ii) Var (G )
u(o) 6 res(VERDF ).
Then, [J + u](s) = [J + u ](s) = [I + u ](s) ResI , [J + u](o) = [J + u ](o) = [I +
u ](o) ResI , J(p) = I(p) ResI . Thus, h[J + u](s), [J + u](o)i PT J (J(p)) implies
h[I + u ](s), [I + u ](o)i PT J (I(p)). Observation 4, latter implies
h[I + u ](s), [I + u ](o)i PT (I(p)).
Case 2) holds: (i) Var (G ) u(s) res(VERDF ) (ii) Var (G )
u(o) 6 res(VERDF ).
Assume u(s) = res(TotalClass), [J + u](o) = y, J(p) = z. y, z ResI .
Additionally, I(p) = J(p) = z [I + u ](o) = [J + u](o) = y. Thus, h[I + u ](s), [I +
u ](o)i = hI(Class), yi. holds hres(TotalClass), yi PT J (z). Due Observation 3,
holds hI(Class), yi PT (z). Thus, h[I + u ](s), [I + u ](o)i = hI(Class), yi PT (z) =
PT (I(p)).
Similarly, u(s) = res(TotalProperty), prove h[I+u ](s), [I+u ](o)i PT (I(p)).
Case 3) holds: Var (G ) u(o) res(VERDF ). Then, Observation 1,
follows Var (G ) u(s) = u(o). Assume u(o) = res(TotalClass),
J(p) = z. Then, z ResI I(p) = J(p) = z. Additionally, h[I + u ](s), [I + u ](o)i =
hI(Class), I(Class)i. holds hres(TotalClass), res(TotalClass)i PT J (z). Due Observation 3, follows hI(Class), I(v)i PT (z). Thus, h[I + u ](s), [I + u ](o)i =
hI(Class), I(Class)i PT (z) = PT (I(p)).
Similarly, u(o) = res(TotalProperty), prove h[I+u ](s), [I+u ](o)i PT (I(p)).
cases, holds h[I + u ](s), [I + u ](o)i = PT (I(p)), follows I, u |= G ,
implies |= G .
) Let G |=RDF G . show G |=ERDF G . Let ERDF interpretation
vocabulary V , |= G. Thus, u : Var (G) ResI s.t. I, u |= G.
show |= G .
define V = V VRDF VRDF VERDF . Based I, construct RDFS interpretation J V that: ResJ = ResI , P ropJ = P ropI , LV J = LV , ClsJ =
ClsI , JV (x) = IV (x), x V URI, PT J (x) = PT (x), x P ropJ , ILJ (x) =
ILI (x), x V L, CT J (x) = CT (x), x ClsJ .
show J indeed RDFS interpretation V .
First, show J satisfies semantic condition 1 Definition A.3 (Appendix
A, RDF interpretation). holds: x P ropJ iff x P ropI iff x CT (I(Property)) iff
hx, I(Property)i PT (I(type)) iff hx, J(Property)i PT J (J(type)).
82

fiExtended RDF Semantic Foundation Rule Markup Languages

show J satisfies semantic condition 2 Definition A.3.
Let srdf :XMLLiteral V well-typed XML literal string. Then,
follows definition J fact ERDF interpretation V
ILJ (srdf :XMLLiteral ) XML value s, ILJ (srdf :XMLLiteral )
CT J (J(XMLLiteral )). show ILJ (srdf :XMLLiteral ) LV J . Since
ERDF interpretation, ILI (srdf :XMLLiteral ) CT (I(XMLLiteral )). Additionally,
hI(XMLLiteral ), I(Literal)i PT (I(subClassOf )). Therefore, ILI (srdf :XMLLiteral )
CT (I(Literal)), thus, ILI (srdf :XMLLiteral ) LV . last statement implies
ILJ (srdf :XMLLiteral ) LV J .
show J satisfies semantic condition 3 Definition A.3.
Let srdf :XMLLiteral V ill-typed XML literal string. Then,
follows definition J fact ERDF interpretation V
ILJ (srdf :XMLLiteral ) ResJ LV J . show
hILJ (srdf :XMLLiteral ), J(XMLLiteral )i 6 PT J (J(type)). Assume
hILJ (srdf :XMLLiteral ), J(XMLLiteral )i PT J (J(type)). Then,
hILI (srdf :XMLLiteral ), I(XMLLiteral )i PT (I(type)). Thus,
ILI (srdf :XMLLiteral ) CT (I(XMLLiteral )). Since holds
hI(XMLLiteral ), I(Literal)i PT (I(subClassOf )), follows
ILI (srdf :XMLLiteral ) CT (I(Literal)). Thus, ILI (srdf :XMLLiteral ) LV ,
impossible since ERDF interpretation V . Therefore,
hILJ (srdf :XMLLiteral ), J(XMLLiteral )i 6 PT J (J(type)).
easy see J satisfies semantic condition 4 Definition A.3
semantic conditions Definition A.5 (Appendix A, RDFS Interpretation). Therefore, J
RDFS interpretation V .
show J, u |= G. Let p(s, o) G. Since |= G, holds p V ,
s, V Var , J(p) = I(p) P ropI = P ropJ . holds: h[J + u](s), [J + u](o)i
PT J (J(p)) iff h[I + u](s)), [I + u](o)i P ropI (I(p)), true, since I, u |= G. Thus,
J, u |= G, implies J |= G. Since G |=RDF G , follows J |= G . Thus,
v : Var (G ) ResJ s.t. J, v |= G .
show |= G . Let p(s, o) G . Since J, v |= G , holds p V ,
s, V Var , I(p) = J(p) P ropJ = P ropI . holds: h[I + v](s), [I + v](o)i
PT (I(p)) iff h[J + v](s), [J + v](o)i PT J (J(p)), true, since J, v |= G . Thus,
I, v |= G , implies |= G .
Proposition 4.1. Let G ERDF graph let F ERDF formula
VF skG (Var (G)) = . holds: G |=ERDF F iff sk(G) |=ERDF F .
Proof:
) Let G |=ERDF F . show sk(G) |=ERDF F . Let ERDF interpretation
vocabulary V s.t. |= sk(G). show |= G. define V = V VRDF
VRDF VERDF . Additionally, define total function u : Var (G) ResI s.t. u(x) =
IV (skG (x)), x Var (G). Moreover, define total function u : V Var (G) V s.t.
u (x) = skG (x), x Var (G) u (x) = x, otherwise.
Let p(s, o) G. Then, p V , s, V Var , I(p) P ropI . holds: h[I+u](s), [I+
u](o)i PT (I(p)) iff hI(u (s)), I(u (o))i PT (I(p)), true, since p(u (s), u (o))
sk(G) |= sk(G). Thus, I, u |= p(s, o).
83

fiAnalyti, Antoniou, Damasio, & Wagner

Let p(s, o) G. Then, p V , s, V Var , I(p) P ropI . holds:
h[I + u](s), [I + u](o)i PF (I(p)) iff hI(u (s)), I(u (o))i PF (I(p)), true, since
p(u (s), u (o)) sk(G) |= sk(G). Thus, I, u |= p(s, o).
Therefore, |= G. Since G |=ERDF F , follows |= F .
) Let sk(G) |=ERDF F . show G |=ERDF F . Let ERDF interpretation
vocabulary V |= G. show |= F . Since |= G, total
function u : Var (G) ResI s.t. I, u |= G. define V = V VRDF VRDF VRDF .
construct ERDF interpretation J V skG (Var (G)) follows: ResJ = ResI , P ropJ =
P ropI , LV J = LV , ClsJ = ClsI . define JV : (V skG (Var (G))) URI ResJ ,
1
follows: JV (x) = IV (x), x V URI JV (x) = u(skG
(x)), x skG (Var (G)).
Moreover, PT J (x) = PT (x), x P ropJ , PF J (x) = PF (x), x P ropJ , ILJ (x) =
ILI (x), x V L, CT J (x) = CT (x), x ClsJ , CF J (x) = CF (x), x ClsJ .
Since ERDF interpretation V , easy see J indeed ERDF interpretation V skG (Var (G)). show J |= sk(G). First, define total func1
tion g : V skG (Var (G)) V Var (G) follows: g(x) = skG
(x), x skG (Var (G))
g(x) = x, otherwise. Let p(s, o) sk(G). Since |= G, follows p V ,
s, V Var , J(p) = I(p) P ropI = P ropJ . holds J(s) = [I + u](g(s)),
J(o) = [I + u](g(o)), J(p) = I(p). Therefore, holds: hJ(s), J(o)i PT J (J(p)) iff
h[I + u](g(s)), [I + u](g(o))i PT (I(p)), holds since p(g(s), g(o)) G I, u |= G.
Let v : {} ResJ . follows J, v |= p(s, o). Let p(s, o) sk(G). show
J, v |= p(s, o), similar manner. Therefore, J |= sk(G).
Since sk(G) |=ERDF F , follows J |= F . show |= F . define
V = V VRDF VRDF VERDF . Note ResJ = ResI .


Lemma: every mapping u : Var (F ) ResJ , holds J, u |= F iff I, u |= F .
Proof: prove Lemma induction. Without loss generality, assume
appears front positive ERDF triples. Otherwise apply transformation
rules Definition 3.4, get equivalent formula satisfies assumption.
Let F = p(s, o). Assume J, u |= F . Since VF skG (Var (G)) = , follows
p V , s, V Var , J(p) = I(p) P ropI = P ropJ . Since h[J + u](s), [J + u](o)i
PT J (J(p)), follows h[I + u](s), [I + u](o)i PT (I(p)). Therefore, I, u |= F .
Assume I, u |= F . follows p V , s, V Var , J(p) = I(p) P ropI =
P ropJ . Since h[I + u](s), [I + u](o)i PT (I(p)), follows h[J + u](s), [J + u](o)i
PT J (J(p)). Therefore, J, u |= F .
Let F = p(s, o). Similarly, prove J, u |= F iff I, u |= F .
Assumption: Assume lemma holds subformulas F .
show lemma holds F .
Let F = G. holds: I, u |= F iff VG V I, u 6|= G iff VG V J, u 6|= G iff
J, u |= F .
Let F = F1 F2 . holds: I, u |= F iff I, u |= F1 I, u |= F2 iff J, u |= F1
J, u |= F2 iff J, u |= F .
84

fiExtended RDF Semantic Foundation Rule Markup Languages

Let F = x G. holds: I, u |= F iff I, u |= x G iff v : Var (G) ResI
s.t. v(y) = u(y), Var (G) {x} I, v |= G iff v : Var (G) ResJ s.t.
v(y) = u(y), Var (G) {x} J, v |= G iff J, u |= x G iff J, u |= F .
Let F = F1 F2 F = F1 F2 F = xG. prove, similarly
cases, I, u |= F iff J, u |= F .
End lemma
Since J |= F , follows every mapping u : Var (F ) ResJ ,
J, u |= F .
Therefore, follows Lemma fact ResJ = ResI every mapping
u : Var (F ) ResI , I, u |= F . Thus, |= F .
Proposition 4.2. Let = hG, P ERDF ontology let I, J H (O). Let
p TProp TProp J . PT (p) 6= PT J (p) PF (p) 6= PF J (p) 6 J J 6 I.
Proof: Assume PT (p) 6= PT J (p). Now, assume J. Then, PT (p) PT J (p)
PF (p) PF J (p). Since I, J H (O) p TProp TProp J , holds
H
PF (p) = ResH
PT (p) PF J (p) = ResO PT J (p). Thus, PF (p) PF J (p),
contradiction. Thus, 6 J. Similarly, prove J 6 I.
Assume PF (p) 6= PF J (p). Then, prove 6 J J 6 I,
similar manner.
Proposition 5.1. Let = hG, P ERDF ontology let Mst (O). holds
MH (O).
Proof: Let Mst (O). Obviously, H (O) |= sk(G). show
|= r, r P . Let r P . Let v mapping v : Var (r) ResH
s.t. M, v |= Cond(r).
enough show M, v |= Concl(r).
mapping u : X ResH (O), X Var , define mapping u : X
VO follows:

u(x) u(x) xml value well-typed XML literal VO
u (x) =

u(x) xml value well-typed XML literal VO




Let x VO , define xu = x. Let x X, define xu = u (x). Let F L(VO )

{true, f alse} FVar (F ) X, define F u formula results F

replacing free variable F u (x). easy see holds: Concl(r)v

Concl(r)v [r]VO [P ]VO .
Lemma: Let F ERDF formula VO let u mapping u : Var (F ) ResH
O.

holds: M, u |= F iff M, u |= F u .
Proof: prove lemma induction. Without loss generality, assume
appears front positive ERDF triples. Otherwise apply transformation
rules Definition 3.4, get equivalent formula satisfies assumption.
Let F = p(s, o). holds: M, u |= F iff M, u |= p(s, o) iff h[M + u](s), [M + u](o)i



PT (M (p)) iff h[M + u](su ), [M + u](ou )i PT (M (p)) iff M, u |= p(s, o)u .
Let F = p(s, o). holds: M, u |= F iff M, u |= p(s, o) iff h[M + u](s), [M + u](o)i



PF (M (p)) iff h[M + u](su ), [M + u](ou )i PF (M (p)) iff M, u |= (p(s, o))u .
Assumption: Assume lemma holds subformulas F .
show lemma holds F .
85

fiAnalyti, Antoniou, Damasio, & Wagner



Let F = G. holds: M, u |= F iff M, u |= G iff M, u 6|= G iff M, u 6|= Gu iff


M, u |= Gu iff M, u |= F u .
Let F = F1 F2 . holds: M, u |= F iff M, u |= F1 F2 iff M, u |= F1 M, u |= F2 iff




M, u |= F1u M, u |= F2u iff M, u |= (F1 F2 )u iff M, u |= F u .
Let F = xG. holds: M, u |= F iff exists mapping u1 : Var (G) ResH
s.t.
u1 (y) = u(y), Var (G) {x} s.t. M, u1 |= G iff exists mapping u1 : Var (G)
u1 iff exists mapping
ResH
s.t. u1 (y) = u(y), Var (G) {x} s.t. M, u1 |= G

u1 : Var (G) ResH
u1 |= (xG)u1 iff (since
s.t. u1 (y) = u(y), Var(G) {x} s.t. M,

u1 (y) = u (y), FVar (xG)) M, u |= (xG)u iff M, u |= F u .
Let F = F1 F2 F = F1 F2 F = xG. prove, similarly

cases, M, u |= F iff M, u |= F u .
End Lemma
First assume Cond(r) 6= true. Then, Cond(r) L(VO ) thus, Cond(r) ERDF

formula VO . Since M, v |= Cond(r), follows Lemma M, v |= Cond(r)v .


since FVar (Cond(r)v ) = , follows Lemma B.1 |= Cond(r)v . Since

Mst (O), follows |= Concl(r)v . Thus, Concl(r) 6= f alse Concl(r)

L(VO |{}). since FVar (Concl(r)v ) = , follows lemma B.1 M, v |=

Concl(r)v . Since Concl(r) ERDF formula VO , follows Lemma
M, v |= Concl(r).

Assume Cond(r) = true. Then, |= Cond(r)v . Since Mst (O),

follows |= Concl(r)v . Therefore, Concl(r) 6= f alse, prove
M, v |= Concl(r).
Therefore, |= r, r P .
Proposition 5.2. Let = hG, P ERDF ontology,
rdfs:subClassOf (rdf :Property, erdf :TotalProperty) G. Then, Mst (O) = MH (O).
Proof: Proposition 5.1, follows Mst (O) MH (O). show
MH (O) Mst (O). Let MH (O). follows |= sk(G). show
minimal({I H (O) | |= sk(G)}).
Let J H (O) s.t. J |= sk(G) J . show J = . Since J ,
follows P ropJ P ropM p P ropJ , holds PT J (p) PT (p)
PF J (p) PF (p). Let p P ropJ . Since J |= sk(G), follows P ropJ TProp J .
Thus, p TProp J . Assume PT J (p) 6= PT (p). Then, hx, yi PT (p)
s.t. hx, yi 6 PT J (p). Then, hx, yi PF J (p). Thus, hx, yi PF (p), impossible,
since hx, yi PT (p). Thus, PT J (p) = PT (p). Similarly, prove PF J (p) =
PF (p). Therefore, p P ropJ , holds PT J (p) = PT (p) PF J (p) = PF (p).
show P ropJ = P ropM . holds P ropJ ={x ResH
| hx, Propertyi
PT J (type)} = {x ResH
|
hx,
Propertyi

PT
(type)}
=P
rop
.
Based
results,



fact J, H (O), follows J = . Therefore, minimal({I
H (O) | |= sk(G)}).
show minimal({I H (O) | |= Concl(r),
r P[M,M ] }). Since MH (O) follows {I H (O) |
|= Concl(r), r P[M,M ] }. Let J {I H (O) | |= Concl(r),
r P[M,M ] } J . Since J , follows P ropM P ropJ ,
p P ropM , holds PT (p) PT J (p) PF (p) PF J (p). Since J ,
86

fiExtended RDF Semantic Foundation Rule Markup Languages

follows P ropJ P ropM , p P ropJ , holds PT J (p) PT (p)
PF J (p) PF (p). Therefore, follows P ropM = P ropJ , p P ropM ,
holds PT (p) = PT J (p) PF (p) = PF J (p). Based result, fact
J, H (O), follows J = .
Thus, minimal({I H (O) | |= Concl(r), r P[M,M ] }).
Since satisfies conditions Definition 5.1 (Stable Model), follows
st
(O). Thus, holds MH (O) Mst (O).
Therefore, MH (O) = Mst (O).
Proposition 6.2. Let G ERDF graph let F ERDF formula
VF skG (Var (G)) = . holds:
1. F ERDF d-formula hG, |=st F G |=ERDF F .
2. G |=ERDF F hG, |=st F .
Proof:
1) Let hG, |=st F . show sk(G) |=ERDF F . Let ERDF interpretation
vocabulary V s.t. |= sk(G). show |= F . define V = V VRDF
VRDF VERDF .
Let = hG, i. Based I, construct partial interpretation J VO follows:
ResJ = ResH
O.
JV (x) = x, x VO URI.
define mapping: ILJ : VO L ResJ that:
ILJ (x) = x, x typed literal VO well-typed XML literal,
ILI (x) XML value x, x well-typed XML literal VO .
define mapping: J : VO ResJ that:
J(x) = JV (x), x VO URI.
J(x) = x, x VO PL.
J(x) = ILJ (x), x VO L.
P ropJ = {x ResJ | x VO , J(x ) = x I(x ) P ropI }.
mapping PT J : P ropJ P(ResJ ResJ ) defined follows:
x, y, z VO , holds:
hJ(x), J(y)i PT J (J(z)) iff hI(x), I(y)i PT (I(z)).
define mapping PF J : P ropJ P(ResJ ResJ ) follows:
x, y, z VO , holds:
hJ(x), J(y)i PF J (J(z)) iff hI(x), I(y)i PF (I(z)).
LV J = {x ResJ | hx, J(Literal)i PT J (J(type))}.
87

fiAnalyti, Antoniou, Damasio, & Wagner

show J partial interpretation, enough show VO PL LV J .
Let x VO PL. Then, x LV . Thus, hx, I(Literal)i PT (I(type)). implies
hx, J(Literal)i PT J (J(type)). Thus, x LV J .
Now, extend J ontological categories:
ClsJ = {x ResJ | hx, J(Class)i PT J (J(type))},
TCls J = {x ResJ | hx, J(TotalClass)i PT J (J(type))},
TProp J = {x ResJ | hx, J(TotalProperty)i PT J (J(type))}.
define mappings CT J , CF J : ClsJ P(ResJ ) follows:
x CT J (y) iff hx, yi PT J (J(type)),
x CF J (y) iff hx, yi PF J (J(type)).
show J ERDF interpretation VO . First, show
J satisfies semantic condition 2 Definition 3.7 (ERDF Interpretation), number
steps:
Step 1: Here, prove ResJ = CT J (J(Resource)). Obviously, CT J (J(Resource))
ResJ . show ResJ CT J (J(Resource)). Let x ResJ . Then,
x VO J(x ) = x. want show hJ(x ), J(Resource)i PT J (J(type)).
holds: hJ(x ), J(Resource)i PT J (J(type)) iff hI(x ), I(Resource)i PT (I(type)),
true, since ERDF interpretation satisfies sk(G) I(x ) ResI .
Thus, x = J(x ) CT J (J(ResourceResource)).
Therefore, ResJ = CT J (J(Resource)).
Step 2: Here, prove P ropJ = CT J (J(Property)). show P ropJ
CT J (J(Property)). Let x P ropJ . Then, x VO J(x ) = x
I(x ) P ropI . want show hJ(x ), J(Property)i PT J (J(type)). holds:
hJ(x ), J(Property)i PT J (J(type)) iff hI(x ), I(Property)i PT (I(type)),
true, since I(x ) P ropI . Thus, x = J(x ) CT J (J(Property)).
Therefore, P ropJ CT J (J(Property)).
show CT J (J(Property)) P ropJ . Let x CT J (J(Property)). Then,
x VO J(x ) = x. holds hJ(x ), J(Property)i PT J (J(type)), implies
hI(x ), I(Property)i PT (I(type)). Thus, I(x ) P ropI x P ropJ .
Therefore, CT J (J(Property)) P ropJ .
Step 3: definition, holds ClsJ = CT J (J(Class)), LV J = CT J (J(Literal)), TCls J =
CT J (J(TotalClass)) TProp J = CT J (J(TotalProperty)).
show J satisfies semantic condition 3 Definition 3.7 (ERDF Interpretation). Let hx, yi PT J (J(domain)) hz, wi PT J (x). show
z CT J (y). x , VO J(x ) = x, J(y ) = y. Thus,
hJ(x ), J(y )i PT J (J(domain)). Additionally, z , w VO J(z ) =
z, J(w ) = w. Thus, hJ(z ), J(w )i PT J (J(x )). Then, hI(x ), I(y )i PT (I(domain))
hI(z ), I(w )i PT (I(x )). Since ERDF interpretation, hI(z ), I(y )i
PT (I(type)). Thus, hJ(z ), J(y )i PT J (J(type)) z CT J (y).
similar manner, prove J satisfies rest semantic conditions
Definition 3.7. Thus, J ERDF interpretation VO .
Moreover, show J coherent ERDF interpretation (Definition 3.2).
Assume case. Thus, z P ropJ s.t. PT J (z) PF J (z) 6= .
Thus, x, ResJ s.t. hx, yi PT J (z) PF J (z), z. Then,
88

fiExtended RDF Semantic Foundation Rule Markup Languages

x , , z VO s.t. J(x ) = x, J(y ) = y, J(z ) = z. holds: hJ(x ), J(y )i PT J (J(z ))
hJ(x ), J(y )i PF J (J(z )). Thus, hI(x ), I(y )i PT (I(z )) hI(x ), I(y )i
PF (I(z )). impossible, since (coherent) ERDF interpretation. Therefore,
J coherent ERDF interpretation.
Thus, J H (O).
show J |= sk(G). Let p(s, o) sk(G). holds p, s, VO . Since
|= sk(G), holds I(p) P ropI . Thus, hI(p), I(Property)i PT (I(type)), implies
hJ(p), J(Property)i PT J (J(type)). this, follows J(p) P ropJ .
holds: hJ(s), J(o)i PT J (J(p)) iff hI(s), I(o)i PT (I(p)). last statement true
since |= sk(G). Let u : {} ResH
. Then, J, u |= p(s, o). Let p(s, o) sk(G).
show J, u |= p(s, o), similar manner. Thus, J |= sk(G).
Now, Definition 5.1 (Stable Model) fact J |= sk(G), follows
K Mst (O) s.t. K J. fact |=st F , follows K |= F .
Since F ERDF d-formula, holds
F = (?x1 , ..., ?xk1 F1 ) ... (?x1 , ..., ?xkn Fn ),
= t1 ... tmi tj , j = 1, ..., mi , ERDF triple. Thus,
{1, ..., n} u : Var (Fi ) ResH
s.t. K, u |= .
show J, u |= .
Let p(s, o) {t1 , ..., tmi }. Since K ERDF interpretation VO , K, u |= ,
P ropK P ropJ , follows p VO , s, VO Var , J(p) = K(p) P ropK
P ropJ . Additionally, h[K +u](s), [K +u](o)i PT K (p). Since h[J +u](s), [J +u](o)i = h[K +
u](s), [K + u](o)i PT K (p) PT J (p), follows h[J + u](s), [J + u](o)i PT J (p).
Thus, J, u |= p(s, o).
Let p(s, o) {t1 , ..., tmi }. Since K ERDF interpretation VO , K, u |= ,
P ropK P ropJ , follows p VO , s, VO Var , J(p) = K(p) P ropK
P ropJ . Additionally, h[K +u](s), [K +u](o)i PF K (p). Since h[J +u](s), [J +u](o)i = h[K +
u](s), [K + u](o)i PF K (p) PF J (p), follows h[J + u](s), [J + u](o)i PF J (p).
Thus, J, u |= p(s, o).
define total function u : VFi Var (Fi ) VO , follows:

u(x) x Var (Fi )




u(x) xml value well-typed XML literal VO


x Var (Fi )
u (x) =


u(x) xml value well-typed XML literal VO



x
otherwise

Moreover, define total function u : Var (Fi ) ResI s.t. u (x) = I(u (x)).
show I, u |= .
Let p(s, o) {t1 , ..., tmi }. Then, p VFi s, VFi Var . Since J, u |= , follows
VFi VO . Therefore, VFi Vsk(G) VRDF VRDF VERDF V . Thus, p V
s, V Var .
show I(p) P ropI . holds:
hI(p), I(Property)i PT (I(type)) iff
hJ(p), J(Property)i PT J (J(type)), holds since J, u |= .
89

fiAnalyti, Antoniou, Damasio, & Wagner

want show h[I +v ](s), [I +v ](o)i PT (I(p)). Note x VFi , holds:
[I + u ](x) = I(u (x)) = I(x) J(u (x)) = [J + u](x) = J(x). Moreover, x Var (Fi ),
holds: [I + u ](x) = I(u (x)) J(u (x)) = [J + u](x) (recall definition J(.)).
Therefore, holds:
h[I + u ](s), [I + u ](o)i PT (I(p)) iff
hI(u (s)), I(u (o))i PT (I(p)) iff
hJ(u (s)), J(u (o))i PT J (J(p)) iff
h[J + u](s), [J + u](o)i PT J (J(p)), true since J, u |= . Thus, I, u |= p(s, o).
Let p(s, o) {t1 , ..., tmi }. show I, u |= p(s, o), similar manner.
Thus, I, u |= , implies I, u |= ?x1 , ..., ?xki . Thus, I, u |= F . Now,
follows Lemma B.1 |= F .
Thus, sk(G) |=ERDF F . Now, follows Proposition 4.1 G |=ERDF F .
2) Let G |=ERDF F . follows Proposition 4.1 sk(G) |=ERDF F . show
hG, |=st F . particular, let = hG, let Mst (O). Note
ERDF interpretation VO , |= sk(G). Since sk(G) |=ERDF F , follows
|= F .
Proposition 8.1 Let instance unbounded tiling problem. holds:
1. solution iff OD {false FD } stable model.
2. solution iff OD 6|=st FD .
Proof:
1) statement follows easily statement 2).
2) ) Let solution D. Since denumerable, exists bijective
function : . Consider Herbrand interpretation OD that:
1. CTI (Tile) = CTI (HasRight) = CTI (HasAbove) = {rdf : | }
CFI (T ile) = CFI (HasRight) = CFI (HasAbove) = .
2. P TI (id ) = {hx, xi | x VO } P (id ) = .
3. P TI (HConstraint) = H P (HConstraint) = .
4. P TI (VConstraint) = V P (VConstraint) = .
5. P TI (Type) = {hrdf : (i, j), (i, j)i | i, j } P (Type) = .
6. P TI (right) = {hrdf : (i, j), rdf : (i + 1, j)i | i, j }
P (right) = {hrdf : i, rdf : ji | i, j hrdf : i, rdf : ji 6 P TI (right)}.
7. P TI (above) = {hrdf : (i, j), rdf : (i, j + 1)i | i, j }
P (above) = {hrdf : i, rdf : ji | i, j hrdf : i, rdf : ji 6 P TI (above)}.

easy see stable model OD 6|= FD . Thus, OD 6|=st FD .
) Let = hT , H, V i, = {T1 , ..., Tn }. Assume OD 6|=st FD let
stable model OD = hG, P 6|= FD . Obviously, CTI (Tile) = {rdf : | }.
Due rule sets (2)-(4) P since OD 6|=st FD , holds starting tile rdf : 0
90

fiExtended RDF Semantic Foundation Rule Markup Languages

placing tiles according P TI (right) P TI (above) relations, grid formed.
define (i, j) = k, i, j, k , iff tile rdf : k placed hi, ji position
previous grid. Note total function. Due rule set (1) P , tile
assigned unique type = {T1 , ..., Tn }. Due rule set (5) P , type assignment
satisfies horizontal vertical adjacency constraints D. Thus, solution
: , (i, j) = iff hrdf : (i, j), P TI (T ype). Since total
function and, k , tile rdf : k assigned unique type , follows
total function.

References
Alferes, J. J., Damasio, C. V., & Pereira, L. M. (1995). Logic Programming System
Non-monotonic Reasoning. Special Issue Journal Automated Reasoning,
14 (1), 93147.
Alferes, J. J., Damasio, C. V., & Pereira, L. M. (2003). Semantic Web Logic Programming Tools. International Workshop Principles Practice Semantic Web
Reasoning (PPSWR03), pp. 1632.
Analyti, A., Antoniou, G., Damasio, C. V., & Wagner, G. (2004). Negation Negative
Information W3C Resource Description Framework. Annals Mathematics,
Computing & Teleinformatics (AMCT), 1 (2), 2534.
Analyti, A., Antoniou, G., Damasio, C. V., & Wagner, G. (2005). Stable Model Theory
Extended RDF Ontologies. 4th International Semantic Web Conference (ISWC2005), pp. 2136.
Antoniou, G., Bikakis, A., & Wagner, G. (2004). System Nonmonotonic Rules
Web. 3rd International Workshop Rules Rule Markup Languages
Semantic Web (RULEML03), pp. 2336.
Antoniou, G., Billington, D., Governatori, G., & Maher, M. J. (2001). Representation
Results Defeasible Logic. ACM Transactions Computational Logic (TOCL),
2 (2), 255287.
Baader, F., Calvanese, D., McGuinness, D. L., Nardi, D., & Patel-Schneider, P. F. (Eds.).
(2003). Description Logic Handbook: Theory, Implementation, Applications.
Cambridge University Press.
Bassiliades, N., Antoniou, G., & Vlahavas, I. P. (2004). DR-DEVICE: Defeasible Logic
System Semantic Web. 2nd International Workshop Principles
Practice Semantic Web Reasoning (PPSWR04), pp. 134148.
Beckett, D. (2004). RDF/XML Syntax Specification (Revised). W3C Recommendation.
Available http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/.
Berger, R. (1966). Undecidability Dominoe Problem. Memoirs American
Mathematical Society, 66, 172.
Berners-Lee, T. (1998). Design Issues - Architectual Philosophical Points. Personal
notes. Available http://www.w3.org/DesignIssues.
91

fiAnalyti, Antoniou, Damasio, & Wagner

Berners-Lee, T., Connolly, D., Kagal, L., Scharf, Y., & Hendler, J. (2008). N3Logic:
Logical Framework World Wide Web. published Theory Practice
Logic Programming (TPLP), Special Issue Logic Programming Web.
Bry, F., & Marchiori, M. (2005). Ten Theses Logic Languages Semantic Web.
3rd International Workshop Principles Practice Semantic Web Reasoning
(PPSWR-2005), pp. 4249.
Damasio, C. V., Analyti, A., Antoniou, G., & Wagner, G. (2006). Supporting Open
Closed World Reasoning Web. 4th Workshop Principles Practice
Semantic Web Reasoning (PPSWR-2006), pp. 149163.
de Bruijn, J., Franconi, E., & Tessaris, S. (2005). Logical Reconstruction Normative RDF.
OWL: Experiences Directions Workshop (OWLED-2005), Galway, Ireland.
Donini, F. M., Lenzerini, M., Nardi, D., & Schaerf, A. (1998). AL-log: Integrating Datalog
Description Logics. Journal Intelligent Information Systems, 10 (3), 227252.
Donini, F. M., Nardi, D., & Rosati, R. (2002). Description Logics Minimal Knowledge
Negation Failure. ACM Transactions Computational Logic, 3 (2), 177225.
Eiter, T., Lukasiewicz, T., Schindlauer, R., & Tompits, H. (2004a). Combining Answer Set
Programming Description Logics Semantic Web. 9th International
Conference Principles Knowledge Representation Reasoning (KR04), pp.
141151.
Eiter, T., Lukasiewicz, T., Schindlauer, R., & Tompits, H. (2004b). Well-Founded Semantics
Description Logic Programs Semantic Web. 3rd International Workshop
Rules Rule Markup Languages Semantic Web (RuleML04), pp. 8197.
Eiter, T., Ianni, G., Polleres, A., & Schindlauer, R. (2006). Answer Set Programming
Semantic Web. Tutorial co-located 3d European Semantic Web Conference
(ESWC-2006).
Gelder, A. V., Ross, K. A., & Schlipf, J. S. (1991). Well-Founded Semantics General
Logic Programs. Journal ACM, 38 (3), 620650.
Gelfond, M., & Lifschitz, V. (1988). Stable Model Semantics Logic Programming.
Kowalski, R., & Bowen, K. A. (Eds.), 5th International Conference Logic Programming, pp. 10701080. MIT Press.
Gelfond, M., & Lifschitz, V. (1990). Logic programs Classical Negation. Warren,
& Szeredi (Eds.), 7th International Conference Logic Programming, pp. 579597.
MIT Press.
Gelfond, M., & Lifschitz, V. (1991). Classical Negation Logic programs Disjunctive
Databases. New Generation Computing, 9, 365385.
Hayes, P. (2004). RDF Semantics. W3C Recommendation. Available http://www.w3.
org/TR/2004/REC-rdf-mt-20040210/.
Herre, H., Jaspars, J., & Wagner, G. (1999). Partial Logics Two Kinds Negation
Foundation Knowledge-Based Reasoning. Gabbay, D. M., & Wansing, H.
(Eds.), Negation? Kluwer Academic Publishers.
92

fiExtended RDF Semantic Foundation Rule Markup Languages

Herre, H., & Wagner, G. (1997). Stable Models Generated Stable Chain. Journal
Logic Programming, 30 (2), 165177.
Horrocks, I., & Patel-Schneider, P. F. (2003). Reducing OWL Entailment Description
Logic Satisfiability. 2nd International Semantic Web Conference (ISWC-2003),
pp. 1729.
Horrocks, I., & Patel-Schneider, P. F. (2004). Proposal OWL Rules Language.
13th International Conference World Wide Web (WWW04), pp. 723731. ACM
Press.
Horrocks, I., Patel-Schneider, P. F., Boley, H., Tabet, S., Grosof, B., & Dean, M.
(2004). SWRL: semantic web rule language combining OWL RuleML.
W3C Member Submission. Available http://www.w3.org/Submission/2004/
SUBM-SWRL-20040521/.
Kifer, M., Lausen, G., & Wu, J. (1995). Logical Foundations Object-Oriented FrameBased Languages. Journal ACM, 42 (4), 741843.
Klyne, G., & Carroll, J. J. (2004). Resource Description Framework (RDF): Concepts
Abstract Syntax. W3C Recommendation. Available http://www.w3.org/TR/
2004/REC-rdf-concepts-20040210/.
Levy, A. Y., & Rousset, M. (1998). Combining Horn Rules Description Logics
CARIN. Artificial Intelligence, 104 (1-2), 165209.
Lloyd, J. W., & Topor, R. W. (1984). Making Prolog Expressive. Journal Logic
Programming, 1 (3), 225240.
Maher, M. J. (2002). Model-Theoretic Semantics Defeasible Logic. ICLP 2002
Workshop Paraconsistent Computational Logic (PCL-2002), pp. 255287.
McGuinness, D. L., & van Harmelen, F. (2004).
OWL Web Ontology Language
Overview. W3C Recommendation. Available http://www.w3.org/TR/2004/
REC-owl-features-20040210/.
Motik, B., Sattler, U., & Studer, R. (2004). Query Answering OWL-DL Rules.
3rd International Semantic Web Conference (ISWC-2004), pp. 549563.
Patel-Schneider, P. F., Hayes, P., & Horrocks, I. (2004). OWL Web Ontology Language
Semantics Abstract Syntax. W3C Recommendation. Available http://www.
w3.org/TR/2004/REC-owl-semantics-20040210/.
Pereira, L. M., & Alferes, J. J. (1992). Well-Founded Semantics Logic Programs
Explicit Negation. Neumann, B. (Ed.), European Conference Artificial Intelligence, pp. 102106. John Wiley & Sons.
Prudhommeaux, E., & Seaborne, A. (2008). SPARQL Query Language RDF. W3C
Recommendation. Available http://www.w3.org/TR/rdf-sparql-query/.
Rao, P., Sagonas, K. F., Swift, T., Warren, D. S., & Freire, J. (1997). XSB: System
Efficiently Computing WFS. Proceedings 4th International Conference Logic
Programming Nonmonotonic Reasoning (LPNMR97), pp. 10701080.
93

fiAnalyti, Antoniou, Damasio, & Wagner

Rosati, R. (1999). Towards Expressive KR Systems Integrating Datalog Description
Logics: Preliminary Report. Proc. 1999 Description Logic Workshop (DL99),
pp. 160164.
Rosati, R. (2005). Decidability Complexity Integrating Ontologies Rules.
Journal Web Semantics, 3, 6173.
Schaffert, S., Bry, F., Besnard, P., Decker, H., Decker, S., Enguix, C. F., & Herzig, A.
(2005). Paraconsistent Reasoning Semantic Web. Workshop Uncertainty
Reasoning Semantic Web, co-located ISWC-2005, pp. 104105.
Sintek, M., & Decker, S. (2002). TRIPLE - Query, Inference, Transformation Language Semantic Web. 1st International Semantic Web Conference (ISWC2002), pp. 364378. Springer-Verlag.
ter Horst, H. J. (2004). Extending RDFS Entailment Lemma. 3rd International
Semantic Web Conference (ISWC-2004), pp. 7791.
ter Horst, H. J. (2005a). Combining RDF Part OWL Rules: Semantics, Decidability, Complexity. 4th International Semantic Web Conference (ISWC-2005),
pp. 668684.
ter Horst, H. J. (2005b). Completeness, Decidability Complexity Entailment
RDF Schema Semantic Extension Involving OWL Vocabulary. Journal
Web Semantics, 3 (2-3), 79115.
Wagner, G. (1991). Database Needs Two Kinds Negation. 3rd Symposium
Mathematical Fundamentals Database Knowledge Base Systems (MFDBS91),
pp. 357371. Springer-Verlag.
Wagner, G. (2003). Web Rules Need Two Kinds Negation. 1st International Workshop Principles Practice Semantic Web Reasoning (PPSWR03), pp. 3350.
Springer-Verlag.
Wagner, G., Giurca, A., & Lukichev, S. (2005). General Markup Framework Integrity
Derivation Rules. Dagstuhl Seminar Proceedings: Principles Practices
Semantic Web Reasoning.
Wagner, G., Giurca, A., & Lukichev, S. (2006). Usable Interchange Format Rich
Syntax Rules Integrating OCL, RuleML SWRL. Workshop Reasoning
Web (RoW-2006), co-located WWW-2006).
Yang, G., & Kifer, M. (2003a). Inheritance Rules Object-Oriented Semantic Web
Languages. 2nd International Workshop Rules Rule Markup Languages
Semantic Web (RULEML03), pp. 95110.
Yang, G., & Kifer, M. (2003b). Reasoning Anonymous Resources Meta Statements Semantic Web. Journal Data Semantics, 1, 6997.
Yang, G., Kifer, M., & Zhao, C. (2003). Flora-2: Rule-Based Knowledge Representation
Inference Infrastructure Semantic Web. 2nd International Conference
Ontologies, DataBases, Applications Semantics Large Scale Information
Systems (ODBASE03), pp. 671688.

94


