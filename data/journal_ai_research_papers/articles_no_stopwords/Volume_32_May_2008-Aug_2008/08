journal artificial intelligence

submitted published

dpop faithful distributed implementation
efficient social choice
adrian petcu
boi faltings

adrian petcu epfl ch
boi faltings epfl ch

artificial intelligence lab ecole polytechnique federale de lausanne
station lausanne switzerland

david c parkes

parkes eecs harvard edu

school engineering applied sciences harvard university
oxford street cambridge usa

abstract
efficient social choice goal assign values subject side constraints
set variables maximize total utility across population agents agent
private information utility function model social choice
distributed constraint optimization dcop agent communicate
agents share interest one variables whereas existing dcop
easily manipulated agent misreporting private information deviating
introduce dpop first dcop provides faithful distributed
implementation efficient social choice provides concrete example methods
mechanism design unified distributed optimization faithfulness ensures
agent benefit unilaterally deviating aspect protocol neither informationrevelation computation communication whatever private information agents
allow payments agents central bank central authority
require achieve faithfulness carefully integrate vickrey clarke groves vcg mechanism dpop agent asked perform computation report
information send messages best interest determining agent payment
requires solving social choice without agent present method reuse
computation performed solving main way robust manipulation
excluded agent experimental structured much
computation required solving marginal avoided use providing
good scalability number agents unstructured observe sensitivity
dpop density reusability decreases almost
sparse around highly connected close discussion features dcop enable faithful implementations challenge
reusing computation main marginal
adopt optapo prospect methods avoid welfare loss occur
transfer payments bank

introduction
distributed optimization model environments set agents must agree
set decisions subject side constraints consider settings agent
preferences subsets decisions agents self interested one would
obtain decision maximizes utility however system whole agrees
social designer determines solution selected maximize total utility across
c

ai access foundation rights reserved

fip etcu faltings parkes

agents thus efficient social choice motivation mind massively
distributed meeting scheduling decisions
hold meeting allocating airport landing slots airlines decisions
airline allocated slot scheduling contractors construction projects
one solve central authority computes optimal solution combination incentive mechanism vickrey clarke groves vcg
mechanism jackson prevent manipulation misreporting preferences however many practical settings hard bound central
authority feasible consider meeting scheduling agent participates
meetings general possible set meetings constraints
meetings thus optimized separately similarly contractors construction
project simultaneously work projects creating web dependencies hard
optimize centralized fashion privacy concerns favor decentralized solutions greenstadt
pearce tambe
distributed constraint reasoning abt awc yokoo hirayama
aas silaghi sam haroud faltings dpop petcu faltings b
adopt modi shen tambe yokoo deal large long influence agent solution limited bounded number variables however
current techniques assume cooperative agents provide robustness misreports
preferences deviations self interested agents major limitation
recent years faithful distributed implementation parkes shneidman proposed
framework within achieve synthesis methods centralized md distributed
solving faithfulness ensures agent benefit unilaterally deviating
aspect protocol neither information revelation computation communication whatever private information agents distributed implementation applied
lowest cost routing shneidman parkes feigenbaum papadimitriou sami shenker
policy routing feigenbaum ramachandran schapira internet
efficient social choice broad applicability
make following contributions
model efficient social choice dcop adapt
dpop exploit local structure distributed model achieve
scalability would possible solving centralized graph
provide whose first stage faithfully generate dcop representation
underlying social choice dcop representation generated
next stages dpop faithful form ex post nash equilibrium
induced non cooperative game
establishing dcop social choice solved faithfully
observe communication information structure
agent prevent rest system aggregate correctly determining marginal
impact allowing agents reported preferences total utility achieved
agents provides generality techniques dcop
part achieving faithfulness requires solving dcop agents reported preferences ignored turn without agent able interfere computational


fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

process provide robustness property nevertheless able
reuse possible intermediate computation solving main
agents
experimental analysis structured meeting scheduling common
benchmark literature demonstrate much computation required
solving marginal avoided reuse provided
unstructured resource allocation dpop sensitive
density loose around computation reused
decreases highly connected
dpop defines strategy agent extensive form game induced
dcop efficient social choice particular dpop defines messages
agent send computation agent perform response messages
received agents proving dpop forms game theoretic equilibrium
agent benefit unilaterally deviating whatever utility functions agents
whatever constraints although robust dominant strategy equilibrium ex
post equilibrium requires every agent follow parkes shneidman
earlier commented appears necessary cost decentralization
total payment made agent bank non negative dpop never
runs deficit e bank receives non negative net payment agents
settings transfer utility bank undesirable would best avoided provide
statistics domains studied loss represent much
total utility achieved solution studied payments
cannot naively redistributed back agents without breaking faithfulness extant work redistribution mechanisms vcg payments suggests mitigated guo conitzer
faltings cavallo moulin bailey defer extension dpop
details surprisingly involved interesting right future work
reuse computation solving marginal agent removed turn
especially important settings distributed optimization motivating scenarios
size massive perhaps spanning multiple organizations encompassing
thousands decisions example consider project scheduling inter firm logistics intra firm
meeting scheduling etc appropriate structure dcop
scale linearly size instance dpop able solve
single back forth traversal graph without use additional
cost solving marginal would make computational cost quadratic rather
linear number agents could untenable massive scale applications
rest organized follows preliminaries section section
describe dpop petcu faltings b distributed constraint optimization
focus study section introduces model self interested agents defines
centralized vcg mechanism section provides simple method simple dpop make
dpop faithful serves illustrate excellent fit information communication
structure dcops faithful vcg mechanisms section describe main mdpop computation used solving marginal agent removed
consider distributed combinatorial auctions instances randomly generated distribution cats
suite leyton brown shoham



fip etcu faltings parkes

turn present experimental section section discuss adapting dcop
social choice adopt optapo see section waste due
payments section conclude section
related work
work draws two areas distributed constraint satisfaction optimization mechanism design coordinated decision making multi agent systems
self interested agents briefly overview relevant areas
c onstraint atisfaction



ptimization

constraint satisfaction optimization powerful paradigms model wide range
tasks scheduling optimal process control etc traditionally
gathered single place centralized applied solution however
social choice naturally distributed often preclude use centralized entity
gather information compute solutions
distributed constraint satisfaction discsp yokoo durfee ishida kuwabara
sycara roth sadeh koniecpol fox collin dechter katz solotorevsky
gudes meisels distributed constraint optimization dcop modi et al
zhang wittenburg petcu faltings b gershman meisels zivan formalisms introduced enable distributed solutions agents involved
must communicate solution overall unknown one
briefly consist individual subproblems agent holds subproblem connected peers subproblems via constraints limit
individual agent goal feasible solutions overall
case discsp optimal ones case dcop
many distributed dcop introduced none deals selfinterested agents well known ones adopt dpop optapo
adopt modi et al backtracking bound propagation adopt
completely decentralized message passing asynchronous adopt
advantage requiring linear memory linear size messages applicability large
questionable due fact produces number messages
exponential depth dfs tree chosen
optapo mailler lesser centralized distributed hybrid uses mediator nodes
centralize subproblems solve dynamic asynchronous mediation sessions
authors message complexity significantly smaller adopts however designed cooperative settings settings self interested agents
social choice unclear whether agents would agree revealing constraints
utility functions possibly many agents solve partially
centralized subproblems
dpop petcu faltings b complete dynamic programming
generates linear number messages dpop size messages depends
largest adopt experiments aware comprise around agents variables



fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

structure largest message exponential induced width
see section adopt dpop maintains full distribution
features suggest dpop good foundation efficient distributed
implementation vcg mechanism social choice
discussion features applicability social choice
provided section focus dpop provide appropriate
modifications payments effective environments self interested agents
section provide brief discussion opportunites challenges
applying methodology adopt optapo
echanism esign



istributed mplementation

long tradition centralized incentive mechanisms within distributed ai going
back least work ephrati rosenschein considered use vcg
mechanism compute joint plans see work sandholm parkes et al
recent discussions noteworthy work rosenschein zlotkin
rules encounter provided non vcg approaches task allocation systems
two agents
hand known methods distributed solving
presence self interested agents example raco n et sandholm improved
upon c ontract n et system davis smith negotiation distributed task reallocation providing better economic realism raco n et nevertheless studied simple
myopically rational agent behaviors performance game theoretic agents never analyzed remains true recent works endriss maudet sadri toni dunne
wooldridge laurence dunne similarly wellmans work market oriented programming wellman considers role virtual markets support optimal
resource allocation developed model price taking agents e agents treat
current prices though final rather game theoretic agents
first step providing satisfactory synthesis distributed md
provided agenda distributed algorithmic mechanism design damd due work
feigenbaum colleagues feigenbaum et al feigenbaum shenker
authors fpss provided efficient lowest cost interdomain routing internet
terminating optimal routes payments vcg mechanism shot
agents case autonomous systems running network domains could benefit misreporting information transit costs missing analysis consideration
robustness manipulation distributed implementation parkes
shneidman introduces additional requirement faithful agent
cannot benefit deviating required actions including information revelation computation message passing number principles achieving faithfulness ex post nash
equilibrium provided parkes shneidman careful incentive design small
amount cryptography able remove remaining opportunities manipulation
lowest cost routing fpss building feigenbaum et al recently provide faithful method policy interdomain routing better capturing typical business
agreements internet domains


fip etcu faltings parkes

first work achieve faithfulness general dcop demonstrated
via application efficient social choice work monderer tennenholtz consider distributed single item allocation focus faithful communication
provide distributed computation izmalkov et al adopt cryptographic primitives
ballot boxes convert centralized mechanisms di fully connected
communication graph interest demonstrating theoretical possibility ideal mechanism design without trusted center work different focus seek computational
tractability require fully connected communication graphs make appeal cryptographic primitives hand content retain desired behavior equilibrium
remaining consistent md literature izmalkov et al avoid introduction
additional equilibria beyond exist centralized mechanism
briefly mention two related topics note well established literature iterative
vcg mechaisms mishra parkes ausubel cramton milgrom bikhchandani
de vries schummer vohra provide partially distributed implementation
combinatorial allocation center typically issuing demand queries agents
via prices prices triggering computation part agents generating demand set
response auctions often interpreted decentralized primal dual parkes
ungar de vries vohra setting differs remains center
performs computation solving winner determination round agent
communicates directly center peer peer mualem initiates orthogonal
direction within computer science related topic nash implementation jackson
economics relies information part private part common knowledge
one agent entirely private information preferences

preliminaries modeling social choice
assume social choice consists finite possibly large number decisions
made time decision modeled variable take
values discrete finite domain agent private information variables
places relations relation associated agent defines utility agent
possible assignment values variables domain relation may
hard constraints restrict space feasible joint assignments subsets variables
definition social choice scp efficient social choice modeled
tuple x c r
x x xm set public decision variables e g hold
meetings resources allocated etc
dm set finite public domains variables x e g list possible
time slots venues list agents eligible receive resource etc
c c cq set public constraints specify feasible combinations values
variables involved constraint cj function cj dj djk
returns allowed combinations values involved variables
disallowed ones denote scope cj set variables associated constraint cj


fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

set self interested agents involved optimization
x ai x privately known set variables agent ai interested
relations
r r rn set private relations ri set relations specified
agent ai relation rij ri function rij dj djk r specified agent
ai denotes utility ai receives possible values involved variables
j jk negative values mean costs denote scope rij domain variables
rij defined
private relations agent may induced solution local optimization additional private decision variables additional private constraints
kept local agent part scp definition
optimal solution scp complete instantiation x variables x
x
x
ri x
cj x

x arg max
xd

n

cj c

rj x agent ai total utility assignment x natural
ri x
rij ri
social choice goal solution maximizes total utility agents
respecting hard constraints notice second sum x infeasible precludes
outcome assume throughout feasible solution introducing vcg
mechanism require solution scp influence agents relations
removed turn let scp denote main
eq
pand scp ai denote
p
marginal without agent ai e maxxd j rj x cj c cj x note
decision variables remain difference scp scp ai
preferences agent ai ignored solving scp ai
variable xj refer agents ai xj x ai forming community
xj choose emphasize following assumptions
p

agent knows variables interested together domain
variable hard constraints involve variable
decision variable supported community mechanism allows interested
agents report interest learn example mechanism
implemented bulletin board
constraint cj c every agent ak community xl scope cj e
xl x ak read membership lists communities xm scope cj
xm xl words every agent involved hard constraint knows
agents involved hard constraint
agent communicate directly agents communities
member agents involved shared hard constraints
communication agents required
note private knowledge variables interest requirement present work
public private knowledge variables interest required agents interested
variable know see assumptions



fip etcu faltings parkes

figure operator placement centralized model variable server load possible
values feasible combinations services run server edges correspond
relations represent agent preferences b decentralized dcop model replicated
variables agent local replica variables interest inter agent edges denote
equality constraints ensure agreement preferences modeled relations hyperedges local respective agents

section establish step identifying scp via community mechanism faithful self interested agents choose volunteer communities
member communities
modeling social choice constraint optimization
first introduce centralized constraint optimization cop model efficient social choice model represented centralized graph given
model distributed constraint optimization dcop along associated
distributed graph distributed graph makes explicit control structure
distributed ultimately used multi agent system solve
sections illustrated reference overlay network optimization huebsch
hellerstein lanham et al faltings parkes petcu shneidman pietzuch ledlie
shneidman roussopoulos welsh seltzer
overlay n etwork ptimization consider optimal placement data aggregation processing operators overlay network large scale sensor network huebsch
et al pietzuch et al application multiple users multiple servers
user associated query client machine located particular node
overlay network query associated set data producers known user located


fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

nodes network query requires set data aggregation processing operators placed server nodes nodes data producers
users node user assigns utility different assignments operators servers represent preferences different kinds data aggregation examples network operators
data aggregation include database style join operators e g user may desire volcano data x
earthquake data joined sent address specific operator call
volcanoxearthquakey join created put network naturally user prefers
operators placed best servers network without regard costs incurred overloading servers denying service users etc optimal
allocation operators servers subject capacity compatibility constraints
faltings et al model one efficient social choice distributed executed user clients situated network nodes used determine assignment
data aggregation processing operators server nodes
c entralized cop odel ulti g raph
viewed centralized scp defined constraint optimization
multigraph e graph several distinct edges connect set nodes denote
cop provide illustration figure decision variables nodes
relations defined subsets variables form edges multigraph hyperedges connect
two vertices case relation involving two variables
multiple edges involve set variables edge corresponding
relations distinct agent set variables hard constraints represented
edges graph
example centralized model overlay optimization example figure contains
users ai servers sj simplicity reasons assume user ai one single operator oi want executed server according prerequisites compatibility
issues assume execute similarly assume execute
execute combination two three operators agents preferences operators executed e g proximity
data sources computational capabilities servers cost electricity etc example
extracts utility executed utility executed
model optimization use following
variables server si create variable si denotes set operators si
execute
values variable si take values set possible combinations operators
server execute example null null means
server executes operator oi executes operator oi executes

constraints restrict possible combinations assignments example two servers
execute operator
relations allow agents express preferences combinations assignments
preference placement relation r defined variables


fip etcu faltings parkes

relation associates utility value combination assignments
total combinations follows
combinations executed neither e g hs

combinations executed e g hs
combinations executed e g hs
depict variables nodes graph constraints relations hyper edges see
figure get arbitrarily complex multiple operators per agent groups
servers able execute certain groups compatible operators etc
ecentralized cop dcop odel u sing r eplicated variables
useful define alternate graphical representation scp centralized
graph replaced distributed graph distributed graph direct correspondence dpop solving dcops denote dcop
agents included corresponds main social choice scp similarly
dcop ai agent ai removed corresponds scp ai
distributed model agent local replica variables interested
public variable xv x ai agent ai interested agent local replica denoted
xvi agent ai local cop x ai ri specifying relations rij ri
locally replicated variables
refer figure b translation centralized figure dcop
model agent local variables loads servers interest e
servers execute one operators e g represents local replica variable
representing server local edges correspond local different constraints agents
variables ensure execute operator several servers time equality
constraints local replicas value ensure global agreement operators
run servers
agents specify relations via local edges local replicas example agent
relation load servers express preference placement
operator relation r assign e g utility executing utility
executing
begin understand potential manipulation self interested agents
example notice although globally optimal solution may require assigning
less preferable providing utility instead therefore absence incentive
mechanism could benefit simple manipulation declare utility hs thus
changing final assignment suboptimal one nevertheless better
alternate model designates owner agent decision variable owner agent would centralize
aggregate preferences agents interested variable subsequently owner agents would use
distributed optimization optimal solution model limits reusability computation
main solving marginal agent removed turn excluding
owner agent variable one needs assign ownership another agent restart computational process
regards variable connected variables reuse computation important making dpop
scalable disaggregated facilitates greater reuse



fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

neighborhood local copy xvi variable composed three kinds variables
neighbors xvi siblings xvi local neighbors xvi hard neighbors xvi



siblings local copies xv belong agents aj ai interested xv
siblings xvi xvj aj ai xv x aj



siblings xvi connected pairwise equality constraint ensures
agents eventually consistent value variable second set variables
local neighbors xvi local optimization ai local copies
variables agent ai interested connected xvi via relations ai local

local neighbors xvi xui xu x ai rij ri xui scope ri



must consider set hard constraints contain scope variable xv
public variables hard xv cs c xv scope cs constraints connect
xv variables xu appear scope may interest
agents well consequently xvi connected local copies xtj
variables xt appear hard constraints
hard neighbors xvi xtj cs hard xv xt scope cs xt x aj



general agent private variables relations constraints involve
private variables link public decision variables example consider meeting
scheduling application employees company apart work related meetings
schedule together one employees personal items agenda appointments doctor etc decisions values private variables information
local relations constraints remain private provide additional complications
discussed
example social choice
continuing present main describe three additional social choice
serve motivate work fact efficient social choice fundamental
microeconomics political science mas colell whinston green
present large scale distributed involves actors system businesses
cannot expected cooperate revealing preferences following rules
distributed
irport lot llocation airports become congested governments turning
market approaches allocate landing takeoff slots instance u federal aviation administration recently commisioned study use auction allocate slots
yorks congested laguardia airport ball donohue hoffman large
scale expands include airports throughout u eventually world exhibits
self interest airlines profit maximizing agents private information utilities


fip etcu faltings parkes

different slot allocations one privacy major concern competitiveness airline industry typical policy goal maximize total utility allocation
e one efficient social choice motivates study combinatorial auctions
section combinatorial auction ca one set heterogeneous indivisible goods
allocated agents values expressed sets goods e g want
slot get slot indifferent slot
airport slot allocation motivated first cas rassenti smith bulfin
recognized airlines would likely need express utilities sets slots
correspond right fly schedule airport
pen access w ireless n etworks wireless spectrum today owned operated
closed networks example cellular companies mobile however
plenty debate creating open access wireless networks bandwidth must available
use phone software recently proposed auction protocol
allow service providers bid dynamic auction right use spectrum given period
time deliver services taken logical conclusion idea anticipated rosenschein
zlotkin wired telephony suggests secondary market wireless spectrum
corresponds efficient social choice allocate spectrum maximize total utility
consumers large scale exhibits self interest inherently decentralized
eeting cheduling p roblem consider large organization dozens departments spread across dozens sites employing tens thousands people employees
different sites departments want setup thousands meetings week due privacy
concerns among different departments centralized solving desirable furthermore
although organization whole desires minimize cost whole process department employee self interested wishes maximize utility artificial
currency created purpose weekly assignment made employee employees
express preferences meeting schedules units currency
refer figure example agents want setup meetings
figure b shows agent local variables time slots corresponding meetings
participates e g represents local replica variable representing meeting
local edges correspond local different constraints agents variables ensure
participate several meetings time equality constraints local
replicas value ensure global agreement agents specify relations via local edges
local replicas example agent relation time meeting express
preference meeting later day relation r assign low utilities morning
time slots high utilities afternoon time slots similarly prefers holding meeting
meeting use local relation r assign high utilities satisfactory
combinations timeslots low utility otherwise example hm
gets utility hm gets utility
breakthrough ruling u federal communications commission fcc require open access
around one third spectrum auctioned early
stopped short mandating spectrum made available wholesale market would service providers
see
http www fcc gov mhz news release pdf
google proposed auction filing made fcc may st
see
http gullfoss fcc gov prod ecfs retrieve cgi native pdf pdf id document



fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

figure meeting scheduling centralized model vertex meeting variable red
edges correspond hard constraints non overlap meetings share participant
agent hyperedge particpates every meeting blue edges correspond
relations represent agent preferences b decentralized dcop model replicated
variables agent local replica variables interest inter agent edges denote
equality constraints ensure agreement hard constraint non overlap meetings
local hyperedge agent c dfs arrangement decentralized
graph used dpop control order solving

experimental presented section adopt meeting scheduling prototypical
structured social choice instances associated organizational
hierarchy meeting scheduling introduced section second set experiments
consider combinatorial auctions cas agents bid bundles goods
consider set instances unstructured provide comparison point
meeting scheduling cas provide nice abstraction kinds allocation exist
airport wireless network domains

cooperative case efficient social choice via dpop
section review dpop petcu faltings b general purpose distributed
optimization dpop distributed pseudotree optimization protocol dynamic
programming adapts dechters dechter general bucket elimination scheme distributed case main advantage generates linear number messages
contrast optimization adopt modi et al ensures minimal network overhead produced message exchange hand concern dpop
size individual messages since grows exponentially parameter constraint graph
called induced width see section nevertheless exhibit local structure
dpop typically scales much larger orders magnitude efficient


fip etcu faltings parkes

techniques petcu faltings b simplify exposition first illustrate
dpop general dcop context instantiate dpop social choice particular explain leverage structure provided local replicas consider
cooperative agents throughout section
dpop dcops
section presents dpop generic dcops simplify exposition
assume section agent ai represents single variable xi
constraint graph given
dpop composed three phases
phase one constructs dfs arrangement dfs defines control flow message passing computation dpop
phase two bottom utility propagation along tree constructed phase
phase utilities different values variables aggregated reflect optimal decisions
made subtrees rooted node tree
phase three top value assignment propagation along tree constructed phase
phase decisions made aggregate utility information phase
describing phases refer figure running example introduce
explicit numerical example illustrate phases two three detail
dpop p hase ne dfs ree g eneration
first phase performs depth first search dfs traversal graph thereby constructing dfs arrangement graph dfs arrangement subsequently used
provide control flow dpop guide variable elimination order underlying graph tree dfs arrangement tree general dfs arrangement
graph define union set tree edges additional back edges connect
nodes ancestors
definition dfs arrangement dfs arrangement graph g defines rooted tree
subset edges tree edges remaining edges included back edges tree
edges defined adjacent nodes g fall branch tree
figure shows example dfs arrangement tree edges shown solid lines e g
back edges shown dashed lines e g two nodes xi xv
said branch dfs arrangement path higher node
lower node along tree edges e g nodes x x figure dfs arrangements already
investigated means boost search constraint optimization freuder quinn
modi et al dechter mateescu advantage allow
exploit relative independence nodes lying different branches dfs arrangement
simplicity assume follows original connected however difficulty
applying dpop disconnected dfs arrangement becomes dfs forest agents
connected component simply execute dpop parallel separate control thread solution overall
union optimal solutions independent subproblem



fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

figure dfs arrangement graph tree edges shown solid back edges
dashed dfs arrangement constructed initializing token passing x k ary
constraints c treated cliques

e nodes direct descendants ancestors one another possible
perform search parallel independent branches combine
introduce definitions related dfs arrangements
definition dfs concepts given node xi dfs arrangement define
parent pi children ci xi ancestor descendants connected xi via tree edges e g
p x c x x
pseudo parents pp xi ancestors connected xi via back edges pp x
pseudo children pc xi descendants connected xi via back edges e g pc
x
separator sep xi ancestors xi directly connected xi descendants xi e g sep x sep x x x
tree neighbors tn xi nodes linked xi via tree edges tn pi ci
e g tn x x x
removing nodes sep completely disconnects subtree rooted xi rest
case tree sep pi xi x general case sep
contains pi pp pseudoparents descendants xi pseudoparents
ancestors xi example figure separator node x contains parent x
pseudoparent x necessary sufficient values variables x x
set rooted node x independent rest separators
play important role dpop contingent solutions must maintained propagating
utility information dfs arrangement different possible assignments separator variables
constructing dfs tree generating dfs trees distributed manner task
received lot attention many available example collin
dolev barbosa cidon cheung name purposes executing dpop assume example cheung
briefly outline instantiate dpop scps present adaptation
dfs generation exploit particulars scp
simple dfs construction starts agents labeling internally neighbors
visited one agents graph designated root example leader


fip etcu faltings parkes

election abu amara simply picking agent
lowest id root initiates propagation token unique message
circulated agents graph thus visiting initially token contains
id root root sends one neighbors waits return sending
one still unvisited neighbors agent xi first receives token marks
sender parent neighbors xi contained token marked xi pseudoparents
pp
xi adds id token sends token turn one notvisited neighbors xj become children every time agent receives token one
neighbors marks sender visited token return xj child
xi sent first place another neighbor xk latter case means
cycle subtree xk marked pseudochild
dead end reached last agent backtracks sending token back parent
neighbors marked visited xi finished exploring subtree xi removes
id token sends token back parent process finished xi
root marked neighbors visited entire dfs construction process
handling non binary constraints special treatment required construct neighbors
variable correspond k ary constraints k example figure left
ary constraint c involving x x x x eq implies x x x x
neighbors dfs construction process appear along branch
tree produces figure right
dpop p hase wo util p ropagation nference
phase two bottom top pass dfs arrangement utility information aggregated
propagated leaves towards root node parent tree edges
back edges high level leaves start computing sending util messages
parents util message informs parent local utility solutions
rest minimally specified terms local utility different value assignments
separator variables subsequently node propagates util message represents
contingent utility subtree rooted node assignments values separator variables
detail nodes perform following steps
wait util messages children store
perform aggregation join messages children relations
parents pseudoparents
perform optimization project resulting join picking optimal
values combination values variables join
send parent util message
cases initially disconnected required choose multiple roots one connected component standard leader election executed agents elect
exactly many leaders connected components



fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

util message sent node xi parent pi multidimensional matrix informs
pi much utility ui sep subtree rooted xi receives different assignments values
variables define separator sep subtree one variables definition
variable managed parent pi util message already represents optimization
variables local subtree optimized different assignments separator
variables compute util message node uses two operations aggregation optimization
aggregations apply join operator optimizations apply project operator described
petcu faltings b briefly summarized
let utilij utilkj denote util messages sent nodes xi xk parent
node xj denote dim utilkj set dimensions matrix e set
variables separator sending node xk assuming xj node receiving messages
define
definition join operator operator join utilij utilkj join two
util matrices matrix dim utilij dim utilkj dimensions
value cell join sum corresponding cells two source matrices
definition project operator operator projection xj dim utilij
utilij xj projection optimization utilij matrix along xj axis
instantiation variables dim utilij xj corresponding values
utilij one value xj tried maximal one chosen matrix
one less dimension xj
notice subtree rooted xi influenced rest xi
separator variables therefore util message contains optimal utility obtained subtree
instantiation variables sep separator size plays crucial role bounding
message size
example util propagation figure shows simple example util propagation
tree structure figure relations r r r detailed figure b
relations variables x x x x x x respectively
individual variables local replicas util phase x x project r r respectively highlighed cells r r figure b
instance optimal value x given x assign x c utility
projections define util messages send x x receives messages x
x joins together relation x adds utilities messages
corresponding cells r projects join instance optimal value
x given x b x max
depicted figure util message x receives x value
message represents total utility entire value x return
example context third phase value propagation
non binary relations constraints binary constraints relations k ary constraint
introduced util propagation lowest node dfs arrangement
part scope constraint example figure constraint c introduced
util propagation x computing message parent x


fip etcu faltings parkes

figure numerical example util propagation simple dcop three
relations r r r x x x x x x respectively b projections
x x relations x sent x util util
respectively c x joins util util relation x x projects
join sends x

dpop p hase hree value p ropagation
phase three top bottom pass assigns values variables decisions made recursively
root leaves value propagation phase initiated root agent
x received util messages children util messages
root assigns variable x value v maximizes sum utility
communicated subtrees sends value x r v message every child
process continues recursively leaves agents xi assigning optimal values
variables end phase finishes variables assigned
optimal values
example value propagation return example figure x receives util
message node x simply choose value x produces largest utility
whole x x x c produce example one
chosen value assignment propagation phase x informs x choice via
message value x node x assigns optimal value x c process continues
message v alu e x c sent children x x children assign x b
x terminates optimal solution hx x c x b x ai
total utility
c omplexity nalysis dpop
dpop produces number messages scales linearly size graph e
linearly number nodes edges dcop model petcu faltings b
complexity dpop lies size util messages note tokens passed around


fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

constructing dfs value messages size linear graph petcu
faltings b size largest util message exponential parameter
called induced width kloks dechter
induced width denoted w constraint graph given chosen dfs arrangement
structural parameter equals size largest separator node dfs arrangement
see definition
w max sep
xi x



example figure induced width graph given particular dfs ordering
w given sep x x x intuitively tree structure
lower induced width particular graph tree induced
width equal dfs arrangement tree graphs cliques
hand induced width equal number nodes minus irrespective
dfs tree arrangement
proposition dpop complexity petcu faltings b number messages passed
dpop n n phases one two three respectively n
number nodes edges dcop model replicated variables maximal number
utility values computed node dpop dw largest util message
dw entries w induced width dfs ordering used
case trees dpop generates util messages dimension equal domain size
variable defining parent node case cliques maximal message size
dpop exponential n dfs arrangements yield width desirable
construct dfs arrangements provide low induced width however finding tree arrangement
lowest induced width np hard optimization arnborg nevertheless
good heuristics identified finding tree arrangements low width kloks
bayardo miranker bidyuk dechter petcu faltings b although
designed explored centralized context notably max degree
maximum cardinality set easily amenable distributed environment
dpop applied social choice
section instantiate dpop efficient social choice specifically first
optimization constructed agents preferences potential variables
interest subsequently changes make dpop adapt scp domain
prominent adaptation exploits fact several variables represent local replicas
variable treated util value phases
adaptation improves efficiency significantly allows complexity claims stated terms
induced width centralized cop graph rather distributed cop
graph see section
nitialization c ommunity f ormation
initialize agent first forms communities around variables interest
x ai defines local optimization cop x ai ri replicated variable xvi


fip etcu faltings parkes

xv x ai shorthand xvi cop denotes agent ai local replica variable
xv agent owns multiple nodes conceptualize node associated virtual agent operated owning agent virtual agent responsible
associated variable
agents subscribe communities interested learn
agents belong communities neighboring relations established local variable
according eq follows agents community xv connect corresponding local
copies xv equality constraints local cop x ai ri
connected according interests owning agents local relations
cop x ai ri connect corresponding local variables hard constraints connect local copies
variables involve thus overall graph formed
example consider figure b decision variables start times three
meetings agent local optimization creating local copies variables
interested expressing preferences local relations formally initialization
process described
dpop init community formation building dcop
dpop init x c r
agent ai interests cop x ai ri set relations ri imposed
set x ai variables xvi replicate public variable xv x ai
agent ai subscribes communities xv x ai
agent ai connects local copies xvi x ai corresponding local copies
agents via equality constraints

dfs raversal
method dfs traversal described starts choosing one
variables x root done randomly example distributed
random number generation leader election ostrovski simply
picking variable lowest id agents involved community x randomly
choose one ar leader local copy x r variable x becomes root
dfs making assumption virtual agents act behalf variable
functioning token passing mechanism similar described section
additional consideration given community structure root chosen agents
participate distributed depth first traversal graph convenience describe
dfs process token passing members within community observe
release pick token agents neighbors node sorted
line prioritize copies variables held agents local variables
finally variables linked hard constraints
example consider meeting scheduling example figure assume chosen
start community chosen within community leader creates empty
token dfs adds id token dfs eq neighbors
sends token dfs first unvisited neighbor


fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

dpop phase one dfs construction
inputs ai knows cop neighbors xvi xvi cop
outputs ai knows p xvi pp xvi c xvi pc xvi xvi cop













procedure initialization
agents choose one variables x root
agents x community elect leader ar
ar initiates token passing x r construct dfs
procedure token passing performed virtual agent xvi cop
xvi root p xvi null create empty token dfs
else dfs handle incoming tokens
let dfs dfs xvi
sort neighbors xvi siblings xvi local neighbors xvi
hard neighbors xvi set c xvi null
forall xl neighbors xvi xl visited yet
c xvi c xvi xl send dfs xl wait dfs token return
send dfs token back p xvi
procedure handle incoming tokens run virtual agent xvi cop








wait incoming dfs message let xl sender
mark xl visited
first dfs message e xl parent
p xvi xl pp xvi xk xl xk neighbors xvi dfs pp xvi
else
xl
c xvi e dfs coming pseudochild
pc xvi pc xvi xl

list e belongs receives token adds copy dfs
sends token first unvisited neighbor belongs
agent receives token adds copy dfs
neighbor list neighbors since token received
already contains means already visited thus next variable
visit happens variable belongs token passed
internally message exchange required added token dfs

process continues exploring sibling variables community turn passing another community eventually replicas variable arranged
chain equality constraints back edges predecessors replicas
variable dead end reached last agent backtracks sending token back
parent example happens receives token community
sends back token eventually token returns path
way root process completes


fip etcu faltings parkes

h andling



p ublic h ard c onstraints

social choice defined definition contain side constraints form publicly known hard constraints represent domain knowledge resource allocated
hotel accomodate people person one meeting
time etc constraints owned agent available agents
interested variable involved domain constraint handling constraints
essentially unchanged handling non binary constraints standard dpop described
section dfs construction phase section util phase specifically
dfs construction neighboring relationships defined eq require local variable
local copies share hard constraint considered neighbors
prioritization line dfs construction dfs traversal mostly made
according structure defined relations agents hard constraints
appear backedges dfs arrangement graph
util propagation hard constraints introduced util propagation phase lowest
agent community variable scope hard constraint e agent
variable lowest dfs ordering example constraint
figure specify occur becomes backedge
communities would assigned handling
h andling r eplica variables
distributed model scp replicates decision variable every interested agent connects copies equality constraints handling replica variables carefully
avoid increasing induced width k dcop model compared induced width
w centralized model adaptation util messages dpop distributed graph would conditioned many variables local copies
original variable however local copies represent variable must assigned
value thus sending many combinations different local copies variable take
different values wasteful therefore handle multiple replicas variable util
propagation though single original variable condition relations one
value realized updating join operator follows
definition updated join operator scp defined two steps
step consider util messages received input one consider variable
xvi message conditioned local copy original variable xv
rename xvi input util message xv e corresponding name original

step apply normal join operator dpop
applying updated join operator makes local copies variable become indistinguishable merges single dimension util message
avoids exponential blow
example consider meeting scheduling example figure centralized model figure dfs arrangement yields induced width clique nodes


fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

nevertheless corresponding dcop model figure b induced width seen
dfs arrangement figure c sep applying dpop
dfs arrangement would condition util message utilm variables
separator however represent variable therefore apply updated join operator leverages equality constraint
two local replicas collapse single dimension called message
outgoing message dimensions takes much less
space possible agents involved e know
represent variable
change value propagation phase modified top local
copy variable solve optimization compute best value announcing
local copies assume value
c omplexity nalysis dpop pplied ocial c hoice
special handling replica variables dpop applied scps scale induced
width centralized graph independently number agents involved
number local replica variables
consider dfs arrangement centralized model scp equivalent
dfs arrangement dcop model equivalent means original variables
scp visited order corresponding communities visited
distributed dfs construction recall distributed dfs traversal described section
visits local copies community dcop moving next community let
w denote induced width dfs arrangement centralized scp similarly let k denote
induced width dfs arrangement distributed model let maxm dm denote
maximal domain variable following
theorem dpop complexity scp number messages passed dpop solving
scp n n phases one two three respectively n
number nodes edges dcop model replicated variables maximal number
utility values computed node dpop dw largest util message
dw entries w induced width centralized graph
p roof first part claim number messages follows trivially proposition
second part message size computation given dfs arrangement dcop applying
proposition trivially gives basic dpop maximal amount computation
node dk largest util message dk entries k induced width dcop graph improve analysis need consider special
handling replica variables
consider util messages travel along dfs tree whose sets dimensions
contain separators sending nodes recall updated join collapses local replicas
original variables union dimensions util messages join dpop
dcop model becomes identical set dimensions nodes dpop
centralized model thus node dcop model performs amount computation
counterpart centralized model follows computation required dpop scales
dw rather dk special handling


fip etcu faltings parkes

remains one additional difference dpop dfs arrangement centralized scp versus dpop dfs arrangement dcop variable xv replicated
across multiple agents projected util propagation local optimization top agent handling local replica xv first node
relevant information place support optimization step particular whenever node
maximal separator set associated top replica variable
must retain dependence value assigned variable util message sends
parent increases worst case message size dpop dw opposed dw
normal dpop computation remains dw utility determined
value xv anyway projecting xv
see effect message size described proof local variable cannot
immediately removed util propagation consider figure suppose agent involved meeting introduces additional back edge
dfs arrangement decentralized model shown figure c dfs
arrangement cop model corresponds decentralized model simply traversal
cop order communities visited distributed dfs construction corresponds chain introduction additional back edge
distributed dfs arrangement change dfs cop model
width remains w however top copy agent cannot project
outgoing util message sends util message w
dimensions opposed w

handling self interest faithful social choice
adapted dpop remain efficient scps turn issue self interest without modification agent manipulate dpop misreporting private relations
deviating ways setting meeting scheduling example
agent might benefit misrepresenting local preferences massively utility
meeting occurring pm incorrectly propagating utility information
competing agents person team high utility meeting pm
incorrectly propagating value decisions already decided meeting
involving person team meeting must pm
introducing carefully crafted payments leveraging information communication
structure inherent dcops social choice careful partitioning computation
agent asked reveal information perform optimization send messages
interest able achieve faithfulness mean agent choose
even self interested follow modified first define vcg mechanism
social choice illustrate ability prevent manipulation centralized solving
simple example place next review definitions faithful distributed implementation useful principle partition principle describe simple
dpop without reuse computation prove faithfulness


fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

review mechanism design vcg mechanism
mechanism design md addresses optimizing criteria frequently social welfare presence self interested agents private information relevant
hand standard story agents report private information center solves
optimization enforces outcome
second price sealed bid vickrey auction simple example mechanism agent
makes claim value item auctioneer allocates item highest
bidder second highest price krishna vickrey auction useful
non manipulable weakly dominant strategy agent report true value
efficient item allocated agent highest value
setting efficient social choice assume existence currency agents
make payments make standard assumption quasilinear utility functions agent
ai net utility
ui x p ri x p



assignment x variables x payment p
center e net utility
p r
j
x
minus amount
r
defined utility assignment ri x
j
ri ri
payment one celebrated md provided vickrey clarke groves
vcg mechanism generalizes vickreys second price auction efficient
social choice
definition vcg mechanism efficient social choice given knowledge public constraints c public decision variables x vickrey clarke groves vcg mechanism works
follows
agent ai makes report ri private relations
centers decision x solves scp given reports r r rn
agent ai makes payment
tax ai

x



rj xi
rj x



j

solution scp given reports r
center xi



r ri ri rn

agent makes payment equals negative marginal externality presence
imposes rest system terms impact preferences solution
scp
vcg mechanism number useful properties
strategyproofness agents weakly dominant strategy e utility maximizing strategy whatever strategies whatever private information agents truthfully report preferences center sense vcg mechanism
non manipulable


fip etcu faltings parkes

efficiency equilibrium mechanism makes decision maximizes total utility
agents feasible solutions scp
participation
p
equilibrium utility agent ai ri x tax ai ri x
p


j rj xi non negative principle optimality therej rj x
fore agents choose participate
deficit
payment
made agent ai non negative scp
p
p


j rj x principle optimality therefore entire
j rj xi
mechanism runs budget surplus
begin understand vcg mechanism strategyproof notice first term
tax ai independent ai report second term taken together
agents
p

true utility decision provides ai net utility ri x j rj x
total utility agents maximize agent simply report true preference
information center explicitly solve picking x
example return example figure make scp associating agents
relations r r r variables x x x x x x respectively breaking ties solution scp x x c x b x
utility agents respectively removing agent solution
would x x x c x utility agents
indicates agents indifferent value x removing agent solution
would x c x b x x c utility agents removing agent solution would x x c x b x utility
agents vcg mechanism would assign x x c x b x
payments collected
agents respectively negative impact agents
incur payment agents make payments presence helps hurts
presence hurts conflict
value assigned variable x agents prefer x assigned b c
respectively chosen solution agent gets best outcome considering case
force b selected reporting suitably high utility choice
x must pay x b must pay case weakly prefers
current outcome makes zero payment
introduced vcg mechanism important realize vcg mechanism
provides known general purpose method exists solve optimization
presence self interest private information positive side straightforward
extend vcg mechanism techniques maximize linear weighted sum
utility agent weights fixed known instance social
planner jackson roberts hand established groves mechanisms vcg mechanism important special case non trivial
strategyproof mechanisms domain social choice unless known structure
agent preferences e g everyone prefers earlier meetings resource weakly
preferred less together another technical assumption roberts theorem extended lavi et al domains kind structure instance combinatorial


fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

auctions see real sense possible address self interested
dcops maximizing something total utility participants
faithful distributed implementation
goal faithful distributed implementation distribute computation required solve
scp determine payments population agents retaining
analog strategyproofness challenging opens additional opportunities
manipulation beyond centralized vcg mechanism
presenting introduce following additional assumptions
made far
agents rational helpful meaning although self interested follow protocol whenever deviation make strictly better given behavior
agents
agent prevented posing several independent agents external technique
perhaps cryptographic providing strong perhaps pseudonymous identities
catastrophic failure occur agents community variable eventually
choose value variable
trusted bank connected trusted communication channel agent
authority collect payments agent
property rational helpful required able rely upon agents compute
payments agents make strong identities required avoid known vulnerabilities
vcg mechanism shown yokoo sakurai matsubara wherein agents
sometimes better participating multiple identities catastrophic failure ensures
decision determined protocol actually executed prevents hold
unhappy agent refuses adopt consensus decision alternative solution would
agents report final decision trusted party responsible enforcement
trusted communication channel mean agent send message bank without
interference agent messages sent agent upon termination
dpop inform bank agents payments bank assumed work
distributed md feigenbaum et al shneidman parkes
trusted entity require purpose ensure payments used align incentives
provide formal definition distributed implementation need concept local
state local state agent ai corresponds sequence messages agent
received sent together initial information available agent including
relations public information constraints given distributed implementation
dm g defined terms three components shneidman parkes parkes
shneidman
strategy space defines set feasible strategies available agent ai
strategy defines message agent ai send every possible local state
suggested protocol sn defines strategy parameterized
private relations ri agent ai


fip etcu faltings parkes

outcome rule g g g g n defines assignment values g
variables x given joint strategy n n g n rn defines
payment g r made agent ai given joint strategy n
defining message sent every state strategy encompasses
computation performed internally agent information agent reveals private
inputs e g relations decisions agent makes propagate information
received messages agents suggested protocol si corresponds
takes input private information available agent relevant details
agents local state generates message messages send neighbors network
applied distributed input r r rn known parts input hard
constraints c protocol induces particular execution trace turn
induces outcome g r g final assignment values information
distributed across agents g vector payments bank
collect agents
main question ask given distributed corresponding suggested
protocol whether suggested protocol forms ex post nash equilibrium induced game
definition ex post nash equilibrium given distributed implementation dm g
suggested protocol sn ex post nash equilibrium epne agents
ai relations ri relations agents ri alternate strategies
ri g si ri si ri g si ri si ri ri g si ri g si ri

epne agent ai benefit deviating protocol si whatever particular
instance dcop e private relations r r rn long agents
choose follow protocol latter requirement makes epne weaker dominantstrategy equilibrium si would best protocol agent even agents
followed arbitrary protocol
definition faithfulness distributed implementation dm g ex post faithful
suggested protocol ex post nash equilibrium
suggested protocol said ex post faithful simply faithful
best interest every agent ai follow aspects information revelation
computation message passing whatever private inputs agents long every
agent follows
idea agent limited set possible messages sent local state implied
notion restricted strategy space justified following sense agents model autonomous
self interested course free send message state hand suggested
protocol followed every agent messages semantically meaningful recipient
agent trigger meaningful change local state recipient agent e change local state
changes future external behavior recipient agent way strategy space characterizes complete
set interesting behaviors available agent given agents follow suggested protocol
sufficient technical perspecitve define ex post nash equilibrium
outcome rule must well defined unilateral deviation e one agent deviates
follow suggested protocol protocol still reaches terminal state decisions payments
defined protocol reaches bad state suitably negative utility participants livelock
deadlock neglect latter possibility rest analysis easily treated introducing
special notation bad outcome



fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

partition principle applied efficient social choice
one cannot achieve faithful di efficient scp simply running dpop n times
graph main agents effect nullified turn
asking simply propagate messages agent ai would seek following interfere
computational process scp ai make solution close possible
scp marginal impact appears small b otherwise decrease payment
example increasing apparent utility agents solution scp turn
increases value second term vcg payment eq
opportunity manipulation recognized parkes shneidman
general setting proposed partition principle method achieving faithfulness distributed vcg mechanisms instantiated context efficient scps
definition partition principle distributed corresponding suggested protocol
satisfies partition principle application efficient social choice
correctness optimal solution obtained scp scp ai every agent
follows bank receives messages instruct collect correct vcg payment
every agent
robustness agent ai cannot influence solution scp ai report
bank receives negative externality ai imposes rest system
conditioned solutions scp scp ai
enforcement decision corresponds scp enforced bank collects
payments instructed
theorem parkes shneidman distributed efficient social choice
satisfies partition principle ex post faithful distributed implementation
intuition behind note opportunity manipulation agent
ai restricted influencing solution computed scp b influencing
payments made agents agent ai cannot prevent agents correctly solving
scp ai correctly reporting negative externality ai imposes agents
presence long agents follow ex post faithfulness follows
strategyproofness vcg mechanism additional opportunity manipulation available misreporting preferences centralized context
change increase reduce amount agents payment opportunity
b opportunity agent influence solution context
centralized vcg mechanism misreporting preferences
remark suggested previous work weakening dominant strategy equilibrium centralized vcg mechanism ex post nash equilibrium distributed implementation viewed cost decentralization incentive properties necessarily rely
payments collected rely turn computation performed agents
turn strategy followed agents
exception provided izmalkov et al able avoid use cryptographic
primitives case best thought physical devices ballot boxes



fip etcu faltings parkes

simple dpop
describes simple dpop variation main scp solved
followed social choice scp ai agent removed turn

n solved every agent aj knows local part solution x xi
ai aj part solution affects utility provides enough
information allow system agents without agent ai ai send message
bank component payment agent ai make
simple dpop
run dpop dcop dfs x
forall ai


build dfs ai run dpop dcop ai dfs ai xi
r x report bank

agents aj p
ai compute tax j ai rj xi
j

bank deducts j tax j ai ai account


ai assigns values x solution local copi

computation payments
p disaggregated across agents tax payment collected
agent ai tax ai j tax j ai

tax j ai rj xi
rj x



component payment occurs negative effect agent ai
utility agent aj information communicated bank agent aj equilibrium
important observation able satisfy partition principle components ai payment satisfy locality property agent aj compute component ai payment private information relations local information
affect utility information availabout parts solutions x xi
able upon termination simple dpop correctly determining payment condition
rely aspect agents including
solutions x xi

ai
figure provides illustration simple dpop earlier meeting scheduling example
shows marginal dfs arrangements
related main
theorem simple dpop faithful distributed implementation efficient social choice terminates outcome vcg mechanism
p roof prove establish simple dpop satisfies partition principle
appeal theorem first dpop computes optimal solutions scp scp ai
simple dpop presented setting main subproblems connected extends
immediately disconnected indeed may main connected one
subproblems disconnected see additional incentive concerns notice sufficient
recognize correctness robustness properties partition principle would retained case
similar disaggregation identified feigenbaum et al lowest cost interdomain routing
internet shneidman parkes subsequently modified protocol authors agents
ai enough information report payments made agent ai



fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

figure simple dpop agent ai excluded turn optimization dcop ai
illustrated meeting scheduling example

ai every agent follows protocol immediate correctness
dcop model scp correctness dpop correct vcg payments collected
every agent follows correctness disaggregation vcg payments
eq second agent ai cannot influence solution scp ai involved
computation way dfs arrangement constructed solved
agents completely ignore ai messages agent ai might send hard
constraints ai may handled scp reassigned automatically agent
scp ai consequence fact dfs arrangement reconstructed dpop
still solves scp ai correctly case graph corresponding scp ai
becomes disconnected case dfs arrangement forest robustness value
reports agents ai negative externality imposed ai conditioned solutions
scp scp ai follows locality property payment terms tax j ai
aj ai enforcement bank trusted empowered collect payments agents
finally set local copies variables x prevent catastrophic failure agent ai
deviate long agents deviate moreover agent ai agent
interested variable value already optimal agent ai anyway
partition principle faithfulness sweeping implications agent
follow subtantive aspects simple dpop agent choose faithfully participate community discovery phase choosing root community
selecting leader agent phase one dpop
one observe useful agent misreport local utility another agent aj sending
util messages around system one hand deviation could course change selection x

xk
k j thus payments agents solution ultimately selected deviating



fip etcu faltings parkes

remark antisocial behavior note reporting exaggerated taxes hurts agents
increase ones utility excluded assumption agents selfinterested helpful

dpop reusing computation retaining faithfulness
section present main dpop simple dpop
computation solve main completely isolated computation solve
marginal comparison dpop use computation already performed
solving main solving marginal enables scale well
agents influence limited small part entire
little additional computation required beyond dpop agents
influence limited precisely interest induced
tree width small dpop scales
challenge face facilitating use computation retain incentive
properties provided partition principle possible manipulation agent
ai deviate computation dcop intended effect change solution
dcop ai via indirect impact computation performed dcop
reused solving dcop ai prevent determine util messages
dcop could influenced agent ai
example refer figure agent ai controls x x way
influencing messages sent subtrees rooted x x x x x x want
able reuse many util messages possible solving agent
ai removed strive construct dfs arrangement dcop ai
similar possible dfs main done goal maximizing
use computation across see figure b notice dfs forest
three distinct connected components util messages sent shaded nodes
used solving dcop ai util messages sent nodes subtrees
influenced agent ai except x x x x different
local dfs arrangement
dpop uses safe reusability idea suggested example see first
stage dpop solves main simple dpop complete
marginal dcop ai solved parallel solve dcop ai dfs forest
forest case dcop ai becomes disconnected constructed modification
dfs retaining much structure dfs possible dpop ai
execution performed dfs u il messages determined reusable
reusable sender message differences dfs dfs
explain dfs constructed
way agent cannot change utility information finally used determining payments
agent aj computes marginal effect agent ai local solution component
tax j ai agent ai payment



fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

figure reconstructing dfs ai dfs dpop general dfs forest
bold nodes main dfs initiate dfs propagation one initiated x redundant
eventually stopped x ones x x useful subtrees become
really disconnected removing ai x initiate propagation since x
pseudoparent x controlled ai eventually connect x notice
x x x x turned tree edges

phase one dpop marginal constructing dfs
given graph dcop dfs arrangement dfs dcop one removes set
nodes x ai dcop ones belong ai need constructs
dfs arrangement dfs dcop x ai want achieve following properties
dfs must represent correct dfs arrangement graph dcop ai dfs forest
case dcop ai becomes disconnected
dfs must constructed way non manipulable ai e without allowing
agent ai interfere construction
dfs similar possible dfs allows reusing util messages
dpop saves computation communication
main difficulty stems fact removing nodes represent variables interest agent ai dfs create disconnected subtrees need reconnect possibly
rearrange disconnected subtrees dfs whenever possible return example figure removing agent ai nodes x x disrupts tree two ways
subtrees become completely disconnected rest e g x x x
ones remain connected via back edges thus forming invalid dfs arrangement


fip etcu faltings parkes

dpop faithfully reuses computation main
run dpop dcop dfs x
forall ai
parallel


create dfs adjusting dfs



run dpop dcop ai dfs
leaves dfs observe changes dfs
send null utili messages








else compute utili messages anew dpop
subsequently nodes xk df
xk receives null utili msgs pk pki p pk p pki ck cki
xk sends null utili message
else
node xk computes utili message reusing
forall xl n eighbors xk xl sent utili null
xk reuses util message xl sent dcop
compute levy taxes simple dpop
ai assigns values x solution local copi

e g x x x basic principle use reconnect disconnected parts via back edges
dfs whenever possible intended preserve much structure possible example figure back edge x x turned tree edge x becomes
x child node x remains x child
dfs reconstruction presented high level overview
follows bold state purpose step
similarity dfs nodes retain dfs data structures constructing
dfs e lists children pseudo parents children parents
dfs use data starting point building dfs arrangements
dfs ai marginal
least one traversal connected component dfs forest root
dfs children removed nodes initiate dfs token passing
dfs except changes
node xk sends token neighbors owned ai
order xk sends token neighbors dfs first xk
children dfs pseudochildren pseudoparents
parent order helps preserve structure dfs dfs ai
children pseudoparents excluded node instance x figure initiate dfs token
passing would redundant would eventually receive dfs token pseudoparent



fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

reconstruction dfs dfs
data structures dfs denoted superscript

procedure token passing dfs executed nodes xk
x ai







forall xl neighbors xk xl belongs ai
remove xl neighbors xk ck pc k pp k e send nothing ai
sort neighbors xk order ck pc k pp k pk mimic dfs
xk root pk x ai e executed root children ai
initiate dfs normal dfs
else process incoming tokens
send dfs xk back pki xk subtree completely explored
procedure process incoming tokens








wait incoming dfs token let xl sender
xl ai ignore message
else
first token received


pki xl pp
k xj pk xj neighbors xi dfs


rootk first node token dfs



else
let xr first node dfs

traversal
xr rooti
k e another dfs
depth xr dfs depth root
k dfs




reset pk pp k ck pc k override redundant dfs lower root


pki xl pp
k xj pk xj neighbors xi dfs

root k xr



continue







unique traversal connected component dfs forest node xk retains
root path dfs knows depth dfs arrangement token
dfs arrives
first dfs token arrives sender let xl marked
parent xk dfs pki xl notice xl could different
parent xk dfs xk stores first node received token dfs
root
k provisional root connected component xk belongs
dcop ai
first dfs token arrives two possibilities
token received part dfs traversal process xk recognizes
fact first node newly received token
previously stored root
k case xk proceeds normal
marks sender pseudochild etc


fip etcu faltings parkes

token received part another dfs traversal process initiated another
node root
k see text could happen let xr first
node newly received token xk recognizes situation fact xr

previously stored rooti
traversal
k case dfs
initiated higher node dfs prevails one dropped
determine traversal pursue one drop xk compares depths

rooti
k xr dfs xr higher becomes rootk xk
overrides previous dfs information one token
continues token passing token
see necessary start propagations children removed nodes step
consider example figure removing x x completely disconnects
subtree x x x x x x x started propagation subtree would
visited since connections rest
nodes subtree
lemma dfs correctness constructs correct dfs arrangement forest
dfs dcop ai given correct dfs arrangement dfs dcop
p roof first since dfs started child node controlled ai
root ensured connected component dfs traversed least follows
step second dfs process similar normal dfs construction node
sends token neighbors except ones controlled ai
pre specified order one given dfs follows nodes connected component
eventually visited follows step third higher priority dfs traversals override
lower priority ones e dfs traversals initiated nodes higher tree priority
step eventually one single dfs traversal performed single connected component
lemma dfs robustness dfs arrangement dfs constructed nonmanipulable agent ai input dfs arrangement solution phase dcop
p roof follows directly step since ai participate process
neighbors send messages see line messages may send
simply ignored see line
fact additional links created constructing dfs possible changes
edges reverse direction parents children pseudoparents pseudochildren
dfs traversals initiated step redundant part graph visited
simple overriding rule step ensures single dfs tree eventually adopted
connected component namely one initiated highest node original dfs
example figure x starts unnecessary dfs propagation eventually stopped x
receives higher priority dfs token x since x knows x higher dfs x drops
propagation initiated x relays one initiated x sending x token
dfs received x adds upon receiving token x node x realizes
x parent dfs thus redundant propagation initiated x eliminated
consistent dfs subtree single connected component p
simple time mechanism used ensure agent knows provisional dfs ordering final
e higher priority dfs traversals arrive future



fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

switch places existing back edges turn tree edges one see
figure
phase two dpop marginal utili propagations
dfs built marginal without ai solved dfs utility propagation proceeds normal dpop except nodes determine whether util message
sent dpop reused signaled parent sending special null util
message specifically process follows
leaves dfs initiate utili propagations
leaves dfs observe changes local dfs arrangement compared dfs util message sent dcop remains valid
announce parents sending instead null utili message
otherwise leaf node computes util message anew sends
parent dfs
nodes wait incoming utili messages
every incoming messages node xk receives children null
changes parent pseudoparents propagate null utili message
parent
otherwise xk recompute utili message reusing util
messages received dcop children sent null messages
dcop ai joining util messages received
example consider dcop ai figure x x children x x
recompute util message send parent x reuse
messages sent x x dcop neither sending subtrees contain ai

x reuses effort spent dcop compute messages util
util

util
util
theorem dpop faithful distributed implementation efficient social
choice terminates outcome vcg mechanism
p roof partition principle appeal theorem turn theorem first
agent ai cannot prevent construction valid dfs dcop ai lemmas
second agent ai cannot influence execution dpop dcop ai messages
ai influenced main dcop recomputed system without ai
rest proof follows simple dpop leveraging locality tax payment messages
enforcement provided bank via catastrophic failure assumption
simple alternative children nodes xki belong ai create bypass link first ancestor
xki belong ai example figure x x could create link x bypass x
completely dfs ai however additional communication links may required



fip etcu faltings parkes

experimental evaluation understanding effectiveness dpop
present experimental evaluation dpop simple dpop dpop
two different domains distributed meeting scheduling ms combinatorial auctions
cas first set experiments investigate performance dpop structured
constraint optimization ms received lot attention cooperative distributed
constraint optimization second set experiments cas investigate unstructured domains observe performance specifically ability use computation computing
payments dpop respect density cas provide abstract model many
real world allocation much studied mechanism design cramton shoham
steinberg
distributed meeting scheduling
distributed meeting scheduling consider set agents working large organization
representing individuals groups individuals engaged scheduling meetings
upcoming period time although agents self interested organization
whole requires optimal overall schedule minimizes cost alternatively maximizes
utility agents makes necessary use faithful distributed implementation
dpop enabling suppose organization distributes virtual currency
agent perhaps currency allocation prioritize particular participants relations held
agents defining agents utility solution scheduling thus stated
units currency
agent ai set local replicate variables xji meeting mj
involved domain variable xj thus local replicas xji represents feasible
time slots meeting equality constraint included replica variables ensure
meeting times aligned across agents since agent cannot participate one
meeting different constraint variables xij belonging agent
modeled clique constraint meeting variables agent assigns utility
possible time meeting imposing unary relation variable xji
relation private ai denotes much utility ai associates starting meeting mj
time dj dj domain meeting mj social objective schedule
total utility maximized satisfying different constraints agent
following maheswaran et al model organization providing hierarchical
structure realistic organization majority interactions within departments
small number across departments even interactions typically take place
two departments adjacent hierarchy hierarchical organization provides structure
test instances high probability around generate meetings within departments
lower probability around generate meetings agents belonging
parent child departments generated random structure increasing
number agents agents agent participates meetings
uniform random utility possible schedule meeting
participates generated feasible solutions
test instances found http liawww epfl ch people apetcu mdpop msexperiments tgz



fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

size averaged different instances solved main
dpop marginal ones simple dpop dpop respectively
experiments performed frodo multiagent simulation environment petcu
ghz gb ram laptop frodo simulated multiagent system agent executes
asynchronously thread communicates peers via message exchange
experiments geared towards showing much effort dpop able reuse
main marginal figure shows absolute computational effort terms
number messages figure terms total size messages exchanged
bytes figure b curves dpop represent number messages total size
messages respectively required solving cooperative curves simplem dpop dpop represent total number size respectively util messages
main marginal economies
notice several interesting facts first number messages required dpop increases
linearly number agents dpops complexity terms number messages
linear size hand number messages simple mdpop increases roughly quadratically number agents since solves linear number
marginal economies scratch dpop requiring linear number messages
performance dpop lies somewhere dpop simple dpop
advantage achieved simple dpop size increases culminating
almost order magnitude improvement simple dpop largest sizes e
agents similar observations made total size util
messages good measure computation traffic memory requirements inspecting
figure b metrics performance dpop slightly superlinear size
figure shows percentage additional effort required solving marginal
reused main e probability util message required solving marginal taken directly message already used main
clearly see size increases actually reuse computation
main intuition behind large individual agent
localized particular area translates agent localized
specific branch tree thus rendering computation performed branches reusable
marginal corresponds respective agent looking percentage
reuse defined terms message size rather number messages see
trending upwards size increases
combinatorial auctions
combinatorial auctions cas popular means allocate resources multiple agents cas
bidders bid bundles goods opposed bidding single goods combinatorial bids
model complementarity substitutability among goods e valuation
bundle respectively less sum valuations individual items
setting agents distributed geographically logically form graph
neighbors agents bids overlap objective feasible solution e
declare bids winning losing two winning bids share good maximizes
total utility agents


fip etcu faltings parkes



e


messages

dpop
simple dpop
dpop

total size util messages

dpop
simple dpop
dpop





e






























number agents















number agents

number messages

b total size util messages valuations

figure meeting scheduling measures absolute computational effort terms number

effort marginals reused main

messages sent total size util messages dpop simple dpop mdpop curves dpop represent effort spent main ones
simple dpop dpop represent total effort main marginal










total information
number messages






















number agents

figure meeting scheduling percentage effort required marginal
reused dpop main reuse measured terms percentage
util messages reused dashed terms total size util
messages reused fraction total util message size solid



fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

cas adopted stylized model distributed allocation airport slot
allocation wireless spectrum allocation discussed introduction ca instances
provide counterpoint meeting scheduling represent
less structure dcop model agent holds variable one bids two
possible values bid rejected bid accepted pair overlapping
bids bids share least one good connected one constraint specifies
cannot accepted multiple bids submitted agent
connected additional constraints capture bid logic instance exclusive constraints
one bid accepted
generated random cats leyton brown pearson shoham
l distribution sandholm l constant distribution agent
demands bundle goods selected uniformly random value distributed uniformly
simulations consider market goods vary number agents
recorded performance dpop simple mdpop dpop
graphs figures figure shows density increase three
require effort solving terms number messages terms
total information exchange
figure shows reusability varies density one see loose reusability good close agents density
increases number agents reusability decreases well around
dense agents explain phenomenon follows loose
many goods bidders bids mostly non overlapping turn ensures
removing individual agents solving marginal affect computation
performed solving main end spectrum dense
tend highly connected produces dfs trees similar chains
case removing agents close bottom chain invalidates much computation performed solving main therefore limited amount computation
reused
noting l recognized one hardest distributions cats
suite leyton brown et al remark need limit experiments distribution large induced tree width high density graphs
consider example every agent bids bundle overlaps every
agent graph clique dpop scale leave detailed
examination future work recent extension dpop h dpop kumar petcu faltings
immediately address issue h dpop consistency techniques used order
compactly represent util messages tightly constrained orders magnitude
improvements dpop reported see section

discussion
section discuss alternatives improving computational performance dpop
possibility faithful variations dcop adopt modi et al
optapo mailler lesser loss utility agents occur due
transfer payments bank mentioning address


fip etcu faltings parkes



e
total size util messages

dpop
simple dpop
dpop
messages







dpop
simple dpop
dpop

e
e

















number agents







number messages







number agents





b total size util messages valuations

figure combinatorial auctions measures absolute computational effort terms

effort marginals reused main

number messages sent total size util messages dpop simple dpop
dpop curves dpop represent effort spent main ones
simple dpop dpop represent effort main marginal
higher number agents thus bids thus constraints graph
density greater computational effort solve









total information
number messages



















number agents

figure combinatorial auctions percentage effort required marginal
reused dpop main reuse measured terms percentage
util messages reused dashed terms total size util
messages reused fraction total util message size solid



fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

algorithmic alternatives improved performance
dpop scales well size long induced width remains
low characteristic dpop inherits dpop
high induced width dpop dpop require producing sending storing large messages
may unfeasible undesirable mitigate several advances basic
dpop recently proposed sacrifice optimality
return computational tractability makes difficult combine vcg payment
mechanism way faithfulness guaranteed nevertheless h dpop kumar et al
mb dpop petcu faltings employ two different techniques preserve
optimality guarantees fitted dpop
h dpop leverages observation many real contain hard constraints significantly reduce space feasible assignments example auctions possible
allocate item one bidder meeting scheduling possible set two different start times given meeting unfortunately dpop take advantage pruning
power hard constraints sends messages explicitly represent value combinations including many infeasible ones h dpop addresses issue constraint decision
diagrams cdd introduced cheng yap compactly represent util messages
excluding unfeasible combinations performance improvements several orders magnitude
achieved especially highly constrained kumar et al
mb dpop petcu faltings uses idea cycle cutsets dechter explore
parts search space sequentially dense parts explored iterating
assignments subset nodes designated cycle cuts assignment performing
limited util propagation similar one dpop easy parts explored
one shot util messages exactly dpop mb dpop offers thus configurable tradeoff
number messages exchanged size messages memory
requirements
achieving faithfulness dcop
partition principle described section independent question
whether another optimal dcop made faithful therefore revolves critically around
whether satisfy robustness requirement partition priciple make
following observations
robustness first sense e agent ai influence solution efficient scp without agent ai achievable cost restarting computation
marginal agent removed turn proposed simple dpop
robustness second sense e agent ai influence report bank
receives negative externality ai imposes rest system conditioning
solutions main without ai requires dcop
terminates every agent knowing part solution relevant
defining utility robustness property follows disaggregation payments
thus one content restart dcop multiple times kinds
provide simple dpop generally available possible


fip etcu faltings parkes

already mentioned locality property payments follows disaggregation
vcg payment across agents eq information communication
structure dcop
useful property dcop context self interested agents worth reemphasizing possible retain faithfulness even one agent plays pivotal role
connecting graph suppose dcop ai becomes disconnected without ai case optimal solution represented union optimal
solutions connected subcomponent information needs flow disconnected components purpose solving purpose
reporting components agent ai tax
discuss following two sections adaptation two prominent complete dcop adopt modi et al optapo mailler lesser
discuss following two sections adaptation two prominent complete dcop adopt modi et al optapo mailler lesser
consider computational aspects making faithful specifically issues related efficient handling replica variables providing reusability main
marginal
u sing adopt



faithful e fficient ocial c hoice

adopt polynomial space search dcop guaranteed globally
optimal solution allowing agents execute asynchronously parallel agents
adopt make local decisions conservative cost estimates adopt works dfs
arrangement constructed detailed section roughly speaking main process
executed adopt backtrack search dfs tree
adaptation adopt dcop model replicated variables adopts complexity
given number messages exponential height dfs tree similar
dpop dcop model replicated variables could artificially increase complexity
solving process specifically height dfs tree increased replicated
variables compared centralized graph adopt modified exploit special
structure replicated local variables similar way dpop specifically adopt
explore sequentially values original variable ignore assignments replicas
variable take different values works allowing agent owns
highest replica variable freely choose values variable agent announces
value variable agents owning replicas variable agents
would consider announced value replicas add corresponding utilities continue search process special handling replica variables
resulting complexity longer exponential height distributed dfs tree
height dfs tree obtained traversing original graph example figure sufficient explore values directly assign values
via value messages without trying combinations values reduces adopts
complexity exponential exponential
reusability computation adopt turning use computation main
marginal note adopt uses dfs arrangement easy
identify parts dfs arrangement main impossible agent


fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

manipulate therefore reused computing solution marginal
agent removed however major difference dpop adopt dpop
agent stores outgoing util message thus available utilities contingent
assignments variables agents separator makes possible agent
simply reuse information marginal economies structure dfs proves
safe contrast adopt store information linear memory
policy turn makes impossible reuse computation main marginal
marginal solved scratch thus performance would
scale poorly size increases even structured meeting scheduling
see two alternatives addressing renounce linear memory guarantees
use caching scheme example ncbb chechetka sycara would allow
similar reusability dpop previously computated utilities extracted
cache instead recomputed alternatively b one devise scheme
previously computed best solution saved reference subsequently used
approximation solving marginal could possibly provide better bounds
thus allow better pruning computation could saved alternatives
outside scope considered future work
u sing ptapo



faithful e fficient ocial c hoice

optapo mailler lesser popular dcop similar
adaptations dpop adopt social choice optapo made take advantage
special features dcop model replicated variables complexity would
artificially increased use dcop model optapo particularity uses
mediator agents centralize subproblems solve dynamic asynchronous mediation sessions e partial centralization mediator agents announce
agents previously sent subproblems mediators process alone would
introduce additional possibility manipulation setting self interested agents however
vcg mechanism addresses concern agents choose behave correctly according protocol
adopt main issue optapo faithful social choice reusability
computation main marginal specifically consider solving
main mediator agent ai centralized aggregated preferences number
agents solving mediation dictated optapo protocol subsequently
trying compute solution marginal without agent ai computation
go waste could manipulated ai solving main furthermore since optapos centralization process asynchronous conflict driven opposed
structure driven dpop unclear whether computation main
could safely reused marginal make matters worse experimental studies davin modi petcu faltings many situations optapo ends
relying single agent system centralize solve whole implies
solving marginal without agent one reuse zero effort main



fip etcu faltings parkes

loss utility due wasting vcg taxes
vcg mechanism agents net utility difference utility derives
optimal solution vcg tax pay net utility whole group agents
sum individual net utilities agents e total utility assignment values
variables net total payment made agents bank loss utility
dpop great total utility optimal solution meeting
scheduling domain size increases money burnt
form vcg taxes similar waste observed others e g faltings
context efficient social choice
one cannot naively redistribute payment back agents instance sharing payments equally across agents would break faithfulness example agent ai would prefer
agents make greater payments order receive larger repayment bank
faithfulness properties dpop would unravel hand
inherent structure possible redistribute fraction payments back agents
idea careful redistribution suggested bailey subsequently extended
cavallo guo conitzer moulin another advocated example faltings simply preclude agent transfer payments
agent work centralized context
important issue future work study budget surplus accrues bank
dpop seek mitigate welfare loss setting distributed implementation
defer discussion topic future work investigate methods
leverage structure redistributing majority payments back agents
without compromising efficiency faithfulness

conclusions
developed dpop faithful distributed solve efficient
social choice multi agent systems private information self interest agent
improve utility misreporting local information deviating aspect
e g computation message passing information revelation centralized
component bank able receive messages payments collect payments
addition promoting efficient decisions minimize amount additional computational
effort required computing vcg payments reusing effort main first
set experimental shows significant amount computation required
marginal reused main sometimes provides
near linear scalability massive distributed social choice local structure
maximal induced tree width small second set experiments performed
without local structure shows density increases amount effort required increases reusability computation decreases suggest dpop
good candidate solving loose exhibit local structure induced width
remains small addition addressing need reduce total payments made agents
bank one issue future work relates need provide robustness faced adversarial
faulty agents current solution fragile sense equilibrium properties relying
agents following protocol papers lysyanskaya triandopoulos aiyer
alvisi clement dahlin martin porth shneidman parkes provide robustness


fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

mixture e g rational adversarial aware work
mixture context efficient social choice another interesting direction ways
allow approximate social choice example memory limited dpop variations petcu
faltings retaining incentive properties perhaps approximate equilibria future
consider design distributed protocols robust false name
manipulations agents participate multiple pseudonyms yokoo et al
seek mitigate opportunities collusive behavior possibility multiple equilibria exist incentive mechanisms ausubel milgrom andelman feldman
mansour katz gordon

acknowledgments
parkes supported part national science foundation grants iis iis
alfred p sloan foundation award petcu supported swiss national science foundation
grant authors would thank wei xue valuable feedback several
parts thank jeffrey shneidman feedback early version
thank aaron bernstein valuable insights dfs reconstruction process three
anonymous reviewers provided excellent suggestions improving exposition work
earlier version appeared proc fifth international joint conference
autonomous agents multiagent systems aamas

references
abu amara h h fault tolerant distributed election complete networks ieee
trans comput
aiyer alvisi l clement dahlin martin j p porth c bar fault tolerance
cooperative services th acm symposium operating systems principles
andelman n feldman mansour strong price anarchy acm siam symposium
discrete soda
arnborg efficient combinatorial graphs bounded decomposability
survey bit
ausubel l cramton p milgrom p clock proxy auction practical combinatorial auction
design cramton et al cramton et al chap
ausubel l milgrom p lovely lonely vickrey auction cramton et al cramton et al
chap
bailey j demand revealing process distribute surplus publicchoice
ball donohue g hoffman k auctions safe efficient equitable allocation
airspace system resources cramton shoham ed combinatorial auctions mit press
barbosa v introduction distributed mit press
bayardo r miranker space time trade solving constraint satisfaction proceedings th international joint conference artificial intelligence ijcai
montreal canada
bidyuk b dechter r finding minimal w cutset auai proceedings th
conference uncertainty artificial intelligence pp arlington virginia united states
auai press


fip etcu faltings parkes

bikhchandani de vries schummer j vohra r v linear programming vickrey
auctions dietrich b vohra r eds mathematics internet e auction markets pp
ima volumes mathematics applications springer verlag
cavallo r optimal decision making minimal waste strategyproof redistribution vcg payments proc th int joint conf autonomous agents multi agent systems aamas
chechetka sycara k space distributed constraint optimization
proceedings aaai spring symposium distributed plan schedule management
cheng k c k yap r h c constrained decision diagrams proceedings national
conference artificial intelligence aaai pp pittsburgh usa
cheung graph traversal techniques maximum flow distributed computation
ieee trans software eng
cidon yet another distributed depth first search inf process letters
collin z dechter r katz feasibility distributed constraint satisfaction
proceedings th international joint conference artificial intelligence ijcai pp
sidney australia
collin z dechter r katz self stabilizing distributed constraint satisfaction chicago journal
theoretical computer science
collin z dolev self stabilizing depth first search information processing letters

cramton p shoham steinberg r eds combinatorial auctions mit press
davin j modi p j impact centralization distributed constraint optimization
aamas proceedings fourth international joint conference autonomous
agents multiagent systems pp york ny usa acm press
davis r smith r g negotiation metaphor distributed solving artificial
intelligence
de vries vohra r v combinatorial auctions survey informs journal computing

dechter r constraint processing morgan kaufmann
dechter r mateescu r search spaces graphical artificial intelligence
appear
dunne p e extremal behaviour multiagent contract negotiation journal artificial intelligence
jair
dunne p e wooldridge laurence complexity contract negotiation artificial
intelligence journal
endriss u maudet n sadri f toni f negotiating socially optimal allocations resources
journal artificial intelligence
ephrati e rosenschein j clarke tax consensus mechanism among automated agents
proceedings national conference artificial intelligence aaai pp anaheim
ca
faltings b budget balanced incentive compatible scheme social choice workshop
agent mediated e commerce amec vi springer lecture notes computer science
faltings b parkes petcu shneidman j optimizing streaming applications selfinterested users dpop comsoc international workshop computational social
choice pp amsterdam netherlands


fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

feigenbaum j papadimitriou c sami r shenker bgp mechanism lowest cost
routing proceedings acm symposium principles distributed computing pp

feigenbaum j ramachandran v schapira incentive compatible interdomain routing
proceedings th conference electronic commerce pp
feigenbaum j shenker distributed algorithmic mechanism design recent
future directions proceedings th international workshop discrete
methods mobile computing communications pp
freuder e c quinn j taking advantage stable sets variables constraint satisfaction
proceedings th international joint conference artificial intelligence ijcai pp los angeles ca
gershman meisels zivan r asynchronous forward bounding distributed constraints
optimization proceedings th european conference artificial intelligence ecai
riva del garda italy
greenstadt r pearce j p tambe analysis privacy loss distributed constraint optimization proc twenty first national conference artificial intelligence aaai
guo conitzer v worst case optimal redistribution vcg payments proceedings
th acm conference electronic commerce ec pp
huebsch r hellerstein j lanham n et al querying internet pier vldb
izmalkov micali lepinski rational secure computation ideal mechanism design
focs proceedings th annual ieee symposium foundations computer science
pp washington dc usa ieee computer society
jackson mechanism theory encyclopedia life support systems eolss publishers
jackson crash course implementation theory social choice welfare
katz j gordon rational secret sharing revisited proc security cryptography
networks
kloks treewidth computations approximations vol lecture notes computer
science springer
krishna v auction theory academic press
kumar petcu faltings b h dpop hard constraints prune search space
ijcai distributed constraint reasoning workshop dcr pp hyderabad india
lavi r mualem nisan n towards characterization truthful combinatorial auctions
proc th annual symposium foundations computer science
leyton brown k pearson shoham towards universal test suite combinatorial
auction proceedings acm conference electronic commerce ec pp

leyton brown k shoham test suite combinatorial auctions cramton p shoham
steinberg r eds combinatorial auctions chap mit press
lysyanskaya triandopoulos n rationality adversarial behavior multi party computation th annual int cryptology conference crypto
maheswaran r tambe bowring e pearce j p varakantham p taking dcop
real world efficient complete solutions distributed multi event scheduling aamas
mailler r lesser v solving distributed constraint optimization cooperative mediation proceedings third international joint conference autonomous agents multiagent
systems aamas


fip etcu faltings parkes

mailler r lesser v asynchronous partial overlay solving distributed
constraint satisfaction journal artificial intelligence jair
mas colell whinston green j r microeconomic theory oxford university press
mishra parkes ascending price vickrey auctions general valuations journal
economic theory
modi p j shen w tambe yokoo adopt asynchronous distributed constraint
optimization quality guarantees ai journal
monderer tennenholtz distributed games mechanisms protocols proc th
national conference artificial intelligence aaai pp
moulin h efficient strategy proof almost budget balanced assignment tech rep rice university
mualem decentralized incentive compatible mechanisms partially informed environments
proc acm conf electronic commerce ec
ostrovsky r rajagopalan vazirani u simple efficient leader election full information model stoc proceedings twenty sixth annual acm symposium theory
computing pp york ny usa acm press
parkes c kalagnanam j r eso achieving budget balance vickrey payment
schemes exchanges proc th international joint conference artificial intelligence ijcai pp
parkes c shneidman j distributed implementations vickrey clarke groves mechanisms
proc rd int joint conf autonomous agents multi agent systems pp
parkes c ungar l h iterative combinatorial auctions theory practice proc th
national conference artificial intelligence aaai pp
petcu frodo framework open distributed constraint optimization technical
report swiss federal institute technology epfl lausanne switzerland http
liawww epfl ch frodo
petcu faltings b dpop approximations distributed optimization proceedings
eleventh international conference principles practice constraint programming
cp pp sitges spain
petcu faltings b b dpop scalable method multiagent constraint optimization
proceedings th international joint conference artificial intelligence ijcai pp
edinburgh scotland
petcu faltings b pc dpop partial centralization extension dpop proceedings
second international workshop distributed constraint satisfaction ecai riva
del garda italy
petcu faltings b mb dpop memory bounded distributed optimization proceedings th international joint conference artificial intelligence ijcai
hyderabad india
pietzuch p ledlie j shneidman j roussopoulos welsh seltzer network aware
operator placement stream processing systems icde
rassenti j smith v l bulfin r l combinatorial mechanism airport time slot allocation bell journal economics
roberts k characterization implementable rules laffont j j ed aggregation
revelation preferences pp north holland amsterdam
rosenschein j zlotkin g designing conventions automated negotiation ai magazine
fall


fim dpop faithful istributed mplementation e fficient ocial c hoice p roblems

sandholm optimal winner determination combinatorial auctions artificial
intelligence
sandholm w implementation contract net protocol marginal cost calculations proc th national conference artificial intelligence aaai pp
sandholm w limitations vickrey auction computational multiagent systems second
international conference multiagent systems icmas pp
shneidman j parkes c rationality self interest peer peer networks nd int
workshop peer peer systems iptps
shneidman j parkes c specification faithfulness networks rational nodes proc
rd acm symp principles distributed computing podc st johns canada
silaghi c sam haroud faltings b asynchronous search aggregations
aaai iaai pp austin texas
solotorevsky g gudes e meisels modeling solving distributed constraint satisfaction
dcsps proceedings second international conference principles practice
constraint programming cp pp cambridge massachusetts usa
sycara k roth f sadeh koniecpol n fox distributed constrained heuristic search
ieee transactions systems man cybernetics
wellman p market oriented programming environment application distributed multicommodity flow journal artificial intelligence
wellman p market oriented programming early lessons clearwater h ed
market control paradigm distributed resource allocation chap pp world
scientific
yokoo durfee e h ishida kuwabara k distributed constraint satisfaction formalizing distributed solving international conference distributed computing systems pp

yokoo hirayama k distributed constraint satisfaction review autonomous
agents multi agent systems
yokoo sakurai matsubara effect false name bids combinatorial auctions
fraud internet auctions games economic behavior
zhang w wittenburg l distributed breakout distributed constraint optimization
dbarelax proceedings international joint conference autonomous agents
multi agent systems aamas melbourne australia
zlotkin g rosenschein j mechanisms automated negotiation state oriented domains
journal artificial intelligence




