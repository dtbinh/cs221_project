journal artificial intelligence

submitted published

ultrametric constraint
application phylogenetics
neil c moore

ncam cs st andrews ac uk

computer science university st andrews scotland

patrick prosser

pat dcs gla ac uk

computing science glasgow university scotland

abstract
phylogenetic tree shows evolutionary relationships among species internal nodes
tree represent speciation events leaf nodes correspond species goal
phylogenetics combine trees larger trees called supertrees whilst respecting
relationships original trees rooted tree exhibits ultrametric property
three leaves tree must one pair deeper recent common
ancestor pairs three recent common ancestor
inspires constraint programming encoding rooted trees present efficient
constraint enforces ultrametric property symmetric array constrained
integer variables inevitable property lower bounds three variables
mutually supportive allows efficient constraint solution
supertree construction demonstrate versatility constraint
programming exploited allow solutions variants supertree construction


introduction
one grand challenges phylogenetics build tree life tol representation evolutionary history every living thing date biologists catalogued
million species yet estimates total number species range
million million species identified placed tol
far pennisi applications tol help understand pathogens
become virulent time diseases emerge recognise species risk
extinction pennisi mace gittleman purvis one building
tol divide conquer combining smaller trees available treebase
treebase called supertrees bininda emonds
complete tol
date supertree construction dominated imperative techniques semple
steel semple daniel hordijk page steel daniel bordewich
evans semple ng wormald bryant steel page
recently declarative approaches emerged constraint programming gent
prosser smith wei prosser beldiceanu flener lorca answer
set programming wu lin one properties rooted trees suits
approaches trees nature ultrametric rooted trees root node
depth depth nodes plus depth parent taking
c

ai access foundation rights reserved

fimoore prosser

three leaves b c pairs must one pair deeper recent common
ancestor mrca pairs three pairs mrca
mean ultrametric three tie minimum fact
know depth mrca pairs leaves structure tree uniquely
determined inspires constraint programming encoding rooted trees
ultrametric constraint define later explore solutions phylogenetic
supertree variants practicality ultrametric
encoding rooted tree well arguing valuable addition
set techniques supertree
organised follows first introduce constraint programming
supertree construction propose specialised ultrametric constraint
terms propagation procedures maintains bounds z consistency bessiere
three variables specialised constraint required
use toolkit primitives cannot guarantee ultrametric property supertree via propagation alone furthermore space complexity becomes
prohibitive ultrametric constraint extended maintain property
symmetric matrix variables go constraint efficiently
applied supertree construction particular applying propagation
model gives polynomial time procedure supertree construction demonstrate real data give justification improvement time
space previous constraint encodings one benefits constraint programming variants supertree addressed within
one model justify assertion proposing constraint solution finding essential
relations supertree daniel addressing ancestral divergence dates semple
et al bryant semple steel modelling nested taxa page daniel
semple coping conflicting data

background
section give necessary definitions descriptions constraint satisfaction
tsang constraint programming supertree
constraint programming csp
constraint programming cp rossi van beek walsh declarative style
programming modelled csp e set variables
assigned values variables domains satisfy set constraints values
might typically integers drawn finite domains real numbers ranges
complex entities sets graphs considering integers
definition constraint satisfaction csp triple v c v set
n variables v vn dom v dom vn collection domains
totally ordered set integer values c c ce set e constraints
scope variables scope c vc vck relation rel c dom vc dom vck
assignment value x dom v variable vi v denoted vi x constraint
c c satisfied assignment vc xc vck xck scope c vc vck


fithe ultrametric constraint phylogenetics

xc xck rel c set assignments v x vn xn involving every
variable solution satisfies constraints c
constraint solver finds solution csp via process constraint propagation
search constraint propagation inferencing process takes place variable
initialised loses values propagation maintains level consistency arcconsistency mackworth across variables removing values domains
cannot occur solution e removing unsupported values use definitions
generalized arc consistency g ac due bessiere
definition given csp v c constraint c c scope c vc vck
variable v scope c value x dom v consistent respect c alternatively
supported c iff exists satisfying assignment vc vck ak c
v x ai dom vci domain dom v generalized arcconsistent c iff values dom v consistent respect c csp
generalized arc consistent variable domains generalized arc consistent
constraints c
arc consistency established csp ac mackworth sake exposition assume constraints c binary
constraint c counterpart c scope c va vb
scope c vb va rel c rel c example constraint
cxy x constraint cyx x heart ac revise
function takes binary constraint c argument delivers boolean
function removes dom va values support dom vb w r
constraint c returns true removals take place initially constraints added
set constraints iteratively removed revised revise ckm returns
true becomes cik cik c k step considered
propagation domain reduction variable vk variables constrained vk
iteration terminates empty variables domain becomes empty
empty arc consistency reached fixed point e application
arc consistency process effect domains variables
made arc consistent domain empties shown
solutions globally hence stop ac e time
complexity e number constraints size largest domain however achieve time bound e yuanlin yap bessiere
regin
demonstrate arc consistency example figure smith
three constrained integer variables x z integer domain
binary constraints cxy x cyz z even czx z x since
constraints binary represent constraint graph nodes
vertices edges constraints initially constraint cxy revised respect x
values removed dom x cxy revised w r dom
becomes cyz revised w r effect revised w r z
effect revising czx w r z reduces dom z becomes consequently
constraint cyz added set constraints pending revision constraint czx


fimoore prosser



se



zi




n

x



x


z

z x

figure binary constraint satisfaction
import choco
import choco contradictionexception
import choco integer
public class bmstut
public static void main string args throws contradictionexception
pb

intdomainvar x
pb makeenumintvar x x
intdomainvar
pb makeenumintvar
intdomainvar z
pb makeenumintvar z
intdomainvar even pb makeenumintvar even int
pb post pb gt pb minus x
x
pb post pb gt pb plus pb mult x z z x
pb post pb eq even pb plus z
z even
pb solve

solve mac




figure jchoco constraint program csp figure
revised w r x cyz w r effect revision set point
empty arc consistency established variable domains dom x
dom dom z
solving csp may involve search e might need try different values variables order determine solution exists typically constraint solver begin
establishing arc consistency repeatedly select variable assign value
domain instantiate effectively reduces variables domain singleton
arc consistency established succeeds another instantiation made
fails backtrack undoing recent instantiation called mac
maintaining arc consistency sabin freuder
figure shows constraint program figure choco constraint programming toolkit java language choco finds solution
x z first
constraint toolkits tend around ac van hentenryck deville
teng allowing propagators specialised specific constraints resulting
improved efficiency adaptability ac amends set ac contain triples
form v c v scope c set values lost v consequently


fithe ultrametric constraint phylogenetics

revision efficient propagation focus values may lost support
rather check every value support object oriented toolkit language
constraint associated propagation methods implemented
methods activated domain event occurs variable involved constraint
domain events initialisation variable increase lower bound
decrease upper bound removal value bounds instantiation
variable exhaustive list however toolkits allow one event
one values lost propagator writer must determine
action take give examples toolkit specialised constraints
modelling routing might constrained integer variable location
visited domain values corresponding index next destination
called single successor model subtour elimination constraint caseau laburthe
might used ensure legal tours produced regins alldifferent constraint regin could added increase domain filtering pick
delivery variant side constraints could added ensure locations
visited others job shop scheduling might model uses
variables decide relative order pairs activities share resource
might increase propagation adding carlier pinsons edge finding constraint
constraint programming general practical modelling solving
provides framework combination specific
one solver allows us solve many classes efficiently model even
via addition side constraints
supertree
supertree construction phylogenetics combine leaf labelled
species trees sets leaf labels intersect single tree respects
arboreal relationships input tree bininda emonds species trees describe
part evolutionary history set species labels leaves correspond existing
species internal nodes represent divergence events evolutionary history one
species split least two species species trees may annotated dates
internal nodes representing time divergence event happened
define term displays makes precise mean respects
arboreal relationships supertree displays tree equivalent
e induce hierarchy leaf labels obtained following
steps semple steel
let l set leaves
let unique subtree connects leaves l
obtain wherever subpath p pk path root
leaf p pk interior nodes degree contract
single edge
produce rooted species tree forest input trees f
contains species f displays every tree f figures illustrate
displays property


fimoore prosser

















b

c














e





















e


































l e



e

e

figure example tree displays tree









l e


















c

b

e




































e




e














e

figure example tree display tree



fithe ultrametric constraint phylogenetics

say two trees compatible incompatible exists doesnt
exist third tree displays variants supertree
previously published solved specialist bioinformatics literature include
finding solutions counting solutions finding conserved relationships supertrees
daniel incorporating nested taxa semple et al incorporating ancestral divergence dates semple et al possibility contradictory input data semple
steel

ultrametric constraint
ultrametric constraint first proposed gent et al within context
supertree construction bininda emonds implemented toolkit primitives review encoding constraint toolkits inefficient
terms space time motivates creation specialised ultrametric
propagator three variables maintains ultrametric property bounds
variables presented describing necessary propagation methods
extend specialised propagator maintains ultrametric property
symmetric matrix variables
previous work ultrametric constraint
first give definition ultrametric constraint
definition ultrametric constraint three variables henceforth um x z
constrains
x z x z z x x z



constraint ensures tie least element three e
three two greater constraint
proposed gent et al used prosser times implemented
literal translation equation toolkit primitives evidence obtained
jchoco eclipse ilog constraint programming toolkits shows propagation
done lower bounds combination primitive constraints due disjunctive constraints since many constraint programming toolkits propagation delayed
one disjuncts true known delayed disjunction consistency
van hentenryck saraswat deville consequently encoding values
cannot occur satisfying assignment might pruned domain
variable consider case three variables x z
domains variables already fixed point respect delayed disjunction
consistency ultrametric assignment x takes value e delayeddisjunction propagation achieve arc consistency shall see later finding
solution supertree toolkit constraints backtracking
search prefer avoid course higher levels consistency would overcome
constructive disjunction consistency van hentenryck et al singleton
may multiple supertrees set input trees



fimoore prosser

arc consistency debruyne bessiere filtering lhomme
however cost greater average case delayed disjunction preventing use toolkits fact um constraint especially unfortunate
lower bounds may trimmed properly
lemma um constraint lower bounds supported e form ultrametric instantiation values constrained variables support
proof consider three supported lower bounds suppose contradiction two
least distinct one distinct lowest cannot supported
account fact equal anything larger anything therefore
contradiction two least must equal however lower bound least
large lower bounds mutually supportive
lemma important implications species tree model presented
detail section particular lower bounds bounds z consistency model
form solution bounds z consistency bessiere defined follows
definition given v c constraint c c scope c vc vck tuple
xc xck bound support rel c xci min dom vci
xci max dom vci constraint c bounds z consistent vci scope c
exist bound supports involving min dom vci max dom vci csp bounds z consistent every constraint c c bounds z consistent
henceforth abbreviate bound support support bounds z consistency
bc z bc z differs ac puts weaker conditions values comprise
support rather domain need
lower upper bounds domain means bc z prunes subset
values ac general weaker levels consistency bc z useful
certain prune number values ac easily
fewer values much quickly case bc z interesting level
consistency enough ensure solved propagation
search shall see
design bc z um propagator
section describe um propagator enforces bc z namely um bcz
analysis lower upper bounds
section dont take account domains becoming empty since analyse lower
upper bounds isolation lower bound may pass upper bound vice versa
thereby emptying domain happens propagator described section
enforce bc z rather terminate domain
becoming empty means solution continue would waste time
concordantly section analyse lower bounds assume upper
bound domain cannot become null reason vice versa


fithe ultrametric constraint phylogenetics

code style variables v v v l constrained integer variables synonymous domains consequently variable x considered domain x lb
x ub return references lower upper bounds respectively sortonlowerbounds x z
returns tuple references variables x z non decreasing order lower bounds
sortonupperbounds analogous let l names references l
lb lb lower bound assigned equal value lower bound
although lb subsequently changes distinct expression x b returns
intersection domains max x lb lb min x

um bcz
lbfix v v v

let l sortonlowerbounds v v v

lb lb

lb lb
ubfix v v v

let l sortonupperbounds v v v

ub ub

b l

ub ub

else b

l ub ub
min event v v v

lbfix v v v

domains non empty

ubfix v v v
max event v v v

ubfix v v v
fix event v v v

lbfix v v v

domains non empty

ubfix v v v

figure um bcz propagator



fimoore prosser




l






l


l

l


figure cases analysis lbfix

l


l



l








figure cases analysis ubfix
procedure lbfix figure takes input three variables removes unsupported values lower bounds domain intuition achieving
one needs involved tie least element hence smallest
lower bound strictly less others must unsupported
possible states lower bounds lbfix invoked summarised figure
three different case three case two
one different cases give relationships bounds point time
lower bound may unsupported boxes figure shaded follows
regions shaded black removed propagation whereas gray regions supported
diagrams supposed suggest example case bounds differ
rather two bounds lined bound one
different another different non zero unspecified amount hence
describe relationships actual values
following shows lbfix removes unsupported values remove
supported values
lemma lbfix invoked lower bounds argument variables supported
w r um constraint supported values removed
proof cases figure condition line satisfied line
executed removal unsupported range inspection
remaining bounds mutually supportive cases condition line
failed changes made domains bounds mutually supportive
procedure ubfix figure job upper bounds lbfix
lower bounds following lemma justifies assertion cases used
proof shown figure
lemma ubfix invoked


fithe ultrametric constraint phylogenetics

upper bounds argument variables supported w r um bcz constraint supported values removed
domain null removing unsupported values

proof let l domains smallest middle largest upper bounds
breaking ties arbitrarily let l upper bounds
first prove case figure shaded region supported
l b potentially bound supported
equal values l least small e b l
equal value l value least large remaining domain
however notice latter impossible due fact l contains equal
value value large
similar arguments establish shaded regions l case case
l case supported b l b b respectively
establish lemma cases
cases condition line false domains changed
upper bounds mutually supportive case
case shaded region unsupported l b hence
ubfix line executed unsupported region removed upper
bounds l l mutually supportive
case shaded region supported lb shaded
region l supported b neither line executed
changes made domains upper bound supported
l shaded region l supported b
line executed resulting removal region bounds
l mutually supportive
case shaded regions l supported l b
b hence domain changes executing ubfix l l
supported l l supported l
case shaded regions l unsupported l b
b line ubfix executed becoming null
case shaded region supported shaded region l supported
lb b executed remove unsupported
region bounds l mutually supportive
case shaded region l supported shaded region supported
symmetric previous case

note analog lemma upper bounds since example bounds
x z supported mutually supportive


fimoore prosser

propagation
presented lbfix ubfix position present complete propagation propagator works arbitrary domains enforces bc z
except domain becomes empty case work
described action taken three domain events occur
min domain lost lower bound since propagator last invoked
max domain lost upper bound since propagator last invoked
fix domain singleton e variable instantiated upper lower bounds
equal
e consider events bounds variables listed lines
figure intuitively procedures work change
upper bound affect support upper bounds change lower
bound affect support lower upper bounds hence need run
lbfix lower bound may changed ubfix must run change
lower upper bounds whilst would correct cycle trimming upper
lower bounds fixed point reached e changes occur guarantee
fixed point easily
lemma possible change lower bound loss support
another lower bound
proof bounds diagram support black shaded lower
bound lost dark gray shaded lower bound loses support

lemma possible change lower bound loss support
upper bound
proof bounds diagram support black shaded lower
bound lost dark gray shaded upper bound loses support

lemma possible loss upper bound cause loss support
another upper bound


fithe ultrametric constraint phylogenetics

proof bounds diagram support black shaded upper
bound lost dark gray shaded upper bound loses support

corollary impossible change upper bound loss support
lower bound
proof lemma lower bound retains support long lower bounds
intact hence losing upper bound effect
asymmetry upper lower bounds due asymmetry
definition um bcz practical repercussion bc z lower bounds
must mutually supportive whereas bc z upper bounds may may require
support values including lower bounds
corollary suggests improvement figure
execute line lower bound lost remaining support
upper bound however conditionals intrinsic ubfix amount much
thing little point repeating
point theorems build complete proof correctness
bc z status
theorem code min max fix events listed figure remove
values involved bound supports um bcz constraint domains
non null propagation resultant domains bc z
proof first must establish values removed propagation could
involved support domains subsets input domains
former immediate lemmas values removed
executing lbfix ubfix latter immediate inspection lbfix ubfix
ever make lower bounds larger upper bounds smaller
final thing establish bc z enforced unless domain becomes null
domain becomes empty running theorem
trivially true
domain becomes empty must bounds supported
lower bounds lemma corollary know loss lower bound
need change lower bound propagation lower bounds
change fix min events hence propagator figure runs lbfix
event lbfix runs leaves lower bounds supported shown
lemma upper bounds lemmas know loss lower
upper bound loss upper bound hence upper lower bounds
change event lower bounds change lbfix
hence propagator runs ubfix events runs lbfix finished
necessary ubfix runs leaves upper bounds supported provided domain
becomes empty shown lemma


fimoore prosser









































b

figure propagation done domains singleton
propagation runs time operations
lbfix ubfix min max fix events provided domain representation
allows access upper lower bounds guaranteed domain
reductions occur bounds case domains represented
one structures proposed van hentenryck et al
entailment
schulte carlsson define entailment possible constractions
domains constraints scope consistent detect happened
stop running propagator henceforth since cannot prune values
definition propagator entailed domains dn set
domains subsets e e e en ei di fixed
point
describe sufficient condition um bcz constraint entailed e
um bcz constraint becomes entailed soon two variables singleton domains
theorem um bcz becomes entailed soon two variables singleton domains
proof consider possible scenarios two singletons case
figure distinct case b figure domains propagation
shown figure boxes domains propagation shaded gray clearly
remaining choices third variable valid instantiations since propagation
safe cannot removed propagation definition
propagation fixed point
ultrametric matrix constraint
supertree model presented section makes use ultrametric constraint however
context desired end product constrain whole matrix ultrametric
matrix merely constrain three variables


fithe ultrametric constraint phylogenetics

code style let j index v declares j indices variable v matrix
constraint

um matrix bcz
min event v

let j index v

k n

k k j

min event mij mik mjk

max event mij mik mjk
max event v

let j index v

k n

k k j

max event mij mik mjk
fix event v

let j index v

k n

k k j

min event mij mik mjk

max event mij mik mjk

figure um matrix bcz propagator

definition symmetric matrix ultrametric matrix every set
three distinct indices j k tie minimum mij mik mjk
mii
ultrametric matrix constraint achieved matrix posting constraint um bcz
ij mik mjk choices distinct j k cost

introducing n constraints practical constraint solvers model containing constraint n space complexity since solver must list n
constraints stored somewhere however domain event occurs matrix variable mij straightforward iterate k indices propagation
um matrix bcz figure replaces n space list representation set
um bcz constraints code representation hence propose ultrametric
matrix constraint propagator um matrix bcz figure
propagator mimics part ac mackworth since
receives propagation event variable b identifies constraints
variable c arranges propagation carried events caused
queued dispatched underlying propagator normal may
cause um matrix bcz run variable involved n
constraints since variable two indices matrix constraint
involving choice three different indices
n


propagates n time expensive per event
um constraints factor n fewer propagators wake event


fimoore prosser



b

c



c

b

b

c





b

c

figure four possible relationships three leaf nodes tree e three
triples ab c ac b bc fan abc

supertree construction
review imperative solutions supertree construction review first
constraint programing solution gent et al present encoding exploits
specialised um matrix bcz constraint
imperative solutions supertree
earliest imperative techniques due bryant steel ng wormald
present onetree build
aho sagiv szymanski ullman onetree observation
tree three leaf nodes define unique relation respect recent
common ancestor mrca mrca b interior node furthest root
leaf nodes b descendants abuse notation writing mrca b
mrca c former greater depth latter similarly mrca b
mrca c depth given three different leaf nodes species labelled
b c one following four relations must hold


mrca b mrca c mrca b c



mrca c mrca b mrca c b



mrca b c mrca b mrca c



mrca b mrca c mrca b c

say triples ab c ac b bc
xy z read x closer z fan abc e
fan relationship species unresolved dont specify pair
closely related shown figure prior applying onetree two
species trees broken triples fans breakup
ng wormald resulting linear sized encoding trees supertree
constructed possible encoding input
figure shows example breakup process two variants
process shown top hard breakup fans considered hard
evidence must respected hard polytomies described ng wormald
soft breakup fans taken lack evidence soft polytomies
described bryant steel hard breakup modified


fithe ultrametric constraint phylogenetics

e



b

c

b

c

g

break

break

break

b c
b
c
b c

cd e

de f

ef g





e

c

e



f

break

f

f

g



e

f

g

e

f

g



break

break

break

break

ab e
bc e

cd e

de f

ef g

e

g

c

abc abd

bcd cd e
de f ef g

f

g



e

f

g

e

f

ab e bc e

cd e de f
ef g

g



figure example execution breakup top hard breakup
soft breakup fans produced

code style function sortedinteriornodes delivers set interior nodes tree nonincreasing order depth tree degree v delivers degree node v function child v
delivers ith child interior node v uncleorcousin l delivers leaf node descended
sibling parent leaf node l function becomesleaf v l transforms interior node v leaf
node labelled l removechild l v removes leaf node l list children interior node v

hardbreakup
hardbreakup

let v sortedinteriornodes

let

let

notroot v degree v

let v v

let c child v

degree v

let c child v

let c uncleorcousinof c

triple c c c

v becomesleaf v c

ii

else j degree v

k j degree v

let c child v j

let c child v k

fan c c c

v removechild c v
return

figure hard breakup tree producing triples fans

encountering kfan broken n fans soft breakup
fan broken linear number rooted triples hard soft breakups
given figures used imperative onetree
constraint programming


fimoore prosser

softbreakup
softbreakup

let v sortedinteriornodes

let

let

notroot v

let v v

let c child v

let c child v

let c uncleorcousinof c

triple c c c

degree v

v becomesleaf v c

ii

else v removechild c v
return

figure soft breakup tree producing triples

c



b

c

e

c

b



c





e

b

e

figure toy input left single solution supertree right input
trees distorted make relationships resultant supertree obvious

toy set input triples single solution shown figure triples
drawn reflect solution compatible
ng wormald give complexity onetree h n h n
n n bn n f n number labels number triples f number
fans b sum squares number leaves fans inverse
ackermann function less conceivable inputs behaves
constant therefore input trees fully resolved e fans running


fithe ultrametric constraint phylogenetics

time complexity n worst case complexity grows n
contrasted n complexity bryant steels onetree
constraint encoding toolkit constraints
second stage e onetree equivalent first solved constraint program
gent et al encoding takes advantage equivalence ultrametric
trees ultrametric matrices
definition let real symmetric n n matrix ultrametric tree
rooted tree
n leaves corresponding unique row
internal node least children
two leaves j mij label recent common ancestor
j
along path root leaf labels strictly increase
theorem symmetric matrix ultrametric tree
ultrametric matrix furthermore tree uniquely determines matrix
matrix uniquely determines tree
proof proof given gusfield
clear correspondence definition description species
tree given section species tree ultrametric tree matrix mij
depth mrca species j mij divergence date two species
reason use ultrametric matrix model solve supertree
model gent et al
given input forest f n distinct leaf labels symmetric
constrained integer variables created domains n
diagonal variable mij depth mrca species j
posted make whole matrix ultrametric thus ensuring
ultrametric
mij mik mjk
mik mij mjk
mjk mij mik
mij mik mjk

n n matrix
main
initially constraints
resulting tree



j k input trees broken triples fans
breakup figures triple ij k produced constraint
mij mik mjk




fimoore prosser



b
c

e
f
g


e g

c



b c e f g













b f

figure one iteration convert ultrametric matrix tree
posted fan ijk
mij mik mjk



posted constraints break disjunctions equation model n n
variables
f


n
n n n n




constraints number triples f number fans n
one breaks disjunction one constraint equation
n
converting back tree representation
final step use constructive proof gusfield
direction theorem build tree matrix produced constraint
solver describe detail sake intuition works
follows
pick arbitrary leaf let number distinct entries row
partition leaves sets p pd entry row
solve recursively pi ignoring rows columns
matrix pi
combine overall solution attaching subproblem solutions correct depth
path
figure shows one recursion choice leaf shows
row fully describes path corresponding tree


fithe ultrametric constraint phylogenetics

cpbuild
cpbuild f
let v c cpmodel f
f

breakup c post c
propagate v c return umtotree v
else fail

figure build supertree forest f ultrametric constraint model
time complexity model gent et al
breakup procedures build constraint model convert ultrametric
matrix tree polynomial time however complexity backtracking search

n variables n size domains worst case nn upper bound
time taken solve supertree attempted derive lesser
upper bound time complexity since following section
model provably achieved polynomial time bound
constraint encoding propagator design
issue potentially exponential solution time model section worrying
experiments time taken solve instances major issue conversely
memory requirements practice theory model requires
n space n species constant factor inhibiting posting constraint
equation literally toolkit propagators described section uses propagators jchoco toolkit requires roughly times runtime memory
single propagator since corresponds single java object
comparable footprints empirical study section prevents
modest instances loaded typical current workstations

propagator section replace n propagators single
compact propagator memory usage reduced asymptotically n
n since model memory dominated n space needed
matrix reducing amount space initialised delivers proportional
saving build time importantly constraint provides solution
exponential time complexity enforcing bc z model allows solution
read lower bound domain theorem proof correctness

figure gives schema constraint programming supertree construction cpbuild takes input forest f trees line constraint
model produced e n n symmetric array constrained integers variables created n unique species forest um matrix bcz constraint
posted variables lines breaks input trees triples
fans breakup given figures posts
model constraints propagators constraints executed fixed point
line succeeds tree created lower bounds ultrametric matrix
otherwise fail


fimoore prosser

lemma propagator every constraint model enforces bc z furthermore lower bounds mutually supportive executing propagators
fixed point lower bounds solution empty domain fail
proof reduce domain lower bound fixed point obtained
bound supported mutually supportive supposition hence
every constraint simultaneously satisfied singleton domains definition
solution
theorem cpbuild polynomial time solution supertree
proof constraints involved model triples fans ultrametric constraints theorem know lower bounds supported
propagators run lemma know lower bounds mutually supportive true disjunction breaking propagators hence lemma
shown figure read solution fail enforce bc z
polynomial time shown
immediate preserve polynomial time solution
addition polynomial number side constraints long additional constraints
preserve property lower bounds mutually supportive fact csps
ordered domains constraints property lower bounds
mutually supportive belong known tractable class called min closed jeavons cooper

time complexity cpbuild
implemented run n time variation ac
ac mackworth begins queue containing constraints
repeatedly removes constraint none remain runs associated propagator
constraints affected variables queued necessary queue empties
propagators fixed point need n constraints worst case complexity

n
z



build initial q

n n
z

worst case queues value removed time




z

propagation time

n overall matches worst case complexity onetree ng wormald
constraint solution worst case unsolvable since
unsolvable domains emptied propagation whereas solvable instances
propagation reaches fixed point sooner

empirical study
present empirical study determine practical improvements
achieved constraint solutions supertree size improvement experiments run ghz pentium processor mb memory
sun java build b constraint toolkit used jchoco version


fithe ultrametric constraint phylogenetics

input trees broken hard breakup consequently cases fans treated
hard polytomies
benchmark real life seabird data previously used kennedy page
beldiceanu et al present statistics techniques producing supertrees namely onetree cp solutions section entries toolkit
cpbuild completeness reproduce beldiceanu et al
data set tabulate treecon treecon uses single successor model
constrained integer variables represent nodes within tree domains correspond
possible successors unique variable represents root loops e
vroot root leaf nodes indegree zero precedence incomparability
constraints generated input trees
treecon encoded constraint programming toolkit
processor approximately twice fast ghz correct times
compensate factor mark bold differ significantly
cpbuild treecon specifically whose runtimes would undoubtedly
factor different processor reported combinations
seabird trees input trees named g following data tabulated
data combination attempted
n total distinct species input trees
sol iff supertree possible
technique type used solve
build time milliseconds initialise cp model
solve time milliseconds first solution
total build solve
nodes number nodes search tree
mem model memory mb
table dnl means model could loaded large dnf
means could solved within mins succeeded loading
provided memory usage onetree however smaller
constraint encodings
obvious thing note much faster imperative compared
constraint techniques primarily due lower complexity
onetree absence fans investigated benefit
partly due generality constraint programming imperative
highly specialised one class whereas constraint
sits within toolkit runs top general purpose constraint maintenance system
expect constraint compete raw speed
later demonstrate section benefits versatility e
later section use soft breakup
alternative constraint model tree might use variables corresponding potential edges
within adjacency matrix prosser unsworth indeed cp graph computation domain
dooms



fimoore prosser

costs space time repaid ease accommodating variants
model
data
ab

n


sol


ac



f

ad





ae



f

af





ag





bc



f

bd









f

bf





bg





cd





ce





cf





cg



f

technique
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon

build



solve















dnl


dnl


























dnl


dnl




















dnl


dnl
















total












dnl



















dnl















dnl











nodes



mem















dnl





























dnl























dnl

















fithe ultrametric constraint phylogenetics

de



f

df





dg



f

ef



f

eg



f

fg



f

abdf





abdg



f

acdf



f

acdg



f

ace



f

onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
treecon
onetree
toolkit
cpbuild
onetree

dnl


dnl














dnl


dnl


dnl


dnl





dnl











dnf








dnl


dnl


dnl


dnl



dnl











dnl



dnl



dnl







dnf







dnl



dnl



dnl

















dnl





dnl





dnl











dnf











dnl





dnl





impressive aspect matrix model section section
improvement memory requirements instances loaded comfortably dramatic impact build time improvements dominate
reduction solve time practice toolkit model outperformed cpbuild
order magnitude instance moreover two cases search occurring
toolkit model data sets bc abdg whereas cpbuild never search
polynomial time complexity due provable absence search
compare well beldiceanu et al one
case cpbuild order magnitude slower treecon far
explanation four cases treecon significantly worse
cpbuild available treecon data set ace
noted beldiceanu et al yet complete filtering
constraint model personal communication although treecon


fimoore prosser

figure supertree largest compatible data sets birds abdf took ms
model ms solve cpbuild

model never backtracked birds data set yet proof complexity
model polynomial noted see cpbuild taking time
unsolvable instances solvable instances predicted
figure shows supertree displayed treeview page produced
largest compatible forest b f supertree leaves takes
second produce although printed table finding forest
b c e f g incompatible takes seconds total seconds build
model seconds determine incompatibility


fithe ultrametric constraint phylogenetics

versatility constraint model
one strengths constraint programming versatility given constraint model
core model enhanced address variants original pure
demonstrate versatility respect ultrametric model presenting
four variants supertree incorporating ancestral divergence dates
model b nested taxa c determining induced triple fan common
supertrees coping incompatibilities
ancestral divergence dates
semple et al bryant et al add temporal information input trees
interior nodes may labelled integer ranks interior node v proper
descendant v rank v rank v resulting ranked phylogenetic tree additionally relative divergence dates may expressed form div c predates div b
interpreted divergence species c predates species b
rankedtree bryant et al takes input collection precedence
constraints derived input ranked species trees predates relations
outputs ranked tree respects relations returns compatible
trivial incorporate constraint model trees ranked
pair species j leaf set instantiate constrained integer variable
mij value mrca j predates relation div c predates div b post
constraint mcd mab done step cpbuild figure e ranks
predates relations become side constraints similarly time bounds speciation events
posted unary constraints e dated phylogenetic tree upper lower divergence
bounds given interior nodes l b u b give respectively lower
upper bounds divergence dates species b constraint program
following two side constraints posted step l b mab
mab u b
demonstration ranked trees given figure left two ranked
species trees cats used recently semple et al originally janczewski
modi stephens obrien branch lengths source trees
translated rankings added interior vertices trees right
one possible resultant supertrees total solutions contain
interior nodes ranges interior nodes labelled specific values rather
ranges solutions produced structurally identical goes
way addressing issue enumerating supertrees compactly raised
challenge semple et al figure effect adding predates
constraint supertree construction data previously used bryant et al
figures
nested taxa
taxon plural taxa group organisms comprising single common ancestor
descendents dawkins wong example species lion class birds
taxa far species trees leaf labelled however restrictive


fimoore prosser

figure two ranked trees cats right one possible supertrees produced
cpbuild displayed treeview

figure two input trees c x b x resultant supertree shown
rd position tree far right supertree
side constraint div c predates div b produced cpbuild
displayed treeview



fithe ultrametric constraint phylogenetics

p

p

q

q

p

q



b

c



e

g

b

f



e



g

b

c

f



e

figure two input rooted x trees left output tree right
perfectly displays

trees may annotated taxa names leaves internal nodes giving
nested taxa example figure shows tree internal node labelled p
descendents b e b taxa nested within p taxon
related creating compatible supertrees type data raised page
defined solved daniel semple set input trees possible
solution shown figure notice labels conserved
solution ancestral relationships conserved labels li lj
input tree li ancestor lj input tree li ancestor lj solution
tree instance higher taxa compatibility defined daniel
semple semple et al tree must perfectly display
input trees define formally
definition rooted x tree daniel semple species tree internal
nodes well leaves may labelled set x
following slightly loose may use label l identify labelled node
well label e g descendants l means descendants
node labelled l
definition rooted x tree perfectly displays rooted x tree
x x
displays neglecting internal labels
descendant b descendant b
descendant b descendant b
rooted x tree perfectly displays forest phylogenetic trees f tn
perfectly displays every ti
constraint encoding
constraint encoding implemented addition variables side constraints
standard model section describe transform input make
constraint solution simpler describe variables constraints needed


fimoore prosser







p

q

p

q

q


b

c



e

f

p

e

g

f



b

c

e

g

f

figure two input trees enclosing taxon p process substitution replaced

substitution taxon p figure appears internal node call
label enclosing taxon note appears leaf input trees
preprocessed replace tree enclosing taxon p leaf tree
single subtree rooted p substituted place must subtree
elsewhere input forest contradiction enclosing taxon
process add remove information since relationships
everything tree still holds relationships taxa subtree
rest tree implicit input
aim process obtain set inputs enclosing taxa appear
internal nodes without loss generality constraint encoding assumes
case figure shows example substitution process applied
trees would replaced
variables constraints variables added one integer variable vl per enclosing
taxa label l domain n value variable solution
tree depth internal node labels labels position final
tree determined must unique node depth path one
nested taxa root see figure suppose sake argument
enclosing taxa labels b variable lm solution
unique location label go root node
properties definition immediate properties
earlier model foundation one explaining enforce
property introduce notations convenience function desc l f returns
set descendants label l tree forest f notdesc l returns
set labels descendants l tree
first need constraint l must label every single species labels input
every enclosing label l post following set constraints
vl mij desc l f j desc l f j



label must settle least shallow mrca descendants input
hence must remain descendants notice necessary consider pairs species
distinct input trees alternative taking pairs tree work
necessary pairs internal node l rather two


fithe ultrametric constraint phylogenetics

distinct nodes happen correct depth next label must constrained
label already descendant becomes one x tree
enclosing label l x post following set constraints
vl mij desc l j notdesc l



label l must placed strictly deeper mrca descendant
something thats descendant e non descendents l descendent
illustration list generated constraints example figure
equation l p vp mab vp mag vp mbg
equation l q vq mde vq mdf vq mef
equation l p vp mac vp mad vp mae vp
mbc vp mbd vp mbe vp mgf vp mgd vp mge vp mbf
equation l q vq mad vq mae vq mbd vq
mbe vp mcd vq mce vq mgf vp mbf vp mgd vp mge
number constraints created equations bounded
number distinct pairs species e n constraints
necessity
may many possible supertrees given input forest one question
relationships common supertrees determining derived
induced triple fan supertree necessary e common possible supertrees
introduced daniel along polynomial time decision procedure necessity
necessity figure takes arguments forest f trees assumed
compatible rooted triple fan determines occurs every supertree
displays trees f simple modification cpbuild
lines essentially line negation triple posted
posted
mik mjk mij mik mij mik



ij k posted
mij mik mij mjk mik mjk



ijk call made propagate make arc consistent line
fails necessary otherwise necessary
complexity cpbuild
coping conflict
supertree cannot produced pair trees input triples fans
must conflict one another directly indirectly junkers quickxplain
method junker discovers minimal subset constraints posted
propagated failure set necessarily smallest possible set


fimoore prosser

necessity
necessity f
let v c cpmodel f
f

breakup c post c
c post c
return propagate v c

figure triple fan occur every supertree displays trees f
minimal sense removal element set constitute
sound explanation addition constraint would redundant set
constraints input triples fans minimal set semantically collection input
data incompatible junker state method achieved worst
case k log n k k propagations k size minimal explanation
found n number constraints
alternative satisfy many input triples fans possible
within reasonable amount time e polynomial time semple steel propose
mincutsupertree refined page
propose similar scheme within constraint programming framework call
greedybuild works follows associate constrained integer
variable x domain triple fan variable assigned
value triple fan respected otherwise ignored therefore triple
ij k post constraint equation fan ijk constraint equation


x mij mik mjk x mik mjk mij mik mij mik



x mij mik mjk x mij mik mij mjk mik mjk



greedybuild instantiates turn x variables e decision variables
preferring value value instantiation made arcconsistent shown figure line constraint model produced
e n n symmetric array constrained integers variables created n
unique species forest um matrix bcz constraint posted
variables variable x line set decision variables input trees
broken variable x created triple fan line
constraints equations posted model loop lines
turn select decision variable set lowest possible value make
arc consistent might turn cause uninstantiated variables
value removed domain associated triple fan conflicts triple
bc z propagator however time complexity number
propagations



fithe ultrametric constraint phylogenetics

greedybuild
greedybuild f

let v c cpmodel f

let x

f

breakup

let x newv ar

let c newconstraint x x

x x x

v v x

c post c c
x x

instantiate x

propagate v c
return umtotree v

figure greedily build supertree forest f ultrametric constraint model

fan enforced process terminates without failure
conflicting triples fans essentially ignored line ultrametric matrix
converted tree complexity greedybuild f n
triples f fans
greedybuild applied forest bird data b c e f g section soft breakup data incompatible use cpbuild however
greedybuild produces supertree figure supertree contains species
softbreakup produced triples rejected took less
seconds build model seconds solve model
compared cpbuild data set taking seconds build model
seconds determine incompatibility greedybuild applied data set
abdf producing identical supertree cpbuild comparable time ms build
model ms solve
executed greedybuild decision variables set x lines
analysed identify set triples fans excluded
supertree e x variable instantiated value corresponding
triple fan ignored
note claim biological significance arbitrary order use
suppress triples greedybuild could amended follow order mincutsupertree investigated greedybuild enhanced
follows currently triple fan exists multiple input trees occurs
constraint information could exploited weighting decision variables
take consideration relative weight evidence triple fan e g number
times triple fan occurs input decision variables instantiated
non increasing order weight e variable ordering heuristic used
extreme greedybuild modified become optbuild full backtracking
search performed objective minimising sum decision variables


fimoore prosser

figure supertree largest data set birds abcdefg species
took seconds model seconds solve greedybuild
displayed rod treeview



fithe ultrametric constraint phylogenetics

potentially exponential cost time would return tree fewest possible
input triples suppressed
summary
little effort constraint model adapted deal ancestral divergence
dates nested taxa achieved adding side constraints
added advantage respect ancestral divergence compact
enumeration output trees interior nodes labelled ranges rather specific
values
input trees conflict propose two options use quickxplain determine
cause conflict greedily build supertree greedybuild bryant et al
state essentially nothing supertree construction
rankedtree needed something akin mincutsupertree e
trees incompatible build supertree violates minimum number triples
fans polynomial time page semple steel since
done bordewich et al done constraint model
incorporating constraints identified section greedybuild
although shown obvious ancestral divergence data nested taxa
combined one model simply adding necessary constraint auxiliary
variables variants one model could done greedybuild
would require heuristic rule used deciding constraints ignore
input trees side constraints incompatible
opinion deriving combining analysing imperative
supertree much difficult variants
required far complex data structures tailored processing
moreover combine produced seems practically impossible account
intricacy finally constraint programming provides generic methods
quickxplain box turn interest supertree

conclusion
presented constraint propagator ultrametric constraint three
integer variables shown extended symmetric matrix constrained
integer variables bounds z consistency established symmetric array
lower bounds variables give mutual support sufficient modelling solving
supertree construction n time n space comparable complexity onetree ng wormald inferior bryant
steel bother cpbuild efficient imperative
approaches already exist answer lies versatility constraint programming
rather develop variant supertree add
side constraints base model shown polynomial time bound
often achieved done ancestral divergence dates nested taxa
shown model used deliver necessary triples fans
proposed greedybuild way dealing incompatible trees


fimoore prosser

acknowledgments
would thank pierre flener xavier lorca barbara smith ian gent christine wei wu charles semple mike steel rod page muffy calder joe sventek
stanislav zivny chris unsworth three anonymous reviewers co authors

references
aho sagiv szymanski ullman j inferring tree lowest
common ancestors application optimization relational expressions
siam j comput
beldiceanu n flener p lorca x combining tree partitioning precedence
incompatibility constraints constraints
bessiere c regin j c refining basic constraint propagation
ijcai pp
bessiere c constraint propagation handbook constraint programming elsevier chapter
bininda emonds phylogenetic supertrees combining information reveal
tree life springer
bordewich evans g semple c extending limits supertree methods
annals combinatorics
bryant steel extension operations sets leaf labeled trees advances applied mathematics
bryant semple c steel supertree methods ancestral divergence
dates applications bininda emonds ed phylogenetic supertrees
combining information reveal tree life pp computational biology
series kluwer
carlier j pinson e adjustment heads tails jobshop scheduling
european journal operational
caseau laburthe f solving small tsps constraints proceedings
international conference logic programming pp
choco http www choco constraints net home choco constraint programming system
daniel p supertree methods approaches masters thesis department
mathematics statistics university canterbury
daniel p semple c supertree nested taxa bininda emonds
ed phylogenetic supertrees combining information reveal tree life
pp computational biology series kluwer


fithe ultrametric constraint phylogenetics

dawkins r wong ancestors tale weidenfeld nicholson
debruyne r bessiere c practicable filtering techniques constraint
satisfaction proceedings ijcai pp
dooms g cp graph computation domain constraint programming
ph thesis universite catholique de louvain faculte des sciences appliquees
gent prosser p smith b wei w supertree construction constraint
programming principles practice constraint programming pp
springer
gusfield strings trees sequences computer science
computational biology cambridge university press york ny usa
janczewski modi w stephens j obrien molecular evolution
mitochondrial rna cytochrome b sequences pantherine lineage
felidae mol biol evol
jeavons p g cooper c tractable constraints ordered domains artif
intell
junker u quickxplain preferred explanations relaxations overconstrained proceedings aaai pp
kennedy page r seabird supertrees combining partial estimates procellariiform phylogeny auk
lhomme efficient filtering disjunction constraints
principles practice constraint programming pp springer
mace g gittleman j l purvis preserving tree life science

mackworth consistency networks relations artificial intelligence

ng p wormald n c reconstruction rooted trees subtrees discrete
appl math
page r treeview application display phylogenetic trees personal
computers computer applications biosciences
page r taxonomy supertrees tree life bininda emonds ed
phylogenetic supertrees combining information reveal tree life pp
computational biology series kluwer
page r modified mincut supertrees wabi proceedings second
international workshop bioinformatics pp london uk
springer verlag


fimoore prosser

pennisi e modernizing tree life science
prosser p supertree construction constraint programming recent progress
challenges wcb workshop constraint methods bioinformatics pp
prosser p unsworth c rooted tree spanning tree constraints th
ecai workshop modelling solving constraints
regin j c filtering constraints difference csps proceedings aaai pp
rossi f van beek p walsh handbook constraint programming elsevier
sabin freuder e contradicting conventional wisdom constraint satisfaction proceedings ecai pp
schulte c carlsson finite domain constraint programming systems
handbook constraint programming elsevier chapter
semple c daniel p hordijk w page r steel supertree
ancestral divergence dates nested taxa bioinformatics
semple c steel supertree method rooted trees discrete appl math

smith b tutorial constraint programming technical report
university leeds
treebase http www treebase org treebase database phylogenetic knowledge
tsang e foundations constraint satisfaction academic press
van hentenryck p deville teng c generic arc consistency
specializations artificial intelligence
van hentenryck p saraswat v deville design implementation
evaluation constraint language cc fd journal logic programming

wu g j h lin g quartet phylogeny reconstruction answer
set programming ieee acm transactions computational biology bioinformatics
yuanlin z yap r h c making ac optimal ijcai pp





