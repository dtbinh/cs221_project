Journal Artificial Intelligence Research 32 (2008) 901-938

Submitted 08/07; published 08/08

Ultrametric Constraint
Application Phylogenetics
Neil C.A. Moore

ncam@cs.st-andrews.ac.uk

Computer Science, University St. Andrews, Scotland

Patrick Prosser

pat@dcs.gla.ac.uk

Computing Science, Glasgow University, Scotland

Abstract
phylogenetic tree shows evolutionary relationships among species. Internal nodes
tree represent speciation events leaf nodes correspond species. goal
phylogenetics combine trees larger trees, called supertrees, whilst respecting
relationships original trees. rooted tree exhibits ultrametric property;
is, three leaves tree must one pair deeper recent common
ancestor pairs, three recent common ancestor.
inspires constraint programming encoding rooted trees. present efficient
constraint enforces ultrametric property symmetric array constrained
integer variables, inevitable property lower bounds three variables
mutually supportive. show allows efficient constraint-based solution
supertree construction problem. demonstrate versatility constraint
programming exploited allow solutions variants supertree construction
problem.

1. Introduction
One grand challenges phylogenetics build Tree Life (ToL), representation evolutionary history every living thing. date, biologists catalogued
1.7 million species, yet estimates total number species range 4 100
million. 1.7 million species identified 80,000 placed ToL
far (Pennisi, 2003). applications ToL: help understand pathogens
become virulent time, new diseases emerge, recognise species risk
extinction (Pennisi, 2003; Mace, Gittleman, & Purvis, 2003). One approach building
ToL divide conquer: combining smaller trees available TreeBase
(TreeBASE, 2003) so-called supertrees (Bininda-Emonds, 2004) approach
complete ToL.
date, supertree construction dominated imperative techniques (Semple
& Steel, 2000; Semple, Daniel, Hordijk, Page, & Steel, 2004; Daniel, 2003; Bordewich,
Evans, & Semple, 2006; Ng & Wormald, 1996; Bryant & Steel, 1995; Page, 2002)
recently new declarative approaches emerged using constraint programming (Gent,
Prosser, Smith, & Wei, 2003; Prosser, 2006; Beldiceanu, Flener, & Lorca, 2008) answer
set programming (Wu, You, & Lin, 2007). One properties rooted trees suits
approaches trees nature ultrametric: rooted trees root node
depth 0, depth nodes 1 plus depth parent. Taking
c
2008
AI Access Foundation. rights reserved.

fiMoore & Prosser

three leaves a, b c pairs must one pair deeper recent common
ancestor (mrca) pairs, three pairs mrca.
mean ultrametric, three tie minimum. fact,
know depth mrca pairs leaves structure tree uniquely
determined. inspires constraint programming encoding rooted trees, using
ultrametric constraint define later. explore solutions phylogenetic
supertree problem variants. doing, show practicality ultrametric
encoding rooted tree problems, well arguing valuable addition
set techniques supertree problems.
paper organised follows. First, introduce constraint programming
supertree construction problem. propose specialised ultrametric constraint,
terms propagation procedures, maintains bounds(Z)-consistency (Bessiere, 2006)
three variables. show specialised constraint required models
use toolkit primitives cannot guarantee ultrametric property supertree problem via propagation alone. Furthermore, space complexity models becomes
prohibitive. ultrametric constraint extended maintain property
symmetric matrix variables. go show constraint efficiently
applied problem supertree construction, particular applying propagation
model gives polynomial time procedure supertree construction. demonstrate real data give justification improvement time
space previous constraint encodings. One benefits constraint programming approach variants supertree problem addressed within
one model. justify assertion proposing constraint solution finding essential
relations supertree (Daniel, 2003), addressing ancestral divergence dates (Semple
et al., 2004; Bryant, Semple, & Steel, 2004), modelling nested taxa (Page, 2004; Daniel &
Semple, 2004) coping conflicting data.

2. Background
section give necessary definitions descriptions Constraint Satisfaction
Problem (Tsang, 1993), Constraint Programming, Supertree problem.
2.1 Constraint Programming CSP
Constraint Programming (CP) (Rossi, van Beek, & Walsh, 2007) declarative style
programming problems modelled CSP, i.e., set variables
assigned values variables domains satisfy set constraints. Values
might typically integers drawn finite domains, real numbers ranges,
complex entities sets graphs. considering integers.
Definition 1. constraint satisfaction problem (CSP) triple (V, D, C) V set
n variables {v1 , . . . , vn }; = {dom(v1 ), . . . , dom(vn )} collection domains,
totally ordered set integer values; C = {c1 , . . . , ce } set e constraints,
scope variables scope(c) = (vc1 , . . . , vck ) relation rel(c) dom(vc1 ). . .dom(vck ).
assignment value x dom(v) variable vi V denoted (vi , x). constraint
c C satisfied assignment {(vc1 , xc1 ), . . . , (vck , xck )} scope(c) = (vc1 , . . . , vck )
902

fiThe Ultrametric Constraint Phylogenetics

(xc1 , . . . , xck ) rel(c). set assignments {(v1 , x1 ), . . . , (vn , xn )} involving every
variable problem solution satisfies constraints C.
constraint solver finds solution CSP via process constraint propagation
search. Constraint propagation inferencing process takes place variable
initialised loses values. Propagation maintains level consistency, arcconsistency (Mackworth, 1977), across variables, removing values domains
cannot occur solution (i.e., removing unsupported values). use definitions
(generalized) arc-consistency ((G)AC) due Bessiere (2006):
Definition 2. Given CSP (V, D, C), constraint c C scope(c) = (vc1 , . . . , vck ),
variable v scope(c), value x dom(v) consistent respect c (alternatively,
supported c) iff exists satisfying assignment = {(vc1 , a1 ), . . . , (vck , ak )} c
(v, x) i, ai dom(vci ). domain dom(v) (generalized) arcconsistent c iff values dom(v) consistent respect c, CSP
(generalized) arc-consistent variable domains (generalized) arc-consistent
constraints C.
Arc-consistency established CSP using algorithm AC3 (Mackworth, 1977). sake exposition assume constraints C binary
constraint c counterpart c scope(c) = (va , vb )
scope(c ) = (vb , va ) rel(c ) = rel1 (c). example, constraint
cxy = x < constraint cyx = > x. heart AC3 revise
function, takes binary constraint c argument delivers Boolean result.
function removes dom(va ) values support dom(vb ) w.r.t.
constraint c, returns true removals take place. Initially constraints added
set S. Constraints iteratively removed revised. revise(ckm ) returns
true becomes {cik |cik C 6= k 6= m}. step considered
propagation domain reduction variable vk variables constrained vk .
iteration terminates empty variables domain becomes empty.
empty arc-consistency algorithm reached fixed point (i.e., application
arc-consistency process effect domains variables)
problem made arc-consistent. domain empties, shown
solutions globally hence stop. AC3 algorithm O(e d3 ) time
complexity, e number constraints size largest domain, however algorithms achieve time bound O(e d2 ) (Yuanlin & Yap, 2001; Bessiere
& Regin, 2001).
demonstrate arc-consistency example Figure 1 Smith (1995).
three constrained integer variables x, z, integer domain {1..5},
binary constraints cxy : x < 2, cyz : + z even, czx : z < 2x + 1. Since
constraints binary represent problem constraint graph, nodes
vertices edges constraints. Initially constraint cxy revised respect x
values {3..5} removed dom(x). cxy revised w.r.t. dom(y)
becomes {4, 5}. cyz revised w.r.t. effect revised w.r.t. z,
effect. Revising czx w.r.t. z reduces dom(z) becomes {1..4}, consequently
constraint cyz added set constraints pending revision. Constraint czx
903

fiMoore & Prosser

{1..5}

se



zi

2

y+
n

x<



x
{1..5}

z {1..5}

z < 2x + 1

Figure 1: binary constraint satisfaction problem.
import choco.Problem;
import choco.ContradictionException;
import choco.integer.*;
public class BMStut {
public static void main(String[] args) throws ContradictionException {
Problem pb
= new Problem();
IntDomainVar x
= pb.makeEnumIntVar("x",1,5); // x {1..5}
IntDomainVar
= pb.makeEnumIntVar("y",1,5); // {1..5}
IntDomainVar z
= pb.makeEnumIntVar("z",1,5); // {1..5}
IntDomainVar even = pb.makeEnumIntVar("even",new int[] {2,4,6,8,10});
pb.post(pb.gt(pb.minus(y,2),x));
// x < - 2
pb.post(pb.gt(pb.plus(pb.mult(2,x),1),z)); // z < 2x + 1
pb.post(pb.eq(even,pb.plus(y,z)));
// + z even
pb.solve();

// solve using MAC

}
}

Figure 2: JChoco constraint program CSP Figure 1.
revised w.r.t. x cyz w.r.t. y, effect. revision set point
empty arc-consistency established variable domains dom(x) = {1, 2},
dom(y) = {4, 5}, dom(z) = {1..4}.
Solving CSP may involve search, i.e., might need try different values variables order determine solution exists. Typically constraint solver begin
establishing arc-consistency, repeatedly select variable assign value
domain (instantiate it). effectively reduces variables domain singleton,
arc-consistency re-established. succeeds another instantiation made,
fails backtrack undoing recent instantiation. called MAC,
maintaining arc-consistency (Sabin & Freuder, 1994).
Figure 2 shows constraint program problem Figure 1 using choco constraint programming toolkit Java language (Choco, 2008), finds solution
x = 1, = 4, z = 2 first.
Constraint toolkits tend based around AC5 algorithm (van Hentenryck, Deville,
& Teng, 1992), allowing propagators specialised specific constraints resulting
improved efficiency adaptability. AC5 amends set AC3 contain triples
form (v, c, ) v scope(c) set values lost v, consequently
904

fiThe Ultrametric Constraint Phylogenetics

revision efficient propagation focus values may lost support,
rather check every value support. object-oriented toolkit language
constraint associated propagation methods implemented,
methods activated domain event occurs variable involved constraint.
Domain events initialisation variable, increase lower bound,
decrease upper bound, removal value bounds, instantiation
variable. exhaustive list, however toolkits allow one event:
one values lost propagator writer must determine
action take. give examples using toolkit specialised constraints,
modelling routing problem might constrained integer variable location
visited, domain values corresponding index next destination (the
so-called single-successor model). subtour elimination constraint (Caseau & Laburthe,
1997) might used ensure legal tours produced, Regins alldifferent constraint (Regin, 1994) could added increase domain filtering. pick
delivery variant, side constraints could added ensure locations
visited others. job shop scheduling problem might model uses
0/1 variables decide relative order pairs activities share resource,
might increase propagation adding Carlier Pinsons edge finding constraint (1994).
constraint programming approach general practical modelling solving
problems, provides framework combination problem specific algorithms
one solver. allows us solve many classes problems efficiently model even
problems via addition side constraints.
2.2 Supertree Problem
Supertree construction problem phylogenetics combine leaf-labelled
species trees, sets leaf labels intersect, single tree respects
arboreal relationships input tree (Bininda-Emonds, 2004). Species trees describe
part evolutionary history set species. Labels leaves correspond existing
species internal nodes represent divergence events evolutionary history one
species split least two species. Species trees may annotated dates
internal nodes, representing time divergence event happened.
define term displays, makes precise mean respects
arboreal relationships: supertree T1 displays tree T2 T2 equivalent T4
(i.e. induce hierarchy leaf labels) T4 obtained following
steps (Semple & Steel, 2000):
1. Let L set leaves T1 T2 .
2. Let T3 unique subtree T1 connects leaves L.
3. obtain T4 : wherever subpath (p1 , . . . , pk ) path root
leaf T3 p2 , . . . , pk1 interior nodes degree 2, contract
single edge.
problem produce rooted species tree forest input trees F,
contains species F displays every tree F . Figures 3 4 illustrate
displays property.
905

fiMoore & Prosser

1
0

T1

1
0

1
0

T3

1
0

b

c



1
0









e

1 0
0
1



2

0
1
1
0
1 0
0
1 0
1

1
0

e

0
1
1
0
1 0
0
1 0
1



=
4
2

1
0

1
0

1 0
0
1 0
1 0
1 0
1



1
0

L={a,d,e}



e

e

Figure 3: example tree T1 displays tree T2

1
0

T1

1
0

L={a,d,e}

1
0

1
0

1 0
0
1 0
1 0
1 0
1





c

b

e

T4 = 2

1
0

1
0
0
1
1 0
0
1 0
1



1 0
0
1


T2

1
0

T3

1
0





e

1
0

e

0
1
1
0
1 0
0
1 0
1





e

Figure 4: example tree T1 display tree T2

906

fiThe Ultrametric Constraint Phylogenetics

say two trees T1 T2 compatible (incompatible) exists (doesnt
exist) third tree T3 displays T1 T2 . Variants supertree problem
previously published solved specialist bioinformatics literature include
finding solutions1 , counting solutions, finding conserved relationships supertrees
(Daniel, 2003), incorporating nested taxa (Semple et al., 2004), incorporating ancestral divergence dates (Semple et al., 2004) possibility contradictory input data (Semple
& Steel, 2000).

3. Ultrametric Constraint
ultrametric constraint first proposed Gent et al. (2003) within context
supertree construction (Bininda-Emonds, 2004), implemented using toolkit primitives. review encoding show constraint toolkits inefficient
terms space time. motivates creation specialised ultrametric
propagator three variables, maintains ultrametric property bounds
variables. presented describing necessary propagation methods.
extend specialised propagator maintains ultrametric property
symmetric matrix variables.
3.1 Previous Work Ultrametric Constraint
First, give definition ultrametric constraint.
Definition 3. ultrametric constraint three variables (henceforth, Um-3) x, z
constrains that:
(x > = z) (y > x = z) (z > x = y) (x = = z)

(1)

constraint ensures tie least element three, i.e., either
three same, two greater. constraint
proposed Gent et al. (2003), used Prosser (2006) times implemented
literal translation Equation 1 using toolkit primitives. Evidence obtained
JChoco, ECLiPSe ILog constraint programming toolkits shows propagation
done lower bounds combination primitive constraints. due disjunctive constraints since many constraint programming toolkits propagation delayed
one disjuncts true, known delayed-disjunction consistency
(van Hentenryck, Saraswat, & Deville, 1998). Consequently, encoding values
cannot occur satisfying assignment might pruned domain
variable. Consider case three variables: x {1, 2, 3}, {2, 3} z {3}.
domains variables already fixed point respect delayed-disjunction
consistency ultrametric assignment x takes value 1, i.e., delayeddisjunction propagation achieve arc-consistency. shall see later, finding
solution supertree problem using toolkit constraints result backtracking
search, prefer avoid this. course, higher levels consistency would overcome
this, constructive-disjunction consistency (van Hentenryck et al., 1998), singleton
1. may multiple supertrees set input trees.

907

fiMoore & Prosser

arc-consistency (Debruyne & Bessiere, 1997) filtering algorithm Lhomme (2003).
However, cost greater average case delayed-disjunction, preventing use toolkits. fact Um-3 constraint especially unfortunate
lower bounds may trimmed properly:
Lemma 1. Um-3 constraint, lower bounds supported (i.e., form ultrametric instantiation values constrained variables), support other.
Proof. Consider three supported lower bounds. Suppose contradiction two
least distinct. One distinct lowest cannot supported
account fact equal anything larger anything. Therefore
contradiction two least must equal. However lower bound least
large these, lower bounds mutually supportive.
Lemma important implications species tree model presented
detail Section 4: particular, lower bounds bounds(Z)-consistency model
form solution, bounds(Z)-consistency (Bessiere, 2006) defined follows
Definition 4. Given (V, D, C) constraint c C scope(c) = (vc1 , . . . , vck ), tuple
= (xc1 , . . . , xck ) bound support rel(c) xci , min(dom(vci ))
xci max(dom(vci )). constraint c bounds(Z)-consistent vci scope(c)
exist bound supports involving min(dom(vci )) max(dom(vci )). CSP bounds(Z)consistent every constraint c C bounds(Z)-consistent.
henceforth abbreviate bound support support bounds(Z)-consistency
BC(Z). BC(Z) differs AC puts weaker conditions values comprise
support: rather domain, need
lower upper bounds domain. means BC(Z) prunes subset
values AC can, general. Weaker levels consistency BC(Z) useful
certain problems prune number values AC easily,
fewer values much quickly. case, BC(Z) interesting level
consistency enough ensure problem solved propagation
search, shall see.
3.2 Design BC(Z) UM-3 Propagator
Section describe Um-3 propagator enforces BC(Z), namely UM-3-BCZ.
3.2.1 Analysis Lower Upper Bounds
section dont take account domains becoming empty. Since analyse lower
upper bounds isolation lower bound may pass upper bound vice-versa,
thereby emptying domain. happens propagator described Section 3.2.2
enforce BC(Z), rather terminate. problem, domain
becoming empty means solution continue would waste time.
Concordantly, section, analyse lower bounds assume upper
bound domain cannot become null reason, vice-versa.
908

fiThe Ultrametric Constraint Phylogenetics

Code style: Variables v1 , v2 , v3 , S, L constrained integer variables, synonymous domains. Consequently variable x considered domain x.lb
x.ub return references lower upper bounds respectively; SortOnLowerBounds(x,y,z)
returns tuple references variables x, z non-decreasing order lower bounds;
SortOnUpperBounds analogous; let (S,M ,L) . . . names references S, L;
result S.lb .lb, lower bound assigned equal value lower bound ,
although .lb subsequently changes distinct again; expression x b returns
intersection domains [max(x.lb,y.lb) . . . min(x.up,y.up)].

Algorithm UM-3-BCZ
LBFix(v1 ,v2 ,v3 )
A1
let (S, M, L) SortOnLowerBounds(v1 , v2 , v3 )
A2
(S.lb < .lb)
A2.1
S.lb .lb
UBFix(v1 ,v2 ,v3 )
A3
let (S, M, L) SortOnUpperBounds(v1 , v2 , v3 )
A4
(S.ub < .ub)
A4.1
(S b L = )
A4.2
.ub S.ub
A4.3
else (S b = )
A4.4
L.ub S.ub
Min event(v1 ,v2 ,v3 )
A5
LBFix(v1 ,v2 ,v3 )
A6
domains non-empty
A6.1
UBFix(v1 ,v2 ,v3 )
Max event(v1 ,v2 ,v3 )
A7
UBFix(v1 ,v2 ,v3 )
Fix event(v1 ,v2 ,v3 )
A8
LBFix(v1 ,v2 ,v3 )
A9
domains non-empty
A9.1
UBFix(v1 ,v2 ,v3 )

Figure 5: Algorithm UM-3-BCZ propagator

909

fiMoore & Prosser

(1)

(2)
l



(3)

(4)
l
s=m

s=m=l

m=l


Figure 6: Cases analysis LBFix

L
(1)

l



L
(3)

(2)



(4)

Figure 7: Cases analysis UBFix
procedure LBFix Figure 5 takes input three variables removes unsupported values lower bounds domain. intuition algorithm achieving
one needs involved tie least element, hence smallest
lower bound strictly less others must unsupported.
possible states lower bounds LBFix invoked summarised Figure 6.
Either three different (case 1), three (case 2) two
one different (cases 3 4). give relationships bounds point time
lower bound may unsupported. boxes Figure 6 shaded follows:
regions shaded black removed propagation whereas gray regions supported.
diagrams supposed suggest that, example case 1, bounds differ
1. Rather two bounds lined bound one
different another different non-zero unspecified amount. Hence
describe relationships actual values.
following shows LBFix removes unsupported values remove
supported values.
Lemma 2. LBFix invoked lower bounds argument variables supported
w.r.t. Um-3 constraint supported values removed.
Proof. cases 1 4 (Figure 6) condition line A2 satisfied, line A2.1
executed, results removal unsupported range inspection
remaining bounds mutually supportive. cases 2 3, condition line A2
failed changes made domains; bounds mutually supportive.
procedure UBFix Figure 5 job upper bounds LBFix
lower bounds. following Lemma justifies assertion cases used
proof shown Figure 7:
Lemma 3. UBFix invoked either
910

fiThe Ultrametric Constraint Phylogenetics

upper bounds argument variables supported w.r.t. UM-3-BCZ constraint supported values removed,
domain null result removing unsupported values.

Proof. Let S, L domains smallest, middle largest upper bounds,
breaking ties arbitrarily. Let s, l upper bounds.
First prove case 1 (Figure 7) shaded region supported
L b 6= : Potentially, bound supported
equal values L least small (i.e., b L 6= ),
equal value either L, value least large remaining domain.
However, notice latter impossible due fact L contains equal
value, value large this.
Similar arguments establish shaded regions L case 1, case 3
L case 3 supported b 6= , L b 6= b 6= , respectively.
establish Lemma cases 1, 2, 3 4:
Cases 2 4 condition line A4 false, domains changed.
upper bounds mutually supportive case.
Case 1 shaded region unsupported L b = . Hence
UBFix line A4.2 executed unsupported region removed. upper
bounds l L, mutually supportive.
Case 1 shaded region supported Lb 6= . shaded
region L supported b 6= neither line A4.2 A4.4 executed
changes made domains. upper bound supported,
L, S. shaded region L supported b =
line A4.4 executed resulting removal region. new bounds S,
L mutually supportive.
Case 3 shaded regions L supported above, L b 6=
b 6= . Hence domain changes result executing UBFix. l L
supported l L, S. supported L, S.
Case 3 shaded regions L unsupported above, L b =
b = line A4.2 UBFix executed results becoming null.
Case 3, shaded region supported shaded region L supported
Lb 6= b = , A4.4 executed remove unsupported
region. new bounds S, L mutually supportive.
Case 3, shaded region L supported shaded region supported
Symmetric previous case.

Note analog Lemma 1 upper bounds since, example, bounds
x = {1, 2, 3}, = {1, 2} z = {1} supported, mutually supportive.
911

fiMoore & Prosser

3.2.2 Propagation Algorithm
presented LBFix UBFix position present complete propagation algorithm. propagator works arbitrary domains enforces BC(Z),
except domain becomes empty, case work. algorithm
described action taken three domain events occur:
min domain lost lower bound since propagator last invoked.
max domain lost upper bound since propagator last invoked.
fix domain singleton, i.e., variable instantiated upper lower bounds
equal.
i.e. consider events bounds variables. algorithm listed lines
A5-A9 Figure 5. Intuitively procedures work because, show, change
upper bound affect support upper bounds, change lower
bound affect support lower upper bounds. Hence need run
LBFix lower bound may changed, UBFix must run change either
lower upper bounds. Whilst would correct cycle trimming upper
lower bounds fixed point reached (i.e. changes occur), guarantee
fixed point easily.
Lemma 4. possible change lower bound result loss support
another lower bound.
Proof. bounds diagram support, black shaded lower
bound lost dark gray shaded lower bound loses support.

Lemma 5. possible change lower bound result loss support
upper bound.
Proof. bounds diagram support, black shaded lower
bound lost dark gray shaded upper bound loses support.

Lemma 6. possible loss upper bound cause loss support
another upper bound.
912

fiThe Ultrametric Constraint Phylogenetics

Proof. bounds diagram support, black shaded upper
bound lost dark gray shaded upper bound loses support.

Corollary 1. impossible change upper bound result loss support
lower bound.
Proof. Lemma 1 lower bound retains support long lower bounds
intact, hence losing upper bound effect.
asymmetry upper lower bounds? due asymmetry
definition UM-3-BCZ practical repercussion BC(Z) lower bounds
must mutually supportive whereas BC(Z) upper bounds may may require
support values including lower bounds.
Corollary 1 suggests improvement algorithm Figure 5
execute Line A6 A9 lower bound lost remaining support
upper bound. However, conditionals intrinsic UBFix amount much
thing little point repeating them.
point theorems build complete proof correctness
BC(Z) status:
Theorem 1. code min, max fix events listed Figure 5 remove
values involved bound supports UM-3-BCZ constraint, and, domains
non-null propagation, resultant domains BC(Z).
Proof. First must establish values removed propagation could
involved support, result domains subsets input domains.
former immediate Lemmas 2 3, values removed result
executing LBFix UBFix. latter immediate inspection LBFix UBFix,
ever make lower bounds larger upper bounds smaller.
final thing establish BC(Z) enforced, unless domain becomes null.
domain becomes empty result running algorithm Theorem
trivially true.
domain becomes empty must show bounds supported.
lower bounds, Lemma 4 Corollary 1 know loss lower bound
result need change lower bound propagation. Lower bounds
change result either fix min events, hence propagator Figure 5 runs LBFix
either event. LBFix runs leaves lower bounds supported, shown
Lemma 2. upper bounds, Lemmas 5 6 know loss either lower
upper bound result loss upper bound. Hence upper lower bounds
change result event, lower bounds change result LBFix,
hence propagator runs UBFix events, runs LBFix finished,
necessary. UBFix runs leaves upper bounds supported provided domain
becomes empty, shown Lemma 3.
913

fiMoore & Prosser

1
0
0
1
0
1
0
1
0
1
0
1

(a)

1
0
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1

(b)

Figure 8: Propagation done 2 domains singleton
propagation algorithm runs (1) time. operations
LBFix, UBFix, min, max fix events (1), provided domain representation
allows access upper lower bounds (1). guaranteed domain
reductions occur bounds, case here, domains represented using
one structures proposed van Hentenryck et al. (1992).
3.3 Entailment
Schulte Carlsson (2006) define entailment possible constractions
domains constraints scope consistent. detect happened
stop running propagator henceforth, since cannot prune values.
Definition 5. propagator entailed domains = {d1 , . . . , dn } set
domains subsets these, i.e., E = {e1 , . . . , en } s.t. i.ei di , fixed
point.
describe sufficient condition UM-3-BCZ constraint entailed, i.e.,
UM-3-BCZ constraint becomes entailed soon two variables singleton domains:
Theorem 2. UM-3-BCZ becomes entailed soon two variables singleton domains.
Proof. Consider possible scenarios: either two singletons (case (a)
Figure 8) distinct (case (b) Figure 8). domains propagation
shown Figure 8 boxes; domains propagation shaded gray. Clearly
remaining choices third variable valid instantiations since propagation
algorithm safe cannot removed propagation definition
propagation fixed point.
3.4 Ultrametric Matrix Constraint
supertree model presented Section 4 makes use ultrametric constraint, however
context desired end product constrain whole matrix ultrametric
matrix, merely constrain three variables.
914

fiThe Ultrametric Constraint Phylogenetics

Code style: let (i, j) index(v) declares j indices variable v matrix
constraint over.

Algorithm UM-Matrix-BCZ
Min event(v)
A1
let (i, j) index(v)
A2
k 1 . . . n
A2.1
k 6= k 6= j
A2.2
Min event(Mij , Mik , Mjk )
A2.3
Max event(Mij , Mik , Mjk )
Max event(v)
A3
let (i, j) index(v)
A4
k 1 . . . n
A4.1
k 6= k 6= j
A4.2
Max event(Mij , Mik , Mjk )
Fix event(v)
A5
let (i, j) index(v)
A6
k 1 . . . n
A6.1
k 6= k 6= j
A6.2
Min event(Mij , Mik , Mjk )
A6.3
Max event(Mij , Mik , Mjk )

Figure 9: Algorithm UM-Matrix-BCZ propagator

Definition 6. symmetric matrix ultrametric matrix every set
three distinct indices i, j k, tie minimum Mij , Mik Mjk ;
Mii = 0 i.
ultrametric matrix constraint achieved matrix posting constraint UM-3-BCZ(M
ij , Mik , Mjk ) choices distinct i, j k, cost

introducing n3 constraints. practical constraint solvers model containing constraint (n3 ) space complexity, since solver must list (n3 )
constraints stored somewhere. However, domain event occurs matrix variable Mij straightforward iterate k indices propagation
UM-Matrix-BCZ Figure 5. replaces (n3 ) space list representation set
UM-3-BCZ constraints (1) code representation. Hence propose ultrametric
matrix constraint propagator UM-Matrix-BCZ Figure 9.
propagator mimics part AC3 algorithm (Mackworth, 1977) since (a)
receives propagation event variable, (b) identifies constraints
variable, (c) arranges propagation carried out. events caused
result queued dispatched underlying propagator normal may
cause UM-Matrix-BCZ run again. variable involved n 2
constraints, since variable two indices matrix constraint
involving choice three different indices.
n
3

algorithm propagates (n) time, expensive per event using
Um-3 constraints, factor n fewer propagators wake result event.
915

fiMoore & Prosser



b

c



c

b

b

c





b

c

Figure 10: four possible relationships three leaf nodes tree: i.e. three
triples (ab)c, (ac)b, (bc)a, fan (abc).

4. Supertree Construction
review imperative solutions supertree construction problem, review first
constraint programing solution (Gent et al., 2003), present new encoding exploits
specialised UM-Matrix-BCZ constraint.
4.1 Imperative Solutions Supertree Problem
earliest imperative techniques due Bryant Steel (1995) Ng Wormald
(1996). present OneTree algorithm based Build algorithm
Aho, Sagiv, Szymanski, Ullman (1981). OneTree based observation
tree three leaf nodes define unique relation respect recent
common ancestor (mrca), mrca(a, b) interior node furthest root
leaf nodes b descendants. abuse notation writing mrca(a, b) >
mrca(c, d) former greater depth latter, similarly mrca(a, b) =
mrca(c, d) depth. Given three different leaf nodes/species (labelled
a, b, c) one following four relations must hold:
(1)

mrca(a, b) > mrca(a, c) = mrca(b, c)

(2)

mrca(a, c) > mrca(a, b) = mrca(c, b)

(3)

mrca(b, c) > mrca(b, a) = mrca(c, a)

(4)

mrca(a, b) = mrca(a, c) = mrca(b, c)

say (1), (2) (3) triples (ab)c, (ac)b, (bc)a (where
(xy)z read x closer z) (4) fan (abc), i.e.,
fan relationship species unresolved dont specify pair
closely related. shown Figure 10. Prior applying OneTree algorithm two
(or more) species trees broken triples fans using BreakUp algorithm
(Ng & Wormald, 1996), resulting linear sized encoding trees. supertree
constructed (if possible) using encoding input.
Figure 11 shows example BreakUp algorithm process. Two variants
process shown; top hard breakup, fans considered hard
evidence must respected (hard polytomies described Ng Wormald, 1996)
soft breakup fans taken lack evidence (soft polytomies
described Bryant Steel, 1995). hard breakup algorithm modified
916

fiThe Ultrametric Constraint Phylogenetics

e



b

c

b

c

g

BREAK

BREAK

BREAK

(a b c)
(a b d)
(a c d)
(b c d)

(cd)e

(de)f

(ef)g





e

c

e



f

BREAK

f

f

g



e

f

g

e

f

g



BREAK

BREAK

BREAK

BREAK

(ab)e,
(bc)e

(cd)e

(de)f

(ef)g

e

g

c

{(abc),(abd),
}
(bcd),(cd)e,
(de)f,(ef)g}

f

g



e

f

g

e

f

{(ab)e,(bc)e,
}
(cd)e,(de)f,
(ef)g}

g



Figure 11: Example execution BreakUp algorithm. top, hard breakup,
soft breakup (no fans produced)

Code style: function sortedInteriorNodes(T ) delivers set interior nodes tree nonincreasing order depth tree; degree(v) delivers degree node v; function child(v, i)
delivers ith child interior node v; uncleOrCousin(l) delivers leaf node descended
sibling parent leaf node l; function becomesLeaf(v, l) transforms interior node v leaf
node labelled l; removeChild(l, v) removes leaf node l list children interior node v.

Algorithm HardBreakup
HardBreakup(T )
1
let V sortedInteriorNodes(T )
2
let
3
let 0
4
notRoot(V [i]) degree(V [i]) > 2
5
let v V [i]
6
let c0 child(v, 0)
7
degree(v) = 2
8
let c1 child(v, 1)
9
let c2 uncleOrCousinOf(c0 )
10
{triple(c0 , c1 , c2 )}
11
v becomesLeaf(v, c0 )
12
ii+1
13
else j 1 degree(v) 2
14
k j + 1 degree(v) 1
15
let c1 child(v, j)
16
let c2 child(v, k)
17
{fan(c0 , c1 , c2 )}
18
v removeChild(c0 , v)
19 return

Figure 12: Hard breakup tree , producing triples fans.

encountering kfan broken n3 3-fans, soft breakup
fan broken linear number rooted triples. Algorithms hard soft breakups
given Figures 12 13, used imperative OneTree algorithm
constraint programming models.
917

fiMoore & Prosser

Algorithm SoftBreakup
SoftBreakup(T )
1
let V sortedInteriorNodes(T )
2
let
3
let 0
4
notRoot(V [i])
5
let v V [i]
6
let c0 child(v, 0)
7
let c1 child(v, 1)
8
let c2 uncleOrCousinOf(c0 )
9
{triple(c0 , c1 , c2 )}
10
degree(v) = 2
11
v becomesLeaf(v, c0 )
12
ii+1
13
else v removeChild(c0 , v)
14 return

Figure 13: Soft breakup tree , producing triples.

c



b

c

e

c

b



c





e

b

e

Figure 14: toy input (left) single solution supertree problem (right). Input
trees distorted make relationships resultant supertree obvious.

toy set input triples single solution shown Figure 14. triples
drawn reflect solution compatible them.
Ng Wormald (1996) give complexity OneTree O(h(n)) h(n) =
n(n + + bn)(n + + f ), n number labels, number triples, f number
fans, b sum squares number leaves fans, inverse
Ackermann function (and less 4 conceivable inputs behaves
constant). Therefore input trees fully resolved (i.e., fans) running
918

fiThe Ultrametric Constraint Phylogenetics

time complexity O(n2 ) worst case complexity grows O(n4 ).
contrasted O(t n) complexity Bryant Steels OneTree (1995).
4.2 Constraint Encoding using Toolkit Constraints
second stage, i.e., OneTree equivalent, first solved constraint program
Gent et al. (2003). encoding takes advantage equivalence ultrametric
trees ultrametric matrices:
Definition 7. Let real symmetric n n matrix. ultrametric tree
rooted tree that:
1. n leaves, corresponding unique row M;
2. internal node least 2 children;
3. two leaves j, Mij label recent common ancestor
j;
4. along path root leaf, labels strictly increase.
Theorem 3. symmetric matrix ultrametric tree
ultrametric matrix. Furthermore, tree uniquely determines matrix
matrix uniquely determines tree .
Proof. proof given Gusfield (1997).
clear correspondence Definition 7 description species
tree given Section 4: species tree ultrametric tree matrix , Mij
depth mrca species j Mij divergence date two species.
reason use ultrametric matrix model solve supertree problem.
4.2.1 Model Gent et al.
Given input forest F n distinct leaf labels, symmetric
constrained integer variables created domains {1, . . . , n 1}
diagonal. Variable Mij depth mrca species j.
posted make whole matrix ultrametric thus ensuring
ultrametric:
Mij > Mik = Mjk
Mik > Mij = Mjk
Mjk > Mij = Mik
Mij = Mik = Mjk

n n matrix
{0} main
Initially, constraints
resulting tree

(2)

< j < k. input trees broken triples fans using either
breakup algorithms Figures 12 13. triple (ij)k produced constraint
Mij > Mik = Mjk
919

(3)

fiMoore & Prosser

1

b
c

e
f
g

3
{e,g}
5
{c,d}



b c e f g
0 5 3 3 1 5 1
5 0
3
0
3
0
1
0
5
0
0
1

{b,f}

Figure 15: One iteration algorithm convert ultrametric matrix tree
posted 3-fan (ijk)
Mij = Mik = Mjk

(4)

posted. constraints break disjunctions Equation 2. model (n2 n)/2
variables
t+f +


n
= O(n3 ) + O(n3 ) + (n3 ) = (n3 )
3

(5)

constraints, number triples f number fans. O(n3 )
one breaks disjunction one constraint Equation 2,
(n3 ) those.
4.2.2 Converting Back Tree Representation
final step use algorithm based constructive proof Gusfield (1997)
direction Theorem 3 build tree matrix produced constraint
solver. describe algorithm detail, sake intuition works
follows
Pick arbitrary leaf s. Let number distinct entries row d.
Partition leaves sets p1 , . . . , pd based entry row s.
Solve problem recursively pi ignoring rows columns
matrix pi .
Combine overall solution attaching subproblem solutions correct depth
path s.
Figure 15 shows one recursion algorithm choice leaf shows
row fully describes path corresponding tree.
920

fiThe Ultrametric Constraint Phylogenetics

Algorithm CPBuild
CPBuild(F )
1 let (V, D, C) CPModel(F )
2 F
3
BreakUp(T ) C post(t, C)
4 propagate(V,D,C) return UMToTree(V,D)
5 else fail()

Figure 16: Build supertree forest F using ultrametric constraint model.
4.2.3 Time Complexity Model Gent et al.
BreakUp, procedures build constraint model convert ultrametric
matrix tree polynomial time. However complexity backtracking search
2
O(n2 ) variables O(n)-size domains worst case O(nn ). upper bound
time taken solve supertree problem. attempted derive lesser
upper bound time complexity, since, show following section,
new model provably achieved polynomial time bound.
4.3 Constraint Encoding Using New Propagator Design
issue potentially exponential solution time model Section 4.2 worrying,
experiments time taken solve instances major issue. Conversely
memory requirements problem practice, theory! model requires
(n3 ) space n species, constant factor inhibiting. Posting constraint
Equation 1 literally (using toolkit propagators) described Section 3 uses 23 propagators JChoco toolkit. requires roughly 23 times runtime memory
single propagator, since corresponds single Java object,
comparable footprints. show empirical study Section 5, prevents
modest instances loaded typical current workstations.

Using new propagator Section 3 replace n3 propagators single
compact propagator result memory usage reduced asymptotically (n3 )
(n2 ) since model memory dominated (n2 ) space needed
matrix . reducing amount space initialised delivers proportional
saving build time. importantly, using new constraint provides solution
exponential time complexity, enforcing BC(Z) model allows solution
read lower bound domain. Theorem 4 proof correctness
algorithm.
Figure 16 gives schema constraint programming algorithm supertree construction, CPBuild. algorithm takes input forest F trees. line 1 constraint
model produced, i.e., n n symmetric array constrained integers variables created, n unique species forest, UM-Matrix-BCZ constraint
posted variables. Lines 2 3 breaks input trees triples
fans using either breakup algorithms given Figures 12 13, posts
model constraints. Propagators constraints executed fixed point
line 4; succeeds tree created lower bounds ultrametric matrix
otherwise fail.
921

fiMoore & Prosser

Lemma 7. propagator every constraint model enforces BC(Z) furthermore lower bounds mutually supportive, executing propagators
fixed point, either lower bounds solution, empty domain fail.
Proof. reduce domain lower bound fixed point obtained
bound supported mutually supportive supposition. Hence
every constraint simultaneously satisfied singleton domains and, definition,
solution.
Theorem 4. CPBuild polynomial time solution supertree problem.
Proof. constraints involved model triples fans ultrametric constraints. Theorem 1 know lower bounds supported
propagators run, Lemma 1 know lower bounds mutually supportive. true disjunction-breaking propagators. Hence Lemma 7,
shown Figure 16, either read solution fail. enforce BC(Z)
problem polynomial time shown below.
Immediate preserve polynomial time solution
addition polynomial number side-constraints, long additional constraints
preserve property lower bounds mutually supportive. fact, CSPs
ordered domains constraints property lower bounds
mutually supportive belong known tractable class called min-closed (Jeavons & Cooper,
1995).
4.3.1 Time Complexity CPBuild
algorithm implemented run O(n4 ) time using variation AC3
algorithm. AC3 (Mackworth, 1977) begins queue containing constraints.
repeatedly removes constraint none remain runs associated propagator.
constraints affected variables re-queued, necessary. queue empties,
propagators fixed point. need O(n3 ) constraints worst case complexity

O(n3 )
| {z }

+

build initial Q

O(n)O(n3 )
| {z }

worst case re-queues 1 value removed time

.

O(1)
| {z }

propagation time

O(n4 ) overall. matches worst case complexity OneTree (Ng & Wormald,
1996). constraint solution worst case problem unsolvable, since
unsolvable domains emptied propagation, whereas solvable instances
propagation reaches fixed point sooner.

5. Empirical Study
present empirical study determine practical improvements
achieved constraint solutions supertree problem and, so, size improvement. Experiments run using 1.7GHz Pentium 4 processor 768MB memory,
using Sun Java build 1.5.0 06-b05. constraint toolkit used JChoco version 1.1.04.
922

fiThe Ultrametric Constraint Phylogenetics

Input trees broken using hard breakup, consequently cases fans treated
hard polytomies2 .
benchmark real-life seabird data previously used Kennedy Page (2002)
Beldiceanu et al. (2008) present statistics various techniques producing supertrees, namely OneTree, CP solutions Section 4 (entries Toolkit
CPBuild). completeness reproduce results Beldiceanu et al. (2008)
data set, tabulate TreeCon. TreeCon uses single-successor model,
constrained integer variables represent nodes within tree, domains correspond
possible successors3 . unique variable represents root loops (i.e.,
vroot = root), leaf nodes indegree zero. Precedence incomparability
constraints generated input trees.
TreeCon results encoded constraint programming toolkit
processor approximately twice fast (3GHz). correct times
compensate factor. mark bold results differ significantly
CPBuild TreeCon results, specifically whose runtimes would undoubtedly
factor 10 different processor. Results reported combinations
seabird trees (input trees named G) following data tabulated below:
Data combination attempted.
n Total distinct species input trees
Sol iff supertree possible
Technique Type algorithm used solve
Build Time milliseconds initialise CP model
Solve Time milliseconds first solution,
Total = Build + Solve
Nodes Number nodes search tree
Mem Model memory MB
table, DNL means model could loaded (as large) DNF
means could solved within 30 mins, succeeded loading.
provided memory usage OneTree; however smaller
constraint encodings.
obvious thing note much faster imperative approach compared
constraint techniques. this? Primarily due lower complexity
OneTree absence fans (we investigated benefit this),
partly due generality constraint programming approach. imperative
approach highly specialised one class problem whereas constraint approach
sits within toolkit, runs top general purpose constraint maintenance system.
expect constraint approach compete raw speed
later demonstrate (in Section 6) approach benefits versatility, i.e.,
2. later section use soft breakup.
3. alternative constraint model tree might use 0/1 variables corresponding potential edges
within adjacency matrix (Prosser & Unsworth, 2006), indeed CP(Graph) computation domain
(Dooms, 2006).

923

fiMoore & Prosser

costs space time repaid ease accommodating variants problem
model.
Data
AB

n
23

Sol


AC

32

F

AD

47



AE

95

F

AF

31



AG

46



BC

29

F

BD

42





94

F

BF

30



BG

40



CD

45



CE

68



CF

34



CG

44

F

Technique
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon

Build
2056
183

Solve
374
131

2670
189

327
153

8235
220

946
248

DNL
340

DNL
1477

2497
188

379
137

7671
222

871
252

2056
171

21931
107

5833
201

930
251

DNL
335

DNL
16340

2405
174

343
99

5098
203

651
353

10056
224

1134
276

DNL
516

DNL
1451

3101
180

563
133

6683
210

587
215

924

Total
2430
314
302
13
2997
342
406
12
9181
468
398
22
DNL
1817
10393
37
2876
325
127
20
8542
474
409
21
23987
278
32
8
6763
452
301
17
DNL
16675
892
11
2748
273
144
8
5749
556
1440
13
11190
500
630
14
DNL
1967
27180
36
3662
313
393
11
7270
425
1530

Nodes
23
23

Mem
26.92
0.24

0
0

36.34
0.34

38
38

118.51
0.70

DNL
0

> 629
2.79

19
18

32.99
0.32

31
31

111.07
0.68

171
0

26.90
0.27

33
33

84.26
0.55

DNL
0

> 629
2.71

29
29

29.83
0.28

30
30

72.71
0.51

45
45

143.91
0.77

DNL
68

> 629
2.72

30
30

43.72
0.36

0
0

97.10
0.61

fiThe Ultrametric Constraint Phylogenetics

DE

104

F

DF

44



DG

56

F

EF

94

F

EG

97

F

FG

38

F

ABDF

72



ABDG

78

F

ACDF

72

F

ACDG

81

F

ACE

97

F

OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
TreeCon
OneTree
Toolkit
CPBuild
OneTree

DNL
360

DNL
2021

6613
203

987
250

14090
252

2280
640

DNL
331

DNL
9546

DNL
344

DNL
8900

4299
195

DNL
212

27032
277

5291
722

60847
301

DNF
3633

31067
286

1931
649

DNL
307

DNL
1711

DNL
737

DNL
1632

14
DNL
2381
1126
34
7600
453
630
17
16370
892
910
19
DNL
9877
1035
12
DNL
9244
1211
15
DNL
407
62
10
32323
999
8139
34
DNF
3934
347
29
32998
935
8690
28
DNL
2018
12650
35
DNL
2369
38

DNL
0

> 629
3.31

37
37

97.10
0.60

1
0

201.42
0.99

DNL
0

> 629
2.71

DNL
0

> 629
2.89

DNL
0

61.41
0.46

63
59

382.52
1.48

DNF
0

553.49
1.91

0
0

434.84
1.61

DNL
0

> 629
2.06

DNL
0

> 629
2.91

impressive aspect matrix model Section 4.3 Section 4.2
improvement memory requirements, instances loaded comfortably. dramatic impact build time. improvements dominate
reduction solve time practice. toolkit model outperformed CPBuild
order magnitude instance; moreover, two cases search occurring
toolkit model (on data sets BC ABDG) whereas CPBuild never search.
polynomial time complexity due provable absence search.
results compare well Beldiceanu et al. (2008). one
case, BE, CPBuild order magnitude slower TreeCon; far
explanation this. four cases TreeCon significantly worse
CPBuild. results available TreeCon data set ACE.
noted Beldiceanu et al. yet complete filtering algorithm problem
based constraint model and, personal communication, although TreeCon
925

fiMoore & Prosser

Figure 17: Supertree largest compatible data sets birds ABDF. took 737ms
model 270ms solve using cpbuild.

model never backtracked birds data set yet proof complexity
model polynomial. noted see CPBuild taking time
unsolvable instances solvable instances, predicted.
Figure 17 shows supertree, displayed treeView (Page, 1996), produced
largest compatible forest {A, B, D, F }. supertree 72 leaves takes
1 second produce. Although result printed table, finding forest
{A, B, C, D, E, F, G} incompatible takes 12 seconds total (1.5 seconds build
model 10 seconds determine incompatibility).
926

fiThe Ultrametric Constraint Phylogenetics

6. Versatility Constraint Model
One strengths constraint programming versatility: given constraint model
core problem model enhanced address variants original pure
problem. demonstrate versatility respect ultrametric model, presenting
four variants supertree problem (a) incorporating ancestral divergence dates
model, (b) nested taxa, (c) determining induced triple fan common
supertrees, (d) coping incompatibilities.
6.1 Ancestral Divergence Dates
Semple et al. (2004) Bryant et al. (2004) add temporal information input trees.
Interior nodes may labelled integer ranks interior node v2 proper
descendant v1 rank(v1 ) < rank(v2 ), resulting ranked phylogenetic tree. Additionally relative divergence dates may expressed form div(c,d) predates div(a,b)
interpreted divergence species c predates species b.
RankedTree algorithm (Bryant et al., 2004) takes input collection precedence
constraints derived input ranked species trees predates relations. algorithm
outputs ranked tree respects relations returns compatible.
trivial incorporate constraint model. trees ranked
pair species (i, j) leaf set instantiate constrained integer variable
Mij value mrca(i, j). predates relation div(c,d) predates div(a,b) post
constraint Mcd < Mab . done step 4 CPBuild (Figure 16), i.e., ranks
predates relations become side constraints. Similarly time bounds speciation events
posted unary constraints, i.e. dated phylogenetic tree upper lower divergence
bounds given interior nodes, l(a, b) u(a, b) give respectively lower
upper bounds divergence dates species b. constraint program
following two side constraints posted (again, step 4): l(a, b) Mab
Mab u(a, b).
demonstration ranked trees given Figure 18. left two ranked
species trees cats used recently Semple et al. (2004) originally Janczewski,
Modi, Stephens, OBrien (1995). branch lengths source trees
translated rankings added interior vertices trees. right
one 17 possible resultant supertrees. total, 7 17 solutions contain
interior nodes ranges. interior nodes labelled specific values rather
ranges 30 solutions produced, structurally identical. goes
way addressing issue enumerating supertrees compactly, raised
challenge Semple et al. (2004). Figure 19 show effect adding predates
constraint supertree construction. data previously used Bryant et al.
(2004) Figures 5 6.
6.2 Nested Taxa
taxon (plural, taxa) group organisms comprising single common ancestor
descendents (Dawkins & Wong, 2004). example species lion class birds
taxa. far, species trees leaf-labelled, however restrictive
927

fiMoore & Prosser

Figure 18: Two ranked trees cats. right one 17 possible supertrees produced
CPBuild. Displayed using Pages treeView.

Figure 19: Two input trees T1 = ((a, c), x) T2 = (b, x) resultant supertree shown
3rd position. tree far right supertree T1 T2
side constraint div(a,c) predates div(a,b), produced CPBuild
displayed using Pages treeView.

928

fiThe Ultrametric Constraint Phylogenetics

P

P

Q

Q

P

Q



b

c



e

g

b

f



e



g

b

c

f



e

Figure 20: Two input rooted X-trees T1 T2 (left) output tree T3 (right)
perfectly displays them.

trees may annotated taxa names leaves internal nodes, giving
nested taxa. example, Figure 20 shows tree T1 internal node labelled P
descendents b, i.e., b taxa nested within P taxon. Problems
related creating compatible supertrees type data raised Page (2004)
defined solved Daniel Semple (2004). set input trees possible
solution problem shown Figure 20: notice labels conserved
solution, ancestral relationships conserved and, labels li lj
input tree, li ancestor lj input tree li ancestor lj solution
tree. instance problem Higher Taxa Compatibility defined Daniel
Semple (2004) Semple et al. (2004), result tree must perfectly display
input trees. define problem formally.
Definition 8. rooted X-tree (Daniel & Semple, 2004) species tree internal
nodes well leaves may labelled set X.
following slightly loose may use label l identify labelled node,
well label itself, e.g., descendants l means descendants
node labelled l.
Definition 9. rooted X-tree perfectly displays rooted X -tree
1. X X;
2. displays , neglecting internal labels;
3. descendant b descendant b ;
4. descendant b descendant b .
rooted X-tree perfectly displays forest phylogenetic trees F = {T1 , . . . , Tn }
perfectly displays every Ti .
6.2.1 Constraint Encoding
constraint encoding implemented addition variables side constraints
standard model Section 4. describe transform input make
constraint solution simpler, describe variables constraints needed.
929

fiMoore & Prosser

T1

T2

T2

P

Q

P

Q

Q


b

c



e

f

P

e

g

f



b

c

e

g

f

Figure 21: Two input trees T1 T2 enclosing taxon P . process substitution T2 replaced T2 .

Substitution Taxon P Figure 21 appears internal node T1 , call
label enclosing taxon. Note appears leaf T2 . input trees
preprocessed replace tree enclosing taxon P leaf tree
single subtree rooted P substituted place. must subtree
elsewhere input forest, contradiction enclosing taxon.
process add remove information, since relationships
everything tree still holds, new relationships taxa subtree
rest tree always implicit input.
aim process obtain set inputs enclosing taxa appear
internal nodes only, without loss generality constraint encoding assumes
case. Figure 21 shows example substitution process applied
trees T1 T2 , T2 would replaced T2 .
Variables constraints variables added one integer variable vl per enclosing
taxa/label l, domain {1, . . . , n 1}. value variable solution
tree depth internal node labels, labels position final
tree determined must unique node depth path one
nested taxa root. See Figure 15 suppose sake argument
enclosing taxa labels b, variable lM = 1 solution.
unique location label go root node.
Properties (1) (2) Definition 9 immediate properties
earlier model foundation one. explaining enforce
property (3) introduce notations convenience. Function desc(l, F ) returns
set descendants label l tree forest F , notDesc(l, ) returns
set labels descendants l tree .
first need constraint l must label every single species labels input.
every enclosing label l, post following set constraints:
{vl Mij | desc(l, F ) j desc(l, F ) 6= j}

(6)

label must settle least shallow mrca descendants input,
hence must remain descendants. Notice necessary consider pairs species
distinct input trees. alternative taking pairs tree work,
necessary pairs internal node l, rather two
930

fiThe Ultrametric Constraint Phylogenetics

distinct nodes happen correct depth. Next, label must constrained
label already descendant becomes one. X-tree
enclosing label l X, post following set constraints:
{vl > Mij | desc(l, {T }) j notDesc(l, )}

(7)

label l must placed strictly deeper mrca descendant
something thats descendant, i.e., non-descendents l descendent
result. illustration list generated constraints example Figure 20.
1. Equation 6 l = P : {vP Mab , vP Mag , vP Mbg }
2. Equation 6 l = Q: {vQ Mde , vQ Mdf , vQ Mef }
3. Equation 7, l = P {T1 , T2 }: {vP > Mac , vP > Mad , vP > Mae , vP >
Mbc , vP > Mbd , vP > Mbe , vP > Mgf , vP > Mgd , vP > Mge , vP > Mbf }
4. Equation 7, l = Q {T1 , T2 }: {vQ > Mad , vQ > Mae , vQ > Mbd , vQ >
Mbe , vP > Mcd , vQ > Mce , vQ > Mgf , vP > Mbf , vP > Mgd , vP > Mge }
number new constraints created Equations 6 7 bounded
number distinct pairs species, i.e. (n2 ) new constraints.
6.3 Necessity
may many possible supertrees given input forest. One question then,
relationships common supertrees? problem determining derived
induced triple (or fan) supertree necessary (i.e., common possible supertrees)
introduced (Daniel, 2003) along polynomial time decision procedure Necessity.
algorithm Necessity Figure 22 takes arguments forest F trees, assumed
compatible, rooted triple fan determines occurs every supertree
displays trees F . algorithm simple modification CPBuild,
lines 1 3 essentially same. line 4 negation triple posted
problem, posted
Mik 6= Mjk Mij Mik Mij Mik

(8)

= (ij)k posted
Mij 6= Mik Mij 6= Mjk Mik 6= Mjk

(9)

= (ijk). call made propagate make problem arc-consistent (line
5), fails necessary, otherwise necessary. algorithm
complexity CPBuild.
6.4 Coping Conflict
supertree cannot produced pair trees input triples fans
must conflict one another, either directly indirectly. Junkers quickXPlain
method (Junker, 2004) discovers minimal subset constraints posted
propagated result failure. set necessarily smallest possible set
931

fiMoore & Prosser

Algorithm Necessity
Necessity(F, )
1 let (V, D, C) CPModel(F )
2 F
3
BreakUp(T ) C post(t, C)
4 C post(, C)
5 return propagate(V, D, C)

Figure 22: triple/fan occur every supertree displays trees F ?
minimal sense removal element set constitute
sound explanation, addition constraint would redundant. set
constraints input triples fans, minimal set semantically collection input
data incompatible. Junker (2004) state method achieved worst
case 2k log2 (n/k) + 2k propagations4 , k size minimal explanation
found n number constraints.
alternative approach satisfy many input triples fans possible
within reasonable amount time, i.e., polynomial time. Semple Steel propose
algorithm, MinCutSupertree (2000), refined Page (2002).
propose similar scheme within constraint programming framework. call
algorithm GreedyBuild works follows. associate constrained integer
variable x, domain {0, 1}, triple fan. variable assigned
value 0 triple (or fan) respected, otherwise ignored. Therefore triple
(ij)k post constraint equation 10 3-fan (ijk) constraint equation
11.

(x = 0 Mij > Mik = Mjk ) (x = 1 (Mik 6= Mjk Mij Mik Mij Mik ))

(10)

(x = 0 Mij = Mik = Mjk ) (x = 1 (Mij 6= Mik Mij 6= Mjk Mik 6= Mjk ))

(11)

GreedyBuild instantiates turn x variables, i.e. decision variables,
preferring value 0 value 1, instantiation problem made arcconsistent. algorithm shown Figure 23. line 1 constraint model produced,
i.e., n n symmetric array constrained integers variables created, n
unique species forest, UM-Matrix-BCZ constraint posted
variables. variable X line 2 set decision variables. input trees
broken before, new variable x created triple fan. line
6 constraints equations 10 11 posted model. loop lines 10
12 turn select decision variable, set lowest possible value, make
problem arc-consistent. might turn cause uninstantiated variables
value 0 removed domain associated triple fan conflicts triple
4. BC(Z) propagator O(1), however, time complexity number
propagations.

932

fiThe Ultrametric Constraint Phylogenetics

Algorithm GreedyBuild
GreedyBuild(F )
1
let (V, D, C) CPModel(F )
2
let X
3
F
4
BreakUp(T )
5
let x newV ar(0, 1)
6
let c newConstraint((t x = 0) (t x = 1))
7
X X {x}
8
V V {x}
9
C post(c, C)
10 x X
11
instantiate(x)
12
propagate(V, D, C)
13 return UMToTree(V, D)

Figure 23: Greedily Build supertree forest F using ultrametric constraint model.

fan enforced. process terminates without failure,
conflicting triples fans essentially ignored. line 13 ultrametric matrix
converted tree. complexity GreedyBuild O((t + f ) n4 )
triples f fans.
GreedyBuild applied forest bird data {A, B, C, D, E, F, G} section 5, using soft breakup. data incompatible use CPBuild, however
GreedyBuild produces supertree Figure 24. supertree contains 121 species.
SoftBreakup produced 201 triples, 17 rejected. took less 2
seconds build model 100 seconds solve model.
compared CPBuild data set, taking 1.5 seconds build model
10 seconds determine incompatibility. GreedyBuild applied data set
ABDF, producing identical supertree CPBuild, comparable time (890ms build
model 578ms solve).
executed GreedyBuild decision variables set X (lines 2, 7, 10
11) analysed identify set triples fans excluded
supertree, i.e., x variable instantiated value 1 corresponding
triple fan ignored.
Note claim biological significance arbitrary order use
suppress triples. GreedyBuild could amended follow order MinCutSupertree investigated this. GreedyBuild enhanced
follows. Currently triple fan exists multiple input trees occurs
constraint. information could exploited weighting decision variables
take consideration relative weight evidence triple fan, e.g., number
times triple fan occurs input. decision variables instantiated
non-increasing order weight, i.e., variable ordering heuristic used.
extreme GreedyBuild modified become OptBuild full backtracking
search performed objective minimising sum decision variables,
933

fiMoore & Prosser

Figure 24: Supertree largest data set birds, ABCDEFG, 121 species.
took 2 seconds model 100 seconds solve using GreedyBuild.
Displayed using Rod Pages treeView.

934

fiThe Ultrametric Constraint Phylogenetics

potentially exponential cost time. would return tree fewest possible
input triples suppressed.
6.5 Summary
little effort, constraint model adapted deal ancestral divergence
dates nested taxa. achieved adding side constraints.
added advantage respect ancestral divergence result compact
enumeration output trees interior nodes labelled ranges rather specific
values.
input trees conflict propose two options: use quickXPlain determine
cause conflict greedily build supertree using GreedyBuild. Bryant et al. (2004)
state essentially all-or-nothing approach supertree construction
using RankedTree needed something akin MinCutSupertree, i.e.
trees incompatible build supertree violates minimum number triples
fans, polynomial time (Page, 2002; Semple & Steel, 2000). since
done Bordewich et al. (2006) done constraint model
incorporating constraints identified section 6.1 GreedyBuild.
Although shown, obvious ancestral divergence data nested taxa
combined one model, simply adding necessary constraint auxiliary
variables variants one model. This, again, could done GreedyBuild,
would require heuristic rule used deciding constraints ignore
input trees side constraints incompatible.
opinion, deriving, combining analysing results imperative algorithms
supertree problems much difficult above. algorithms variants
required far complex data structures tailored algorithms processing them.
Moreover, combine algorithms produced seems practically impossible account
intricacy. Finally constraint programming provides various generic methods
quickXPlain box turn interest supertree problems.

7. Conclusion
presented new constraint propagator ultrametric constraint three
integer variables, shown extended symmetric matrix constrained
integer variables. bounds(Z)-consistency established symmetric array
lower bounds variables give mutual support. sufficient modelling solving
supertree construction problem O(n4 ) time O(n2 ) space, comparable complexity OneTree (Ng & Wormald, 1996) inferior algorithm Bryant
Steel (1995). So, bother CPBuild approach efficient imperative
approaches already exist? answer lies versatility constraint programming.
Rather develop new algorithm new variant supertree problem add
side constraints base model, shown polynomial time bound
often achieved. done ancestral divergence dates nested taxa,
shown model used deliver necessary triples fans,
proposed GreedyBuild way dealing incompatible trees.
935

fiMoore & Prosser

Acknowledgments
would thank Pierre Flener Xavier Lorca; Barbara Smith, Ian Gent Christine Wei Wu; Charles Semple, Mike Steel Rod Page; Muffy Calder Joe Sventek;
Stanislav Zivny; Chris Unsworth; three anonymous reviewers/co-authors.

References
Aho, A., Sagiv, Y., Szymanski, T., & Ullman, J. (1981). Inferring tree lowest
common ancestors application optimization relational expressions.
SIAM J. Comput, 10 (3), 405421.
Beldiceanu, N., Flener, P., & Lorca, X. (2008). Combining tree partitioning, precedence,
incompatibility constraints. Constraints, 13, 131.
Bessiere, C., & Regin, J.-C. (2001). Refining basic constraint propagation algorithm.
IJCAI, pp. 309315.
Bessiere, C. (2006). Constraint propagation. Handbook constraint programming. Elsevier. Chapter 3.
Bininda-Emonds, O. (2004). Phylogenetic Supertrees: Combining information reveal
tree life. Springer.
Bordewich, M., Evans, G., & Semple, C. (2006). Extending limits supertree methods.
Annals combinatorics, 10, 3151.
Bryant, D., & Steel, M. (1995). Extension Operations Sets Leaf-labeled Trees. Advances Applied Mathematics, 16, 425453.
Bryant, D., Semple, C., & Steel, M. (2004). Supertree methods ancestral divergence
dates applications. Bininda-Emonds, O. (Ed.), Phylogenetic Supertrees:
Combining information reveal tree life, pp. 151171. Computational Biology
Series Kluwer.
Carlier, J., & Pinson, E. (1994). Adjustment heads tails jobshop scheduling
problem. European Journal Operational Research, 78, 146161.
Caseau, Y., & Laburthe, F. (1997). Solving small TSPs constraints. Proceedings
International Conference Logic Programming, pp. 115.
Choco (2008). http://www.choco-constraints.net/ home choco constraint programming system..
Daniel, P. (2003). Supertree methods: new approaches. Masters thesis, Department
Mathematics Statistics, University Canterbury.
Daniel, P., & Semple, C. (2004). Supertree algorithms nested taxa. Bininda-Emonds,
O. (Ed.), Phylogenetic Supertrees: Combining information reveal tree life,
pp. 151171. Computational Biology Series Kluwer.
936

fiThe Ultrametric Constraint Phylogenetics

Dawkins, R., & Wong, Y. (2004). Ancestors Tale. Weidenfeld Nicholson.
Debruyne, R., & Bessiere, C. (1997). practicable filtering techniques constraint
satisfaction problem. Proceedings IJCAI97, pp. 412417.
Dooms, G. (2006). CP(Graph) Computation Domain Constraint Programming.
Ph.D. thesis, Universite catholique de Louvain, Faculte des sciences appliquees.
Gent, I., Prosser, P., Smith, B., & Wei, W. (2003). Supertree construction constraint
programming. Principles Practice Constraint Programming, pp. 837841.
Springer.
Gusfield, D. (1997). Algorithms strings, trees, sequences: computer science
computational biology. Cambridge University Press, New York, NY, USA.
Janczewski, D., Modi, W., Stephens, J., & OBrien, S. (1995). Molecular evolution
mitochondrial 12S RNA Cytochrome b sequences pantherine lineage
Felidae. Mol. Biol. Evol., 12, 690707.
Jeavons, P. G., & Cooper, M. C. (1995). Tractable constraints ordered domains. Artif.
Intell., 79 (2), 327339.
Junker, U. (2004). QUICKXPLAIN: Preferred Explanations Relaxations OverConstrained Problems. Proceedings AAAI2004, pp. 167172.
Kennedy, M., & Page, R. (2002). Seabird supertrees: Combining partial estimates procellariiform phylogeny. Auk, 69, 88108.
Lhomme, O. (2003). efficient filtering algorithm disjunction constraints.
Principles Practice Constraint Programming, pp. 904908. Springer.
Mace, G. M., Gittleman, J. L., & Purvis, A. (2003). Preserving Tree Life. Science,
300, 17071709.
Mackworth, A. (1977). Consistency networks relations. Artificial Intelligence, 8,
99118.
Ng, M. P., & Wormald, N. C. (1996). Reconstruction rooted trees subtrees. Discrete
Appl. Math., 69 (1-2), 1931.
Page, R. (1996). TREEVIEW: application display phylogenetic trees personal
computers. Computer Applications Biosciences, 12, 357358.
Page, R. (2004). Taxonomy, supertrees, tree life. Bininda-Emonds, O. (Ed.),
Phylogenetic Supertrees: Combining information reveal tree life, pp. 247265.
Computational Biology Series Kluwer.
Page, R. D. M. (2002). Modified mincut supertrees. WABI 02: Proceedings Second
International Workshop Algorithms Bioinformatics, pp. 537552 London, UK.
Springer-Verlag.
937

fiMoore & Prosser

Pennisi, E. (2003). Modernizing Tree Life. Science, 300, 16921697.
Prosser, P. (2006). Supertree construction constraint programming: recent progress
new challenges. WCB06 - Workshop Constraint Based Methods Bioinformatics, pp. 7582.
Prosser, P., & Unsworth, C. (2006). Rooted Tree Spanning Tree Constraints. 17th
ECAI Workshop Modelling Solving Problems Constraints.
Regin, J.-C. (1994). filtering algorithm constraints difference CSPs. Proceedings AAAI94, pp. 362367.
Rossi, F., van Beek, P., & Walsh, T. (2007). Handbook Constraint Programming. Elsevier.
Sabin, D., & Freuder, E. (1994). Contradicting conventional wisdom constraint satisfaction. Proceedings ECAI-94, pp. 125129.
Schulte, C., & Carlsson, M. (2006). Finite domain constraint programming systems.
Handbook constraint programming. Elsevier. Chapter 14.
Semple, C., Daniel, P., Hordijk, W., Page, R., & Steel, M. (2004). Supertree algorithms
ancestral divergence dates nested taxa. Bioinformatics, 20 (15), 23552360.
Semple, C., & Steel, M. (2000). supertree method rooted trees. Discrete Appl. Math.,
105 (1-3), 147158.
Smith, B. M. (1995). Tutorial Constraint Programming. Technical Report 95.14,
University Leeds.
TreeBASE (2003). http://www.treebase.org/ TreeBASE: database phylogenetic knowledge..
Tsang, E. (1993). Foundations Constraint Satisfaction. Academic Press.
van Hentenryck, P., Deville, Y., & Teng, C.-M. (1992). generic arc-consistency algorithm
specializations. Artificial Intelligence, 57, 291321.
van Hentenryck, P., Saraswat, V., & Deville, Y. (1998). Design, implementation,
evaluation constraint language cc(fd). Journal Logic Programming, 37, 139
164.
Wu, G., You, J.-H., & Lin, G. (2007). Quartet-based phylogeny reconstruction answer
set programming. IEEE/ACM Transactions Computational Biology Bioinformatics, 4, 139152.
Yuanlin, Z., & Yap, R. H. C. (2001). Making AC-3 optimal algorithm. IJCAI, pp.
316321.

938


