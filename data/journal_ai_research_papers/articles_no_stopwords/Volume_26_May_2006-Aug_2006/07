journal artificial intelligence

submitted published

engineering benchmarks domains used
deterministic part ipc
jorg hoffmann

hoffmann mpi sb mpg de

max planck institute computer science
saarbrucken germany

stefan edelkamp

stefan edelkamp cs uni dortmund de

fachbereich informatik
universitat dortmund germany

sylvie thiebaux

ylvie hiebaux anu edu au

national ict australia computer sciences laboratory
australian national university canberra australia

roman englert

roman e nglert telekom de

deutsche telekom laboratories
berlin germany

frederico dos santos liporace

liporace inf puc rio br

departamento de informatica puc rio
rio de janeiro brazil

sebastian trug

trueg informatik uni freiburg de

institut fur informatik
universitat freiburg germany

abstract
field general reasoning mechanisms essential appropriate
benchmarks ideally benchmarks reflect possible applications developed technology ai researchers tend draw testing examples
benchmark collections used international competition ipc organization
deterministic part fourth ipc ipc authors therefore invested significant effort
create useful set benchmarks come five different potential real world applications airport ground traffic control oil derivative transportation pipeline networks
model checking safety properties power supply restoration umts call setup adapting
preparing application use benchmark ipc involves time inevitable
often drastic simplifications well careful choice engineering domain encodings first time ipc used compilations formulate complex domain features
simple languages strips rather dropping interesting constraints simpler language subsets article explains discusses five application
domains adaptation form pddl test suites used ipc summarize known
theoretical structural properties domains regarding computational complexity
provable properties topology h function idealized version relaxed
plan heuristic present empirical illuminating properties quality
wide spread heuristic functions graph serial graph relaxed plan
growth propositional representations instance size number actions available
achieve fact discuss data conjunction best achieved
different kinds planners participating ipc

c

ai access foundation rights reserved

fih offmann e delkamp hi ebaux e nglert l iporace r ug

introduction
today large extent discipline ai concerned improving performance domain independent generative systems domain independent generative
system planner must able fully automatically plans solution sequences
declaratively specified transition systems simplest formalism deterministic planner given input set state variables often booleans called facts
initial state value assignment variables goal formula set actions
precondition formula describing applicability effect specifying action changes
state plan time stamped sequence actions maps initial state state
satisfies goal sort formalism called deterministic since initial state fully specified effects actions non ambiguous restrictions may weakened obtain
non deterministic probabilistic
performance planners measured testing benchmark example instances
best point time generally considered one
solves examples efficiently particular idea international competition ipc biennial event aimed showcasing capabilities current
systems
first ipc took place time writing four events providing details ipc beyond scope refer reader overview
articles written organizers respective ipc editions mcdermott bacchus
long fox hoffmann edelkamp particular hoffmann edelkamp
provide details th ipc overall organization different tracks evaluation participating planners basic information included reader
able follow main discussion without detailed background language used describe
ipc called pddl domain definition language introduced mcdermott first ipc ipc subset language
selected bacchus ipc language extended temporal numerical constructs fox long form language pddl ipc
extended two additional constructs timed initial literals derived predicates
hoffmann edelkamp form language pddl ipc
since even simplest forms ai computationally hard system
work efficiently instances bylander helmert thus crucial importance kinds examples used testing today ai
researchers draw testing examples collections used ipc makes ipc
benchmarks important instrument field organization deterministic part
th ipc probabilistic part see younes littman weissman asmuth
authors therefore invested considerable effort creating set useful benchmarks

first question answer precisely meant word useful
easy question widely accepted mathematical definition deciding whether
set benchmarks considered useful however widely accepted intuitions
case benchmarks
oriented applications benchmark reflect application technology developed field


fie ngineering b enchmarks



p lanning

diverse structure set benchmarks cover different kinds structure rather
state similar tasks
first usually considered particularly important indeed ai frequently criticized obsession toy examples recent years performance
state art systems improved dramatically realistic examples come
within reach made another step direction orienting ipc benchmarks
application domains traditionally benchmarks less fantasy products
created real scenario mind took actual possible applications
technology turned something suitable competition considered five different application domains airport ground traffic control airport oil derivative transportation
pipeline networks pipesworld model checking safety properties promela power supply restoration psr setup mobile communication umts umts course adaptation
application use ipc simplifications need made get back
diverse structure benchmarks traditionally given less attention realism
believe less important structure underlying testing example determines
performance applied solving mechanism particularly true solving mechanisms
whose performance rises falls quality heuristic use hoffmanns
suggest much spectacular performance modern heuristic search planners
due structural similarities traditional benchmarks
imply modern heuristic search planners arent useful certainly shows
creation benchmarks risk introducing bias towards one specific way solving
selecting benchmark domains ipc tried cover range intuitively
different kinds structure get back
one hand creator benchmarks noble goal realistic structurally diverse benchmark domains hand pragmatic goal
come version representation benchmarks attacked existing systems given still quite restricted capabilities systems obviously two goals
conflict make matters worse isnt arbitrarily large supply applications
publicly available whose developers agree application used basis
benchmark ipc organizer top final benchmarks must accessible
large enough number competing systems means must formulated language
understood systems benchmarks must differences scalability planners e must easy hard thus straddling boundary current
system capabilities
solution difficulties least solution organization ipc involved slow tedious interleaved process contacting application developers choosing domains
exploring domain versions engineering domain version representations article presents
motivates discusses choice benchmark domains ipc explains engineering
processes led finally used domain versions instances report
present data determining certain structural properties resulting benchmarks
details main contribution work set benchmarks provided
course exceptions rule one important one context satellite domain used
ipc refined use ipc later



fih offmann e delkamp hi ebaux e nglert l iporace r ug

ipc contributions article first providing necessary documentation
benchmarks second describing technical processes used creation third providing
extensive discussion structural properties benchmarks apart technical contributions believe work value example large scale attempt
engineering useful set benchmarks classical
difficult make formal claim created set benchmarks
way better previous benchmarks working intent
overcome certain shortcomings many benchmarks though one would hard pressed come
formal proof improvements indeed made judging quality
set benchmarks rather complex matter guided mostly intuitions worse personal
opinions best create realistic structurally diverse accessible
benchmarks possible ipc belief succeeded benchmarks
definitely differ certain ways previous benchmarks think
differences advantageous discuss places point differences
regarding realism benchmarks pointed main step took design
benchmarks top e start actual possible applications technology
turn something suitable competition rather traditional bottomup artificially creating domain real scenario mind course
modelling application pddl particularly modelling way making suitable
use ipc simplifications need made cases e g airport ground traffic
control simplifications overly drastic preserved overall properties intuitive
structure domain cases e g oil derivative transportation pipeline networks
simplifications needed make drastic domains could well
created traditional bottom way still even greatly simplified domain generated
top better chance capture structure relevant real application moreover
top domain advantage since derived real application provides
clear guideline towards realism future challenge make planners work
realistic encodings application previous competitions domains generated
top sense elevator domain used ipc koehler schuster
bacchus satellite rovers domains used ipc long fox
regarding diverse structure benchmarks contrast previous competitions
ipc domains common theme underlying many benchmarks ipc
domains variants transportation ipc domains variants transportation ipc domains variants transportation gathering
data space variants fact interesting use constructs
locked locations fuel units road map graphs stackable objects complex side constraints
however certainly intuitive similarity structure relationships domains
extent similarity even automatically detectable long fox ipc airport ground traffic control oil derivative transportation pipeline networks model checking
safety properties power supply restoration umts call setup rather different topics
benchmarks downloaded ipc web page http ipc icaps conference org
consider example movie domain used ipc instances domain matter size
share space reachable states thing increases connectivity states e
number actions effect still one argue movie useful benchmark sense
highlight systems approaches difficulties attacking characteristics



fie ngineering b enchmarks



p lanning

one could claim airport ground traffic control umts call setup scheduling nature see however ipc version airport ground traffic control allows
considerably freedom classical scheduling formulations making pspace complete
decision particulars domains overviewed section
approaching structure formal point view difficult largely unclear
precisely relevant structure domain instance general sense
hoffmann provides one possible definition search space surface topology certain heuristic function many possible options particular hoffmanns
relevant heuristic search planners generate heuristic functions
ignoring delete lists relaxation mcdermott bonet loerincs geffner
bonet geffner hoffmann nebel lack better formal handle used
hoffmanns definitions qualify structure domains selected domains cover different regions hoffmanns domain taxonomy particular lie regions
less coverage traditional benchmarks interesting context
hand summarize hoffmanns domains including domains
used previous competitions summarize helmerts b computational complexity satisficing optimal ipc domains turns
complexity covers wide range widest possible range propositional formalisms
pspace hard polynomial finally provide data analyze structural
relationships differences domains amongst things instance
measure number parallel sequential steps needed achieve goal estimated
smallest plan found ipc participant number estimated graphs
relaxed plans distribution number possible achieving actions fact
examined comparison different domains taking account
runtime performance exhibited different kinds planners ipc
apart realism diverse structure main quest creation ipc benchmarks
promote accessibility applications typically modelled
pddl naturally modelled rather complex language constructs time numeric
variables logical formulas conditional effects existing systems handle subsets
fact half systems entered ipc precisely could handle
simple strips language slight extensions previous competitions done
example elevator satellite rovers domains handled simply dropping
interesting domain constraints simpler languages e removing respective
language constructs domain instance descriptions contrast first time ipc
compiled much domain semantics possible simpler language formats
compilation hard sometimes impossible done adl constructs
well two constructs introduced ipc language pddl derived predicates
timed initial literals implemented applied compilation methods cases
strips stanford institute solver name simplest time widespread language form language used today state variables boolean formulas
conjunctions positive atoms action effects atomic positive make fact true add atomic negative
make fact false delete fikes nilsson languages selected ipc bacchus
pddl pddl derived strips adl adl prominent expressive alternative
strips extending arbitrary first order formulas preconditions goal conditional effects
e effects occur individual effect condition first order formula met state execution
pednault



fih offmann e delkamp hi ebaux e nglert l iporace r ug

compilations serve preserve original domain structure simpler language
classes example strips version elevator domain ipc simplified
original adl version bears marginal similarity real elevator control particular
planner explicitly tell passengers get lift contrast strips
formulation airport ground traffic domain semantically identical adl formulation
expresses things awkward fashion
compiled domain versions offered competitors alternative domain version formulations yielding step hierarchy domain domain ipc
could contain several different domain versions differing terms number domain constraints properties considered within domain version could several domain version formulations differing terms language used formulate semantics
competitors could choose within version whichever formulation planners could handle
best handle within domain version evaluated together
way intended make competition accessible possible time keeping
number separation lines data number distinctions need made
evaluating data acceptable level
course aware encoding details significant impact system performance particularly compiling adl strips cases revert fully
grounded encodings certainly isnt desirable believe acceptable price
pay benefit accessibility current systems ground operators pre process
anyway cases considered compiled domain formulations different
original ones allow fair comparison typically plan length increased significantly
due compilation compiled formulation posed competitors separate domain version
article organized follows main body text contains general information
section give detailed explanation compilation methods used section give
summary domains short application description motivation including
domain brief explanation main simplifications made brief explanation
different domain versions formulations section summarize hoffmanns
helmerts b theoretical structure ipc domains section provide
empirical analysis structural properties section discusses achieved
provides summary main issues left open ipc domains include
separate section appendix providing detailed information application adaptation
ipc domain versions example instances used future directions although
details appendix emphasize secondary importance
contrary describe main body work presentation appendix
seems suitable since expect reader typically examine domains detail
selective non chronological manner
passengers wont get floors origin destination however explicit control
planner choose let someone accurate encoding via conditional effects action
stopping lift floor
detailed account matters provided howe dahlman



fie ngineering b enchmarks



p lanning

pddl compilations
used three kinds compilation methods
adl simple adl strips conditional effects strips
pddl derived predicates pddl without
pddl timed initial literals pddl without
consider compilation methods order explaining compilation
works main difficulties possible solutions giving outline
used compilation competition note adl simple adl strips subsets
pddl compilation methods published elsewhere already see citations
text section serves overview article since coherent summary techniques
behavior practice appeared elsewhere literature
compilations adl simple adl strips
adl constructs compiled away methods first proposed gazen knoblock
suppose given instance constant object set c initial state goal g
operator set operator precondition pre conditional effects e taking form
con e add e del e add e del e lists atoms preconditions effect conditions
g first order logic formulas effect conditions ru e unconditional effects since
domain discourse set constants finite formulas equivalently transformed propositional logic
quantifiers turned conjunctionsvand disjunctions simply expanding
w
available objects x x turns cc c x x turns cc c iterate
quantifiers left
since strips allows conjunctions positive atoms transformations necessary
formulas brought negation normal form turns
turns iterate negation front atoms
x occurs formula introduce predicate x set x iff
x effects e set x add e iff x del e x del e iff x add e
formulas replace x x iterate negations left
transform formulas dnf turns
iterate conjunctions occur disjunctions
operator precondition pre n disjuncts create n copies one
disjunct precondition effect condition con e n disjuncts create n
copies e one disjunct condition g n disjuncts introduce
fact goal reached set g goal reached create n operators one
disjunct precondition single unconditional effect adding goal reached



fih offmann e delkamp hi ebaux e nglert l iporace r ug

action move
parameters
airplane airplanetype direction segment direction
precondition
type moving facing move
move dir segment
exists airplane blocked
forall segment imply blocked occupied
effect
occupied blocked occupied segment segment
blocked blocked
facing facing
forall segment blocked blocked
forall segment
blocked blocked
blocked

figure operator airport ground traffic control
illustrative example consider operator description figure taken domain
encoding airport ground traffic control operator moves airplane one airport segment
another consider specifically precondition formula exists airplane
blocked saying airplane different allowed block segment
segment moving say set airplanes step
turn formula blocked blocked
step yields blocked blocked
step yields blocked blocked step
finally naively transform blocked
blocked e mathematically notated


x
x

blocked blocked

words transforming formula dnf requires enumerating n vectors atoms
vector position selected one two possible atoms regarding airplane ai
yields exponential blow dnf n disjuncts dnf split single
disjuncts one yielding copy operator
reader noticed exponential blow inherent compilation step
quantifier may expanded c sub formulas k nested quantifiers
expanded c k sub formulas obviously general way around
blow ups deal complex formulas allowed strips practice
however blow ups typically dealt reasonably well thanks relative simplicity
operator descriptions frequent occurrence static predicates explained shortly
quantifiers arent deeply nested figure blow inherent step
matter transformation dnf often example key
successful application compilation practice least far personal experience
goes exploitation static predicates idea described example koehler


fie ngineering b enchmarks



p lanning

hoffmann static predicates arent affected operator effect predicates
easily found truth value fully determined initial state soon fully
instantiated transformation step operator parameters still variables
even knew course static predicate would help us
wouldnt know instantiate however instantiation
operator atoms trivialize true false large dnf collapses
v
single conjunction airplane blocked instantiation
similarly expansion quantifiers often made much easier first instantiating
operator parameters inserting true false static predicate soon
parameters grounded inserting true false often simplifies formulas significantly
information propagated upwards e g disjunction true element becomes
true
assuming compilation succeeded thus far steps processed
strips description conditional effects e actions still conditional effects con e
add e del e con e conjunction atoms subset adl termed
simple adl fahiem bacchus used encoding one versions
elevator domain used ipc e competition choose leave
language necessitating deal conditional effects directly
several existing systems example hoffmann nebel ipp koehler
nebel hoffmann dimopoulos sensible since nebel
proved conditional effects cannot compiled strips without exponential blowup task description linear increase plan length one might suspect
steps exponential blow mostly avoided practice
airport move operator figure provides example effect conditions static
conditional effects disappear completely instantiate parameters another
good reason instantiation prior compilation however conditional effects
disappear many even simple natural domains consider following effect taken
classical briefcaseworld domain
forall

effect says object currently briefcase moves along briefcase
obviously effect condition static outcome operator truly depend
contents briefcase note forall means actually set distinct
conditional effects one object
basically two known methods compile conditional effects away corresponding
two options left open nebels first option enumerate possible
combinations effect outcomes preserves plan length cost exponential blow
description size exponential number different conditional effects single action
consider briefcaseworld operator say object set every
subset k k n complement subset get distinct
operator precondition contains
k k n

effect objects
k k


fih offmann e delkamp hi ebaux e nglert l iporace r ug

words operator applied exactly k briefcase
moves exactly objects since deterministic considered never
uncertainty objects inside briefcase exactly one
operators applied whenever original operator applied compilation method
preserves size nodes form edges state space however wont able
transformation planner wont able deal resulting task n grows beyond say
maximally often real world operators contain distinct conditional effects
alternative method first proposed nebel introduce artificial actions
facts enforce application normal action effect evaluation phase
conditional effects action must tried whose condition satisfied
must applied briefcaseworld example would look follows first
conditional effect gets removed fact evaluate effects inserted add list
fact normal inserted precondition delete list n operators
two object oi one means move along oi means leave oi former
oi precondition latter oi former oi oi
effect evaluate effects precondition fact tried oi
add effect final operator stops evaluation whose precondition
conjunction evaluate effects tried tried whose add effect normal
whose delete effect evaluate effects conditional effects several operators compiled
away method evaluate effects tried oi facts made specific
operator normal remain single fact used operators effect k facts
condition k leave oi actions must created negation one facts
precondition
nebels method increases plan length number distinct conditional effects
operators note benign say effects search
procedure recognizes constructs search space essentially remains
compilation artificial constructs easily deciphered
human necessarily true likely case computer
searches general purpose search procedure example naive forward
search space choice order application conditional effects
could avoided enforcing order yet artificial constructs probably
importantly standard search heuristics unlikely recognize nature constructs
example without delete lists suffices achieve tried tried
later apply conditional effects needed
conclude necessary eliminate conditional effects whenever feasible one
compile conditional effects away first method enumerating effect outcomes
ipc took ffs pre processor implements transformation steps
extended code compiles conditional effects away optionally two described methods call resulting tool adl strips cases domain
version formulated adl used adl strips generate strips formulation domain
version one case version power supply restoration generated simple adl
executables adl strips downloaded ipc web page http ipc icaps conference org
download tool named ground code mips system edelkamp b takes
full syntax pddl hoffmann edelkamp puts grounded representation
use tool ipc since temporal numeric planners pre processing steps implemented



fie ngineering b enchmarks



p lanning

formulation cases one enumerating effect outcomes feasible single exception another version power supply restoration forced use nebels
method details process exceptions use adl strips
domain specific method described sections individual domains appendix
compilations derived predicates
several proposals literature compile derived predicates away certain restrictions form use rest domain description gazen
knoblock garagnani compilation scheme works general proposed
thiebaux hoffmann nebel thiebaux et al proved compilation scheme works general worst case involve exponential
blow domain description size length plans note exponential refers increase plan length description blow unlike
compilation conditional effects discussed makes compilation derived predicates rather difficult task ipc compilation schemes oriented approaches taken
gazen knoblock thiebaux et al used detail
first let us explain derived predicates compilations work
derived predicates predicates affected operators whose truth
value derived set derivation rules rules take form x p x
basic intuition x satisfied instantiation c variable vector x p c
concluded formally semantics derivation rules defined negation
failure starting empty extension instances p c derived fixpoint reached
instances lie outside fixpoint assumed false consider following example
derived trans x edge x exists z edge x z trans z

derivation rule defines transitive closure edges graph typical
application derived predicates example blocksworld naturally formalized
predicate power supply restoration domain transitive closure power
flow paths network electric lines obviously pairs x
transitively connected appear fixpoint negation failure
matters become interesting think derived predicates allowed refer
may used rest task description important distinctions
derived predicate appear antecedent derivation rule derived predicate
appear negated antecedent derivation rule derived predicate appear negated
action precondition goal
derived predicates appear antecedents derivation rules merely
non recursive macros serving syntactic sugar one simply replace derived predicates
definitions derived predicate p appears negated negation normal form
antecedent derivation rule predicate q fixpoints p q computed
interleaved way extension q may differ depending order individual
instances derived say rule p x p x basic predicate rule
q p x q x say objects b current state satisfies
derived predicates recursive cycle free replaced definitions may incure
exponential blow



fih offmann e delkamp hi ebaux e nglert l iporace r ug

computing derived predicates interleaved way may derive p b
q b stop may derive p q b q b p
non monotonic behavior making non trivial define extension b keep
things simple extensions derived predicates must computed every
world state thiebaux et al propose simply order q p compute
p extension first compute q generalized one ends semantics
corresponding stratified logic programs apt blair walker context
ipc e pddl hoffmann edelkamp sake simplicity use negated
derived predicates antecedents derivation rules allowed
whether derived predicates appear negated action preconditions goal makes
difference gazen knoblocks compilation scheme idea scheme
simply replace derivation rules actions rule x p x replaced
operator parameters x precondition x add effect p x actions influence
truth value affect atoms mentioned delete instances p words
actions allow derivation p normal action applied may influence
value p extension p initialized
derived predicates used negated gazen knoblocks compilation
scheme works however say p c contained action precondition compiled
version planner achieve precondition simply applying derivation rule
action adds p c planner choice predicate instances derive
course negation failure semantics reader may point
wonder compile negations away first thereafter use gazen knoblocks
compilation would need inverse derivation rules work
negation failure semantics clear done say example
want define negated version trans x predicate one would tempted
take negation derivation rule antecedent
derived trans x edge x forall z edge x z trans z

work however say every node graph least one adjacent edge starting
empty extension trans x single instantiation derived given
x edge z edge x would
trans z first place
one possible solution difficulties extend gazen knoblocks compilation constructs force planner compute entire extension derived predicates
resuming normal full description dealing arbitrary derivation rules
described thiebaux et al nutshell compilation works follows one
introduces flags saying one normal fixpoint mode normal actions invoke fixpoint mode affect predicates relevant derivation rules fixpoint mode action
applied one conditional effect derivation rule effect condition true
respective derived predicate instance false predicate instance added plus
flag changes made another action tests whether fixpoint changes made
true action resets false changes made false action switches back
normal mode reduce domain strips compilation derived predicates
negations conditional effects must compiled away techniques explained earlier



fie ngineering b enchmarks



p lanning

one would imagine thiebaux et al compilation making use rather complicated constructs tends confuse domain independent search techniques indeed thiebaux
et al report even completely naive explicit treatment derived predicates
performs lot better benchmark domains standard version applied
compiled benchmarks gazen knoblocks compilation makes use less artificial
constructs thus preferable whenever safely applied note however compilations imply potentially exponential blow plan length exponential arity derived
predicates worst case every action affects derivation rules every computation
extension derived predicates go predicates instantiations
situation every pair normal actions planner apply order c
actions maximum arity derived predicate typically small
power supply restoration domain aware features derived predicate
two four namely arguments even plan length increase linear number
objects mean quite significant decrease planner performance
ipc benchmarks derived predicates occur power supply restoration appendix model checking safety properties appendix latter derived
predicates occur negated stefan edelkamp encoded domain version without derived predicates hand method along lines one described gazen knoblock
power supply restoration derived predicates occur negated used variation
method described thiebaux et al cases due increase plan length
considered resulting domain formulation different original formulation directly compared terms planner performance compiled formulations posed
competitors distinct domain versions instead alternative domain version formulations
indeed expected planner ipc much worse compiled encodings
compilations timed initial literals
timed initial literals literals known become true time points pre specified
initial state literals compiled durational pddl relatively easily cost
plan length domain description size blowing linearly number timed initial
literals compilation proposed brought attention fox long halsey
idea use wrapper action must applied action
whose duration occurrence time last timed initial literal planner must apply
sequence literal actions achieve timed initial literals order occurrence
durations time intervals occurrences wrapper action
terminated literal actions longer applied planner forced apply
direct sequence suffices encode desired semantics consider following example
init
work
work
bar open
bar open

encode standard durational pddl wrapper
action wrapper


fih offmann e delkamp hi ebaux e nglert l iporace r ug

parameters
duration duration
condition
start wrapper
effect
start wrapper
start wrapper started
start wrapper active
start literal started
end wrapper active

wrapper ensures one wrapper action executed wrapper started inserted
precondition every normal action thus ensures wrapper started
action executed wrapper active precondition literal actions precisely

action literal
parameters
duration duration
condition
wrapper active
literal started
effect
end literal started
end literal started
end work
action literal
parameters
duration duration
condition
wrapper active
literal started
effect
end literal started
end literal started
end work
end bar open
action literal
parameters
duration duration
condition
wrapper active
literal started
effect
end literal started
end bar open
end literals done



fie ngineering b enchmarks



p lanning

fact literals done made goal planner must actually apply literal actions
note need three actions since two timed initial literals
longer work opening bar scheduled occur time note
nebels compilation conditional effects thiebaux et al
compilation derived predicates compiled encoding likely confusing domain
independent search methods
many ipc domains made use timed initial literals versions encode
kinds time windows see appendix compiled domain versions pure
durational pddl provided resulting encodings additional domain versions
due increase number actions needed plans figured compilation
constructs much change direct comparison indeed derived predicates
planner ipc much worse domain versions compiled way

summary domains
section provide brief summary ipc domains domain provide
short description application motivation inclusion domain brief explanation
main simplifications made ipc brief explanation different domain versions
formulations used ipc proceed alphabetical order
airport
contact person application domain wolfgang hatzack working
application area several years domain adapted ipc jorg hoffmann
sebastian trug
application task control ground traffic airport timed travel routes must
assigned airplanes reach targets inbound outbound traffic
former airplanes must take latter airplanes landed park
main constraint course ensure safety airplanes means avoid
collisions prevent airplanes entering unsafe zones behind large airplanes
engines running optimization criterion minimize summed travel time
surface airport airplanes usually standard routes e routes
airplane must take outbound certain parking area inbound certain runway
reason introducing routes reduce complexity human ground controllers since
significant computer support yet available real airports solving instances optimally
corresponding decision pspace hard without standard routes helmert b
np complete routes standardized hatzack nebel latter case
pure scheduling former case complicated unrealistic airport traffic situations
lead exponentially long solutions see section
motivation main motivation including domain able model
application quite accurately particular generate quite realistic instances fact
able generate instances real airport made possible contact
wolfgang hatzack completed phd application hatzack apart
alternative criterion would minimize summed squared delay airplanes interest
airlines minimizing summed travel time interest airport neither two easily
modelled pddl discuss simplifications



fih offmann e delkamp hi ebaux e nglert l iporace r ug

developing domain specific solutions hatzack nebel developed realistic simulation
tool kindly supplied us purpose generating ipc domain versions test
instances sebastian trug implemented options inside simulator allowed point
time simulation traffic flow output current traffic situation pddl format
simulator included real airports frankfurt zurich munich frankfurt zurich proved
large purposes able devise competition instances munich airport
simplifications make two simplifications first amounts discretization space
location airport making domain amenable pddl style discrete actions
continuous space representation one would need actions continuous choice far
move discretization loses precision believe distort nature
much due amount expected conflicting traffic different points
airport high parking positions relatively easy choose discretization
segments different length precise small enough time second
simplification severe drop original optimization criterion
awkward express current pddl model travel times airplanes one needs access
times plans wait e nothing aware way express
current pddl ipc committee voted introduction additional language
construct look clock since didnt seem relevant anywhere else another option
would introduce explicit waiting actions causes lot trouble similar
continuous space must continuous choice long wait end decided
drop criterion ask planners optimize standard makespan instead
corresponding arrival time last airplane meaning arrival destination
airport ideal reasonable optimization criterion system participating
ipc single exception lpg td gerevini saetti serina able take
account general optimization criteria built ones makespan use
full standard routes thus allowing airplanes choice move use standards
routes particularly regions near runways large airports one thing served
keep large airports manageable pddl encoding planners another thing seems
good compromise exploiting capabilities computers time remaining
close existing practice
versions formulations generated four versions airport domain non temporal
one temporal one temporal one time windows fact planes land
future block certain runways modeled timed initial literals latter version
timed initial literals compiled away versions constraints ensuring airplane safety
modelled adl logical formulas compilation partially grounded strips
provides version alternative formulation domain version one adl formulation
one strips formulation
pipesworld
frederico liporace working application area several years submitted
early domain version workshop competition icaps domain
adapted ipc frederico liporace jorg hoffmann
difficulty arises modelling delay one must compute travel times
makespan means amount time start plan last action stops executing



fie ngineering b enchmarks



p lanning

application task control flow different oil derivatives pipeline
network certain product amounts transported destinations pipeline networks
graphs consisting areas nodes pipes edges pipes differ length
available actions pump liquid ends pipes effect liquid end
pipe gets ejected application rich additional constraints constraints
types products may interface within pipe restricted tankage space areas deadlines
arrival products
motivation main motivation including domain original structure one inserts
something pipe one end something possibly completely different comes pipe
end way changing position one object directly changing
position several objects namely objects inside affected pipeline
case transportation domain aware fact reminiscent complicated
single player games rubiks cube indeed strong interaction objects lead
several subtle phenomena example instances solution must pump liquid
ring pipeline segments cyclic fashion
simplifications severely simplify domain order able solve reasonably
complex instances current planners importantly encoding heavily assuming smallest indivisible unit liquid batch every amount liquid encoding modelled
terms number batches capture continuous nature real application means
one choose batch size trade encoding size accuracy trade
less well behaved one airport choosing segments sizes since unit size cannot
made flexible every batch may pass every pipeline smallest batch governs
discretization pipelines contrast airport segments may vary size
another important simplification used personalized goals e goals referred specific
batch objects rather product amounts serves avoid large disjunctions enumerating
possible combinations individual batches simplifications quite severe indeed
seems unlikely realistic representation pipesworld particular real valued product amounts instead batches could solved efficiently planners without introducing
specialized language constructs sort queue data structure pddl see appendix
versions formulations created six different versions pipesworld four versions
without temporal actions without tankage restrictions respectively one temporal version
without tankage restrictions arrival deadlines goal batches one version identical
last one except timed initial literals compiled away
promela
domain created ipc stefan edelkamp
application task validate properties systems communicating processes often
communication protocols encoded promela language promela process meta language
input language model checker spin holzmann language loosely
dijkstras guarded command language borrowing notation hoares csp language
one important property check detect deadlock states none processes apply
transition example process may blocked trying read data empty
communication channel edelkamp developed automatic translation promela
pddl extended generate competition examples



fih offmann e delkamp hi ebaux e nglert l iporace r ug

motivation main motivation including domain promote make visible important connection model checking model checking clarke
grumberg peled automated formal method basically consists three
phases modeling specification checking first two phases system correctness specification modeled formalism last step automatically checks
model satisfies specification roughly speaking step analyzes state space model
check validity specification especially concurrent systems several components
interact state spaces grow exponentially size components system two
main branches model checking explicit state model checking implemented spin
exploits automata theory stores explored state individually symbolic model checking
describes sets states properties binary decision diagrams bdds efficient
representations boolean formulas
checking validity reachability property property asks system state certain property reachable similar question plan existence use model checking approaches solve explored depth e g cimatti roveri
traverso bertoli cimatti roveri traverso lago pistore traverso
kvarnstrom doherty haslum bacchus kabanza holldobler
stor fourman edelkamp b dierks kabanza thiebaux
however much done inverse direction applying planners model checking
running ipc planners encodings promela specifications first step

promela domain contributes unusual structural properties domain set computational complexity local search topology quite different discussed section
simplifications main simplification make use simple example classes
communicating processes pddl refer fixed length state vectors could
include process construction calls therefore considered active processes e processes
called initialization time pddl support temporally extended
goals consider reachability properties moreover prototypical nature
language compiler many features promela rendezvous communication supported although limited support shared variables competition chose
simple message passing protocols experimented reachability properties pddl goals competition event deadlock detection concretely
ipc instances come two toy examples used area model checking well known
dining philosophers optical telegraph viewed
version dining philosophers philosophers complex inner life exchanging data
two hands separate process goal reach deadlock
state
versions formulations created eight different versions domain differ
promela example class encoded two options whether use numeric variables
encoding whether use derived predicates encoding four encodings
promela example class semantically equivalent sense correspondence plans decided make different versions rather formulations
derived predicates make large difference plan length numeric variables make
large difference applicability systems translation promela



fie ngineering b enchmarks



p lanning

pddl makes use adl constructs domain version contains one adl formulation
one fully grounded compiled strips formulation
psr
sylvie thiebaux others worked application domain domain adapted
ipc sylvie thiebaux jorg hoffmann
application task psr power supply restoration reconfigure faulty power distribution network resupply customers affected faults network consists electric
lines connected switches fed via number power sources equipped circuitbreakers faults occur circuit breakers sources feeding faulty lines open
protect network leaving lines many healthy ones un supplied network needs reconfigured opening closing switches circuit breakers way
resupply healthy portions unreliable fault sensors switches lead uncertainty
state network furthermore breakdown costs depend parameters need
optimized constraints capacity sources lines application topic ongoing interest field power distribution investigated ai community
long time including ai standpoint thiebaux cordier jehl krivine
thiebaux cordier bertoli cimatti slaney thiebaux bonet thiebaux
motivation motivation including psr twofold first well researched interesting
application domain second original structure rarely found previous benchmarks
natural encoding power propagation recursive derived predicates compute transitive closure connectivity relation network contrast
benchmarks number actions needed optimal plan necessarily grow
instance size available actions alter position switches even large
network altering position switches may suffice reconfiguration difficult
question answer switches
simplifications three major simplifications made first deterministic
assume network state fully observable e initial state description
complete actions succeed second ignored numerical optimization
aspects psr third used personalized goals sense lines supplied named
explicitly goal note even simplified form domain exhibits structure
explained
versions formulations created four domain versions differing primarily size
available formulations natural domain formulation adl derived predicates
though experimented many combinations pddl encodings compilation strategies
size instances could compile simpler languages quite restricted precisely
versions large version adl plus derived predicates middle version
could devise simple adl plus derived predicates strips plus derived predicates
middle compiled version adl identical middle version except derived
predicates compiled away small version pure strips instances latter
domain version particularly small since extremely difficult come
encoding pure strips yield prohibitively long plans prohibitively large
pddl descriptions fact obtain small version applied pre computation step bertoli
et al obviates need reasoning power propagation consequently



fih offmann e delkamp hi ebaux e nglert l iporace r ug

need derived predicates resulting tasks opening closing switch directly without
detour power propagation affects parts network thus planner longer needs
compute flow power network left issue configure
flow
satellite
domain introduced long fox ipc adapted ipc jorg
hoffmann domain comes nasa space application satellites take images
spatial phenomena motivation inclusion ipc domain applicationoriented similar sense domains wanted immediate comparison performance achieved ipc achieved ipc top domain
versions used ipc added versions introducing additional time windows formulated
alternatively timed initial literals compilation sending data earth
settlers
domain introduced long fox ipc task build
infrastructure unsettled area involving building housing railway tracks sawmills etc
distinguishing feature domain domain semantics encoded numeric variables makes domain important benchmark numeric
reason ipc participant could solve smallest instances included
domain ipc modification made except compiled away universally
quantified preconditions order improve accessibility
umts
roman englert working application area several years domain adapted
ipc stefan edelkamp roman englert
application third generation mobile communication called umts holma
toskala makes available broad variety applications mobile terminals
comes challenge maintain several applications one terminal first due limited resources radio bearers restrictions quality service qos applications second
cell setup execution several mobile applications may lead unacceptable waiting periods
user third qos may insufficient call setup case execution
mobile application shut thus arises call setup several mobile applications main requirement course setup minimum possible amount
time pure scheduling necessitates ordering optimizing execution
modules needed setup many scheduling finding necessarily
optimal solution trivial main challenge good quality solutions optimal ones ideally
motivation main motivation modelling pure scheduling domain
strong industrial need flexible solution procedures umts call setup
due rapidly evolving nature domain particularly sorts mobile applications
available ideal solution would put automatic planner mobile device
let compute optimized schedules fly sense umts call setup
natural promising field real world application automatic planners interesting



fie ngineering b enchmarks



p lanning

sense scheduling far central competitive ai
domain serves advertise usefulness pddl addressing certain kinds scheduling

simplifications setup model chose considers coarse parts network environment
present umts applications invoked action duration fixed rather computed
network traffic inter operational restrictions different concurrent devices
neglected considered plausible timings instances rather real application
data running certain applications umts device designed domain
applications single device challenge optimal planners computing minimum
makespan solutions much challenge satisficing planners
versions formulations created six domain versions arise two groups
three versions first group standard umts domain comes without timing
constraints latter represented timed initial literals compilation
separated two options different domain versions rather domain version
formulations due increase plan size second group domain versions similar
structure difference three domain versions includes additional flaw
action single step action achieves one needed fact normally several steps
required however action useless reality deletes another fact needed
cannot achieved flaw action added see happens intentionally
stressed planners beside increasing branching factor flaw action look useful
perspective heuristic function ignores delete lists

known theoretical domain structure
section start structural analysis ipc domains summarizing known
literature helmert b analyzes domains perspective domainspecific computational complexity hoffmann analyzes domains used ipcs far
plus standard benchmarks literature identifying topological properties search
space surface relaxed plan heuristic introduced system hoffmann
nebel variants used many modern systems studies
exclusively concerned purely propositional non temporal strips adl
follows domain names refer respective non temporal domain versions
computational complexity
helmert b studied complexity plan existence bounded plan existence
ipc benchmark plan existence asks whether given task solvable bounded
plan existence asks whether given task solvable given number
actions helmert established following
airport plan existence bounded plan existence pspace complete even
aircraft inbound need taxi park goal location map planar
symmetric safety constraints simply prevent planes occupying adjacent segments
umts domain temporal versions treated studies computational
complexity easy see deciding plan existence p deciding bounded plan existence optimizing
makespan np complete umts topological properties relaxed plan heuristic havent yet defined
temporal setting



fih offmann e delkamp hi ebaux e nglert l iporace r ug

proof reduction sliding tokens puzzle set tokens must reach goal
assignment vertices graph moving adjacent vertices ensuring two
tokens ever adjacent vertices length optimal sequential plans
exponential number tokens likewise airport domain even parallel plans
shorter linear amount since plane move per time step proof
sliding tokens puzzle quite complicated involves construction instances
exponentially long optimal plans one would expect constructions used
unlikely occur real airport particular true necessary density conflicting
traffic graph structure consider interesting since makes airport benchmark
extremely high worst case complexity much good natured typical case
behavior typically ample space airport comparatively airplanes moving
across
pipesworld whether without tankage plan existence bounded plan existence np hard unknown whether np however np hardness proof
reduction sat four literals per clause variable occurs
clauses sat instance reduced network way parts network variable subnetworks represent choice assignment variables parts
clause subnetworks represent satisfaction clauses content areas pipes
initialized batches way interface restrictions guarantee goal area
reached certain batch clause subnetwork iff clause satisfied assignment
general promela defined edelkamp plan existence bounded
plan existence pspace complete pspace hardness proof reduction halting space restricted turing machines tm cells machines tape
mapped onto process queue unit capacity states tm form set promela
messages tms alphabet form set promela states processes promela transitions encode tms transitions shown tm halts iff promela task reaches
deadlock
dining philosophers hand particular structure one process per
philosopher transition graph optimal plans generated linear time
number philosophers making constant number transitions reach known state
graphs similar considerations apply optical telegraph
psr tasks solved optimally polynomial time requires rather complex
plans start wait action opens circuit breakers affected fault
simplest form optimal plans follow prescribing series actions opening switches
connecting feedable line faulty one necessary sufficient ensure
network safe state faulty line supplied minimal set devices
disjoint previous one must closed resupply rest network
achieved generating minimal spanning tree healthy part network
done polynomial time
figure gives overview summarizes helmerts
standard benchmarks domain set displayed set investigated hoffmann
minor differences explained shortly blocksworld arm briefcaseworld ferry fridge
simple tsp tireworld traditional benchmarks never used ipc
blocksworld arm version blocksworld blocks moved directly destination without
referring robot arm simple tsp used fox long demonstrate potential symmetry



fifor

p lanning

pspace

e ngineering b enchmarks

promela
airport

p

plan existence

np

pipesworld
mystery
mprime
miconicadl
freecell

tireworld
simpletsp
schedule
psr
opticaltelegraph
movie
gripper
fridge
ferry
diningphil

zenotravel
satellite
rovers
miconicstrips
miconicsimple
logistics
grid
driverlog
depots
briefcaseworld
blocksworldnoarm
blocksworldarm

p

np

pspace

bounded plan existence

figure overview helmerts computational complexity benchmarks
ipc benchmarks assembly grid gripper logistics movie mprime mystery
ipc benchmarks blocksworld arm freecell logistics miconic adl miconic simple
miconic strips miconic schindler lifts name elevator domain schedule
ipc benchmarks depots driverlog freecell rovers satellite zenotravel ipc
benchmarks displayed bold face including hypothetical general promela domain
table figure organized along two axes x axis shows complexity
deciding bounded plan existence axis shows complexity deciding unbounded plan
existence membership table entry means np pspace rows columns
respective complete respective complexity class exception pipesworld
domain stated still unknown whether two decision
members np assembly domain displayed since helmert proved
existence exponentially long optimal plans showing plan generation quite hard
domain table sectors diagonal crossed unbounded plan existence
polynomially reduced bounded plan existence set bound n n
number distinct actions adl number distinct conditional effects
striking feature ipc introduction pspace complete benchmark
domains filling top right corner figure thus benchmarks cover four inhabited
sectors table previous ipcs ipc ipc cover three sectors inhabited
detection one simply visit n nodes move action applied two nodes
permutation nodes optimal tour hoffmann investigates towers hanoi domain



fih offmann e delkamp hi ebaux e nglert l iporace r ug

sectors except top right corner ipc benchmarks cover two sectors namely
bounded plan existence np complete domains domains except freecell
polynomial time deciding unbounded plan existence
ipc benchmarks exceptional aspects visible figure particularly explained polynomial decision psr highly non obvious
benchmarks important since one hand principle allow planners provide efficient solutions hand necessitating employ interesting techniques
schedule polynomial benchmark bounded plan generation
requires non obvious domains left bottom middle bottom
sectors table polynomial deciding bounded unbounded plan existence
completely trivial mostly addressing one subgoal time
pointed already final exception lies extraordinarily large difference
worst case typical case behavior airport see section even fully automated
methods ipc planners least unbounded plan existence generation quite efficient
typical instances domain large differences worst case typical case
behavior unusual believe extent phenomenon airport really unusual
example planners tend psr much harder airport
topology h
hoffmann considers state spaces forward search spaces strips adl tasks
taken standard benchmark domains defines given task world state h
length shortest possible relaxed plan relaxed plan relaxed plan
plan achieves goal one assumes delete lists empty computing
h corresponding decision np hard bylander many modern planners
e g hsp bonet geffner hoffmann nebel sgplan wah chen
chen hsu wah yahsp vidal fast diagonally downward helmert
interpreted sort heuristic search approximation h plus
techniques decomposition wah chen lookahead techniques vidal
additional different heuristic functions helmert context question
great practical interest quality underlying heuristic function addressed domains
heuristic quality measured terms topological properties search space surface
many local minima large flat regions hoffmann
investigates questions h function topological properties search space
surface proven
hoffmann defines topological phenomena following frank cheeseman stutz
identifies several parameters particularly interesting behavior benchmarks
dead end world state reachable initial state goal state cannot
reached unrecognized dead end dead end h exit distance
state length shortest path state space leading state
h h direct neighbor state h h
exit distance number steps need go order better state
helmerts words think domains solved polynomial time polynomial
obvious extraordinarily interesting deterministic psr definitely domain kind
regard optimization np hard cannot solved without strong reliance search polynomial
planners capture important concepts



fie ngineering b enchmarks



p lanning

minus since distance measured plays role exit state used
frank et al state lies local minimum paths exit temporary increase
heuristic value otherwise state lies bench maximal local minimum exit distance
mlmed state space maximum exit distances states lying local minima
state space similarly maximal bench exit distance mbed maximum exit
distances states lying benches core hoffmanns investigation
displayed figure

blocksworldarm
depots
driverlog

pipesworld
psr

rovers
opticaltelegraph

mystery
mprime
miconicadl
freecell
assembly
airport

mbed c

mlmed c

hanoi
blocksworldnoarm
fridge
briefcaseworld
grid

logistics
ferry
gripper
undirected

tireworld
satellite
zenotravel
miconicsimple
miconicstrips
movie
simpletsp
harmless

diningphil
schedule

recognized

unrecognized

figure overview hoffmanns topology h benchmarks
x axis figure corresponds properties regarding dead ends axis corresponds
properties regarding exit distance local minima benches domains assigned
appropriate table sectors classes domains depending worst case behavior possible
detail meaning table following state space undirected
every transition action directly inverted state space harmless inversion
possible dead ends anyway recognized means dead ends
h unrecognized means least one unrecognized dead end
domain falls class worst case instance example single instance whose
state space contains single unrecognized dead end domain considered unrecognized
proved e domain example considered harmless means
provably instance domain contains dead ends
axis figure distinction lines correspond existence non existence
constant upper bounds maximal local minimum exit distance upper line maximal
bench exit distance lower line note constant upper bounds maximal local minimum
exit distance exist domains upper line domains lower line
bounds exist constant meant bound valid every instance
presentation assumes domains bounded bench exit distance subset bounded
local minimum exit distance true general hold considered benchmark domains



fih offmann e delkamp hi ebaux e nglert l iporace r ug

domain regardless size actual bounds proved displayed brackets local minimum
bound precedes bench bound cases right bottom part table
crossed since unrecognized dead ends infinite exit distance domain classes
empty
obvious intuition behind figure transition easy hard
systems heuristic search approximating h one moves left bottom
side top right side table indeed table sense coincide well
empirical behavior least system note extreme topological behavior
many domains upper bound local minimum exit distance means
local minima case investigated domains several
domains widely used logistics benchmark top single step suffices reach
exit benches hoffmann shows would polynomial bottom classes
table provided oracle computing h
considering table perspective benchmark development one notices particularly older benchmarks tend lie left bottom side consider example ferry briefcaseworld fridge simple tsp tireworld distribution ipc benchmarks gripper
logistics movie grid assembly mystery mprime somewhat extreme first four
list belong simple classes last three belong hardest class today
mystery mprime domains amongst causing planners trouble
ipc benchmarks logistics blocksworld arm miconic strips miconic simple schedule
freecell miconic adl many simple challenging domains
notable exceptions respect blocksworld arm left top side table
schedule contain dead ends local minima ipc benchmarks distribution starts get varied domains zenotravel satellite depots driverlog rovers
freecell span three four top classes table plus one bottom classes
ipc domains shown bold face obviously continue development two
sharing class pipesworld psr continue emphasis spanning top classes
table domain one bottom classes dining philosophers
highly exceptional exceedingly large bound making bound practically useless
exploitation satellite domain adopted ipc benchmarks serves
represent interesting instance easier classes note satellite simple
talking strips version drops challenging constraints formulated numeric variables airport domain exceptional top right class
worst case place figure differs lot typical case dead
end airport situation two airplanes completely block others paths course
practical airports designed way doesnt usually happen mentioned earlier
usually non overlapping far possible standard routes place
blocking occur densely populated areas near parking positions
one could skip unrecognized dead ends definition maximum exit distances hoffmann
argues un intuitive plus making things unnecessarily complicated
actually pipesworld invertible sense every two step sequence starting ending pumping operation
directly undone considered harmless since single actions cannot inverted
indeed h bad heuristic dining philosophers basically comes counting number
unsatisfied goals
relaxed plan use free space planes make move across



fie ngineering b enchmarks



p lanning

empirical domain structure
provide empirical analysis structural parameters ipc domains
sake readability conciseness focus non temporal domain versions
types data measure temporal domain versions quite similar
extent visible tables showing numbers actions facts domain versions
individual domain descriptions appendix
empirical analysis aimed highlighting characteristics differences ipc domains apart focussing practical parameters analysis
compared theoretical cited previous section big advantage tells us
something actual instances run competition note choice instances
make huge difference example stated earlier real world airport likely
exponentially long plans neither likely provoke many dead end situations possible instances used ipc chosen relatively realistic details appendix
analysis structured three sub sections section shows individual
domains size grounded encoding grows instance size section assesses
correspondence quality standard heuristic functions runtime achieved
ipc section finally assesses fact connectivity instance size meaning number
choices one achieve fact number actions fact required
encoding size
current strips adl planners far authors aware ground parameters
variables pre process ending task representation consisting ground facts
ground actions obvious question ask large grounded encodings figure
shows data numbers facts actions plotted instance size selected versions
different domains numbers measured ffs pre processor filters static facts
facts added deleted action unreachable actions meaning actions
appear relaxed graph graph without mutex reasoning initial
state hoffmann nebel formulas compiled simple strips conjunctions
facts along lines gazen knoblock outlined section


e
airport
pipesworld
dining philosophers
optical telegraph
psr small
psr large
satellite
umts



airport
pipesworld
dining philosophers
optical telegraph
psr small
psr large
satellite
umts



nr actions

nr facts






















nr instance



















nr instance










b
figure numbers ground facts b ground actions plotted instance number
selected versions ipc domains


fih offmann e delkamp hi ebaux e nglert l iporace r ug

cases except umts temporal versions domain version selected
figure non temporal let us consider domains one one airport one
non temporal version plots figure b us quite nicely instances
scaled sharp drops curves corresponding steps underlying airport precisely
instances growing airports respectively
within airport number travelling airplanes grows
instance example instance instance step one half munich airport
airplanes full munich airport airplanes
pipesworld two non temporal versions without tankage restrictions figure shows data former challenging one ipc planners fared much
worse without tankage restrictions slightly fewer facts factor fewer actions pipesworld instances scaled similar way airport ones five
growing pipeline networks feature growing number travelling liquid batches networks underlie instances respectively
corresponding drops observed stepping instance less significantly
stepping major difference airport visible
much crippled nature featuring much variance curve number actions
airport objects move big spacious structure pipesworld
many objects move within rather dense space fundamental difference airport
pipesworld manifests order curves reversed numbers facts
actions airport extraordinarily many facts required describe huge airport structure
pipesworld fewer facts smaller structure many actions describing
things move along structure stated earlier pipesworld different objects affect
others position moving
promela domains dining philosophers optical telegraph data domain
versions without derived predicates identical derivation rule deriving fact
counted action achieving fact main difference seen lies
extremely smooth scaling domains single size parameter numbers
ground facts actions grow linear functions parameter functions optical telegraph order magnitude higher dining philosophers curves
optical telegraph stop instance able compute grounded
representation much time memory needed simplification precondition formulas note artifact data presentation rather constitutes serious
limitation planner tries perform pre processing
psr interesting domain versions small since could formulated
strips large since goes instances realistic size largest instances
name small suggests numbers quite small able compile strips
indicated earlier make instances small essentially compilation
visible curves large huge number ground facts actions
relatively early instances already curves stop instance beyond simplifying
much objects cannot move affects number ground actions due mentioned filtering
unreachable actions
notable exception instance nr number actions peaks due exceedingly complex goal formula disjuncts dnf yields extra goal achievement action
c f section



fie ngineering b enchmarks



p lanning

formulas becomes extremely costly versions note high degree variance
numbers facts actions somewhat corresponds huge degree variance
observed planner performance domain see figure part variance least
pace oscillations amplitude explained way instances
scaled given number sources instance size generated instances increasing
minimal number switches originally fed given source given number switches
generated instances increasing percentage faulty lines ranging
intuitively larger number switches per source larger harder expect instance
furthermore percentage faulty lines tends induce easy hard easy pattern
lines faulty small part network resupplied devices need
switched similarly faulty lines exist network resupplied
switching operations intermediate percentage effects actions become
complex conditioned positions many switches instances
become critically constrained harder solve
satellite main observation made extremely steep ascent curves
instance particularly growth extremely high numbers actions two reasons
first one action satellite take image parameters reachable almost
combination objects correct types time actions parameters
second size instances grows sharply beyond instance simply
instances used ipc correspond instances posed ipc
challenge hand tailored planners
consider settlers ease readability graphs since domain
quite obviously exceptional anyway relies almost completely numeric variables
umts figure shows data plain domain version without time windows flaw action
obvious characteristic numbers facts actions constants true
domain versions numbers vary slightly reason way umts instances
scaled every instance describes applications requirements changes
goal specifying applications actually need set independent effect
particular scaling method used observe numbers facts actions relatively
low around even largest instances applications must set
plans contain actions
quality heuristics runtime
section measure length best sequential parallel plans found
planner sequential parallel plan length estimates returned common heuristic
functions runtime taken planners precisely optimal planners measure
optimal makespan found ipc parallel optimal planners planners optimizing
makespan
length standard plan graph blum furst e index first plan
graph layer contains goals without mutexes
best runtime taken parallel optimal planner ipc
optimal sequential plan length found ipc sequential optimal planners


fih offmann e delkamp hi ebaux e nglert l iporace r ug

length serialized plan graph pair non noop actions made mutex
best runtime taken sequential optimal planner ipc
satisficing planners measure
best shortest plan length found planner ipc
length relaxed plan initial state action sequence solves task one
assumes delete lists empty computed hoffmann nebel
best runtime taken satisficing planner ipc
main goal identify characteristic behavior domains identify characteristic
effects heuristic quality performance reader note selection measurements make several simplifying assumptions optimal planners exclusively
plan graph estimates satisficing planners exclusively relaxed plan estimates satisficing planners minimize makespan sequential plan length chose
take account latter since potentially estimating non admissible heuristic
specifically estimating parallel plan length best knowledge satisficing planners
minimizing makespan actually use heuristic estimating number remaining actions employ method greedily arrange chosen actions parallel plan said
wish imply simplifying assumptions safe sense lose important
information simplifying assumptions necessary make analysis presentation
feasible data definitely capture many crucial aspects ipc heuristic quality
planner runtime data individual domains proceeding alphabetical order
ipc runtime obtained linux machine running two pentium cpus ghz
gb main memory time memory cutoffs minutes gb per instance
consider figure showing data airport domain note axis two different
meanings runtime left hand side number parallel sequential plan steps
right hand side applies figures sub section airport observe
clear correlation quality plan length estimation runtime optimal parallel
planners figure best observed instances nr difference
makespan estimate plan graph grows grows achieved runtime
exponential scale may look counter example instance nr plan
graph estimate exact coincides real makespan runtime get lower
note however instance much larger airport previous instances
instance onwards instances solved parallel planner exact plan graph
estimate optimal sequential planners figure b get similar behavior
instances nr behavior strong instances nr plan
length grows lot serial plan graph becomes little shorter correspondingly
runtime goes two orders magnitude true instances
satisficing planners figure c striking observation length
real plan coincides instances exactly length relaxed plan respective
initial state actually quite easy explain optimal plan moves airplanes way
never block paths plan optimal even ignoring delete lists
moving airplanes without blocking possible start situation changes


fie ngineering b enchmarks







p lanning





optimal makespan
plangraph
best parallel runtime

optimal nractions
serialplangraph
best sequential runtime


















nr steps



runtime sec





nr steps

runtime sec




















































nr instance

nr instance



b













best nractions
relaxedplan
best runtime












nr steps

runtime sec






























nr instance

c
figure airport domain plots parallel plan length heuristic estimation runtime
optimal parallel planners b optimal sequential planners c satisficing planners
wrong decision made additional moves become necessary reality
without delete lists avoid blocking situation apart figure shows quite nicely
runtime taken corresponds closely length plan found note latter
huge largest instance
pipesworld domain two non temporal domain versions without tankage
restrictions e restrictions amount liquid stored network areas
figure shows data version without restrictions observations made
domain version similar except sorts planners scale much worse thus providing
us less data optimal planners figure b striking difference
airport domain figure b quality even parallel plan graph heuristic
bad underestimates real makespan much larger extent airport
underestimation grows instance size naturally runtime grows well note
planners fail scale much earlier figure b one slight exception
rule poorer heuristic estimate leads longer runtime instance number
optimal sequential plan length grows length serial plan graph remains
runtime drops secs



fih offmann e delkamp hi ebaux e nglert l iporace r ug









optimal makespan
plangraph
best parallel runtime

optimal nractions
serialplangraph
best sequential runtime


















nr steps



runtime sec





nr steps

runtime sec




















































nr instance

nr instance



b













best nractions
relaxedplan
best runtime







nr steps

runtime sec
































nr instance

c
figure pipesworld domain without tankage restrictions plots parallel plan length heuristic estimation runtime optimal parallel planners b optimal sequential planners c satisficing planners
similarly situation optimal planners satisficing planners figure c
main difference figure c much worse quality heuristic function
relaxed plan length differs greatly length real plans found particularly
larger instances curiously despite worse quality heuristic runtimes much
lower longest time taken instance seconds goes first
shortcomings analysis give heuristic quality initial state may
differ lot situation rest state space example airport planner
relaxed plans may get lost huge dead ends wrong decision made early second
course techniques satisficing planners use relevant runtime data
figure b exclusively due sgplan wah chen yahsp vidal whose
decomposition greedy lookahead techniques appear work extremely well domain
satisficing planners perform much worse failing solve largest instances note
pipesworld overall runtime curves planners characteristically jagged
considerable variance comparison e g airport information gets lost
best presentation chosen figures seems hardness domain comes



fie ngineering b enchmarks



p lanning

interactions subtle seen rather high level parameters measured reiterate domain version tankage restrictions much challenging planners
planner getting anywhere close largest instances yahsp








optimal makespan
plangraph
best parallel runtime
optimal nractions
serialplangraph
best sequential runtime



best nractions
relaxedplan
best runtime










nr steps

runtime sec


nr steps

runtime sec


































nr instance

















nr instance


b
figure dining philosophers domain without derived predicates plots parallel plan length
heuristic estimation runtime optimal planners b satisficing planners
figure shows data promela dining philosophers without derived predicates
two separate figures optimal planners since curves quite easy read even
quick glance one sees domain characteristic behavior different
domains optimal makespan plan graph length serial plan graph length constant
across instance size contrast optimal sequential plan length grows linear function
size note logarithmic scale right hand side axis figure use
make figure values plan step measures readable best plans found
satisficing planners optimal e nractions data identical sides
figure figure see effect heuristic quality search performance
parallel planners scale linear function instance size sequential planners
heuristic function becomes worse worse scale highly exponentially latter might
true satisficing planners bit hard tell since solved instances solved
extremely quickly reason instance index higher solved
instances similarly discussed section simplifying precondition formulas
became prohibitively costly instances available adl two satisficing
planners scaled well dining philosophers without derived predicates sgplan
yahsp neither could handle adl formulation domain similarly
optimal planners satplan optiplan scaled well neither could handle
adl formulation note inability planners handle formulas without pre simplification
techniques thus constitutes serious limitation
optical telegraph without derived predicates figure shown observations similar
ones figure except planners scale much worse particularly optimal
sequential planners solve single smallest instance best satisficing runtime clearly
exponential instance size taking seconds solve instance number promela
domain versions derived predicates optimal planners since none
could handle derived predicates observations satisficing planners similar


fih offmann e delkamp hi ebaux e nglert l iporace r ug

nractions grows linear function instance size relaxed plan length grows
linear function significantly lower gradient planners fast dining philosophers
need lot time sec solve largest optical telegraph instances
remain unsolved omit promela domain versions numeric variables
since two planners participated domain versions








optimal makespan
plangraph
best parallel runtime

optimal nractions
serialplangraph
best sequential runtime





















nr steps



runtime sec



nr steps

runtime sec















































nr instance













nr instance



b




best nractions
relaxedplan
best runtime




best nractions
relaxedplan
best runtime








nr steps

runtime sec










nr steps




runtime sec






































nr instance



















nr instance

c

figure psr domain plots parallel plan length heuristic estimation runtime
parallel optimal planners psr small strips version b sequential optimal planners psr small c satisficing planners psr small satisficing planners
psr large featuring adl derived predicates
figure shows psr domain figure b c plots domain version psr small comes pure strips addressed ipc planners
figure shows plots psr large comes adl derived predicates
addressed four satisficing planners data psr middle compiled
psr middle former two satisficing planners participated latter six satisficing
planners participated scaled quite well less challenging instances
less interesting psr large



fie ngineering b enchmarks



p lanning

first note curves psr small large amount zig zagging quite
unusual cannot simply accounted way instances scaled consider
figure main observation made real optimal makespan much larger
estimation plan graph particularly larger instances still optimal parallel planners
quite efficient least solve instances runtime data entirely due
satplan whose search techniques apparently quite efficient domain even
bad plan graph lower bound optimal planners least one order magnitude
slower cant solve largest instances example none solve instances
optimal sequential planners figure b pretty similar except
runtime scaling somewhat worse kinds optimal planners runtime clearly
correlated length optimal plans since plan graph bounds almost
constant coincides difference real plan length estimate
figure c observe relaxed plan bad estimator plan length psr
small least respective initial states planners solve instances quite efficiently anyway runtime data entirely due yahsp fast downward particularly
fast downward extremely efficient showing slight increase runtime instance
size satisficing planner capable solving instances note yahsp
vidal uses powerful techniques besides relaxed plan heuristic fast downward
helmert uses involved apparently powerful case heuristic function note least terms solved instances optimal satisficing planners
unusually equally good bad domain exactly one group solves instances
planners cannot solve instances difficulty planners experiencing
domain remarkable since instances least grounded encodings actually
small compared instances domains c f figure indicates
domain fundamental characteristic yet captured well search
heuristics techniques planners nicely complements said
non obvious polynomial psr section
figure see relaxed plan computed version handling derived
predicates see thiebaux et al rather useless estimator psr domain
expressed natural way adl derived predicates relaxed plan constantly
contains steps meaning approximation semantics derived predicates makes
initial state look goal state happens psr middle situation may
different parts state space heuristic value constantly apparently
causes serious trouble satisficing planners except fast downward planner except fast
downward solve instance higher number fast downward seems profit
involved heuristic function reaching scaling limit instance number
satellite domain many temporal numeric domain versions select
presentation single pure strips version figure b observe
pipesworld promela unlike airport psr satellite domain serial
plan graph provides much worse heuristic values sequential parallel
graph parallel instances solved optimal planners parallel plan
length serial parallel plan graph length grow much sequential plan length
consequently sequentially optimal planners scale much worse parallel ones
true runtime curves individual planners fact planners even disagree widely
instances solved easily take lot time



fih offmann e delkamp hi ebaux e nglert l iporace r ug









optimal makespan
plangraph
best parallel runtime

optimal nractions
serialplangraph
best sequential runtime











nr steps

runtime sec



nr steps

runtime sec















































nr instance

nr instance



b









best nractions
relaxedplan
best runtime











nr steps

runtime sec

























nr instance

c
figure satellite domain plots parallel plan length heuristic estimation runtime
optimal parallel planners b optimal sequential planners c satisficing planners
figure nicely see instances parallel plan length
movement constant parallel plan graph length resulting
movement pretty much shape logarithmic scale best parallel runtime
figure c observe airport unlike domains
relaxed plans initial states almost length real plans actually
slight estimation time seen earlier c f section hoffmann
shown satellite relaxed plan length fact bound close real plan
length states contrast airport unrecognized dead ends possible principle
indeed satellite easy tackle almost satisficing planners ipc
runtime shown figure c appears non trivial remember instances huge see
particular number ground actions figure b instance satisficing ipc
planners could solve instance within minute
skip settlers domain since relies almost exclusively numeric variables encode
domain semantics makes rather incomparable domains figure shows
data umts domain temporal numeric versions half feature
time windows consider versions without time windows figure b concern



fie ngineering b enchmarks




optimal makespan
plangraph
best parallel runtime






best nractions
relaxedplan
best runtime





p lanning















nr steps



runtime sec



temporal makespan

runtime sec















































nr instance













nr instance



b




optimal makespan
plangraph
best parallel runtime




best nractions
relaxedplan
best runtime


















nr steps



runtime sec



temporal makespan

runtime sec




























nr instance






















nr instance









c

figure umts domain plots durational plan length heuristic estimation runtime
optimal b satisficing planners plain temporal version c optimal satisficing planners temporal version flaw action
plain domain version figure c flaw action let us first consider optimal
planners left hand side overall figure optimal planners could tackle
domain e domains syntax tp hspa haslum geffner
makespan minimizing planners data sequentially optimal planners
wouldnt make lot sense temporal setting anyway plangraph curves figure
c correspond makespan estimation delivered initial state tp temporal
numeric extension heuristic effect heuristic quality runtime observe
strong correlation figure instance makespan estimate
close real makespan time two actually coincide runtimes
good starting instance real makespan makes sudden leap upwards
followed estimation runtimes shoot upwards phenomenon clear
instances makespan estimation exhibits good bad good pattern
runtime figure c sort behavior observed
meaning particular flaw action effect makespan estimation
tp fact makespan estimation exactly instances solved
domain versions contained implicitly latter sentence flaw action affect runtime



fih offmann e delkamp hi ebaux e nglert l iporace r ug

set solved instances runtime flaw action consistently
factor larger without flaw action challenging instances planners fail
flaw action present decrease performance presumably due larger state
space incurred flaw action
consider satisficing planners figure b first observe
facing individual characteristic behavior domain challenge
satisficing planners latter shows domain useful benchmark satisficing
planners shows heterogeneous benchmark set common
satisficing planners faster optimal ones except psr domain
picture extreme umts stated earlier domain pure scheduling
obviously satisficing planners provide runtime efficient greedy solutions
looking plots little detail figure b sequential plan length
plans found optimal simple stepwise linear function instances relaxed plan
length initial state coincides real plan length isnt surprise given
excellent runtimes satisficing planners fact scheduling domain
sequentialized schedule harmful delete effects occur picture changes lot figure
real plan length stays basically increased constant relaxed plan
length becomes lot shorter due flaw action satisficing planners unaffected largely
keeping excellent runtime behavior apparently planners incorporate technique
recognizing uselessness flaw action done simple domain analysis
techniques getting rid influence suspicion confirmed fact one
satisficing planner get affected flaw action way one expect crikey
heuristic search forward state space planner relaxed plan heuristic solves task within
seconds without flaw action sometimes takes seconds flaw action
let us briefly summarize overall observations
presented data time performance planners correlates well
quality relevant heuristic function notable exceptions rule far
observed data fast downward psr large relaxed plans
pretty much devoid information sgplan yahsp extent fast
downward pipesworld relaxed plans provide poor estimates planners
experience much serious difficulties
usually known benchmarks general satisficing planners several orders
magnitude faster optimal ones exceptions psr groups perform
almost equally umts satisficing planners hardly need time
usually known benchmarks general parallel plan graph length much
better estimator parallel plan length serial plan graph length sequential plan
length exceptions airport often huge difference
lengths two kinds plan graphs extent psr small
difference parallel sequential plan length big note none
domains purely sequential e parallelism possible
terms quality solutions found satisficing planners reasonably well example lpg td
minimizes makespan domain finds version optimized speed plans take maximally
time optimal ones found tp version lpg td optimized plan quality goes




fie ngineering b enchmarks



p lanning

usually known benchmarks general considerable difference
length relaxed plan initial state length real plan
initial state exceptions airport satellite umts lengths
identical nearly
usually known benchmarks general largest instances solved
within given particular time memory minutes gb plans around
hundred steps psr exceptional fast downward planner able
plan namely steps
indicates diversity ipc domains almost every one appears
least exceptions listed domains dont appear promela
domains pipesworld sort exception meaning domains contribute
typical benchmark behaviors overall set
take existence mentioned distinguishing features evidence
ipc domains indeed several novel aspects besides oriented applications
structurally diverse particular behavior psr domain stands one typically observes note typically easy construct artificial domains provoke
unusual behavior domains oriented applications exhibited behavior particularly psr domain unusual relevant
concrete sense
fact connectivity
conclude empirical analysis data aimed assessing sort connectivity
facts fact p measure number adders actions p add list
adl case effect p adds list gives indication branching factor
action choices comes fact measure number requirers actions
p precondition adl case effect p condition
gives indication central fact task given task measure
parameters distribution adders p requirers p set facts p minimum
min mean mean maximum max standard deviation dev within domain versions
plot data instance size number
data abstract allow deep conclusions reasons planner performance
able highlight characteristic features domains particular see
abstract measurements behave characteristically different ipc domains
ipc domains figure shows plots ipc domains airport pipesworld dining
philosophers satellite picture psr relatively complicated shown separately
figure settlers left exceptional picture umts extremely simple
explained text
consider figure non temporal airport domain min curves shown
since constantly pushing back airplane never added since pushback requests
outbound traffic modelled occupied segment required negation max
curves step functions since follow size underlying airports moving airplane
many adders segments since start engine done segment ispushing back airplane required every action leading overall similar form



fih offmann e delkamp hi ebaux e nglert l iporace r ug




adders max
adders mean
adders deviation
requirers max
requirers mean
requirers deviation















adders max
adders mean
adders deviation
adders min
requirers max
requirers mean
requirers deviation
requirers min






























nr instance













nr instance



b




adders max
adders mean
adders deviation
requirers max
requirers mean
requirers deviation

adders max
adders mean
adders deviation
requirers max
requirers mean
requirers deviation





















nr instance
















nr instance







c

figure distributions numbers actions adding fact actions requiring fact
selected versions ipc domains airport b pipesworld c dining
philosophers satellite
max requirers curve mean adders curve flattened facts ismoving airplane added certain places airport mean requirers curve interestingly shows similar downwards step behavior numbers facts actions shown
figure reason lies occupied facts exist every segment
needed every action moving airplane across segment number facts
increases number airplanes since many facts strong
influence mean much correspondence runtime data
trivial one tend grow instance size
data pipesworld tankage non temporal shown figure b several observations
made max mean curves clearly follow scaling pattern growing traffic
growing underlying networks min curves non zero characteristic
difference curves instance afterwards curves adders
requirers almost exactly coincide apart present airport data
observations clearly distinguish pipesworld domains observation
sometimes larger instances min number adders drop due
interactions complex networks certain configurations inside pipes true initially



fie ngineering b enchmarks



p lanning

achieved later interactions recognized reachability
pre process made actions c f explanation section observation due
large contrast smallest network larger ones smallest network
unitary pipelines containing single batch others pipelines least length
observation particularly odds domains large differences
adders requirers fact measuring distribution difference adders
requirers found numbers distribution parameters extremely
close together instance max adders max requirers max
difference mean dev pipesworld tankage restrictions
phenomenon somewhat less extreme still another characteristic enormously
large max number adders requirers order magnitude larger
domains max adders requirers come normal facts control status
individual pipelines affected action moving combination batches
respective pipeline facts depend single batches combinations
flattens mean curves two orders magnitude regarding runtime mentioned
earlier pipesworld scaling pattern clear correlation runtime neither
fact connectivity measure
consider promela domain figure c data shown dining philosophers derived
predicates extreme characteristics domain recognizable first glance
data dining philosophers without derived predicates identical data optical telegraph differ numbers higher min curves adders constant
requirers linear exist facts without adders due oddity encoding
certain start transitions put forks table first place facts without requirers
blocked philosopher needed goal number adders depend
instance size due static sort domain structure size increases number
parallel processes philosophers form processes stays fixed every process
interacts exactly two processes number requirers linear non constant particular due technicality encoding activating requesting performing
executing transition requires communication channels neutral state respective
flags required transitions number course grows size facts
required locally resulting much lower easily two orders magnitude mean one
would expect domain simple scaling pattern planner performance pretty much
function size
data satellite strips version shown figure characteristic feature
comparison domains extremely smooth parallel close together growth
curves curve stands little max requirers max adders due pointing satellite direction facts added turning direction max
requirers due power instrument facts needed every take image
instrument done every combination direction image mode supported
instrument note contrast domains max curves two
orders magnitude higher mean max requirers one order magnitude
curves curves roughly order min curves
shown since constantly adders power instrument added
switch instrument constantly requirers image direction needed



fih offmann e delkamp hi ebaux e nglert l iporace r ug

goal runtime performance ipc planners scales relatively smoothly size
satellite parameters
umts parameters constants another consequence aforementioned
scaling pattern number specified applications instances
changes goal specifying applications shall actually scheduled precisely plain domain version number adders facts nicely showing
scheduling domain characteristic choice accomplish tasks
accomplish another illustration satisficing planners
domain trivial whereas optimal planner tp haslum geffner spend long
time searching optimal schedule number requirers minimum maximum mean
standard deviation domain version flaw action notable difference
max adders due alternative provided flaw action min
mean deviation interesting note context mentioned
domain version satisficing planner crikey experiences serious trouble



max
mean
deviation

max
mean
deviation




adders

required








































nr instance













nr instance



b




max
mean
deviation

max
mean
deviation





required

adders























nr instance





















nr instance









c

figure distributions numbers actions adding fact actions requiring fact
psr small large adders small b requirers small c adders large
requirers large
data psr shown figure plots adders requirers separately
makes much readable since data contain particularly interesting


fie ngineering b enchmarks



p lanning

phenomena two domain versions small large obvious feature
small figure b huge amount variance data clearly
discernible peaks curves instance nrs coincide peaks size
measured numbers facts actions figure note large
range values spanning four orders magnitude even though instances except number
small comparison domains shown figure minimum numbers
adders requirers constantly updated breaker added wait breaker action
closed breaker needed one wants close regarding maximum adders
requirers instance far highest total number actions max adders
due goal reached fact e disjuncts dnf goal formula
max requirers due normal flag needed every goal reached action
plus actions opening closing breakers remark facts responsible
peaks curves e happens instances
highly characteristic psr small max numbers adders requirers sometimes exceed two thirds total number actions case
domain even domain version psr see intuitive reason lies
one pre compilation steps employed order able formulate reasonably
large psr instances pure strips compilation step bertoli et al removes network
reasoning need derived predicates basically enumerating breaker configurations effects flow current network dense structure
end network directly affects every end explaining high degree
fact connectivity particular explaining extremely complex goal formulas four peak
cases mentioned
pre compilation step key understanding huge difference behavior small large latter shown figure c max
adders curve small linear function note non logarithmic scale axis spite
mostly much larger numbers actions example instance highest number
actions derivation rules number max number adders less half
percent total number actions natural high level domain encoding
flow current network modelled transitive closure derivation rules
propagate current local status network particular breaker
configurations effects flow current implicit structure network
psr large min curves constantly adders requirers notaffected breaker negation derived predicate needed precondition open close
actions isnt added inverse rule given meaning negation failure
semantics derived predicates fed line required goal mean dev
adders completely flattened numerous instance upstream x
facts true currently path open side node x side node added
local derivation rule relies predicate neighbors similarly
satellite max number requirers generally lot larger max number adders
example vs instance max requirers due fact closed device
required derivation rules talking pairs devices instance actions
rules devices
sometimes minimum requirers due artificial goal reached fact introduced get rid complex
goal formulas c f section



fih offmann e delkamp hi ebaux e nglert l iporace r ug




adders max
adders mean
adders deviation
requirers max
requirers mean
requirers deviation

adders max
adders mean
adders deviation
requirers max
requirers mean
requirers deviation








































nr instance















nr instance









nr instance



b




adders max
adders mean
adders deviation
requirers max
requirers mean
requirers deviation

adders max
adders mean
adders deviation
requirers max
requirers mean
requirers deviation






















nr instance

















c

figure distributions numbers actions adding fact actions requiring fact
strips versions ipc domains except freecell satellite depots b
driverlog c rovers zenotravel
sum sub section data generally abstract really tightly interconnected
performance exhibited planners hand certain characteristics visible
particularly pipesworld numbers adders requirers almost identical
promela adders constant requirers linear satellite curves close
together psr small lot variance max numbers adders requirers
sometimes exceed two thirds total number actions contrast psr
large max adders decline less half percent total number actions umts
parameters constant except psr umts phenomena somewhat hard
interpret nothing else certainly us domains rather different
characteristics interestingly differences significant ipc benchmarks shown
figure clearly behavior characteristically diverse seen
ipc domains four domains figure basically observe mostly parallel lines
pretty close together except max lines order magnitude higher
others striking feature zig zag nature curves depots due
scaling pattern smallest instances number crates blocks grows continually
crates instance thereafter come blocks instances first



fie ngineering b enchmarks



p lanning

crates second crates third crates across blocks instance size parameters
grow means zig zag shape curves corresponds exactly zig zag shape
crate numbers
note behavior plots figure similar behavior plot satellite
figure particular first instances instances posed fully
automated planners ipc shown figure ipc domain truly stands
terms behavior curves freecell observe phenomenon similar
pipesworld figure b curves adders requirers almost coincide
phenomenon little weaker pipesworld largest freecell instance number
max adders requirers max difference mean
dev comparison largest pipesworld instance max adders
max requirers max difference mean dev
sum overall empirical analysis data certainly dont solve mystery
behind performance every planner every domain instance however provide
interesting insights instances scaled domains certain subtleties
peculiarities encodings standard heuristic methods groups planners
react observe large characteristic differences domains sense
nicely complement technical descriptions appendix well known theoretical
section

conclusion
field general reasoning mechanisms ai essential
useful benchmarks benchmarks reflect possible applications developed technology
help drive fruitful directions development benchmark
domains instances ipc authors invested significant effort creating set
useful benchmarks ai
explained introduction three main goals tried achieve realism
structural diversity accessibility benchmarks debatable extent goals
achieved extent inherent conflicting nature goals accessibility
benchmark formulation simple possible pddl dialects obviously conflict
realism structural diversity conflict realism since time window available
create competition benchmark set may case large set
suitable applications choose one must make whats available stressed
realism since lack realism traditionally considered one main weaknesses
ai achieving structural diversity accessibility would fact
comparatively easy see said adapt applications ipc
make many significant simplifications still derived domains applications one
expect capture important features even simplification top
clear path towards realism
believe domains constitute best possible compromise ipc name
distinguishing features domain set
somehow makes sense precisely domain stands intuitively different
domains notably deciding plan existence freecell np hard easy domains c f
section



fih offmann e delkamp hi ebaux e nglert l iporace r ug

airport pipesworld psr umts derived directly applications promela
special case since model checking instances could encode simplistic
previously case elevator domain ipc rovers satellite
domains ipc
complexity satisficing optimal strips domain versions covers
entire range p np pspace deciding bounded plan existence p psr
pspace complete airport general promela aware previous
pspace complete strips benchmark polynomial finding plans psr
contrast strips benchmarks quite nontrivial
hoffmanns taxonomy domain classes different h topology ipc
domains lie classes sparse coverage previous benchmarks particular none
domains nearly simple topology proved hoffmann
traditional benchmarks taking account pipesworld actions inverted
one two steps domains lies different class hoffmanns taxonomy
covering classes previous ipc benchmark set ipc ipc
ipc respectively dining philosophers exceptional lies simple class
doesnt simple topology airport exceptional lies hard class
typically real world instances easy
behavior different kinds planners ipc shows lot characteristic
patterns individual domains airport sheer size main obstacle pipesworld
particularly tankage restrictions known heuristic functions badly
promela domains main obstacle lot cases impossibility compiling
pddl description fully grounded simpler representation psr extremely
large amount variance optimal planners perform well poorly satisficing
planners umts satisficing planners need time
abstract level looks numbers actions adding needing fact
behavior domains characteristically diverse ipc domains
last least strips versions domains preserve much original
domain structure previously case ipc strips version elevator
hardly elevator anymore ipc strips versions satellite rovers
devoid interesting constraints contrast strips versions
airport promela semantically identical adl versions psr strips
version pre compiled lot still preserves much original difficulty domain
judging e g behavior ipc planners
feature obviously point realism features points diverse structure particularly feature shows domains pose different challenges current
technology feature point realism combined accessibility would stress
accessibility respect really quite important planners entered ipc
could handle adl features compilation enabled us confront
planners reasonably realistic said certainly debatable role strips


fie ngineering b enchmarks



p lanning

plays play community people may say many core
e g graphs blum furst relaxed plan heuristics mcdermott bonet
geffner hoffmann nebel invented strips others may say
focus strips languages distracts us considering temporal numerical truly different nature notwithstanding strips still widely
used language among community cannot ignored competition organizers
pointed advantages benchmark set point
disadvantages explained detail individual sections appendix make
many simplifications order make applications fit use ipc extent whether
simplifications preserve original domain structure debatable matter feel
airport encoding close real physical thing able represent
real optimization criterion bad ameliorated fact planners
single one lpg td could actually deal user defined optimization criteria pipesworld
simplifications severe ipc domain still resembles core difficulties
reminiscent complicated toy example software could used control
real pipelines promela examples go toy examples model checking area
better traditional toy examples psr removing uncertainty
numerical optimization renders ipc domain unsuitable practical use
course domain set exhaustive meaning presumably numerous applications whose essential structure similar ipc domains examples
spring mind action choice autonomous robots detecting security holes computer networks boddy gohde haigh harp online manufacturing ruml fromherz
structural diversity would easy construct set artificial domains
explore possible extreme cases domains would probably completely infeasible current planners thus posing strong challenges think example rubiks
cube sokoban rintanens purely randomly generated instance distributions
domain set would devoid realism point preparation ipc
considered introducing separate class domains called diverse structure would
contained domains sort decided since competition event already
large without felt applications already quite diverse structural
side pointed several theoretical empirical phenomena suggest latter
indeed case
work experienced successes failures accurately formulating
application domains pddl people asked us obtained picture
suitable pddl current form formulate applications sorts domains
works well answer dont feel obtained many insights matters
particularly deep havent known lessons learned first
foremost formulating application strips takes huge amount engineering expertise unless
one drops constraints simplifications unavoidable second discrete
nature action instantiations previous ipc pddl dialects seriously impedes formulation
domains continuous aspects discretization must chosen sometimes easy
airport sometimes hard pipesworld good way seems adopt
duration inequalities suggested fox long third community pay
good example case pddl moving faster actual technology



fih offmann e delkamp hi ebaux e nglert l iporace r ug

attention lifted encodings deal modern one lesson
compilation activities grounding parameters often simply possible
promela psr since compiling away adl constructs often feasible without grounding c f
section relevant adl strips context final lesson ai
community still mostly far away applicability planners real world
right track
conclude spent significant time effort creating useful set benchmarks
ipc hope become standard benchmarks coming years

acknowledgements would thank competitors detailed comments
bugs found domains would thank malte helmert useful tools
helped remove bugs
thank malte helmert providing us yet unpublished time
writing computational complexity helmert b thank patrik haslum
providing us tp temporal numerical plan graph estimates makespan umts
domain indebted anonymous reviewers much david smith maria
fox whose detailed extensive comments contributed greatly development
finally thank david smith extensive advice language including corrections even
acknowledgements
jorg hoffmann thanks wolfgang hatzack support development airport
domain benchmark instances
frederico dos santos liporace supported conselho nacional de desenvolvimento cientfico
e tecnologico brazil would acknowledge support phd supervisor ruy milidiu development pipesworld application
sylvie thiebaux thanks piergiorgio bertoli blai bonet john slaney contributions
development psr domain instances would acknowledge
support national ict australia nicta funded australian governments backing
australias ability initiative part australian council

appendix detailed domain descriptions
provide detailed descriptions domains alphabetical order section except
satellite settlers domains adapted ipc organized
sub sections follows first give outline application domain explain
main adaptations made model application pddl domain ipc explain ipc
domain structure e domain versions formulations used ipc explain
generated example instances ipc test suites finally discuss possible future
extensions
airport
contact person application domain wolfgang hatzack working
application area several years domain adapted ipc jorg hoffmann
sebastian trug



fie ngineering b enchmarks



p lanning

pplication omain
task control ground traffic airport timed travel routes must assigned
airplanes reach targets inbound outbound traffic former
airplanes must take reach certain runway latter airplanes
landed get parked reach certain parking position main constraint
course ensure safety airplanes means avoid collisions prevent
airplanes entering unsafe zones behind large airplanes engines running
optimization criterion minimize summed travel time surface airport
airplanes usually standard routes e routes airplane outbound
certain park position area inbound certain runway must take reason introducing
routes simply sheer complexity managing situation otherwise without significant
computer support yet available real airports see whether
standard routes present makes big difference computationally
airplanes move airport infrastructure consists runways taxiways
parking positions runways taxiways sub divided smaller segments position
airplane given segment currently located plus direction
precise position within segment several airplanes segment time
airplanes generally divided three categories light medium heavy classify
according engine exhaust jet blast airplane moved inbound bound bound airplanes recently landed way runway
parking position usually gate bound airplanes ready departure meaning
way departure runway since airplanes cannot move backwards need
pushed back gate onto taxiway start engines airports
provide different park positions allow airplane start engines directly
ensure safety airplane must get close back another airplane whose engines
running far safety distance depends category jet blast second
airplane
ground controller planner communicate airplanes ways
shall take stop guidance given purely reactively pays base
decisions anticipating future otherwise may happen airplanes block
need time necessary reach destinations airport objective said
minimize overall summed traveling times airplanes
instances domain one considers traffic situation given point time
time horizon say one hour airplanes known land given time slots inside
time horizon time slots respective runways considered blocked
planner make sure runways free times course situation
changes continually planes moved plans cannot executed intended continuous e consideration domain instance describing traffic situation
necessary solving instances optimally corresponding decision pspace complete
without standard routes helmert b np complete routes standardized hatzack
nebel latter case pure scheduling former case compli criterion airport wants minimize order maximize throughput point view
airlines would better minimize delay e g minimizing summed squared delay airplanes
two criteria may conflict neither two easily modelled pddl see



fih offmann e delkamp hi ebaux e nglert l iporace r ug

cated highly unrealistic course airport topologies lead exponentially long solutions c f
section
ipc pddl daptation
pddl encoding well example instance generation process see
software wolfgang hatzack namely system called astras airport surface ground traffic
simulator software package originally designed training platform
airport controllers astras provides two dimensional view airport allowing user
control airplanes means point click astras simulate traffic flow
airport course specified time window
made three simplifications one benign airport model benign
simplification model park positions airplane start engines directly
without pushed back taxiway first difficult model park positions
pddl seldom occur reality relevant application first
important simplification assume somewhat cruder notion airplane locatedness
requiring single airplane located segment time use
term segment meaning smallest indivisible unit space minimize loss
precision original segments sub divided several smaller segments
safety distance behind back airplane whose engines running measured
terms number segments discretization makes us lose precision believe
distort nature much due amount expected conflicting
traffic different points airport high near parking positions relatively easy
choose discretization segments different length precise small enough
time last simplification severe give real optimization
criterion say rather strong simplification use full standard
routes thus allowing airplanes choice move use standards
routes particularly regions near runways large airports one thing served keep
large airports manageable pddl encoding planners another thing seems good
compromise exploiting capabilities computers time keeping close
traditions airports get back matter section
full pddl description domain encoding downloaded ipc web page
http ipc icaps conference org briefly encoding works follows available actions
pushback move plane away backwards parking position startup engines
move segments park turning engines takeoff amounts
removing plane airport semantics actions encoded
predicates defining current state airplane point time airplane
moving pushed parked airborne airplane occupies one segment engines
running may block several segments depending size occupied segment
category airplane action preconditions ensure blocked segments never
occupied another airplane initial state plane parked moving parked
plane pushed back starting engines moving moving airplane
need smallest indivisible units space case fundamental consequence discrete nature
pddl said section



fie ngineering b enchmarks



p lanning

move current segment neighboring segment park parking position
take runway
example look pddl encoding non durational move action one
preconditions used example section already
action move
parameters
airplane airplanetype direction segment direction
precondition
type moving facing move
move dir segment
exists airplane blocked
forall segment imply blocked occupied
effect
occupied blocked occupied segment segment
blocked blocked
facing facing
forall segment blocked blocked
forall segment
blocked blocked
blocked

six parameters lot compared usual benchmarks cause
prohibitive explosion instantiations since lot restriction static predicates
airplane moves type category segment facing direction
facing direction move direction simple concept
says end segment airplane facing course moves
possible specified static topology airport move
move dir first two complex preconditions says must currently
blocked airplane second complex precondition makes sure
move block segment currently occupied another airplane
necessarily blocked static predicate true iff endangered
blocked plane type w facing direction effects selfexplanatory simply update occupied blocked information effect
looks little complicated last one says segments blocked
move longer blocked move become un blocked note conditions
conditional effects static conditions disappear parameter instantiation chosen
durational pddl actions take time according simple computations time
taken move across segment depends naturally segment length speed
assumed airplanes move speed regardless category time taken start
engines proportional number engines actions fixed duration
planes known land near future blocking runways model
blocking time windows timed initial literals respectively compilation
artificial temporal pddl constructs timed literals simply instances usual blocked
predicate becoming true respective time window starts becoming false
ends
able model real optimization criterion airport ground traffic control
standard criterion pddl minimize execution time e makespan plan


fih offmann e delkamp hi ebaux e nglert l iporace r ug

encoding domain comes minimizing arrival time meaning arrival
destination airport last airplane real objective said minimize
overall summed travel time airplanes appears good way modeling
criterion current pddl difficulty lies accessing waiting times planes e
times stay segment waiting plane pass
way could think get access waiting times current pddl
introduce explicit waiting action one must able tell planner e encode
action long plane supposed wait one option use duration inequalities
proposed fox long action imposes constraints duration
planner choose actual duration action point used
plan additional rational valued parameter potential disadvantage
choice waiting time introduces principle infinite branching factor
state space may thus make much harder automated planners moreover duration inequalities put use ipc part pddl
duration inequalities way encode requested waiting time action use
discretization time one introduce objects representing every considered time
interval give waiting action parameter ranging objects apart loss
precision involved discretization likely cause huge performance
automated planners alternative way considered introducing special
current time variable pddl returning time evaluation plan execution
look clock one could make plane record arrival time thus formulate true optimization criterion without major changes domain structure ipc
organizing committee decided introduction current time variable seemed
problematic algorithmic point view implies commitment precise time points
time didnt seem relevant anywhere except airport
ipc pddl encoding airport domain realistic except optimization criterion demands minimize maximal arrival time makespan instead summed
travel time remains remark one lpg td ipc planners ignored
optimization criterion anyway minimizing latest arrival time appear useful
ideal objective
ipc omain tructure
airport domain versions used ipc non temporal temporal temporal timewindows
temporal timewindows compiled first versions name suggests nondurational pddl second version actions take time explained third fourth
versions consider runways blocked future planes known land given time
windows third version encodes time windows timed initial literals fourth
version uses literals compilation standard temporal pddl constructs c f section
domain versions constraints modeled adl e complex preconditions conditional effects compiled adl encodings strips domainspecific software implemented purpose grounded operator
parameters precisely parameters except action one giving name
modelling summed squared delay airplanes optimization criterion airlines would pose essentially
difficulty involves computing arrival time order compute delay



fie ngineering b enchmarks

version
non temporal
non temporal
temporal
temporal
temporal tw
temporal tw
temporal twc
temporal twc

formulation
adl
strips
adl
strips
adl
strips
adl
strips



max op









p lanning

max act









table overview different domain versions formulations airport abbreviations used temporal tw temporal timewindows temporal twc temporaltimewindows compiled max op maximum number parameterized pddl
operators instance max act maximum number ground actions
instance adl formulations set ground actions could generated
largest instances data shown largest instances could handled data
parentheses collected ffs reachability pre process see text
affected individual airplane parameters fixed formulas conditional
effects simplified usual strips constructs airport domain version contains
original adl formulation well compilation strips grounding
process depends specific airport considered instance set airplanes
travelling strips formulations instance individual domain file
applies strips compilations domains described later
domain versions well blow incurred compilation overviewed
table numbers shown table indicate numbers pddl operators numbers
grounded actions domain version formulation maximum number
instance shown note adl formulations except temporal timewindows compiled
single domain file number operators identical instances
strips formulations number operators high explained operator
parameters grounded difference number ground actions strips
adl formulations automated software able generate
ground actions larger adl instances data shown largest instances
could handle numbers shown parentheses refer situation ffs reachability
pre process said builds relaxed graph initial state removes
actions appear graph difference numbers inside outside
parentheses indicates much simple pre process helps see helps quite lot
pruning almost half actions would never become applicable forward search
least blow representation regardless used
instantiation process course planner dependent similarly section data
ffs pre processor extended pre processor precisely one metric hoffmann deal
temporal constructs



fih offmann e delkamp hi ebaux e nglert l iporace r ug

ipc e xample nstances
airport example instances generated sebastian trug implementation
aforementioned airport simulation tool astras five scaling airport topologies designed
used basis instance generation airports named minimal mintoy
toy half muc muc smallest airports smallest possible airport
astras handle two largest airports correspond one half munich airport muc
full muc airport figure shows sketches minimal airport muc
airport



b
figure smallest largest b ipc airport topologies park position
segments marked black e g top part segments airplanes
takeoff marked white e g left bottom side part lines
road network airport topology b corresponds muc airport
sebastian trug implemented pddl instance generation software inside astras simulation traffic flow airport desired user software exports current traffic
situation pddl encodings explained simulator run different
airports scaling traffic situations exported minimal mintoy
toy half muc muc airport instances scale terms
number travelling airplanes largest instance features planes moved destinations munich airport planes landing future considered respective
domain versions considered realistically sized traffic situation airport



fie ngineering b enchmarks



p lanning

f uture w ork
remains explore relax simplifications make importantly
overcome discrete model space locatedness model real optimization
criterion difficulties partly described already mostly due discrete
nature pddl allow continuous choice instantiation action
continuous choice would natural way saying far plane moving
long waiting best way go direction probably assume
duration inequalities proposed fox long together numeric variables
already contained pddl easy modelling side main
probably technology side e develop planners deal efficiently
continuous choice points time ipc said continuous choice appeared much
demand planners
one interesting topic future work arises one restricts airplanes completely standard
routes e leaves choice route take destination said first
usually done real airports sheer complexity managing situation otherwise
without significant computer support yet available real airports second ipc made limited use feature retain flexibility could offered
automatized methods third restriction turns pspace complete ground traffic control
pure np complete hatzack nebel scheduling
question planes move across segment one could exploit create much
concise pddl encoding restricted comes resolving conflicts
arise two planes need cross airport segment one could thus try encode
pddl physical airport conflicts possible solutions ideally connection
real optimization criterion expected planners much efficient
simpler concisely encoded
pipesworld
frederico liporace working application area several years submitted
early domain version workshop competition icaps domain
adapted ipc frederico liporace jorg hoffmann
pplication omain
pipelines play important role transportation petroleum derivatives since
effective way transport large volumes large distances application domain
consider deals complex arise transporting oil derivative products
multi commodity pipeline system note many benchmarks
dealing variants transportation transporting oil derivatives pipeline
system different characteristic kind structure since uses stationary carriers
whose cargo moves rather usual moving carriers stationary cargo particular
changing position one object directly changing position several objects
less reminiscent transportation domains complicated single player games
rubics cube lead several subtle phenomena example may happen solution
must reverse flow liquid pipeline segment several times may happen



fih offmann e delkamp hi ebaux e nglert l iporace r ug

liquid must pumped ring pipeline segments cyclic fashion achieve goal
see example later
detail application domain following pipeline network graph operational areas connected pipeline segments operational areas may harbors distribution centers
refineries may connected one pipeline segments oil derivatives
moved areas pipelines
different types petroleum derivative products area set tanks
define storage capacity product type pipeline segment fixed
speed depends segments length cross section diameter speed
depends power pumps move contents segment may uni directional e
usable transportation one direction
pipeline segments pressurized must completely filled
petroleum derivative products way move pipeline segments contents
pumping amount product adjacent area segment operation
assuming incompressible fluids amount possibly different product
received area end segment
pumping operations executed violate interface tanking
constraints former distinct products direct contact inside pipeline segment
unavoidable loss due mixture interface
interface losses major concern pipeline operation mixed products
simply discarded must pass special treatment may involve sending back
refinery may require use special tanks severity interface losses depends
products interface inside pipeline segment two product types known generate
high interface losses pipeline plan must place adjacently segment pair
product types said interface restriction
tanking constraints limits product amounts stored area arising
respective tank capacities constraints may effectively block pipeline segment
room receiving area store product would leave segment process
pumping operation
task application bring certain amounts products areas
required e one plan pumping operations shifts positions product
amounts way goal specifications met sometimes deadline specifying
latest product amount arrive destination area may case
area typically refinery known produce given amount product given point
time plan must make sure enough tank space available respective
area store product amount similarly area typically harbor distribution center
may known consume given amount product given point time thereby freeing
respective amount tank space
ipc pddl daptation
main adaptations made pddl encoding unitary batches split pumping operations
personalized goals see latter term batch used oil pipeline
industry refer amount product must transported pipeline batches
thus associated single product predefined batches indivisible



fie ngineering b enchmarks



p lanning

batch bi pumped area aj segment sj k possible another batch
pumped aj sj k bi pumped course reality product
amount batch rational number numeric encoding ipc seemed completely
infeasible due complications modeling expected capabilities participating
planners see section instead encoding concept called
unitary batches smallest considered indivisible portions product pumping
operations refer unitary batches pipeline segments volumes volumes tanks
defined terms unitary batches encoding real world instance domain
actual associated unitary batch choice variable smaller unitary batches decrease
rounding error pddl encoding cost larger encoding size note
smallest units space airport domain discretization need due
non continuous nature actions pddl get back section
modeled pipe segments directional fashion e default direction assigning
one area role area role pumping operations accordingly
distinguish push actions move liquid respective segments default direction
pop actions move liquid opposite direction simply technical device
enable encoding pipe segment contents predicates defining first last
batches segments well successor relation push pop actions receive
amongst things arguments pipeline segment whose contents moved
batch inserted segment batch leaves segment depends
segment content action executed figure shows example
































b
























































b




b












































b

















































































































b









































b



































b




















b

























b























































































































b





b












b



b




































b






































b





























b
















































b










































































b



























b

p




























































p
p

c

figure small example plays role fill pattern batch represents
product shows initial state b shows state push operation
b inserted segment c shows state b pop operation b
inserted segment
apart pipe segment batch inserted push pop actions
take several parameters regarding e g product types tank slots particular order
able update segment contents correctly actions need parameters giving
respective first last second last batch current contents segment thus
action four parameters ranging batches yielding least n ground instances action
n unitary batches considered task found made domain


fih offmann e delkamp hi ebaux e nglert l iporace r ug

completely infeasible system grounded actions since many unitary
batches needed encode even relatively small pipesworld examples planners typically
died pre processing phase already avoided phenomenon splitting actions
two parts start action taking batch parameters inserted batch first batch
pipe end action taking batch parameters last second last batches
pipe make concrete split push action
action push start
parameters
pipe pipe batch atom batch atom area area area area
first batch atom batch atom product batch atom product
product first batch product
precondition
normal pipe first first batch atom pipe connect area area pipe
batch atom area unitary pipe
product batch atom product batch atom
product first batch atom product first batch
may interface product batch atom product first batch
effect
push updating pipe normal pipe first batch atom pipe
first first batch atom pipe follow first batch atom batch atom
batch atom area
action push end
parameters
pipe pipe area area area area last batch atom batch atom
next last batch atom batch atom
precondition
push updating pipe last last batch atom pipe connect area area pipe
unitary pipe follow last batch atom next last batch atom
effect
push updating pipe normal pipe
follow last batch atom next last batch atom
last next last batch atom pipe last last batch atom pipe
last batch atom area

constructs largely self explanatory static predicates used connect
encoding topology network product encoding types liquid may interface
encoding interface restrictions unitary saying whether pipe segment contains
one batch case push pop actions much simpler need
split first last elements pipe identical predicates normal pushupdating ensure obvious way two parts split action used
intended finally first follow last encode relevant batches
role clear encodes locatedness areas pipe contents
modelled queue fashion head first tail last successor function follow
two parts push action update representation accordingly
matters may easier systems ground actions pre process didnt affect
design decision since large majority systems around time ipc employ pre process
note model interface loss products may interface



fie ngineering b enchmarks



p lanning

encode uni directional pipe segments e segments push pop
actions available ipc encodings modeled tankage restrictions simple constructs involving tank slots located areas slot capacity store one unitary batch
given product type push pop actions specify tank slot
inserted outgoing batch comes inserted simple examples regarding interface
tankage restrictions consider figure storage capacity p equal zero
transition state state b becomes invalid forbid interface p
p transition state b state c becomes invalid
pipe segment speed easily taken account durational pddl speed
segment simply assign push pop actions regarding segment duration proportional ipc encoding start end action takes exactly time
non split actions regarding length segments take time
reality outlined goals refer amounts product requested certain
destination areas encoding batches formulating goal would mean introduce potentially large disjunction conjunctive goals one wants say e g three unitary batches product p requested area needed goal condition disjunction
w
b b b b atb atb atb respective conjunctive goal three subsets
b b b batches b type p avoid exponential blow ups kind encoding
used personalized goals instead referring specific batches instead product amounts basically comes pre selecting one b b b subsets disjunction
one could avoid blow replacing disjunction existential quantification
step would undone compilation strips anyway
deadlines arrival batches durational pddl easily modeled compilation
timed initial literals goal deadline literal saying respective batch
still ejected end pipe segment literal initially true becomes false
time deadline described application pre specified time
points area produces consumes given amount product model
ipc domain see section
mentioned structure pipesworld domain lead several subtle phenomena possible plans example plans perform cyclic sequence pumping
operations depicted figure goal place b shortest plan following readability action parameters batches going pipes
shown push b b pop b b pop b b push b b
push b b pop b b push b b push b b observe
plan contains two cyclic patterns action inserts b actions form
cycle brings b thereafter action inserts b actions
form another cycle bringing b goal position
note bad choice b b b make task harder solve however currently investigating computational complexity different variants pipesworld preliminary suggest
allowing disallowing personalized goals affect complexity
note need cyclic patterns oddity introduced encoding something may
probably likely happen reality example becomes necessary isnt enough liquid
origin area push needed amount liquid b destination



fih offmann e delkamp hi ebaux e nglert l iporace r ug



b


b
b

b


b
b

b



b





figure example cycling required achieve goal place b pipe segment
si j directed ai aj
version
notankage nontemporal
notankage temporal
notankage temporal
notankage temporal dc
tankage nontemporal
tankage temporal

formulation
strips
strips
strips
strips
strips
strips

max op







max act







table overview different domain versions pipesworld abbreviations used
temporal temporal deadlines temporal dc deadlines compiled max op
maximum number parameterized pddl operators instance max act
maximum number ground actions instance data parentheses collected ffs reachability pre process see text

ipc omain tructure
pipesworld domain versions used ipc notankage nontemporal tankage nontemporal
notankage temporal tankage temporal notankage temporal deadlines notankage temporaldeadlines compiled versions include interface restrictions versions tankage
name include tankage restrictions versions temporal name actions take
different amounts time depending pipeline segment moved explained
versions deadlines name include deadlines arrival goal
batches one versions deadlines timed initial literals version
naturally compiled name literals compiled artificial temporal pddl
constructs none encodings uses adl constructs version one
strips formulation
domain versions numbers ground actions overviewed table
data measured temporal extension ffs pre processor numbers shown



fie ngineering b enchmarks



p lanning

parentheses refer situation pre processors reachability pre process
builds relaxed graph initial state removes actions appear
graph observe numbers ground actions low domain versions
deadlines extremely high versions tankage restrictions former simply
due complicated generation process explained next sub section examples
deadlines generated smaller size latter high numbers actions
presence tankage restriction due additional blow incurred choice tank
slots draw put batches note effect reachability
pruning relatively moderate particular much lower e g airport c f section
ipc e xample nstances
pipesworld example instances generated frederico liporace process going
random generators xml files pddl files five scaling network topologies designed
used basis instance generation figure shows network topologies well
real world network topology comparison one see largest network topology
used ipc quite yet ballpark real network neither trivially
small comparison volumes pipeline segments connect areas realworld example necessarily segments may different cross section
diameters
domain versions without tankage restrictions deadlines network
topologies scaling random instances generated within network instances scaled
terms total number batches number batches goal location
instances featuring tankage restrictions deadlines generation process complicated
wanted make sure obtain solvable instances tankage restriction examples ran mips edelkamp b respective notankage instances incrementally
growing tankage chose instance random point first instance solved
mips maximum needed tankage enough tankage area accommodate instance
batches instances could solved mips even given several days runtime
inserted maximum tankage deadline examples ran mips
corresponding instances without deadlines arranged deadline goal batch random point interval arrival time batch mipss plan end time
mipss plan instances solved mips left
c urrent



f uture w ork

ongoing work developing pipesworld specific solver named plumber milidiu dos
santos liporace milidiu dos santos liporace b plumber incorporates pipeline
simulator domain specific heuristics procedures reducing branching factor symmetry
elimination lets user choose different search strategies enforced hill
climbing hoffmann nebel learning real time korf currently
extended support temporal well
xml file mapped different pddl files depending kind encoding used lot
trial error came final ipc encoding
mips convenient choice since one planners deal temporal constructs



fih offmann e delkamp hi ebaux e nglert l iporace r ug


























network





network





















network




























ba







ut

rc














tb








network
ba



sz









rd





gu










network



rv











ga







rp
















sb



rb



b

figure ipc pipesworld network topologies real network topology b
segment volumes latter annotated units

availability solver enable extension pipesworld benchmark since
easier overcome aforementioned difficulties generating large feasible instances
hope able generate feasible instances real world pipeline topologies one shown
figure
addition generating larger instances pipesworld benchmark may extended many
ways make closer real application scenario relevant possible extensions include
defining pipeline segments single flow direction segments
push pop actions allowed note introduces dead ends critical choices

un personalized goals could accomplished e g imposing desired tank goal products respective areas planner decide
batches used bring tank desired level
modeling production consumption products pre specified points time described



fie ngineering b enchmarks



p lanning

rational numbers model tank capacities current volumes instead encoding
unitary tank slots apart precise model real world
combined rational valued batch sizes see encoding would avoid unnecessary symmetries currently arise availability several non distinguishable
tank slots area product
important shortcoming encoding use unitary batches would much
appropriate base encoding product amounts given real numbers one problematic
aspect encoding would naturally demand continuous choice
much liquid pump pipeline airport c f section choice could
naturally modelled fox longs duration inequalities unclear
develop planners deal reasonably well unlike airport implementing
choice end difficulties modelling side model continuous
contents pipeline number distinct regions liquid pipeline grow arbitrarily
high principle one solution might fix upper bound simply disallow pumping
operation would many distinct regions may bearable loss precision
given upper bound high enough even bound awkward correctly update
contents pipeline amount x product pushed number different
products leaving pipe depends x option may use complicated construct
conditional effects
impression pipeline scheduling wont realistically modelled pddl
successfully solved planners unless one introduces language data structure
suitable modelling contents pipes basically would queues whose elements
annotated real numbers whose basic operations usual push pop
semantics pipes could explicitly computed inside planner rather awkwardly
modelled language constructs likely disturb general search mechanism
promela
domain created ipc stefan edelkamp
pplication omain
dropping promela domain briefly recall origin
model checker spin holzmann targets efficient software verification
used trace logical design errors distributed systems design operating systems data
communications protocols switching systems concurrent railway signaling protocols
etc tool checks logical consistency specification spin reports deadlocks unspecified receptions identifies race conditions unwarranted assumptions relative speeds
processes spin starting version provides support use embedded c code
part model specifications makes possible directly verify implementation level software
specifications spin driver logic engine verify high level temporal properties spin works fly means avoids need construct global state graph
prerequisite verification system properties spin supports property checking linear temporal logic ltl ltl expresses state trajectory constraints temporal modalities



fih offmann e delkamp hi ebaux e nglert l iporace r ug

eventually spin uses specific mechanisms specifying deadlock freeness
safety properties addition general ltl specifications explore state space
ordinary nested search applied depending whether state k
safety property verified
promela spins input specification language computational model asynchronous
communicating finite state machines promela allows define classes finite processes special
process called init started first usually governs instantiation processes
system possible process invoke another one promela allows modeling systems
dynamic creation state components communication promela achieved via shared variables
message channels two kind message channels distinguished synchronous asynchronous communication asynchronous channel basically fifo queue synchronous
channels imply rendezvous communication transition system involves two processes one reading message channel another sending message
consider asynchronous communication body process class basically sequence
statements statement interpreted transition process typical statements include assignments numerical boolean expressions channel operations promela allows
define atomic regions whose sequence transitions treated atomic
action interpreted weighted transitions whose costs number steps within
regions
ipc used two example communication protocols formulated promela dijkstras
dining philosophers called optical telegraph protocol briefly describe
latter protocol section illustrate promela language let us consider dining
philosophers n philosophers sit around table lunch n plates
one philosopher n forks located left right plate since two
forks required eat spaghetti plates philosopher eat time moreover
communication except taking releasing forks allowed task devise local
strategy philosopher lets philosophers eventually eat simplest solution
access left fork followed right one obvious philosophers wait
second fork released possible progress deadlock occurred
difficult probably insightful derive bottom pddl encoding dining
philosophers domain actions eat wait think motivation however come
top encoding starting promela specification automatically translating
pddl
deadlock model dining philosophers specified promela shown figure
first lines define macros declare array n boolean variables represent
availability forks following lines define behavior process type philosopher
process iterates indefinitely endless loop one unique entry marked symbol
statements separated semicolon first transition left fork consists send
operation tag fork channel left macro address forks current
process id pid represents availability left fork philosopher access transition left fork executed reading tag fork channel left successful
note fragments ltl likely included pddl language next international
competition gerevini long
documentation promela specification language found web site spin
http netlib bell labs com netlib spin whatispin html



fie ngineering b enchmarks



p lanning

define max philosophers n
mtype fork
define left forks pid
define right forks pid max philosophers
chan forks max philosophers bit
active max philosophers proctype philosopher

left fork

left fork try get left fork
right fork try get right fork
eat
left fork right fork release forks
meditation
od

figure promela specification model dining philosophers
next transition right fork similar first last two ones sends tag fork back
channels left right
ipc pddl daptation
model checking action closely related c f section model checker
searches counterexample form sequence transitions falsify given specification planner searches sequence actions satisfies given goal cases
basic strips kripke structures refer implicit graphs nodes
annotated atomic propositions
automatically generating pddl model promela syntax wrote compiler edelkamp restricted safety properties especially deadlocks assertions
global invariances difficult obtain concentrated fixed number processes since communication protocols adhere restriction
compiler parse promela code takes input intermediate
representation generated spin validation tool figure shows
textual automata representation philosopher process case value n
initialized philosophers file contains almost necessary information
dynamic creation processes pddl would require language extension dynamic object creation
extension dismissed since would involve heavy changes existing planner technology relevance
beyond promela unclear
precisely promela input file taken corresponding c file generated verifier compiled
executable run option



fih offmann e delkamp hi ebaux e nglert l iporace r ug

translation number processes queues e message channels well queue capacities read original promela input file
proctype philosopher
state trans state line forks pid fork
state trans state line forks pid fork
state trans state line forks pid fork
state trans state line forks pid fork
state tras state line forks pid fork
figure automata representation model dining philosophers
derive suitable pddl encoding domain process represented finite state
automata hence propositional encoding simulates automaton propositional atoms
true initial state one process running example shown figure

process philosopher philosopher
process philosopher state
trans philosopher trans state state
trans philosopher trans state state
trans philosopher trans state state
trans philosopher trans state state
trans philosopher trans state state

queue forks queue
queue head forks qs
queue tail forks qs
queue next queue qs qs
queue head msg forks empty
queue size forks zero
settled forks



b

writes philosopher forks trans trans msg trans fork
reads philosopher forks trans trans msg trans fork
reads philosopher forks trans trans msg trans fork
writes philosopher forks trans trans msg trans fork
c
figure propositional encoding one philosophers process propositional encoding
single cell communication channel b connecting communication local state transitions c
encoding communication structure represents channels graphs pddl encoding additionally exploits cyclic embedding queue array formally fifo
channel q represented structure gq sq headq tailq q messq contq sq
set queue cells headq tailq sq head tail cells q messq sq
avoid conflicts pre compiler directives first invoked c compiler command line option e
executes pre compiler
use transition ids competition less accessible textual representation label chosen



fie ngineering b enchmarks



p lanning

vector messages q set messages contq ir sq vector
variable values q q sq sq successor relation q sq k
mod k explicitly modeling head tail positions queue trades
space time since queue updates reduce constant time
queue empty full pointers refer queue state special case
simple queues example may consist one queue state successor bucket
queue state queue state case grounded propositional encoding includes
operators add delete lists share atom make standard assumption
deletion done first propositional atoms one queue adaption two queues
one process exemplified figure b c
queue content shared local variables modeled pddl fluents difference
local variables compared shared ones restricted visibility scope local variables
prefixed process appear two benchmark protocols selected ipc rely
pure message passing numerical state variables involved allowed us
supply propositional model
action activate trans
parameters p process pt proctype transition state
precondition forall q queue settled q trans pt
process p pt process p pending p
effect activate p pending p
figure testing transition enabled activating
pddl domain encoding uses seven operators named activate trans queue read
queue write advance queue head advance empty queue tail advance non empty queue tail
process trans activation process shown figure see pending process
activated queues settled transition matches current process state
briefly operators encode protocol semantics follows operator activate trans activates
transition process given type local state operator sets predicate
activate boolean flag precondition queue read queue write actions set
propositions initialize reading writing message queue q activated transition
querying message corresponds promela expression q respectively q
read write operation initialized queue update operators must applied e advancequeue head advance empty queue tail advance non empty queue tail appropriate
names indicate operators respectively update head tail positions needed
implement requested read write operation operators set settled flag
precondition every queue access action action process trans applied executes
transition local state e sets local process state sets flags
stored message match query queue capacity small
large active local state transition block active transitions process block
process block processes blocked deadlock system detection
deadlocks implemented different domain versions collection specifically
engineered actions elegantly set derived predicates cases one infer
along lines argumentation outlined process entire system blocked


fih offmann e delkamp hi ebaux e nglert l iporace r ug

derived blocked trans p process transition
exists q queue
exists message
exists n number
activate p reads p q settled q
trans msg queue size q n zero n
derived blocked p process
exists state
exists pt proctype
process p process p pt
forall transition
blocked trans p forall state trans pt

figure derivation deadlock
goal condition makes planners detect deadlocks protocols simply conjunction
atoms requiring processes blocked example derivation rules derived
predicates pddl description derivation deadlock blocked read accesses
shown figure
ipc omain tructure
two benchmark protocols ipc created three different domain versions
derivedpredicates contains derived predicates infer deadlocks plain purely propositional specification specific actions applied establish deadlock later
actions basically gazen knoblock compilation derived predicates c f section fluents alternative latter numerical state variables encodes size
queues messages used access contents made version called fluentsderivedpredicates obvious combination none ipc competitors participated
omit herein within domain version one formulation includes adl
constructs quantification disjunctive preconditions negated preconditions domain
versions without fluents another formulation pure strips obtained respective adl
encodings adl strips compiler handle numeric variables unfortunately
larger instances lead strips files big stored disk
remember adl strips grounds operator parameters large instances
course left respective test suites
kept fluent domains separated domain versions rather domain version formulations
order able compare propositional numerical exploration efficiencies emphasize
fluent variables essential real world model checking treated separately
domain versions numbers operators ground actions overviewed table
consider rows table top bottom times parentheses values
ffs reachability pre process builds relaxed graph initial state
removes actions appear graph strips formulation fully grounded
adl strips program derived ffs pre processor c f section



fie ngineering b enchmarks

version
optical telegraph
optical telegraph
optical telegraph dp
optical telegraph dp
optical telegraph fluents
philosophers
philosophers
philosophers dp
philosophers dp
philosophers fluents

formulation
strips
adl
strips dp
adl dp
adl
strips
adl
strips dp
adl dp
adl



p lanning

max op











max act











table overview different domain versions promela abbreviations used dp derived predicates max op maximum number parameterized pddl operators
instance max act maximum number ground actions instance
data parentheses collected ffs reachability pre process see text derivation rules ground derivation rules counted operators ground actions

reason number operators number ground actions ffs preprocess identical one run adl strips effect adl formulation see
reachability pruning reduces number actions factor almost similar airport
domain c f section picture next two domain versions derived predicates
similar fact since consistently data section count derivation rules
actions data identical reason identical table derived
predicates instead operators ffs pre processor scales larger instances presumably due
unimportant implementation detail next domain version formulated numeric
variables ffs pre processor scales even worse however even instances number
telegraphs less ground actions due different encoding
observations made dining philosophers exactly different numbers
notable difference effect ffs reachability pruning weaker yielding
slight decrease number actions versions without fluents decrease
version fluents apparently complex process structure optical telegraph leads
useless action instances
ipc e xample nstances
said selected two simple communication protocols benchmarks ipc encoding dining philosopher described called optical telegraph
protocol holzmann
optical telegraph protocol involves n pairs communicating processes pair featuring process pair go fairly long heavily interactive
sequence operations implementing possible data exchange two stations
data exchanged initializing steps must taken ensure processes working
synchronously importantly process writes token control channel queue


fih offmann e delkamp hi ebaux e nglert l iporace r ug

beginning sequence reads token end causes deadlock
situation n control channels accessed two processes
every pair processes occupied one control channel overall system
blocked
dining philosopher optical telegraph benchmark instances scale via
single parameter number philosophers number control stations respectively
scaled parameter competition instances promela benchmarks distributed together experimental model checking tool hsf spin edelkamp
leue lluch lafuente extends spin heuristic search strategies improve error
detection
f uture w ork
general terms see promela benchmark another important step towards exploiting synergies areas model checking giunchiglia traverso
example complement recent progress explicit directed model checking
domain protocol validation edelkamp et al symbolic directed model checking
domain hardware validation reffel edelkamp led drastic improvements
state art model checkers work e g yang dill bloem ravi
somenzi model checking growing interest guided exploration
mostly errors faster blind state space enumeration compilation
promela domain model alternative option applying heuristic search model checking
available work needed understand heuristics work fail
model checking benchmarks
strongly believe communities profit wide spread availability techniques represent model checking pddl allows direct comparison exploration efficiencies design promela domain suitable pddl domain encodings
two expressive model checking input languages graph transformation systems edelkamp
jabbar lluch lafuente petri nets edelkamp jabbar proposed
encodings exploit expressive power pddl well efficiency current planners
state art planners often faster compared model checkers benchmarks
psr
sylvie thiebaux others worked application domain domain adapted
ipc sylvie thiebaux jorg hoffmann
pplication omain
power supply restoration psr domain consider derived application investigated sylvie thiebaux others thiebaux et al thiebaux cordier psr
deals reconfiguring faulty power distribution system resupply customers affected
faults topic ongoing interest field power distribution
detail power distribution system see figure viewed network electric lines connected switches fed via number power sources equipped
circuit breakers switches circuit breakers two possible positions open closed


fie ngineering b enchmarks



p lanning

figure sample power distribution system sources circuit breakers e g cb represented
large squares switches e g sd small squares open switches e g sd
white area fed cb boxed gray dark used distinguish adjacent
areas fed different sources

connected two lines restriction connectivity lines extremities
connected earth circuit breaker power source closed
power flows source lines downstream flow stopped open switch
switches used appropriately configure network position initially set
line fed exactly one source
due bad weather conditions permanent faults affect one lines network
power source feeds faulty line circuit breaker fitted source opens protect
rest network overloads leaves lines fed source without power
consists sequence switching operations opening closing switches
circuit breakers bringing network configuration maximum non faulty lines
resupplied instance suppose line l becomes faulty leads circuit breaker
cb open boxed area without power possible restoration plan would
following open switches sd sd isolate faulty line close sd source
cb resupply l finally close cb resupply others
original psr thiebaux cordier maximal capacity sources
lines well load requested customers taken account plan must optimize
numerical parameters breakdown costs power margins distance initial
configuration subject capacity constraints furthermore due fault sensors switches
unreliable location faults current network configuration partially
observable optimizing leads complex tradeoff acting resupply lines
acting intrusively reduce uncertainty



fih offmann e delkamp hi ebaux e nglert l iporace r ug

ipc pddl daptation
pddl adaptation benefited contributions piergiorgio bertoli blai bonet alessandro cimatti john slaney bertoli et al bonet thiebaux compared
original psr domain described ipc version underwent major adaptations firstly
ipc deals fully observable domains hence partial observability psr crucial
issue thiebaux et al bertoli et al bonet thiebaux ipc version assumes
complete observability secondly given difficulty encoding even basic chose
ignore numerical optimization aspects psr capacities power margins thirdly
ipc version set pure goal achievement goal specifies set
lines must supplied considered realistic goal asking planner supply
line however unable compile goal strips reasonable
space opted simpler goal keep strips formulation consistent possible
others
highest level natural ipc encoding psr involves adl constructs derived
predicates briefly encoding works follows psr instances specify network
topology e objects network connections lines switching devices
switches sources circuit breakers two side constants side side denote
two connection points switching device connection relations objects
initial configuration e initial positions open closed switching devices
modes faulty lines among devices positions change
number predicates derived basic ones model propagation
current network view determining lines currently fed sources
affected fault e feed fault closed world assumption semantics pddl
derived predicates exactly needed elegantly encode relations require
recursive traversal network paths naturally represented transitive closure
connection relation network complex derived predicates upstream
requires four parameters two however take two possible values expresses
power flows one two sides device side sx device x one
sides another side sy device happens side x opposite sx
directly connected sy via line exists closed device z one side
upstream sx side connected sy
derived upstream x device sx side device sy side
closed x
sx side con x side sy
sx side con x side sy
exists z device
closed z
con z side sy upstream x sx z side
con z side sy upstream x sx z side
upstream relatively easy define predicates stating whether given line fed given
source affected



fie ngineering b enchmarks



p lanning

goal instance asks given lines fed sources unaffected
available actions closing opening switching device effect simply set
device position requested addition action wait event circuitbreakers opening become affected wait applicable affected source exists
applicable action case open close actions require precondition
source affected together goal ensures wait action applied
soon source affected effect wait action open affected circuit breakers
concretely wait close actions follows note open similar close earth
treated device whose position cannot changed actions
action close
parameters x device
precondition x earth
closed x
forall b device affected b
effect closed x
action wait
parameters
precondition exists b device affected b
effect forall b device affected b closed b
would possible encode opening affected breakers conditional effect
close action however would required complex derived predicates additional
device parameter conditional flavor specifying e g whether circuit breaker would
affected close device
ipc omain tructure
used four domain versions psr ipc primarily versions differ size
instances encoded instance size determined languages able
formulate domain version tried generate instances size appropriate evaluate
current planners e scaled instances push everybody impossibly hard
current automated planners got intuitions running version enhanced
deal derived predicates largest instances kind size one typically encounters
real world instance generation process said section
domain versions named large middle middle compiled small
version single formulation adl derivedpredicates version formulations adlderivedpredicates simpleadl derivedpredicates strips derivedpredicates version
single formulation adl version single formulation strips formulation names simply give language used version contains largest instances versions contain
medium instances version contains smallest instances adl derivedpredicates
note circuit breaker affected source opens source affected feed
line circuit breaker closed source stay unaffected unless starts feeding faulty
line



fih offmann e delkamp hi ebaux e nglert l iporace r ug

version
large
middle
middle
middle
middle compiled
small

formulation
adl dp
adl dp
simple adl dp
strips dp
adl
strips

max op







max act







table overview different domain versions formulations psr abbreviations used
dp derived predicates max op maximum number parameterized pddl
operators instance max act maximum number ground actions
instance data parentheses collected ffs reachability pre process see
text derivation rules ground derivation rules counted operators ground actions

formulation inspired bonet thiebaux makes use derived predicates explained adl constructs derived predicate action goal definitions
simpleadl derivedpredicates strips derivedpredicates formulations adl constructs except
conditional effects simpleadl case compiled away resulting fully grounded encodings significantly larger original hand length plans remains
nearly unaffected pure adl formulation obtained adl derivedpredicates formulation compiling derived predicates away method described thiebaux et al
significant increase domain size compilation method lead
increase plan length exponential arity derived predicates compilation
method avoid blow worst case see thiebaux et al indeed
particular psr example instances observed considerable blow plan length felt
blow much allow useful direct comparison data generated adlderivedpredicates opposed adl separated adl formulation domain version
listed
strips domain formulation proved quite challenge schemes considered compiling derived predicates adl constructs away led completely
unmanageable domain descriptions completely unmanageable plans feasible compilations derived predicates create actions highly conditional effects
compiling away impractical therefore adopted different fully grounded encoding inspired bertoli et al encoding generated description instance
tool performing reasoning power propagation resulting tasks effects
close actions directly specify circuit breakers open closing switch given
network configuration derived predicates needed consequently strips encoding
much simpler refers positions devices lines faults connections nevertheless still able formulate comparatively small instances strips
without prohibitive blow encoding size
variation due fact existential precondition wait action causes compilation split
action many wait actions circuit breakers



fie ngineering b enchmarks



p lanning

domain versions formulations respective numbers operators ground actions shown figure data parentheses collected ffs reachability preprocess building relaxed graph initial state removing actions
appear graph encodings adl derived predicates reduces number ground actions factor around adl factor much smaller
encodings reduction obtained simply due fact encodings obtained adl strips uses pruning process interesting observations
made middle versions formulations data shown correspond largest
instance ffs pre processor could handle versions formulations enable direct comparison see formulation simple adl strips need introduce
ground actions see curiously compilation derived predicates compilation
middle compiled number ground actions decreases dramatically reason lies
data count ground derivation rules ground actions subtleties compilation derived predicates middle formulations almost ground actions fact
ground derivation rules compiled away middle compiled following thiebaux et al
introducing single action one distinct conditional effect derivation rule c f section means complexity thousands derivation rules
replaced complexity action thousands conditional effects
ipc e xample nstances
due contractual agreements unable use real data competition instead psr
instances randomly generated randomnet special purpose tool implemented john
slaney
power distribution networks often mesh able structure exploited radially path taken
power source forms tree whose nodes switches whose arcs electric
lines terminal switches connect trees together randomnet takes input number
sources percentage faulty lines range parameters controlling tree depth branching
tree adjacency whose default values representative real networks randomnet randomly
generates network topology set faulty lines turned pddl
encodings tool called net pddl implemented piergiorgio bertoli sylvie thiebaux
net pddl computes set lines supplied makes goal
instances generated make use randomnet default settings two exceptions
create increasing difficulty first maximal depth trees takes range
values twice default larger value harder second
percentage faulty lines ranges middle range harder
average bottom range realistic
instance suite contains instances small instances feature sources
middle instances feature sources large instances feature sources
large instances size typical real world instances even larger example
figure representative difficult instance middle set
f uture w ork
psr around time benchmark uncertainty expect
work done framework ipc facilitate acceptance one standard



fih offmann e delkamp hi ebaux e nglert l iporace r ug

benchmarks end developed psr resource web page giving access
relevant papers data tools net pddl randomnet one aspect future work
complete maintain website making available number already existing tools
sydre thiebaux et al domain specific system full psr matt grays
net jpeg graphically displays networks generated randomnet
considering future ipcs potential extending pddl encoding take numerical optimization aspects benchmark account pddl encodings partially
observable version benchmark exist bonet thiebaux ready used
future edition probabilistic part ipc
satellite
satellite domain introduced ipc long fox motivated nasa
space application number satellites take images number spatial phenomena
obeying constraints data storage space fuel usage ipc versions
domain corresponding different levels language pddl strips numeric simpletime
action durations constants time action durations expressions static variables
complex durations numerics e union numeric time
adaptation satellite domain ipc done jorg hoffmann ipc domain
versions example instances used except simpletime ipc domains
didnt want introduce extra version distinction difference constant
durations static durations top ipc versions domain versions added
idea make domain realistic additionally introducing time windows
sending image data earth e antennas visible satellites certain
periods time according derek long lack time windows main shortcoming
ipc domain
extended ipc time domain version two ipc domain versions time timewindows
time timewindows compiled extended ipc complex domain version two ipc
domain versions complex timewindows complex timewindows compiled cases introduced action sending data antenna antenna receive data
single satellite time antenna visible subsets satellites certain time
periods sending image takes time proportional size image time
windows modelled timed initial literals compiled domain versions
literals compiled artificial pddl constructs none domain versions uses adl
constructs versions single strips formulation
instances generated follows objectives clearly demonstrate effect
additional time windows produce solvable instances accomplish former
used ipc instances difference e g time time timewindows
lies additional time window constructs ensure solvability implemented tool read
plans produced one ipc participants namely tlplan arranged time
windows input plan suitable solve enriched instance important note
page available http rsise anu edu au thiebaux benchmarks pds
probabilistic part ipc feature partially observable domains
learned meantime lack time windows gathering data even
essential often due occlusion objects due rotation earth targets visible
restricted periods time probably constitutes one important future directions domain



fie ngineering b enchmarks



p lanning

time windows arranged exactly meet times extracted ipc
plan rather introduced one time window per take image actions made antenna
visible time window respective satellites let image size
individual image random value within certain range time window times
long sending time resulting maximum possible size
course generation process arranged rather arbitrarily resulting instances
might long way away typical characteristics satellite occurs
real world isnt nice best could without inside knowledge
application domain advantage enriched instances solvable directly
comparable ipc ones
domain versions derived complex introduced utilities time
window inside image sent earth image utility
windows decreases monotonically start time window random within
certain interval image put randomly one classes optimization
requirement minimize linear combination makespan fuel usage summed negated
image utility
settlers
settlers domain introduced ipc long fox makes extensive use
numeric variables variables carry domain semantics building
infrastructure unsettled area involving building housing railway tracks sawmills
etc domain included ipc order pose challenge numeric planners
domains mostly make much use numeric variables computing
static durations actions used exact domain file example instances
ipc except removed universally quantified preconditions improve accessibility
planners quantifiers ranged domain constants could easily replaced
conjunctions atoms
umts
roman englert working application area several years domain adapted
ipc stefan edelkamp roman englert
pplication omain
probably best known feature umts universal mobile telecommunication standard
higher bit rate holma toskala packet switched connections reach mega
bit per second mbps optimal case compared existing mobile networks umts provides
important feature namely negotiation quality service qos transfer
properties attributes define characteristics transfer throughput transfer delay data error rate umts bearers generic order provide good support
existing applications evolution applications applications services divided
note extent numeric values abstracted away pddl encoding
mostly airport pipesworld c f sections order obtain discrete encoding suitable
pddl style actions



fih offmann e delkamp hi ebaux e nglert l iporace r ug

class

constraints

examples

conversational
preserve time
relation
information flow
stream
conversational
pattern low delay
voice video
telephony
video games

streaming
preserve time
relation
information
entities
stream

interactive
request response pattern
preserve data
integrity

background
undefined
delay
preserve
data
integrity

streaming
multimedia

web browsing
network games

background
download
e mails

table umts quality service classes characteristics
four traffic classes qos ts holma toskala traffic classes
fundamental characteristics examples applications summarized table
main distinguishing factor classes delay sensitive traffic
conversational class delay sensitive approximately ms time preservation background class defined maximum delay
umts call set modularized perspective intelligent software agents
appleby steward busuioc since agents logical units enable discrete
perspective continuous signaling process call set partitioned following
modules executed sequential order englert
trm initial step initiation application mobile determination
required resources execution resources mobile display memory
checked terminal resource management trm allocated possible otherwise
execution aborted
ct wireless connection radio network initiated via dedicated control channel
gsm holma toskala case success transmission ready service
transferred via node b mobile order ensure connection timing ct
bearer service availability
information mobile location data handling capabilities sent application server internet cf aeei transmission done comfortably
called service agent farjami gorg bell controlled agent management cnd advantage service agent case failure e g
network resources sufficiently available agent negotiate terminals
agent another qos class different quality parameters
aeem service agent required qos class execution application
parameters mobile application sent mobiles agent execution environment
mobile aeem application server internet cf aeei
rrc radio resource controller rrc provisions allocates required qos logical resources mac level radio bearer holma toskala


fie ngineering b enchmarks



p lanning

rab bearer resources supplied physical level radio access bearer
rab cnd call flow set mapping logical qos parameters
physical qos resources together
aeei agent execution environment internet aeei establishes data transfer
core network pdn e g internet sends service agent controlled
application pdn order ensure qos application
bs finally bearer service bs execution mobile application established
required radio bearer resources qos messages sent modules trm
aeei start execution application
modules executed sequential order set call execution mobile
applications two modules aeem aeei executed time windows order
ensure agents life network however two constraints added first
intra application constraint modules one application ordered second interapplication constraint modules names different applications cannot executed parallel order ensure required resources available
ipc pddl daptation
besides action duration domain encodes scheduling types resources consuming
amount action initialization time releasing amount action ending time scheduling
types resources used benchmarks good news
temporal pddl level capable expressing fact used similar encoding
one found job flow shop one feature actions defined
temporarily produce rather temporarily consume resources current pddl way
stating resource constraints explicitly planners want exploit knowledge
look certain patterns increase decrease effects recognize additionally resource
modeling umts adaptation constrained important parameters total
real networks several hundred parameters applied
umts two subsequent actions check update value resources e g
mobile cpu starting resp ending time points far start resp ending events
separated time steps minimum slack time required two dependent
events modeling renewable resources construct invariant condition
action check start event change decided best choice
proper temporal action consequently temporal actions require resources available
adding amount used
finally time windows two agent modules defined average execution times modules average times estimated signaling durations
umts network holma toskala
resources may renewable consumable example renewable resource keyboard mobile used input data several applications consumable resources
terminology resources scheduling varies job shop scheduling machine resource
machine would domain object pddl renewable consumable resources
modeled numerical fluents per se distinguished



fih offmann e delkamp hi ebaux e nglert l iporace r ug

mobile cpu
available
e balance
mobile channels
available
num mobiles
num calls
mobile storage
logical channels
cell update
handover
active set
ggsn bitrate
max pdp
max apn

used x per cent per application
partition display e g ticker chess
energy balance mobile accumulator
used data transfer
number mobiles tractable
node b
mobile network load node b
memory im card
number logical channels available cn
report ue location rnc
handover required get higher bit rate
update connection
capacity kbit ggsn pdn
max packet data protocols per mobile
max access point names apn per mobile

table scheduling types resources umts call set
released action execution resources realized experiments summarized
table see gpp complete list resources umts call set
pddl representation domain eight modules umts
call set eight operators corresponding eight modules let us consider
example bs action final action used establish predicate bs ok
defined follows
durative action bs
parameters
application mobile l list ms ms message agent
duration
duration time bs
condition
start initiated
start aeei ok l
start qos params l
start message trm ms
start message aeei ms
effect
end iu bearer l end bs ok l

action preconditions successful execution module aeei call
set satisfaction required qos class parameters denoted list l transfered
messages set status application mobile pdn resources already
allocated preceding modules effect bearer network connection mobile
application set


fie ngineering b enchmarks



p lanning

initiation application starts mobile trm afterwards ct
asked ready service signal core call set radio access bearer
procedure cnd let us consider latter detail first step logical resources
must allocated rrc e g required number channels must provided logical
level radio bearer later logical resources mapped physical channels
pddl rrc action looks follows
durative action rrc
parameters
application mobile l list agent
duration
duration time rrc
condition
start ct ok l
start aeem ok l
start logical channels
max logical channels app channels
start cell update max cell update
start handover max handover
start active set max active set
effect
start increase logical channels app channels
end decrease logical channels app channels
start increase cell update
end decrease cell update
start increase handover
end decrease handover
start increase active set
end decrease active set
end rrc ok l

requested qos class available fact rab ok true service
agent must sent mobile order negotiate application user weaker qos
requirements case success predicate rab ok true connection pdn must
checked finally goal predicate bs fulfilled resources available
ipc omain tructure
used ipc umts domain six versions first three temporal domain
version timing constraints temporal timewindows domain version pddl timed
initial facts temporal timewindows compiled domain version pddl wrapper encoding timed initial literals second domain version set flaw temporal flaw temporaltimewindows flaw temporal timewindows compiled includes following flaw action
durative action flaw
parameters
application mobile l list agent
duration duration
condition


fih offmann e delkamp hi ebaux e nglert l iporace r ug

version
temporal
temporal tw
temporal twc
flaw temporal
flaw temporal tw
flaw temporal twc

formulation
strips temporal
strips temporal tw
strips temporal
strips temporal
strips temporal tw
strips temporal

max op







max act







table overview different domain versions umts abbreviations used temporaltw temporal timewindows temporal twc temporal timewindows compiled
max op maximum number parameterized pddl operators instance
max act maximum number ground actions instance data parentheses collected ffs reachability pre process see text

start initiated
start qos params l
start trm ok l
effect
end rab ok l
start initiated

action offers shortcut rab ok predicate used real solution
deletes initiated predicate action used heuristic functions
ignoring negative effects sense action encodes flaw may disturb
heuristic techniques used modern planners determine action useful negative interactions considered idea flaw practically motivated order see
heuristic planners react standard form domain big challenge
planners seen section domain versions one formulation namely stripsfluents temporal numerical fluents except typing adl constructs used
instances plan objective minimize makespan
domain versions numbers operators ground actions overviewed table
many empirical data umts seen data quite exceptional
time easy interpret first similar seen section data
actually constant across instances within domain version due
fact instances scale specification applications need actually started
second numbers operators actions differ versions without
time windows increase somewhat additional artificial actions compile
timed initial literals away c f section increase somewhat course introduce
flaw action third striking observation huge effect ffs reachability preprocessor building relaxed graph initial state removing actions
appear graph due technical subtleties encoding restrictions
feasible action instantiations partly implicit possible action sequences rather
explicit static predicates



fie ngineering b enchmarks



p lanning

ipc e xample nstances
umts call set domain following challenges task englert cremers
real time plans execution mobile applications generated appropriate time
done maximum duration exceed umts call set
time
completeness possible generate plan e optimal plan
required applications minimizes waiting period applications started
pddl structure basic discrete umts call set ducs domain
following
define ducs domain basic version
domain ducs domain basic version
objects ms ms message
application
mobile
l l l l l l l l l l list
ae agent
init time trm time ct
time time aeem
time rrc time rab
time aeei time bs

location types
authentification

mobile cpu current status

goal bs ok l ae

first pddl description come objects applications mobiles
come durations modules depending applications e g module trm requires
less time news ticker chess game since latter requires terminal resources
ticker current status resources initialized finally goal defined
bearer establishment execution start initiated mobile applications total execution
time minimized
ipc time windows varied small perturbations order generate different
instances perturbations motivated average execution times modules radio
network according load furthermore number applications set varied
domains assume applications run one mobile terminal however
distributed several mobile terminals different instances per domain version
f uture w ork
umts domain big challenge modern heuristic e hsp lpg style planners
planners satisficing potentially return sub optimal plans objective umts


fih offmann e delkamp hi ebaux e nglert l iporace r ug

minimize execution time one ignores objective task trivializes
optimal planners umts realistic challenge domain already relatively realistically
modelled except left additional constraints many less important resources
remains seen introducing resources planner particular optimal planner
performance gets degraded option case may introduce explicit language constructs
different types renewable consumable resources
future following two challenges shall investigated first negotiation umts
quality service qos parameters could considered assume video application mobile
terminal initiated bearer resources sufficiently available qos
negotiated terminal bearer leads negotiation
plan execution already initiated applications
second optimization umts call set applied wireless
lan registration challenge transfer qos parameters since current wireless lan
standard b contain qos demerit solved applying additional
service level addresses qos

references
gpp g partnership project www gpp org
appleby steward mobile software agents control telecommunication
networks chap hayzelden bigham j eds software agents future telecommunication systems springer
apt k blair h walker towards theory declarative knowledge foundations
deductive databases logic programming pp morgan kaufmann
bacchus f kabanza f temporal logics express search control knowledge
artificial intelligence
bacchus f subset pddl aips competition aips competition comitee available http www cs toronto edu aips pddl subset ps
bacchus f aips competition ai magazine
bertoli p cimatti roveri traverso p nondeterministic domains
partial observability via symbolic model checking nebel nebel
bertoli p cimatti slaney j thiebaux solving power supply restoration via symbolic model checking proceedings th european
conference artificial intelligence ecai pp lyon france wiley
biundo myers k rajan k eds icaps proceedings th international conference automated scheduling icaps monterey ca usa
morgan kaufmann
bloem r ravi k somenzi f symbolic guided search ctl model checking
conference design automation dac pp
blum l furst l fast graph analysis artificial
intelligence



fie ngineering b enchmarks



p lanning

boddy gohde j haigh harp course action generation cyber security
classical biundo et al biundo myers rajan pp
bonet b geffner h heuristic search artificial intelligence

bonet b loerincs g geffner h robust fast action selection mechanism
proceedings th national conference american association
artificial intelligence aaai pp mit press
bonet b thiebaux gpt meets psr giunchiglia e muscettola n nau
eds proceedings th international conference automated
scheduling icaps pp trento italy morgan kaufmann
busuioc distributed intelligent agents solution management complex
telecommunications services chap hayzelden bigham j eds software agents
future telecommunication systems springer
bylander computational complexity propositional strips artificial
intelligence
cesta borrajo eds recent advances ai th european conference
ecp toledo spain springer verlag
chen hsu c wah b sgplan subgoal partitioning resolution
edelkamp hoffmann j littman younes h eds proceedings th
international competition whistler bc canada jpl
chien kambhampati r knoblock c eds aips proceedings th
international conference artificial intelligence systems aips aaai press
menlo park
cimatti roveri traverso p automatic obdd generation universal
plans non deterministic domains proceedings th national conference
american association artificial intelligence aaai pp madison wi mit
press
clarke e grumberg peled model checking mit press
dierks h finding optimal plans domains restricted continuous effects uppaal cora icaps workshop verification validation model
scheduling systems
edelkamp promela workshop model checking software spin lecture notes computer science pp springer
edelkamp b taming numbers durations model checking integrated
system journal artificial intelligence
edelkamp jabbar action directed model checking petri nets
electronic notes theoretical computer science
edelkamp jabbar lluch lafuente action graph transition systems icaps workshop verification validation model
scheduling systems pp


fih offmann e delkamp hi ebaux e nglert l iporace r ug

edelkamp leue lluch lafuente directed explicit state model checking
validation communication protocols international journal software tools technology
englert r optimize umts call set execution mobile applications int journal applied artificial intelligence
englert r cremers b configuration applications rd generation mobile
communication ki workshop ai scheduling configuration design
puk vienna austria
farjami p gorg c bell f advanced service provisioning mobile agents
computer communications
fikes r e nilsson n strips application theorem proving
solving artificial intelligence
fourman p propositional aips workshop model theoretic approaches

fox long halsey k investigation expressive power pddl
saitta l ed proceedings th european conference artificial intelligence
ecai valencia spain wiley
fox long detection exploitation symmetry
pollack ed proceedings th international joint conference artificial
intelligence ijcai pp stockholm sweden morgan kaufmann
fox long pddl extension pddl expressing temporal
domains journal artificial intelligence
frank j cheeseman p stutz j gravity fails local search topology journal
artificial intelligence
garagnani correct efficient preprocessed domain axioms
development intelligent systems xvii springer verlag
gazen b c knoblock c combining expressiveness ucpop efficiency
graphplan steel alami steel alami pp
gerevini long plan constraints preferences aips competition comitee available http zeus ing unibs ipc pddl ipc pdf
gerevini saetti serina temporal scheduling
domains predictable exogenous events journal artificial intelligence

giunchiglia f traverso p model checking biundo fox
eds recent advances ai th european conference ecp
lecture notes artificial intelligence pp durham uk springer verlag
haslum p geffner h heuristic time resources cesta borrajo
cesta borrajo pp
hatzack w entwicklung und auswertung von algorithmen zur autonomen verkehrskoordinierung und konfliktauflsung flughfen ph thesis university freiburg freiburg
germany


fie ngineering b enchmarks



p lanning

hatzack w nebel b operational traffic control computational complexity solutions cesta borrajo cesta borrajo pp
helmert complexity standard benchmark domains artificial
intelligence
helmert heuristic causal graph analysis koenig et al koenig
zilberstein koehler pp
helmert personal communication
helmert fast downward system journal artificial intelligence accepted publication
helmert b complexity classical benchmarks long
smith eds proceedings th international conference automated
scheduling icaps pp english lake district uk morgan kaufmann
hoffmann j local search topology benchmarks empirical analysis
nebel nebel pp
hoffmann j local search topology benchmarks theoretical analysis
ghallab hertzberg j traverso p eds proceedings th international conference artificial intelligence scheduling aips pp toulouse
france morgan kaufmann
hoffmann j metric system translating ignoring delete lists numeric
state variables journal artificial intelligence
hoffmann j ignoring delete lists works local search topology benchmarks journal artificial intelligence
hoffmann j edelkamp deterministic part ipc overview journal
artificial intelligence
hoffmann j nebel b system fast plan generation heuristic
search journal artificial intelligence
holldobler stor h p solving entailment fluent calculus
binary decision diagrams icaps workshop model theoretic approaches
holma h toskala wcdma umts radio access rd generation mobile
communications wiley sons
holzmann g spin model checker primer reference manual addison wesley
holzmann g j design validation computer protocols prentice hall
howe dahlman e critical assessment benchmark comparison
journal artificial intelligence
kabanza f thiebaux search control temporally extended goals
biundo et al biundo et al pp
koehler j hoffmann j instantiation adl operators involving arbitrary
first order formulas ecai workshop scheduling design



fih offmann e delkamp hi ebaux e nglert l iporace r ug

koehler j nebel b hoffmann j dimopoulos extending graphs
adl subset steel alami steel alami pp
koehler j schuster k elevator control chien et al chien
kambhampati knoblock pp
koenig zilberstein koehler j eds icaps proceedings th international conference automated scheduling icaps whistler canada
morgan kaufmann
korf r e real time heuristic search artificial intelligence
kvarnstrom j doherty p haslum p extending talplanner concurrency
ressources horn w ed proceedings th european conference artificial
intelligence ecai pp berlin germany wiley
lago u pistore traverso p language extended goals
proceedings th national conference american association artificial
intelligence aaai pp edmonton al mit press
long fox automatic synthesis use generic types chien
et al chien et al pp
long fox rd international competition analysis
journal artificial intelligence
mcdermott heuristic estimator means ends analysis proceedings
rd international conference artificial intelligence systems aips
pp aaai press menlo park
mcdermott pddl domain definition language aips competition comitee available http ls www cs uni dortmund de edelkamp ipc docs pddl ps gz
mcdermott ai systems competition ai magazine
mcdermott v regression match graphs control search artificial
intelligence
milidiu r l dos santos liporace f plumber pipeline transportation planner
international workshop harbour maritime simulation hms pp rio de
janeiro brazil
milidiu r l dos santos liporace f b pipesworld applying systems
pipeline transportation proceedings international pipeline conference ipc pp

nebel b ed ijcai proceedings th international joint conference artificial intelligence ijcai seattle washington usa morgan kaufmann
nebel b compilability expressive power propositional formalisms
journal artificial intelligence
pednault e p adl exploring middle ground strips situation
calculus brachman r levesque h j reiter r eds principles knowledge
representation reasoning proceedings st international conference kr pp
toronto morgan kaufmann


fie ngineering b enchmarks



p lanning

reffel f edelkamp error detection directed symbolic model checking world
congress formal methods fm pp
rintanen j phase transitions classical experimental study koenig et al
koenig et al pp
ruml w fromherz line scheduling high speed manufacturing biundo et al biundo et al pp
steel alami r eds recent advances ai th european conference
ecp vol lecture notes artificial intelligence toulouse france
springer verlag
thiebaux cordier supply restoration power distribution systems
benchmark uncertainty cesta borrajo cesta borrajo pp

thiebaux cordier jehl krivine j p supply restoration power distribution systems case study integrating model diagnosis repair
horvitz e jensen f v eds proceedings th international conference
uncertainty ai uai pp portland oregon usa morgan kaufmann
thiebaux hoffmann j nebel b defense pddl axioms gottlob g ed
proceedings th international joint conference artificial intelligence ijcai
pp acapulco mexico morgan kaufmann
thiebaux hoffmann j nebel b defense pddl axioms artificial intelligence

ts rd generation partnership project technical specification group service
system aspects qos concept architecture release ts v gpp
vidal v lookahead strategy heuristic search koenig et al koenig et al
pp
wah b chen subgoal partitioning global search solving temporal
mixed space international journal artificial intelligence tools

yang c h dill l validation guided search state space conference
design automation dac pp
younes h littman weissman asmuth j first probabilistic track
international competition journal artificial intelligence




