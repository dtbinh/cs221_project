journal artificial intelligence

submitted published

clause term resolution learning evaluation
quantified boolean formulas
enrico giunchiglia
massimo narizzano
armando tacchella

giunchiglia unige
mox dist unige
tac dist unige

dist universita di genova
viale causa genova italy

abstract
resolution rule inference basis procedures automated reasoning procedures input formula first translated equisatisfiable
formula conjunctive normal form cnf represented set clauses deduction starts inferring clauses resolution goes empty clause
generated satisfiability set clauses proven e g clauses
generated
restrict attention evaluating quantified boolean
formulas qbfs setting outlined deduction process known
sound complete given formula cnf form resolution called qresolution used introduce q resolution terms used formulas disjunctive normal form computation performed available
procedures qbfs davis logemann loveland procedure dll propositional satisfiability corresponds tree q resolution terms clauses
alternate poses theoretical bases introduction learning corresponding
recording q resolution formulas associated nodes tree discuss
related introduction learning dll procedures present
solutions extending state art proposals coming literature propositional
satisfiability finally dll solver extended learning performs
significantly better benchmarks used qbf solvers comparative evaluation

introduction
resolution robinson rule inference basis procedures
automated reasoning see e g fermuller leitsch hustadt tammet bachmair
ganzinger procedures input formula first translated equisatisfiable formula conjunctive normal form cnf represented set clauses
deduction starts inferring clauses resolution goes empty clause
generated satisfiability set clauses proven e g clauses
generated restrict attention evaluating quantified boolean
formulas qbfs setting outlined deduction process known sound
complete given formula cnf form resolution called q resolution
used kleine buning karpinski flogel however available decision
procedures qbfs extend davis logemann loveland procedure
dll davis logemann loveland propositional satisfiability sat
c

ai access foundation rights reserved

figiunchiglia narizzano tacchella

propositional case well known computation performed dll corresponds
specific form resolution called regular tree resolution see e g urquhart
introduce q resolution terms used formulas disjunctive
normal form computation performed dll decision procedures
qbfs corresponds tree q resolution terms clauses alternate
correspondence poses theoretical bases introduction learning corresponding
recording q resolution formulas associated nodes tree particular
recording q resolutions clauses generalizes popular nogood learning constraint satisfaction sat literatures see e g dechter bayardo jr schrag
nogood corresponds set assignments falsifying input formula
useful pruning assignments existential variables recording q resolutions
terms corresponds good learning good corresponds set assignments satisfying input formula useful pruning assignments universal variables
discuss related introduction learning dll procedures
qbfs present solutions extending state art proposals coming literature
sat effectiveness learning qbfs evaluation
implemented qube state art qbf solver qube done
experimental tests several real world qbfs corresponding rintanen
castellini giunchiglia tacchella circuit verification scholl becker
abdelwaheb basin two primary application domains
interest witness effectiveness learning
structured follows first review basics quantified boolean
logic time introducing terminology notation used
throughout section introduce clause term resolution
relation dll decision procedures qbfs section introduce
nogood good learning effectively integrated dll
decision procedures qbfs implementation experimental
presented section ends conclusions related work
builds extends many ways aaai giunchiglia narizzano tacchella respect introduce clause
term resolution ii correspondence clause term q resolution
computation tree searched dll decision procedures iii basis
correspondence extend basic backtracking search procedure first backjumping
learning prove soundness completeness iv discuss
implementation qube providing many details v present
much broader detailed experimental analysis
simply write resolution q resolution

quantified boolean logic
consider set p symbols variable element p literal variable
negation variable following literal l
l variable occurring l
l negation l l variable l otherwise


ficlause term resolution learning quantified boolean formulas

sake simplicity consider formulas negation normal form nnf
thus us propositional formula combination literals k ary k
connectives conjunctions disjunctions following use true
false abbreviations empty conjunction empty disjunction respectively
qbf expression form
q z q z qn zn

n




every qi n quantifier existential universal
z zn distinct variables
propositional formula z zn
example
x yx x x x x x x



qbf
q z qn zn prefix matrix say literal l
existential l belongs prefix universal otherwise finally
define
level variable zi number expressions qj zj qj zj
prefix j qj qj
level literal l level l
example x existential level universal level x
existential level
value semantics qbf defined recursively follows
prefix empty evaluated according truth tables propositional
logic
x true x true x true
true true
l literal l zi l qbf
whose matrix obtained substituting
zi true z false l zi
zi false z true l z
whose prefix q z q z qi zi qi zi qn zn
easy see qbf without universal quantifiers determining
value reduces sat
two qbfs equivalent true false


figiunchiglia narizzano tacchella

resolution dll decision procedures qbfs
section first introduce clause term resolution dll decision procedures
qbfs correspondence two
clause term resolution
according definition qbf matrix combination conjunctions
disjunctions literals however common clause form transformations
renaming first used tseitin possible perform linear time conversion
arbitrary qbf equivalent one matrix conjunctive normal form
cnf conversions fact qbf equivalent
q z q z qn zn x x x

n


propositional formula literal
x variable distinct z z zn
x propositional formula obtained substituting one occurrences x
thus
x x
follows equivalent
x yx x x x x x x x x x x



thanks conversions restrict attention qbfs matrix
cnf represent matrix formula set clauses interpreted
conjunctively clause finite set literals interpreted disjunctively
assume clause non tautological minimal clause tautological
contains variable negation clause c minimal literals c
minimum level existential minimal form clause c clause obtained
c deleting universal literals cause c non minimal instance
clauses non tautological minimal assumption clauses
non tautological minimal restriction following theorem states
theorem let qbf matrix cnf let qbf obtained

eliminating tautological clauses
replacing non tautological non minimal clause minimal form
equivalent


ficlause term resolution learning quantified boolean formulas

proof clearly tautological clauses eliminated equivalent
qbf let c l ln ln lm non tautological non minimal clause
ln lm universal literals c min c n without
loss generality assume level li less equal level li
form p
q l ln ln lm qm zm qp zp l ln ln lm
standing
q l ln ln lm qm zm qp zp l ln ln lm
applying standard rules quantifiers rewritten
q l ln ln lm l ln ln lm qm zm qp zp
equivalent
q l ln ln lm l ln ln lm lm qm zm qp zp
equivalent
q l ln ln l ln ln lm lm qm zm qp zp
equivalent
q l ln ln lm qm zm qp zp l ln ln lm
e qbf obtained deleting lm clause c iterating
reasoning process literals c min c eliminated c hence
thesis

qbf cnf matrix conjunction clauses
clause minimal non tautological represent matrix qbf
set clauses
empty clause stands false
empty set clauses stands true
formula equivalent false
qbf written
x yx x x x x x x x x x x



clause resolution kleine buning et al similar ordinary resolution
existential literals matched precisely clause resolution literal l
rule
c
c

min c



figiunchiglia narizzano tacchella

c
c
c
c

x x
x
x x
x x

input
input
input
input

formula
formula
formula
formula

c
c
c
c

x
x
x







c
c
c
c

c
c
c
c

table clause resolution deduction showing false prefix x yx x

l existential literal
c c two clauses l l c c literal l l l l
c c
c c c l l
c c antecedents min c resolvent rule
theorem kleine buning et al clause resolution sound complete
proof system deciding qbfs cnf qbf cnf true empty
clause derivable clause resolution
instance fact false follows deduction table
alternatively cnf conversion could converted qbf
matrix disjunctive normal form dnf linear time basis qbf
equivalent
q z q z qn zn

n

assuming propositional formula literal variable distinct
z z zn
simple recursive application equivalence leads following
equivalent qbf
x yx
x x
x
x

x
x



given qbf matrix dnf represent matrix set terms
interpreted disjunctively term finite set literals interpreted
conjunctively assume term non contradictory minimal
term contradictory contains variable negation term minimal
literals minimum level universal minimal form term
term obtained deleting existential literals cause non minimal
terms non contradictory minimal analogously said
qbfs cnf qbf dnf assume terms
non contradictory minimal without loss generality


ficlause term resolution learning quantified boolean formulas

theorem let qbf matrix dnf let qbf obtained

eliminating contradictory terms
replacing non contradictory non minimal term minimal form
equivalent
proof analogous proof theorem



qbf dnf matrix disjunction
terms term minimal non contradictory
introduce term resolution literal l consists rule


min

l universal literal
two terms l l literal l l l l

l l
antecedents min resolvent rule
theorem term resolution sound complete proof system deciding qbfs
dnf qbf dnf true empty term derivable term resolution
proof fact term resolution sound complete proof system follows
soundness completeness clause resolution
let set sets literals q z q z qn zn qbf
interpreted set clauses without loss generality assume clause
non tautological minimal following chain equivalences holds
exists deduction empty clause clause resolution

false

qbf q z q z qn zn interpreted set terms true

deduction empty term term resolution
chain equivalences q q q



example term resolution deduction empty term consider qbf
x yx x x x x x x x x x x


figiunchiglia narizzano tacchella

e qbf obtained simultaneously replacing
deduction table deduction empty term
term resolution
qbf dnf cnf term resolution cannot applied
thus term resolution sufficient proving truth falsity however
following model generation rule

min

matrix
non contradictory term clause c c
get sound complete proof system qbfs cnf intuitively model generation rule allows us start minimal form terms propositionally entail
matrix input formula
theorem term resolution model generation sound complete proof system
deciding qbfs cnf qbf cnf true empty term derivable
term resolution model generation
proof given qbf cnf matrix model generation rule derive
set terms form min
term non contradictory clause c c

disjunction terms propositionally logically equivalent
let qbf dnf obtained substituting
value hence thesis thanks theorem


dll decision procedures qbfs
given said far arbitrary qbf converted linear time
equivalent qbf cnf end restrict
attention qbfs format assumption l literal
l zi redefine l qbf
whose matrix obtained removing clauses c l c
removing l clauses
whose prefix q z q z qi zi qi zi qn zn


ficlause term resolution learning quantified boolean formulas

extend notation sequence literals l l lm
defined l l lm
consider qbf
simple procedure determining value starts empty assignment
recursively extends current assignment z z z heuristically
chosen variable highest level empty clause empty set
clauses produced basis values z z value
determined according semantics qbfs value value
cadoli giovanardi giovanardi schaerf introduced improvements
basic procedure
first improvement directly conclude value
matrix contains contradictory clause lemma cadoli et al clause
c contradictory contains existential literal example contradictory clause
empty clause
second improvement allows us directly extend l l unit monotone
lemmas cadoli et al literal l
unit l existential
clause l l lm belongs
literal li universal level lower level l
monotone pure
l existential l belong clause l occurs
l universal l belong clause l occurs
example qbf form
x yx x x
x x unit qbf
x x x x x
monotone literals x
improvements resulting procedure called q dll essentially one
presented work cadoli giovanardi schaerf extends dll
order deal qbfs figure simple recursive presentation figure
given qbf
false returned contradictory clause matrix line otherwise
true returned matrix empty line otherwise
line recursively extended l l unit say l
assigned unit otherwise


figiunchiglia narizzano tacchella

function q dll

ha contradictory clause matrix return false

hthe matrix emptyi return true

hl unit return q dll l

hl monotone return q dll l

l ha literal highest level

hl existentiali return q dll l q dll l

else return q dll l q dll l
figure q dll
line recursively extended l l monotone say l
assigned monotone otherwise
literal l highest level chosen
l existential line extended l first say l
assigned left split false l tried returned
case say l assigned right split
otherwise line l universal extended l first say l
assigned left split true l tried returned
case say l assigned right split
theorem q dll returns true true false otherwise
proof trivial consequence lemmas work cadoli giovanardi
giovanardi schaerf semantics qbfs

given said far clear q dll evaluates generating
semantic tree robinson node corresponds invocation q dll
thus assignment us
assignment qbf possibly empty sequence l l lm
literals li li unit monotone highest level
l l li
semantic tree representing run q dll tree
node call q dll
edge connecting two nodes l l literal
tree representing run q dll least node
example run q dll consider qbf simplicity assume
literal returned line figure negation first variable prefix
occurs matrix qbf consideration tree searched
q dll represented figure figure


ficlause term resolution learning quantified boolean formulas

x x x x x x x x x
x hx li x
x x x x x x

x hx ri x
x x x x x x

hy ri x
hy li
hy li
hy ri x
hx pi x x hx ui x
hx pi x x hx ui x
x

x hx ui x
x x

figure tree generated q dll matrix shown root
node prefix x yx x u p l r stand unit pure left
split right split respectively obvious meaning

node labeled literal assigned q dll order extend assignment built far thus assignment corresponding node sequence
labels path root node instance assignment corresponding node label x x x
literals assigned unit monotone corresponding nodes aligned
one assigned literal l whether l
assigned unit monotone left right split marking u p l r
respectively
l assigned left right split matrix l
sequence literals assigned l
node leaf matrix empty case
write node contains contradictory clause case
write node
considering figure easy see q dll would correctly return false meaning thus false
resolution dll decision procedures qbfs
well known correspondence sat semantic trees resolution see e g
urquhart gives us starting point analysis aimed establish correspondence q dll clause term resolution
consider qbf let tree explored q dll evaluating
time assume dealing sat e
contain universal quantifiers q dll reduces dll false
use generate clause resolution deduction empty clause basic idea
associate node clause c falsified e


figiunchiglia narizzano tacchella

literal l c l say literal l assigned l lm
l l lm precisely
every leaf associate arbitrarily selected clause matrix
falsified least one clause exists contains empty
clause
c clause associated node l
l c c clause associated notice l monotone
l c
l c l unit clause associated resolvent
c arbitrarily selected clause causes l unit
l c l unit consider clause c associated
node l l c c clause associated
first case l c clause associated resolvent c c
lemma let qbf without universal quantifiers let tree searched
q dll let assignment false clause associated
node
falsified
contain existential literals whose negation assigned monotone

proof let set assignments extend clearly assignment
false contain universal quantifiers define partial
order relation according two assignments
extends clearly well founded minimal elements
assignments extending corresponding leaves
extends leaf contains contradictory clause c since
contain universal quantifiers c falsified associated node
clearly c contain existential literals whose negation assigned
monotone
induction hypothesis assignment l falsified
clause containing existential literals whose negation assigned monotone
thesis three cases
l assigned unit let c clause associated l induction
hypothesis thesis holds c c contain l thesis trivially follows
otherwise clause associated resolvent c c clause c
causes l unit c l falsified contain existential
literals whose negation assigned monotone c c c l l thus
thesis trivially holds
l assigned monotone case clause c associated
clause associated l induction hypothesis c contain l
thus c falsified


ficlause term resolution learning quantified boolean formulas

l split case clause c associated l clause c
associated l thesis holds c c induction hypothesis
c contain l clause associated c thesis
trivially holds otherwise c contain l clause associated
c thesis trivially holds otherwise clause associated
c c l l thesis trivially holds

theorem let false qbf without universal quantifiers tree searched qdll corresponds clause resolution deduction empty clause
proof let sequence clauses obtained listing clauses matrix
according arbitrary order followed clauses associated internal nodes
tree searched q dll assuming visited post order clearly
deduction deduction empty clause node associated
falsified clause lemma e empty clause

theorem points close correspondence computation q dll
clause resolution assuming input formula false contain
universal quantifiers input formula contain universal quantifiers true
still tree explored q dll generating path ending empty matrix
corresponds sequence clause resolutions one maximal subtree whose leaves
contains empty clause
longer assume input formula contain universal quantifiers
consider case arbitrary qbf situation gets complicated
possibility assigning unit literals highest level
assume literal l assigned unit node l highest
level
input formula false use tree searched q dll
generate clause resolution deduction empty clause construction analogous
one described difference restrict attention
minimal false subtree e tree obtained deleting subtrees
starting left split universal literal subtrees originated wrong
choices deciding branch explore first minimal false subtree
leaves terminate empty clause associate node
clause exactly way described sat case instance
q dll assigns unit literals highest level figure shows
minimal false subtree q dlls computation associated clause resolution
deduction empty clause figure
clause associated node written red right node

node corresponds assignment unit literal l clause
causes l unit node used corresponding clause resolution written
red left node


figiunchiglia narizzano tacchella

x x x x x x x x x
x hx li x
x x x x x x

x hx ri x
x x x x x x

hy ri x
x x hx ui x
x hx ui x
x x

hy ri x
x x hx ui x
x

figure clause resolution corresponding tree generated q dll
prefix x yx x

lemma let false qbf let minimal false subtree tree searched
q dll assume node l l unit l
highest level let assignment false clause associated
node
falsified
contain existential literals whose negation assigned monotone

proof trivial extension proof lemma assumption node l
l unit l highest level ensures clause associated
node falsified


theorem let false qbf let minimal false subtree tree searched
q dll assume node l l unit l
highest level corresponds clause resolution deduction empty
clause
proof given lemma proof analogous one theorem



regardless whether input formula true false tree explored q dll
may contain exponentially many subtrees whose nodes false
procedure described allows us associate clause resolution deduction
subtrees
input formula true situation simpler far unit
universal literals use tree searched q dll generate deduction
empty term intuitively process analogous one described
false except leaves term resolution deduction terms corresponding
assignments computed q dll entailing matrix details


ficlause term resolution learning quantified boolean formulas

first restrict attention minimal true subtree e tree
obtained deleting subtrees starting left split existential
literal analogously case false leaf minimal true
subtree terminates empty matrix
second associate node term represented set follows
term associated leaf minimal term min
contain universal literals assigned monotone
propositionally entail matrix e clause c matrix
c
subset literals e l l
term associated node l
l term associated node notice l
existential universal monotone l
l consider term associated node
l l term associated first case
l term associated resolvent
easy see term associated node entailed literal

lemma let true qbf let minimal true subtree tree searched
q dll let assignment true term associated
node
entailed
contain universal literals assigned monotone
proof analogous proof lemma



theorem let true qbf let minimal true subtree tree searched
q dll corresponds model generation term resolution deduction
empty term
proof let sequence terms obtained listing terms associated
nodes visited post order clearly model generation term resolution deduction deduction empty term node associated entailed
term lemma e empty term

regardless whether input formula true false tree explored
q dll may contain exponentially many subtrees whose nodes associated
sake efficiency important term satisfies properties however
necessary time discussed next section



figiunchiglia narizzano tacchella

x x x x x x x x x
x hx ri x
x hx li x
x x x x x x x x x x x x
hy li
hx pi
x

hy li
hx pi
x

figure term resolutions corresponding tree generated q dll
prefix x yx x

x x x x x x x x x
x hx li x
x x x x x x

x hx ri x
x x x x x x

hy li
hy li
hy ri x
hy ri x
hx pi x x hx ui x
hx pi x x hx ui x
x
x
x hx ui x x
x x

figure resolution corresponding tree generated q dll prefix
x yx x

assignments true described procedure allows us associate
term resolution deduction subtrees instance
two maximal subtrees roots x x associated deductions
represented figure figure
represent nodes along path root subtrees
term associated node written green right node

leaf non contradictory term entailing matrix whose minimal
form min associated written green left
merging trees figures obtain whole tree deductions corresponding search tree explored q dll represented figure clause
term resolutions intermixed


ficlause term resolution learning quantified boolean formulas

consider case input qbf false longer assume
literals assigned unit highest level restrict
attention minimal false subtree tree searched q dll
procedure described associating clause node may longer work
one thing given leaf may falsified clauses matrix input
formula however guaranteed existence contradicted clause
matrix input formula clause c contradicted
literal l c l
existential literal l c l
long associate node contradicted clause belonging
matrix obtained clause resolution corresponds clause resolution
deduction empty clause indeed clause associated root
empty remember resolvent clause resolution minimal form thus
obvious solution try associate
leaf contradicted clause input formula
internal node contradicted clause obtained resolving input clauses
previously deduced clauses along lines outlined
cases process runs smoothly consider instance qbf form
x x yx x x x x x x



assume split x occurs first following path explored
conventions figure
hx li
hx ui
hx ui




clause associated node
hx li
x x hx ui
x x hx ui


x
x
x
x x

see
clause associated leaf x x x falsified contradicted

respect definition contradictory clause given section clear clause c
contradictory contradicted qbf assignment exists
contradicted clause matrix contains contradicted clause
contains contradictory clause



figiunchiglia narizzano tacchella

function rec c resolve c c l

l l c l c

return c resolve c c

l han existential literal c level level literals c

c ha clause causes l unit l prefix

c c resolve c c

return rec c resolve c c l
figure rec c resolve
able associate node contradicted clause
unfortunately cases things run smoothly e may possible
associate clause internal node simple single resolution input
previously deduced clauses indeed clause resolutions may blocked
universal variables occurring clauses used resolution
consider instance qbf form obtained replacing clause x x
x x
x x yx x x x x x x



would still valid path corresponding clause resolutions would
hx li
x x hx ui
x x hx ui
x x



possible perform clause resolution associated node
label hx ui example clause resolution may blocked
blocking universal literal l
l l
l c l c
since c c minimal form possible c c contain
existential literal l
level less equal level literals clause
assigned unit
obvious solution get rid e g blocking literals l c resolving
away c existential literals level lower level l
idea behind procedure rec c resolve figure figure
assume
input qbf


ficlause term resolution learning quantified boolean formulas

l assignment
l existential literal unit highest level
c clause containing l minimal form l contradicted
c clause containing l minimal form l contradicted l unit
c clause causes l unit
c resolve c c returns resolvent clause resolution two
clauses c c
h c c l satisfies first conditions say
pair hc c l rec c resolved given two clauses hc c
l rec c resolved
set universal literals blocking clause resolution c c
computed line
empty simply return resolvent c c line
otherwise
pick existential literal l c minimum level c line l
assigned unit earlier search consider clause c caused
l assigned unit line c resolvent c c line
rec c resolve c c l returned line
hc c l rec c resolved rec c resolve c c l returns minimal clause contradicted without existential literals whose negation
assigned monotone formally stated following lemma
lemma let c c two clauses hc c l rec c resolved
qbf rec c resolve c c l terminates returns clause
minimal form contradicted
contain existential literals whose negation assigned monotone
proof lemma quite long reported appendix
assuming input qbf false construction deduction empty
clause associated minimal false subtree tree searched q dll
following
every leaf associate clause c input formula contradicted
c clause associated node l
l c l universal c clause associated parent
l e node notice l existential monotone
l c


figiunchiglia narizzano tacchella

l c l unit clause associated node
rec c resolve c c l c clause causes l
unit
l c l existential unit consider
clause c associated node l l c c clause associated
first case l c clause associated node
rec c resolve c c l
example reference deduction blocked resolution one associated node x x x rec c resolve x x x x x x x
line resolves x x x x resolvent c min x x
x x
following recursive call rec c resolve x x x x x x x line
returns x x
thus clause associated node
hx li
x x hx ui
x x hx ui


x
x
x x
x x

notice reference figure choice eliminating blocking literals
c maintaining c invariant arbitrary indeed could eliminate blocking
literals c maintain c invariant case deduction amounts
eliminate universal literal x x resolving clause x x
x get resolvent x x leads following legal deduction
hx li
x x hx ui
x x x x x x hx ui


x
x
x x
x x

lemma let false qbf let minimal false subtree tree searched
q dll let assignment false clause associated
node
minimal form contradicted
contain existential literals whose negation assigned monotone

proof construction clause associated leaf contradicted
clause c associated internal node contradicted
assuming clause c associated child l l contradicted
child l assume clause c associated child l l contradicted


ficlause term resolution learning quantified boolean formulas

l c l universal c c hence c minimal form since l c
l universal c l contradicted c contradicted thesis
follows c c
l c l unit c rec c resolve c c l c
clause causes l unit thesis follows lemma
l c l existential unit consider clause
c associated node l assuming l c otherwise would first
case clause associated rec c resolve c c l
previous case thesis follows lemma

theorem let false qbf let minimal false subtree tree searched
q dll corresponds clause resolution deduction empty clause
proof given lemma proof analogous one theorem



backjumping learning dll procedures qbfs
section first computing resolvent associated node allows
backjump branches backtracking subsection
learning resolvents allows prune search tree branches different ones
resolvents computed learned subsection
conflict solution directed backjumping
procedure described section uses standard backtracking schema whenever
empty clause resp matrix generated q dll backtrack first existential
resp universal literal assigned left split instance given qbf
x x x x x x x x
x x x x x x



tree searched q dll represented figure use conventions
section
work giunchiglia narizzano tacchella shown
exploration branches necessary particular input qbf
assignment possible compute reason un satisfiability
backtracking intuitively speaking reason subset
literals assignment
assigns true false literals assigned e l
l l l
extends e l l


figiunchiglia narizzano tacchella


x x x x x
x x x x x x
hy li
x x x x x
hy li
x hx ui
x x hx ui
x x

hy ri
x x x x x x

hy ri
x x x x
hx li
hx ui


hx li
x x hx ui
hy pi
x hx ui
x

hx ri
hx pi
hy pi
hx ui


figure resolution corresponding tree generated q dll prefix
x x x

equivalent computing reasons avoid right split
literal l l reason assigning l false would change
resulting procedure generalization qbf popular conflict directed backjumping
cbj prosser b introduces concept solution directed backjumping
sbj avoiding useless splits universal variables
later giunchiglia narizzano tacchella possible
optimize computation reasons particular shown
assuming unsatisfiable consider reasons subset existential
literals
assuming satisfiable consider reasons subset universal
literals
apart optimizations tree searched procedures described former
latter papers case exploration branches
starting hy ri hx ri skipped see figure
computation resolutions corresponding q dll allows
avoid exploration branches pretty much cbj sbj case
qbf branches skipped skipped cbj sbj
key point think q dll procedure producing clause resp term
deduction empty clause resp term proving unsatisfiable resp satisfiable
according rules use associating deduction tree searched qdll
c clause associated node l l c clause associated
node c even l existential assigned left split


ficlause term resolution learning quantified boolean formulas

function q dll bj

ha clause c contradictedi

return c

hthe matrix emptyi return modelgenerate

hl unit

c ha clause matrix causes l unit

w r q dll bj l

hw r termi l w r return w r

return rec c resolve w r c l

hl monotone return q dll bj l

l ha literal highest level

w r q dll bj l

hl existentiali hw r termi l w r return w r

hl universali hw r clausei l w r return w r

w r q dll bj l

hl existentiali hw r termi l w r return w r

hl universali hw r clausei l w r return w r

hl existentiali return rec c resolve w r w r l

return resolve w r w r l
figure q dll bj
analogously term associated node l l term
associated node even l universal assigned left
split
rules take account clause term associated node l
thus need explore branch starting l
consider example figure use standard conventions e g write
clause resp term associated node red resp green right
node reference figure clear considering term associated
node need explore branch starting hy ri order
associate entailed term node similarly considering empty clause
associated node x need explore branch starting
hx ri order associate contradicted clause node
procedure q dll bj figure incorporates ideas figure
modelgenerate returns minimal form non contradictory entailed
term
clause c c
universal literal l assigned monotone l
rec c resolve c c l figure


figiunchiglia narizzano tacchella

resolve returns resolvent term resolution two terms

behavior q dll bj illustrated words saying q dll bj
computes returns clause term would associated node tree
explored q dll particular assuming
w r clause resp term returned q dll bj l
l existential resp universal
l assigned left split
q dll bj explore branch starting l l w r resp l w r
see line resp line q dll bj
far reference figure interpret clause resp term red
resp green right node value returned q dll bj
considering term associated node q dll bj explore
branch starting hy ri similarly considering empty clause associated
node x q dll bj explore branch starting hx ri
theorem q dll bj returns empty clause false empty term
true
proof sketch enough notice
node associated clause c c contradicted c
sequence clause resolutions
node associated term entailed
sequence model generations term resolutions
previous section
empty clause associated initial node false
empty term associated initial node true



learning
learning well known technique sat avoiding useless traversal branches
sat learning amounts storing clause resolvents associated nodes tree
explored dll resolvents called nogoods simply added set
input clauses
case qbfs situation different complicated indeed
two types resolutions term clause resolvents clause resolutions
added conjunctively matrix resolvents term resolutions
call goods considered disjunction matrix
practice handle three sets formulas


ficlause term resolution learning quantified boolean formulas

set terms corresponding goods learned search
set clauses corresponding matrix input qbf
set clauses corresponding nogoods learned search
formally qbf form qbf extended learning eqbf
expression form
q z qn zn h
n


set terms called goods interpreted disjunctively good
obtained model generation term resolution
set clauses called nogoods interpreted conjunctively nogood
obtained clause resolution
clearly
q z qn zn

q z qn zn
equivalent
initially empty set input set clauses search
proceeds
nogoods determined backtracking contradiction e assignment unsatisfiable possibly added
goods determined backtracking solution e assignment
satisfiable possibly added
following use term constraints want refer goods
nogoods indifferently
consider eqbf constraints search
pruned considerably indeed descending search tree literal assigned
long guaranteed reconstruct valid clause term deduction
backtracking empty clause term availability already derived clauses terms
allows prune search constraints given assignment
exists contradicted clause c resp satisfied term stop
search return c resp term satisfied
literal l l
universal literal l l
clearly entailed term satisfied extend notion unit
take account constraints literal l
unit eqbf


figiunchiglia narizzano tacchella

function rec resolve w w l

l l w l w

return resolve w w

l ha literal w level level literals w

w ha constraint causes l unit l prefix

w resolve w w

return rec resolve w w l
figure rec resolve
l existential
clause l l lm belongs
expression li occurs right l prefix

l universal
term l l lm belongs
expression li occurs right l prefix

definition monotone literals crucial property ensured
dealing eqbfs existential resp universal literal l assigned monotone
l never enter nogood resp good associated node extending l
guaranteed defining literal l monotone pure
l existential l belong constraint
l universal l belong constraint
possibility assigning universal literals unit may case
term resolutions may blocked existential literals l l
occurring one terms used antecedents term resolution however
procedure rec c resolve presented subsection easily generalized
work case constraints resolved terms
procedure rec resolve w w l figure assumed
eqbf
ways guarantee existential literal l assigned monotone l
enter nogood associated node extending l another one
keep definition existential monotone literal unchanged existential literal assigned
monotone l belong clause
update proceed search updated c c l c
analogously universal monotone literals see work giunchiglia narizzano tacchella details possibilities including discussion interaction
monotone rule learning



ficlause term resolution learning quantified boolean formulas

l assignment
l existential resp universal literal unit highest level

w clause resp term containing l resp l minimal form l contradicted
resp l satisfied
w clause resp term containing l resp l minimal form l contradicted
resp l satisfied l unit w clause resp term
causes l unit
existential resp universal literal l assigned unit l l
prefix l clause resp term causes l unit

resolve w w returns c resolve w w resp resolve w w
h w w l satisfy first conditions say pair hw w
l rec resolved
l defined eqbf obtained
removing resp clauses c resp terms l c resp
l removing l resp l clauses resp terms

removing q l prefix
l l lm defined l l lm
hw w l rec resolved rec resolve w w l returns
constraint minimal form contradicted satisfied stated following
lemma
lemma let w w two clauses resp terms hw w lrec resolved eqbf rec resolve w w l terminates returns minimal
clause resp term
contradicted resp satisfied
contain existential literals whose negation resp universal literals
assigned monotone
proof sketch proof equal resp analogous proof lemma l
existential resp universal

procedure q dll ln incorporates definitions ideas
represented figure considering figure
definition modelgenerate relaxed respect definition provided subsection order return minimal form non contradictory
satisfied term


figiunchiglia narizzano tacchella



function q dll ln

q hthe prefix

hthe matrix

ha contradicted clause c

return c

ha satisfied term

return

hthe matrix emptyi return modelgenerate

hl unit qh

w ha constraint causes l unit qh

w r q dll ln l

hl existentiali hw r termi l w r return w r

hl universali hw r clausei l w r return w r

w r rec resolve qh w r w l

learn w r

return w r

hl monotone qh return q dll ln l

l ha literal highest level

w r q dll ln l

hl existentiali hw r termi l w r return w r

hl universali hw r clausei l w r return w r

w r q dll ln l

hl existentiali hw r termi l w r return w r

hl universali hw r clausei l w r return w r

w r rec resolve qh w r w r l

learn w r

return w r
figure q dll ln
clause c c
universal literal l assigned monotone l
learn w r updates set goods nogoods according given policy
simply assume learn w r updates respectively
satisfy following conditions
subset w r w r term otherwise
subset w r w r clause otherwise
existential resp universal literal l assigned unit initial prefix
l resp still contains clause resp term causes l
assigned unit qh


ficlause term resolution learning quantified boolean formulas

reference figure last condition necessary order guarantee
existence constraint w satisfying condition line
conditions learn w r general ensure soundness
completeness q dll ln
theorem q dll ln returns empty clause false empty term
true
proof analogous proof theorem



understand benefits learning assume input qbf corresponding
eqbf
x yx x h x x x x x x x x x
search proceeds figure first path leading empty matrix
starts term resolution process assuming term min x added
set goods checking value x soon x assigned true
detected unit correspondingly assigned
path corresponding assignment x explored
example shows good learning avoid useless exploration branches
would explored backtracking backjumping schema indeed
assuming deduced term learned backtracking policy according
learn w r simply adds w r
w r clause
otherwise
easily implemented however simple policy may easily lead store exponential number goods nogoods notice call learn w r
literal assigned unit right split thus practical implementations incorporate
policies guaranteed space bounded e ones store polynomial number goods
nogoods sat three popular space bounded learning schemes
size learning order n dechter nogood added
cardinality less equal n added never deleted
relevance learning order n ginsberg given current assignment
nogood c added deleted soon number
literals l c l bigger n
unique implication point uip learning marques silva sakallah
nogood c stored c contains one literal maximum decision
level given assignment decision level literal l number
splits done l uip learning set added clauses
periodically inspected clauses deleted according criteria


figiunchiglia narizzano tacchella

thus size learning nogood stored never deleted relevance uip
learning nogoods dynamically added deleted depending current assignment see work bayardo details related size relevance
learning including complexity analysis work zhang madigan moskewicz
malik discussion uip learning mechanisms sat size
relevance uip learning possibilities limiting
number stored clauses one generalized ways considering
qbfs instead sat formulas next section present particular learning
schema implemented qube

implementation experimental analysis
section first describe details implementation nogood good
learning qube report experimental analysis conducted order
evaluate separate benefits nogood good learning relative efficiency
solver compared state art qbf solvers
implementation qube
evaluate benefits deriving learning implemented good nogood learning qube qube qbf solver search non random
instances compares well respect state art solvers search
semprop letz yquaffle zhang malik e best solvers
search non random instances according le berre simon tacchella
see giunchiglia narizzano tacchella c details
besides learning version qube used features
efficient detection unit monotone literals lazy data structures gent
giunchiglia narizzano rowley tacchella
branching strategy exploits information gleaned input formula initially
leverages information extracted learning phase
see giunchiglia narizzano tacchella b description characteristics
learning computation nogoods goods corresponding internal
nodes search tree carried clause term resolution
working reason initialized backtracking starts reasons stored
descending search tree
unit literal stored reason constraint literal unit
literal assigned right split stored reason constraint computed
backtracking left branch
monotone literals way working reasons initialized ensures existential
resp universal monotone literals never belong working reason computed
backtracking contradiction resp solution


ficlause term resolution learning quantified boolean formulas

assume l l lm assignment corresponding leaf consideration considering initializing working reason way
qube
return contradicted clause matrix input qbf set learned
nogoods contradiction
compute minimal form satisfied prime implicant matrix contains universal literals possible solution
second case computation prime implicant important order short
reasons possible universal literals important order backjump
nodes requirements met recursively removing irrelevant literals
set literals starting universals ones given set literals say
literal irrelevant clause c matrix l c exists another
literal l l v
c prime set literals recursive
procedure term prime
satisfied
prime implicant matrix input qbf
exist another term satisfying first two properties
smaller set inclusion set universal literals
order reduce number universal literals initial goods take
advantage fact assignment may partial literal l may
case neither l l use existential literals
level lower level universal literals assigned left split
order reduce number universals prime fact sequence
literals extending existential literals set universals prime subset
prime instance considering qbf x x
prime x x
extend x prime x x x
finally evaluating universal literals irrelevant follow reverse
order assigned order try backjump high possible
search tree
said previous section besides setting initial working
reason another learning unconstrained storage clauses resp terms
obtained reasons conflicts resp solutions may lead exponential memory
blow practice necessary introduce criteria
limiting constraints learned
unlearning


figiunchiglia narizzano tacchella

implementation learning qube works follows assume backtracking
literal l assigned decision level n constraint corresponding reason
current conflict resp solution learned following conditions satisfied
l existential resp universal
assigned literals reason except l decision level strictly lower
n
open universal resp existential literals reason l
prefix
notice three conditions ensure l unit constraint corresponding
reason qube learned constraint backjumps node
maximum decision level among literals reason excluding l say l
unique implication point uip therefore lookback qube uip
notice definition uip generalizes qbf concepts first described silva
sakallah used sat solver grasp sat instance qube lookback
scheme behaves similarly uip learning scheme used zchaff described
zhang et al even qube guaranteed learn one clause resp term
per conflict resp solution still number learned constraints may blow
number backtracks exponential stop course qube scans periodically
set learned constraints search became irrelevant e clauses resp
terms number open literals exceeds parameter n corresponding
relevance order thus implementation uses uip learning decide store
constraint relevance criteria decide forget constraint
experimental analysis presented next subsection parameter n set
set learned constraints scanned every nodes
besides learning mechanism current version qube features lazy data
structures unit literal detection propagation described gent et al
monotone literal fixing described giunchiglia et al variable state independent decaying sum heuristic vsids introduced sat moskewicz madigan
zhao zhang malik sat basic ideas heuristic initially
rank literals basis occurrences matrix ii increment weight
literals learned constraints iii periodically divide constant weight
literal
experimental
evaluate effectiveness implementation considered formal verification benchmarks constituted part qbf solvers comparative
evaluation instances comes verification described scholl
becker abdelwaheb basin remaining domains described rintanen castellini giunchiglia tacchella start
analysis considering qube without learning enabled versions qube
respect non random instances used qbf comparative evaluation test set
include qbf encodings modal k formulas submitted pan vardi



ficlause term resolution learning quantified boolean formulas

figure effectiveness learning qube versus qube cbj sbj cpu time left
number backtracks instances solved solvers right

compute goods nogoods order backjump irrelevant existential universal
branching nodes differ treatment computed goods nogoods
learning enabled qube records goods nogoods
learning disabled qube records neither nogoods goods
call two versions qube cln sln qube cbj sbj respectively order
specify type look back used two systems notice consider
qube backtracking e version computes neither nogoods goods
performs simple chronological backtracking competitive
solvers
experiments run farm identical pcs one equipped
pentium ghz processor gb ram running linux debian sarge finally
system timeout value per instance
figure left shows performances qube cln sln versus qube cbj sbj
plot x axis cpu time qube cln sln axis cpu time
qube cbj sbj plotted point hx yi represents benchmark qube cln sln
qube cbj sbj take x seconds respectively convenience plot
points hx xi representing benchmarks solved qube cln sln x seconds
first observation learning pays
principle one point hx yi could correspond many benchmarks solved qube cln sln
qube cbj sbj x seconds respectively however scatter diagrams
present point except point h representing instances solvers
time corresponds single instance cases



figiunchiglia narizzano tacchella

figure effectiveness learning random heuristic qube rnd cln sln versus qube rnd cbj sbj cpu time left number backtracks
instances solved solvers right

qube cln sln resp qube cbj sbj able solve resp instances
solved qube cbj sbj resp qube cln sln
among instances solved solvers qube cln sln resp qube cbj sbj
least one order magnitude faster qube cbj sbj resp qube cln sln
resp instances
order implementation quality independent measure pruning introduced
learning right plot figure shows number backtracks e number
solutions conflicts found qube cbj sbj versus qube cln sln
solved systems plotted point hx yi represents benchmark
solved qube cln sln qube cbj sbj performing x backtracks
respectively seen learning substantially prunes search space
point diagonal meaning never case qube cbj sbj performs
less backtracks qube cln sln still learning overhead thus
pruning caused learning pays terms speed proved
points diagonal left plot
experimental data entirely satisfactory two reasons
first learning heuristic tightly coupled qube whenever qube learns
constraint increments score literals qube cbj sbj constraint
imply tree searched qube cln sln subtree tree searched
qube cbj sbj indeed literal selected branching node two systems guaranteed




ficlause term resolution learning quantified boolean formulas

figure effectiveness conflict learning
qube rnd cln sln versus
qube rnd cbj sln cpu time left number conflict backtracks
instances solved solvers right

ever learned consequence qube cbj sbj literals initially sorted
basis occurrences input qbf ii score literal periodically
halved becomes literals score literals prefix
level chosen according lexicographic order
second independently heuristic used plot showing performances
qube without learning say two learning schemes conflict
solution effective gent rowley
address first consider qube random heuristic e heuristic
randomly selects literal among maximum level yet assigned
call resulting systems qube rnd cln sln qube rnd cbj sbj respectively
names suggest first learning enabled second learning
disabled randomness run solver times instance
define qube rnd cln sln system whose performances
instance th best among obtained running qube rnd cln sln
instance qube rnd cbj sbj defined analogously
figure shows cpu time left number backtracks solved instances
right qube rnd cln sln qube rnd cbj sbj plots easy
see qube rnd cln sln faster qube rnd cbj sbj cases
witness fact
qube rnd cln sln resp qube rnd cbj sbj able solve resp instances solved qube cbj sbj resp qube


figiunchiglia narizzano tacchella

figure effectiveness solution learning
qube rnd cln sln versus
qube rnd cln sbj cpu time left number solution backtracks instances solved solvers right

among instances solved solvers qube resp qube cbj sbj least
one order magnitude faster qube cbj sbj resp qube resp
instances
still longer case enabling learning causes reduction number
backtracks different literals selected branching node
pruning node may prevent long backjump prosser
would cause vast reduction search space interestingly comparing
figure seems random heuristic learning becomes important
fact witnesses setting well known tension look ahead look back
techniques smart look ahead makes look back less important viceversa
address second considered systems qube rnd cbj sln
qube rnd cln sbj e systems obtained qube rnd cln sln disabling
conflict learning solution learning respectively usual system run times
instance qube rnd cbj sln qube rnd cln sbj
defined left plots figures performances
qube rnd cln sln versus qube rnd cbj sln qube rnd cln sbj respectively measured number backtracks however order better
highlight pruning due conflict resp solution learning right plot figure
resp shows number conflict resp solution backtracks qube rnd cbj sln
resp qube rnd cln sbj plots see conflict solution
learning prune search space pay plot points
well diagonal comparing two left plots see test set


ficlause term resolution learning quantified boolean formulas

qube rnd cln sln
qube rnd cln sln
qube rnd cln sln
qube rnd cln sln
qube rnd cln sln
qube rnd cbj sbj
qube rnd cbj sbj
qube rnd cbj sbj
qube rnd cbj sbj
qube rnd cbj sbj
qube rnd cbj sln
qube rnd cbj sln
qube rnd cbj sln
qube rnd cbj sln
qube rnd cbj sln
qube rnd cln sbj
qube rnd cln sbj
qube rnd cln sbj
qube rnd cln sbj
qube rnd cln sbj






























































































































































































table comparison among versions qube row compares system written first column respect qube rnd cln sln taken reference
qube rnd cln sln b solver first column
columns report number b solve
time b solve takes less time b b solve
takes time b solves b solve
b b solve b solve
least one order magnitude faster b solve
least one order magnitude slower b solve
number timeouts qube rnd cln sln
considered solution learning helps solving conflict learning
qube rnd cbj sln times qube rnd cln sbj times
hand two right plots suggest conflict learning prunes solution learning conclusion correct indeed plot shows number
conflicts number solutions pruning node matter whether existential
universal may avoid finding exponentially many solutions conflicts particular
given instances cnf thus form
yx x xn
n pruning variable x x xn potential prune n conflicts


figiunchiglia narizzano tacchella

detailed quantitative information cpu times reported table last column table see indicate
number timeouts system
qube rnd cln sln

qube rnd cbj sln
qube rnd cbj sbj
qube rnd cln sbj

gives indication capacity solvers e ability solve
order get indication productivity e considering
solve ability solve quickly consider number fs
difference columns lower fs better

fs qube rnd cln sln

fs qube rnd cbj sln
fs qube rnd cbj sbj
fs qube rnd cln sbj

clear conflict solution learning
allow improve capacity productivity experimental thus seem
contradict negative reported gents rowleys work solution
look back mechanisms however comparable given
different mechanisms implemented respective solvers e g computing
initial solution monotone literal fixing different experimental setting e g
testset

conclusions related work
extends giunchiglia et al introduces nogood
good learning qbfs satisfiability correspondence computation trees searched dll qbf solvers clause term resolution deductions
nogoods goods clauses terms respectively resolution deductions
perspective learning simply amounts storing nogoods goods
incorporate nogoods goods learning dll qbf solvers considering
eqbfs qbfs extended learning illustrate means examples
computation nogoods goods
allows solution conflict directed backjumping spirit giunchiglia et al

stored allows pruning branches parts search tree
present high level description incorporating ideas formally
prove soundness completeness discuss related effective
implementations dll qbf solvers present details implementation qube state art qbf solver experimental analysis shows qube
enhanced nogood good learning effective considering selection
nonrandom consisting formal verification benchmarks
qube competitive respect state art


ficlause term resolution learning quantified boolean formulas

already said work builds giunchiglia et al papers dealing
learning qbfs satisfiability letz zhang malik gent
rowley particular letz conflict solution learning called lemma
model caching proposes technique model caching dealing qbfs variable independent subformulas zhang malik propose
conflict learning extended solution learning zhang malik b
second terms called cubes gent rowley introduce form
solution learning technique revisits less solutions standard techniques
experimental reported positive works share
intuitions thus propose similar techniques though difficult establish
precise relation among works due differences terminology
different level detail presentations believe main differences
implementation level e way solution conflict learning implemented
therefore quite difficult impossible compare different alternatives without
implementing recasting different learning mechanisms even different solvers
common framework indeed specific learning mechanism implemented within
solver may motivated characteristics solver e g data structures used heuristic instance watched data structures used e g
qube yquaffle semprop allow efficient detection propagation unit pure literals gent et al consequence solvers watched
data structures may profitably maintain huge databases goods nogoods solvers
standard data structures costs involved managing huge databases may
overwhelm advantages considering solvers whole experimental
analysis conducted giunchiglia et al c shows solver qube compares
well respect semprop yquaffle formal verification
benchmarks considered

acknowledgments
would thank ian gent andrew rowley discussions related subject
anonymous reviewers suggestions corrections work
partially supported miur

appendix proof lemma
proof well founded induction thus steps follow
definition well founded order tuples hc c l
proof thesis holds minimal elements partial order
assuming thesis holds tuples hc c l hc c l
hc c l proof thesis holds hc c l
instance letz zhang malik b initial work giunchiglia et al
method used computing initial working reason corresponding solution procedure
modelgenerate figure detailed



figiunchiglia narizzano tacchella

deliberately omitted properties elements tuples
hc c l partial order satisfy indeed standard assumption would
c c two clauses hc c l rec c resolved however
sufficient indeed may happen starting two clauses hc c
l rec c resolved line numbers refer figure
set l l c l c l universal empty see line
clause c computed line figure l contradicted thus
tuple hc c l element partial order
better understand consider following simple example
x x x x x x x x x x x x x



qbf
x x x x assignment producing contradictory clause
h x x x x x x x x x rec c resolved
rec c resolve x x x x x x x x x x
causes call rec c resolve x x x x x x x x x
clause c x x x x x x contradicted
b returns clause x x x x x contradicted expected
fact universal literal causes c x x x x contradicted
appear clause returned rec c resolve due following two facts
lower level blocking literal
negation existential literals c level lower assigned
x x x x
formally define notions need additional notation first consider
given clause c resc c set literals c level lower literal
blocking resolution c c formally
resc c l l c l blockingc c level l level l

literal l level l prefix level l
blockingc function defined
blockingc c l l c l c l universal
let assignment say clause c contradictable respect
c


ficlause term resolution learning quantified boolean formulas

existential literal l c l
universal literal l c l
l resc c
b existential literal l c level l level l l left l

clearly clause contradicted contradictable considering qbf
clause x x x x x x contradicted x x x x contradictable respect x x
well founded order induction set tuples hc c l
c l contradictable preliminary step first define well founded order
literals according l l l l l l
l assigned l e l left l
extend partial order relation literals clauses minimal form ii
containing l iii l contradictable saying two clauses c c
c c
c c
e
e
e
e



l rese
c c resc c l resc c resc c l l resc c
subset existential literals resc c similarly rese
c c

order well founded minimal elements resc c
equivalently blockingc c empty
finally consider set w tuples hc c l
l assignment
l existential literal unit highest level
c clause containing l minimal form l contradictable respect
c
c contains l minimal form l contradicted l unit
c clause causes l unit
set define well founded order according hc c l hc c l
c c
consider procedure rec c resolve figure prove well founded
induction tuple hc c l w rec c resolve c c l terminates
returns clause c minimal form contradicted end
assume c l contradicted simply l contradictable
c contain existential literals whose negation assigned monotone

base case c resc c empty hence universal literal
l c l thus c l contradicted since resc c empty set
computed line empty thus rec c resolve c c l terminates returning


figiunchiglia narizzano tacchella

resolvent c c c clearly c minimal form easy c
contradicted
step case induction hypothesis thesis holds rec cresolve c c l holds rec c resolve c c l
assuming hc c l hc c l set resc c empty see base case
assume resc c empty thus blockingc c empty
let l literal blockingc c highest level l
l resc c c l contradictable l l c c
l contradicted level l level l see consider two possible
cases
l unit since l c c clause causes l unit
must level l level l level l
l highest level since l l l highest
level level l level l hand level l level l l
universal l existential
since c minimal form exists existential literal l l c l
level l level l level l let l existential literal
c necessarily distinct l level less equal level
literals c see line since
level l level l level l



l c l contradictable follows l assigned unit
thus exists clause c causes l unit l
initial prefix see line
consider set
blockingc c l l c l c l universal
blockingc c empty fact universal literal l c
level l level l l c since c minimal form
level l level l l l assume l c since c l contradictable
l l however l l l l possible l l l existential
l universal
since blockingc c empty resolve c c l obtaining
c min c c l l
resolvent c minimal form contains l
c c remains showed c l contradictable indeed
existential literal l c l universal literals c consider
two cases


ficlause term resolution learning quantified boolean formulas

blockingc c empty case l blockingc c easy
consequence following facts
literal l blockingc c level l level l l c definition
blockingc c hence l c l contradicted therefore
level l level l thus thesis see
b blockingc c blockingc c blockingc c c thus blockingc c
blockingc c blockingc c c c l l c e literals
blockingc c blockingc c blockingc c
omitted minimal form c
c blockingc c empty
since l blockingc c literals resc c c belong
resc c e
resc c resc c c

consider universal literal l c c l
l resc c c l contradictable hence l resc c
see
b existential literal l c level l level l l l
c l contradictable
c existential literal l l c l l fact level l level l
l l c l contradictable existential literal l l
c l l
finally consider universal literal l c c l level l level l
hence
l resc c level l level l see
b existential literal l c level l level l l c hence
l l
blockingc c empty let lowest among level literals c
level l since l c universal literal l c l e
c l contradicted fact assume exists universal literal l c
level l l c l c consider first case l c
l resc c c l contradictable level l level l
possible level l level l consider case
l c level l level l hence level l level l see
possible
since c c hc c l hc c l conclude induction hypothesis
rec c resolve c c l returns clause minimal form contradicted


figiunchiglia narizzano tacchella

make assumption input clause c l contradicted
c contain existential literals whose negation assigned monotone holds c clause c used line hence rec cresolve c c l returns clause without existential literals whose negation
assigned monotone

references
abdelwaheb basin bounded model construction monadic second order
logics th international conference computer aided verification cav
lecture notes computer science pp chicago usa springerverlag
bachmair l ganzinger h resolution theorem proving robinson
voronkov eds handbook automated reasoning vol chap pp
elsevier science
bayardo jr r j schrag r c csp look back techniques solve
real world sat instances proceedings th national conference artificial intelligence th innovative applications artificial intelligence conference
aaai iaai pp menlo park aaai press
bayardo jr roberto j miranker p complexity analysis space bounded
learning constraint satisfaction proceedings
thirteenth national conference artificial intelligence eighth innovative
applications artificial intelligence conference pp menlo park aaai
press mit press
cadoli schaerf giovanardi giovanardi evaluate
quantified boolean formulae experimental evaluation journal automated
reasoning
cadoli giovanardi schaerf evaluate quantified
boolean formulae proceedings th national conference artificial intelligence aaai th conference innovative applications artificial
intelligence iaai pp menlo park aaai press
castellini c giunchiglia e tacchella improvements sat conformant proc ecp
castellini c giunchiglia e tacchella sat complex
domains concurrency constraints nondeterminism artificial intelligence
davis logemann g loveland w machine program theorem
proving communication acm
de la tour b minimizing number clauses renaming proc
th conference automated deduction pp springer verlag
dechter r enhancement schemes constraint processing backjumping learning
cutset decomposition artificial intelligence


ficlause term resolution learning quantified boolean formulas

fermuller c g leitsch hustadt u tammet resolution decision procedures robinson voronkov eds handbook automated reasoning
vol ii chap pp elsevier science b v
gent giunchiglia e narizzano rowley tacchella watched data
structures qbf solvers giunchiglia e tacchella eds theory
applications satisfiability testing th international conference sat santa
margherita ligure italy may selected revised papers vol lecture
notes computer science pp springer
gent p rowley g solution learning solution directed backjumping revisited tech rep apes apes group available
http www dcs st ac uk apes apesreports html
ginsberg l dynamic backtracking journal artificial intelligence

giunchiglia e narizzano tacchella backjumping quantified boolean
logic satisfiability proc international joint conference artificial intelligence ijcai
giunchiglia e narizzano tacchella learning quantified boolean
logic satisfiability proceedings eighteenth national conference artificial
intelligence fourteenth conference innovative applications artificial intelligence july august edmonton alberta canada aaai press
pp
giunchiglia e narizzano tacchella backjumping quantified boolean
logic satisfiability artificial intelligence
giunchiglia e narizzano tacchella monotone literals learning
qbf reasoning tenth international conference principles practice
constraint programming cp pp
giunchiglia e narizzano tacchella b qbf reasoning real world instances theory applications satisfiability testing th international conference sat vancouver bc canada may revised selected papers
pp
giunchiglia e narizzano tacchella c qube efficient qbf solver
th international conference formal methods computer aided design fmcad
pp
kleine buning h karpinski flogel resolution quantified boolean
formulas information computation
le berre simon l tacchella challenges qbf arena sat
evaluation qbf solvers sixth international conference theory applications satisfiability testing sat vol lncs springer verlag
letz r lemma model caching decision procedures quantified boolean
formulas proceedings tableaux lnai pp springer


figiunchiglia narizzano tacchella

marques silva j p sakallah k grasp search
satisfiability proceedings ieee acm international conference computeraided design pp
moskewicz w madigan c f zhao zhang l malik chaff engineering efficient sat solver proceedings th design automation
conference dac pp
pan g vardi optimizing bdd modal solver automated
deduction cade th international conference automated deduction miami
beach fl usa july august proceedings pp
plaisted greenbaum structure preserving clause form translation
journal symbolic computation
prosser p domain filtering degrade intelligent backjumping search proceedings th international joint conference artificial intelligence ijcai vol pp
prosser p b hybrid constraint satisfaction computational intelligence
rintanen j constructing conditional plans theorem prover journal artificial intelligence
robinson machine oriented logic resolution principle journal
acm
robinson generalized resolution principle machine intelligence vol
pp oliver boyd edinburgh
scholl c becker b checking equivalence partial implementations
proceedings th design automation conference dac pp
tseitin g complexity proofs propositional logics seminars mathematics
urquhart complexity propositional proofs bulletin symbolic
logic
zhang l madigan c f moskewicz w malik efficient conflict driven
learning boolean satisfiability solver international conference computeraided design iccad pp
zhang l malik conflict driven learning quantified boolean satisfiability solver proceedings international conference computer aided design
iccad
zhang l malik b towards symmetric treatment satisfaction conflicts
quantified boolean formula evaluation proceedings eighth international
conference principles practice constraint programming pp




