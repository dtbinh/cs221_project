Journal Artificial Intelligence Research 26 (2006) 247287

Submitted 01/06; published 07/06

Landscape Random Job Shop Scheduling
Instances Depends Ratio Jobs Machines
Matthew J. Streeter
Stephen F. Smith

matts@cs.cmu.edu
sfs@cs.cmu.edu

Carnegie Mellon University
5000 Forbes Avenue, Pittsburgh, PA, 15213 USA

Abstract
characterize search landscape random instances job shop scheduling
problem (JSP). Specifically, investigate expected values (1) backbone size,
(2) distance near-optimal schedules, (3) makespan random schedules vary
N
N
N
function job machine ratio (
). limiting cases
0

N
provide analytical results, intermediate values perform experiments.
N
N
prove
0, backbone size approaches 100%,
backbone
N
N
vanishes. process show 0 (resp. ), simple priority rules
almost surely generate optimal schedule, providing theoretical evidence easyhard-easy pattern typical-case instance difficulty job shop scheduling. draw
connections theoretical results big valley picture JSP landscapes.

1. Introduction
1.1 Motivations
goal work provide picture typical landscape random instance
job shop scheduling problem (JSP), determine picture changes
N
function job machine ratio (
). picture potentially useful (1)
N
understanding typical-case instance difficulty varies function
(2) designing
selecting search heuristics take advantage regularities typical instances
JSP.

1.1.1 Understanding instance difficulty function

N


job shop scheduling literature contains much empirical evidence square JSPs (those
N

= 1) difficult solve rectangular instances (Fisher & Thompson,
1963). work makes theoretical empirical contributions toward understanding
phenomenon. Empirically, show random schedules random local
N
1. Analytically, prove two
optima furthest optimality
N
N
limiting cases ( 0 ) exist simple priority rules almost surely
produce optimal schedule, providing theoretical evidence easy-hard-easy pattern
instance difficulty JSP.
c
2006
AI Access Foundation. rights reserved.

fiStreeter & Smith

1.1.2 Informing design search heuristics
Heuristics based local search, example tabu search (Glover & Laguna, 1997; Nowicki
& Smutnicki, 1996) iterated local search (Lourenco, Martin, Stutzle, 2003),
shown excellent performance benchmark instances job shop scheduling problem
(Jain & Meeran, 1998; Jones & Rabelo, 1998). order design effective heuristic, one
must (explicitly implicitly) make assumptions search landscape instances
heuristic applied. example, Nowicki Smutnicki motivate
use path relinking state-of-the-art i-TSAB algorithm citing evidence
JSP big valley distribution local optima (Nowicki & Smutnicki, 2005). One
conclusions work typical landscape random instances
N
N
thought big valley values
close 1; larger values
(including values
common benchmark instances), landscape breaks many big valleys, suggesting
modifications i-TSAB may allow better handle case (we discuss i-TSAB
9.3).
1.2 Contributions
contributions paper twofold. First, design novel set experiments
run experiments random instances JSP. Second, derive analytical results
confirm provide insight trends suggested experiments.
main contributions empirical work follows.
N
, show low-makespan schedules clustered small
low values
region search space many attributes (i.e., directed disjunctive graph edges)
N
common low-makespan schedules.
increases, low-makespan schedules
become dispersed throughout search space attributes common
low-makespan schedules.

introduce statistic (neighborhood exactness) used quantitatively
measure smoothness search landscape, estimate expected value
statistic random instances JSP. results, combination
results clustering, suggest landscape typical instances JSP
N
N
described big valley low values
; high values

many separate big valleys.
limiting cases
prove

N


0

N


, derive analytical results. Specifically,

N

0, expected size backbone (i.e., set problem variables
N
common value global optima) approaches 100%,
,
expected backbone size approaches 0%;
N
N

0 (resp.
), randomly generated schedule almost surely (a)
located close search space optimal schedule (b) near-optimal
makespan.

248

fiThe Landscape Random Job Shop Scheduling Instances

2. Related Work
least three threads research conducted search space analyses
related ones conduct here. include literature big valley distribution
common number combinatorial optimization problems, studies backbone size
Boolean satisfiability, statistical mechanical analysis TSP. briefly review
three areas below, well relevant work phase transitions easy-hardeasy pattern instance difficulty.
2.1 Big Valley
term big valley originated paper Boese et al. (1994) examined
distribution local optima Traveling Salesman Problem (TSP). Based sample
local optima obtained next-descent starting random TSP tours, Boese calculated
two correlations:
1. correlation cost locally optimal tour average distance
locally optimal tours,
2. correlation cost locally optimal tour distance
tour best tour sample.
distance two TSP tours defined total number edges minus
number edges common two tours. Based fact
correlations surprisingly high, Boese conjectured local optima TSP
arranged big valley. Adapted work Boese et al. (1994), Figure 1
gives intuitive picture big valley, set local minima appears convex
one central global minimum (Boese et al., 1994). offer formal definition
big valley landscape 6.
Boeses analysis applied combinatorial problems (Kim & Moon, 2004),
including permutation flow shop scheduling problem (Watson, Barbulescu, Whitley, &
Howe, 2002; Reeves & Yamada, 1998) JSP (Nowicki & Smutnicki, 2001). Correlations observed JSP generally weaker observed TSP.
related study, Mattfeld (1996) examined cost-distance correlations famous
JSP instance ft10 (Beasley, 1990) found evidence Massif Central. . . many
near optimal solutions reside laying closer together local optima. 4 contains
related results backbone size ft10.
2.2 Backbone Size
backbone problem instance set variables assigned common value
globally optimal solutions instance. example, Boolean satisfiability
problem (SAT), backbone set variables assigned fixed truth value
satisfying assignments. JSP, backbone defined number
disjunctive edges (3.2) common orientation globally optimal schedules
(a formal definition given 4).
large literature backbones combinatorial optimization problems, including many empirical analytical results (Slaney & Walsh, 2001; Monasson, Zecchina,
249

fiStreeter & Smith

Figure 1: intuitive picture big valley landscape.
Kirkpatrick, Selman, & Troyansky, 1999). analysis problem difficulty JSP,
Watson et al. (2001) present histograms backbone size random 6x6 (6 job, 6 machine)
6x4 (6 job, 4 machine) JSP instances. Summarizing experiments reported
paper, Watson et al. note [job:machine ratios] > 1.5, bias toward small backbones becomes pronounced, ratios < 1, bias toward larger backbones
magnified. 4 generalizes observations proves two theorems give
insight phenomenon occurs.
2.3 Statistical Mechanical Analyses
large growing literature applies techniques statistical mechanics analysis
combinatorial optimization problems (Martin, Monasson, & Zecchina, 2001). least
one result obtained literature concerns clustering low-cost solutions. study
TSP, Mezard Parisi (1986) obtain expression expected overlap (number
common edges) random TSP tours drawn Boltzmann distribution.
show temperature parameter Boltzmann distribution lowered (placing
probability mass low-cost TSP tours), expected overlap approaches 100%. Though
use Boltzmann weighting, 5 paper examines expected overlap
random JSP schedules changes probability mass placed low-makespan
schedules.
2.4 Phase Transitions Easy-hard-easy Pattern
Loosely speaking, phase transition occurs system expected value
statistic varies discontinuously (asymptotically) function parameter.
example, > 0 holds random instances 2-SAT problem satisfiable
probability asymptotically approaching 1 clause variable ratio (
n ) 1,
satisfiable probability approaching 0 clause variable ratio 1 + .
similar statement conjectured hold 3-SAT; critical value k
n (if exists)
must satisfy 3.42 k 4.51 (Achlioptas & Peres, 2004).
problems exhibit phase transitions (notably 3-SAT), average-case instance
difficulty (for typical solvers) appears first increase decrease one increases
relevant parameter, hardest instances appearing close threshold value
250

fiThe Landscape Random Job Shop Scheduling Instances

(A) JSP instance

J1 :

J11

J 12

J 2 : J12









J 13

J 22


(B) JSP schedule

J 14

J 32

J 42





J11





J12

J 22



time

(C) Disjunctive

graph




J11

J 12

J 13

J 32

J 14
J 42



J 14
o*



J12


J 12 J 13



J 22


J 32


J 42

Figure 2: (A) JSP instance,

(B) afeasibleschedule instance, (C) disjunctive graph representation schedule. Boxes represent operations; operation
durations proportional width box; machine
operation performed represented texture. (C), solid arrows represent
conjunctive arcs dashed arrows represent disjunctive arcs (arc weights
proportional duration operation arc points of).

(Cheeseman, Kanefsky, & Taylor, 1991; Yokoo, 1997). phenomenon referred
easy-hard-easy pattern instance difficulty (Mammen & Hogg, 1997). 7.4
discuss evidence easy-hard-easy pattern instance difficulty JSP, though
(to knowledge) associated phase transition.
results 4-5 empirical results 6 previously presented conference paper (Streeter & Smith, 2005a).

3. Job Shop Scheduling Problem
adopt notation [n] {1, 2, . . . , n}.
3.1 Problem Definition
Definition (JSP instance). N JSP instance = {J 1 ,J 2 , . . . , J N } set N
k ) sequence operations. operation
jobs , job J k = (J1k , J2k , . . . , JM
k
= Ji associated duration (o) (0, max ] machine m(o) [M ]. require
job uses machine exactly (i.e., J k [M ],
exactly one [M ] m(Jik ) = m). define
1. ops(I) {Jik : k [N ], [M ]},
2. (J k )

PM

k
i=1 (Ji ),


251

fiStreeter & Smith

3. job-predecessor J (Jik ) operation Jik
J (Jik )




k
Ji1


> 1
otherwise

fictitious operation (o ) = 0 m(o ) undefined.
Definition (JSP schedule). JSP schedule instance function : ops(I)
<+ associates operation ops(I) start time S(o) (operation performed
machine m(o) time S(o) time S(o) + (o); preemption allowed). make
following definitions.
1. completion time operation + (o) S(o) + (o).
2. machine-predecessor M(o) operation ops(I)

M(o)

arg maxoOprev (o) S(o)


Oprev (o) 6=
otherwise.

Oprev (o) = {o ops(I) : m(o) = m(o), S(o) < S(o)} set operations
scheduled run os machine.
3. feasible schedule S(o) max(S + (J (o)), + (M(o))) ops(I).
4. quantity
`(S) max + (o)
oops(I)

called makespan S.
consider makespan-minimization version JSP, goal find
schedule minimizes makespan.
remainder paper, whenever refer JSP schedule shall adopt
convention S(o ) = 0 shall assume
S(o) = max(S + (J (o)), + (M(o))) ops(I)

(3.1)

(i.e., so-called semi-active schedule, French, 1982). words, ignore schedules
superfluous idle time start schedule end one operation
start another.
Figure 2 (A) (B) depict, respectively, JSP instance feasible schedule
instance.
3.2 Disjunctive Graphs
schedule satisfying (3.1) uniquely represented weighted, directed graph called
disjunctive graph. disjunctive graph representation schedule JSP
instance I, operation ops(I) vertex directed edge (o1 , o2 ) indicates
operation o1 completes o2 starts.
252

fiThe Landscape Random Job Shop Scheduling Instances

Definition (disjunctive graph). disjunctive graph G = G(I, S) schedule
~ w) defined follows.
JSP instance weighted, directed graph G = (V, E,
V = ops(I) {o , }, (like ) fictitious operation (o ) = 0
m(o ) undefined.
~ =C
~ D,
~
E


~ = {(J (o), o) : ops(I)} (J k , ) : k [N ] called set conjunctive
C

arcs (which specify cannot start J (o) completes),
~ = {(o1 , o2 ) : {o1 , o2 } ops(I), m(o1 ) = m(o2 ), S(o1 ) < S(o2 )} called set

disjunctive arcs (which specify, pair operations performed
machine, two operations performed first).
w((o1 , o2 )) = (o1 ).
Figure 2 (C) depicts disjunctive graph schedule depicted Figure 2 (B).
connection schedule disjunctive graph established following
proposition (Roy & Sussmann, 1964).
Proposition 1. Let feasible schedule satisfying (3.1), let G = G(I, S)
corresponding disjunctive graph. `(S) equal length longest weighted
path G.
Proof. operation o, let L(o) denote length longest weighted path
G. suffices show ops(I), S(o) = L(o). follows
induction number edges path, base case S(o ) = L(o ) = 0.
undirected version disjunctive arc called disjunctive edge.
Definition (disjunctive edge). Let JSP instance. disjunctive edge set
{o1 , o2 } ops(I) m(o1 ) = m(o2 ). define following notation.
E(I) set disjunctive edges I.
Let schedule let e = {o1 , o2 } disjunctive edge. denote
~e(S) unique arc {(o1 , o2 ), (o2 , o1 )} appears disjunctive graph G(I, S)
(this arc called orientation e S).
measure distance two schedules S1 S2 JSP instance
counting number disjunctive edges oriented opposite directions G(I, S1 )
G(I, S2 ).
Definition (disjunctive graph distance). disjunctive graph distance kS1 S2 k
two schedules S1 S2 JSP instance defined
kS1 S2 k |{e E(I) : ~e(S1 ) 6= ~e(S2 )}| .
253

fiStreeter & Smith

3.3 Random Schedules Instances
define uniform distribution JSP instances follows. distribution identical
one used Taillard (1993).
Definition (random JSP instance). random N JSP instance generated
follows.
1. Let 1 , 2 , . . . , N random permutations [M ].
2. Let G probability distribution (0, max ] mean variance 2 > 0.
3. Define = {J 1 , J 2 , . . . , J N }, m(Jik ) = k (i) (Jik ) drawn (independently random) G.
Note definition (and likewise, theoretical results) assumes maximum
operation duration max , makes assumptions form distribution
operation durations. empirical results reported paper, choose operation
durations uniform distribution {1, 2, . . . , 100}.
proofs frequently make use priority rules. priority rule greedy schedulebuilding algorithm assigns priority operation and, step greedy
algorithm, assigns earliest possible start time operation minimum priority.
Definition (priority rule). priority rule function that, given instance
operation ops(I), returns priority (I, o) <. schedule = S(, I) associated
defined following procedure.
1. U nscheduled ops(I), S(o ) 0.
2. |U nscheduled| > 0 do:
(a) Ready {o U nscheduled : J (o)
/ U nscheduled}.
(b) element Ready least priority.
(c) S(o) max(S + (J (o)), + (M(o))).
(d) Remove U nscheduled.
priority rule called instance-independent if, N JSP instance
integers k [N ], [M ], value (I, Jik ) depends k, i, N , .
obtain random schedule assigning random priorities operation.
resulting distribution equivalent one used Mattfeld (1996).
Definition (random schedule). random schedule N JSP instance
generated performing following steps.
1. Create list L containing occurrences integer k k [N ] (we think
occurrences k representing operations job J k ).
2. Shuffle L (obtaining permutation equal probability).
3. Return schedule S(rand , I) rand (I, Jik ) = index ith occurrence
k L.
254

fiThe Landscape Random Job Shop Scheduling Instances

4. Number Common Attributes Function Makespan
backbone JSP instance set disjunctive edges common orientation schedules whose makespan globally optimal. 1, define
backbone set disjunctive edges common orientation schedules whose makespan within factor optimal (a related definition appears Slaney
& Walsh, 2001).
Definition ( backbone). Let JSP instance optimal makespan `min (I).
1, let opt(I) {S : `(S) `min (I)} set schedules whose makespan
within factor optimal.
backbone(I) {e E(I) : ~e(S1 ) = ~e(S2 ) {S1 , S2 } opt(I)} .
section compute expected value | backbone| function
random N JSP instances, examine shape curve changes
N
function
.
4.1 Computing backbone
compute backbone use following proposition.
Proposition 2. Let JSP instance optimal makespan `min (I). Let e = {o1 , o2 }
disjunctive edge orientations a1 = (o1 , o2 ) a2 = (o2 , o1 ). disjunctive
arc a, let `min (I|a) denote optimum makespan among schedules whose disjunctive graph
contains arc a.
e backbone(I) max {`min (I|a1 ), `min (I|a2 )} > lmin (I) .
Proof. e backbone, e must common orientation (say a1 ) schedules
`(S) `min (I), implies `min (I|a2 ) > `min (I). e
/ backbone,
must {S1 , S2 } opt(I) ~e(S1 ) = a1 ~e(S2 ) = a2 , implies
max{`min (I|a1 ), `min (I|a2 )} `min (I).

Thus compute backbone(I) need compute `min (I|a) 2M N2
possible choices a. Given disjunctive arc a, compute `min (I|a) using branch
bound. branch bound algorithms JSP, nodes search tree represent
choices orientations subset disjunctive edges. constructing root search
tree node fixed arc, determine `min (I|a). use branch bound
algorithm due Brucker et al. (1994) efficient code
freely available via ORSEP (Brucker, Jurisch,
& Sievers, 1992).


N
Computing `min (I|a) 2M 2 possible choices requires 1 + N2 runs
branch bound. first run used find globally optimal schedule,
gives

N
N
value `min (I|a) 2 possible choices (namely, 2 disjunctive arcs

present globally optimal schedule). separate run used
N2 remaining choices a.
Figure 3 graphs fraction disjunctive edges belong backbone
function instance ft10 (a 10 job, 10 machine instance) library (Beasley,
255

fiStreeter & Smith

Instance ft10
Normalized |-backbone|

1
0.8
0.6
0.4
0.2
0
1.00

1.02

1.04

1.06

1.09

1.11

1.13



Figure 3: Normalized | backbone| function library instance ft10.
1990). Note definition curve non-increasing respect ,
curve exact . noteworthy among schedules whose makespan within
factor 1.005 optimal, 80% disjunctive edges fixed orientation. see
N
behavior typical JSP instances
= 1.
4.2 Results
plotted | backbone| function instances library 10
fewer jobs 10 fewer machines. results available online (Streeter & Smith,
2005b). Inspection graphs revealed shape curve largely function
job:machine ratio. investigate further, repeat experiments large
number randomly generated JSP instances.
use randomly generated instances 7 different combinations N study
N
N
instances
equal 1, 2, 3.
= 1 use 6x6, 7x7, 8x8 instances;
N
N
=
2

use
8x4

10x5
instances;



= 3 use 9x3 12x4 instances.
generate 1000 random instances combination N .
Figure 4 parts (A), (B), (C) graph expected fraction edges belonging
N
-backbone function combination N , grouped according
.
N
Figure 4 (D) compares curves different values , plots 0.25 0.75
quantiles. purposes study two important observations Figure
4 follows.
curves depend size instance (i.e., N ) shape (i.e.,
N
N
). two factors, far stronger influence shape
curves.
values , expected fraction edges belonging backbone decreases
N

increases.
256

fiThe Landscape Random Job Shop Scheduling Instances

(A) Job:machine ratio 1:1

(B) Job:machine ratio 2:1
1

0.8

E[frac. edges -backbone]

E[frac. edges -backbone]

1

6x6 instances
7x7 instances

0.6

8x8 instances
0.4

0.2

0.8

8x4 instances
10x5 instances

0.6
0.4
0.2
0

0
1

1.1

1.2



1.3

1.4

1

1.5

1.1

1.3

1.4

1.5



(C) Job:machine ratio 3:1

(D) Comparison

1

1

0.8

Frac. edges -backbone

E[frac. edges -backbone]

1.2

9x3 instances

0.6

12x4 instances

0.4
0.2
0

0.8

8x8 instances
10x5 instances

0.6

12x4 instances
0.4

0.2

0

1

1.1

1.2

1.3

1.4

1.5



1

1.1

1.2



1.3

1.4

1.5

Figure 4: Expected fraction edges -backbone function random JSP
N
instances. Graphs (A), (B), (C) depict curves random instances
= 1, 2, 3, respectively. Graph (D) compares curves depicted (A), (B),
(C) (only curves largest instance sizes shown (D)). (D),
top bottom error bars represent 0.75 0.25 quantiles, respectively.

257

fiStreeter & Smith

4.3 Analysis
give insight Figure 4 analyzing two limiting cases. prove
N
0, expected fraction disjunctive edges belong backbone approaches
N
1,
expected fraction approaches 0.
N
Intuitively, happens follows.
0 (i.e., N held constant )
jobs becomes long. Individual disjunctive edges represent precedence
relations among operations performed far apart time. example,
10,000 machines (and job consists 10,000 operations), disjunctive
edge might specify whether operation 1,200 job performed operation
8,500 job B. Clearly, waiting job B complete 8,500 operations allowing
job complete 12% operations likely produce inefficient schedule. Thus,
orienting single disjunctive edge wrong direction likely prevent schedule
optimal, particular edge likely common orientation
globally optimal schedules.
N
contrast,
, workloads machines become long.
order jobs processed particular machine matter much
long machine longest workload kept busy, fact particular
edge oriented particular way unlikely prevent schedule optimal.
formalized below.
make use following well-known definition.
Definition (whp). sequence events n occurs high probability (whp) limn
P[n ] = 1.
Lemma 1 Theorem 1 show constant N , randomly chosen edge random
N JSP instance backbone whp (as ). Lemma 2 Theorem 2
show constant , randomly chosen edge random N JSP instance
backbone whp (as N ).
Lemma 1. Let random N JSP instance, let = S(, I) schedule
obtained using instance-independent priority rule . arbitrary job J I,
define SJ + (JM ) (J). E[SJ ] O(N ).
Proof. assume N = 2 > 1. generalization larger N straightforward,
cases N = 1 = 1 trivial. Let = {J 1 , J 2 } let J = J 1 .
Let = (o1 , o2 , . . . , ) sequence operations selected Ready (in line
2(b) definition priority rule 3.3) constructing S. say operation
Ji1 overlaps operation Jj2
1. Jj2 appears Ji1 ,
1 ), + (J 1 ) + (J 1 )] 6= .
2. [S(Jj2 ), + (Jj2 )] [S + (Ji1
i1


additionally m(Ji1 ) = m(Jj2 ), say Ji1 contends Jj2 . Intuitively, Ji1
overlaps o0 Jj2 start time might delayed os machine
used o0 . contends o0 , start time actually delayed.
258

fiThe Landscape Random Job Shop Scheduling Instances

Let i,j (resp. i,j ) indicator event Ji1 overlaps (resp. contends)
2
2
1
Let
Ci {Jj : i,j = 1} set operations J Ji overlaps with.
|Ci i0 >i Ci0 | 1. Thus

Jj2 .

X


|Ci | =

X


|Ci \

[

Ci0 | +

i0 >i

X


|Ci

[

Ci0 | 2M .

(4.1)

i0 >i

Let = IN,M 1 random N 1 JSP instance, define i,j , i,j , Ci
analogously above. i, j 1,




P i,j = 1|m(Ji1 ) = m(Jj2 ) = P i,j = 1 .
true P[i,j = 1] function joint distribution operations
set {Ji10 : i0 < i} {Jj20 : j 0 < j}; and, far joint distribution concerned,
conditioning event m(Ji1 ) = m(Jj2 ) deleting operations use
machine m(Ji1 ).
h




1
1
1
P i,j = 1|m(Ji1 ) = m(Jj2 ) =
P i,j = 1 =
E i,j .
Thus E [i,j ] = P [i,j = 1] =
Therefore,
PM 1 PM 1
PM PM
j=1 E[i,j ]
i=1
j=1 E[i,j ] 2 +
i=1
1 PM 1 PM 1
= 2 + i=1
j=1 E[i,j ]
1 PM 1
= 2 + i=1 E[|Ci |]
4
last step used (4.1). follows E[SJ ] 4max (max
maximum operation duration defined 3). consider arbitrary N , get E[SJ ]
4max (N 1).
corollary Lemma 1, show simple priority rule (0 ) almost surely
N
0.
generates optimal schedule case
Definition (priority rule 0 ). Given N JSP instance I, let k = arg maxk[N ]
(J k ) index longest job. priority rule 0 first schedules operations

J k , schedules remaining operations fixed order.


k = k
k
0 (I, Ji ) =
k + otherwise.
Corollary 1. Let random N JSP instance. fixed N , holds
whp (as ) schedule = S(0 , i) optimal makespan `(S) =
maxk[N ] (J k ).
Proof. Define priority rule k k (I, Jik ) = k = k; k + otherwise. k
instance-independent, 0 equivalent k . Thus J
E[J0 ]

X

E[Jk ] = O(N 2 )

k

259

fiStreeter & Smith

S(,I)

define J J
, second step uses Lemma 1. Markovs inequal1
0
ity, J < 4 J whp. Central Limit Theorem,
(J) asymptotically
normally distributed mean standard deviation . follows whp,
1



(J k ) (J k ) > 4 k 6= k . implies `(S) = (J k ). (J k ) lower
bound makespan schedule, corollary follows.
Theorem 1. Let random N JSP instance, let e randomly selected
element E(I). fixed N , holds whp (as ) e 1 backbone(I).
Proof. Let e = {Ji , Jj0 } j let = (Jj0 , Ji ). Proposition 1 Corollary 1,
suffices show whp, disjunctive graphs containing contain path
weighted length > maxk[N ] (J k ).
3

Assume j 4 (this holds whp j selected uniformly
random [M ]), consider path
P = (o , J10 , J20 , . . . , Jj0 , Ji , Ji+1 , . . . , JM , )
3

passes |P | 3+M +M 4 vertices weighted length w(P ). want
show w(P ) > maxJI (J) whp. Central Limit Theorem, (1) fixed
j, w(P
p) asymptotically normally distributed mean (|P | 2) standard
deviation (|P | 2) (2)
J, (J) asymptotically normally distributed
mean standard deviation . w(P ) > maxJI (J) whp follows
Chebyshevs inequality.
N
, simple priority rule ( ) almost surely generates
Lemma 2 shows
schedule machine idle operations performed machine
completed (a schedule property clearly optimal).

Definition (priority rule ). Given N JSP instance I, priority rule
first schedules first operation job (taking jobs order ascending indices),
second operation job, forth. defined (I, Jik ) = + k.
Lemma 2. Let random N JSP instance. fixed , holds whp (as
N ) schedule = S( , I) property
S(o) = + (M(o)) ops(I) .
Proof. Suppose executing replace line S(o) max(S + (J (o)),
+ (M(o))) (line 2(c) definition priority rule given 3.3) S(o) + (M(o)).
resulting feasible replacement must effect. Thus suffices
show resulting feasible whp. Equivalently, want show whp,
S(o) + (J (o)) ops(I) constructed using modified version line 2
(c).
Let ops2+ (I) = {Jik ops(I) : > 1} set operations first
job. suffices show S(o) S(J (o)) max ops2+ (I). end, consider
arbitrary operation = Jik ops2+ (I). , number operations lower
260

fiThe Landscape Random Job Shop Scheduling Instances

priority (i 1)N + (k 1). number operations lower priority
1
Jik run machine m(o) is, expectation, equal
[(i 1)(N 1) + (k 1)]
(where switch N N 1 due fact operation job J k
uses machine m(o)). follows
E[S(o)] =


[(i 1)(N 1) + (k 1)]



k
)] =
E[S(o) S(J (o))] = E[S(Jik ) S(Ji1

N 1
.


Appendix use martingale tail inequality establish following claim.
Claim 2.1. high probability, ops2+ (I)
1
S(o) S(J (o)) E[S(o) S(J (o))] .
2
Lemma follows fact 21 E[S(o) S(J (o))] > max N sufficiently
large.
Based results computational experiments, Taillard (1994) conjectured
optimal makespan almost surely equal maximum machine workload.
following corollary Lemma 2 confirms conjecture.
N


Corollary 2. Let random N JSP instance optimal makespan `min (I).
Let (m) ({o ops(I) : m(o) = m}) denote workload machine m. fixed
, holds whp (as N ) `min (I) = maxm[M ] (m).
Theorem 2. Let random N JSP instance, let e randomly selected
element E(I). fixed , holds whp (as N ) e
/ 1 backbone(I).
Proof. Let e = {Ji , Jj0 }. Remove J J 0 create N 2 instance
comes distribution random N 2 JSP instance. Lemma
I,
2 shows whp exists optimal schedule property described
statement lemma.
: m(o) = m}) denote workload machine
Let (m) ({o ops(I)

instance I. Central Limit Theorem,
(m) asymptotically normally distributed
mean (N 2) standard deviation N 2. follows whp, | (m) (m0 )| >
1
N 4 6= m0 .
Thus whp one machine still processing operations interval
1
[`(S) N 4 , `(S)]. max( (J), (J 0 )) max = O(1), use interval
construct optimal schedules containing disjunctive arc (Ji , Jj0 ) well optimal
schedules containing disjunctive arc (Jj0 , Ji ).
261

fiStreeter & Smith

5. Clustering Function Makespan
section estimate expected distance random schedules whose makespan
within factor optimal, function various combinations N .
N
examine shape curve changes function
. formally,
random N JSP instance optimal makespan `min (I),
opt(I) {S : `(S) `min (I)},
S1 S2 drawn independently random opt(I),
wish compute E[kS1 S2 k].
Note experiments 4 provide upper bound quantity:

N
E [| backbone|]
E [kS1 S2 k]
2
provide lower bound (a low backbone size evidence mean distance
global optima large). experiments section viewed test
degree upper bound provided 4 tight.
5.1 Methodology
generate random samples opt(I) running simulated annealing algorithm
van Laarhoven et al. (1992) finds schedule. precisely, procedure
sampling distances follows.
1. Generate random N JSP instance I.
2. Using branch bound algorithm Brucker et al. (1994), determine optimal
makespan I.
3. Perform k runs, R1 , R2 , . . . , Rk , van Laarhoven et al. (1992) simulated annealing
algorithm. Restart run many times necessary find schedule whose
makespan optimal.
4. {1, 1.01, 1.02, . . . , 1.5}, find first schedule, call Si (), run
Ri whose makespan within factor optimal. k2 pairs
runs (Ri , Rj ), add distance Si () Sj () sample distances
associated .
ran procedure random JSP instances 7 combinations N
used 4.2. smallest instance sizes ratio (i.e., 6x6, 8x4
9x3 instances) generate 100 random JSP instances run procedure k = 100.
Setting k = 100 allows us measure variation instance-specific expected values.
4 combinations N , performing 10,000 simulated annealing runs
computationally expensive, instead generate 1000 random JSP instances run
procedure k = 2.
262

fiThe Landscape Random Job Shop Scheduling Instances

Figure 5 (A), (B), (C) plot expected distance random -optimal schedN
ules function three values
. Figure 5 (D) shows 0.75
0.25 quantiles 100 instance-specific sample means three smallest
instance sizes. Examining Figure 5 (D), see variation among random instances
N small relative differences curves different
N
values
.
5.2 Discussion
examining Figure 5 see , expected distance random N
optimal schedules increases
increases. Indeed, global optima dispersed widely
N
N
throughout search space
= 3, true lesser extent
= 2.
immediate implication Figure 5 whether exhibit two
correlations operational definition big valley, typical landscapes JSP
N
= 3 cannot expected big valleys sense central
instances
cluster optimal near-optimal solutions. anything, one might posit existence
multiple big valleys, leading separate global optimum. next section expands
upon observations.

6. Big Valley
section define formal properties big valley landscape, conduct experiments determine extent random JSP instances exhibit properties
N
N
N
vary
, present analytical results limiting cases
0
.
Considering intuitive picture given Figure 1, take following
necessary (though perhaps sufficient) conditions function f (x) big valley.
1. Small improving moves. x global minimum f , must exist nearby
x0 f (x0 ) < f (x).
2. Clustering global optima. maximum distance two global minima
f small.
Note direct relationship two properties cost-distance
correlations considered Boese et al. (1994).
6.1 Formalization
following four definitions allow us formalize notion big valley landscape.
Definition (Neighborhood Nr ). Let arbitrary JSP instance, let U set
schedules I. Let r positive integer. neighborhood Nr : U 2U defined

Nr (S) {S 0 U : kS 0 k r} .
Definition (local optimum L(S, N )). Let U above; let N : U 2U
arbitrary neighborhood function; let schedule I. L(S, N ) schedule
returned following procedure (which finds local optimum performing next-descent
starting using neighborhood N ).
263

fiStreeter & Smith

(A) Job:machine ratio 1:1

(B) Job:machine ratio 2:1
0.5

E[dist. schedules]

E[dist. schedules]

0.5
0.4
0.3
0.2

6x6 instances
7x7 instances

0.1

8x8 instances
0

0.4
0.3
0.2

8x4 instances

0.1

10x5 instances

0
1

1.1

1.2

1.3

1.4

1.5

1

1.1

1.2



(C) Job:machine ratio 3:1

1.4

1.5

(D) Comparison

0.5

0.5

E[dist. schedules]

E[dist. schedules]

1.3



0.4
0.3
0.2

9x3 instances

0.1

12x4 instances

0.4
0.3
0.2

6x6 instances
8x4 instances

0.1

9x3 instances
0

0
1

1.1

1.2

1.3

1.4

1.5

1

1.1

1.2

1.3

1.4

1.5





Figure 5: Expected distance random schedules within factor optimal,
function . Graphs (A), (B), (C) depict curves random instances
N
= 1, 2, 3, respectively. Graph (D) compares curves depicted (A),
(B), (C) (only curves smallest instance sizes shown (D)).
(D), top bottom error bars represent 0.75 0.25 quantiles (respectively)
instance-specific sample means.

264

fiThe Landscape Random Job Shop Scheduling Instances

(A) (r,)-valley

(B) Three (r,)-valleys

r

r

r

r









Figure 6: Two landscapes comprised (r, )-valleys. (A) single (r, ) valley (for
values r shown figure), (B) either viewed three
distinct (r, ) valleys single (r, 0 )-valley. (The values r shown
figure slightly larger necessary.)

1. Let N (S) = {S1 , S2 , . . . , S|N (S)| } (where elements N (S) indexed fixed
arbitrary manner).
2. Find least `(Si ) < `(S). exists, return S; otherwise set
Si go 1.
Definition ((r, )-valley). Let U above, let r non-negative
integers. set V U (r, )-valley V following two properties.
1. V , schedule L(S, Nr ) V globally optimal.
2. two globally optimal schedules S1 S2 V , kS1 S2 k .
Figure 6 illustrates definition (r, )-valley. would say landscape
depicted Figure 6 (A) big valley, depicted 6 (B) comprised three
big valleys.
Definition ((r, , p) landscape). Let U above, let random schedule
I. (r, , p) landscape exists V U
1. V (r, )-valley,
2. P[S V ] p.



JSP instance trivially (M N2 , N2 , 1) landscape (because r = N2

Nr includes possible schedules). JSP instance (r, N2 , 1) landscape,
globally optimal schedule always found starting random schedule
applying next-descent using neighborhood Nr .
say JSP instance big valley landscape (r, , p) landscape
small r combination p near 1. contrast, small r combination
p near 1 require large , say landscape consists multiple big valleys.
265

fiStreeter & Smith

6.2 Neighborhood Exactness
section seek determine extent random JSP instances
small improving moves property. require following definition.
Definition (neighborhood exactness). Let I, U , N above, let
random schedule I. exactness neighborhood N instance
probability L(S, N ) global optimum.

exactness Nr p, (r, N2 , p) landscape (let V consist
schedules L(S, N ) global optimum). estimate expected exactness
Nr function r various combinations N . examining resulting
curves, able draw conclusions extent landscapes
random N JSP instance typically small improving moves property.
N
determine presence absence property depends
.

fixed N , compute expected exactness Nr 1 r N2
repeatedly executing following procedure.
1. Generate random N JSP instance I.
2. Using algorithm Brucker et al. (1994), compute optimal makespan I.
3. Repeat k times:
(a) random feasible schedule, r 1, opt f alse.
(b) opt = f alse do:
L(S, Nr ).
global optimum, opt true.
Record pair (r, opt).
r r + 1.
(c) r0 r r0

N
2



record pair (r0 , true).

pairs recorded procedure (in step 3(c) third bullet point 3 (b))
used obvious way estimate expected exactness. Specifically, r
estimated expected exactness Nr fraction pairs (r, x) x = true.
implementation first bullet point step 3 (b) deserves discussion.
determine L(S, Nr ), step next-descent must able determine best schedule
{S 0 : kS 0 k r}. large r impractical brute force. Instead
developed radius-limited branch bound algorithm that, given arbitrary center
schedule Sc radius r, finds schedule arg min{S 0 :kSc 0 kr} `(S 0 ). radius-limited
branch bound algorithm uses branching rule Balas (1969) combined
lower bounds branch ordering heuristic Brucker et al. (1994).
266

fiThe Landscape Random Job Shop Scheduling Instances

6.3 Results
N
use three combinations N
= 15 (3x15, 4x20, 5x25 instances), three
N
N
combinations = 1 (6x6, 7x7, 8x8 instances) two combinations
=5
(15x3 20x4 instances). smallest instance sizes ratio (i.e., 3x15, 6x6,
15x3 instances) generate 100 random JSP instances run procedure
k = 100. Otherwise, generate 1000 random JSP instances run procedure
k = 1.

Figure 7 (A), (B), (C) plot expected exactness function neighborhood radius
N
(normalized number disjunctive edges) three values
. Figure
7 (D) shows 0.75 0.25 quantiles 100 instance-specific sample means
three smallest instance sizes.
6.4 Discussion
Examining Figure 7, see normalized neighborhood radius, neighborhood
N
exactness lowest instances
= 1 higher two extreme ratios
1
N
N
( = 5 = 5). view neighborhood exactness measuring smoothness
landscape, data suggest typical JSP landscapes least smooth
N
N
N
intermediate value
, become smooth
0
.
suggests easy-hard-easy pattern typical-case instance difficulty JSP,
phenomenon explored fully next section.
Using methodology 4-5, found expected proportions backbone
edges 3x15, 4x20, 5x25 instances 0.94, 0.93, 0.92, respectively,
expected distance global optima 0.02 three cases. contrast,
expected proportions backbone edges 15x3 20x4 instances near-zero,
expected distances global optima 0.33 0.28, respectively. conclude
landcapes random N JSP instances typically clustering global
N
N
optima property
= 51
= 5. However, Figure 7 suggests small
N
N
improving moves property present
= 51
= 5. Accordingly, would
N
1
N
say typical landscapes = 5 big valleys,
= 5 landscape
comprised many big valleys rather one.
N
data 4-5 show
= 1, typical landscapes clustering
global optima property. Examining Figure 7 (B), see able descend
random schedule globally optimal schedule probability 12 (normalized)
neighborhood radius 6%. reason, think landscapes random
N
JSP instances
= 1 small improving moves property extent.
This, combination curve Figure 5 (A) (which shows expected distance
random -optimal schedules function ) leads us say typical landscapes
N
random JSP instances
= 1 still roughly described big valleys. However,
valley much rougher (meaning larger steps required move random
schedule global optimum via sequence improving moves) extreme
N
values
.

Table 1 summarizes empirical findings discussed.
267

fiStreeter & Smith

(A) Job:machine ratio 1:5

(B) Job:machine ratio 1:1

1

1
0.8

3x15 instances
0.6

E[exactness]

E[exactness]

0.8

4x20 instances

0.4

5x25 instances

6x6 instances
0.6

7x7 instances
8x8 instances

0.4
0.2

0.2

0

0
0

0.1

0.2

0

0.3

0.2

0.3

Normalized radius

Normalized radius

(C) Job:machine ratio 5:1

(D) Comparison

1

1
0.8

E[exactness]

0.8

E[exactness]

0.1

15x3 instances
0.6

20x4 instances
0.4

3x15 instances

0.6

6x6 instances
0.4

15x3 instances

0.2

0.2

0

0
0

0.1

0.2

0.3

0

0.1

0.2

0.3

Normalized radius

Normalized radius

Figure 7: Expected exactness Nr function (normalized) neighborhood radius
N
r. Graphs (A), (B), (C) depict curves random instances
= 15 ,
1, 5, respectively. Graph (D) compares curves depicted (A), (B),
(C) (only curves largest instances shown (D)). (D), top
bottom error bars represent 0.75 0.25 quantiles (respectively) instancespecific exactness.

268

fiThe Landscape Random Job Shop Scheduling Instances

N

1
5

N
Table 1. Landscape attributes three values
.
Clustering
Small
improving
Description
global optima? moves?
Yes
Yes
Big valley

1

Yes

Somewhat

(Rough) big valley

5



Yes

Multiple big valleys

6.5 Analysis
first establish behavior curves depicted Figure 7 limiting cases
N
N
0 . use results characterize landscapes random
JSP instances using (r, , p) notation introduced 6.1.
N
N
following two lemmas show
0 (resp.
), random schedule
almost surely close optimal schedule. proofs given Appendix A.
Lemma 3. Let random N JSP instance, let random schedule
I. Let optimal schedule kS Sk minimal. Let f (M )
unbounded, increasing function . fixed N , holds whp (as )
kS Sk < f (M ).
Lemma 4. Let random N JSP instance, let random schedule I,
let optimal schedule kS Sk minimal. fixed
> 0, holds whp (as N ) kS Sk < N 1+ .
following immediate corollaries Lemmas 3 4.
Corollary 3. fixed N , expected exactness Nf (M ) approaches 1 ,
f (M ) unbounded, increasing function .
Corollary 4. fixed > 0, expected exactness NN 1+ approaches 1
N .

total number disjunctive edges N2 , two corollaries imply
N
N
0 (resp.
), curve depicted Figure 7 approaches horizontal line

height 1.
Using Lemmas 3 4, Theorems 3 4 characterize landscape random JSP
instances using (r, , p) notation 6.1. presenting theorems, slight
disclaimer order. Lemmas 3 4 (the proofs fairly involved) indicate
N
N
extreme cases
0
jump random schedule
globally optimal schedule via single small move. strongly believe cases
possible go random schedule global optimum sequence many
(smaller) improving moves, although proving seems difficult. Nevertheless,
understood theoretical results strictly imply existence landscapes
depicted Figure 6 (where starting points sequence two
small improving moves leading global optimum).
N
Theorem 3 shows
0, random JSP instance almost certainly

(r, , p) landscape r grows arbitrarily slowly function , o(M N2 ),
269

fiStreeter & Smith

N
p arbitrarily close 1. words,
0 landscape small
improving move(s) property clustering global optima property. contrast,
N
Theorem 4 shows
, random JSP instance almost surely
(r, , p) landscape unless (N 2 ). Instead, landscape contains (N !) (r, 1)-valleys,
N
r o(M N2 ). Thus,
, landscape small improving move(s)
property clustering global optima property. analytical results confirm
trend suggested Figure 7 discussed 6.4.

Theorem 3. Let random N JSP instance. Let f (M ) unbounded,
increasing function . fixed N > 0, holds whp (as )
(r, , p) landscape r = f (M ), = N2 p = 1 .
Proof. Let V set schedules L(S, Nr ) global optimum. follows
Corollary 3 whp, exactness r least p, means V
probability least p. remains show V (r, )-valley whp. Part 1
definition (r, )-valley satisfied definition V . Part 2 follows Theorem
1.
Theorem 4. Let random N JSP instance, let random schedule
I. exists set V (I) = ni=1 Vi schedules fixed > 0, V
following properties whp:
1. V ;
2. Vi (r, )-valley r = N 1+ = 1 [n];
3. n > N !(1 );
4. max{S1 ,S2 }V kS1 S2 k > (N 2 ).
Proof. Let {S1 , S2 , . . . , Sn } set globally optimal schedules I, define Vi
{S : L(S, N 1+ ) = Si }. Property 1 holds whp Lemma 4. Property 2 holds definition
Vi .
fact property 3 holds whp consequence Lemma 2. Recall Lemma
N
2 showed
, priority rule generates optimal schedule whp,
k
(I, Ji ) = + k. indices assigned jobs arbitrary, Lemma 2
applies priority rule (I, Jik ) = + (k), permutation [N ].
N ! possible choices . Let f number choices fail yield globally
optimal schedule. Property 3 fail hold f N !. Lemma 1, E[f ]
o(1)N !; hence f < N ! whp Markovs inequality.
establish property 4, choose permutations 1 2 list elements [N ]
reverse order (i.e., 1 (i) = 2 (N i) [N ]). Lemma 2, schedules S1 =
S( 1 , I) S2 = S( 2 , I) globally optimal whp. disjunctive edge
e = {J1 , J10 } must ~e(S1 ) 6= ~e(S2 ), hence kS1 S2 k |{{J, J 0 } : m(J1 ) =
1
1
m(J10 )}| N M2
= (N 2 ), obtain expression N M2
using pigeonhole
principle.
270

fiThe Landscape Random Job Shop Scheduling Instances

7. Quality Random Schedules
7.1 Methodology
section examine quality randomly generated schedules changes
function job:machine ratio. Specifically, various combinations N ,
estimate expected value following four quantities:
(A) makespan random schedule,
(B) makespan locally optimal schedule obtained starting random schedule
applying next-descent using N1 move operator,
(C) makespan optimal schedule,
(D) lower bound makespan optimal schedule given maximum
maximum job duration maximum machine workload:


X
max max (J), max
(o) .
JI

m[M ]

oops(I):m(o)=m

N
considered experiments set R = { 17 , 16 , 51 , 14 ,
values
1 1 2
3
3 , 2 ,S3 , 1, 2 , 2, 3, 4, 5, 6, 7 }. consider combinations N set
N
rR Sr , Sr {(N, ) :
= r, min(N, ) 2, max(N, ) 6, N < 1000}.
(N, ) S, estimate expected value (A) (resp. (B)) generating 100
random N JSP instances and, instance, generating 100 random schedules
(resp. local optima). estimate (D) generating 1000 random JSP instances
(N, ) S. combinations (N, ) Ssmall S, practical compute
N
quantity (C). Let nr = |Ssmall Sr | number combinations (N, )
= r
3
computed (C). chose Ssmall nr 4 r 6= 2 n 3 = 3.
2
(N, ) Ssmall , estimate (C) using 1000 random JSP instances.

7.2 Results
Figure 8 plots mean values (A), (B), (C), respectively, mean value
(D), various combinations N . data points combination N
N
assigned symbol based value
. Top bottom error bars represent 0.75
0.25 quantiles (respectively) instance-specific sample means. Note width
error bars small relative differences curves different values
N

.
N
Examining Figure 8, see set data points value
approximately (though exactly) collinear. Furthermore, three graphs slope line
N
formed data points
= r maximized r = 1, decreases r gets
away 1 (see Figure 9 (A)).
investigate trend, performed least squares linear regression set
N
data points value
. slopes resulting lines shown function
N
Figure 9 (A).
examination Figure 9 (A), apparent
271

fiStreeter & Smith

(A) Random schedules
Mean makespan

7000
6000
5000
4000

Ratio 1:5

3000

Ratio 1:3
Ratio 1:1

2000

Ratio 3:1

1000

Ratio 5:1

0
0

1000 2000 3000 4000 5000 6000 7000

Mean lower bound

(B) Random local optima
Mean makespan

7000
6000
5000
4000

Ratio 1:5

3000

Ratio 1:3
Ratio 1:1

2000

Ratio 3:1

1000

Ratio 5:1

0
0

1000 2000 3000 4000 5000 6000 7000

Mean lower bound

(C) Optimal schedules
Mean makespan

7000
6000
5000
4000

Ratio 1:5

3000

Ratio 1:3
Ratio 1:1

2000

Ratio 3:1

1000

Ratio 5:1

0
0

1000 2000 3000 4000 5000 6000 7000

Mean lower bound

Figure 8: Expected makespan (A) random schedules, (B) random local optima, (C)
optimal schedules vs. expected lower bound, various combinations N
N
(grouped symbol according
). Top bottom error bars represent
0.75 0.25 quantiles (respectively) instance-specific sample means.
272

fiThe Landscape Random Job Shop Scheduling Instances

(A) Results least squares regression

Slope E[makespan]
vs. E[lower bound]

4

Random schedules
Random local optima
Optimal schedules

3

2

1
0.1

1

10

Job:machine ratio

(B) Branch bound search cost
2:1

Num. tree nodes

10000

3:2

1:1
2:3

1000
1:2

100

1:3

3:1
4:1
5:1

10

1:4

1:5
1:6

6:1

1:7
7:1

1
0

500

1000

1500

log(search space size)

1:7
1:6
1:5
1:4
1:3
1:2
2:3
1:1
3:2
2:1
3:1
4:1
5:1
6:1
7:1

2000

Figure 9: (A) graphs slope least squares fits data Figure 8 (A), (B),
N
N
(C) function
(includes values
depicted Figure 8). (B)
th
graphs number search tree nodes (90 percentile) used branch
bound algorithm Brucker et al. (1994) find optimal schedule.

273

fiStreeter & Smith

N
value
becomes extreme (i.e., approaches either 0 ), expected makespan random schedules (resp. random local optima) comes closer
expected value lower bound makespan;

difference expected makespan random schedules (resp. random
local optima) expected value lower bound makespan maximized
N
value
1.
N
first two observations suggests
approaches either 0 ,
random schedule almost certainly near-optimal. 7.3 contains two theorems confirm
this.
second two observations suggests expected difference
makespan random schedule makespan optimal schedule maximized
N
value
somewhere neighborhood 1. observation particularly interesting
N
light empirical fact square instances JSP (i.e.,
= 1)
harder solve rectangular ones (Fisher & Thompson, 1963).
Figure 9 (B) graphs number search tree nodes (90th percentile) required
branch bound algorithm Brucker et al. (1994) optimally solve random N
instances, function log (base 10) search space size. take size
search space N JSP instance number possible disjunctive graphs,

namely 2N ( 2 ) . Note disjunctive graphs contain cycles therefore
correspond feasible schedules, expression overestimates size search
space. Data points given combination N could afford
run branch bound (i.e., combination N computed quantity
N
(C)). data points grouped curves according
.
Examining Figure 9 (B), see curves steepest ratios 23 , 1, 32 , 2,
N
3, curves substantially less steep extreme values
17
7. Thus, least point view particular branch bound algorithm,
random JSP instances exhibit easy-hard-easy pattern instance difficulty. discuss
pattern 7.4.

7.3 Analysis
following two theorems show that,
almost surely near-optimal.

N


approaches either 0 , random schedule

Theorem 5. Let random N JSP instance optimal makespan `min (I)
let random schedule I. fixed N > 0, holds whp (as )
`(S) (1 + )`min (I).
Proof. priority rule rand associates priority operation ops(I). Let
sequence contain elements ops(I), sorted ascending order priority.
schedule = S(rand , I) depends , N ! possible choices . Thus
rand seen choosing random set N ! instance-independent priority
rules. instance-independent priority rules subject Lemma 1, rand

Lemma 1 thus J, E[SJ ] O(N ). Thus E[`(S) `min (I)]
Palso subject

2
J E[J ] = O(N ), `(S) `min (I) exceed `min (I) = (M ) whp Markovs
inequality.
274

fiThe Landscape Random Job Shop Scheduling Instances

Theorem 6. Let random N JSP instance optimal makespan `min (I)
let random schedule I. fixed > 0, holds whp (as N )
`(S) (1 + )`min (I).
Proof. See Appendix A.
idea behind proof Theorem 6 following. shown Lemma 2,
priority rule almost surely generates optimal schedule. relevant property
that, operations sorted order ascending priority, number
operations J (o) (N ). key proof Theorem 6
expectation, rand shares property operations ops(I).
7.4 Easy-hard-easy Pattern Instance Difficulty
N
N
proofs Corollary 1 (resp. Lemma 2) show
0 (resp.
) exist
simple priority rules almost surely produce optimal schedule. Moreover, Theorems
5 6 show two limiting cases, even random schedule almost surely
N
N
makespan close optimal. Thus,
0
, almost
JSP instances easy.
N
contrast,
1, Figure 9 (A) suggests random schedules (as well random
local optima) far optimal. literature JSP (as well results depicted
N
Figure 9 (B)) attests fact random JSP instances
1 hard.
Thus conjecture that, 3-SAT, typical instance difficulty JSP follows easyhard-easy pattern function certain parameter. contrast 3-SAT, easyhard-easy pattern JSP (to knowledge) associated phase transition
N
(i.e., identified quantity undergoes sharp threshold
1).
Furthermore, although empirical results Figures 9 (A) (B) support idea
typical-case instance difficulty JSP follows easy-hard-easy pattern,
N
claim isolated particular value
point maximum
difficulty. shown Figure 9 (B), random JSP N JSP instances difficult
N
branch bound algorithm Brucker et. al (1994)
2, may
true branch bound algorithms JSP heuristics based local search.
leave task characterizing easy-hard-easy pattern precisely future
work.
related work, Beck (1997) studied constraint-satisfaction (as opposed makespanminimization) version JSP, gave empirical evidence probability
random JSP instance satisfiable undergoes sharp threshold function quantity
called constrainedness instance.

8. Limitations Extensions
primary limitation work reported paper theoretical
empirical results apply random instances job shop scheduling problem.
guarantee observations generalize instances drawn distributions
interesting structure (Watson et al., 2002). difficulty extending
analysis distributions analytical results similar ones presented
275

fiStreeter & Smith

paper may become much difficult derive. However, least three
distributions studied scheduling literature believe
difficult adapt proofs (the conclusions may change part
adaptation process).
Random workflow JSP instances. workflow JSP instance, set machines
partitioned sets (say M1 , M2 , . . . , Mk ). < j, job must use
machines Mi using machines Mj . Mattfeld et al. (1999) define
random distribution workflow JSPs generalizes natural way
distribution defined 3.3 (the difference permutations 1 , 2 , . . . , N
chosen uniformly random set permutations satisfy workflow
constraints).
Random instances (permutation) flow shop scheduling problem. instance
flow shop scheduling problem (FSP) JSP instance jobs use
machines order (equivalently, FSP instance workflow JSP instance
k = ). permutation flow shop problem (PFSP) special case FSP
which, additionally, machine must process jobs order.
large literature (P)FSP; Framinan et al. (2004) Hejazi Saghafian
(2005) provide relevant surveys.
Job-correlated machine-correlated JSP instances. job-correlated JSP instance,
distribution operation durations drawn depends job
operation belongs. Similarly, machine-correlated JSP instance distribution
depends machine operation performed. Watson et al. (2002)
studied job-correlated machine-correlated instances PFSP.
Regarding difficulty instances drawn three distributions, computational
experience shows (i) random workflow JSPs harder random JSPs; (ii) random PFSPs easier random JSPs; (iii) job-correlated machine-correlated
PFSPs easier random PFSPs. Extending theoretical analysis
distributions may give insight relevant differences them.
8.1 Big Valley vs. Cost-Distance Correlations
6, defined big valley landscape one exhibits two properties: small improving moves clustering global optima. analytical experimental results
based definition. Although believe definition captures properties JSP
landscapes important designers heuristics understand, properties
(e.g., cost-distance correlations) likely important well. particular, may
possible algorithms exploit cost-distance correlations landscapes neither
small improving moves clustering global optima properties.
existing literature, term big valley used amorphously mean either
(1) landscape depicted Figure 1 (2) landscape exhibits high costdistance correlations. making sharper distinction two distinct concepts,
improve understanding JSP landscapes well landscapes
combinatorial problems.
276

fiThe Landscape Random Job Shop Scheduling Instances

9. Conclusions
9.1 Summary Experimental Results
N
Empirically, demonstrated low values job machine ratio (
), lowmakespan schedules clustered small region search space backbone
N
size high.
increases, low-makespan schedules become dispersed throughout
N
search space backbone vanishes. function
, smoothness
landscape (as measured statistic called neighborhood exactness) starts small
N
N
N
low values
(e.g.,
= 15 ), relatively high
1, becomes small
N
N
N
high values (e.g., = 5). extremely low extremely high values
,
expected makespan random schedules comes close optimal schedules.
quality random schedules (resp. random local optima) appears worst
N
value
1.
6.4 discussed implications results big valley picture JSP search
N
1, concluded typical landscape described big
landscapes.
N
N
valley, larger values
(e.g.,
3) many big valleys. 7.4 discussed
data support idea JSP instance difficulty exhibits easy-hard-easy
N
.
pattern function

9.2 Summary Theoretical Results
Table 2 shows asymptotic expected values various attributes random N
N
N
JSP instance limiting cases
0
.
Table 2. Attributes random JSP instances.
Fixed N , Fixed , N
Optimum makespan

Max. job length
(Corollary 1)

Max. machine workload
(Corollary 2)

Normalized backbone size

1 (Theorem 1)

0 (Theorem 2)

Normalized maximum distance global optima
Normalized distance random
schedule nearest global optimum
Ratio makespan random schedule
optimum makespan

0 (Theorem 1)

(1) (Theorem 4)

0 (Lemma 3)

0 (Lemma 4)

1 (Theorem 5)

1 (Theorem 6)

9.3 Rules Thumb Designing JSP Heuristics
Though claim deep insights solve random instances
JSP, results suggest two general rules thumb:
N
N

low (say,
1 lower), algorithm attempt locate
cluster global optima exploit it;

277

fiStreeter & Smith

N
N

high (say,
3) algorithm attempt isolate one
clusters global optima deal separately them.

briefly discuss ideas relation two recent algorithms: backbone-guided local
search (Zhang, 2004) i-TSAB (Nowicki & Smutnicki, 2005).
9.3.1 Backbone-guided local search
Several recent algorithms attempt use backbone information bias move operator employed local search. example, Zhang (2004) describes approach called
backbone-guided local search frequency attribute (e.g., assignment particular value particular variable Boolean formula) appears
random local optima used proxy frequency attribute appears global optima. approach improved performance WalkSAT algorithm
(Selman, Kautz, & Cohen, 1994) large instances SATLIB (Hoos & Stutzle, 2000).
similar algorithm successfully applied TSP (Zhang & Looks, 2005)
improve performance iterated Lin-Kernighan algorithm (Martin, Otto, & Felten,
1991). Zhang writes:
method built upon following working hypothesis: problem
whose optimal near optimal solutions form cluster, local search algorithm reach close vicinities solutions, algorithm effective
finding information solution structures, backbone particular.
(Zhang, 2004, p. 3)
Based results 4-5, working hypothesis satisfied random JSPs
1 lower. seems plausible backbone-guided local search could used boost
performance early local search heuristics JSP van Laarhoven
et al. (1992) Taillard (1994) (whether results would competitive
recent algorithms i-TSAB separate question).
N
hypothesis typically violated random JSP instances larger values
.
cases makes sense attempt exploit local clustering optimal
near-optimal schedules.
N


9.3.2 i-TSAB
Nowicki Smutnicki (2005) present JSP heuristic called i-TSAB employs multiple
runs tabu search algorithm TSAB (Nowicki & Smutnicki, 1996). i-TSAB employs path
relinking localize center BV [big valley], probably close global minimum
(Nowicki & Smutnicki, 2005). words, i-TSAB designed based intuitive
picture depicted Figure 6 (A), inaccurate typical random JSP instances
N
N
3. Note although random JSP instances become easy , instances
N

3 means easy, evidenced Figure 9 (B).
concreteness, briefly describe i-TSAB works. Initially, i-TSAB performs
number independent runs TSAB adds best-of-run schedule pool elite
solutions. performs additional runs TSAB uses best-of-run schedules
additional runs replace schedules pool elite solutions. Starting points
278

fiThe Landscape Random Job Shop Scheduling Instances

additional TSAB runs either (i) random elite solutions (ii) schedules obtained
performing path relinking random pair elite solutions. Given two schedules S1
S2 , path relinking uses move operator generate new schedule midway
(in terms disjunctive graph distance) S1 S2 . pool elite solutions
thought cloud particles hovers search space (hopefully)
converges region space containing global optimum.
N
random JSP instances
1, results consistent idea
cloud elite solutions converges center big valley. random JSP
N
instances
3, however, cloud must either converge one many big valleys
converge all. alternate approach one imagine using multiple clouds,
intention cloud specializes particular big valley. seems plausible
ideas could improve performance i-TSAB random JSP instances
N
larger values
.

Appendix A: Additional Proofs
P
proofs section, define (O) oO (o), set operations.
make use following inequality (Spencer, 2005).
Azumas Perimetric Inequality (A.P.I.). Let X = (X1 , X2 , . . . , Xn ) vector n independent random variables. Let function f (x) take input vector x = (x1 , x2 , . . . , xn ),
xi realization Xi [n], produce output real number. Suppose
> 0 holds two vectors x x0 differ one
component,
|f (x) f (x0 )| .
> 0,




2
P X > E[X] + n exp 2 .
2

inequality holds P [X E[X] n].
Lemma 2. Let random N JSP instance. fixed , holds whp (as
N ) schedule = S( , I) property
S(o) = + (M(o)) ops(I) .
Proof. remains prove Claim 2.1 proof 4, says whp,
ops2+ (I)
1
S(o) S(J (o)) E[S(o) S(J (o))] .
2
Pick arbitrary operation ops2+ (I), suppose random choices used
construct made following order:
1. Randomly choose m1 = m(o) m2 = J (o).
2. k 1 N :
279

fiStreeter & Smith

(a) Randomly choose order job J k uses machines (if J k
part choice already made step 1).
(b) Randomly choose (Jik ) [M ].
Let random variable Xk denote sequence random bits used steps (a)
(b) k th iteration loop. Define S(o) S(J (o)). Then, fixed choices
m1 m2 , function N independent events X1 , X2 , . . . , XN , easy
check altering particular Xi changes value 2max . Thus
h



1)
P < 12 E[o ] = P < E[o ] (N
2M
h

N
P < E[o ] 2M


2
exp 2(4M N
2
max )
first step used fact (from proof 4) E[o ] = (NM1)
last step used A.P.I. Taking union bound N (M 1) operations
ops2+ (I) proves claim.

Lemma 3. Let random N JSP instance, let random schedule
I. Let optimal schedule kS Sk minimal. Let f (M )
unbounded, increasing function . fixed N , holds whp (as )
kS Sk < f (M ).
Proof. Let = S(0 , I). proof Corollary 1 showed J, E[SJ ] O(N 2 ).
Thus holds whp SJ < log(f (M )) J. proof Theorem 5, procedure
used produce mixture instance-independent priority rules, subject
Lemma 1. Thus J, E[SJ ] O(N ), whp SJ < log(f (M )) J.
P
P
Let Onear (Ji ) = {Jj0 : J 0 6= J, | i0 <i (Ji0 ) j 0 <j (Jj0 0 )| < log(f (M ))}. (Onear (Ji )
set operations would scheduled near time Ji ignored fact
machine may perform one operation time.) Let Enear = {e = {Ji , Jj0 }
E(I) : Jj0 Onear (Ji )}. assumptions previous paragraph (each
hold whp), kS Sk |Enear |. Ji , E[|Onear (Ji )|] O(N log f (M )). Thus


E kS Sk E [|Enear |] =

X
oops(I)


1
E [|Onear (o)|] = N 2 log(f (M ))


kS Sk < f (M ) whp Markovs inequality.
purpose remaining proofs, convenient introduce additional
notation. Let = (T1 , T2 , . . . , T|T | ) sequence operations. define
T(i1 ,i2 ] {Ti : i1 < i2 },
T(im1 ,i2 ] {Ti T(i1 ,i2 ] : m(Ti ) = m} .
280

fiThe Landscape Random Job Shop Scheduling Instances

Lemma 4. Let random N JSP instance, let random schedule I,
let optimal schedule kS Sk minimal. fixed
> 0, holds whp (as N ) kS Sk < N 1+ .
Proof. Let sequence operations ops(I), sorted ascending order priority
rand (I, o) (where rand random priority rule used create S). Note
ops(I) J (o) 6= , J (o) must appear . Let Ti denote ith operation
.
Consider schedule defined following procedure:
1. S(o) ops(I).
2. Q (). Let Qj denote j th operation Q.
3. Let function ready(o) return true + (M(o)) + (J (o)), false otherwise.
4. 1 N do:
(a) ready(Ti ), set S(o) + (M(Ti )). Otherwise append Ti onto Q.
(b) j 1 |Q| do:
i. ready(Qj ), set S(Qj ) + (M(Qj )) remove Qj Q.
5. Schedule remaining operations Q manner specified (in last
paragraph proof).
construction construction S, except manipulations
involving Q. purpose Q delay scheduling operation that,
scheduled immediately, might produce schedule S(o) > + (M(o)). first
show kS Sk < N 1+ whp; show optimal whp.
Let P
Qi denote Q exists iterations step 4 performed. Let
NM

iterations Q. claim
q(o) =
i=1
P |o Q | number
N

|. Letting E 6= = {e E(I) : ~e(S) 6= ~e(S)},
kS Sk oops(I) q(o) + (N 1)|Q
kS Sk = |{e E 6= : e QN = }| + |{e E 6= : e QN 6= }|
|{e E 6= : e QN = }| + (N 1)|QN |
P
suffices show |{e E 6= : e QN = }|
oops(I) q(o). see this, let
=
6
N

e = {o1 , o2 } E e Q
= . must q(o1 ) + q(o2 ) > 0. charge e
operation {o1 , o2 } inserted Q first. easy see operation
charged one edge perPiteration spends Q, establishing claim.
Thus suffices show kS Sk oops(I) q(o) + (N 1)|QN | N 1+ whp.
1

0

1

0

divide construction n = N 2 epochs, consisting N 2 +
iterations step 4, to-be-specified 0 > 0. Let zj denote number iterations
step 4 occur end j th epoch, zj = 0 j 0 convention. Let

Cjm T(0,z
\ Qzj set operations scheduled run
j]

end j th epoch;
281

fiStreeter & Smith


Onear j[n] {o T(zj1 ,zj ] : J (o) T(zj(M +2) ,zj ] } set operations whose
job-predecessor belongs nearby epoch.
1

0

[N ], P[Ti Onear ] (M + 2)N 2 + . Thus j [n], E[|Onear
0
T(zj1 ,zj ] |] (M + 2)N 2 . Using A.P.I. straightforward show whp,
|Onear T(zj1 ,zj ] | N

1+0
2

j [n] .

(9.1)

claim whp, following statements hold j [n]:
[

Qi Onear ,

(9.2)

izj

J Qzj1 6= |J Qzj1 Qzj | < |J Qzj1 |
zj

zjM

Q Q

|Qzj | N

J ,

(9.3)

= ,
1+0
2

(9.4)

.

(9.5)

prove induction, step induction fails exponentially
small probability. j = 0, (9.3) (9.4) hold trivially. (9.2) true
operations T(0,z1 ] \ Onear first operations jobs, hence cannot added
Q. (9.5) follows (9.2) (9.1).
Consider case j > 0. show (9.2), let arbitrary operation T(zj1 ,zj ] \Onear .
m(J (o))

induction hypothesis (specifically, equation (9.4)), J (o) Cj2




m(J (o))
m(o)
0 Cj2
> Cj1 . induction hypothesis,

. Thus q(o) >









1+0
m(o)
m(J (o))
m(o)
m(J (o))
.
Cj1 Cj2
T(0,zj1 ] N 2 T(0,zj2 ]
Letting denote right hand side inequality, E[] =
1+0
2

1
+0
1
2
MN



, A.P.I. used show K > 0 independent N , P[ <
MN
0
0
0] exp( K1 N ). Thus (9.2) holds probability least 1 exp( K1 N ).
show (9.3), let J J Qzj1 6= , let Ji Qzj1
chosenso
m(J (Ji ))
m(J (Ji ))
m(J )
minimal. J (Ji ) Cj1
. Thus Ji Qzj Cj1
> Cj . (9.1),
1+0

(9.2), induction hypothesis (equation (9.5)), |Qzj | (M + 1)N 2 . Using
0
technique above, show (9.3) holds probability least 1 exp( K1 N )
K > 0 independent N .
(9.3) implies (9.4). (9.2) (9.4) together (9.1) imply (9.5). Thus whp, (9.2)
(9.5) hold j [n].
(9.2) (9.4),


X
1
0
0
E
q(o) E[|Onear |]M N 2 + 2 (M + 2)N 1+2
oops(I)


282

fiThe Landscape Random Job Shop Scheduling Instances

0

E[|QN |] E[|T(znM ,zn ] Onear |] (M + 2)N 2
P
setting 0 = 3 gives kS Sk oops(I) q(o) + (N 1)|QN | N 1+ whp.
remains show optimal whp. first prove following claim.
Claim 4.1. non-negative integers b, probability T(a,b] contains
two operations job

(ba)2
N .

Proof Claim 4.1. Let X denote number pairs operations T(a,b] belong
1
(ba)2
job. P[X > 0] E[X] ba
2 N
N .
see optimal whp, note operations scheduled prior step 5
cause idle time machine, operations QN cause
sub-optimal. Let (m) ({o ops(I) : m(o) = m}) denote workload machine
m. Let = arg maxm[M ] (m). following hold whp.
set Z
last. (It holds

1

consists operations belonging jobs use

(N 2M N 4 ,N ]
whp Z Z,

Z

1

(N N 3 ,N ]

. Z contains

operation job use last, Z must contain two operations
job. Claim 4.1, probability happens
1
(N 3 )2 N1 = o(1).)
1

N 4 (Z ) (Z ) (m) (m) 6= m. (This follows applying
Central Limit Theorem (Z ), (m), (m)).
Thus whp holds prior execution step 5, contains period length
1
least (Z ) N 4 operations processed Z ,
0
{o ops(I) : J (o) Z } = . Assuming |QN | < N 3 (holds whp), always
schedule operations QN guarantee `(S) = (m), implies optimal.

Theorem 6. Let random N JSP instance optimal makespan `min (I)
let random schedule I. fixed > 0, holds whp (as N )
`(S) (1 + )`min (I).
Proof. proof Lemma 4, let sequence operations ops(I), sorted
ascending order priority rand (I, o) (where rand random priority rule used
create S). Note ops(I) J (o) 6= , J (o) must appear .
Let Ti denote ith operation .
Rather analyze directly, analyze schedule defined following procedure:
1. 0.
2. 1 N do:
283

fiStreeter & Smith

(a) Set S(Ti ) = max(t, + (J (Ti )), + (M(Ti ))) .
(b) + (J (Ti )) > + (M(Ti )), set = maxi0 + (Ti0 ).
procedure identical one used construct S, except that, whenever
operation Ti assigned start time S(Ti ) > + (M(Ti )), procedure inserts artificial
delays schedule order re-synchronize machines. , clear
`(S) `(S). Thus, suffices show `(S) (1 + )`min (I) whp.
divide construction n epochs, update (in step 2(b)) defines beginning new epoch. Let zi number operations scheduled
end ith epoch, z0 = 0 convention. Let ti = maxi0 zi + (oi0 ) (updated)
P
+
0
value end ofPthe ith epoch. Define
m=1
Ptni maxi0 <i,m(Ti0 )=m (Ti ).
n
`(S) `min (I) i=1 , suffices show i=1 `min (I) whp.
P
2
Let P
= [n], let L = {i : zi zi1 N 7 }. first consider iL ;
consider iI\L .
2

Let i1 i2 arbitrary integers 0 i1 , i2 N i2 i1 N 7 . Let
i1
. , function outcome
= (T(im1 ,i2 ] ). E[ ] = i2M
i2 i1 events (namely, definition jobs {J : J T(i1 ,i2 ] 6= }),
alters value max . follows A.P.I.
!
0

N 2
0
P[| E[ ]| > N
i2 i1 ] 2 exp 2
2max

0 > 0. Thus, holds whp | E[ ]| N i2 i1 possible choices
0
i1 i2 . particular, whp
2M N zi zi1 L, implies
p
P
5 P
6
2
0
0
7
2M N N 7 = 2M N 7 + .
iL N
iL
P
consider
iI\L . shown proof Lemma 4 (Claim 4.1),
non-negative integers b probability T(a,b] contains two operations
2

2

7
job (ba)
N . Thus probability arbitrary subsequence size N
4
37
contains two operations job N , E[|I \ L|] N 7 . Clearly
P
2
6
max N 7 \ L, E[ iI\L ] O(N 7 ).
P
P
6
6
0
0
Thus E[ iI ] O(N 7 + ) 0 > 0, iI N 7 +2 whp, easy
see `min (I) N2 whp.

References
Achlioptas, D., & Peres, Y. (2004). threshold random k-SAT 2k log 2 O(k).
Journal AMS, 17, 947973.
Balas, E. (1969). Machine sequencing via disjunctive graphs: implicit enumeration
algorithm. Operations Research, 17, 110.
Beasley, J. E. (1990). OR-library: Distributing test problems electronic mail. Journal
Operational Research Society, 41(11), 10691072.
284

fiThe Landscape Random Job Shop Scheduling Instances

Beck, J. C., & Jackson, W. K. (1997). Constrainedness phase transition job
shop scheduling. Tech. rep. CMPT97-21, School Computing Science, Simon Fraser
University.
Boese, K. D., Kahng, A. B., & Muddu, S. (1994). new adaptive multi-start technique
combinatorial global optimizations. Operations Research Letters, 16, 101113.
Brucker, P., Jurisch, B., & Sievers, B. (1992). Job-shop (C-codes). European Journal Operational Research, 57, 132133. Code available http://optimierung.
mathematik.uni-kl.de/ORSEP/contents.html.
Brucker, P., Jurisch, B., & Sievers, B. (1994). branch bound algorithm
job-shop scheduling problem. Discrete Applied Mathematics, 49(1-3), 107127.
Cheeseman, P., Kanefsky, B., & Taylor, W. M. (1991). really hard problems are.
Proceedings Twelfth International Joint Conference Artificial Intelligence,
IJCAI-91, Sidney, Australia, pp. 331337.
Fisher, H., & Thompson, G. L. (1963). Probabilistic learning combinations local job-shop
scheduling rules. Muth, J. F., & Thompson, G. L. (Eds.), Industrial Scheduling,
pp. 225251. Prentice-Hall, Englewood Cliffs, NJ.
Framinan, J. M., Gupta, J. N. D., & Leisten, R. (2004). review classification
heuristics permutation flow-shop scheduling makespan objective. Journal
Operational Research Society, 55(12), 12431255.
French, S. (1982). Sequencing Scheduling: Introduction Mathematics
Job-Shop. Wiley, New York.
Glover, F., & Laguna, M. (1997). Tabu Search. Kluwer Academic Publishers, Boston, MA.
Hejazi, S. R., & Saghafian, S. (2005). Flowshop-scheduling problems makespan criterion: review. International Journal Production Research, 43(14), 28952929.
Hoos, H. H., & Stutzle, T. (2000). SATLIB: online resource research SAT.
Gent, I. P., v. Maaren, H., & Walsh, T. (Eds.), Proceedings SAT 2000, pp. 283292.
SATLIB available online www.satlib.org.
Jain, A., & Meeran, S. (1998). state-of-the-art review job-shop scheduling techniques.
Tech. rep., Department Applied Physics, Electronic Mechanical Engineering,
University Dundee, Dundee, Scotland.
Jones, A., & Rabelo, L. C. (1998). Survey job shop scheduling techniques. Tech. rep.,
National Institute Standards Technology, Gaithersburg, MD.
Kim, Y.-H., & Moon, B.-R. (2004). Investigation fitness landscapes graph bipartitioning: empirical study. Journal Heuristics, 10, 111133.
Lourenco, H., Martin, O., & Stutzle, T. (2003). Iterated local search. Glover, F., &
Kochenberger, G. (Eds.), Handbook Metaheuristics. Kluwer Academic Publishers,
Boston, MA.
Mammen, D. L., & Hogg, T. (1997). new look easy-hard-easy pattern combinatorial search difficulty. Journal Artificial Intelligence Research, 7, 4766.
285

fiStreeter & Smith

Martin, O. C., Otto, S. W., & Felten, E. W. (1991). Large-step Markov chains
traveling salesman problem. Complex Systems, 5, 299326.
Martin, O. C., Monasson, R., & Zecchina, R. (2001). Statistical mechanics methods
phase transitions combinatorial problems. Theoretical Computer Science, 265(1-2),
367.
Mattfeld, D. C. (1996). Evolutionary Search Job Shop: Investigations Genetic
Algorithms Production Scheduling. Physica-Verlag, Heidelberg.
Mattfeld, D. C., Bierwirth, C., & Kopfer, H. (1999). search space analysis job shop
scheduling problem. Annals Operations Research, 86, 441453.
Mezard, M., & Parisi, G. (1986). replica analysis traveling salesman problem.
Journal de Physique, 47, 12851296.
Monasson, R., Zecchina, R., Kirkpatrick, S., Selman, B., & Troyansky, L. (1999). Determining computational complexity characteristic phase transitions. Nature, 400,
133137.
Nowicki, E., & Smutnicki, C. (1996). fast taboo search algorithm job-shop problem.
Management Science, 42(6), 797813.
Nowicki, E., & Smutnicki, C. (2001). new ideas TS job shop scheduling. Tech.
rep. 50/2001, University Wroclaw.
Nowicki, E., & Smutnicki, C. (2005). advanced tabu search algorithm job shop
problem. Journal Scheduling, 8, 145159.
Reeves, C. R., & Yamada, T. (1998). Genetic algorithms, path relinking, flowshop
sequencing problem. Evolutionary Computation, 6, 4560.
Roy, B., & Sussmann, B. (1964). Les problemes dordonnancement avec contraintes disjonctives. Note D.S. no. 9 bis, SEMA, Paris, France, Decembre.
Selman, B., Kautz, H., & Cohen, B. (1994). Noise strategies local search. Proceedings
AAAI-94, pp. 337343.
Slaney, J., & Walsh, T. (2001). Backbones optimization approximation. Proceedings 17th International Joint Conference Artificial Intelligence (IJCAI2001), pp. 254259.
Spencer, J. (2005). Modern probabilistic methods combinatorics. http://www.cs.nyu.
edu/cs/faculty/spencer/papers/stirlingtalk.pdf.
Streeter, M. J., & Smith, S. F. (2005a). Characterizing distribution low-makespan
schedules job shop scheduling problem. Biundo, S., Myers, K., & Rajan, K.
(Eds.), Proceedings ICAPS 2005, pp. 6170.
Streeter, M. J., & Smith, S. F. (2005b). Supplemental material ICAPS 2005 paper
Characterizing distribution low-makespan schedules job shop scheduling
problem. http://www.cs.cmu.edu/~matts/icaps_2005.
Taillard, E. (1993). Benchmarks basic scheduling problems. European Journal Operational Research, 64, 278285.
286

fiThe Landscape Random Job Shop Scheduling Instances

Taillard, E. (1994). Parallel taboo search techniques job shop scheduling problem.
ORSA Journal Computing, 6, 108117.
van Laarhoven, P., Aarts, E., & Lenstra, J. (1992). Job shop scheduling simulated
annealing. Operations Research, 40(1), 113125.
Watson, J.-P., Barbulescu, L., Whitley, L. D., & Howe, A. (2002). Contrasting structured
random permutation flow-shop scheduling problems: search-space topology
algorithm performance. INFORMS Journal Computing, 14(2), 98123.
Watson, J.-P., Beck, J. C., Howe, A. E., & Whitley, L. D. (2001). Toward understanding
local search cost job-shop scheduling. Cesta, A. (Ed.), Proceedings Sixth
European Conference Planning.
Yokoo, M. (1997). adding constraints makes problem easier hill-climbing
algorithms: Analyzing landscapes CSPs. Principles Practice Constraint
Programming, pp. 356370.
Zhang, W. (2004). Configuartion landscape analysis backbone guided local search: Part
I: Satisfiability maximum satisfiability. Artificial Intelligence, 158(1), 126.
Zhang, W., & Looks, M. (2005). novel local search algorithm traveling salesman problem exploits backbones. Proceedings 19th International Joint
Conference Artificial Intelligence, pp. 343350.

287


