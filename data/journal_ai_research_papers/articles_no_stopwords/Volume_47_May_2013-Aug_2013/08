journal artificial intelligence

submitted published

heuristic search time matters
ethan burns
wheeler ruml

eaburns cs unh edu
ruml cs unh edu

department computer science
university hampshire
durham nh usa

minh b

minh b nasa gov

scheduling group
sgt inc
nasa ames center
moffett field ca usa

abstract
many applications shortest path impractical provably
optimal solution one hope achieve appropriate balance search
time solution cost respects users preferences preferences come many
forms consider utility functions linearly trade search time solution cost
many natural utility functions expressed form example solution
cost represents makespan plan equally weighting search time plan makespan
minimizes time arrival goal achieved current state theart approaches optimizing utility functions rely anytime use
extensive training data compute termination policy propose direct
called bugsy incorporates utility function directly search
obviating need separate termination policy describe method
line parameter tuning novel benchmark domain time pressure
platform style video games present believe first
empirical study applying anytime monitoring heuristic search compare
proposals suggest parameter tuning technique give
best performance representative set training instances available bugsy
choice performs well require line training
work extends tradition metareasoning search illustrating
benefits embedding lightweight reasoning time search

introduction
many artificial intelligence formulated shortest path
solved heuristic search hart nilsson raphael
unfortunately state spaces often grow exponentially size
usually infeasible optimal solutions shortest path practical interest
instead practitioners tend settle suboptimal solutions often found
efficiently expensive execute one left choice spending
long time searching cheap solution little time searching expensive one
argue strictly concerned optimizing solution cost
optimizing utility function given terms solution cost search time
c

ai access foundation rights reserved

fiburns ruml

utility function user specify preference search time solution
cost handles rest
consider utility functions given linear combination search time solution
cost important form utility function two reasons first easily elicited
user already explicitly application domain example cost
given monetary terms usually possible ask much time one willing spend
decrease solution cost certain amount second solution cost given terms
time e cost represents time required agent execute solution
form utility function used optimize call goal achievement time
weighting search time execution time equally utility aware search attempt
minimize sum two thus attempting behave agent achieve
goal quickly possible
existing techniques anytime dean
boddy general class emit stream solutions decreasing
cost converging optimal one sufficient knowledge performance
profile anytime represents probability decrease
solution cost certain amount given current solution cost additional search time
possible create stopping policy aware users preference trading
solving time solution cost hansen zilberstein finkelstein markovitch
two disadvantages anytime trade solving time
solution cost first profile anytime must learned line
representative set training instances many settings domain independent
set unknown one cannot easily assemble representative training set often obvious parameters affect performance
difficult tell set representative even instance generator
available instances generates may represent seen real world
second issue stopping policy aware users preference time
cost underlying anytime oblivious emit stream
solutions regardless desired trade policy must simply best
solutions found may waste lot time finding many
solutions simply discarded search fully aware
possible candidate solutions available relative estimated merits
presents four main contributions first combine anytime heuristic search
dynamic programming monitoring technique hansen zilberstein
best knowledge first apply anytime monitoring
anytime heuristic search second present simple portfolio method
estimates good parameter use bounded suboptimal search optimize
given utility function third present bugsy best first search
rely line training yet accounts users preference search time
solution cost one important difference bugsy previous proposals
trading deliberation time solution cost bugsy considers trade directly search whereas previous techniques anytime
consider trade externally actual search finally
previous version bugsy proposed ruml see appendix discussion
improvements incorporated version presented



fiheuristic search time matters

present set experiments comparing portfolio method anytime monitoring bugsy along utility oblivious greedy
best first search real time search decision theoretic dta russell
ericwefald previously proposed utility aware search much
work discussing trade deliberation solution cost best
knowledge first implement thoroughly evaluate many ideas
context heuristic search
experiments reveal two surprises first representative set
training instances available effective simple technique
selecting bound use bounded suboptimal search surprisingly convincingly
dominates anytime monitoring tests second neither bugsy
anytime search monitoring dominates bugsy require line
training yet surprisingly bugsy perform well methods use training data
representative set available bugsy choice
work extends tradition metareasoning illustrating
benefits embedding lightweight reasoning time search

background
section briefly describe heuristic search present terminology used
remainder discuss type utility functions addressing
heuristic search
considered heuristic search technique finding shortest path
nodes weighted graph many specified form since
typical graphs much large represent explicitly usually
generate graph lazily function called expand expand function returns
successors node graph call process evaluating expand function
node expanding node expanding node say generating
successors
hart et al probably best known heuristic search maintains two sets nodes open list contains frontier nodes generated
yet expanded closed list contains nodes already expanded
common optimization closed list include nodes already
open list therefore represent duplicate states encountered open list
sorted f n g n h n g n cost path initial node
node n h n heuristic estimate cheapest path cost n goal node
reachable n proceeds removing node minimum f value
open list expanding putting children open list putting node
closed list removes goal node open list stops searching
returns path goal solution finally heuristic never estimates
cost go called admissible admissible heuristic returns optimal
solutions
dechter pearl prove heuristic satisfies property called consistency
nodes n h n h c n c n cost cheapest


fiburns ruml

path n expands fewest possible nodes required prove
optimality solution given heuristic practice often takes long
helmert roger thus given optimal efficiency infeasible look optimal
solutions many instead one must settle suboptimal solutions
hope possible sufficiently cheap solution within reasonable amount
time memory
suboptimal search
greedy best first search michie ross popular suboptimal search
proceeds orders open list heuristic h n idea
remaining search effort correlates remaining solution cost words assumes
easier path goal nodes low h strictly
attempting minimize search time thayer ruml greedy best first
search different heuristic effective instead estimating cost go
done traditional h functions heuristic called distance estimate estimates
number remaining search nodes path cheapest solution beneath node
practice distance estimates readily available cost go heuristics provide
much better performance used greedy best first search domains less cost
go directly correlated less search go call greedy best first search
heuristic speedy search analogy greedy search
greedy best first search solutions quickly bound
cost solutions bounded suboptimal search remedy weighted
pohl perhaps common techniquesit proceeds
orders open list f n g n w h n w weighting parameter
w puts emphasis heuristic estimate cost arriving node thus
greedier often finds suboptimal solutions much faster finds
optimal ones addition weight provides bound suboptimality solutions
solutions w times cost optimal solution pohl unlike
greedy best first search weighted lets user select weight allowing provide
cheaper solutions faster solutions depending needs
refer reader work thayer depth study suboptimal
bounded suboptimal search including many use heuristics
utility functions
far described optimizes solution cost bounded suboptimal search
finds solutions within constant factor optimal greedy best first search
attempts minimize solver time often none really desired optimal solutions
require impractical amount resources one rarely requires solutions strictly within
given bound optimal unboundedly suboptimal solutions costly instead
propose optimizing simple utility function given linear combination search time
solution cost
u wf g wt

solution g cost solution time solution
returned wf wt user specified weights used express preference trading


fiheuristic search time matters

search time solution cost number time units user willing spend
achieve improvement one cost unit wf wt quantity usually easily elicited
users already explicit application domain cost empty
solution g user specified value defines utility achieved case
search gives without returning solution
linear utility function two main benefits first fairly expressive
example one optimize cost solution search time given
monetary terms situation occur cloud computing environments computation time costs money linear utility function capture optimal greedy search
weight execution time solution cost respectively additionally
linear utility function express goal achievement time weighting search time equally
solution makespan practical examples minimizing goal achievement time
desired include robotic video game pathfinding settings user
often care optimal solutions take long may
care achieving goal quickly possible
demonstration minimizing goal achievement time made video
speedy search bugsy solving pathfinding video game pathfinding
available online appendix web http youtu
yluf v plu video includes three panels showing agent different
search since focus finding cost optimal solutions
speedy bugsy agents begin moving almost immediately agent stands still
long time plans optimal path doesnt start moving bugsy
arrived goal occurring speedy agent following
extremely circuitous path doesnt reach goal approximately seconds
didnt agonizing seconds video instead stopped recording
soon reached goal clearly bugsy agent optimizes goal achievement
time solution cost search time preferred scenario
quite expressive linear utility functions rather simple one main benefit
simplicity fixed utility function passage time decays utility
values rate simplification allows us ignore time passed
current decision point express utility values terms utility
outcome starting current moment time without benefit mere passage
time would change relative ordering utilities different outcomes
would need compute utility values every point time order select best
outcome
consider linear utility functions work noted one
could consider expressive functions step functions example represent
deadlines certain amount time elapsed utility acting greatly
decreases bugsy support functions anytime monitoring technique
discussed section restrictions utility functions optimize
anytime monitoring naturally handle expressive functions step functions

previous work
next describe previous techniques trading solver time solution cost


fiburns ruml

monitoring anytime
much previous work optimizing utility functions solving time cost equation focused finding stopping policies anytime anytime
dean boddy general class one solution
stream solutions strictly decreasing cost get name one
stop anytime time get current best solution anytime
attractive candidate optimizing utility function since
single solution pick opportunity choose solution
greater utility finds single solution different
solutions found different times knew time
would solutions cost solutions could compute
utilities return solution maximizes utility unfortunately usually
possible know solutions anytime return without running
instead running one must continually make decision stop
keep going
deciding stop easy task utility solution depends
cost time needed one hand stopping early reduce
amount computation time expense costly solution
hand continues may reduce solution cost enough
justify extra computation time case final utility worse would
stopped earlier little extra information however
possible create reasonable policy
near optimal response time nora shekhar dutta provides
one simple stopping policy optimizing goal achievement time nora simply stops
anytime current search time user specified factor current
incumbent solutions execution time shekhar dutta prove search
stops time factor incumbent solution cost goal achievement
time within factor min optimal goal achievement time
use nora slightly different shekhar dutta
apply nora anytime heuristic search instead evaluated empirically
database query optimization tree search every leaf
node possible solution describe one could use nora search
make assumption stopped early without reaching goal
heuristic procedure used achieve goal executing partial
solution found procedure often available nora
anytime heuristic search incumbent solution guaranteed reach
goal disadvantage anytime stopping policies cannot
better best solution found utility oblivious anytime
nora finds solution within specified bound optimal goal achievement time
instead hansen zilberstein present dynamic programming technique
building optimal stopping policy utility function requires one extra piece
information profile anytime hansen zilberstein define
profile probability distribution cost solution returned
conditioned current solution cost additional time given improve


fiheuristic search time matters

solution p qj qi qj qi two possible solution costs
additional time profile allows reasoning solution cost may decrease
given time improve requires extra knowledge
performed small experiment shown found optimal policy found
dynamic programming performs better simpler nora technique
hansen zilbersteins technique monitors progress anytime
evaluating stopping policy discrete time intervals considers stopping
every time units utility achievable time current
solution costs qi

u qi
stop

v qi max p
p
q
q

v
q





continue

j
j
j
stopping policy

qi argmax




u qi
stop
p
p
q
q

v
q





continue
j
j
j



u user specified utility function p profile anytime
sophisticated technique accounts cost evaluating
policy however presented cost evaluating policy
consists mere array lookup essentially free
since profile anytime usually known must estimated
possible estimate profile line one access representative set training instances estimate profile run training
instances dimensional histogram created represent conditional probability distribution p qj qi needed compute stopping policy cf equation
appendix c gives detailed description implementation procedure
anytime heuristic search
anytime general class many anytime
heuristic search likhachev gordon thrun hansen zhou richter
thayer ruml van den berg shah huang goldberg thayer benton
helmert use anytime repairing ara likhachev et al
since tended give best performance approaches according experiments
done thayer ruml ara executes series weighted searches
smaller weight previous since weight bounds solution cost
looser bounds early iterations tend costly solutions quickly time passes
weight decreases solution cost eventually converging optimal ara
special handling duplicates encountered search enables
efficient still guaranteeing bound solutions
anytime heuristic search ara parameters running
ara user must select weight schedule typically comprised initial
weight amount decrement weight solution found
behavior ara varies different weight schedules experiments used
initial weight decrement schedule used likhachev


fiburns ruml




h
b





h


h
c



e

figure small example graph
et al found gave best performance compared several
alternative schedules domains considered
given fixed weight schedule anytime heuristic search emit fixed
stream solutions given instance take users
utility function account solutions found regardless whether
user wants solution fast possible optimal solution costs figure
shows small concrete example goal path node node e
node labelled heuristic value h number nodes remaining
goal edges labelled costs user wants optimal
solution would ideally return path b c e however user
wants solution fast possible may better solution e
fewer nodes may found fewer expansions ara considers cost
distance initial weight less longer cheaper solution
found regardless users preference monitoring technique select
best solutions found
contract search
dionne thayer ruml consider contract search goal
must returned hard deadline unlike real time search korf
agents next action must ready deadline contract search requires
return complete path goal optimizing utility function contract search must
aware cost solutions amount time required
conventional approaches contract search use anytime dionne et al
present deadline aware search das considers search time directly
basic idea behind das consider states lead solutions deemed
reachable within deadline two different estimates used determine set
nodes estimate maximum length solution path search explore
deadline arrives called dmax estimate distance solution beneath


fiheuristic search time matters

search node open list words states dmax deemed
reachable states pruned search expands non pruned nodes best first
order f g h updating dmax estimates line updates cause
remaining nodes pruned remaining time deadline das uses
recovery mechanism repopulate open list set pruned nodes continues
searching deadline reached
mentioned previously estimates readily available normal cost go heuristics h domains leaves question estimate dmax dionne et al
simply remaining number possible expansions computed via
expansion rate remaining time appropriate due phenomenon
call search vacillation best first search expands nodes typically expand straight single solution path instead considers multiple solution paths
time expanding nodes said vacillating
many different paths may return work particular path
performed many expansions along others account vacillation dionne et al
introduce metric called expansion delay estimates number additional expansions performed search expansion two successive nodes along single

texp
path define dmax rem
delay trem time remaining deadline
texp average expansion rate delay average expansion delay compute
average expansion delay averaging difference total expansion
count node expanded generated
dionne et al showed experimentally das performs favorably anytimebased approaches alternative contract search indicating
directly considers search time may beneficial utility function optimization

line bound selection
turn first two methods introduced
section present simple technique trading search time
solution cost bounded suboptimal search recall bounded suboptimal
search return solutions guaranteed within user specified factor
optimal solution cost practice applications require actual bound instead
bound used practitioners parameter tweaked speed search
finding solutions quickly enough fact bound trade search time
solution cost makes prime candidate automatic parameter tuning rice
exactly propose
anytime methods discussed previous section line bound selection requires representative set training instances instances used gather
information bounded suboptimal search trades search time solution
cost requirement user select set diverse bounds try
parameters search run n training instances suboptimality bound creating list n pairs bound
sols b h c cn tn b bound passed parameter
ci cost solution ith training instance ti time ith
solution found given utility function u cost time r select bound


fiburns ruml

gives greatest expected utility training set


x

bound u argmax

u c
sols b
b



c sols b

experiments select different weight use utility function
set may possible reduce number weights
training set linear interpolation estimate performance parameters
used training simple extended select
portfolio different addition different bounds may beneficial
example include speedy search portfolio
likely selected cheap solutions required solution must found quickly
see section simple technique outperforms ara anytime
monitor experimental evaluation fact representative set training instances
available technique tends perform better
evaluate
related technique dove tailing method valenzano sturtevant schaeffer buro
kishimoto presented way side stepping need
parameter tuning running parameter settings simultaneously found
dove tailing weighted ida korf able return first solution much faster
dove tailing greatly reduced high variance solving times given weight
found dove tailing different operator orderings effective ida
main difference work valenzano et al quite
different goals concern first solution quickly rather select
setting better optimizes user specified utility function
run multiple settings time instead selects single parameter run
single search fact approaches complementary given utility aware
parameters one could use dove tailing avoid need perform
offline parameter selection

best first utility guided search
anytime search aware utility monitoring bound selection require training
section present bugsy utility aware search require
line training
expansion order
bugsy best first search instead ordering open list f bugsy
orders open list estimate utility outcome resulting node
expansion since utility dependent time mere passage time affects utility
values differs traditional search values used order
expansions remain constant recall however linear utility function
utility values decay exact rate given bugsy ignores past time
bugsy acronym best first utility guided searchyes



fiheuristic search time matters

compares utility estimates assuming time begins current decision point
utility values match utility ultimate outcome still
preserve relative order different choices agent make
understand bugsys ordering function first consider best utility
outcome resulting node expansion computed oracle foreknowledge maximum utility outcome purpose search would
achieve expanding nodes along path initial node order build
solution path since utility function given linear combination solution cost
search time utility value outcome written terms cost
length possibly empty maximum utility outcome
u wf g wt texp



g cost path recall cost empty path user specified
constant number nodes texp time required expand node
given maximum utility value u best utility outcome resulting
expanding node n

u
n leads maximum utility outcome


u n

u wt texp otherwise
words utility get expanding node leads maximum utility
outcome maximum utility expanding node simply waste time
utility maximum utility minus cost performing unnecessary expansion
practice know maximum utility must rely estimates bugsy
uses two estimates approximate maximum utility first estimates cost
solution beneath node f note f estimate
heuristic estimate true cost go cheapest
solution beneath node may solution greatest utility see appendix
possible alternatives second estimates number expansions required
solution beneath node n exp n one crude estimate remaining expansions
distance heuristic estimates remaining nodes solution path reality
bugsy experience search vacillation discussed earlier expanding nodes
along single solution path account vacillation use expansion
delay technique dionne et al estimate exp n delay n
expect remaining n steps goal require delay expansions
bugsy choose expand node stop return empty solution
one way bugsy differs bugsy decides among actions search
level terminating search expanding one many open nodes whereas
committed expanding nodes fixed order bugsy node open
list represents possible outcome bugsys maximum utility estimated
maximum utility estimates open nodes equation


u max max wf f n wt n delay texp u

nopen

note expansion time constant general includes time add remove elements
data structures open list



fiburns ruml

bugsy initial u
open initial closed


n remove node open highest u n value

n goal return

add n closed

ns children c

c goal u c old version c open closed

skip c

else add c open

expansion count power two

compute u n nodes open list recent estimates

heapify open list
loop step
figure pseudo code bugsy
estimate u found would possible substitute u equation
estimate u n utility outcome expanding node open list
however bugsy going expand one node need estimate u n
open node bugsy simply expands node best estimated outcome
additionally instead computing maximization equation scratch time
expand node bugsy simply orders open list u n wf f n wt
n delay texp iteration popping node maximum u n expansion
way directly attempts maximize utility
recall figure shows two paths initial node goal node e
bugsy accounts distance utility function shorter path
e utility function sufficiently emphasizes finding solutions quickly finding
cheaper solutions hand utility function gives preference finding
cheap solutions bugsy spend extra search time cheaper path
b c e
implementation
figure shows high level pseudo code bugsy clarity code elides details
computing u n values proceeds selecting open node
highest u n expansion line node goal returned solution
line otherwise node put closed list line children generated
child put onto open list line except duplicate nodes nodes
expansion estimated negative utility occurs utility returning
solution greater continuing search discarded lines
bugsy estimates current expansion time expansion delay online
estimates change expansion instead sorting open list
expansion bugsy sorts whenever number nodes expanded power


fiheuristic search time matters

two utility open node computed latest set estimates
texp expansion delay described section open list heapified
lines describe sorting step greater detail section
stopping
bugsy orders open list decreasing order u n stops searching maximum estimated utility less returning empty solution may
possible continue searching anytime fashion first goal found
utility perspective correct prove
theorem assuming expansion time texp constant h admissible exp never
overestimates expansions go time bugsy finds first solution
solutions bugsy would beneath remaining nodes would less utility
immediately returning
proof let current time bugsy found solution utility returning
u u wf f wt u utility returning
f cost solution note h admissible goal h
g g f f therefore u u exp never overestimates
expansions go exp since chosen expansion u n u every
node n open list
let n minimum amount additional time bugsy requires solution
beneath unexpanded node n n texp since bugsy must least expand n
node n open list best utility bugsy could achieve going straight
cheapest goal n
u n wf f n wt n

wf f n wt n since f n f n due admissibility h

wf f n wt exp n texp since exp never overestimates

u n definition u n

u since u u chosen expansion n

justifies bugsys strategy returning first goal node selects expansion
noted bugsys estimate exp n delay n lower bound
see later sections stopping criterion performs quite well practice
heuristic corrections
many best first search use admissible heuristic estimates never overestimate
true cost go proof optimality proofs bounded suboptimality
bounded suboptimal search rely crucially admissibility property
heuristic bugsy fixate cost optimal solutions guarantee bounded
cost instead bugsy attempts optimize utility function solution cost
one two terms since strict cost guarantees bugsy free drop
admissibility requirement informed inadmissible estimates available


fiburns ruml

thayer dionne ruml inadmissible estimates provide better
performance bounded suboptimal search one technique attempts correct
heuristic estimates line average single step error heuristic values
node best child thayer et al technique provides good
search guidance actually less accurate estimating true cost go values
standard admissible heuristics bugsy undesirable need
good guidance proper estimates thayer et al learning heuristic
line linear regression provide accurate estimates unfortunately
line training would negate one bugsys main benefits matter empirical
evaluation whether techniques provide better performance bugsy
section standard admissible heuristics often gives best
performance anyway
resorting
instead requiring line training previous approaches bugsy uses line
estimates order nodes open list first many analyses regard texp
constant practice depend log time heaps cache behavior multiprogramming overhead among factors implementation bugsy estimates texp
global average computed search second bugsys expansion delay estimate
calculated global average difference expansion count node
generated expanded must done line unfortunately
line estimates may change node expansion navely latest estimates
compute u value newly generated nodes lead poor performance
due comparisons used order open list instead fair comparisons
estimated utility node recent fresh estimates nodes
compared old possibly stale estimates nodes open
long time
alleviate implementation bugsy uses two sets estimates
one stable set used order open list one ever changing set maintaining
recent estimates certain points throughout search bugsy copies upto date estimates stable set recomputes utility values open nodes
sorts open list open list implemented binary heap establish
heap property linear time number elements heap unfortunately
would still expensive every node expansion instead bugsy reorders
open list exponentially less frequently search progressesit reorders
number expansions power two prove logarithmic scheme
adds constant amount overhead per expansion amortized entire search
theorem search space grows geometrically finite branching factor
overhead reordering open list power two expansions constant expansion amortized search
proof let b maximum branching factor maximum number nodes
open list n expansions n n bn n n b total cost


fiheuristic search time matters

sorting n expansions
lg n

x


lg n


n

x


b definition n
lg n

c b

x

c definition


lg n

c b

identity

c b lg n

pj




j

c b n

n


overhead per expansion constant amortized expansions
matter empirical evaluation determine constant overhead detrimentalwe
address section

experimental evaluation
techniques discussed involve approximations estimations may may
work well practice section present experimental comparison
techniques better understand performance
domains implemented c source code available https github com
eaburns search
overview
following sections answer several questions experimentally first would
ensure monitored ara performing best comparing
profile learned line oracle see line profile
estimate true profile quite well informed
section proved sorting adds constant overhead per expansion
amortized entire search matter empirical evaluation determine
whether benefits outweigh overhead experiments sorting
logarithmic schedule greatly outperforms bugsy without sorting
section pointed bugsy require admissible heuristic estimates
fact may perform better inadmissible accurate heuristics
bugsy performs admissible heuristics two different types corrected
heuristics overall conclude best configuration bugsy standard
admissible heuristics
discussed expansion delay section demonstrate
expansion delay better simply estimate expansions
goal compare two variants bugsy one ignores newly generated nodes
found already closed list call duplicate nodes one
reinserts nodes onto open list better utility estimates


fiburns ruml

previously closed version ignoring duplicates performs better domains
others performs better preference short search times
compare speedy search monitored ara weighted learned
weight bugsy simplest learning good weight
weighted gives best performance bugsy doesnt use
line training performs well monitored ara use line
training therefore training instances available recommend simple weighted
weight selected performance training set
training instances available bugsy choice
lastly compare bugsy real time search dta platform pathfinding domain experiments bugsy achieves best utility
domains
order verify hold variety different performed
experiments four different domains domains used described briefly
following paragraphs detailed descriptions given appendix b
puzzle
puzzle popular heuristic search benchmark small branching factor
duplicates domain used reasonably informed manhattan distance
heuristic implementation followed heavily optimized solver presented burns
hatem leighton ruml ran instances created korf
plots including use instances solvable gb
memory
pancake
pancake another standard puzzle large constant branching factor
experiments used instances pancakes gap heuristic helmert
since many difficult used ida instead
domain
platform pathfinding
platform domain pathfinding domain creation dynamics
dimensional platform style video game player must jump platforms
traverse maze video games often naturally element time pressure
large state space many cycles reasonably informed heuristic
visibility navigation instances used experiments created randomly
generator described appendix b domain particular interest
action costs given units time action ms objective minimizing
goal achievement time expressed linear combination search time solution
cost


fiheuristic search time matters

grid pathfinding
grid pathfinding popular heuristic search benchmark motivated robotics video
games experiments used two different cost two different movement
cost standard unit cost model life cost model
assigns action costs shortest direct path expensive longer
circuitous path captures popular adage time money instances
grids uniformly distributed obstacles heuristics
manhattan distance heuristic four way grids octile distance heuristic eightway grids octile distance heuristic simple modification manhattan
distance

multiplies shorter horizontal vertical displacement accounts
eight way move costs
anytime profile accuracy
want ensure implementation works well training instance sets
representative enough monitored ara perform best subsection
evaluate accuracy stopping policies created estimated anytime profiles
comparing oracle since stopping policy guaranteed optimal
true profile matter empirical study determine whether
estimated profile lead good policy
estimate profile used monitored version ara ran ara
gb memory limit convergence separate test instances domain
next created histogram discretizing costs times solutions
bins experimented different utility functions varying
ratio wf wt equation small values wf wt give preference finding solutions
quickly whereas large values prefer finding cheaper solutions case platform
game example viewed way change speed agent
moves slow agent might benefit search order shorter path
fast agent execute path quickly may prefer feasible solution fast
possible
figure shows experiment box plots represent distribution
utility values found ara estimated stopping policy given factor
oracles utility oracle finds solutions anytime converges
optimal solution picks solution would maximized utility
function since utility values negative larger factors represent smaller negative utilities thus worse outcome boxes surround second third quartiles
whiskers extend extremes circles values
inter quartile range outside box center line box shows median
gray rectangles confidence interval means box represents
different wf wt shown x axis reference line drawn across
point oracle estimated policy performed equally well many cases
boxes narrow indistinguishable line
points figures lie slightly line indicating instances
oracle performed worse estimated policy possible due
variance solving times experiment ara runs used compute oracles


fiburns ruml

platform
factor oracle

factor oracle

puzzle



e

e e e
cost time preference







e

e
e
e
cost time preference

way unit grids

pancake
factor oracle



factor oracle












e

e e e
cost time preference



e

e e e
cost time preference

way unit grids



way life grids
factor oracle

factor oracle










e

e e e
cost time preference



e

e e e
cost time preference



way life grids
factor oracle





e

e e e
cost time preference



figure comparison optimal stopping policy learned stopping policy


puzzle












log cost time preference










log cost time preference



















log cost time preference



log cost time preference



way life grids
log factor best utility







log cost time preference

resort
resort



way life grids
log factor best utility

way unit grids
log factor best utility

way unit grids

platform


log factor best utility



log factor best utility

log factor best utility

heuristic search time matters










log cost time preference



figure bugsy resorting open list circles vs boxes
utilities occasionally found solutions slowly ara runs estimated
stopping policy words caused non determinism inherent utility
function depends solving time obvious figure instances quite
rare usually happened small values wf wt miniscule time differences
large effect utility
conclude monitored ara implementation performs
quite well stopping policy often stopped best solution available
emitted underlying anytime
resort resort
section proved sorting bugsys open list power two expansions
added constant overhead per expansion amortized search matter
empirical evaluation determine whether overhead worth effort
sorting schedules possible tried sorting power two expansions
figure shows utility achieved bugsy without sorting
x axes wf wt ratio determining preference solution cost search time
log scale previous plots smaller values indicate preference faster
search times larger values indicate preference cheaper solutions axes
factor utility achieved best technique instance log
scale value log indicates best utility achieved technique given


fiburns ruml

instance values greater zero indicate less utility points mean value
test instances error bars giving confidence intervals plots
see sorting open list led significant improvements domains
pancake puzzle bugsy without sorting unable solve instances within
gb memory limit remaining experiments enable sorting
exponential schedule
heuristic corrections
section mentioned bugsy require admissible heuristic estimates
provides guarantees solution cost section compare bugsy
standard admissible heuristics bugsy line line corrected heuristics
following thayer et al line heuristic correction used global average
single step heuristic error node best offspring line heuristic
linear combination h g depth node coefficients term
line heuristic learned solving set training linear
least squares regression
comparison shown figure plots style figure typically line correction technique performed worstsome times significantly worse
two attribute poor accuracy observed thayer et al
puzzle way unit cost grid pathfinding line correction technique performed best general simple admissible
heuristics best competitive best remainder experiments chose use simplest variant without corrections require
line training one bugsys main benefits never worst
often best near best
expansion delay
section described simply approximation exp n number
nodes expanded arrive goal beneath node n inaccurate search
expand nodes along path goal instead vacillates
different solutions account search vacillation choose estimate exp n
delay n delay average expansion delaythe average number nodes
expanded search makes progress along single path goal subsection
experimentally expansion delay provides much better performance
alone
figure shows two versions bugsy one uses expansion delay labelled
exp delay one labelled without exp delay clear
figure expansion delay beneficial see right side
plots cheaper solutions preferred short search times expansion delay
wf relatively large compared
wt utility functions exp n term little influence utility estimates


fiheuristic search time matters

puzzle



log factor best utility

log factor best utility



log factor best utility

pancake

platform
online
none
offline














log factor best utility

log factor best utility















log cost time preference
way life grids

log factor best utility

way life grids
log factor best utility







log cost time preference










log cost time preference
way unit grids









log cost time preference

way unit grids










log cost time preference












log cost time preference





log cost time preference

figure bugsy heuristic corrections

duplicate dropping
suboptimal search expand nodes strict order increasing f consequently expand node later generate node via cheaper path
call generations duplicates generated via cheaper paths
say inconsistent current path cost subsequently cost
paths descendants expensive necessary likhachev et al
face inconsistent nodes search put already expanded
node back open list cost accounts cheaper path
node comes front open list expanded inconsistency


fiburns ruml

platform





pancake



log factor best utility

log factor best utility

log factor best utility

puzzle














log cost time preference









log cost time preference

without exp delay
exp delay

log factor best utility

log factor best utility















log cost time preference



way unit grids














log cost time preference









log cost time preference

way life grids



way life grids



log factor best utility

log factor best utility





way unit grids

























log cost time preference





log cost time preference

figure bugsy expansion delay
propagate descendants unfortunately lot
inconsistencies search spend lot time expanding
nodes alternative technique simply ignore inconsistency
drop duplicate nodes generated dropping duplicates reduce
search effort needed goal cost finding expensive solutions whether
dropping duplicates beneficial typically depends domain thayer ruml

figure shows comparison bugsy without duplicate dropping
platform tiles pancake domains duplicate dropping nearly better
expanding duplicates grid pathfinding notable excep

fiheuristic search time matters







pancake
log factor best utility

platform
log factor best utility

log factor best utility

puzzle


















log cost time preference










log cost time preference

duplicate reexpansion
duplicate dropping



























log cost time preference









log cost time preference



way life grids
log factor best utility

way life grids
log factor best utility



log cost time preference

way unit grids
log factor best utility

log factor best utility

way unit grids
























log cost time preference





log cost time preference

figure bugsy duplicate dropping

tion way life cost gridsre expanding duplicate nodes seems give better performance
except solutions needed quickly possible left hand side plots
reasonable duplicate dropping tends sacrifice solution cost order
reduce search time note values axes plots small
statistically significant difference two techniques
grid duplicate expansion performs better quite small next
section see actually achieves utility many cases
duplicate expansion outperforms duplicate dropping


fiburns ruml

platform

log factor best utility

log factor best utility

puzzle











log cost time preference







log cost time preference



log factor best utility

pancake

pee
ugsy











log cost time preference



figure comparison techniques

comparing techniques
understand promising configurations techniques studying finally turn attention comparing
figures comparison three different techniques utility aware
search plots larger previous plots improve clarity
lines plots include speedy search bugsy ara monitoring
ara weighted weight chosen automatically different utility
function set wa would expect
preference shorter search times left end x axis performed poorly
stubbornly stuck optimal solutions speedy search however performed quite well
preference shifted toward desiring cheaper solutions began better whereas
speedy worse utility aware techniques much robust


fiheuristic search time matters

way unit grids
log factor best utility

log factor best utility

way unit grids












log cost time preference







log factor best utility

way life grids

log factor best utility

way life grids



log cost time preference








log cost time preference







log cost time preference



figure comparison techniques continued
speedy neither take users preference search time solution cost
account
utility aware techniques bugsy weighted automatically
selected weight performed best bugsy better puzzle
platform domain grid bugsy weighted roughly
performance right side x axes left side bugsy tended get worse
relative utility aware techniques ara anytime monitor often
best performer however ara performed significantly worse middle
right hand portion plot domains leading us recommend weighted
technique simpler robust
utility aware techniques often performed well low cost solutions
preferred fast solutions preferred techniques sometimes outperformed
speedy search likely indicates solution cost still played roll final utility


fiburns ruml

log factor best utility

orz








bugsy

ara





log cost time preference
wa

speedy

figure grid pathfinding video game map
left points plots ara tended achieve greater utility
bugsy solutions needed quickly cheaper solutions preferred
bugsy tended better ara domains ara spike low utility
ratios peak appearing life cost
grids peak approximately coincides utility functions estimated
profile performed worse oracle shown figure possibly indicating
training instances required utility functions
overall utility aware techniques able achieve much greater utility
utility oblivious speedy terribly surprising surprisingly
suggest simple parameter tuning technique often give best
performance representative set training instances available bugsy
choice performs well require line training
indeed putting reasoning search time search bugsy
competitive techniques requiring previous experience
limitations
previous set experiments saw utility aware outperformed
speedy search wide range utility functions section look
one domain tends case video game grid maps
video games one main motivations grid pathfinding
sturtevant observed grid maps created game designers often exhibit
different properties maps generated algorithmically figure shows comparison
bugsy monitored ara weighted automatically selected weight speedy


fiheuristic search time matters

figure grid pathfinding video game map







speedy time



time

execution time



speedy time

speedy nodes

nodes expanded











instance













instance









instance



figure nodes expanded search time execution time
dragon age origins map orz benchmark set sturtevant
map shown figure fairly wide open area top closed
bottom half containing rooms hallways format plot figure
previous subsection see gave best performance
large range utility functions bugsy actually never outperformed speedy
entire experiment neither ara wa gave best performance
single data point hypothesized bugsys poor performance
easy solve bugsys extra computation overhead small
prominent
explore hypothesis plotted performance bugsy given difference
speedy single utility function given wf wt


fiburns ruml

left utility function figure function speedy search performed
best bugsy performed poorly figure shows number nodes expanded
time spent executing time spent searching bugsyas percentages
equivalent values speedy search data points gathered random sample
instances sturtevants scenario set orz map values
line represent instances bugsy expanded fewer nodes spent less
time searching executing values line represent instances bugsy
expanded nodes spent time speedy x axes shows rank
instances sample increasing order optimal solution lengths
see figure bugsy expanded number nodes
similar execution times speedy larger optimal solution
costs bugsy slightly less execution time major difference performance
two however shown right plot see bugsy
required search time speedy search almost every instance since bugsy
speedy expanded number nodes additional time must due
bugsys small amount extra overhead incurred sorting computing utility
conclude barring extra overhead bugsy would performed well
best performer utility function domains node expansion heuristic
computation isnt simplistic overhead would insignificant
training set homogeneity
section showed weighted outperformed techniques
domains notable exception platform domain puzzle
bugsy best additionally compared domains weighted technique
performed relatively poorly video game pathfinding cf figure wa outperformed utility oblivious approaches points except one believe
poor performance wa domains due heterogeneous training sets
verify looked mean standard deviation optimal path lengths
domains optimal path length viewed proxy
difficulty high standard deviation statistic points diverse
set instancessome easy solve quite difficult platform
video game path finding domains standard deviation optimal path length
greater mean twice domains note
domains video game map variety layout different areas map
means instances inherently differ characteristicsmerely gathering
instances produce homogeneous set evidence supports hypothesis
weighted performance greatly hindered situations representative
training set available
real time search
main focus study line searchthey entire paths
goal execution begins real time search korf search execution
happen parallel agent allowed fixed amount time plan
must perform action real time search possibility efficient


fiheuristic search time matters

line search terms goal achievement time search happens
parallel execution goal achievement time simply execution time plus
small amount time required first action contrast line
goal achievement time sum entire search time execution
time situations however starting execution complete plan
goal acceptable may lead agent dead end longer
reach goal real time search may applicable examples domains deadends include robotics manufacturing ruml zhou fromherz spacecraft
control exactly applications involving high value danger automation
worthwhile cases desirable entire plan guaranteed reach
goal execution begins
hernandez baier uras koenig introduce model comparing real time
line techniques called game time model game time
model partitions time uniform intervals agent execute single action
interval path happen parallel execution agent
plan step execution step goal move agent start
location goal location time intervals possible minimizing goal achievement
time objective discuss section game time model special
case utility functions considered solution cost given discrete
fixed duration units time
real time search provides two benefits first may possible reduce goal
achievement time allowing search execution happen time second
agent start moving toward goal right awaya necessary property video games
leaves us question whether real time search achieve
better goal achievement time line utility aware methods one hand realtime search spend little time searching without making progress toward
goal hand real time search tend make decisions
local information costly solutions hernandez et al
report best solves initially known grid maps
number time intervals previous section showed utilityaware techniques outperformed utility functions section compare
state art real time search called lss lrta koenig sun
bugsy platform pathfinding domain
previous experiments tested variety values
ratio wf wt since interested goal achievement time set wt
calculate search time units seconds means wf represents number
seconds one unit execution costthe speed agent set real time
constraint lss lrta allowed plan duration one unit
execution next action ready execution currently
executing action completed
compare time bounded tba bjornsson bulitko sturtevant method
performed best hernandez et al platform domain forms directed search
graph tba works undirected search graphs compare newer
f lrta sturtevant perform well lss lrta platform domain
directed edges



fiburns ruml

platform
log factor best gat



lss lrta

speedy
bugsy












log w f w





figure comparison bugsy real time search
figure shows comparison see lss lrta gives rather
poor performance goal achievement times nearly match bugsy able
achieve goal much faster shows simply allowing search execution
take place parallel sufficient reduce goal achievement time better
spend time searching solution way goal alternative spend
long time executing poor plan
decision theoretic
decision theoretic dta russell ericwefald utility aware
allows concurrent search execution ideas real time heuristic
search unlike traditional real time search action emitted fixed
amount search dta decides stop searching emit action decisiontheoretic analysis time single best top level action lowest cost
estimate search emits action decided utility emitting
action outweighs utility search dta uses approximation found
line training solution cost estimate top level action improves
additional search consistent heuristic estimate increase nilsson
dta stops searching decides time required raise best
actions estimated cost point longer best action costly
expected gain determining different best action
compared bugsy dta relatively myopic considers cost
search involved selecting individual actions dta consider additional search
required solution path commits choosing action bugsy
uses expansion delay reason required search effort entire


fiheuristic search time matters

log factor best utility

platform small instances
speedy

dta
bugsy














log w f w





figure comparison bugsy dta
path beneath node dta reasons search required determine best
action emit right
implemented dta assess utility aware real time search might compare
utility aware line search time pressure figure shows
comparison dta bugsy platform pathfinding domain
unfortunately dta fairly poor performance experiment used smaller instances
consisting x blocks instead x block instances used previous experiments
following russell ericwefald gathered line training data dta
states sampled uniformly probability among visited real time
search russell ericwefald used called slrta
used lss lrta current state art training set consisted
x platform instances verified implementation ensuring
compared favorably speedy search puzzlethe domain used
russell ericwefaldusing variety different utility functions figure
see dta often significantly worse utility bugsy often performing
slightly better speedy search sometimes performing worse example
cheap solutions desired

related work
bugsy uses estimates search time select whether terminate continue select node expand may said engaging metareasoning
reasoning reasoning action take much work
topic ai since late dean boddy continuing today cox raja



fiburns ruml

dean boddy consider faced agent trying respond
predicted events time constraints unlike setting concern
choosing much time allocate prediction much allocate deliberation solve type time dependent suggest use
coined term anytime unlike anytime techniques discussed
previously attempt stopping policy optimize utility function dean
boddy used anytime means allowing different allocations time
predicting deliberation later boddy dean anytime
time dependent framework used delivery agent
must traverse set waypoints grid allocating time ordering
waypoints used travel dean kaelbling kirman
nicholson adapt technique scheduling deliberation execution
face uncertainty
garvey lesser present design time methods advocate available time best possible solution unlike anytime approaches interrupted time design time method requires time deadline given
upfront way spend time focusing finding single
good solution instead possibly wasting time finding intermediate design time
differs contract techniques das dionne et al designto time framework must predefined set solvers known predictable
solution times costs design time method select appropriate solver
deadline possibly interleaving different solvers deemed appropriate
information cost solutions times design time methods require usually unavailable must learned line techniques das bugsy
hand use information computed line
hansen zilberstein danilchenko heuristic search inadmissible
heuristics used make anytime heuristic search techniques
presented consider trading search effort solution
quality end propose one possible optimization function anytime heuristic
search search attempts maximize rate decreases solution
cost anytime monitoring technique shown section evaluation function
relies learning profile anytime offline analysis puzzle conclude method good anytime behavior little
benefit instead trial error hand tuning surprising given
strong performance demonstrated offline tuned weighted experiments
recently thayer et al proposed minimizing time solutions anytime demonstrate state art
performs well wide variety domains robust
previous approaches bugsy technique relies heuristics estimate
search effort required solutions however focus solutions
require least amount effort optimize trade search time
solution cost
addition controlling expansion decisions metareasoning used
heuristic evaluation often search use maximum value computed
multiple heuristics accurate estimate cost goal


fiheuristic search time matters

domain independent heuristics quite expensive increased accuracy
gained via maximizing many heuristics may worth increased computation
time domshlak karpas markovitch introduce line learning technique
decide single heuristic compute state instead computing many
taking max
related work metareasoning control combinatorial search done
area constraint satisfaction csps boolean satisfiability sat tolpin
shimony use rational metareasoning decide compute value ordering
heuristics csp solver focus work value ordering heuristics
gave solution count estimates solver bothered compute heuristic decision
points deemed worthwhile experiments demonstrate
metareasoning variant outperformed variant computed heuristic
one computed heuristic randomly horvitz ruan gomes kautz selman
chickering apply bayesian structure learning csps sat
consider quasi group completion unlike tolpin shimony
use line metareasoning control search use line bayesian learning set
hand selected variables predict whether instances long short running
lot work attempting estimate size search trees offline burns ruml knuth chen kilby slaney thiebaux walsh
korf reid edelkamp zohavi felner burch holte
related topic concerned estimating search effort entire search
performed one may imagine leveraging technique predict search time
bugsy unfortunately estimation methods rather costly
terms computation time suitable estimator needed every
single node generation another possibility use line estimations parameters
affect performance search given domain knowledge could helpful
creating representative training sets used weighted anytime
monitoring require line training

conclusions
investigated utility aware search take account user specified
preference trading search time solution cost presented three different techniques
addressing first method previous work area
learning stopping policies anytime best knowledge
first demonstrate techniques area heuristic search second method
novel use selection bounded suboptimal search chooses correct
weight use weighted given utility function last technique
presented bugsy bugsy technique three
require line training
performed empirical study techniques context heuristic search
investigated effect parameters performance compared
different techniques surprisingly simplest technique learning
weight weighted able achieve greatest utility many outperforming conventional anytime monitoring surprisingly bugsy


fiburns ruml

use line training performed well line
techniques advantage learning thousands line training instances
representative set training instances available bugsy
choice overall utility aware methods outperformed speedy search
wide range utility functions demonstrates heuristic search longer
restricted solely optimizing solution cost freeing user choice slow
search times expensive solutions
unlike previous methods trading deliberation time solution quality bugsy considers trade directly search algorithmdeciding node whether
expansion worth time provides alternative anytime instead returning stream solutions relying external
process decide additional search effort longer justified search process
makes judgments node evaluations available empirical
demonstrate bugsy provides simple effective way solve shortest path
computation time matters would suggest search procedures
usefully thought black boxes controlled external termination policy
complete intelligent agents informed users goals acting rationally
basis information collect directly maximize users utility

acknowledgments
greatly appreciate feedback suggestions shlomo zilberstein scott kiesel
would think richard korf pointing work shekhar dutta
grateful support nsf grant grant
darpa cssg program grant ap university hampshire
dissertation year fellowship preliminary version bugsy presented ruml
see appendix elisabeth crawford assisted original version
summer internship parc

appendix previous bugsy
previous version bugsy proposed ruml however early
realization differs substantially one presented used aggressive duplicate
expansion heuristic corrections used estimate remaining expansions
goal reached section showed duplicate dropping outperforms duplicate expansion many domains found inadmissible heuristics performed
poorly cf section practice even compared standard admissible estimates temper inadmissible corrected estimates previous bugsy
multiplied heuristic estimates arbitrary weight min wt wf version require ad hoc fix discussed poor estimate number
remaining expansions section section showed experimentally
expansion delay performs much better alone
recall bugsy uses f approximate cost path length best
utility outcome enabled expansion node note however f
function used throughout refer cheapest solution beneath node n


fiheuristic search time matters

may goal maximum utility better assess available
outcomes previous version bugsy computed two utility estimates node one
cheapest solution beneath node nearest solution terms
node expansions non unit cost domains two estimates may differ example
life cost grid pathfinding domains cheapest solution usually involves moving toward
top grid actions cheap nearest solution follow straight line
path goal general large number different solutions
search node solutions may cover whole spectrum different cost time trade offs
considering cheapest solution done implementation
may possible solutions better utility hand may
costly compute multiple heuristics node whether modification
beneficial depends domain

appendix b domains
performed experiments variety different domains describe
detail
b puzzle
puzzle one popular benchmark domains heuristic search
consists frame tiles placed one slot board
contain tile called blank tiles left right
blank may slid blank slot objective puzzle slide tiles
around order transform initially scrambled puzzle goal state blank
upper left corner tiles ordered going left right top bottom
domain interesting plans hard branching factor small
varies little mean korf et al duplicates
heuristic reasonably informed
experiments use popular puzzle instances created korf
plots include however used instances solvable gb
memory average optimal solution length instances training
set generated instances million step random walk back goal
position used manhattan distance heuristic sums vertical horizontal
distance tile must move arrive goal position implementation follows
heavily optimized solver presented burns et al
b pancake puzzle
pancake puzzle dweighter gates papadimitriou another permutation
puzzle consists stack differently sized pancakes numbered n pancakes
must presented fancy breakfast chef needs sort originally unordered
stack pancakes continually sticking spatula stack reversing order
pancakes said another way pancake involves sorting sequence
numbers prefix reversal operations simple interesting
creates search graph large branching factor number pancakes minus one


fiburns ruml

figure screenshot platform pathfinding domain left zoomed image
single instance right knight must path starting
location maze door right side left image
center right image

experiments used randomly generated pancake puzzle instances
training set consisted randomly generated instances used powerful gap
heuristic helmert sums number pairs adjacent pancakes
sequence
b platform pathfinding
platform domain pathfinding domain creation dynamics
dimensional platform style video game written partially first author called
mid left image figure shows screenshot mid goal knight
traverse maze initial location jumping platform platform
reaches door mid open source game available http code google com p
mid game experiments game physics game ported c c
embedded c search codebase generated training instances
test instances level generator mid example instance shown
right panel figure domain unit cost large state space
well informed heuristic
available actions different combinations controller keys may pressed
single iteration games main loop left right jump left right move
knight respective directions holding time never considered
search domain movements would cancel leaving knight
author steve mccoy drew tile graphics shown figure



fiheuristic search time matters

place jump button makes knight jump applicable knight jump
different heights holding jump button across multiple actions row
maximum actions unit cost cost entire solution number
game loop iterations called frames required execute path frame corresponds
ms game play
state state space contains x position knight doubleprecision floating point values velocity direction x velocity stored
determined solely left right actions number remaining actions
pressing jump button add additional height jump boolean stating
whether knight currently falling knight moves speed units per
frame horizontal direction jumps speed units per frame simulate
gravity falling units per frame added knights downward velocity
maximum units per frame
details platform domain please refer source code repository
given start section
b level generator
instances used experiments created level generator mid
special maze generator builds dimensional platform mazes grid blocks
block open occluded ensure solvability given constraints imposed
limited jump height generator builds maze stitching together pieces
hand created portfolio piece consists number blocks free
occluded start end location traversability ensured within piece
piece added grid location fits piece fits
occlude block belongs previously placed piece maze built depthfirst procedure piece selected random fits grid start location
lined end location predecessor placed procedure recurs
number successors node chosen uniformly range inclusive
procedure backtracks pieces fit previous block
maze constructed blocks belong piece marked occluded
right image figure shows sample level generated procedure source
code level generator available mid source repository mentioned
b heuristic
developed heuristic platform domain visibility navigation
nilsson maze pre processed convert grid representation set
polygons representing connected component occluded cells level space
scaled account movement speed knight knight fall faster
move horizontal direction polygons end squished vertically
stretched horizontally visibility navigation solved reverse
four corners goal cell center every non occluded cell maze
maintain admissibility cost edge visibility length


visibility line instead maximum length line divided
x displacements end points line accounts fact


fiburns ruml

figure visibility navigation instance platform domains heuristic visibility path initial state goal state drawn red

knight bemoving horizontally vertically time
moving distance scaled space still takes single frame
search heuristic value state computed one two different ways
straight line path center knight goal occluded
maximum x distances goal scaled travel speed used
heuristic estimate otherwise heuristic cost path visibility graph
center cell contains knights center point minus maximum
x distance number frames knights center point center
cell figure shows map right image figure scaled broken
polygon components visibility path initial state goal
state drawn red
b grid pathfinding
final domain grid pathfinding popular domain video games
robotics garnered much attention heuristic search community
experiments used x grids four way eight way connectivity
uniform obstacle distributions four way connected grids cell blocked
probability eight way connected grids cells blocked
probability consider two different cost standard
unit cost model
horizontal vertical moves cost diagonal moves cost
called life cost model move cost equal row number
move took place causing cells toward top grid preferred
life cost model short direct solutions found quickly however relatively
expensive least cost solution involves many annoying economizing steps ruml
model viewed instantiation popular belief time
money one choose incur additional cost shorter simpler path
combination movement model cost model generated test instances
training instances finally used manhattan distance heuristic four connected
grids octile distance heuristic eight connected grids life cost model


fiheuristic search time matters

heuristics took account fact moving toward top grid back
may cheaper direct path

appendix c anytime policy estimation
challenging write rely line training data
behaves unexpectedly unclear bug implementation bug
line learning procedure training set merely insufficiently representative
appendix describe implemented verified procedure estimating
anytime profile
figure shows pseudocode building profile description given
hansen zilberstein accepts set solution streams
input one stream solved instance proceeds two steps first step
count solutions function counts number times solution cost
improved upon function iterates solution line computes bin
histogram cost value falls line subsequent solution count
added qqtcounts time step first solution improved second
solution addition number total improvements solution time bin
counted qtcounts array costbin timebin functions bin cost time values
respectively returning integer corresponding index histogram


q qmin
costbin q
qmax qmin ncost


tmin
timebin
tmax tmin ntime

second step probabilities function converts counts computed
first step normalized probability values achieved dividing number
steps solution cost qi improved solution cost qj qqtcounts
total number steps solution cost qi improved qtcounts
lines probability values smoothed adding half smallest probability
bin representing solution cost improvement step removes zero probabilities
allowing improvement considered finally probabilities normalized
probability non decreasing cost solutions current cost time step sum
one lines profile computed saved disk later use
computing stopping policy
found extremely useful simple way validate policies
debugging implementation one option create stopping policy run ara
monitoring handful instances handful utility functions verify
gives expected behavior unfortunately rather cumbersome
prone error evaluated policy small number instances
willing run hand instead chose validate implementation plotting
polices generated training data different utility functions plotting
extreme policies care solution cost search time along
intermediate policies trade two much simpler debug code


fiburns ruml

profile streams
qtcounts qqtcounts count solutions streams
return probabilities qtcounts qqtcounts
count solutions streams
qtcounts int ncost ntime initialized zero
qqtcounts int ncost ncost ntime initialized zero
streams



qi costbin cost

qcur qi tcur

count cost time increment solution

j

qnext costbin j cost

tnext timebin j time time

current solution cost time solution j

tcur tnext

increment qtcounts qi

increment qqtcounts qcur qi

qcur qnext tcur tnext

last solution cost final time

tcur ntime

increment qtcounts qi

increment qqtcounts qcur qi
return qtcounts qqtcounts
probabilities qtcounts qqtcounts
probs float ncost ncost ntime
qi ncost

ntime

qtcounts qi continue

qj ncost

probs qj qi qqtcounts qj qi qtcounts qi
smoothing add half smallest probability elements probs improving solution cost
normalize
qi ncost

ntime

sum

qj ncost

sum sum probs qj qi

qj ncost

probs qj qi probs qj qi sum
return probs

figure pseudocode profile estimation

figure shows plots created platform domain plot cost
axis time x axis green circles represent inputs policy
says keep searching red crosses represent inputs policy says stop


fiheuristic search time matters



b











cost



cost

cost



c





time



time











time

figure three different policies prefers cheaper solutions expense wf
wt b attempts trade search time solution cost wf
wt c prefers solution fast possible wf wt


searching return solution expected policy continues goal
minimize solution cost stops goal minimize search time cf
left right plots figure respectively center plot shows
successfully found policies trade search time solution cost stopping
cost sufficiently low finally left plot bottom rightmost sides policy stop implementation chose stop
training data available estimate profile given input values

references
bjornsson bulitko v sturtevant n tba time bounded proceedings
twenty first international joint conference artificial intelligence ijcai pp
boddy dean solving time dependent proceedings
eleventh international joint conference artificial intelligence ijcai
vol pp
burns e hatem leighton j ruml w implementing fast heuristic
search code proceedings fifth annual symposium combinatorial search
socs
burns e ruml w iterative deepening search line tree size prediction
annals mathematics artificial intelligence
chen p c heuristic sampling method predicting performance tree
searching programs siam journal computing
cox raja metareasoning thinking thinking mit press


fiburns ruml

dean boddy analysis time dependent proceedings
seventh national conference artificial intelligence aaai pp
dean kaelbling l p kirman j nicholson deadlines
stochastic domains proceedings eleventh national conference artificial
intelligence vol p washington dc
dechter r pearl j optimality kanal l kumar v eds
search artificial intelligence pp springer verlag
dionne j thayer j ruml w deadline aware search line measures behavior proceedings fourth annual symposium combinatorial
search socs
domshlak c karpas e markovitch max max online learning
speeding optimal aaai conference artificial intelligence
aaai pp
dweighter h elementary e american mathematical monthly

finkelstein l markovitch optimal schedules monitoring anytime artificial intelligence
garvey j lesser v r design time real time scheduling systems man
cybernetics ieee transactions
gates w h papadimitriou c h bounds sorting prefix reversal discrete
mathematics
hansen e zhou r anytime heuristic search journal artificial intelligence

hansen e zilberstein monitoring control anytime
dynamic programming artificial intelligence
hansen e zilberstein danilchenko v anytime heuristic search first
tech rep university massachusetts amherst
hart p e nilsson n j raphael b formal basis heuristic determination minimum cost paths ieee transactions systems science cybernetics
ssc
helmert landmark heuristics pancake proceedings
third symposium combinatorial search socs
helmert roger g good almost perfect proceedings
twenty third aaai conference artificial intelligence aaai
hernandez c baier j uras koenig time bounded adaptive
proceedings eleventh international joint conference autonomous agents
multiagent systems aamas
horvitz e ruan gomes c kautz h selman b chickering
bayesian tackling hard computational proceetings
seventeenth conference uncertainty artificial intelligence uai


fiheuristic search time matters

kilby p slaney j thiebaux walsh estimating search tree size
proceedings twenty first national conference artificial intelligence aaai
knuth e estimating efficiency backtrack programs mathematics
computation
koenig sun x comparing real time incremental heuristic search
real time situated agents autonomous agents multi agent systems

korf r e iterative deepening optimal admissible tree search proceedings ninth international joint conference artificial intelligence pp

korf r e real time heuristic search artificial intelligence
korf r e reid edelkamp time complexity iterative deepening
artificial intelligence
likhachev gordon g thrun ara anytime provable bounds
sub optimality advances neural information processing systems nips

michie ross r experiments adaptive graph traverser machine
intelligence pp
nilsson n j mobile automaton application artificial intelligence techniques proceedings first international joint conference artificial intelligence ijcai pp
nilsson n j principles artificial intelligence tioga publishing co
pohl heuristic search viewed path finding graph artificial intelligence

rice j r selection advances computers
richter thayer j ruml w joy forgetting faster anytime search
via restarting proceedings twentieth international conference automated
scheduling icaps pp
ruml w zhou r fromherz p line scheduling
application controlling modular printers journal artificial intelligence

ruml w b best first utility guided search proceedings th
international joint conference artificial intelligence ijcai pp
russell ericwefald right thing studies limited rationality
mit press
shekhar dutta minimizing response times real time
search proceedings eleventh international joint conference artificial
intelligence ijcai pp citeseer


fiburns ruml

sturtevant n benchmarks grid pathfinding transactions computational intelligence ai games
sturtevant n r distance learning agent centered heuristic search proceedings
fourth annual symposium combinatorial search socs
thayer j faster optimal suboptimal heuristic search ph thesis university
hampshire
thayer j benton j helmert better parameter free anytime search
minimizing time solutions proceedings fifth annual symposium
combinatorial search socs
thayer j dionne ruml w learning inadmissible heuristics
search proceedings twenty first international conference automated
scheduling icaps
thayer j ruml w faster weighted optimistic
bounded suboptimal search proceedings eighteenth international conference
automated scheduling icaps
thayer j ruml w distance estimates heuristic search proceedings nineteenth international conference automated scheduling icaps
thayer j ruml w anytime heuristic search frameworks
proceedings third annual symposium combinatorial search socs
tolpin shimony e rational deployment csp heuristics proceedings twenty second international joint conference artificial intelligence
ijcai
valenzano r sturtevant n schaeffer j buro k kishimoto simultaneously searching multiple settings alternative parameter tuning
suboptimal single agent search proceedings twentieth international conference automated scheduling icaps
van den berg j shah r huang goldberg k ana anytime nonparametric proceedings twenty fifth aaai conference artificial intelligence
aaai
zohavi u felner burch n holte r predicting performance ida
conditional distributions journal artificial intelligence





