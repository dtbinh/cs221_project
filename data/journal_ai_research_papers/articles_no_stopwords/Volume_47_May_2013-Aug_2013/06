journal artificial intelligence

submitted published

refined view causal graphs component sizes
sp closed graph classes beyond
christer backstrom
peter jonsson

christer backstrom liu se
peter jonsson liu se

department computer science
linkoping university
se linkoping sweden

abstract
causal graph instance important tool
practice theory theoretical studies causal graphs largely analysed
computational complexity instances causal graph certain
structure often combination parameters domain size variables
chen gimenez ignored even structure considered size weakly
connected components proved tractable components
bounded constant otherwise intractable intractability however
conditioned assumption parameterised complexity theory known
useful relationship standard complexity classes
perspective standard complexity classes prove np hard
classes unbounded components additional restriction refer spclosed argue np hardness theorems causal graphs difficult
apply thus prove general even component sizes grow slowly
class densely populated graphs still cannot tractable unless
polynomial hierachy collapses still hold restricted class
acyclic causal graphs finally give partial characterization borderline
np hard np intermediate classes giving insight

introduction
first briefly explain causal graph give short survey applications
well theoretical reported literature following give overview
presented article
background
causal graph instance explicit description variable dependencies implicitly defined operators precisely directed graph
arc variable x another variable x appears
precondition operator effect operator effects x
standard definition causal graph traced back knoblock
although give name used causal graph alpine
guidance partitioning ordering variables process automatically
deriving state abstraction hierarchies actual name causal graph traced back
williams nayak general restricted
c

ai access foundation rights reserved

fibackstrom jonsson

knoblocks one hand generalized concept binary variables
multi valued variables hand considered acyclic causal graphs
implies operators unary e every operator changes one variable
context work reactive planner burton onboard space ship control
causal model compiled transition system could efficiently exploited
reactive controller choose appropriate operators achieve given goals compilation
done way operators unary claimed often
possible real applications resulting acyclicity causal graph exploited
burton traversed graph bottom order issue operators order
consistent causal relationships
jonsson backstrom b studied acyclic causal graphs referred
dependency graphs considered subclass graphs particular structure used implicitly define corresponding class instances
class class property possible decide polynomial time
solution solutions may exponential length thus
necessarily taking exponential time generate although one single restricted case
class probably first example relating structural properties causal graph
computational complexity general extensive analysis
done domshlak dinitz analysed complexity
classes instances corresponding number different possible structures acyclic
causal graphs however work done context multi agent coordination
term causal graph never used
first two papers may viewed early examples exploiting causal
graph practice latter papers form starting point subsequent theoretical relationships complexity structure
causal graphs
important step forward usage causal graphs helmert
demonstrated causal graph particularly useful context
multi valued variables previous complexity multi valued
variables focussed structure domain transition graphs variables
jonsson backstrom rather causal graph helmert realized power
domain transition graphs causal graph heuristic
exploited practice highly succesful fast downward planner helmert
translates pddl instances binary variables representation
multi valued variables removes carefully chosen edges resulting causal
graph make acyclic resulting causal graph used compute heuristic
hierarchically computing composing plan lengths subgraphs one
particular structures studied domshlak dinitz somewhat similarly katz
domshlak identified subgraphs causal graph certain structures
make tractable exploited able use larger variables
sets constructing pattern databases example exploiting causal graph
make efficient factored brafman domshlak
showed structure causal graph used guide
deciding instance solved efficiently dividing
loosely coupled subinstances use constraint processing basic idea causal


fia refined view causal graphs component sizes

graph represent variable dependencies course quite general necessarily
restricted instance wehrle helmert transferred causal
graph concept context model checking
previously mentioned two papers jonsson backstrom b
domshlak dinitz viewed starting point successful line
studying relationships complexity structure
causal graph class jonsson backstrom limited
special case domshlak dinitz studied classes instances corresponding
number general graph structures stars aka inverted forks stars aka
forks directed path graphs aka directed chain graphs polytrees singly connected
dags followed instance articles brafman domshlak
gimenez jonsson latter article additionally showed although
instances exponential length plans possible generate macro representation
plan polynomial time extended classes defined
structure causal graph many complexity papers use
additional numerical parameters conjunction graph structure examples
parameters maximum domain size variables maximum degree
graph increasing number possible cases analyse allow
fine grained analysis many cases consider instance case directed path
graphs domshlak dinitz proved tractable decide
plan case domains binary gimenez jonsson proved
domain size sufficient make np hard similarly gimenez
jonsson proved tractability instances binary variables constant
number prevail conditions causal graph polytree
brafman domshlak fits line theoretical exhibiting
runs time exponential two parameters tree width
undirected version causal graph maximum number times variable must
change value
standard definition causal graphs
set already knoblock although often generalisation multi valued variables
important exceptions one potential standard defintion
whenever two variables affected operator causal graph must
necessarily contain cycles major reason focus mainly
unary operators attempt circumvent jonsson
defined relaxed variant causal graph introduce cycles
non unary operators sometimes allow fine grained complexity analysis
previous relate structure causal graph complexity satisficing e deciding plan corresponding branch
relating structure causal graph complexity cost optimal
cf katz domshlak katz keyder
contributions
theoretical studies complexity structure causal graph possibly parameters domain sizes important


fibackstrom jonsson

milestone deviates line article chen gimenez
even consider structure causal graph simple quantitative measure size weakly connected components proved deciding
plan done polynomial time size weakly connected components causal graph bounded constant one sense
sharp final however intractability unbounded components
conditional assumtion w nu fpt assumption relies theory
parameterised complexity theory neither complexity classes assumption
related ordinary complexity classes clear way chen gimenez acknowledge prove conditionally intractable include np intermediate
hence take take point investigation
component sizes reflect standard complexity classes since know chen
gimenez graph classes unbounded components np hard must
consider restrictions order np hard classes adding
type closure property sp closure incomparable subset closure subset minor closure prove np hard sp closed graph class
unbounded components noted still holds class
acyclic graphs important considering practical relevance acyclicity
previously mentioned
many graph classes studied literature indeed sp closed
exists natural classes lack property present one way handling
classes aid non uniform complexity theory case able
np hardness polynomial hierarchy collapses second
level fairly general applied even component sizes grow
slowly graph class densely populated graphs
holds even restricted acyclic graphs used demonstrate clearly
complexity class causal graphs necessarily connection complexity generic
class causal graphs raises question preferably natural np intermediate chen gimenez state np intermediate
obtained methods similiar ones employed bodirsky
grohe hard describe natural though
ladners diagonalization technique removes large fraction input strings
apparently difficult connect graph classes constructed technique
simple conditions component growth alternative graph classes
component sizes grow polylogarithmically np intermediate double
assumption w nu fpt exponential time hypothesis impagliazzo
paturi holds every k exists class gk graphs
component size bounded v g k g gk corresponding
np hard coarsely stake borderline
np hard np intermediate classes
possible conclusion complexity analysis
structure causal graph limited value additional parameters
needed achieve useful may fair conclusion general
cases graph structure sufficient instance katz hoffmann domsh

fia refined view causal graphs component sizes

lak applied chen gimenez context called
red black variant delete relaxation computing heuristics furthermore
even structure causal graph combined parameters
still important know behaviour parameter isolation
remainder article structured follows section set notation
terminology used graphs section define causal graphs
structural general section contains number np hardness
special graph classes need main first two main
theorems article appears section define concept sp closed graph
classes prove np hard classes component size
unbounded section discusses previous theorem
similar literature way around second main
theorem shows even without closure requirements likely hard
even components grow slowly graphs appear densely class
section contains observations concerning borderline np intermediate
np hard article ends discussion section

preliminaries
section sets terminology notation graphs used article
write x denote cardinality set x length sequence x e
number elements x write x denote size representation
object x

since article many connections one chen gimenez
follow notation terminology plannning notational variant sas
backstrom nebel
instance tuple v init goal whose components
defined follows
v finite set variables variable v v associated finite domain
v note variables necessarily propositional v may
finite set state mapping defined variables v v v
v v partial state mapping p defined subset vars p variables v
v vars p holds p v v p otherwise undefined
init state called initial state
goal partial state
set operators operator consists precondition pre
postcondition post partial states often use notation
hpre posti define operator precondition pre postcondition post
instance hx z defines operator applicable
state x effect setting variable
z


fibackstrom jonsson

state partial state w subset variable set v write
w denote partial state resulting restricting w say state
goal state goal vars goal
define plan instance sequence operators p
starting state define state resulting applying plan p denoted
p inductively follows empty plan p define non empty
plans p define p follows last operator p p prefix
p including
pre p vars pre preconditions satisfied
state p p p
otherwise p state equal post variables v vars post
equal p variables v v vars post
plan p solution plan init p goal state
concerned computational plan existence planexist given
instance v init goal decide exists solution plan
graphs
directed graph pair v e v vertex set e v v edge set
undirected graph pair v e v vertex set e u v u v v
edge set often say graph edge clear context whether
directed undirected notation v g refers vertex set graph g
e g refers edge set e u v e u v edge vertices u
v incident e furthermore directed edge u v outgoing edge u
incoming edge v directed graph g v e write u g denote
correspsonding undirected graph u g v eu eu u v u v e
u g undirected graph induced g ignoring orientation edges
let g v e directed graph let v vk v v vk
distinct vi vi e k sequence v vk directed
path length k g v vk directed cycle length k g v vk paths
cycles undirected graphs defined analogously except direction
consider graph acyclic contains cycles
let g v e directed graph let v v vertex v isolated
incoming outgoing edges v source least one outgoing edge
incoming edge v sink least one incoming edge outgoing edge
otherwise v intermediate
let g vg eg h vh eh two directed graphs g h
isomorphic denoted g h exists bijective function f vg vh
u v eg f u f v eh furthermore h subgraph g vh vg
eh eg vh vh eh eg vh vh say subgraph h
induced vertex set vh isomorphisms subgraphs analogously defined
undirected graphs
let g undirected graph g connected path every
pair vertices g connected component g maximal subgraph g


fia refined view causal graphs component sizes

connected let g directed graph g weakly connected u g connected
weakly connected component g maximal subgraph g weakly connected
weakly connected component paths every pair vertices
ignore direction edges let g vg eg h vh eh two directed
graphs vg vh disjoint disjoint union g h defined
g h vg vh eg eh commutative operation note graph g
consists weakly connected components g gn g g g gn
define numeric graph parameters directed graph g vertex
v v g indegree v u v g u v e g e number incoming
edges incident v outdegree v u v g v u e g e number
outgoing edges incident v undirected graph g degree v v g
u v g v u e g e number edges incident v extend
graphs follows g undirected graph deg g denotes largest degree
vertex v g similarly g directed graph deg g denotes largest
indegree vertex v g deg g denotes largest outdegree vertex
v g furthermore g undirected graph path length g denotes length
longest path g cc size g denotes size largest connected component
g g directed graph path length g denotes length longest directed path
g define upath length g path length u g cc size g cc size u g
upath length g length longest path g ignoring direction
edges cc size g size largest weakly connected component g note
g undirected connected graph path length g equals diameter g
extend numeric graph properties deg path length etc sets graphs
c set graphs prop graph property prop c maxgc prop g
special graph types
literature causal graphs well article certain types graphs
particular interest thus useful refer names distinguish
following types undirected graphs tree undirected graph two
vertices connected exactly one path e acyclic connected path graph
tree vertices degree e tree branch star
graph tree vertices except one centre vertex degree
directed graphs distinguish following types star graph directed
graph g u g star graph edges directed towards centre
star graph directed graph g u g star graph edges
directed centre directed path graph directed graph g u g
path graph deg g deg g e g directed path
vertices contains edges polytree directed graph g u g
tree e g weakly connected directed graph constructed tree
giving unique direction every edge polypath directed graph g u g
path graph e g weakly connected directed graph constructed
path graph giving unique direction every edge fence polypath every
vertex source sink e edges alternate direction every vertex


fibackstrom jonsson

noted star graph usually called directed star graph
graph theory star graph appears standard name hence deviate
sligthly standard terminology order logical names graph types
polypath appears standard name polypath logical term
analogy polytree noted parallel terminology certain
graph types evolved literature causal graphs instance instars stars directed paths commonly referred inverted forks forks
directed chains respectively
note number sinks sources polypath differ one e
polypath sinks c sources c furthermore every fence
polypath every polypath fence
define following graphs graphs classes
skin denotes star graph one centre vertex k sources define
class sin skin k
skout denotes star one centre vertex k sinks define class
sout skout k
dpk denotes directed path k vertices define class dp dpk k
c c denotes fence sinks c sources define
fm
c c class f f f f
class fc fm

examples graph types illustrated figure

v
v

v
v

vc
v

v

v

v

vc
v

v

v

v

v

v
u

v
u

f

v

v




v

dp

v
u

v
u

v
u

v
u

f

v
u

v
u

u

f

figure examples important graph types
following observation polypaths used later
proposition let g polypath sinks sources
path length g k v g mk


fia refined view causal graphs component sizes

proof distinct paths source sink
k intermediate vertices hence v g k mk
bound obviously tight case sinks sources
every path source sink contains exactly k intermediate vertices

structurally restricted
topic study article causal graphs discussing
concept first define concept domain transition graphs jonsson backstrom
although used explicitly useful explaining
proofs later article let v init goal instance
variable v v define domain transition graph dtg v directed graph
v e x v e contains edge x operator
post v pre v x v vars pre
causal graph instance describes variables instance
depends implicitly defined operators
definition causal graph instance v init goal directed
graph cg v e e contains edge u v every pair distinct vertices u v v u vars pre vars post v vars post
operator
causal graph gives information operators instance
causal graph acyclic operators must unary e vars post
operators since non unary operator must necessarily introduce cycle according
definition however presence cycles necessarily mean
non unary operators instance edges u v v u present
graph mean operator u vars post
v vars post however mean two operators
u vars pre v vars post v vars pre u vars post could
thus unary operators similarly degree vertices provides upper bound
number pre postconditions operators lower bound suppose
vertex u indegree incoming edges v u w u could mean
operator u vars post v vars pre
w vars pre however mean two different operators
v vars pre u vars post w vars pre u vars post
planexist extended instances causal graphs
following way class c directed graphs planexist c deciding
arbitrary instance cg c whether solution
complexity planexist c refers complexity set
instances whose causal graphs members c
number literature computational complexity
classes causal graphs however usually assume
graph class restricted structure e g containing stars directed
paths general abstract following theorem


fibackstrom jonsson

theorem chen gimenez thm let c class directed graphs
cc size c bounded planexist c solvable polynomial time cc size c
unbounded planexist c polynomial time solvable unless w nu fpt
theorem describes crisp borderline tractable intractable graph
classes assumption w nu fpt complexity
classes theory parameterised complexity cannot immediately related
usual complexity classes scope article treat parameterised
complexity refer reader standard textbooks downey fellows flum
grohe theorem parameterised however
condition parameterised suffices note intractability holds
condition difficult relate common assumptions p np
one reasons chen gimenez forced state theorem way
classification polynomial np hard classes would exhaustive
since graph classes np intermediate np intermediate
neither p np complete unless p np
theorem might viewed starting point reported
article investigate perspective standard complexity
classes instance np hardness proved case unbounded components
adding restrictions section

basic constructions
section presents necessary theorems later article
first three np hard stars aka inverted forks stars
aka forks directed paths aka directed chains known literature
np hardness fences however provide proofs
star star cases major reason section need refer
reductions certain precisely known properties furthermore original proofs
published technical report domshlak dinitz b may thus hard
access
lemma domshlak dinitz thm iv planexist sin np hard
holds even restricted operators preconditions postcondition
proof proof proof reduction sat class instances
causal graphs sin reduction constructs instance source
causal graph corresponds one variables formula centre corresponds
clauses construction illustrated figure formally defined follows
let f c cm arbitrary sat formula variables x xn clauses
c cm construct corresponding instance f v init goal follows
v vc v vn
vc
vi u f n
condition simplified w fpt class c recursively enumerable



fia refined view causal graphs component sizes

vc







u


u


u

f
v



f
v

f
vn

figure star causal graph dtgs construction proof
lemma

init vi u n init vc
goal vc goal otherwise undefined
consists following operators
n contains operators
set f hvi u vi f
set hvi u vi ti
clause ci j j k
ji xk ji xk let contain operator
verify clause pos j hvc vk vc ii ji xk
operator
verify clause neg j hvc vk f vc ii ji xk
clearly instance f constructed polynomial time cg f snin
remains prove f solution f satisfiable
source variable vi changed independently starts undefined
value u set f corresponding true false respectively
corresponding variable xi f set f cannot changed
variables v vn used choose commit truth assignment
x xn centre variable vc one value clause ci f plus initial
value possible reach goal value inital value stepping


fibackstrom jonsson

intermediate values numerical order step
three operators choose corresponding literals clause ci step
possible one v vn set value consistent one literals ci
goal vc achieved variables v vn set values
corresponding truth assignment x xn satisfies f
restricted case respect pre post conditions immediate
construction
known tractable though domain size centre variable
bounded constant katz domshlak furthermore causal graph heuristic
helmert identifying star subgraphs causal graph
noted provided variant original proof due minor technical
differences formulations
lemma domshlak dinitz thm iii planexist sout np hard
holds even restricted operators precondition postcondition
proof proof proof reduction sat class instances
causal graphs sout reduction constructs instance centre vertex
causal graph corresponds variables formula sink corresponds
one clauses construction illustrated figure formally defined
follows
v

u

v

vm



u



u







tn

f

f

f

fn



vc

figure star causal graph dtgs construction proof
lemma

let f c cm arbitrary sat formula variables x xn clauses
c cm construct corresponding instance f v init goal follows


fia refined view causal graphs component sizes

v vc v vm
vc f fn tn
vi u
init vi u init vc f
goal vi goal vc undefined
consists following operators
n contains operators
step c hvc vc
step c ti hvc vc ti
step c ti hvc ti vc
step c ti ti hvc ti vc ti
clause ci j j k
ji xk ji xk let contain operator
verify clause pos j hvc tk vi si ji xk
operator
verify clause neg j hvc fk vi si ji xk
clearly instance f constructed polynomial time cg f snout
remains prove f solution f satisfiable
variable vc changed independently two values ti
variable xi f corresponding possible truth values xi addition
initial value f dummy value order simplify formal definition
values tn fn reachable initial value f plan correspond
path f z z zn zi ti vc must pass value
ti hence path correspond truth assignment
variables x xn f clause ci f corresponding variable
vi change value initial value u unsatisfied goal value satisfied
vi three operators one literal ci ci contains
literal xk xk vi change value u vc value tk fk
hence goal v vm achieved path vc
corresponds truth assignment x xn satisfies f note though
vc must follow path way fn tn since partial assignment may
sometimes sufficient prove satisfiability
restricted case respect pre post conditions immediate
construction
known tractable though domain size centre variable
bounded constant katz keyder
following directed path causal graphs known
literature
lemma gimenez jonsson prop planexist dp np hard even
variables domain size operators preconditions postcondition


fibackstrom jonsson

refer gimenez jonsson proof however implicitly use
proof later article important observations make
reduction sat thus works reduction sat furthermore
reduction transforms formula n variables clauses instance
n variables final remark known tractable variables
domain size domshlak dinitz
three previous known literature following
best knowledge
lemma planexist f np hard holds even restricted operators
preconditions postcondition
proof proof reduction sat class instances causal graphs
f
reduction constructs instance sink causal graph corresponds one clauses formula source corresponds variables
furthermore source variables synchronized behaviour construction illustrated figure formally defined follows
let f c cm arbitrary sat formula variables x xn clauses
c cm construct corresponding instance f follows
v u um v vm
ui f fn tn
u tu tu f f ts ts
vi f u fm




init ui f init vi f u
goal vi goal otherwise undefined
let consist following operators
j n j contains operators
step x j huj uj
step x j ti huj uj ti
step x j ti huj ti uj
step x j ti ti huj ti uj ti
j n j contains operators
u
u f u hv f u u
step clause u j
j
j uj vj

u
u
u
u
step clause u j ti hvj uj ti uj ti vj ti
step clause u j tui fiu hvj tui uj uj vj fiu
step clause u j tui tui hvj tui uj ti uj ti vj tui
f hv f u

step clause j
j

j uj vj
ts hv f u

step clause j
j

j ti uj ti vj ti



step clause j ti hvj ti uj uj vj fis
step clause j tsi tsi hvj tsi uj ti uj ti vj tsi
j j contains operators
finalize clause f j hvj fns vj si
finalize clause j hvj tsn vj si


fia refined view causal graphs component sizes

vi

vi

vi
tu

tu

tu

tun

f u

f u

f u

fnu

x ci

x ci

ts

ts

ts

tsn

f

f

f

fns









tn







tn

f

f

f

fn

f

f

f

fn

ui

ui

figure fence causal graph dtgs construction proof
lemma example assumes clause ci contains literals x x

clause ci j j k
ji xk ji xk let contain operator
verify pos j hvi tuk vi tsk ji xk
operator
verify neg j hvi fku vi fks ji xk
hence
clearly instance f constructed polynomial time cg f fm
remains prove f solution f satisfiable
first consider variables ui vi construction domain
operators ui identical one vc proof lemma e
directed path value f fn tn every possible truth assignment variables
x xn f variable vi corresponds clause ci contains two copies dtg
ui values differ extra superscript u latter copy extended
additional value denoting clause satisfied operators
allows vi mimic behaviour ui follow corresponding path
two copies furthermore three literals ci operator



fibackstrom jonsson

makes possible move value zku value zks value zk ui consistent
ts order reach goal value
literal since vi starts f u must reach fm

necessary vi make transition one literals ci ui
follows path f z zn vi must follow path f u z u zku zks zns
k xk occurs literal ci zk satisfying truth value literal
consider variable ui since operator affects value vi
precondition ui ui precondition follows
ui ui must choose path vi reach goal since every variable vj
forces synchronization adjacent variables uj uj manner follows
u um must choose exactly path plan solution thus
follows argument ui vi goal v vm
achieved path u um choose
path corresponds satisfying truth assignment f
restriction first note immediate construction operators
preconditions postcondition sufficient see preconditions
sufficient consider following variation construction step clause u stepclause operator replaced two operators follows example consider
u tu first introduce extra value f tu v replace
operator step clause u j
j


operator two operators
u f tu hv f u u
u
step clause u j
j

j ti vj f ti
step clause u j f tui tui hvj f tui uj ti vj tui
u
consider step dtg vj
tui original construction
u tu requires u
done single operator step clause u j
j uj

u
value ti modified construction instead requires two steps first step
u
u
intermediate value f ti step value ti previous
conjunctive constraint uj uj ti replaced sequential constraint first
uj ti uj ti although technically possible uj moved
value second step taken matter uj uj must
still choose exactly path respective dtgs
corollary planexist f planexist f planexist f np hard
proof neither two outer source vertices u um necessary construction
previous proof hence omitting reduction works
f f finally planexist f np hard since f f
basic necessary main theorems following
two sections

graph classes closure properties
literature previous section classes
consisting particular graph type class sin stars class f
fences section depart instead study graph classes certain
closure properties first discuss standard concepts subgraph closure minor
closure finding first contain graphs need latter


fia refined view causal graphs component sizes

set many graphs reason define concept sp closure
incomparable subgraph closure subset minor closure
closure concept defines borderline non np hard graph classes
large number useful np hard classes
subgraph closure minor closure
suppose c class graphs closed taking subgraphs every graph
g c case every subgraph h g must c subgraph closure
sufficient purposes though instance subgraph polypath
polypath graph every weakly connected component polypath
however polypath need subgraphs fences trivial size
need closure property guarantees c contains polypath sinks
contains fence sinks obvious candidate concept
minor closure superset subgraph closure concepts graph minors
minor closure rapidly evolved important useful area
mathematical well computational graph theory lovasz mohar
order define graph minors first need concept edge contraction
commonly defined follows although definitions occur literature
definition let g v e directed graph let e u v e edge
u v contraction e g graph g v e
v v u v w
e f x f x e x u v x v u
w vertex v function f v v defined
f u f v w otherwise f x x
edge u v contracted two vertices u v replaced
single vertex w edges previously incident u v
redirected incident w figure shows example edge contraction say
graph h contraction another graph g h contracting zero
edges g
concept graph minors defined follows
definition directed graph h minor directed graph g h isomorphic
graph obtained zero edge contractions subgraph g
example illustrated figure graph g figure weakly connected
directed graph happens polypath vertex v removed g
restriction remaining vertices still weakly connected graph
subgraph g removing v graph h consists two weakly
connected components h h h h h subgraphs g
minors g since subgraph minor definition contracting edge v v
h graph w vertex replacing v v similarly
contracting edge v v h graph minor g since


fibackstrom jonsson

v

v
v

v

v
v

v
v

v

v

v

v

v

w

v

v

v

graph g

v

v

b contracting edge v v g

figure edge contraction

edge contraction subgraph h g graph analogously
minor g graph consisting two components
minor g since two contractions subgraph h g
graphs h h h subgraphs minors g graphs
minors g subgraphs

v
v
v

v
v

v
v

v
v

v

polypath

v

v
v

g

v

v
v

w

v


v
h

v
w


h

b subgraph h g
h h h

c minor g


figure subgraphs minors

trivial example minor closed class class graphs minor closed
since contains graphs every minor graph graph interestingly
many commonly studied graph types minor closed classes instance class
sin stars minor closed class sout stars class dp


fia refined view causal graphs component sizes

directed paths furthermore weakly connected minor polypath polypath
weakly connected minor polytree polytree illustration consider
figure graph g polypath weakly connected graphs h h
minors g polypaths fact fences
note though neither h polypath since consist one
weakly connected component worth noting however class f fences
minor closed although every fence polypath weakly connected minor fence
must polypath necessarily fence
requiring minor closed graph classes however overly strong instance would
sufficient require every graph g c every weakly connected minor g
c example figure would require h h
c g c would require h c
reasonable desirable context causal graphs causal graph
instance consists two weakly connected components components
correspond entirely independent subinstances solved separately
furthermore certain natural restrictions mix well minor closed classes
consider instance example figure acyclic graph g v e
v v v v v e v v v v v v v v contract edge
v v vertex w get cycle graph vertices w v v class
acyclic graphs minor closed general problematic considering importance acyclic causal graphs

v

v

v

v

v
w

acyclic graph g

v
b contraction v v g

figure contracting edge acyclic graph cycle

sp closed graph classes
order avoid acyclicity similar avoid defining
special variants contraction minor concepts instead identify set minimal
requirements closure must satisfy order imply np hardness planexist
focus one set restrictions defining concept refer
sp closure sp denotes set closed stars polypaths
definition let g h two directed graphs h sp graph g h
weakly connected following holds
h star subgraph g


fibackstrom jonsson

h star subgraph g
h obtained zero contractions polypath g g
subgraph g
class c graphs sp closed contains every sp graph every graph g c
sp closure number interesting properties including following
proposition let g h directed graphs let c class directed graphs
g polypath every sp graph g polypath
every sp graph g acyclic
h sp graph g h minor g
c minor closed c sp closed
proof suppose g polypath obviously g cannot contain star star
higher degree two star polypath hence need
consider third case definition note weakly connected subgraph g
g must polypath contractions polypath polypath
immediate since stars stars polypaths acyclic contracting edges
cannot introduce cycle cases
immediate definitions minors sp graphs
immediate
proposition says makes sense talk sp closed classes polypaths
sp closed classes acyclic graphs says sp closure minor closure
comparable concepts sp closure class subset minor closure
class
prove following sp closed classes polypaths
need main theorem
lemma let c sp closed class polypaths cc size c unbounded
planexist c np hard holds even restricted operators
preconditions postcondition
proof proof cases depending whether directed path length c bounded
case suppose path length c unbounded let n arbitrary integer
must graph g c g contains subgraph h directed
path graph v h n obviously h sp graph g since directed path
polypath follows h c since c sp closed furthermore h dpn
np hardness planexist c follows lemma since n choosen arbitrarily
case instead suppose path length c k constant k let n
arbitrary integer since graphs c polypaths cc size c unbounded
must polypath g c v g n thus follows assumption
proposition g must least sinks sources


fia refined view causal graphs component sizes

v g mk must thus subgraph g g polypath
exactly sinks sources e g weakly connected must thus

graph h obtained zero contractions g h fm
follows h c since c sp closed np hardness planexist c thus follows
lemma since n choosen arbitrarily k constant
see holds even operators consideration
preconditions postcondition simply note restriction holds reductions
used underlying np hardness proofs section
chen gimenez thm proved similar c class polypaths
unbounded components unbounded number sources planexist c
polynomial time solvable unless w nu fpt
order prove main section need moore bound biggs
p stated follows arbitrary connected undirected graph g
maximum number vertices
v g

k
x







deg g k path length g
prove additional restriction graph classes spclosed avoid np intermediate prove np hardness graph classes
unbounded components
theorem let c sp closed class directed graphs cc size c unbounded
planexist c np hard holds even restricted operators
preconditions postcondition graphs c acyclic
proof first suppose constant k deg c k deg c k
upath length c k consider arbitrary graph g c obviously deg u g k
path length u g k p
follows moore bound component u g

k k
k vertices however since cc size g cc size u g
g choosen arbitrarily follows cc size c bounded contradicts
assumption least one deg c deg c upath length c unbounded
remainder proof three possibly overlapping cases
case suppose deg c unbounded let n arbitrary integer
must graph g c containing vertex indegree n must
subgraph h g h snin hence h c since c sp closed thus
follows lemma planexist c np hard since n choosen arbitrarily
case suppose deg c unbounded case analogous previous
one lemma instead lemma
case suppose upath length c unbounded let n arbitrary integer
must graph g c u g contains path length n
must thus subgraph h g h polypath length n obviously h
chen gimenez use term source sink configuration polypath



fibackstrom jonsson

sp graph g zero contractions h c since c sp closed thus follows
lemma planexist c np hard since n choosen arbitrarily
see holds even operators consideration
preconditions postcondition simply note restriction holds reductions
used underlying np hardness proofs section similarly acyclicity restriction
holds since stars stars polypaths
acyclic graphs
theorem somewhat restricted one chen gimenez since
requires additional constraint c sp closed hand demonstrates
sp closure sufficient condition avoid graph classes planexist npintermediate thus sharpen np hardness noted though
exact characterization graph classes np hard planexist
graph classes sp closure captures large number interesting
graph classes instance class acyclic graphs sp closed recall class
minor closed although every subclass sp closed opposite example
non empty class contain single acyclic graph cannot sp closed

beyond sp closed graph classes
section divided three parts first discuss previous well
similar np hardness literature problematic motivates
us switch non uniform complexity theory second part contains number
preparatory required main theorem third part
np hardness enough
refer generic instances varying size depending
one parameters archetypical example blocks world natural
parameter number blocks particular encoding specified number
blocks variables operators whatever inital state goal
fix encoding get frame n vn every number
n blocks n instances n blocks thus function
n instances vn init goal n blocks instantiations n different
init goal components vn components instance thus
specified three unique parameters n init goal first parameter
n affects size instance furthermore causal graph instance depends
variables operators means instantiations frame n
causal graph denote cg n class causal graphs blocks
world instances cg cg cg although
thus differ depending encoding
often possible analyse complexity particular generic
examples complexity blocks world gupta nau
complexity international competitions ipc
helmert b context article though rather interested
complexity class causal graphs corresponding generic


fia refined view causal graphs component sizes

complexity specific suppose class causal graphs
happens subset class c graphs know planexist c
tractable infer planexist tractable thus
generic causal graphs tractable however order
prove planexist np hard hard complexity class would
prove class c graphs planexist c np hard c
subset finding class c may trivial though
one encoding large influence densely sparsely
causal graphs occur respect size consider instance blocks world encodings
multi valued variables boolean variables respectively typical encoding
multi valued variables use one variable status hand two variables
block one position block one flag whether block clear
encodings use n variables n block frame encoding
boolean variables hand typically represent block position
number boolean variables one block block boolean
encoding thus use n variables n block frame contain graph
every odd number vertices first case increasingly sparse second
case class causal graphs generic thus typically
sp closed even closed taking subsets furthermore since typically
contain member every possible number vertices cannot possibly contain
known np hard sets sin sout dp etc subset hence order prove
class causal graphs hard np complexity class often
necessary make dedicated proof often doable however generic
corresponding function f takes parameter value n e g
number blocks blocks world f n n f furthermore polynomialtime computable value n often case corresponding
causal graph cg n polynomial time computable however even done
many generic specific proof every specific encoding
every particular generic holds particular classes causal
graphs every specific class typically require dedicated proof
order get around able prove general
depend specific causal graphs switch nonuniform complexity makes possible prove powerful retaining
natural connections ordinary complexity classes basic vehicle proving nonuniform complexity advice taking turing machine defined follows
definition advice taking turing machine associated sequence advice
strings special advice tape advice function natural
numbers advice sequence n input x advice tape immediately
loaded x continues ordinary turing machine except
access advice written advice tape
exists polynomial p n p n n said use
polynomial advice complexity class p poly set decision
solved advice taking tm runs polynomial time polynomial advice


fibackstrom jonsson

note advice depends size input content need
even computable somewhat simplistically advice taking turing machine
machine infinite data base constant access time however input
size polynomial amount information might exponential
number instances sharing information power polynomial advice thus still
somewhat limited useful relationships known non uniform complexity
classes relate standard ones known one following
theorem karp lipton thm np p poly polynomial
hierarchy collapses second level
preparatory
carrying main theorem section need auxiliary
first instance causal graph g subgraph graph
h instance extended equivalent instance h causal graph
lemma let instance let g directed graph cg
subgraph g instance g
g constructed polynomial time
cg g g
g solution solution
furthermore g maximum number pre postconditions operators
one value zero
proof let v init goal instance let cg v e let
g vg eg directed graph cg subgraph g let u vg v
construct instance g vg initg goalg ag follows
dg u u u
dg v v v v value v
initg v init v v v
initg u u u
goalg v goal v v v
goalg u undefined u u
let ag consist following operators
let ag contain
edge x v eg e x vg v v let ag contain
operator star x v hx v
edge x u eg x vg u u let ag contain
operator set x u hx init x u


fia refined view causal graphs component sizes

obviously g constructed polynomial time cg g g remains
prove g solution solution
suppose p plan p plan g since goalg u
undefined u u ag contrary suppose p
plan g operator ai p three cases ai ai set
operator ai star operator case operator ai serves purpose since
modifies variable u undefined goal value case operator ai sets
variable v v effect variables goalg v undefined
ai serves purpose otherwise must operator aj j aj
change v value v e ai serves purpose case
follows operator sequence p obtained p removing operators
plan g furthermore since p contains operators
plan follows plan g plan
construction increases maximum domain size one little effect
maximum number pre postconditions suitable purpose since
consider influence domain sizes article constructions
possible want balance factors differently
proof forthcoming theorem opposite taking graph
minors starting minor g target graph h extend g h
order need operation similar opposite edge contraction
satisfied graph operation known edge subdivision
definition let g v e directed graph let u v e edge
u v subdivision u v g graph g v w e w
vertex e e u v u w w v
although one might consider definitions e g case u v
v u e one sufficient purpose follows usual extension
directed graphs cf kuhn osthus young usually operation called smoothing
considered inverse edge subdivision however smoothing viewed
restricted case edge contraction reasonable think edge subdivision sort
inverse edge contraction example edge subdivision illustrated figure
note edge contraction polypath polypath edge
subdivision polypath polypath
need operation instances corresponding edge subdivision
causal graphs purpose need concept variable substitution
operators denote substitution variable w variable v partial state
v w defined

x w
v
x
x vars v w
v w x

undefined otherwise
operator operator v w defined pre pre v w
post post v w


fibackstrom jonsson

v

v
v

v

v
v

v
v

v

v

v

v
v

graph g

v

v
v

w

v

v
v

v

b subdividing edge v v g

figure edge subdivision

necessary concepts modifying arbitrary instance
corresponds subdividing edge causal graph instance
however need instances causal graph polypath
proving done first need following lemma states
certain reordering property plans causal graph polypath choose
arbitrary vertex v polypath g remove v g g falls apart two weakly
connected components c c words vertices g partitioned
three sets c c c c v edge directly
vertex c vertex c follows definition causal graphs
operator changes variable c precondition variable
c vice versa following lemma utilises fact prove sequence
operators change variable v reordered operators
change variables c come operators change variables c
lemma let v init goal instance g cg
polypath let v arbitrary variable v let c v let c c v two
possibly empty weakly connected components g vertex v removed
g define ai vars post ci let p plan
let p p q operator sequences p p q p q contains operator
let q subsequence q containing operators let q
subsequence q containing operators p q q p plan

proof assume c c c defined lemma recall c v first
note g acyclic since polypath operators unary follows
partition thus let init p
obviously vars pre c vars post c q vars pre c
vars post c q e state holds c c
q c c q furthermore state holds


fia refined view causal graphs component sizes

v v q since follows q c q c
q c q c hence
q q c q c
q q c q c q c
q q c q c q c
q q q follows p q q p plan
prove instance cg polypath
subdivide edge cg create instance cg
subdivision cg solvable solvable
lemma let instance cg polypath let e
edge cg instance
constructed polynomial time
cg edge subdivision e cg
solution solution
proof let v init goal instance cg polypath
let e u v edge cg construct instance v init goal
follows
v v w w u w v
init v init v v v
init w init u
goal goal
let consist following groups operators
let contain operators u vars pre v vars post
let contain operator u w every operator
u vars pre v vars post
let contain operator copy u w x hu x w xi every value
x v
operators group original operators corresponding edges
cg except u v operators group operators corresponding
edge u v modified instead correspond edge w v operators
group correspond edge u w defined variable w
mimic variable u clearly polynomial time construction cg edge
subdivision cg remains prove plan plan
suppose p plan construct operator sequence p
p follows first ai p u vars pre ai v
vars post ai replace ai ai u w ai p u vars post ai


fibackstrom jonsson

let x post ai u add operator copy u w x ai ai resulting
sequence p plan
suppose p plan define corresponding state sequence
sn init si ai n without losing
generality assume p shortest plan implies ai applicable
si every n define three variable sets c c c lemma
c w v c u c define corrsponding partition
e ai vars post ci contains copy
operators nothing else proving main direction first prove
following auxiliary
according lemma assume every longest subsequence ak
contain operator form ak
ak since longest sequence must
hold k ak case sk init
sk u sk w since init u init w case operator ak copy u w x
x sk w sk u x hence sk u sk w x since ak
change u case sk u sk w furthermore
k holds si c c sk c c since ai follows
si u si w k every k w vars pre ai
ai must form u w v vars pre ai definition hence
ai follows si u si w since proof holds longest
subsequences containing operator conclude following
used
operator ai p ai u w holds
si u si w
prove main direction plan since
plan constructing plan p p two steps first construct
intermediate operator sequence p construct plan p p sequence
p technically plan intermediate step makes proof
clearer temporarily introduce virtual dummy operator dum precondition
postcondition e applicable state effect construct
operator sequence p b bn dum follows
ai bi ai
ai copy operator bi dum
otherwise ai u w operator let bi operator
define corresponding state sequence tn init ti b bi
n claim ti v si v n proof induction

basis definition
induction suppose ti v si v n three cases
ai bi ai w pre postcondition ai bi
bi applicable ti since ai applicable si ti v si v assumption
furthermore ti v ti bi v si ai v si v


fia refined view causal graphs component sizes

ai copy operator bi dum immediate definition bi
applicable ti ti ti furthermore vars post ai v
si v si v since ti v si v assumption thus follows ti v si v
ai bi u w bi follows si w si u si w
ti u since u v ti v si v assumption since ai applicable si
pre ai w pre bi u pre ai x pre bi x variables v u follows
bi applicable ti definition vars post bi vars post ai v since ai
bi must unary thus follows definition post bi post ai
hence follows ti v si v since ti v si v assumption
thus shown ti v si v n furthermore clearly
ti ti bi dum follows create plan p
removing dummy operators p
conclude solution solution
finally need following observations sat instances let f sat
formula n variables clauses contains repeated clauses

n
n thus n


furthermore f represented list literals requires log n
log bits plus overhead hence f represented cm bits
constant c later use upper bound safe
note reduction used proof lemma transforms sat
instance n variables clauses instance n n
variables however n n safely
overestimated n
main theorem
prepared state prove main theorem section follows
proof theorem deg c deg c upath length c bounded
class c graphs cc size c bounded case immediate theorem
tractable c begs question happens parameters
bounded constant yet bounded slow growing function consider
case allowed grow slowly long polynomially related
instance size since noted practical typically
causal graph every size require every graph g c
must larger graph g c size p g polynomial p
define parameter g max upath length g deg g deg g require
g g polynomially related turns still hard
restrictions following theorem says
theorem let p q increasing polynomials natural numbers let c
class directed graphs containing subset weakly connected graphs g g g

v g p q
v gi v gi p v gi


fibackstrom jonsson

v gi q gi
planexist c polynomial time solvable polynomial hierarchy collapses holds even restricted operators preconditions postcondition
graphs c acyclic
proof let g g g sequence weakly connected graphs c assumed
theorem let h h h sequence graphs defined follows
hi gj smallest j q v gj
first prove underestimates hi combining requirement q
v gj condition theorem v gj q gj get q v gj
q gj since hi gj get q v hi q hi hi
follows v hi holds
prove v hi polynomially bounded p q since j choosen
smallest value satisfying q v gj must j v gj
q j hi gj g v g p q condition theorem
hence v hi v g p q p q since p q increasing otherwise
j condition lemma says v gj p v gj combining
inequality v gj q yields v gj p v gj p q
v hi p q since hi gj combining previous
v hi construction hi yields h h h sequence graphs
non decreasing unbounded size
define sequence tuples
following holds
deg hi ai deg hi xi xi subgraph hi xi siin
deg hi ai deg hi xi xi subgraph hi
xi siout
upath length hi ai upath length hi xi xi subgraph hi
xi polypath length
every least one three cases must hold since hi
define advice taking turing machine uses sequence
advice takes sat formulae input assume representation formula
f padded size bits number clauses although somewhat
redundant still reasonable encoding sense garey johnson
let work follows let f input formula n variables clauses
let f advice x ht xt first constructs
instance f three cases depending x
x deg construction xt subgraph ht ht stin since
n follows n xt contains subgraph h h snin
construct f way proof lemma vertices h
variables cg f h
x deg analogous previous case constructing f according proof
lemma instead


fia refined view causal graphs component sizes

x upath length construction xt subgraph ht polypath length
suppose xt contains less sinks sources
path length xt follows proposition
v xt
however contradicts construction xt must contain directed path
length least sinks sources
xt contains subgraph h directed path length
construct instance f according proof lemma
vertices h variables cg f h
xt contains subgraph h polypath sinks sources
construct instance
f according proof lemma us

ing variables h variables cg
f fm graph
fence e polypath directed paths length path
stretched directed path arbitrary length repeatedly applying
lemma graph h polypath used template
paths cg
f stretch much order get graph

isomorphic h instance
f thus modified instance f
cg f h
constructions done polynomial time cases f
solution f satisfiable furthermore cg f isomorphic subgraph
ht four cases according lemma thus possible extend f


instance
f cg f ht f solution
solution extension done polynomial time according lemma
since planexist c solved polynomial time assumption theorem
thus follows solve sat polynomial time however implies
np p poly impossible unless polynomial hierarchy collapses theorem
see holds even operators consideration
preconditions postcondition simply note restriction holds reductions
used underlying np hardness proofs section similarly acyclicity restriction
holds since stars stars polypaths
acyclic graphs
recall generic blocks world encoding discussed beginning
section class causal graphs blocks world instances satisfies requirements theorem means planexist likely tractable however
finding non optimal plans blocks world tractable plan length twice
length optimal plan found polynomial time gupta nau
likely difficult blocks world happen exactly
causal graphs illustrates complexity generic
cannot deduced corresponding class causal graphs alone


fibackstrom jonsson

np hard np intermediate classes
theorem chen gimenez states crisp complexity theoretic borderline
component sizes bounded constant polynomial time solvable
otherwise polynomial time solvable exploited extra
constraint sp closure able prove np hardness leaves greyzone
polynomial cases np hard ones longer require classes spclosed longer obviously np hard even components unbounded
natural question arises say something middle ground
instance say something np intermediate cases may look
borderline np hard np intermediate although seem
likely could characterize borderline exactly
least give partial answers questions proving two theorems
related growth rate components first shows still
np hard components grow v g k integers k second one shows
likely np intermediate components grow polylogarithmically
theorem every constant integer k class gk graphs
cc size g v g k g gk planexist gk np hard
proof let k arbitrary integer construct graph class gk g g g
follows let gm mk components isomorphic dpm
e v gm mk components size v gm k prove np hardness
planexist gk reduction planexist dp let arbitrary instance
cg dp cg dpm construct instance
consists mk renamed copies clearly polynomial time construction
since k constant furthermore cg isomorphic gm
solution solution hence polynomial reduction follows
lemma planexist gk np hard
obviously size graphs exponential k
second must conditioned assumption exponential time
hypothesis impagliazzo paturi impagliazzo paturi zane holds
hypothesis conjecture stated follows
definition constant integers k let sk infimum real numbers
k sat solved n time n number variables
instance exponential time hypothesis eth conjecture sk k
informally eth says satisfiability cannot solved subexponential time eth
arbitrarily choosen concept quite strong assumption allows
defining theory similar one np completeness concept called serf
subexponential reduction family reduction preserves subexponential time solvability concept called serf completeness similar np completeness
serf reductions subclass np complete
serf complete meaning serf reduced
hence one solved subexponential time


fia refined view causal graphs component sizes

theorem constant integers k classes c directed graphs
cc size g logk v g g c planexist c np hard unless eth
false
proof let k arbitrary integer let arbitrary instance n
variables maximum domain size cc size cg c components correspond independent subinstances thus solved separately component
state space size dc less plan corresponding subinstance found
c time dijkstras since n components whole
instance solved nd c time however follows standard assumptions
reasonable encodings n looser bound
solved x x c x c time x
suppose planexist c np hard polynomial reduction sat
planexist c furthermore size sat instance polynomially bounded
number variables hence must polynomial p sat instance
n variables corresponding instance size p n
since number variables upper bounded follows assumption component size upper bounded logk logk p n hence
k
solved p n log p n time according earlier observation
p n log

k

p n

log p n log

k

p n

log

k

p n logk p n

log

k

k

p n



k

furthermore logk p n logk n since p polynomial log p n log n
k
follows solved log n time however solved n
time arbitrarily small contradicts eth follows planexist c cannot
np hard unless eth false
since components unbounded likely solvable polynomial
time thus np intermediate double assumption
w nu fpt eth holds
theorems together thus tell us something borderline
np intermediate np hard graph classes however crisp distinction
asymptotically quite gap polylogarithmic functions root
functions e functions form x k one may instance note function


f n log n


log log n c

lies within gap whenever c

discussion
sp closed graph classes appealing properties fit well concept stronger
subgraph closed weaker minor closed give partial characterization
borderline np hardness lies however noted earlier possible define
types graph classes imply np hard one example
family g g g classes proof theorem another specialized
perhaps contrived class following intended give contrast sp closure
concept gk classes


fibackstrom jonsson

tournament directed graph formed giving directions edge complete
graph let denote set tournaments note sp closed however
tournaments hamiltonian graphs redei tournament n vertices
path length n furthermore path length n computed
polynomial time bar noy naor
assume given sat formula f n variables clauses let
n e polynomially bounded f according lemma thus
construct instance f polynomial time
f contains variables
cg f dp
f solution f satisfiable
choose arbitrary tournament vertices path length
identify cg f add dummy operators corresponding remaining
edges thus shown polynomial time transformation sat
planexist planexist np hard one may note variations
technique used proving planexist np hard many different

considered domain sizes tractable restrictions article
note theorem may give ideas look tractable cases consider
case variable domains bounded size constant k
cc size g log v g first part proof see solved
n k log n time however k log n log k log n log n log k n log k
polynomial since k constant tractable restricted case even
though observation straightforward interesting contrast theorem
suggests even larger tractable subgraphs consider additional
restrictions instances
explicitly commented sufficient number pre postconditions
alternative characterizations might relevant would bear far list possibilities let suffice one example
concept prevail conditions e preconditions variables changed
operator originate sas formalism backstrom nebel
recently considered context causal graphs gimenez jonsson
refer operator k dependent precondition k variables
change may note proofs lemmata introduce
operators dependent since proof theorem impose
restrictions original instance follows theorem
holds operators dependent
final question one might wonder practical use know
tractable np intermediate severely limited component sizes
instances likely causal graph weakly connected
whole graph one single component answer question first important
observation make complexity instances directly related
complexity components separately


fia refined view causal graphs component sizes

linearly number variables many components solved
polynomial time components instance solved polynomial time
whole instance conversely cannot solved polynomial time
whole instance least one component polynomial time solvable
complexity instances components directly related
words relevant methods artificially split causal
graph components one way another examples causal graph heuristic
helmert factored brafman domshlak structural pattern
data bases katz domshlak

acknowledgments
anonymous reviewers provided valuable comments suggestions improving
article

references
backstrom c nebel b complexity sas computational
intelligence
bar noy naor j sorting minimal feedback sets hamilton paths
tournaments siam journal discrete mathematics
biggs n algebraic graph theory cambridge univ press nd ed
bodirsky grohe non dichotomies constraint satisfaction complexity
proceedings th international colloquium automata languages
programming icalp reykjavik iceland pp
brafman r domshlak c structure complexity unary
operators journal artificial intelligence
brafman r domshlak c factored
proceedings st national conference artificial intelligence aaai
boston usa pp aaai press
chen h gimenez causal graphs structurally restricted journal computer systems science
domshlak c dinitz multi agent line coordination structure complexity proceedings th european conference ecp toledo
spain
domshlak c dinitz b multi agent line coordination structure complexity tech rep department computer science ben gurion university cs
downey r g fellows r parameterized complexity monographs computer science springer york
flum j grohe parameterized complexity theory vol xiv texts
theoretical computer science eatcs series springer berlin


fibackstrom jonsson

garey r johnson computers intractability guide theory
np completeness w h freeman york
gimenez jonsson complexity simple
causal graphs journal artificial intelligence
gimenez jonsson chain causal graphs variables
domains size np hard journal artificial intelligence
gimenez jonsson influence k dependence complexity
artificial intelligence
gupta n nau complexity blocks world artificial
intelligence
helmert complexity standard benchmark domains
artificial intelligence
helmert heuristic causal graph analysis proceedings
th international conference automated scheduling icaps
whistler bc canada pp aaai press
helmert fast downward system journal artificial intelligence

helmert b complexity classical benchmarks proceedings th international conference automated scheduling
icaps cumbria uk pp aaai press
impagliazzo r paturi r complexity k sat journal computer
system science
impagliazzo r paturi r zane f strongly exponential
complexity journal computer system science
jonsson role macros tractable journal artificial intelligence
jonsson p backstrom c state variable structural restrictions
complexity artificial intelligence
jonsson p backstrom c b tractable plan existence imply tractable
plan generation annals mathematics artificial intelligence
karp r lipton r j connections nonuniform uniform complexity classes proceedings th acm symposium theory
computing stoc los angeles ca usa pp
katz domshlak c structural patterns tractable sequentially optimal
proceedings th international conference automated
scheduling icaps providence ri usa pp aaai press
katz domshlak c islands tractability cost optimal
journal artificial intelligence
katz domshlak c implicit abstraction heuristics journal artificial
intelligence


fia refined view causal graphs component sizes

katz hoffmann j domshlak c said need relax variables proceedings rd international conference automated
scheduling icaps rome italy aaai press
katz keyder e structural patterns beyond forks extending complexity
boundaries classical proceedings th aaai conference
artificial intelligence aaai toronto canada aaai press
knoblock c automatically generating abstractions artificial
intelligence
kuhn osthus young note complete subdivisions digraphs
large outdegree journal graph theory
ladner r e structure polynomial time reducibility journal
acm
lovasz l graph minor theory bulletin ams
mohar b graph minor notices ams
redei l ein kombinatorischer satz acta litteraria szeged
wehrle helmert causal graph revisited directed model checking
proceedings static analysis th international symposium sas los
angeles ca usa vol lncs pp springer
williams b nayak p p reactive planner model executive
proceedings th international joint conference artificial intelligence
ijcai nagoya japan pp




