Journal Artificial Intelligence Research 47 (2013) 575-611

Submitted 02/13; published 07/13

Refined View Causal Graphs Component Sizes:
SP-Closed Graph Classes Beyond
Christer Backstrom
Peter Jonsson

christer.backstrom@liu.se
peter.jonsson@liu.se

Department Computer Science
Linkoping University
SE-581 83 Linkoping, Sweden

Abstract
causal graph planning instance important tool planning
practice theory. theoretical studies causal graphs largely analysed
computational complexity planning instances causal graph certain
structure, often combination parameters domain size variables.
Chen Gimenez ignored even structure considered size weakly
connected components. proved planning tractable components
bounded constant otherwise intractable. intractability result was, however,
conditioned assumption parameterised complexity theory known
useful relationship standard complexity classes. approach problem
perspective standard complexity classes, prove planning NP-hard
classes unbounded components additional restriction refer SPclosed. argue NP-hardness theorems causal graphs difficult
apply and, thus, prove general result; even component sizes grow slowly
class densely populated graphs, planning still cannot tractable unless
polynomial hierachy collapses. results still hold restricted class
acyclic causal graphs. finally give partial characterization borderline
NP-hard NP-intermediate classes, giving insight problem.

1. Introduction
first briefly explain causal graph give short survey applications
well theoretical results reported literature. Following that, give overview
new results presented article.
1.1 Background
causal graph planning instance explicit description variable dependencies implicitly defined operators. precisely, directed graph
arc variable x another variable either x appears
precondition operator effect operator effects x y.
standard definition causal graph traced back Knoblock (1994)
although give name. used causal graph Alpine algorithm,
guidance partitioning ordering variables process automatically
deriving state abstraction hierarchies. actual name causal graph traced back
Williams Nayak (1997). approach general restricted
c
2013
AI Access Foundation. rights reserved.

fiBackstrom & Jonsson

Knoblocks. one hand, generalized concept binary variables
multi-valued variables, hand, considered acyclic causal graphs
implies operators unary, i.e. every operator changes one variable.
context work reactive planner Burton onboard space-ship control.
causal model compiled transition system could efficiently exploited
reactive controller choose appropriate operators achieve given goals. compilation
done way operators unary, claimed often
possible real applications. resulting acyclicity causal graph exploited
Burton, traversed graph bottom order issue operators order
consistent causal relationships.
Jonsson Backstrom (1998b) studied acyclic causal graphs, referred
dependency graphs. considered subclass graphs particular structure used implicitly define corresponding class planning instances, 3S
class. class property always possible decide polynomial time
solution not, solutions may exponential length, thus
necessarily taking exponential time generate. Although one single restricted case,
3S class probably first example relating structural properties causal graph
computational complexity planning. general extensive analysis
done Domshlak Dinitz (2001a), analysed complexity planning
classes instances corresponding number different possible structures acyclic
causal graphs. However, work done context multi-agent coordination
term causal graph never used.
first two papers may viewed early examples exploiting causal
graph practice, latter papers form starting point subsequent theoretical research relationships planning complexity structure
causal graphs.
important step forward usage causal graphs paper Helmert
(2004) demonstrated causal graph particularly useful context
multi-valued variables. Previous research complexity planning multi-valued
variables focussed structure domain-transition graphs variables
(Jonsson & Backstrom, 1998a), rather causal graph. Helmert realized power
using domain-transition graphs causal graph heuristic planning.
exploited practice highly succesful Fast Downward planner (Helmert,
2006a). translates PDDL planning instances binary variables representation
multi-valued variables removes carefully chosen edges resulting causal
graph make acyclic. resulting causal graph used compute heuristic
hierarchically computing composing plan lengths subgraphs one
particular structures studied Domshlak Dinitz (2001a). Somewhat similarly, Katz
Domshlak (2010) identified subgraphs causal graph certain structures
make planning tractable. exploited able use larger variables
sets constructing pattern databases. example exploiting causal graph
make planning efficient paper factored planning Brafman Domshlak
(2006). showed structure causal graph used guide
deciding planning instance solved efficiently dividing
loosely coupled subinstances use constraint processing. basic idea causal
576

fiA Refined View Causal Graphs Component Sizes

graph represent variable dependencies is, course, quite general necessarily
restricted planning. instance, Wehrle Helmert (2009) transferred causal
graph concept context model checking.
previously mentioned, two papers Jonsson Backstrom (1998b)
Domshlak Dinitz (2001a) viewed starting point successful line
research studying relationships planning complexity structure
causal graph. 3S class Jonsson Backstrom limited
special case, Domshlak Dinitz studied classes planning instances corresponding
number general graph structures, in-stars (aka. inverted forks), out-stars (aka.
forks), directed path graphs (aka. directed chain graphs), polytrees singly-connected
DAGs. results followed, instance, articles Brafman Domshlak (2003),
Gimenez Jonsson (2008). latter article additionally showed although 3S
instances exponential-length plans, possible generate macro representation
plan polynomial time, result extended classes defined
structure causal graph. Many complexity results papers use
additional numerical parameters conjunction graph structure. Examples
parameters maximum domain size variables maximum in-degree
graph. increasing number possible cases analyse, allow
fine-grained analysis many cases. Consider instance case directed path
graphs. Domshlak Dinitz (2001a) proved tractable decide
plan case domains binary, Gimenez Jonsson (2009) proved
domain size 5 sufficient make problem NP-hard. Similarly, Gimenez
Jonsson (2012) proved tractability planning instances binary variables, constant
number prevail conditions causal graph polytree. paper
Brafman Domshlak (2006) fits line theoretical research, exhibiting
planning algorithm runs time exponential two parameters, tree-width
undirected version causal graph maximum number times variable must
change value.
research based standard definition causal graphs
set already Knoblock, although often generalisation multi-valued variables,
important exceptions. One potential problem standard defintion
whenever two variables affected operator, causal graph must
necessarily contain cycles, major reason focus mainly
planning unary operators. attempt circumvent problem, Jonsson (2009)
defined relaxed variant causal graph always introduce cycles
non-unary operators, sometimes allow fine-grained complexity analysis.
previous results relate structure causal graph complexity satisficing planning, i.e. deciding plan. corresponding branch
research relating structure causal graph complexity cost-optimal
planning (cf., Katz & Domshlak, 2007, 2008, 2010; Katz & Keyder, 2012).
1.2 Contributions
theoretical research studies complexity planning based structure causal graph, possibly parameters domain sizes. important
577

fiBackstrom & Jonsson

milestone deviates line research article Chen Gimenez
(2010) even consider structure causal graph simple quantitative measure, size weakly connected components. proved deciding
plan done polynomial time size weakly connected components causal graph bounded constant. one sense,
sharp final result. However, intractability result unbounded components
conditional assumtion W[1] 6 nu-FPT. assumption relies theory
parameterised complexity theory neither complexity classes assumption
related ordinary complexity classes clear way. Chen Gimenez acknowledge problems prove conditionally intractable include NP-intermediate
problems. Hence, take result take-off point investigation
component sizes reflect standard complexity classes. Since know Chen
Gimenez graph classes unbounded components NP-hard must
consider restrictions order find NP-hard classes. adding new
type closure property, SP-closure, incomparable subset-closure subset minor-closure, prove planning NP-hard SP-closed graph class
unbounded components. noted result still holds class
acyclic graphs, important considering practical relevance acyclicity
previously mentioned.
many graph classes studied literature indeed SP-closed,
exists natural classes lack property. present one way handling
classes aid non-uniform complexity theory. case, able
show NP-hardness show polynomial hierarchy collapses second
level. fairly general result applied even component sizes grow
slowly graph class densely populated graphs. result
holds even restricted acyclic graphs. result used demonstrate clearly
complexity results planning based class causal graphs necessarily connection complexity generic planning problem
class causal graphs. result raises question find (preferably natural) NP-intermediate planning problems. Chen Gimenez state NP-intermediate
problems obtained using methods similiar ones employed Bodirsky
Grohe (2008). problems hard describe natural, though. based
Ladners (1975) diagonalization technique removes large fraction input strings
problem. apparently difficult connect graph classes constructed technique
simple conditions component growth. alternative, show graph classes
component sizes grow polylogarithmically NP-intermediate double
assumption W[1] 6 nu-FPT exponential time hypothesis (Impagliazzo
& Paturi, 2001) holds. show every k > 1, exists class Gk graphs
component size bounded |V (G)|1/k G Gk corresponding
planning problem NP-hard. results coarsely stake borderline
NP-hard NP-intermediate classes.
possible conclusion paper complexity analysis planning based
structure causal graph limited value, additional parameters
needed achieve useful results. may fair conclusion general,
cases graph structure sufficient. instance, Katz, Hoffmann, Domsh578

fiA Refined View Causal Graphs Component Sizes

lak (2013) applied result Chen Gimenez (2010) context called
red-black planning, variant delete relaxation computing heuristics. Furthermore,
even structure causal graph combined parameters,
still important know behaviour parameter isolation.
remainder article structured follows. Section 2 set notation
terminology used planning graphs, Section 3 define causal graphs
structural planning general. Section 4 contains number NP-hardness results
various special graph classes need main results. first two main
theorems article appears Section 5, define concept SP-closed graph
classes prove planning NP-hard classes component size
unbounded. Section 6 discusses problems previous theorem
similar results literature. way around problems, second main
theorem shows even without closure requirements, planning likely hard
even components grow slowly graphs appear densely class.
Section 7 contains observations concerning borderline NP-intermediate
NP-hard planning problems. article ends discussion section.

2. Preliminaries
section sets terminology notation planning graphs used article.
write |X| denote cardinality set X length sequence X, i.e.
number elements X, write ||X|| denote size representation
object X.
2.1 Planning
Since article many connections one Chen Gimenez (2010)
follow notation terminology plannning, notational variant SAS+
(Backstrom & Nebel, 1995).
instance planning problem tuple = (V, init, goal, A) whose components
defined follows:
V finite set variables, variable v V associated finite domain
D(v). Note variables necessarily propositional, is, D(v) may
finite set. state mapping defined variables V s(v) D(v)
v V . partial state mapping p defined subset vars(p) variables V
v vars(p), holds p(v) D(v), p otherwise undefined.
init state called initial state.
goal partial state.
set operators; operator consists precondition pre(a)
postcondition post(a) partial states. often use notation
hpre ; posti define operator precondition pre postcondition post.
instance, = hx = 0, = 1 ; z = 1i defines operator applicable
state s(x) = 0 s(y) = 1, effect setting variable
z 1.
579

fiBackstrom & Jonsson

state partial state W subset variable set V , write
W denote partial state resulting restricting W . say state
goal state goal = vars(goal).
define plan (for instance ) sequence operators P = a1 , . . . , .
Starting state s, define state resulting applying plan P , denoted
s[P ], inductively follows. empty plan P = , define s[] = s. non-empty
plans P define s[P ] follows, last operator P P 0 prefix
P to, including, a:
pre(a) 6= s[P 0 ] vars(pre(a)) (that is, preconditions satisfied
state s[P 0 ]), s[P 0 , a] = s[P 0 ].
Otherwise, s[P 0 , a] state equal post(a) variables v vars(post(a)),
equal s[P 0 ] variables v V \ vars(post(a)).
plan P solution plan init[P ] goal state.
concerned computational problem plan existence (PlanExist): given
instance = (V, init, goal, A), decide exists solution plan.
2.2 Graphs
directed graph pair (V, E) V vertex set E V V edge set.
undirected graph pair (V, E) V vertex set E {{u, v} | u, v V }
edge set. often say graph edge clear context whether
directed undirected. notation V (G) refers vertex set graph G
E(G) refers edge set. e = (u, v) e = {u, v} edge, vertices u
v incident e. Furthermore, directed edge (u, v) outgoing edge u
incoming edge v. directed graph G = (V, E), write U (G) denote
correspsonding undirected graph U (G) = (V, EU ) EU = {{u, v} | (u, v) E}.
is, U (G) undirected graph induced G ignoring orientation edges.
Let G = (V, E) directed graph let v0 , . . . , vk V v1 , . . . , vk
distinct (vi1 , vi ) E (1 k). sequence v0 , . . . , vk directed
path length k G v0 6= vk directed cycle length k G v0 = vk . Paths
cycles undirected graphs defined analogously, except direction
consider. graph acyclic contains cycles.
Let G = (V, E) directed graph let v V vertex. Then, v isolated
incoming outgoing edges, v source least one outgoing edge
incoming edge, v sink least one incoming edge outgoing edge
otherwise v intermediate.
Let G = (VG , EG ) H = (VH , EH ) two directed graphs. G H
isomorphic (denoted G ' H) exists bijective function f : VG VH
(u, v) EG (f (u), f (v)) EH . Furthermore, H subgraph G VH VG
EH EG (VH VH ). EH = EG (VH VH ) say subgraph H
induced vertex set VH . Isomorphisms subgraphs analogously defined
undirected graphs.
Let G undirected graph. G connected path every
pair vertices G. connected component G maximal subgraph G
580

fiA Refined View Causal Graphs Component Sizes

connected. Let G directed graph. G weakly connected U (G) connected.
weakly connected component G maximal subgraph G weakly connected.
is, weakly connected component paths every pair vertices
ignore direction edges. Let G = (VG , EG ) H = (VH , EH ) two directed
graphs VG VH disjoint. (disjoint) union G H defined
G H = (VG VH , EG EH ) commutative operation. Note graph G
consists (weakly) connected components G1 , . . . , Gn , G = G1 G2 . . . Gn .
define numeric graph parameters. directed graph G vertex
v V (G), indegree v |{u V (G) | (u, v) E(G)}|, i.e. number incoming
edges incident v, outdegree v |{u V (G) | (v, u) E(G)}|, i.e. number
outgoing edges incident v. undirected graph G, degree v V (G)
|{u V (G) | {v, u} E(G)}|, i.e. number edges incident v. extend
graphs follows. G undirected graph, deg(G) denotes largest degree
vertex V (G). Similarly, G directed graph in-deg(G) denotes largest
indegree vertex V (G) out-deg(G) denotes largest outdegree vertex
V (G). Furthermore, G undirected graph, path-length(G) denotes length
longest path G cc-size(G) denotes size largest connected component
G. G directed graph, path-length(G) denotes length longest directed path
G. define upath-length(G) = path-length(U (G)) cc-size(G) = cc-size(U (G)).
is, upath-length(G) length longest path G ignoring direction
edges cc-size(G) size largest weakly connected component G. Note
G undirected connected graph, path-length(G) equals diameter G.
extend numeric graph properties (in-deg, path-length etc.) sets graphs
C set graphs prop graph property, prop(C) = maxGC prop(G).
2.3 Special Graph Types
literature causal graphs, well article, certain types graphs
particular interest thus useful refer names. distinguish
following types undirected graphs: tree undirected graph two
vertices connected exactly one path, i.e. acyclic connected. path graph
tree vertices degree 1 2, i.e. tree branch. star
graph tree vertices except one, centre vertex, degree 1.
directed graphs, distinguish following types: in-star graph directed
graph G U (G) star graph edges directed towards centre.
out-star graph directed graph G U (G) star graph edges
directed centre. directed path graph directed graph G U (G)
path graph, in-deg(G) 1 out-deg(G) 1, i.e. G directed path
vertices contains edges. polytree directed graph G U (G)
tree, i.e. G weakly connected directed graph constructed tree
giving unique direction every edge. polypath directed graph G U (G)
path graph, i.e. G weakly connected directed graph constructed
path graph giving unique direction every edge. fence polypath every
vertex either source sink, i.e. edges alternate direction every vertex.
581

fiBackstrom & Jonsson

noted out-star graph usually called directed star graph
graph theory, in-star graph appears standard name. hence deviate
sligthly standard terminology order logical names graph types.
polypath appears standard name, polypath logical term
analogy polytree. noted parallel terminology certain
graph types evolved literature causal graphs planning. instance, instars, out-stars directed paths commonly referred inverted forks, forks
directed chains, respectively.
Note number sinks sources polypath differ one, i.e.
polypath sinks + c sources c {1, 0, 1}. Furthermore, every fence
polypath, every polypath fence.
define following graphs graphs classes:
Skin denotes in-star graph one centre vertex k sources. define
class Sin = {Skin | k 0}.
Skout denotes out-star one centre vertex k sinks. define class
Sout = {Skout | k 0}.
dPk denotes directed path k vertices. define class dP = {dPk | 1 k}.
c , c {1, 0, 1}, denotes fence sinks + c sources. define
Fm
c | 1 m}, c {1, 0, 1}, class F = F1 F0 F+1 .
class Fc = {Fm

Examples graph types illustrated Figure 1.

v1
v5

v1
v2

vc
v4

v5

v3

v2

vc
v4

v0

v1

v2

v1

v2
u1

v3
u2

F31

v4

v3
S5out

S5in

v3

dP5

v1
u0

v2
u1

v3
u2

v1
u0

F30

v2
u1

v3
u2

u3

F3+1

Figure 1: Examples important graph types.
following observation polypaths used later on.
Proposition 1. Let G polypath sinks + 1 sources
path-length(G) k. |V (G)| 2mk + 1.
582

fiA Refined View Causal Graphs Component Sizes

Proof. 2m distinct paths source sink,
k 1 intermediate vertices. Hence |V (G)| + (m + 1) + 2m(k 1) = 2mk + 1.
bound obviously tight case sinks + 1 sources,
every path source sink contains exactly k 1 intermediate vertices.

3. Structurally Restricted Planning
topic study article causal graphs planning, discussing
concept first define concept domain-transition graphs (Jonsson & Backstrom,
1998a). Although used explicitly results, useful explaining
proofs later article. Let = (V, init, goal, A) planning instance.
variable v V , define domain-transition graph (DTG) v directed graph
(D(v), E), x, D(v), E contains edge (x, y) operator
post(a)(v) = either pre(a)(v) = x v 6 vars(pre(a)).
causal graph planning instance describes variables instance
depends other, implicitly defined operators.
Definition 2. causal graph planning instance = (V, init, goal, A) directed
graph CG() = (V, E) E contains edge (u, v) every pair distinct vertices u, v V u vars(pre(a)) vars(post(a)) v vars(post(a))
operator A.
causal graph gives some, all, information operators. instance,
causal graph acyclic, operators must unary, i.e. |vars(post)(a)| = 1
operators, since non-unary operator must necessarily introduce cycle according
definition. However, presence cycles necessarily mean
non-unary operators. instance, edges (u, v) (v, u) present
graph, mean operator u vars(post(a))
v vars(post(a)). However, mean two operators a0
u vars(pre(a)), v vars(post(a)), v vars(pre(a0 )) u vars(post(a0 )), could
thus unary operators. Similarly, degree vertices provides upper bound
number pre- postconditions operators, lower bound. Suppose
vertex u indegree 2 incoming edges (v, u) (w, u). could mean
operator u vars(post(a)) v vars(pre(a))
w vars(pre(a)). However, mean two different operators a0
v vars(pre(a)), u vars(post(a)), w vars(pre(a0 )) u vars(post(a0 )).
PlanExist problem extended planning instances causal graphs
following way. class C directed graphs, PlanExist(C) problem deciding
arbitrary planning instance CG() C, whether solution
not. is, complexity PlanExist(C) refers complexity set planning
instances whose causal graphs members C.
number results literature computational complexity
planning various classes causal graphs. However, results usually assume
graph class restricted structure, e.g. containing in-stars directed
paths. general abstract result following theorem.
583

fiBackstrom & Jonsson

Theorem 3. (Chen & Gimenez, 2010, Thm. 3.1) Let C class directed graphs.
cc-size(C) bounded, PlanExist(C) solvable polynomial time. cc-size(C)
unbounded, PlanExist(C) polynomial-time solvable (unless W[1] nu-FPT).
theorem describes crisp borderline tractable intractable graph
classes, assumption W[1] 6 nu-FPT1 . complexity
classes theory parameterised complexity cannot immediately related
usual complexity classes. scope article treat parameterised
complexity refer reader standard textbooks (Downey & Fellows, 1999; Flum
& Grohe, 2006). result theorem parameterised result, however;
condition parameterised, suffices note intractability result holds
condition difficult relate common assumptions, P 6= NP.
One reasons Chen Gimenez forced state theorem way
classification polynomial NP-hard classes would exhaustive,
since graph classes NP-intermediate. (A problem NP-intermediate
neither P NP-complete, unless P = NP.)
theorem might viewed starting point research reported
article, investigate problem perspective standard complexity
classes. instance, NP-hardness proved case unbounded components
adding restrictions, Section 5.

4. Basic Constructions
section presents results necessary theorems later article.
first three results, planning NP-hard in-stars (aka. inverted forks), out-stars
(aka. forks) directed paths (aka. directed chains), known literature,
NP-hardness result fences new. will, however, provide new proofs
in-star out-star cases. major reason Section 6 need refer
reductions certain precisely known properties. Furthermore, original proofs
published technical report (Domshlak & Dinitz, 2001b) may thus hard
access.
Lemma 4. (Domshlak & Dinitz, 2001a, Thm. 3.IV) PlanExist(Sin ) NP-hard. result
holds even restricted operators 2 preconditions 1 postcondition.
Proof. (New proof) Proof reduction 3SAT class planning instances
causal graphs Sin . reduction constructs planning instance source
causal graph corresponds one variables formula centre corresponds
clauses. construction illustrated Figure 2 formally defined follows.
Let F = c1 . . . cm arbitrary 3SAT formula variables x1 , . . . , xn clauses
c1 , . . . , cm . Construct corresponding planning instance F = (V, init, goal, A) follows:
V = {vc , v1 , . . . , vn },
D(vc ) = {0, . . . , m}
D(vi ) = {u, f, t}, (1 n).
1. condition simplified W[1] 6 FPT class C recursively enumerable.

584

fiA Refined View Causal Graphs Component Sizes

vc
0

1

2


u


u


u

f
v1



f
v2

f
vn

Figure 2: in-star causal graph DTGs construction proof
Lemma 4.

init(vi ) = u, (1 n), init(vc ) = 0.
goal(vc ) = goal otherwise undefined.
consists following operators:
(1 n), contains operators
set-f(i) = hvi = u ; vi = f
set-t(i) = hvi = u ; vi = ti.
clause ci = (`1i `2i `3i ) j (1 j 3), k
`ji = xk `ji = xk , let contain either operator
verify-clause-pos(i, j) = hvc = 1, vk = ; vc = ii, `ji = xk ,
operator
verify-clause-neg(i, j) = hvc = 1, vk = f ; vc = ii, `ji = xk .
Clearly, instance F constructed polynomial time CG(F ) = Snin ,
remains prove F solution F satisfiable.
source variable vi changed independently. starts undefined
value u set either f , corresponding true false, respectively,
corresponding variable xi F . set either f , cannot changed again.
is, variables v1 , . . . , vn used choose commit truth assignment
x1 , . . . , xn . centre variable vc one value, i, clause ci F , plus initial
value 0. possible reach goal value inital value 0 stepping
585

fiBackstrom & Jonsson

intermediate values numerical order. step, 1 i,
three operators choose from, corresponding literals clause ci . step
possible one v1 , . . . , vn set value consistent one literals ci .
is, goal vc = achieved variables v1 , . . . , vn set values
corresponding truth assignment x1 , . . . , xn satisfies F .
restricted case (with respect pre- post-conditions) immediate
construction above.
problem known tractable, though, domain size centre variable
bounded constant (Katz & Domshlak, 2010). Furthermore, causal graph heuristic
Helmert (2004) based identifying in-star subgraphs causal graph,
noted provided variant original proof due minor technical
differences problem formulations.
Lemma 5. (Domshlak & Dinitz, 2001a, Thm. 3.III) PlanExist(Sout ) NP-hard. result
holds even restricted operators 1 precondition 1 postcondition.
Proof. (New proof) Proof reduction 3SAT class planning instances
causal graphs Sout . reduction constructs planning instance centre vertex
causal graph corresponds variables formula sink corresponds
one clauses. construction illustrated Figure 3 formally defined
follows.
v1

u

v2

vm



u



u

t0

t1

t2

tn

f0

f1

f2

fn



vc

Figure 3: out-star causal graph DTGs construction proof
Lemma 5.

Let F = c1 . . . cm arbitrary 3SAT formula variables x1 , . . . , xn clauses
c1 , . . . , cm . Construct corresponding planning instance F = (V, init, goal, A) follows:
586

fiA Refined View Causal Graphs Component Sizes

V = {vc , v1 , . . . , vm },
D(vc ) = {f0 , . . . , fn , t0 , . . . , tn }
D(vi ) = {u, s}, (1 m).
init(vi ) = u, (1 m), init(vc ) = f0 .
goal(vi ) = s, (1 m), goal(vc ) undefined.
consists following operators:
(1 n), contains operators
step-c(fi1 , ) = hvc = fi1 ; vc = i,
step-c(fi1 , ti ) = hvc = fi1 ; vc = ti i,
step-c(ti1 , ) = hvc = ti1 ; vc =
step-c(ti1 , ti ) = hvc = ti1 ; vc = ti i.
clause ci = (`1i `2i `3i ) j (1 j 3), k
`ji = xk `ji = xk , let contain either operator
verify-clause-pos(i, j) = hvc = tk ; vi = si, `ji = xk ,
operator
verify-clause-neg(i, j) = hvc = fk ; vi = si, `ji = xk .
Clearly, instance F constructed polynomial time CG(F ) = Snout ,
remains prove F solution F satisfiable.
Variable vc changed independently two values, ti ,
variable xi F , corresponding possible truth values xi . addition
initial value f0 (and dummy value t0 order simplify formal definition).
values tn fn reachable initial value f0 , plan correspond
path f0 , z1 , z2 , . . . , zn zi either ti . is, vc must pass either value
ti , both, i. Hence, path correspond truth assignment
variables x1 , . . . , xn F . clause ci F , corresponding variable
vi change value initial value u, unsatisfied, goal value s, satisfied.
vi three operators this, one literal ci . is, ci contains
literal xk (or xk ) vi change value u vc value tk (or fk ).
Hence, goal v1 = . . . = vm = achieved path vc
corresponds truth assignment x1 , . . . , xn satisfies F . (Note, though,
vc must always follow path way fn tn since partial assignment may
sometimes sufficient prove satisfiability.)
restricted case (with respect pre- post-conditions) immediate
construction above.
problem known tractable, though, domain size centre variable
bounded constant (Katz & Keyder, 2012).
following result planning directed-path causal graphs known
literature.
Lemma 6. (Gimenez & Jonsson, 2009, Prop. 5.5) PlanExist(dP) NP-hard, even
variables domain size 5 operators 2 preconditions 1 postcondition.
587

fiBackstrom & Jonsson

refer Gimenez Jonsson proof. However, implicitly use
proof later article important observations make it.
reduction SAT and, thus, works reduction 3SAT. Furthermore,
reduction transforms formula n variables clauses planning instance
(2m + 4)n variables. final remark, problem known tractable variables
domain size 2 (Domshlak & Dinitz, 2001a).
three previous results known literature, following result new
best knowledge.
Lemma 7. PlanExist(F+1 ) NP-hard. result holds even restricted operators
2 preconditions 1 postcondition.
Proof. Proof reduction 3SAT class planning instances causal graphs
F+1 .
reduction constructs planning instance sink causal graph corresponds one clauses formula, source corresponds variables.
Furthermore, source variables synchronized behaviour. construction illustrated Figure 4 formally defined follows.
Let F = c1 . . . cm arbitrary 3SAT formula variables x1 , . . . , xn clauses
c1 , . . . , cm . Construct corresponding planning instance F follows:
V = {u0 , . . . , um , v1 , . . . , vm },
D(ui ) = {f0 , . . . , fn , t0 , . . . , tn }, (0 m),
u , tu , . . . , tu , f , . . . f , ts , . . . , ts , s}, (1 m).
D(vi ) = {f0u , . . . , fm
0
0

0
init(ui ) = f0 , (0 m), init(vi ) = f0u , (1 m).
goal(vi ) = s, (1 m), goal otherwise undefined.
Let consist following operators:
i, j (1 n, 0 j m), contains operators
step-x(j, fi1 , ) = huj = fi1 ; uj = i,
step-x(j, fi1 , ti ) = huj = fi1 ; uj = ti i,
step-x(j, ti1 , ) = huj = ti1 ; uj =
step-x(j, ti1 , ti ) = huj = ti1 ; uj = ti i.
i, j, (1 n, 1 j m), contains operators
u
u , f u ) = hv = f u , u
step-clause-u(j, fi1
j
i1 j1 = , uj = ; vj = i,

u
u
u
u
step-clause-u(j, fi1 , ti ) = hvj = fi1 , uj1 = ti , uj = ti ; vj = ti i,
step-clause-u(j, tui1 , fiu ) = hvj = tui1 , uj1 = , uj = ; vj = fiu i,
step-clause-u(j, tui1 , tui ) = hvj = tui1 , uj1 = ti , uj = ti ; vj = tui i,
, f ) = hv = f , u

step-clause-s(j, fi1
j

i1 j1 = , uj = ; vj = i,
, ts ) = hv = f , u

step-clause-s(j, fi1
j

i1 j1 = ti , uj = ti ; vj = ti i,



step-clause-s(j, ti1 , ) = hvj = ti1 , uj1 = , uj = ; vj = fis i,
step-clause-s(j, tsi1 , tsi ) = hvj = tsi1 , uj1 = ti , uj = ti ; vj = tsi i,
j (1 j m), contains operators
finalize-clause-f(j) = hvj = fns ; vj = si
finalize-clause-t(j) = hvj = tsn ; vj = si.
588

fiA Refined View Causal Graphs Component Sizes

vi1

vi+1

vi
tu0

tu1

tu2

tun

f0u

f1u

f2u

fnu

x1 ci

x2 ci

ts0

ts1

ts2

tsn

f0s

f1s

f2s

fns



t0

t1

t2

tn

t0

t1

t2

tn

f0

f1

f2

fn

f0

f1

f2

fn

ui1

ui

Figure 4: fence causal graph DTGs construction proof
Lemma 7. (This example assumes clause ci contains literals x1 x2 ).

clause ci = (`1i `2i `3i ) j (1 j 3), k
`ji = xk `ji = xk let contain either operator
verify-pos(i, j) = hvi = tuk ; vi = tsk i, `ji = xk ,
operator
verify-neg(i, j) = hvi = fku ; vi = fks i, `ji = xk .
+1 . Hence,
Clearly, instance F constructed polynomial time CG(F ) = Fm
remains prove F solution F satisfiable.
First consider variables ui vi , i. construction domain
operators ui identical one vc proof Lemma 5, i.e.
directed path value f0 fn tn every possible truth assignment variables
x1 , . . . , xn F . Variable vi , corresponds clause ci contains two copies DTG
ui , values differ extra superscript, u s. latter copy extended
additional value s, denoting clause satisfied. operators
allows vi mimic behaviour ui ; follow corresponding path either
two copies. Furthermore, three literals ci operator

589

fiBackstrom & Jonsson

makes possible move value zku value zks value zk ui consistent
ts order reach goal value
literal. Since vi starts f0u must reach either fm

s, necessary vi make transition one literals ci . is, ui
follows path f0 , z1 , . . . , zn vi must follow path f0u , z1u , . . . , zku , zks , . . . , zns , s,
k xk occurs literal ci zk satisfying truth value literal.
consider variable ui1 . Since operator affects value vi either
precondition ui1 ui precondition either, follows
ui1 ui must choose path vi reach goal. Since every variable vj
forces synchronization adjacent variables uj1 uj manner, follows
u0 , . . . , um must choose exactly path plan solution. thus
follows argument ui vi goal v1 = . . . = vm =
achieved path u0 , . . . , um choose
path corresponds satisfying truth assignment F .
restriction, first note immediate construction operators
3 preconditions 1 postcondition sufficient. see 2 preconditions
sufficient, consider following variation construction. step-clause-u stepclause-t operator replaced two operators follows. example, consider
u , tu ). First introduce extra value f tu D(v ). replace
operator step-clause-u(j, fi1
j


operator two new operators
u , f tu ) = hv = f u , u
u
step-clause-u(j, fi1
j

i1 j1 = ti ; vj = f ti
step-clause-u(j, f tui , tui ) = hvj = f tui , uj = ti ; vj = tui i.
u
Consider step DTG vj fi1
tui . original construction,
u , tu ), requires u
done single operator step-clause-u(j, fi1
j1 uj

u
value ti . modified construction instead requires two steps, first step fi1
u
u
new intermediate value f ti step value ti . previous
conjunctive constraint uj1 = uj = ti replaced sequential constraint first
uj1 = ti uj = ti . Although technically possible uj1 moved
new value second step taken, matter; uj1 uj must
still choose exactly path respective DTGs.
Corollary 8. PlanExist(F1 ), PlanExist(F0 ) PlanExist(F) NP-hard.
Proof. Neither two outer source vertices, u0 um , necessary construction
previous proof. Hence, omitting either reduction works
F1 F0 . Finally, PlanExist(F) NP-hard since F+1 F.
basic results necessary main theorems following
two sections.

5. Graph Classes Closure Properties
results literature, results previous section classes
consisting particular graph type, class Sin in-stars class F
fences. section depart instead study graph classes certain
closure properties. first discuss standard concepts subgraph closure minor
closure, finding first contain graphs need latter results
590

fiA Refined View Causal Graphs Component Sizes

set many graphs. reason, define new concept, SP-closure,
incomparable subgraph closure subset minor closure.
show closure concept defines borderline non-NP-hard graph classes
large number useful NP-hard classes.
5.1 Subgraph Closure Minor Closure
Suppose C class graphs closed taking subgraphs. every graph
G C case every subgraph H G must C. Subgraph closure
sufficient purposes, though. instance, subgraph polypath always
either polypath graph every weakly connected component polypath.
However, polypath need subgraphs fences trivial size.
need closure property guarantees C contains polypath sinks,
contains fence sinks. obvious candidate concept
minor-closure, superset subgraph-closure. concepts graph minors
minor-closure rapidly evolved important useful research area
mathematical well computational graph theory (Lovasz, 2005; Mohar, 2006).
order define graph minors first need concept edge contraction,
commonly defined follows, although definitions occur literature.
Definition 9. Let G = (V, E) directed graph let e = (u, v) E edge
u 6= v. contraction e G results new graph G0 = (V 0 , E 0 ),
V 0 = (V \ {u, v}) {w}
E 0 = {(f (x), f (y)) | (x, y) E, (x, y) 6= (u, v) (x, y) 6= (v, u)},
w new vertex, V , function f : V V 0 defined
f (u) = f (v) = w otherwise f (x) = x.
is, edge (u, v) contracted, two vertices u v replaced
single new vertex w edges previously incident either u v
redirected incident w. Figure 5 shows example edge contraction. say
graph H contraction another graph G H result contracting zero
edges G.
concept graph minors defined follows.
Definition 10. directed graph H minor directed graph G H isomorphic
graph obtained zero edge contractions subgraph G.
example illustrated Figure 6. graph G figure weakly connected
directed graph, happens polypath. vertex v9 removed G,
restriction remaining vertices still weakly connected graph
subgraph G. Removing v4 results graph H, consists two weakly
connected components H1 H2 . H, H1 H2 subgraphs G,
minors G, since subgraph minor, definition. Contracting edge (v1 , v2 )
H1 results graph M1 , w1 new vertex replacing v1 v2 . Similarly,
contracting edge (v8 , v7 ) H2 results M2 . graph M1 minor G since
591

fiBackstrom & Jonsson

v9

v9
v10

v8

v10
v8

v2
v7

v5

v7

v1

v6

v5

w

v6

v3

v4

a) graph G

v3

v4

b) result contracting edge (v1 , v2 ) G.

Figure 5: Edge contraction.

result edge contraction subgraph H1 G graph M2 analogously
minor G too. graph , consisting two components M1 M2
minor G, since result two contractions subgraph H G.
graphs H, H1 H2 subgraphs minors G, graphs , M1 M2
minors G, subgraphs.

v6
v3
v2

v5
v4

v6
v7

v3
v8

v1

a) polypath

v7

v2
v9

G

v5

v3
v8

w1

v5
M1

v1
H1

v6
w2
M2

H2

b) subgraph H G
(where H = H1 H2 )

c) minor G
(where = M1 M2 )

Figure 6: Subgraphs minors.

trivial example minor-closed class class graphs, minor-closed
since contains graphs every minor graph graph. interestingly,
many commonly studied graph types result minor-closed classes. instance, class
Sin in-stars minor-closed, class Sout out-stars class dP
592

fiA Refined View Causal Graphs Component Sizes

directed paths. Furthermore, weakly connected minor polypath polypath
weakly connected minor polytree polytree. illustration, consider
Figure 6. graph G polypath, weakly connected graphs H1 , H2 , M1
M2 minors G, polypaths. fact, M1 M2 fences.
Note though, neither H polypath, since consist one
weakly connected component. worth noting, however, class F fences
minor-closed although every fence polypath; weakly connected minor fence
must polypath, necessarily fence.
Requiring minor-closed graph classes is, however, overly strong. instance, would
sufficient require every graph G C, every weakly connected minor G
C. is, example Figure 6 would require H1 , H2 , M1 M2
C G C, would require H C.
reasonable desirable context causal graphs. causal graph planning
instance consists two weakly connected components, components
correspond entirely independent subinstances solved separately.
Furthermore, certain natural restrictions mix well minor-closed classes.
Consider, instance, example Figure 7, acyclic graph G = (V, E),
V = {v1 , v2 , v3 , v4 } E = {(v1 , v2 ), (v2 , v3 ), (v3 , v4 ), (v1 , v4 )}. contract edge
(v1 , v4 ) new vertex w get cycle graph vertices w, v2 , v3 . is, class
acyclic graphs minor-closed general, problematic considering importance acyclic causal graphs.

v1

v2

v4

v3

v2
w

a) acyclic graph G

v3
b) contraction (v1 , v4 ) G.

Figure 7: Contracting edge acyclic graph result cycle.

5.2 SP-Closed Graph Classes
order avoid problems acyclicity (and similar problems) avoid defining
special variants contraction minor concepts, instead identify set minimal
requirements closure must satisfy order imply NP-hardness PlanExist
problem. focus one set restrictions, defining concept refer
SP-closure (where SP denotes set closed stars polypaths).
Definition 11. Let G H two directed graphs. H SP-graph G H
weakly connected either following holds:
1. H in-star subgraph G,
593

fiBackstrom & Jonsson

2. H out-star subgraph G
3. H obtained zero contractions polypath G0 G0
subgraph G.
class C graphs SP-closed contains every SP-graph every graph G C.
SP-closure number interesting properties, including following:
Proposition 12. Let G H directed graphs let C class directed graphs.
1. G polypath, every SP-graph G polypath.
2. Every SP-graph G acyclic.
3. H SP-graph G, H minor G.
4. C minor-closed, C SP-closed.
Proof. 1) Suppose G polypath. Obviously, G cannot contain in-star out-star
higher degree two, star polypath. Hence, need
consider third case definition. note weakly connected subgraph G0
G must polypath, contractions polypath results polypath.
2) Immediate since in-stars, out-stars polypaths acyclic contracting edges
cannot introduce cycle cases.
3) Immediate definitions minors SP-graphs.
4) Immediate 3.
proposition says makes sense talk SP-closed classes polypaths
SP-closed classes acyclic graphs. says SP-closure minor-closure
comparable concepts; SP-closure class subset minor-closure
class.
prove following result SP-closed classes polypaths,
need main theorem.
Lemma 13. Let C SP-closed class polypaths. cc-size(C) unbounded,
PlanExist(C) NP-hard. result holds even restricted operators
2 preconditions 1 postcondition.
Proof. Proof cases depending whether directed path length C bounded not.
Case 1: Suppose path-length(C) unbounded. Let n > 1 arbitrary integer.
must graph G C G contains subgraph H directed
path graph V (H) = n. Obviously, H SP graph G, since directed path
polypath. follows H C since C SP-closed. Furthermore, H ' dPn
NP-hardness PlanExist(C) follows Lemma 6, since n choosen arbitrarily.
Case 2: Instead suppose path-length(C) k constant k 0. Let n > 1
arbitrary integer. Since graphs C polypaths cc-size(C) unbounded,
must polypath G C V (G) n. thus follows assumption
Proposition 1 G must least sinks + 1 sources,
594

fiA Refined View Causal Graphs Component Sizes

V (G) 2mk + 1. must, thus, subgraph G0 G polypath
exactly sinks + 1 sources (i.e. G0 weakly connected) must, thus,
+1 .
graph H obtained zero contractions G0 H ' Fm
follows H C since C SP-closed. NP-hardness PlanExist(C) thus follows
Lemma 7, since n choosen arbitrarily k constant.
see result holds even operators consideration 2
preconditions 1 postcondition, simply note restriction holds reductions
used underlying NP-hardness proofs Section 4.
Chen Gimenez (2010, Thm. 3.19) proved similar result: C class polypaths2
unbounded components unbounded number sources, PlanExist(C)
polynomial-time solvable unless W[1] nu-FPT.
order prove main result section, need Moore bound (Biggs,
1993, p. 180), stated follows: arbitrary connected undirected graph G,
maximum number vertices
|V (G)| 1 +

k1
X

(d 1)i ,

(1)

i=0

= deg(G) k = path-length(G).
prove additional restriction graph classes SPclosed, avoid NP-intermediate problems prove NP-hardness graph classes
unbounded components.
Theorem 14. Let C SP-closed class directed graphs. cc-size(C) unbounded,
PlanExist(C) NP-hard. result holds even restricted operators
2 preconditions 1 postcondition graphs C acyclic.
Proof. First suppose constant k in-deg(C) k, out-deg(C) k
upath-length(C) k. Consider arbitrary graph G C. Obviously, deg(U (G)) 2k
path-length(U (G)) k, P
follows Moore bound component U (G)

1 + 2k k1
i=0 (2k 1) vertices. However, since cc-size(G) = cc-size(U (G))
G choosen arbitrarily, follows cc-size(C) bounded. contradicts
assumption least one in-deg(C), out-deg(C) upath-length(C) unbounded.
remainder proof three (possibly overlapping) cases.
Case 1: Suppose in-deg(C) unbounded. Let n > 0 arbitrary integer.
must graph G C containing vertex indegree n more, must
subgraph H G H ' Snin . Hence, H C since C SP-closed. thus
follows Lemma 4 PlanExist(C) NP-hard, since n choosen arbitrarily.
Case 2: Suppose out-deg(C) unbounded. case analogous previous
one, using Lemma 5 instead Lemma 4.
Case 3: Suppose upath-length(C) unbounded. Let n > 0 arbitrary integer.
must graph G C U (G) contains path length n,
must, thus, subgraph H G H polypath length n. Obviously, H
2. Chen Gimenez use term source-sink configuration polypath.

595

fiBackstrom & Jonsson

SP-graph G (doing zero contractions) H C since C SP-closed. thus follows
Lemma 13 PlanExist(C) NP-hard, since n choosen arbitrarily.
see result holds even operators consideration 2
preconditions 1 postcondition, simply note restriction holds reductions
used underlying NP-hardness proofs Section 4. Similarly, acyclicity restriction
holds since result based in-stars, out-stars polypaths,
acyclic graphs.
theorem somewhat restricted one Chen Gimenez since
requires additional constraint C SP-closed. hand, demonstrates
SP-closure sufficient condition avoid graph classes PlanExist NPintermediate and, thus, sharpen result NP-hardness. noted, though,
exact characterization graph classes NP-hard PlanExist.
graph classes, SP-closure captures large number interesting
graph classes. instance, class acyclic graphs SP-closed (recall class
minor-closed), although every subclass SP-closed. opposite example,
non-empty class contain single acyclic graph cannot SP-closed.

6. Beyond SP-Closed Graph Classes
section divided three parts. first discuss previous results, well
similar NP-hardness results literature, problematic, motivates
us switch non-uniform complexity theory. second part contains number
preparatory results required main theorem third part.
6.1 NP-Hardness Enough
refer planning problem generic instances varying size, depending
one parameters. archetypical example blocks world, natural
parameter number blocks. particular encoding specified number
blocks, variables operators whatever inital state goal is.
is, fix encoding get planning frame n = (Vn , ) every number,
n, blocks. is, n instances n blocks thus function
n. instances (Vn , init, goal, ) n blocks instantiations n different
init goal components Vn components. instance thus
specified three unique parameters, n, init goal, first parameter,
n, affects size instance. Furthermore, causal graph instance depends
variables operators, means instantiations frame n
causal graph, denote CG(n ). class causal graphs blocks
world instances = {CG(1 ), CG(2 ), CG(3 ), . . .}, although 1 , 2 , 3 , . . .,
thus D, differ depending encoding.
often possible analyse complexity particular generic planning problem.
Examples complexity blocks-world planning (Gupta & Nau, 1992)
complexity various problems International Planning Competitions (IPC)
(Helmert, 2003, 2006b). context article, though, rather interested
complexity class causal graphs corresponding generic problem,
596

fiA Refined View Causal Graphs Component Sizes

complexity specific problem itself. Suppose class causal graphs
happens subset class C graphs know PlanExist(C)
tractable. infer PlanExist(D) tractable, thus
generic planning problems causal graphs tractable. However, order
prove PlanExist(D) NP-hard (or hard complexity class) would
prove class C graphs PlanExist(C) NP-hard C
subset D. Finding class C may trivial, though.
One problem encoding large influence densely sparsely
causal graphs occur respect size. Consider, instance, blocks world encodings
multi-valued variables boolean variables respectively. typical encoding
multi-valued variables use one variable status hand two variables
block, one position block one flag whether block clear
not. is, encodings use 2n + 1 variables n-block frame. encoding
boolean variables, hand, typically represent block position
number boolean variables, one block block on. boolean
encoding thus use n2 + 1 variables n-block frame. contain graph
every odd number vertices first case, increasingly sparse second
case. class causal graphs generic planning problem will, thus, typically
SP-closed, even closed taking subsets. Furthermore, since typically
contain member every possible number vertices, cannot possibly contain
known NP-hard sets Sin , Sout , dP etc. subset. Hence, order prove
class causal graphs hard NP (or complexity class), often
necessary make dedicated proof D. often doable, however. generic
planning problem corresponding function f takes parameter value n, e.g.
number blocks blocks world, f (n) = n . f furthermore polynomialtime computable value n, often case, corresponding
causal graph, CG(n ), polynomial-time computable. However, even done
many generic planning problems, specific proof every specific encoding
every particular generic planning problem. holds particular classes causal
graphs; every specific class typically require dedicated proof.
order get around problems able prove general result
depend specific planning problems causal graphs, switch nonuniform complexity. makes possible prove powerful results, retaining
natural connections ordinary complexity classes. basic vehicle proving nonuniform complexity results advice-taking Turing machine, defined follows.
Definition 15. advice-taking Turing machine associated sequence advice
strings A0 , A1 , A2 , . . ., special advice tape advice function A, natural
numbers advice sequence, s.t. A(n) = . input x advice tape immediately
loaded A(||x||). continues ordinary Turing machine, except
access advice written advice tape.
exists polynomial p s.t. ||A(n)|| p(n), n > 0, said use
polynomial advice. complexity class P/poly set decision problems
solved advice-taking TM runs polynomial time using polynomial advice.
597

fiBackstrom & Jonsson

Note advice depends size input, content, need
even computable. Somewhat simplistically, advice-taking Turing machine
machine infinite data-base constant access time. However, input
size polynomial amount information might exponential
number instances sharing information. power polynomial advice thus still
somewhat limited useful relationships known non-uniform complexity
classes relate standard ones known. One result following.
Theorem 16. (Karp & Lipton, 1980, Thm. 6.1) NP P/poly, polynomial
hierarchy collapses second level.
6.2 Preparatory Results
carrying main theorem section, need auxiliary results.
first show planning instance causal graph G subgraph graph
H, instance extended equivalent instance H causal graph.
Lemma 17. Let planning instance let G directed graph CG()
subgraph G. planning instance G
G constructed polynomial time,
CG(G ) = G
G solution solution.
Furthermore, G maximum number pre- postconditions operators
(or one value zero ).
Proof. Let = (V, init, goal, A) planning instance let CG() = (V, E). Let
G = (VG , EG ) directed graph CG() subgraph G. Let U = VG \ V .
Construct planning instance G = (VG , initG , goalG , AG ) follows:
DG (u) = {0, 1}, u U ,
DG (v) = D(v) {?}, v V , (where ? new value D(v)).
initG (v) = init(v), v V ,
initG (u) = 0, u U .
goalG (v) = goal(v), v V ,
goalG (u) undefined u U .
Let AG consist following operators:
Let AG contain A.
edge (x, v) EG \ E x VG v V , let AG contain
operator star(x, v) = hx = 0 ; v = ?i.
edge (x, u) EG x VG u U , let AG contain
operator set(x, u) = hx = init(x) ; u = 1i.
598

fiA Refined View Causal Graphs Component Sizes

Obviously G constructed polynomial time CG(G ) = G, remains
prove G solution solution.
Suppose P = a1 , . . . , plan . P plan G since goalG (u)
undefined u U a1 , . . . , AG . contrary, suppose P = a1 , . . . ,
plan G . operator ai P , three cases: (1) ai A, (2) ai set
operator (3) ai star operator. case 2, operator ai serves purpose since
modifies variable U , undefined goal value. case 3, operator ai sets
variable v V ? effect variables. goalG (v) undefined,
ai serves purpose. Otherwise must operator aj , j > i, aj
change v ? value D(v), i.e. ai serves purpose case either.
follows operator sequence P 0 obtained P removing operators
plan G . Furthermore, since P 0 contains operators
plan . follows plan G plan.
construction increases maximum domain size one little effect
maximum number pre- postconditions. suitable purpose, since
consider influence domain sizes article. constructions
possible want balance various factors differently.
proof forthcoming theorem opposite taking graph
minors, is, starting minor G target graph H extend G H.
order so, need operation similar opposite edge contraction.
satisfied graph operation known edge subdivision.
Definition 18. Let G = (V, E) directed graph let (u, v) E edge
u 6= v. subdivision (u, v) G graph G0 = (V {w}, E 0 ) w new
vertex E 0 = (E \ {(u, v)}) {(u, w), (w, v)}.
Although one might consider definitions, e.g. case (u, v)
(v, u) E, one sufficient purpose follows usual extension
directed graphs (cf., Kuhn, Osthus, & Young, 2008). Usually operation called smoothing
considered inverse edge subdivision. However, smoothing viewed
restricted case edge contraction, reasonable think edge subdivision sort
inverse edge contraction. example edge subdivision illustrated Figure 8.
note edge contraction polypath polypath, edge
subdivision polypath polypath.
need operation planning instances corresponding edge subdivision
causal graphs. purpose, need concept variable substitution
operators. denote substitution variable w variable v partial state
a[v/w], defined as:

x = w,
s(v),
s(x),
x vars(s) \ {v, w},
s[v/w](x) =

undefined, otherwise.
operator, operator a0 = a[v/w] defined pre(a0 ) = pre(a)[v/w]
post(a0 ) = post(a)[v/w].
599

fiBackstrom & Jonsson

v9

v9
v10

v8

v10
v8

v2
v7

v5

v7

v1

v6
v3

a) graph G

v2

v6
v4

w

v5

v1
v3

v4

b) result subdividing edge (v1 , v2 ) G.

Figure 8: Edge subdivision.

necessary concepts modifying arbitrary planning instance
result corresponds subdividing edge causal graph instance.
However, need instances causal graph polypath.
proving done, first need following lemma, states
certain reordering property plans causal graph polypath. choose
arbitrary vertex v polypath G remove v G, G falls apart two weakly
connected components C1 C2 . words, vertices G partitioned
three sets C0 , C1 C2 C0 = {v} edge directly
vertex C1 vertex C2 . follows definition causal graphs
operator changes variable C1 precondition variable
C2 vice versa. following lemma utilises fact prove sequence
operators change variable v reordered operators
change variables C1 come operators change variables C2 .
Lemma 19. Let = (V, init, goal, A) planning instance G = CG()
polypath. Let v arbitrary variable V , let C0 = {v} let C1 , C2 V two
(possibly empty) weakly connected components G result vertex v removed
G. Define Ai = {a | vars(post(a)) Ci } (0 2). Let P plan .
Let P1 , P2 Q operator sequences P = P1 , Q, P2 Q contains operator
A0 . Let Q1 subsequence Q containing operators A1 let Q2
subsequence Q containing operators A2 . P1 , Q1 , Q2 , P2 plan
.
Proof. Assume C0 , C1 C2 defined lemma recall C0 = {v}. First
note G acyclic since polypath, operators unary. follows
{A0 , A1 , A2 } partition and, thus, A0 A1 A2 = A. Let s0 = init[P1 ].
Obviously, (vars(pre(a))C2 = (vars(post(a))C2 = Q1 (vars(pre(a))C1 =
(vars(post(a)) C1 = Q2 , i.e. state holds s[a] C2 = C2
Q1 s[a] C1 = C1 Q2 . Furthermore, state holds
600

fiA Refined View Causal Graphs Component Sizes

s[a](v) = s(v) Q, since 6 A0 . follows s0 [Q] C1 = s0 [Q1 ] C1
s0 [Q] C2 = s0 [Q2 ] C2 . Hence,
s0 [Q1 , Q2 ] C0 = s0 [Q] C0 ,
s0 [Q1 , Q2 ] C1 = s0 [Q1 ] C1 = s0 [Q] C1
s0 [Q1 , Q2 ] C2 = s0 [Q2 ] C2 = s0 [Q] C2 .
is, s0 [Q1 , Q2 ] = s0 [Q] follows P1 , Q1 , Q2 , P2 plan .
prove planning instance CG() polypath,
subdivide edge CG() create planning instance 0 CG(0 )
subdivision CG() 0 solvable solvable.
Lemma 20. Let planning instance CG() polypath let e
edge CG(). planning instance 0
0 constructed polynomial time,
CG(0 ) edge subdivision e CG()
0 solution solution.
Proof. Let = (V, init, goal, A) planning instance CG() polypath
let e = (u, v) edge CG(). Construct new instance 0 = (V 0 , init0 , goal0 , A0 )
follows:
V 0 = V {w}, D(w) = D(u) w 6 V .
init0 (v) = init(v), v V ,
init0 (w) = init(u).
goal0 = goal.
Let A0 consist following groups operators:
1. Let A0 contain operators u 6 vars(pre(a)) v 6 vars(post(a)).
2. Let A0 contain operator a[u/w] every operator
u vars(pre(a)) v vars(post(a)).
3. Let A0 contain operator copy(u, w, x) = hu = x ; w = xi every value
x D(v).
operators group 1 original operators corresponding edges
CG() except (u, v). operators group 2 operators corresponding
edge (u, v) modified instead correspond new edge (w, v). operators
group 3 correspond new edge (u, w) defined variable w
mimic variable u. Clearly, polynomial-time construction CG(0 ) edge
subdivision CG(). remains prove 0 plan plan.
If: Suppose P = a1 , . . . , plan . Construct new operator sequence P 0
A0 P follows: First, ai P u vars(pre(ai )) v
vars(post(ai )), replace ai ai [u/w]. Then, ai P u vars(post(ai )),
601

fiBackstrom & Jonsson

let x = post(ai )(u) add operator copy(u, w, x) ai ai+1 . resulting
sequence P 0 plan 0 .
if: Suppose P = a1 , . . . , plan 0 . Define corresponding state sequence
s0 , . . . , sn s0 = init0 si = s0 [a1 , . . . , ai ] (1 n). Without losing
generality, assume P shortest plan 0 , implies ai applicable
si1 every (1 n). Define three variable sets C0 , C1 C2 Lemma 19
C0 = {w}, v C1 u C2 . define corrsponding partition {A0 , A1 , A2 }
A0 , i.e. Ai = {a A0 | vars(post(a)) Ci } (0 2). A0 contains copy
operators nothing else. proving main result direction, first prove
following auxiliary result:
According Lemma 19 assume every longest subsequence ak , . . . , a`
contain operator A0 form ak , . . . , , am+1 , . . . , a`
ak , . . . , A1 am+1 , . . . , a` A2 . Since longest sequence, must
hold either (1) k = 1 (2) ak1 A0 . case (1) sk1 = s0 = init0 ,
sk1 (u) = sk1 (w) since init0 (u) = init0 (w). case (2) operator ak1 = copy(u, w, x)
x sk1 (w) = sk2 (u) = x. Hence, sk1 (u) = sk1 (w) = x since ak1
change u. is, either case sk1 (u) = sk1 (w). Furthermore,
(k m) holds si (C0 C2 ) = sk1 (C0 C2 ) since ai A1 . follows
si (u) = si (w) (k m). Now, every (k `), w vars(pre(ai ))
ai must form a[u/w], A, v vars(pre(ai )) definition. Hence,
ai A1 follows si1 (u) = si1 (w). Since proof holds longest
subsequences containing operator A0 conclude following,
used below:
(*) operator ai P ai = a[u/w] A, holds
si1 (u) = si1 (w).
prove main result direction, plan since 0
plan. constructing plan P 00 P two steps. First construct
intermediate operator sequence P 0 construct plan P 00 P 0 . sequence
P 0 technically plan either 0 , intermediate step makes proof
clearer. Temporarily introduce virtual dummy operator dum precondition
postcondition, i.e. applicable state effect. construct
new operator sequence P 0 = b1 , . . . , bn {dum} follows:
ai A, bi = ai .
ai copy operator, bi = dum.
Otherwise, ai = a[u/w] operator A, let bi operator a.
Define corresponding state sequence t0 , . . . , tn t0 = init0 ti = t0 [b1 , . . . , bi ]
(1 n). claim ti V = si V (0 n). Proof induction
i:
Basis: t0 = s0 definition.
Induction: Suppose ti1 V = si1 V (1 n). three cases:
(1) ai = bi ai A. w pre- postcondition either ai bi
bi applicable ti1 since ai applicable si1 ti1 V = si1 V assumption.
Furthermore, ti V = ti1 [bi ] V = si1 [ai ] V = si V .
602

fiA Refined View Causal Graphs Component Sizes

(2) ai copy operator bi = dum. immediate definition bi
applicable ti1 ti = ti1 . Furthermore, vars(post(ai )) V =
si V = si1 V . Since ti1 V = si1 V assumption thus follows ti V = si V .
(3) ai bi [u/w] bi A. follows (*) si1 (w) = si1 (u), si1 (w) =
ti1 (u) since u V ti1 V = si1 V assumption. Since ai applicable si1 ,
pre(ai )(w) = pre(bi )(u) pre(ai )(x) = pre(bi )(x) variables V \{u}, follows
bi applicable ti1 . definition, vars(post(bi )) = vars(post(ai )) = {v}, since ai
bi must unary, thus follows definition post(bi ) = post(ai ).
Hence, follows ti V = si V , since ti1 V = si1 V assumption.
thus shown ti V = si V (0 n). Furthermore, clearly
ti = ti1 bi = dum. follows create plan P 00
removing dummy operators P 0 .
conclude solution 0 solution.
finally need following observations 3SAT instances. Let F 3SAT
formula n variables clauses. contains repeated clauses,

n
8n3 and, thus, ( )1/3 n 3m.
3
8
Furthermore, F represented list 3m literals requires 3m(1 + log n)
3m(1 + log 3m) bits, plus overhead. Hence, F represented cm2 bits,
constant c, later use upper bound 40m3 , safe.
note reduction used proof Lemma 6 transforms 3SAT
instance n variables clauses planning instance N = (2m + 4)n
variables. However, n 3m N (2m + 4) 3m = 6m2 + 12m, safely
overestimated N 18m2 .
6.3 Main Theorem
prepared state prove main theorem section. follows
proof Theorem 14 in-deg(C), out-deg(C) upath-length(C) bounded
class C graphs, cc-size(C) bounded. case immediate Theorem 3
planning tractable C. begs question happens parameters
bounded constant, yet bounded slow-growing function? consider
case allowed grow slowly, long polynomially related
instance size. Since noted practical planning problems typically
causal graph every size, require every graph G C
must larger graph G0 C size p(|G|), polynomial p.
define parameter (G) = max{upath-length(G), in-deg(G), out-deg(G)}, require
(G) ||G|| polynomially related. turns planning still hard
restrictions, following theorem says.
Theorem 21. Let p q increasing polynomials natural numbers. Let C
class directed graphs containing subset weakly connected graphs G1 , G2 , G3 , . . .
that:
1. |V (G1 )| p(q(1)),
|V (Gi1 )| < |V (Gi )| p(|V (Gi1 )|), > 1,
603

fiBackstrom & Jonsson

2. |V (Gi )| q( (Gi )), 1.
PlanExist(C) polynomial-time solvable, polynomial hierarchy collapses. result holds even restricted operators 2 preconditions 1 postcondition
graphs C acyclic.
Proof. Let G1 , G2 , G3 , . . . sequence weakly connected graphs C assumed
theorem. Let H1 , H2 , H3 , . . . sequence graphs defined follows: > 0,
Hi = Gj smallest j q(i) |V (Gj )|.
first prove underestimates (Hi ). Combining requirement q(i)
|V (Gj )| condition 2 theorem, |V (Gj )| q( (Gj )), get q(i) |V (Gj )|
q( (Gj )). Since Hi = Gj get q(i) |V (Hi )| q( (Hi )), is, (Hi ).
follows |V (Hi )| holds.
prove |V (Hi )| polynomially bounded p(q(i)). Since j choosen
smallest value satisfying q(i) |V (Gj )|, must either j = 1 |V (Gj1 )| <
q(i). j = 1, Hi = Gj = G1 |V (G1 )| p(q(1)) condition 1 theorem.
Hence, |V (Hi )| = |V (G1 )| p(q(1)) p(q(i)), since p q increasing. Otherwise,
j > 1, condition 1 lemma says |V (Gj )| p(|V (Gj1 )|). Combining
inequality |V (Gj1 )| < q(i) yields |V (Gj )| p(|V (Gj1 )|) < p(q(i)),
is, |V (Hi )| p(q(i)) since Hi = Gj . Combining previous result
|V (Hi )| construction Hi yields H1 , H2 , H3 sequence graphs
non-decreasing unbounded size.
Now, define sequence A0 , A1 , A2 , . . . tuples 0, either
following holds:
1. in-deg(Hi ) Ai = (in-deg, Hi , Xi ) Xi subgraph Hi Xi ' Siin .
2. out-deg(Hi ) Ai = (out-deg, Hi , Xi ) Xi subgraph Hi
Xi ' Siout .
3. upath-length(Hi ) Ai = (upath-length, Hi , Xi ) Xi subgraph Hi
Xi polypath length i.
every > 0, least one three cases must hold since (Hi ).
Define advice-taking Turing machine uses sequence A1 , A2 , A3 , . . .
advice takes 3SAT formulae input. Assume representation formula
F padded size 40m3 bits, number clauses. Although somewhat
redundant, still reasonable encoding sense Garey Johnson (1979).
Let work follows. Let F input formula n variables clauses
let = ||F || = 40m3 . advice = (x, Ht , Xt ). First constructs planning
instance F . three cases depending x:
x = in-deg: construction, Xt subgraph Ht Ht ' Stin . Since = 40m3
n 3m, follows n t, Xt contains subgraph H 0 H 0 ' Snin .
Construct F way proof Lemma 4, using vertices H 0
variables. Then, CG(F ) = H 0 .
x = out-deg: Analogous previous case, constructing F according proof
Lemma 5 instead.
604

fiA Refined View Causal Graphs Component Sizes

x = upath-length: construction, Xt subgraph Ht polypath length
= 40m3 . Suppose Xt contains less sinks + 1 sources
path-length(Xt ) < 18m2 . follows Proposition 1
|V (Xt )| < 2m 18m2 + 1 = 36m3 + 1 < 40m3 = t.
However, contradicts construction Xt must either contain directed path
length 18m2 least sinks + 1 sources.
1. Xt contains subgraph H 0 directed path length 18m2 ,
construct planning instance F according proof Lemma 6, using
vertices H 0 variables. Then, CG(F ) ' H 0 .
2. Xt contains subgraph H 0 polypath sinks m+1 sources,
construct planning instance
F according proof Lemma 7, us0
+1
ing variables H variables. Then, CG(
F ) ' Fm . graph
fence, i.e. polypath directed paths length 1. path
stretched directed path arbitrary length repeatedly applying
Lemma 20. graph H 0 polypath used template
paths CG(
F ) stretch much order get graph
0
isomorphic H . Instance
F thus modified new instance F
CG(F ) ' H 0 .
constructions done polynomial time, cases, F
solution F satisfiable. Furthermore, CG(F ) isomorphic subgraph
Ht four cases. According Lemma 17 thus possible extend F new
+
+
planning instance +
F CG(F ) ' Ht F solution
solution. extension done polynomial time according lemma.
Since PlanExist(C) solved polynomial time assumption theorem,
thus follows solve 3SAT polynomial time. However, implies
NP P/poly, impossible unless polynomial hierarchy collapses (Theorem 16).
see result holds even operators consideration 2
preconditions 1 postcondition, simply note restriction holds reductions
used underlying NP-hardness proofs Section 4. Similarly, acyclicity restriction
holds since result based in-stars, out-stars polypaths,
acyclic graphs.
Recall generic blocks world encoding discussed beginning
section. class causal graphs blocks-world instances satisfies requirements Theorem 21, means PlanExist(D) likely tractable. However,
finding non-optimal plans blocks world tractable; plan length twice
length optimal plan found polynomial time (Gupta & Nau, 1992). is,
likely difficult problems blocks world happen exactly
causal graphs, illustrates complexity generic planning problem
cannot deduced corresponding class causal graphs alone.
605

fiBackstrom & Jonsson

7. NP-Hard NP-Intermediate Classes
theorem Chen Gimenez (2010) states crisp complexity-theoretic borderline:
component sizes bounded constant, planning polynomial-time solvable
and, otherwise, planning polynomial-time solvable. exploited extra
constraint, SP-closure, able prove NP-hardness, leaves greyzone
polynomial cases NP-hard ones. longer require classes SPclosed, longer obviously NP-hard even components unbounded.
natural question arises, say something middle ground?
instance, say something NP-intermediate cases may look
borderline NP-hard NP-intermediate is? Although seem
likely could find results characterize borderline exactly,
least give partial answers questions. proving two theorems
related growth rate components. first shows planning still
NP-hard components grow O(|V (G)|1/k ) integers k, second one shows
planning likely NP-intermediate components grow polylogarithmically.
Theorem 22. every constant integer k > 1, class Gk graphs
cc-size(G) |V (G)|1/k G Gk PlanExist(Gk ) NP-hard.
Proof. Let k > 1 arbitrary integer. Construct graph class Gk = {G1 , G2 , G3 , . . .}
follows. > 0, let Gm mk1 components, isomorphic dPm ,
i.e. |V (Gm )| = mk components size = |V (Gm )|1/k . prove NP-hardness
PlanExist(Gk ) reduction PlanExist(dP). Let arbitrary planning instance
CG() dP. CG() = dPm > 0. Construct new instance 0
consists mk1 renamed copies . clearly polynomial time construction
since k constant < ||||. Furthermore, CG(0 ) isomorphic Gm 0
solution solution. Hence, polynomial reduction follows
Lemma 6 PlanExist(Gk ) NP-hard.
Obviously, size graphs exponential k.
second result must conditioned assumption exponential time
hypothesis (Impagliazzo & Paturi, 2001; Impagliazzo, Paturi, & Zane, 2001) holds.
hypothesis conjecture stated follows.
Definition 23. constant integers k > 2, let sk infimum real numbers
k-SAT solved O(2n ) time, n number variables
instance. exponential time hypothesis (ETH) conjecture sk > 0 k > 2.
Informally, ETH says satisfiability cannot solved subexponential time. ETH
arbitrarily choosen concept, quite strong assumption allows
defining theory similar one NP-completeness. concept called SERF
(subexponential reduction family) reduction preserves subexponential time solvability. concept called SERF-completeness similar NP-completeness,
based SERF reductions. is, subclass NP-complete problems
SERF-complete, meaning SERF reduced other.
Hence, one solved subexponential time, can.
606

fiA Refined View Causal Graphs Component Sizes

Theorem 24. constant integers k > 0 classes C directed graphs,
cc-size(G) logk |V (G)| G C, PlanExist(C) NP-hard unless ETH
false.
Proof. Let k > 0 arbitrary integer. Let arbitrary planning instance n
variables maximum domain size cc-size(CG()) c. components correspond independent subinstances, thus solved separately. component
state space size dc less, plan corresponding subinstance found
O(d2c ) time, using Dijkstras algorithm. Since n components, whole
instance solved O(nd2c ) time. However, follows standard assumptions
reasonable encodings n |||| ||||, looser bound
solved O(x x2c ) = O(x1+2c ) time, x = ||||.
Suppose PlanExist(C) NP-hard. polynomial reduction 3SAT
PlanExist(C). Furthermore, size 3SAT instance polynomially bounded
number variables. Hence, must polynomial p 3SAT instance
n variables, corresponding planning instance size |||| p(n).
Since number variables upper bounded ||||, follows assumption component size upper bounded logk |||| logk p(n). Hence,
k
solved O(p(n)1+2 log p(n) ) time, according earlier observation,
p(n)1+2 log

k

p(n)

= (2log p(n) )1+2 log

k

p(n)

(2(1+2 log

k

p(n)) logk p(n)

) 23 log

2k

2k

p(n)

.

2k

Furthermore, logk p(n) O(logk n), since p polynomial, 23 log p(n) 2O(log n)
2k
follows solved 2O(log n) time. However, solved 2n
time arbitrarily small , contradicts ETH. follows PlanExist(C) cannot
NP-hard unless ETH false.
Since components unbounded, problem likely solvable polynomial
time either. thus NP-intermediate problem double assumption
W[1] 6 nu-FPT ETH holds.
Theorems 22 24 together thus tell us something borderline
NP-intermediate NP-hard graph classes is. However, crisp distinction;
asymptotically, quite gap polylogarithmic functions root
functions (i.e. functions form x1/k ). One may, instance, note function
1

f (n) = 2(log n)

1
(log log n)c

lies within gap whenever 0 < c < 1.

8. Discussion
SP-closed graph classes appealing properties fit well concept stronger
subgraph-closed weaker minor-closed. give partial characterization
borderline NP-hardness lies. However, noted earlier, possible define
types graph classes imply planning NP-hard. One example
family G1 , G2 , G3 , . . . classes proof Theorem 22. Another specialized
and, perhaps, contrived class following, intended give contrast SP-closure
concept Gk classes.
607

fiBackstrom & Jonsson

tournament directed graph formed giving directions edge complete
graph. Let denote set tournaments note SP-closed. However,
tournaments Hamiltonian graphs (Redei, 1934) tournament n vertices,
path-length(T ) = n 1. Furthermore, path length n 1 computed
polynomial time (Bar-Noy & Naor, 1990).
Assume given 3SAT formula F n variables clauses. Let ` =
(2m + 4)n, i.e. ` polynomially bounded F . According Lemma 6 thus
construct planning instance F polynomial time
1. F contains ` variables,
2. CG(F ) ' dP` ,
3. F solution F satisfiable.
Choose arbitrary tournament ` vertices T. Find path length `1
identify CG(F ). add dummy operators corresponding remaining
edges . thus shown polynomial-time transformation 3SAT
PlanExist(T), PlanExist(T) NP-hard. One may note variations
technique used proving PlanExist(T0 ) NP-hard many different
T0 T.
considered domain sizes tractable restrictions article,
note Theorem 24 may give ideas look tractable cases. Consider
case variable domains bounded size constant k
cc-size(G) log V (G). Using first part proof, see planning solved
O(n k 2 log n ) time. However, k 2 log n = (2log k )2 log n = (2log n )2 log k = n2 log k ,
polynomial since k constant. is, planning tractable restricted case. Even
though observation straightforward, interesting contrast Theorem 24.
suggests even larger tractable subgraphs consider additional
restrictions planning instances.
explicitly commented sufficient number pre- postconditions
various results, alternative characterizations might relevant. would bear far list possibilities, let suffice one example.
concept prevail conditions, i.e. preconditions variables changed
operator, originate SAS+ formalism (Backstrom & Nebel, 1995)
recently considered context causal graphs. Gimenez Jonsson (2012)
refer operator k-dependent precondition k variables
change. may note proofs Lemmata 17 20 introduce
operators 1-dependent, most. Since proof Theorem 21 impose
restrictions original planning instance, follows theorem
holds operators 1-dependent, most.
final question, one might wonder practical use know
planning tractable, NP-intermediate, severely limited component sizes? all,
planning instances likely causal graph weakly connected,
is, whole graph one single component. answer question, first important
observation make complexity planning instances directly related
complexity planning components separately.
608

fiA Refined View Causal Graphs Component Sizes

linearly (in number variables) many components. planning solved
polynomial time components instance, solved polynomial time
whole instance. Conversely, planning cannot solved polynomial time
whole instance, least one component polynomial-time solvable.
is, complexity results instances components directly related
other. words, results relevant methods artificially split causal
graph components, one way another. Examples causal-graph heuristic
Helmert (2006a), factored planning (Brafman & Domshlak, 2006) structural pattern
data bases (Katz & Domshlak, 2010).

Acknowledgments
anonymous reviewers provided valuable comments suggestions improving
article.

References
Backstrom, C., & Nebel, B. (1995). Complexity results SAS+ planning. Computational
Intelligence, 11, 625656.
Bar-Noy, A., & Naor, J. (1990). Sorting, minimal feedback sets, Hamilton paths
tournaments. SIAM Journal Discrete Mathematics, 3 (1), 720.
Biggs, N. (1993). Algebraic Graph Theory. Cambridge Univ. Press. 2nd ed.
Bodirsky, M., & Grohe, M. (2008). Non-dichotomies constraint satisfaction complexity.
Proceedings 35th International Colloquium Automata, Languages
Programming (ICALP 2008), Reykjavik, Iceland, pp. 184196.
Brafman, R. I., & Domshlak, C. (2003). Structure complexity planning unary
operators. Journal Artificial Intelligence Research, 18, 315349.
Brafman, R. I., & Domshlak, C. (2006). Factored planning: How, when, not.
Proceedings 21st National Conference Artificial Intelligence (AAAI 2006),
Boston, MA, USA, pp. 809814. AAAI Press.
Chen, H., & Gimenez, O. (2010). Causal graphs structurally restricted planning. Journal Computer Systems Science, 76 (7), 579592.
Domshlak, C., & Dinitz, Y. (2001a). Multi-agent off-line coordination: Structure complexity. Proceedings 6th European Conference Planning (ECP01), Toledo,
Spain.
Domshlak, C., & Dinitz, Y. (2001b). Multi-agent off-line coordination: Structure complexity. Tech. rep., Department Computer Science, Ben-Gurion University. CS-0104.
Downey, R. G., & Fellows, M. R. (1999). Parameterized Complexity. Monographs Computer Science. Springer, New York.
Flum, J., & Grohe, M. (2006). Parameterized Complexity Theory, Vol. XIV Texts
Theoretical Computer Science. EATCS Series. Springer, Berlin.
609

fiBackstrom & Jonsson

Garey, M. R., & Johnson, D. S. (1979). Computers Intractability: Guide Theory
NP-Completeness. W. H. Freeman, New York.
Gimenez, O., & Jonsson, A. (2008). complexity planning problems simple
causal graphs. Journal Artificial Intelligence Research, 31, 319351.
Gimenez, O., & Jonsson, A. (2009). Planning chain causal graphs variables
domains size 5 NP-hard. Journal Artificial Intelligence Research, 34, 675706.
Gimenez, O., & Jonsson, A. (2012). influence k-dependence complexity
planning. Artificial Intelligence, 177-179, 2545.
Gupta, N., & Nau, D. S. (1992). complexity blocks-world planning. Artificial
Intelligence, 56 (2-3), 223254.
Helmert, M. (2003). Complexity results standard benchmark domains planning.
Artificial Intelligence, 143 (2), 219262.
Helmert, M. (2004). planning heuristic based causal graph analysis. Proceedings
14th International Conference Automated Planning Scheduling (ICAPS
2004), Whistler, BC, Canada, pp. 161170. AAAI Press.
Helmert, M. (2006a). Fast Downward planning system. Journal Artificial Intelligence
Research, 26, 191246.
Helmert, M. (2006b). New complexity results classical planning benchmarks. Proceedings 16th International Conference Automated Planning Scheduling
(ICAPS 2006), Cumbria, UK, pp. 5262. AAAI Press.
Impagliazzo, R., & Paturi, R. (2001). complexity k-SAT. Journal Computer
System Science, 62 (2), 367375.
Impagliazzo, R., Paturi, R., & Zane, F. (2001). problems strongly exponential
complexity?. Journal Computer System Science, 63 (4), 512530.
Jonsson, A. (2009). role macros tractable planning. Journal Artificial Intelligence Research, 36, 471511.
Jonsson, P., & Backstrom, C. (1998a). State-variable planning structural restrictions:
Algorithms complexity. Artificial Intelligence, 100 (1-2), 125176.
Jonsson, P., & Backstrom, C. (1998b). Tractable plan existence imply tractable
plan generation. Annals Mathematics Artificial Intelligence, 22 (3-4), 281296.
Karp, R. M., & Lipton, R. J. (1980). connections nonuniform uniform complexity classes. Proceedings 12th ACM Symposium Theory
Computing (STOC80), Los Angeles, CA, USA, pp. 302309.
Katz, M., & Domshlak, C. (2007). Structural patterns tractable sequentially-optimal
planning. Proceedings 17th International Conference Automated Planning
Scheduling (ICAPS 2007), Providence, RI, USA, pp. 200207. AAAI Press.
Katz, M., & Domshlak, C. (2008). New islands tractability cost-optimal planning.
Journal Artificial Intelligence Research, 32, 203288.
Katz, M., & Domshlak, C. (2010). Implicit abstraction heuristics. Journal Artificial
Intelligence Research, 39, 51126.
610

fiA Refined View Causal Graphs Component Sizes

Katz, M., Hoffmann, J., & Domshlak, C. (2013). said need relax variables?. Proceedings 23rd International Conference Automated Planning
Scheduling (ICAPS 2013), Rome, Italy, 126134. AAAI Press.
Katz, M., & Keyder, E. (2012). Structural patterns beyond forks: Extending complexity
boundaries classical planning. Proceedings 26th AAAI Conference
Artificial Intelligence (AAAI 2012), Toronto, ON, Canada. AAAI Press.
Knoblock, C. A. (1994). Automatically generating abstractions planning. Artificial
Intelligence, 68 (2), 243302.
Kuhn, D., Osthus, D., & Young, A. (2008). note complete subdivisions digraphs
large outdegree. Journal Graph Theory, 57 (1), 16.
Ladner, R. E. (1975). structure polynomial time reducibility. Journal
ACM, 22 (1), 155171.
Lovasz, L. (2005). Graph minor theory. Bulletin AMS, 43 (1), 7586.
Mohar, B. (2006). ... graph minor. Notices AMS, 53 (3), 338339.
Redei, L. (1934). Ein kombinatorischer Satz. Acta Litteraria Szeged, 7, 3943.
Wehrle, M., & Helmert, M. (2009). causal graph revisited directed model checking.
Proceedings Static Analysis, 16th International Symposium (SAS09), Los
Angeles, CA, USA, Vol. 5673 LNCS, pp. 86101. Springer.
Williams, B., & Nayak, P. P. (1997). reactive planner model-based executive.
Proceedings 15th International Joint Conference Artificial Intelligence
(IJCAI97), Nagoya, Japan, pp. 11781185.

611


