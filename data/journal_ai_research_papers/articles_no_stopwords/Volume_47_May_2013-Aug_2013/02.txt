Journal Artificial Intelligence Research 47 (2013) 71-93

Submitted 11/12; published 05/13

Identifying Class Maxi-Consistent Operators Argumentation
Srdjan Vesic

VESIC @ CRIL . FR

CRIL - CNRS
Rue Jean Souvraz SP 18
F 62307 Lens Cedex
FRANCE

Abstract
Dungs abstract argumentation theory seen general framework non-monotonic
reasoning. important question then: class logics subsumed
instantiations theory? goal paper identify study large class
logic-based instantiations Dungs theory correspond maxi-consistent operator, i.e.
function returns maximal consistent subsets inconsistent knowledge base.
words, study class instantiations every extension argumentation system
corresponds exactly one maximal consistent subset knowledge base. show
attack relation belonging class must conflict-dependent, must valid, must
conflict-complete, must symmetric etc. Then, show attack relations serve
lower upper bounds class (e.g. attack relation contains canonical undercut
member class). using results, show existing attack relations whether
belong class. define new attack relations members
class. Finally, interpret results discuss general questions, like: added
value argumentation setting? believe work first step towards achieving
long-term goal, better understand role argumentation and, particularly,
expressivity logic-based instantiations Dung-style argumentation frameworks.

1. Introduction
question whether Dungs (1995) abstract theory used general framework nonmonotonic reasoning drawn particular amount attention among researchers artificial
intelligence. precisely, question is: existing new approaches reasoning seen
instantiations Dungs theory? certainly general question. Furthermore, different
approaches suppose available knowledge represented different form. paper studies problem setting one given finite inconsistent set classical propositional logic
formulae, refer knowledge base. number approaches dealing
inconsistent information: notable example paraconsistent logics (Priest, 2002) one
able draw (but all) conclusions inconsistent set formulae. Indeed,
paraconsistent logic allows subset inferences could obtained using classical logic
knowledge. examples dealing inconsistent knowledge include belief
revision (Gardenfors, 1988), belief merging (Konieczny & Perez, 2011) voting (Arrow, Sen, &
Suzumura, 2002). completely precise, note approaches one given
multiset instead set, example several voters express knowledge preferences number agents stating / voting proposition important. However,
paper, suppose information represented form set.
c
2013
AI Access Foundation. rights reserved.

fiV ESIC

Generally speaking, call operator function provides way go inconsistent knowledge base set subsets knowledge base. Examples operators are:
function returning maximal set inclusion consistent subsets knowledge base, called maxiconsistent operator, function returning maximal cardinality consistent subsets knowledge
base, called maxi-card operator, function returning consistent subsets knowledge base...
understand extent Dungs theory used general framework
reasoning, essential study link result obtained applying operator
knowledge base extensions argumentation framework F = (Arg(), R),
set , denote Arg(S) set arguments built S, R
relation used identifying attacks arguments. papers (Cayrol, 1995; Caminada & Amgoud, 2007; Amgoud & Besnard, 2009, 2010; Amgoud & Vesic, 2010; Gorogiannis
& Hunter, 2011) studying notions somehow related link knowledge
base corresponding argumentation framework. However, since work Dung (1995),
almost papers studying link operator instantiation Dungs theory. Cayrol (1995) showed instantiation Dungs theory using stable semantics direct
undercut attack relation, corresponds maxi-consistent operator. argumentation community,
one-to-one correspondence sometimes identified main objection pure logic-based
argumentation, additional value constructing argumentation framework
said questionable (since computing extensions applying maxiconsistent operator). However, recent work Vesic van der Torre (2012) shows
exists large class logic-based instantiations Dungs abstract theory two interesting
features: (i) returns extensions correspond maximal consistent subsets initial
knowledge base, (ii) result satisfies basic argumentation postulates (Caminada & Amgoud,
2007), e.g. consistency, closure... paper shows space logic-based instantiations
Dungs theory much larger believed.
previous result makes question class operators viewed
instantiations Dungs theory? even relevant research topic. aim
giving broad overview class. First note that, interestingly, rather big class
instantiations Dungs theory returning inconsistent results, showed Caminada Amgoud
(2007). However, one would normally prefer avoid type behaviour, study class
instantiations returning consistent results.1 Thus, long-term goal identify whole
class instantiations Dungs theory yield consistent result. However, certainly
hard task. start noticing that, given set , common well-known way deal
inconsistent information use maxi-consistent operator, i.e. select maximal consistent
subsets . Also, conjecture one biggest2 sub-classes class instantiations
returning consistent result class instantiations corresponding maxi-consistent operator.
first goal, main goal paper, study class. (Note
general approach would consider set maxi-consistent subsets selection function
f among maxi-consistent subsets. Thus, maxi-consistent sets would used
reasoning. However, present paper studies case maxi-consistent subsets
taken account since already captures significant number systems.)
1. Note consensus regarding postulates (e.g. indirect consistency), postulates
(e.g. direct consistency) enjoy much wider acceptance.
2. informally, sense: number known instantiations

72

fiI DENTIFYING C LASS AXI -C ONSISTENT PERATORS RGUMENTATION

particularly, paper aims answering following questions: properties
attack relations semantics used instantiations Dungs theory correspond maxiconsistent operators? necessary sufficient conditions attack relation
belongs class (under given semantics)? properties satisfy: must (not)
conflict-dependent, valid, symmetric, ... ? identify sub-classes attack relations belonging / belonging class? find lower / upper bound (in terms set
inclusion) class attack relations? existing (in literature) attack relations belong
class semantics? new attack relations belonging class?
paper organised follows: Section 2 introduces main notions argumentation theory use rest paper. Section 3 formally defines class instantiations corresponding maxi-consistent operator. Section 4 shows properties satisfied attack relations
belonging class. Section 5 identifies several classes attack relations (not-)corresponding
maxi-consistent operator. Section 6 shows (to best knowledge) existing attack relations literature whether belong class, defines new attack relation
member class. last section concludes discusses related work.

2. Basics Argumentation
already mentioned, paper supposes one given set classical propositional logic
formulae . use well-known (e.g. Besnard & Hunter, 2001; Amgoud & Cayrol, 2002;
Gorogiannis & Hunter, 2011) logic-based approach instantiating Dungs theory. L denotes
set well-formed formulae, ` stands classical entailment, logical equivalence.
use notation MC() set maximal consistent subsets .
logical argument defined pair (support, conclusion).
Definition 1 (Argument). argument pair (, ) minimal (for set
inclusion) consistent set formulae ` .
argument = (, ), use function Supp(a) = denote support
Conc(a) = denote conclusion.
Example 1. Let = {, , }. = ({, }, ), b = ({ }, )
c = ({, }, ) arguments constructed . example,
Supp(a) = {, } Conc(a) = .
given set formulae S, denote Arg(S) set arguments constructed
S. Formally, Arg(S) = {a | argument Supp(a) S}. Let Arg(L) denote set
arguments constructedSfrom language propositional logic. given set
arguments E, denote Base(E) = aE Supp(a). suppose function Arg defined L
function Base defined Arg(L); slightly abusing notation, sometimes write
Arg (respectively Base) restriction functions set formulae (respectively
arguments).
Definition 2 (Argumentation system). argumentation system (AS) pair (A, R)
Arg(L) set arguments R binary relation. pair (a, b) R, say
attacks b. sometimes use notation aRb instead (a, b) R.
73

fiV ESIC

order simplify notation, explicitly mention argumentation system
clear context argumentation system refer to. Since arguments built
formulae, suppose attack relation defined specifying condition every
two arguments b, attacks b condition definition
attack relation satisfied. example, condition conclusion logically
equivalent negation conclusion b. suppose attack relations defined
set Arg(L) Arg(L), every set Arg(L), use restriction attack
relation set AA. why, order simplify notation, simply write R attack
relation defined set Arg(L) Arg(L) well restriction attack relation
every set A, Arg(L).
order determine mutually acceptable sets arguments, different semantics
introduced argumentation. first introduce basic notions conflict-freeness defence.
Definition 3 (Conflict-free, defence). Let F = (A, R) AS, E A.
E conflict-free exist arguments a, b E R b
E defends every b b R exists c E
c R b.
Let us define commonly used semantics.
Definition 4 (Acceptability semantics). Let F = (A, R) B A. say set B
admissible conflict-free defends elements.
B complete extension B defends arguments contains
arguments defends.
B preferred extension maximal (with respect set inclusion) admissible set.
B stable extension B conflict-free \ B, exists b B
b R a.
B semi-stable extension B complete extension union set
B set arguments attacked B maximal (for set inclusion).
B grounded extension B minimal (for set inclusion) complete extension.
B ideal extension B maximal (for set inclusion) admissible set contained
every preferred extension.
argumentation system F = (A, R) denote Extx (F); or, slight abuse
notation, Extx (A, R) set extensions respect semantics x. use abbreviations
c, p, s, ss, g respectively complete, preferred, stable, semi-stable, grounded ideal
semantics. example, Extp (F) denotes set preferred extensions argumentation system F.
Example 2. Let F = (A, R) argumentation framework = {a, b, c, d} R =
{(b, c), (c, b), (b, d), (c, d)}. two preferred/stable/semi-stable extensions: {a, b} {a, c};
three complete extensions: {a}, {a, b} {a, c}; one grounded/ideal extension: {a}.
74

fiI DENTIFYING C LASS AXI -C ONSISTENT PERATORS RGUMENTATION

3. Defining Problem Setting
now, specified to, knowledge base , construct argumentation system F =
(Arg(), R), then, using chosen semantics, calculate extensions. Since components
system except semantics attack relation fixed, whether instantiation
corresponds maxi-consistent operator depends exclusively two components. next
definition provides formal definition mean saying instantiation Dungs
framework corresponds maxi-consistent operator. idea function Arg
bijection MC() extensions corresponding argumentation system.
Definition 5 (MC Ext). Let x argumentation semantics. say attack relation R
satisfies (MC Extx ) every finite set propositional formulae
Arg bijection MC() Extx (Arg(), R)
means every set MC(), holds Arg(S) Ext(Arg(), R)
every E Ext(Arg(), R), exists MC() E = Arg(S). example, say
attack relation R satisfies (MC Extc ) every finite , Arg
bijection MC() Extc (Arg(), R). Sometimes, clear context
semantics refer semantics important, use simplified notation
(MC Ext). say attack relation R falsifies (MC Extx ) R satisfy
(MC Extx ). following example shows attack relation satisfy (MC Exts ).
Example 3. Consider attack relation known defeating rebut, denoted Rdr defined
follows: two arguments b, say attacks b write aRdr b
Conc(a) ` Conc(b). attack relation falsifies (MC Exts ). see why, sufficient find
set formulae Arg bijection MC() (Arg(), Rdr ). end,
consider = { , } denote F = (Arg(), Rdr ). see MC() = {S1 , S2 }
S1 = { } S2 = { }. Denote E1 = Arg(S1 ) E2 = Arg(S2 ). Exts (F) 6=
{E1 , E2 } Rdr satisfy (MC Exts ). Consider argument = ({ }, ),
note E1 . Observe every argument b Arg(), bRdr
Conc(b) ` ( ). words, every argument b Arg(), b attacks
Conc(b) ` . Recall Definition 1 know every argument b,
Supp(b) ` Conc(b). Thus, every argument b Arg(), bRdr Supp(b) ` .
Since = { , } argument b Arg() Supp(b) ` .
Thus, argument attacked argument E2 . means E2 stable extension
F. Consequently, Arg bijection MC() Exts (F). Hence, Rdr falsifies
(MC Exts ).
3.1 Complete Incomplete Systems
two ways study link instantiated argumentation system F (containing
arguments attacks them) corresponding knowledge base (containing formulae). first scenario follows:
choose attack relation R semantics x
start finite knowledge base
75

fiV ESIC

consider system F = (Arg(), R), containing arguments built
compare result obtained using operator one obtained calculating
extensions F
case, say obtained argumentation system complete. Every complete system
infinite number arguments, every complete system F, exists finite system
F 0 F F 0 equivalent. formally define equivalence argumentation
systems topic present paper; details reader invited consult
literature subject (Amgoud, Besnard, & Vesic, 2011).
second possibility converse:
given attack relation R semantics x,
start argumentation system F = (A, R),
define set formulae used supports arguments F, is, define
def
= Base(A)
compare result obtained using operator one obtained calculating
extensions F
obtained argumentation system may incomplete, sense =
6 Arg(Base(A)).
important difference two scenarios. Namely, first case,
arguments built considered calculating Extx (F). second case,
contains formulae A, F, formulae equally represented. Let us illustrate
situation.
Example 4. Let R defined as: every a, b Arg(L), (a, b) R exists
Supp(b) Conc(a) . Let us use preferred semantics. Let F = (A, R)
= {a, b} = ({, }, ) b = ({}, ). case, since b attacks
vice versa, extension E = {b}. Note conclusion accepted argument
. However, take union formulae used supports arguments F,
obtain = {, , }. two maximal consistent subsets knowledge base:
MC() = {{, }, {, }}.
clear setting similar previous example, or, generally,
second scenario, one cannot expect Arg bijection MC() Ext(A, R). But,
incomplete argumentation system stand for? obtained? conclude system
6= Arg(Base(A)) meaningless would certainly hasty. Let us consider
question detail. Namely, know missing arguments added intelligent
agent. first add missing arguments calculate extensions
complete version system? two possible answers: (1) yes, must add missing
arguments order take account available information; (2) no, since given
argumentation system arguments constructed (in case monological argumentation) uttered (in case dialogical argumentation). arguments (1) (2) make
sense different applications: first possibility corresponds case want simulate
resource unbounded agent, take account information (where information seen
76

fiI DENTIFYING C LASS AXI -C ONSISTENT PERATORS RGUMENTATION

formulae) known agent(s). Note disadvantages since so, ignore
argumentational representation problem. second possibility used want
know output argumentation system is, take account fact
arguments constructed (e.g. lack computational resources, since
given argumentation framework representing dialogue everything said).
Note numerous works 1990s (Pollock, 1992; Vreeswijk, 1997; Loui, 1998) yield
conceptual philosophical arguments supporting partial computation (i.e. incomplete systems).
important part Vreeswijks (1997) work devoted defining constructing complete
argumentation systems. Loui (1998) discusses philosophical difference demonstrative
reasoning non-demonstrative reasoning claims realistic (i.e. resource-bounded)
setting, reasons demonstrative, process disputation essential reasoning. Note, however, none frameworks instantiation Dungs system,
formalisations works differ lot framework studied paper. goal
present paper argue complete systems sense better incomplete
ones (or vice versa), study possibilities limits related instantiating Dungs abstract theory. analyse difference complete incomplete systems,
find necessary point exist, order make context research
question clear. second scenario, reasonable expect correlation
result obtained directly F. why, rest paper suppose
first scenario.

4. Properties Relations Satisfying (MCExt)
section, analyse properties attack relations satisfying (MC Ext). first show
condition satisfied, function Base : Ext(F) MC() inverse function
function Arg : MC() Ext(F).
Proposition 1. Let R attack relation x acceptability semantics. relation R satisfies
(MC Extx ) then:
every MC(), = Base(Arg(S)),
every E Extx (F), E = Arg(Base(E)).
Proof. Let finite set propositional formulae let F = (Arg(), R).
Let MC() E = Arg(S). Since R satisfies (MC Ext), E Extx (F). Let
0 = Base(E) let us suppose 6= 0 . Let us study two cases.
Let \ 0 6= 0 \ 0 . means argument E
0 Supp(a) 0
/ S, contradiction.
Let 0 \ 6= 0 0 \ S. means argument E
0 Supp(a). Contradiction 0
/ S.
Since \ 0 = 0 \ = , = 0 ; words, Base(Arg(S)) = S.
Let E Extx (F) = Base(E). Since R satisfies (MC Extx ), exists
unique 0 MC() Arg(S 0 ) = E. Let us prove = 0 .
77

fiV ESIC

Let us suppose \ 0 6= let \ 0 . means argument
E Supp(a). Contradiction fact
/ S0.
Suppose 0 \ 6= 0 0 \ S. 0 0 , conclude
exists E 0 Supp(a). Contradiction fact 0
/ S.
\ 0 = 0 \ = , conclude = 0 . Thus, Arg(Base(E)) = E.

Let us illustrate result following example.
Example 5. Consider attack relation known direct undercut, denoted Rdu defined
follows: two arguments b, say attacks b write aRdu b
exists Supp(b) Conc(a) . known direct undercut satisfies (MC Exts )
(Cayrol, 1995). Proposition 1, see every , every MC(), holds
= Base(Arg(S)) and, interestingly, every E Exts (Arg(), Rdu ),
E = Arg(Base(E)).
previous result allows easily show attack relation satisfies (MC Ext),
every extension consistent base union arguments conclusions consistent.
Corollary 1. Let R attack relation x semantics. Let R satisfy (MC Extx ) let
finite set formulae. Denote F = (Arg(), R). Then, every E Extx (F), have:
Base(E) consistent

aE Conc(a) consistent
Proof. Let E Extx (F). Since R satisfies (MC Extx ), exists MC()
E = Arg(S). Proposition 1, obtain E = Arg(Base(E)). Since Arg injective function,
every 0 MC(), E = Arg(S 0 ) = 0 . Thus, = Base(E). Consequently, Base(E)
consistent set. clear
every argument E, Base(E) ` Conc(a). Since
Base(E) consistent, aE Conc(a) consistent well.
Note use previous result show attack relation satisfy (MC Ext).
Namely, attack relation returns extensions inconsistent bases, violates (MC Ext).
Corollary 2. Let R attack relation, x acceptability semantics. exists finite
knowledge base exists extension E Extx (Arg(), R) Base(E)
inconsistent, R satisfy (MC Extx ).
4.1 Conflict-Dependence Validity
subsection, study link satisfying (MC Ext) conflict-dependence
validity. attack relation conflict-dependent whenever argument attacks another one,
union supports inconsistent (Amgoud & Besnard, 2009).
Definition 6 (Conflict-dependent). Let R Arg(L) Arg(L) attack relation. say R
conflict-dependent every a, b Arg(L), (a, b) R Supp(a) Supp(b) `
.
78

fiI DENTIFYING C LASS AXI -C ONSISTENT PERATORS RGUMENTATION

prove conflict-dependence necessary condition satisfying (MC Ext).
completely precise, specify say semantics x returns conflict-free sets
every argumentation system (A, R), every E Extx (A, R), holds E
conflict-free respect R. semantics Definition 4 return conflict-free sets.
Proposition 2. Let R attack relation x semantics returning conflict-free sets. R
satisfies (MC Extx ), R conflict-dependent.
Proof. Let us suppose contrary, i.e. let R attack relation conflict-dependent, let
knowledge base let a, b Arg() aRb Supp(a) Supp(b) consistent.
Thus, exists set MC() Supp(a)Supp(b) S. Since R satisfies (MC Extx )
E = Arg(S) extension corresponding argumentation system F = (Arg(), R).
means a, b E. Contradiction assumption x returns conflict-free extensions.
Thus, R must conflict-dependent.
proved this, know relation satisfying (MC Ext) enjoys properties
conflict-dependent relations. example, shown attack relation conflictdependent, self-attacking arguments (Amgoud & Besnard, 2009).
Corollary 3. Let R attack relation x semantics returning conflict-free sets. R satisfies
(MC Extx ) every argument Arg(L), (a, a)
/ R.
Proof. Proposition 2, R conflict-dependent. Then, self-attacking
arguments (Amgoud & Besnard, 2009, Prop. 4).
means another way identify (some the) attack relations satisfying
(MC Ext): namely, attack relation exists self-attacking argument, given
attack relation falsifies (MC Ext) semantics returning conflict-free sets. Let us study
notion validity (Amgoud & Besnard, 2010).
Definition 7 (Valid). Let R Arg(L) Arg(L) attack relation. say R valid
every E Arg(L) holds E conflict-free, Base(E) consistent.
Let us show property incompatible conflict-dependence.
Proposition 3. exists attack relation conflict-dependent valid.
Proof. Let R attack relation suppose R conflict-dependent valid. Let
= ({}, ), b = ({}, ), c = ({ }, ) let E = {a, b, c}. Since R
valid Base(E) inconsistent, E conflict-free. Since R conflict-dependent,
(a, b)
/ R, (b, a)
/ R, (a, c)
/ R, (c, a)
/ R, (b, c)
/ R, (c, b)
/ R. Thus, E conflict-free.
Contradiction.
means attack relation R satisfies (MC Ext) must exist set E
conflict-free respect R whose base inconsistent.
Corollary 4. Let R attack relation x acceptability semantics returning conflict-free
sets let R satisfy (MC Extx ). Then, R valid.
79

fiV ESIC

proof previous fact consequence Proposition 2 Proposition 3. useful
since attack relation valid, immediately conclude violates (MC Extx )
(possible) semantics returning conflict-free sets.
general level, see asking every conflict-free set consistent base
demanding. Roughly speaking, due fact attacks binary whereas minimal
conflicts may ternary (or greater cardinality). authors argue obtain consistent
result, one concentrate admissibility conflict-freeness. example, Caminada Vesic (2012) claim n-ary attacks, n 3, simulated Dungs framework
throughout notion admissibility. Thus, idea future work could study alternative
condition, every admissible set consistent base.
4.2 Satisfying (MCExt) Different Acceptability Semantics
subsection, study properties related particular semantics. show attack
relation satisfies (MC Ext) stable semantics, satisfies semi-stable semantics also.
identify conditions attack relation satisfies (MC Ext) stable semantics. provide similar result preferred semantics. identify sufficient condition
attack relation falsifies (MC Ext) complete semantics. Then, discuss case
single-extension semantics, grounded ideal.
First, suppose R satisfies (MC Exts ). means every finite set formulae ,
function Arg bijection MC() Exts (Arg(), R). Since every finite set formulae
least one maximal consistent subset (even empty set) every , must
(Arg(), R) least one stable extension. Since stable extensions, stable
semi-stable semantics coincide (Caminada, 2006). Thus, obtain following proposition.
Proposition 4. Let R attack relation. R satisfies (MC Exts ) then:
every finite set formulae F = (Arg(), R), Exts (F) = Extss (F)
R satisfies (MC Extss ).
Let us prove case stable semantics, image respect Arg every
maximal consistent set extension base every extension consistent,
attack relation question satisfies (MC Ext).
Proposition 5. Let R attack relation. every set formulae F = (Arg(), R),
have:
MC(), Arg(S) Exts (F),
E Exts (F), Base(E) consistent
R satisfies (MC Exts ).
Proof. Let us prove R satisfies (MC Exts ). already know every MC(),
Arg(S) Exts (F). Let us suppose E Exts (F) let us prove exists unique set
MC() Arg(S) = E. prove set exists, uniqueness guaranteed
since S, 0 , 6= 0 Arg(S) 6= Arg(S 0 ) trivially holds. Thus, let us prove
exists MC() Arg(S) = E. Let 0 = Base(E) let us prove 0 MC()
80

fiI DENTIFYING C LASS AXI -C ONSISTENT PERATORS RGUMENTATION

Arg(S 0 ) = E. means contradiction, suppose 0 consistent maximal
consistent set. Then, exists 00 MC() 0 00 . assumptions
proposition, E 00 = Arg(S 00 ) stable extension F. E ( E 00 . Since
stable extension proper subset another stable extension, E stable extension.
Contradiction. Thus, must 0 MC(). easy see E Arg(Base(E)) (namely,
every set arguments, applying function Arg base, obtain superset). Let
us prove Arg(S 0 ) = E. Suppose contrary. Then, E ( Arg(S 0 ). Since 0 MC()
Arg(S 0 ) Exts (F). Thus, E stable extension (since stable extension proper subset
another stable extension).
prove similar two conditions sufficient guarantee R satisfies (MC Ext)
preferred semantics.
Proposition 6. Let R attack relation. every set formulae F = (Arg(), R),
have:
MC(), Arg(S) Extp (F),
E Extp (F), Base(E) consistent
R satisfies (MC Extp ).
Proof property similar proof Proposition 5.
consequence two previous results, identify sufficient condition R
satisfies (MC Exts ) (MC Extp ).
Corollary 5. Let R attack relation. every set formulae F = (Arg(), R),
have:
MC(), Arg(S) Exts (F),
E Extp (F), Base(E) consistent
R satisfies (MC Exts ) (MC Extp ).
Proof. Since every stable extension preferred one (Dung, 1995), clear R satisfies
conditions Proposition 5 Proposition 6. applying propositions, R
satisfies (MC Exts ) (MC Extp ).
Let us show attack relation returns stable extension inconsistent base,
violates (MC Ext) stable, semi-stable, preferred complete semantics.
Proposition 7. Let R attack relation. exists finite set formulae
F = (Arg(), R) stable extension E Base(E) inconsistent, R falsifies
(MC Extx ) x {s, ss, p, c}.
Proof. supposed exists stable extension E Exts (F) Base(E) ` .
proved (Dung, 1995) every stable extension preferred complete one.
know (Caminada, 2006) E must semi-stable extension. using Corollary 2, conclude
R satisfy (MC Ext) stable, semi-stable, preferred complete semantics.
81

fiV ESIC

Let us study case complete semantics. show possible attack
relation satisfy (MC Extc ). condition use result every argument
a, formula support, , exists argument b Arg()
b attacks a.
Proposition 8. Let R attack relation every finite set formulae , every
Arg(), every Supp(a), exists exists
b Arg() (b, a) R. Then, R satisfy (MC Extc ).
Proof. prove attack relation R satisfies condition proposition,
falsifies (MC Extc ). use proof contradiction. words, plan proof
follows: first, suppose R satisfies given condition. Second, means contradiction,
suppose R satisfies (MC Extc ). Third, draw conclusions obtain contradiction.
Fourth, reductio ad absurdum, conclude must R falsifies (MC Extc ).
So, let us start supposing condition proposition suppose R satisfies
(MC Extc ). Thus, Proposition 2, obtain R conflict-dependent. Since R satisfies
(MC Extc ), every , Arg bijection MC() Extc (Arg(), R). Consider
= {, , } denote F = (Arg(), R). clear MC() = {S1 , S2 } S1 = {, }
S2 = {, }. Since R satisfies (MC Extc ) Extc (F) = {E1 , E2 } E1 = Arg(S1 )
E2 = Arg(S2 ).
Let us obtain contradiction proving E3 = Arg({}) complete extension. First,
prove set conflict-free. Let a, b E3 . Since R conflict-dependent, (a, b)
/ R.
Thus, E3 conflict-free.
Let us prove E3 , b Arg() \ E3 , (a, b)
/ R
(b, a)
/ R. means contradiction, suppose contrary. conflict-dependence,
Supp(a) Supp(b) ` . must {, } Supp(a) Supp(b). Since support
every argument consistent, Supp(a) contains either . Contradiction fact
Arg({}). Thus, E3 admissible set.
Let us prove E3 defend arguments Arg() \ E3 . show this,
need prove every argument Arg() \ E3 attacked least one argument. Note
every Arg() \ E3 , holds E1 \ E2 E2 \ E1 . Without loss generality,
let E1 \ E2 . Let us prove attacked. Note every argumentation system, every
non-attacked argument complete extensions. Since
/ E2 , must attacked. sum
up:
E3 admissible set
E3 attack argument Arg() \ E3
Arg() \ E3 attack argument E3
every argument Arg() \ E3 attacked least one argument.
Thus, E3 complete extension. Contradiction claim Extc (F) = {E1 , E2 }.
reductio ad absurdum, conclude R satisfy (MC Extc ).
semantics always return unique extension, grounded ideal
semantics? case, reasonable expect bijection MC()
82

fiI DENTIFYING C LASS AXI -C ONSISTENT PERATORS RGUMENTATION

set extensions, since several maximal consistent subsets . Let us formally
state fact.
Proposition 9. x semantics every argumentation system F |Extx (F)| =
1 attack relation R satisfies (MC Extx ).
Proof. Let = {, , }. Denote F = (Arg(), R). two maximal consistent subsets
, i.e. |MC()| = 2. Since supposed every argumentation system exactly one
extension semantics x, bijection MC() Extx (F).
previous simple result surprising. idea semantics one
extension contains arguments accepted according every point view.
Thus, expect link set formulae belonging minimal inconsistent
set extensions. Note sufficient conditions R identified (Gorogiannis
& Hunter, 2011) every finite set F = (Arg(), R) grounded
ideal semantics coincide extension exactly Arg( \ (1 . . . k ))
{1 , . . . , k } set minimal (for set inclusion) inconsistent subsets .

5. Identifying Classes Attack Relations (Not-)Satisfying (MCExt)
previous sections show identify properties attack relation satisfying (MC Ext)
must satisfy. provide several results closely related choice specific acceptability semantics. section, identify classes attack relations satisfy, satisfy
(MC Ext), serve lower (upper) bounds (with respect set inclusion) (non-)satisfying
(MC Ext).
first show whole class symmetric attack relations violates (MC Ext)
semantics Definition 4.
Proposition 10. R symmetric attack relation, every x {s, ss, p, c, g, i}, R falsifies
(MC Extx ).
Proof. Proposition 9, see R violates (MC Extg ) (MC Exti ). Let us
prove acceptability semantics.
R symmetric attack relation, every conflict-free set admissible. Furthermore,
easy see case every maximal conflict-free set stable extension (and vice versa).
Since every finite argumentation system least one maximal conflict-free set, every finite
argumentation system using symmetric attack relation least one stable extension. Let R
symmetric relation suppose least one x {s, ss, p, c}, R satisfies (MC Extx ).
Corollary 4, conclude R valid. means exists finite propositional
knowledge base F = (Arg(), R) conflict-free set E Arg()
inconsistent base. Let E 0 Arg() maximal conflict-free set containing E, i.e.
E E 0 . Since E 0 maximal conflict-free set, stable extension F. Since E 0
stable extension, semi-stable, preferred complete one. Since Base(E 0 ) `
Corollary 2 implies x {s, ss, p, c}, R fails satisfy (MC Extx ).
identify another class attack relations satisfy (MC Ext). Namely,
show every (possible) attack generating many attacks falsifies (MC Ext). First,
83

fiV ESIC

need formally define mean many attacks. introducing notion
conflict-completeness.
Definition 8 (Conflict-complete). Let R Arg(L) Arg(L) attack relation. say
R conflict-complete every minimal conflict C L (i.e. every inconsistent
set whose every proper subset consistent), every C1 , C2 C C1 6= , C2 6= ,
C1 C2 = C, every argument a1 Supp(a1 ) = C1 , exists argument a2
Supp(a2 ) = C2 (a2 , a1 ) R.
Intuitively, attack relation conflict-complete two sets form minimal conflict,
every argument built one two sets attacked argument set.
notion inspired desire describe properties class existing (and new) attack
relations. example, canonical undercut conflict-complete.
show attack relation conflict-complete, falsifies (MC Ext) stable,
semi-stable, preferred complete semantics.
Proposition 11. Let R attack relation. R conflict-complete R satisfy
(MC Extx ) x {s, ss, p, c}.
Proof. Let R conflict-complete attack relation let us use proof contradiction. Thus,
suppose exist x {s, ss, p, c} R satisfies (MC Extx ) obtain contradiction. Proposition 2, R conflict-dependent. Let = {, , }. Let
F = (Arg(), R) E = Arg({}) Arg({ }) Arg({}). prove E stable
extension F. First, prove E conflict-free. Let a, b E suppose (a, b) R.
conflict-dependence, obtain Supp(a) Supp(b) ` . Contradiction definition E,
since two arguments E union supports inconsistent. Now,
prove E attacks every argument Arg() \ E. Let a0 Arg() \ E. three cases.
Case 1: Supp(a0 ) = {, }. case, since R conflict-complete, a0 attacked
least one argument set Arg(). Case 2: Supp(a0 ) = {, }. conflictcompleteness, argument attacked argument set Arg({ }). Case 3:
Supp(a0 ) = { , } similar, since a0 attacked argument support
{}. conclude E Exts (F). easy see Base(E) ` . Proposition 7 implies
R satisfy (MC Extx ) every x {s, ss, p, c}. Contradiction.
previous part paper studies classes attack relations. Let us define

V
particular cases attack relations. = {1 , . . . , k } set formulae, notation stands
1 . . . k .
Definition 9 (Attack relations). Let a, b Arg(L). define following attack relations:
V
defeat: aRd b Conc(a) ` Supp(b)
direct defeat: aRdd b exists Supp(b) Conc(a) `
V
undercut: aRu b exists Supp(b) Conc(a)
direct undercut: aRdu b exists Supp(b) Conc(a)
V
canonical undercut: aRcu b Conc(a) Supp(b)
84

fiI DENTIFYING C LASS AXI -C ONSISTENT PERATORS RGUMENTATION

rebut: aRr b Conc(a) Conc(b)
defeating rebut: aRdr b Conc(a) ` Conc(b)
conflicting attack: aRc b Supp(a) Supp(b) `
rebut + direct undercut: aRrdu b aRr b aRdu b
big argument attack: aRba b exists Supp(b) Supp(a) ` .
first seven items previous definition list are, best knowledge,
attack relations used logic-based argumentation literature. Finding exact paper
occurs first time would quite challenging task. say rebut
defined Pollock (1987, 1992). Direct undercut introduced work Elvang-Gransson,
Fox, Krause (1993) Elvang-Gransson Hunter (1995). Undercut canonical undercut defined form Besnard Hunter (2000, 2001). best knowledge,
conflicting attack used argumentation literature. possibility use relation
mentioned (Besnard & Hunter, 2008, p. 35). show enough capture
presence inconsistency make good attack relation. Namely, show later attack
relation may return inconsistent extensions. Rebut + direct undercut added author
present paper, attempt investigate possibility use rebut detect conflicts
detected direct undercut, avoid using symmetric relation (rebut). name big argument
attack idea behind attack relation due L. van der Torre (personal communication,
June 18, 2012). attack relation coined goal show reasonable attack relations taking account conclusion argument. later show (Proposition 16)
attack relation satisfies (MC Ext). (The idea behind name attack relation
sufficient use one argument per support since conclusions important.
arguments called big since one big argument plays role whole class normal
arguments, i.e. arguments support. attack relation called big since
used big arguments.)
reader easily check canonical undercut conflict-complete, leads
conclusion every attack relation containing canonical undercut (in set-theoretic sense)
conflict-complete.
Proposition 12. Let R Arg(L) Arg(L) attack relation. Rcu R R conflictcomplete.
Thus, Proposition 11, conclude every attack relation containing canonical undercut
falsifies (MC Ext) stable, semi-stable, preferred complete semantics.
Corollary 6. Let R attack relation. Rcu R, R satisfy (MC Extx )
x {s, ss, p, c}.
Since Rcu Ru Rd Rc , obtain soon attack relation R contains Ru ,
Rd Rc falsifies (MC Ext) stable, semi-stable, preferred complete semantics.
Corollary 7. Let R attack relation. Ru R, Rd R Rc R R falsifies
(MC Extx ) x {s, ss, p, c}.
85

fiV ESIC

Hence, whole class attack relations based undercutting satisfy
(MC Ext). identified another class attack relations, time based rebutting,
satisfy (MC Exts ). Namely, every attack relation contained defeating rebut must
falsify (MC Exts ). Observe proof following proposition based idea
Example 3.
Proposition 13. Let R attack relation. R Rdr R satisfy (MC Exts ).
Proof. Let us suppose contrary, i.e. let R satisfy (MC Exts ). Let = { , }
F = (Arg(), R). MC() = {S1 , S2 }, S1 = { } S2 = { }. Thus,
must Exts (F) = {E1 , E2 } E1 = Arg(S1 ) E2 = Arg(S2 ). obvious
argument a1 = ({ }, ) must a1 E1 . Since E2 stable extension,
must exist argument a2 E2 (a2 , a1 ) R. Thus, must Conc(a2 ) ` .
Consequently, Conc(a2 ) ` . Recall Supp(a2 ) = { } Supp(a2 ) = { }.
Contradiction.
Since Rr Rdr previous conclusion holds every relation contained Rr .
Corollary 8. Let R attack relation. R Rr R satisfy (MC Exts ).
Proof. Let R Rr . Since Rr Rdr , R Rdr . Proposition 13, R falsifies
(MC Exts ).

6. Particular Attack Relations (MCExt)
previous section, identified classes relations satisfy (MC Ext).
section, examine detail attack relations Definition 9.
using results presented now, prove direct undercut, direct defeat big
argument attack satisfy (MC Ext) stable, semi-stable preferred semantics, falsify
semantics, whereas attack relations fail satisfy (MC Ext) semantics.
Note proved (Cayrol, 1995) direct undercut satisfies (MC Ext) case
stable semantics. Proposition 4, conclude direct undercut satisfies (MC Ext)
semi-stable semantics. So, need prove Rdu satisfies (MC Ext) case
preferred semantics.
Proposition 14. Attack relation Rdu satisfies (MC Extx ) x {s, ss, p}.
Proof. already seen Rdu satisfies (MC Ext) stable semi-stable semantics. study case preferred semantics. Let finite set formulae F =
(Arg(), Rdu ). Since already proved (Cayrol, 1995) stable extensions F exactly
Arg(S), ranges MC(), since every stable extension preferred one,
clear every MC() Arg(S) preferred extension F. Thanks
Proposition 6, need prove base every preferred extension consistent.
result follows Prop. 34 Gorogiannis Hunter (2011), since relation Rdu satisfies
conditions proposition. Thus, direct undercut satisfies (MC Extp ).
Example 6. Consider relation ; inferring inconsistent knowledge base defined
follows: given set , write ; every maximal consistent subset ,
86

fiI DENTIFYING C LASS AXI -C ONSISTENT PERATORS RGUMENTATION

holds ` , ` stands classical entailment. Now, consider argumentation system
using direct undercut attack relation stable semantics. Proposition 14, conclude
every , Arg bijection MC() Exts (Arg(), Rdu ). Roughly speaking,
means set formulae inferred respect ; equal set
formulae conclusions extensions corresponding argumentation framework
based direct undercut stable semantics. formally: every L, every formula
L that: ; every extension E Exts (Arg(), Rdu ), exists
E = Conc(a).
Let us show Rdd satisfies (MC Ext) stable, semi-stable preferred semantics.
Proposition 15. Attack relation Rdd satisfies (MC Extx ) x {s, ss, p}.
Proof. Let finite knowledge base F = (Arg(), Rdd ). Let MC(). easy
see E = Arg(S) stable extension F. Namely, E conflict-free since Rdd conflictdependent. Furthermore, every argument a0 Arg() \ E, must Supp(a0 ) contains
least one formulae \ S. fact, easy conclude exists argument
E Supp(a) Conc(a) (since maximal consistent set). Thus,
attacks a0 ends part proof shows E Exts (F). Since every stable
extension semi-stable preferred one, E Extss (F) E Extp (F). Let us
suppose E preferred extension F. Since direct defeat satisfies conditions Prop. 34
Gorogiannis Hunter (2011), conclude Base(E) consistent. Corollary 5,
conclude Rdd satisfies (MC Ext) stable preferred semantics. Now, Proposition 4
implies Rdd satisfies (MC Extss ).
show necessary look conclusions arguments order satisfy
(MC Ext). Namely, show big argument attack satisfies (MC Ext) stable, semistable preferred semantics.
Proposition 16. Attack relation Rba satisfies (MC Extx ) x {s, ss, p}.
Proof. Let us first show every MC(), holds E = Arg(S) stable extension
F = (Arg(), Rba ). Since Rba conflict-dependent, E conflict-free. Let a0 Arg() \ E
let us prove exists E aRba a0 . Since a0
/ E, exists
Supp(a0 )
/ S. Since maximal consistent subset , ` . Let 0
minimal respect set inclusion consistent set 0 ` (such set exists since
consistent) let = (S 0 , ). argument since 0 minimal consistent set
deduced. see (a, a0 ) Rba . means image respect Arg
every maximal consistent subset stable extension F. Thus, semi-stable
preferred extension F. Let us prove every corresponding F =
(Arg(), Rba ), base every preferred extension E F consistent set. Let E Extp (F)
= Base(E). Aiming contradiction, suppose contrary, i.e. let inconsistent set.
Let 0 minimal (with respect set inclusion) inconsistent set. Denote 0 = {1 , . . . , n }.
Let E argument n Supp(a), let a0 = (S 0 \ {n }, n ). clear
(a0 , a) Rba . Since E preferred extension, conflict-free, thus a0
/ E. Furthermore, E
admissible, must exist b E (b, a) Rba . Since (b, a) Rba ,
87

fiV ESIC

exists {1, . . . , n 1} Supp(b) ` . Since 0 , exists argument
c E Supp(c). According definition Rba , would mean b attacks
c. Contradiction fact E conflict-free. So, must consistent set. shows
every corresponding F = (Arg(), Rba ), base every preferred extension E
F consistent set. Corollary 5, conclude Rba satisfies (MC Ext) stable
preferred semantics. Now, Proposition 4 implies Rba satisfies (MC Extss ).
already know relation satisfies (MC Ext) grounded ideal semantics.
using Proposition 8, easy conclude Rdu , Rdd Rba falsify (MC Extc ).
Let us prove remaining attack relations Definition 9 satisfy (MC Ext)
neither semantics Definition 4.
Proposition 17. Attack relations Rd , Ru , Rcu , Rr , Rdr , Rrdu , Rc falsify (MC Ext) stable,
semi-stable, preferred, complete, grounded ideal semantics.
Proof. Note already showed attack relation satisfies (MC Ext) grounded
ideal semantics. So, rest proof, need consider stable, semi-stable, preferred
complete semantics.
Let us first consider attack relations Rcu , Ru , Rd Rc . using Proposition 11,
conclude relations violate (MC Ext) stable, semi-stable, preferred complete
semantics.
obvious relations Rr Rc symmetric. Note Rdr symmetric:
comes fact ` , ` ` . Thus, Proposition
10 yields conclusion satisfy (MC Ext) neither considered acceptability
semantics.
Let us study relation Rrdu . Let = {, , } F = (Arg(), Rrdu ). Let
us define set E arguments follows: E = {a Arg() | Conc(a) 6 Conc(a) 6
( ) Conc(a) 6 }.
Prove E conflict-free. Let a, b E let aRrdu b. Whether aRr b aRdu b
important, since cases, obtain Supp(a) Supp(b) ` . Contradiction, since
two formulae whose union inconsistent set. E conflict-free set.
Suppose a0 Arg() \ E. So, Conc(a0 ) Conc(a0 ) ( ) Conc(a0 ) .
cases, a0 attacked least one argument E, namely ({}, ),
({ }, ), ({}, ). So, E stable extension, consequently, semi-stable,
preferred complete extension. obvious Base(E) inconsistent set, Corollary 2
conclude Rrdu satisfy (MC Ext) stable, semi-stable, preferred complete
semantics.

7. Discussion, Related Future Work
paper identified studied large class instantiations Dungs abstract theory corresponding maxi-consistent operator. words, studied instantiations every
extension argumentation system corresponds exactly one maximal consistent subset
knowledge base. proved properties attack relations belonging class: must
conflict-dependent, must valid, must conflict-complete, must symmetric etc.
identified attack relations serving lower upper bounds class. using
88

fiI DENTIFYING C LASS AXI -C ONSISTENT PERATORS RGUMENTATION

results, showed existing attack relations argumentation literature whether
belong class. showed first time attack relation depending
arguments conclusions return reasonable results. Furthermore, showed relation
member (MC Ext) class.
Practical benefits work reported paper, generally, work devoted
studying link class instantiations Dungs theory operator, resumed
follows.
(I) case instantiation Dungs theory shown correspond existing operator.
First, work help validate argumentation-based approach showing
cases returns result comparable non argumentation-based approach. possible
criticism instantiation useless, since one obtain result without
using argumentation. But, far true; namely, argumentation used explanatory purposes. example, one wants know certain conclusion accepted,
argument conclusion presented. argument attacked arguments on. Also, might possible construct part argumentation graph
related argument question, thus better knowledge representation (i.e. ignoring
parts knowledge base unrelated argument one wants concentrate on).
second benefit type work help reduce computational complexity
using simpler approach cases result obtained argumentation-based approaches non argumentation-based approaches same. Please note work
category (capturing operator instantiation Dungs theory) far limited
case maxi-consistent operator, shown Vesic van der Torre (2012)
exists large class instantiations abstract argumentation theory returning consistent
result substantially different one returned maxi-consistent operator.
(II) case instantiation Dungs theory correspond existing operator.
Working links instantiations Dungs theory operators even
beneficial case instantiation abstract argumentation theory corresponding known operator happens found. distinguish three possible situations.
(a) case instantiation calculates useful result obtained operator, operator unknown now. case, new operator discovered thanks
argumentation. question then, situations use argumentative approach,
apply operator? answer depends balance need computational
efficiency (which conjecture often side approach directly applying operator)
need represent knowledge format easy grasp, argue justify accepted
piece knowledge, usual advantages argumentation.
(b) case instantiation Dungs abstract theory returns useful result cannot
obtained operator. Recall operator function that, every finite knowledge
base, returns set subsets. But, argumentative approach could return result cannot
represented form, instance, argument (, ) extension, whereas (, )
not, 6= . Thus, expressive power operator-based approach might enough
distinguish subtleties. important question define instantiation
still open. Another relevant issue see context instantiations make sense
applied.
89

fiV ESIC

(c) case instantiation returns bad result. class regroups set instantiations
representing behaviour one would avoid. general question: distinguish useful
bad instantiations? certainly hard one. Apart scientific debate, evaluation
include tests set benchmark examples. Note limits testing reasoning formalism
set benchmark examples pointed Vreeswijk (1995). Another, principled (and demanding) way proceed define set postulates satisfied
argumentation formalism (Caminada & Amgoud, 2007; Caminada, Carnielli, & Dunne, 2012).
remark, note fact instantiation may return inconsistent result,
mean completely useless. Namely, might cases arguments constructed
inconsistent knowledge base, one resolves existing inconsistencies argumentative approach, applies another inconsistency-tolerant approach.
Also, inconsistency handling use argumentation. Thus, still setting,
drastic case would first use argumentation another purpose (not dealing
inconsistencies) apply different approach reason inconsistency.
review related work. Maxi-consistent sets play major role characterization various forms non-classical logical reasoning (Bochman, 2001) belief revision
(Alchourron, Gardenfors, & Makinson, 1985). remainder section considers papers
link argumentation.
paper Cayrol (1995) one early works relating results obtained directly
knowledge base using argumentative approach. paper, shown direct
undercut satisfies (MC Ext) stable semantics, results semantics attack
relations provided. studied attack relations semantics,
provided general study properties attack relation satisfying (MC Ext) must satisfy.
Amgoud Vesic (2010) generalised result Cayrol (1995) case prioritised
knowledge base, showing Arg bijection preferred sub-theories (Brewka, 1989),
generalise maximal consistent sets case prioritised knowledge base, stable extensions corresponding preference-based argumentation system using direct undercut
attack relation weakest link principle preference relation.
Amgoud Besnard (2009, 2010) studied link knowledge base corresponding argumentation system. papers introduced important notions conflictdependence validity attack relation proved numerous results related consistency
underlying logic. However, note criterion (MC Ext) neither defined studied
papers; provided (Amgoud & Besnard, 2010, Corollary 1) link MC()
maximal conflict-free sets F = (Arg(), R). Furthermore, result proved hypotheses impossible satisfy: attack relation valid conflict-dependent,
impossible (as proved Proposition 3). results paper (Amgoud &
Besnard, 2010, e.g. Prop. 4) proved attack relation conflict-dependent
conflict-sensitive, case well-known attack relations. Consequently, majority negative results papers applicable minority
attack relations. Furthermore, examples papers often incomplete systems; thus,
surprising link MC(Base(A)) Ext(A, R) examples.
recent paper Gorogiannis Hunter (2011) studied properties attack relations
case Dung-style argumentation system instantiated classical propositional
logic. work related ideas, however, focus paper different. main
goal study extent Dungs theory used general framework reasoning.
90

fiI DENTIFYING C LASS AXI -C ONSISTENT PERATORS RGUMENTATION

technical side, concentrate studying properties class attack relations
satisfying (MC Ext) identifying attack relations serving lower upper bounds classes
relations non-satisfying (MC Ext).
One open questions find set conditions attack relation satisfies
conditions satisfies (MC Ext). recently, direct undercut direct
defeat known attack relations satisfying condition (Vesic, 2012). Consequently,
seemed space attack relations satisfying condition rather narrow (note similarity
direct undercut direct defeat). However, present paper shows Rba belongs
(MC Ext), indicating class instantiations corresponding maxi-consistent
operator much larger.
formal framework studied paper classical propositional logic-based argumentation. vast majority ideas considerations present paper hold
instantiations Dungs theory, example setting studied Modgil Prakken (2013).
words, result obtained argumentation frameworks could compared
obtained operator. slightly adapting definition operator, one study
questions: link result obtained argumentation system
obtained operator (from strict defeasible rules)? argumentation help us
find new operators? argumentation systems returning result cannot captured
operator? Answering questions certainly part future work.

Acknowledgments
author would thank Leendert van der Torre assistance advice. useful
comments helped improve paper significantly. author thanks three reviewers
helpful comments.
paper revised extended version conference paper: S. Vesic. Maxi-Consistent
Operators Argumentation. Proceedings 20th European Conference Artificial Intelligence (ECAI12), pages 810-815.
major part work paper carried author affiliated
Computer Science Communication Research Unit University Luxembourg. First,
author started work tenure ERCIM Alain Bensoussan Fellowship Programme, supported Marie Curie Co-funding Regional, National International Programmes (COFUND) European Commission. time, author
funded National Research Fund, Luxembourg. Second, still University Luxembourg, author continued work paper FNR AFR postdoc project
supported National Research Fund, Luxembourg, cofunded Marie Curie
Actions European Commission (FP7-COFUND). Third, time finishing
work paper, author CRNS researcher affiliated CRIL.

References
Alchourron, C. E., Gardenfors, P., & Makinson, D. (1985). logic theory change: Partial
meet contraction revision functions. Journal Symbolic Logic, 50, 510530.
91

fiV ESIC

Amgoud, L., & Besnard, P. (2009). Bridging gap abstract argumentation systems
logic. International Conference Scalable Uncertainty Management (SUM09), pp.
1227.
Amgoud, L., & Besnard, P. (2010). formal analysis logic-based argumentation systems.
International Conference Scalable Uncertainty Management (SUM10), pp. 4255.
Amgoud, L., Besnard, P., & Vesic, S. (2011). Identifying core logic-based argumentation
systems. 23rd International Conference Tools Artificial Intelligence (ICTAI11),
pp. 633636.
Amgoud, L., & Cayrol, C. (2002). reasoning model based production acceptable arguments. Annals Mathematics Artificial Intelligence, 34, 197216.
Amgoud, L., & Vesic, S. (2010). Handling inconsistency preference-based argumentation.
Proceedings 4th International Conference Scalable uncertainty Management
(SUM10), pp. 5669.
Arrow, K. J., Sen, A. K., & Suzumura, K. (Eds.). (2002). Handbook Social Choice Welfare.
North-Holland.
Besnard, P., & Hunter, A. (2000). Towards logic-based theory argumentation. Proceedings
17th National Conference Artificial Intelligence (AAAI00), pp. 411416. AAAI Press
/ MIT Press.
Besnard, P., & Hunter, A. (2001). logic-based theory deductive arguments. Artificial Intelligence Journal, 128, 203235.
Besnard, P., & Hunter, A. (2008). Elements Argumentation. MIT Press.
Bochman, A. (2001). logical theory nonmonotonic inference belief change - numerical
methods. Springer.
Brewka, G. (1989). Preferred subtheories: extended logical framework default reasoning.
Proceedings International Joint Conference Artificial Intelligence (IJCAI89), pp.
10431048.
Caminada, M. (2006). Semi-stable semantics. Proceedings 1st International Conference
Computational Models Argument (COMMA06), pp. 121130. IOS Press.
Caminada, M., & Amgoud, L. (2007). evaluation argumentation formalisms. Artificial
Intelligence Journal, 171 (5-6), 286310.
Caminada, M., Carnielli, W., & Dunne, P. (2012). Semi-stable semantics. Journal Logic
Computation.
Caminada, M., & Vesic, S. (2012). extended conflict-freeness argumentation.. Proceedings
24th Benelux Conference Artificial Intelligence (BNAIC12), pp. 4350.
Cayrol, C. (1995). relation argumentation non-monotonic coherence-based entailment. Proceedings 14th International Joint Conference Artificial Intelligence
(IJCAI95), pp. 14431448.
Dung, P. M. (1995). acceptability arguments fundamental role nonmonotonic reasoning, logic programming n-person games. Artificial Intelligence Journal, 77,
321357.
92

fiI DENTIFYING C LASS AXI -C ONSISTENT PERATORS RGUMENTATION

Elvang-Gransson, M., Fox, J., & Krause, P. (1993). Acceptability arguments logical uncertainty. Proceedings 2nd European Conference Symbolic Quantitative
Approaches Reasoning Uncertainty (ECSQARU93), pp. 8590.
Elvang-Gransson, M., & Hunter, A. (1995). Argumentative logics: Reasoning classically
inconsistent information. Data Knowl. Eng., 16(2), 125145.
Gardenfors, P. (1988). Knowledge Flux Modeling dynamics epistemic states. Cambridge,
MA, MIT Press.
Gorogiannis, N., & Hunter, A. (2011). Instantiating abstract argumentation classical logic
arguments: Postulates properties. Artificial Intelligence Journal, 175, 14791497.
Konieczny, S., & Perez, R. P. (2011). Logic based merging. Journal Philosophical Logic, 40(2),
239270.
Loui, R. (1998). Process policy: Resource-bounded nondemonstrative reasoning. Computational Intelligence, 14(1), 138.
Modgil, S., & Prakken, H. (2013). general account argumentation preferences. Artificial
Intelligence, 195, 361397.
Pollock, J. (1987). Defeasible reasoning. Cognitive Science, 11(4), 481518.
Pollock, J. (1992). reason defeasibly. Artificial Intelligence Journal, 57, 142.
Priest, G. (2002). Paraconsistent logic. Gabbay, D., & Guenthner, F. (Eds.), Handbook Philosophical Logic, Vol. 6, pp. 287393. Dordrecht: Kluwer Academic Publishers.
Vesic, S. (2012). Maxi-consistent operators argumentation. 20th European Conference
Artificial Intelligence (ECAI12), pp. 810815.
Vesic, S., & van der Torre, L. (2012). Beyond maxi-consistent argumentation operators. 13th
European Conference Logics Artificial Intelligence (JELIA12), pp. 424436.
Vreeswijk, G. (1995). Interpolation benchmark problems defeasible reasoning. Proceedings
Second World Conference Fundamentals Artificial Intelligence (WOCFAI95),
pp. 453468.
Vreeswijk, G. (1997). Abstract argumentation systems. Artificial Intelligence Journal, 90, 225279.

93


