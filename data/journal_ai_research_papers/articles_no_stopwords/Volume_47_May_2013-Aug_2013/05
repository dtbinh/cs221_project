journal artificial intelligence

submitted published

protecting privacy distributed computation
multi agent decision making
thomas leaute
boi faltings

thomas leaute epfl ch
boi faltings epfl ch

ecole polytechnique federale de lausanne epfl
artificial intelligence laboratory lia
station
ch lausanne switzerland

abstract
large scale theft data corporate servers becoming increasingly common
becomes interesting examine alternatives paradigm centralizing sensitive data
large databases instead one could use cryptography distributed computation
sensitive data supplied processed encrypted form final
made known examine paradigm used
implement constraint satisfaction technique solve broad class ai
resource allocation scheduling diagnosis previous work
privacy constraint satisfaction attempted protect specific types information
particular feasibility particular combinations decisions formalize
extend restricted notions privacy introducing four types private information
including feasibility decisions final decisions made identities
participants topology present distributed
allow computing solutions constraint satisfaction maintaining four
types privacy formally prove privacy properties
experiments compare respective performance benchmark

introduction
protecting privacy information becoming crucial concern many users
increasingly ubiquitous information communication technologies companies invest
lot effort keeping secret internal costs future development strategies
actors market importantly competitors individuals
need privacy personal information instance carelessly disclosing ones
activity schedule location might reveal burglars opportunities break ones home
hand accessing private information often necessary solve
depend data context supply chain management companies
need exchange information contractors subcontractors quantities
goods must produced price scheduling meetings
events friends co workers individuals confronted challenge taking
coordinated scheduling decisions protecting respective availability schedules
artificial intelligence crucial tool help people make better decisions
privacy concerns delegating part decision personal intelligent
agents executing carefully chosen far complex performed
ai access foundation rights reserved

fileaute faltings

human alone particular framework constraint satisfaction
csps core ai technology successfully applied many decision making
configuration scheduling solving strategic games
distributed ai used solve csps providing strong guarantees
privacy knowledge use techniques borrowed
cryptography makes possible solve coordination depend secret
data without reveal data parties hand distributed
encrypted computation involving message exchange cost terms performance
suitable tradeoff privacy scalability must found
motivating examples
present set novel privacy protecting distributed constraint satisfaction discsps wide class multi agent decision making applications many configuration scheduling design
diagnosis consider three examples illustrate privacy requirements might
arise meeting scheduling airport slot allocation computing game equilibria
meeting scheduling maheswaran tambe bowring pearce varakantham number meetings need scheduled involving possibly overlapping sets
participants taking account respective availability constraints participants
given meeting must agree time meeting one given participant
involved multiple meetings creates constraints meetings class participants usually want protect privacy respective availability
schedules well lists meetings involved
another class airport slot allocation rassenti smith bulfin
airlines express interests combinations takeoff landing time slots airports corresponding possible travel routes aircraft end goal airports
efficiently allocate slots airlines point view airlines crucial
combinations slots interested remain private indicate
routes intend fly sensitive strategic information want hide
competitors
finally consider general class one shot strategic games party game
singh soni wellman players invited party must decide whether
attend respective intrinsic costs attendance whether people
dislike choose attend players would best play strategies form
nash equilibrium single player better deviating chosen
strategy computing equilibrium typical example multiagent decision making privacy issue players necessarily want
reveal attendance costs whether dislike another invitee
four types private information
seen previous examples information participants would
keep private differ nature propose classify four privacy types
briefly introduce illustrate formal definitions given section


fiprotecting privacy thru distributed computation multi agent decision making

agent privacy relates identities participants consider instance
ceo wants schedule two meetings respectively journalist
another companys ceo revealing journalist ceos involvement
decision making could leak companies plans merge
case agent privacy considered critical
topology privacy covers information presence constraints
type critical information airline companies want keep secret airport
slot allocation presence constraint airline specific
airport reveals airlines strategic plans offer flights airport
constraint privacy nature constraints covers instance
participants availability schedules meeting scheduling
party game whether player likes dislikes invitees
decision privacy solution eventually chosen
depending class type privacy may may relevant
meeting scheduling time chosen meeting necessarily
revealed participants meeting however desirable hide
information non attendees
previous work privacy discsp assume participants honest
curious goldreich honestly follow interested
learning much possible agents private information messages exchanged note honesty assumption mean agents
assumed faithfully report true constraints may tempted
strategize reporting slightly different constraints hoping would lead select solution deem preferable issue
incentive compatibility addressed related work petcu faltings
parkes orthogonal issue privacy addressed furthermore agent would take risk reporting constraints different true constraints
reporting relaxed constraints could yield solution violates true constraints
would therefore viable reporting tighter constraints could make overall
infeasible fail solution
hand depart previous work two respects first
previous work almost exclusively focused constraint privacy often ignoring agent
topology decision privacy address four types
propose correspond points tradeoff different levels privacy
efficiency second literature focuses quantitatively measuring
reducing amount privacy loss discsp developed
give strong guarantees certain pieces private information
leaked contrast previous privacy protecting typically case
piece private information may leaked small probability
rest organized follows section first formally defines discsp
framework four aforementioned types privacy section presents first
called p dpop section describes p dpop


fileaute faltings

variant achieves higher level decision privacy expense additional
computational overhead another variant called p dpop introduced section
order improve constraint privacy finally section compares performance
previous state art several classes benchmarks

preliminaries
section first formally defines discsp framework section introduces
four types privacy section
distributed constraint satisfaction
providing formal definition distributed constraint satisfaction section
recall existing discsp optimization variant section
definition
distributed constraint satisfaction formally defined follows
definition discsp discrete discsp tuple x c
ak set agents
x x xn set variables
x mapping assigns control variable xi agent xi
dn set finite variable domains variable xi takes values di
c c cm set constraints ci ci ary function scope
xi xis ci ci di dis ci false true assigning false infeasible
tuples true feasible ones
v
solution complete assignment conjunction ci c ci true
case exactly assignment consistent constraints
important assumptions discsp framework following first
assume details given constraint ci known agents involved
agent wants keep constraints private formulate way
involve variables controls furthermore assume two neighboring agents
e agents share least one constraint able communicate
securely messages delivered fifo order finite time
hand assume two non neighboring agents initially ignore everything
even including involvement particular discsp
protects agent privacy require communicate directly
even allow discover others presence finally assume agent honestly
follows protocol focus preventing private information leaks agents
figure introduces simple graph coloring instance used illustrate throughout rest assume five nodes


fiprotecting privacy thru distributed computation multi agent decision making

r x




x

x b




x



x b r

figure discsp constraint graph simple graph coloring instance

graph correspond five different agents must choose color among red
blue green decisions modeled five variables x x domains
r b g agent may express secret unary constraint variable instance
x want assigned color red binary inequality constraints imposed
pair neighboring nodes known two agents involved
distributed constraint optimization dcop extension discsp formalism
constraints specify variable assignments feasible infeasible
assign costs utilities assignments optimal solution
dcop one minimizes sum costs maximizes sum utilities
easily generalized solve dcops complexity
increase linear upper bound assumed integer cost
optimal solution generalization left outside scope sake
conciseness addressed leaute faltings leaute
complete discsps
range distributed exist literature solve discsps dcops
seen belonging two classes depending order variables
largest class consists order variables along linear order
abt yokoo durfee ishida kuwabara awc yokoo synchbb hirayama yokoo aas silaghi sam haroud faltings afc meisels
zivan disfc brito meseguer comp apo mailler lesser grinshpoun meisels concdb zivan meisels afb gershman meisels
zivan concfb netzer meisels grubshtein linear order may
chosen fixed initially run dynamically revised online
second class variables ordered along tree partial order includes
adopt modi shen tambe yokoo variants bnb adopt yeoh
felner koenig bnb adopt gutierrez meseguer dpop petcu
faltings countless variants ncbb chechetka sycara
order variables following pseudo tree definition among aforementioned
pseudo tree dpop one dynamic programming dp
others search proposed perform dp
different partial variable orders action gdl uses junction trees vinyals rodrguezaguilar cerquides dcte cluster trees brito meseguer


fileaute faltings

dpop
dpop originally designed solve optimization dcops
described terms utility maximization one way apply pure satisfaction
discsps first reformulate discsp max discsp constraints
longer boolean rather take values stands feasibility
infeasibility cost minimizing variant dpop described
applied solution minimal cost cost hereafter called feasibility
value corresponds number constraint violations want equal
overview dpop instance general bucket elimination
scheme dechter performed distributedly requires first arranging
constraint graph pseudo tree formally defined follows
definition pseudo tree pseudo tree generalization tree node
allowed links back edges remote ancestors pseudo parents remote
descendants pseudo children never nodes branches tree
pseudo tree arrangement constraint graph figure illustrated figure
pseudo tree naturally decomposes original two loosely coupled subproblems corresponding two branches perform rest
parallel figure shows feas messages originally called util messages
context utility maximization exchanged propagation feasibility
values following multi party dynamic programming computation lines
overal dpop variable x
require pseudo tree ordering variables px denotes xs parent
util propagation propagate feasibility values pseudo tree
x px c c c xscope c scope c childrenx pseudo childrenx c x
join received messages
yi childrenx

wait message feas mi x yi

sepyi scope mi

x px x px mi x



project x
x root variable

x px arg minx x px

send message feas x px px px
else x arg minx x x px actually depends x










value propagation propagate decisions top along pseudo tree
x root
wait message decision px parent px
x x px px
yi childrenx send message decision sepyi yi


fiprotecting privacy thru distributed computation multi agent decision making

x

x x
r b g

x x
x
r

b

g


x x
x
x r b g
r

b

g


x

x

x

x

x

x x
x
x r b g
r

b

g


figure multiparty dynamic programming computation feasible value x
pseudo tree arrangement constraint graph figure dashed
edge represents back edge pseudo parent pseudo tree

part messages travel bottom along tree edges consider instance
message sent agent x parent agent x message
projection lines variable x conjunction line x two
constraints x x x b summarizes minimal number constraint violations x achieve function ancestor variable x generally
message sent variable x summarizes minimal number constraint violations
achievable aggregate subproblem owned entire subtree rooted x
function whose scope called separator x line dpop separator x necessarily includes xs parent px potentially ancestor variables indicated
notation px instance message x x summarizes minimal number
constraint violations achievable entire subtree rooted x function x
separator px x x notice separator variable x contain variables
neighbors x example x x separator descendent x
constraint x privacy aware presented later
notion separator extended allow separators necessarily include
parent variable may include multiple codenames referring variables
might necessarily ancestors pseudo tree
upon receiving messages x x x x line agent x joins
line constraint x x variable x projected resulting joint
table produces message x x lines end feasibility
propagation line root variable x chooses value x minimizes
number constraint violations entire e g x r decision
propagated downwards along tree edges via decision messages originally called
value messages variables assigned optimal values lines


fileaute faltings

complexity given pseudo tree ordering n variables dpops bottom
top phases exchange exactly n messages one tree edge
however decision message contains n variable assignments
feas message sent given variable x contain exponentially many feasibility values
contains table representation function sepx variables size
sepmax
largest feas message therefore dmax
dmax size largest
variable domain sepmax maxx sepx n width pseudo tree
best case width equal treewidth constraint graph however finding
pseudo tree achieves minimal width np hard practice pseudo tree
generated heuristic distributed depth first traversal constraint graph online
appendix producing called dfs tree pseudo tree parentchild relationships neighbors constraint graph since dpop exchanges
n feas messages overall complexity terms runtime measured number
sepmax
constraint checks memory information exchange n dmax

privacy properties privacy aware section dpop
two desirable properties allow higher levels privacy first dpop
requires message exchanges neighboring agents provided pseudotree used dfs tree necessary protect agent privacy greenstadt pearce
tambe made opposite claim pseudo trees detrimental privacy
compared linear orderings however claim valid type privacy
considered constraint privacy hold agent privacy topology privacy
guaranteed e pseudo tree publicly known agents second dpinherited property dpops performance depend constraint tightness
e easy hard satisfy constraint search
inferences constraint tightness made observing runtime amount
information exchanged silaghi mitra case meeting scheduling
constraint tightness maps directly participants levels availability private
information application domains leak constraint tightness tolerable
search rather dp used many privacy enhancing
techniques presented dpop applicable search
privacy discsps
section formally defines four types privacy considered section
recalls previous work attempted address subsets privacy types
privacy definitions
definition introduces concept semi private information faltings leaute petcu
may inevitably leaked discsp
definition semi private information semi private information refers information
solution agent might consider private
inevitably leaked agents views chosen solution discsp
words semi private information covers everything given agent discover
agents making inferences simply initial knowledge


fiprotecting privacy thru distributed computation multi agent decision making

values variables take solution instance graph coloring
involving two colors node infer color neighbors
color assigned chosen solution provided solution correct excluding
semi private information distinguish four types private information agents
may desire protect faltings et al
definition agent privacy agent able discover identity even
existence non neighboring agents particular consequence type privacy
two agents allowed communicate directly share constraint
figure means instance agent x able discover
existence identities agents x x even two non neighboring agents
communicate directly agent privacy might still leaked contents messages
propose method codenames fully protect agent privacy
definition topology privacy agent able discover existence
topological constructs constraint graph nodes e variables edges e
constraints cycles unless owns variable involved construct
figure topology privacy means instance agent x discover
many neighbors x besides however x might discover existence
cycle involving x x x tolerated x involved cycle
x discover length cycle e x x share neighbor
definition constraint privacy agent able discover nature
constraint involve variable owns
figure example breach constraint privacy would agent x
able discover agent x want assigned color blue
type privacy discsp literature mostly focuses
definition decision privacy agent able discover value another
agents variable takes chosen solution modulo semi private information
distributed graph coloring means agent discover color
neighbor let alone non neighboring agent solution chosen
previous work privacy discsp
discussing information may leaked given prevent
important clarify information assumed initially known agent
initial knowledge assumptions use following three assumptions
currently widely used discsp literature
agent knows agents variables neighbors variables
know agents even existence
variable domain known owner agent agents owning
neighboring variables agents ignore existence variable


fileaute faltings

constraint fully known agents owning variables scope
agent knows anything constraint even existence
brito meseguer introduced partially known constraints pkcs whose
scopes known agents involved knowledge whose nature assignments allowed disallowed distributed among agents relaxation
assumption however worth noting presented
still support pkcs without introducing privacy leaks enforcing assumption
pkc decomposed number constraints copy variables
assumption holds instance agents share knowledge unary pkc
variable x constraint decomposed n unary constraints
constraint ci known fully agent ai expressed copy
variable xi owned ai equality constraints added enforce equality
copy variables however introduction copy variables detrimental
decision privacy grubshtein grinshpoun meisels zivan later proposed
similar concept asymmetric constraints reformulated symmetric
constraints copy variables purpose applying
previous work adopted dual assuming variables public
known agents constraint known one agent silaghi et al
yokoo suzuki hirayama silaghi silaghi b even proposed framework constraints secret everyone dual disadvantage necessarily violating topology privacy since variables public
measuring constraint privacy loss literature privacy discsps
focuses constraint privacy metrics proposed evaluate constraint privacy
loss particular distributed meeting scheduling franzin freuder rossi
wallace wallace freuder maheswaran pearce bowring varakantham
tambe designed framework called valuation possible states vps
used measure constraint privacy loss optapo synchbb
considered impact whether topology public partially
known agents greenstadt et al applied vps evaluate dpop
adopt meeting scheduling assumption topology
public doshi matsui silaghi yokoo zanker proposed consider cost
privacy loss optimization order elegantly balance privacy optimality
preventing constraint privacy loss previous work proposed approaches
partially reduce constraint privacy loss instance brito meseguer described
modification distributed forward checking disfc discsps
agents allowed lie finite time order achieve higher levels privacy however performance search disfc leaks information
constraint tightness explained end section avoid subtle privacy
leak one must perform full exhaustive search option chosen silaghi
resort dynamic programming option chosen
cryptographic technique secret sharing shamir ben goldwasser
wigderson applied silaghi faltings petcu greenstadt
grosz smith lower constraint privacy dpop assuming constraint
graph topology public knowledge cryptography applied provide strong


fiprotecting privacy thru distributed computation multi agent decision making

guarantees constraint privacy preservation multi agent decision making instance
yokoo suzuki yokoo et al yokoo suzuki hirayama
showed public key encryption scheme used solve discsps multiple
servers protecting constraint privacy decision privacy bilogrevic jadliwala
hubaux aad niemi solved single meeting scheduling similar
techniques one semi trusted server however consider
make use third parties third parties might available herlea
claessens preneel neven piessens decker showed use secure multiparty
computation smc securely schedule single meeting without relying servers
smc agents collaboratively compute value given publicly known function
private inputs without revealing inputs herlea et al inputs
participants availability given time function outputs whether
available
mpc discsp silaghi applied smc solve general
discsps private inputs agents constraint valuations function
returns randomly chosen solution proceeds follows leaute
agent ai first creates vector one entry per candidate solution discsp equal
candidate solution satisfies ai private constraints otherwise reduce
size candidate solutions may filtered publicly known constraints
exists shamirs polynomial secret sharing technique shamir benor et al agent ai sends one secret share fij vector
agent aj receives corresponding secret shares fji respective vectors agent ai
multiplies together secret shares received multiplication shamir secret
shares non trivial operation secret share value polynomial
multiplying two polynomials increases degree output must remain
lower number agents resolvable therefore multiplication
two secret shares agent ai must perform complex sequence operations involving
exchange messages order reduce degree output
performing pairwise multiplications secret shares agent ai vector contains secret shares entries corresponding globally feasible solutions
agent ai performs transformation one secret share
remains identifying one particular feasible solution exists one selecting
first entry would posteriori reveal previous entries correspond infeasible
solutions discsp prevent privacy leak vector first collaboratively
randomly permuted mix net agent ai performs sequence iterative operations including communication intensive multiplications set entries
secret shares except one secret share corresponding chosen solution
discsp vector un shuffled traversing mix net
reverse finally agent ai compute secret shares domain index variables
chosen assignment reveal secret shares owners variables
numerous drawbacks first agent must know variables
domains construct initial vector immediately violates agent privacy
topology privacy table page second shamirs secret sharing scheme
silaghi uses different acronym mpc concept



fileaute faltings

majority threshold scheme means least half agents collude
discover everyones private information even though assuming
agents honest collude consequence threshold
scheme provide privacy guarantee involves two agents
third often practical small performs
full exhaustive search demonstrated experimental section

p dpop full agent privacy partial topology constraint
decision privacy
section describes variant dpop guarantees full agent privacy
partially protects topology constraint decision privacy
improvement p dpop originally proposed faltings et al
dpop performs dynamic programming dfs tree ordering
variables figure first elect one variable generate dfs tree
rooted variable given online appendices
reveal pseudo tree entirety agent instead agent discovers
pseudo parents pseudo children variables sake simplicity
hereafter assume without loss generality constraint graph consists single
component actually consisted two fully decoupled subproblems
subproblem would solved parallel independently others
overal p dpop variable x
require dfs tree ordering variables
choose exchange codenames x domain dx
wait message codes yix dyxi yxi yi parentx pseudo parentsx
yi childrenx pseudo childrenx

xyi large random number

dxyi list dx random unique identifiers

xyi random permutation dx

send message codes xyi dxyi xyi yi



choose exchange obfuscation key x
wait record message key keyyxi yi pseudo parentsx
yi pseudo childrenx
keyxyi vector large random numbers b bits indexed dx
send message key keyxyi yi



propagate feasibility values pseudo tree section



propagate decisions top along pseudo tree section
x root
wait message decision px parent px
x x px px x computed line
yi childrenx
yi sepyi line
send message decision sep















fiprotecting privacy thru distributed computation multi agent decision making

finding feasible value root variable
already illustrated dpop section agents perform bottom propagation feasibility values along pseudo tree done
extension dpops util propagation phase extensions indicated comments
bold improves originally proposed faltings et al
patching important constraint privacy leak single variable feas messages
sent variables singleton separators following sections describe obfuscation
techniques used protect private information could leaked feasibility
messages codenames section addition random numbers section
feasible value root dfs tree variable x
require dfs tree ordering variables px denotes xs parent
join local constraints
x px c c c xscope c scope c childrenx pseudo childrenx c x




apply codenames
yi px pseudo parentsx
x px replace yi dyi x px yix dyxi line
apply permutation yxi dyxi

obfuscate infeasible entries
r large positive
random number b bits

x px
x px
x px
x px r x px











join received messages
yi childrenx
wait message feas mi x yi
sepyi scope mi
z childrenx pseudo childrenx resolve codenames
mi x identify xz dxz x dx mi x xz present
x px x px mi x

de obfuscate feasibility values respect x
yi pseudo childrenx

x px x px keyxyi x keyxyi line


project x
x root variable

x px arg minx x px

px minx x px










obfuscate feasibility values
yi pseudo parentsx
px px keyyxi yix keyyxi line
send message feas px px
else x arg minx x x px actually depends x


fileaute faltings

hiding variable names values codenames
consider feasibility message x x sent agent x parent variable x
figure message recalled figure reformulated terms minimizing
number constraint violations message actually received cleartext would
breach agent privacy topology privacy agent x would able infer
dependency message variable x existence agent x violates
agent privacy fact x neighbor one unknown nodes x
x x
x
x r b g
r

b

g

cleartext

x
r
b
g

x x






b partly obfuscated

x
r
b
g

x x












c fully obfuscated

figure message sent agent x parent variable x figure

order patch privacy leaks variable x domain r b g replaced random codenames xx x figure b preliminarily
generated x communicated directly leaf back edge
lines leaf applies codenames output message line
resolved propagation reaches root back edge line knowing codenames agents x
infer existence cycle constraint graph involving unknown ancestor descendent tolerated definition topology privacy definition
since involved cycle secret random permutation x applied
x useful classes variable domains public notice
x constraint x reasoning would still hold x would
sent different codename xx x would able resolve
unknown codename xx x case x separator would x xx xx
message sent x would three dimensional instead two dimensional
obfuscating feasibility values
hiding variable names values codenames addresses leaks agent topology
privacy however address fact feasibility values message
x x figure b violate constraint privacy reveal x subtree
feasible solution subproblem x r regardless value
obfuscated variable patch privacy leak feasibility values obfuscated
adding large random numbers generated root back edge x
sent secure channel leaf back edge lines
number bits b random numbers independent parameter
obfuscation performed way different random number


fiprotecting privacy thru distributed computation multi agent decision making

added feasibility values associated value x figure c
obfuscation key random numbers added leaf
back edge outgoing message line eventually
subtracted propagation reaches root back edge line
notice obfuscation scheme achieves two objectives hides x
absolute feasibility values subtree hides relative dependencies
values obfuscated variable different random numbers used
value obfuscated domain agent x still able infer relative
dependencies variable x necessary perform projection
variable unable tell value obfuscated variable whether
subtrees feasible many constraints violated notice
particular given value obfuscated variable e column agent x
know whether assignments x feasible therefore would
incorrect simply assume lowest obfuscated feasibility entries decrypts
similarly equal entries column correspond high probability entries
number constraint violations number necessarily
would incorrect infer correspond feasible entries
notice obfuscation scheme applicable presence backedge e message contains parent variable consider
instance single variable message x x recalled figure agent x knew
x leaf pseudo tree cleartext message would reveal agent x private
local constraint x b r agent x previous obfuscation scheme
apply absence back edges notice threat constraint privacy
tempered fact p dpop guarantees terms topology privacy prevent
agent x discovering x indeed leaf x point view larger
subproblem might hanging variable x figure message could actually
aggregation multiple agents subproblems

x
r
b
g

x x
conflicts




cleartext

x

x x
conflicts

r
b
g





b obfuscated

figure message received agent x figure

reduce privacy leak present original faltings et al
propose additional obfuscation scheme consists adding large b bit positive
random numbers positive entries single variable messages order obfuscate
true numbers constraint violations line figure b
random numbers never subtracted back must added zero entries otherwise would fail solution violation feasible entries still
revealed numbers constraint violations infeasible entries remain obfuscated


fileaute faltings

propagating final decisions
feasibility values propagated way root pseudotree feasible assignment root variable found exists one
assignment propagated pseudo tree lines
variable uses assignments contained message parent order look
corresponding assignment line sends child assignments
variables separator line codenames
protect agent topology privacy decision privacy partially guaranteed
variable learns values chosen parent pseudo parents
non neighboring variables separator hidden unknown codenames
properties
section first formally proves complete analyses complexity
present variant lower complexity finally privacy guarantees
provided summarized table formally described
privacy type

agent

topology

constraint

decision

p dpop

full
full
full


partial
partial
partial
partial

partial
partial
full
partial

partial
full
full
partial



dpop

p
p dpop
mpc discsp

table privacy guarantees

completeness complexity
theorem provided codename clashes p dpop terminates returns feasible solution discsp exists one
proof exchanging codenames obfuscation keys guaranteed require
number messages quadratic number n variables bottom
propagation feasibility values terminates sending exactly n
messages one tree edge one prove induction left reader
multi party dynamic programming computation almost surely correctly reveals
variable x obfuscated feasibility subtrees subproblem function x
possibly ancestor variables pseudo tree process may fail case
collisions codenames roots two overlapping back edges choose
codenames codename clashes inherent privacy protecting
made improbable desired augmenting size codename space
finally top decision propagation phase lines guaranteed yield feasible assignment variable exists one exchange
exactly n messages one tree edge


fiprotecting privacy thru distributed computation multi agent decision making

comes complexity terms number messages
exchanged bottleneck election root variable online appendix
requires n messages diameter constraint graph degree
n number variables however n messages containing feasibility
values exponentially large message sent variable x expressed sepx
sep
variable codenames line therefore contains dmaxx feasibility
values dmax size largest variable domain overall complexity
terms information exchange memory runtime measured number constraint
sepmax
checks therefore n dmax
sepmax maxx sepx dpop
except p dpop variable may appear multiple times different codenames
separator hereby increasing value sepmax however increase
multiplicative factor upper bounded degree constraint graph since
number codenames given variable equal number neighbors
empirically experimental section suggest almost
classes considered median value sepmax tends grow rather linearly n
p dpop trading topology privacy performance
possible reduce sizes sepxi separators enforcing agent x
send codename x x xs pseudo children unlike lines
variant identified absence plus sign exponent p dpop
version initially proposed faltings et al
change variables previously may occurred multiple times
feasibility message different codenames appear
sepmax n worst case complexity p dpop
becomes dpop petcu faltings sepmax equal
width pseudo tree bounded treewidth constraint graph
however privacy considerations prevents use p dpop dpops efficient
less privacy aware pseudo tree generation heuristics resulting higher width pseudo trees
complexity p dpop hereby decreased compared p dpop sending
codename x variable x pseudo children drawbacks terms
topology privacy analyzed
full agent privacy
two ways identity agent could leaked non neighbor b
require b exchange messages agent
receive message whose content refers identifiably b case never happen
ever involve exchanging messages neighboring
agents case addressed mainly use codenames
theorem p dpop guarantee full agent privacy
proof p dpop proceed following sequential phases preliminary phases root election pseudo tree generation addressed online appendices
bottom feasibility propagation feasibility message contains
function line set variables whose names transmitted clear


fileaute faltings

text could identify owner agent prevent agent privacy leak p dpop
replaces variable names secret random codenames follows
consider variable x pseudo tree note feasibility message sent x
ancestor x function x message sent x function
x x projected message sent line variable x cannot
appear feasibility message higher pseudo tree agents local
involve variable lower pseudo tree line
similarly consider feasibility message sent descendant x
pseudo tree assume first leaf pseudo tree since
children feasibility message sends function variables
local local involves x replace x codename xy
line sends feasibility message one prove inference
feasibility message sent variable x contain x
necessarily contain one several codenames xyi
since codenames xyi random numbers chosen x line
communicated channels assumed secure respective
neighbors yi x line non neighbor x receiving message
involving xyi discover identity owner agent
domain dx variable x could contain values might identify owner
agent fix privacy risk xs domain replaced obfuscated domains dxyi
random numbers similarly way variable names obfuscated
make simplifying assumption variables domain
size naturally holds many classes one variables domain
size give information owner agent otherwise variable domains
padded fake values order make size
top decision propagation section messages contain assignments
variables line obfuscated codenames
concludes proof p dpop agent receive
message infer identity non neighboring agent
partial topology privacy
theorem p dpop guarantees partial topology privacy minor leaks topology
privacy lie fact variable might able discover lower bound neighbor
variables degree constraint graph lower bound total number variables
proof root election pseudo tree generation left online appendices
bottom feasibility propagation variable x receives feas
message child containing function whose scope might reveal topological
information variable scope represented secret codename
however x may able decrypt codename neighbor x
x sent codename neighbors
leak topology privacy x discovers neighboring ancestor


fiprotecting privacy thru distributed computation multi agent decision making

whether least one neighbor given child x cannot
discover exactly many neighbors
furthermore case x neighbors x cannot decrypt
still infer exists another non neighboring ancestor corresponding
codename another breach topology privacy sent
codename neighbors x discover whether ancestor
least one neighbor xs children moreover since codenames
large random numbers almost surely unique x may discover existence
several distinct non neighboring ancestors
top decision propagation section variable receives message
parent contain codenames variables variable values
already present feas message received previous phase
concludes proof p dpop partially protects topology privacy limited
topology information leaked variable concerns branch pseudo tree
information leaked branch even existence
theorem use different codenames pseudo child improves topology
privacy p dpop compared p dpop bounds still leaked
proof consider variable x receives feas message including secret codename
corresponding variable x sent different codename
neighbors x longer able decrypt even neighbor x consequence
x longer able infer whether refers known neighbor x unknown
non neighboring variable however since codename corresponds unique backedge pseudo tree pair unknown codenames xs received feas
message pair exists least one following statements must hold
refer two different ancestors x therefore x discovers least
two ancestors might known pseudo parent
sent two different descendants x possibly including
sender child therefore x discovers least two descendants
including might known pseudo child
therefore x might able refine lower bound total number variables
partial constraint privacy
theorem p dpop guarantee partial constraint privacy local
feasibility subproblem partial variable assignment x may leaked even x
cannot extended overall feasible solution e semi private information
proof information constraints transmitted feasibility propagation knowledge optimal variable assignments transmitted
last phase section feasibility information may decrypted


fileaute faltings

single variable feasibility messages variable px receives feasibility message
involving px message obfuscated adding secret random
numbers infeasible entries line feasible entries remain equal px
identify entries refer respectively feasible infeasible assignments px
however addition secret positive random number infeasible entry
ensures upper bound number constraint violations leaked
made loose desired choosing random numbers large necessary
multi variable feasibility messages feas message involves least one
variable yi message entries obfuscated adding large random
numbers keyyxi yix b bits line furthermore keyyxi yix known
sender x message pseudo parent yi recipient px
therefore cannot subtract de obfuscate entries
assume simplicity message px yix involves two variables
px yix argument extends easily variables recipient px might
able make inferences fixing yix comparing obfuscated entries
corresponding different values px fixing px varying yix instead
given value yix entries obfuscated adding
random number keyyxi yix line px compute relative differences
feasibility values assignments px however cannot decrypt
absolute values without knowing keyyxi yix particular lowest obfuscated
value necessarily equal keyyxi yix necessarily decrypt
values px may infeasible particular value yix
one exception feasible solution found


yix yix px px px yix necessarily decrypts therefore


px able infer keyyxi yix fixing yix yix message

subtracting keyyxi yix reasoning made single variable
case feasible infeasible entries identifiable numbers
constraint violations infeasible entries remain obfuscated
given value px feasibility value px yix obfuscated
adding different secret random number keyyxi yix choosing number
bits b sufficiently large makes sure useful information relative
absolute obtained comparing obfuscated feasibility values
concludes proof p dpop guarantees partial constraint privacy
partial decision privacy
theorem p dpop guarantee partial decision privacy leak lies
fact variable might discover values chosen neighbors
proof first notice cannot leak information chosen values
variables lower pseudo tree since variables projected
feasibility messages received however decision propagation phase
variable receives message parent contains chosen values parent


fiprotecting privacy thru distributed computation multi agent decision making

pseudo parents message may contain codenames assignments nonneighboring variables recipient able decode furthermore domains
shuffled secret permutations making impossible decode codename
value non neighboring variable index variables domain

p dpop adding full decision privacy
section presents another variant p dpop achieves full decision
privacy novel seen hybrid
p dpop p dpop leaute faltings called p dpop
overview
patches decision privacy leak p dpop removing decision propagation phase root variable assigned value order variables
assigned values variable made root turn unless first feasibility propagation
revealed infeasible case terminate early

intuition behind p dpop therefore p dpop bottom
feasibility propagation phase repeated multiple times time different variable x
root pseudo tree lines end iteration constraint
x x added enforce consistency across iterations line
overall p dpop full decision privacy variable x
require first temporary dfs tree unique id idx tight strict lower bound

next unique id id
x upper bound n total number variables
idx

id
x idx

z z
vectorx

z

n

















exchange public key shares
privatex generate private elgamal key x
publicx generate set id
x idx public key shares corresponding privatex
share publicx toprevious share share
n
wait record one message share share
share publicx toprevious share share
generate compound elgamal public key public key shares
vectorx
choose root section
construct pseudo tree rooted root online appendix
exchange codenames x domain dx lines
choose exchange obfuscation key x lines
propagate feasibility values pseudo tree except line
x root add local constraint x x x line


fileaute faltings

choosing root variable
iteratively reroot pseudo tree propose use improved version rerooting
procedure initially introduced p dpop leaute faltings
procedure requires n variables assigned unique id
achieve presented online appendix reveals variable x
unique id idx well tight strict lower bound next unique id id
x e
total number variables




upper
bound
n
next unique id equals id
x
variable x creates boolean vector vectorx single zero entry index
corresponding unique id idx line vector shuffled
random permutation used hide sequence variables become roots
keep permutation secret vector first encrypted elgamal encryption
appendix compound public key jointly produced agents
lines asymmetric encryption scheme enables agent encrypt
entries vectors common public key decryption
performed collaboratively agents respective private keys
choose root variable x
procedure shufflevectors variable x
myid large random number
px random permutation n
propagate xs encrypted vector backwards along circular ordering
vectorx e vectorx encrypts vector compound public key
toprevious vect myid vectorx appendix b




process received vectors
true

wait message vect id vector round next variable















round
id myid j idx id
x vector j
else round round xs vector move next round
round x current root
round round root starts round except first
round vector px vector shuffle vector
round id myid done processing vectorx
vectorx vector
continue
pass vector backwards along circular ordering
vector e vector encrypts vector compound public key
toprevious vect id vector round appendix b

procedure reroot variable x
repeat entry decrypt pop vectorx entry
entry x root


fiprotecting privacy thru distributed computation multi agent decision making

agents proceed variable x first starts procedure
shufflevectors run performance improvement
previous work leaute faltings performed iteration
vectors passed variable variable round robin fashion circular message
routing presented appendix b agent applies secret permutation
vector shuffle shufflevectors proceeds four rounds round
started line vector makes full round along circular ordering
variable x overwrites entries line
positions vectorx line entries account
ids idx id
x assigned variable online appendix
x received back vectorx enters incomplete round line
vectorx passed reaches current root line root starts round
line variable x shuffles vector secret permutation px
line incomplete round returns fully shuffled vector owner line
reroot variable ordering beginning iteration p dpop
variable x calls procedure reroot removes decrypts first element
vectorx entries decrypt correspond unassigned ids skipped
single entry decrypts identifies root decryption process
collaborative effort involves variable private elgamal key partially
decrypt cyphertext travels around circular variable ordering way
vectors gets back sender variable finally fully decrypt
collaborative decryption multiply encrypted cyphertext e
procedure decrypt e variable x
codename large random number used secret codename x
codenamesx codenamesx codename
toprevious decr codename e
wait message decr codename e next variable ordering
return decryption e xs private key
procedure collaborativedecryption variable x
loop

wait message decr c e next variable ordering

c codenamesx

e partial decryption e xs private key

toprevious decr c e

properties


first analyze completeness complexity properties p dpop move privacy properties
completeness complexity
theorem provided codename clashes p dpop
terminates returns feasible solution discsp exists one


fileaute faltings

proof basis theorem remains prove rerooting
terminates correct overall remains correct latter easy
prove iteration feasible value found root variable exists
one value necessarily consistent chosen assignments previous roots
since assignments enforced additional constraints line
comes rerooting procedure unique id assignment online
appendix ensures n variables gets unique id n therefore
variable entry unique position vector line round
makes sure vectors entries positions
ensures exactly one variable become root iteration since vectors
applied sequence permutations variable root twice


terms complexity p dpop proceeds similar way p dpop section except bottom feasibility propagation phase repeated n times
time different root variable overall complexity information exchange theresep
fore becomes n dmaxmax sepmax maximum separator size variables
iterations therefore likely higher exponent pdpop information exchanged rerooting protocol negligible comparison
sep
runtime complexity measured number constraint checks n dmaxmax
sep
memory complexity n dmaxmax removing decision propagation phase makes become unnecessary compute record x px
line experimental graph coloring benchmarks section suggest
median value sepmax may greater median value sepmax pdpop small multiplicative factor terms number elgamal cryptographic
operations rerooting procedure requires total n n n n encryptions
n variables encrypts n vectors size n variables vector
performs full rounds except roots vector performs full rounds
n n n incrmin incrmin constant input parameter
procedure requires total n n n collaborative decryptions
n variables partially decrypts n vectors size n
full agent privacy
theorem p dpop guarantee full agent privacy
proof unique id assignment circular routing guarantee full agent privacy demonstrated respectively online appendix appendix b
pseudo tree rerooting messages sent shufflevectors contain variable id vector elgamal cyphertexts round number id
used recipient detect whether vector vector large
random number chosen owner agent line therefore
cannot linked identity owner agent agent elgamal
vector round number contain information could used
identify agent note procedure used exchange elgamal public
key shares lines leak information agents


fiprotecting privacy thru distributed computation multi agent decision making

identities reroot procedure makes use collaborative decryption
whose properties terms agent privacy discussed
collaborative decryption procedure exchanges messages contain elgamal cyphertext codename used variable id
codename similarly set large random number chosen current agent
cannot linked identity agent agent


concludes proof p dpop guarantee agent privacy
partial topology privacy


topology privacy p dpop slightly worse p dpop
theorem p dpop guarantee partial topology privacy variable unavoidably discovers total number variables might
discover lower bound neighbor variables degree constraint graph advan

tages p dpop p dpop p dpop p dpop
proof since one feasibility propagation phase per variable total
number variables inevitably becomes public following analyzes topology privacy
properties phase p dpop already present p dpop except
unique id assignment online appendix secure message routing appendix b
exchange elgamal key shares lines messages containing elgamal key shares contain information could used make
inferences topology constraint graph
pseudo tree rerooting message travels along circular variable
ordering message routing appendix b contains
vector encrypted encrypted operation therefore cannot provide topological information
id identifies owner vector secret large random number
owner vector identify
round number take following values
round indicates vector modified variable
setting turn values
round indicates vector sent root
pseudo tree happen vector unknown root
round indicates vector shuffled variable
round indicates vector way back owner
happen vector belonging unknown root
reroot uses decryption whose properties described


fileaute faltings

collaborative decryption decr messages passed along circular variable ordering containing secret codename original sender variable
variable capable deciphering codename last part
message payload elgamal cyphertext remains encrypted reaches
back original sender therefore leak topological information


concludes proof p dpop guarantees partial topology privacy
partial constraint privacy


constraint privacy properties p dpop differ pdpop former protect decision privacy benefits constraint privacy
reveal total number variables hurts constraint privacy
theorem p dpop guarantee partial constraint privacy
leaks p dpop section happen less frequently
proof single variable feasibility messages leak amount constraint privacy
p dpop notice however since p dpop reveal total
number variables circumstances may possible variable discover
child leaf feasibility message sends therefore contains information
local subproblem however multi variable feasibility messages leak potentially much
less information p dpop consider simpler non restrictive case

two variable message px yix received px p dpop protects

decision privacy px longer discovers value yix chosen yix therefore
longer able infer entries corresponding px px decrypts
one exception following three conditions simultaneously hold p dpop

used codename yix refers variable yix neighbor px yix

semi private information px px still discover yix able make

inferences p dpop first condition satisfied e p dpop

used instead p dpop px able link codename yix known

variable case p dpop used second condition

hold finally first two conditions hold px able discover yix
semi private information e infer knowledge
chosen value px
full decision privacy
theorem p dpop guarantee full decision privacy
proof leak decision privacy p dpop fixed removing decision propagation phase instead variable ordering rerooted feasibility propagation
phase restarted possible compare feasibility messages received one
iteration next infer decision made previous iteration
messages comparable since different codenames obfuscation keys used


fiprotecting privacy thru distributed computation multi agent decision making

p dpop adding full constraint privacy
describe previous non fully secure obfuscation scheme replaced
elgamal homomorphic encryption appendix achieve full constraint privacy
corresponds original p dpop leaute faltings improved
use multiple codenames important limitation elgamal scheme
fully homomorphic possible compute two encrypted booleans
possible compute encrypted boolean cleartext
boolean consequence bottom feasibility propagation performed
variable ordering variable one child e linear variable
ordering figure message routing appendix b otherwise
pseudo tree variable ordering variable two children would able join
two encrypted feasibility messages sent children could addressed
fully homomorphic encryption scheme gentry however unclear whether
scheme would practically applicable would sufficient performance
x
x

x

x

x

figure counter clock wise circular variable ordering corresponding figure

propagating encrypted feasibility values along linear variable order
contrast figure illustrates multi party dynamic programming pseudotree variable ordering counting constraint violations figure shows cleartext
carried linear ordering boolean domain assumes
circular communication structure preliminarily set described appendix b
gives detailed pseudocode procedure intended
replacement line differences pseudo tree following first initially reformulated discsp
max discsp minimize number constraint violations works
directly original discsp means conjunction operator
replaces sum operator lines disjunction operator replaces
operator min line notice case linear ordering variables local
subproblem longer necessarily involves parent variable ordering line
x shares constraint x figures
next difference variable x longer partially de obfuscates feasibility
matrix projecting line reason elgamal
scheme homomorphic therefore longer necessary first partially decrypt


fileaute faltings

x

x x
r
b
true false

g
true

x

x

x
r
b
g

x x
x
r
b
true false
true
true
false false

x x
x
r
b
true false
true true
true true

x
r
b
g
x

g
true
true
false

x

x
r
b
g

g
true
true
true
x
x x
x
r
b
true true
true true
true false

g
true
false
true

figure multiparty dynamic programming computation cleartext feasible value
variable x linear variable ordering figure

propagating feasibility values along linear ordering variable x
join local constraints
v
x c c c xscope c scope c childrenx pseudo childrenx c x

apply codenames
yi parentx pseudo parentsx

x replace yi dyi x yix dyxi line
apply permutation yxi dyxi








join received message
wait message feas next variable ordering
z childrenx pseudo childrenx
identify xz dxz x dx xz present
x x

project x
x root
w variable

e x x encrypts compound public key

toprevious feas
else x feasiblevalue x






fiprotecting privacy thru distributed computation multi agent decision making

feasibility values project x operator x root variable requires
decryption line value x variable x whose encrypted
feasibility value decrypts true described following section
decrypting feasible value root variable
decryption feasibility values root collaborative process variable partially decrypts cyphertext private key dichotomy
procedure uses least log dx log dx decryptions
feasible assignment root variable detect infeasibility
finding feasible value encrypted feasibility matrix x
procedure feasiblevalue x xil xir
il ir hthen
ki half remaining subdomain
j cut
il ir

il


w

f easible decrypt ii x xi

f easible true return feasiblevalue
x xii

else return feasiblevalue x xi il ir
else one value remains x

f easible decrypt x xil

f easible true return xil else return null


properties
first analyze completeness complexity properties p dpop
move privacy properties
completeness complexity
theorem provided codename clashes p dpop
terminates returns feasible solution discsp exists one
proof termination follows theorem fact message routing
procedure appendix b guarantees feasibility messages eventually reach destinations comes completeness homomorphic property elgamal scheme
ensures projection variable x encrypted feasibility matrix correct
feasibility message received variable linear ordering summarizes
encrypted feasibility lower agents aggregated subproblems function higher
variables particular feasibility message received root allows value
variable satisfies overall exists one
analysis complexity remains similar analysis secsep
tion n dmaxmax information exchange number constraint checks
sep
n dmaxmax memory sepmax maximum separator size along
successive linear variable orderings instead along pseudo trees requirement


fileaute faltings

variable may one child tends make exponent increase significantly
illustrated empirically section terms number elgamal cryptographic operations addition cost rerooting variable ordering section
sep
requires n dmaxmax encryptions n log dmax collaborative decryptions
full agent privacy
theorem p dpop guarantee full agent privacy


proof changes introduced p dpop respect p dpop
feasibility propagation finding feasible value root variable
elgamal feasibility propagation point view agent privacy procedure message
routing guarantee agent privacy
root variable assignment consists iteratively calling procedure already shown guarantee agent privacy
concludes proof p dpop guarantee agent privacy
partial topology privacy
theorem p dpop guarantee partial topology privacy addition
limited leaks topology privacy p dpop agent might able
discover exists another branch constraint graph involved


proof two relevant differences p dpop linear variable ordering choice value root variable requires collaborative decryption
elgamal feasibility propagation exchange feas messages along
linear variable ordering makes use circular message routing
procedure shown appendix b guarantee full topology privacy however
last variable linear ordering needs know last order initiate
feasibility propagation therefore contraposition non last variables know
last particular non last leaves pseudo tree discover
existence another branch minor leak topology privacy already present
unique variable id assignment online appendix besides
topology privacy properties feasibility propagation phases p dpop
p dpop p dpop p dpop respectively
root variable assignment involves recursively calling
collaborative decryption procedure shown guarantee full topology privacy
concludes proof p dpop guarantees partial topology privacy


fiprotecting privacy thru distributed computation multi agent decision making

full constraint privacy
theorem p dpop guarantee full constraint privacy
proof p dpop fix leaks constraint privacy p dpop
replacing cryptographically insecure obfuscation addition random numbers cryptographically secure elgamal encryption appendix makes
longer possible compare two encrypted feasibility values without decrypting
would require collaboration agents amount computation break
encryption made arbitrarily high worst case increasing elgamal
key size particular possible compute logical two cyphertexts
without decrypting remains encrypted cannot compared two
inputs decide one true
full decision privacy
theorem p dpop guarantee full decision privacy
proof proof applies theorem

experimental
report empirical performance state art mpcdiscsp four classes benchmarks graph coloring meeting scheduling
resource allocation game equilibrium compare mpc discsp
knowledge general discsp provides strong privacy
guarantees class choice discsp formulation crucial
dictates four types privacy defined discsp constraint graph
relate actual privacy original particular p dpop use standard discsp assumption constraint known agents
owning variable scope section therefore agent wants hide
constraint neighboring agents must express constraint copies neighbors variables additional equality constraints must introduced make copy variables
equal respective original variables contrast mpc discsp make use
discsp assumption therefore need introduction copy variables
first performance metric simulated time sultanik lass regli
used agents simulated single machine estimate time would
taken solve run parallel dedicated machines ignoring
communication delays two metrics number messages amount
information exchanged metric report median least
instances confidence intervals obfuscation p dpop used
random numbers b bits p dpop used bit elgamal encryption
mpc discsp used bits paillier encryption unique variable id
generation procedure p dpop parameter incrmin set
implemented inside java frodo platform discsp leaute ottens
szymanek coupled csp solver jacop kuchcinski szymanek
experiments run ghz dual core computer java java
heap space gb timeout set min wall clock time


fileaute faltings

graph coloring
first report performance distributed color graph coloring
graphs randomly generated varying numbers nodes
edge density fixed notice fixed number colors fixed edge
density increasing number nodes increases degree graph therefore
reduces number feasible solutions explains trends following
graphs discsp formulation involves one decision variable per node assumes
variable controlled single variable agent notice inter agent constraints
binary inequality constraints therefore decision privacy relevant class
knowing ones chosen color insufficient infer respective colors ones neighbors
study tradeoff privacy performance mpc discsp considered
variant denoted mpc discsp assumes inter agent inequality constraints e
node neighborhoods public final choice colors protected agent

simulated time ms



induced width


mpc



mpc





p dpop
p dpop







p

dpop


p

dpop






p dpop



p dpop



dpop












number nodes







number messages









number nodes





information exchanged bytes







mpc
mpc





p dpop




p dpop



p dpop





p dpop




dpop









number nodes
















number nodes

figure performance graph coloring







fiprotecting privacy thru distributed computation multi agent decision making

first enumerates feasible solutions overall section uses
cryptographic techniques securely randomly choose one feasible solutions
exists none therefore terminates without cryptographic operations
exchanging messages explains phase transition mpc discsp
following graphs since probability infeasibility increases size
figure shows mpc discsp denoted mpc subsequent figures
scales poorly timing nodes mpc discsp
performs better however mentioned protects final choices colors
small numbers nodes total state space small mpc discsp performs
relatively well numbers nodes instances mostly infeasible
mpc discsp quickly detects infeasibility without exchange message
efficient far p dpop whose performance curves
least one order magnitude particular p dpops runtime
sensibly dpop communication overhead almost solely due root
simulated time ms



induced width




p dpop


p dpop
dpop
















number nodes





number messages








number nodes



information exchanged bytes


















number nodes












number nodes

figure performance larger graph coloring





fileaute faltings

election cost improved topology privacy p dpop vs p dpop
starts sizes induced widths p dpop pseudotrees start deviate p dpop dpop full decision privacy comes much higher
costs p dpop curve orders magnitude p dpop
even though induced widths remain sensibly suggests rerooting
pseudo tree involves expensive cryptographic operations far complexity
bottleneck even full constraint privacy additionally guaranteed p dpop
whose linear variable orderings nevertheless significantly higher induced widths
p dpop pseudo tree orderings notice slope runtime curve decreases
size increases due fact become
infeasible p dpop able terminate first iteration
infeasible similarly p dpop vs p dpop cost improved topology
privacy visible nodes p dpop even timed size
finally figure illustrates fact mpc discsp tends send large numbers
small messages p dpop send lower numbers larger messages
figure compares performance p dpop dpop larger graph coloring instances larger improved topology privacy pdpop comes complexity price high scale nodes
hand p dpops curves one two orders magnitude dpop
p dpops median runtime instances size
meeting scheduling
report experimental random meeting scheduling benchmarks varied
number meetings keeping number participants per meeting
meeting participants randomly drawn common pool agents goal
assign time meeting among available time slots agent required
attend simultaneous meetings pool agents deliberately chosen small increase
complexity increasing probability agent take part
multiple meetings note fixing pool size number participants per
meeting still generates unbounded number different instances increase
number meetings since state space cartesian product domains
decision variables keeps increasing number meetings decisions made
discsp formulation class following agent owns
one variable domain size meeting participates alldifferent
constraint variables enforce meetings scheduled different
times meeting binary equality constraint expressed corresponding
variables owned two participants enforces participants agree time
meeting notice inter agent constraints binary equality constraints

therefore p dpop bring additional privacy compared p dpop
since values neighboring variables semi private information therefore
report performance p dpop mpc discsp simplified formulation
introducing one variable per meeting owned initiator way
meeting initiator made public exact list participants remains secret
revealed posteriori participants meeting attend


fiprotecting privacy thru distributed computation multi agent decision making

simulated time ms







p dpop
p dpop



mpc




p dpop



p dpop



dpop




induced width











number meetings





number messages







number meetings



information exchanged bytes


























number meetings











number meetings



figure performance meeting scheduling

seen figure p dpops performance comparable mpcdiscsp much stronger privacy guarantees although former sends significantly information smallest significantly fewer messages
largest could solve within timeout limit hand
majority threshold scheme mpc discsp actually could provide privacy
guarantees size since involved agents could
scale size timed larger p dpop increased topology privacy comes price made time earlier p dpop
complexity increase due p dpop steeper induced width curve
p dpop remain efficient far perform
orders magnitude better others terms runtime information
exchanged graph coloring improved topology privacy p dpop comes
price negligible small grow one order magnitude
size even induced width remains close p dpop terms


fileaute faltings

runtime information exchange p dpop worse dpop small factor
since median induced width however sends approximately one order
magnitude messages mostly due pseudo tree root election mechanism
resource allocation
next performed experiments distributed resource allocation benchmarks
instances produced combinatorial auction generator cats leytonbrown pearson shoham ignoring bid prices used temporal matching
distribution modeling allocation airport takeoff landing slots fixing total number
slots e resources varying numbers bids bid request
bundle resources takeoff slot corresponding landing slot multiple requests
may placed airline company airline exactly one fulfilled

simulated time ms



induced width






mpc





p dpop
p dpop





dpop














number bids











number bids





information exchanged bytes

number messages




























number bids















number bids

figure performance resource allocation







fiprotecting privacy thru distributed computation multi agent decision making

modeled discsp follows leaute faltings one
agent introduced bidder airline resource slot assuming
resource controller different resource provider airport resource x
bidder b requests resource one binary variable xb controlled
resource provider whether b allocated
p resource xb
xb resource provider expresses one constraint
variables
enforce resource allocated one interested bidders
variable xb introduce one copy variable bx owned bidder b
constraint xb bx bidder b expresses constraint variables
enforcing allocated two resources correspond exactly one
requests introduction copy variables motivated discsp assumption
agent knows constraints involving variables serves two privacy related
purposes full list agents placing requests given resource known
resource provider full list resources requested given agent
bundles known agent meeting scheduling class
inter agent constraints equality constraints therefore report performance
p dpop whose privacy guarantees p dpop
mpc discsp discsp formulation simplified introducing copy
variables hold bidders since necessary protect constraint privacy bidders
request resources expressing constraints directly variables owned
resource providers however since mpc discsp assumes variables public
order increase topology privacy introduced resource many variables
bidders regardless whether actually interested resource reduce
size search space assumed constraints public
figure shows performance mpc discsp decreases fast
number requests able scale beyond
size p dpop seem scale better able solve
involving requests three metrics largely outperformed
p dpop whose runtime curve remarkably flat almost overlaps runtime
curve dpop consistent undistinguishable induced width curves
overhead p dpop compared dpop slightly larger terms information
exchanged goes one order magnitude terms number messages pdpop p dpop performed respective non plus variants
strategic game equilibria
finally report experimental one last class benchmarks
corresponds distributed computation pure nash equilibria strategic games
used particular example party game introduced singh et al
one shot simultaneous move graphical game kearns littman singh
players invited common party players possible strategies whether
attend party players arranged undirected social graph
defines invitees player knows players reward attending
cats assumes single auctioneer specify slot airport
assumed resource provided separate resource provider



fileaute faltings

party depends whether acquaintances decide attend whether
likes reward per attendee likes minus per attendee dislikes
minus constant cost attendance reward attending
computing nash equilibrium game formulated
discsp follows player agent owns one binary variable
strategy one copy variable strategy acquaintances variable
constrained equal copy variables binary equality constraints
resource allocation section agent expresses one constraint
variables allows particular strategy agent best response
neighbors joint strategies notice resulting constraint graph
game graph due presence copy variables solution discsp therefore
yields joint strategy profile players pure nash equilibrium since
player plays best response neighbors notice since player holds copy

simulated time ms



induced width










p dpop



mpc



p dpop








dpop




















number players





number messages








number players



information exchanged bytes

























number players












number players

figure performance party games





fiprotecting privacy thru distributed computation multi agent decision making

variable neighbors strategy strategies semi private information
cannot protected report performance p dpop
mpc discsp discsp formulation simplified introducing copy
variables vickrey koller interesting consequence difference
contrary p dpop mpc discsp able hide players chosen strategy
neighbors context party game useful players
decide attend party since necessarily eventually discover whether
acquaintances decided attend hand player declines
invitation directly discover anything list attendees might still
able make indirect inferences decisions acquaintances
fact decision decline best response respective chosen strategies
figure reports performance random acyclic game graphs
degree e trees node children varying numbers
players p dpop able scale size
due rapidly increasing induced width outperformed mpc discsp
least one order magnitude across three metrics still performed
largely worse p dpop capable scaling much larger
setting induced width remains bounded since
game graphs acyclic dpops induced width constantly equal
feas message sent agent ax parent agent ay expressed ay strategy
variable copy ax strategy variable held ay p dpop induced width
increased agent ay children pseudo tree
different codename ay strategy variable performance overhead
p dpop compared dpop minimal terms runtime slightly larger
information exchanged reaches one order magnitude number messages

conclusion
addressed issue providing strong privacy guarantees distributed constraint satisfaction discsps defined four types information agents might want hide agent privacy
hiding agents identity non neighbors topology privacy keeping topology
constraint graph private constraint privacy protecting knowledge constraints decision privacy final value variable known
owner agent departing previous work literature addressed
subsets privacy types often focused quantifying privacy loss proposed set strong guarantees
information provably leaked
carried performance experiments four different classes benchmarks
graph coloring meeting scheduling resource allocation game equilibrium computation
provide stronger privacy guarantees
scale better previous state art explored tradeoff
privacy performance p dpop variant shown scale much better
others guarantee partial constraint decision privacy may still
considered sufficient many classes full decision privacy p dpop full


fileaute faltings

constraint privacy p dpop come significantly higher prices computation time
information exchange todays hardware limits applicability smaller
instances compared performance mpcdiscsp considered previous state art discsp
strong privacy guarantees first three classes benchmarks
almost systematically outperformed mpc discsp terms runtime number
messages exchanged however mpc discsp proved exchange less information
p dpop game equilibrium computation mpc discsp scaled much better
p dpop along three metrics still largely outperformed p dpop
terms practical applicability shown scale mediumsize beyond reach previous state art general discsp
strong privacy guarantees investigated application
real life meeting scheduling collaboration nokia center lausanne
future work could extend techniques along several directions first
restricted pure satisfaction sake simplicity
easily extended solve distributed constraint optimization dcops fact p dpop already optimization
p dpop requires changes applied dcops changes involve
replacing elgamal encrypted boolean feasibility values elgamal encrypted bit wise
vector representations integer cost values described yokoo suzuki
would incur increase complexity linear upper bound cost
optimal solution optimization variant mpc discsp called mpc diswcsp
already proposed silaghi mitra report performance comparisons
publications leaute faltings leaute
avenues future could relaxing assumption agents
honest curious number challenging issues arise attempting apply
techniques self interested agents manipulate protocol
order achieve solutions better suit selfish preferences one issue
verifiability involves making possible check whether protocols executed
designed without need decrypt messages exchanged another interesting issue
whether possible modify make incentive compatible
agents best interest honestly follow protocol

appendix cooperative elgamal homomorphic encryption
homomorphic encryption crucial building block privacy preserving
introduced encryption process message appendix
boolean turned cyphertext way decrypting cyphertext
retrieve initial cleartext message impossible case computationally
hard worst case without knowledge secret encryption key used
produce cyphertext encryption scheme said homomorphic possible
perform operations cyphertexts translate operations initial cleartext
messages without need know encryption key elgamal encryption elgamal
one encryption scheme possesses homomorphic property


fiprotecting privacy thru distributed computation multi agent decision making

basic elgamal encryption booleans
elgamal encryption used encrypt booleans performing following
operations encrypted booleans possible without knowledge decryption key
encrypted cleartext boolean
two encrypted booleans
elgamal encryption homomorphic public key cryptography system
intractability diffie hellman tsiounis yung proceeds
follows let p safe prime form rt r large random number
large prime numbers computations modulo p let g generator
zp e g powers cover p p g assumed public knowledge
elgamal private key chosen random number x p associated public
key gx cleartext number encrypted follows
e r gr



r random number chosen encryptor decryption proceeds follows
r



x
gr x
useful feature elgamal encryption allows randomize encrypted value
generate encryption bearing similarity original value randomizing
e eq yields








e r g r r r gr r
still decodes encrypt booleans represent false true
value z allows us compute operations
e true e

e false e

e e e
cooperative elgamal encryption
previous elgamal encryption scheme decryption performed single step
private key secret agent originally encrypted message
however possible perform elgamal encryption way agents
need cooperate order perform decryption possible use
compound elgamal key x generated cooperatively agents pedersen
distributed key generation elgamal key pairs xi yi n agents combined following fashion obtain compound key pair x
x ni xi

ni yi

distributed decryption agent publishes decryption share xi message
decrypted follows


x
ni xi



fileaute faltings

appendix b routing messages along circular variable ordering
order implement round robin exchange vectors briefly presented section
variables ordered along circular ordering mapped chosen pseudo tree
illustrated figure page variable needs able send message
previous variable e clock wise ordering challenge
neighboring variables communicate directly furthermore protect agent
topology privacy agent know overall circular ordering solve issue
used p dpop leaute faltings route messages
sending message clock wise circular variable ordering
procedure toprevious variable x
x root pseudo tree send message last xs last child
else send message prev xs parent
procedure routemessages variable x
loop

wait incoming message type neighbor yi

type last

x leaf deliver message x

else send message last xs last child

else type prev

yi xs first child deliver message x

else send message last child yi xs list children
consider instance message agent x wants send previous
variable x x know agent x wraps prev
message sends parent variable x line sender variable x
x first child x infers deliver line consider
x wants forward previous variable x x
know x sends message prev parent variable x
reacts sending message last last child preceding x list children
x line last messages indicate payload delivered
last leaf current subtree line therefore x delivers line since
children root wants send message previous variable uses
last message forward last leaf overall pseudo tree line
theorem guarantees full agent privacy
proof goal precisely address agent privacy issues pseudotree rerooting procedure involves variable sending message previous
variable circular ordering variables guarantee exist
circular ordering two consecutive variables owned neighboring agents
necessary protect agent privacy therefore responsible routing
messages paths involve communication neighboring agents
routing procedure involves encapsulating routed messages inside
prev last messages contain payload therefore long


fiprotecting privacy thru distributed computation multi agent decision making

routed messages contain information used identify nonneighboring agent routing procedure guarantees agent privacy
theorem guarantees full topology privacy
proof purpose enable variables propagate messages along
circular variable ordering without need know topological information
constraint graph knowledge respective pseudo parents
pseudo children pseudo tree toprevious makes possible send message
previous variable circular ordering without knowing variable
reception prev message indicates sender child wants
included message delivered previous variable
recipient prev message unknown descendant thereof
reception last message ones parent indicates unknown
variable unknown root pseudo tree unknown child
unknown ancestor another branch wants delivered previous variable
ones descendant pseudo tree

references
ben goldwasser wigderson completeness theorems noncryptographic fault tolerant distributed computation extended abstract proceedings twentieth annual acm symposium theory computing stoc
pp
bilogrevic jadliwala hubaux j p aad niemi v privacy preserving
activity scheduling mobile devices proceedings first acm conference
data application security privacy codaspy pp
brito meseguer p distributed forward checking proceedings
ninth international conference principles practice constraint programming
cp vol lecture notes computer science pp
brito meseguer p distributed forward checking may lie privacy
proceedings ninth international workshop distributed constraint reasoning
cp dcr
brito meseguer p cluster tree elimination distributed constraint optimization quality guarantees fundamenta informaticae
chechetka sycara k commitment branch bound search distributed constraint optimization proceedings fifth international joint conference autonomous agents multiagent systems aamas pp

dechter r constraint processing morgan kaufmann


fileaute faltings

doshi p matsui silaghi c yokoo zanker distributed private
constraint optimization proceedings ieee wic acm international
conference intelligent agent technology iat pp
elgamal public key cryptosystem signature scheme discrete
logarithms ieee transactions information theory
faltings b leaute petcu privacy guarantees distributed constraint satisfaction proceedings ieee wic acm international conference intelligent agent technology iat pp
franzin freuder e c rossi f wallace r j multi agent constraint
systems preferences efficiency solution quality privacy loss computational
intelligence
gentry c fully homomorphic encryption ideal lattices proceedings
forty first annual acm symposium theory computing stoc pp
acm special interest group computation theory sigact
gershman meisels zivan r asynchronous forward bounding distributed constraints optimization proceedings seventeenth european conference artificial intelligence ecai pp
goldreich foundations cryptography vol basic applications cambridge
university press
greenstadt r grosz b smith ssdpop secret sharing
improve privacy dcop proceedings ninth international workshop
distributed constraint reasoning cp dcr
greenstadt r pearce j p tambe analysis privacy loss distributed
constraint optimization proceedings twenty first national conference
artificial intelligence aaai pp
grinshpoun meisels completeness performance apo
journal artificial intelligence jair
grubshtein grinshpoun meisels zivan r asymmetric distributed
constraint optimization proceedings ijcai distributed constraint reasoning workshop dcr pp
gutierrez p meseguer p bnb adopt several soft arc consistency
levels proceedings nineteenth european conference artificial intelligence
ecai frontiers artificial intelligence applications pp
herlea claessens j preneel b neven g piessens f decker b securely scheduling meeting proceedings sixteenth international conference
information security trusted information decade challenge sec
international federation information processing ifip series pp
hirayama k yokoo distributed partial constraint satisfaction
proceedings third international conference principles practice
constraint programming cp vol lecture notes computer science
pp


fiprotecting privacy thru distributed computation multi agent decision making

kearns j littman l singh p graphical game theory
proceedings seventeenth conference uncertainty artificial intelligence
uai pp
kuchcinski k szymanek r java library jacop java constraint programming
solver http jacop osolpro com
leaute distributed constraint optimization privacy guarantees stochastic
uncertainty phd thesis ecole polytechnique federale de lausanne epfl
leaute faltings b privacy preserving multi agent constraint satisfaction
proceedings ieee international conference privacy security risk
trust passat pp
leaute faltings b coordinating logistics operations privacy guarantees proceedings twenty second international joint conference artificial
intelligence ijcai pp
leaute ottens b szymanek r frodo open source framework
distributed constraint optimization proc ijcai distributed constraint
reasoning workshop dcr pp http frodo sourceforge net
leyton brown k pearson shoham towards universal test suite
combinatorial auction proceedings second acm conference
electronic commerce ec pp acm special interest group electronic
commerce sigecom http www cs ubc ca kevinlb cats
maheswaran r pearce j p bowring e varakantham p tambe
privacy loss distributed constraint reasoning quantitative framework analysis
applications autonomous agents multi agent systems jaamas

maheswaran r tambe bowring e pearce j p varakantham p
taking dcop real world efficient complete solutions distributed multievent scheduling proceedings third international joint conference autonomous agents multiagent systems aamas vol pp acm
special interest group artificial intelligence sigart
mailler r lesser v r mediation protocol distributed constraint
satisfaction proceedings fourth international workshop distributed constraint reasoning dcr
meisels zivan r asynchronous forward checking discsps proceedings
fourth international workshop distributed constraint reasoning dcr
modi p j shen w tambe yokoo adopt asynchronous distributed constraint optimization quality guarantees artificial intelligence

netzer meisels grubshtein concurrent forward bounding dcops
proceedings twelfth international workshop distributed constraint reasoning dcr pp


fileaute faltings

pedersen p threshold cryptosystem without trusted party extended abstract advances cryptology eurocrypt workshop theory
application cryptographic techniques proceedings vol lecture notes
computer science pp
petcu faltings b dpop scalable method multiagent constraint
optimization proceedings nineteenth international joint conference
artificial intelligence ijcai pp
petcu faltings b parkes c dpop faithful distributed implementation efficient social choice journal artificial intelligence
jair
rassenti j smith v l bulfin r l combinatorial auction mechanism
airport time slot allocation bell journal economics
shamir share secret communications acm
silaghi c hiding absence solution distributed constraint satisfaction
poster proceedings eighteenth international florida artificial
intelligence society conference flairs pp
silaghi c b secure discsp solvers generalized vickrey auctions
complete stochastic techniques proceedings ijcai distributed constraint reasoning workshop
silaghi c faltings b petcu secure combinatorial optimization simulating dfs tree variable elimination proceedings ninth international
symposium artificial intelligence mathematics
silaghi c mitra distributed constraint satisfaction optimization
privacy enforcement proceedings ieee wic acm international
conference intelligent agent technology iat pp
silaghi c sam haroud faltings b asynchronous search aggregations proceedings seventeenth national conference artificial intelligence twelfth conference innovative applications artificial intelligence
aaai iaai pp
singh soni v wellman p computing approximate bayes nash equilibria
tree games incomplete information proceedings fifth acm conference
electronic commerce ec pp
sultanik e lass r n regli w c dcopolis framework simulating
deploying distributed constraint optimization proceedings
ninth international workshop distributed constraint reasoning cp dcr
tsiounis yung security elgamal encryption proceedings first international workshop practice theory public key
cryptography pkc vol lecture notes computer science pp
vickrey koller multi agent solving graphical games proceedings eighteenth national conference artificial intelligence aaai
pp


fiprotecting privacy thru distributed computation multi agent decision making

vinyals rodrguez aguilar j cerquides j constructing unifying
theory dynamic programming dcop via generalized distributive
law autonomous agents multi agent systems jaamas
wallace r j freuder e c constraint reasoning privacy efficiency
tradeoffs multi agent solving artificial intelligence
yeoh w felner koenig bnb adopt asynchronous branch andbound dcop journal artificial intelligence jair

yokoo asynchronous weak commitment search solving distributed constraint
satisfaction proceedings first international conference principles practice constraint programming cp lecture notes
computer science pp
yokoo durfee e h ishida kuwabara k distributed constraint satisfaction formalizing distributed solving proceedings twelfth
international conference distributed computing systems icdcs pp

yokoo suzuki k secure multi agent dynamic programming homomorphic encryption application combinatorial auctions proceedings
first international joint conference autonomous agents multi agent
systems aamas pp
yokoo suzuki k hirayama k secure distributed constraint satisfaction
reaching agreement without revealing private information proc th intl conf
principles practice constraint prog cp vol lncs pp
yokoo suzuki k hirayama k secure distributed constraint satisfaction
reaching agreement without revealing private information artificial intelligence
distributed constraint satisfaction
zivan r meisels concurrent dynamic backtracking distributed csps
proceedings tenth international conference principles practice
constraint programming cp vol lecture notes computer science
pp




