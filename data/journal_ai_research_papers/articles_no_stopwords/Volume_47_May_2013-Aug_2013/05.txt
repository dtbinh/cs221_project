Journal Artificial Intelligence Research 47 (2013) 649-695

Submitted 02/13; published 08/13

Protecting Privacy Distributed Computation
Multi-agent Decision Making
Thomas Leaute
Boi Faltings

thomas.leaute@a3.epfl.ch
boi.faltings@epfl.ch

Ecole Polytechnique Federale de Lausanne (EPFL)
Artificial Intelligence Laboratory (LIA)
Station 14
CH-1015 Lausanne, Switzerland

Abstract
large-scale theft data corporate servers becoming increasingly common,
becomes interesting examine alternatives paradigm centralizing sensitive data
large databases. Instead, one could use cryptography distributed computation
sensitive data supplied processed encrypted form, final
result made known. paper, examine paradigm used
implement constraint satisfaction, technique solve broad class AI problems
resource allocation, planning, scheduling, diagnosis. previous work
privacy constraint satisfaction attempted protect specific types information,
particular feasibility particular combinations decisions. formalize
extend restricted notions privacy introducing four types private information,
including feasibility decisions final decisions made, identities
participants topology problem. present distributed algorithms
allow computing solutions constraint satisfaction problems maintaining four
types privacy. formally prove privacy properties algorithms, show
experiments compare respective performance benchmark problems.

1. Introduction
Protecting privacy information becoming crucial concern many users
increasingly ubiquitous Information Communication Technologies. Companies invest
lot effort keeping secret internal costs future development strategies
actors market, importantly competitors. Individuals
need privacy personal information: instance, carelessly disclosing ones
activity schedule location might reveal burglars opportunities break ones home.
hand, accessing using private information often necessary solve
problems depend data. context supply chain management, companies
need exchange information contractors subcontractors quantities
goods must produced, price. scheduling meetings various
events friends co-workers, individuals confronted challenge taking
coordinated scheduling decisions, protecting respective availability schedules.
Artificial Intelligence crucial tool help people make better decisions
privacy concerns, delegating part decision problem personal intelligent
agents executing carefully chosen algorithms far complex performed
2013 AI Access Foundation. rights reserved.

fiLeaute & Faltings

human alone. particular, framework Constraint Satisfaction Problems
(CSPs) core AI technology successfully applied many decision-making
problems, configuration scheduling, solving strategic games. show
distributed AI algorithms used solve CSPs, providing strong guarantees
privacy problem knowledge, use techniques borrowed
cryptography. makes possible solve coordination problems depend secret
data, without reveal data parties. hand, distributed,
encrypted computation involving message exchange cost terms performance,
suitable tradeoff privacy scalability must found.
1.1 Motivating Examples
paper, present set novel, privacy-protecting algorithms Distributed Constraint Satisfaction Problems (DisCSPs), wide class multi-agent decision-making problems applications many problems configuration, scheduling, planning, design
diagnosis. consider three examples illustrate privacy requirements might
arise: meeting scheduling, airport slot allocation, computing game equilibria.
meeting scheduling problem (Maheswaran, Tambe, Bowring, Pearce, & Varakantham, 2004), number meetings need scheduled, involving possibly overlapping sets
participants. Taking account respective availability constraints, participants
given meeting must agree time meeting. One given participant
involved multiple meetings, creates constraints meetings. problem class, participants usually want protect privacy respective availability
schedules, well lists meetings involved in.
Another problem class airport slot allocation (Rassenti, Smith, & Bulfin, 1982),
airlines express interests combinations takeoff landing time slots airports, corresponding possible travel routes aircraft. end goal airports
efficiently allocate slots airlines, point view airlines crucial
combinations slots interested remain private, indicate
routes intend fly, sensitive strategic information want hide
competitors.
Finally, consider general class one-shot strategic games, party game
(Singh, Soni, & Wellman, 2004): players invited party, must decide whether
attend, based respective intrinsic costs attendance, whether people
dislike choose attend. Players would best play strategies form
Nash equilibrium, single player better deviating chosen
strategy. problem computing equilibrium typical example multiagent decision-making problem, privacy issue: players necessarily want
reveal attendance costs, whether dislike another invitee.
1.2 Four Types Private Information
seen previous examples, information participants would
keep private differ nature; propose classify four privacy types.
briefly introduce illustrate here; formal definitions given Section 2.2.1.
650

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

1. Agent privacy relates identities participants. Consider instance
CEO wants schedule two meetings respectively journalist
another companys CEO. Revealing journalist CEOs involvement
decision-making problem could leak companies plans merge.
case agent privacy considered critical.
2. Topology privacy covers information presence constraints.
type critical information airline companies want keep secret airport
slot allocation problem: presence constraint airline specific
airport reveals airlines strategic plans offer flights airport.
3. Constraint privacy nature constraints. covers instance
participants availability schedules meeting scheduling problem, and,
party game, whether player likes dislikes invitees.
4. Decision privacy solution eventually chosen problem.
Depending problem class, type privacy may may relevant.
meeting scheduling problem, time chosen meeting necessarily
revealed participants meeting; however desirable hide
information non-attendees.
previous work privacy DisCSP, assume participants honest,
curious (Goldreich, 2009), honestly follow algorithm, interested
learning much possible agents private information based messages exchanged. Note honesty assumption mean agents
assumed faithfully report true constraints algorithm; may tempted
strategize reporting slightly different constraints, hoping would lead algorithm select solution problem deem preferable them. issue
incentive-compatibility addressed related work Petcu, Faltings,
Parkes (2008), orthogonal issue privacy addressed paper. Furthermore, agent would take risk reporting constraints different true constraints:
reporting relaxed constraints could yield solution violates true constraints
would therefore viable, reporting tighter constraints could make overall
problem infeasible algorithm fail find solution all.
hand, algorithms depart previous work two respects. First,
previous work almost exclusively focused constraint privacy, often ignoring agent,
topology decision privacy. show address four types, algorithms
propose correspond various points tradeoff different levels privacy
efficiency. Second, literature focuses quantitatively measuring
reducing amount privacy loss various DisCSP algorithms, developed
algorithms give strong guarantees certain pieces private information
leaked. contrast, previous privacy-protecting algorithms, typically case
piece private information may leaked (small) probability.
rest paper organized follows. Section 2 first formally defines DisCSP
framework four aforementioned types privacy. Section 3 presents first
algorithm, called P-DPOP+. Section 4 describes P3/2 -DPOP+ algorithm,
651

fiLeaute & Faltings

variant achieves higher level decision privacy, expense additional
computational overhead. Another variant, called P2 -DPOP+, introduced Section 5
order improve constraint privacy. Finally, Section 6 compares performance
algorithms previous state art, several classes benchmarks.

2. Preliminaries
section first formally defines DisCSP framework (Section 2.1), introduces
four types privacy (Section 2.2).
2.1 Distributed Constraint Satisfaction
providing formal definition Distributed Constraint Satisfaction (Section 2.1.1),
recall existing algorithms DisCSP optimization variant (Section 2.1.2).
2.1.1 Definition
Distributed Constraint Satisfaction Problem formally defined follows.
Definition 1 (DisCSP). discrete DisCSP tuple < A, X , a, D, C >:
= {a1 , ..., ak } set agents;
X = {x1 , ..., xn } set variables;
: X mapping assigns control variable xi agent a(xi );
= {D1 , ..., Dn } set finite variable domains; variable xi takes values Di ;
C = {c1 , ..., cm } set constraints, ci s(ci )-ary function scope
(xi1 , , xis(ci ) ), ci : Di1 .. Dis(ci ) {false, true}, assigning false infeasible
tuples, true feasible ones.
V
solution complete assignment conjunction ci C ci = true,
case exactly assignment consistent constraints.
important assumptions DisCSP framework following. First,
assume details given constraint ci known agents involved;
agent wants keep constraints private, formulate way
involve variables controls. Furthermore, assume two neighboring agents
(i.e. agents share least one constraint) able communicate
securely, messages delivered FIFO order finite time.
hand, assume two non-neighboring agents initially ignore everything
other, even including involvement problem. particular, DisCSP algorithm
protects agent privacy require communicate directly,
even allow discover others presence. Finally, assume agent honestly
follows protocol, focus preventing private information leaks agents.
Figure 1 introduces simple graph coloring problem instance used illustrate algorithms throughout rest paper. assume five nodes
652

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

R 6= x1

6=

6=
x2

x4 6= B
6=

6=

x3

6=

x5 6 {B, R}

Figure 1: DisCSP constraint graph simple graph coloring problem instance.

graph correspond five different agents, must choose color among red,
blue green. decisions modeled five variables x1 , . . . , x5 domains
{R, B, G}. agent may express secret, unary constraint variable; instance,
x1 want assigned color red. Binary, inequality constraints imposed
pair neighboring nodes, known two agents involved.
Distributed Constraint Optimization (DCOP) extension DisCSP formalism,
constraints specify variable assignments feasible infeasible,
assign costs (or utilities) assignments. (optimal) solution
DCOP one minimizes sum costs (or maximizes sum utilities).
algorithms paper easily generalized solve DCOPs, complexity
increase linear upper bound (assumed integer) cost
optimal solution. generalization left outside scope paper sake
conciseness, addressed Leaute Faltings (2011) Leaute (2011).
2.1.2 Complete Algorithms DisCSPs
range distributed algorithms exist literature solve DisCSPs DCOPs.
seen belonging two classes, depending order variables.
largest class consists algorithms order variables along linear order,
ABT (Yokoo, Durfee, Ishida, & Kuwabara, 1992), AWC (Yokoo, 1995), SynchBB (Hirayama & Yokoo, 1997), AAS (Silaghi, Sam-Haroud, & Faltings, 2000), AFC (Meisels &
Zivan, 2003), DisFC (Brito & Meseguer, 2003), (Comp)APO (Mailler & Lesser, 2003; Grinshpoun & Meisels, 2008), ConcDB (Zivan & Meisels, 2004), AFB (Gershman, Meisels, &
Zivan, 2006) ConcFB (Netzer, Meisels, & Grubshtein, 2010). linear order may
chosen fixed initially algorithm run, dynamically revised online.
second class, variables ordered along tree-based partial order. includes
ADOPT (Modi, Shen, Tambe, & Yokoo, 2005) variants BnB-ADOPT (Yeoh,
Felner, & Koenig, 2010) BnB-ADOPT+ (Gutierrez & Meseguer, 2010), DPOP (Petcu
& Faltings, 2005) countless variants, NCBB (Chechetka & Sycara, 2006),
order variables following pseudo-tree (Definition 2). Among aforementioned
pseudo-tree-based algorithms, DPOP one using Dynamic Programming (DP),
others based search. algorithms proposed perform DP
different partial variable orders: Action-GDL uses junction trees (Vinyals, RodrguezAguilar, & Cerquides, 2010), DCTE cluster trees (Brito & Meseguer, 2010).
653

fiLeaute & Faltings

2.1.3 DPOP Algorithm
DPOP algorithm originally designed solve optimization problems (DCOPs)
described terms utility maximization. One way apply pure satisfaction problems
(DisCSPs) first reformulate DisCSP Max-DisCSP, constraints
longer boolean rather take values {0, 1}, 0 stands feasibility
1 infeasibility. cost-minimizing variant DPOP (described below)
applied find solution minimal cost, cost (hereafter called feasibility
value) corresponds number constraint violations (which want equal 0).
Overview Algorithm DPOP instance general bucket elimination
scheme Dechter (2003), performed distributedly (Algorithm 1). requires first arranging
constraint graph pseudo-tree, formally defined follows.
Definition 2 (Pseudo-tree). pseudo-tree generalization tree, node
allowed links (back-edges) remote ancestors (pseudo-parents) remote
descendants (pseudo-children), never nodes branches tree.
pseudo-tree arrangement constraint graph Figure 1 illustrated Figure 2.
pseudo-tree naturally decomposes original problem two, loosely coupled subproblems, corresponding two branches, perform rest algorithm
parallel. Figure 2 shows FEAS messages (originally called UTIL messages
context utility maximization) exchanged propagation feasibility
values, following multi-party dynamic programming computation (lines 1 12).
Algorithm 1 Overal DPOP algorithm, variable x
Require: pseudo-tree ordering variables; px denotes xs parent
1: // (UTIL propagation) Propagate feasibility values pseudo-tree:
2: m(x, px , ) c{c C | xscope(c) scope(c )(childrenx pseudo childrenx )=} c(x, )
// Join received messages:
yi childrenx
5:
Wait message (FEAS, mi (x, )) yi
6:
sepyi scope(mi )
7:
m(x, px , ) m(x, px , ) + mi (x, )
3:
4:

// Project x:
x root variable
10:
x (px , ) arg minx {m(x, px , )}
11:
Send message (FEAS, m(x (px , ), px , )) px
12: else x arg minx {m(x)} // m(x, px , ) actually depends x
8:

9:

13:
14:
15:
16:
17:

// (VALUE propagation) Propagate decisions top-down along pseudo-tree:
x root
Wait message (DECISION, px , ) parent px
x x (px = px , )
yi childrenx send message (DECISION, sepyi ) yi
654

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

x2

x3 x2
R B G
0 1 0
x5 x3
x3
R
0
B
0
G
1

x4 x3
x2
x3 R B G
R
0 1 0
B
0 0 0
G
0 0 0

x2

x3

x5

x4

x1

x1 x4
x2
x4 R B G
R
0 0 0
B
0 0 1
G
0 1 0

Figure 2: Multiparty dynamic programming computation feasible value x2 , based
pseudo-tree arrangement constraint graph Figure 1. dashed
edge represents back-edge pseudo-parent pseudo-tree.

part algorithm, messages travel bottom-up along tree edges. Consider instance
message sent agent a(x5 ) parent agent a(x3 ). message result
projection (lines 10 11) variable x5 conjunction (line 2) x5 two
constraints x5 6= x3 x5 6= B, summarizes minimal number constraint violations a(x5 ) achieve, function ancestor variable x3 . generally,
message sent variable x summarizes minimal number constraint violations
achievable aggregate subproblem owned entire subtree rooted x,
function whose scope called separator x (line 6). DPOP, separator x necessarily includes xs parent px , potentially ancestor variables; indicated
notation m(px , ). instance, message x4 x3 summarizes minimal number
constraint violations achievable entire subtree rooted x4 , function x4
separator {px4 = x3 , x2 }. Notice separator variable x contain variables
neighbors x; example, x2 x4 separator descendent x4
constraint x2 . privacy-aware algorithms presented later paper,
notion separator extended allow separators necessarily include
parent variable, may include multiple codenames referring variables,
might necessarily ancestors pseudo-tree.
Upon receiving messages x5 x3 x4 x3 (line 5), agent a(x3 ) joins
(line 7) constraint x3 6= x2 . Variable x3 projected resulting joint
table, produces message x3 x2 (lines 10 11). end feasibility
propagation (line 12), root variable x2 chooses value x2 minimizes
number constraint violations entire problem (e.g. x2 = R). decision
propagated downwards along tree-edges via DECISION messages (originally called
VALUE messages) variables assigned optimal values (lines 13 17).
655

fiLeaute & Faltings

Complexity Given pseudo-tree ordering n variables, DPOPs bottom-up
top-down phases exchange exactly (n 1) messages (one tree edge).
However, DECISION message contains (n 1) variable assignments,
FEAS message sent given variable x contain exponentially many feasibility values,
contains table representation function |sepx | variables. size
sepmax
largest FEAS message therefore O(Dmax
), Dmax size largest
variable domain, sepmax = maxx |sepx | < n 1 width pseudo-tree.
best case, width equal treewidth constraint graph; however finding
pseudo-tree achieves minimal width NP-hard. practice, pseudo-tree
generated heuristic, distributed, depth-first traversal constraint graph (Online
Appendix 1), producing so-called DFS tree pseudo-tree parentchild relationships neighbors constraint graph. Since DPOP exchanges
(n 1) FEAS messages, overall complexity terms runtime (measured number
sepmax
constraint checks), memory, information exchange O(n Dmax
).
Privacy Properties privacy-aware algorithms Section 3 based DPOP,
two desirable properties allow higher levels privacy. First, DPOP
requires message exchanges neighboring agents, provided pseudotree used DFS tree; necessary protect agent privacy. Greenstadt, Pearce,
Tambe (2006) made opposite claim pseudo-trees detrimental privacy
compared linear orderings; however claim valid type privacy
considered constraint privacy, hold agent privacy topology privacy
guaranteed, i.e. pseudo-tree publicly known agents. second, DPinherited property DPOPs performance depend constraint tightness,
i.e. easy hard satisfy constraint. other, search-based algorithms,
inferences constraint tightness made observing runtime amount
information exchanged (Silaghi & Mitra, 2004). case meeting scheduling problems,
constraint tightness maps directly participants levels availability, private
information. application domains leak constraint tightness tolerable,
algorithms based search rather DP used, many privacy-enhancing
techniques presented paper DPOP applicable search-based algorithms.
2.2 Privacy DisCSPs
Section 2.2.1 formally defines four types privacy considered paper. Section 2.2.2
recalls previous work attempted address various subsets privacy types.
2.2.1 Privacy Definitions
Definition 3 introduces concept semi-private information (Faltings, Leaute, & Petcu,
2008), may inevitably leaked DisCSP algorithm.
Definition 3 (Semi-private information). Semi-private information refers information
problem and/or solution agent might consider private,
inevitably leaked agents views chosen solution DisCSP.
words, semi-private information covers everything given agent discover
agents making inferences simply based initial knowledge problem
656

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

values variables take solution. instance, graph coloring problem
involving two colors, node infer color neighbors
color assigned chosen solution, provided solution correct. Excluding
semi-private information, distinguish four types private information agents
may desire protect (Faltings et al., 2008).
Definition 4 (Agent privacy). agent able discover identity, even
existence non-neighboring agents. particular consequence type privacy
two agents allowed communicate directly share constraint.
Figure 1, means instance agent a(x1 ) able discover
existence identities agents a(x3 ) a(x5 ). Even two non-neighboring agents
communicate directly, agent privacy might still leaked contents messages;
paper propose method based codenames fully protect agent privacy.
Definition 5 (Topology privacy). agent able discover existence
topological constructs constraint graph, nodes (i.e. variables), edges (i.e.
constraints), cycles, unless owns variable involved construct.
Figure 1, topology privacy means instance agent a(x1 ) discover
many neighbors x2 besides itself. However, a(x1 ) might discover existence
cycle involving x1 , x2 x4 . tolerated x1 involved cycle,
a(x1 ) discover length cycle (i.e. x2 x4 share neighbor).
Definition 6 (Constraint privacy). agent able discover nature
constraint involve variable owns.
Figure 1, example breach constraint privacy would agent a(x1 )
able discover agent a(x4 ) want assigned color blue.
type privacy DisCSP literature mostly focuses on.
Definition 7 (Decision privacy). agent able discover value another
agents variable takes chosen solution (modulo semi-private information).
distributed graph coloring problem, means agent discover color
neighbor (let alone non-neighboring agent) solution chosen problem.
2.2.2 Previous Work Privacy DisCSP
discussing information may leaked given algorithm, prevent
it, important clarify information assumed initially known agent.
Initial Knowledge Assumptions paper, use following three assumptions,
currently widely used DisCSP literature.
1. agent knows agents variables neighbors variables,
know agents (not even existence);
2. variable domain known owner agent agents owning
neighboring variables, agents ignore existence variable;
657

fiLeaute & Faltings

3. constraint fully known agents owning variables scope,
agent knows anything constraint (not even existence).
Brito Meseguer (2003) introduced Partially Known Constraints (PKCs), whose
scopes known agents involved, knowledge whose nature (which assignments allowed disallowed) distributed among agents. relaxation
Assumption 3; however worth noting algorithms presented paper
still support PKCs without introducing privacy leaks enforcing assumption,
PKC decomposed number constraints copy variables
Assumption 3 holds. instance, agents a1 . . . share knowledge unary PKC
variable x, constraint decomposed n unary constraints,
constraint ci known fully agent ai expressed copy
variable xi owned ai . Equality constraints added problem enforce equality
copy variables. However, introduction copy variables detrimental
decision privacy. Grubshtein, Grinshpoun, Meisels, Zivan (2009) later proposed
similar concept asymmetric constraints, reformulated symmetric
constraints copy variables purpose applying algorithms.
previous work adopted dual approach, assuming variables public
known agents, constraint known one agent (Silaghi et al., 2000;
Yokoo, Suzuki, & Hirayama, 2002; Silaghi, 2005a). Silaghi (2005b) even proposed framework constraints secret everyone. dual approach disadvantage necessarily violating topology privacy, since variables public.
Measuring Constraint Privacy Loss literature privacy DisCSPs
focuses constraint privacy. Metrics proposed evaluate constraint privacy
loss algorithms, particular distributed meeting scheduling (Franzin, Freuder, Rossi,
& Wallace, 2004; Wallace & Freuder, 2005). Maheswaran, Pearce, Bowring, Varakantham,
Tambe (2006) designed framework called Valuation Possible States (VPS)
used measure constraint privacy loss OptAPO SynchBB algorithms,
considered impact whether problem topology public partially
known agents. Greenstadt et al. (2006) applied VPS evaluate DPOP
ADOPT meeting scheduling problems, assumption problem topology
public. Doshi, Matsui, Silaghi, Yokoo, Zanker (2008) proposed consider cost
privacy loss optimization problems, order elegantly balance privacy optimality.
Preventing Constraint Privacy Loss previous work proposed approaches
partially reduce constraint privacy loss. instance, Brito Meseguer (2007) described
modification Distributed Forward Checking (DisFC) algorithm DisCSPs
agents allowed lie finite time order achieve higher levels privacy. However, performance search-based algorithms DisFC leaks information
constraint tightness, explained end Section 2.1.3. avoid subtle privacy
leak, one must either perform full exhaustive search, option chosen Silaghi,
resort Dynamic Programming, option chosen paper.
cryptographic technique secret sharing (Shamir, 1979; Ben-Or, Goldwasser, &
Wigderson, 1988) applied Silaghi, Faltings, Petcu (2006) Greenstadt,
Grosz, Smith (2007) lower constraint privacy DPOP, assuming constraint
graph topology public knowledge. Cryptography applied provide strong
658

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

guarantees constraint privacy preservation multi-agent decision making. instance,
Yokoo Suzuki (2002), Yokoo et al. (2002) Yokoo, Suzuki, Hirayama (2005)
showed public key encryption scheme used solve DisCSPs using multiple
servers, protecting constraint privacy decision privacy. Bilogrevic, Jadliwala,
Hubaux, Aad, Niemi (2011) solved single-meeting scheduling problems using similar
techniques, one semi-trusted server. paper however, consider algorithms
make use third parties, third parties might available. Herlea,
Claessens, Preneel, Neven, Piessens, Decker (2001) showed use Secure Multiparty
Computation (SMC) 1 securely schedule single meeting, without relying servers.
SMC, agents collaboratively compute value given, publicly known function
private inputs, without revealing inputs. Herlea et al. (2001), inputs
participants availability given time, function outputs whether
available.
MPC-DisCSP4 Algorithm Silaghi (2005a) applied SMC solve general
DisCSPs, private inputs agents constraint valuations, function
returns randomly chosen solution. algorithm proceeds follows (Leaute, 2011).
agent ai first creates vector one entry per candidate solution DisCSP, equal
1 candidate solution satisfies ai private constraints, 0 otherwise. reduce
size , candidate solutions may filtered publicly known constraints,
exists any. Using Shamirs polynomial secret sharing technique (Shamir, 1979; BenOr et al., 1988), agent ai sends one secret share Fij vector
agent aj , receives corresponding secret shares Fji respective vectors. Agent ai
multiplies together secret shares received. multiplication Shamir secret
shares non-trivial operation, secret share value polynomial,
multiplying two polynomials increases degree output, must always remain
lower number |A| agents resolvable. Therefore, multiplication
two secret shares, agent ai must perform complex sequence operations involving
exchange messages order reduce degree output.
performing (|A| 1) pairwise multiplications secret shares, agent ai vector contains secret shares 1 entries corresponding globally feasible solutions.
Agent ai performs transformation one secret share 1
remains, identifying one particular feasible solution (if exists one). selecting
first entry would posteriori reveal previous entries correspond infeasible
solutions DisCSP; prevent privacy leak, vector first collaboratively,
randomly permuted using mix-net. Agent ai performs sequence iterative operations (including communication-intensive multiplications) set entries
secret shares 0, except one secret share 1 corresponding chosen solution
DisCSP (if any). vector un-shuffled re-traversing mix-net
reverse. Finally, agent ai compute secret shares domain index variables
chosen assignment, reveal secret shares owners variables.
algorithm numerous drawbacks. First, agent must know variables
domains construct initial vector , immediately violates agent privacy
topology privacy (Table 3.3, page 664). Second, Shamirs secret sharing scheme
1. Silaghi uses different acronym MPC concept.

659

fiLeaute & Faltings

majority threshold scheme, means least half agents collude,
discover everyones private information. Even though, paper, assuming
agents honest collude, consequence threshold
scheme provide privacy guarantee problem involves two agents.
Third, algorithm often practical small problems, performs
full exhaustive search; demonstrated experimental results Section 6.

3. P-DPOP+ : Full Agent Privacy Partial Topology, Constraint
Decision Privacy
section describes variant DPOP algorithm guarantees full agent privacy.
partially protects topology, constraint, decision privacy. Algorithm 2
improvement P-DPOP algorithm originally proposed (Faltings et al., 2008).
DPOP, algorithm performs dynamic programming DFS-tree ordering
variables (Figure 2). Algorithms first elect one variable, generate DFS tree
rooted variable given Online Appendices 1 2. algorithms
reveal pseudo-tree entirety agent; instead, agent discovers
(pseudo-)parents (pseudo-)children variables. sake simplicity,
hereafter assume without loss generality constraint graph consists single
component. problem actually consisted two fully decoupled subproblems,
subproblem would solved parallel, independently others.
Algorithm 2 Overal P-DPOP+ algorithm, variable x
Require: DFS-tree ordering variables
1: // Choose exchange codenames x domain Dx :
2: Wait message (CODES, yix , Dyxi , yxi ) yi {parentx } pseudo parentsx
3: yi childrenx pseudo childrenx
4:
xyi large random number
5:
Dxyi list |Dx | random, unique identifiers
6:
xyi random permutation [1, . . . , |Dx |]
7:
Send message (CODES, xyi , Dxyi , xyi ) yi

12:

// Choose exchange obfuscation key x:
Wait record message (KEY, keyyxi ) yi pseudo parentsx (if any)
yi pseudo childrenx
keyxyi vector large random numbers B bits, indexed Dx
Send message (KEY, keyxyi ) yi

13:

Propagate feasibility values pseudo-tree (Algorithm 3, Section 3.1)

14:

// Propagate decisions top-down along pseudo-tree (Section 3.2):
x root
Wait message (DECISION, px , ) parent px
x x (px = px , ) // x () computed Algorithm 3, line 21
yi childrenx
) yi , sepyi Algorithm 3, line 12
Send message (DECISION, sep


8:
9:
10:
11:

15:
16:
17:
18:
19:

660

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

3.1 Finding Feasible Value Root Variable
already illustrated DPOP Section 2.1.3, agents perform bottom-up propagation feasibility values along pseudo-tree. done Algorithm 3,
extension DPOPs UTIL propagation phase (the extensions indicated comments
bold), improves algorithm originally proposed (Faltings et al., 2008)
patching important constraint privacy leak single-variable FEAS messages
sent variables singleton separators. following sections describe obfuscation
techniques used protect private information could leaked feasibility
messages, using codenames (Section 3.1.1) addition random numbers (Section 3.1.2).
Algorithm 3 Algorithm find feasible value root DFS tree, variable x
Require: DFS-tree ordering variables; px denotes xs parent
1: // Join local constraints:
2: m(x, px , ) c{c C | xscope(c) scope(c )(childrenx pseudo childrenx )=} c(x, )
3:
4:
5:

// Apply codenames:
yi {px } pseudo parentsx
m(x, px , ) replace (yi , Dyi ) m(x, px , ) (yix , Dyxi ) Algorithm 2, line 2,
apply permutation yxi Dyxi

// Obfuscate infeasible entries:
r large, positive,
random number B bits

m(x, px , )
m(x, px , ) = 0
8: m(x, px , )
m(x, px , ) + r m(x, px , ) > 0
6:
7:

9:
10:
11:
12:
13:
14:
15:

// Join received messages:
yi childrenx
Wait message (FEAS, mi (x, )) yi
sepyi scope(mi )
z childrenx pseudo childrenx // resolve codenames
mi (x, ) identify (xz , Dxz ) (x, Dx ) mi (x, ) (if xz present)
m(x, px , ) m(x, px , ) + mi (x, )

// De-obfuscate feasibility values respect x:
17: yi pseudo childrenx
18:
m(x, px , ) m(x, px , ) keyxyi (x) // keyxyi Algorithm 2, line 11
16:

// Project x:
x root variable
21:
x (px , ) arg minx {m(x, px , )}
22:
m(px , ) minx {m(x, px , )}
19:

20:

23:
24:
25:
26:
27:

// Obfuscate feasibility values:
yi pseudo parentsx
m(px , ) m(px , ) + keyyxi (yix ) // keyyxi Algorithm 2, line 9
Send message (FEAS, m(px , )) px
else x arg minx {m(x)} // m(x, px , ) actually depends x
661

fiLeaute & Faltings

3.1.1 Hiding Variable Names Values Using Codenames
Consider feasibility message x1 x4 sent agent a(x1 ) parent variable x4
Figure 2. message recalled Figure 3(a), reformulated terms minimizing
number constraint violations. message actually received cleartext, would
breach agent privacy topology privacy: agent a(x4 ) would able infer
dependency message variable x2 existence agent a(x2 ) (which violates
agent privacy) fact x2 neighbor one unknown nodes x1 .
x1 x4
x2
x4 R B G
R
0 0 0
B
0 0 1
G
0 1 0
(a) cleartext

x4
R
B
G

x1 x4
928372

0 0 0
0 0 1
0 1 0

(b) partly obfuscated

x4
R
B
G

x1 x4
928372


620961 983655
620961 983655
620961 983656


534687
534688
534687

(c) fully obfuscated

Figure 3: message sent agent a(x1 ) parent variable x4 Figure 2.

order patch privacy leaks, variable x2 domain D2 = {R, B, G} replaced random codenames xx2 1 = 928372 D2x1 = {, , } (Figure 3b) preliminarily
generated a(x2 ) communicated directly leaf back-edge (Algorithm 2,
lines 2 7). leaf applies codenames output message (Algorithm 3, line 5),
resolved propagation reaches root back-edge (Algorithm 3, line 14). knowing codenames, agents between, a(x4 ),
infer existence cycle constraint graph involving unknown ancestor descendent. tolerated definition topology privacy (Definition 5)
since involved cycle. secret, random permutation 2x1 applied
D2x1 ; useful problem classes variable domains public. Notice
x4 constraint x2 , reasoning would still hold, x2 would
sent different codename xx2 4 x4 , would able resolve
unknown codename xx2 1 x2 . case, x4 separator would {x3 , xx2 1 , xx2 4 },
message sent x3 would three-dimensional instead two-dimensional.
3.1.2 Obfuscating Feasibility Values
Hiding variable names values using codenames addresses leaks agent topology
privacy. However, address fact feasibility values message
x1 x4 Figure 3(b) violate constraint privacy, reveal x4 subtree
always find feasible solution subproblem x4 = R, regardless value
obfuscated variable 928372. patch privacy leak, feasibility values obfuscated
adding large, random numbers generated root back-edge (x2 )
sent secure channel leaf back-edge (Algorithm 2, lines 9 12).
number bits B random numbers problem-independent parameter
algorithm. obfuscation performed way different random number
662

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

added feasibility values associated value x2 , Figure 3(c), using
obfuscation key [620961, 983655, 534687]. random numbers added leaf
back-edge outgoing message (Algorithm 3, line 25), eventually
subtracted propagation reaches root back-edge (Algorithm 3, line 18).
Notice obfuscation scheme achieves two objectives: 1) hides x4
absolute feasibility values subtree, 2) hides relative dependencies
values obfuscated variable 928372, different random numbers used
value obfuscated domain {, , }. Agent a(x4 ) still able infer relative
dependencies variable x4 , necessary perform projection
variable, unable tell, value (obfuscated) variable, whether
subtrees problem feasible, not, many constraints violated. Notice
particular that, given value obfuscated variable (i.e. column), agent a(x4 )
know whether assignments x4 feasible, therefore would
incorrect simply assume lowest obfuscated feasibility entries decrypts 0.
Similarly, equal entries column correspond high probability entries
number constraint violations, number necessarily 0,
would incorrect infer correspond feasible entries.
Notice obfuscation scheme applicable presence backedge, i.e. message contains parent variable. Consider
instance single-variable message x5 x3 , recalled Figure 4(a). agent a(x3 ) knew
x5 leaf pseudo-tree, cleartext message would reveal agent a(x5 )s private
local constraint x5 6 {B, R} agent a(x3 ), previous obfuscation scheme
apply absence back-edges. Notice threat constraint privacy
tempered fact P-DPOP+ guarantees terms topology privacy prevent
agent a(x3 ) discovering x5 indeed leaf. a(x3 )s point view, larger
subproblem might hanging variable x5 Figure 2, message could actually
aggregation multiple agents subproblems.

x3
R
B
G

x5 x3
# conflicts
0
0
1

(a) cleartext

x3

x5 x3
# conflicts

R
B
G

0
0
730957

(b) obfuscated

Figure 4: message received agent a(x3 ) Figure 2.

reduce privacy leak present original algorithm (Faltings et al., 2008),
propose new additional obfuscation scheme consists adding large (B-bit), positive,
random numbers positive entries single-variable messages, order obfuscate
true numbers constraint violations (Algorithm 3, line 8 Figure 4(b)).
random numbers never subtracted back, must added zero entries, otherwise algorithm would fail find solution violation. Feasible entries still
revealed, numbers constraint violations infeasible entries remain obfuscated.
663

fiLeaute & Faltings

3.2 Propagating Final Decisions
feasibility values propagated way root pseudotree, feasible assignment root variable found (if exists one),
assignment propagated pseudo-tree (Algorithm 2, lines 14 19).
variable uses assignments contained message parent, order look
corresponding assignment (line 17). sends child assignments
variables separator (line 19), using codenames
protect agent topology privacy. Decision privacy partially guaranteed,
variable learns values chosen parent pseudo-parents other,
non-neighboring variables separator hidden unknown codenames.
3.3 Algorithm Properties
section first formally proves algorithm complete, analyses complexity.
present algorithm variant lower complexity. Finally, privacy guarantees
provided algorithms (summarized Table 3.3) formally described.
privacy type:

agent

topology

constraint

decision

P-DPOP(+)

full
full
full
-

partial
partial
partial
partial

partial
partial
full
partial

partial
full
full
partial

3/2

-DPOP(+)

P
P2 -DPOP(+)
MPC-DisCSP4

Table 1: Privacy guarantees various algorithms.

3.3.1 Completeness Complexity
Theorem 1. Provided codename clashes, P-DPOP+ (Algorithm 2) terminates returns feasible solution DisCSP, exists one.
Proof. exchanging codenames obfuscation keys, guaranteed require
number messages quadratic number n variables, bottom-up
propagation feasibility values (Algorithm 3) terminates sending exactly (n 1)
messages (one tree-edge). One prove induction (left reader)
multi-party dynamic programming computation almost surely correctly reveals
variable x (obfuscated) feasibility subtrees subproblem, function x
possibly ancestor variables pseudo-tree. process may fail case
collisions codenames, roots two overlapping back-edges choose
codenames. codename clashes inherent privacy-protecting algorithms,
made improbable desired augmenting size codename space.
Finally, top-down decision propagation phase (Algorithm 2, lines 14 19) guaranteed yield feasible assignment variable (if exists one), exchange
exactly (n 1) messages (one tree-edge).
664

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

comes complexity algorithm terms number messages
exchanged, bottleneck election root variable (Online Appendix 1),
requires O( n2 ) messages, diameter constraint graph, degree,
n number variables. However, (n 1) messages containing feasibility
values exponentially large: message sent variable x expressed |sepx |
|sep |
variable codenames (Algorithm 3, line 12), therefore contains O(Dmaxx ) feasibility
values, Dmax size largest variable domain. overall complexity
terms information exchange, memory runtime (measured number constraint
sepmax
checks) therefore O(n Dmax
), sepmax = maxx |sepx |. DPOP,
except P-DPOP+ variable may appear multiple times different codenames
separator, hereby increasing value sepmax . However, increase
multiplicative factor upper bounded degree constraint graph, since
number codenames given variable equal number neighbors.
Empirically, experimental results Section 6 suggest that, almost problem
classes considered, median value sepmax tends grow rather linearly n.
3.3.2 P-DPOP: Trading Topology Privacy Performance
possible reduce sizes |sepxi | separators, enforcing agent a(x)
send codename x x xs (pseudo-)children, unlike Algorithm 2 (lines
2 7). variant identified absence plus sign exponent; P-DPOP
version algorithm initially proposed Faltings et al. (2008).
result change, variables previously may occurred multiple times
feasibility message different codenames appear
once, sepmax < n. worst-case complexity P-DPOP
becomes DPOP (Petcu & Faltings, 2005), sepmax equal
width pseudo-tree, bounded treewidth constraint graph.
However, privacy considerations prevents use P-DPOP DPOPs efficient,
less privacy-aware pseudo-tree generation heuristics, resulting higher-width pseudo-trees.
complexity P-DPOP hereby decreased compared P-DPOP+ , sending
codename x variable x (pseudo-)children drawbacks terms
topology privacy, analyzed below.
3.3.3 Full Agent Privacy
two ways identity agent could leaked non-neighbor B:
1) algorithm require B exchange messages other, 2) Agent
receive message whose content refers identifiably B. Case 1 never happen
algorithms, ever involve exchanging messages neighboring
agents. Case 2 addressed mainly use codenames.
Theorem 2. P-DPOP(+) algorithms guarantee full agent privacy.
Proof. P-DPOP(+) algorithms proceed following sequential phases (the preliminary phases root election pseudo-tree generation addressed online appendices):
Bottom-up feasibility propagation (Algorithm 3) feasibility message contains
function (line 11) set variables, whose names, transmitted clear
665

fiLeaute & Faltings

text, could identify owner agent. prevent agent privacy leak, P-DPOP(+)
replaces variable names secret, random codenames, follows.
Consider variable x pseudo-tree. Note feasibility message sent x
ancestor x function x. message sent x function
x, x projected message sent (line 22). Variable x cannot
re-appear feasibility message higher pseudo-tree, agents local
problem involve variable lower pseudo-tree (line 2).
Similarly, consider feasibility message sent descendant x
pseudo-tree, assume first leaf pseudo-tree. Since
children, feasibility message sends function variables
local problem. local problem involves x, replace x codename xy
(line 5) sends feasibility message. One prove inference
feasibility message sent variable x contain x either;
(and necessarily) contain one several codenames xyi .
Since codenames xyi random numbers chosen x (Algorithm 2, line 4),
communicated (through channels assumed secure) respective
neighbors yi x (Algorithm 2, line 7), non-neighbor x receiving message
involving xyi discover identity owner agent.
domain Dx variable x could contain values might identify owner
agent. fix privacy risk, xs domain replaced obfuscated domains Dxyi
random numbers, similarly way variable names obfuscated.
paper, make simplifying assumption variables domain
size (which naturally holds many problem classes), one variables domain
size give information owner agent. Otherwise, variable domains
padded fake values order make size.
Top-down decision propagation (Section 3.2) messages contain assignments
variables (Algorithm 2, line 19), obfuscated using codenames.
concludes proof that, P-DPOP(+) algorithms, agent receive
message infer identity non-neighboring agent.
3.3.4 Partial Topology Privacy
Theorem 3. P-DPOP guarantees partial topology privacy. minor leaks topology
privacy lie fact variable might able discover lower bound neighbor
variables degree constraint graph, lower bound total number variables.
Proof. Root election pseudo-tree generation left online appendices.
Bottom-up feasibility propagation (Algorithm 3) variable x receives FEAS
message child, containing function whose scope might reveal topological
information. variable scope represented secret codename y,
however x may able decrypt codename y, neighbor x
(or x itself), sent codename neighbors.
results leak topology privacy: x discovers, neighboring ancestor y,
666

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

whether least one neighbor given child x. cannot
discover exactly many neighbors are.
Furthermore, case x neighbors, x cannot decrypt y,
still infer exists another, non-neighboring ancestor corresponding
codename. another breach topology privacy. sent
codename neighbors, x discover whether ancestor
least one neighbor xs children. Moreover, since codenames
large random numbers almost surely unique, x may discover existence
several, distinct non-neighboring ancestors.
Top-down decision propagation (Section 3.2) variable receives message
parent, contain codenames variables variable values
already present FEAS message received previous phase.
concludes proof P-DPOP partially protects topology privacy. limited
topology information leaked variable concerns branch pseudo-tree;
information leaked branch, even existence.
Theorem 4. use different codenames (pseudo-)child improves topology
privacy P-DPOP+ compared P-DPOP, bounds still leaked.
Proof. Consider variable x receives FEAS message including secret codename
corresponding variable (6= x). sent different codename
neighbors, x longer able decrypt y, even neighbor x. consequence,
x longer able infer whether refers known neighbor x, unknown,
non-neighboring variable. However, since codename corresponds unique backedge pseudo-tree, pair (, ) unknown codenames xs received FEAS
message (if pair exists), least one following statements must hold:
refer two different ancestors x, therefore x discovers least
two ancestors (which might known, pseudo-parent); and/or
sent two different descendants x (and possibly including)
sender child y, therefore x discovers least two descendants
(and including) (which might known, pseudo-child y).
Therefore x might able refine lower bound total number variables.
3.3.5 Partial Constraint Privacy
Theorem 5. P-DPOP(+) algorithms guarantee partial constraint privacy. local
feasibility subproblem partial variable assignment X may leaked, even X
cannot extended overall feasible solution (i.e. semi-private information).
Proof. Information constraints transmitted feasibility propagation (Algorithm 3). Based knowledge optimal variable assignments transmitted
last phase (Section 3.2), feasibility information may decrypted.
667

fiLeaute & Faltings

Single-variable feasibility messages variable px receives feasibility message
involving px , message obfuscated adding secret random
numbers infeasible entries (line 8). Feasible entries remain equal 0, px
identify entries refer respectively feasible infeasible assignments px .
However, addition secret, positive, random number infeasible entry
ensures upper bound number constraint violations leaked,
made loose desired choosing random numbers large necessary.
Multi-variable feasibility messages FEAS message involves least one
variable yi , message entries obfuscated adding large random
numbers keyyxi (yix ) B bits (line 25). Furthermore, keyyxi (yix ) known
sender x message pseudo-parent yi , recipient px ,
therefore cannot subtract de-obfuscate entries.
Assume, simplicity, message m(px , yix ) involves two variables
px yix ; argument extends easily variables. recipient px might
able make inferences: 1) fixing yix comparing obfuscated entries
corresponding different values px ; 2) fixing px varying yix instead.
1. given value yix , entries obfuscated adding
random number keyyxi (yix ) (line 25), px compute relative differences
feasibility values various assignments px . However, cannot decrypt
absolute values without knowing keyyxi (yix ). particular, lowest obfuscated
value necessarily equal keyyxi (yix ), necessarily decrypt
0: values px may infeasible particular value yix .
one exception: feasible solution found problem


yix = yix px = px , m(px , yix ) necessarily decrypts 0, therefore


px able infer keyyxi (yix ). fixing yix = yix message

subtracting keyyxi (yix ), reasoning made single-variable
case, feasible infeasible entries identifiable, numbers
constraint violations infeasible entries remain obfuscated.
2. given value px , feasibility value m(px , yix ) obfuscated
adding different, secret random number keyyxi (yix ). Choosing number
bits B sufficiently large makes sure useful information (relative,
absolute) obtained comparing obfuscated feasibility values.
concludes proof P-DPOP(+) guarantees partial constraint privacy.
3.3.6 Partial Decision Privacy
Theorem 6. P-DPOP(+) algorithms guarantee partial decision privacy. leak lies
fact variable might discover values chosen neighbors.
Proof. First notice algorithm cannot leak information chosen values
variables lower pseudo-tree, since variables projected
feasibility messages received. However, decision propagation phase,
variable receives message parent contains chosen values parent
668

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

pseudo-parents. message may contain codenames assignments other, nonneighboring variables, recipient able decode. Furthermore, domains
shuffled using secret permutations, making impossible decode codename
value non-neighboring variable index variables domain.

4. P3/2 -DPOP+ : Adding Full Decision Privacy
section presents another variant P-DPOP+ algorithm achieves full decision
privacy. results novel algorithm, seen hybrid
P-DPOP+ P2 -DPOP (Leaute & Faltings, 2009) algorithms, called P3/2 -DPOP+.
4.1 Overview Algorithm
Algorithm 4 patches decision privacy leak P-DPOP+ removing decision propagation phase. root variable assigned value, order variables
assigned values, variable made root turn (unless first feasibility propagation
revealed problem infeasible, case algorithm terminate early).
3
intuition behind P /2 -DPOP+ algorithm therefore P-DPOP+ bottom-up
feasibility propagation phase repeated multiple times, time different variable x
root pseudo-tree (lines 10 15). end iteration, constraint
x = x added problem enforce consistency across iterations (line 16).
Algorithm 4 Overall P3/2 -DPOP+ algorithm full decision privacy, variable x
Require: first temporary DFS tree, unique ID idx , tight strict lower bound
+
next unique ID id+
x , upper bound n total number variables
idx

id+
x idx

z }| { z }| {
1: vectorx [1, . . . , 1, 0, 1, . . . , 1, 1, . . . , 1]
|
{z
}
n+

2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:

// Exchange public key shares:
privatex generate private ElGamal key x
publicx generate set (id+
x idx + 1) public key shares corresponding privatex
share publicx ToPrevious((SHARE, share)) Algorithm 9
= 1 . . . n+
Wait record one message (SHARE, share)
share 6 publicx ToPrevious((SHARE, share)) Algorithm 9
Generate compound ElGamal public key based public key shares
vectorx 6=
Choose new root (Algorithm 5, Section 4.2)
Construct new pseudo-tree rooted new root (Online Appendix 2)
Exchange codenames x domain Dx (Algorithm 2, lines 2 7)
Choose exchange obfuscation key x (Algorithm 2, lines 9 12)
Propagate feasibility values pseudo-tree (Algorithm 3, except line 21)
x root Add local constraint x = x , x Algorithm 3, line 27
669

fiLeaute & Faltings

4.2 Choosing New Root Variable
iteratively reroot pseudo-tree, propose use improved version rerooting
procedure initially introduced P2 -DPOP algorithm (Leaute & Faltings, 2009).
procedure requires n variables assigned unique ID; algorithm
achieve presented Online Appendix 3. algorithm reveals variable x
unique ID idx , well tight strict lower bound next unique ID id+
x (i.e.
+ total number variables.
+
1),


upper
bound
n
next unique ID equals id+
x
variable x creates Boolean vector vectorx single zero entry index
corresponding unique ID idx (Algorithm 4, line 1); vector shuffled using
random permutation used hide sequence variables become roots.
keep permutation secret, vector first encrypted using ElGamal encryption
(Appendix A), based compound public key jointly produced agents (Algorithm 4,
lines 2 9). asymmetric encryption scheme enables agent (re-)encrypt
entries vectors using common public key, decryption
performed collaboratively agents, using respective private keys.
Algorithm 5 Algorithm choose new root, variable x
Procedure: ShuffleVectors() variable x
1: myID large random number
2: px random permutation [1 . . . n+ ]
// Propagate xs encrypted vector backwards along circular ordering
vectorx E(vectorx ) // encrypts vector using compound public key
5: ToPrevious((VECT, myID, vectorx , 1)) Algorithm 9 Appendix B
3:

4:

// Process received vectors
7: true
8:
Wait message (VECT, id, vector, round) next variable
6:

9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:

round = 1
id 6= myID j = (idx + 1) . . . id+
x vector[j] 1
else round round + 1 // xs vector; move next round
round > 1 x current root
round round + 1 // root starts round except first
round = 3 vector px (vector) // shuffle vector
round = 4 id = myID // done processing vectorx
vectorx vector
continue
// Pass vector backwards along circular ordering
vector E(vector) // re-encrypts vector using compound public key
ToPrevious((VECT, id, vector, round)) Algorithm 9 Appendix B

Procedure: Reroot() variable x
21: repeat entry Decrypt(pop(vectorx )) entry 6= 1 // Algorithm 6
22: entry = 0 x new root
670

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

agents proceed Algorithm 5. variable x first starts procedure
ShuffleVectors(), run performance improvement
previous work (Leaute & Faltings, 2009), performed iteration.
vectors passed variable variable round-robin fashion, using circular message
routing algorithm presented Appendix B. agent applies secret permutation
vector shuffle it. ShuffleVectors() proceeds four rounds. round 1
(started line 5, Algorithm 5), vector makes full round along circular ordering,
variable x overwrites entries 1 (line 10),
positions vectorx (Algorithm 4, line 1). 1 entries account
IDs [idx + 1, id+
x ] assigned variable (Online Appendix 3).
x received back vectorx , enters incomplete round 2 (line 11)
vectorx passed reaches current root (line 12). root starts round 3
(line 13), variable x shuffles vector using secret permutation px
(line 14). incomplete round 4 returns fully shuffled vector owner (line 16).
reroot variable ordering beginning iteration P3/2 -DPOP+ ,
variable x calls procedure Reroot(), removes decrypts first element
vectorx . Entries decrypt 1 correspond unassigned IDs skipped.
single entry decrypts 0 identifies new root. decryption process (Algorithm 6)
collaborative effort involves variable using private ElGamal key partially
decrypt cyphertext, travels around circular variable ordering way
vectors, gets back sender variable, finally fully decrypt it.
Algorithm 6 Collaborative decryption multiply-encrypted cyphertext e
Procedure: Decrypt(e) variable x
1: codename large random number used secret codename x
2: codenamesx codenamesx {codename}
3: ToPrevious((DECR, codename, e)) Algorithm 9
4: Wait message (DECR, codename, e ) next variable ordering
5: return decryption e using xs private key
Procedure: CollaborativeDecryption() variable x
6: loop
7:
Wait message (DECR, c, e) next variable ordering
8:
c 6 codenamesx
9:
e partial decryption e using xs private key
10:
ToPrevious((DECR, c, e )) Algorithm 9

4.3 Algorithm Properties
3

first analyze completeness complexity properties P /2 -DPOP(+) algorithms, move privacy properties.
4.3.1 Completeness Complexity
Theorem 7. Provided codename clashes, P3/2 -DPOP+ algorithm
terminates returns feasible solution DisCSP, exists one.
671

fiLeaute & Faltings

Proof. basis Theorem 1, remains prove rerooting Algorithm 5
terminates correct, overall algorithm remains correct. latter easy
prove: iteration, feasible value found root variable (if exists
one), value necessarily consistent chosen assignments previous roots
since assignments enforced new, additional constraints (Algorithm 4, line 16).
comes rerooting procedure, unique ID assignment algorithm (Online
Appendix 3) ensures n variables gets unique ID 0 . . . (n+ 1). Therefore,
variable 0 entry unique position vector (Algorithm 4, line 1). Round 1
Algorithm 5 makes sure vectors 1 entries positions.
ensures exactly one variable become new root iteration, since vectors
applied sequence permutations, variable root twice.
3

terms complexity, P /2 -DPOP+ proceeds similar way P-DPOP+ (Section 3.3), except bottom-up feasibility propagation phase repeated n times (each
time different root variable). overall complexity information exchange theresep
fore becomes O(n2 Dmaxmax ), sepmax maximum separator size variables,
iterations, therefore likely higher exponent PDPOP+ . information exchanged rerooting protocol negligible comparison.
sep
runtime complexity (measured number constraint checks) O(n2 Dmaxmax ),
sep
memory complexity O(n Dmaxmax ), removing decision propagation phase makes become unnecessary compute record x (px , ) (Algorithm 3,
line 21). experimental results graph coloring benchmarks (Section 6.1) suggest
median value sepmax may greater median value sepmax PDPOP+ small multiplicative factor. terms number ElGamal cryptographic
operations, rerooting procedure requires total n(3n 1)n+ O(n3 ) encryptions:
n variables (re-)encrypts (3n 1) vectors size n+ (each variables vector
performs 3 full rounds, except roots vector, performs 2 full rounds),
n+ n + n 2incrmin , incrmin constant input parameter algorithm.
procedure requires total n2 n+ O(n3 ) collaborative decryptions:
n variables (partially) decrypts n vectors size n+ .
4.3.2 Full Agent Privacy
Theorem 8. P3/2 -DPOP(+) algorithms guarantee full agent privacy.
Proof. unique ID assignment circular routing algorithms guarantee full agent privacy, demonstrated respectively Online Appendix 3 Appendix B.
Pseudo-tree rerooting (Algorithm 5) messages sent ShuffleVectors() contain variable ID, vector ElGamal cyphertexts, round number. ID
used recipient detect whether vector vector; large
random number chosen owner agent (Algorithm 5, line 1), therefore
cannot linked identity owner agent agent. ElGamal
vector round number contain information could used
identify agent. note procedure used exchange ElGamal public
key shares (Algorithm 4, lines 2 9) leak information agents
672

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

identities. Reroot() procedure makes use collaborative decryption
algorithm, whose properties terms agent privacy discussed below.
Collaborative decryption (Algorithm 6) procedure exchanges messages contain ElGamal cyphertext, codename used variable ID Algorithm 5.
codename similarly set large random number chosen current agent,
cannot linked identity agent agent.
3

concludes proof P /2 -DPOP(+) algorithms guarantee agent privacy.
4.3.3 Partial Topology Privacy
3

topology privacy P /2 -DPOP(+) slightly worse P-DPOP(+) .
Theorem 9. P3/2 -DPOP(+) algorithms guarantee partial topology privacy. variable unavoidably discovers total number variables problem, might
discover lower bound neighbor variables degree constraint graph. advan3
3
tages P /2 -DPOP+ P /2 -DPOP P-DPOP+ P-DPOP.
Proof. Since one feasibility propagation phase per variable problem, total
number variables inevitably becomes public. following analyzes topology privacy
properties phase P3/2 -DPOP(+) already present P-DPOP(+) , except
unique ID assignment (Online Appendix 3) secure message routing (Appendix B).
Exchange ElGamal key shares (Algorithm 4, lines 29) messages containing ElGamal key shares contain information could used make
inferences topology constraint graph.
Pseudo-tree rerooting (Algorithm 5) message travels along circular variable
ordering using message routing algorithm Appendix B, contains:
vector encrypted (and re-encrypted operation) therefore cannot provide topological information;
id identifies owner vector; secret, large random number,
owner vector identify itself;
round number take following values:
round = 1 indicates vector modified, variable
setting turn values 1;
round = 2 indicates vector sent root
pseudo-tree. happen vector (unknown) root;
round = 3 indicates vector shuffled variable;
round = 4 indicates vector way back owner.
happen vector belonging (unknown) root.
Reroot() uses decryption algorithm whose properties described below.
673

fiLeaute & Faltings

Collaborative decryption (Algorithm 6) DECR messages passed along circular variable ordering, containing secret codename original sender variable,
variable capable deciphering codename. last part
message payload ElGamal cyphertext, remains encrypted reaches
back original sender, therefore leak topological information.
3

concludes proof P /2 -DPOP(+) guarantees partial topology privacy.
4.3.4 Partial Constraint Privacy
3

constraint privacy properties P /2 -DPOP(+) algorithms differ PDPOP(+) , former protect decision privacy (which benefits constraint privacy),
reveal total number variables problem (which hurts constraint privacy).
Theorem 10. P3/2 -DPOP(+) algorithms guarantee partial constraint privacy.
leaks P-DPOP(+) (Section 3.3.5), happen less frequently.
Proof. Single-variable feasibility messages leak amount constraint privacy
P-DPOP(+) ; notice however that, since P3/2 -DPOP(+) algorithms reveal total
number variables, circumstances may possible variable discover
child leaf, feasibility message sends therefore contains information
local subproblem only. However, multi-variable feasibility messages leak potentially much
less information P-DPOP(+) : consider simpler non-restrictive case
3
two-variable message m(px , yix ) received px . P /2 -DPOP(+) protects

decision privacy, px longer discovers value yix chosen yix , therefore
longer able infer entries corresponding px = px decrypts 0.
One exception following three conditions simultaneously hold: 1) P3/2 -DPOP

used, 2) codename yix refers variable yix neighbor px , 3) yix

semi-private information px ; px still discover yix , able make
3
inferences P-DPOP(+) . first condition satisfied, i.e. P /2 -DPOP+
3
used instead P /2 -DPOP, px able link codename yix known
3
variable. case P /2 -DPOP used, second condition

hold. Finally, first two conditions hold, px able discover yix
semi-private information, i.e. infer knowledge problem,
chosen value px .
4.3.5 Full Decision Privacy
Theorem 11. P3/2 -DPOP(+) algorithms guarantee full decision privacy.
Proof. leak decision privacy P-DPOP(+) fixed removing decision propagation phase. Instead, variable ordering rerooted, feasibility propagation
phase restarted. possible compare feasibility messages received one
iteration next infer decision made previous iteration:
messages comparable, since different codenames obfuscation keys used.
674

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

5. P2 -DPOP+ : Adding Full Constraint Privacy
describe previous, non-fully secure obfuscation scheme replaced
ElGamal homomorphic encryption (Appendix A) achieve full constraint privacy,
corresponds original P2 -DPOP algorithm (Leaute & Faltings, 2009), improved
use multiple codenames. important limitation ElGamal scheme
fully homomorphic: possible compute two encrypted Booleans,
possible compute encrypted Boolean cleartext
Boolean. consequence, bottom-up feasibility propagation performed
variable ordering variable one child, i.e. linear variable
ordering (Figure 5), using message routing algorithm Appendix B. Otherwise,
pseudo-tree variable ordering, variable two children would able join
two encrypted feasibility messages sent children. could addressed using
fully homomorphic encryption scheme Gentry (2009), however unclear whether
scheme would practically applicable would sufficient performance.
x2
x3

x1

x5

x4

Figure 5: (counter-clock-wise) circular variable ordering corresponding Figure 2.

5.1 Propagating Encrypted Feasibility Values along Linear Variable Order
contrast Figure 2, illustrates multi-party dynamic programming pseudotree variable ordering (counting constraint violations), Figure 6 shows (in cleartext)
carried linear ordering (in Boolean domain). assumes
circular communication structure preliminarily set described Appendix B.
Algorithm 7 gives detailed pseudocode procedure, intended
replacement line 15 Algorithm 4. differences pseudo-tree-based Algorithm 3 following. First, Algorithm 3 initially reformulated DisCSP
Max-DisCSP minimize number constraint violations, Algorithm 7 works
directly original DisCSP problem. means conjunction operator
replaces sum operator (lines 2 10), disjunction operator replaces
operator min (line 13). Notice that, case linear ordering, variables local
subproblem longer necessarily involves parent variable ordering (line 2),
x4 shares constraint x5 Figures 5 6.
next difference variable x longer partially de-obfuscates feasibility
matrix projecting (Algorithm 3, line 18). reason ElGamal
scheme homomorphic, therefore longer necessary first (partially) decrypt
675

fiLeaute & Faltings

x2

x3 x2
R
B
true false

G
true

x2

x3

x3
R
B
G

x5 x3
x2
R
B
true false
true
true
false false

x4 x5
x2
R
B
true false
true true
true true

x3
R
B
G
x5

G
true
true
false

x4

x4
R
B
G

G
true
true
true
x1
x1 x4
x2
R
B
true true
true true
true false

G
true
false
true

Figure 6: Multiparty dynamic programming computation (in cleartext) feasible value
variable x2 , using linear variable ordering based Figure 5.

Algorithm 7 Propagating feasibility values along linear ordering, variable x
1: // Join local constraints:
V
2: m(x, ) c{c C | xscope(c ) scope(c )(childrenx pseudo childrenx )=} c(x, )

// Apply codenames:
4: yi {parentx } pseudo parentsx
5:
m(x, ) replace (yi , Dyi ) m(x, ) (yix , Dyxi ) Algorithm 2, line 2,
apply permutation yxi Dyxi
3:

6:
7:
8:
9:
10:

// Join received message:
Wait message (FEAS, ()) next variable ordering
z childrenx pseudo childrenx
() identify (xz , Dxz ) (x, Dx ) () (if xz present)
m(x, ) m(x, ) ()

// Project x:
x root
W variable
13:
m() E ( x m(x, )) // re-encrypts using compound public key
14:
ToPrevious((FEAS, m())) Algorithm 9
15: else x FeasibleValue(m(x, )) Algorithm 8
11:

12:

676

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

feasibility values project x using operator x . root variable requires
decryption (Algorithm 7, line 15) find value x variable x whose encrypted
feasibility value decrypts true (if any). described following section.
5.2 Decrypting Feasible Value Root Variable
decryption feasibility values root collaborative process variable partially decrypts cyphertext using private key (Algorithm 6). dichotomy
procedure Algorithm 8 uses least log2 |Dx | log2 |Dx | + 1 decryptions
find feasible assignment root variable, detect infeasibility.
Algorithm 8 Finding feasible value encrypted feasibility matrix m(x)
Procedure: FeasibleValue(m (x = xil . . . xir ))
1: il < ir hthen
ki half remaining subdomain:
j // cut
il +ir
2:
il ,
2

W
3:
f easible Decrypt iI (x = xi ) Algorithm 6
4:
f easible = true return FeasibleValue(m
(x = xiI ))
5:
else return FeasibleValue x = xi[il ,ir ]I
else // one value remains x
7:
f easible Decrypt(m (x = xil )) Algorithm 6
8:
f easible = true return xil else return null
6:

5.3 Algorithm Properties
first analyze completeness complexity properties P2 -DPOP(+) algorithms,
move privacy properties.
5.3.1 Completeness Complexity
Theorem 12. Provided codename clashes, P2 -DPOP+ algorithm
terminates returns feasible solution DisCSP, exists one.
Proof. Termination follows Theorem 7, fact message routing
procedure Appendix B guarantees feasibility messages eventually reach destinations. comes completeness, homomorphic property ElGamal scheme
ensures projection variable x encrypted feasibility matrix correct,
feasibility message received variable linear ordering summarizes
(encrypted) feasibility lower agents aggregated subproblems, function higher
variables. particular, feasibility message received root allows find value
variable satisfies overall problem, exists one.
analysis complexity algorithm remains similar analysis Secsep
tion 4.3: O(n2 Dmaxmax ) information exchange number constraint checks,
sep
O(n Dmaxmax ) memory, sepmax maximum separator size along
successive linear variable orderings, instead along pseudo-trees. requirement
677

fiLeaute & Faltings

variable may one child tends make exponent increase significantly,
illustrated empirically Section 6. terms number ElGamal cryptographic operations, addition cost rerooting variable ordering (Section 4.3), algorithm
sep
requires O(n2 Dmaxmax ) encryptions, O(n log Dmax ) collaborative decryptions.
5.3.2 Full Agent Privacy
Theorem 13. P2 -DPOP(+) algorithms guarantee full agent privacy.
3

Proof. changes introduced P2 -DPOP(+) respect P /2 -DPOP(+)
feasibility propagation, finding feasible value root variable.
ElGamal feasibility propagation (Algorithm 7) point view agent privacy, procedure Algorithm 3, using Algorithm 9 message
routing, algorithms guarantee agent privacy.
Root variable assignment (Algorithm 8) consists iteratively calling procedure Algorithm 6, already shown guarantee agent privacy.
concludes proof P2 -DPOP(+) algorithms guarantee agent privacy.
5.3.3 Partial Topology Privacy
Theorem 14. P2 -DPOP(+) algorithms guarantee partial topology privacy. addition
limited leaks topology privacy P3/2 -DPOP(+) , agent might able
discover exists another branch constraint graph involved in.
3

Proof. two relevant differences P /2 -DPOP(+) : linear variable ordering, choice value root variable requires collaborative decryption.
ElGamal feasibility propagation (Algorithm 7) exchange FEAS messages along
linear variable ordering, algorithm makes use circular message routing
procedure, shown Appendix B guarantee full topology privacy. However,
last variable linear ordering needs know last order initiate
feasibility propagation; therefore, contraposition, non-last variables know
last, and, particular, non-last leaves pseudo-tree discover
existence another branch. minor leak topology privacy already present
unique variable ID assignment algorithm (Online Appendix 3). Besides this,
topology privacy properties feasibility propagation phases P2 -DPOP
P2 -DPOP+ P-DPOP P-DPOP+ , respectively.
Root variable assignment (Algorithm 8) algorithm involves recursively calling
collaborative decryption procedure, shown guarantee full topology privacy.
concludes proof P2 -DPOP(+) guarantees partial topology privacy.
678

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

5.3.4 Full Constraint Privacy
Theorem 15. P2 -DPOP(+) algorithms guarantee full constraint privacy.
Proof. P2 -DPOP(+) algorithms fix leaks constraint privacy P<2 -DPOP(+) ,
replacing cryptographically insecure obfuscation addition random numbers, cryptographically secure ElGamal encryption (Appendix A). makes
longer possible compare two encrypted feasibility values without decrypting them,
would require collaboration agents (or amount computation break
encryption made arbitrarily high worst case increasing ElGamal
key size). particular, possible compute logical two cyphertexts
without decrypting them, result remains encrypted, cannot compared two
inputs decide one true, any.
5.3.5 Full Decision Privacy
Theorem 16. P2 -DPOP(+) algorithms guarantee full decision privacy.
Proof. proof applies Theorem 11.

6. Experimental Results
report empirical performance algorithms state-of-the-art MPCDisCSP4 algorithm, four classes benchmarks: graph coloring, meeting scheduling,
resource allocation, game equilibrium. compare MPC-DisCSP4,
knowledge general DisCSP algorithm provides strong privacy
guarantees. problem class, choice DisCSP formulation crucial,
dictates four types privacy defined based DisCSP constraint graph
relate actual privacy original problem. particular, P -DPOP(+) algorithms use standard DisCSP assumption constraint known agents
owning variable scope (Section 2.2.2). Therefore, agent wants hide
constraint neighboring agents, must express constraint copies neighbors variables. Additional equality constraints must introduced make copy variables
equal respective original variables. contrast, MPC-DisCSP4 make use
DisCSP assumption, therefore need introduction copy variables.
first performance metric simulated time (Sultanik, Lass, & Regli, 2007),
used, agents simulated single machine, estimate time would
taken solve problem run parallel dedicated machines (ignoring
communication delays). two metrics number messages amount
information exchanged. metric, report median least 100 problem
instances, 95% confidence intervals. obfuscation P<2 -DPOP(+) , used
random numbers B = 128 bits, P2 -DPOP(+) used 512-bit ElGamal encryption.
MPC-DisCSP4 used 512 bits Paillier encryption. unique variable ID
generation procedure P>1 -DPOP(+) , parameter incrmin set 10. algorithms
implemented inside Java-based FRODO platform DisCSP (Leaute, Ottens, &
Szymanek, 2009), coupled CSP solver JaCoP (Kuchcinski & Szymanek, 2011).
experiments run 2.2-GHz, dual-core computer, Java 1.6 Java
heap space 2 GB. timeout set 10 min (wall-clock time).
679

fiLeaute & Faltings

6.1 Graph Coloring
first report performance algorithms distributed, 3-color graph coloring
problems. graphs randomly generated varying numbers nodes,
edge density fixed 0.4. Notice that, fixed number colors fixed edge
density, increasing number nodes increases degree graph, therefore
reduces number feasible solutions; explains trends following
graphs. DisCSP formulation involves one decision variable per node, assumes
variable controlled single-variable agent. Notice inter-agent constraints
binary inequality constraints, therefore decision privacy relevant problem class:
knowing ones chosen color insufficient infer respective colors ones neighbors.
study tradeoff privacy performance MPC-DisCSP4, considered
variant denoted MPC-DisCSP4 , assumes inter-agent inequality constraints (i.e.
node neighborhoods) public, final choice colors protected. agent

Simulated time (in ms)

106

Induced width

10
MPC

5

MPC

10

8

P2 -DPOP+
P2 -DPOP

104
3

10

3
P2

-DPOP

3
P2

-DPOP

6
+

4

P-DPOP+

102

P-DPOP

2

DPOP

101

0
3

4

5
6
7
8
Number nodes

9

10

3

Number messages

106

4

5
6
7
8
Number nodes

9

10

Information exchanged (in bytes)

108

105

107

MPC
MPC

104



P>1 -DPOP+
3

106

P>1 -DPOP

10

P-DPOP+

102

105

P-DPOP

101
100

DPOP

3

4

5
6
7
8
Number nodes

9

104
103

10

3

4

5
6
7
8
Number nodes

Figure 7: Performance graph coloring problems.

680

9

10

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

first enumerates feasible solutions overall problem (Section 2.2.2), uses
cryptographic techniques securely randomly choose one feasible solutions.
exists none, algorithm therefore terminates without cryptographic operations
exchanging messages. explains phase transition MPC-DisCSP4
following graphs, since probability infeasibility increases problem size.
Figure 7 shows MPC-DisCSP4 (denoted MPC subsequent figures)
scales poorly, timing problems 6 nodes. MPC-DisCSP4
performs better; however, mentioned before, protects final choices colors.
small numbers nodes, total state space small, MPC-DisCSP4 performs
relatively well; numbers nodes 9, problem instances mostly infeasible,
MPC-DisCSP4 quickly detects infeasibility without exchange message.
efficient algorithms far P-DPOP(+) , whose performance curves
least one order magnitude algorithms. particular, P-DPOPs runtime
sensibly DPOP (the communication overhead almost solely due root
Simulated time (in ms)

105

Induced width
14
12

104
P-DPOP+

10
P-DPOP
DPOP

103

8
6

102

4
12

14

16
18
20
Number nodes

22

12

Number messages

105

14

16
18
20
Number nodes

22

Information exchanged (in bytes)

109
108

104
107
106
103
105
102

12

14

16
18
20
Number nodes

104

22

12

14

16
18
20
Number nodes

Figure 8: Performance larger graph coloring problems.

681

22

fiLeaute & Faltings

election algorithm). cost improved topology privacy P-DPOP+ vs. P-DPOP
starts show problem sizes 7, induced widths P-DPOP+ pseudotrees start deviate P-DPOP DPOP. Full decision privacy comes much higher
costs: P3/2 -DPOP(+) curve 1 3 orders magnitude P-DPOP(+) s,
even though induced widths remain sensibly same. suggests rerooting
pseudo-tree (which involves expensive cryptographic operations) far complexity
bottleneck, even full constraint privacy additionally guaranteed P2 -DPOP(+) ,
whose linear variable orderings nevertheless significantly higher induced widths
P<2 -DPOP(+) pseudo-tree orderings. Notice slope runtime curve decreases
problem size increases; due fact problems become
infeasible, P>1 -DPOP(+) algorithms able terminate first iteration
infeasible problems. Similarly P-DPOP+ vs. P-DPOP, cost improved topology
privacy visible 7 nodes; P2 -DPOP+ even timed problems size 10.
Finally, Figure 7 illustrates fact MPC-DisCSP4 tends send large numbers
small messages, P>1 -DPOP(+) algorithms send lower numbers larger messages.
Figure 8 compares performance P-DPOP(+) DPOP larger graph coloring problem instances. larger problems, improved topology privacy PDPOP+ comes complexity price high scale 12 nodes.
hand, P-DPOPs curves one two orders magnitude DPOP,
P-DPOPs median runtime problem instances size 22 30 s.
6.2 Meeting Scheduling
report experimental results random meeting scheduling benchmarks. varied
number meetings, keeping number participants per meeting 2.
meeting, participants randomly drawn common pool 3 agents. goal
assign time meeting among 8 available time slots, agent required
attend simultaneous meetings. pool agents deliberately chosen small increase
complexity problems, increasing probability agent take part
multiple meetings. Note fixing pool size number participants per
meeting still generates unbounded number different problem instances increase
number meetings, since state space (the Cartesian product domains
decision variables) keeps increasing number meetings/decisions made.
DisCSP formulation problem class following. agent owns
one variable domain size 8 meeting participates in. allDifferent
constraint variables enforce meetings scheduled different
times. meeting, binary equality constraint expressed corresponding
variables owned two participants enforces participants agree time
meeting. Notice inter-agent constraints binary equality constraints,
3
therefore P /2 -DPOP(+) bring additional privacy compared P-DPOP(+) ,
since values neighboring variables semi-private information; therefore,
report performance P3/2 -DPOP(+) . MPC-DisCSP4, simplified formulation
introducing one variable per meeting, owned initiator. way,
meeting, initiator made public, exact list participants remains secret
(it revealed posteriori participants meeting attend it).
682

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

Simulated time (in ms)

106

5

105

P2 -DPOP+
P2 -DPOP

104

MPC

4
3

P-DPOP+

103

P-DPOP

2

DPOP

102
101

Induced width

6

1
0
1

2
3
4
5
Number meetings

6

1

Number messages

106

2
3
4
5
Number meetings

6

Information exchanged (in bytes)

108

105

107

104
106
3

10

105
102
104

101
100

1

2
3
4
5
Number meetings

103

6

1

2
3
4
5
Number meetings

6

Figure 9: Performance meeting scheduling problems.

seen Figure 9, P2 -DPOPs performance comparable MPCDisCSP4 (but much stronger privacy guarantees), although former sends significantly information smallest problems, significantly fewer messages
largest problems could solve within timeout limit. hand,
majority threshold scheme, MPC-DisCSP4 actually could provide privacy
guarantees problems size 1, since involved 2 agents. algorithms could
scale problems size 4, timed larger problems. P2 -DPOP+ increased topology privacy comes price made time earlier P2 -DPOP;
complexity increase due P2 -DPOP+ steeper induced width curve.
P-DPOP(+) algorithms remain efficient far: perform 1
2 orders magnitude better others, terms runtime information
exchanged. graph coloring, improved topology privacy P-DPOP+ comes
price negligible small problems, grow one order magnitude
problems size 6, even induced width remains close P-DPOP. terms
683

fiLeaute & Faltings

runtime information exchange, P-DPOP worse DPOP small factor
(since median induced width); however sends approximately one order
magnitude messages (which mostly due pseudo-tree root election mechanism).
6.3 Resource Allocation
Next, performed experiments distributed resource allocation benchmarks. Problem
instances produced using combinatorial auction problem generator CATS (LeytonBrown, Pearson, & Shoham, 2000), ignoring bid prices. used temporal matching
distribution modeling allocation airport takeoff/landing slots, fixing total number
slots (i.e. resources) 8, varying numbers bids. bid request
bundle 2 resources (a takeoff slot corresponding landing slot). Multiple requests
may placed airline company; airline exactly one fulfilled.

Simulated time (in ms)

106

Induced width

5

105

4
MPC

104

3

P2 -DPOP(+)
P-DPOP(+)

103

2

DPOP

102
101

1
0
1

2

3
4
5
6
Number bids

7

8

1

3
4
5
6
Number bids

7

8

Information exchanged (in bytes)

Number messages

106

2

109
108

105

107
104
106
103
105
102
101

104

1

2

3
4
5
6
Number bids

7

103

8

1

2

3
4
5
6
Number bids

Figure 10: Performance resource allocation problems.

684

7

8

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

problem modeled DisCSP follows (Leaute & Faltings, 2009). One
agent introduced bidder/airline resource/slot, assuming
resource controller different resource provider/airport2 . resource X,
bidder B requests resource, one binary variable xb controlled
resource provider, models whether B allocated
P resource (xb = 1)
(xb = 0). resource provider expresses one constraint
1 variables
enforce resource allocated one interested bidders.
variable xb , introduce one copy variable bx owned bidder B,
constraint xb = bx . bidder B expresses constraint variables,
enforcing allocated two resources correspond exactly one
requests. introduction copy variables motivated DisCSP assumption
agent knows constraints involving variables, serves two privacy-related
purposes: 1) full list agents placing requests given resource known
resource provider, 2) full list resources requested given agent (and
bundles) known agent itself. meeting scheduling problem class,
inter-agent constraints equality constraints, therefore report performance
P3/2 -DPOP(+) , whose privacy guarantees P-DPOP(+) .
MPC-DisCSP4, DisCSP formulation simplified introducing copy
variables hold bidders, since necessary protect constraint privacy: bidders
request resources expressing constraints directly variables owned
resource providers. However, since MPC-DisCSP4 assumes variables public,
order increase topology privacy introduced, resource, many variables
bidders, regardless whether actually interested resource. reduce
size search space, assumed 1 constraints public.
Figure 10 shows performance MPC-DisCSP4 decreases fast
number requests, algorithm able scale beyond problems
size 4. P2 -DPOP(+) algorithms seem scale better, able solve problems
involving 5 requests. three metrics, algorithms largely outperformed
P-DPOP(+) , whose runtime curve remarkably flat, almost overlaps runtime
curve DPOP, consistent undistinguishable induced width curves.
overhead P-DPOP(+) compared DPOP slightly larger terms information
exchanged, goes one order magnitude terms number messages. PDPOP+ P2 -DPOP+ performed respective non-plus variants.
6.4 Strategic Game Equilibria
Finally, report experimental results one last class problem benchmarks,
corresponds distributed computation pure Nash equilibria strategic games.
used particular example party game introduced Singh et al. (2004),
one-shot, simultaneous-move, graphical game (Kearns, Littman, & Singh, 2001)
players invited common party, players possible strategies whether
attend party not. Players arranged undirected social graph,
defines invitees player knows. players reward attending
2. CATS assumes single auctioneer, specify slot airport;
assumed resource provided separate resource provider.

685

fiLeaute & Faltings

party depends whether acquaintances decide attend, whether
likes not. reward 1 per attendee likes, minus 1 per attendee dislikes,
minus constant cost attendance [0, 1]. reward attending 0.
problem computing Nash equilibrium game formulated
DisCSP follows. player agent, owns one binary variable
strategy, one copy variable strategy acquaintances. variable
constrained equal copy variables, using binary equality constraints
resource allocation problems (Section 6.3). agent expresses one constraint
variables, allows particular strategy agent best response
neighbors joint strategies. Notice resulting constraint graph
game graph, due presence copy variables. solution DisCSP therefore
yields joint strategy profile players pure Nash equilibrium, since
player plays best-response neighbors. Notice that, since player holds copy

Simulated time (in ms)

106

Induced width

10
9

105

8

104

P2 -DPOP(+)

7

MPC

6

P-DPOP

103

(+)

5
4

DPOP

3

2

10

2
1

10

1
2

3

4
5
6
Number players

7

2

Number messages

105

3

4
5
6
Number players

7

Information exchanged (in bytes)

108
107

104

106
3

10

105
102

101

104

2

3

4
5
6
Number players

103

7

2

3

4
5
6
Number players

Figure 11: Performance party games.

686

7

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

variable neighbors strategy, strategies semi-private information
cannot protected, report performance P3/2 -DPOP(+) .
MPC-DisCSP4, DisCSP formulation simplified introducing copy
variables (Vickrey & Koller, 2002). interesting consequence difference that,
contrary P1 -DPOP(+) , MPC-DisCSP4 able hide players chosen strategy
neighbors. context party game, useful players
decide attend party, since necessarily eventually discover whether
acquaintances decided attend not. hand, player declines
invitation directly discover anything list attendees. might still
able make indirect inferences decisions acquaintances, based
fact decision decline best response respective chosen strategies.
Figure 11 reports performance algorithms random acyclic game graphs
degree 2 (i.e. trees node 2 children), varying numbers
players. P2 -DPOP(+) algorithms able scale problems size 5
due rapidly increasing induced width, outperformed MPC-DisCSP4
least one order magnitude across three metrics. algorithms still performed
largely worse P-DPOP(+) algorithms, capable scaling much larger
problems. because, setting, induced width remains bounded: since
game graphs acyclic, DPOPs induced width constantly equal 2,
FEAS message sent agent ax parent agent ay expressed ay strategy
variable copy ax strategy variable held ay . P-DPOP(+) induced width
increased 2 agent ay 2 children pseudo-tree, using
different codename ay strategy variable. result, performance overhead
P-DPOP(+) compared DPOP minimal terms runtime; slightly larger
information exchanged, reaches one order magnitude number messages.

7. Conclusion
paper, addressed issue providing strong privacy guarantees Distributed Constraint Satisfaction Problems (DisCSPs). defined four types information problem agents might want hide other: agent privacy
(hiding agents identity non-neighbors), topology privacy (keeping topology
constraint graph private), constraint privacy (protecting knowledge constraints), decision privacy (the final value variable known
owner agent). Departing previous work literature, addressed
subsets privacy types, often focused quantifying privacy loss various algorithms, proposed set algorithms strong guarantees
information provably leaked.
carried performance experiments four different classes benchmarks:
graph coloring, meeting scheduling, resource allocation, game equilibrium computation.
results show algorithms provide stronger privacy guarantees,
scale better previous state art. explored tradeoff
privacy performance: P-DPOP+ variant shown scale much better
others, guarantee partial constraint decision privacy, may still
considered sufficient many problem classes. Full decision privacy (P3/2 -DPOP+ ) full
687

fiLeaute & Faltings

constraint privacy (P2 -DPOP+ ) come significantly higher prices computation time
information exchange, which, todays hardware, limits applicability smaller
problem instances. compared performance algorithms MPCDisCSP4 algorithm, considered previous state art DisCSP
strong privacy guarantees. first three classes benchmarks, algorithms
almost systematically outperformed MPC-DisCSP4 terms runtime number
messages exchanged; however, MPC-DisCSP4 proved exchange less information
P>1 -DPOP+ . game equilibrium computation, MPC-DisCSP4 scaled much better
P2 -DPOP+ along three metrics, still largely outperformed P-DPOP+ .
terms practical applicability, shown algorithms scale mediumsize problems beyond reach previous state art general DisCSP
strong privacy guarantees. investigated application algorithms
real-life meeting scheduling, collaboration Nokia Research Center Lausanne.
Future work could extend techniques paper along several directions. First,
restricted pure satisfaction problems sake simplicity,
algorithms easily extended solve Distributed Constraint Optimization Problems (DCOPs). fact, P<2 -DPOP+ algorithms already optimization algorithms;
P2 -DPOP+ requires changes applied DCOPs. changes involve
replacing ElGamal-encrypted Boolean feasibility values ElGamal-encrypted, bit-wise
vector representations integer cost values, described Yokoo Suzuki (2002).
would incur increase complexity linear upper bound cost
optimal solution. optimization variant MPC-DisCSP4, called MPC-DisWCSP4,
already proposed Silaghi Mitra (2004); report performance comparisons
algorithms publications (Leaute & Faltings, 2011; Leaute, 2011).
avenues future research could result relaxing assumption agents
honest, curious. number challenging issues arise attempting apply
techniques paper self-interested agents manipulate protocol
order achieve solutions better suit selfish preferences. One issue
verifiability, involves making possible check whether protocols executed
designed, without need decrypt messages exchanged. Another interesting issue
whether possible modify algorithms make incentive-compatible,
agents best interest honestly follow protocol.

Appendix A. Cooperative ElGamal Homomorphic Encryption
Homomorphic encryption crucial building block privacy-preserving algorithms
introduced paper. Encryption process message appendix,
Boolean turned cyphertext, way decrypting cyphertext
retrieve initial cleartext message impossible (or, case, computationally
hard worst case) without knowledge secret encryption key used
produce cyphertext. encryption scheme said homomorphic possible
perform operations cyphertexts translate operations initial cleartext
messages, without need know encryption key. ElGamal encryption (Elgamal,
1985) one encryption scheme possesses homomorphic property.
688

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

A.1 Basic ElGamal Encryption Booleans
ElGamal encryption used encrypt Booleans performing following
operations encrypted Booleans possible without knowledge decryption key:
encrypted cleartext Boolean;
two encrypted Booleans.
ElGamal encryption homomorphic, public key cryptography system based
intractability Diffie-Hellman problem (Tsiounis & Yung, 1998), proceeds
follows. Let p safe prime form 2rt + 1, r large random number,
large prime. numbers computations modulo p. Let g generator
Zp , i.e. g powers cover [1, p 1]. p g assumed public knowledge,
ElGamal private key chosen random number x [1, p 2], associated public
key = gx . cleartext number encrypted follows:
E(m) = (, ) = (my r , gr )

(1)

r random number chosen encryptor. Decryption proceeds follows:
r

=
=m.
x
(gr )x
useful feature ElGamal encryption allows randomize encrypted value
generate new encryption bearing similarity original value. Randomizing
E(m) Eq. (1) yields:








E 2 (m) = (y r , g r ) = (my r+r , gr+r )
still decodes m. encrypt Booleans, represent false 1, true
value z 6= 1, allows us compute operations:
E(m) true = E 2 (m) ;

E(m) false = E(1)

E(m1 ) E(m2 ) = (1 2 , 1 2 ) = E(m1 m2 ) .
A.2 Cooperative ElGamal Encryption
previous ElGamal encryption scheme, decryption performed single step,
using private key, secret agent originally encrypted message.
However, possible perform ElGamal encryption way agents
need cooperate order perform decryption. possible use
compound ElGamal key (x, y) generated cooperatively agents (Pedersen, 1991):
Distributed Key Generation ElGamal key pairs (xi , yi ) n agents combined following fashion obtain compound key pair (x, y):
x = ni=1 xi

= ni=1 yi .

Distributed Decryption agent publishes decryption share xi , message
decrypted follows:


= x =m.
ni=1 xi

689

fiLeaute & Faltings

Appendix B. Routing Messages along Circular Variable Ordering
order implement round-robin exchange vectors briefly presented Section 4.1,
variables ordered along circular ordering mapped chosen pseudo-tree,
illustrated Figure 5 (page 675) . variable needs able send message
previous variable (i.e. clock-wise) ordering, challenge
neighboring variables communicate directly. Furthermore, protect agent
topology privacy, agent know overall circular ordering. solve issue,
Algorithm 9 algorithm used P2 -DPOP (Leaute & Faltings, 2009) route messages.
Algorithm 9 Sending message clock-wise circular variable ordering.
Procedure: ToPrevious(M ) variable x
1: x root pseudo-tree Send message (LAST, ) xs last child
2: else Send message (PREV, ) xs parent
Procedure: RouteMessages() variable x
3: loop
4:
Wait incoming message (type, ) neighbor yi
5:
type = LAST
6:
x leaf Deliver message x
7:
else Send message (LAST, ) xs last child
8:
else type = PREV
9:
yi xs first child Deliver message x
10:
else Send message (LAST, ) child yi xs list children
Consider instance message agent a(x1 ) wants send previous
variable x4 , a(x1 ) know it. Agent a(x1 ) wraps PREV
message sends parent variable x4 (line 2). sender variable x1
x4 first (and only) child, a(x4 ) infers deliver (line 9). Consider
a(x4 ) wants forward previous variable x5 , a(x4 )
know. before, a(x4 ) sends message (PREV, ) parent variable x3 ,
reacts sending message (LAST, ) last child preceding x4 list children,
x5 (line 10). LAST messages indicate payload delivered
last leaf current subtree (line 7); therefore, a(x5 ) delivers (line 6) since
children. root wants send message previous variable, uses
LAST message forward last leaf overall pseudo-tree (line 1).
Theorem 17. Algorithm 9 guarantees full agent privacy.
Proof. goal algorithm precisely address agent privacy issues pseudotree rerooting procedure, involves variable sending message previous
variable circular ordering variables. guarantee exist
circular ordering two consecutive variables owned neighboring agents,
necessary protect agent privacy. Therefore, Algorithm 9 responsible routing
messages paths involve communication neighboring agents.
routing procedure involves encapsulating routed messages inside
PREV LAST messages, contain payload. Therefore, long
690

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

routed messages contain information used identify nonneighboring agent, routing procedure guarantees agent privacy.
Theorem 18. Algorithm 9 guarantees full topology privacy.
Proof. purpose algorithm enable variables propagate messages along
circular variable ordering, without need know topological information
constraint graph, knowledge respective (pseudo-)parents
(pseudo-)children pseudo-tree. ToPrevious() makes possible send message
previous variable circular ordering, without knowing variable is.
reception (PREV, ) message indicates sender child wants
included message delivered previous variable, either
recipient PREV message, unknown descendant thereof.
reception (LAST, ) message ones parent indicates unknown
variable (either unknown root pseudo-tree, unknown child
unknown ancestor, another branch) wants delivered previous variable,
ones descendant pseudo-tree.

References
Ben-Or, M., Goldwasser, S., & Wigderson, A. (1988). Completeness theorems noncryptographic fault-tolerant distributed computation (extended abstract). Proceedings Twentieth Annual ACM Symposium Theory Computing (STOC88),
pp. 110.
Bilogrevic, I., Jadliwala, M., Hubaux, J.-P., Aad, I., & Niemi, V. (2011). Privacy-preserving
activity scheduling mobile devices. Proceedings First ACM COnference
Data Application Security PrivacY (CODASPY11), pp. 261272.
Brito, I., & Meseguer, P. (2003). Distributed forward checking. Proceedings
Ninth International Conference Principles Practice Constraint Programming
(CP03), Vol. 2833 Lecture Notes Computer Science, pp. 801806.
Brito, I., & Meseguer, P. (2007). Distributed forward checking may lie privacy.
Proceedings Ninth International Workshop Distributed Constraint Reasoning
(CP-DCR07).
Brito, I., & Meseguer, P. (2010). Cluster tree elimination distributed constraint optimization quality guarantees. Fundamenta Informaticae, 102, 263286.
Chechetka, A., & Sycara, K. (2006). No-commitment branch bound search distributed constraint optimization. Proceedings Fifth International Joint Conference Autonomous Agents Multiagent Systems (AAMAS06), pp. 1427
1429.
Dechter, R. (2003). Constraint Processing. Morgan Kaufmann.
691

fiLeaute & Faltings

Doshi, P., Matsui, T., Silaghi, M.-C., Yokoo, M., & Zanker, M. (2008). Distributed private
constraint optimization. Proceedings 2008 IEEE/WIC/ACM International
Conference Intelligent Agent Technology (IAT08), pp. 277281.
Elgamal, T. (1985). public key cryptosystem signature scheme based discrete
logarithms. IEEE Transactions Information Theory, 31 (4), 469472.
Faltings, B., Leaute, T., & Petcu, A. (2008). Privacy guarantees distributed constraint satisfaction. Proceedings 2008 IEEE/WIC/ACM International Conference Intelligent Agent Technology (IAT08), pp. 350358.
Franzin, M. S., Freuder, E. C., Rossi, F., & Wallace, R. J. (2004). Multi-agent constraint
systems preferences: Efficiency, solution quality, privacy loss. Computational
Intelligence, 20 (2), 264286.
Gentry, C. (2009). Fully homomorphic encryption using ideal lattices. Proceedings
Forty-first Annual ACM Symposium Theory Computing (STOC09), pp. 169
178. ACM Special Interest Group Algorithms Computation Theory (SIGACT).
Gershman, A., Meisels, A., & Zivan, R. (2006). Asynchronous forward-bounding distributed constraints optimization. Proceedings Seventeenth European Conference Artificial Intelligence (ECAI06), pp. 103107.
Goldreich, O. (2009). Foundations Cryptography, Vol. 2, Basic Applications. Cambridge
University Press.
Greenstadt, R., Grosz, B., & Smith, M. D. (2007). SSDPOP: Using secret sharing
improve privacy DCOP. Proceedings Ninth International Workshop
Distributed Constraint Reasoning (CP-DCR07).
Greenstadt, R., Pearce, J. P., & Tambe, M. (2006). Analysis privacy loss distributed
constraint optimization. Proceedings Twenty-First National Conference
Artificial Intelligence (AAAI06), pp. 647653.
Grinshpoun, T., & Meisels, A. (2008). Completeness performance APO algorithm.
Journal Artificial Intelligence Research (JAIR), 33, 223258.
Grubshtein, A., Grinshpoun, T., Meisels, A., & Zivan, R. (2009). Asymmetric distributed
constraint optimization. Proceedings IJCAI09 Distributed Constraint Reasoning Workshop (DCR09), pp. 6074.
Gutierrez, P., & Meseguer, P. (2010). BnB-ADOPT+ several soft arc consistency
levels. Proceedings Nineteenth European Conference Artificial Intelligence
(ECAI10), No. 215 Frontiers Artificial Intelligence Applications, pp. 6772.
Herlea, T., Claessens, J., Preneel, B., Neven, G., Piessens, F., & Decker, B. D. (2001). securely scheduling meeting. Proceedings Sixteenth International Conference
Information Security Trusted information: new decade challenge (SEC01),
International Federation Information Processing (IFIP) Series, pp. 183198.
Hirayama, K., & Yokoo, M. (1997). Distributed partial constraint satisfaction problem.
Proceedings Third International Conference Principles Practice
Constraint Programming (CP97), Vol. 1330 Lecture Notes Computer Science,
pp. 222236.
692

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

Kearns, M. J., Littman, M. L., & Singh, S. P. (2001). Graphical models game theory.
Proceedings Seventeenth Conference Uncertainty Artificial Intelligence
(UAI01), pp. 253260.
Kuchcinski, K., & Szymanek, R. (2011). Java library: JaCoP Java constraint programming
solver. http://jacop.osolpro.com/.
Leaute, T. (2011). Distributed Constraint Optimization: Privacy Guarantees Stochastic
Uncertainty. PhD thesis, Ecole Polytechnique Federale de Lausanne (EPFL).
Leaute, T., & Faltings, B. (2009). Privacy-preserving multi-agent constraint satisfaction.
Proceedings 2009 IEEE International Conference PrivAcy, Security, riSk
Trust (PASSAT09), pp. 1725.
Leaute, T., & Faltings, B. (2011). Coordinating logistics operations privacy guarantees. Proceedings Twenty-Second International Joint Conference Artificial
Intelligence (IJCAI11), pp. 24822487.
Leaute, T., Ottens, B., & Szymanek, R. (2009). FRODO 2.0: open-source framework
distributed constraint optimization. Proc. IJCAI09 Distributed Constraint
Reasoning Workshop (DCR09), pp. 160164. http://frodo2.sourceforge.net.
Leyton-Brown, K., Pearson, M., & Shoham, Y. (2000). Towards universal test suite
combinatorial auction algorithms. Proceedings Second ACM Conference
Electronic Commerce (EC00), pp. 6676. ACM Special Interest Group Electronic
Commerce (SIGEcom). http://www.cs.ubc.ca/~kevinlb/CATS.
Maheswaran, R. T., Pearce, J. P., Bowring, E., Varakantham, P., & Tambe, M. (2006).
Privacy loss distributed constraint reasoning: quantitative framework analysis
applications. Autonomous Agents Multi-Agent Systems (JAAMAS), 13 (1),
2760.
Maheswaran, R. T., Tambe, M., Bowring, E., Pearce, J. P., & Varakantham, P. (2004).
Taking DCOP real world: Efficient complete solutions distributed multievent scheduling. Proceedings Third International Joint Conference Autonomous Agents Multiagent Systems (AAMAS04), Vol. 1, pp. 310317. ACM
Special Interest Group Artificial Intelligence (SIGART).
Mailler, R., & Lesser, V. R. (2003). mediation based protocol distributed constraint
satisfaction. Proceedings Fourth International Workshop Distributed Constraint Reasoning (DCR03).
Meisels, A., & Zivan, R. (2003). Asynchronous forward-checking DisCSPs. Proceedings
Fourth International Workshop Distributed Constraint Reasoning (DCR03).
Modi, P. J., Shen, W.-M., Tambe, M., & Yokoo, M. (2005). ADOPT: Asynchronous distributed constraint optimization quality guarantees. Artificial Intelligence, 161,
149180.
Netzer, A., Meisels, A., & Grubshtein, A. (2010). Concurrent forward bounding DCOPs.
Proceedings Twelfth International Workshop Distributed Constraint Reasoning (DCR10), pp. 6579.
693

fiLeaute & Faltings

Pedersen, T. P. (1991). threshold cryptosystem without trusted party (extended abstract). Advances Cryptology EUROCRYPT91, Workshop Theory
Application Cryptographic Techniques, Proceedings, Vol. 547 Lecture Notes
Computer Science, pp. 522526.
Petcu, A., & Faltings, B. (2005). DPOP: Scalable Method Multiagent Constraint
Optimization. Proceedings Nineteenth International Joint Conference
Artificial Intelligence (IJCAI05), pp. 266271.
Petcu, A., Faltings, B., & Parkes, D. C. (2008). M-DPOP: Faithful distributed implementation efficient social choice problems. Journal Artificial Intelligence Research
(JAIR), 32, 705755.
Rassenti, S. J., Smith, V. L., & Bulfin, R. L. (1982). combinatorial auction mechanism
airport time slot allocation. Bell Journal Economics, 13 (2), 402417.
Shamir, A. (1979). share secret. Communications ACM, 22 (11), 612613.
Silaghi, M.-C. (2005a). Hiding absence solution distributed constraint satisfaction
problem (poster). Proceedings Eighteenth International Florida Artificial
Intelligence Research Society Conference (FLAIRS05), pp. 854855.
Silaghi, M.-C. (2005b). Using secure DisCSP solvers generalized Vickrey auctions
complete stochastic techniques. Proceedings IJCAI05 Distributed Constraint Reasoning Workshop.
Silaghi, M.-C., Faltings, B., & Petcu, A. (2006). Secure combinatorial optimization simulating DFS tree-based variable elimination. Proceedings Ninth International
Symposium Artificial Intelligence Mathematics.
Silaghi, M.-C., & Mitra, D. (2004). Distributed constraint satisfaction optimization
privacy enforcement. Proceedings 2004 IEEE/WIC/ACM International
Conference Intelligent Agent Technology (IAT04), pp. 531535.
Silaghi, M.-C., Sam-Haroud, D., & Faltings, B. (2000). Asynchronous search aggregations. Proceedings Seventeenth National Conference Artificial Intelligence Twelfth Conference Innovative Applications Artificial Intelligence
(AAAI/IAAI00), pp. 917922.
Singh, S., Soni, V., & Wellman, M. P. (2004). Computing approximate Bayes-Nash equilibria
tree-games incomplete information. Proceedings Fifth ACM Conference
Electronic Commerce (EC04), pp. 8190.
Sultanik, E. A., Lass, R. N., & Regli, W. C. (2007). DCOPolis: framework simulating
deploying distributed constraint optimization algorithms. Proceedings
Ninth International Workshop Distributed Constraint Reasoning (CP-DCR07).
Tsiounis, Y., & Yung, M. (1998). security Elgamal-based encryption. Proceedings First International Workshop Practice Theory Public Key
Cryptography (PKC98), Vol. 1431 Lecture Notes Computer Science, pp. 117134.
Vickrey, D., & Koller, D. (2002). Multi-agent algorithms solving graphical games. Proceedings Eighteenth National Conference Artificial Intelligence (AAAI02),
pp. 345351.
694

fiProtecting Privacy thru Distributed Computation Multi-agent Decision Making

Vinyals, M., Rodrguez-Aguilar, J. A., & Cerquides, J. (2010). Constructing unifying
theory dynamic programming DCOP algorithms via generalized distributive
law. Autonomous Agents Multi-Agent Systems (JAAMAS), 22 (3), 439464.
Wallace, R. J., & Freuder, E. C. (2005). Constraint-based reasoning privacy/efficiency
tradeoffs multi-agent problem solving. Artificial Intelligence, 161 (12), 209227.
Yeoh, W., Felner, A., & Koenig, S. (2010). BnB-ADOPT: asynchronous branch-andbound DCOP algorithm. Journal Artificial Intelligence Research (JAIR), 38, 85
133.
Yokoo, M. (1995). Asynchronous weak-commitment search solving distributed constraint
satisfaction problems. Proceedings First International Conference Principles Practice Constraint Programming (CP95), No. 976 Lecture Notes
Computer Science, pp. 88102.
Yokoo, M., Durfee, E. H., Ishida, T., & Kuwabara, K. (1992). Distributed constraint satisfaction formalizing distributed problem solving. Proceedings Twelfth
International Conference Distributed Computing Systems (ICDCS92), pp. 614
621.
Yokoo, M., & Suzuki, K. (2002). Secure multi-agent dynamic programming based homomorphic encryption application combinatorial auctions. Proceedings
First International Joint Conference Autonomous Agents Multi-Agent
Systems (AAMAS02), pp. 112119.
Yokoo, M., Suzuki, K., & Hirayama, K. (2002). Secure distributed constraint satisfaction:
Reaching agreement without revealing private information. Proc. 8th Intl. Conf.
Principles Practice Constraint Prog. (CP02), Vol. 2470 LNCS, pp. 387401.
Yokoo, M., Suzuki, K., & Hirayama, K. (2005). Secure distributed constraint satisfaction:
Reaching agreement without revealing private information. Artificial Intelligence,
161 (12, Distributed Constraint Satisfaction), 229245.
Zivan, R., & Meisels, A. (2004). Concurrent dynamic backtracking distributed CSPs.
Proceedings Tenth International Conference Principles Practice
Constraint Programming (CP04), Vol. 3258 Lecture Notes Computer Science,
pp. 782787.

695


