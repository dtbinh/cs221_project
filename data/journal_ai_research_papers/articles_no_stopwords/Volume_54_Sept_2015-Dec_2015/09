journal artificial intelligence

submitted published

continuing plan quality optimisation
fazlul hasan siddiqui
patrik haslum

fazlul siddiqui anu edu au
patrik haslum anu edu au

australian national university
nicta optimisation group
canberra australia

abstract
finding high quality plans large hard although current
anytime planners often able improve plans quickly tend reach limit
plans produced still far best possible planners fail
improvement even given several hours runtime
present continuing plan quality optimisation larger time scales
implementation system called bdpo key decomposition
subproblems improving parts current best plan decomposition
block deordering form plan deordering identifies hierarchical plan structure
bdpo seen application large neighbourhood search lns local search
strategy neighbourhood plan defined replacing one
subplans improved subplans line learning used adapt strategy
selecting subplans subplanners course plan optimisation
even starting best plans found means bdpo able continue
improving plan quality often producing better plans anytime planners
given enough runtime best however achieved combination
different techniques working together

introduction
classical ai involves representing world initial
goal states available actions formal modelling language reasoning
preconditions effects actions given system
planner short generates sequence actions whose application transforms
world initial state desired goal state thus makes intelligent
system autonomous construction plans action achieve goals
key concern automated producing high quality plans planners
optimal bounded suboptimal heuristic search methods offer guarantees plan quality
unable solve large fast planners greedy heuristic search
techniques hand solve large often poor quality plans
gap capabilities two kinds planners means producing high
quality plans large still challenge example gap shown
figure seek address gap proposing continuing plan
improvement able tackle large works varying time scales
anytime search tries strike balance optimal bounded suboptimal
greedy heuristic search methods anytime search finding initial
solution possibly poor quality quickly continuing search better solutions
c

ai access foundation rights reserved






plan cost



siddiqui haslum














sorted

figure illustration plan quality gap dashed line represents best lowestcost plan genome edit distance ged domain haslum
found different non optimal planners including anytime planners solid line represents corresponding highest known lower bound difference two
optimality gap points represent plans found optimal planners
vertical bars optimality gap obtained specific grimm

time given anytime search example rwa
richter thayer ruml aees thayer benton helmert b
successfully used anytime planners however planners often effective
making use increasing runtime beyond first minutes xie valenzano muller
define unproductive time planner amount time remaining
finds best plan total time given four ipc domains
barman elevators parcprinter woodworking unproductive time lama
planner uses rwa given minutes per
observed similar shown figure figure shows average
ipc quality score function time several anytime planners plan optimisation
methods including lama planner full description experiment setup
even anytime planners presented section page lama
finds first solution quickly solves within maximum
hours cpu time per first plan found less minutes quality
lamas plans improve rapidly early later trend one flattening e
decreasing increase drop beginning due figure showing average
plan quality solved initial low quality plans found
average drops increasing better plans found
hours cpu time lama improves plans solved yet
better plans exist found methods time
interval lamas average plan quality score increases increase


ficontinuing plan quality optimisation




average quality score relative ipc quality score coverage




























































































































































bdpo pngs base plans
bdpo base plans
pngs base plans
ibcs base plans
bss base plans
lama scratch
ibacop scratch












































time hours

figure average ipc quality score function time per set
large scale quality score plan cref c c cost
plan cref reference cost least cost plans hence
higher score represents better plan quality anytime planners lama ibacop start
scratch post processing pngs bdpo bounded cost search ibcs beamstack search methods start set base plans curves delayed hour
account maximum time given generating base plan experiment setup
additional planners described section page



fisiddiqui haslum

figure general framework bdpo

least possible memory limited branch bound beam stack
search zhou hansen may run indefinitely improvements slowly
increase average plan quality made bss entire time depicted figure

plan optimisation approaches post processing start valid plan seek
improve figure shows plan neighbourhood graph search nakhost
muller pngs searches shortcuts subgraph state space
constructed around current plan pngs implementation used
experiment applies nakhosts mullers action elimination technique applying
pngs substantial plan quality improvements quickly improved plans
found less minutes stops runs memory
summary experiment shows current anytime plan optimisation methods
become unproductive runtime increases suffer slow rate plan quality
improvement
present post processing plan optimisation implementation
system called bdpo source code bdpo provided line appendix
article post processor bdpo work depends
methods providing initial plan experiment set input plans referred
base plans best plans found lama hour plan found ibacop
ipc figure shows switching time
overcome limitation current anytime techniques continue improve
plan quality allotted time increases best shown obtained chaining
several techniques together applying first pngs base plans bdpo
best produced pngs could achieved previous anytime
approaches alone
bdpo uses large neighborhood search lns local search technique local
search explores neighbourhood around current solution plan better quality valid
plan lns neighbourhood solution defined destroy repair methods
together replace part current solution keeping rest unchanged
bdpo destroy step selects subsequence linearisation deordering
current plan call window repair step applies bounded cost
planner subproblem finding better replacement subplan focus
solving smaller subproblems makes local search lns particular scale better
large size structure neighborhood however plays crucial


ficontinuing plan quality optimisation

role performance local search hoffmann setting neighbourhood determined strategies used select windows subplanners destroy
methods used lns often contain element randomness local
search may accept moves lower quality solutions ropke pisinger schrimpf
schneider stamm wilbrandt dueck contrast explore neighbourhood
systematically examining candidate windows generated ordered several heuristics
accept moves strictly better plans introduce lns idea
delayed restarting meaning search combine multiple local improvements
restarting next iteration best plan found delayed
restarts allow better exploration subplans different parts current plan
helps avoid local minima otherwise occur system attempts optimise
part plan successive iterations
bdpo framework shown figure broadly consists four components plan
decomposition lns e repeated destroy repair steps windowing line
adaptation first step decomposition uses deordering produce partially ordered
plan deordering enables windowing strategies subplans easier
improve leading much better anytime performance use block deordering siddiqui
haslum simultaneously decomposes given plan coherent subplans
called blocks relaxes ordering constraints blocks block deordering removes
inherent limitations existing step wise deordering techniques able
deorder sequential plans cases step wise deordering possible
windowing component collection strategies extracting windows block
deordered plan ranking policies order windows system attempts
optimise promising windows first
bdpo extends earlier system bdpo siddiqui haslum b mainly
variety alternatives task bdpo used single windowing strategy
ranking single subplanner bdpo uses portfolios window generation
ranking strategies several subplanners improves capability robustness
system since single alternative windowing strategy subplanner etc dominates
others across furthermore take advantage fact system
solves many subproblems course local search learn line
best alternatives current particular use ucb multi armed
bandit learning policy auer cesa bianchi fischer subplanner selection
sequential portfolio window ranking policies
remainder article structured follows section describes block deordering theory block deordering presented slightly different earlier
account siddiqui haslum allowing deordering cases better contrasting traditional partially ordered plan semantics section presents
overview bdpo system main empirical sections give
details windowing line adaptation components respectively including
empirical analysis impact performance system whole section
reviews related work section presents conclusions outlines ideas future work


fisiddiqui haslum

plan decomposition
continuing plan quality improvement optimising plan
parts one time every subplan consider local optimisation subsequence
linearisation partially ordered plan therefore key step removing unnecessary ordering constraints typically sequential input plan process called
plan deordering importance deordering demonstrated one experiments
presented section page apply bdpo input plans
already high quality total plan quality improvement measured increase
average ipc plan quality score achieved bdpo without deordering
less achieved bdpo plan deordering technique
standard notion valid partially ordered plan requires unordered steps
plan non interfering e two subsequences plan unordered every
interleaving steps two must form valid execution limits amount
deordering done cases extent deordering sequential
plan possible example situation shown figure page
remedy introduced block deordering siddiqui haslum creates
hierarchical decomposition plan non interleaving blocks deorders
blocks makes possible deorder plans including cases
conventional step wise deordering possible example found
figure page section present slightly different account
theory practice block deordering first relaxes restriction block deordered
plans thereby allowing deordering plans second contrasts semantics
block decomposed partially ordered plans traditional partially ordered plan
semantics clearer way
sections describe necessary background sections introduce block
decomposed partially ordered plans block deordering
sequential plan validity
consider standard strips representation classical action
costs tuple hm c gi set atoms
alternatively called fluents propositions set actions c r cost
function actions assigns action non negative cost initial
state g goal
action characterised triple hpre add del pre add
del preconditions add delete effects respectively say
action consumer atom pre producer add
deleter del action applicable state pre
applied state apply del add sequence
actions hai ai aj applicable state si pre ak sk k j
si apply ai si si apply ai si resulting state
apply si si j
valid sequential plan totally ordered plan seq ha
sequence actions applicable g apply seq
actions seq must executed specified order


ficontinuing plan quality optimisation

partially ordered plan validity
plans partially ordered case actions unordered respect
partially ordered plan p plan tuple pop hs
set steps labelled action represents strict e
irreflexive partial order unordered steps pop executed order
denotes transitive closure element hsi sj si sj basic
ordering constraint iff transitively implied constraints plan
step use pre add del denote preconditions add delete effects
action associated use terms producer consumer deleter
cost plan steps referring associated actions include two steps
si sg si ordered steps consumes nothing produces initially
true atoms sg ordered steps consumes goal atoms produces
nothing
linearisation pop total ordering steps respects p plan
pop valid iff every linearisation pop valid sequential
plan words p plan viewed compact representation
set totally ordered plans namely linearisations
every basic ordering constraint si sj pop set associated reasons denoted
si sj reasons explain ordering necessary plan
valid si sj non empty step precondition may unsatisfied
execution linearisations pop violate si sj reasons three
types
pc producerconsumer atom first step si produces precondition second step sj thus order changed sj executed si
precondition sj may established required
cd consumerdeleter second step sj deletes precondition
si thus order changed may deleted required
dp deleterproducer first step si deletes produced
second step sj order changed add effect producer step may
undone deleter causing later step fail however necessary
order producer deleter step may occur producer plan
depends added atom
note ordering constraint several associated reasons including several
reasons type referring different atoms producerconsumer relation
pc si sj usually called causal link si sj mcallester
rosenblitt denoted triple hsi sj causal link hsi sj threatened
deleter may ordered last producer sj
sj since implies possibility false required execution
sj formal definition follows
definition let pop hs p plan hsp sc causal link pop
hsp sc threatened step sd deletes neither sc sd
p add p sd p sc true


fisiddiqui haslum

mentioned p plan pop hs valid iff
every linearisation pop valid sequential plan however following theorem
gives alternative equivalent condition p plan validity
theorem e g nebel backstrom p plan valid iff every step precondition
supported causal link threat causal link
condition chapmans modal truth criterion
sc pre sc
sp pc sp sc
st del st sc sd p add p sd p sc





deordering
process deordering converts sequential plan p plan removing ordering
constraints steps steps plan successfully executed
order consistent partial order still achieve goal backstrom
refer step wise deordering distinguish block decomposition
deordering introduce later section since current state space search planners
produce sequential plans efficiently deordering plays important role efficient
generation p plans
let pop hs valid p plan step wise deordering pop valid plan


pop
hs pop
removing basic
ordering constraints without invalidating plan sequential plan seq ha
represented p plan one step si action ai seq ordering
si sj whenever j two steps unordered thus deordering
sequential plan different deordering p plan
computing step wise deordering minimum number ordering constraints
np hard backstrom several non optimal e g pednault
veloso perez carbonell regnier fade used variant
explanation generalisation kambhampati kedar
works two phases first phase constructs validation structure
exactly one causal link hsp sc precondition step sc sp chosen
earliest producer preceding sc input plan intervening threatening
step e deletes sp sc veloso perez carbonell
similar selects latest producer instead second phase builds
partial ordering keeping orderings original plan correspond
causal links validation structure required prevent threatening step
becoming unordered w r steps causal link
kambhampati kedars deordering due greedy strategy
guarantee optimality example fails transform totally ordered plan
least constrained plan shown figure however recent study found
produce optimal step wise plan deorderings plans
tested muise mcilraith beck
however motivation plan deordering deordering adequate
generating useful candidate subplans local optimisation important achieving


ficontinuing plan quality optimisation

figure example kambhampati kedars fails
least constrained plan derived figure backstroms article plan
deordering figure sequential input plan b plan produced
choosing earliest producer validation structure preconditions p
q c minimally ordered version simplicity goal atoms
produced steps b c shown figure

optimal step wise deordering overcoming inherent limitation step wise deordering allows plan steps unordered non interfering block
deordering described next two sections remove orderings input
plans forming blocks helps generate decomposed plan suitable
extracting subplans local optimisation
block decomposition
conventional p plan whenever two subplans unordered every interleaving steps
two forms valid execution limits deordering cases individual steps
non interfering remove restriction proposed block decomposed partial
ordering restricts interleaving steps dividing plan steps blocks
steps block must interleaved steps block however
steps within block still partially ordered illustrated example
figure figure shows difference linearisations p plan block
decomposed p plan b c valid linearisation standard partial ordering
block decomposed p plan formal definition block follows
definition let pop hs p plan block w r subset b steps
two steps b exists step b
decomposition plan blocks recursive e block wholly
contained another however blocks cannot partially overlapping two blocks
ordered bi bj exist steps si bi sj bj si sj neither block
contained e bi bj bj bi
definition let pop hs p plan set b subsets block
decomposition pop iff b b block w r every bi bj b
bi bj bj bi bi bj disjoint block decomposed plan denoted
bdp hs b


fisiddiqui haslum

figure normal p plan left represents set sequential plans linearisations plan steps example ha b c di hb c di hb c di hb c ai
block decomposed p plan shown right dashed outlines blocks allows
unordered blocks executed order steps different blocks
interleaved thus ha b c di hb c di hb c ai possible linearisations
plan

semantics block decomposed plan defined restricting linearisations
must valid respect block decomposition e
interleave steps disjoint blocks bi bj steps bi must precede steps bj
linearisation block decomposed plan
definition let bdp hs b block decomposed p plan
linearisation bdp total order lin lin every
b b block w r lin bdp valid iff every linearisation bdp plan
blocks behave much non sequential macro steps preconditions add
delete effects subset union constituent steps
enables blocks encapsulate plan effects preconditions reducing interference
thus allowing deordering following definition captures preconditions
effects visible outside block e give rise dependencies
interference parts plan need consider
deciding two blocks unordered note responsible step step block
causes produce consume threaten atom
definition let bdp hs b block decomposed p plan b b block
block semantics defined
b adds iff b precondition responsible step b
add b deletes
b precondition iff responsible step b pre
step b causal link hs si without active threat
b deletes iff responsible step b del step
b adds
note block consumes proposition cannot produce proposition
reason taking black box view block execution proposition
simply persists true execution block begins remains true
finished steps within block totally ordered preconditions effects
block according definition nearly cumulative preconditions


ficontinuing plan quality optimisation

effects action sequence defined haslum jonsson difference
consumer block cannot producer proposition
conventional p plan valid must contain threat causal link
contrast block decomposed p plan allows threat causal link exist plan
long causal link protected threat block structure causal
link protected threat iff causal link contained block
contain threat ii threat contained block contain
causal link delete threatened atom e encapsulates delete effect
threat causal link active link protected otherwise inactive
formal definition follows
definition let bdp hs b block decomposed p plan st threat
causal link hsp sc bdp hsp sc protected st iff exist block
b b following true sp sc b st
b st b sp sc
b

del b
example block decomposition protects causal link seen figure
page
following theorem provides alternative criterion validity block decomposed p plan analogy condition conventional p plan given
theorem cited difference block decomposed p plan allows
threats causal links long threats inactive let bdp hs b block
decomposed p plan analogously chapmans modal truth criterion condition
stated follows
sc pre sc
sp add sp
st del st st sp sc st hsp sc protected st
theorem block decomposed p plan valid iff every step precondition supported
causal link active threat
proof let bdp hs b block decomposed p plan let
us first prove part e every step precondition supported causal
link active threat every linearisation bdp valid plan let
seq h sc arbitrary linearisation bdp total order seq
pre sc according validity criteria sequential plan
must satisfied execution sc seq since every step precondition
supported causal link bdp active threat must supported
causal link hsp sc active threat moreover since seq sp seq sc
let st threat hsp sc bdp clearly sp seq st seq sc possibility
may cause unsatisfied execution sc since hsp sc active
threat hsp sc protected st therefore according definition
sp sc b st
b st b sp sc
b
del b must hold true
sp seq st seq sc occur valid linearisation bdp since interleaves
steps sp sc b st
b thus b block w r seq second case since


fisiddiqui haslum


del b must producer p b st seq p moreover
since sp sc
b sp seq st seq sc true sp seq st seq p seq sc
makes true execution sc seq
let us prove part e bdp valid every step precondition
supported causal link active threat let sc pre sc
seq h sc linearisation bdp total order seq consider two
possible situations producer causal link hs sc bdp
constructed least one producer construct causal
link sc atom causal link active threat bdp
none situations happen long bdp valid according situation
seq well seq sc causes unsatisfied
execution sc seq e seq become invalid consequently bdp become invalid
since one linearisation invalid contradicts assumption therefore
must exist least one producer construct causal link hs sc bdp
situation assume sp last producer execution sc
seq e p sp add p p seq sp sc seq p let sp producer
causal link hsp sc bdp possible since sp ordered sc
bdp assume hsp sc active threat st bdp since hsp sc active
threat st e hsp sc protected st neither sp sc b st
b
ii st b sp sc
b
del b true therefore sp seq st seq sc possible
linearisation bdp moreover since producer sp sc
must unsatisfied execution sc e seq becomes invalid consequently
bdp invalid since one linearisations invalid therefore hsp sc must
active threat
block deordering
block deordering siddiqui haslum process removing orderings
plan steps adding blocks block decomposed p plan may add plan
ordering constraints transitively implied ordering
constraints block deordering often remove ordering constraints step wise deordering interleaving restriction among blocks affords
us simplified black box view blocks localises interactions
preconditions effects executing block whole important thus allows deordering able ignore dependencies effects matter
internally within block addition providing linearisations improving
deordering blocks formed block deordering often correspond coherent selfcontained subplans form basis windowing strategies described detail
section use generate candidate subplans local optimisation
subsection presents conditions adding blocks block decomposition allows removal basic ordering constraints complete block deordering
presented next subsection
simple example block deordering figure shows sequential plan small
logistics plan deordered conventional p plan
plan step reason ordered previous block deordering however


ficontinuing plan quality optimisation

figure sequential plan block deordering plan two unordered blocks
b b ordering constraints labelled reasons producerconsumer pc
e causal link deleterproducer dp consumerdeleter cd note ordering
constraint sequential plan removed without invalidating thus step wise
deordering plan possible

able break ordering removing reason pc p
formation two blocks b b shown figure ii neither two blocks
delete add atom p although precondition removes
interference allows two blocks executed order
without interleaving therefore possible linearisations block decomposed
p plan hs hs note b ordered b
b optimised removing step
besides necessary orderings pair steps plan due reasons pc
cd dp stated section valid block decomposed p plan must maintain one
type necessary ordering called threat protection ordering removing ordering
sx sy causes block containing steps delete effect
ordering delete effect causes causal link outside block become
unprotected satisfying two conditions definition sx sy
threat protection ordering may removed threat protection ordering
introduced block deordering process introduced removed
demonstrated figure removing kind ordering leads invalid
block decomposed p plan threat protection ordering defined formally follows
definition let bdp hs b block decomposed p plan hsp sc
causal link protected st bdp let b b st b sp sc
b add

del b st st threat protection ordering breaking ordering
causes del b causes hsp sc become unprotected st


fisiddiqui haslum

figure two block decompositions plan containing five steps
decomposition three transitively reduced necessary orderings
dp dp n pc
pc n decomposition valid since every step precondition
satisfied causal link without active threats threat causal link hs n
inactive since link protected block bx contains
delete disjoint causal link forming two blocks
bz would possible remove shown ii since hs
protected bz however decomposition delete effect block bx
becomes del bx n block therefore longer protects hs n therefore
decomposition deordering invalid ordering threat protection
ordering must broken note consumers produced
atom n yet acts white knight hs n protect n deleter

notion threat protection ordering missing earlier block deordering
procedure siddiqui haslum relied implicitly stronger restriction
delete effects block change due subsequent deordering inside block
explicitly checking necessary threat protection orderings allows deordering
inside created blocks take place
remove basic ordering si sj block decomposed p plan bdp hs b
create two blocks bi bj si bi sj bj bi bj note one
two blocks consist single step blocks must consistent existing
decomposition e b bi bj must still valid block decomposition sense
definition remainder subsection define four rules state conditions
blocks bi bj allow different reasons ordering si sj eliminated
since ordering si sj exist several reasons including several reasons
type referring different atoms blocks bi bj found
allow us remove every reason si sj ordering steps
removed
rule let bdp hs b valid block decomposed p plan si sj basic
ordering whose removal cause threat protection ordering removed
pc si sj let bi block si bi sj
bi bi si pc
removed si sj pre bi sp
bi sp establish
causal link bi sj


ficontinuing plan quality optimisation

figure formation block p addition causal link hr qi ii order
remove reason pc behind basic ordering constraint p q different
situations iii iv threat may active hr qi

explanation rule pc si sj bi must produce since
si produces followed deleter within bi si sj basic
ordering sj
bi way happen bi consumes since plan
valid must producer sp
bi necessarily precedes step bi

consumes note sp sj adding causal link pc sp sj e
adding hsp sj already present allows pc removed si sj
theorem deordering according rule preserves plan validity
proof let bdp hs b valid block decomposed p plan therefore according
theorem every step precondition bdp supported causal link active
threat let p q basic ordering constraint p q bp bq b blocks
meet conditions removing pc p q bp bq ordered
ordering constraints removing pc p q

plan bdp
hs b meets condition theorem therefore
remains valid
assume pc p q removed precondition q supplied
step r newly established causal link hr qi deordering formulating

bp p bq q bdp
shown figure ii hr qi


active threat bdp therefore bdp
valid assume active threat


hr qi bdp course r q examine every
situation active threat hr qi
situation assume shown figure iii since active threat
hr si bdp according theorem contained block


fisiddiqui haslum

figure formation blocks removing reason cd behind basic ordering
p q

delete threatened atom contain hr si hr si contained

block b r contain first case holds true bdp


therefore active threat hr qi second case b partially
overlap bp p therefore bp b b bp bp b bp must contain r
happen according pc removing criteria e r
bp must hold stated
rule b bp b must contain least r p b partially
overlap bp p since active threat hp qi bdp hp qi
must contained block b p q contain since b
b partially overlap b b whichever bigger must contain least r p
q b b whichever bigger protects hr qi
situation assume p shown figure iii since active
threat hp qi bdp contained block
encapsulates threatened atom e delete contain hp qi
hp qi contained block b r p q contain cases
hr qi protected
situation assume p shown figure iv possible bp
since interleave steps bp
bp therefore bp causes
hr qi protected bp contain hr qi
delete since add p p
therefore conclude never active threat hr qi
situation
rule let bdp hs b valid block decomposed p plan si sj basic ordering
whose removal cause threat protection ordering removed cd


ficontinuing plan quality optimisation

si sj let bi bj two blocks si bi sj bj bi bj
cd removed si sj bi consume
theorem deordering according rule preserves plan validity
proof let bdp hs b valid block decomposed p plan p q basic
ordering constraint p q cd p q order meet
condition rule let us assume bp block includes r p hr pi
causal link every consumer bp exist ordered r bdp
shown figure therefore meets condition bp must consume
assume bq block contains q bp bq ordered ordering
constraints therefore cd p q well p q removed


plan bdp
hs b bdp
valid according theorem
since bdp valid active threat causal link bdp according
theorem due deordering p q deleter q becomes threat

however hr pi contained bp contain
causal link hr pi bdp
q therefore according definition hr pi protected q e q becomes

remains valid
inactive threat bdp
rule let bdp hs b valid block decomposed p plan si sj basic ordering
whose removal cause threat protection ordering removed cd
si sj let bi bj two blocks si bi sj bj bi bj
cd removed si sj bj delete
theorem deordering according rule preserves plan validity
proof let bdp hs b valid block decomposed p plan p q basic
ordering constraint p q cd p q order meet condition
rule let us assume bq block includes q dp q
every deleter bq exist ordered bdp shown
figure ii therefore meets condition bq must delete assume bp
block contains p bp bq ordered ordering constraints
therefore cd p q well p q removed plan


valid according theorem
hs b bdp
bdp
since bdp valid active threat causal link bdp according
theorem due deordering p q deleter q becomes threat

causal link hr pi bdp
however q contained bq contain hr pi
delete therefore according definition hr pi protected q e

q becomes inactive threat bdp
satisfies condition theorem
therefore remains valid
rule let bdp hs b valid block decomposed p plan si sj basic ordering
whose removal cause threat protection ordering removed dp
si sj let bj block sj bj si
bj dp removed
si sj bj includes every step pc sj
theorem deordering according rule preserves plan validity


fisiddiqui haslum

figure formation blocks removing reason dp behind basic ordering
p q

proof let bdp hs b valid block decomposed p plan let p q basic
ordering constraint p q let bq block includes steps r
hq ri hq si causal links bdp shown figure ii hence
meets condition rule assume bp block contains p bp bq
ordered ordering constraints dp p q well


hs b bdp
p q removed plan bdp
satisfies condition theorem therefore remains valid
since bdp valid active threat causal link bdp according
theorem due deordering p q deleter p becomes threat

however causal links contained
causal links hq ri hq si bdp
bq contain p therefore according definition protected p

e p becomes inactive threat bdp
remains valid

even applying four rules blocks bi bj remove
reasons ordering si sj thus permitting ordering removed
guaranteed two blocks bi bj unordered may ordered
bi contains step si ordered step bj whether sj
another even block b b contains bi bj
b still ordered bj resp bi due constraint
hsi sj blocks bi bj still ordered sense bi appear bj
linearisation consistent block decomposition


ficontinuing plan quality optimisation

block deordering
previous subsection described four conditions rules adding blocks
decomposition allows reasons ordering constraints thus ultimately ordering
constraints removed preserving plan validity next describe
uses rules perform block deordering e convert sequential
plan seq block decomposed p plan bdp
divided two phases first apply step wise deordering procedure convert seq p plan pop used kambhampati
kedars simple shown produce
good muise et al even though optimality guarantee
step wise plan deordering extend ordering blocks two blocks ordered
bi bj exist steps si bi sj bj si sj neither block contained
e bi bj bj bi case steps bi must precede steps bj
linearisation block decomposed plan extend reasons ordering
pc cd dp ordering constraints blocks set propositions
produced consumed deleted block given definition recall responsible
step step block causes produce consume delete proposition
example b produces p must step b produces p step
block ordered deletes p say step responsible b producing p
next phase block deordering converts p plan pop
block decomposed p plan bdp b done greedy procedure
examines basic ordering constraint bi bj turn attempts create blocks
consistent decomposition built far allow ordering
removed core resolve procedure takes
input two blocks bi bj ordered one blocks may consist single step
tries break ordering extending larger blocks b b j procedure
examines reason ordering constraint extends one blocks remove
reason following rules given previous subsection sets
propositions produced consumed deleted blocks b b j recomputed
following definition reasons ordering constraint arisen
steps included added b b j repeated
reason ordering remains case blocks returned
procedure safely unordered reason cannot removed case
deordering possible signalled returning null function intermediate bi bj
returns set steps ordered bi bj e bi bj
refers nearest step preceding following another step means step
smallest number basic ordering constraints
applied resolve procedure basic ordering constraint would obtain
collection blocks break orderings collection
necessarily valid decomposition since blocks may partial overlap
valid decomposition use greedy procedure repeatedly examine basic
ordering constraint bi bj call resolve two extended blocks b bi b j bj
allow ordering removed iteration constraints checked order
beginning plan block added bdp removed


fisiddiqui haslum

resolve ordering constraints pair blocks
procedure resolve bi bj

initialise b bi b j bj

b b j

r b b j

r pc p
try rule

responsible step b nearest b consumes
p

exists

set b b intermediate b

else return null

else r dp p
try rule

responsible step b j b j
hs p causal link

exists

set b j b j intermediate b j

else return null

else r cd p
try rule

responsible step b j nearest b j produces p


exists

set b j b j intermediate b j

else
try rule

responsible step b nearest b produces
p

exists

set b b intermediate b

else return null

recompute b b j


return b b j

accommodate another block partially overlaps existing block throughout
procedure even later rejected block could produce deordering one
created earlier since choice deordering apply greedy guaranteed
optimal b b j cannot added decomposition one
partially overlaps existing block consider blocks ordered immediately
bi check orderings broken simultaneously union
blocks returned resolve ordering constraint symmetrically check
set blocks immediately bj though rarely useful additional


ficontinuing plan quality optimisation

heuristic discard two blocks basic ordering constraint step
internal one blocks e preceding following steps within
block step outside block
ordering removed inner loop exits ordering relation updated
constraints b blocks ordered bj b j blocks
ordered bi done checking three reasons pc cd dp
sets propositions produced consumed deleted b b j inner loop
restarted ordering constraints previously could broken checked
done removing ordering constraints make possible resolution
constraints since removal orderings change set steps intermediate
two steps
main loop repeats deordering consistent current decomposition found iteration runs polynomial time know upper
bound number iterations note however procedure anytime
sense interrupted running completion end last completed iteration still block deordering plan bdpo use time limit
minutes whole deordering procedure however almost every considered
experiments described section block deordering finishes seconds
except visitall domain takes couple minutes
summary deordering makes structure plan explicit showing us parts
necessarily sequential dependency interference independent non interfering block deordering improves creating fly
hierarchical decomposition plan encapsulating dependencies interferences
within block considering blocks instead primitive actions units partial
ordering thus enables deordering plans greater extent including cases deordering possible standard step wise partial order plan notion impact
block decomposition anytime performance plan quality optimisation system
discussed section

system overview
bdpo post processing plan quality optimisation system starting initial
plan seeks optimise parts plan e subplans replacing lower cost
subplans refer subplans candidates replacement windows
better plan found certain conditions met starts
plan viewed local search large neighborhood search lns
strategy neighborhood plan defined set plans
reached replacing window subplan local search plain hill climbing
move strictly better neighbouring plan lns searching
better plan neighbourhood done formulating local optimisation
solved bounded cost subplanners
block deordering described previous section helps identify candidate windows
providing large set possible plan linearisations block decomposition used
windowing strategies window subsequence linearisation
block deordered input plan however represent window slightly different


fisiddiqui haslum

way partitioning blocks part replaced w ordered
p q part
definition let bdp b block decomposed p plan window bdp
partitioning b sets p w q bdp linearisation consistent
bp bw bq bp p bw w bq q
window defines subproblem finding plan
fill gap left removing steps w linearisation bdp consistent
window formally defined follows
definition let bdp b block decomposed p plan
hp w qi window bdp p p p w p w sn linearisation bdp consistent window subproblem corresponding hp w qi
sub atoms actions initial state sub isub
progressing initial state p e applying p
goal sub gsub regressing goal sn p w
theorem let bdp b block decomposed p plan hp w qi window bdp sub subproblem corresponding window
p p p w p w sn linearisation sub constructed


plan
let w
sub p sk p w sn

k
valid sequential plan
proof proof straightforward subsequence p applicable initial
state construction sub initial state sub isub hence
p k applicable construction sub state
sg satisfies goal sub gsub since gsub regressing goal
g p w sn reverse follows subsequence applicable sg
applying state satisfying g relevant properties regression
see example ghallab nau traverso section
subproblem corresponding window hp w qi solution form
linearisation steps w improve plan quality however replacement
subplan must cost strictly lower cost w c w amounts
solving bounded cost subproblems subplanners used bdpo
described section return question multiple windows
within plan simultaneously replaced section
describes bdpo performs one step local search exploring
neighbourhood current plan first step block deorder current plan
line next optimisation bounded cost subplanner tried systematically
candidate windows lines restart condition met line
local improvements possible time limit reached point difference
lns used delayed restart meaning exploration
neighbourhood continue better plan found helps avoid
local minima driving exploration different parts current plan restart
conditions impact local search described section


ficontinuing plan quality optimisation

neighbourhood exploration procedure bpdo
procedure bdpo tlimit banditpolicy rankpolicy optsubprob

initialize telapsed last triallimit n windowdb

bdp blockdeorder

telapse tlimit last locally optimal

windows needed

extractmorewindows bdp windowdb optsubprob















p selectplanner banditpolicy
w selectwindow p rankpolicy triallimit windowdb
w null windows extract triallimit p
w null continue
wnew searchresult optimisewindow p w
updatewindowdb p w wnew optsubprob searchresult windowdb
c wnew c w
merge bdp windowdb
c c last last
updatebanditpolicy p w wnew searchresult banditpolicy
updaterankpolicy p searchresult rankpolicy
c last c restart condition true
return bdpo last tlimt telapsed banditpolicy rankpolicy optsubprob
return last

key design goal procedure avoid unproductive time meaning spending
much time one step trying optimise one window options could
lead improvement left waiting therefore steps done incrementally
time limit step could take unbounded time
database windowdb stores unique window extracted block deordered
plan records status many times optimisation window tried
subplanner structural summary information window window database populated incrementally lines applying different
windowing strategies limit time spent number windows added
limits used seconds windows respectively balances time
window extraction optimisation prevent procedure spending unproductive time windowing strategies described section compute lower
bound cost replacement plan window admissible lm cut
heuristic helmert domshlak window proven optimal current subplan cost equals bound previous attempt optimise window exhausted
bounded cost search space already optimal windows course excluded
optimisation windows added database number windows eligible selected optimisation one subplanner defined next paragraph
drops threshold used current window database size
threshold


fisiddiqui haslum

subplanner use selected ucb multi armed bandit policy auer et al
learns repeated trials select often subplanner succeeds
often finding improvements next window try chosen among eligible
ones database according ranking policy windows eligible optimisation
chosen subplanner already proven optimal
tried chosen subplanner current trial limit overlap
improved window already found ranking policy heuristic aimed selecting
windows likely improved chosen subplanner use several ranking
policies switch one next subplanner fails improvement
number consecutive tries since indicates current ranking policy may
recommending right windows current threshold used
switching ranking policy maximum number windows added
window database call extractmorewindows ranking policies
described section subplanner given time limit increased time
retried window used limit seconds increasing another
seconds retry limit number times retried
window kept subplanner initially set limit increased
subplanner tried every window database excluding windows
already proven optimal overlap windows better replacement
found strategy generate windows line lower cost
replacement subplan window found together improvements already
found current neighbourhood fed merge procedure tries
combine several replacements achieve greater overall plan cost reduction merge
procedure described section
procedure restarts best plan learned bandit policy subplanner selection current ranking policy subplanner carried
next iteration keep database subproblems defined initial
state goal whose plan cost proven optimal avoid trying fruitlessly optimise window database contains information specific
current input plan reset
remainder section organised follows next two sections describe
settings used experiments overview main respectively
describe subplanners used bdpo section restart conditions
section merge procedure section section discusses impact
block deordering performance system windowing strategies ranking
policies described section details line adaptation methods
used presented section
experiment setup
presenting overview outline three different experimental
setups used experiment setup used large scale instances
ipc domains selection domains instances described
experiment included additional medium sized instances total instances
domains used domains sequential satisficing track


ficontinuing plan quality optimisation

ipc except cybersec cavediving citycar domains
cybersec domain slow system parse two conditional
effects implementation handle used alarm processing
power networks appn domain haslum grastien plans used input
bdpo plan produced ibacop cenamor de la rosa fernandez
ipc competition best plan found lama
richter westphal ipc version hour cpu time
refer base plans experiments selected domain
last instances base plan exists domains less instances
solved lama ibacop total rather domains
appeared one competition used instances ipc set
experiments run core ghz amd cpus l cache
gb memory limit every system comparing anytime performance bdpo
systems require input plan count time generate base plan
hour cpu time maximum time allocated generating base plan
found much quickly
first experiment use bdpo system instead ran two
subplanners pngs ibcs seconds every subproblem corresponding
window extracted six windowing strategies base plans excluding
subproblems window proven optimal lower bound obtained
admissible lm cut heuristic helmert domshlak experiment provided
information inform design combined window extraction procedure window
ranking policies aspects system present
refer later discuss system components detail
experiment compare bdpo eight anytime planners plan optimisation systems lama richter westphal ipc version aees implemented
fast downward code base cf thayer et al b ibcs described section
beam stack search bss zhou hansen pngs including action elimination nakhost muller ibacop cenamor et al lpg gerevini
serina arvand nakhost muller bdpo uses pngs ibcs
subplanners configured described aees uses lm cut helmert domshlak admissible heuristic heuristic without action costs
inadmissible estimates bss uses lm cut heuristic implementation bss
use divide conquer solution reconstruction run beam width
systems described section
system run hours cpu time per bdpo pngs
use base plans input ibcs beam stack search use base
plan cost initial cost bound mentioned allocated hour cpu time
generating base plan therefore comparing systems planners
starting scratch lama aees ibacop lpg arvand add hour start
delay runtime beam stack search much slower planners used
experiment therefore ran hours cpu time reporting
divide runtime words shown hypothetical
implementation beam stack search amount search faster
constant factor


fisiddiqui haslum

experiment uses setup experiment except input bdpo
best plan found running pngs hour cpu time gb memory
limit base plans mentioned previously vast majority cases pngs runs
memory much less time cases run hour
limit use setup primarily run different configurations bdpo analyse
impact different designs e g planner selection window ranking policies
immediate vs delayed restart setting input plans already good
quality comparing anytime bdpo experiment
systems add hours runtime
overview
figure shows headline form average plan quality achieved
bdpo systems time per increases ipc quality score plan
calculated cref c c cost plan cref cost best plan
instance found runs systems used experiments thus
higher score reflects lower cost plan figure experiment
described previous section shown figure page
including compared anytime systems none planners
starting scratch solution lama solves
ibacop arvand aees lpg planners average quality
score shown figure average
time found least one plan previously mentioned reason
average quality sometimes falls first plan low quality previously unsolved
found average decrease words metric unaffected
differences coverage likewise none post processing bounded cost search
methods improve base plans bdpo finds plan lower cost base plan
pngs ibcs beam stack search
systems average quality shown figure taken
base plan quality score system improved
majority compared systems trend similar lama e
improving quickly early flattening ultimately stagnating reasons
vary memory limiting factor notably pngs exhausts
gb available memory reaching hour cpu time limit
lama aees runs memory
hand planners use limited memory
beam stack search lpg arvand use local search never run
memory thus could conceivably run indefinitely however rate
plan quality improvements small hours average quality produced
lpg arvand increases respectively latter excludes three
solved arvand first time hours including
brings average making increase less increase average
quality achieved bdpo starting high quality plans generated pngs
base plans time interval


ficontinuing plan quality optimisation






average quality score relative ipc quality score coverage











































































































































































bdpo pngs base plans
bdpo base plans
pngs base plans
ibcs base plans
bss base plans
lama scratch
aees scratch
ibacop scratch
arvand scratch
lpg scratch






























































































































time hours

figure average ipc quality score function time per set
large scale quality score plan cref c c cost
plan cref least cost plans hence higher score represents
better plan quality lama aees lpg arvand ibacop planners start
scratch whereas post processing pngs bdpo bounded cost search ibcs
beam stack search methods start set base plans curves delayed
hour maximum time allocated generating base plan experimental
setup described detail section



fisiddiqui haslum

bdpo
bdpo
pngs

appn



barman


childsnack


elevators


floortile


ged


hiking


maintenance

nomystery



openstacks
parcprinter





parking
scanalyzer


sokoban


tetris


thoughtful


tidybot


transport


visitall


woodworking

overall

domains

lama

aees

arvand

lpg

ibcs

bss

pngs

ibacop










































































































table plan improvement method percentage instances found
plan cost matching best plan found plan strictly better method
found plan known optimal e matched highest lower bound
percentage instances domain shown figure zeros
omitted improve readability bdpo pngs bdpo experiment
experiment see section

draw two main conclusions first bdpo achieves aim continuing quality
improvement even time limit grows fact continues better plans though
decreasing rate even beyond hour time limit used experiment second
combination pngs bdpo achieves better alone partly
work well different sets figure showing
average bdpo sometimes produces better started best plan
found pngs domains bdpo already outperforms pngs start
base plans e g elevators transport however seen
opposite domains e g floortile hiking starting bdpo worse
input plan often yields better final plan seen figure provides
detailed view shows cost best plan found
system hour total time limit scaled interval base plan cost
highest known lower bound hlb plan lower bounds
obtained variety methods including several optimal planners cf haslum
excluded figure cases base plan cost
already matches lower bound improvement possible another
method improves base plans within stipulated time pegsol domain
appear graph base plans one optimal method
improves cost last one


ficontinuing plan quality optimisation

base plans









































best cost achieved normalised



































nomystery

maintenance

ged

floortile

barman

hiking



elevators



childsnack



appn

hlb







lama scratch
aees scratch
arvand scratch
lpg scratch
ibacop scratch
pngs base plans
ibcs base plans
bss base plans
bdpo base plans
bdpo pngs base plans

base plans




































best cost achieved normalised

































hlb



lama scratch
aees scratch
arvand scratch
lpg scratch
ibacop scratch
pngs base plans
ibcs base plans
bss base plans
bdpo base plans
bdpo pngs base plans
woodworking

visitall

transport

tidybot

thoughtful

tetris

sokoban

scanalyzer

parking

parcprinter

openstacks





figure best plan cost normalised interval cost base plan
corresponding highest known lower bound achieved different anytime plan
optimisation methods experiment bdpo experiments see section




fisiddiqui haslum

table provides different summary information figure showing
domain system percentage instances found plan cost
matching best plan instance strictly better method
matching lower bound e known optimal aggregate combination
bdpo pngs base plans achieves best three measures
however domains ged hiking openstacks parking tidybot lama finds
plans strictly better method tried lama
one subplanners bdpo lead better overall
domains openstacks ged smallest improvable subplan often whole
almost whole plan lama finds improvement plan searching
longer time although bdpo increases time limit given subplanners
retry average time limit across local optimisation attempts experiment
seconds thus strategy searching quick improvements plan parts
work well domains
subplanners used window optimisation
subplanners used bdpo used plan window subproblem
stated definition cost less cost current window c w
considered three subplanners
iterated bounded cost search ibcs greedy search admissible heuristic pruning
plan neighbourhood graph search pngs including action elimination technique nakhost muller
restarting weighted richter et al implemented lama planner
however experimental setups described previous section bdpo uses
two subplanners ibcs pngs two reasons choosing two first
good complementarity across domains example ibcs significantly better pngs appn barman floortile hiking maintenance parking sokoban
thoughtful woodworking domains pngs better elevators scanalyzer
tetris transport visitall domains second learning policy use subplanner selection learns faster smaller number options therefore adding third
subplanner improve overall performance bpdo given limited time per
subplanner complements two well e performs well
significant fraction instances two set benchmark
used experiment case different set benchmarks
could course yield different outcome experiment comparing effectiveness
three subplanners individually well combination ibcs pngs
learning policy bdpo presented section page
solve bounded cost ibcs uses greedy best first search guided
unit cost heuristic pruning states cannot lead plan within cost bound
f value admissible lm cut heuristic helmert domshlak
implemented fast downward planner search complete plan


ficontinuing plan quality optimisation

within cost bound prove exhausting search space given sufficient
time memory bounded cost search return plan within cost
bound get best subplan possible within given time limit iterate whenever
plan found long time remains search restarted bound set
strictly less cost plan
pngs nakhost muller plan improvement technique searches subgraph state space around input plan limited bound number states
lower cost plan better plan found exploration limit increased usually
doubled continues time memory limit reached ibcs
iterate pngs get best subplan possible within given time limit improves
current subplan process repeated around best plan
lama richter westphal finds first solution greedy best first search
switches rwa richter et al search better quality solutions
restart
restart condition determines trade exploring neighbourhood
current solution continuing local search different parts solution space
obvious choice one used lns restart
best solution soon one found call immediate restart however
found continuing explore neighbourhood current plan even better
plan found merging together several subplan improvements described
section often produces better call delayed restart
setting right conditions make delayed restart critical success
used disjunction two conditions first union
improved windows found neighbourhood covers steps input plan
recall continue exploration loop improvement
found windows overlap already improved window excluded
optimisation drives procedure search improvements different
parts current plan helps avoid certain myopic behaviour occur
immediate restarts restarting best plan get block
decomposition set windows lead attempting optimise
part plan improved even several restarts may lead
local optimum time consuming escape second condition consecutive
subplanner calls failed improvement threshold three
times threshold switching ranking policy cf description
beginning section means attempts tried optimise
promising windows among remaining eligible ones recommended
ranking policies without success suggests improvable windows
found none ranking policies good current neighbourhood
making restart point allows exploration return parts plan
intersect already improved windows thus increasing set eligible windows
average plan quality function time per achieved bdpo
immediate restart delayed restart conditions shown top
two lines figure page experiment configurations run


fisiddiqui haslum

merge improved windows
procedure merge bdp windowdb

initialise bdp bdp

w improved windows windowdb sorted cost reduction c w c wnew

w

hp w qi wnew pop window highest c w c wnew w

bdp replaceifpossible bdp hp w qi wnew

w removeconflictingwindows w bdp


return bdp

setup experiment described section page seen
delayed restart yields better overall compared bdpo immediate restart
achieves total improvement higher however found immediate restart
work better instances especially visitall woodworking domains
bdpo immediate restart found better final plan nearly instances
average number iterations e steps lns done bdpo
delayed restart condition per across domains considered
experiment highest average single domain thoughtful solitaire
immediate restart average domains increases words
configurations bdpo spend significant time exploring neighbourhood plan
anytime performance curve figure shows additional time spent
neighbourhood delayed restarts pays
merging improved windows
delayed restarting would benefit without ability simultaneously replace
several improved windows current plan improved windows nonoverlapping better subplan window found windows overlap
longer considered optimisation corresponding subproblems may
generated different linearisations block deordered plan
replacement subplans may additional preconditions delete effects
replaced windows lack add effects thus may
linearisation permits two windows simultaneously replaced
merge procedure shown greedy procedure maintains
times valid block deordered plan bdp meaning precondition block
supported causal link active threat recall block context
block consists single step initially input plan bdp
causal links ordering constraints computed block deordering
procedure gets improved windows w window database tries replace
current plan bdp order contribution decreasing plan cost e
cost replaced window c w minus cost subplan c wnew
first replacement succeeds since construction subproblem
linearisation input plan wnew valid cf theorem subsequent
replacements may fail case merge proceeds next improved window w


ficontinuing plan quality optimisation

since replacing window different subplan may impose ordering constraints
remaining improved windows conflict partial order current plan
removed w
replaceifpossible function takes current plan bdp returns updated plan becomes current plan plan replacement
possible replacement subplan wnew made single block whose steps totally ordered preconditions effects block replaced window
w computed according definition page atom pre wnew
w existing causal link kept likewise causal links effect add w
add wnew kept links unthreatened consistent
order since plan valid replacement additional precondition
subplan pre wnew pre wi causal link hbp bc bdp
producer replaced window bp w consumer bc w
atom link produced replacement subplan add wnew
causal link must found given consumer bc atom requires pre bc
procedure tries following two ways creating unthreatened causal link
c block b bc add b every threatening block e
b del b b b bc b added existing plan ordering
without contradiction b chosen ordering constraints necessary resolve
threats added
c otherwise block b add b unordered w r bc
every threatening block b b bc b enforced b chosen
causal link implying ordering b bc threat resolution ordering constraints
added plan
two tried order c first c c fails neither rule
required causal link replacement fails wnew may threaten existing causal
links bdp w threatened link hbp bc procedure tries
resolve threat three ways
consumer bc ordered w linearisation corresponding
subproblem bc p bc wnew consistent threat removed adding
ordering
producer bp ordered w linearisation corresponding subproblem bp q wnew bp consistent threat removed adding ordering
unthreatened causal link supplying bc found one two
rules c c threatened link replaced causal link
rules tried order none resolve threat replacement
fails
non basic ordering constraints blocks w may disappear w
replaced wnew likewise ordering constraints w rest
plan may become unnecessary wnew may delete every atom w deletes
may preconditions w thus removed may make pairs
blocks b b plan ordered replacement unordered thus create
threats threats checked replaceifpossible found
resolved restoring ordering constraint lost


fisiddiqui haslum

lemma current plan bdp valid wnew solves subproblem corresponding
window hp w qi plan returned replaceifpossible valid
proof procedure ensures every precondition every step supported causal
link active threat link existed plan replacement
threats created replacement resolved ordering constraints
added procedure thus replacement succeeds resulting plan valid
according theorem replacement fails plan returned current plan
bdp unchanged valid assumption
theorem input plan bdp valid plan returned merge
proof immediate lemma induction sequence accepted replacements

impact plan decomposition
neighbourhood explored step lns bdpo defined substituting
improved subplans current plan subplan considered local optimisation
subsequence linearisation block deordering current plan obviously
restrict windows consecutive subsequences totally ordered input
plan fact similar approaches plan optimisation adopted restriction ratner
pohl estrem krebsbach balyo bartak surynek section
address question much block deordering contributes performance
bdpo
preliminary experiment setup described section page
observed subproblems improved subplan found
correspond non consecutive part sequential input plan however prove optimising subplans found without
deordering would lead equally good end
therefore conducted another experiment setup experiment described section experiment ran bdpo separately different degrees
plan decomposition block deordering default bdpo configuration
one used experiments presented section page standard e step wise plan deordering configuration used kambhampati
kedars described section plan deordering without
deordering e passing totally ordered input plan directly lns process
addition configurations run immediate restarting
delayed restarting described section
figure shows average ipc plan quality score function time per
achieved configurations bdpo shows simple clear picture
immediate restart lns applied block deordered plans outperforms lns applied
step wise deordered plans turn outperforms use totally ordered plans
total improvement measured increase average ipc plan quality score
achieved bdpo without deordering less achieved best
configuration see deordering enabler delayed restarting
block step wise deordering delayed restarting boosts performance lns


ficontinuing plan quality optimisation



















































































































bdpo delayed restart block deordered plans
bdpo immediate restart block deordered plans
bdpo delayed restart standard partially ordered plans
bdpo immediate restart standard partially ordered plans
bdpo delayed restart totally ordered plans
bdpo immediate restart totally ordered plans











average quality score relative ipc quality score coverage



time hours

figure average ipc quality score function time per bdpo applied
totally ordered input plan standard step wise deordering plan
block deordering plan plan type system run two configurations delayed restarting immediate restarting cf section
page experiment run setup described section page
time shown runtime bdpo e without hour delay
generating input plans shown figure note axis truncated
curves start average quality input plans



fisiddiqui haslum

plan optimisation respectively totally ordered plans
significant effect
deordering increases number linearisations therefore enables many
distinct candidate windows created however recall bdpo neighbourhood
exploration procedure interleaves incremental window generation optimisation attempts many windows could generated current plan may
never generated restart occurs thus average number windows generated
iteration reflect difference performance block deordering
average number windows generated remain filtering
totally ordered plans filtering immediate
restart deordering helps windowing strategies generate windows
easily optimised recall neighbourhood exploration retry subplanner
window higher time limit windows tried
subplanner average number optimisation attempts subplanner
window selected optimisation least around block deordering
standard deordering used input plan without deordering however
average number attempts higher high domains leaving
highest neighbourhoods encountered average slightly
plan neighbourhoods average number attempts
cases words generating windows totally ordered plan
causes procedure spend average time window improving
plan found
hand noted section domains subplanners need
runtime better plans improvable windows bdpo configuration without
deordering better plan default configuration
current bdpo system subplanner time limit increased window
retried procedure attempts candidate windows likely improved
example indicated window ranking policies described section
frequently varies amount time given optimise window may perform better
optimal amount deordering plan may well different averaged across set benchmark deordering
unarguably better none

windowing strategies ranking windows
window subplan linearisation block deordered plan extracted order
attempt local optimisation section describes strategies use generate
rank windows experimental evaluation impact systems performance
recall definition page window represented triple hp w qi
w set blocks replaced p q sets blocks ordered
w respectively linearisation block decomposed p plan
many linearisations producing many possible windows typically far many
attempt optimise windowing heuristic procedure extracts reduced
set windows hopefully including promising ones systematic way


ficontinuing plan quality optimisation

figure block deordered plan transformation extended blocks blocks b
b merged single block blocks b b

windowing heuristics
rule
cyclic thread
causal followers

generated
basic
ext







filtered
basic
ext







improved
basic
ext







impr gen
basic
ext







table total number thousands windows generated filtered
finally improved different windowing heuristics different block types basic
extended number possible windows sequential input plans
even considering deordering million rightmost pair columns shows
rate success meaning fraction improved windows generated windows
numbers experiment described section page
present three windowing heuristics called rule cyclic thread causal followers
heuristics described detail following subsections
heuristic applied two types block basic extended one time
basic blocks blocks generated block deordering purpose windowing
step included block created block deordering considered
block extended blocks created merging basic blocks block
deordered plan form complete non branching subsequences block bi
immediate predecessor block bj bj immediate successor bi
merged one extended block shows procedure extended block
formation ip b denotes set bs immediate predecessors b bs immediate
successors
computing extended blocks
bext bbasic
bi bj bext ip bj bi bi bj

bext bext bi bj bi bj
process illustrated example figure note blocks b
b merged one extended block although b
immediate successor b b immediate predecessor b extended blocks
useful allow windowing heuristics capture larger windows
experiment windows different sizes useful different domains


fisiddiqui haslum

extract candidate windows
global array strategy stores state windowing strategy
procedure extractmorewindows bdp windowdb optsubprob

w

tlimit initial time limit tincrement

telapsed tlimit w nwindowslimit

nextwindowingstrategy

null break windowing strategies exhausted

w strategy getwindows bdp windowdb optsubprob
nwindowslimit w tlimit telapsed

telapsed tlimit w tlimit tincrement


windowdb insert w

example larger windows likely improved pegsol openstacks
parcprinter domains optimising smaller windows better elevators transport
scanalyzer woodworking domains
windowing strategy windowing heuristic applied block type thus use
total six different strategies strategies contributes improvable
windows generated strategies cf section
particular table page thus sense useful
hand size set windows generates fraction improvable
windows set varies strategies sense useful
others
table shows first experiment systematically tried two
subplanners pngs ibcs every window generated filtered
windowing strategy input plans table shows total number thousands
windows generated remain filtering finally improved
least one two subplanners experiment windows filtered
window cost matched lower bound given admissible lm cut heuristic
helmert domshlak experiment setup described section
page first observation strategies selective number
windows could potentially generated even without considering deordering e
taking subsequences totally ordered input plans million thus
even prolific strategy generates less tenth possible windows second
used rate success meaning fraction windows generated improved
subplanners used experiment order strategies order
follows
rule heuristic extended blocks
cyclic thread heuristic basic blocks
cyclic thread heuristic extended blocks
causal followers heuristic basic blocks
rule heuristic basic blocks
causal followers heuristic extended blocks


ficontinuing plan quality optimisation

neighbourhood exploration procedure page adds windows
database incrementally calling extractmorewindows procedure shown
procedure selects next strategy try cycling
order asks strategy generate specified number windows
limited time strategy keeps state part heuristic
applied part plan next time queried resume
generating windows windows possible given strategy
generated say strategy exhausted windowing strategies discard
windows known optimal cost matches lower bound
given admissible lm cut heuristic helmert domshlak
stored set optimally solved subproblems windows overlap
already improved window windows eligible optimisation cf section
generating redundant selected strategy finishes without generating enough
windows time remains next yet exhausted strategy order queried
w nwindowslimit time windows generated
strategies still exhausted time limit increased
rule windowing heuristic
first version bdpo siddiqui haslum b used single windowing strategy
applying fixed set rules extended blocks strategy complements windowing heuristics well kept bdpo
rule applied block b block deordered plan bdp selects set
blocks go replaced part w relation b ensure
window consistent block deordering e consistent linearisation
stated definition page blocks constrained ordered
blocks window must included call intermediate blocks formally
defined follows
definition let bdp hs b block decomposed p plan intermediate
blocks b b ib b b b b b b b b
let b block bdp let un b set blocks ordered w r b
ip b immediate predecessors b b immediate successors rules used
windowing heuristic
w b
w b ip b
w b b
w b un b
w b un b ip b
w b un b b
w b un b ip b b
w b un b ip b un b
w b un b b un b


fisiddiqui haslum

figure window formation applying st rule rule windowing heuristic
block b e w b p un b unordered block b placed
predecessor set note window optimised removing step
causal link successors

w b un b ip b un b b un b
given blocks selected one rules partitioning blocks hp w qi
made setting w w ib w assigning p block ordered
unordered w q block ordered w figure shows example
rule windowing st rule applied block b applied blocks
rules produce duplicates course unique windows kept
first rules include fewer blocks generally produce smaller windows
later rules tend produce larger window though exact relation since
number actions block varies heuristic applies rules block
block deordered plan bdp turn rules applied order e
starting first last second second last blocks
ordered size descending ties broken order input plan opposite
direction extended blocks
recall extractmorewindows repeatedly asks windowing strategy generate limited number windows ordering blocks rules described helps
ensure heuristic generates varied set windows including small
large covering different parts current plan time queried
cyclic thread windowing heuristic
discover windowing heuristics noted key changes decomposed plan
structure frequently occur plan improved one significant observation
multiple steps input plan add effects steps together
steps necessarily ordered form subplan often im

ficontinuing plan quality optimisation

proved call cyclic behavior one experiment found cycles type
removed plan replaced different cycles
improvements across domains definition cyclic behavior
individual atom intuitively atom cyclic behavior multiple producers
defined
definition let bdp hs b block decomposed p plan pm
set producers atom e spm add cyclic behavior iff pm
note pm contains init step si iff however since window never contains
initial step si candidate windows formed extended producers instead step

si sg extended producer atom iff produces consumes
si produces ordered block deordered plan
formal definition follows
definition let bdp hs b block decomposed p plan step
extended producer atom iff
si sg
add
pre ks si add k k
order form candidate windows respect atom cyclic behavior
first extract blocks contain least one extended producer atom
cyclic thread cf definition formed taking linearisation blocks
consistent input plan
definition let bdp hs b block deordering sequential plan seq
bx b two blocks bx let hbx linearisation bx
hbx consistent seq least one step bx appears step seq
way linearise blocks consistent input plan clarified
following example assume bx sa sc sb sd two blocks
linearise orderings constituent steps input plan
sa sb sc sd linearisation starts block contains first
element e bx case since contains sa updated bx
linearisation continues fashion empty resulting linearisation
example blocks hbx multiple nested blocks contain first element
innermost one picked formal definitions thread cyclic thread
follows
definition let bdp hs b block deordering sequential plan seq epm
set extended producers atom bm b set blocks
element bm contains least one element epm thread tm
linearisation blocks bm linearisation consistent seq thread
called cyclic iff cyclic behavior
example plan shown figure atom cyclic behaviour
since holds initial state added step extended producers
cyclic thread hb b


fisiddiqui haslum

finally candidate windows formed taking consecutive subsequence blocks
intermediate blocks necessary cyclic thread rule windowing
blocks unordered respect window assigned set blocks
precede window
definition let tm b bk cyclic thread atom cyclic thread
windows cyclic thread tm wl b ib b b bi bi l consecutive
subsequence tm unordered blocks placed predecessor set
rule windowing heuristic cyclic thread heuristic generates windows order aims ensure returns varied set windows time
called first identifies cyclic threads block deordered plan generates
stream candidate windows one cyclic thread another mentioned
candidate window formed taking consecutive subsequence blocks intermediate blocks required form consistent window cyclic thread given
thread tm blocks subsequences generated according following order sizes
tm tm tm words subsequence lengths ordered
smallest biggest second smallest second biggest size
order windows generated moving beginning end thread
causal followers windowing heuristic
third strategy use obtain broader range potentially improvable
windows similar cyclic thread heuristic creates windows subsequences linearisation blocks connected particular atom different
connections via causal links
definition let bdp hs b block decomposed p plan c set
causal links causal followers atom producer p cfhm pi
p sj sk hp sj hp sk c si sg causal followers
producers cfm sequence hcfhm p cfhm pn p pn linearisation
producers
words causal followers atom list sets steps
set steps one producer others consumers sj
causal link every sj e pc sj example atom b
block deordered plan figure appears two causal links
producer hs b hs b thus causal followers
cf b h
block deordered plan extract sequence sets blocks corresponding
causal follower steps according definition example sequence
causal follower blocks cf b plan figure cfb b h b
since steps cf b contained block b
definition let bdp hs b block decomposed p plan cfhm pi
causal followers atom respect producer p causal follower
blocks respect producer p atom cfbhm pi set blocks
block contains least one element cfhm pi causal follower blocks


ficontinuing plan quality optimisation

exclusive


basic block



ext block



rule



cyclic thread



causal followers



table percentage improvable windows found two block types three
windowing heuristics total number improvable windows found blocks
types windowing heuristics first row gives percentage improvable windows
found one block type one windowing heuristic
others second row gives percentage improvable windows found one
block type windowing heuristic first experiment described
section
producers cfbm sequence hcfbhm p cfbhm pn p pn
linearisation producers bdp
candidate windows formed taking consecutive subsequences sequence
causal follower blocks intermediate blocks necessary formal definition
given windowing heuristics blocks unordered respect
window assigned set blocks precede window
definition let bdp hs b block decomposed p plan cfbm
hcfbhm p cfbhm pn causal follower blocks causal followers
windows cfbm wl b ib b b cfbhm pi cfbhm pi l
consecutive subsequence cfbm length l unordered blocks placed
predecessor list
order windows generated causal followers heuristic
principle cyclic thread heuristic generates stream candidate
windows causal follower blocks cfbm associated atom turn
windows consecutive subsequences sets blocks cfbm lengths chosen
according pattern l l l l length cfbm
impact windowing heuristics
one single windowing heuristic block type combination guaranteed
improvable windows first row table shows percentage improvable
windows found one block type one windowing heuristic
others total number improvable windows found blocks types
windowing heuristics first experiment described section
shows every windowing heuristic block type contributes improvable
windows found strategies example improvable windows
found rule windowing heuristic basic extended blocks
hand improvable windows found heuristic
windowing heuristics strengths limitations rule heuristic
example generate windows contain sequences extended blocks
fixed length cyclic thread causal followers heuristics make windows
blocks connected single atom


fisiddiqui haslum












































































































































































bdpo combined windowing heuristics
bdpo random windowing
bdpo rulebased windowing
bdpo causal followers windowing
bdpo cyclic thread windowing










average quality score relative ipc quality score coverage



time hours

figure average ipc quality score function time separate runs bdpo
three windowing heuristics alone three heuristics combined random
window generation run done setup experiment described
section page x axis shows runtime bdpo e without
hour delay generating input plans shown figure note
axis truncated average quality input plans



ficontinuing plan quality optimisation

figure shows impact different windowing heuristics anytime performance
bdpo measured average ipc plan quality score achieved function timeper experiment ran bdpo three windowing heuristics
alone three combined sequential portfolio described beginning
section combined portfolio windowing heuristic configuration
bdpo presented experimental section page
compare non heuristic random windowing strategy window
formed taking random subsequence blocks random linearisation
block deordered plan subsequences chosen distribution window sizes
measured number actions window roughly produced
combined heuristics experiment uses setup described section page
e input plans bdpo already high quality average ipc plan
quality score
predicted data table three windowing heuristics
much worse system performance since fails substantial
fraction improvable windows fact random window generation better
heuristics however combined portfolio heuristics outperforms
random windowing good margin total quality improvement achieved
random windowing strategy less best bdpo configuration
demonstrates heuristics capture information useful guide selection
windows
possible extensions windowing strategies
since window formed partitioning plan steps three disjoint sets blocks
number possible windows exponential challenge good windowing heuristic
extract reduced set contains windows likely improved every windowing
strategy limitations hence scope developing windowing
heuristics extending existing ones one extension discussed section
combination strategies use may miss improvable windows example
long sequence blocks form part cyclic thread causal followers sequence
respect single atom captured heuristics example
shown figure three candidate windows w w w found causal
followers windowing heuristic improvable separately situation forming
window union separate windows found one several strategies overcome
limitations strategies example union w w improvable
type composite windows could formed later stages plan improvement
process individual windowing heuristics exhausted however
number composite windows created large set candidate windows
combinatorial thus optimising take long time
window ranking
although windowing strategies generate fraction possible windows
number candidate windows still often large cf table order speed


fisiddiqui haslum

figure three candidate windows w w w found causal followers
windowing heuristic atoms b p p respectively none
improvable however composite window formed merging w w
improvable substituting delivery package p location b c provided
truck truck atom c required
successors e goal example

plan improvement process helpful order windows likely
improved optimised first role window ranking
ranking windows made difficult fact properties improvable windows
vary one another lot domain domain example mentioned
beginning section larger windows likely improved pegsol
openstacks parcprinter domains smaller windows better elevators
transport scanalyzer woodworking domains sokoban domain
hand medium sized windows better moreover improvable window may
improved particular subplanner within given time bound noted
domains e g pegsol scanalyzer subplanners require average time
lower cost plan
developed set window ranking policies examining structural properties
generated candidate windows generated first experiment cf
section ran two subplanners ibcs pngs generated window
second time limit excluding windows whose cost already shown
optimal admissible lm cut heuristic helmert domshlak investigating
properties improved unimproved windows identified four metrics work
relatively well across domains


ficontinuing plan quality optimisation


random ranking
outgoing causal links per length min max
incoming causal links per length min max
pairwise ordering disagreement min max
gap cost admissible heuristic max min

fraction improvable windows selected windows














































































number selected top ranked windows

figure fraction improvable windows across domains selected top
windows ranked orders generated ranking policies see text

total number causal links whose producers reside window whose consumers outside window divided length window lower
value higher rank call property outgoing causal links per length
total number causal links whose consumers reside window whose producers outside window divided length window lower
value higher rank call property incoming causal links per length
gap cost window lower bound cost plan
corresponding subproblem given admissible heuristic higher value
higher rank
number pairwise ordering steps disagreements window hp w qi
sequential input plan lower value higher rank calculate
first take linearisation hp w qi used generate corresponding
subproblem every pair plan steps ordering
linearisation input plan call pairwise ordering
disagreement lower total number disagreements window
higher rank words ordering steps window different
input plan less likely improved



fisiddiqui haslum


fraction improvable windows selected windows

random ranking
outgoing causal links per length min max
incoming causal links per length min max
pairwise ordering disagreement min max
gap cost admissible heuristic max min























































































number selected top ranked windows

figure fraction improvable windows parking domain selected top
windows ranked orders generated ranking policies see text

infer first two ranking policies disconnected window
blocks decomposed plan likely improved figure
compares ranking policies performance random ordering windows
average across domains four ranking policies good picking improvable
windows example take top windows order generated
incoming causal links per length policy nearly windows improvable
least one subplanner top windows random order contain
improvable windows random ranking figure best three
separate random rankings values x axis expected exhibits
roughly ratio improvable windows ranges nearly
selected windows across domains improvable however performance
individual ranking policies varies domain policy domain
good example figure shows ranking instances
parking domain outgoing causal links per length policy work
well considering top windows ranked order even worse random
however ranking policies quite beneficial domain
bdpo uses first three ranking policies sequential portfolio explained
section subplanner bdpo uses current ranking policy select next


ficontinuing plan quality optimisation



average quality score relative ipc quality score coverage



















































































bdpo rankbased
bdpo randomranked




























time hours

figure average ipc plan quality score function time two separate runs
without window ranking second case order candidate windows
randomised run done experimental setup described section
page time shown runtime bdpo excluding hour delay
generating input plans shown figure axis truncated
curves start average quality score input plans

window chosen subplanner eligible optimisation subplanner
improvement found subplanner certain number attempts
current configuration system switches different ranking policy produce different
ordering candidate windows subplanner
use window ranking beneficial effect anytime performance
plan improvement process shown figure achieve higher quality scores
particular achieve faster window ranking compared random ranking
experiment ran bdpo portfolio ranking policies described


fisiddiqui haslum

windows chosen optimisation random order experiment
used setup experiment described section page
tried many alternative methods combining ordered lists generated different
ranking policies order achieve ranking stable performance across domains
combining rankings often called rank aggregation studied many
disciplines social choice theory sports competitions machine learning information retrieval database middleware rank aggregation techniques range
quite simple rank average number pairwise wins complex procedures
require solving optimisation tried five simple popular rank aggregation techniques namely bordas method kemenys optimal
ordering copelands majority graph mc dwork kumar naor sivakumar
multivariate spearmans rho bedo ong experiments however rank aggregation produce better stable window
rankings especially cases one individual policy relatively bad hence choice
ranking policies cyclic portfolio instead

line adaptation
lns optimisation repeatedly solving local subproblems gives us
opportunity adapting process line current noted
different subplanners windowing strategies ranking policies work better different
domains example figure shows fraction local improvements found
three subplanners different domains seen ibcs subplanner
productive compared pngs lama appn barman maintenance parking
sokoban woodworking domains pngs hand better scanalyzer
visitall domains lama elevators openstacks domains therefore
learn course local search relative success rate different subplanners
current system perform better similar fashion window
generation strategies ranking policies may adapted current
system likely select subplans optimisation improvable
use line machine learning technique multi armed bandit mab model
specific select subplanner local optimisation attempt technique impact anytime performance bpo described following
subsections
window selection line adaptation limited switching alternative
ranking policies window selected optimisation subplanner top one
order given current ranking policy subplanner cf section
long improvements found among windows consider current
policy useful subplanner reaches certain number attempts
improvements found switch next policy subplanner number
windows neighbourhood optimised typically small compared
number candidate windows generated average across experiment
cf section page optimisation least one subplanner tried
generated windows adapting ranking policy influence


ficontinuing plan quality optimisation

figure percentage improved windows found subplanners pngs
ibcs lama total number improved windows found subplanners experiment bdpo run three times time one subplanner
setup experiment described section page

windows tried adapting windowing strategies effect adaptive
window ranking anytime performance bdpo shown figure page
bandit learning
multi armed bandit mab model popular machine learning formulation dealing
exploration versus exploitation dilemma mab
presented sequence trials round chooses one set
alternatives often called arms past history receives reward
choice goal maximise total reward time bandit learning
balances exploiting arms highest observed average reward exploring poorly
understood arms discover yield better reward
mab found numerous applications diverse fields e g control economics statistics learning theory influential robbins many policies
proposed mab different assumptions example independent auer et al dependent arms pandey chakrabarti agarwal
exponentially infinitely many arms wang audibert munos finite infinite
time horizon jones gittins without contextual information slivkins

cast selecting subplanner local optimisation attempt
multi armed bandit goal maximise total number improved
windows time use learning optimistic exploration strategy chooses arm favorable environments high probability
best given observed far strategy often called optimism
face uncertainty trial arm k strategy use past
observations probabilistic argument define high probability confidence intervals
expected reward k favorable environment arm k thus upper


fisiddiqui haslum

confidence bound ucb k simple policy strategy play arm
highest ucb
number developed optimistic exploration bandit arms
ucb ucb ucb normal auer et al ucb v audibert
munos szepesvari kl ucb garivier cappe use
ucb planner selection ucb
selects trial arm
q
ln
highest upper confidence bound bk
bk
nk sum exploitation term
exploration term respectively
bk empirical mean rewards received
arm k

trial


n


number
times arm k tried far
k
q
ln
second term
nk confidence interval average reward within true
expected reward falls almost certain probability hence bk upper confidence
bound ucb achieve logarithmic regret uniformly number
trials without preliminary knowledge reward distributions auer et al

applied subplanner selection bdpo works follows first
select subplanner p initialise average reward
bp optimisation
attempt give reward chosen subplanner found improvement
reward otherwise could use scheme assigning rewards rather
simply example making reward proportional amount improvement
time taken however observed assigning varying rewards
subplanners makes bandit learning system complicated help
achieving better overall next select
q attempt subplanner p
maximises upper confidence bound p bp
bp nlnp explained
np number times p tried far total number optimisation
attempts subplanners done far see bp grows shrinks
np increase uniformly ensures alternative tried infinitely often
still balances exploration exploitation words try p
smaller size confidence interval closer gets mean value
bp

p cannot tried becomes smaller p p planner best
average reward
impact bandit learning
response bandit policy subplanner selection shown figure figure
shows fraction total number optimisation attempts one subplanner ibcs
selected fraction total number window improvements found
subplanner since bdpo experiment uses two subplanners ibcs pngs
corresponding fraction pngs example third
left appn domain window improvements found ibcs
bandit policy selects subplanner total number optimisation attempts
pngs chosen finds improvement see bandit
policy selects promising subplanner often across however
bandit policy somewhat conservative ensures rule
subplanners fare poorly early moreover current plan improved


ficontinuing plan quality optimisation


improvement ratio
exploitation ratio




exploitation improvement ratio ibcs


























































































woodworking

visitall

transport

thoughtful

tetris

sokoban

parking

scanalyzer

parcprinter

nomystery

maintenance

hiking

ged

floortile

elevators

childsnack

barman

appn



figure response bandit policy subplanner success rates exploitation
ratio fraction total number optimisation attempts ibcs
subplanner chosen total number attempts subplanners
improvement ratio fraction total number improved windows found ibcs
total number improved windows found subplanners since ibcs
pngs two subplanners used experiment corresponding ratios
pngs opposite e experiment run setup
experiment described section page

becomes harder improvements within given time bound average
reward subplanners decreases forces bandit policy switch
subplanners often
figure shows impact combining subplanners ucb bandit policy
compared simply alternating subplanners subplanner alone
anytime performance bdpo experiment ran bdpo ibcs
pngs lama subplanner combining two ibcs pngs
simple alternation policy selects two turn combining
two bandit policy run done experiment setup described
section page e input plans high quality ipc plan quality
score plan calculated see page average score input
plans expected combining ibcs pngs subplanners fashion
leads quality improvement across entire time scale achieved running
bdpo individual subplanner figure shows combining multiple
subplanners bandit policy better strategy simply alternating


fisiddiqui haslum



average quality score relative ipc quality score coverage















































































































































bdpo pngs ibcs bandit
bdpo pngs ibcs alternating
bdpo pngs
bdpo ibcs
bdpo lama








































time hours

figure average ipc quality score function time per five different
runs bdpo one three subplanners two ibcs
pngs combined ucb bandit policy without simple alternation
instead experiment run setup described section page
note axis truncated curves start average quality input plans
time shown runtime bdpo excluding hour
delay generating input plans shown figure



ficontinuing plan quality optimisation

total quality improvement achieved bdpo alternation policy
less bdpo bandit policy

related work
survey four areas related work anytime search post processing approaches common aim continuing plan quality
improvement uses local search finally uses portfolios

anytime search
large state space search kind frequently arise
often cannot solved optimally optimal search exhaust memory
finding solution anytime search try deal finding
first solution quickly possibly greedy suboptimal heuristic search continue
restart searching better quality solution anytime attractive allow users stop computation time e good enough solution
found long wait contrasts require
user decide advance deadline suboptimality bound parameter
fixes trade time solution qualty
bounded suboptimal search finding solution cost less
equal user specified factor w optimal weighted wa search pohl
explicit estimation search ees thayer ruml two
kind used iteratively applying bounded suboptimal
search lower value w whenever best solution found provides
anytime improvement plan quality restarting wa richter et al
schedule decreasing weights rwa used lama planner richter westphal
lama finds first plan greedy best first search bonet geffner
uses several search enhancements preferred operators deferred evaluation
richter helmert ees conducts bounded suboptimal best first search restricted
expanding nodes may lead solution cost given factor w
times optimal among open nodes set expands one estimated
fewest remaining actions goal uses admissible heuristic plan
cost informative inadmissible estimates guide search aees thayer
et al b anytime version ees achieve anytime behavior aees lowers
value w whenever best solution found
bounded cost search stern puzis felner subproblems solved example requires finding solution cost less
equal user specified cost bound c aim bounded cost search solution quickly possible iteratively applying bounded cost
search bound less cost best solution found far provides
anytime quality improvement ibcs used one subplanners bdpo bees beeps thayer stern felner
ruml adapt ees setting bounded cost search expand


fisiddiqui haslum

best open node among whose inadmissible cost estimate c falling back
expanding node best admissible estimate set empty
branch bound explore search space systematic fashion
admissible heuristic lower bound cost prune nodes cannot lead solution
better best found far branch bound implemented linearmemory depth first search strategy well top strategies experiment
reported section page used beam stack search bss zhou hansen
bounded cost search providing initial upper bound cost
base plan bss combines backtracking branch bound beam
search behaves breadth first search limits size open list
layer user specified parameter known beam width forced backtrack
bss reconstructs nodes pruned open list search complete beam
width parameter used control memory consumption bss never
exceeds available memory however whose state spaces often
dense transpositions accurate admissible heuristics expensive compute
repeatedly reconstructing paths unexplored nodes becomes time consuming
anytime search planners aim provide continuing improvement plan quality given
time often succeed early stages search however
observed experiments often stagnate reaching
point better plans even several hours cpu time cf
figure page section page example experiment lama
aees found better plans respectively total number
hours hours cpu time bdpo found better plans
time interval memory one limiting factor
one almost half aees ran full hours cpu time
without running memory yet found improved plans bss found plans
cost less initial upper bound cost base plans
even hours cpu time per
local search
local search explores space searching small neighbourhood current element
search space one way better moving neighbour
repeating process compared systematic search advantage local
search needs much less memory therefore local search widely
used solve hard optimisation however local search cannot offer
guarantees global optimality bounded suboptimality local search
used mainly plans quickly rarely improve plan quality though
post processing methods discussed next section viewed local searches
hoffmann nebel forward chaining heuristic state space search planner
heuristic used estimates distance state nearest goal state
uses local search strategy called enforced hill climbing state uses breadthfirst search neighbour state may several steps away current
state strictly better heuristic value e believed closer goal
commits state starts search neighbour better yet


ficontinuing plan quality optimisation

heuristic value local search fails due getting trapped dead end falls back
complete best first search rw ls xie nakhost
muller similar ffs hill climbing uses combination greedy
best first search exploration random walks better next state local
search step nakhost muller developed system called arvand
uses random walk local exploration conjunction search heuristic
showed arvand outperforms hard many domains execution
arvand consists series search episodes episode starts set random
walks initial state endpoint random walk evaluated
heuristic function choose next state search episode continues set
random walks state process repeats goal reached
enough transitions made without heuristic progress case process
restarted ipc versions arvand apply post processing improve
quality generated plan post processing techniques action elimination
plan neighborhood graph search nakhost muller discussed next
subsection arvands search randomised system continue generating
alternative plans optmised indefinitely storing times best plan
generated far provides certain anytime capability manner
used experiment reported section page
lpg planner gerevini serina local search space
action graphs represent partial plans neighbourhood defined operators
modify action graph inserting removing actions function
evaluates nodes neighbourhood combines terms estimate far action
graph becoming valid plan termed search cost expected quality
plan may become choice neighbour move involves element
randomness lpg performs continuing search better plans similar
anytime search discussed last subsection whenever finds plan
local search restarts partial plan obtained removing randomly selected
actions current plan numerical constraint forcing cost next plan
lower added provides guidance towards better quality next plan
close relationship local search approaches plan repair
adaptation methods garrido guzman onaindia lpg planner originated
method plan repair gerevini serina iterative repair methods
used plan generation chien knight stechert sherwood rabideau
key difference use local search previous uses
carry local search space valid plans permits neighbourhood
evaluation focus exclusively plan quality searching space partial plans represented states done incomplete invalid plans done lpg requires
neighbourhood evaluation consider close element becoming valid plan
balancing quality
large neighbourhood search lns strategy formulates finding
good neighbor optimisation rather simply enumerating evaluating
neighbours allows much larger neighbourhood considered lns used
successfully solve hard combinatorial optimisation vehicle routing
time windows shaw scheduling godard laborie nuijten theoretical


fisiddiqui haslum

experimental studies shown increased neighborhood size may improve
effectiveness quality solutions local search ahuja goodstein mukherjee
orlin sharma neighbourhood current solution small
difficult escape local minima case additional meta heuristic techniques
simulated annealing tabu search may needed escape local minimum
lns size neighborhood may sufficient allow search process
avoid escape local minima
lns literature neighborhood solution usually defined set
solutions reached applying destroy heuristic repair method
destroy heuristic selects part current solution removed unassigned
repair method rebuilds destroyed part keeping rest current solution
fixed destroy heuristic often includes element randomness enabling search
explore modifications different parts current solution role destroy
heuristic system played windowing strategies select candidate windows subplans optimisation explore windows systematically lns
e g ropke pisinger schrimpf et al allow local search
move neighbouring solution lower quality e g simulated annealing
consider strictly improving moves however difference previous lns
immediately move better plan restart neighbourhood exploration
local improvement found instead use delayed restarting allows better
solution found one local search step destroying repairing multiple parts
current plan experimentally found delayed restarting produces better quality
plans produces faster immediate restarts cf section page
plan post processing
post processing method mean one takes valid plan input attempts
improve making modifications related plan repair adaptation
chien et al fox gerevini long serina garrido et al
key difference plan repair adaptation starts plan valid
current situation focuses making work discrepancy current
state goals plan originally built provide guidance repairs
needed contrast post processing plan optimisation may require modifications
anywhere current plan
nakhost muller proposed two post processing techniques action elimination ae plan neighborhood graph search pngs action elimination identifies
removes unnecessary actions given plan pngs constructs plan neighborhood graph subgraph state space built around
path state space induced current plan expanding limited number
states state path searches least cost plan subgraph
finds plan better current process repeated around best
plan otherwise exploration limit increased time memory limit exceeded
furcys iterative tunneling search itsa similar pngs itsa
explores area called tunnel state space search restricted fixed
distance current plan methods seen creating neighborhood


ficontinuing plan quality optimisation

includes small deviations current plan anywhere along plan
contrast bdpo focuses one section decomposed plan time often grouping
together different parts input plan puts restriction much section
changes hence creates different neighbourhood experiments best
obtained exploring neighbourhoods example pngs often finds
plan improvements quickly running additional hours improves average
ipc plan quality score best plans finds first hour
running instead bdpo pngs subplanner taking best plans
found pngs hour input improves average plan quality score
hours
ratner pohl used local optimisation shortening solutions sequential
search select subpath optimise used sliding window predefined size dmax consecutive segments current path estrem krebsbach
instead used form windowing heuristic select local optimisation pairs
states current path maximise estimate redundancy ratio
estimated distances two states given state space heuristic
cost current path balyo bartak surynek used sliding window
minimise parallel plan length makespan assuming actions
unit duration rather take segments single path state space use block
deordering input plan create candidate windows local optimisation shown
experimental important success bdpo total
improvement average plan quality achieved without deordering less
achieved bdpo block deordering input plans cf section page
rewriting ambite knoblock uses local modifications partially ordered plans improve quality plan modifications defined
domain specific rewrite rules provided domain designer learned
many examples good bad plans hence technique effective
solving many instances domain planner solve subproblems may time consuming applying pre defined rules makes process
automatic however consider solving many domain may
possible reduce average time learning generalised rules subplan
improvements discover applicable avoid invoking subplanner
portfolio automatic parameter tuning
portfolio system runs several subplanners sequence parallel short
timeouts hope least one component planners solution
time allotted portfolio systems motivated observations
single planner dominates others domains planner solve
task quickly often solve therefore many todays
successful planners run sequential portfolio planners coles coles olaya celorrio
linares lopez sanner yoon
gerevini saetti vallati introduced pbp planner learns portfolio
given set planners specific domain well domain specific macro actions
fast downward stone soup fdss helmert roger seipp karpas hoffmann keyder


fisiddiqui haslum

nissim richter westphal uses fixed portfolio computed optimise performance
large sample training domains domains ibacop cenamor et al
dynamically configures portfolio predictive model planner success
another recent trend use automatic configuration tools
paramils framework hutter hoos leyton brown stutzle enhance planner
performance specific domain paramils local search space configurations suite training evaluate performance different parameter
settings combinatorial explosion caused many parameters many different values managed varying one parameter time paramils used configure
lpg planner vallati fawcett gerevini hoos saetti fast downward planner fawcett helmert hoos karpas roger seipp pbp portfolio
planner gerevini saetti vallati successor pbp includes version lpg
customised domain paramils learned portfolio
bdpo course uses portfolio subplanners shown selecting
right subplanner current important cf section much important
however focus subproblems brings comparing figures page
page clear even single subplanner within bdpo
effective subplanners multiple window ranking
policies used bdpo cf section viewed simple sequential portfolio
compared previous portfolio planners iterated use subplanners windowing strategies components offers possibility learn best portfolio
configuration line rather spend time configuring system
training learn experience solving several subproblems
actually working optimising current plan
finally although explored great depth suggest combining different anytime search post processing methods effectively kind
sequential portfolio running bdpo running pngs
lama ibacop experiment shown figure page
often achieves better quality final plans investing available time single
method

conclusions future work
plan quality optimisation particularly large central concern automated
anytime aims deliver continuing stream better plans
given time attractive idea offering flexibility stop process
point best plan found good enough wait next plan
becomes long presented anytime plan improvement
realisation bdpo system large neighbourhood local
search strategy shaw windowing heuristics select candidate windows
block deordering current plan local optimisation shelf bounded cost
techniques
experiments demonstrate bdpo achieves continuing plan quality improvement
even large time scales several hours cpu time anytime planners stagnate
key achieving focus optimising subproblems corresponding windows


ficontinuing plan quality optimisation

mentioned section extending windowing heuristics improving line
learning effective window rankings one way improve complementing window ranking estimates promising window
estimate difficult windows optimise inform time allocated subplanners currently uniform windows may contribute better
performance best however achieved chaining several techniques together
example applying bdpo best plan found pngs applied best plan
found lama ibacop cannot achieved previous anytime approaches alone thus another area future work examine greater
depth best way combine different plan improvement methods
learned line optimising plan example conducted study
optimal time switch base plan generation lama post processing
pngs bdpo function total runtime siddiqui haslum
demonstrated experimentally block deordering step essential
good performance bdpo cf section page block deordering creates
decomposition plan non interleaving blocks removing ordering constraints
blocks lifts limitation conventional step wise deordering
requires unordered steps plan non interfering shown validity
condition block decomposed partially ordered plans stated almost
chapmans modal truth criterion allowing threats causal link
remain unordered long link protected block structure theorem
page therefore block deordering yield less order constrained plans including
cases conventional deordering possible
plan structure uncovered block decomposition uses recently used planner independent macro generation system bloma chrpa
siddiqui longer macros capture compound activities order improve
planners coverage efficiency domains e g barman childsnack scanalyzer
parcprinter gripper woodworking etc block deordering often identifies structurally similar subplans symmetric improvement patterns could potentially
exploited learning plan rewrite rules ambite knoblock minton structure
block deordered plans often comprises nested hierarchical decomposition
meaningful subplans reminiscent hierarchical task network htn representations
hence block deordering technique could potentially applied generating helping
generate htn structures domain independent way reducing knowledge engineering
effort recent work scala torasso extends deordering plans
domains numeric state variables identifying numeric dependencies capture
additional reasons necessary orderings defining conditions blocks sufficient
encapsulate dependencies would allow block deordering numeric plans
may synergy block deordering numeric since numeric dependencies often involve groups plan steps rather single producerconsumer pair
acknowledgment
work partially supported australian council discovery project
dp robust ai hybrid systems nicta funded aus

fisiddiqui haslum

tralian government department communications australian council ict centre excellence program

references
ahuja r k goodstein j mukherjee orlin j b sharma
large scale neighborhood search combined fleet assignment
model informs journal computing
ambite j l knoblock c rewriting journal artificial
intelligence jair
ambite j l knoblock c minton learning plan rewriting rules
proc th international conference artificial intelligence systems
aips breckenridge co usa april pp aaai press
audibert j munos r szepesvari c explorationexploitation tradeoff
variance estimates multi armed bandits theoretical computer science

auer p cesa bianchi n fischer p finite time analysis multiarmed
bandit machine learning
backstrom c computational aspects reordering plans journal artificial
intelligence jair
balyo bartak r surynek p improving plan quality via local enhancements proc th international symposium combinatorial search socs
niagara falls canada july aaai press
bedo j ong c multivariate spearmans rho aggregating ranks
copulas corr abs
bonet b geffner h heuristic search artificial intelligence
cenamor de la rosa fernandez f ibacop ibacop planners
proc th international competition ipc deterministic part
pp
chapman conjunctive goals artificial intelligence
chien knight r stechert sherwood r rabideau g iterative
repair improve responsiveness scheduling proc
th international conference artificial intelligence systems aips
breckenridge co usa april pp aaai press
chrpa l siddiqui f h exploiting block deordering improving planners efficiency proc th international joint conference artificial intelligence
ijcai buenos aires argentina july pp aaai press
coles j coles olaya g celorrio j linares lopez c sanner yoon
survey seventh international competition ai magazine



ficontinuing plan quality optimisation

copeland h reasonable social welfare function university michigan
seminar applications mathematics social sciences
de borda j c memory election ballot history royal academy
sciences paris
dwork c kumar r naor sivakumar rank aggregation methods
web proc th international conference world wide web www
hong kong may pp york ny usa acm
estrem j krebsbach k airs anytime iterative refinement solution proc th international florida artificial intelligence society
conference marco island florida may
fawcett c helmert hoos h karpas e roger g seipp j fd autotune
domain specific configuration fast downward proc icaps
workshop learning pal freiburg germany june
pp aaai press
fox gerevini long serina plan stability replanning versus plan
repair proc th international conference automated
scheduling icaps cumbria uk june pp aaai press
furcy itsa iterative tunneling search proc aaai
workshop heuristic search memory heuristics applications
july boston massachusetts pp aaai press
garivier cappe kl ucb bounded stochastic bandits
beyond corr abs
garrido guzman c onaindia e anytime plan adaptation continuous
proc joint th workshop uk special interest group
scheduling th italian workshop scheduling pp

gerevini saetti vallati automatically configurable portfolio
planner macro actions pbp proc th international conference
automated scheduling icaps thessaloniki greece september
pp aaai press
gerevini saetti vallati pbp automatic configuration portfoliobased multi planner th international competition ipc learning
track http www plg inf uc es ipc learning
gerevini serina lpg planner local search graphs
action costs proc th international conference artificial intelligence
scheduling aips april toulouse france pp
aaai press
gerevini e serina fast plan adaptation graphs local
systematic search techniques proc th international conference
artificial intelligence systems aips breckenridge co usa april
pp aaai press


fisiddiqui haslum

ghallab nau traverso p automated theory practice
morgan kaufmann publishers inc san francisco ca usa
godard laborie p nuijten w randomized large neighborhood search
cumulative scheduling proc th international conference automated
scheduling icaps monterey california usa june
pp aaai press
haslum p computing genome edit distances domain independent
proc icaps workshop scheduling applications
spark freiburg germany june aaai press
haslum p incremental lower bounds additive cost proc
nd international conference automated scheduling icaps
atibaia sao paulo brazil june pp aaai press
haslum p grastien diagnosis two case studies proc
icaps workshop scheduling applications spark
freiburg germany june aaai press
haslum p jonsson p reduced operator sets proc
th international conference artificial intelligence systems aips
breckenridge co usa april pp aaai press
helmert roger g seipp j karpas e hoffmann j keyder e nissim r richter
westphal fast downward stone soup planner abstract
proc th international competition ipc deterministic part
http www plg inf uc es ipc deterministic
helmert domshlak c landmarks critical paths abstractions whats
difference anyway proc th international conference automated
scheduling icaps thessaloniki greece september
pp aaai press
hoffmann j local search topology benchmarks empirical analysis
proc th international joint conference artificial intelligence ijcai
seattle washington usa august pp san francisco ca
usa morgan kaufmann publishers inc
hoffmann j nebel b system fast plan generation
heuristic search journal artificial intelligence jair
hutter f hoos h h leyton brown k stutzle paramils automatic
configuration framework journal artificial intelligence jair

jones gittins j dynamic allocation index sequential design
experiments university cambridge department engineering
kambhampati kedar unified framework explanation generalization partially ordered partially instantiated plans artificial intelligence



ficontinuing plan quality optimisation

mcallester rosenblitt systematic nonlinear proc th
national conference artificial intelligence aaai anaheim ca usa july
pp aaai press mit press
muise c j mcilraith beck j c optimally relaxing partial order plans
maxsat proc nd international conference automated
scheduling icaps atibaia sao paulo brazil june pp
aaai press
nakhost h muller monte carlo exploration deterministic
proc st international joint conference artificial intelligence ijcai
pasadena california usa july vol pp
nakhost h muller action elimination plan neighborhood graph search
two plan improvement proc th international conference
automated scheduling icaps toronto canada may
pp aaai press
nebel b backstrom c computational complexity temporal projection plan validation artificial intelligence
pandey chakrabarti agarwal multi armed bandit
dependent arms proc th international conference machine learning
icml corvallis oregon usa june vol pp acm
pednault e p formulating multiagent dynamic world classical
framework reasoning actions plans
pohl heuristic search viewed path finding graph artificial intelligence

ratner pohl joint lpa combination approximation search
proc th national conference artificial intelligence aaai philadelphia pa august science pp morgan kaufmann
regnier p fade b complete determination parallel actions temporal
optimization linear plans action proc european workshop
ewsp sankt augustin frg march vol lecture notes
computer science pp springer
richter helmert preferred operators deferred evaluation satisficing
proc th international conference automated
scheduling icaps thessaloniki greece september pp
aaai press
richter thayer j ruml w joy forgetting faster anytime search
via restarting proc th international conference automated
scheduling icaps toronto canada may pp aaai
press
richter westphal lama planner guiding cost anytime
landmarks journal artificial intelligence jair



fisiddiqui haslum

robbins h aspects sequential design experiments herbert
robbins selected papers vol pp springer
ropke pisinger adaptive large neighborhood search heuristic
pickup delivery time windows transportation science

scala e torasso p deordering numeric macro actions plan repair
proc th international joint conference artificial intelligence ijcai
buenos aires argentina july pp aaai press
schrimpf g schneider j stamm wilbrandt h dueck g record breaking
optimization ruin recreate principle journal computational
physics
shaw p constraint programming local search methods solve vehicle
routing proc th international conference principles
practice constraint programming cp pisa italy october
vol lecture notes computer science pp springer
siddiqui f h haslum p block structured plan deordering proc th
australasian joint conference advances artificial intelligence ai sydney
australia december vol lecture notes computer science pp
berlin heidelberg springer
siddiqui f h haslum p local search space valid plans proc
icaps workshop evolutionary techniques scheduling evops rome italy june pp http icaps icapsconference org wp content uploads evops proceedings pdf
siddiqui f h haslum p b plan quality optimisation via block decomposition
proc rd international joint conference artificial intelligence ijcai
beijing china august pp aaai press
slivkins contextual bandits similarity information journal machine
learning
stern r puzis r felner potential search bounded cost search
proc st international conference automated
scheduling icaps freiburg germany june pp aaai
press
thayer j stern r felner ruml w faster bounded cost search
inadmissible heuristics proc nd international conference automated
scheduling icaps atibaia sao paulo brazil june
pp aaai press
thayer j benton j helmert b better parameter free anytime search
minimizing time solutions proc th international symposium
combinatorial search socs niagara falls canada july pp
aaai press


ficontinuing plan quality optimisation

thayer j ruml w bounded suboptimal search direct
inadmissible estimates proc nd international joint conference artificial intelligence ijcai barcelona catalonia spain july pp
aaai press
vallati fawcett c gerevini hoos h saetti parlpg generating domain specific planners automatic parameter configuration lpg
proc th international competition ipc deterministic part
http www plg inf uc es ipc deterministic
veloso perez carbonell j g nonlinear parallel
resource allocation proc darpa workshop innovative approaches
scheduling control san diego california november pp
morgan kaufmann
wang audibert j munos r infinitely many armed bandits
proc nd annual conference neural information processing systems
nips vancouver british columbia canada december pp
curran associates inc
xie f nakhost h muller via random walk driven local search
proc nd international conference automated scheduling
icaps atibaia sao paulo brazil june pp aaai press
xie f valenzano r muller better time constrained search via randomization postprocessing proc rd international conference
automated scheduling icaps rome italy june
pp aaai press
young h p levenglick consistent extension condorcets election principle siam journal applied mathematics
zhou r hansen e beam stack search integrating backtracking beam
search proc th international conference automated
scheduling icaps monterey california usa june pp
aaai press




