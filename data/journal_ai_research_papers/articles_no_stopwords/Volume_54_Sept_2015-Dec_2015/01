Journal Artificial Intelligence Research 59 (2015) 59-82

Submitted 05/15; published 09/15

Solving #SAT MaxSAT Dynamic Programming
Sigve Hortemo Sther
Jan Arne Telle
Martin Vatshelle

sigve.sether@ii.uib.no
telle@ii.uib.no
martin.vatshelle@ii.uib.no

Department Informatics, University Bergen
Bergen, Norway

Abstract
look dynamic programming algorithms propositional model counting,
called #SAT, MaxSAT. Tools graph structure theory, particular treewidth,
used successfully identify tractable cases many subfields AI, including
SAT, Constraint Satisfaction Problems (CSP), Bayesian reasoning, planning.
paper attack #SAT MaxSAT using similar, modern, graph structure
tools. tractable cases include formulas whose class incidence graphs
unbounded treewidth unbounded clique-width. show algorithms extend
previous results MaxSAT #SAT achieved dynamic programming along
structural decompositions incidence graph input formula. present
limited experimental results, comparing implementations algorithms state-of-the-art
#SAT MaxSAT solvers, proof concept warrants research.

1. Introduction
propositional satisfiability problem (SAT) fundamental problem computer science
AI. Many real-world applications planning, scheduling, formal verification
encoded SAT SAT solver used decide exists solution.
decide many solutions are, propositional model counting problem (#SAT),
finds number satisfying assignments, could useful. solutions,
may interesting know close get solution. propositional
formula encoded Conjunctive Normal Form (CNF) may solved maximum
satisfiability problem (MaxSAT), finds maximum number clauses
satisfied assignment. paper investigate classes CNF formulas
two problems, #SAT MaxSAT, solved polynomial time. Tools
graph structure theory, particular treewidth, used successfully identify
tractable cases many subfields AI, including SAT, Constraint Satisfaction Problems
(CSP), Bayesian reasoning, planning (Bacchus, Dalmao, & Pitassi, 2003; Darwiche,
2001; Fischer, Makowsky, & Ravve, 2008; Samer & Szeider, 2010). paper
attack #SAT MaxSAT using similar, modern, graph structure tools.
tractable cases include formulas whose class incidence graphs unbounded
treewidth unbounded clique-width.
#SAT MaxSAT significantly harder simply deciding satisfying
assignment exists. #SAT #P-hard (Garey & Johnson, 1979) even restricted
Horn 2-CNF formulas, monotone 2-CNF formulas (Roth, 1996). MaxSAT
NP-hard even restricted Horn 2-CNF formulas (Jaumard & Simeone, 1987),
c
2015
AI Access Foundation. rights reserved.

fiSther, Telle & Vatshelle

2-CNF formulas variable appears 3 times (Raman, Ravikumar, & Rao,
1998). problems become tractable certain structural restrictions obtained
bounding width parameters graphs associated formulas (Fischer, Makowsky, & Ravve,
2008; Ganian, Hlineny, & Obdrzalek, 2013; Samer & Szeider, 2010; Szeider, 2003).
work present inspired recent results work Paulusma, Slivovsky,
Szeider (2013) work Slivovsky Szeider (2013) showing #SAT
solvable polynomial time incidence graph1 I(F ) input formula F
bounded modular treewidth, strongly, bounded symmetric clique-width.
tractability results work dynamic programming along decomposition I(F ).
two steps involved: (1) find good decomposition, (2) perform dynamic
programming along decomposition. goal fast runtime, usually
expressed function known graph width parameter incidence graph I(F )
formula F , tree-width. Step (1) solved known graph algorithm
computing decomposition low (tree-)width, step (2) solves #SAT MaxSAT
dynamic programming runtime expressed terms (tree-)width k
decomposition.
algorithms give paper work dynamic programming along
decomposition, slightly different framework. Since solving graph
theoretic problem, expressing runtime graph theoretic parameter may limitation.
Therefore, strategy develop framework based following strategy
(A) consider, #SAT MaxSAT, amount information needed combine
solutions subproblems global solutions,
(B) define notion good decompositions based parameter minimizes
information,
(C) design dynamic programming algorithm along decomposition runtime
expressed parameter
work Paulusma et al. (2013) Slivovsky Szeider (2013)
two assignments considered equivalent satisfy set clauses.
carrying (A) #SAT MaxSAT led us concept ps-value
CNF formula. Let us define give intuitive explanation. subset C clauses
CNF formula F called projection satisfiable complete assignment
satisfying every clause C satisfying clause C. ps-value F
number projection satisfiable subsets clauses. Let us consider connection
dynamic programming, general applies optimal solution found
combining optimal solutions certain subproblems. #SAT MaxSAT
subproblems, least cases consider, take form subformula F induced
subset clauses variables, i.e. first remove F variables
remove clauses S. Consider simplicity two subproblems FS FS
defined complement S. combining solutions FS FS , order
1. I(F ) bipartite incidence graph clauses F one hand variables F
hand. Information positive negative occurrences variables encoded I(F )
sometimes signed directed version used includes information.

60

fiSolving #SAT MaxSAT Dynamic Programming

find solutions F , seems clear must consider number cases least
big ps-values two disjoint subformulas crossing S, i.e.
subformulas obtained removing clauses variables S, removing
clauses variables S. See Figure 2 example.
find literature study ps-value CNF formulas, start
asking characterization formulas low ps-value. led concept
mim-value I(F ), size maximum induced matching I(F ),
induced matching subset edges property edge graph
incident one edge . Note value much lower
size maximum matching, e.g. complete bipartite graph mim-value 1. show
ps-value F upper bounded number clauses F raised power
mim-value I(F ), plus 1. CNF formula F I(F ) mim-value 1
interpretation result straightforward: clauses totally ordered
two clauses C < C 0 variables occurring C subset variables occurring
C 0 , implication number subsets clauses
complete assignment satisfies exactly subset number clauses plus 1.
Families CNF formulas small ps-value algorithmic interest,
paper continue part (B) strategy, focus
decompose CNF formula F based concept ps-value. common way decompose
mathematical object recursively partition ground set two parts, giving
binary tree whose root represents ground set whose leaves bijectively mapped
elements ground set. Taking ground set F set containing
clauses variables, decompose F , words binary tree
whose leaves 1-1 correspondence variables clauses. node binary
tree represents subset X variables clauses leaves subtree.
decomposition trees good efficiently solving #SAT MaxSAT? accordance
discussion part (A) answer good decomposition trees
subformulas crossing X X, X defined node
tree, low ps-value. See Figure 2 example. define informal notion
precisely use concept branch decomposition ground set formula
cut function ps-value formulas crossing cut. Branch decompositions
standard notion graph matroid theory, originating work Robertson
Seymour graph minors (Robertson & Seymour, 1991). way arrive
definition ps-width CNF formula F , decompositions F achieve
ps-width. important note formula ps-value exponential
formula size ps-width polynomial, general class formulas low
ps-width much larger class formulas low ps-value.
finish strategy, must carry part (C) show solve #SAT
MaxSAT dynamic programming along branch decomposition formula,
express runtime function ps-width. complicated, dynamic
programming everything defined properly simply becomes exercise
brute-force computation sufficient necessary information, technical
quite tedious. leads following theorem.
Theorem 2. Given formula F n variables clauses, decomposition F
ps-width k, solve #SAT weighted MaxSAT time O(k 3 m(m + n)).
61

fiSther, Telle & Vatshelle

Thus, given decomposition ps-width k polynomially-bounded
number variables n clauses formula, get polynomial-time algorithms.
Let us compare result strongest previous result direction, namely
work Slivovsky Szeider (2013) #SAT. algorithm takes input branch
decomposition vertex set I(F ), ground set F ,
evaluates runtime cut function call index. show cut function
closely related symmetric clique-width scw given decomposition, giving runtime
(n + m)O(scw) . Considering clique-width cw given decomposition runtime
cw
work Slivovsky Szeider (2013) becomes (n + m)O(2 ) since symmetric clique-width
clique-width related essentially tight inequalities 0.5cw scw 2cw (Courcelle,
2004). algorithm thus polynomial-time algorithm given decomposition
constantly bounded scw. result Theorem 2 encompasses this, since Corollary 1
ties ps-width mim-width work Vatshelle (2012) shows mim-width upper
bounded clique-width, see work Rao (2008) symmetric clique-width,
decomposition I(F ) constantly bounded (symmetric) clique-width
polynomially bounded ps-width. way, given decomposition assumed input
work Slivovsky Szeider (2013), algorithm Theorem 2 runtime
O(m3cw s), cw clique-width given decomposition.
work Brault-Baron, Capelli, Mengel (2014), appearing preliminary
presentation results (Sther, Telle, & Vatshelle, 2014), argued framework
behind Theorem 2 gives uniform explanation tractability results #SAT
literature, particular using dynamic programming based structural decompositions
incidence graph. work Brault-Baron et al. (2014) goes beyond this, giving
polynomial-time algorithm, dynamic programming, solve #SAT -acyclic
CNF formulas, exactly formulas whose incidence graphs chordal bipartite.
show formulas bounded ps-width incidence
graphs bounded mim-width. See Figure 1 gives overview results
paper papers.
Using concept mim-width graphs, introduced thesis Vatshelle (2012),
connection ps-value mim-value alluded earlier, show rich class
formulas, including classes unbounded clique-width, polynomially bounded ps-width
thus covered Theorem 2. Firstly, holds classes formulas incidence
graphs represented intersection graphs certain objects, interval graphs
(Belmonte & Vatshelle, 2013). Secondly, holds much larger class bipartite
graphs achieved taking bigraph bipartizations intersection graphs, obtained
imposing bipartition vertex set keeping edges partition classes.
bigraph bipartizations studied previously, particular interval
bigraphs. interval bigraphs contain bipartite permutation graphs, latter
graphs shown unbounded clique-width (Brandstadt & Lozin, 2003). See
Figure 1.
Let us discuss step (1), finding good decomposition. Note Theorem 2 assumes
input formula given along decomposition ps-width k. value k
need optimal, heuristic finding reasonable branch decomposition could
used practice. Computing decompositions optimal ps-width probably doable
62

fiSolving #SAT MaxSAT Dynamic Programming

iden
inc

F

h F
ce grap

ps-width mk

#SAT poly. Paper A.
#SAT poly. Paper B.

chordal
bipartite

#SAT MaxSAT poly.
paper.

-acyclic

ps-width m2
MIM-width k
clique-width k
symmetric
clique-width k/2
modular
treewidth k/2

ps-width
k-trapezoid
bigraph

circular arc
bigraph
interval bigraph
bipartite
permutation

Figure 1: believe, argued work Brault-Baron et al. (2014), dynamic
programming approach working along structural decomposition solve #SAT
(or MaxSAT) polynomial time cannot go beyond green box. Paper
Brault-Baron et al. (2014) Paper B Slivovsky Szeider (2013).
left two dashed lines 4 classes graphs bound k/2 k
structural graph width parameter, 5 classes bipartite graphs.
right -acyclic CNF formulas 3 classes CNF formulas ps-width
varying linear number clauses m, m2 mk . arc
P Q formula F incidence graph I(F ) property P
property Q. Hasse diagram, lack arc transitive closure
means relation provably hold.
polynomial-time, complexity question adressed paper. However,
able efficiently decide CNF formula certain linear structure guaranteeing
low ps-width. combining alternative definition interval bigraphs (Hell & Huang,
2004) fast recognition algorithm (Muller, 1997; Rafiey, 2012) arrive
following. Say CNF formula F interval ordering exists total ordering
variables clauses variable x occurring clause C, x appears
C variable occurs C, C appears x x
occurs clause them.
Theorem 6. Given formula F n variables clauses literals.
time O((m + n)mn) decide F interval ordering (yes iff I(F )
interval bigraph), yes solve #SAT weighted MaxSAT additional
runtime O(min{m2 , 4t }(m + n)m).
Formulas interval ordering precisely whose incidence graphs interval
bigraphs, Theorem 6 encompasses classes formulas whose incidence graphs
unbounded clique-width.
Could parts algorithms interest practical applications? Answering
question beyond scope present paper. However, performed limited
testing, particular formulas linear structure, simple proof concept.
code found online (Sther, Telle, & Vatshelle, 2015). designed
implemented heuristic step (1) finding good decomposition, case linear
63

fiSther, Telle & Vatshelle

one binary tree describing decomposition path attached leaves.
implemented step (2) dynamic programming solving #SAT MaxSAT along
decompositions. run (1) followed (2) compare one
best MaxSAT solvers Max-SAT-2014 event SAT-2014 conference
latest version #SAT solver called sharpSAT (Thurley, 2006). solvers beat
implementation inputs, suprising since code include
techniques beyond algorithm. Nevertheless, able generate classes
CNF formulas interval orderings implementation far better.
lends support belief methods related ps-value warrants research
investigate could useful practice.
paper organized follows. Section 2 give formal definitions ps-value
ps-width CNF formula show central combinatorial lemma linking ps-value
formula size maximum induced matching incidence graph
formula. Section 3 present dynamic programming algorithms given formula
decomposition solves #SAT weighted MaxSAT, proving Theorem 2. Section 4
investigate classes formulas decompositions low ps-width, basically proving
correctness hierarchy presented Figure 1. Section 5 consider formulas
interval ordering prove Theorem 6. Section 6 present results
implementations testing. end Section 7 open problems.

2. Framework
consider propositional formulas Conjunctive Normal Form (CNF). literal
propositional variable negated variable, x x, clause set literals,
formula multiset clauses. formula F , cla(F ) denotes clauses F .
incidence graph formula F bipartite graph I(F ) vertex clause
variable, variable x adjacent clause C occurs. consider
input formulas I(F ) connected, otherwise would solve problems
separate components I(F ). clause C, lit(C) denotes set literals
C var(C) denotes
variables literals lit(C). formula F , var(F )

denotes union Ccla(F ) var(C). set X variables, assignment X
function : X {0, 1}. literal `, define (`) 1 (var(`)) ` negated
variable (` = x variable x) (var) otherwise (` = x variable
x). clause C said satisfied assignment exists least one literal
` lit(C) (`) = 1. clause assignment satisfy said
falsified . notice means empty clause falsified assignments.
formula satisfied assignment satisfies clauses cla(F ).
problem #SAT, given formula F , asks many distinct assignments var(F )
satisfy F . optimization problem weighted MaxSAT, given formula
P F weight
function w : cla(F ) N, asks assignment var(F ) maximizes C w(C)
C cla(F ) satisfied . problem MaxSAT asks maximum number satisfied
clauses achieved, equivalent weighted MaxSAT clauses weight
one. weighted MaxSAT, assume sum weights 2O(cla(F )) ,
thus summation weights time linear cla(F ).
64

fiSolving #SAT MaxSAT Dynamic Programming

set A, elements universe U denote elements U \ A,
universe usually given context.
2.1 Cut Formula
paper, solve MaxSAT #SAT use dynamic programming.
using divide conquer technique solve problem smaller
subformulas original formula F combine solutions smaller
formulas form solution entire formula F . Note however, solutions found
subformula depend interaction subformula remainder
formula. use following notation subformulas.
clause C set X variables, C|X denote clause {` C : var(`) X}.
say C|X clause C induced X. Unless otherwise specified, clauses mentioned
paper set cla(F ) (e.g., write C|X cla(F 0 ), still assume C
cla(F )). formula F subsets C cla(F ) X var(F ), say subformula
FC,X F induced C X formula consisting clauses {Ci |X : Ci C}.
is, FC,X formula get removing clauses C followed removing
literal variable X. set C clauses, denote C|X set {C|X : C C}.
clause, assignment set X variables, say assignment
induced X 0 X assignment |X 0 domain restricted X 0 .
formula F sets C cla(F ), X var(F ), = C X, call cut F
note breaks F four subformulas FC,X , FC,X , FC,X , FC,X . See Figure 2.
One important fact may observe definition clause C F satisfied
assignment var(F ), C (induced X X) satisfied
least one formulas cut F .
2.2 Projection Satisfiable Sets ps-value Formula
formula F assignment variables var(F ), denote sat(F, )
inclusion maximal set C cla(F ) clause C satisfied .
set C cla(F ) sat(F, ) = C variables var(F ), C
known projection (Kaski, Koivisto, & Nederlof, 2012; Slivovsky & Szeider, 2013)
say C projection satisfiable F . denote PS(F ) family projection
satisfiable sets F . is,
PS(F ) = {sat(F, ) : assignment entire set var(F )}.
cardinality set, |PS(F )|, referred ps-value F .
get grasp structure formulas low ps-value consider induced
matchings incidence graph formula. incidence graph formula F
bipartite graph I(F ) vertex clause variable, variable x adjacent
clause C occurs. induced matching graph subset edges
property edge graph incident one edge .
words, 3 vertices a, b, c, ab edge bc edge
exist edge cd . number edges called size induced matching.
following result provides upper bound ps-value formula terms
maximum size induced matching incidence graph.
65

fiSther, Telle & Vatshelle

Lemma 1. Let F CNF formula clause containing literals,
let k maximum size induced matching I(F ). |PS(F )|
min{|cla(F )|k + 1, 2tk }.
Proof. first argue |PS(F )| |cla(F )|k + 1. Let C PS(F ) Cf = cla(F ) \ C.
Thus, exists complete assignment clauses satisfied
Cf = cla(F ) \ sat(F, ). Since every variable var(F ) appears clause F
means |var(Cf ) unique assignment variables var(Cf ) satisfy
0
0
clause Cf . Let Cf Cf inclusion minimal set var(Cf ) = var(Cf ),
hence |var(Cf ) unique assignment variables var(Cf ) satisfy
0
0
clause Cf . upper bound number different minimal Cf ,
0
C PS(F ), give upper bound |PS(F )|. every C Cf variable vC
0
0
appearing C clause Cf , otherwise Cf would minimal. Note
induced matching I(F ) containing edges vC , C. assumption,
0
induced matching k edges hence |Cf | k. easy show
induction k |cla(F )|k + 1 sets k clauses lemma
follows.
argue |PS(F )| 2tk . maximum induced matching size k
set C k clauses var(C) = var(F ). clause C C |var(C)| t,
|var(F )| = |var(C)| tk. 2|var(F )| assignments F ,
PS-value F upper bounded 2tk .
2.3 ps-width Formula
define branch decomposition formula F pair (T, ) rooted
binary tree bijective function leaves clauses variables
F . non-leaf nodes (also referred internal nodes) induce path,
say (T, ) linear branch decomposition. non-leaf node v , denote
(v) set {(l) : l leaf subtree rooted v}. Based this, say
decomposition (T, ) formula F induces certain cuts F , namely cuts defined (v)
node v .
formula F branch decomposition (T, ), node v , Fv denote
formula induced clauses cla(F ) \ (v) variables (v), Fv
denote formula complement sets; i.e. clauses (v) variables
var(F ) \ (v). words, (v) = C X C cla(F ) X var(F )
Fv = FC,X Fv = FC,X . simplify notation, node v branch
decomposition set C clauses denote C|v set C|var(Fv ) . define ps-value
cut (v)
ps((v)) = max{|P S(Fv )|, |P S(Fv )|}
define ps-width branch decomposition
psw(T, ) = max{ps((v)) : v node }
define ps-width formula F
psw(F ) = min{psw(T, ) : (T, ) branch decomposition F }
66

fiSolving #SAT MaxSAT Dynamic Programming

v
x4
x3 c4 x5 c2
x1

x2

c1

C
c1 = {x1 , x2 }
c3 = {x2 , x4 , x5 }

c3
FC,X = Fv

X

FC,X

FC,X

x1 x2

x3 x4
x5

FC,X = Fv

c2 = {x1 , x2 , x3 }
c4 = {x2 , x3 , x5 }

X

C

Figure 2: top branch decomposition formula F var(F ) = {x1 , x2 , x3 , x4 , x5 }
4 clauses cla(F ) = {c1 , c2 , c3 , c4 } given boxes. node
v tree defines cut (v) = C X C = {c1 , c3 } X =
{x1 , x2 }. 4 subformulas defined cut: FC,X , FC,X , FC,X , FC,X .
example, FC,X = {{x1 , x2 }, {x2 }} FC,X = {, {x4 , x5 }}.
Fv = FC,X Fv = FC,X projection satisfiable sets clauses PS(Fv ) =
{{c2 |v }, {c4 |v }, {c2 |v , c4 |v }} PS(Fv ) = {, {c3 |v }} ps-value cut
ps((v)) = max{|P S(Fv )|, |P S(Fv )|} = 3.

Note ps-value cut symmetric function. is, ps-value cut
equals ps-value cut S. See Figure 2 example.

3. Dynamic Programming MaxSAT #SAT
Given branch decomposition (T, ) CNF formula F n variables clauses
total size s, give algorithms solve MaxSAT #SAT F time
O(psw(T, )3 m(m + n)). algorithms strongly inspired work Slivovsky
Szeider (2013), order achieve runtime polynomial ps-width, solve
MAXSAT, must make crucial changes. particular, must index dynamic
progranming tables PS-sets rather shapes used work Slivovsky
Szeider (2013).
Let us discuss special terminology used section. dynamic
programming section, combine partial solutions subformulas solutions
input formula F . improve readability introduce notation P 0 sat0
allows us refer directly clauses F , working subformulas.
67

fiSther, Telle & Vatshelle

Thus, formula F branch decomposition (T, ), node v , induced
subformula Fv F , PS0 (Fv ) denote subsets clauses C cla(F ) \ (v)
PS(Fv ) = C|var(Fv ) . Similarly, assignment var(Fv ), sat0 (Fv , )
denote set clauses C cla(F ) \ (v) sat(Fv , ) = C|var(Fv ) . Note
|PS0 (Fv )| = |PS(Fv )| |sat0 (Fv , )| = |sat(Fv , )|. take liberty call
sets projection satisfiable refer PS-sets text, clear
context mean clauses cla(F ) cla(Fv ).
Let us discuss implementation details. regard PS-sets boolean vectors
length |cla(F )|, assume identify clauses variables integer numbers. So,
checking clause PS-set done constant time, checking two PS-sets
equal done O(|cla(F )|) time. manage PS-sets, use binary trie
datastructure (Fredkin, 1960). add retrieve PS-set trie
O(|cla(F )|) time. Trying add PS-set trie already containing equivalent PS-set
alter content trie, tries contain distinct PS-sets.
retrieval element trie takes O(|cla(F )|) time, assigning distinct integer
PS-set time added trie, O(|cla(F )|)-time mapping
PS-sets distinct integers. used implicitly algorithms
say index PS-sets; implementing algorithm instead index
corresponding integer PS-set mapped to.
pre-processing step need following which, node v computes
sets projection satisfiable subsets clauses PS0 (Fv ) PS0 (Fv ) two crossing
subformulas Fv Fv .
Theorem 1. Given CNF formula F branch decomposition (T, ) ps-width k,
time O(k 2 m(m + n)) compute sets PS0 (Fv ) PS0 (Fv ) v .

Proof. notice node v children c1 c2 , express PS0 (Fv )


C1 PS0 (Fc1 ),
0
PS (Fv ) = (C1 C2 ) cla(Fv ) :
.
C2 PS0 (Fc2 )

Similarly, sibling parent p v , set PS0 (Fv ) expressed


Cp PS0 (Fp ),
0
PS (Fv ) = (Cp Cs ) cla(Fv ) :
.
Cs PS0 (Fs )
transforming recursive expressions dynamic programming algorithm,
done Procedure 1 Procedure 2 below, able calculate desired sets
long compute sets base cases PS0 (Fl ) l leaf , PS0 (Fr )
root r . However, formulas contain one variable, thus
easily construct set projection satisfiable clauses linear amount time
formulas. rest formulas, construct formulas using Procedure 1
Procedure 2. twice many nodes clauses
variables F , procedures run O(|cla(F )| + |var(F )|) times. run
algorithms, iterate k 2 pairs projection satisfiable sets,
constant number set operations might take O(|cla(F )|) time each. results
total runtime O(k 2 |cla(F )|(|cla(F )| + |var(F )|)) = O(k 2 m(m + n)) nodes
combined.
68

fiSolving #SAT MaxSAT Dynamic Programming

Procedure 1: Generating PS0 (Fv )
input: PS0 (Fc1 ) PS0 (Fc2 ) children c1 c2 v
branch decomposition
output: PS0 (Fv )
L empty trie projection satisfiable clause-sets
(C1 , C2 ) PS0 (Fc1 ) PS0 (Fc2 )
add (C1 C2 ) cla(Fv ) L
return L
Procedure 2: Generating PS0 (Fv )
input: PS0 (Fs ) PS0 (Fp ) sibling parent p v
branch decomposition
output: PS0 (Fv )
L empty trie projection satisfiable clause-sets
(Cs , Cp ) PS0 (Fs ) PS0 (Fp )
add (Cs Cp ) cla(Fv ) L
return L
move dynamic programming proper. first give algorithm
MaxSAT briefly describe changes necessary solving weighted MaxSAT
#SAT.
algorithm uses technique expectation introduced work Bui-Xuan,
Telle, Vatshelle (2010, 2011). partial solutions might good combined
certain partial solutions, bad combined others. technique
expectation categorize partial solutions interact, optimize selection
partial solutions based expectation interaction occurs. dynamic
programming algorithm MaxSAT, apply technique making expectations
cut regarding set clauses satisfied variables opposide side
cut.
node v decomposition F PS-sets C PS0 (Fv ) C 0 PS0 (Fv ),
say assignment var(F ) meets expectation C C 0 sat0 (Fv , |v ) = C
sat0 (Fv , |v ) = C 0 . node v branch decomposition, algorithm uses
table Tabv pair (C, C 0 ) PS0 (Fv ) PS0 (Fv ) stores Tabv (C, C 0 ) maximum
number clauses (v) satisfied, assignments meeting expectation
C C 0 . variables var(F ) \ (v) satisfy exactly C 0 , assignment
meets expectation, equivalent formulation content Tabv (C, C 0 )
must satisfy following constraint:
assignments var(F ) (v) sat0 (Fv , ) = C ,



Tabv (C, C 0 ) = max sat0 (F, 0 ) (v) C 0

(1)



bottom-up dynamic programming along tree compute tables
node . leaf l , generating Tabl done easily linear time since
formula Fv contains one variable. internal node v , children c1 , c2 ,
69

fiSther, Telle & Vatshelle

compute Tabv algorithm described Procedure 3. 3 tables involved
update, one child one parent. pair entries, one child
table, may lead update entry parent table. table entry indexed
pair, thus 6 indices involved single potential update. trick first introduced
work Bui-Xuan et al. (2011) allows us loop triples indices
triple compute remaining 3 indices forming 6-tuple involved update, thereby
reducing runtime.
Procedure 3: Computing Tabv inner node v children c1 , c2
input: Tabc1 , Tabc2
output: Tabv
1. initialize Tabv : PS0 (Fv ) PS0 (Fv ) {1}
2. (Cc1 , Cc2 , Cv0 ) PS0 (Fc1 ) PS0 (Fc2 ) PS0 (Fv )
3.
Cc0 1 (Cc2 Cv0 ) (c1 )
4.
Cc0 2 (Cc1 Cv0 ) (c2 )
5.
Cv (Cc1 Cc2 ) \ (v)
6.
Tabc1 (Cc1 , Cc0 1 ) + Tabc2 (Cc2 , Cc0 2 )
7.
Tabv (Cv , Cv0 ) < Tabv (Cv , Cv0 )
8. return Tabv
Lemma 2. CNF formula F clauses inner node v, branch decomposition (T, ) ps-width k, Procedure 3 computes Tabv satisfying Constraint (1) time
O(k 3 m).
Proof. assume Tabc1 Tabc2 satisfy Constraint (1). Procedure 3 loops triples
PS0 (Fc1 ) PS0 (Fc2 ) PS0 (Fv ). definition ps-width (T, )
k 3 triples. operation inside iteration loop take O(m) time
constant number operations. Thus runtime O(k 3 m).
show correctness output, let us look bit workings
Procedure 3. assignment var(F ), cut, assignment meet
expectation single pair PS-sets. Let (X1 , X10 ), (X2 , X20 ) (Xv , Xv0 ) pairs
assignment meets expectation respect cuts induced c1 , c2 , v,
respectively. notice
Xv = sat0 (Fv , |v )

= sat0 (Fv , |c1 ] |c2 )

= sat0 (Fv , |c1 ) sat0 (Fv , |c2 )

= (sat0 (Fc1 , |c1 ) \ (v)) (sat0 (Fc2 , |c2 ) \ (v))

(2)

= (X1 \ (v)) (X2 \ (v))
= (X1 X2 ) \ (v).

seen Figure 3. symmetry, find similar values X10 X20 ;
namely X10 = (X2 Xv0 ) (c1 ) X20 = (X1 Xv0 ) (c2 ). So, latter three sets
implicit based three former sets respect cuts induced v, c1
c2 . therefore, convenience proof, say assignment meets
70

fiSolving #SAT MaxSAT Dynamic Programming

= X1 = sat (Fc1 , |c1 )

clauses cla(F ) \ (v)

= X2 = sat (Fc2 , |c2 )
= Xv = sat (Fv , |v )

clauses (c2 )

clauses (c1 )

Figure 3: shown chain equalities (2) proof Lemma 2, clauses
sat0 (Fv , |v ) precisely clauses (sat0 (Fc1 , |c1 ) sat0 (Fc2 , |c2 )) \ (v).
expectation triple (C1 , C2 , C 0 ) PS-sets, meets expectation implicit
three pairs respective cuts. notice choice triples
PS-sets (Cc1 , Cc2 , Cv0 ) Procedure 3 computes implicit three sets names
Cc0 1 , Cc0 2 Cv accordingly.
show pairs (C, C 0 ) PS0 (Fv ) PS0 (Fv ) value Tabv (C, C 0 )
correct. Let 0 assignment var(F ) satisfies maximum number
clauses, meeting expectation C C 0 . Thus, value Tabv (C, C 0 ) correct
stores exactly number clauses (v) 0 satisfies.
Let (C1 , C10 ) (C2 , C20 ) pairs PS-sets 0 meet expectation
cut ((c1 ), (c1 )) ((c2 ), (c2 )), respectively. 0 meets expectations, value
Tabc1 (C1 , C10 ) Tabc2 (C2 , C20 ) must least large number clauses 0
satisfies (c1 ) (c2 ), respectively. Thus, number clauses 0 satisfies
(c1 ) (c2 ) large sum two entries. Since Procedure 3,
iteration Cv0 = C 0 , Cc1 = C1 Cc2 = C2 , ensures Tabv (C, C 0 ) least
sum Tabc1 (C1 , C10 ) Tabc2 (C2 , C20 ), know Tabv (C, C 0 ) least large
correct value.
assume contradiction value cell Tabv (C, C 0 ) large.
means iteration Procedure 3 assigned value Tabc1 (Cc1 , Cc0 1 ) +
Tabc2 (Cc2 , Cc0 2 ) sum large. Let 1 2 assignments var(F )
meeting expectation Cc1 Cc0 1 meeting expectation Cc2 , Cc0 2 , respectively,
number clauses (c1 ) (c2 ), respectively, equals according table
entries Tabc1 Tabc2 . take assignment x = 1 |c1 ] 2 |c2 ] 0 |v ,
assignment meets expectation C C 0 , satisfies clauses
(v) 0 , contradicting choice 0 . Tabv (C, C 0 ) neither smaller larger
number clauses (v) 0 satisfies, exactly same.
Theorem 2. Given formula F n variables clauses, branch decomposition
(T, ) F ps-width k, solve MaxSAT, #SAT, weighted MaxSAT time
O(k 3 m(m + n)).
Proof. solve MaxSAT, first compute Tabr root node r . requires
first compute PS0 (Fv ) PS0 (Fv ) nodes v , then, bottom
manner, compute Tabv O(m + n) nodes . former part
71

fiSther, Telle & Vatshelle

O(k 2 m(m + n)) time Theorem 1, latter part O(k 3 m(m + n)) time
Lemma 2.
root r (r) = var(F ) cla(F ). Thus Fr = Fr
variables, P S(Fr ) P S(Fr ) contains (, ). assignments var(F )
meet expectation cut ((r), (r)), cla(F ) (r) = cla(F ),
Constraint (1) value Tabr (, ) maximal number clauses F assignment
var(F ) satisfies. hence, number solution MaxSAT.
weight function w : cla(F ) N, redefining Constraint (1) Tabv maximize
w(sat0 (F, ) (v)) instead |sat0 (F, ))(v)|, able solve general
problem weighted MaxSAT way.
problem #SAT, care assignments satisfying clauses
F , want decide number distinct assignments so. requires
alterations. Firstly, alter definition contents Tabv (C, C 0 ) Constraint
(1) number assignments var(F ) (v) sat0 (Fv , ) = C
clauses (v) either C 0 satisfied . Secondly, computing Tabl
leaves l , set entries Tabl either zero, one, two, according
definition. Thirdly, alter algorithm compute Tabv (Procedure 3) inner nodes.
initialize Tabv (C, C 0 ) zero start algorithm, substitute lines 6
7 Procedure 3 following line increases table value product
table values children
Tabv (Cv , Cv ) Tabv (Cv , Cv ) + Tabc1 (Cc1 , Cc1 ) Tabc2 (Cc2 , Cc2 )
satisfy new constraint Tabv internal nodes v . value Tabr (, )
root r exactly number distinct assignments satisfying clauses
F.
bottleneck giving cubic factor k 3 runtime Theorem 2 number
triples PS0 (Fv ) PS0 (Fc1 ) PS0 (Fc2 ) node v children c1 c2 . (T, )
linear branch decomposition, always case either c1 c2 leaf .
case either |PS0 (Fc1 )| |PS0 (Fc2 )| constant. Therefore, linear branch decompositions
PS0 (Fv ) PS0 (Fc1 ) PS0 (Fc2 ) contain O(k 2 ) triples. Thus reduce
runtime algorithm factor k.
Theorem 3. Given formula F n variables clauses, linear branch
decomposition (T, ) F ps-width k, solve #SAT, MaxSAT, weighted MaxSAT
time O(k 2 m(m + n)).

4. CNF Formulas Polynomial ps-width
section investigate classes CNF formulas decompositions ps-width
polynomially bounded total size formula. particular, show
holds whenever incidence graph formula constant mim-width (maximum
induced matching-width, introduced Vatshelle, 2012). show large class
bipartite graphs, using call bigraph bipartizations, constant mim-width.
72

fiSolving #SAT MaxSAT Dynamic Programming

order lift upper bound Lemma 1 ps-value F , i.e |PS(F )|,
ps-width F , use mim-width incidence graph I(F ), defined using branch
decompositions graphs. branch decomposition formula F , defined Section
2, seen branch decomposition incidence graph I(F ). Nevertheless,
completeness, formally define branch decompositions graphs mim-width.
branch decomposition graph G pair (T, ) rooted binary tree
bijection leaf set vertex set G. node w
let subset V (G) bijection leaves subtree rooted w
denoted Vw . say decomposition defines cut (Vw , Vw ). mim-value cut
(Vw , Vw ) size maximum induced matching G[Vw , Vw ]. mim-width (T, )
maximum mim-value cuts (Vw , Vw ) defined node w . mim-width
graph G, denoted mimw(G), minimum mim-width branch decompositions
(T, ) G. linear branch decomposition branch decomposition inner
nodes underlying tree induces path.
Since decomposition I(F ) seen decomposition F , immediately
get Lemma 1 following corollary.
Corollary 1. CNF formula F clauses, clause containing
literals, ps-width F min{mk + 1, 2tk } k = mimw(I(F )).
Many classes graphs intersection models, meaning represented
intersection graphs certain objects, i.e. vertex associated object
two vertices adjacent iff objects intersect. objects used define intersection
graphs usually consist geometrical objects lines, circles polygons. Many well
known classes intersection graphs constant mim-width, following
lists subset classes proven bounds (Belmonte & Vatshelle, 2013;
Vatshelle, 2012).
Theorem 4. (Belmonte & Vatshelle, 2013; Vatshelle, 2012) Let G graph. G a:
interval graph mimw(G) 1.
circular arc graph mimw(G) 2.
k-trapezoid graph mimw(G) k.
Moreover exist linear decompositions satisfying bound, found polynomial time (for k-trapezoid assume intersection model given).
Let us briefly mention definition graph classes. graph interval graph
intersection model consisting intervals real line. graph circular arc
graph intersection model consisting arcs circle. build k-trapezoid
start k parallel line segments (s1 , e1 ), (s2 , e2 ), ..., (sk , ek ) add two non-intersecting
paths e joining si si+1 ei ei+1 respectively straight lines
{1, ..., k 1}. polygon defined e two line segments (s1 , e1 ), (sk , ek )
forms k-trapezoid. graph k-trapezoid graph intersection model consisting
k-trapezoids. See work Brandstadt, Le, Spinrad (1999) information
graph classes containment relations.
Combining Corollary 1 Theorem 4 get following
Corollary 2. Let F CNF formula containing clauses maximum clause-size t.
I(F ) a:
73

fiSther, Telle & Vatshelle

interval graph psw(F ) min{m + 1, 2t }.
circular arc graph psw(F ) min{m2 + 1, 4t }.
k-trapezoid graph psw(F ) min{mk + 1, 2tk }.
Moreover exist linear decompositions satisfying bound, found polynomial time (for k-trapezoid assume intersection model given).
incidence graphs formulas bipartite graphs, case
majority graphs above-mentioned graph classes. following show
extend results Corollary 2 large classes bipartite graphs. graph G
subset vertices V (G) bipartite graph G[A, A] subgraph G containing
edges G exactly one endpoint A. graph G V (G) call G[A, A]
bigraph bipartization G, note G bigraph bipartization subset
vertices. graph class X define class X bigraphs bipartite graphs H
exists G X H isomorphic bigraph bipartization G.
example, bipartite graph H interval bigraph interval graph G
V (G) H isomorphic G[A, A].
following result allow us lift results Corollary 2 given graphs
bigraph bipartizations graphs.
Theorem 5. Assume given CNF formula F clauses maximum
clause-size t, graph G, subset V (G), (T, G ) (linear) branch decomposition
G mim-width k. I(F ) connected isomorphic G[A, A] (thus I(F ) bigraph
bipartization G) linear time produce (linear) branch decomposition (T, F )
F ps-width min{mk + 1, 2tk }
Proof. Since variable clause F corresponding node I(F ), node
I(F ) corresponding node G, defining F function mapping leaf
l variable clause F corresponding node G (l), get (T, F )
branch decomposition F . Consider cut (B, B) induced node (T, F ). Note
mim-value G[B, B] k. I(F ) connected means
either corresponding set variables F . Assume wlog former. Thus
C = B cla(F ) clauses B, C = cla(F ) \ C X = B var(F )
variables B, X = var(F ) \ X. mim-values G[C, X] G[C, X]
k, since induced subgraphs G[B, B], taking induced subgraphs
cannot increase size maximum induced matching. Hence Lemma 1,
|PS(FC,X )| |cla(F )|k + 1, likewise |PS(FC,X )| |cla(F )|k + 1,
maximum two ps-value cut. Since ps-width decomposition
maximum ps-value cut theorem follows.
Combining Theorems 5 4 immediately get following.
Corollary 3. Let F CNF formula containing clauses maximum clause-size t.
I(F ) a:
interval bigraph psw(F ) min{m + 1, 2t }.
circular arc bigraph psw(F ) min{m2 + 1, 4t }.
k-trapezoid bigraph psw(F ) min{mk + 1, 2tk }.
Moreover exist linear decompositions satisfying bound.
74

fiSolving #SAT MaxSAT Dynamic Programming

next section address question finding linear decompositions
polynomial time. succeed case interval bigraphs, circular arc bigraphs
k-trapezoid bigraphs must leave open problem.

5. Interval Bigraphs Formulas Interval Orders
section show formulas whose incidence graph interval bigraph
polynomial time find linear branch decompositions small ps-width. Let
us recall definition interval ordering. CNF formula F interval ordering
exists linear ordering variables clauses variable x occurring
clause C, x appears C variable occurs C,
C appears x x occurs clause them. See Figure 4
example.
Order:
x1 c 1 x2 x3 c 2 c 3 x4 x5

Clauses:

Bipartized interval rep.

Incidence graph

x1
c1
x2
x3
c2
c3
x4
x5

c1 = {x1 , x2 }
c2 = {x2 , x3 , x5 }
c3 = {x3 , x4 , x5 }

c1

x1

c2 c3

x2 x3

x4 x5

Figure 4: CNF formula interval ordering. incidence graph interval
bigraph, since isomorphic bigraph bipartization, defined blue
intervals, interval graph intersection model left.
work Hell Huang (2004) follows formula F interval ordering
I(F ) interval bigraph.
Theorem 6. Given CNF formula F n variables clauses
literals. time O((m + n)mn) decide F interval ordering (yes iff I(F )
interval bigraph), yes solve #SAT weighted MaxSAT additional
runtime O(min{m2 , 4t }(m + n)m).
Proof. Using characterization work Hell Huang (2004) algorithm
Rafiey (2012) time O((m + n)mn) decide F interval ordering
yes, find it. interval ordering build interval graph G I(F )
bigraph bipartization G, construct linear branch decomposition G
mim-width 1 (Belmonte & Vatshelle, 2013). linear branch decomposition
75

fiSther, Telle & Vatshelle

get Theorem 5 construct another linear branch decomposition F
ps-width O(m). run algorithm Theorem 3.

6. Experimental Results
present simple experimental results, intended proof concept. belief
ideas behind algorithms, notion ps-value, useful
practice, require thorough investigation confirm belief. results
indicate worst-case runtime bounds dynamic programming, Theorems 2
3, probably higher would commonly seen practice.
past decade, SAT solvers become powerful, currently able
handle large practical instances. Techniques SAT solvers
applied develop relatively powerful MaxSAT #SAT solvers (Biere, Heule, & van
Maaren, 2009). experiments compare implementations algorithms
state-of-the-art MaxSAT #SAT solvers. enhance implementations
techniques, even simple pre-processing, vast majority instances
implementations fall far behind comparison. However, focusing formulas
certain linear order implementations compare favorably.
explained Section 1, two steps involved: (1) find good decomposition
input CNF formula F , (2) perform DP (dynamic programming) along
decomposition. Let us start describing simple heuristic step (1). takes
input bipartite graph I(F ) vertex set cla(F ) var(F ), outputs linear
order vertex set. heuristic GreedyOrder greedy algorithm
increasing values chooses (i) vertex highest number already
chosen neighbors, among choosing one fewest non-chosen neighbors.
defines linear branch decomposition (T, ) CNF formula F , non-leaf nodes
binary tree inducing path, rooted one end path,
mapping ith leaf encountered breadth-first search starting root
clause variable (i), 1 |cla(F ) var(F )|.

Algorithm GreedyOrder
input: G = (V, E), (bipartite) graph
output: , linear ordering V
L = , R = V , = 1
v V set Ldegree(v) = 0
R empty
choose v: vertices R max Ldegree take one smallest degree
set (i) = v, increment i, add v L remove v R
w R vw E increment Ldegree(w)

76

fiSolving #SAT MaxSAT Dynamic Programming

implementations found online (Sther, Telle, & Vatshelle, 2015).
implemented GreedyOrder Java, together straight-forward implementation
DP algorithm Theorem 3.
Given CNF formula, allows us solve MaxSAT #SAT first running
GreedyOrder DP. compare implementation best solvers could
find online, respectively CCLS-to-akmaxsat (Luo, Cai, Wu, Jie, & Su, 2014)
among best solvers Ninth Max-SAT Evaluation (2014), latest version
#SAT solver called sharpSAT (Thurley, n.d., 2006). solvers handily beat
implementation inputs. therefore generated CNF formulas
interval orderings, Theorem 6, check least instances better.
Note step (1) implemented polynomial-time algorithm recognizing
formulas interval orders, relying instead GreedyOrder heuristic.
6.1 Generation Instances
presenting results, let us describe generation set instances,
three types. start type 1. generation formulas based
definition interval orderings given interval bigraph definition, see e.g. left side
Figure 4. generate formula type 1 n variables clauses, generate
n + intervals real line iterating points 1 2(n + m) left
right endpoints intervals:
step i, check 4 cases legal (e.g. 3 legal exists
live variable, i.e. left endpoint < right endpoint) randomly make
one legal choices:
1. start interval new variable left endpoint
2. start interval new clause left endpoint
3. end interval randomly chosen live variable right endpoint
4. end interval randomly chosen live clause right endpoint
Towards end process boundary conditions enforced reach exactly
clauses, n expected slightly smaller m. clause interval randomly
choose variable overlapping interval either positive negative
clause. resulting CNF formula interval ordering given rightmost
endpoints intervals. hide ordering clauses variables randomly permuted
make final CNF formula.
formulas type 2 generated similar fashion type 1, except
guarantee clauses size t, Lemma 1 could big help.
change case 4 instead choice becomes enforced live
clause step accumulated exactly overlapping variable intervals. let
clause interval represent 4 clauses variable set randomly chosen
literals, aim increasing probability instance satisfiable.
formulas type 3 CNF-representation conjunction XOR functions
XOR fixed number literals variables XOR functions
77

fiSther, Telle & Vatshelle

overlap way incidence graph bipartization circular arc
graph.
formula type 3 generated three input parameters n, t, s. n variables
represented successive points 1 n circle. first XOR function interval
1 thus containing variables points 1 t, second interval + 1 + t,
general ith interval + 1 + t, appropriate modulo addition
boundary condition end ensure n/s XOR functions. Variables chosen
randomly appear positive negative XOR. XOR transformed
standard way CNF formula 2t1 clauses give us resulting CNF formula
n/s 2t1 clauses. Again, variables clauses randomly permuted hide
ordering giving circular arc bigraph representation.
Note resulting formulas quite simple structure, state-ofthe-art SAT solver, lingeling (Biere, 2014), handles generated instances within
seconds.
6.2 Results
ready present results. ran solvers Dell Optiplex 780
running Ubuntu 12.04 64-Bit. machine 8GB memory Intel Core 2 Quad
Q9650 processor OpenJDK java 6 (IcedTea6 1.13.5).
instances type 1 GreedyOrder heuristic fails terribly becomes huge
bottleneck. greedy choice based degrees vertices I(F ) simple. However,
given correct interval order solver(s) performed better.
Instances type 2 generated similar type 1 clauses small size,
Lemma 1 could help. case number clauses approximately

Runtime seconds

600

400

CCLS
sharpSAT
MaxSAT
#SAT
(practically equal)

200

0
0

1000
2000
Number variables

3000

Figure 5: Runtimes instances type 2. MaxSAT solver clearly faster
CCLS akmaxsat. vertical axis represents time seconds. Runs taking
600 seconds stopped completion drawn
dotted line.

78

fiSolving #SAT MaxSAT Dynamic Programming

four times number variables, consequence great number instances
satisfiable, making work #SAT-solvers easier MaxSAT
solvers. generated instances type 2 solved within seconds sharpSAT, see
Figure 5. size instances grow, see clear tendency runtimes
CCLS akmaxsat increase much rapidly solvers. runtimes
two solvers almost identical. GreedyOrder heuristic instances seems
produce decompositions/orders low PS-width.
type 3 instances shown Figure 6 generated k = 5 = 3.
instances satisfiable, may explain CCLS akmaxsat fast. Choosing
k = 3 = 2 satisfiable instances CCLS akmaxsat would
often spend 600 seconds time out. size instances grow,
see clear tendency runtimes sharpSAT increase much rapidly
solvers. runtimes two solvers almost identical.

Runtime seconds

600

400

CCLS
sharpSAT
MaxSAT
#SAT
(practically equal)

200

0
60

80
100
120
Number variables

140

Figure 6: Runtimes instances type 3. #SAT solver clearly faster
sharpSAT. vertical axis represents time seconds. Runs taking
600 seconds stopped completion drawn dotted line.

7. Conclusion
paper proposed structural parameter CNF formulas, called ps-width
projection-satisfiable-width. showed weighted MaxSAT #SAT
solved polynomial time given decomposition formula polynomially bounded
ps-width. Using concept interval bigraphs showed polynomial time algorithm
actually finds decomposition, formulas interval ordering. Could
one devise algorithm larger class circular arc bigraphs, maybe
even even larger class k-trapezoid bigraphs? words, problem
recognizing bipartite input graph circular arc bigraph, k-trapezoid bigraph,
polynomial-time solvable?
79

fiSther, Telle & Vatshelle

could practical interest design heuristic algorithm given formula finds
decomposition relatively low ps-width, done boolean-width (Hvidevold,
Sharmin, Telle, & Vatshelle, 2011). One could check benchmarks covering real-world
SAT instances low ps-width, perform study correlation low
ps-width practical hardness MaxSAT #SAT solvers, done
treewidth SAT solvers (Mateescu, 2011). presented simple experimental
results, require thorough investigation check ideas algorithms
could useful practice. Finally, hope essential combinatorial result enabling
improvements paper, Lemma 1, may uses well.

References
Bacchus, F., Dalmao, S., & Pitassi, T. (2003). Algorithms complexity results for#SAT
bayesian inference. Foundations computer science, 2003. proceedings. 44th
annual ieee symposium (pp. 340351).
Belmonte, R., & Vatshelle, M. (2013). Graph classes structured neighborhoods
algorithmic applications. Theor. Comput. Sci., 511 , 54-65.
Biere, A. (2014). Yet another local search solver lingeling friends entering SAT
competition 2014. SAT Competition 2014 , 39.
Biere, A., Heule, M., & van Maaren, H. (2009). Handbook satisfiability. (Vol. 185,
chap. 20). IOS Press.
Brandstadt, A., Le, V. B., & Spinrad, J. P. (1999). Graph classes: survey (Vol. 3).
Philadelphia: SIAM Society Industrial Applied Mathematics.
Brandstadt, A., & Lozin, V. V. (2003). linear structure clique-width bipartite
permutation graphs. Ars Comb., 67 .
Brault-Baron, J., Capelli, F., & Mengel, S. (2014). Understanding model counting
-acyclic CNF-formulas. CoRR, abs/1405.6043 . Retrieved http://arxiv.org/
abs/1405.6043
Bui-Xuan, B.-M., Telle, J. A., & Vatshelle, M. (2010). H-join decomposable graphs
algorithms runtime single exponential rankwidth. Discrete Applied Mathematics,
158 (7), 809-819.
Bui-Xuan, B.-M., Telle, J. A., & Vatshelle, M. (2011). Boolean-width graphs. Theoretical
Computer Science, 412 (39), 51875204.
Courcelle, B. (2004). Clique-width countable graphs: compactness property. Discrete
Mathematics, 276 (1-3), 127148. Retrieved http://dx.doi.org/10.1016/S0012
-365X(03)00303-0 doi: 10.1016/S0012-365X(03)00303-0
Darwiche, A. (2001). Recursive conditioning. Artificial Intelligence, 126 (1), 541.
Fischer, E., Makowsky, J. A., & Ravve, E. V. (2008). Counting truth assignments
formulas bounded tree-width clique-width. Discrete Applied Mathematics, 156 (4),
511-529.
80

fiSolving #SAT MaxSAT Dynamic Programming

Fredkin, E. (1960). Trie memory. Communications ACM , 3 (9), 490499.
Ganian, R., Hlineny, P., & Obdrzalek, J. (2013). Better algorithms satisfiability problems
formulas bounded rank-width. Fundam. Inform., 123 (1), 59-76.
Garey, M. R., & Johnson, D. S. (1979). Computers intractability: guide theory
NP-completeness. W. H. Freeman.
Hell, P., & Huang, J. (2004). Interval bigraphs circular arc graphs. Journal Graph
Theory, 46 (4), 313-327.
Hvidevold, E. M., Sharmin, S., Telle, J. A., & Vatshelle, M. (2011). Finding good
decompositions dynamic programming dense graphs. D. Marx & P. Rossmanith
(Eds.), Ipec (Vol. 7112, p. 219-231). Springer.
Jaumard, B., & Simeone, B. (1987). complexity maximum satisfiability
problem Horn formulas. Inf. Process. Lett., 26 (1), 1-4.
Kaski, P., Koivisto, M., & Nederlof, J. (2012). Homomorphic hashing sparse coefficient
extraction. Proceedings 7th international conference parameterized
exact computation (pp. 147158).
Luo, C., Cai, S., Wu, W., Jie, Z., & Su, K. (2014). CCLS: efficient local search
algorithm weighted maximum satisfiability. IEEE Transactions Computers. doi:
10.1109/TC.2014.2346195
Mateescu, R. (2011). Treewidth industrial SAT benchmarks (Tech. Rep.). Tech. rep.
Cambridge, UK: Microsoft Research. Retrieved http://research.microsoft
.com/pubs/145390/MSR-TR-2011-22.pdf
Muller, H. (1997). Recognizing interval digraphs interval bigraphs polynomial time.
Discrete Applied Mathematics, 78 (1-3), 189-205.
Ninth Max-SAT Evaluation. (2014). Retrieved http://www.maxsat.udl.cat/14/
(accessed 16-January-2015)
Paulusma, D., Slivovsky, F., & Szeider, S. (2013). Model counting CNF formulas
bounded modular treewidth. N. Portier & T. Wilke (Eds.), Stacs (Vol. 20, p. 55-66).
Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik.
Rafiey, A. (2012).
abs/1211.2662 .

Recognizing interval bigraphs forbidden patterns.

CoRR,

Raman, V., Ravikumar, B., & Rao, S. S. (1998). simplified NP-complete MAXSAT
problem. Inf. Process. Lett., 65 (1), 1-6.
Rao, M. (2008). Clique-width graphs defined one-vertex extensions. Discrete
Mathematics, 308 (24), 61576165.
Robertson, N., & Seymour, P. D. (1991). Graph minors X. obstructions tree-decomposition.
J. COMBIN. THEORY SER. B , 52 (2), 153190.
Roth, D. (1996). connectionist framework reasoning: Reasoning examples.

81

fiSther, Telle & Vatshelle

W. J. Clancey & D. S. Weld (Eds.), Aaai/iaai, vol. 2 (p. 1256-1261). AAAI Press /
MIT Press.
Sther, S. H., Telle, J. A., & Vatshelle, M. (2014). Solving MaxSAT #SAT
structured CNF formulas. C. Sinz & U. Egly (Eds.), SAT 2014 (Vol. 8561, pp. 16
31). Springer. Retrieved http://dx.doi.org/10.1007/978-3-319-09284-3 3
doi: 10.1007/978-3-319-09284-3 3
Sther, S. H., Telle, J. A., & Vatshelle, M. (2015). online implementations. Retrieved
http://people.uib.no/ssa032/pswidth/
Samer, M., & Szeider, S. (2010). Algorithms propositional model counting. J. Discrete
Algorithms, 8 (1), 50-64.
Slivovsky, F., & Szeider, S. (2013). Model counting formulas bounded clique-width.
L. Cai, S.-W. Cheng, & T. W. Lam (Eds.), Isaac (Vol. 8283, p. 677-687). Springer.
Szeider, S. (2003). fixed-parameter tractable parameterizations SAT. E. Giunchiglia
& A. Tacchella (Eds.), Sat 2003 (Vol. 2919, p. 188-202). Springer.
Thurley, M. (n.d.). sharpSAT. Retrieved https://sites.google.com/site/
marcthurley/sharpsat (accessed 16-January-2015)
Thurley, M. (2006). sharpSATcounting models advanced component caching
implicit BCP. Theory applications satisfiability testing-sat 2006 (pp. 424429).
Springer.
Vatshelle, M. (2012). New width parameters graphs. Unpublished doctoral dissertation,
University Bergen.

82


