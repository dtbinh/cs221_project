journal artificial intelligence

submitted published

solving sat maxsat dynamic programming
sigve hortemo sther
jan arne telle
martin vatshelle

sigve sether ii uib
telle ii uib
martin vatshelle ii uib

department informatics university bergen
bergen norway

abstract
look dynamic programming propositional model counting
called sat maxsat tools graph structure theory particular treewidth
used successfully identify tractable cases many subfields ai including
sat constraint satisfaction csp bayesian reasoning
attack sat maxsat similar modern graph structure
tools tractable cases include formulas whose class incidence graphs
unbounded treewidth unbounded clique width extend
previous maxsat sat achieved dynamic programming along
structural decompositions incidence graph input formula present
limited experimental comparing implementations state art
sat maxsat solvers proof concept warrants

introduction
propositional satisfiability sat fundamental computer science
ai many real world applications scheduling formal verification
encoded sat sat solver used decide exists solution
decide many solutions propositional model counting sat
finds number satisfying assignments could useful solutions
may interesting know close get solution propositional
formula encoded conjunctive normal form cnf may solved maximum
satisfiability maxsat finds maximum number clauses
satisfied assignment investigate classes cnf formulas
two sat maxsat solved polynomial time tools
graph structure theory particular treewidth used successfully identify
tractable cases many subfields ai including sat constraint satisfaction
csp bayesian reasoning bacchus dalmao pitassi darwiche
fischer makowsky ravve samer szeider
attack sat maxsat similar modern graph structure tools
tractable cases include formulas whose class incidence graphs unbounded
treewidth unbounded clique width
sat maxsat significantly harder simply deciding satisfying
assignment exists sat p hard garey johnson even restricted
horn cnf formulas monotone cnf formulas roth maxsat
np hard even restricted horn cnf formulas jaumard simeone
c

ai access foundation rights reserved

fisther telle vatshelle

cnf formulas variable appears times raman ravikumar rao
become tractable certain structural restrictions obtained
bounding width parameters graphs associated formulas fischer makowsky ravve
ganian hlineny obdrzalek samer szeider szeider
work present inspired recent work paulusma slivovsky
szeider work slivovsky szeider showing sat
solvable polynomial time incidence graph f input formula f
bounded modular treewidth strongly bounded symmetric clique width
tractability work dynamic programming along decomposition f
two steps involved good decomposition perform dynamic
programming along decomposition goal fast runtime usually
expressed function known graph width parameter incidence graph f
formula f tree width step solved known graph
computing decomposition low tree width step solves sat maxsat
dynamic programming runtime expressed terms tree width k
decomposition
give work dynamic programming along
decomposition slightly different framework since solving graph
theoretic expressing runtime graph theoretic parameter may limitation
therefore strategy develop framework following strategy
consider sat maxsat amount information needed combine
solutions subproblems global solutions
b define notion good decompositions parameter minimizes
information
c design dynamic programming along decomposition runtime
expressed parameter
work paulusma et al slivovsky szeider
two assignments considered equivalent satisfy set clauses
carrying sat maxsat led us concept ps value
cnf formula let us define give intuitive explanation subset c clauses
cnf formula f called projection satisfiable complete assignment
satisfying every clause c satisfying clause c ps value f
number projection satisfiable subsets clauses let us consider connection
dynamic programming general applies optimal solution found
combining optimal solutions certain subproblems sat maxsat
subproblems least cases consider take form subformula f induced
subset clauses variables e first remove f variables
remove clauses consider simplicity two subproblems fs fs
defined complement combining solutions fs fs order
f bipartite incidence graph clauses f one hand variables f
hand information positive negative occurrences variables encoded f
sometimes signed directed version used includes information



fisolving sat maxsat dynamic programming

solutions f seems clear must consider number cases least
big ps values two disjoint subformulas crossing e
subformulas obtained removing clauses variables removing
clauses variables see figure example
literature study ps value cnf formulas start
asking characterization formulas low ps value led concept
mim value f size maximum induced matching f
induced matching subset edges property edge graph
incident one edge note value much lower
size maximum matching e g complete bipartite graph mim value
ps value f upper bounded number clauses f raised power
mim value f plus cnf formula f f mim value
interpretation straightforward clauses totally ordered
two clauses c c variables occurring c subset variables occurring
c implication number subsets clauses
complete assignment satisfies exactly subset number clauses plus
families cnf formulas small ps value algorithmic interest
continue part b strategy focus
decompose cnf formula f concept ps value common way decompose
mathematical object recursively partition ground set two parts giving
binary tree whose root represents ground set whose leaves bijectively mapped
elements ground set taking ground set f set containing
clauses variables decompose f words binary tree
whose leaves correspondence variables clauses node binary
tree represents subset x variables clauses leaves subtree
decomposition trees good efficiently solving sat maxsat accordance
discussion part answer good decomposition trees
subformulas crossing x x x defined node
tree low ps value see figure example define informal notion
precisely use concept branch decomposition ground set formula
cut function ps value formulas crossing cut branch decompositions
standard notion graph matroid theory originating work robertson
seymour graph minors robertson seymour way arrive
definition ps width cnf formula f decompositions f achieve
ps width important note formula ps value exponential
formula size ps width polynomial general class formulas low
ps width much larger class formulas low ps value
finish strategy must carry part c solve sat
maxsat dynamic programming along branch decomposition formula
express runtime function ps width complicated dynamic
programming everything defined properly simply becomes exercise
brute force computation sufficient necessary information technical
quite tedious leads following theorem
theorem given formula f n variables clauses decomposition f
ps width k solve sat weighted maxsat time k n


fisther telle vatshelle

thus given decomposition ps width k polynomially bounded
number variables n clauses formula get polynomial time
let us compare strongest previous direction namely
work slivovsky szeider sat takes input branch
decomposition vertex set f ground set f
evaluates runtime cut function call index cut function
closely related symmetric clique width scw given decomposition giving runtime
n scw considering clique width cw given decomposition runtime
cw
work slivovsky szeider becomes n since symmetric clique width
clique width related essentially tight inequalities cw scw cw courcelle
thus polynomial time given decomposition
constantly bounded scw theorem encompasses since corollary
ties ps width mim width work vatshelle shows mim width upper
bounded clique width see work rao symmetric clique width
decomposition f constantly bounded symmetric clique width
polynomially bounded ps width way given decomposition assumed input
work slivovsky szeider theorem runtime
cw cw clique width given decomposition
work brault baron capelli mengel appearing preliminary
presentation sther telle vatshelle argued framework
behind theorem gives uniform explanation tractability sat
literature particular dynamic programming structural decompositions
incidence graph work brault baron et al goes beyond giving
polynomial time dynamic programming solve sat acyclic
cnf formulas exactly formulas whose incidence graphs chordal bipartite
formulas bounded ps width incidence
graphs bounded mim width see figure gives overview
papers
concept mim width graphs introduced thesis vatshelle
connection ps value mim value alluded earlier rich class
formulas including classes unbounded clique width polynomially bounded ps width
thus covered theorem firstly holds classes formulas incidence
graphs represented intersection graphs certain objects interval graphs
belmonte vatshelle secondly holds much larger class bipartite
graphs achieved taking bigraph bipartizations intersection graphs obtained
imposing bipartition vertex set keeping edges partition classes
bigraph bipartizations studied previously particular interval
bigraphs interval bigraphs contain bipartite permutation graphs latter
graphs shown unbounded clique width brandstadt lozin see
figure
let us discuss step finding good decomposition note theorem assumes
input formula given along decomposition ps width k value k
need optimal heuristic finding reasonable branch decomposition could
used practice computing decompositions optimal ps width probably doable


fisolving sat maxsat dynamic programming

iden
inc

f

h f
ce grap

ps width mk

sat poly
sat poly b

chordal
bipartite

sat maxsat poly


acyclic

ps width
mim width k
clique width k
symmetric
clique width k
modular
treewidth k

ps width
k trapezoid
bigraph

circular arc
bigraph
interval bigraph
bipartite
permutation

figure believe argued work brault baron et al dynamic
programming working along structural decomposition solve sat
maxsat polynomial time cannot go beyond green box
brault baron et al b slivovsky szeider
left two dashed lines classes graphs bound k k
structural graph width parameter classes bipartite graphs
right acyclic cnf formulas classes cnf formulas ps width
varying linear number clauses mk arc
p q formula f incidence graph f property p
property q hasse diagram lack arc transitive closure
means relation provably hold
polynomial time complexity question adressed however
able efficiently decide cnf formula certain linear structure guaranteeing
low ps width combining alternative definition interval bigraphs hell huang
fast recognition muller rafiey arrive
following say cnf formula f interval ordering exists total ordering
variables clauses variable x occurring clause c x appears
c variable occurs c c appears x x
occurs clause
theorem given formula f n variables clauses literals
time n mn decide f interval ordering yes iff f
interval bigraph yes solve sat weighted maxsat additional
runtime min n
formulas interval ordering precisely whose incidence graphs interval
bigraphs theorem encompasses classes formulas whose incidence graphs
unbounded clique width
could parts interest practical applications answering
question beyond scope present however performed limited
testing particular formulas linear structure simple proof concept
code found online sther telle vatshelle designed
implemented heuristic step finding good decomposition case linear


fisther telle vatshelle

one binary tree describing decomposition path attached leaves
implemented step dynamic programming solving sat maxsat along
decompositions run followed compare one
best maxsat solvers max sat event sat conference
latest version sat solver called sharpsat thurley solvers beat
implementation inputs suprising since code include
techniques beyond nevertheless able generate classes
cnf formulas interval orderings implementation far better
lends support belief methods related ps value warrants
investigate could useful practice
organized follows section give formal definitions ps value
ps width cnf formula central combinatorial lemma linking ps value
formula size maximum induced matching incidence graph
formula section present dynamic programming given formula
decomposition solves sat weighted maxsat proving theorem section
investigate classes formulas decompositions low ps width basically proving
correctness hierarchy presented figure section consider formulas
interval ordering prove theorem section present
implementations testing end section open

framework
consider propositional formulas conjunctive normal form cnf literal
propositional variable negated variable x x clause set literals
formula multiset clauses formula f cla f denotes clauses f
incidence graph formula f bipartite graph f vertex clause
variable variable x adjacent clause c occurs consider
input formulas f connected otherwise would solve
separate components f clause c lit c denotes set literals
c var c denotes
variables literals lit c formula f var f

denotes union ccla f var c set x variables assignment x
function x literal define var negated
variable x variable x var otherwise x variable
x clause c said satisfied assignment exists least one literal
lit c clause assignment satisfy said
falsified notice means empty clause falsified assignments
formula satisfied assignment satisfies clauses cla f
sat given formula f asks many distinct assignments var f
satisfy f optimization weighted maxsat given formula
p f weight
function w cla f n asks assignment var f maximizes c w c
c cla f satisfied maxsat asks maximum number satisfied
clauses achieved equivalent weighted maxsat clauses weight
one weighted maxsat assume sum weights cla f
thus summation weights time linear cla f


fisolving sat maxsat dynamic programming

set elements universe u denote elements u
universe usually given context
cut formula
solve maxsat sat use dynamic programming
divide conquer technique solve smaller
subformulas original formula f combine solutions smaller
formulas form solution entire formula f note however solutions found
subformula depend interaction subformula remainder
formula use following notation subformulas
clause c set x variables c x denote clause c var x
say c x clause c induced x unless otherwise specified clauses mentioned
set cla f e g write c x cla f still assume c
cla f formula f subsets c cla f x var f say subformula
fc x f induced c x formula consisting clauses ci x ci c
fc x formula get removing clauses c followed removing
literal variable x set c clauses denote c x set c x c c
clause assignment set x variables say assignment
induced x x assignment x domain restricted x
formula f sets c cla f x var f c x call cut f
note breaks f four subformulas fc x fc x fc x fc x see figure
one important fact may observe definition clause c f satisfied
assignment var f c induced x x satisfied
least one formulas cut f
projection satisfiable sets ps value formula
formula f assignment variables var f denote sat f
inclusion maximal set c cla f clause c satisfied
set c cla f sat f c variables var f c
known projection kaski koivisto nederlof slivovsky szeider
say c projection satisfiable f denote ps f family projection
satisfiable sets f
ps f sat f assignment entire set var f
cardinality set ps f referred ps value f
get grasp structure formulas low ps value consider induced
matchings incidence graph formula incidence graph formula f
bipartite graph f vertex clause variable variable x adjacent
clause c occurs induced matching graph subset edges
property edge graph incident one edge
words vertices b c ab edge bc edge
exist edge cd number edges called size induced matching
following provides upper bound ps value formula terms
maximum size induced matching incidence graph


fisther telle vatshelle

lemma let f cnf formula clause containing literals
let k maximum size induced matching f ps f
min cla f k tk
proof first argue ps f cla f k let c ps f cf cla f c
thus exists complete assignment clauses satisfied
cf cla f sat f since every variable var f appears clause f
means var cf unique assignment variables var cf satisfy


clause cf let cf cf inclusion minimal set var cf var cf
hence var cf unique assignment variables var cf satisfy


clause cf upper bound number different minimal cf

c ps f give upper bound ps f every c cf variable vc


appearing c clause cf otherwise cf would minimal note
induced matching f containing edges vc c assumption

induced matching k edges hence cf k easy
induction k cla f k sets k clauses lemma
follows
argue ps f tk maximum induced matching size k
set c k clauses var c var f clause c c var c
var f var c tk var f assignments f
ps value f upper bounded tk
ps width formula
define branch decomposition formula f pair rooted
binary tree bijective function leaves clauses variables
f non leaf nodes referred internal nodes induce path
say linear branch decomposition non leaf node v denote
v set l l leaf subtree rooted v say
decomposition formula f induces certain cuts f namely cuts defined v
node v
formula f branch decomposition node v fv denote
formula induced clauses cla f v variables v fv
denote formula complement sets e clauses v variables
var f v words v c x c cla f x var f
fv fc x fv fc x simplify notation node v branch
decomposition set c clauses denote c v set c var fv define ps value
cut v
ps v max p fv p fv
define ps width branch decomposition
psw max ps v v node
define ps width formula f
psw f min psw branch decomposition f


fisolving sat maxsat dynamic programming

v
x
x c x c
x

x

c

c
c x x
c x x x

c
fc x fv

x

fc x

fc x

x x

x x
x

fc x fv

c x x x
c x x x

x

c

figure top branch decomposition formula f var f x x x x x
clauses cla f c c c c given boxes node
v tree defines cut v c x c c c x
x x subformulas defined cut fc x fc x fc x fc x
example fc x x x x fc x x x
fv fc x fv fc x projection satisfiable sets clauses ps fv
c v c v c v c v ps fv c v ps value cut
ps v max p fv p fv

note ps value cut symmetric function ps value cut
equals ps value cut see figure example

dynamic programming maxsat sat
given branch decomposition cnf formula f n variables clauses
total size give solve maxsat sat f time
psw n strongly inspired work slivovsky
szeider order achieve runtime polynomial ps width solve
maxsat must make crucial changes particular must index dynamic
progranming tables ps sets rather shapes used work slivovsky
szeider
let us discuss special terminology used section dynamic
programming section combine partial solutions subformulas solutions
input formula f improve readability introduce notation p sat
allows us refer directly clauses f working subformulas


fisther telle vatshelle

thus formula f branch decomposition node v induced
subformula fv f ps fv denote subsets clauses c cla f v
ps fv c var fv similarly assignment var fv sat fv
denote set clauses c cla f v sat fv c var fv note
ps fv ps fv sat fv sat fv take liberty call
sets projection satisfiable refer ps sets text clear
context mean clauses cla f cla fv
let us discuss implementation details regard ps sets boolean vectors
length cla f assume identify clauses variables integer numbers
checking clause ps set done constant time checking two ps sets
equal done cla f time manage ps sets use binary trie
datastructure fredkin add retrieve ps set trie
cla f time trying add ps set trie already containing equivalent ps set
alter content trie tries contain distinct ps sets
retrieval element trie takes cla f time assigning distinct integer
ps set time added trie cla f time mapping
ps sets distinct integers used implicitly
say index ps sets implementing instead index
corresponding integer ps set mapped
pre processing step need following node v computes
sets projection satisfiable subsets clauses ps fv ps fv two crossing
subformulas fv fv
theorem given cnf formula f branch decomposition ps width k
time k n compute sets ps fv ps fv v

proof notice node v children c c express ps fv


c ps fc

ps fv c c cla fv

c ps fc

similarly sibling parent p v set ps fv expressed


cp ps fp

ps fv cp cs cla fv

cs ps fs
transforming recursive expressions dynamic programming
done procedure procedure able calculate desired sets
long compute sets base cases ps fl l leaf ps fr
root r however formulas contain one variable thus
easily construct set projection satisfiable clauses linear amount time
formulas rest formulas construct formulas procedure
procedure twice many nodes clauses
variables f procedures run cla f var f times run
iterate k pairs projection satisfiable sets
constant number set operations might take cla f time
total runtime k cla f cla f var f k n nodes
combined


fisolving sat maxsat dynamic programming

procedure generating ps fv
input ps fc ps fc children c c v
branch decomposition
output ps fv
l empty trie projection satisfiable clause sets
c c ps fc ps fc
add c c cla fv l
return l
procedure generating ps fv
input ps fs ps fp sibling parent p v
branch decomposition
output ps fv
l empty trie projection satisfiable clause sets
cs cp ps fs ps fp
add cs cp cla fv l
return l
move dynamic programming proper first give
maxsat briefly describe changes necessary solving weighted maxsat
sat
uses technique expectation introduced work bui xuan
telle vatshelle partial solutions might good combined
certain partial solutions bad combined others technique
expectation categorize partial solutions interact optimize selection
partial solutions expectation interaction occurs dynamic
programming maxsat apply technique making expectations
cut regarding set clauses satisfied variables opposide side
cut
node v decomposition f ps sets c ps fv c ps fv
say assignment var f meets expectation c c sat fv v c
sat fv v c node v branch decomposition uses
table tabv pair c c ps fv ps fv stores tabv c c maximum
number clauses v satisfied assignments meeting expectation
c c variables var f v satisfy exactly c assignment
meets expectation equivalent formulation content tabv c c
must satisfy following constraint
assignments var f v sat fv c



tabv c c max sat f v c





bottom dynamic programming along tree compute tables
node leaf l generating tabl done easily linear time since
formula fv contains one variable internal node v children c c


fisther telle vatshelle

compute tabv described procedure tables involved
update one child one parent pair entries one child
table may lead update entry parent table table entry indexed
pair thus indices involved single potential update trick first introduced
work bui xuan et al allows us loop triples indices
triple compute remaining indices forming tuple involved update thereby
reducing runtime
procedure computing tabv inner node v children c c
input tabc tabc
output tabv
initialize tabv ps fv ps fv
cc cc cv ps fc ps fc ps fv

cc cc cv c

cc cc cv c

cv cc cc v

tabc cc cc tabc cc cc

tabv cv cv tabv cv cv
return tabv
lemma cnf formula f clauses inner node v branch decomposition ps width k procedure computes tabv satisfying constraint time
k
proof assume tabc tabc satisfy constraint procedure loops triples
ps fc ps fc ps fv definition ps width
k triples operation inside iteration loop take time
constant number operations thus runtime k
correctness output let us look bit workings
procedure assignment var f cut assignment meet
expectation single pair ps sets let x x x x xv xv pairs
assignment meets expectation respect cuts induced c c v
respectively notice
xv sat fv v

sat fv c c

sat fv c sat fv c

sat fc c v sat fc c v



x v x v
x x v

seen figure symmetry similar values x x
namely x x xv c x x xv c latter three sets
implicit three former sets respect cuts induced v c
c therefore convenience proof say assignment meets


fisolving sat maxsat dynamic programming

x sat fc c

clauses cla f v

x sat fc c
xv sat fv v

clauses c

clauses c

figure shown chain equalities proof lemma clauses
sat fv v precisely clauses sat fc c sat fc c v
expectation triple c c c ps sets meets expectation implicit
three pairs respective cuts notice choice triples
ps sets cc cc cv procedure computes implicit three sets names
cc cc cv accordingly
pairs c c ps fv ps fv value tabv c c
correct let assignment var f satisfies maximum number
clauses meeting expectation c c thus value tabv c c correct
stores exactly number clauses v satisfies
let c c c c pairs ps sets meet expectation
cut c c c c respectively meets expectations value
tabc c c tabc c c must least large number clauses
satisfies c c respectively thus number clauses satisfies
c c large sum two entries since procedure
iteration cv c cc c cc c ensures tabv c c least
sum tabc c c tabc c c know tabv c c least large
correct value
assume contradiction value cell tabv c c large
means iteration procedure assigned value tabc cc cc
tabc cc cc sum large let assignments var f
meeting expectation cc cc meeting expectation cc cc respectively
number clauses c c respectively equals according table
entries tabc tabc take assignment x c c v
assignment meets expectation c c satisfies clauses
v contradicting choice tabv c c neither smaller larger
number clauses v satisfies exactly
theorem given formula f n variables clauses branch decomposition
f ps width k solve maxsat sat weighted maxsat time
k n
proof solve maxsat first compute tabr root node r requires
first compute ps fv ps fv nodes v bottom
manner compute tabv n nodes former part


fisther telle vatshelle

k n time theorem latter part k n time
lemma
root r r var f cla f thus fr fr
variables p fr p fr contains assignments var f
meet expectation cut r r cla f r cla f
constraint value tabr maximal number clauses f assignment
var f satisfies hence number solution maxsat
weight function w cla f n redefining constraint tabv maximize
w sat f v instead sat f v able solve general
weighted maxsat way
sat care assignments satisfying clauses
f want decide number distinct assignments requires
alterations firstly alter definition contents tabv c c constraint
number assignments var f v sat fv c
clauses v c satisfied secondly computing tabl
leaves l set entries tabl zero one two according
definition thirdly alter compute tabv procedure inner nodes
initialize tabv c c zero start substitute lines
procedure following line increases table value product
table values children
tabv cv cv tabv cv cv tabc cc cc tabc cc cc
satisfy constraint tabv internal nodes v value tabr
root r exactly number distinct assignments satisfying clauses
f
bottleneck giving cubic factor k runtime theorem number
triples ps fv ps fc ps fc node v children c c
linear branch decomposition case c c leaf
case ps fc ps fc constant therefore linear branch decompositions
ps fv ps fc ps fc contain k triples thus reduce
runtime factor k
theorem given formula f n variables clauses linear branch
decomposition f ps width k solve sat maxsat weighted maxsat
time k n

cnf formulas polynomial ps width
section investigate classes cnf formulas decompositions ps width
polynomially bounded total size formula particular
holds whenever incidence graph formula constant mim width maximum
induced matching width introduced vatshelle large class
bipartite graphs call bigraph bipartizations constant mim width


fisolving sat maxsat dynamic programming

order lift upper bound lemma ps value f e ps f
ps width f use mim width incidence graph f defined branch
decompositions graphs branch decomposition formula f defined section
seen branch decomposition incidence graph f nevertheless
completeness formally define branch decompositions graphs mim width
branch decomposition graph g pair rooted binary tree
bijection leaf set vertex set g node w
let subset v g bijection leaves subtree rooted w
denoted vw say decomposition defines cut vw vw mim value cut
vw vw size maximum induced matching g vw vw mim width
maximum mim value cuts vw vw defined node w mim width
graph g denoted mimw g minimum mim width branch decompositions
g linear branch decomposition branch decomposition inner
nodes underlying tree induces path
since decomposition f seen decomposition f immediately
get lemma following corollary
corollary cnf formula f clauses clause containing
literals ps width f min mk tk k mimw f
many classes graphs intersection meaning represented
intersection graphs certain objects e vertex associated object
two vertices adjacent iff objects intersect objects used define intersection
graphs usually consist geometrical objects lines circles polygons many well
known classes intersection graphs constant mim width following
lists subset classes proven bounds belmonte vatshelle
vatshelle
theorem belmonte vatshelle vatshelle let g graph g
interval graph mimw g
circular arc graph mimw g
k trapezoid graph mimw g k
moreover exist linear decompositions satisfying bound found polynomial time k trapezoid assume intersection model given
let us briefly mention definition graph classes graph interval graph
intersection model consisting intervals real line graph circular arc
graph intersection model consisting arcs circle build k trapezoid
start k parallel line segments e e sk ek add two non intersecting
paths e joining si si ei ei respectively straight lines
k polygon defined e two line segments e sk ek
forms k trapezoid graph k trapezoid graph intersection model consisting
k trapezoids see work brandstadt le spinrad information
graph classes containment relations
combining corollary theorem get following
corollary let f cnf formula containing clauses maximum clause size
f


fisther telle vatshelle

interval graph psw f min
circular arc graph psw f min
k trapezoid graph psw f min mk tk
moreover exist linear decompositions satisfying bound found polynomial time k trapezoid assume intersection model given
incidence graphs formulas bipartite graphs case
majority graphs mentioned graph classes following
extend corollary large classes bipartite graphs graph g
subset vertices v g bipartite graph g subgraph g containing
edges g exactly one endpoint graph g v g call g
bigraph bipartization g note g bigraph bipartization subset
vertices graph class x define class x bigraphs bipartite graphs h
exists g x h isomorphic bigraph bipartization g
example bipartite graph h interval bigraph interval graph g
v g h isomorphic g
following allow us lift corollary given graphs
bigraph bipartizations graphs
theorem assume given cnf formula f clauses maximum
clause size graph g subset v g g linear branch decomposition
g mim width k f connected isomorphic g thus f bigraph
bipartization g linear time produce linear branch decomposition f
f ps width min mk tk
proof since variable clause f corresponding node f node
f corresponding node g defining f function mapping leaf
l variable clause f corresponding node g l get f
branch decomposition f consider cut b b induced node f note
mim value g b b k f connected means
corresponding set variables f assume wlog former thus
c b cla f clauses b c cla f c x b var f
variables b x var f x mim values g c x g c x
k since induced subgraphs g b b taking induced subgraphs
cannot increase size maximum induced matching hence lemma
ps fc x cla f k likewise ps fc x cla f k
maximum two ps value cut since ps width decomposition
maximum ps value cut theorem follows
combining theorems immediately get following
corollary let f cnf formula containing clauses maximum clause size
f
interval bigraph psw f min
circular arc bigraph psw f min
k trapezoid bigraph psw f min mk tk
moreover exist linear decompositions satisfying bound


fisolving sat maxsat dynamic programming

next section address question finding linear decompositions
polynomial time succeed case interval bigraphs circular arc bigraphs
k trapezoid bigraphs must leave open

interval bigraphs formulas interval orders
section formulas whose incidence graph interval bigraph
polynomial time linear branch decompositions small ps width let
us recall definition interval ordering cnf formula f interval ordering
exists linear ordering variables clauses variable x occurring
clause c x appears c variable occurs c
c appears x x occurs clause see figure
example
order
x c x x c c x x

clauses

bipartized interval rep

incidence graph

x
c
x
x
c
c
x
x

c x x
c x x x
c x x x

c

x

c c

x x

x x

figure cnf formula interval ordering incidence graph interval
bigraph since isomorphic bigraph bipartization defined blue
intervals interval graph intersection model left
work hell huang follows formula f interval ordering
f interval bigraph
theorem given cnf formula f n variables clauses
literals time n mn decide f interval ordering yes iff f
interval bigraph yes solve sat weighted maxsat additional
runtime min n
proof characterization work hell huang
rafiey time n mn decide f interval ordering
yes interval ordering build interval graph g f
bigraph bipartization g construct linear branch decomposition g
mim width belmonte vatshelle linear branch decomposition


fisther telle vatshelle

get theorem construct another linear branch decomposition f
ps width run theorem

experimental
present simple experimental intended proof concept belief
ideas behind notion ps value useful
practice require thorough investigation confirm belief
indicate worst case runtime bounds dynamic programming theorems
probably higher would commonly seen practice
past decade sat solvers become powerful currently able
handle large practical instances techniques sat solvers
applied develop relatively powerful maxsat sat solvers biere heule van
maaren experiments compare implementations
state art maxsat sat solvers enhance implementations
techniques even simple pre processing vast majority instances
implementations fall far behind comparison however focusing formulas
certain linear order implementations compare favorably
explained section two steps involved good decomposition
input cnf formula f perform dp dynamic programming along
decomposition let us start describing simple heuristic step takes
input bipartite graph f vertex set cla f var f outputs linear
order vertex set heuristic greedyorder greedy
increasing values chooses vertex highest number already
chosen neighbors among choosing one fewest non chosen neighbors
defines linear branch decomposition cnf formula f non leaf nodes
binary tree inducing path rooted one end path
mapping ith leaf encountered breadth first search starting root
clause variable cla f var f

greedyorder
input g v e bipartite graph
output linear ordering v
l r v
v v set ldegree v
r empty
choose v vertices r max ldegree take one smallest degree
set v increment add v l remove v r
w r vw e increment ldegree w



fisolving sat maxsat dynamic programming

implementations found online sther telle vatshelle
implemented greedyorder java together straight forward implementation
dp theorem
given cnf formula allows us solve maxsat sat first running
greedyorder dp compare implementation best solvers could
online respectively ccls akmaxsat luo cai wu jie su
among best solvers ninth max sat evaluation latest version
sat solver called sharpsat thurley n solvers handily beat
implementation inputs therefore generated cnf formulas
interval orderings theorem check least instances better
note step implemented polynomial time recognizing
formulas interval orders relying instead greedyorder heuristic
generation instances
presenting let us describe generation set instances
three types start type generation formulas
definition interval orderings given interval bigraph definition see e g left side
figure generate formula type n variables clauses generate
n intervals real line iterating points n left
right endpoints intervals
step check cases legal e g legal exists
live variable e left endpoint right endpoint randomly make
one legal choices
start interval variable left endpoint
start interval clause left endpoint
end interval randomly chosen live variable right endpoint
end interval randomly chosen live clause right endpoint
towards end process boundary conditions enforced reach exactly
clauses n expected slightly smaller clause interval randomly
choose variable overlapping interval positive negative
clause resulting cnf formula interval ordering given rightmost
endpoints intervals hide ordering clauses variables randomly permuted
make final cnf formula
formulas type generated similar fashion type except
guarantee clauses size lemma could big help
change case instead choice becomes enforced live
clause step accumulated exactly overlapping variable intervals let
clause interval represent clauses variable set randomly chosen
literals aim increasing probability instance satisfiable
formulas type cnf representation conjunction xor functions
xor fixed number literals variables xor functions


fisther telle vatshelle

overlap way incidence graph bipartization circular arc
graph
formula type generated three input parameters n n variables
represented successive points n circle first xor function interval
thus containing variables points second interval
general ith interval appropriate modulo addition
boundary condition end ensure n xor functions variables chosen
randomly appear positive negative xor xor transformed
standard way cnf formula clauses give us resulting cnf formula
n clauses variables clauses randomly permuted hide
ordering giving circular arc bigraph representation
note resulting formulas quite simple structure state ofthe art sat solver lingeling biere handles generated instances within
seconds

ready present ran solvers dell optiplex
running ubuntu bit machine gb memory intel core quad
q processor openjdk java icedtea
instances type greedyorder heuristic fails terribly becomes huge
bottleneck greedy choice degrees vertices f simple however
given correct interval order solver performed better
instances type generated similar type clauses small size
lemma could help case number clauses approximately

runtime seconds





ccls
sharpsat
maxsat
sat
practically equal








number variables



figure runtimes instances type maxsat solver clearly faster
ccls akmaxsat vertical axis represents time seconds runs taking
seconds stopped completion drawn
dotted line



fisolving sat maxsat dynamic programming

four times number variables consequence great number instances
satisfiable making work sat solvers easier maxsat
solvers generated instances type solved within seconds sharpsat see
figure size instances grow see clear tendency runtimes
ccls akmaxsat increase much rapidly solvers runtimes
two solvers almost identical greedyorder heuristic instances seems
produce decompositions orders low ps width
type instances shown figure generated k
instances satisfiable may explain ccls akmaxsat fast choosing
k satisfiable instances ccls akmaxsat would
often spend seconds time size instances grow
see clear tendency runtimes sharpsat increase much rapidly
solvers runtimes two solvers almost identical

runtime seconds





ccls
sharpsat
maxsat
sat
practically equal









number variables



figure runtimes instances type sat solver clearly faster
sharpsat vertical axis represents time seconds runs taking
seconds stopped completion drawn dotted line

conclusion
proposed structural parameter cnf formulas called ps width
projection satisfiable width showed weighted maxsat sat
solved polynomial time given decomposition formula polynomially bounded
ps width concept interval bigraphs showed polynomial time
actually finds decomposition formulas interval ordering could
one devise larger class circular arc bigraphs maybe
even even larger class k trapezoid bigraphs words
recognizing bipartite input graph circular arc bigraph k trapezoid bigraph
polynomial time solvable


fisther telle vatshelle

could practical interest design heuristic given formula finds
decomposition relatively low ps width done boolean width hvidevold
sharmin telle vatshelle one could check benchmarks covering real world
sat instances low ps width perform study correlation low
ps width practical hardness maxsat sat solvers done
treewidth sat solvers mateescu presented simple experimental
require thorough investigation check ideas
could useful practice finally hope essential combinatorial enabling
improvements lemma may uses well

references
bacchus f dalmao pitassi complexity sat
bayesian inference foundations computer science proceedings th
annual ieee symposium pp
belmonte r vatshelle graph classes structured neighborhoods
algorithmic applications theor comput sci
biere yet another local search solver lingeling friends entering sat
competition sat competition
biere heule van maaren h handbook satisfiability vol
chap ios press
brandstadt le v b spinrad j p graph classes survey vol
philadelphia siam society industrial applied mathematics
brandstadt lozin v v linear structure clique width bipartite
permutation graphs ars comb
brault baron j capelli f mengel understanding model counting
acyclic cnf formulas corr abs retrieved http arxiv org
abs
bui xuan b telle j vatshelle h join decomposable graphs
runtime single exponential rankwidth discrete applied mathematics

bui xuan b telle j vatshelle boolean width graphs theoretical
computer science
courcelle b clique width countable graphs compactness property discrete
mathematics retrieved http dx doi org
x doi x
darwiche recursive conditioning artificial intelligence
fischer e makowsky j ravve e v counting truth assignments
formulas bounded tree width clique width discrete applied mathematics



fisolving sat maxsat dynamic programming

fredkin e trie memory communications acm
ganian r hlineny p obdrzalek j better satisfiability
formulas bounded rank width fundam inform
garey r johnson computers intractability guide theory
np completeness w h freeman
hell p huang j interval bigraphs circular arc graphs journal graph
theory
hvidevold e sharmin telle j vatshelle finding good
decompositions dynamic programming dense graphs marx p rossmanith
eds ipec vol p springer
jaumard b simeone b complexity maximum satisfiability
horn formulas inf process lett
kaski p koivisto nederlof j homomorphic hashing sparse coefficient
extraction proceedings th international conference parameterized
exact computation pp
luo c cai wu w jie z su k ccls efficient local search
weighted maximum satisfiability ieee transactions computers doi
tc
mateescu r treewidth industrial sat benchmarks tech rep tech rep
cambridge uk microsoft retrieved http microsoft
com pubs msr tr pdf
muller h recognizing interval digraphs interval bigraphs polynomial time
discrete applied mathematics
ninth max sat evaluation retrieved http www maxsat udl cat
accessed january
paulusma slivovsky f szeider model counting cnf formulas
bounded modular treewidth n portier wilke eds stacs vol p
schloss dagstuhl leibniz zentrum fuer informatik
rafiey
abs

recognizing interval bigraphs forbidden patterns

corr

raman v ravikumar b rao simplified np complete maxsat
inf process lett
rao clique width graphs defined one vertex extensions discrete
mathematics
robertson n seymour p graph minors x obstructions tree decomposition
j combin theory ser b
roth connectionist framework reasoning reasoning examples



fisther telle vatshelle

w j clancey weld eds aaai iaai vol p aaai press
mit press
sther h telle j vatshelle solving maxsat sat
structured cnf formulas c sinz u egly eds sat vol pp
springer retrieved http dx doi org
doi
sther h telle j vatshelle online implementations retrieved
http people uib ssa pswidth
samer szeider propositional model counting j discrete

slivovsky f szeider model counting formulas bounded clique width
l cai w cheng w lam eds isaac vol p springer
szeider fixed parameter tractable parameterizations sat e giunchiglia
tacchella eds sat vol p springer
thurley n sharpsat retrieved https sites google com site
marcthurley sharpsat accessed january
thurley sharpsatcounting advanced component caching
implicit bcp theory applications satisfiability testing sat pp
springer
vatshelle width parameters graphs unpublished doctoral dissertation
university bergen




