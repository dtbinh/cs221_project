Journal Artificial Intelligence Research 54 (2015) 193231

Submitted 6/15; published 10/15

Expressiveness Two-Valued Semantics
Abstract Dialectical Frameworks
Hannes Strass

strass@informatik.uni-leipzig.de

Computer Science Institute, Leipzig University
Augustusplatz 10, 04109 Leipzig, Germany

Abstract
analyse expressiveness Brewka Woltrans abstract dialectical frameworks
two-valued semantics. expressiveness mean ability encode desired set
two-valued interpretations given propositional vocabulary using atoms
A. compare ADFs expressiveness (the two-valued semantics of)
abstract argumentation frameworks, normal logic programs propositional logic.
computational complexity two-valued model existence problem
languages (almost) same, show languages form neat hierarchy
respect expressiveness. demonstrate hierarchy collapses
allow introduce linear number new vocabulary elements. finally analyse
compare representational succinctness ADFs (for two-valued model semantics),
is, capability represent two-valued interpretation sets space-efficient manner.

1. Introduction
often not, different knowledge representation languages conceptually similar partially overlapping intended application areas. faced
application choice several possible knowledge representation languages
could used application? One first axes along compare different
formalisms comes mind computational complexity: language computationally expensive considering problem sizes typically encountered practice,
clear criterion exclusion. available language candidates
computational complexity? expressiveness computationalcomplexity sense kinds problems formalism solve? same,
need fine-grained notion expressiveness. paper, use notion
study expressiveness abstract dialectical frameworks (ADFs) (Brewka & Woltran,
2010; Brewka, Ellmauthaler, Strass, Wallner, & Woltran, 2013), recent generalisation
abstract argumentation frameworks (AFs) (Dung, 1995).
Argumentation frameworks de-facto standard formalism abstract argumentation, field studies (abstract) arguments relate terms directed
conflicts (attacks), conflicts resolved without looking
arguments. AFs popular well-studied, noted many times
literature expressive capabilities somewhat limited. recently
made technically precise Dunne, Dvorak, Linsbichler, Woltran (2014, 2015),
basically showed introducing new, purely technical arguments sometimes inevitable using AFs representation purposes. However, due nature,
dialectical meaning technical arguments might ironically debatable.
c
2015
AI Access Foundation. rights reserved.

fiStrass

surprisingly, quite number generalisations AFs proposed (for
overview refer Brewka, Polberg, & Woltran, 2014). one general AF
alternatives, aforementioned abstract dialectical frameworks (ADFs) emerged.
formalism, arguments (called statements there) abstract, links
arguments. AFs links necessarily attacks, ADFs statement
associated acceptance condition Boolean function parent statements
specifies exactly statement accepted. way, acceptance
conditions ultimately express meaning links ADF. Even restricted subclass
bipolar ADFs intuitively links supporting attacking proper
generalisation AFs, quite expressive one shall see paper.
ADFs could called lovechild AFs logic programs, since combine
intuitions semantics Dung-style abstract argumentation well logic programming (Brewka et al., 2013; Strass, 2013; Alviano & Faber, 2015). abstract
level, ADFs intended function argumentation middleware sufficiently expressive target formalism translations concrete (application) formalisms.
part ADF success story, mention reconstruction Carneades model
argument (Brewka & Gordon, 2010), instantiation simple defeasible theories
ADFs (Strass, 2015a), recent applications ADFs legal reasoning reasoning
cases Al-Abdulkarim, Atkinson, Bench-Capon (2014, 2015).
paper, approach abstract dialectical frameworks knowledge representation
formalisms, since used represent knowledge arguments relationships
arguments. employ view analyse representational capabilities
ADFs. Due roots AFs logic programs, compare representational capabilities formalisms setting. initial study restrict
looking two-valued semantics, specifically ADF (stable) model semantics, corresponds AF stable extension semantics, supported stable
model semantics logic programs. add propositional logic well-known reference point. Analysing precise formalisms additionally makes sense us
computational complexity respective model existence problems (with
one exception):
AFs, deciding stable extension existence NP-complete (Dimopoulos, Nebel, &
Toni, 2002);
normal logic programs, deciding existence supported/stable models NPcomplete (Bidoit & Froidevaux, 1991; Marek & Truszczynski, 1991);
ADFs, deciding existence (supported) models NP-complete (Brewka
et al., 2013), deciding existence stable models P2 -complete general
ADFs (Brewka et al., 2013) NP-complete subclass bipolar ADFs (Strass
& Wallner, 2015);
propositional satisfiability problem NP-complete.
view almost identical complexities, use alternative measure
expressiveness knowledge representation formalism F: Given set two-valued
interpretations, knowledge base F exact model set? notion
194

fiExpressiveness Two-Valued Semantics ADFs

lends straightforwardly compare different formalisms (Gogic, Kautz, Papadimitriou,
& Selman, 1995):
Formalism F2 least expressive formalism F1 every
knowledge base F1 equivalent knowledge base F2 .
expressiveness understood terms realisability, kinds model sets
formalism express? (In model theory, known definability.)
easy see propositional logic express set two-valued interpretations,
universally expressive. easy (but less easy) see normal logic programs
supported model semantics. normal logic programs stable model semantics,
clear model sets expressed, since two different stable models
always incomparable respect subset relation.1 paper, study
expressiveness properties mentioned formalisms different semantics.
turns languages form less strict expressiveness hierarchy, AFs
bottom, ADFs LPs stable semantics higher ADFs LPs
supported model semantics top together propositional logic.
show language F2 least expressive language F1 mainly
use two different techniques. best case, use syntactic compact faithful
translation knowledge bases F1 F2 . Compact means translation
change vocabulary, is, introduce new atoms. Faithful means
translation exactly preserves models knowledge base respective semantics
two languages. second best case, assume knowledge base F1
given form set X desired models construct semantic realisation X
F2 , is, knowledge base F2 model set precisely X. show language
F2 strictly expressive F1 , additionally present knowledge base kb
F2 prove F1 cannot express model set kb.
Analysing expressiveness argumentation formalisms quite recent strand
work. ascent attributed Dunne et al. (2014, 2015), studied realisability
argumentation frameworks (allowing introduce new arguments long
never accepted). Likewise, Dyrkolbotn (2014) analysed AF realisability projection
(allowing introduce new arguments) three-valued semantics. Baumann, Dvorak, Linsbichler, Strass, Woltran (2014) studied expressiveness subclass compact
AFs, argument accepted least once. Finally, recently, Puhrer
(2015) analysed realisability three-valued semantics ADFs. Previous preliminary works include Brewka, Dunne, Woltran (2011), translated ADFs
AFs ADF model AF stable extension semantics, however translation
introduces additional arguments therefore compact; (Strass, 2013),
studied syntactic intertranslatability ADFs LPs, look
expressiveness realisability.
gain achieved analysis paper increased
clarity fundamental properties knowledge representation languages
formalisms express, actually? several applications. Dunne
et al. (2015) remarked, major application constructing knowledge bases aim
1. However, stable model semantics becomes universally expressive allow nested expressions
form p rule bodies (Lifschitz, Tang, & Turner, 1999; Lifschitz & Razborov, 2006).

195

fiStrass

encoding certain model set. necessary prerequisite this, must known
intended model set realisable first place. example, recent approach
revising argumentation frameworks (Coste-Marquis, Konieczny, Mailly, & Marquis, 2014),
authors avoid problem assuming produce collection AFs whose model sets
union produce desired model set. work Dunne et al. (2015) showed
indeed necessary case AFs stable extension semantics, work shows
ADFs model semantics, single knowledge base (ADF) always enough
realise given model set. more, assume intended model set
given form propositional formula, size realising ADF
linear size formula. one example several occasions
consider sizes realisations, uncommon logic-based AI (Darwiche &
Marquis, 2002; Lifschitz & Razborov, 2006; French, van der Hoek, Iliev, & Kooi, 2013; Shen
& Zhao, 2014). Indeed, representation size fundamental practical aspect knowledge
representation languages: universal expressiveness little use model sets express
require exponential-size knowledge bases even best case!
course, fact languages study computational complexity
means principle exist polynomial intertranslations respective decision
problems. intertranslations may involve introduction polynomial number
new atoms. theory, increase n atoms nk atoms k > 1
consequence. practice, profound impact: number n atoms directly
influences search space implementation potentially cover. There, step
2n
k1 n
k
k1
2n = 2n n = 2n
amounts exponential increase search space size. able realise model set
compactly, without new atoms, therefore attests formalism F certain basic
kind efficiency property, sense F-realisation model set
unnecessarily enlarge search space algorithms operating it.
might seem restricting assumption view formalisms sets F knowledge bases kb F associated two-valued semantics. However, language
representation model universal sense another way expressing languages sets words {0, 1}. Using n-element vocabulary = {a1 , . . . , }, binary word w = x1 x2 xn length n encoded set Mw = {ai | xi = 1} .
example, using vocabulary A3 = {a1 , a2 , a3 }, binary word 101 length 3 corresponds set M101 = {a1 , a3 }. Consequently, set Ln words length n
represented set XLn 2An subsets : XLn = {Mw | w Ln }.
example vocabulary, word set L3 = {101, 110, 011} represented model
set XL3 = {{a1 , a3 } , {a1 , a2 } , {a2 , a3 }}. Conversely, sequence (Xn )n0 sets

Xn 2An uniquely determines language L = n0 Ln {0, 1}: n N,
Ln = {wM | Xn } wM = x1 x2 xn {1, . . . , n}, xi = 1
ai xi = 0 ai
/ . paper use language refer object-level
languages formalism refers meta-level languages, propositional logic,
argumentation frameworks, abstract dialectical frameworks, logic programs.
Formally, syntax ADFs defined via Boolean functions. However, interested representations ADFs. fix representation ADFs via fixing
196

fiExpressiveness Two-Valued Semantics ADFs

representation Boolean functions. choose use (unrestricted) propositional formulas, customary literature (Brewka & Woltran, 2010; Brewka et al.,
2013; Polberg et al., 2013; Polberg, 2014; Gaggl & Strass, 2014; Linsbichler, 2014; Strass &
Wallner, 2015; Puhrer, 2015; Gaggl, Rudolph, & Strass, 2015). Exceptions custom
works Brewka et al. (2011), use Boolean circuits, one (Strass,
2013) used characteristic models (that is, used representation equivalent
representing formulas disjunctive normal form). subclass bipolar ADFs,
yet uniform representation exists, another question address paper.
propositional formulas vocabulary mean formulas Boolean
basis {, , }, is, trees whose leaves (sinks) atoms logical constants
true > false , internal nodes either unary () binary (,). make
occasional use Boolean circuits, trees replaced directed acyclic
graphs; particular, allow unbounded fan-in, is, reusing sub-circuits. usual,
depth formula (circuit) length longest path root leaf
(sink). Figure 1 shows formula circuit examples depth 3.



p



















q

p

q

p

q

Figure 1: Representing (p q) (q p) formula tree (left) circuit (right).

Analysing expressive power representation size Boolean circuits established sub-field computational complexity (Arora & Barak, 2009). led
number language classes whose members recognised Boolean circuits satisfying

certain restrictions. need class AC0 , contains languages L = n0 Ln
exist d, k N n N, exists Boolean circuit Cn
depth size nk models Cn exactly express Ln .2
words, every language L AC0 recognised family polynomial-size Boolean
circuits fixed maximal depth independent word length.
paper proceeds follows. first define notion expressiveness (and succinctness) formally introduce formalisms study. reviewing several
intertranslatability results languages, step-wise obtain results lead
expressiveness hierarchy, times looking representational efficiency.
finally show allowing linearly expand vocabulary leads collapse
hierarchy. paper concludes discussion possible future work.

2. precise, n N, models Cn exactly XLn , turn expresses Ln .

197

fiStrass

2. Background
presume finite set atoms (statements, arguments), vocabulary. knowledge
representation formalism interpreted set F; (two-valued) semantics

F mapping : F 22 assigns sets two-valued models knowledge bases
kb F. (So implicit .) Strictly speaking, two-valued interpretation mapping
set atoms two truth values true false, technical ease
represent two-valued interpretations sets containing atoms true. Below,
write (F) = {(kb) | kb F}; intuitively, (F) set interpretation sets
formalism F express, knowledge base whatsoever. example, F = PL

propositional logic = mod usual model semantics, (PL) = 22 since
obviously set models realisable propositional logic.3 leads us compare
different pairs languages semantics respect semantics range models.
concept formalism concentrates semantics decidedly remains abstract.
first define expressiveness relation among formalisms.
Definition 1. Let finite vocabulary, F1 , F2 formalisms interpreted


1 : F1 22 2 : F2 22 two-valued semantics. define
F11 e F22

iff

1 (F1 ) 2 (F2 )

Intuitively, formalism F2 semantics 2 least expressive formalism F1
semantics 1 , model sets F1 express 1 contained
F2 produce 2 . (If semantics clear context
omit them; holds particular argumentation frameworks propositional logic,
look single semantics.) usual,
F1 <e F2 iff F1 e F2 F2 6e F1 ;
F1
=e F2 iff F1 e F2 F2 e F1 .
relation e reflexive transitive definition, necessarily antisymmetric.
is, might different formalisms F1 6= F2 equally expressive: F1
=e F2 .
next introduce succinctness relation defined Gogic et al. (1995).
Definition 2. Let finite vocabulary; let F1 F2 formalisms interpreted A, size measures kk1 kk2 , two-valued semantics 1 2 ,
respectively. Define F11 F22 k N kb1 F1
1 (kb1 ) 1 (F1 ) 2 (F2 ), kb2 F2 1 (kb1 ) = 2 (kb2 ) kkb2 k2 kkb1 kk1 .
Intuitively, F11 F22 means F2 2 least succinct F1 1 .
Put another way, F11 F22 hold, knowledge base F1 equivalent
counterpart F2 must equivalent counterpart polynomially larger.
Note succinctness talks model sets express,
meaningful comparing languages equally expressive, is, whenever
3. set X 2A simply define X =
mod (X ) = X.

W

X

198

=

V





V

aA\M

clearly

fiExpressiveness Two-Valued Semantics ADFs

1 (F1 ) = 2 (F2 ). usual, define F1 <s F2 iff F1 F2 F2 6s F1 , F1
=s F2
iff F1 F2 F2 F1 . relation reflexive, necessarily antisymmetric
transitive.
final general definition formalisms polynomially expressing languages.
Here, already make use previously introduced bijection interpretations
binary words use term languages synonymously refer both.

Definition 3. formalism F polynomially express language L = n0 Ln


semantics : F 22 k N positive n N
knowledge base kbn F formalism (kbn ) = Ln kkbn k O(nk ).
next introduce specific object-level languages use. First all,
language Parity contains odd-element subsets vocabulary. Formally,
= {a1 , . . . , } n 1
Parityn = {M | N : |M | = 2m + 1}

explained before, Parity = nN,n1 Parityn . textbook result Parity
expressible polynomial-size propositional formulas (Jukna, 2012); example,
define Parity
(a1 ) = a1 n 2 set
1
Parity
(a1 , . . . , ) = (Parity
(a1 , . . . , ) Parity
(an +1 , . . . , ))
n
n
n
(Parity
(a1 , . . . , ) Parity
(an +1 , . . . , ))
n
n


n = n2 n = n2 . (This construction yields formula logarithmic depth
therefore polynomial size.) textbook result (although nearly easy
see) Parity cannot expressed depth-bounded polynomial-size circuits, is,
Parity
/ AC0 (Jukna, 2012).
another important class, threshold languages defined n, k N n 1
k n:
Thresholdn,k = {M | k |M |}
is, Thresholdn,k contains
interpretations n atoms least k atoms
true. special case k = n2 leads majority languages,
Majorityn = Thresholdn,d n e
2

contain interpretations least half atoms vocabulary true.
next introduce particular knowledge representation languages study
paper. make use vocabulary A; results paper considered
parametric given vocabulary.
2.1 Logic Programs
vocabulary define = {not | A} accordingly set literals
= A. normal logic program rule form B
B . set B called body rule, abbreviate B + = B
199

fiStrass

B = {a | B}. logic program (LP) P set logic program rules
A. interpretation satisfies body B rule B P iff B +
B = . supported model P iff = {a | B P, satisfies B}.
logic program P denote set supported models su(P ). intuition
behind semantics atoms true model
kind support.
However, support might cyclic self-support. instance, logic program
{a {a}} two supported models, {a}, latter undesired many
application domains. alternative, Gelfond Lifschitz (1988) proposed stable
model semantics, allow self-support: set stable model P iff
-least supported model P , P obtained P (1) eliminating
rule whose body contains literal , (2) deleting literals
form bodies remaining rules (Gelfond & Lifschitz, 1988).
write st(P ) set stable models P . follows definition st(P )
-antichain: M1 6= M2 st(P
P) M1 6 M2 . size measure define
ka Bk = |B| + 1 rules kP k = rP krk programs.
example, consider vocabulary = {a, b, c} logic program
P = {a {b} , b {a} , c {not a}}. find su(P ) = {{c} , {a, b}} st(P ) = {{c}}.
2.2 Argumentation Frameworks
Dung (1995) introduced argumentation frameworks pairs F = (A, R) set
(abstract) arguments R relation attack arguments.
purpose semantics argumentation frameworks determine sets arguments (called
extensions) acceptable according various standards. given extension
A, arguments considered accepted, attacked
argument considered rejected, others neither, status
undecided. interested so-called stable extensions, sets arguments
attack attack arguments set. stable extensions,
argument either accepted rejected definition, thus semantics two-valued.
formally, set arguments conflict-free iff a, b (a, b) R.
set stable extension (A, R) iff conflict-free \
argument b (b, a) R. AF F , denote set stable extensions
st(F ). Again, follows definition stable extension set st(F ) always
-antichain. size argumentation framework F = (A, R) kF k = |A| + |R|.
example, AF F = ({a, b, c} , {(a, b), (b, a), (b, c)}) visualised using
c set stable extensions st(F ) = {{a, c} , {b}}.
b
directed graph
2.3 Abstract Dialectical Frameworks
abstract dialectical framework tuple = (A, L, C) set statements
(representing positions one take take debate), L set links
(representing dependencies positions), C = {Ca }aA collection total
functions Ca : 2par (a) {t, f }, one statement A. function Ca called
acceptance condition expresses whether accepted, given acceptance
200

fiExpressiveness Two-Valued Semantics ADFs

status parents par (a). paper, represent Ca propositional formula
par (a). mentioned earlier, propositional formulas built using negation ,
conjunction disjunction ; connectives material implication , logical equivalence
exclusive disjunction = regarded abbreviations. specify acceptance
condition, then, take Ca (M par (a)) = hold iff model , |= .
Brewka Woltran (2010) introduced useful subclass ADFs: ADF = (A, L, C)
bipolar iff links L supporting attacking (or both). link (b, a) L supporting iff par (a), Ca (M ) = implies Ca (M {b}) = t.
Symmetrically, link (b, a) L attacking iff par (a),
Ca (M {b}) = implies Ca (M ) = t. link (b, a) supporting attacking
b influence a, link redundant (but violate bipolarity).
sometimes use circumstance searching ADFs; simply assume
L = A, links actually needed expressed acceptance conditions make redundant.
numerous semantics ADFs; interested two them,
(supported) models stable models. set model iff
find iff Ca (M ) = t. definition stable models inspired logic
programming slightly complicated (Brewka et al., 2013). Define operator by4
(X, ) = (ac(X, ), re(X, )) X, A,
ac(X, ) = {a | Z : X Z \ Ca (Z) = t}
re(X, ) = {a | Z : X Z \ Ca (Z) = f }
intuition behind operator follows: pair (X, ) represents partial interpretation set statements X accepted (true), rejected
(false), \ (X ) neither. operator checks statement
whether total interpretations possibly arise (X, ) agree truth
value acceptance condition a. is, accepted matter
statements \ (X ) interpreted, acc(X, ). set rej (X, ) defined
symmetrically, pair (acc(X, ), rej (X, )) constitutes refinement (X, ).
A, reduced ADF DM = (M, LM , C ) defined LM = L
setting
/ ], is, replacing b
/ false
= [b/ : b
acceptance formula a. model stable model iff least fixpoint
operator DM given (M, ). usual, su(D) st(D) denote respective model
sets; ADF models
P-related, ADF stable models cannot. size ADF
given kDk = aA ka k; size kk formula number
nodes.
example ADF D, consider vocabulary = {a, b, c} acceptance formulas
= c, b = c, c = b. single supported model, su(D) = {{a, b, c}},
find st(D) = since atoms model support circularly.
2.4 Translations Formalisms
review known translations mentioned formalisms.
4. operator closely related ultimate approximation operators Denecker, Marek,
Truszczynski (2004), observed earlier (Strass, 2013).

201

fiStrass

2.4.1 AFs BADFs
Brewka Woltran (2010) showed translate AFs ADFs: AF FV= (A, R),
define ADF associated F DF = (A, R, C) C = {a }aA = (b,a)R b
A. Clearly, resulting ADF bipolar: parents always attacking. Brewka
Woltran proved translation faithful AF stable extension ADF
model semantics (Proposition 1). Brewka et al. (2013) later proved AF
stable extension ADF stable model semantics (Theorem 4). easy see
translation computed polynomial time induces linear blowup.
2.4.2 ADFs PL
Brewka Woltran (2010) showed ADFs supported model semantics
faithfully translated propositional logic: acceptance conditions statements represented propositional formulas , supported models
ADF given classical propositional models formula set
= {a | A}.
2.4.3 AFs PL
combination, previous two translations yield

n polynomial
V
fifaithfulotranslation

chain AFs propositional logic: (A,R) =
(b,a)R b .
2.4.4 ADFs LPs
earlier work (Strass, 2013), showed ADFs faithfully translated normal
logic programs. ADF = (A, L, C), standard LP
PD = {a (M (par (a) \ )) | A, Ca (M ) = t}
follows Lemma 3.14 Strass (2013) translation preserves supported
model semantics. translation size-preserving acceptance condition representation Strass (2013) via characteristic models; representing acceptance conditions
via propositional formulas, cannot guaranteed show later.5
2.4.5 AFs LPs
translation chain AFs ADFs LPs compact, faithful AF stable
semantics LP stable semantics (Osorio, Zepeda, Nieves, & Cortes, 2005), AF stable
semantics LP supported semantics (Strass, 2013). size-preserving since single
rule atom contains attackers once: P(A,R) = {a {not b | (b, a) R} | A}.
5. Already complexity reasons, cannot expect translation faithful stable
semantics. indeed, ADF = ({a} , {(a, a)} , {a = a}) stable model {a}
standard logic program P (D) = {a {a} , {not a}} stable model. However, holds
st(P (D)) st(D) (Denecker et al., 2004; Strass, 2013).

202

fiExpressiveness Two-Valued Semantics ADFs

2.4.6 LPs PL
well-known logic programs supported model semantics translated
propositional logic (Clark, 1978). logic program P becomes propositional theory P ,


_
^
^

P = {a | A} =
b
b A.
aBP

bB +

bB

stable model semantics, additional formulas added, extended
translation works (Lin & Zhao, 2004).
2.4.7 LPs ADFs
Clark completion normal logic program directly yields equivalent ADF
signature (Brewka & Woltran, 2010). Clearly translation computable
polynomial time blowup (with respect original logic program)
linear. resulting translation faithful supported model semantics, follows
Lemma 3.16 Strass (2013).
2.5 Representing Bipolar Boolean Functions
bipolarity hitherto predominantly defined used context
ADFs (Brewka & Woltran, 2010), easy define concept Boolean functions
general. Let set atoms f : 2A {t, f } Boolean function. atom
supporting iff A, f (M ) = implies f (M {a}) = t; write sup(f ).
atom attacking iff A, f (M ) = f implies f (M {a}) = f ;
write att(f ). Boolean function f : 2A {t, f } semantically bipolar iff
supporting attacking both. Throughout paper, sometimes take Boolean
function given interpretation set say set bipolar.
define bipolar propositional formulas representing bipolar ADFs.
important study, since (for three-valued semantics), bipolarity
key BADFs low complexity comparison general ADFs (Strass & Wallner, 2015).
now, usually assumed specify bipolar ADF, addition statements,
links acceptance conditions, user specifies link whether supporting
attacking (Strass & Wallner, 2015). introduce arguably simpler way,
support attack represented syntax propositional formula encoding
acceptance function.
Formally, polarity atom formula determined number
negations path root formula tree atom. polarity positive
number even negative number odd.
Definition 4. propositional formula syntactically bipolar
atom occurs positively negatively .
Recall use formulas basis {, , } thus hidden
negations, e.g. material implication. formulas negation normal form (that is,
negation applied atomic formulas), polarities atoms read
formula directly.
203

fiStrass

address question represent bipolar Boolean functions. Clearly
Boolean functions represented propositional formulas; modify construction
later thus reproduce here: Boolean function f : 2A {t, f }, associated
formula
^
^
_

(1)
=

f =


A,f (M )=t

aA\M

is, exactly one model , f enumerates models.
particular, bipolar Boolean functions represented propositional formulas well. However, guarantees us existence representations
gives us way actually obtain them. first fundamental result shows
construct syntactically bipolar propositional formula given semantically bipolar
Boolean function. converse straightforward, thus two notions bipolarity
closely related. formula , associated Boolean function f returns
gets input model .
Theorem 1. Let set atoms.
1. syntactically bipolar formula A, Boolean function f semantically
bipolar.
2. semantically bipolar Boolean function f : 2A {t, f }, syntactically bipolar
formula f = f given
f =

_



=

A,
f (M )=t

^
aM,
aatt(f
/
)



^



(2)

aA\M,
asup(f
/
)

Proof.
1. Obvious: every atom occurring positively supporting, every atom occurring negatively attacking.
2. Let f : 2A {t, f } semantically bipolar. Note first (2),
|= . easy see f syntactically bipolar: Since f
semantically bipolar, is: (1) attacking supporting,
occurs negatively f ; (2) supporting attacking, occurs
positively f ; (3) supporting attacking, occur f .
remains show = f ; show |= f f .
|= f f : Let v : {t, f } v(f ) = t.
f (M ) = v(M ) = t. (Clearly v = vM .) |= get v(M ) =
thus v(f ) = t.
|= f f : model v f , f (M ) =
v(M ) = t. show model f model f , show
f (M ) = t, model v model f . Let |A| = n.
contains exactly n literals. corresponding
k N 0 k n contains exactly n k literals. two
204

fiExpressiveness Two-Valued Semantics ADFs

interpretations v1 : {t, f } v2 : {t, f }, define difference
(v1 , v2 ) = {a | v1 (a) 6= v2 (a)}. (Note |A| = n always
|(v1 , v2 )| n.) use induction k show following:
f (M ) = t, v : {t, f } v(M ) = |(v, vM )| = k
find v(f ) = t. covers models v f (since |(v, vM )| |A|)
thus establishes claim.
k = 0: (v, vM ) = implies v = vM whence v(f ) = vM (f ) = vM (M ) =
definition f .
k
k + 1: Let f (M ) = t, v : {t, f } v(M ) =
|(v, vM )| = k + 1. Since k + 1 > 0, (v, vM ), is,
v(a) 6= vM (a).
(a) supporting attacking. necessarily v(a) = t. (If v(a) = f ,
vM (a) 6= v(a) implies vM (a) = t, is, whence {M } |=
v(M ) = f , contradiction.) Define interpretation w : {t, f }
w(a) = f w(c) = v(c) c \ {a}. Clearly (v, w) = {a}
|(w, vM )| = k. Hence induction hypothesis applies w
w(f ) = t. w(a) = f , v(a) = w(f ) = t. Since supporting, v(f ) = t.
(b) attacking supporting. Symmetric opposite case above.
(c) supporting attacking. Define interpretation w : {t, f }
w(a) = vM (a) w(c) = v(c) c \ {a}. follows
|(w, vM )| = k, whence induction hypothesis applies w
w(f ) = t. Since supporting attacking (thus redundant),
get v(f ) = w(f ) = t.

result paves way analysing succinctness bipolar ADFs, since
quite natural way representing them.

3. Relative Expressiveness
analyse compare relative expressiveness argumentation frameworks
(AFs), (bipolar) abstract dialectical frameworks ((B)ADFs), normal logic programs (LPs)
propositional logic (PL). first look different families semantics supported
stable models isolation afterwards combine results two semantics.
formalisms F {ADF, LP} supported stable semantics,
indicate semantics via superscript Definition 1. AFs consider
stable semantics, (to date) semantics AFs interpretations
guaranteed map arguments either true (accepted) false (rejected, i.e. attacked
accepted argument). propositional logic PL consider usual model semantics.
syntactic translations reviewed previous section, currently
following expressiveness relationships. supported semantics,
AF e BADFsu e ADFsu
=e LPsu e PL
stable semantics,
205

fiStrass

AF e LPst <e PL AF e BADFst e ADFst <e PL
Note LPst <e PL ADFst <e PL hold since sets stable models antichain
property, contrast model sets propositional logic.
succinctness relation,
AF BADFsu ADFsu PL LPsu ADFsu
3.1 Supported Semantics
depicted above, know expressiveness AFs propositional logic
decrease. However, yet clear relationships strict. follows
show two strict, working way top-down least
expressive.
3.1.1 ADF vs. PL
first show ADFs realise set models showing given propositional
formula used construct equivalent ADF linear size.6
Theorem 2. PL e ADFsu PL ADFsu .
Proof. Let propositional formula vocabulary A. Define ADF
setting, A,
= = (a ) (a )
Thus ka k O(kk), whence kD k O(|A| kk). remains toVshow su(D ) = mod ().
Recall ADF A, su(D) = mod (D ) = aA (a ). Applying
definition yields
V
= aA (a (a ))
A, formula (a (a ))Vis equivalent . (The proof case
distinction a.) Thus equivalent aA , is, , follows
su(D ) = mod (D ) = mod ().

example, consider vocabulary = {a, b} propositional formula = b.
canonical construction yields ADF acceptance formulas = (a b)
b = b (a b). have:
= (a b) = (a (a b)) ((a b) a) (a b) b
Intuitively, = b expresses cannot false, true b true.
symmetrical argument, acceptance formula b equivalent b a. readily
checked su(D ) = {{a, b}} desired. Since know Section 2.4.2
converse translation possible (ADFsu PL), get following.
Corollary 3. PL
=s ADFsu
6. consider vocabulary part input, size increase quadratic.

206

fiExpressiveness Two-Valued Semantics ADFs

acceptance conditions written propositional formulas, construction
realise X 2A proof Theorem 2 defines space-efficient equivalent
_
_

=

X,aM

A,M X,a
/

/

acceptance formula a, Footnote 3.
3.1.2 ADF vs. LP
Since ADFs supported semantics faithfully translated logic programs,
likewise translated propositional logic, following.
Corollary 4. ADFsu
=e LPsu
=e PL
However, extend succinctness relation, logic programs stipulate
particular syntactic form essentially fixed-depth circuit. specifically,
easy see language polynomially expressible normal logic programs
supported semantics AC0 . stable semantics so-called canonical logic
programs, recently shown Shen Zhao (2014) (Proposition 2.1).
case interested (supported semantics) works similarly, still present
proof completeness. main technical result towards proving lemma showing
turn logic program equivalent Boolean circuit fixed depth.
Lemma 5. every normal logic program P , exists circuit CP basis
{, , } that:
1. CP accepts supported models P ,
2. size CP linear size P ,
3. CP depth 4.
Proof. Let = {a1 , . . . , } vocabulary P , Clark completion P =
{ai | ai A}
V DNFs literals A. Clearly circuit P
must compute CP = ai (ai ) ai replaced (ai )(ai )
CNF literals A. construction depicted follows,
inner layers shown one only, dotted lines represent potential edges.

ai

...




...



a1

a1

...







ai
...



ai

ai
207

...

...







fiStrass

(1) follows since su(P ) = mod (P ) CP accepts models P .
(2), P contains = |P | rules, kP k total number inner gates
bounded n(2m + 3) n(2 kP k + 3). (3) clear.

statement Lemma 5 actually much stronger gives constant upper
bound resulting circuit depth arbitrarily-sized logic programs, readily follows
set polynomially logic-program expressible languages subset languages
expressible alternating Boolean circuits unbounded fan-in constant depth.
Proposition 6. L polynomially expressible normal logic programs supported
semantics, L AC0 .
follows immediately normal logic programs cannot polynomially express
language Parity.7 supported-semantics counterpart Theorem 3.1 (Shen
& Zhao, 2014).
Corollary 7. Parity polynomial size normal logic program representation.
Proof. Proposition 6 Parity
/ AC0 (Jukna, 2012).



follows propositional logic strictly succinct normal logic programs
supported semantics.
Corollary 8. PL 6s LPsu thus LPsu <s PL.
considerations since Theorem 2, follows small conjunctive
normal form (a conjunction clauses) disjunctive normal form (disjunction monomials) representation, small normal logic program representation
mod ().
3.1.3 ADF vs. BADF
quite obvious canonical ADF constructed Theorem 2 bipolar, since
well every atom mentioned occurs positively negatively .
raises question whether construction adapted bipolar ADFs.
turns subclass bipolar ADFs strictly less expressive. Towards
proof result start new concept: conjugate model set
respect atom. concept used characterise ADF realisability
precisely captures if-and-only-if part ADFs supported model semantics:
translation ADF propositional logic V
(cf. Section 2.4.2) see result
basically conjunction equivalences: = aA (a ). conjunction part
captured set intersection, conjugate capture equivalence part.
Definition 5. Let vocabulary, X 2A A. a-conjugate X set
hai(X) = {M | X, } {M |
/ X,
/ M}
7. Logic programs supported models universally expressive, express Parity,
polynomial size.

208

fiExpressiveness Two-Valued Semantics ADFs

Alternatively, could write hai(X) = {M | X }. Intuitively, hai(X)
contains interpretations containment coincides exactly containment X. Formulated terms propositional formulas, X model set
formula A, hai(X) model set formula . Note vocabulary
implicit conjugate function.
Example 1. Consider vocabulary A2 = {a, b}. functions hai() hbi() operate

set 22 2 interpretation sets A2 shown Table 1.


b
b
b
ab

b

b
a=b
ab
ab
b
ab
ba
>

hai()

b
b
b
ab
>
ab

a=b
b
b
ba
b
ab
ab


hbi()
b
b
b
b
ba
ab
>
a=b



ab
b
ab
ab
b

Table 1: Conjugation functions A2 = {a, b}. Interpretation sets represented using
formulas A2 , connective = denotes exclusive disjunction XOR.
two-valued ADF semantics, conjugation function plays essential semantical
role, since provides bridge models acceptance functions models
ADF. interesting itself: first show properties conjugation
function associated atom, since used proof later on. First
all, involution, is, inverse (and thus particular bijection). Next,
compatible complement operation (logical negation formula level).
Finally, preserves evenness cardinality input set.
Proposition 9. Let vocabulary, X 2A A.
1. hai(hai(X)) = X.

(involution)

2. 2A \ hai(X) = hai 2A \ X .


(compatible negation)

3. |X| even iff |hai(X)| even.

(preserves evenness)

Proof. Let |A| = n, X 2A A.
209

fiStrass

1. Let A.
hai(hai(X)) iff hai(X)
iff (M X )
iff X (a )
iff X
2. Denote
S, = {M | X, }
S,/ = {M | X,
/ M}
S,
= {M |
/ X, }
/
S,
/ X,
/ M}
/
/ = {M |
observe
2A = S, ] S,/ ] S,
/ ] S,
/
/
X = S, ] S,/
hai(X) = S, ] S,
/
/
] denotes disjoint union.

2A \ hai(X) = 2A \ S, ] S,
/
/
= S,/ ] S,
/
= {M | X,
/ } ] {M |
/ X, }






= AfiM
/ 2 \ X,
/ ] 2A \ X,

= hai 2A \ X
3. show |X| + |hai(X)| even. Firstly,
S,/ ] S,
/ } = 2A\{a}
/
/ = {M |



n1 . Thus

whence fiS,/ + fiS,
/
/ =2





|X| + |hai(X)| = |S, | + fiS,/ + |S, | + fiS,
/
/




= 2 |S, | + fiS,/ + fiS,
/
/
= 2 |S, | + 2n1
even.



current purpose characterising expressiveness bipolar ADFs,
use concept conjugation make ADF realisability model semantics slightly
accessible. show ADF realisation model set X n-element
vocabulary equivalently characterised n-tuple (Y1 , . . . , Yn ) supersets X
whose intersection exactly X. crux proof result acceptance
conditions realising ADF Yi related conjugation function.
210

fiExpressiveness Two-Valued Semantics ADFs

Proposition 10. Let = {a1 , . . . , } vocabulary X 2A set interpretations. Denote ADF sequence (1 , . . . , n ) acceptance formulas (for
{1, . . . , n}, formula acceptance formula ai ), define
CX = {(mod (1 ), . . . , mod (n )) | su(1 , . . . , n ) = X}

(
!
)
n

\

YX = (Y1 , . . . , Yn ) Y1 , . . . , Yn 2A ,
Yi = X

i=1

sets CX YX one-to-one correspondence; particular |CX | = |YX |.
Proof. provide bijection CX YX . Consider function
n
n
(B1 , . . . , Bn ) 7 (ha1 i(B1 ) , . . . , han i(Bn ))
22
f : 22
involution Proposition 9. Using results Section 2.4.2, get
(mod (1 ), . . . , mod (n )) CX iff su(1 , . . . , n ) = X


^
iff mod
(ai ) = X
1in

iff

\

mod (ai ) = X

1in

iff

\

hai i(mod (i )) = X

1in

iff (ha1 i(mod (1 )) , . . . , han i(mod (n ))) YX
iff f (mod (1 ), . . . , mod (n )) YX
Thus f (CX ) = YX whence f (YX ) = f (f (CX )) = CX f |CX : CX YX bijective.



one-to-one correspondence important since later analyse precise
number realisations given model sets. Furthermore, result shows role
conjugation function characterising two-valued model realisability general ADFs.
adapt characterisation result case bipolar ADFs. precisely,
give several necessary sufficient conditions given model set bipolarly realisable.
characterisation hand, later show specific interpretation set fails
necessary conditions thus cannot model set BADF.
Below, fiwe denote

set supersets set X interpretation sets X = 2A X .
Proposition 11. Let = {a1 , . . . , } vocabulary X 2A set interpretations. following equivalent:
1. X bipolarly realisable.
2. exist Y1 , . . . , Yn X that:

(a) ( ni=1 Yi ) = X,
211

fiStrass

(b) 1 n, set hai i(Yi ) bipolar.
3. exist Y1 , . . . , Yn X

(a) ( ni=1 Yi ) = X,
(b) 1 i, j n, least one :
A, (M Yi ai ) (M {aj } Yi ai {aj });
N A, (N Yi = ai N ) (N {aj } Yi = ai N {aj }).
Proof. (1) (2): X bipolarly realisable, exists bipolar ADF = (A, L, C)
su(D) = X. particular, exist bipolar Boolean functions C1 , . . . , Cn
X 1 n find ai iff Ci (M ) = t.
1 n define YT
= hai i(Ci ). assumption, hai i(Yi ) = hai i(hai i(Ci )) = Ci bipolar; furthermore ( ni=1 Yi ) = X follows above.
(2) (3): Let {1, . . . , n} assume hai i(Yi ) bipolar. means
aj A, find aj supporting attacking (or both) hai i(Yi ). aj
supporting haj i(Yi ) iff find:
hai i(Yi ) {aj } hai i(Yi ) , is,
(M Yi ai ) (M {aj } Yi ai {aj })
Similarly, aj attacking hai i(Yi ) iff N find:
N
/ hai i(Yi ) N {aj }
/ hai i(Yi ) , is,
(N Yi ai N ) (N {aj } Yi ai N {aj })
Thus aj A, find least one following:
A, (M Yi ai ) (M {aj } Yi ai {aj });
N A, (N Yi = ai N ) (N {aj } Yi = ai N {aj }).
(3) (1): construct ADF = (A, L, C) follows: {1, . . . , n} define Ci = hai i(Yi ) finally set L = A. Ci bipolar equivalences
established previous proof item, su(D)
= X follows fact
hai i(Ci ) = hai i(hai i(Yi )) = Yi presumption ( ni=1 Yi ) = X.


apply characterisation result show interpretation set
three atoms cannot realised bipolar ADFs model semantics.
smallest example terms number atoms (actually, one two smallest
examples) interpretation sets binary vocabulary bipolarly realisable.
Proposition 12. vocabulary A3 = {1, 2, 3}, bipolar ADF realises
X = Even3 = {, {1, 2} , {1, 3} , {2, 3}}.
212

fiExpressiveness Two-Valued Semantics ADFs

Proof. Assume contrary X bipolarly realisable. exist Y1 , Y2 , Y3 X

Proposition 11. 2|2 ||X| = 284 = 24 = 16 candidates Yi , is,
every Yi must form X ] Z
Z {{1} , {2} , {3} , {1, 2, 3}} = 2A \ X
eleven sixteen model set candidates Yi , set hii(Yi )
bipolar. show model set hii(Yi ) bipolar, provide statement j A3
neither supporting attacking; say statement dependent.
1. Y1 = X, get h1i(Y1 ) = {{1, 2} , {1, 3} , {2} , {3}}, bipolar since
statement 2 dependent: 2 supporting, {3} h1i(Y1 ) would imply
{2, 3} h1i(Y1 ); 2 attacking,
/ h1i(Y1 ) would imply {2}
/ h1i(Y1 ).
remaining cases, justifications specific statement dependent
equally easy read model set; brevity indicate statements.
2. Y1 = X {{1}}, get h1i(Y1 ) = {{1, 2} , {1, 3} , {1} , {2} , {3}},
bipolar since statement 2 dependent.
3. Y1 = X {{2}}, get h1i(Y1 ) = {{1, 2} , {1, 3} , {3}}, bipolar since
statement 2 dependent.
4. case Y1 = X {{3}} symmetric previous one: get model set
h1i(Y1 ) = {{1, 2} , {1, 3} , {2}}, bipolar since statement 3 dependent.
5. Y1 = X {{1, 2, 3}}, get h1i(Y1 ) = {{1, 2, 3} , {1, 2} , {1, 3} , {2} , {3}},
bipolar since statement 2 dependent.
6. Y1 = X {{1} , {2}}, get h1i(Y1 ) = {{1, 2} , {1, 3} , {1} , {3}},
bipolar since statement 3 dependent.
7. case Y1 = X {{1} , {3}} symmetric previous one.
8. Y1 = X {{2} , {3}}, get h1i(Y1 ) = {{1, 2} , {1, 3}}, bipolar since
statement 2 dependent.
9. Y1 = X {{1} , {1, 2, 3}}, get h1i(Y1 ) = {{1, 2, 3} , {1, 2} , {1, 3} , {1} , {2} , {3}},
bipolar since statement 2 dependent.
10. Y1 = X {{2} , {1, 2, 3}}, get h1i(Y1 ) = {{1, 2, 3} , {1, 2} , {1, 3} , {3}},
bipolar since statement 2 dependent.
11. Y1 = X {{3} , {1, 2, 3}} symmetric previous case.
remains set C five candidates (due symmetry i):
C = {X ] {{1} , {2} , {3}} ,
X ] {{1} , {2} , {1, 2, 3}} ,
X ] {{1} , {3} , {1, 2, 3}} ,
X ] {{2} , {3} , {1, 2, 3}} ,
X ] {{1} , {2} , {3} , {1, 2, 3}}}
213

fiStrass

Basically, candidates least three four interpretations
= {{1} , {2} , {3} , {1, 2, 3}} contained addition already X. clearly
assumption Yi realise X
1 , Y2 , Y3
C.
T3
Yi 1 3 thus
i=1 Yi = X. However, X = .
Contradiction. Thus Yi exist X bipolarly realisable.

interpretation set A3 bipolarly realisable, found
complement Even3 above, Parity language three atoms.
Proposition 13. vocabulary A3 = {1, 2, 3}, bipolar ADF realises
Parity3 = {{1} , {2} , {3} , {1, 2, 3}}.
Together straightforward statement fact Even3 realised
non-bipolar ADF, Proposition 12 leads next result.
Theorem 14. BADFsu <e ADFsu
Proof. Model set Even3 Proposition 12 realisable model semantics ADF
DEven3 acceptance conditions
1 = (2 = 3),

2 = (1 = 3),

3 = (1 = 2)

However, bipolar ADF realising Even3 , witnessed Proposition 12.



Another consequence characterisation two-valued model realisability Proposition 10 get precise number distinct realisations given model set.
significant illustrates rather intricate difficulty underlying bipolar non-realisability: cannot necessarily use model set Even3 determine
single reason bipolar non-realisability, is, single link (b, a) neither supporting attacking realisations. Rather, culprit(s) might different
realisation, show bipolar non-realisability, prove realisations,
necessarily exists reason non-bipolarity. number different ADF
realisations given model set X considerable.8

Proposition

15. Let vocabulary |A| = n, X 2 interpretation set
fi2 \ X = m. number distinct ADFs su(D) = X

r(n, m) = (2n 1)m
Proof. According Proposition
10,T realisation
tufi
X characterised
n
n tuples.
ple (Y1 , . . . , Yn ) X X = ni=1 Yi . Since fiX = 2m , (2m )T
However,Ttowards r(n, m), wrongly counts tuples (Y1 , . . . , Yn ) ( ni=1 Yi ) ) X,
is, |( ni=1 Yi ) \ X| > 0 (at least once); remains subtract
{1, . . . , n},
n them.
overestimate number tuples (Y1 , . . . , Yn ) X |( ni=1 Yi ) \ X|
expression

n

q(n, m, i) =
2mi
(3)

8. counting ADFs A, take account different link relations, take L =
count different acceptance functions, redundant links modelled.

214

fiExpressiveness Two-Valued Semantics ADFs


seen follows: Let 2A \ X fixed i-element set. (Intuitively, interpretation-set X contains
interpretations many.)
mi sets.
exactly


n
I, fiI = 2mi . Thus 2mi possible ways choose n
elements (the Y1 , . . . , Yn ) . matter Yj chosen, intersection
contains thus least elements many. However, sets least
+ 1 elements many counted twice subtracted. subtract
q(n, m, + 1), counted sets least + 2 elements many
add q(n, m, + 2),
inclusion-exclusion principle, number
n etc. Hence

tuples (Y1 , . . . , Yn ) X ni=1 Yi = X given
r(n, m) = q(n, m, 0) q(n, m, 1) + q(n, m, 2) . . . q(n, m, m)

X
=
(1)i q(n, m, i)
i=0

X


n

=
(1)
2mi

i=0



X
=
(2n )mi (1)i



(by (3) above)
(reordering factors)

i=0
n

= (2 1)m

(binomial theorem)

main contributing factor number interpretations excluded
desired model set X. Proposition 12, instance, (23 1)4 = 74 = 2401
ADFs model set Even3 . According Theorem 14, none bipolar. Obvin
ously, maximal number realisations achieved X = whence r(n, 2n ) = (2n 1)2 .
hand, model set X = 2A exactly one realisation, r(n, 0) = 1. Note
number (syntactically distinct) realisations universally expressive
formalisms, logic programs propositional logic, unbounded general since
add arbitrary number tautologies.
finally show reduction problem bipolar realisability propositional
satisfiability. approaches problem another angle (a possible implementation
deciding bipolar realisability using SAT solver), provides proof Theorem 3
Strass (2015b), contained work.
given vocabulary set X 2A set interpretations, aim
construct propositional formula X satisfiable X bipolarly
realisable. propositional signature use following: A,
propositional variable pM
expresses whether Ca (M ) = t. allows
encode possible acceptance conditions statements A. enforce bipolarity,
use additional variables model supporting attacking links: a, b A,
a,b
variable pa,b
sup saying supports b, variable patt saying attacks b.
vocabulary X given

n

a,b
a,b
P = pM
,
p
,
p


A,


A,
b




sup att
guarantee desired set models, constrain acceptance conditions dictated
X: desired set statement a, containment must correspond
215

fiStrass

exactly whether Ca (M ) = t; encoded
X . Conversely, undesired set
/
statement a, must correspondence,
X expresses.
enforce bipolarity, state link must supporting attacking. model
meaning support attack, encode ground instances definitions.
Definition 6. Let vocabulary X 2A set interpretations. Define
following propositional formulas:

/
BADF
=
X
X X bipolar


^
^
^


pM

pM


X =
X



aA\M




^

/

X =

_


A,M X
/

bipolar =

^

_

pM





pM


aA\M



a,b
a,b
a,b
pa,b
sup patt sup att



a,bA

a,b
sup

= pa,b
sup

a,b
att

pa,b
att

^



(a, b A)



(a, b A)

{a}

pM
b pb



=



^

{a}

pb

pM
b



corresponding result shows reduction correct.
Theorem 16. Let vocabulary X 2A set interpretations. X bipolarly
realisable BADF
satisfiable.
X
Proof. if: Let P model X . A, define acceptance condition follows: A, set Ca (M ) = iff pM
I. easy see bipolar
guarantees acceptance conditions bipolar. ADF given
su = (A, A, C). remains show model su
DX
X
X.
su . Consider A.
if: Let X. show model DX

1. . Since model
X , pa thus definition
Ca (M ) = t.
/ thus definition
2. \ . Since model
X , pa
Ca (M ) = f .
/
if: Let
/ X. Since model
X ,
Ca (M ) = f
/ Ca (M ) = t. case, model
su .
DX

if: Let bipolar ADF su(D) = X. use define model X .
First, A, set pM
iff Ca (M ) = t. Since bipolar, link
supporting attacking a, b find valuation pa,b
sup
pa,b
.

remains

show




model


.
X
att
216

fiExpressiveness Two-Valued Semantics ADFs

1. model
X : Since realises X, X model thus
Ca (M ) = iff .
/
2. model
/ X model
X : Since realises X,
D. Thus , witnessing model
D: (1) Ca (M ) = f , (2)
/ Ca (M ) = t.

3. model bipolar : straightforward since bipolar assumption.



Remarkably, decision procedure give answer, case
positive answer read BADF realisation satisfying evaluation
constructed formula. illustrate construction example seen earlier.
Example 2. Consider A3 = {1, 2, 3} model set Even3 = {, {1, 2} , {1, 3} , {2, 3}}.
construction Theorem 16 yields formulas:
{1}





Even3 = p1 p2 p3
{1,2}

p2

{1,3}

p2

p1
p1

{1,2}

{2,3}

p1

/

Even3 = (p1
{1,2}



(p1

{1,3}



(p1

p3

{1,3}

p3

{2,3}

p3

p2

{2,3}

{1}

p3 )

{2}

p2

{1}

{2}

p2

p3 )

{3}

p2

{3}

p3 )

{1,2,3}

(p1

{2}

{3}

{1,2,3}

p2

{1,2,3}

p3

)

remaining formulas bipolarity independent Even3 , show
here. implemented translation proof Theorem 16 used solver
clasp (Gebser, Kaminski, Kaufmann, Ostrowski, Schaub, & Schneider, 2011) verify
Even3 unsatisfiable.
3.1.4 BADF vs. LP
Earlier, used language Parity show propositional logic (and thus
PL
=s ADFsu general ADFs are) exponentially succinct normal logic programs
(under supported models). However, bipolar ADFs, Proposition 13 BADF
A3 = {1, 2, 3} model set su(D) = Parity3 = {{1} , {2} , {3} , {1, 2, 3}}, is,
BADFs cannot even express Parity. Fortunately, Majority language trick
case.
Theorem 17. BADFsu 6s LPsu
Proof. show language Majority polynomially expressed BADFsu ,
LPsu . latter fact follows Majority
/ AC0 (Jukna, 2012) Proposition 6. show first part constructing series BADFs Dn = {a1 , . . . , }
(n N, n 1) su(Dn ) = Majorityn . use results (Friedman, 1986; Boppana, 1986), show positive n N k n, language Thresholdn,k
negation-free propositional formulas Threshold
polynomial size s, use
n,k


4.27
bound Boppana, k n log n . Define D1 a1 = >, n 2 set k = n2
1 n,
ai = ai Threshold
(a1 , . . . , ai1 , ai+1 , . . . , )
n1,k
217

fiStrass

Intuitively, formula ai checks whether remaining variables could achieve majority
without ai . so, ai set arbitrarily; otherwise, ai must set true. Clearly
Boolean function computed ai bipolar, since ai supporting parents
attacking. size Dn , observe


kDn k n Threshold
n1,k

whence overall size polynomial. remains show su(Dn ) = Majorityn .
: Let Majorityn . show su(Dn ), is, iff |=
. , immediate |= , let aj
/
j {1, .. . ,n}. show 6|= aj . Since Majorityn , |M | =
k = n2 n 1 Thresholdn1,k , is,
|= Threshold
(a1 , . . . , aj1 , aj+1 , . . . , )
n1,k
Together 6|= aj , follows 6|= aj .

: Let
/ Majorityn . |M | = 0 < n2 = k. particular,
aj \ . < k implies N Thresholdn1,k
(a1 , . . . , aj1 , aj+1 , . . . , ) whence follows
|N | = = |M |. Thus 6|= Threshold
n1,k
|= aj . Together 6|= aj conclude
/ su(Dn ).

Since every BADF ADF size, get:
Corollary 18. ADFsu 6s LPsu
combination translation logic programs ADFs (implying relation
LPsu ADFsu ), means ADFs strictly succinct logic programs.
Corollary 19. LPsu <s ADFsu
3.1.5 BADF vs. AF
comparably easy show BADF models strictly expressive AFs,
since sets supported models bipolar ADFs antichain property.
Proposition 20. AF <e BADFsu
Proof. Consider vocabulary = {a} BADF = (A, {(a, a)} , {a }) = a.
straightforward check model set su(D) = {, {a}}. Since model sets AFs
stable extension semantics satisfy antichain property, equivalent AF
A.

yields following overall relationships:
AF <e BADFsu <e ADFsu
=e LPsu
=e PL
concise overview relative succinctness, present results open problems
glance Table 2 below.9
9. remark three open problems Table 2 really two: easy show ADFs
propositional logic behave equivalently relation bipolar ADFs, since equally expressive
equally succinct; is, holds ADFsu BADFsu PL BADFsu .

218

fiExpressiveness Two-Valued Semantics ADFs

su

BADF
ADFsu
LPsu
PL

BADFsu
=
?
?
?

ADFsu

=
<s

=s

LPsu
6s
6s
=
6s

PL


=s
<s
=

Table 2: Relative succinctness results (bipolar) ADFs model semantics, normal
logic programs supported semantics, classical propositional logic. entry
row F1 column F2 means F1 F2 .
3.2 Stable Semantics
before, recall current state knowledge:
AF e BADFst e ADFst <e PL AF e LPst <e PL
first show BADFs strictly expressive AFs.
Proposition 21. AF <e BADFst
Proof. Consider set X2 = {{a, b} , {a, c} , {b, c}} desired models. Dunne et al. (2015)
proved X2 realisable stable AF semantics. However, model set X2
realisable BADF DX2 stable semantics:
= b c,

b = c,

c = b

Let us exemplarily show = {a, b} stable model (the cases completely
symmetric): reduct DM characterised two acceptance formulas = b
b = . easily find DM (, ) = (M, ) = DM (M, ).

Intuitively, argument AF non-realisability X2 follows: Since b occur
extension together, attack them. holds
pairs a, c b, c. set {a, b, c} conflict-free thus must stable
extension containing three arguments, allowed X2 . reason AFs
restriction individual attack, set attack (also called joint collective attack) suffices
realise X2 seen above.
construction used proof realize X2 comes work
Eiter, Fink, Puhrer, Tompits, Woltran (2013) logic programming,
generalised realise non-empty model set satisfying antichain property.
st = (A, L, C) C
Definition 7. Let X 2A . Define following BADF DX

given


_
^

=
b
X,aM

bA\M

thus L = {(b, a) | X, M, b \ }.
219

fiStrass

next result shows construction indeed works.
st ) = X.
Theorem 22. Let X =
6 X 2A -antichain. find st(DX

Proof. Let A.
st ) st(D st ); use case distinction.
: Let
/ X. show
/ su(DX
X

1. N X ( N . N \ . Consider
acceptance
V formula . Since N N X, formula disjunct
a,N = bA\N b. N implies \ N \ model
st ).
a,N . Thus model although
/ , hence
/ su(DX
2. N X, 6 N . X 6= implies 6= , let .

V N X N , acceptance formula contains disjunct
a,N = bA\N b. assumption, N X bN \ N .
Clearly bN \ N bN evaluated true . Hence N X
N , disjunct a,N evaluated false . Thus false
st ).

/ su(DX
st ), is: A, find
: Let X. first show su(DX
iff model .
st
1. Let .
V construction, DX contains disjunct
form a,M = bA\M b. According interpretation , b \
false thus a,M true whence true.

2. Let \ consider acceptance formula . Assume contrary
model V
. N X N
model a,N = bA\N b, is, \ N \ . Hence N ; and,
since N \ , even ( N , whence X -antichain. Contradiction.
Thus model .
st respect . There, contains
consider reduct DM DX


disjunct a,M = a,M [b/ : b
/ ] b \ replaced false,
= . . . equivalent true. Thus true
whence a,M

st ).
least fixpoint DM thus st(DX


restriction non-empty model sets immaterial relative expressiveness, since
use construction Theorem 2 fact st(D) su(D) ADF
realize empty model set. stable model semantics ADFs logic programs
antichain property, get:
Corollary 23. ADFst e BADFst LPst e BADFst
leads following overall relationships:
AF <e BADFst
=e ADFst
=e LPst <e PL
remark antichain property provides characterisation realisability
stable semantics; is, model set stable-realisable iff -antichain.
220

fiExpressiveness Two-Valued Semantics ADFs

3.3 Supported vs. Stable Semantics
put supported stable pictures together. proof Theorem 22,
st antichain X, supported
read canonical realisation DX
st ) = st(D st ) = X. observation,
stable semantics coincide, is, su(DX
X
bipolar ADFs supported semantics realize antichain, this:
Proposition 24. BADFst e BADFsu
seen Proposition 20, bipolar ADFs supported-model sets
antichains. get:
Corollary 25. BADFst <e BADFsu
result allows us close last gap put together big picture relative
expressiveness Figure 2 below.
ADFsu
=e PL
=e LPsu
BADFsu
BADFst
=e LPst
=e ADFst
AF
Figure 2: expressiveness hierarchy. Expressiveness strictly increases bottom
top. F denotes formalism F semantics , su supported st
stable model semantics; formalisms among AFs (argumentation frameworks), ADFs
(abstract dialectical frameworks), BADFs (bipolar ADFs), LPs (normal logic programs)
PL (propositional logic).

4. Allowing Vocabulary Expansion
here, considered compact realisations, introduce new vocabulary elements. section, allow introduction small number new
atoms/arguments/statements. precisely, small means number linear
size source knowledge base (representing model set wish realize
target language). purpose realisability, new vocabulary elements projected
resulting models.
turns out, adding additional arguments already makes AFs universally expressive
(under projection). technically, show propositional formula
vocabulary A, exists AF F expanded vocabulary
models stable extensions F correspond one-to-one. Roughly,
possible since AFs regarded syntactic variant classical propositional
logic connective logical (Gabbay, 2011; Brewka et al.,
2011). Using connective, negation expressed = disjunction
221

fiStrass

= ( ) = ( ) ( ). equivalences used translate arbitrary propositional formulas (over , , ) syntactical -fragment; guarantee
size increase linear, introduce names subformulas (Tseitin,
1968). next definition combines ideas.
Definition 8. Let formula using , , vocabulary A. Define sets
R inductively follows:
A> = {a> }

R> =

= {a }

R = {(a , )}

Ap = {p, ap } p

Rp = {(p, ap ), (ap , p)} p

= {a }

R = {(a , )} R

= {a , , } R = {(a , ), (a , )} R R
= {a , }

R = {(a , ), (a , ), (a , )} R R

AF associated given F = (A , R {(a , )} R ).
argument a> unattacked thus part every stable extension (is true every
interpretation); argument attacks thus cannot part stable extension (is false every interpretation). mutually attacking arguments p ap
p serve guess valuation A, guarantee (and all)
valuations models lead stable extensions F : intuitively, must
attacked, candidate . arguments attacks Boolean
connectives express usual truth-theoretic semantics, first technical result
translation shows.
Lemma 26. Let formula vocabulary F associated AF.
stable extension F , , have:
iff
/ M;
iff ;
iff one ;
iff neither .
Proof.
definition, attacker argument form argument
. Thus iff
/ M.
attackers arguments . case above,
iff
/ , iff
/ . Consequently, iff

/
/ iff .
attacker argument . Similarly previous cases,
show iff
/
/ , iff
/ .
combination, iff .
222

fiExpressiveness Two-Valued Semantics ADFs

attackers arguments . directly follows
iff neither .

correspondences used show induction newly introduced
arguments capture semantics formulas encode (for subformulas ).
Lemma 27. Let formula F associated AF. stable extension
F , iff model .
Proof. Let stable extension F . use structural induction .
= >: Trivial: a> since attackers.
= : Trivial:
/ since set {a } conflict-free.
= p A: Trivial: p iff |= p definition.
= : iff iff
/ iff 6|= iff |= iff |= .
= : iff iff iff |= |= iff |=
iff |= .
= : iff iff iff |= |= iff |=
iff |= .
= : iff iff
/
/ iff 6|= 6|= iff |=
iff |= .

lets us show main result section, namely AF stable extension
semantics universally expressive projection.
Theorem 28. Let formula vocabulary F associated AF.
1. model , exists stable extension E F = E A.
2. stable extension E F , set E model .
Proof.

1. Let model . Define set
E = {a | , |= }

Observe = E A. presumption, E. remains show E
stable extension, is, E conflict-free attacks arguments b
/ E.
E conflict-free: Assume contrary attack r = (a, b) R
a, b E. definition, cases:
arbitrary b = . definition E get |= ,
contradiction.
r = (p, ap ) r = (ap , p) p A. definition E get
|= p |= p, contradiction.
223

fiStrass

r = (a , ). definition E get |= |= ,
contradiction.
r = (a , ) r = (a , ). |= , |= |= ,
contradiction.
r = (a , ). |= , whence |= ( ). |= ,
contradiction.
r = (a , ) r = (a , ). |= , |= |= .
|= , contradiction.
E attacks arguments E: Let b (A {a }) \ E argument.
definition, formula b = 6|= . use structural
induction.
= E attacks definition.
= , |= whence E attacks definition.
= , |= |= whence E E.
case, E attacks definition.
= , |= whence E attacks definition.
= , |= whence E E.
case, E attacks definition.
2. Let E stable extension F . Since E conflict-free,
/ E. Since E stable,
E attacks , yields E. Lemma 27, E model .

particular, F stable extension iff unsatisfiable. shows
construction Definition 8 works intended, remains show number new
arguments linear formula size. even show total increase
size linear, thus number new arguments linear.
Proposition 29. formula , find kF k O(kk).
Proof. first note
kF k = k(A , R {(a , )} R )k
= |A | + |R {(a , )} R |
= |A | + 1 + |R | + 2
= |A | + |R | + 3
use structural induction show formulas , find |A | 5 kk
|R | 4 kk. follows kF k (5 + 4) kk + 3 = 9 kk + 3 O(kk).
= >:
|A> | = |{a> }| = 1 5 = 5 k>k
|R> | = || = 0 4 = 4 k>k
224

fiExpressiveness Two-Valued Semantics ADFs

= :
|A | = |{a }| = 1 5 = 5 kk
|R | = |{(a , )}| = 1 4 = 4 kk
= A:
|Aa | = |{a, aa }| = 2 5 = 5 kak
|Ra | = |{(a, aa ), (aa , a)}| = 2 4 = 4 kak
= :
|A | = |A {a }| |A | + 1 (5 kk) + 1 5 (kk + 1) = 5 kk
|R | = |R {(a , )}| |R | + 1 (4 kk) + 1 4 (kk + 1) = 4 kk
= :
|A | |A | + |A | + 3 (|A | + 1) + (|A | + 1) + 3
(5 kk + 1) + (5 kk + 1) + 3 = 5 kk + 5 kk + 5
= 5 (kk + kk + 1) = 5 k k
|R | |R | + |R | + 2 (|R | + 1) + (|R | + 1) + 2
(4 kk + 1) + (4 kk + 1) + 2 = 4 kk + 4 kk + 4
= 4 (kk + kk + 1) = 4 kk
= :
|A | |A | + |A | + 2 5 kk + 5 kk + 2
5 kk + 5 kk + 5 = 5 (kk + kk + 1) = 5 kk
|R | |R | + |R | + 3 (4 kk) + (4 kk) + 3
4 kk + 4 kk + 4 = 4 (kk + kk + 1) = 4 kk



Hence projection, AF stable extension semantics realise much propositional logic can. results previous section (AF e PL), means
allowing introduce linear number new vocabulary elements (that later projected
out), languages considered paper equally (universally) expressive.
However, must note equal expressiveness mean equal efficiency:
assume knowledge base size n leads search space size O(2n ),
linear increase knowledge base size (that is, n c n constant c) leads
polynomial increase search space size (that is, O(2n ) O(2cn ) = O((2n )c ).
225

fiStrass

5. Discussion
compared expressiveness abstract argumentation frameworks, abstract dialectical
frameworks, normal logic programs propositional logic. showed expressiveness
different semantics varies formalisms obtained neat expressiveness hierarchy. results inform us capabilities languages encode sets
two-valued interpretations, help us decide languages use specific applications. Furthermore, seen results sensitive vocabulary one
permitted use, hierarchy collapses allow introduce even linear
number new atoms.
Concerning succinctness, shown ADFs (under model semantics) exponentially succinct normal logic programs (under supported model semantics),
even bipolar ADFs (under model semantics) although less expressive
succinctly express model sets equivalent normal logic programs (under supported model semantics) vocabulary must necessarily blow exponentially
size. open whether converse direction holds, is, whether BADFs
exponentially succinct logic programs (if LPsu BADFsu ) two
mutually incomparable terms succinctness (if LPsu 6s BADFsu ). stable semantics, relative succinctness logic programs BADFs completely open, partly due
technical aspect two stable semantics conceptually different, ADFs
fact employ ultimate stable models (Denecker et al., 2004; Brewka et al., 2013; Strass
& Wallner, 2015). Furthermore, general ADFs, computational complexity
model existence problem stable semantics higher normal logic programs,10
succinctness comparison regard stable models would limited significance.
easy see AFs somewhat special role representationally
succinct case: vocabulary , syntactically possibility specify knowledge base (an AF) exponential size, since largest AF size
k(An , )k = n + n2 thus polynomially large. anything expressed AF expressed reasonable space definition. However,
strength AFs taken grain salt, since comparably inexpressive. (in addition results presented) already seen simple
counting argument: even syntactically different AFs semantically differ2
ent (which not), could express 2n different model sets,
n
increasing n negligible relation 22 possible model sets .
original paper, Gogic et al. (1995) used relaxed version succinctness,
allowed introduce linear number new variables. follows results
Section 4 formalisms consider equally succinct relaxed
notion.
Parts expressiveness results normal logic programs carry LP
classes. example, canonical logic programs provide limited form nesting allowing
literals form rule bodies (Lifschitz et al., 1999). makes quite easy
see normal logic programs supported semantics translated equivalent
canonical logic programs, namely replacing positive body atom
10. P
2 -hard ADFs (Strass & Wallner, 2015) opposed NP normal LPs (Bidoit & Froidevaux,
1991; Marek & Truszczynski, 1991).

226

fiExpressiveness Two-Valued Semantics ADFs

rule bodies. Recently, Shen Zhao (2014) showed canonical logic programs
propositional logic programs succinctly incomparable (under assumption11 ),
provide interesting avenues succinctness studies. add succinctness
questions own: firstly comparing disjunctive logic programs stable
models general ADFs stable models, since two equally complex
(P2 -complete) model existence problem (Eiter & Gottlob, 1995; Brewka et al., 2013).
more, alternative proposals stable model semantics ADFs:
(Strass, 2013) (Definition 3.2, later called approximate stable models Strass
& Wallner, 2015), model existence NP-complete (Strass & Wallner, 2015)
thus potentially easier stable models Brewka et al. (2013)
(called ultimate stable models Strass & Wallner, 2015);
grounded model semantics Bogaerts, Vennekens, Denecker (2015) (Definition 6.8), whose model existence problem P2 -complete (Bogaerts et al.,
2015);
F-stable model semantics Alviano Faber (2015) (Definition 10).
follows Theorem 5.9 Bogaerts et al. (2015) grounded models F-stable
models coincide. Still, demonstrably different approximate ultimate stable models ADFs (Alviano & Faber, 2015),12 relative succinctness
comparison normal/disjunctive logic programs unanalysed.
potential work. First all, nice characterisation bipolar
ADF realisability still missing; unsure whether much improvement Proposition 11 possible. Incidentally, AFs exact characterisation compact stable extension realisability constitutes major open problem (Dunne et al., 2015; Baumann et al.,
2014). Second, semantics abstract dialectical frameworks whose expressiveness could studied; Dunne et al. (2015) Dyrkolbotn (2014) already analyse many
argumentation frameworks. work thus start
done remaining semantics. example admissible, complete preferred
semantics defined AFs, (B)ADFs LPs (Strass, 2013; Brewka et al., 2013),
Puhrer (2015) already made huge step direction characterising realisability. Third, formalisms abstract argumentation (Brewka et al., 2014)
whose expressiveness large unexplored best knowledge. Finally,
representational succinctness subclass bipolar ADFs (using bipolar propositional
formulas represent them) supported model semantics mostly open (cf. Table 2),
evidence pointing toward meaningful capabilities.

Acknowledgements
paper combines, extends improves results previous work (Strass, 2014,
2015b, 2015c). wish thank Stefan Woltran providing useful pointer related
1
11. P 6 NC/poly
, Boolean circuit equivalent assumption NP 6 P.
12. terminology Alviano Faber (2015), approximate stable models (Strass, 2013) called
S-stable models ultimate stable models (Brewka et al., 2013) called B-stable models.
shown different F-stable models.

227

fiStrass

work realisability logic programming, Bart Bogaerts pointing grounded
models F-stable models same, Jorg Puhrer several suggestions improvement manuscript, Frank Loebe helpful discussions. research partially
supported Deutsche Forschungsgemeinschaft (DFG, project BR 1817/7-1).

References
Al-Abdulkarim, L., Atkinson, K., & Bench-Capon, T. J. M. (2014). Abstract dialectical
frameworks legal reasoning. Hoekstra, R. (Ed.), Proceedings TwentySeventh Annual Conference Legal Knowledge Information Systems (JURIX),
Vol. 271 Frontiers Artificial Intelligence Applications, pp. 6170. IOS Press.
Al-Abdulkarim, L., Atkinson, K., & Bench-Capon, T. J. M. (2015). Evaluating approach
reasoning cases using abstract dialectical frameworks. Proceedings
Fifteenth International Conference Artificial Intelligence Law (ICAIL).
Alviano, M., & Faber, W. (2015). Stable model semantics abstract dialectical frameworks revisited: logic programming perspective. Yang, Q., & Wooldridge, M.
(Eds.), Proceedings Twenty-Fourth International Joint Conference Artificial
Intelligence (IJCAI), pp. 26842690, Buenos Aires, Argentina. IJCAI/AAAI.
Arora, S., & Barak, B. (2009). Computational Complexity: Modern Approach. Cambridge
University Press.
Baumann, R., Dvorak, W., Linsbichler, T., Strass, H., & Woltran, S. (2014). Compact
argumentation frameworks. Proceedings Twenty-First European Conference
Artificial Intelligence (ECAI), pp. 6974, Prague, Czech Republic.
Bidoit, N., & Froidevaux, C. (1991). Negation default unstratifiable logic programs.
Theoretical Computer Science, 78 (1), 85112.
Bogaerts, B., Vennekens, J., & Denecker, M. (2015). Grounded fixpoints applications knowledge representation. Artificial Intelligence, 224, 5171.
Boppana, R. B. (1986). Threshold functions bounded depth monotone circuits. Journal
Computer System Sciences, 32 (2), 222229.
Brewka, G., Dunne, P. E., & Woltran, S. (2011). Relating semantics abstract dialectical frameworks standard AFs. Proceedings Twenty-Second International
Joint Conference Artificial Intelligence (IJCAI), pp. 780785. IJCAI/AAAI.
Brewka, G., Ellmauthaler, S., Strass, H., Wallner, J. P., & Woltran, S. (2013). Abstract
dialectical frameworks revisited. Proceedings Twenty-Third International
Joint Conference Artificial Intelligence (IJCAI), pp. 803809. IJCAI/AAAI.
Brewka, G., & Gordon, T. F. (2010). Carneades abstract dialectical frameworks: reconstruction. Proceedings Third International Conference Computational
Models Argument (COMMA), Vol. 216 FAIA, pp. 312. IOS Press.
Brewka, G., Polberg, S., & Woltran, S. (2014). Generalizations Dung frameworks
role formal argumentation. IEEE Intelligent Systems, 29 (1), 3038. Special
Issue Representation Reasoning.
228

fiExpressiveness Two-Valued Semantics ADFs

Brewka, G., & Woltran, S. (2010). Abstract dialectical frameworks. Proceedings
Twelfth International Conference Principles Knowledge Representation
Reasoning (KR), pp. 102111.
Clark, K. L. (1978). Negation failure. Gallaire, H., & Minker, J. (Eds.), Logic
Data Bases, pp. 293322. Plenum Press.
Coste-Marquis, S., Konieczny, S., Mailly, J.-G., & Marquis, P. (2014). revision
argumentation systems: Minimal change arguments statuses. Proceedings
Fourteenth International Conference Principles Knowledge Representation
Reasoning (KR), pp. 5261.
Darwiche, A., & Marquis, P. (2002). knowledge compilation map. Journal Artificial
Intelligence Research, 17, 229264.
Denecker, M., Marek, V. W., & Truszczynski, M. (2004). Ultimate approximation
application nonmonotonic knowledge representation systems. Information
Computation, 192 (1), 84121.
Dimopoulos, Y., Nebel, B., & Toni, F. (2002). computational complexity
assumption-based argumentation default reasoning. Artificial Intelligence,
141 (1/2), 5778.
Dung, P. M. (1995). Acceptability Arguments Fundamental Role
Nonmonotonic Reasoning, Logic Programming n-Person Games. Artificial Intelligence, 77, 321358.
Dunne, P. E., Dvorak, W., Linsbichler, T., & Woltran, S. (2014). Characteristics multiple
viewpoints abstract argumentation. Proceedings Fourteenth International
Conference Principles Knowledge Representation Reasoning (KR), pp.
7281, Vienna, Austria.
Dunne, P. E., Dvorak, W., Linsbichler, T., & Woltran, S. (2015). Characteristics multiple
viewpoints abstract argumentation. Artificial Intelligence, 228, 153178.
Dyrkolbotn, S. K. (2014). argue anything: Enforcing arbitrary sets labellings
using AFs. Proceedings Fourteenth International Conference Principles
Knowledge Representation Reasoning (KR), pp. 626629, Vienna, Austria.
Eiter, T., Fink, M., Puhrer, J., Tompits, H., & Woltran, S. (2013). Model-based recasting
answer-set programming. Journal Applied Non-Classical Logics, 23 (12), 75104.
Eiter, T., & Gottlob, G. (1995). computational cost disjunctive logic programming:
Propositional case. Annals Mathematics Artificial Intelligence, 15 (34), 289
323.
French, T., van der Hoek, W., Iliev, P., & Kooi, B. (2013). succinctness
modal logics. Artificial Intelligence, 197, 5685.
Friedman, J. (1986). Constructing O(n log n) size monotone formulae k-th elementary symmetric polynomial n Boolean variables. SIAM Journal Computing, 15,
641654.
Gabbay, D. M. (2011). Dungs argumentation essentially equivalent classical propositional logic Peirce-Quine dagger. Logica Universalis, 5 (2), 255318.
229

fiStrass

Gaggl, S. A., & Strass, H. (2014). Decomposing Abstract Dialectical Frameworks. Parsons, S., Oren, N., & Reed, C. (Eds.), Proceedings Fifth International Conference
Computational Models Argument (COMMA), Vol. 266 FAIA, pp. 281292.
IOS Press.
Gaggl, S. A., Rudolph, S., & Strass, H. (2015). computational complexity naivebased semantics abstract dialectical frameworks. Yang, Q., & Wooldridge, M.
(Eds.), Proceedings Twenty-Fourth International Joint Conference Artificial
Intelligence (IJCAI), pp. 29852991, Buenos Aires, Argentina. IJCAI/AAAI.
Gebser, M., Kaminski, R., Kaufmann, B., Ostrowski, M., Schaub, T., & Schneider, M.
(2011). Potassco: Potsdam Answer Set Solving Collection. AI Communications,
24 (2), 105124. Available http://potassco.sourceforge.net.
Gelfond, M., & Lifschitz, V. (1988). stable model semantics logic programming.
Proceedings International Conference Logic Programming (ICLP), pp.
10701080. MIT Press.
Gogic, G., Kautz, H., Papadimitriou, C., & Selman, B. (1995). comparative linguistics
knowledge representation. Proceedings Fourteenth International Joint
Conference Artificial Intelligence (IJCAI), pp. 862869. Morgan Kaufmann.
Jukna, S. (2012). Boolean Function Complexity: Advances Frontiers, Vol. 27 Algorithms Combinatorics. Springer.
Lifschitz, V., & Razborov, A. (2006). many loop formulas?. ACM Transactions Computational Logic, 7 (2), 261268.
Lifschitz, V., Tang, L. R., & Turner, H. (1999). Nested expressions logic programs. Annals
Mathematics Artificial Intelligence, 25 (34), 369389.
Lin, F., & Zhao, Y. (2004). ASSAT: Computing answer sets logic program SAT
solvers. Artificial Intelligence, 157 (1-2), 115137.
Linsbichler, T. (2014). Splitting abstract dialectical frameworks. Parsons, S., Oren, N., &
Reed, C. (Eds.), Proceedings Fifth International Conference Computational
Models Argument (COMMA), Vol. 266 FAIA, pp. 357368. IOS Press.
Marek, V. W., & Truszczynski, M. (1991). Autoepistemic logic. Journal ACM, 38 (3),
587618.
Osorio, M., Zepeda, C., Nieves, J. C., & Cortes, U. (2005). Inferring acceptable arguments
answer set programming. Proceedings Sixth Mexican International
Conference Computer Science (ENC), pp. 198205.
Polberg, S. (2014). Extension-based semantics abstract dialectical frameworks. Endriss,
U., & Leite, J. (Eds.), Proceedings Seventh European Starting AI Researcher
Symposium (STAIRS), Vol. 264 FAIA, pp. 240249. IOS Press.
Polberg, S., Wallner, J. P., & Woltran, S. (2013). Admissibility abstract dialectical
framework. Leite, J., Son, T. C., Torroni, P., van der Torre, L., & Woltran, S.
(Eds.), Proceedings Fourteenth International Workshop Computational Logic
Multi-Agent Systems (CLIMA XIV), Vol. 8143 LNAI, pp. 102118. Springer.
230

fiExpressiveness Two-Valued Semantics ADFs

Puhrer, J. (2015). Realizability three-valued semantics abstract dialectical frameworks. Yang, Q., & Wooldridge, M. (Eds.), Proceedings Twenty-Fourth
International Joint Conference Artificial Intelligence (IJCAI), pp. 31713177. IJCAI/AAAI, Buenos Aires, Argentina.
Shen, Y., & Zhao, X. (2014). Canonical logic programs succinctly incomparable
propositional formulas. Proceedings Fourteenth International Conference
Principles Knowledge Representation Reasoning (KR), pp. 665668,
Vienna, Austria.
Strass, H. (2013). Approximating operators semantics abstract dialectical frameworks. Artificial Intelligence, 205, 3970.
Strass, H. (2014). relative expressiveness argumentation frameworks, normal
logic programs abstract dialectical frameworks. Konieczny, S., & Tompits,
H. (Eds.), Proceedings Fifteenth International Workshop Non-Monotonic
Reasoning (NMR).
Strass, H. (2015a). Instantiating rule-based defeasible theories abstract dialectical frameworks beyond. Journal Logic Computation, Advance Access published 11
February 2015, http://dx.doi.org/10.1093/logcom/exv004.
Strass, H. (2015b). relative expressiveness abstract argumentation logic programming. Proceedings Twenty-Ninth AAAI Conference Artificial Intelligence
(AAAI), pp. 16251631, Austin, TX, USA.
Strass, H. (2015c). Representational succinctness abstract dialectical frameworks.
Black, E., Modgil, S., & Oren, N. (Eds.), Proceedings Third International Workshop Theory Applications Formal Argumentation (TAFA).
Strass, H., & Wallner, J. P. (2015). Analyzing computational complexity abstract
dialectical frameworks via approximation fixpoint theory. Artificial Intelligence, 226,
3474.
Tseitin, G. S. (1968). complexity derivations propositional calculus. Structures Constructive Mathematics Mathematical Logic, Part II, Seminars
Mathematics (translated Russian), 115125.

231


