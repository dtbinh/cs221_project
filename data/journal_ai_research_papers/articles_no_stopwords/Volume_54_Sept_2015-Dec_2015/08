Journal Artificial Intelligence Research 54 (2015) 309-367

Submitted 03/15; published 11/15

PAGOdA: Pay-As-You-Go Ontology Query Answering
Using Datalog Reasoner
Yujiao Zhou
Bernardo Cuenca Grau
Yavor Nenov
Mark Kaminski
Ian Horrocks

yujiao.zhou@cs.ox.ac.uk
bernardo.cuenca.grau@cs.ox.ac.uk
yavor.nenov@cs.ox.ac.uk
mark.kaminski@cs.ox.ac.uk
ian.horrocks@cs.ox.ac.uk

Department Computer Science, University Oxford
Parks Road, Oxford OX1 3QD, United Kingdom

Abstract
Answering conjunctive queries ontology-enriched datasets core reasoning task
many applications. Query answering is, however, computationally expensive,
led development query answering procedures sacrifice either expressive
power ontology language, completeness query answers order improve
scalability. paper, describe hybrid approach query answering OWL 2
ontologies combines datalog reasoner fully-fledged OWL 2 reasoner order
provide scalable pay-as-you-go performance. key feature approach
delegates bulk computation datalog reasoner resorts expensive
OWL 2 reasoning necessary fully answer query. Furthermore, although
main goal efficiently answer queries OWL 2 ontologies data, technical
results general approach applicable first-order knowledge representation languages captured rules allowing existential quantification
disjunction head; assumption availability datalog reasoner
fully-fledged reasoner language interest, used black boxes.
implemented techniques PAGOdA system, combines datalog
reasoner RDFox OWL 2 reasoner HermiT. extensive evaluation shows
PAGOdA succeeds providing scalable pay-as-you-go query answering wide range
OWL 2 ontologies, datasets queries.

1. Introduction
Ontologies increasingly used rich conceptual schemas wide range application
domains (Staab & Studer, 2004). One widely used ontology languages OWL,
description logic based language standardised World Wide Web Consortium
(W3C) 2004 revised (as OWL 2) 2009 (Baader, Calvanese, McGuinness, Nardi,
& Patel-Schneider, 2003; Horrocks, Patel-Schneider, & van Harmelen, 2003; Cuenca Grau,
Horrocks, Motik, Parsia, Patel-Schneider, & Sattler, 2008). OWL ontology consists
set axioms, correspond first-order sentences containing unary binary
predicates (called classes properties OWL), structure axioms/sentences
restricted ensure decidability basic reasoning problems.
applications, main focus conceptual model itself, class subsumption key reasoning problem. increasing number applications, however,
main focus using conceptual model access data, often form RDF
c 2015 AI Access Foundation. rights reserved.

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

graph (Manola & Miller, 2004). data-centric applications key reasoning problem
answer conjunctive queries (CQs)sentences constructed function-free atoms using
conjunction existential quantification (Abiteboul, Hull, & Vianu, 1995)which
constitute core component standard query languages SQL SPARQL
(W3C SPARQL Working Group, 2013).
Conjunctive query answering ontology-enriched datasets is, however, high worstcase complexity (Glimm, Lutz, Horrocks, & Sattler, 2008; Eiter, Ortiz, & Simkus, 2012),
even measured respect size data (so called data complexity).
Although heavily optimised, existing systems query answering respect (RDF)
data unrestricted OWL 2 ontology process small medium size datasets
(Sirin, Parsia, Cuenca Grau, Kalyanpur, & Katz, 2007; Moller, Neuenstadt, Ozcep, &
Wandelt, 2013; Wandelt, Moller, & Wessel, 2010; Kollia & Glimm, 2013). led
development query answering procedures sacrifice expressive power
ontology language completeness query answers order improve scalability.
former case (sacrificing expressive power), query answering procedures
developed various fragments OWL 2 conjunctive query answering tractable
respect data complexity, three fragments standardised so-called
profiles OWL 2 (Motik, Cuenca Grau, Horrocks, Wu, Fokoue, & Lutz, 2012). OWL 2
QL OWL 2 EL profiles based DL-Lite (Calvanese, De Giacomo, Lembo,
Lenzerini, & Rosati, 2007) EL (Baader, Brandt, & Lutz, 2005) families description
logics; OWL 2 RL profile corresponds fragment rule-based language datalog
(Grosof, Horrocks, Volz, & Decker, 2003; Dantsin, Eiter, Gottlob, & Voronkov, 2001).
Conjunctive query answering systems profiles shown highly scalable
practice (Bishop, Kiryakov, Ognyano, Peikov, Tashev, & Velkov, 2011; Wu, Eadon, Das,
Chong, Kolovski, Annamalai, & Srinivasan, 2008; Motik, Nenov, Piro, Horrocks, & Olteanu,
2014; Erling & Mikhailov, 2009; Rodriguez-Muro & Calvanese, 2012; Lutz, Seylan, Toman,
& Wolter, 2013; Stefanoni, Motik, & Horrocks, 2013). favourable computational
properties fragments make natural choice data-intensive applications,
come expense loss expressive power, many ontologies used
applications captured profiles.
latter case (sacrificing completeness), query answering procedures
developed exploit scalable reasoning techniques, expense computing
approximate query answers (Thomas, Pan, & Ren, 2010; Tserendorj, Rudolph, Krotzsch,
& Hitzler, 2008; Wandelt et al., 2010; Bishop et al., 2011). cases, computed
answers sound (only correct answer tuples identified) incomplete (some correct
answer tuples may identified). One way realise procedure weaken
ontology falls within one OWL 2 profiles, use scalable
procedure relevant fragment. required weakening trivially achieved
simply discarding (parts of) out-of-profile axioms, sophisticated techniques may
try reduce even minimise information loss (Console, Mora, Rosati, Santarelli, & Savo,
2014). approach clearly sound (if answer tuple entailed weakened
ontology, entailed original ontology), incomplete general,
ontologies outside relevant profile, answer returned systems therefore
understood providing lower-bound correct answer; however, procedures

310

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

cannot general provide complementary upper bound even indication
complete computed answer (Cuenca Grau, Motik, Stoilos, & Horrocks, 2012).
paper, describe novel hybrid approach query answering combines
scalable datalog (or OWL 2 RL) reasoner fully-fledged OWL 2 reasoner provide
scalable performance still guaranteeing sound complete answers cases.
procedure uses datalog reasoner efficiently compute lower bound (sound
possibly incomplete) upper bound (complete possibly unsound) answers input query. lower upper bound answers coincide, obviously provide sound
complete answer. Otherwise, relevant subsets ontology data computed
guaranteed sufficient test correctness tuples gap
lower upper bounds. subsets computed using datalog reasoner,
typically much smaller input ontology data. Finally, fully-fledged
reasoner used check gap tuples w.r.t. relevant subset. still computationally expensive, load fully-fledged reasoner reduced exploiting
summarisation techniques inspired SHER system quickly identify spurious gap
tuples (Dolby, Fokoue, Kalyanpur, Kershenbaum, Schonberg, Srinivas, & Ma, 2007; Dolby,
Fokoue, Kalyanpur, Schonberg, & Srinivas, 2009), analysing dependencies
remaining gap tuples reduce number checks need performed.
key feature approach pay-as-you-go behaviour: bulk computational workload delegated datalog reasoner, extent
fully-fledged reasoner needed depend solely ontology, interactions
ontology, dataset query. Thus, even using expressive
ontology, queries often fully answered using datalog reasoner, even
fully-fledged reasoner required, relevant subset extraction, summarisation
dependency analysis greatly reduce number size reasoning problems. Moreover,
approach additional advantage lower bound answer tuples quickly
returned, even cases completion answer requires time consuming computations. Finally, although main goal efficiently answer queries OWL 2
ontologies datasets, technical results general approach
restricted ontology languages based description logics. precisely, given KR
language L captured first-order rules allowing existential quantification
disjunction head, want answer conjunctive queries,
assumption availability fully-fledged reasoner L datalog reasoner,
used black box.
implemented techniques PAGOdA system1 using RDFox datalog
reasoner (Motik et al., 2014) HermiT fully-fledged OWL 2 reasoner (Glimm,
Horrocks, Motik, Stoilos, & Wang, 2014),2 conducted extensive evaluation using
wide range realistic benchmark datasets queries. evaluation suggests
techniques eective providing scalable pay-as-you-go query answering: tests
4,000 queries 8 ontologies, none contained within
OWL profiles, 99% queries fully answered without resorting fullyfledged reasoner. Moreover, even fully-fledged reasoner used, relevant subset
1. http://www.cs.ox.ac.uk/isg/tools/PAGOdA/
2. Although techniques proved correct general conjunctive queries, practice limited
current query capabilities OWL 2 reasoners.

311

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

extraction, summarisation dependency analysis greatly reduced number size
reasoning problems: tests, size dataset typically reduced order
magnitude, often several orders magnitude, seldom required
single test resolve status gap tuples. Taken together, experiments show
PAGOdA provide efficient conjunctive query answering service scenarios requiring
expressive ontologies datasets containing hundreds millions facts, something
far beyond capabilities pre-existing state-of-the-art ontology reasoners.
remainder paper organised follows. Section 2 introduce key
concepts definitions. Section 3 present high-level overview approach.
Section 4 describe lower bound answers computed prove
sound, Section 5 describe upper bound answers computed prove
complete. Section 6 present technique reducing size
ontology dataset processed fully-fledged reasoner prove
preserves completeness. Section 7 present summarisation dependency analysis
optimisations prove preserve completeness. Section 8 describe
implementation techniques PAGOdA system discuss additional
optimisations. Finally, positioning work within state-of-the-art Section 9,
present extensive evaluation Section 10, draw conclusions Section 11.

2. Preliminaries
section briefly introduce rule-based first-order languages description logics
(DLs)a family knowledge representation formalisms underpinning OWL OWL 2
ontology languages (Baader et al., 2003).
use standard notions first-order logic constant, predicate, function,
term, substitution, atom, formula, sentence. adopt standard definitions
(Herbrand) interpretation model, well (un)satisfiability entailment (written
|=) sets first-order sentences. denote ? nullary predicate false
interpretations. Formulas may contain special equality predicate . assume
first-order knowledge base F function-free signature uses axiomatises
semantics usual way; is, F must contain following first-order sentences,
(EQ1) (EQ4) instantiated n-ary predicate P F 1 n:
8x1 , . . . , xn (P (x1 , . . . , xi , . . . , xn ) ! xi xi )

(EQ1)

8x, y(x ! x)

8x, y, z(x ^ z ! x z)

8x1 , . . . , xn , y(P (x1 , . . . , xi , . . . , xn ) ^ xi ! P (x1 , . . . , xi

(EQ2)
(EQ3)
1 , y, xi+1 , . . . , xn ))

(EQ4)

Finally, exploit following notion homomorphism applicable sets
atoms, formulas substitutions. Given sets ground atoms , define
homomorphism mapping ground terms ground terms s.t.
(c) = c constant c S, P (t1 , . . . , tn ) 2 atom P (t1 , . . . , tn ) 2 S.
application homomorphism naturally extended ground atoms, ground
formulas ground substitutions, e.g. atom = P (t1 , . . . , tn ), = P (t1 , . . . , tn )
ground substitution , substitution {x 7! x | x 2 dom( )}.
312

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

2.1 Rule-Based Knowledge Representation
Rule languages well-known knowledge representation formalisms strongly connected ontology languages (Dantsin et al., 2001; Cal, Gottlob, Lukasiewicz, Marnette,
& Pieris, 2010; Bry, Eisinger, Eiter, Furche, Gottlob, Ley, Linse, Pichler, & Wei, 2007).
define fact function-free ground atom dataset finite set facts.
rule r function-free first-order sentence form
8~x, ~y (


x, ~y )
(~

x, ~y )
1 (~

^ ^

x, ~y )
n (~

!


_

i=1

9~zi 'i (~x, ~zi ))

(1)

atom dierent ? free variables ~x [ ~y , either

= 1 '1 (~x, ~z1 ) = ?,
1, 1 formula 'i (~x, ~zj ) conjunction atoms dierent
? free variables ~x [ ~zj .
conjunction
atoms 1 (~x, ~y ) ^ ^ n (~x, ~y ) body r, denoted body(r).
W
formula
9~
z
'
x, ~zi ) head r, denoted head(r). assume rules
(~
i=1
safe; is, every variable ~x mentioned body(r). brevity, universal quantifiers
omitted rules.
Rules form general able capture first-order rule languages
knowledge representation, including datalog (Abiteboul et al., 1995), existential rules
datalog (Cal et al., 2010), well datalog,_ (Alviano, Faber, Leone, & Manna,
2012b; Bourhis, Morak, & Pieris, 2013).
say rule r
disjunctive datalog head(r) contains existential quantifiers conjunction;
existential = 1;
datalog disjunctive datalog = 1.
knowledge base K = K [ DK consists finite set rules K dataset DK
predicate DK assumed occur K .
order simplify presentation technical results, sometimes restrict
knowledge bases particular normal form, specify next. say
rule r normalised one following forms,
1
x, ~zi ) single atom dierent ?:
(~
x, ~y )
1 (~
x, ~y )
1 (~
x, ~y )
1 (~

^ ^

x, ~y )
n (~

^ ^

x, ~y )
n (~

^ ^

x, ~y )
n (~

!?

(2)

! 9~z1 1 (~x, ~z1 )
!

x)
1 (~

_ _

(3)
x)
(~

(4)

knowledge base K [ DK normalised rules K normalised. restriction
normalised knowledge bases w.l.o.g. since every set rules form (1)
transformed polynomial time set normalised rules norm() conservative
extension given next. rule r 2 1 m, let ~xi tuple
313

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

free variables subformulas 9~zi 'i (~x, ~zi ) head(r), ~xi ~x. Furthermore,
let E'i fresh predicates arity |~xi | let C'i fresh predicates arity |~xi | + |~zi |
uniquely associated r i. Then, norm() consists following rules:3

x, ~y )
1 (~

^ ^

x, ~y )
n (~

!


_

E'i (~xi ),

(5)

i=1

E'i (~xi ) ! 9~zi C'i (~xi , ~zi ) 1 m,
C'i (~xi , ~zi ) !

1 atom

'i (~x, ~zi ) ! E'i (~xi ) 1 m,

'i (~x, ~zi ) ! C'i (~xi , ~zi ) 1 m.

(6)
'i (~x, ~zi ),

(7)
(8)
(9)

frequently use Skolemisation interpret rules Herbrand interpretations.
rule r form (1) existentially quantified variable zij , let fijr function
symbol globally unique r zij arity ~x. Furthermore, let sk substitution
sk (zij ) = fijr (~x) zij 2 ~zi . Skolemisation sk(r) r following
first-order sentence, slight abuse notation refer Skolemised rule:
x, ~y )
1 (~

^ ^

x, ~y )
n (~

!


_

'i (~x, ~zi )sk

i=1

Skolemisation sk() set rules obtained Skolemising individual rule
. extend definitions head body rules Skolemised rules naturally.
well-known Skolemisation entailment-preserving transformation.
2.2 Description Logics Ontology Languages
next present brief overview DLs underpinning W3C standard ontology
language OWL 2 (Horrocks, Kutz, & Sattler, 2006; Cuenca Grau et al., 2008). Typically,
predicates DL signatures restricted unary binary; former called atomic
concepts, whereas latter typically referred atomic roles. DLs typically provide
two special concepts ? (the bottom concept) > (the top concept), mapped
every interpretation empty set interpretation domain, respectively.
Every OWL 2 DL ontology normalised set axioms form given
left-hand-side Table 1 (Motik, Shearer, & Horrocks, 2009).4 Thus, w.l.o.g.,
define OWL 2 DL ontology finite set axioms form (O1)(O13) Table 1.
Every OWL 2 DL ontology must satisfy certain additional requirements order ensure
decidability reasoning (Horrocks et al., 2006). restrictions, however, immaterial
technical results.
normalised axiom corresponds single rule, given right-hand-side
Table 1. Concept ? translated special nullary predicate ?, whereas > translated
3. Although rules (5)(7) sufficient express normal form, introduce rules (8)(9) order
facilitate computation upper bound query answers (see Sections 5.2 5.3).
4. convenience, omit axioms form v n R.B simulated v 9R.Bi ,
Bi v B Bi u Bj v ? 1 < j n Bi fresh concept.

314

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

Axioms
dn
Ai v F
?
di=1
n


v
i=1
j=1 Bj
9R.A v B
v Self(R)
Self(R) v
R vS
R vS
R vT
RuS v?
v 9R.B
v R.B
v {a}
> v 8R.A

Rules
Vn
Ai (x) ! W
?
Vi=1
n


(x)
!
i=1
j=1 Bj (x)
R(x, y) ^ A(y) ! B(x)
A(x) ! R(x, x)
R(x, x) ! A(x)
R(x, y) ! S(x, y)
R(x, y) ! S(y, x)
R(x, z) ^ S(z, y) ! (x, y)
R(x, y) ^ S(x, y) ! ?
A(x) ! 9y(R(x, y) ^ B(y))
V
W
A(x) ^ m+1
i=1 [R(x, yi ) ^ B(yi )] !
1i<jm+1 yi yj
A(x) ! x
R(x, y) ! A(y)

(O1)
(O2)
(O3)
(O4)
(O5)
(O6)
(O7)
(O8)
(O9)
(O10)
(O11)
(O12)
(O13)

Table 1: Normalised DL axioms translation rules n, > 0, B
atomic concepts >, R, S, atomic roles.
ordinary unary predicate, meaning axiomatised. Let function
maps OWL 2 axiom corresponding rule Table 1, let
ontology. Then, (O) smallest knowledge base containing:
() 2 O;
rule A(x) ! >(x) atomic concept O;
rules R(x, y) ! >(x) R(x, y) ! >(y) atomic role R O.
Note since (O) knowledge base, must contain axioms equality
signature whenever required translate axiom O.
recent years, growing interest ontology languages favourable
computational properties, led standardisation RL, QL, EL
profiles OWL 2 (Motik et al., 2012). say ontology Horn = 1
axioms (O2) (O11). Additionally, say Horn ontology
RL contain axioms (O4), (O5), (O10).
QL contain axioms (O4), (O5), (O8), (O9), (O11), (O12); furthermore, axioms (O1) (O2) satisfy n 2 axioms (O3) satisfy = >.
EL contain axioms (O7), (O9) (O11). Additionally, say
EL ontology ELHOr? contain axioms (O4), (O5) (O8).
2.3 Conjunctive Queries
conjunctive query (CQ) formula q(~x) form 9~y '(~x, ~y ), '(~x, ~y )
conjunction function-free atoms. query Boolean |~x| = 0, atomic '(~x, ~y )
315

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

consists single atom |~y | = 0. simplicity, sometimes omit free variables
write q instead q(~x).
Let K knowledge base. tuple ~a constants possible answer q(~x) w.r.t. K
arity ~x constant ~a occurs K. Furthermore, say
possible answer ~a certain answer K |= q(~a); set certain answers denoted
cert(q, K). Note that, '(~x, ~y ) Boolean, set certain answers either empty
consists tuple length zero. treat unsatisfiability Boolean query
'(~x, ~y ) nullary falsehood symbol ?; query holds w.r.t. K K unsatisfiable.
CQs alternatively represented using datalog rules. end, query q(~x)
uniquely associated predicate Pq arity |~x| (where take P? = ?) set
Rq rules defined follows:

;
q=?
Rq =
(10)
{'(~x, ~y ) ! Pq (~x)} otherwise
Then, ~a 2 cert(q, K) K [ Rq |= Pq (~a). way, certain answers characterised
means entailment single facts.
Answering CQs w.r.t. knowledge bases computationally hard, decidability knowledge bases stemming OWL 2 DL ontologies remains open. Decidability
obtained ensuring ontology stays within one standardised profiles
OWL 2. restriction ensures tractability respect data complexity,
makes profiles natural choice ontology language data-intensive applications.
standard language SPARQL 1.1 (W3C SPARQL Working Group, 2013) allows users
formulate CQs OWL 2 ontologies; however, ensure decidability reduce
complexity query answering, CQs interpreted SPARQL 1.1 ground semantics.
say possible answer ~a q(~x) = 9~y '(~x, ~y ) ground answer w.r.t. satisfiable
knowledge base K exists tuple ~e constants K K |= '(~a, ~e). Clearly,
every ground answer certain answer vice versa. denote ground(q, K)
set ground answers q w.r.t. K.
Many reasoning systems currently support SPARQL 1.1 hence compute ground(q, K)
given CQ q OWL 2 DL ontology K input. Additionally, systems
able compute certain answers q suitably restricted. precisely, say q
internalisable Kq = K [ Rq corresponds OWL 2 DL knowledge base. Internalisation
amounts transforming query ontology axiom typically referred
rolling-up DL literature (Horrocks & Tessaris, 2000).
paper, focus general problem computing certain answers CQ
w.r.t. knowledge base K, theoretical results generally applicable regardless
rule-based language K expressed.
2.4 Hyperresolution
Reasoning knowledge bases realised means hyperresolution calculus
(Robinson & Voronkov, 2001), briefly discuss next. treatment hyperresolution consider standard basic notions theorem proving (ground) clause
general unifier (MGU). Furthermore, treat disjunctions ground atoms
sets hence allow duplicated atoms disjunction. assume ?
316

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

occur clauses denote empty clause. Skolemisation sk(r)
normalised rule r logically equivalent clause containing atom dierent
? head(sk(r)) negation atom body(sk(r)), sometimes abuse
notation use sk(r) refer Skolemised rule corresponding clause.
Let C = 1 _ _ n _ 1 _ _ clause, j atoms
(possibly containing functional terms). Furthermore 1 n, let = _
positive ground clause. Finally, let MGU pairs , , 1 n. Then,
positive ground clause 1 _ _ _ 1 _ _ n hyperresolvent C 1 , . . . , n .
inference called hyperresolution step, clause C main premise.
Let K = K [ DK normalised knowledge base let C positive ground clause.
derivation C K pair = (T, ) tree, labeling function
maps node ground clause, v :
(1)

(v) = C v root;

(2)

(v) 2 DK v leaf;

(3) v children w1 , . . . , wn , (v) hyperresolvent sk(r) (w1 ), . . . , (wn )
rule r 2 K .
support , written support(), set facts rules participating hyperresolution steps . write K ` C denote hyperresolution derivation
C K. Hyperresolution sound complete: K unsatisfiable K ` ;
furthermore, K satisfiable K ` K |= ground atom .
2.5 Skolem Chase
Answering CQs knowledge base K = K [ DK K consists existential
rules realised using chase technique (Abiteboul et al., 1995; Cal, Gottlob, &
Kifer, 2013). paper, use Skolem chase variant (Marnette, 2009; Cuenca Grau,
Horrocks, Krotzsch, Kupke, Magka, Motik, & Wang, 2013).
Skolem chase sequence K sequence sets ground atoms {B }i 0 ,
0
B = DK , B i+1 inductively defined follows:
B i+1 = B [ {head(sk(r)) | r 2 K ,

substitution, B |= body(r) }.

Skolem chase K, written ChaseK , defined 0 B .
key property Skolem chase computes universal Herbrand model
K, used database answering CQs. Formally, K satisfiable
?2
/ ChaseK ; furthermore, K satisfiable, ChaseK homomorphically embeddable
every Herbrand model K (seen set atoms). follows K satisfiable
q Boolean CQ K |= q ChaseK |= q.
Note ChaseK might contain infinitely many atoms. K datalog, however,
ChaseK guaranteed finite contains precisely facts logically entailed K.
case, often refer ChaseK materialisation K.

317

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

3. Overview
section provide high-level overview approach conjunctive query answering. assume availability two reasoners:
datalog reasoner sound complete answering conjunctive queries
datalog knowledge bases;
fully-fledged reasoner sound complete answering given class
conjunctive queries Q (which includes unsatisfiability query) w.r.t. knowledge
bases given ontology language L.
describe approach general form, make assumptions
two reasoners, treating black-box query answering procedures.
kind queries knowledge bases dealt using approach
ultimately depends capabilities fully-fledged reasoner. instance, OWL
2 DL reasoners typically process arbitrary OWL 2 DL knowledge bases; however,
query language limited internalisable queries. turn, scalability approach
ultimately depends much reasoning workload delegated datalog
reasoner; goal delegate bulk computation datalog reasoner
restrict (expensive) use fully-fledged reasoner bare minimum.
Here, rest paper, fix arbitrary normalised knowledge base
K = K [ DK . Given arbitrary query q (which may special unsatisfiability query)
containing symbols K, core approach relies exploiting datalog
reasoner accomplishing following tasks:
Lower Upper Bound Computation, exploit datalog reasoner
compute lower bound Lq upper bound U q certain answers
q w.r.t. K. bounds match (i.e. Lq = U q ), query fully
answered datalog reasoner; otherwise, dierence Gq = U q \ Lq provides
set gap answers need verified using fully-fledged reasoner.
relevant techniques computing bounds described Sections 4 5.
Knowledge Base Subset Computation, exploit datalog reasoner
compute (hopefully small) subset Kq K sufficient check answers Gq
cert(q, K); is, ~a 2 cert(q, K) ~a 2 cert(q, Kq ) ~a 2 Gq . details
compute Kq given Section 6.
proceed according following steps given query q:
Step 1. Check satisfiability K.
(a) Compute bounds L? U ? unsatisfiability query ?. L? 6= ;,
terminate report K unsatisfiable. U ? = ;, proceed Step 2
(K satisfiable).
(b) Compute subset K? K.

(c) Use fully-fledged reasoner check satisfiability K? . minimise
computational workload fully-fledged reasoner, proceed follows:
318

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

i. Construct summary K? (See Section 7), use fully-fledged reasoner check satisfiable; is, proceed Step 2 (K satisfiable).
ii. Use fully-fledged reasoner check satisfiability K? ; unsatisfiable, terminate report K unsatisfiable. Otherwise,
proceed Step 2 (K satisfiable).
Step 2. Compute bounds Lq U q . Gq = ;, terminate return Lq . Otherwise,
proceed Step 3.
Step 3. Compute subset Kq K.
Step 4. ~a 2 Gq , use fully-fledged reasoner check whether Kq |= q(~a).
minimise computational workload, step carried follows:
(a) Construct summary Kq Kq (see Section 7). ~a 2 Gq , use
fully-fledged reasoner check whether ~a certain answer q w.r.t.
summary Kq , remove ~a Gq case.
(b) Compute dependency relation remaining answers Gq s.t. ~b
depends ~a ~a spurious answer, ~b. (See Section 7).
(c) Remove remaining spurious answers Gq , answer spurious
entailed Kq depends spurious answer; use fullyfledged reasoner check relevant entailments, arranging checks heuristics
w.r.t. dependency relation.
Step 5. Return Lq [ Gq .
following sections, describe steps formally. introduce
number improvements optimisations, rely additional assumption
datalog reasoner materialisation-basedthat is, datalog knowledge base K0
query q 0 , computes query answers cert(q 0 , K0 ) first computing materialisation
ChaseK0 evaluating q 0 resulting materialisation. reasonable
assumption practice since datalog reasoners Semantic Web applications (e.g.,
OWLim, RDFox, Oracles native inference engine) materialisation-based. cases,
assume direct access materialisation. PAGOdA system
combines HermiT materialisation-based reasoner RDFox, hence able
exploit improvements optimisations described below; realisation
approach PAGOdA discussed detail Section 8.
illustrate techniques using running example consisting knowledge
base Kex = Kex [ DKex query qex (x) given Table 2. Note rules (R6)
(R8) Kex normalised; however, easily brought normal form
introducing fresh binary predicates eatsH eatsL follows:
MeatEater(x) ! 9y eatsH (x, y) (R6a)

eats(x, y) ^ Herbivore(y) ! eatsH (x, y)
eatsH (x, y) ! eats(x, y)

eatsH (x, y) ! Herbivore(y)

(R6b)
(R6c)

(R6d)

319

Folivore(x) ! 9y eatsL (x, y) (R8a)

eats(x, y) ^ Leaf(y) ! eatsL (x, y)
eatsL (x, y) ! eats(x, y)
eatsL (x, y) ! Leaf(y)

(R8b)

(R8c)
(R8d)

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

Mammal(tiger)

(D1)

Mammal(wolf )

(D6)

Mammal(howler)

(D11)

Mammal(lion)

(D2)

MeatEater(wolf )

(D7)

MeatEater(python)
eats(python, rabbit)

(D3)
(D4)

eats(wolf , sheep)
Herbivore(sheep)

(D8)
(D9)

Folivore(howler)
Mammal(a hare)

(D12)
(D13)

Folivore(a hare)

(D14)

Herbivore(rabbit)

(D5)

eats(sheep, grass)

(D10)

eats(a hare, willow)

(D15)

Carnivore(x) ! Mammal(x)

Herbivore(x) ! Mammal(x)

Folivore(x) ^ MeatEater(x) ! ?

Herbivore(x) ^ eats(x, y) ! Plant(y)

(R1)
(R2)
(R3)
(R4)

Mammal(x) ! Herbivore(x) _ MeatEater(x)

(R5)

Mammal(x) ! 9y eats(x, y)

(R7)

MeatEater(x) ! 9y[eats(x, y) ^ Herbivore(y)]
Folivore(x) ! 9y[eats(x, y) ^ Leaf(y)]
Leaf(x) ! Plant(x)

(R6)
(R8)
(R9)

qex (x) = 9y[eats(x, y) ^ Plant(y)]

Table 2: Running example knowledge base Kex query qex (x). set Kex consists
rules (R1)(R9), dataset DKex consists facts (D1)(D15).
core techniques described Sections 4-6 applicable knowledge base
query. order simplify presentation definitions technical results
sections fix, addition knowledge base K = K [ DK , arbitrary query
q(~x) = 9~y '(~x, ~y ) (which may unsatisfiability query ?).

4. Lower Bound Computation
straightforward way compute lower bound answers using datalog reasoner
evaluate q w.r.t. datalog subset K consisting facts DK datalog rules
K . case OWL 2 ontologies, amounts considering subset OWL 2
RL axioms ontology. monotonicity property first-order logic certain
answers w.r.t. subset certain answers w.r.t. K. Furthermore, subset
unsatisfiable, K.
Example 4.1. datalog subset example Kex consists rules (R1)(R4)
(R9), together facts (D1)(D15). materialisation datalog subset
Kex results following dataset: Dex [ {Mammal(rabbit), Mammal(sheep), Plant(grass)}
evaluating qex (x) materialisation obtain sheep answer.
}
basic lower bound rather imprecise practice since rules featuring disjunction existential quantification typically abound OWL 2 DL ontologies. improve

320

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

bound, exploit techniques allow us deterministically derive (also via datalog
reasoning) additional consequences K follow datalog subset.
4.1 Dealing Disjunctive Rules: Program Shifting
deal disjunctive rules, adopt variant shiftinga polynomial program transformation commonly used Answer Set Programming (Eiter, Fink, Tompits, & Woltran,
2004). next illustrate intuition behind transformation example.
Example 4.2. Let us consider information Kex Arctic hares (a hare).
(R3) (D14), one deduce hare MeatEater, follows
rule (R5) fact (D13) hare Herbivore. Since hare eats willow,
deduce Plant(willow) (R4) hence hare answer qex . Although (R5)
disjunctive rule, reasoning process fully deterministic captured
datalog. end, introduce predicate MeatEater intuitively stands
complement MeatEater. extend datalog subset Kex rules encoding
intended meaning fresh predicate. particular, (R3) (R5) two rules,
obtained (R3) (R5), respectively.
Folivore(x) ! MeatEater(x)

(R3)

Mammal(x) ^ MeatEater(x) ! Herbivore(x)

(R5)

exploit rules derive MeatEater(a hare) Herbivore(a hare).

}

define shifting transformation formally.
Definition 4.3. Let r normalised disjunctive datalog rule. predicate P r
let P fresh predicate arity. Furthermore, given atom = P (~t) let
P (~t). shifting r, written shift(r), following set rules:
r form (2), shift(r) = {r}[{ 1 ^ ^

1 ^ i+1 ^ ^ n

!



| 1 n};

r form (4), shift(r) consists following rules: (i) rule (S1);
(ii) rules (S2) 1 j m; (iii) rules (S3) 1 n s.t.
variable occurs atom rule.
1
1
1

^ ^
^ ^
^ ^

n
n

^
^

1

1
1

^

^ ^
^ ^
i+1



!?

j 1

^ ^

^
n

(S1)
j+1

^

1

^ ^

^ ^




!

!

j

(S2)



(S3)

Let set normalised disjunctive datalog rules. Then, shifting defined
following set datalog rules:
[
shift() =
shift(r)
}
r2

Note shifting polynomial transformation. r disjunctive datalog rule
n atoms body atoms head, shift(r) contains + n + 1 datalog
rules. Furthermore, shown following theorem, sound.
321

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

Theorem 4.4. Let DD
subset disjunctive datalog rules K ; furthermore, let
K
K0 = shift(DD
)
[

.
Then,
cert(q, K0 ) cert(q, K).
K
K
0
Proof. Let ChaseK0 = {B }L
i=1 L non-negative integer (recall K datalog
knowledge base hence Skolem chase finite). show induction
following properties hold 0 L 2 B :

(a) = ?, K unsatisfiable;
(b) = P (~a), K |= P (~a);
(c) = P (~a), K |= P (~a).
Base case: Clearly, B 0 = DK properties trivially follow fact DK K.

Inductive step: Assume properties (a)(c) hold every 2 B . show
hold every 2 B i+1 \ B . must exist rule r0 2 K0 substitution
B |= body(r0 ) = head(r0 ) . Since every atom body(r0 ) B ,
properties (a)-(c) hold atoms induction hypothesis. Furthermore,
must exist rule r 2 K form 1 ^ ^ n ! 1 _ _ r0 2 shift(r).
(a) = ?, distinguish two cases. (i) head(r) = ?, case r = r0
induction hypothesis, K |= { 1 , . . . , n } hence K |= ?; (ii) head(r) 6= ?,
case r0 form (S1) 1 , . . . , n 1 , . . . , B .
induction hypothesis, K entails 1 , . . . , n 1 , . . . , . then, rule r
cannot satisfied model K since r 2 K, obtain K unsatisfiable.
(b) = P (~a), r0 form (S2) = P (~a). Hence, B contains atoms
i+1 , . . . , . induction hypothesis, K entails
1 ,..., n , 1 ,... 1
,
.
.
.
,
,

,
.
.
.
,

a)
1
n
1
1 , i+1 , . . . , . Since r 2 K = P (~
must case K |= P (~a).
(c) = P (~a), following cases. (i) head(r) = ?, case induction
K |= { 1 , . . . , 1 , i+1 , . . . , n }; then, since 1 ^ ^ n ! ?
rule K, obtain K |= , required. (ii) head(r) 6= ?, case
r0 form (S3) = P (~a); then, B contains atoms 1 , . . . , 1 ,
induction hypothesis K entails atoms
i+1 , . . . , n , 1 , . . . ,
,
.
.
.
,
,
,
.
.
.
,


a).
1
1
i+1
n
1 , . . . , . Since r 2 K obtain K |= P (~
V
q = ?, theorem follows property (a). Otherwise, let q(~x) = 9~y ( ni=1 (~x, ~y ))
let ~a possible answer K0 |= q(~a). Since K0 datalog, exists tuple
~e constants K0 non-negative integer L (~a, ~e) 2 B L 0 n.
then, (b) K |= (~a, ~e), hence K |= q(~a).
Shifting captures consequences disjunctive datalog rules K.
Furthermore, note refinement shifting ensures preservation
consequences; indeed, well-known disjunctive datalog express queries (e.g.,
non-3-colorabilility) cannot captured means datalog program (Afrati, Cosmadakis, & Yannakakis, 1995).
322

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

Example 4.5. Consider disjunctive datalog knowledge base consisting fact
GreenSeaTurtle(turtle), rules (R1), (R2)
GreenSeaTurtle(x) ! Herbivore(x) _ Carnivore(x).
Clearly, Mammal(turtle) follows knowledge base. shifting consists fact
GreenSeaTurtle(turtle) following rules, predicates Carnivore, GreenSeaTurtle,
Herbivore Mammal abbreviated as, respectively, C, G, H M:
C(x) ^ M(x) ! ?

C(x) ! M(x)

M(x) ! C(x)

G(x) ^ H(x) ^ C(x) ! ?

G(x) ^ H(x) ! C(x)

G(x) ^ C(x) ! H(x)

H(x) ^ M(x) ! ?

H(x) ! M(x)

H(x) ^ C(x) ! G(x)

M(x) ! H(x)

}

checked fact Mammal(turtle) follow shifting.
4.2 Dealing Existential Rules: Combined Approach OWL 2 EL

Existentially quantified rules ubiquitous large-scale complex ontologies, especially
life sciences applications. EL profile OWL 2 specifically designed
applications, many large ontologies used practice seen consisting large
EL backbone extended small number axioms outside profile.
Given prevalence EL axioms realistic ontologies, natural consider
OWL 2 EL subset K computing lower bound answers. CQ answering OWL
2 EL is, however, PSpace-complete (Stefanoni, Motik, Krotzsch, & Rudolph, 2014)
system currently supports CQ answering whole OWL 2 EL. Complexity,
however, drops NP case ELHOr? (Stefanoni et al., 2014). setting,
restriction ELHOr? ontologies added practical benefit exploit socalled combined approach delegate computational work associated CQ
answering datalog reasoner (Stefanoni et al., 2013; Lutz, Toman, & Wolter, 2009)a
technique currently supported systems KARMA.5 Although datalog-based CQ
answering techniques available richer languages, extension ELHOr?
inverse roles (i.e., axioms (O7) Table 1), resulting datalog programs hard
compute exponential size worst case (Perez-Urbina, Motik, & Horrocks,
2010). contrast combined approach ELHOr? , relevant datalog
programs straightforwardly constructed without need reasoning,
linear size (see Related Work section details).
Thus, compute query answers depend existentially quantified rules consider
r
subset EL
K ELHO ? rules K, syntactically characterised follows.
Definition 4.6. rule ELHOr? one following forms, '(x) either
?, form A(x), x c, 9yR(x, y):
p
^

i=1

Ai (x) ^

q
^

j=1

[Rj (x, yj ) ^

lj
^

k=1

5. http://www.cs.ox.ac.uk/isg/tools/KARMA/

323

Bjk (yj )] ! '(x),

(EL1)

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

R1 (x, y) ! R2 (x, y),
R(x, y) ! A(y).

(EL2)
(EL3)

combined approach exploit CQ answering conceptualised
three-step process.
1. first step compute materialisation datalog program obtained
EL
K respect DK . contains ?, knowledge base unsatisfiable. Otherwise model knowledge base. model, however,
universal cannot homomorphically embedded every model. Thus,
evaluation CQs may lead unsound answers.
2. second step evaluate query q . step intractable query
size, well-known database techniques exploited.
3. third step, unsound answers obtained second step discarded using
polynomial time filtration algorithm.
next specify transformation knowledge bases datalog used first
step, transformation exploited later Section 5 computing upper
bound query answers. computation datalog program knowledge base
Step 1 relies form Skolemisation existentially quantified variables mapped
fresh constants (instead functional terms).
Definition 4.7. rule r form (1) existentially quantified variable
zij , let crij constant globally unique r zij , let c-sk substitution
c-sk (zij ) = crij zij 2 ~zi . c-Skolemisation c-sk(r) r given follows:
x, ~y )
1 (~

^ ^

x, ~y )
n (~

!


_

'i (~x, ~zi )c-sk .

i=1

Then, define c-sk(K) = {c-sk(r) | r 2 K } [ DK .

}

Note application c-Skolemisation ELHOr? rule always results
datalog rule. Note that, contrast standard Skolemisation, c-Skolemisation
satisfiability entailment preserving transformation, may query answers
w.r.t. c-sk(K) unsound w.r.t. K. shown, however, c-Skolemisation
satisfiability-preserving ELHOr? knowledge bases; thus, c-sk(EL
K ) [ DK satisfiable
EL
[


satisfiable
(Stefanoni
et
al.,
2013).

next
sketch

filtration step,
K
K
refer interested reader work Stefanoni et al. details.
main source spurious answers evaluating query materialisation
obtained Step 1 presence forksconfluent chains binary atoms involving
Skolem constantsin image query materialisation. due
fact ELHOr? so-called forest-model property, forks cannot manifest
forest-shaped models. say constant c EL
K [DK auxiliary
dierent constant b exists c-sk(EL
)
[

|=
c

b;

is,
auxiliary constants
K
K
introduced c-Skolemisation entailed equal
324

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

constant present original ELHOr? knowledge base. Let substitution
mapping free variables ~x q constants ~a K |= q . Then, relation
q ~a smallest reflexive-transitive binary relation terms q satisfying
following fork rule
(fork)

0 t0
st

R(s, s0 ) P (t, t0 ) occur q,
(s0 ) auxiliary constant.

Clearly equivalence relation, computed polynomial time size
q. term q, let [t] equivalence class w.r.t. , let mapping
term q arbitrary fixed representative [t]. auxiliary graph
q ~a directed graph G = hV, Ei
V contains vertex (t) term q (t) auxiliary;
E contains directed edge h (s), (t)i atom form R(s, t) q
{ (s), (t)} V .
Now, ready define filtration. say ~a spurious answer either
auxiliary graph q contains cycle, terms occurring q exist
c-sk(EL

K ) [ DK 6|= (s) (t). Clearly, filtration candidate answer ~
done polynomial time size q.
assume availability procedure soundAnswers solves Steps 2 3;
is, given q model computed Step 1, returns answers q w.r.t.
input ELHOr? knowledge base. Consequently, given K q, obtain lower bound
query answers follows:
r
extract subset EL
K ELHO ? rules K;

compute materialisation c-sk(EL
K ) [ DK ;
q = ? return unsatisfiable ? 2 ; otherwise, return soundAnswers(q, ).
Example 4.8. Consider running example. ELHOr? subset Kex consists
facts (D1)(D15) together rules except (R4) (R5). fact (D12)
rule (R8) deduce howler eats leaf, must plant rule (R9). Hence
howler answer qex . answer identified using aforementioned steps.
c-Skolemisation (R8a) leads datalog rule
Folivore(x) ! eatsL (x, c3 )

(R8aU)

materialisation datalog program consisting facts rule (R8aU) contains
fact Plant(c3 ) hence tuple (howler, c3 ) matches qex materialisation.
match deemed sound filtration procedure.
}
4.3 Aggregated Lower Bound
techniques section seamlessly combined obtain lower bound Lq
hopefully close actual set certain answers. Given K q, proceed follows:
325

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

DD subset
1. Construct datalog knowledge base shift(DD
K ) [ DK , K
L
disjunctive datalog rules K . Compute materialisation M1 .
L
L
2. Construct datalog program c-sk(EL
K ) [ M1 compute materialisation M2 .

3. q = ?, Lq = cert(q, M2L ). Otherwise, Lq = soundAnswers(q, M2L ).
Theorem 4.4 ensures K |= 2 M1L signature K, hence M1L
used initial dataset second step. properties c-Skolemisation
filtration discussed Section 4.2 ensure every answer Lq indeed certain
answer q w.r.t. K. Furthermore, ? 2 M2L , K indeed unsatisfiable. Finally, note
materialisation M1L obtained first step pipelined second step;
result, Lq (sometimes strict) superset answers would obtain simply
EL
computing answers q w.r.t. shift(DD
K ) [ DK c-sk(K ) [ DK independently
union results.
Example 4.9. running example Kex , aggregated lower bound Lex consists
sheep (which follows datalog subset Kex ), hare (which follows shift(Kex )),
howler (which follows ELHOr? fragment Kex ).
}

5. Upper Bound Computation
many practical cases lower bound Lq described Section 4.3 constitutes rather
precise approximation actual set certain answers. Furthermore,
computed efficiently resorting datalog reasoner. lower bound
computation, however, gives indication accuracy answers: without
corresponding upper bound, every possible answer remains candidate answer,
needs either confirmed discarded.
section, describe approach efficiently computing upper bound
set certain answers. lower upper bounds coincide, fully answered
query; otherwise, gap lower upper bounds provides margin
error lower bound, narrows set candidate answers whose
verification may require powerful computational techniques.
5.1 Strengthening Knowledge Base
first step towards computing upper bound construct (polynomial size)
datalog knowledge base K0 K unsatisfiable, K0 entails nullary predicate
?s , cert(q, K) cert(q, K0 ) otherwise. Roughly speaking, K0 , refer
datalog strengthening K, obtained K
1. replacing ? fresh nullary predicate ?s predefined meaning;
2. splitting disjuncts occurring head position dierent datalog rules;
3. Skolemising existentially quantified variables constants Definition 4.7.
convenient subsequent definitions proofs explicitly define splitting
K, written split(K), intermediate knowledge base resulting Steps 1 2 above,
326

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

satisfiable disjunction-free. datalog strengthening K defined
result applying Step 3 replacing existentially quantified rule
split(K) c-Skolemisation.
Definition 5.1. splitting rule r form (1) following set rules:
head(r) = ?, split(r) = { 1 ^ ^
predicate predefined meaning;
otherwise, split(r) = {

! ?s }, ?s fresh nullary

! 9~zj 'j (~x, ~zj ) | 1 j }.

splitting K = K [ DK defined split(K) = r2K split(r) [ DK . Finally,
datalog strengthening K defined str(K) = c-sk(split(K)).
}
1

^ ^

n

n

Example 5.2. Consider example knowledge base Kex . splitting Kex obtained
replacing rule (R5) rules (R5Ua) (R5Ub), rule (R3) (R3U).
Mammal(x) ! Herbivore(x)

Mammal(x) ! MeatEater(x)

Folivore(x) ^ MeatEater(x) ! ?s

(R5Ua)
(R5Ub)
(R3U)

Finally, str(K) obtained replacing existentially quantified rules (R6a), (R7)
following rules (R6aU), (R7U)
MeatEater(x) ! eatsH (x, c1 )
Mammal(x) ! eats(x, c2 )

well rule (R8a) rule (R8aU) given Example 4.8.

(R6aU)
(R7U)
}

Note K contain rules ? head, str(K) logically entails
K: splitting amounts turning disjunctions head rules conjunctions,
c-Skolemisation restricts possible values existentially quantified variables fixed
constants. Thus, cert(q, str(K)) constitutes upper bound cert(q, K). is, however,
longer case ? replaced ordinary predicate ?s without predefined
meaning. rationale behind replacement provide meaningful upper bound
even cases splitting disjunctions c-Skolemising existentially quantified variables
would make strengthened knowledge base unsatisfiable.
0 = str(K ) example knowledge base.
Example 5.3. Consider strengthening Kex
ex
Since howler Mammal, Rule (R5Ub) MeatEater. then,
since Folivore(howler) fact Kex derive ?s using Rule (R3U). Note that,
replaced falsehood predicate ? ?s , strengthening Kex would
unsatisfiable, case meaningful upper bound could obtained query. }

next show str(K) exploited compute meaningful upper bound
input query, despite fact ? stripped built-in semantics first-order
logic. following lemma establishes key property splitting transformation
Definition 5.1: ground clause ' = 1 _ _ n derivable K via hyperresolution,
Skolem chase split(K) contains every atom 1 n.
327

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

Lemma 5.4. Let = (T, ) hyperresolution derivation K let H = split(K).
Then, every node v 2 ground atom occurring (v), 2 ChaseH .
Proof. prove claim structural induction .
Base case: v leaf , (v) 2 DK . Since DK H 2 ChaseH .

Inductive step: Assume induction hypothesis holds children w1 , . . . , wn
node v 2 . exists rule r 2 K substitution , sk(r) form
1 _ _ n _ disjunction atoms, (v) =
_ 1 _ _ n
hyperresolvent sk(r) (wi ) = _ 1 n. induction
hypothesis, disjuncts ChaseH , need show claim
disjunct
. distinguish following cases depending form
normalised rule r
r form (2),

empty. claim holds vacuously.

r form (3), = 1 sk . induction hypothesis,
ChaseH , since split(r) = r hence r 2 H, obtain 1 sk 2 ChaseH .





r form (4), = 1 _ _ . induction hypothesis,
ChaseH , 1 m, since rule 1 ^ ^ n ! H, obtain
atom ChaseH , required.
exploit completeness hyperresolution show split(K) satisfies
required properties. Furthermore, fact str(K) |= split(K) immediately implies
str(K) satisfies properties well hence may exploited compute upper
bound query answers.
Theorem 5.5. following properties hold H = split(K) well H = str(K):
(i) cert(?, K) cert(?s , H), i.e. K unsatisfiable, H |= ?s ; (ii) K
satisfiable cert(q, K) cert(q, H).
Proof. first show Properties (i) (ii) hold H = split(K). K unsatisfiable,
hyperresolution derivation empty clause K. Thus, must
exist rule r form (2) K substitution
atom
1 n derivable K. then, Lemma 5.4 2 ChaseH .
Since H contains rule 1 ^ ^ n ! ?s ?s 2 ChaseH H |= ?s , required.
Assume K satisfiable. cert(q, K) = ;, cert(q, K) cert(q, H) holds trivially;
otherwise let ~a certain answer q w.r.t. K. K |= q(~a) hence K [ Rq |= Pq (~a).
Since cert(?, K) = ;, q 6= ?. Using completeness hyperresolution
Lemma 5.4 obtain Pq (~a) chase K [ Rq . then, aforementioned
splitting entails Pq (~a) since split(K [ Rq ) = H [ Rq ~a 2 cert(q, H),
required. Finally, Properties (i) (ii) hold str(K) direct consequence fact
str(K) |= split(K).
Example 5.6. Figure 1 depicts materialisation str(Kex ), edges predicates
introduced normalisation ignored edges figure represent
binary predicate eats. Explicit facts Kex depicted black; implicit facts depicted
328

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

c1

tiger
Mammal
Herbivore
MeatEater

MeatEater
Mammal
Herbivore
Plant

lion
Mammal
Herbivore
MeatEater

c2

python
MeatEater

Plant

grass Plant

wolf

rabbit
Herbivore
Mammal
MeatEater

Mammal
MeatEater
Herbivore

c3

sheep
Herbivore
Mammal
MeatEater
Plant

Leaf
Plant

willow Plant

howler

hare

Mammal
Folivore
Herbivore
MeatEater

Mammal
Folivore
Herbivore
MeatEater

Figure 1: Materialisation Datalog strengthening Kex
using dierent colours facilitate subsequent illustration refinements
materialisation allow us tighten upper bound. obtain following
upper bound cert(qex , Kex ) evaluating qex materialisation:
cert(qex , str(Kex )) = {tiger, lion, python, rabbit, wolf , sheep, howler, hare, c1 }
already mentioned, str(Kex ) |= ?s ; however, obtained upper bound still meaningful
since contain possible answers Kex , grass willow. Please note
c1 certain answer qex w.r.t. str(Kex ); however, constant c1 signature
Kex hence possible answer qex w.r.t. K.
}
5.2 Tightening Upper Bound: Existential Rules
upper bound obtained str(K) rather coarse-grained practice: discussed
Example 5.6, python, tiger, lion wolf contained upper bound, none
certain answer qex . section, show refine upper bound
restricting application c-Skolemisation existential rules. Instead computing
upper bound q constructing strengthened knowledge base str(K)
evaluating q (the materialisation of) str(K), proceed follows.
1. Apply K variant Skolem chase, refer c-chase first
splitting disjuncts occurring head position dierent rules applying
Skolem chasing split(K) following modifications: (i) similarly
restricted chase (Cal et al., 2013), existential rules applied rule
head already satisfied; (ii) rather Skolemising head atom (using
functional term) whenever existential rule applied, resort c-Skolemisation
instead. Due latter modification, c-chase compute least
Herbrand Model split(K), rather model split(K).
2. Evaluate q result aforementioned chase, thus obtaining upper bound
certain answers q w.r.t. split(K), thus w.r.t. K.
following example motivates practical advantages approach.
Example 5.7. Consider materialisation str(Kex ) Figure 1. already
mentioned, python returned upper bound answer since qex matches facts
329

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

eats(python, c1 ) Plant(c1 ) materialisation. fact eats(python, c1 ) obtained
eatsH (python, c1 ), included materialisation satisfy c-Skolemised
rule (R6aU) str(Kex ), existentially quantified rule (R6a) Kex . case
python, however, rule (R6a) Kex already satisfied fact eatsH (python, rabbit),
derived eats(python, rabbit) Herbivore(rabbit) dataset, rule
(R6b). Please note rule (R6b) form (9) normalisation (R6).
Rule (R6b) ensures (R6) satisfied substitution, (R6a) satisfied substitution. obtain upper bound suffices construct model
Kex (rather model str(Kex )); thus, prevent application rule (R6aU)
python chase, dispense eats(python, c1 ) materialisation. }
ready define c-chase formally.
Definition 5.8. Let H = split(K), let dH subset datalog rules H ,
eH = H \ dH . c-chase sequence K sequence sets ground atoms {B }i 0 ,
B 0 = DH (i.e. B 0 = DK ), B i+1 inductively defined given next. Let Sdi+1
Sei+1 defined follows:
Sdi+1 = {head(r) | r 2 dH ,

Sei+1 = {head(c-sk(r)) | r 2 eH ,

substitution, B |= body(r) B 6|= head(r)}
substitution, B |= body(r) B 6|= head(r)}

Then, B i+1 = B [ Sdi+1 Sdi+1
6 ;, B i+1 = B [ Sei+1 otherwise. Finally, define
=
c-chase K c-ChaseK = 0 B .
}

Note c-chase K finite set since terms occur
constants c-sk(split(K)).
Example 5.9. c-chase Kex depicted Figure 2. materialisation strict
subset Figure 1, orange-coloured binary facts longer derived.
Consequently, python longer derived answer qex .
}
relevant properties c-chase summarised following lemma.
Theorem 5.10. following properties hold: (i) cert(?, K) cert(?s , c-ChaseK ), i.e.
K unsatisfiable, ?s 2 c-ChaseK ; (ii) K satisfiable, cert(q, K) cert(q, c-ChaseK ).
Proof. first prove c-ChaseK model split(K). Since DK c-ChaseK clear
satisfies facts split(K). Let r 2 split(K); distinguish two cases:
rule r datalog. c-ChaseK |= body(r) substitution definition
c-chase ensures head(r) 2 c-ChaseK hence rule satisfied.
Otherwise, r form (3). c-ChaseK |= body(r) substitution
definition c-ChaseH ensures head(c-sk(r)) 2 c-ChaseK ; thus, c-ChaseK |=
head(r) hence rule satisfied.
show contrapositive first property. Assume ?s 62 c-ChaseK .
c-ChaseK model split(K), split(K) 6|= ?s hence K satisfiable
Theorem 5.5. Finally, assume K satisfiable. cert(q, K) = ;, cert(q, K) cert(q, H)
holds trivially; otherwise let ~a certain answer q w.r.t. K. Theorem 5.5, obtain
~a 2 cert(q, split(K)). c-ChaseK |= split(K), ~a 2 cert(q, c-ChaseK ).
330

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

c1

tiger
Mammal
Herbivore
MeatEater

MeatEater
Mammal
Herbivore
Plant

lion
Mammal
Herbivore
MeatEater

c2

python

Plant

grass Plant

wolf

rabbit

MeatEater

Herbivore
Mammal
MeatEater

Mammal
MeatEater
Herbivore

c3

sheep
Herbivore
Mammal
MeatEater
Plant

Leaf
Plant

willow Plant

howler

hare

Mammal
Folivore
Herbivore
MeatEater

Mammal
Folivore
Herbivore
MeatEater

Figure 2: c-chase Kex
5.3 Tightening Upper Bound: Disjunctive Rules
Although technique described previous section quite eective practice,
main limitation split(K) disjunctions heads rules K eectively turned conjunctions. section, show refine upper bound
exploiting extension c-chase uses similar approach deal disjunctive
rules well existential rules.
Specifically, extend c-chase deal disjunctive rules r form (4)
(i) r applied none disjuncts head rule already
satisfied; (ii) r applied, one disjuncts included chase (rather
them). order avoid non-determinism chase expansion reduce
computational cost, disjuncts selected deterministically means (efficiently
implementable) choice function.
Example 5.11. Consider running example. First observe wolf answer
qex w.r.t. c-chase Kex shown Figure 2. Indeed, Herbivore(wolf ) derived
Mammal(wolf ) rules split (R5); thus, Plant(sheep) derived using
rule (R4). Note, however, wolf spurious answer: given MeatEater(wolf )
explicit fact Kex , rule (R5) already satisfied wolf hence dispense
fact Herbivore(wolf ) materialisation.
Finally, since goal construct model Kex reasonable pick disjuncts
whose predicate unrelated ? Kex . Since ? depends MeatEater Folivore
(by rule (R3)), makes sense include fact Herbivore(b) materialisation whenever
disjunctive rule (R5) applied constant b.
}
details refer reader Section 8, specific choice function
implemented PAGOdA described.
define extended notion c-chase, efficiently implementable
choice function given additional parameter.
Definition 5.12. Let H knowledge base obtained K replacing ?
nullary predicate ?s , let dH set datalog rules H , let nH = H \ dH .
Furthermore, let f polynomially computable choice function given ground clause
set ground atoms returns disjunct . c-chase sequence K w.r.t. f
331

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

c2

tiger
Mammal
Herbivore

lion
Mammal
Herbivore

python
MeatEater

Plant

grass Plant

wolf

rabbit
Herbivore
Mammal

Mammal
MeatEater

c3

sheep
Herbivore
Mammal

Leaf
Plant

willow Plant

howler

hare

Mammal
Folivore
Herbivore

Mammal
Folivore
Herbivore

Figure 3: c-chasef Kex
sequence sets ground atoms {B }i 0 , B 0 = DH (i.e., B 0 = DK ), B i+1
defined given next. Let Sdi+1 Sni+1 follows:
Sdi+1 = {head(r) | r 2 dH ,

Sni+1 = {f (head(c-sk(r)) , B ) | r 2 nH ,

substitution, B |= body(r) B 6|= head(r)}

substitution , B |= body(r) B 6|= head(r)}

Then, B i+1 = B [ Sdi+1 Sdi+1 6= ;, B i+1 = B [ Sni+1 otherwise. Finally, define

c-chase K w.r.t. f c-ChasefK = 0 B .
}
Example 5.13. Consider aforementioned choice function f picks Herbivore(b)
whenever rule (R5) applied fact Mammal(b). Figure 3 depicts facts c-ChasefKex .
observed c-ChasefKex strict subset materialisation Figure 2,
brown-colored facts longer derived. see wolf answer
qex w.r.t. c-ChasefKex hence identified spurious. Furthermore, nullary
predicate ?s derived hence determine Kex satisfiable. }
relevant properties variant c-chase follows.
Theorem 5.14. Let f choice function Definition 5.12. ?s 62 c-ChasefK ,
c-ChasefK model K cert(q, K) cert(q, c-ChasefK ).
Proof. dataset DK contained c-ChasefK , suffices show c-ChasefK satisfies
rule r 2 K. distinguish following cases:
r form (2). Since ?s 2
/ c-ChasefK , cannot exist substitution
c-ChasefK |= body(r) hence c-ChasefK satisfies r vacuously.



r form (3). Pick c-ChasefK |= body(r) . definition c-ChasefK
ensures head(c-sk(r)) 2 c-ChasefK hence c-ChasefK satisfies r.
r form (4). Pick c-ChasefK |= body(r) . definition
c-ChasefK , f (head(c-sk(r)), Sni ) 2 c-ChasefK set atoms Sni
chase sequence, c-ChasefK satisfies r.

q = ?, cert(q, K) = ; cert(q, K) cert(q, c-ChasefK ) holds trivially; otherwise,
cert(q, K) cert(q, c-ChasefK ) follows fact c-ChasefK model K.
332

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

5.4 Combined Upper Bound
introduced three dierent techniques computing upper bound cert(q, K).
1. Compute materialisation M1U str(K), evaluate q w.r.t. M1U obtain set
possible answers U1q q w.r.t. K (c.f. Section 5.1).
2. Compute c-chase K, denoted M2U , evaluate q w.r.t. M2U obtain set
possible answers U2q q w.r.t. K (c.f. Section 5.2).
3. Fix choice function f , compute c-chase K w.r.t. f , denoted M3U , evaluate q w.r.t. M3U obtain set possible answers U3q q w.r.t. K (c.f. Section 5.3).

trivially seen U2q U3q precise U1q , i.e. U2q U1q U3q U1q .
shown following example, U2q U3q are, however, incomparable.

Example 5.15. Consider knowledge base H consisting facts A(a1 ), R(a1 , b1 ), B(b1 ),
A(a2 ), R(a2 , b2 ), B(b2 ) rules B(x) ! C(x) _ D(x), R(x, y) ^ C(y) ! S(x, y)
A(x) ! 9yS(x, y). Let c freshly introduced constant A(x) ! 9yS(x, y), let
f choice function picks disjunct D(bi ) every clause C(bi ) _ D(bi ). Then,
c-ChaseH = DH [ {C(b1 ), D(b1 ), S(a1 , b1 ), C(b2 ), D(b2 ), S(a2 , b2 )},
c-ChasefH = DH [ {D(b1 ), S(a1 , c), D(b2 ), S(a2 , c)}.

q1 (x) = 9y(S(x, y) ^ C(y) ^ D(y)), upper bound computed using c-ChaseH
contains two additional answers a1 a2 compared computed using c-ChasefH .
q2 (x1 , x2 ) = 9y(S(x1 , y) ^ S(x2 , y)), upper bound computed using c-ChasefH
additional answers (a1 , a2 ) (a2 , a1 ) compared computed using c-ChaseH . }

are, however, tradeos considered. Clearly, upper bound U1q
convenient ease implementation point view: str(K) constructed,
bound directly computed using o-the-shelf datalog reasoner without modification. Furthermore, upper bound U3q important shortcoming: use
whenever ?s derived, show following example.
Example 5.16. Consider choice function g picks MeatEater(a) disjunction form Herbivore(a) _ MeatEater(a). c-chase Kex w.r.t. g derive
MeatEater(howler) fact Mammal(howler) disjunctive rule (R5). Using
fact Folivore(howler) rule (R3U) derive ?s . Thus see that, although
howler cert(qex , Kex ), Herbivore(howler) c-chase Kex w.r.t. g, hence
howler upper bound computed using it; contrast two
upper bounds, Herbivore(howler) materialisation str(Kex ) c-chase
Kex , hence howler upper bound computed w.r.t. them.
}
Therefore, ?s 62 c-ChasefK , combine U2q U3q compute hopefully
precise upper bound; otherwise, use U2q . combined upper bound query answer
U q q K formally defined follows:
8 ?s
?
< U2 \ U3 q = ?;
q
q
q
U =
(13)
U \ U3
q 6= ? ?s 62 c-ChasefK ;
: 2q
U2
otherwise.
333

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

Example 5.17. combined upper bound qex Kex gives:
Uex = {tiger, lion, rabbit, sheep, howler, hare}.
compare upper bound aggregated lower bound Lex given Example 4.9
identify gap Gex = {tiger, lion, rabbit}.
}

6. Reducing Size Knowledge Base
Whenever non-empty gap Gq lower upper bound (e.g., running
example) need verify whether answer Gq spurious not. Accomplishing
task using fully-fledged reasoner computationally expensive: verifying
answer Gq typically involves satisfiability test, infeasible practice
large-scale knowledge bases.
section propose technique identifying (typically small) subset Kq
knowledge base K sufficient verifying answers Gq (i.e. ~a 2 cert(q, K)
~a 2 cert(q, Kq ) ~a 2 Gq ). essential subsets be, one hand,
small possible and, hand, efficiently computable. requirements
conflict: computing minimal-sized subsets hard answering query, whereas
subsets easily computed may almost large initial knowledge base.
main idea behind approach construct datalog knowledge base whose
materialisation identifies rules facts Kq . knowledge base size polynomial
sizes K q include predicates arity higher K
q. way, subset computation fully delegated scalable datalog reasoner,
hence addressing efficiency requirement. key property Kq , ensures
contains relevant information K, following: rule fact 2
/ Kq
show occur hyperresolution proof (resp. gap answer
Gq ) K [ Rq q = ? (resp. q 6= ?). completeness hyperresolution
guarantees excluded facts rules indeed irrelevant.
6.1 Overview Approach
Let us motivate main ideas behind approach using running example. Since ?s
derived M2U \ M3U , know cert(?, Kex ) = ;, hence Kex
satisfiable (see Example 5.13). However, still need determine whether answers
Gex = {tiger, lion, rabbit} combined upper bound cert(qex , Kex ), i.e.,
certain answers qex .
sketch construction datalog knowledge base track(Kex , qex , Gex )
subset Kex relevant answers Gex derived. key property
knowledge base materialisation tracks rules facts may
participate hyperresolution proof gap answer thus encodes contents
subset Kqex . relevant information recorded using fresh predicates constants:
fresh predicate P R predicate P Kex , extension
materialisation track(Kex , qex , Gex ) give us facts subset.

334

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

fresh constant dr rule r Kex special unary predicate Rel,
extension materialisation track(Kex , qex , Gex ) give us rules
subset.
key step construction knowledge base invert rule r 2 Kex
set datalog rules (r) (i) moving head atoms r body
replacing predicates corresponding fresh ones (e.g., replace P P R );
(ii) copying atoms originally body r (now empty) head
replacing predicates corresponding fresh ones adding special atom
Rel(dr ) additional conjunct; (iii) eliminating conjunction head r
splitting r multiple rules, one head conjunct.
Consider first example datalog rule (R4) Kex , inverted
following rules:
PlantR (y) ^ Herbivore(x) ^ eats(x, y) ! HerbivoreR (x)
R

R

Plant (y) ^ Herbivore(x) ^ eats(x, y) ! eats (x, y)
R

Plant (y) ^ Herbivore(x) ^ eats(x, y) ! Rel(dR4 )

(14)
(15)
(16)

head Plant(y) (R4) moved body predicate Plant replaced
PlantR ; body Herbivore(x) ^ eats(x, y) copied head conjunction
HerbivoreR (x) ^ eatsR (x, y), conjoined special atom Rel(dR4 ); finally
head conjunction eliminated splitting rule three separate rules.
rules reflect intuitive meaning freshly introduced predicates. fact
PlantR (c) holds constant c, means fact Plant(c) may participate
hyperresolution proof Kex answer gap. Additionally, Herbivore(b)
eats(b, c) hold b, facts rule (R4) could participate
one proof since Plant(c) hyperresolvent facts Herbivore(b) eats(b, c)
rule (R4), recorded facts HerbivoreR (b), eatsR (b, c), Rel(dR4 ). Thus, rules
(14)(16) faithfully invert hyperresolution steps involving rule (R4).
Similarly, disjunctive rule (R5) inverted following two rules:
HerbivoreR (x) ^ MeatEaterR (x) ^ Mammal(x) ! MammalR (x)
R

R

Herbivore (x) ^ MeatEater (x) ^ Mammal(x) ! Rel(dR5 )

(17)
(18)

case, disjunctive head Herbivore(x)_MeatEater(x) (R5) moved
body conjunction HerbivoreR (x) ^ MeatEaterR (x) fresh predicates HerbivoreR
MeatEaterR . facts HerbivoreR (c) MeatEaterR (c) hold c (which means
facts Herbivore(c) MeatEater(c) may participate relevant proof Kex )
Mammal(c) holds, deem fact Mammal(c) rule (R5) relevant.
situation dierent comes inverting existentially quantified rules,
case longer capture relevant hyperresolution steps Kex faithfully. Consider
rule (R7), inverted follows:
eatsR (x, y) ^ Mammal(x) ! MammalR (x)
R

eats (x, y) ^ Mammal(x) ! Rel(dR7 )
335

(19)
(20)

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

case, existentially quantified head 9y eats(x, y) moved body atom
eatsR (x, y). eatsR (b, c) holds b c (and hence fact may participate
relevant proof), Mammal(b) holds, record (R7) Mammal(b)
relevant (the latter means fact MammalR (b)). hyperresolvent Mammal(b)
(R7) atom eats(b, t), functional term, may unrelated eats(b, c)
hence irrelevant proving answer gap.
addition inverting rules Kex , construction track(Kex , qex , Gex )
needs take query gap answers account. this, encode query
eats(x, y) ^ Plant(y) ! Pqex (~x) rules
PqRex (x) ^ eats(x, y) ^ Plant(y) ! eatsR (x, y)

(21a)

PqRex (x) ^ eats(x, y) ^ Plant(y) ! PlantR (y)

(21b)

add fact PqRex (c) c 2 Gex . query-dependent rules used initialise extension fresh predicates, subsequently makes rules
track(Kex , qex , Gex ) applicable.
query answers gap stem upper bound; consequently, order
rules (21a) (21b) applicable data track(Kex , qex , Gex ) obtained
upper bound materialisation Kex . following section show suffices
include facts c-chase Kex order ensure computed subset
contain necessary facts rules.
6.2 Subset Definition Properties
ready formally define datalog knowledge base used subset computation
well corresponding relevant subset.
Definition 6.1. Let G set possible answers q, let Rel fresh unary predicate
let dr fresh constant unique r K [ Rq . Furthermore, predicate
P K [ Rq , let P R fresh predicate arity P and, atom = P (~t),
let R denote P R (~t). normalised rule r 2 K [ Rq , let move(r) following
conjunction atoms:
P?R r form (2);


R x, ~
z1 )
1 (~



R x)
1 (~

Then,

r form (3);

^ ^

R x)
(~

r form (4).

(r) following set rules:

(r) = {move(r) ^ body(r) ! Rel(dr )} [ {move(r) ^ body(r) !

R
k

|

k

body(r)}.

tracking knowledge base track(K, q, G) smallest knowledge base containing
(i) facts c-chase K;

(ii) rules r2K[Rq (r);
336

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

(iii) fact PqR (~a) ~a 2 G;
(iv) fact P?R q 6= ?.
subset K relevant q G, denoted Kq,G , smallest knowledge base
containing
rule r 2 K track(K, q, G) |= Rel(dr );
fact 2 DK track(K, q, G) |= R .
brevity, write Kq particular case G set gap answers Uq \ Lq
defined Sections 4.3 5.4.
}
Note K? subset Kq since track(K, ?, G? ) subset track(K, q, Gq ):
Definition 6.1, point (i) track(K, ?, G? ) track(K, q, Gq ); furthermore,
set rules (ii) track(K, ?, G? ) subset track(K, q, Gq ) since
K [ R? K [ Rq ; finally, fact P?R , included track(K, ?, G? ) point (iii),
belongs track(K, q, Gq ) point (iv).
Example 6.2. Consider running example, Gex = {tiger, lion, rabbit}.
subset Kex relevant qex Gex consists rules R2, R4, R5, R6, R7 facts
D1, D2, D3, D5, D7, D9, D11.
}
key properties computed subsets established following theorem.
Theorem 6.3. following properties hold:
(1) Assume L? = ;. Then, K unsatisfiable K? unsatisfiable.
(2) Let q dierent ? let G non-empty set possible answers q w.r.t.
K. K satisfiable, ~a 2 cert(q, K) ~a 2 cert(q, Kq,G ) every ~a 2 G.
Proof. direction (1) (2) follows directly monotonicity firstorder logic. direction (1) (2) follows completeness
hyperresolution following claim, establishes q non-empty
G, Kq,G contains support hyperresolution derivations clause (q, G)
K [ Rq

{}
q = ?;
(q, G) =
{Pq (~a) | ~a 2 G} otherwise.
Claim (|) = ( , ) derivation 2 (q, G) K [ Rq , support() Kq,G .
show direction (1), assume K unsatisfiable. Theorem 5.10,
Theorem 5.14 (13), U ? 6= ; thus G? 6= ;. exists hyperresolution
derivation 1 K. Since (?, G? ) = {}, know support(1 ) K?
(|). K? unsatisfiable. show direction (2), assume ~a 2 G
~a 2 cert(q, K). exists hyperresolution 2 Pq (~a) K [ Rq . Similarly,
(|), know support(2 ) Kq,G hence ~a 2 cert(q, Kq,G ).
337

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

next show inductively statement (|) follow. Let = ( , )
derivation clause (q, G) K [ Rq , let H = split(K). already
established (see proof Theorem 5.10) c-ChaseK model H. Since ChaseH
universal model H exists homomorphism ChaseH c-ChaseK . show
following properties inductively every node v .
a. track(K, q, G) |= R , atom (v);
b. track(K, q, G) |= Rel(dr ), sk(r) main premise used obtain parent u v.
proceed induction distance v root .
Base case: base case v root . Property (b) follows vacuously
since v parent .
q = ?, derivation empty clause (v) empty disjunction
and. property (a) follows vacuously.
Otherwise, (v) = Pq (~a) ~a 2 G. definition track(K, q, G) (point
(iii)) ( (v))R 2 track(K, q, G) hence property (a) holds.
Inductive step: Assuming properties (a) (b) hold node u, show
hold children v1 , . . . , vn u. Let r rule K sk(r)
main premise relevant hyperresolution step MGU , i.e., (u) = 1 _ _
_ 1 _ _ n hyperresolvent sk(r) = 1 _ _ n _ 1 _ _
(vi ) = _ 1 n, using . easy observation composition
substitution homomorphism used later rest proof.
(

) = ( ) arbitrary function-free atom .

(22)

Lemma 5.4 Section 5.1 2 ChaseH 1 n. Since
homomorphism ChaseH c-ChaseK ( ) 2 c-ChaseK
(22), ( ) 2 c-ChaseK 1 n. next show track(K, q, G) |= move(r) .
= 0, move(r) = P?R . distinguish two cases.
q 6= ?, P?R 2 track(K, q, G) point (iv);

q = ?, ?s 2 c-ChaseK hence PqR 2 track(K, q, G) point (iii).
Otherwise, induction hypothesis, track(K, q, G) |= (
(22), track(K, q, G) |= jR ( ) 1 j m.

j

)R

Therefore track(K, q, G) |= move(r) . body rules (r) satisfied
substitution hence track(K, q, G) |= Rel(dr ), track(K, q, G) |= iR ( )
1 n. (22), track(K, q, G) |= ( iR ) 1 n. addition,
induction hypothesis, track(K, q, G) |= R
, 1 n. Hence, shown
(a), (b) hold child vi u.
remains shown (a) (b) imply (|). Indeed, take 2 support().
338

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

fact K, leaf node ; hence, property (a)
track(K, q, G) |= R . then, since fact DK definition homomorphism ensures R = R . definition Kq,G implies 2 Kq,G .
rule K, Property (b) track(K, q, G) |= Rel(d ). Again,
definition Kq,G ensures 2 Kq,G .
completes proof theorem.
Note Claim (|) proof theorem establishes important property
computed subsets, namely proof-preserving; is, support every
hyperresolution proof relevant gap answer original knowledge base K
contained computed subset. two key implications. First, every justification
(i.e., minimal subset K entailing gap answer) contained subset;
way, subsets preserve formulas K relevant gap answers,
formulas disregarded seen irrelevant. Second, fully-fledged reasoner
whose underpinning calculus cast framework resolution able
compute subset derivations gap answers K. Consequently,
practice reasonable expect fully-fledged reasoner uniformly display
better performance computed subsets Kan expectation borne
experiments.
conclude section example illustrating dataset track(K, q, G)
(point 1 Definition 6.1) obtained c-ChaseK materialisation underpinning
upper bound Section 5.2rather c-ChasefK Section 5.3.
Example 6.4. Consider query q(x) = E(x) knowledge base K consisting
following rules facts.
A(x) ! B(x) _ D(x)

D(x) ! E(x)

B(x) ! E(x)

A(a)

Let f function always choosing B(a) D(a), c-ChasefK = {A(a), B(a), E(a)}
constant answer q(x) gap lower upper bound. Suppose
define track(K, q, G) Definition 6.1 replacing facts point (i)
c-ChasefK . Since D(a) hold c-ChasefK corresponding subset
contain rule D(x) ! E(x), essential derive E(a).
}
6.3 Optimisations Datalog Encoding
conclude section, present two optimisations datalog encoding Definition
6.1 exploit system PAGOdA.
first optimisation aims reducing size computed subsets. Recall
key step construction tracking knowledge base track(K, q, G) invert
rules K capture hyperresolution proofs backwards fashion. Consider
inversion (17) rule (R5) running example. eect inversion capture applicability hyperresolution: facts Mammal(rabbit), HerbivoreR (rabbit)
MeatEaterR (rabbit) hold, include rule (R5) subset since may proof
339

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

K involving step ground clause Herbivore(rabbit) _ MeatEater(rabbit) _
obtained resolving (R5) Mammal(rabbit) _ .
Note, however, step redundant Herbivore(rabbit) already contained K, case (R5) may needed relevant subset. capture
observation distinguishing tracking knowledge base facts c-chase
K already present original dataset DK . encode implied
facts instantiating fresh predicates P predicate P K. running example,
fact MeatEaterI (rabbit) tracking knowledge base establishes MeatEater(rabbit)
present original data. use atoms predicates guards
inverted rules, e.g. rule (17) would written follows:
HerbivoreI (x) ^ MeatEaterI (x) ^ HerbivoreR (x)

^ MeatEaterR (x) ^ Mammal(x) ! MammalR (x)

Formally, Definition 6.1 optimised given next.
Definition 6.5. Let K, q, G predicates P R Definition 6.1. predicate
P , let P fresh predicate arity P . redefine move(r)
rule r following conjunction atoms:
P?R r form (2);


x, ~
z1 )
1 (~



x)
1 (~

^

R x, ~
z1 )
1 (~

^ ^

x)
(~

r form (3);

^

R x)
1 (~

^ ^

R x)
(~

r form (4).

Then, (r) Definition 6.1, track(K, q, G) Definition 6.1, extended
addition fact P (~a) fact P (~a) c-ChaseK DK . }
easy see optimisation aect correctness Theorem 6.3:
disjunction atoms derived via hyperresolution, one atoms already
present data, disjunction subsumed dispensed with.
second optimisation used obtain succinct encoding datalog
reasoners support equality reasoning natively (such RDFox). already mentioned,
built-in semantics equality predicate axiomatised within datalog. However,
axiomatisation lead performance issues, scalability improved native
treatment equality equal objects merged single representative
whole equivalence class.
axiomatisation equality significant eect tracking encoding.
example, replacement rules r form (EQ4) inverted following rules
(r) predicate P :
P R (x1 , . . . , xi

1 , y, xi+1 , . . . , xn )

P R (x1 , . . . , xi

1 , y, xi+1 , . . . , xn )

^ P (x1 , . . . , xn ) ^ xi ! P R (x1 , . . . , xn )
^ P (x1 , . . . , xn ) ^ xi ! R (xi , y)

(23)
(24)

(23) tautology dispensed with, rule (24) required.
datalog reasoner native support equality, need include
340

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

tracking knowledge base inversion equality axioms (EQ1), (EQ2) (EQ3),
need include rules (24) order ensure computed subset required
properties. result succinct encoding materialised efficiently.
Example 6.6. Consider knowledge base K consists facts {R(a1 , b), R(a2 , b), A(a1 )}
following rules.
A(x) ! B(x) _ C(x)

R(x1 , y) ^ R(x2 , y) ! x1 x2

(25)
(26)

B(x) ! D(x)
C(x) ! D(x)

(27)
(28)

Let q = D(x), gap G lower upper bounds q {a1 , a2 }. easy
see rule (26) essential derive q(a2 ). ensure rule fragment
Kq,G , track a1 a2 using instance rule (24).
}
6.4 Comparison Magic Sets
idea inverting rules recording relevant information heavily exploited
Logic Programming. particular, magic set transformation (Bancilhon, Maier, Sagiv,
& Ullman, 1986) technique that, given program query, optimises materialisation process derive facts relevant query. Similarly
tracking encoding, magic sets technique uses auxiliary predicates, called magic predicates, identify relevant facts. technique originally developed datalog,
subsequently extended handle negation failure (Beeri, Naqvi, Ramakrishnan, Shmueli, & Tsur, 1987; Kemp, Srivastava, & Stuckey, 1995) disjunctions (Alviano,
Faber, Greco, & Leone, 2012a).
contrast magic sets, goal transformation reduce size
materialisation, rather compute relevant fragment knowledge base potentially
given expressive (even undecidable) language, reduce computation
datalog reasoning. sense, technique orthogonal magic sets. Indeed,
benefits technique relevant knowledge bases containing existentially
quantified and/or disjunctive rules (if K datalog, query would fully
answered lower bound).
Furthermore, worth noticing way invert (datalog) rules dierent
magic sets yields precise tracking. assumption
tracking starts already computed materialisation (see Point (i) Definition
6.1). instance, given already adorned rule A(x) ^ B(x) ! C(x), magic sets would
produce following rules deriving magic predicates B B:
C (x) ! (x)

C (x) ^ A(x) ! B (x)

rules used derive fact (a) C (a), even A(a) cannot used
derive C(a) aforementioned rule applicable (e.g., B(a) hold
C(a) derived using rules). transformation, contrast, would yield
restrictive rules
C R (x) ^ A(x) ^ B(x) ! AR (x)

C R (x) ^ A(x) ^ B(x) ! B R (x)

applicable A(a) B(a) hold materialisation.
341

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

7. Summarisation Analysis Answer Dependencies
section, let q input query dierent unsatisfiability query ?.
K? Kq computed, still need check, using fully-fledged reasoner,
satisfiability K? well whether Kq entails candidate answer Gq .
computationally expensive subsets large complex, many
candidate answers verify. therefore exploit summarisation techniques (Dolby et al.,
2007) eort reduce number candidate answers.
idea behind summarisation shrink data knowledge base merging
constants instantiate unary predicates. Since summarisation equivalent
extending knowledge base equality assertions constants, summary
knowledge base entails original one monotonicity first-order logic. Consequently, exploit summarisation follows:
1. satisfiability K remains undetermined, construct summary K?
check satisfiability. satisfiable, K? (and thus K) satisfiable.
2. Construct summary Kq use fully-fledged reasoner check whether
summary ~a entailed certain answer q summary Kq ,
discarding answers entailed.
Formally, summarisation defined follows.
Definition 7.1. type set unary predicates; given constant c K, say
= {A | A(c) 2 K} type c. type , let fresh constant
uniquely associated . summary function K substitution mapping
constant c K , type c. Finally, summary K K . }
following proposition shows summarisation exploited detect spurious
answers setting. Since summarisation significantly reduce data size practice,
relevant subsets K? Kq already significantly smaller K, checking
satisfiability K? gap answer Kq becomes feasible many cases, even
though implies resorting fully-fledged reasoner.
Proposition 7.2. Let summary function K. Satisfiability K? implies
following: (i) K satisfiable; (ii) cert(q, K) cert(q , Kq ) every CQ q.
Example 7.3. case running example, constants tiger lion
type {Mammal}, therefore mapped fresh constant, say tMammal , uniquely
associated {Mammal}. Since tMammal certain answer qex w.r.t. summary
Kex , determine tiger lion spurious answers.
}
summarisation succeed pruning candidate answers G, try
last step reduce calls fully-fledged reasoner exploiting dependencies
remaining candidate answers that, answer ~a depends answer ~c,
~a spurious, ~c.
Consider two tuples ~c d~ constants Gq . Suppose find endomor~ determine (by calling fully-fledged
phism dataset DK ~c = d.
~
reasoner) spurious answer, must ~c; result, longer need
call fully-fledged reasoner verify ~c. endomorphisms defined next.
342

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

Definition 7.4. Let ~c = (c1 , . . . , cn ) d~ = (d1 , . . . , dn ) n-tuples constants K.
endomorphism ~c d~ K mapping constants constants
(i) ci = di 1 n; (ii) P (t1 , . . . , tm ) 2 DK fact P (t1 , . . . , tm ) 2 DK ;
(iii) r 2 K r 2 K .
}
relevant property endomorphisms given following proposition.
Proposition 7.5. Let ~c, d~ possible answers q let endomorphism ~c
d~ K. Then, ~c 2 cert(q, K) implies d~ 2 cert(q, K).
Proof. Since ~c 2 cert(q, K), know K |= q(~c). hyperresolution derivation
= (T, ) Pq (~c) K [ Rq . easy check (T,
) hyperresolution
~ K [ Rq . Then, K |= q(d)
~ hence d~ 2 cert(q, K).
derivation Pq (d)
exploit idea compute dependency graph candidate answer tuples
~ whenever endomorphism DK exists mapping ~c d.
~ Since
nodes edge (~c, d)
computing endomorphisms hard resort practice sound greedy algorithm
approximate dependency graph, describe Section 8.

8. Implementation: PAGOdA System
implemented approach system called PAGOdA, written Java
available academic license. system integrates datalog reasoner
RDFox (Motik et al., 2014) fully-fledged OWL 2 reasoner HermiT (Glimm et al.,
2014) black-boxes, exploit combined approach ELHOr? (see Section
4.2) implemented KARMA (Stefanoni et al., 2014).
PAGOdA accepts input arbitrary OWL 2 DL ontologies, datasets turtle format
(PrudHommeaux & Carothers, 2014) CQs SPARQL. Queries interpreted
ground certain answer semantics. former case, PAGOdA sound
complete. latter case, however, PAGOdA limited capabilities HermiT,
check entailment ground DL concept queries; hence, PAGOdA
guarantee completeness lower upper bounds match, query
transformed DL concept query via internalisation (see Section 2.3). Otherwise,
PAGOdA returns sound (but possibly incomplete) set answers, along bound
incompleteness computed answer set.
architecture PAGOdA depicted Figure 4. box Figure 4 represents
component PAGOdA, indicates external systems exploited within
component. could, principle, use materialisation-based datalog reasoner
supports CQ evaluation incremental addition facts, fully-fledged OWL
2 DL reasoner supports fact entailment.
PAGOdA uses four instances RDFox (one lower bound, c-chase, cchasef subset extractor components) two instances HermiT (one
summary filter dependency graph components).
process fully answering query divided several steps. Here, distinguish query independent steps query dependent ones. see Figure
4, loading ontology materialisation steps query independent. Therefore,

343

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

cert(q, [ D)
heuristic planner

G0 Gq

HermiT
q, Gq

summary filter
HermiT
q, Gq

endomorphism
checker

Full reasoning

Kq

Lq

subset extractor

tracking encoder

Extracting subsets

RDFox
track(, q, Gq )

, q, Gq

Gq

Lq
F



Computing query bounds

soundAnswers(q, [ D)
certU3 (q, [ D)

M2L
q
lower store
KARMA
RDFox

certU2 (q, [ D)

M3U

M2U
q

q
c-chase

f

*

c-chase
RDFox

RDFox



Materialisation



shift

Loading ontology & data

profile checker

normaliser
HermiT clausifier


Figure 4: architecture PAGOdA
counted pre-processing steps. Computing query bounds, extracting subset
full reasoning query dependent, called query processing steps.
next describe component, following process flow PAGOdA.
8.1 Loading Ontology Data
PAGOdA uses OWL API parse input ontology O. dataset given
separately turtle format. normaliser computes set rules corresponding
axioms ontology. PAGOdAs normaliser extension HermiTs clausification
component (Glimm et al., 2014), transforms axioms so-called DL-clauses (Motik
et al., 2009). dataset loaded directly (the four instances of) RDFox.
normalisation, ontology checked determine inside OWL 2 RL
ELHOr? . input ontology OWL 2 RL (resp. ELHOr? ), RDFox (resp.
KARMA) already sound complete, cases PAGOdA simply processes
344

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

ontology, dataset queries using relevant component. Otherwise, PAGOdA uses
dedicated program shifting component enrich deterministic part ontology
additional information disjunctive rules (see Section 4.1), resulting set rules .
8.2 Materialisation
three components involved step, namely lower bound, c-chase cchasef . takes input D, computes materialisation (shown
Figure 4 ellipses). lower bound component performs Steps 1 2 Section 4.3
order compute aggregated lower bound M2L . c-chase c-chasef components
compute M2U M3U upper bound materialisations described Section 5.4 using
dedicated implementation c-chase algorithm. chase sequence stored RDFox,
applicability existential disjunctive rules determined posing SPARQL
queries RDFox. applying disjunctive rule (while computing M3U ), PAGOdA
uses choice function select one disjuncts. discussed Section 5.4, choice
function try select disjuncts (eventually) lead contradiction.
end, PAGOdA implements following heuristics.
construct standard dependency graph containing edge predicate P
Q rule P occurs body Q head. Then, compute
preference ordering predicates occurring disjunction according
distance ? dependency graph, preferring furthest ?.
exploit result materialising using shifting enriched rules (see
Section 4.1). fact form P (~a) obtained materialisation, P (~a)
follows knowledge base. Hence, obtained P (~a), try
avoid choosing P (~a) disjunct P (~a) _ chase computation.
M2L contains contradiction, input ontology dataset unsatisfiable,
PAGOdA reports terminates. ?s derived M3U , computation
aborted M3U longer used. M2U contains ?s , PAGOdA checks
satisfiability [ D; eect, computes cert(?, [ D). answer query
non-empty, input ontology dataset unsatisfiable, PAGOdA reports
terminates; otherwise input ontology dataset satisfiable, PAGOdA
able answer queries.
8.3 Computing Query Bounds
Given query q, PAGOdA uses M2L lower bound materialisation compute lower
bound answer Lq . order exploits KARMAs implementation filtration
procedure (algorithm soundAnswers Section 4.2), clarity step shown separately (as circle F it) Figure 4. ?s derived computing
M3U materialisation, U q = cert(q, M2U ) \ cert(q, M3U ); otherwise U q = cert(q, M2U ). either
case U q computed directly using RDFox answer q w.r.t. relevant materialisation.
Extracting Subsets tracking encoder component implements datalog encoding
based Definition 6.1 optimisations described Section 6.3. resulting
datalog knowledge base added rules data c-chase component,
345

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

RDFox used extend c-chase materialisation accordingly. freshly derived facts
(over tracking predicates introduced tracking encoder) passed
subset extractor component, uses facts identify facts rules
relevant checking gap answers, computes intersection relevant facts
input dataset querying instance RDFox containing only.
8.4 Full Reasoning
PAGOdA uses HermiT verify gap answers Gq = U q \ Lq . HermiT accepts
queries given either facts DL concepts, implemented standard rolling-up
technique transform internalisable CQs. summary filter component, PAGOdA uses
HermiT filter gap answers entailed summary Kq (see Section 7).
remaining gap answers G0 Gq passed endomorphism checker,
exploits greedy algorithm compute incomplete dependency graph answers
G0 . graph used heuristic planner optimise order answers
G0 checked using HermiT (see Section 7). Verified answers G0 combined
lower bound Lq give cert(q, [ D).
implementation summarisation straightforward: PAGOdA essentially merges
constants (explicit) types data.

1
2
3
4
5
6
7
8
9
10

1
2
3
4
5
6
7
8
9
10
11
12

Input: knowledge base K = K [ DK , two tuples (a1 , . . . , ), (b1 , . . . , bn ).
Output: return true endomorphism (a1 , . . . , ) (b1 , . . . , bn ) K found,
otherwise, false.
= ;;
foreach 2 [1..n]
ai locally embeddable bi K return false;
else (ai ) = bi ;
end
foreach 2 [1..n]
check(ai , bi ) return false;
end
K 6= K return false;
else return true;
Subroutine check(a, b)
Oa := {c | P (ai , c) 2 DK }, Ia := {c | P (c, ai ) 2 DK };
Ob := {d | P (bi , d) 2 DK }, Ib := {d | P (d, bi ) 2 DK };
foreach 2 {O, I} c 2 Sa
:= {d 2 Sb | c locally embedded d};
empty return false;
defined c
(c) := similar constant c D;
check(c, d) return false;
end
else (c) 62 return false;
end

Algorithm 1: Greedy endomorphism checker.

346

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

next describe greedy algorithm implemented PAGOdA checking answer
dependencies (see Algorithm 1). Given tuples (a1 , . . . , ) (b1 , . . . , bn ), algorithm
returns True able find endomorphism, False otherwise. algorithm
considers constant ai tries map bi locally, sense
immediate neighbourhoods ai bi considered stage. Formally,
captured following notion local embedding.
Definition 8.1. Given K constant c let Mc multiset containing occurrence
fact A(c) 2 DK , occurrence P binary fact P (c, c0 ) 2 DK ,
occurrence P binary fact P (c0 , c) 2 DK .
Given constants c K, say c locally embeddable predicate
Mc occurs (with cardinality) Md .
}
check(a, b) subroutine implements greedy search looking immediate neighbours b. Specifically, subroutine considers neighbour c picks
neighbour b c locally embedded d. several choices
available, algorithm heuristically chooses one according Jaccard similarity
multisets Mc Md .6 algorithm terminates success manages
compute mapping defined constants reachable {a1 , . . . , }
K. immediate see computed endomorphism ~a ~b K; thus,
algorithm sound. algorithm works polynomial time choices made
construction never revisited local embeddability checked efficiently.

9. Related Work
Conjunctive query answering ontology-enriched datasets received great deal
attention recent years. computational complexity thoroughly investigated
wide range KR languages number practicable algorithms proposed
literature implemented reasoning systems.
9.1 Computational Complexity CQ Answering
decision problem associated CQ answering conjunctive query entailment (CQE),
namely decide whether K |= q(~a) given input CQ q, possible answer ~a,
knowledge base K expressed (fixed) language L. problem well-known
undecidable general, even q restricted atomic L language
existential rules (Dantsin et al., 2001).
CQE knowledge bases stemming OWL DL ontologies decidable
assumption query mention transitive relations (Rudolph & Glimm, 2010).
Decidability CQE unrestricted OWL DL OWL 2 DL ontologies CQs remains
open problem. Even cases CQE decidable, typically high
computational complexity. CQE 2-ExpTime-complete expressive DLs SHIQ
SHOQ (Glimm et al., 2008; Eiter, Lutz, Ortiz, & Simkus, 2009). Hardness results
6. Jaccard similarity multisets 0 defined |M \ 0 |/|M [ 0 |, |M \ 0 | counts
minimum number occurrences common element 0 , whereas |M [ 0 | counts
sum occurrences elements 0 .

347

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

2-ExpTime obtained already ALCI (Lutz, 2008) well Horn-SROIQ,
underpins Horn fragment OWL 2 DL (Ortiz, Rudolph, & Simkus, 2011). CQE
ALC SHQ, involve inverse roles, ExpTime-complete (Lutz, 2008).
Single exponential time results obtained Horn DLs disallowing complex role
inclusion axioms: CQE ExpTime-complete Horn-SHOIQ, underpins Horn
fragment OWL DL (Ortiz et al., 2011).
Given high complexity CQE, recently increasing interest
lightweight DLs CQE computationally easier. lightweight DLs
incorporated OWL 2 standard profiles (Motik et al., 2012). CQE OWL
2 EL profile PSpace-complete (Stefanoni et al., 2014). Furthermore, complexity
CQE drops NP complex role inclusions (with exception transitivity
reflexivity) disallowed OWL 2 EL (Stefanoni & Motik, 2015). latter complexity
rather benign since CQE databases already NP-hard. Finally, CQE OWL
2 QL profile NP-complete (Calvanese et al., 2007). Regarding data complexity,
CQE coNP-complete non-Horn DLs, ALE (Schaerf, 1993). contrast,
data complexity PTime-complete Horn DLs encode recursion, HornSROIQ OWL 2 EL (Ortiz et al., 2011; Stefanoni et al., 2014). Finally, data complexity
known AC0 OWL 2 QL profile (Calvanese et al., 2007).
complexity CQE well understood rule-based KR languages. plain
datalog, ExpTime-complete combined complexity PTime-complete w.r.t. data
complexity. disjunctive datalog, coNExpTime-complete combined complexity
coNP-complete w.r.t. data complexity. Datalog refers family decidable KR
languages based existential rules (Cal, Gottlob, & Lukasiewicz, 2012). includes
guarded (Cal et al., 2013), sticky (Cal, Gottlob, & Pieris, 2011), acyclic (Cuenca Grau
et al., 2013) datalog . extension datalog languages disjunctive rules
recently studied (Alviano et al., 2012b; Bourhis et al., 2013).
Finally, refer ground query entailment (GCQE) problem checking whether
tuple ~a ground answer q(~x) = 9~y '(~x, ~y ) w.r.t. K. KR languages allow
existentially quantified rules, restriction ground answers typically makes CQE easier:
definition ground answers means GCQE trivially reduced satisfiability
checking. Consequently, GCQE decidable OWL 2 DL.
9.2 Practical Query Answering Approaches
o-the-shelf DL reasoners, Pellet (Sirin et al., 2007) HermiT (Glimm
et al., 2014) provide support query answering. Pellet supports SPARQL conjunctive
queries implements rolling-up technique. contrast, HermiT provide
SPARQL API supports CQs form (complex) DL concepts. Racer
among first DL reasoners implement optimise CQ answering ground
semantics (Haarslev, Hidde, Moller, & Wessel, 2012). Finally, intensive
work optimising query answering DL systems, including filter-and-refine techniques
(Wandelt et al., 2010), ordering strategies query atoms (Kollia & Glimm, 2013), data
summarisation (Dolby et al., 2009). Optimising CQ answering DL reasoners complementary approach, use optimised DL reasoner could significantly
improve performance PAGOdA queries require full reasoning.

348

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

RDF triple stores typically implement materialisation-based (a.k.a. forward chaining)
reasoning algorithms, answer queries evaluating resulting materialisation. Jena (McBride, 2001) Sesame (Broekstra, Kampman, & van Harmelen, 2002)
among first systems provide support RDF-Schema. Modern triple stores
OWLim (Bishop et al., 2011), Oracles native inference engine (Wu et al., 2008),
provide extended suppport ontologies RL profile. Additionally, RDFox (Motik
et al., 2014) supports arbitrary datalog unary binary predicates. Finally, ASP
engines DLV (Leone, Pfeifer, Faber, Eiter, Gottlob, Perri, & Scarcello, 2006) implement sound complete reasoning (extensions of) disjunctive datalog. Although triple
stores exhibit appealing scalability, support restricted ontology languages;
however, DL reasoners, improving scalability triple stores complementary
approach, advances area directly exploited PAGOdA.
technique CQ answering lightweight DLs receiving increasing attention
so-called combined approach (Lutz et al., 2009; Stefanoni et al., 2013; Kontchakov,
Lutz, Toman, Wolter, & Zakharyaschev, 2011). combined approach dataset
first augmented new facts query-independent way build (in polynomial time)
model ontology. model exploited query answering two equivalent
ways. approach Lutz et al. (2009) Kontchakov et al. (2011) query first
rewritten evaluated constructed model. Alternatively, work
Stefanoni et al. (2013) Lutz et al. (2013) query first evaluated model
unsound answers eliminated means polynomial time filtration process.
Combined approaches applied logics EL family (Lutz et al., 2009;
Stefanoni et al., 2013) well DL-Lite (Kontchakov et al., 2011), PAGOdA,
use implementation (Stefanoni et al., 2013) compute aggregated lower bound.
CQ answering Horn ontologies often realised means query rewriting techniques. rewriting query q w.r.t. ontology another query q 0 captures
information necessary answer q arbitrary dataset. Unions CQs
datalog common target languages query rewriting. Query rewriting enables reuse
optimised data management system: UCQs answered using standard relational
databases, whereas datalog queries evaluated using triple store. Query rewriting
successfully applied OWL 2 QL ontologies, rewritability UCQs
guaranteed. Example systems include QuOnto (Acciarri, Calvanese, De Giacomo, Lembo,
Lenzerini, Palmieri, & Rosati, 2005), Mastro (Calvanese, De Giacomo, Lembo, Lenzerini,
Poggi, Rodriguez-Muro, Rosati, Ruzzi, & Savo, 2011), Rapid (Chortaras, Trivela, & Stamou, 2011), Prexto (Rosati, 2012), Ontop (Bagosi, Calvanese, Hardi, Komla-Ebri,
Lanti, Rezk, Rodriguez-Muro, Slusnys, & Xiao, 2014). systems
successful large scale applications; however, applicable OWL 2 QL
size rewriting exponential size ontology. Datalog-based query
rewriting implemented systems REQUIEM (Perez-Urbina et al., 2010),
supports extension ELHOr? inverse roles. introduction inverse
roles, however, leads significant jump complexity: query answering ELHOr?
NP-complete (and tractable atomic queries), whereas becomes ExpTime-complete
inverse roles introduced (furthermore, ExpTime-hardness holds already unsatisfiability checking atomic queries). practice, restricting ELHOr?
allows us compute datalog program linear size straightforward way Skolemis349

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

ing existentially quantified variables constants. Furthermore, datalog materialisation
query independent queries without existentially quantified variables answered
directly materialisation, complex queries answered using filtration.
Finally, similarly PAGOdA, system Hydrowl (Stoilos, 2014a) combines OWL
2 RL reasoner query rewriting system fully-fledged DL reasoner order
answer conjunctive queries OWL 2 knowledge base. techniques Hydrowl are,
however, rather dierent PAGOdA. Hydrowl uses two dierent query answering
strategies. first one based repairing (Stoilos, 2014b) query rewriting,
applicable ontologies suitable repair exists. second strategy exploits
query base: set atomic queries Hydrowl computes pre-processing phase,
fully answered using triple store given ontology arbitrary
dataset. answering query q, Hydrowl checks q covered query base (Stoilos
& Stamou, 2014); is, q completely evaluated using OWL 2 RL reasoner;
otherwise, fully-fledged reasoner used answer q. However, computation
query base appear correct general,7 believe accounts
apparent incompleteness Hydrowl tests (see Section 10.3.1).
9.3 Approximate Reasoning
idea transforming ontology, data and/or query obtain lower upper bound
answers already explored previous work. Screech system (Tserendorj et al.,
2008) uses KAON2 (Hustadt, Motik, & Sattler, 2007) transform SHIQ ontology
(exponential size) disjunctive datalog program way ground answers
queries preserved. Subsequently, Screech exploit (unsound incomplete) techniques
transform disjunctive datalog plain datalog. way, Screech computes
approximation answer. TrOWL (Thomas et al., 2010) exploits approximation
techniques transform OWL 2 ontology ontology QL profile (Pan &
Thomas, 2007). approximation first computes closure input ontology
entailment OWL 2 QL axioms, disregards axioms outside OWL 2 QL.
Related approximations OWL 2 QL proposed, e.g., Wandelt et al.
(2010) Console et al. (2014). Efficient approximation strategies OWL 2 ontologies
complementary approach, exploited PAGOdA order
refine lower upper bound query answers.

10. Evaluation
evaluated query answering system PAGOdA range realistic benchmark ontologies, datasets queries, compared performance stateof-the-art query answering systems. test data systems used comparison
introduced Sections 10.1 10.2, respectively. results discussed Section
10.3. Experiments conducted 32 core 2.60GHz Intel Xeon E5-2670 250GB
RAM, running Fedora 20. test ontologies, queries, results available online.8
7. Stoilos (2014a) mentions limitation automatically extracting [the atomic queries].
8. http://www.cs.ox.ac.uk/isg/tools/PAGOdA/2015/jair/

350

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

LUBM(n)
UOBM(n)
FLY
NPD
DBPedia+
ChEMBL
Reactome
Uniprot

]axioms
93
186
14,447
771
1,716
2,593
559
442

]rules
133
234
18,013
778
1,744
2,960
575
459

]9-rules
15
23
8396
128
11
426
13
20

]_-rules
0
6
0
14
5
73
23
43

]facts
n 105
2.6n 105
8 103
3.8 106
2.9 107
2.9 108
1.2 107
1.2 108

Table 3: Statistics test datasets
10.1 Test Ontologies Queries
Table 3 summarises test data. first two columns table indicate total
number DL axioms test ontology well total number rules
normalisation. interested ontologies captured OWL 2 RL
hence cannot fully processed RDFox; thus, number rules containing existential
quantification disjunction especially relevant given third fourth
columns table, respectively. Finally, rightmost column lists number data
facts dataset.
LUBM UOBM widely-used reasoning benchmarks (Guo, Pan, & Heflin, 2005;
Ma, Yang, Qiu, Xie, Pan, & Liu, 2006). ontology axioms benchmarks
manually created considered fixed, whereas data synthetically generated
according parameter n determines size. LUBM UOBM come 14 15
standard queries, respectively. make tests LUBM challenging, extended
benchmark 10 additional queries datalog lower-bound answers
guaranteed complete (as case standard queries).
FLY realistic ontology describes anatomy Drosophila
currently integrated Virtual Fly Brain tool.9 Although data rather small
compared test cases (about 8, 000 facts), ontology rich existentially
quantified rules, makes query answering especially challenging. tested 6 realistic
queries provided developers ontology.
NPD FactPages ontology describing petroleum activities Norwegian
continental shelf. ontology comes realistic dataset containing 3.8 million facts.
Unfortunately, NPD realistic queries tested atomic queries
signature ontology.
DBPedia contains information Wikipedia entries. Although dataset rather
large, ontology axioms simple captured OWL 2 RL. provide
challenging test, used ontology matching system LogMap (JimenezRuiz & Cuenca Grau, 2011) extend DBPedia tourism ontology containing
9. http://www.virtualflybrain.org/site/vfb site/overview.htm

351

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

existential disjunctive rules. case NPD example test queries,
focused evaluation atomic queries.
ChEMBL, Reactome, Uniprot realistic ontologies made publicly available European Bioinformatics Institute (EBI) linked data platform.10
ontologies especially interesting testing purposes. one hand,
ontology axioms data realistic used number applications;
hand, ontologies rich existentially quantified disjunctive rules,
datasets extremely large. Furthermore, EBI website provides number
example queries ontologies. order test scalability datasets
well compare PAGOdA systems implemented data sampling algorithm
based random walks (Leskovec & Faloutsos, 2006) computed subsets data
increasing size. used evaluation example queries correspond CQs
well atomic queries relevant signature.
10.2 Comparison Systems
compared PAGOdA four ontology reasoners: HermiT (v.1.3.8), Pellet (v.2.3.1),
TrOWL-BGP (v.1.2), Hydrowl (v.0.2). single exception TrOWL,
systems implement sound complete algorithms standard reasoning tasks OWL
2 DL ontologies, including ontology consistency checking concept instance retrieval.
Additionally, HermiT provide support SPARQL queries.
pointed Section 9, many systems answer queries
ontologies. However, systems generally designed specific fragments
OWL 2, incomplete ontologies outside fragments. Although TrOWL
incomplete OWL 2, included evaluation is,
one hand, widely-used system Semantic Web applications and, hand,
similar PAGOdA exploits ontology approximation techniques. follows,
describe capabilities systems detail.
HermiT fully-fledged OWL 2 reasoner based hypertableau calculus (Motik
et al., 2009; Glimm et al., 2014). HermiT focuses standard reasoning tasks DLs.
provide SPARQL conjunctive query answering API, capable
answering atomic queries unary predicates checking fact entailment.
Pellet tableau-based OWL 2 DL reasoner support CQ answering (Sirin et al.,
2007). Pellet provides SPARQL API, hence compute set ground
answers arbitrary conjunctive queries expressed SPARQL. Pellet capable
computing certain answers internalisable conjunctive queries using rolling-up
technique (see Section 2.3).
TrOWL system based approximated reasoning. accepts input arbitrary
OWL 2 DL ontology CQ SPARQL, aims computing ground answers
given query (Thomas et al., 2010). TrOWL exploits technique approximates
input ontology OWL 2 QL profile, provide completeness guarantees.
10. http://www.ebi.ac.uk/rdf/platform

352

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

correct#

incomplete#

unsound#

error#

Kmeout#

cannot#handle#

100%#
90%#
80%#
70%#
60%#
50%#

Tr

Tr

Pe Hy

Pe Hy

Tr

Pe Hy

Tr

Tr

Pe Hy

Pe Hy

Tr

Pe Hy

Tr

Pe Hy

Tr

Pe Hy

Tr

Pe Hy

Tr

Pe Hy

40%#
30%#
20%#
10%#

#1
%
#
Pr
ot
Un


EM


ac


e#
10
%
#

BL
#1
%
#

#
DB
Pe


ia
Ch

NP
D#

Fa

ct
Pa
ge
s#

le
dU
p#
ro
l
Y_
FL

1_
ro
l

le
dU
p#

1#
UO
BM

UO
BM

le
dU
p#
1_
ro
l
LU
BM

LU
BM

1#

0%#

Figure 5: Quality answers computed system. four bars ontology
represent Trowl, Pellet, HermiT Hydrowl respectively.
Hydrowl (Stoilos, 2014a) hybrid reasoning system similar spirit PAGOdA
(see Section 9.2 detailed comparison). Hydrowl integrates triple store OWLim
HermiT. accepts input arbitrary OWL 2 ontology conjunctive queries rules,
computes ground answers query.
10.3 Experiments Results
performed three dierent experiments. first experiment, compared
PAGOdA mentioned systems, respect quality
answers (i.e., number correctly answered queries) performance relative
PAGOdA. second experiment, evaluated scalability considering datasets
increasing size. Finally, third experiment, evaluated eectiveness
dierent reasoning techniques implemented PAGOdA.
10.3.1 Comparison Systems
compared PAGOdA systems test ontologies. used
LUBM(1) UOBM(1) since already rather hard systems. Similarly, used relatively small samples EBI platform ontologies (1% data
ChEMBL UniProt, 10% Reactome) processed majority
systems. test ontology computed ground answers corresponding
test queries, whenever possible used internalisation (see Section 2.3) additionally
compute certain answers. case FLY, test queries yield empty set
ground answers, case computed certain answers (all FLY queries
internalised). set timeouts 20 minutes answering individual query, 5
hours answering queries given ontology.
Figure 5 summarises quality answers computed reasoner. bar
figure represents performance particular reasoner w.r.t. given ontology
353

fiPellet"

HermiT"

Hydrowl"

DB
Pe


TrOWL"

ct
Pa
ge
s"

Zhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

1000"

100"

10"

"1
%
"
Pr
ot
Un


EM


ac


e"
10
%
"

BL
"1
%
"

"
ia
Ch

Fa
NP
D"

le
dU
p"
ro
l
Y_
FL

1_
ro
l

le
dU
p"

1"
UO
BM

le
dU
p"
1_
ro
l

UO
BM

0"

LU
BM

LU
BM

1"

1"

Figure 6: Performance comparison systems. bar depicts total time
answer test queries relevant ontology comparison PAGOdA.
set test queries. use green indicate percentage queries reasoner
computed correct answers, correctness determined majority voting,
blue (resp. purple) indicate percentage queries reasoner
incomplete (resp. unsound). Red, orange grey indicate, respectively, percentage
queries reasoner reported exception execution, accept
input query, exceeded timeout. criterion correctness, PAGOdA
able correctly compute answers every query test ontology within given
timeouts. Consequently, performance PAGOdA represented figure.
Figure 6 summarises performance system relative PAGOdA,
case considered queries relevant system yields answer (even
computed answer unsound and/or incomplete). ideal, chose
consider queries (rather queries relevant system
yields correct answer) (i) resulting time measurement obviously closer
time would required correctly answer queries; (ii) correctness
relative gold standard query answers. ontology
reasoner, corresponding bar shows t2 /t1 (on logarithmic scale), t1 (resp. t2 )
total time required PAGOdA (resp. compared system) compute answers
queries consideration; missing bar indicates comparison system failed
answer queries within given timeout. Please note two dierent bars
ontology comparable may refer dierent sets queries, bar
needs considered isolation.
draw following conclusions results experiments.
TrOWL faster PAGOdA LUBM rolling up, UOBM rolling
FLY rolling up, incomplete 7 14 LUBM queries 3
4 UOBM queries. ChEMBL, TrOWL exceeds timeout performing
satisfiability check. remaining ontologies, PAGOdA efficient spite
fact TrOWL incomplete queries, even unsound several
UniProt queries.
354

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

Pellet one robust systems evaluation. Although times
FLY ontology, succeeds computing answers remaining cases.
observe, however, cases Pellet significantly slower PAGOdA,
sometimes two orders magnitude.
HermiT answer queries one distinguished variable, could
evaluate atomic binary queries. see HermiT exceeds timeout many
cases. tests HermiT succeeds, significantly slower PAGOdA.
Although Hydrowl based theoretically sound complete algorithm,
found incomplete tests. exceeded timeout queries
three ontologies, ran memory queries another two
ontologies, reported exception ChEMBL 1%. remaining cases,
significantly slower PAGOdA.
10.3.2 Scalability Tests
tested scalability PAGOdA LUBM, UOBM ontologies EBI
linked data platform. LUBM used datasets increasing size step n =
100. UOBM used increasingly large datasets step n = 100
considered smaller step n = 5 hard queries. Finally, case EBIs datasets,
implemented data sampling algorithm based random walks computed subsets
data increasing sizes 1% original dataset 100% steps
10%. used test queries described Section 10.1 ontologies;
Section 10.3.1, computed ground answers and, whenever possible, used internalisation
additionally compute certain answers. test ontology measured following:
Pre-processing time. includes pre-processing steps Section 8 well
satisfiability checking (i.e., query processing Boolean unsatisfiability query).
Query processing time. time perform query processing steps
query given ontology. organise test queries following three
groups depending techniques exploited PAGOdA compute answers:
G1: queries lower upper bounds coincide;
G2: queries non-empty gap, summarisation able filter
remaining candidate answers;
G3: queries fully-fledged reasoner called ontology subset
least one test datasets.
scalability test, set timeout 5 hours answering queries 2.5 hours
individual query. LUBM UOBM, increased size dataset
PAGOdA exceeded timeout; ontologies, PAGOdA able answer
queries within timeout, even largest dataset.
Pellet compared system found sound complete test
ontologies queries, conducted scalability tests it. scalability
Pellet is, however, limited: already failed LUBM(100), UOBM(5), well ChEMBL
355

fi3.0#

G1(18)"

2.5#

Thousands)seconds)

Thousands)seconds)

Zhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

2.0#
1.5#
1.0#

Q32"

Q34"

9"
8"
7"
6"
5"
4"
3"
2"

0.5#

1"

0.0#

0"

1#

100#

200#

300#

400#

500#

600#

700#

800#

1"

200"

300"

400"

500"

600"

700"

800"

(b) LUBM query processing

14"

G1(18)"

12"

Thousands)seconds)

Thousands)seconds)

(a) LUBM pre-processing

100"

10"
8"
6"

G2(1)"

Q18"

2.5"
2"
1.5"
1"

4"

0.5"

2"
0"
1"

100"

200"

300"

400"

0"

500"

0"

(c) UOBM pre-processing

100"

200"

300"

400"

500"

(d) UOBM query processing

Figure 7: Scalability tests benchmarks
10% Uniprot 10%. dataset Pellet managed process least two data
samples Reactome, succeeded samples smaller 40%. case
Reactome discussed detail later on.
results summarised Figures 7 8. ontology, plot time
size input dataset, query processing distinguish dierent groups
queries discussed above. PAGOdA behaves relatively uniformly queries G1
G2, plot average time per query groups. contrast, PAGOdAs
behaviour queries G3 quite variable, plot time individual query.
LUBM(n) shown Figure 7a, pre-processing fast, times appear scale linearly increasing dataset size. LUBM queries belong either G1 G3
latter group containing two queries. Figure 7b illustrates average query processing
time queries G1, never exceeds 13 seconds, well time
two queries G3 (Q32 Q34), reaches 8,000 seconds LUBM(800),
accounted HermiT.
UOBM(n) shown Figure 7c, pre-processing times significantly higher
LUBM, reflecting increased complexity ontology, still appear scale linearly
dataset size. LUBM, test queries contained G1,
processing times never exceeds 8 seconds UOBM(1) UOBM(500). found one
query G2. Processing times query somewhat longer G1
reached 569s UOBM(500). Finally, found one query (Q18) that, due UOBMs
356

fi12"

G1(1896)#

10"

Seconds(

Thousands))seconds)

PAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

8"
6"
4"
2"
0"
1%"

10%" 20%" 30%" 40%" 50%" 60%" 70%" 80%" 90%" 100%"

0.50#
0.45#
0.40#
0.35#
0.30#
0.25#
0.20#
0.15#
0.10#
0.05#
0.00#
1%# 10%# 20%# 30%# 40%# 50%# 60%# 70%# 80%# 90%# 100%#

(a) ChEMBL pre-processing
Pellet"

G1(128)"

14"

Seconds(

Hundreds(seconds(

PAGOdA"

(b) ChEMBL query processing

12"

G2(1)"

Q65"

Pellet_Q65"

1000"
800"

10"
8"

600"

6"

400"

4"
200"

2"
0"

0"
10%" 20%"

30%"

40%"

50%" 60%"

70%"

80%"

90%" 100%"

10%" 20%" 30%" 40%" 50%" 60%" 70%" 80%" 90%" 100%"

(c) Reactome pre-processing
Unsa9sable#

G1(236)"

2.0#

Seconds(

Thousands)seconds)

Satsiable#

(d) Reactome query processing

1.5#

G2(4)"

25"
20"
15"

1.0#
10"

0.5#

5"

0.0#

0"

1%# 10%# 20%# 30%# 40%# 50%# 60%# 70%# 80%# 90%# 100%#

1%"

(e) Uniprot pre-processing

10%"

20%"

30%"

40%"

(f) Uniprot query processing

Figure 8: Scalability tests EBI linked data platform
randomised data generation, dierent groups dierent datasets: UOBM(1),
UOBM(10) UOBM(50) G3, HermiT called relevant subsets
fully answer query; UOBM(40) G2, HermiT called
summary relevant subset; remaining cases shown Figure 7d
G1, lower upper bounds coincided. query timed UOBM(50),
due time taken HermiT reason relevant subset, shown
times remaining G1 G2 queries UOBM(500).
ChEMBL shown Figure 8a, pre-processing times significant manageable,
appear scale linearly dataset size. test queries contained G1.

357

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

Total
L1 + U 1
L2 + U 1
L2 + U 2
L2 + U2|3

LUBM
(100)
35
26
33
33
33

UOBM
(1)
20
4
4
12
16

FLY

NPD

DBPedia

6
0
5
5
5

478
442
442
442
473

1247
1240
1241
1241
1246

ChEMBL
1%
1896
1883
1883
1883
1896

Reactome
10%
130
82
82
98
128

Uniprot
1%
240
204
204
204
236

Table 4: ]Queries answered dierent bounds
Figure 8b illustrates average processing times queries, less 0.5s
datasets increases smoothly dataset size.
Reactome shown Figure 8c, pre-processing times appear scale quite
smoothly. Groups G2 G3 contained one query, remaining queries
belonging G1. Query processing times shown Figure 8d. Average query processing time queries G1 never exceeded 10 seconds. Average processing times G2
queries appeared grow linearly size datasets, average time never exceeded
10 seconds. Finally, seen G3 query (Q65) much challenging,
could still answered less 900 seconds, even largest dataset.
already mentioned, tested scalability Pellet Reactome, Pellet
able process samples size 10%, 20% 30%. pre-processing time Pellet
datasets comparable PAGOdA shown Figure 8c. Average queryprocessing times queries G1 G2 slightly higher PAGOdA.
contrast, times query Q65 significantly higher: 445s, 518s 2, 626s Reactome
10%, 20% 30%, respectively (see Figure 8d). Processing times Q65 PAGOdA,
however, grow smoothly thanks eectiveness subset extraction technique,
able keep input fully-fledged reasoner small, even largest datasets.
Uniprot contrast cases, Uniprot whole unsatisfiable; sampling
technique can, however, produce satisfiable subset. Figure 8e illustrates pre-processing
times. seen, drop abruptly unsatisfiable samples (50% larger);
unsatisfiability efficiently detected lower bound. figure shows
time detect inconsistency 100% even less 90%;
time dominated loading time, I/O performance varies run run. Query
processing times considered satisfiable samples (see Figure 8f).
queries G3, four G2. observe average times queries
appear scale linearly data size groups.
10.3.3 Effectiveness Implemented Techniques
evaluated eectiveness various reasoning techniques implemented
PAGOdA comparing numbers test queries fully answered using
relevant technique.
Query bounds Sections 4 5 described dierent techniques computing lower
upper bound query answers. Table 4 illustrates eectiveness bounds
358

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

Facts
Rules

LUBM
0.5%
3.7%

UOBM
10.4%
10.9%

Fly
7.3%
0.9%

NPD
16.5%
18.4%

DBPedia
9 10 5 %
2.4%

Reactome
5.2%
5.3%

Uniprot
4 10 4 %
1.1%

Table 5: Size largest subsets given percentage input rules facts.
terms number queries bounds coincided test ontologies.
table, refer lower bound described Section 4.1 L1 aggregated
lower bound described Section 4.3 L2 . Similarly, refer three upper bound
computation techniques discussed Section 5.4 U1 , U2 , U3 combined upper
bound U2|3 . observe following experiments:
basic lower upper bounds suffice answer queries many
test ontologies. particular, L1 U1 matched 26 35 queries
LUBM(100), 442 478 NPD, 240 1247 DBPedia, 1883 1896
ChEMBL, 204 240 Uniprot.
aggregated lower bound L2 eective case FLY, basic
bounds match query. useful LUBM, yielding matching
bounds 7 queries.
refined treatment existential rules described Section 5.2, yields
upper bound U2 , especially eective UOBM(1) Reactome, many
existentially quantified rules already satisfied lower bound materialisation.
Finally, refined treatment disjunctive rules Section 5.3, yields combined upper bound U2|3 , instrumental obtaining additional matching bounds
non-Horn ontologies. could answer additional 4 queries UOBM(1), 31
NPD, 5 DBPedia, 13 ChEMBL, 30 Reactome, 32 Uniprot.
Overall, obtained matching bounds queries test ontologies:
could answer queries ChEMBL, 1 FLY DBPedia, 2
Reactome LUBM(100), 4 UOBM(1) Uniprot, 5 NPD.
Subset extraction Table 5 shows, dataset, maximum percentage facts
rules included relevant subset test queries non-matching
bounds. observe subset extraction eective cases terms facts
rules. Uniprot DBPedia, reduction data size especially dramatic.
interesting observe large reduction number rules FLY,
rather complex ontology. Finally, subset extraction least eective NPD
UOBM, even cases reduction almost one order magnitude
size ontology dataset.
turn attention summarisation dependency analysis. eectiveness
techniques measured number hard calls HermiT required
fully answer query, call HermiT considered hard knowledge base
passed HermiT summary. first row Table 6 shows number gap
359

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

L2 + U2|3
+ Sum
+ Dep

LUBM
26 14
26 14
1
1

264
264
1

UOBM
112 1470
0 1444
0
1

264
264
1

FLY
344
344
7

DBPedia
10
0
0

NPD
326
0
0

Reactome
18
52
0
52
0
37

UniProt
168
0
0

Table 6: number hard calls HermiT fully answer query
answers query L2 U2|3 bounds match. Without optimisation,
would call HermiT number times fully answer query. Row 2
(resp. row 3) shows number hard calls HermiT applying summarisation (resp.
summarisation plus dependency analysis). mentioned above, respectively 5
4 queries non-matching bounds NPD UniProt. However,
groups, summarisation dependency analysis identical eects queries
group, present one representative query ontology.
Summarisation already discussed, summarisation enables PAGOdA fully answer
number test queries non-empty gaps. instrumental fully answering one
query UOBM(1), DBPedia Reactome, well 5 queries NPD, 4
queries Uniprot. Even cases summarisation suffice fully answer
query, eective reducing size gap. instance, one queries
UOBM(1) obtained 1,470 gap answers, 26 ruled summarisation.
Dependency analysis LUBM(100) two queries gap 26 answers
14 answers, respectively; cases, answers merged single group,
hence single call HermiT sufficed complete computation. Similarly, UOBM(1)
single call HermiT sufficient, even though three queries gap
involved large number candidate answers. FLY, 344 answers remaining
verified summarisation, 7 hard calls HermiT required. Finally,
case Reactome one query 52 gap answers, dependency analysis reduced
number calls HermiT 37.

11. Conclusions
paper, investigated novel pay-as-you-go approach conjunctive query
answering combines datalog reasoner fully-fledged reasoner. key feature
approach delegates bulk computation datalog reasoner
resorts fully-fledged reasoner necessary fully answer query.
reasoning techniques proposed general applicable
wide range knowledge representation languages. main goal practice, however,
realise approach highly scalable robust query answering system
OWL 2 DL ontologies, called PAGOdA. extensive evaluation
confirmed feasibility approach practice, system PAGOdA
significantly ourperforms state-of-the art reasoning systems terms robustness
scalability. particular, experiments using ontologies EBI linked data
platform shown PAGOdA capable fully answering queries highly complex
expressive ontologies realistic datasets containing hundreds millions facts.
360

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

Acknowledgments
extended version conference publications (Zhou, Nenov, Cuenca Grau, &
Horrocks, 2014; Zhou, Nenov, Grau, & Horrocks, 2013). work supported
Royal Society Royal Society Research Fellowship, EPSRC projects
Score!, MaSI3 , DBOnto, well EU FP7 project Optique.

References
Abiteboul, S., Hull, R., & Vianu, V. (Eds.). (1995). Foundations Databases: Logical
Level. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA.
Acciarri, A., Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Palmieri, M., &
Rosati, R. (2005). QuOnto: Querying ontologies. Veloso, M. M., & Kambhampati,
S. (Eds.), AAAI 2005, Proceedings Twentieth National Conference Artificial Intelligence Seventeenth Innovative Applications Artificial Intelligence
Conference, July 9-13, 2005, Pittsburgh, Pennsylvania, USA, pp. 16701671. AAAI
Press / MIT Press.
Afrati, F. N., Cosmadakis, S. S., & Yannakakis, M. (1995). datalog vs. polynomial time.
J. Comput. Syst. Sci., 51 (2), 177196.
Alviano, M., Faber, W., Greco, G., & Leone, N. (2012a). Magic sets disjunctive datalog
programs. Artificial Intelligence, 187188, 156192.
Alviano, M., Faber, W., Leone, N., & Manna, M. (2012b). Disjunctive datalog existential quantifiers: Semantics, decidability, complexity issues. Theory Practice
Logic Programming, 12 (4-5), 701718.
Baader, F., Brandt, S., & Lutz, C. (2005). Pushing EL envelope. IJCAI 2015,
Proceedings Nineteenth International Joint Conference Artificial Intelligence,
Edinburgh, Scotland, UK, July 30-August 5, 2005, pp. 364369.
Baader, F., Calvanese, D., McGuinness, D. L., Nardi, D., & Patel-Schneider, P. F. (2003).
Description Logic Handbook: Theory, Implementation, Applications. Cambridge Univ. Press.
Bagosi, T., Calvanese, D., Hardi, J., Komla-Ebri, S., Lanti, D., Rezk, M., Rodriguez-Muro,
M., Slusnys, M., & Xiao, G. (2014). Ontop framework ontology based data access. Zhao, D., Du, J., Wang, H., Wang, P., Ji, D., & Pan, J. Z. (Eds.), CSWS 2014,
Proceedings Semantic Web Web Science - 8th Chinese Conference, Wuhan,
China, August 8-12, 2014, Revised Selected Papers, Vol. 480 Communications
Computer Information Science, pp. 6777. Springer.
Bancilhon, F., Maier, D., Sagiv, Y., & Ullman, J. D. (1986). Magic sets strange
ways implement logic programs. Silberschatz, A. (Ed.), Proceedings Fifth
ACM SIGACT-SIGMOD Symposium Principles Database Systems, March 2426, 1986, Cambridge, Massachusetts, USA, pp. 115. ACM.
Beeri, C., Naqvi, S. A., Ramakrishnan, R., Shmueli, O., & Tsur, S. (1987). Sets negation
logic database language (LDL1). Vardi, M. Y. (Ed.), Proceedings Sixth
361

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

ACM SIGACT-SIGMOD-SIGART Symposium Principles Database Systems,
March 23-25, 1987, San Diego, California, USA, pp. 2137. ACM.
Bishop, B., Kiryakov, A., Ognyano, D., Peikov, I., Tashev, Z., & Velkov, R. (2011).
OWLIM: family scalable semantic repositories. Semantic Web, 2 (1), 3342.
Bourhis, P., Morak, M., & Pieris, A. (2013). impact disjunction query answering guarded-based existential rules. IJCAI 2013, Proceedings 23rd
International Joint Conference Artificial Intelligence, Beijing, China, August 3-9,
2013, pp. 796802. AAAI Press.
Broekstra, J., Kampman, A., & van Harmelen, F. (2002). Sesame: generic architecture
storing querying RDF RDF schema. Horrocks, I., & Hendler, J. A.
(Eds.), ISWC 2002, Proceedings Semantic Web - First International Semantic
Web Conference, Sardinia, Italy, June 9-12, 2002, Proceedings, Vol. 2342 Lecture
Notes Computer Science, pp. 5468. Springer.
Bry, F., Eisinger, N., Eiter, T., Furche, T., Gottlob, G., Ley, C., Linse, B., Pichler, R., & Wei,
F. (2007). Foundations rule-based query answering. Antoniou, G., Amann, U.,
Baroglio, C., Decker, S., Henze, N., Patranjan, P., & Tolksdorf, R. (Eds.), Reasoning
Web 2007, Vol. 4636 Lecture Notes Computer Science, pp. 1153. Springer.
Cal, A., Gottlob, G., & Kifer, M. (2013). Taming infinite chase: Query answering
expressive relational constraints. Journal Artificial Intelligence Research, 48,
115174.
Cal, A., Gottlob, G., & Lukasiewicz, T. (2012). general datalog-based framework
tractable query answering ontologies. J. Web Sem., 14, 5783.
Cal, A., Gottlob, G., Lukasiewicz, T., Marnette, B., & Pieris, A. (2010). Datalog+/-:
family logical knowledge representation query languages new applications.
LICS 2010, Proceedings 25th Annual IEEE Symposium Logic Computer
Science, 11-14 July 2010, Edinburgh, United Kingdom, pp. 228242. IEEE Computer
Society.
Cal, A., Gottlob, G., & Pieris, A. (2011). New expressive languages ontological query
answering. Burgard, W., & Roth, D. (Eds.), AAAI 2011, Proceedings TwentyFifth AAAI Conference Artificial Intelligence, San Francisco, California, USA,
August 7-11, 2011, Vol. 2, pp. 15411546. AAAI Press.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Poggi, A., Rodriguez-Muro, M.,
Rosati, R., Ruzzi, M., & Savo, D. F. (2011). MASTRO system ontology-based
data access. Semantic Web, 2 (1), 4353.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2007). Tractable
reasoning efficient query answering description logics: DL-Lite family.
Journal Automated Reasoning, 39 (3), 385429.
Chortaras, A., Trivela, D., & Stamou, G. B. (2011). Optimized query rewriting OWL
2 QL. Bjrner, N., & Sofronie-Stokkermans, V. (Eds.), CADE 23, Proceedings
23rd International Conference Automated Deduction, Wroclaw, Poland, July
31 - August 5, 2011, Vol. 6803 Lecture Notes Computer Science, pp. 192206.
Springer.
362

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

Console, M., Mora, J., Rosati, R., Santarelli, V., & Savo, D. F. (2014). Eective computation
maximal sound approximations description logic ontologies. ISWC 2014,
Proceedings Semantic Web - 13th International Semantic Web Conference,
Riva del Garda, Italy, October 19-23, 2014. Proceedings, Part II, pp. 164179.
Cuenca Grau, B., Horrocks, I., Krotzsch, M., Kupke, C., Magka, D., Motik, B., & Wang, Z.
(2013). Acyclicity notions existential rules application query answering
ontologies. Journal Artificial Intelligence Research, 47, 741808.
Cuenca Grau, B., Horrocks, I., Motik, B., Parsia, B., Patel-Schneider, P. F., & Sattler, U.
(2008). OWL 2: next step OWL. Journal Web Semantics, 6 (4), 309322.
Cuenca Grau, B., Motik, B., Stoilos, G., & Horrocks, I. (2012). Completeness guarantees
incomplete ontology reasoners: Theory practice. Journal Artificial Intelligence
Research, 43, 419476.
Dantsin, E., Eiter, T., Gottlob, G., & Voronkov, A. (2001). Complexity expressive
power logic programming. ACM Computing Surveys, 33 (3), 374425.
Dolby, J., Fokoue, A., Kalyanpur, A., Kershenbaum, A., Schonberg, E., Srinivas, K., &
Ma, L. (2007). Scalable semantic retrieval summarization refinement.
AAAI 2007, Proceedings Twenty-Second AAAI Conference Artificial Intelligence, July 22-26, 2007, Vancouver, British Columbia, Canada, pp. 299304. AAAI
Press.
Dolby, J., Fokoue, A., Kalyanpur, A., Schonberg, E., & Srinivas, K. (2009). Scalable highly
expressive reasoner (SHER). Journal Web Semantics, 7 (4), 357361.
Eiter, T., Fink, M., Tompits, H., & Woltran, S. (2004). Simplifying logic programs
uniform strong equivalence. LPNMR 2004, Proceedings Logic Programming
Nonmonotonic Reasoning - 7th International Conference, Fort Lauderdale, FL,
USA, January 6-8, 2004, Proceedings, pp. 8799.
Eiter, T., Lutz, C., Ortiz, M., & Simkus, M. (2009). Query answering description logics
transitive roles. Boutilier, C. (Ed.), IJCAI 2009, Proceedings 21st
International Joint Conference Artificial Intelligence, Pasadena, California, USA,
July 11-17, 2009, pp. 759764.
Eiter, T., Ortiz, M., & Simkus, M. (2012). Conjunctive query answering description
logic SH using knots. Journal Computer System Sciences, 78 (1), 4785.

Erling, O., & Mikhailov, I. (2009). Virtuoso: RDF support native RDBMS. Virgilio,
R. D., Giunchiglia, F., & Tanca, L. (Eds.), Semantic Web Information Management
- Model-Based Perspective, pp. 501519. Springer.
Glimm, B., Horrocks, I., Motik, B., Stoilos, G., & Wang, Z. (2014). HermiT: OWL 2
reasoner. Journal Automated Reasoning, 53 (3), 245269.
Glimm, B., Lutz, C., Horrocks, I., & Sattler, U. (2008). Conjunctive query answering
description logic SHIQ. Journal Artificial Intelligence Research, 31, 157204.

Grosof, B. N., Horrocks, I., Volz, R., & Decker, S. (2003). Description logic programs:
combining logic programs description logic. Hencsey, G., White, B., Chen,
Y. R., Kovacs, L., & Lawrence, S. (Eds.), WWW 2003, Proceedings Twelfth
363

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

International World Wide Web Conference, Budapest, Hungary, May 20-24, 2003,
pp. 4857. ACM.
Guo, Y., Pan, Z., & Heflin, J. (2005). LUBM: benchmark OWL knowledge base
systems. Journal Web Semantics, 3 (2-3), 158182.
Haarslev, V., Hidde, K., Moller, R., & Wessel, M. (2012). RacerPro knowledge representation reasoning system. Semantic Web, 3 (3), 267277.
Horrocks, I., Kutz, O., & Sattler, U. (2006). even irresistible SROIQ. KR
2006, Proceedings Tenth International Conference Principles Knowledge
Representation Reasoning, Lake District United Kingdom, June 2-5, 2006,
pp. 5767.
Horrocks, I., Patel-Schneider, P. F., & van Harmelen, F. (2003). SHIQ RDF
OWL: making web ontology language. Journal Web Semantics, 1 (1),
726.
Horrocks, I., & Tessaris, S. (2000). conjunctive query language description logic
aboxes. Kautz, H. A., & Porter, B. W. (Eds.), AAAI/IAAI 2000, Proceedings
Seventeenth National Conference Artificial Intelligence Twelfth Conference
Innovative Applications Artificial Intelligence, July 30 - August 3, 2000, Austin,
Texas, USA., pp. 399404. AAAI Press / MIT Press.
Hustadt, U., Motik, B., & Sattler, U. (2007). Reasoning description logics reduction
disjunctive datalog. Journal Automated Reasoning, 39 (3), 351384.
Jimenez-Ruiz, E., & Cuenca Grau, B. (2011). LogMap: Logic-based scalable ontology
matching. Aroyo, L., Welty, C., Alani, H., Taylor, J., Bernstein, A., Kagal, L., Noy,
N. F., & Blomqvist, E. (Eds.), ISWC 2011, Semantic Web - 10th International
Semantic Web Conference, Bonn, Germany, October 23-27, 2011, Proceedings, Part
I, Vol. 7031 Lecture Notes Computer Science, pp. 273288. Springer.
Kemp, D. B., Srivastava, D., & Stuckey, P. J. (1995). Bottom-up evaluation query
optimization well-founded models. Theoretical Computer Science, 146 (12), 145
184.
Kollia, I., & Glimm, B. (2013). Optimizing SPARQL query answering OWL ontologies.
Journal Artificial Intelligence Research, 48, 253303.
Kontchakov, R., Lutz, C., Toman, D., Wolter, F., & Zakharyaschev, M. (2011). combined approach ontology-based data access. Walsh, T. (Ed.), IJCAI 2011,
Proceedings 22nd International Joint Conference Artificial Intelligence,
Barcelona, Catalonia, Spain, July 16-22, 2011, pp. 26562661. IJCAI/AAAI.
Leone, N., Pfeifer, G., Faber, W., Eiter, T., Gottlob, G., Perri, S., & Scarcello, F. (2006).
DLV system knowledge representation reasoning. ACM Transactions
Computational Logic, 7 (3), 499562.
Leskovec, J., & Faloutsos, C. (2006). Sampling large graphs. KDD 2006, Proceedings
Twelfth ACM SIGKDD International Conference Knowledge Discovery
Data Mining, Philadelphia, PA, USA, August 20-23, 2006, pp. 631636.

364

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

Lutz, C. (2008). complexity conjunctive query answering expressive description logics. Armando, A., Baumgartner, P., & Dowek, G. (Eds.), IJCAR 2008,
Proceedings 4th International Joint Conference Automated Reasoning, Sydney,
Australia, August 12-15, 2008, Vol. 5195 Lecture Notes Computer Science, pp.
179193. Springer.
Lutz, C., Seylan, I., Toman, D., & Wolter, F. (2013). combined approach OBDA:
Taming role hierarchies using filters. Alani, H., Kagal, L., Fokoue, A., Groth, P. T.,
Biemann, C., Parreira, J. X., Aroyo, L., Noy, N. F., Welty, C., & Janowicz, K. (Eds.),
ISWC 2013, Proceedings Semantic Web - 12th International Semantic Web
Conference, Sydney, NSW, Australia, October 21-25, 2013, Proceedings, Part I, Vol.
8218 Lecture Notes Computer Science, pp. 314330. Springer.
Lutz, C., Toman, D., & Wolter, F. (2009). Conjunctive query answering description logic EL using relational database system. Boutilier, C. (Ed.), IJCAI
2009, Proceedings 21st International Joint Conference Artificial Intelligence,
Pasadena, California, USA, July 11-17, 2009, pp. 20702075.
Ma, L., Yang, Y., Qiu, Z., Xie, G. T., Pan, Y., & Liu, S. (2006). Towards complete OWL
ontology benchmark. Sure, Y., & Domingue, J. (Eds.), ESWC 2006, Semantic
Web: Research Applications, 3rd European Semantic Web Conference, Budva,
Montenegro, June 11-14, 2006, Proceedings, Vol. 4011 Lecture Notes Computer
Science, pp. 125139. Springer.
Manola, F., & Miller, E. (2004). RDF primer. W3C Recommendation. Available
http://www.w3.org/TR/rdf-primer/.
Marnette, B. (2009). Generalized schema-mappings: termination tractability.
PODS 2009, Proceedings Twenty-Eigth ACM SIGMOD-SIGACT-SIGART
Symposium Principles Database Systems, June 19 - July 1, 2009, Providence,
Rhode Island, USA, pp. 1322.
McBride, B. (2001). Jena: Implementing RDF model syntax specification.
SemWeb 2001, Proceedings Second International Workshop Semantic
Web.
Moller, R., Neuenstadt, C., Ozcep, O. L., & Wandelt, S. (2013). Advances accessing
big data expressive ontologies. Timm, I. J., & Thimm, M. (Eds.), KI 2013,
Proceedings Advances Artificial Intelligence - 36th Annual German Conference
AI, Koblenz, Germany, September 16-20, 2013, Vol. 8077 Lecture Notes
Computer Science, pp. 118129. Springer.
Motik, B., Cuenca Grau, B., Horrocks, I., Wu, Z., Fokoue, A., & Lutz, C. (2012). OWL 2
Web Ontology Language Profiles (second edition). W3C Recommendation. Available
http://www.w3.org/TR/owl2-profiles/.
Motik, B., Nenov, Y., Piro, R., Horrocks, I., & Olteanu, D. (2014). Parallel materialisation
datalog programs centralised, main-memory RDF systems. Brodley, C. E., &
Stone, P. (Eds.), AAAI 2014, Proceedings Twenty-Eighth AAAI Conference
Artificial Intelligence, July 27 -31, 2014, Quebec City, Quebec, Canada., pp. 129137.
AAAI Press.
365

fiZhou, Cuenca Grau, Nenov, Kaminski, & Horrocks

Motik, B., Shearer, R., & Horrocks, I. (2009). Hypertableau reasoning description logics.
Journal Artificial Intelligence Research, 36, 165228.
Ortiz, M., Rudolph, S., & Simkus, M. (2011). Query answering horn fragments
description logics SHOIQ SROIQ. IJCAI 2011, Proceedings 22nd
International Joint Conference Artificial Intelligence, Barcelona, Catalonia, Spain,
July 16-22, 2011, pp. 10391044.
Pan, J. Z., & Thomas, E. (2007). Approximating OWL-DL ontologies. AAAI 2007,
Proceedings Twenty-Second AAAI Conference Artificial Intelligence, July
22-26, 2007, Vancouver, British Columbia, Canada, pp. 14341439.
Perez-Urbina, H., Motik, B., & Horrocks, I. (2010). Tractable query answering rewriting
description logic constraints. Journal Applied Logic, 8 (2), 186209.
PrudHommeaux, E., & Carothers, G. (2014). RDF 1.1 Turtle. W3C Recommendation.
Available http://www.w3.org/TR/turtle/.
Robinson, J. A., & Voronkov, A. (Eds.). (2001). Handbook Automated Reasoning (in 2
volumes). Elsevier MIT Press.
Rodriguez-Muro, M., & Calvanese, D. (2012). High performance query answering
DL-Lite ontologies. Brewka, G., Eiter, T., & McIlraith, S. A. (Eds.), KR 2012,
Proceedings Principles Knowledge Representation Reasoning, Thirteenth
International Conference, Rome, Italy, June 10-14, 2012, pp. 308318. AAAI Press.
Rosati, R. (2012). Prexto: Query rewriting extensional constraints DL - lite.
Simperl, E., Cimiano, P., Polleres, A., Corcho, O., & Presutti, V. (Eds.), ESWC
2012, Proceedings Semantic Web: Research Applications - 9th Extended
Semantic Web Conference, Heraklion, Crete, Greece, May 27-31, 2012, Vol. 7295
Lecture Notes Computer Science, pp. 360374. Springer.
Rudolph, S., & Glimm, B. (2010). Nominals, inverses, counting, conjunctive queries or:
infinity friend!. Journal Artificial Intelligence Research, 39, 429481.
Schaerf, A. (1993). complexity instance checking problem concept languages
existential quantification. Komorowski, H. J., & Ras, Z. W. (Eds.), ISMIS
1993, Proceedings Methodologies Intelligent Systems, 7th International Symposium, Trondheim, Norway, June 15-18, 1993, Vol. 689 Lecture Notes Computer
Science, pp. 508517. Springer.
Sirin, E., Parsia, B., Cuenca Grau, B., Kalyanpur, A., & Katz, Y. (2007). Pellet: practical
OWL-DL reasoner. Journal Web Semantics, 5 (2), 5153.
Staab, S., & Studer, R. (Eds.). (2004). Handbook Ontologies. International Handbooks
Information Systems. Springer.
Stefanoni, G., & Motik, B. (2015). Answering conjunctive queries EL knowledge bases
transitive reflexive roles. Bonet, B., & Koenig, S. (Eds.), AAAI 2015,
Proceedings 29th AAAI Conference Artificial Intelligence, Austin, TX, USA.
AAAI Press. appear.
Stefanoni, G., Motik, B., & Horrocks, I. (2013). Introducing nominals combined
query answering approaches EL. AAAI 2013, Proceedings Twenty-Seventh
AAAI Conference Artificial Intelligence, pp. 11771183.
366

fiPAGOdA: Pay-As-You-Go Query Answering Using Datalog Reasoner

Stefanoni, G., Motik, B., Krotzsch, M., & Rudolph, S. (2014). complexity answering
conjunctive navigational queries OWL 2 EL knowledge bases. Journal
Artificial Intelligence Research, 51, 645705.
Stoilos, G. (2014a). Hydrowl: hybrid query answering system OWL 2 DL ontologies.
RR 2014, Proceedings Web Reasoning Rule Systems - 8th International
Conference, Athens, Greece, September 15-17, 2014, pp. 230238.
Stoilos, G. (2014b). Ontology-based data access using rewriting, OWL 2 RL systems
repairing. Presutti, V., dAmato, C., Gandon, F., dAquin, M., Staab, S., & Tordai,
A. (Eds.), Semantic Web: Trends Challenges - 11th International Conference,
ESWC 2014, Anissaras, Crete, Greece, May 25-29, 2014. Proceedings, Vol. 8465
Lecture Notes Computer Science, pp. 317332. Springer.
Stoilos, G., & Stamou, G. B. (2014). Hybrid query answering OWL ontologies.
Schaub, T., Friedrich, G., & OSullivan, B. (Eds.), ECAI 2014 - 21st European Conference Artificial Intelligence, 18-22 August 2014, Prague, Czech Republic - Including Prestigious Applications Intelligent Systems (PAIS 2014), Vol. 263 Frontiers
Artificial Intelligence Applications, pp. 855860. IOS Press.
Thomas, E., Pan, J. Z., & Ren, Y. (2010). Trowl: Tractable OWL 2 reasoning infrastructure.
ESWC 2010, Proceedings Semantic Web: Research Applications, 7th
Extended Semantic Web Conference, Heraklion, Crete, Greece, May 30 - June 3, 2010,
Part II, pp. 431435.
Tserendorj, T., Rudolph, S., Krotzsch, M., & Hitzler, P. (2008). Approximate OWLreasoning screech. Calvanese, D., & Lausen, G. (Eds.), RR 2008, Proceedings
Web Reasoning Rule Systems, Second International Conference, Karlsruhe,
Germany, October 31-November 1, 2008, Vol. 5341 Lecture Notes Computer
Science, pp. 165180. Springer.
W3C SPARQL Working Group (2013). SPARQL 1.1 Overview. W3C Recommendation.
Available http://www.w3.org/TR/sparql11-overview/.
Wandelt, S., Moller, R., & Wessel, M. (2010). Towards scalable instance retrieval
ontologies. International Journal Software Informatics, 4 (3), 201218.
Wu, Z., Eadon, G., Das, S., Chong, E. I., Kolovski, V., Annamalai, M., & Srinivasan, J.
(2008). Implementing inference engine RDFS/OWL constructs user-defined
rules oracle. Alonso, G., Blakeley, J. A., & Chen, A. L. P. (Eds.), ICDE 2008,
Proceedings 24th International Conference Data Engineering, April 7-12,
2008, Cancun, Mexico, pp. 12391248. IEEE.
Zhou, Y., Nenov, Y., Cuenca Grau, B., & Horrocks, I. (2014). Pay-as-you-go OWL query
answering using triple store. Proceedings Twenty-Eighth AAAI Conference
Artificial Intelligence.
Zhou, Y., Nenov, Y., Grau, B. C., & Horrocks, I. (2013). Complete query answering
horn ontologies using triple store. Semantic Web - ISWC 2013 - 12th
International Semantic Web Conference, Sydney, NSW, Australia, October 21-25,
2013, Proceedings, Part I, pp. 720736.

367


