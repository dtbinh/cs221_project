journal artificial intelligence

submitted published

pagoda pay go ontology query answering
datalog reasoner
yujiao zhou
bernardo cuenca grau
yavor nenov
mark kaminski
ian horrocks

yujiao zhou cs ox ac uk
bernardo cuenca grau cs ox ac uk
yavor nenov cs ox ac uk
mark kaminski cs ox ac uk
ian horrocks cs ox ac uk

department computer science university oxford
parks road oxford ox qd united kingdom

abstract
answering conjunctive queries ontology enriched datasets core reasoning task
many applications query answering however computationally expensive
led development query answering procedures sacrifice expressive
power ontology language completeness query answers order improve
scalability describe hybrid query answering owl
ontologies combines datalog reasoner fully fledged owl reasoner order
provide scalable pay go performance key feature
delegates bulk computation datalog reasoner resorts expensive
owl reasoning necessary fully answer query furthermore although
main goal efficiently answer queries owl ontologies data technical
general applicable first order knowledge representation languages captured rules allowing existential quantification
disjunction head assumption availability datalog reasoner
fully fledged reasoner language interest used black boxes
implemented techniques pagoda system combines datalog
reasoner rdfox owl reasoner hermit extensive evaluation shows
pagoda succeeds providing scalable pay go query answering wide range
owl ontologies datasets queries

introduction
ontologies increasingly used rich conceptual schemas wide range application
domains staab studer one widely used ontology languages owl
description logic language standardised world wide web consortium
w c revised owl baader calvanese mcguinness nardi
patel schneider horrocks patel schneider van harmelen cuenca grau
horrocks motik parsia patel schneider sattler owl ontology consists
set axioms correspond first order sentences containing unary binary
predicates called classes properties owl structure axioms sentences
restricted ensure decidability basic reasoning
applications main focus conceptual model class subsumption key reasoning increasing number applications however
main focus conceptual model access data often form rdf
c ai access foundation rights reserved

fizhou cuenca grau nenov kaminski horrocks

graph manola miller data centric applications key reasoning
answer conjunctive queries cqs sentences constructed function free atoms
conjunction existential quantification abiteboul hull vianu
constitute core component standard query languages sql sparql
w c sparql working group
conjunctive query answering ontology enriched datasets however high worstcase complexity glimm lutz horrocks sattler eiter ortiz simkus
even measured respect size data called data complexity
although heavily optimised existing systems query answering respect rdf
data unrestricted owl ontology process small medium size datasets
sirin parsia cuenca grau kalyanpur katz moller neuenstadt ozcep
wandelt wandelt moller wessel kollia glimm led
development query answering procedures sacrifice expressive power
ontology language completeness query answers order improve scalability
former case sacrificing expressive power query answering procedures
developed fragments owl conjunctive query answering tractable
respect data complexity three fragments standardised called
profiles owl motik cuenca grau horrocks wu fokoue lutz owl
ql owl el profiles dl lite calvanese de giacomo lembo
lenzerini rosati el baader brandt lutz families description
logics owl rl profile corresponds fragment rule language datalog
grosof horrocks volz decker dantsin eiter gottlob voronkov
conjunctive query answering systems profiles shown highly scalable
practice bishop kiryakov ognyano peikov tashev velkov wu eadon das
chong kolovski annamalai srinivasan motik nenov piro horrocks olteanu
erling mikhailov rodriguez muro calvanese lutz seylan toman
wolter stefanoni motik horrocks favourable computational
properties fragments make natural choice data intensive applications
come expense loss expressive power many ontologies used
applications captured profiles
latter case sacrificing completeness query answering procedures
developed exploit scalable reasoning techniques expense computing
approximate query answers thomas pan ren tserendorj rudolph krotzsch
hitzler wandelt et al bishop et al cases computed
answers sound correct answer tuples identified incomplete correct
answer tuples may identified one way realise procedure weaken
ontology falls within one owl profiles use scalable
procedure relevant fragment required weakening trivially achieved
simply discarding parts profile axioms sophisticated techniques may
try reduce even minimise information loss console mora rosati santarelli savo
clearly sound answer tuple entailed weakened
ontology entailed original ontology incomplete general
ontologies outside relevant profile answer returned systems therefore
understood providing lower bound correct answer however procedures



fipagoda pay go query answering datalog reasoner

cannot general provide complementary upper bound even indication
complete computed answer cuenca grau motik stoilos horrocks
describe novel hybrid query answering combines
scalable datalog owl rl reasoner fully fledged owl reasoner provide
scalable performance still guaranteeing sound complete answers cases
procedure uses datalog reasoner efficiently compute lower bound sound
possibly incomplete upper bound complete possibly unsound answers input query lower upper bound answers coincide obviously provide sound
complete answer otherwise relevant subsets ontology data computed
guaranteed sufficient test correctness tuples gap
lower upper bounds subsets computed datalog reasoner
typically much smaller input ontology data finally fully fledged
reasoner used check gap tuples w r relevant subset still computationally expensive load fully fledged reasoner reduced exploiting
summarisation techniques inspired sher system quickly identify spurious gap
tuples dolby fokoue kalyanpur kershenbaum schonberg srinivas dolby
fokoue kalyanpur schonberg srinivas analysing dependencies
remaining gap tuples reduce number checks need performed
key feature pay go behaviour bulk computational workload delegated datalog reasoner extent
fully fledged reasoner needed depend solely ontology interactions
ontology dataset query thus even expressive
ontology queries often fully answered datalog reasoner even
fully fledged reasoner required relevant subset extraction summarisation
dependency analysis greatly reduce number size reasoning moreover
additional advantage lower bound answer tuples quickly
returned even cases completion answer requires time consuming computations finally although main goal efficiently answer queries owl
ontologies datasets technical general
restricted ontology languages description logics precisely given kr
language l captured first order rules allowing existential quantification
disjunction head want answer conjunctive queries
assumption availability fully fledged reasoner l datalog reasoner
used black box
implemented techniques pagoda system rdfox datalog
reasoner motik et al hermit fully fledged owl reasoner glimm
horrocks motik stoilos wang conducted extensive evaluation
wide range realistic benchmark datasets queries evaluation suggests
techniques eective providing scalable pay go query answering tests
queries ontologies none contained within
owl profiles queries fully answered without resorting fullyfledged reasoner moreover even fully fledged reasoner used relevant subset
http www cs ox ac uk isg tools pagoda
although techniques proved correct general conjunctive queries practice limited
current query capabilities owl reasoners



fizhou cuenca grau nenov kaminski horrocks

extraction summarisation dependency analysis greatly reduced number size
reasoning tests size dataset typically reduced order
magnitude often several orders magnitude seldom required
single test resolve status gap tuples taken together experiments
pagoda provide efficient conjunctive query answering service scenarios requiring
expressive ontologies datasets containing hundreds millions facts something
far beyond capabilities pre existing state art ontology reasoners
remainder organised follows section introduce key
concepts definitions section present high level overview
section describe lower bound answers computed prove
sound section describe upper bound answers computed prove
complete section present technique reducing size
ontology dataset processed fully fledged reasoner prove
preserves completeness section present summarisation dependency analysis
optimisations prove preserve completeness section describe
implementation techniques pagoda system discuss additional
optimisations finally positioning work within state art section
present extensive evaluation section draw conclusions section

preliminaries
section briefly introduce rule first order languages description logics
dls family knowledge representation formalisms underpinning owl owl
ontology languages baader et al
use standard notions first order logic constant predicate function
term substitution atom formula sentence adopt standard definitions
herbrand interpretation model well un satisfiability entailment written
sets first order sentences denote nullary predicate false
interpretations formulas may contain special equality predicate assume
first order knowledge base f function free signature uses axiomatises
semantics usual way f must contain following first order sentences
eq eq instantiated n ary predicate p f n
x xn p x xi xn xi xi

eq

x x x

x z x z x z

x xn p x xi xn xi p x xi

eq
eq
xi xn

eq

finally exploit following notion homomorphism applicable sets
atoms formulas substitutions given sets ground atoms define
homomorphism mapping ground terms ground terms
c c constant c p tn atom p tn
application homomorphism naturally extended ground atoms ground
formulas ground substitutions e g atom p tn p tn
ground substitution substitution x x x dom


fipagoda pay go query answering datalog reasoner

rule knowledge representation
rule languages well known knowledge representation formalisms strongly connected ontology languages dantsin et al cal gottlob lukasiewicz marnette
pieris bry eisinger eiter furche gottlob ley linse pichler wei
define fact function free ground atom dataset finite set facts
rule r function free first order sentence form
x


x


x




x
n








zi x zi



atom dierent free variables x

x z
formula x zj conjunction atoms dierent
free variables x zj
conjunction
atoms x n x body r denoted body r
w
formula

z

x zi head r denoted head r assume rules


safe every variable x mentioned body r brevity universal quantifiers
omitted rules
rules form general able capture first order rule languages
knowledge representation including datalog abiteboul et al existential rules
datalog cal et al well datalog alviano faber leone manna
b bourhis morak pieris
say rule r
disjunctive datalog head r contains existential quantifiers conjunction
existential
datalog disjunctive datalog
knowledge base k k dk consists finite set rules k dataset dk
predicate dk assumed occur k
order simplify presentation technical sometimes restrict
knowledge bases particular normal form specify next say
rule r normalised one following forms

x zi single atom dierent

x

x

x




x
n



x
n



x
n





z x z


x





x




knowledge base k dk normalised rules k normalised restriction
normalised knowledge bases w l g since every set rules form
transformed polynomial time set normalised rules norm conservative
extension given next rule r let xi tuple


fizhou cuenca grau nenov kaminski horrocks

free variables subformulas zi x zi head r xi x furthermore
let e fresh predicates arity xi let c fresh predicates arity xi zi
uniquely associated r norm consists following rules

x




x
n






e xi





e xi zi c xi zi
c xi zi

atom

x zi e xi

x zi c xi zi


x zi





frequently use skolemisation interpret rules herbrand interpretations
rule r form existentially quantified variable zij let fijr function
symbol globally unique r zij arity x furthermore let sk substitution
sk zij fijr x zij zi skolemisation sk r r following
first order sentence slight abuse notation refer skolemised rule
x




x
n






x zi sk



skolemisation sk set rules obtained skolemising individual rule
extend definitions head body rules skolemised rules naturally
well known skolemisation entailment preserving transformation
description logics ontology languages
next present brief overview dls underpinning w c standard ontology
language owl horrocks kutz sattler cuenca grau et al typically
predicates dl signatures restricted unary binary former called atomic
concepts whereas latter typically referred atomic roles dls typically provide
two special concepts bottom concept top concept mapped
every interpretation empty set interpretation domain respectively
every owl dl ontology normalised set axioms form given
left hand side table motik shearer horrocks thus w l g
define owl dl ontology finite set axioms form table
every owl dl ontology must satisfy certain additional requirements order ensure
decidability reasoning horrocks et al restrictions however immaterial
technical
normalised axiom corresponds single rule given right hand side
table concept translated special nullary predicate whereas translated
although rules sufficient express normal form introduce rules order
facilitate computation upper bound query answers see sections
convenience omit axioms form v n r b simulated v r bi
bi v b bi u bj v j n bi fresh concept



fipagoda pay go query answering datalog reasoner

axioms
dn
ai v f

di
n


v

j bj
r v b
v self r
self r v
r vs
r vs
r vt
rus v
v r b
v r b
v
v r

rules
vn
ai x w

vi
n


x


j bj x
r x b x
x r x x
r x x x
r x x
r x x
r x z z x
r x x
x r x b
v
w
x
r x yi b yi
jm yi yj
x x
r x















table normalised dl axioms translation rules n b
atomic concepts r atomic roles
ordinary unary predicate meaning axiomatised let function
maps owl axiom corresponding rule table let
ontology smallest knowledge base containing

rule x x atomic concept
rules r x x r x atomic role r
note since knowledge base must contain axioms equality
signature whenever required translate axiom
recent years growing interest ontology languages favourable
computational properties led standardisation rl ql el
profiles owl motik et al say ontology horn
axioms additionally say horn ontology
rl contain axioms
ql contain axioms furthermore axioms satisfy n axioms satisfy
el contain axioms additionally say
el ontology elhor contain axioms
conjunctive queries
conjunctive query cq formula q x form x x
conjunction function free atoms query boolean x atomic x


fizhou cuenca grau nenov kaminski horrocks

consists single atom simplicity sometimes omit free variables
write q instead q x
let k knowledge base tuple constants possible answer q x w r k
arity x constant occurs k furthermore say
possible answer certain answer k q set certain answers denoted
cert q k note x boolean set certain answers empty
consists tuple length zero treat unsatisfiability boolean query
x nullary falsehood symbol query holds w r k k unsatisfiable
cqs alternatively represented datalog rules end query q x
uniquely associated predicate pq arity x take p set
rq rules defined follows


q
rq

x pq x otherwise
cert q k k rq pq way certain answers characterised
means entailment single facts
answering cqs w r knowledge bases computationally hard decidability knowledge bases stemming owl dl ontologies remains open decidability
obtained ensuring ontology stays within one standardised profiles
owl restriction ensures tractability respect data complexity
makes profiles natural choice ontology language data intensive applications
standard language sparql w c sparql working group allows users
formulate cqs owl ontologies however ensure decidability reduce
complexity query answering cqs interpreted sparql ground semantics
say possible answer q x x ground answer w r satisfiable
knowledge base k exists tuple e constants k k e clearly
every ground answer certain answer vice versa denote ground q k
set ground answers q w r k
many reasoning systems currently support sparql hence compute ground q k
given cq q owl dl ontology k input additionally systems
able compute certain answers q suitably restricted precisely say q
internalisable kq k rq corresponds owl dl knowledge base internalisation
amounts transforming query ontology axiom typically referred
rolling dl literature horrocks tessaris
focus general computing certain answers cq
w r knowledge base k theoretical generally applicable regardless
rule language k expressed
hyperresolution
reasoning knowledge bases realised means hyperresolution calculus
robinson voronkov briefly discuss next treatment hyperresolution consider standard basic notions theorem proving ground clause
general unifier mgu furthermore treat disjunctions ground atoms
sets hence allow duplicated atoms disjunction assume


fipagoda pay go query answering datalog reasoner

occur clauses denote empty clause skolemisation sk r
normalised rule r logically equivalent clause containing atom dierent
head sk r negation atom body sk r sometimes abuse
notation use sk r refer skolemised rule corresponding clause
let c n clause j atoms
possibly containing functional terms furthermore n let
positive ground clause finally let mgu pairs n
positive ground clause n hyperresolvent c n
inference called hyperresolution step clause c main premise
let k k dk normalised knowledge base let c positive ground clause
derivation c k pair tree labeling function
maps node ground clause v


v c v root



v dk v leaf

v children w wn v hyperresolvent sk r w wn
rule r k
support written support set facts rules participating hyperresolution steps write k c denote hyperresolution derivation
c k hyperresolution sound complete k unsatisfiable k
furthermore k satisfiable k k ground atom
skolem chase
answering cqs knowledge base k k dk k consists existential
rules realised chase technique abiteboul et al cal gottlob
kifer use skolem chase variant marnette cuenca grau
horrocks krotzsch kupke magka motik wang
skolem chase sequence k sequence sets ground atoms b

b dk b inductively defined follows
b b head sk r r k

substitution b body r

skolem chase k written chasek defined b
key property skolem chase computes universal herbrand model
k used database answering cqs formally k satisfiable

chasek furthermore k satisfiable chasek homomorphically embeddable
every herbrand model k seen set atoms follows k satisfiable
q boolean cq k q chasek q
note chasek might contain infinitely many atoms k datalog however
chasek guaranteed finite contains precisely facts logically entailed k
case often refer chasek materialisation k



fizhou cuenca grau nenov kaminski horrocks

overview
section provide high level overview conjunctive query answering assume availability two reasoners
datalog reasoner sound complete answering conjunctive queries
datalog knowledge bases
fully fledged reasoner sound complete answering given class
conjunctive queries q includes unsatisfiability query w r knowledge
bases given ontology language l
describe general form make assumptions
two reasoners treating black box query answering procedures
kind queries knowledge bases dealt
ultimately depends capabilities fully fledged reasoner instance owl
dl reasoners typically process arbitrary owl dl knowledge bases however
query language limited internalisable queries turn scalability
ultimately depends much reasoning workload delegated datalog
reasoner goal delegate bulk computation datalog reasoner
restrict expensive use fully fledged reasoner bare minimum
rest fix arbitrary normalised knowledge base
k k dk given arbitrary query q may special unsatisfiability query
containing symbols k core relies exploiting datalog
reasoner accomplishing following tasks
lower upper bound computation exploit datalog reasoner
compute lower bound lq upper bound u q certain answers
q w r k bounds match e lq u q query fully
answered datalog reasoner otherwise dierence gq u q lq provides
set gap answers need verified fully fledged reasoner
relevant techniques computing bounds described sections
knowledge base subset computation exploit datalog reasoner
compute hopefully small subset kq k sufficient check answers gq
cert q k cert q k cert q kq gq details
compute kq given section
proceed according following steps given query q
step check satisfiability k
compute bounds l u unsatisfiability query l
terminate report k unsatisfiable u proceed step
k satisfiable
b compute subset k k

c use fully fledged reasoner check satisfiability k minimise
computational workload fully fledged reasoner proceed follows


fipagoda pay go query answering datalog reasoner

construct summary k see section use fully fledged reasoner check satisfiable proceed step k satisfiable
ii use fully fledged reasoner check satisfiability k unsatisfiable terminate report k unsatisfiable otherwise
proceed step k satisfiable
step compute bounds lq u q gq terminate return lq otherwise
proceed step
step compute subset kq k
step gq use fully fledged reasoner check whether kq q
minimise computational workload step carried follows
construct summary kq kq see section gq use
fully fledged reasoner check whether certain answer q w r
summary kq remove gq case
b compute dependency relation remaining answers gq b
depends spurious answer b see section
c remove remaining spurious answers gq answer spurious
entailed kq depends spurious answer use fullyfledged reasoner check relevant entailments arranging checks heuristics
w r dependency relation
step return lq gq
following sections describe steps formally introduce
number improvements optimisations rely additional assumption
datalog reasoner materialisation basedthat datalog knowledge base k
query q computes query answers cert q k first computing materialisation
chasek evaluating q resulting materialisation reasonable
assumption practice since datalog reasoners semantic web applications e g
owlim rdfox oracles native inference engine materialisation cases
assume direct access materialisation pagoda system
combines hermit materialisation reasoner rdfox hence able
exploit improvements optimisations described realisation
pagoda discussed detail section
illustrate techniques running example consisting knowledge
base kex kex dkex query qex x given table note rules r
r kex normalised however easily brought normal form
introducing fresh binary predicates eatsh eatsl follows
meateater x eatsh x r

eats x herbivore eatsh x
eatsh x eats x

eatsh x herbivore

r b
r c

r



folivore x eatsl x r

eats x leaf eatsl x
eatsl x eats x
eatsl x leaf

r b

r c
r

fizhou cuenca grau nenov kaminski horrocks

mammal tiger



mammal wolf



mammal howler



mammal lion



meateater wolf



meateater python
eats python rabbit




eats wolf sheep
herbivore sheep




folivore howler
mammal hare




folivore hare



herbivore rabbit



eats sheep grass



eats hare willow



carnivore x mammal x

herbivore x mammal x

folivore x meateater x

herbivore x eats x plant

r
r
r
r

mammal x herbivore x meateater x

r

mammal x eats x

r

meateater x eats x herbivore
folivore x eats x leaf
leaf x plant x

r
r
r

qex x eats x plant

table running example knowledge base kex query qex x set kex consists
rules r r dataset dkex consists facts
core techniques described sections applicable knowledge base
query order simplify presentation definitions technical
sections fix addition knowledge base k k dk arbitrary query
q x x may unsatisfiability query

lower bound computation
straightforward way compute lower bound answers datalog reasoner
evaluate q w r datalog subset k consisting facts dk datalog rules
k case owl ontologies amounts considering subset owl
rl axioms ontology monotonicity property first order logic certain
answers w r subset certain answers w r k furthermore subset
unsatisfiable k
example datalog subset example kex consists rules r r
r together facts materialisation datalog subset
kex following dataset dex mammal rabbit mammal sheep plant grass
evaluating qex x materialisation obtain sheep answer

basic lower bound rather imprecise practice since rules featuring disjunction existential quantification typically abound owl dl ontologies improve



fipagoda pay go query answering datalog reasoner

bound exploit techniques allow us deterministically derive via datalog
reasoning additional consequences k follow datalog subset
dealing disjunctive rules program shifting
deal disjunctive rules adopt variant shiftinga polynomial program transformation commonly used answer set programming eiter fink tompits woltran
next illustrate intuition behind transformation example
example let us consider information kex arctic hares hare
r one deduce hare meateater follows
rule r fact hare herbivore since hare eats willow
deduce plant willow r hence hare answer qex although r
disjunctive rule reasoning process fully deterministic captured
datalog end introduce predicate meateater intuitively stands
complement meateater extend datalog subset kex rules encoding
intended meaning fresh predicate particular r r two rules
obtained r r respectively
folivore x meateater x

r

mammal x meateater x herbivore x

r

exploit rules derive meateater hare herbivore hare



define shifting transformation formally
definition let r normalised disjunctive datalog rule predicate p r
let p fresh predicate arity furthermore given atom p let
p shifting r written shift r following set rules
r form shift r r

n





n

r form shift r consists following rules rule
ii rules j iii rules n
variable occurs atom rule








n
n



















j




n


j
















j







let set normalised disjunctive datalog rules shifting defined
following set datalog rules

shift
shift r

r

note shifting polynomial transformation r disjunctive datalog rule
n atoms body atoms head shift r contains n datalog
rules furthermore shown following theorem sound


fizhou cuenca grau nenov kaminski horrocks

theorem let dd
subset disjunctive datalog rules k furthermore let
k
k shift dd





cert q k cert q k
k
k

proof let chasek b l
l non negative integer recall k datalog
knowledge base hence skolem chase finite induction
following properties hold l b

k unsatisfiable
b p k p
c p k p
base case clearly b dk properties trivially follow fact dk k

inductive step assume properties c hold every b
hold every b b must exist rule r k substitution
b body r head r since every atom body r b
properties c hold atoms induction hypothesis furthermore
must exist rule r k form n r shift r
distinguish two cases head r case r r
induction hypothesis k n hence k ii head r
case r form n b
induction hypothesis k entails n rule r
cannot satisfied model k since r k obtain k unsatisfiable
b p r form p hence b contains atoms
induction hypothesis k entails
n















n

since r k p
must case k p
c p following cases head r case induction
k n since n
rule k obtain k required ii head r case
r form p b contains atoms
induction hypothesis k entails atoms
n

















n
since r k obtain k p
v
q theorem follows property otherwise let q x ni x
let possible answer k q since k datalog exists tuple
e constants k non negative integer l e b l n
b k e hence k q
shifting captures consequences disjunctive datalog rules k
furthermore note refinement shifting ensures preservation
consequences indeed well known disjunctive datalog express queries e g
non colorabilility cannot captured means datalog program afrati cosmadakis yannakakis


fipagoda pay go query answering datalog reasoner

example consider disjunctive datalog knowledge base consisting fact
greenseaturtle turtle rules r r
greenseaturtle x herbivore x carnivore x
clearly mammal turtle follows knowledge base shifting consists fact
greenseaturtle turtle following rules predicates carnivore greenseaturtle
herbivore mammal abbreviated respectively c g h
c x x

c x x

x c x

g x h x c x

g x h x c x

g x c x h x

h x x

h x x

h x c x g x

x h x



checked fact mammal turtle follow shifting
dealing existential rules combined owl el

existentially quantified rules ubiquitous large scale complex ontologies especially
life sciences applications el profile owl specifically designed
applications many large ontologies used practice seen consisting large
el backbone extended small number axioms outside profile
given prevalence el axioms realistic ontologies natural consider
owl el subset k computing lower bound answers cq answering owl
el however pspace complete stefanoni motik krotzsch rudolph
system currently supports cq answering whole owl el complexity
however drops np case elhor stefanoni et al setting
restriction elhor ontologies added practical benefit exploit socalled combined delegate computational work associated cq
answering datalog reasoner stefanoni et al lutz toman wolter
technique currently supported systems karma although datalog cq
answering techniques available richer languages extension elhor
inverse roles e axioms table resulting datalog programs hard
compute exponential size worst case perez urbina motik horrocks
contrast combined elhor relevant datalog
programs straightforwardly constructed without need reasoning
linear size see related work section details
thus compute query answers depend existentially quantified rules consider
r
subset el
k elho rules k syntactically characterised follows
definition rule elhor one following forms x
form x x c yr x
p




ai x

q


j

rj x yj

lj


k

http www cs ox ac uk isg tools karma



bjk yj x

el

fizhou cuenca grau nenov kaminski horrocks

r x r x
r x

el
el

combined exploit cq answering conceptualised
three step process
first step compute materialisation datalog program obtained
el
k respect dk contains knowledge base unsatisfiable otherwise model knowledge base model however
universal cannot homomorphically embedded every model thus
evaluation cqs may lead unsound answers
second step evaluate query q step intractable query
size well known database techniques exploited
third step unsound answers obtained second step discarded
polynomial time filtration
next specify transformation knowledge bases datalog used first
step transformation exploited later section computing upper
bound query answers computation datalog program knowledge base
step relies form skolemisation existentially quantified variables mapped
fresh constants instead functional terms
definition rule r form existentially quantified variable
zij let crij constant globally unique r zij let c sk substitution
c sk zij crij zij zi c skolemisation c sk r r given follows
x




x
n






x zi c sk



define c sk k c sk r r k dk



note application c skolemisation elhor rule
datalog rule note contrast standard skolemisation c skolemisation
satisfiability entailment preserving transformation may query answers
w r c sk k unsound w r k shown however c skolemisation
satisfiability preserving elhor knowledge bases thus c sk el
k dk satisfiable
el



satisfiable
stefanoni
et
al


next
sketch

filtration step
k
k
refer interested reader work stefanoni et al details
main source spurious answers evaluating query materialisation
obtained step presence forksconfluent chains binary atoms involving
skolem constantsin image query materialisation due
fact elhor called forest model property forks cannot manifest
forest shaped say constant c el
k dk auxiliary
dierent constant b exists c sk el




c

b


auxiliary constants
k
k
introduced c skolemisation entailed equal


fipagoda pay go query answering datalog reasoner

constant present original elhor knowledge base let substitution
mapping free variables x q constants k q relation
q smallest reflexive transitive binary relation terms q satisfying
following fork rule
fork


st

r p occur q
auxiliary constant

clearly equivalence relation computed polynomial time size
q term q let equivalence class w r let mapping
term q arbitrary fixed representative auxiliary graph
q directed graph g hv ei
v contains vertex term q auxiliary
e contains directed edge h atom form r q
v
ready define filtration say spurious answer
auxiliary graph q contains cycle terms occurring q exist
c sk el

k dk clearly filtration candidate answer
done polynomial time size q
assume availability procedure soundanswers solves steps
given q model computed step returns answers q w r
input elhor knowledge base consequently given k q obtain lower bound
query answers follows
r
extract subset el
k elho rules k

compute materialisation c sk el
k dk
q return unsatisfiable otherwise return soundanswers q
example consider running example elhor subset kex consists
facts together rules except r r fact
rule r deduce howler eats leaf must plant rule r hence
howler answer qex answer identified aforementioned steps
c skolemisation r leads datalog rule
folivore x eatsl x c

r au

materialisation datalog program consisting facts rule r au contains
fact plant c hence tuple howler c matches qex materialisation
match deemed sound filtration procedure

aggregated lower bound
techniques section seamlessly combined obtain lower bound lq
hopefully close actual set certain answers given k q proceed follows


fizhou cuenca grau nenov kaminski horrocks

dd subset
construct datalog knowledge base shift dd
k dk k
l
disjunctive datalog rules k compute materialisation
l
l
construct datalog program c sk el
k compute materialisation

q lq cert q l otherwise lq soundanswers q l
theorem ensures k l signature k hence l
used initial dataset second step properties c skolemisation
filtration discussed section ensure every answer lq indeed certain
answer q w r k furthermore l k indeed unsatisfiable finally note
materialisation l obtained first step pipelined second step
lq sometimes strict superset answers would obtain simply
el
computing answers q w r shift dd
k dk c sk k dk independently
union
example running example kex aggregated lower bound lex consists
sheep follows datalog subset kex hare follows shift kex
howler follows elhor fragment kex


upper bound computation
many practical cases lower bound lq described section constitutes rather
precise approximation actual set certain answers furthermore
computed efficiently resorting datalog reasoner lower bound
computation however gives indication accuracy answers without
corresponding upper bound every possible answer remains candidate answer
needs confirmed discarded
section describe efficiently computing upper bound
set certain answers lower upper bounds coincide fully answered
query otherwise gap lower upper bounds provides margin
error lower bound narrows set candidate answers whose
verification may require powerful computational techniques
strengthening knowledge base
first step towards computing upper bound construct polynomial size
datalog knowledge base k k unsatisfiable k entails nullary predicate
cert q k cert q k otherwise roughly speaking k refer
datalog strengthening k obtained k
replacing fresh nullary predicate predefined meaning
splitting disjuncts occurring head position dierent datalog rules
skolemising existentially quantified variables constants definition
convenient subsequent definitions proofs explicitly define splitting
k written split k intermediate knowledge base resulting steps


fipagoda pay go query answering datalog reasoner

satisfiable disjunction free datalog strengthening k defined
applying step replacing existentially quantified rule
split k c skolemisation
definition splitting rule r form following set rules
head r split r
predicate predefined meaning
otherwise split r

fresh nullary

zj j x zj j

splitting k k dk defined split k r k split r dk finally
datalog strengthening k defined str k c sk split k





n

n

example consider example knowledge base kex splitting kex obtained
replacing rule r rules r ua r ub rule r r u
mammal x herbivore x

mammal x meateater x

folivore x meateater x

r ua
r ub
r u

finally str k obtained replacing existentially quantified rules r r
following rules r au r u
meateater x eatsh x c
mammal x eats x c

well rule r rule r au given example

r au
r u


note k contain rules head str k logically entails
k splitting amounts turning disjunctions head rules conjunctions
c skolemisation restricts possible values existentially quantified variables fixed
constants thus cert q str k constitutes upper bound cert q k however
longer case replaced ordinary predicate without predefined
meaning rationale behind replacement provide meaningful upper bound
even cases splitting disjunctions c skolemising existentially quantified variables
would make strengthened knowledge base unsatisfiable
str k example knowledge base
example consider strengthening kex
ex
since howler mammal rule r ub meateater
since folivore howler fact kex derive rule r u note
replaced falsehood predicate strengthening kex would
unsatisfiable case meaningful upper bound could obtained query

next str k exploited compute meaningful upper bound
input query despite fact stripped built semantics first order
logic following lemma establishes key property splitting transformation
definition ground clause n derivable k via hyperresolution
skolem chase split k contains every atom n


fizhou cuenca grau nenov kaminski horrocks

lemma let hyperresolution derivation k let h split k
every node v ground atom occurring v chaseh
proof prove claim structural induction
base case v leaf v dk since dk h chaseh

inductive step assume induction hypothesis holds children w wn
node v exists rule r k substitution sk r form
n disjunction atoms v
n
hyperresolvent sk r wi n induction
hypothesis disjuncts chaseh need claim
disjunct
distinguish following cases depending form
normalised rule r
r form

empty claim holds vacuously

r form sk induction hypothesis
chaseh since split r r hence r h obtain sk chaseh





r form induction hypothesis
chaseh since rule n h obtain
atom chaseh required
exploit completeness hyperresolution split k satisfies
required properties furthermore fact str k split k immediately implies
str k satisfies properties well hence may exploited compute upper
bound query answers
theorem following properties hold h split k well h str k
cert k cert h e k unsatisfiable h ii k
satisfiable cert q k cert q h
proof first properties ii hold h split k k unsatisfiable
hyperresolution derivation empty clause k thus must
exist rule r form k substitution
atom
n derivable k lemma chaseh
since h contains rule n chaseh h required
assume k satisfiable cert q k cert q k cert q h holds trivially
otherwise let certain answer q w r k k q hence k rq pq
since cert k q completeness hyperresolution
lemma obtain pq chase k rq aforementioned
splitting entails pq since split k rq h rq cert q h
required finally properties ii hold str k direct consequence fact
str k split k
example figure depicts materialisation str kex edges predicates
introduced normalisation ignored edges figure represent
binary predicate eats explicit facts kex depicted black implicit facts depicted


fipagoda pay go query answering datalog reasoner

c

tiger
mammal
herbivore
meateater

meateater
mammal
herbivore
plant

lion
mammal
herbivore
meateater

c

python
meateater

plant

grass plant

wolf

rabbit
herbivore
mammal
meateater

mammal
meateater
herbivore

c

sheep
herbivore
mammal
meateater
plant

leaf
plant

willow plant

howler

hare

mammal
folivore
herbivore
meateater

mammal
folivore
herbivore
meateater

figure materialisation datalog strengthening kex
dierent colours facilitate subsequent illustration refinements
materialisation allow us tighten upper bound obtain following
upper bound cert qex kex evaluating qex materialisation
cert qex str kex tiger lion python rabbit wolf sheep howler hare c
already mentioned str kex however obtained upper bound still meaningful
since contain possible answers kex grass willow please note
c certain answer qex w r str kex however constant c signature
kex hence possible answer qex w r k

tightening upper bound existential rules
upper bound obtained str k rather coarse grained practice discussed
example python tiger lion wolf contained upper bound none
certain answer qex section refine upper bound
restricting application c skolemisation existential rules instead computing
upper bound q constructing strengthened knowledge base str k
evaluating q materialisation str k proceed follows
apply k variant skolem chase refer c chase first
splitting disjuncts occurring head position dierent rules applying
skolem chasing split k following modifications similarly
restricted chase cal et al existential rules applied rule
head already satisfied ii rather skolemising head atom
functional term whenever existential rule applied resort c skolemisation
instead due latter modification c chase compute least
herbrand model split k rather model split k
evaluate q aforementioned chase thus obtaining upper bound
certain answers q w r split k thus w r k
following example motivates practical advantages
example consider materialisation str kex figure already
mentioned python returned upper bound answer since qex matches facts


fizhou cuenca grau nenov kaminski horrocks

eats python c plant c materialisation fact eats python c obtained
eatsh python c included materialisation satisfy c skolemised
rule r au str kex existentially quantified rule r kex case
python however rule r kex already satisfied fact eatsh python rabbit
derived eats python rabbit herbivore rabbit dataset rule
r b please note rule r b form normalisation r
rule r b ensures r satisfied substitution r satisfied substitution obtain upper bound suffices construct model
kex rather model str kex thus prevent application rule r au
python chase dispense eats python c materialisation
ready define c chase formally
definition let h split k let dh subset datalog rules h
eh h dh c chase sequence k sequence sets ground atoms b
b dh e b dk b inductively defined given next let sdi
sei defined follows
sdi head r r dh

sei head c sk r r eh

substitution b body r b head r
substitution b body r b head r

b b sdi sdi
b b sei otherwise finally define

c chase k c chasek b


note c chase k finite set since terms occur
constants c sk split k
example c chase kex depicted figure materialisation strict
subset figure orange coloured binary facts longer derived
consequently python longer derived answer qex

relevant properties c chase summarised following lemma
theorem following properties hold cert k cert c chasek e
k unsatisfiable c chasek ii k satisfiable cert q k cert q c chasek
proof first prove c chasek model split k since dk c chasek clear
satisfies facts split k let r split k distinguish two cases
rule r datalog c chasek body r substitution definition
c chase ensures head r c chasek hence rule satisfied
otherwise r form c chasek body r substitution
definition c chaseh ensures head c sk r c chasek thus c chasek
head r hence rule satisfied
contrapositive first property assume c chasek
c chasek model split k split k hence k satisfiable
theorem finally assume k satisfiable cert q k cert q k cert q h
holds trivially otherwise let certain answer q w r k theorem obtain
cert q split k c chasek split k cert q c chasek


fipagoda pay go query answering datalog reasoner

c

tiger
mammal
herbivore
meateater

meateater
mammal
herbivore
plant

lion
mammal
herbivore
meateater

c

python

plant

grass plant

wolf

rabbit

meateater

herbivore
mammal
meateater

mammal
meateater
herbivore

c

sheep
herbivore
mammal
meateater
plant

leaf
plant

willow plant

howler

hare

mammal
folivore
herbivore
meateater

mammal
folivore
herbivore
meateater

figure c chase kex
tightening upper bound disjunctive rules
although technique described previous section quite eective practice
main limitation split k disjunctions heads rules k eectively turned conjunctions section refine upper bound
exploiting extension c chase uses similar deal disjunctive
rules well existential rules
specifically extend c chase deal disjunctive rules r form
r applied none disjuncts head rule already
satisfied ii r applied one disjuncts included chase rather
order avoid non determinism chase expansion reduce
computational cost disjuncts selected deterministically means efficiently
implementable choice function
example consider running example first observe wolf answer
qex w r c chase kex shown figure indeed herbivore wolf derived
mammal wolf rules split r thus plant sheep derived
rule r note however wolf spurious answer given meateater wolf
explicit fact kex rule r already satisfied wolf hence dispense
fact herbivore wolf materialisation
finally since goal construct model kex reasonable pick disjuncts
whose predicate unrelated kex since depends meateater folivore
rule r makes sense include fact herbivore b materialisation whenever
disjunctive rule r applied constant b

details refer reader section specific choice function
implemented pagoda described
define extended notion c chase efficiently implementable
choice function given additional parameter
definition let h knowledge base obtained k replacing
nullary predicate let dh set datalog rules h let nh h dh
furthermore let f polynomially computable choice function given ground clause
set ground atoms returns disjunct c chase sequence k w r f


fizhou cuenca grau nenov kaminski horrocks

c

tiger
mammal
herbivore

lion
mammal
herbivore

python
meateater

plant

grass plant

wolf

rabbit
herbivore
mammal

mammal
meateater

c

sheep
herbivore
mammal

leaf
plant

willow plant

howler

hare

mammal
folivore
herbivore

mammal
folivore
herbivore

figure c chasef kex
sequence sets ground atoms b b dh e b dk b
defined given next let sdi sni follows
sdi head r r dh

sni f head c sk r b r nh

substitution b body r b head r

substitution b body r b head r

b b sdi sdi b b sni otherwise finally define

c chase k w r f c chasefk b

example consider aforementioned choice function f picks herbivore b
whenever rule r applied fact mammal b figure depicts facts c chasefkex
observed c chasefkex strict subset materialisation figure
brown colored facts longer derived see wolf answer
qex w r c chasefkex hence identified spurious furthermore nullary
predicate derived hence determine kex satisfiable
relevant properties variant c chase follows
theorem let f choice function definition c chasefk
c chasefk model k cert q k cert q c chasefk
proof dataset dk contained c chasefk suffices c chasefk satisfies
rule r k distinguish following cases
r form since
c chasefk cannot exist substitution
c chasefk body r hence c chasefk satisfies r vacuously



r form pick c chasefk body r definition c chasefk
ensures head c sk r c chasefk hence c chasefk satisfies r
r form pick c chasefk body r definition
c chasefk f head c sk r sni c chasefk set atoms sni
chase sequence c chasefk satisfies r

q cert q k cert q k cert q c chasefk holds trivially otherwise
cert q k cert q c chasefk follows fact c chasefk model k


fipagoda pay go query answering datalog reasoner

combined upper bound
introduced three dierent techniques computing upper bound cert q k
compute materialisation u str k evaluate q w r u obtain set
possible answers u q q w r k c f section
compute c chase k denoted u evaluate q w r u obtain set
possible answers u q q w r k c f section
fix choice function f compute c chase k w r f denoted u evaluate q w r u obtain set possible answers u q q w r k c f section

trivially seen u q u q precise u q e u q u q u q u q
shown following example u q u q however incomparable

example consider knowledge base h consisting facts r b b b
r b b b rules b x c x x r x c x
x ys x let c freshly introduced constant x ys x let
f choice function picks disjunct bi every clause c bi bi
c chaseh dh c b b b c b b b
c chasefh dh b c b c

q x x c upper bound computed c chaseh
contains two additional answers compared computed c chasefh
q x x x x upper bound computed c chasefh
additional answers compared computed c chaseh

however tradeos considered clearly upper bound u q
convenient ease implementation point view str k constructed
bound directly computed shelf datalog reasoner without modification furthermore upper bound u q important shortcoming use
whenever derived following example
example consider choice function g picks meateater disjunction form herbivore meateater c chase kex w r g derive
meateater howler fact mammal howler disjunctive rule r
fact folivore howler rule r u derive thus see although
howler cert qex kex herbivore howler c chase kex w r g hence
howler upper bound computed contrast two
upper bounds herbivore howler materialisation str kex c chase
kex hence howler upper bound computed w r

therefore c chasefk combine u q u q compute hopefully
precise upper bound otherwise use u q combined upper bound query answer
u q q k formally defined follows


u u q
q
q
q
u

u u
q c chasefk
q
u
otherwise


fizhou cuenca grau nenov kaminski horrocks

example combined upper bound qex kex gives
uex tiger lion rabbit sheep howler hare
compare upper bound aggregated lower bound lex given example
identify gap gex tiger lion rabbit


reducing size knowledge base
whenever non empty gap gq lower upper bound e g running
example need verify whether answer gq spurious accomplishing
task fully fledged reasoner computationally expensive verifying
answer gq typically involves satisfiability test infeasible practice
large scale knowledge bases
section propose technique identifying typically small subset kq
knowledge base k sufficient verifying answers gq e cert q k
cert q kq gq essential subsets one hand
small possible hand efficiently computable requirements
conflict computing minimal sized subsets hard answering query whereas
subsets easily computed may almost large initial knowledge base
main idea behind construct datalog knowledge base whose
materialisation identifies rules facts kq knowledge base size polynomial
sizes k q include predicates arity higher k
q way subset computation fully delegated scalable datalog reasoner
hence addressing efficiency requirement key property kq ensures
contains relevant information k following rule fact
kq
occur hyperresolution proof resp gap answer
gq k rq q resp q completeness hyperresolution
guarantees excluded facts rules indeed irrelevant
overview
let us motivate main ideas behind running example since
derived u u know cert kex hence kex
satisfiable see example however still need determine whether answers
gex tiger lion rabbit combined upper bound cert qex kex e
certain answers qex
sketch construction datalog knowledge base track kex qex gex
subset kex relevant answers gex derived key property
knowledge base materialisation tracks rules facts may
participate hyperresolution proof gap answer thus encodes contents
subset kqex relevant information recorded fresh predicates constants
fresh predicate p r predicate p kex extension
materialisation track kex qex gex give us facts subset



fipagoda pay go query answering datalog reasoner

fresh constant dr rule r kex special unary predicate rel
extension materialisation track kex qex gex give us rules
subset
key step construction knowledge base invert rule r kex
set datalog rules r moving head atoms r body
replacing predicates corresponding fresh ones e g replace p p r
ii copying atoms originally body r empty head
replacing predicates corresponding fresh ones adding special atom
rel dr additional conjunct iii eliminating conjunction head r
splitting r multiple rules one head conjunct
consider first example datalog rule r kex inverted
following rules
plantr herbivore x eats x herbivorer x
r

r

plant herbivore x eats x eats x
r

plant herbivore x eats x rel dr





head plant r moved body predicate plant replaced
plantr body herbivore x eats x copied head conjunction
herbivorer x eatsr x conjoined special atom rel dr finally
head conjunction eliminated splitting rule three separate rules
rules reflect intuitive meaning freshly introduced predicates fact
plantr c holds constant c means fact plant c may participate
hyperresolution proof kex answer gap additionally herbivore b
eats b c hold b facts rule r could participate
one proof since plant c hyperresolvent facts herbivore b eats b c
rule r recorded facts herbivorer b eatsr b c rel dr thus rules
faithfully invert hyperresolution steps involving rule r
similarly disjunctive rule r inverted following two rules
herbivorer x meateaterr x mammal x mammalr x
r

r

herbivore x meateater x mammal x rel dr




case disjunctive head herbivore x meateater x r moved
body conjunction herbivorer x meateaterr x fresh predicates herbivorer
meateaterr facts herbivorer c meateaterr c hold c means
facts herbivore c meateater c may participate relevant proof kex
mammal c holds deem fact mammal c rule r relevant
situation dierent comes inverting existentially quantified rules
case longer capture relevant hyperresolution steps kex faithfully consider
rule r inverted follows
eatsr x mammal x mammalr x
r

eats x mammal x rel dr





fizhou cuenca grau nenov kaminski horrocks

case existentially quantified head eats x moved body atom
eatsr x eatsr b c holds b c hence fact may participate
relevant proof mammal b holds record r mammal b
relevant latter means fact mammalr b hyperresolvent mammal b
r atom eats b functional term may unrelated eats b c
hence irrelevant proving answer gap
addition inverting rules kex construction track kex qex gex
needs take query gap answers account encode query
eats x plant pqex x rules
pqrex x eats x plant eatsr x



pqrex x eats x plant plantr

b

add fact pqrex c c gex query dependent rules used initialise extension fresh predicates subsequently makes rules
track kex qex gex applicable
query answers gap stem upper bound consequently order
rules b applicable data track kex qex gex obtained
upper bound materialisation kex following section suffices
include facts c chase kex order ensure computed subset
contain necessary facts rules
subset definition properties
ready formally define datalog knowledge base used subset computation
well corresponding relevant subset
definition let g set possible answers q let rel fresh unary predicate
let dr fresh constant unique r k rq furthermore predicate
p k rq let p r fresh predicate arity p atom p
let r denote p r normalised rule r k rq let move r following
conjunction atoms
p r r form


r x
z




r x




r form



r x


r form

r following set rules

r move r body r rel dr move r body r

r
k



k

body r

tracking knowledge base track k q g smallest knowledge base containing
facts c chase k

ii rules r k rq r


fipagoda pay go query answering datalog reasoner

iii fact pqr g
iv fact p r q
subset k relevant q g denoted kq g smallest knowledge base
containing
rule r k track k q g rel dr
fact dk track k q g r
brevity write kq particular case g set gap answers uq lq
defined sections

note k subset kq since track k g subset track k q gq
definition point track k g track k q gq furthermore
set rules ii track k g subset track k q gq since
k r k rq finally fact p r included track k g point iii
belongs track k q gq point iv
example consider running example gex tiger lion rabbit
subset kex relevant qex gex consists rules r r r r r facts


key properties computed subsets established following theorem
theorem following properties hold
assume l k unsatisfiable k unsatisfiable
let q dierent let g non empty set possible answers q w r
k k satisfiable cert q k cert q kq g every g
proof direction follows directly monotonicity firstorder logic direction follows completeness
hyperresolution following claim establishes q non empty
g kq g contains support hyperresolution derivations clause q g
k rq


q
q g
pq g otherwise
claim derivation q g k rq support kq g
direction assume k unsatisfiable theorem
theorem u thus g exists hyperresolution
derivation k since g know support k
k unsatisfiable direction assume g
cert q k exists hyperresolution pq k rq similarly
know support kq g hence cert q kq g


fizhou cuenca grau nenov kaminski horrocks

next inductively statement follow let
derivation clause q g k rq let h split k already
established see proof theorem c chasek model h since chaseh
universal model h exists homomorphism chaseh c chasek
following properties inductively every node v
track k q g r atom v
b track k q g rel dr sk r main premise used obtain parent u v
proceed induction distance v root
base case base case v root property b follows vacuously
since v parent
q derivation empty clause v empty disjunction
property follows vacuously
otherwise v pq g definition track k q g point
iii v r track k q g hence property holds
inductive step assuming properties b hold node u
hold children v vn u let r rule k sk r
main premise relevant hyperresolution step mgu e u
n hyperresolvent sk r n
vi n easy observation composition
substitution homomorphism used later rest proof


arbitrary function free atom



lemma section chaseh n since
homomorphism chaseh c chasek c chasek
c chasek n next track k q g move r
move r p r distinguish two cases
q p r track k q g point iv

q c chasek hence pqr track k q g point iii
otherwise induction hypothesis track k q g
track k q g jr j

j

r

therefore track k q g move r body rules r satisfied
substitution hence track k q g rel dr track k q g ir
n track k q g ir n addition
induction hypothesis track k q g r
n hence shown
b hold child vi u
remains shown b imply indeed take support


fipagoda pay go query answering datalog reasoner

fact k leaf node hence property
track k q g r since fact dk definition homomorphism ensures r r definition kq g implies kq g
rule k property b track k q g rel
definition kq g ensures kq g
completes proof theorem
note claim proof theorem establishes important property
computed subsets namely proof preserving support every
hyperresolution proof relevant gap answer original knowledge base k
contained computed subset two key implications first every justification
e minimal subset k entailing gap answer contained subset
way subsets preserve formulas k relevant gap answers
formulas disregarded seen irrelevant second fully fledged reasoner
whose underpinning calculus cast framework resolution able
compute subset derivations gap answers k consequently
practice reasonable expect fully fledged reasoner uniformly display
better performance computed subsets kan expectation borne
experiments
conclude section example illustrating dataset track k q g
point definition obtained c chasek materialisation underpinning
upper bound section rather c chasefk section
example consider query q x e x knowledge base k consisting
following rules facts
x b x x

x e x

b x e x



let f function choosing b c chasefk b e
constant answer q x gap lower upper bound suppose
define track k q g definition replacing facts point
c chasefk since hold c chasefk corresponding subset
contain rule x e x essential derive e

optimisations datalog encoding
conclude section present two optimisations datalog encoding definition
exploit system pagoda
first optimisation aims reducing size computed subsets recall
key step construction tracking knowledge base track k q g invert
rules k capture hyperresolution proofs backwards fashion consider
inversion rule r running example eect inversion capture applicability hyperresolution facts mammal rabbit herbivorer rabbit
meateaterr rabbit hold include rule r subset since may proof


fizhou cuenca grau nenov kaminski horrocks

k involving step ground clause herbivore rabbit meateater rabbit
obtained resolving r mammal rabbit
note however step redundant herbivore rabbit already contained k case r may needed relevant subset capture
observation distinguishing tracking knowledge base facts c chase
k already present original dataset dk encode implied
facts instantiating fresh predicates p predicate p k running example
fact meateateri rabbit tracking knowledge base establishes meateater rabbit
present original data use atoms predicates guards
inverted rules e g rule would written follows
herbivorei x meateateri x herbivorer x

meateaterr x mammal x mammalr x

formally definition optimised given next
definition let k q g predicates p r definition predicate
p let p fresh predicate arity p redefine move r
rule r following conjunction atoms
p r r form


x
z




x




r x
z




x


r form



r x




r x


r form

r definition track k q g definition extended
addition fact p fact p c chasek dk
easy see optimisation aect correctness theorem
disjunction atoms derived via hyperresolution one atoms already
present data disjunction subsumed dispensed
second optimisation used obtain succinct encoding datalog
reasoners support equality reasoning natively rdfox already mentioned
built semantics equality predicate axiomatised within datalog however
axiomatisation lead performance issues scalability improved native
treatment equality equal objects merged single representative
whole equivalence class
axiomatisation equality significant eect tracking encoding
example replacement rules r form eq inverted following rules
r predicate p
p r x xi

xi xn

p r x xi

xi xn

p x xn xi p r x xn
p x xn xi r xi




tautology dispensed rule required
datalog reasoner native support equality need include


fipagoda pay go query answering datalog reasoner

tracking knowledge base inversion equality axioms eq eq eq
need include rules order ensure computed subset required
properties succinct encoding materialised efficiently
example consider knowledge base k consists facts r b r b
following rules
x b x c x

r x r x x x




b x x
c x x




let q x gap g lower upper bounds q easy
see rule essential derive q ensure rule fragment
kq g track instance rule

comparison magic sets
idea inverting rules recording relevant information heavily exploited
logic programming particular magic set transformation bancilhon maier sagiv
ullman technique given program query optimises materialisation process derive facts relevant query similarly
tracking encoding magic sets technique uses auxiliary predicates called magic predicates identify relevant facts technique originally developed datalog
subsequently extended handle negation failure beeri naqvi ramakrishnan shmueli tsur kemp srivastava stuckey disjunctions alviano
faber greco leone
contrast magic sets goal transformation reduce size
materialisation rather compute relevant fragment knowledge base potentially
given expressive even undecidable language reduce computation
datalog reasoning sense technique orthogonal magic sets indeed
benefits technique relevant knowledge bases containing existentially
quantified disjunctive rules k datalog query would fully
answered lower bound
furthermore worth noticing way invert datalog rules dierent
magic sets yields precise tracking assumption
tracking starts already computed materialisation see point definition
instance given already adorned rule x b x c x magic sets would
produce following rules deriving magic predicates b b
c x x

c x x b x

rules used derive fact c even cannot used
derive c aforementioned rule applicable e g b hold
c derived rules transformation contrast would yield
restrictive rules
c r x x b x ar x

c r x x b x b r x

applicable b hold materialisation


fizhou cuenca grau nenov kaminski horrocks

summarisation analysis answer dependencies
section let q input query dierent unsatisfiability query
k kq computed still need check fully fledged reasoner
satisfiability k well whether kq entails candidate answer gq
computationally expensive subsets large complex many
candidate answers verify therefore exploit summarisation techniques dolby et al
eort reduce number candidate answers
idea behind summarisation shrink data knowledge base merging
constants instantiate unary predicates since summarisation equivalent
extending knowledge base equality assertions constants summary
knowledge base entails original one monotonicity first order logic consequently exploit summarisation follows
satisfiability k remains undetermined construct summary k
check satisfiability satisfiable k thus k satisfiable
construct summary kq use fully fledged reasoner check whether
summary entailed certain answer q summary kq
discarding answers entailed
formally summarisation defined follows
definition type set unary predicates given constant c k say
c k type c type let fresh constant
uniquely associated summary function k substitution mapping
constant c k type c finally summary k k
following proposition shows summarisation exploited detect spurious
answers setting since summarisation significantly reduce data size practice
relevant subsets k kq already significantly smaller k checking
satisfiability k gap answer kq becomes feasible many cases even
though implies resorting fully fledged reasoner
proposition let summary function k satisfiability k implies
following k satisfiable ii cert q k cert q kq every cq q
example case running example constants tiger lion
type mammal therefore mapped fresh constant say tmammal uniquely
associated mammal since tmammal certain answer qex w r summary
kex determine tiger lion spurious answers

summarisation succeed pruning candidate answers g try
last step reduce calls fully fledged reasoner exploiting dependencies
remaining candidate answers answer depends answer c
spurious c
consider two tuples c constants gq suppose endomor determine calling fully fledged
phism dataset dk c

reasoner spurious answer must c longer need
call fully fledged reasoner verify c endomorphisms defined next


fipagoda pay go query answering datalog reasoner

definition let c c cn dn n tuples constants k
endomorphism c k mapping constants constants
ci di n ii p tm dk fact p tm dk
iii r k r k

relevant property endomorphisms given following proposition
proposition let c possible answers q let endomorphism c
k c cert q k implies cert q k
proof since c cert q k know k q c hyperresolution derivation
pq c k rq easy check
hyperresolution
k rq k q
hence cert q k
derivation pq
exploit idea compute dependency graph candidate answer tuples
whenever endomorphism dk exists mapping c
since
nodes edge c
computing endomorphisms hard resort practice sound greedy
approximate dependency graph describe section

implementation pagoda system
implemented system called pagoda written java
available academic license system integrates datalog reasoner
rdfox motik et al fully fledged owl reasoner hermit glimm et al
black boxes exploit combined elhor see section
implemented karma stefanoni et al
pagoda accepts input arbitrary owl dl ontologies datasets turtle format
prudhommeaux carothers cqs sparql queries interpreted
ground certain answer semantics former case pagoda sound
complete latter case however pagoda limited capabilities hermit
check entailment ground dl concept queries hence pagoda
guarantee completeness lower upper bounds match query
transformed dl concept query via internalisation see section otherwise
pagoda returns sound possibly incomplete set answers along bound
incompleteness computed answer set
architecture pagoda depicted figure box figure represents
component pagoda indicates external systems exploited within
component could principle use materialisation datalog reasoner
supports cq evaluation incremental addition facts fully fledged owl
dl reasoner supports fact entailment
pagoda uses four instances rdfox one lower bound c chase cchasef subset extractor components two instances hermit one
summary filter dependency graph components
process fully answering query divided several steps distinguish query independent steps query dependent ones see figure
loading ontology materialisation steps query independent therefore



fizhou cuenca grau nenov kaminski horrocks

cert q
heuristic planner

g gq

hermit
q gq

summary filter
hermit
q gq

endomorphism
checker

full reasoning

kq

lq

subset extractor

tracking encoder

extracting subsets

rdfox
track q gq

q gq

gq

lq
f



computing query bounds

soundanswers q
certu q

l
q
lower store
karma
rdfox

certu q

u

u
q

q
c chase

f



c chase
rdfox

rdfox



materialisation



shift

loading ontology data

profile checker

normaliser
hermit clausifier


figure architecture pagoda
counted pre processing steps computing query bounds extracting subset
full reasoning query dependent called query processing steps
next describe component following process flow pagoda
loading ontology data
pagoda uses owl api parse input ontology dataset given
separately turtle format normaliser computes set rules corresponding
axioms ontology pagodas normaliser extension hermits clausification
component glimm et al transforms axioms called dl clauses motik
et al dataset loaded directly four instances rdfox
normalisation ontology checked determine inside owl rl
elhor input ontology owl rl resp elhor rdfox resp
karma already sound complete cases pagoda simply processes


fipagoda pay go query answering datalog reasoner

ontology dataset queries relevant component otherwise pagoda uses
dedicated program shifting component enrich deterministic part ontology
additional information disjunctive rules see section resulting set rules
materialisation
three components involved step namely lower bound c chase cchasef takes input computes materialisation shown
figure ellipses lower bound component performs steps section
order compute aggregated lower bound l c chase c chasef components
compute u u upper bound materialisations described section
dedicated implementation c chase chase sequence stored rdfox
applicability existential disjunctive rules determined posing sparql
queries rdfox applying disjunctive rule computing u pagoda
uses choice function select one disjuncts discussed section choice
function try select disjuncts eventually lead contradiction
end pagoda implements following heuristics
construct standard dependency graph containing edge predicate p
q rule p occurs body q head compute
preference ordering predicates occurring disjunction according
distance dependency graph preferring furthest
exploit materialising shifting enriched rules see
section fact form p obtained materialisation p
follows knowledge base hence obtained p try
avoid choosing p disjunct p chase computation
l contains contradiction input ontology dataset unsatisfiable
pagoda reports terminates derived u computation
aborted u longer used u contains pagoda checks
satisfiability eect computes cert answer query
non empty input ontology dataset unsatisfiable pagoda reports
terminates otherwise input ontology dataset satisfiable pagoda
able answer queries
computing query bounds
given query q pagoda uses l lower bound materialisation compute lower
bound answer lq order exploits karmas implementation filtration
procedure soundanswers section clarity step shown separately circle f figure derived computing
u materialisation u q cert q u cert q u otherwise u q cert q u
case u q computed directly rdfox answer q w r relevant materialisation
extracting subsets tracking encoder component implements datalog encoding
definition optimisations described section resulting
datalog knowledge base added rules data c chase component


fizhou cuenca grau nenov kaminski horrocks

rdfox used extend c chase materialisation accordingly freshly derived facts
tracking predicates introduced tracking encoder passed
subset extractor component uses facts identify facts rules
relevant checking gap answers computes intersection relevant facts
input dataset querying instance rdfox containing
full reasoning
pagoda uses hermit verify gap answers gq u q lq hermit accepts
queries given facts dl concepts implemented standard rolling
technique transform internalisable cqs summary filter component pagoda uses
hermit filter gap answers entailed summary kq see section
remaining gap answers g gq passed endomorphism checker
exploits greedy compute incomplete dependency graph answers
g graph used heuristic planner optimise order answers
g checked hermit see section verified answers g combined
lower bound lq give cert q
implementation summarisation straightforward pagoda essentially merges
constants explicit types data

























input knowledge base k k dk two tuples b bn
output return true endomorphism b bn k found
otherwise false

foreach n
ai locally embeddable bi k return false
else ai bi
end
foreach n
check ai bi return false
end
k k return false
else return true
subroutine check b
oa c p ai c dk ia c p c ai dk
ob p bi dk ib p bi dk
foreach c sa
sb c locally embedded
empty return false
defined c
c similar constant c
check c return false
end
else c return false
end

greedy endomorphism checker



fipagoda pay go query answering datalog reasoner

next describe greedy implemented pagoda checking answer
dependencies see given tuples b bn
returns true able endomorphism false otherwise
considers constant ai tries map bi locally sense
immediate neighbourhoods ai bi considered stage formally
captured following notion local embedding
definition given k constant c let mc multiset containing occurrence
fact c dk occurrence p binary fact p c c dk
occurrence p binary fact p c c dk
given constants c k say c locally embeddable predicate
mc occurs cardinality md

check b subroutine implements greedy search looking immediate neighbours b specifically subroutine considers neighbour c picks
neighbour b c locally embedded several choices
available heuristically chooses one according jaccard similarity
multisets mc md terminates success manages
compute mapping defined constants reachable
k immediate see computed endomorphism b k thus
sound works polynomial time choices made
construction never revisited local embeddability checked efficiently

related work
conjunctive query answering ontology enriched datasets received great deal
attention recent years computational complexity thoroughly investigated
wide range kr languages number practicable proposed
literature implemented reasoning systems
computational complexity cq answering
decision associated cq answering conjunctive query entailment cqe
namely decide whether k q given input cq q possible answer
knowledge base k expressed fixed language l well known
undecidable general even q restricted atomic l language
existential rules dantsin et al
cqe knowledge bases stemming owl dl ontologies decidable
assumption query mention transitive relations rudolph glimm
decidability cqe unrestricted owl dl owl dl ontologies cqs remains
open even cases cqe decidable typically high
computational complexity cqe exptime complete expressive dls shiq
shoq glimm et al eiter lutz ortiz simkus hardness
jaccard similarity multisets defined counts
minimum number occurrences common element whereas counts
sum occurrences elements



fizhou cuenca grau nenov kaminski horrocks

exptime obtained already alci lutz well horn sroiq
underpins horn fragment owl dl ortiz rudolph simkus cqe
alc shq involve inverse roles exptime complete lutz
single exponential time obtained horn dls disallowing complex role
inclusion axioms cqe exptime complete horn shoiq underpins horn
fragment owl dl ortiz et al
given high complexity cqe recently increasing interest
lightweight dls cqe computationally easier lightweight dls
incorporated owl standard profiles motik et al cqe owl
el profile pspace complete stefanoni et al furthermore complexity
cqe drops np complex role inclusions exception transitivity
reflexivity disallowed owl el stefanoni motik latter complexity
rather benign since cqe databases already np hard finally cqe owl
ql profile np complete calvanese et al regarding data complexity
cqe conp complete non horn dls ale schaerf contrast
data complexity ptime complete horn dls encode recursion hornsroiq owl el ortiz et al stefanoni et al finally data complexity
known ac owl ql profile calvanese et al
complexity cqe well understood rule kr languages plain
datalog exptime complete combined complexity ptime complete w r data
complexity disjunctive datalog conexptime complete combined complexity
conp complete w r data complexity datalog refers family decidable kr
languages existential rules cal gottlob lukasiewicz includes
guarded cal et al sticky cal gottlob pieris acyclic cuenca grau
et al datalog extension datalog languages disjunctive rules
recently studied alviano et al b bourhis et al
finally refer ground query entailment gcqe checking whether
tuple ground answer q x x w r k kr languages allow
existentially quantified rules restriction ground answers typically makes cqe easier
definition ground answers means gcqe trivially reduced satisfiability
checking consequently gcqe decidable owl dl
practical query answering approaches
shelf dl reasoners pellet sirin et al hermit glimm
et al provide support query answering pellet supports sparql conjunctive
queries implements rolling technique contrast hermit provide
sparql api supports cqs form complex dl concepts racer
among first dl reasoners implement optimise cq answering ground
semantics haarslev hidde moller wessel finally intensive
work optimising query answering dl systems including filter refine techniques
wandelt et al ordering strategies query atoms kollia glimm data
summarisation dolby et al optimising cq answering dl reasoners complementary use optimised dl reasoner could significantly
improve performance pagoda queries require full reasoning



fipagoda pay go query answering datalog reasoner

rdf triple stores typically implement materialisation k forward chaining
reasoning answer queries evaluating resulting materialisation jena mcbride sesame broekstra kampman van harmelen
among first systems provide support rdf schema modern triple stores
owlim bishop et al oracles native inference engine wu et al
provide extended suppport ontologies rl profile additionally rdfox motik
et al supports arbitrary datalog unary binary predicates finally asp
engines dlv leone pfeifer faber eiter gottlob perri scarcello implement sound complete reasoning extensions disjunctive datalog although triple
stores exhibit appealing scalability support restricted ontology languages
however dl reasoners improving scalability triple stores complementary
advances area directly exploited pagoda
technique cq answering lightweight dls receiving increasing attention
called combined lutz et al stefanoni et al kontchakov
lutz toman wolter zakharyaschev combined dataset
first augmented facts query independent way build polynomial time
model ontology model exploited query answering two equivalent
ways lutz et al kontchakov et al query first
rewritten evaluated constructed model alternatively work
stefanoni et al lutz et al query first evaluated model
unsound answers eliminated means polynomial time filtration process
combined approaches applied logics el family lutz et al
stefanoni et al well dl lite kontchakov et al pagoda
use implementation stefanoni et al compute aggregated lower bound
cq answering horn ontologies often realised means query rewriting techniques rewriting query q w r ontology another query q captures
information necessary answer q arbitrary dataset unions cqs
datalog common target languages query rewriting query rewriting enables reuse
optimised data management system ucqs answered standard relational
databases whereas datalog queries evaluated triple store query rewriting
successfully applied owl ql ontologies rewritability ucqs
guaranteed example systems include quonto acciarri calvanese de giacomo lembo
lenzerini palmieri rosati mastro calvanese de giacomo lembo lenzerini
poggi rodriguez muro rosati ruzzi savo rapid chortaras trivela stamou prexto rosati ontop bagosi calvanese hardi komla ebri
lanti rezk rodriguez muro slusnys xiao systems
successful large scale applications however applicable owl ql
size rewriting exponential size ontology datalog query
rewriting implemented systems requiem perez urbina et al
supports extension elhor inverse roles introduction inverse
roles however leads significant jump complexity query answering elhor
np complete tractable atomic queries whereas becomes exptime complete
inverse roles introduced furthermore exptime hardness holds already unsatisfiability checking atomic queries practice restricting elhor
allows us compute datalog program linear size straightforward way skolemis

fizhou cuenca grau nenov kaminski horrocks

ing existentially quantified variables constants furthermore datalog materialisation
query independent queries without existentially quantified variables answered
directly materialisation complex queries answered filtration
finally similarly pagoda system hydrowl stoilos combines owl
rl reasoner query rewriting system fully fledged dl reasoner order
answer conjunctive queries owl knowledge base techniques hydrowl
however rather dierent pagoda hydrowl uses two dierent query answering
strategies first one repairing stoilos b query rewriting
applicable ontologies suitable repair exists second strategy exploits
query base set atomic queries hydrowl computes pre processing phase
fully answered triple store given ontology arbitrary
dataset answering query q hydrowl checks q covered query base stoilos
stamou q completely evaluated owl rl reasoner
otherwise fully fledged reasoner used answer q however computation
query base appear correct general believe accounts
apparent incompleteness hydrowl tests see section
approximate reasoning
idea transforming ontology data query obtain lower upper bound
answers already explored previous work screech system tserendorj et al
uses kaon hustadt motik sattler transform shiq ontology
exponential size disjunctive datalog program way ground answers
queries preserved subsequently screech exploit unsound incomplete techniques
transform disjunctive datalog plain datalog way screech computes
approximation answer trowl thomas et al exploits approximation
techniques transform owl ontology ontology ql profile pan
thomas approximation first computes closure input ontology
entailment owl ql axioms disregards axioms outside owl ql
related approximations owl ql proposed e g wandelt et al
console et al efficient approximation strategies owl ontologies
complementary exploited pagoda order
refine lower upper bound query answers

evaluation
evaluated query answering system pagoda range realistic benchmark ontologies datasets queries compared performance stateof art query answering systems test data systems used comparison
introduced sections respectively discussed section
experiments conducted core ghz intel xeon e gb
ram running fedora test ontologies queries available online
stoilos mentions limitation automatically extracting atomic queries
http www cs ox ac uk isg tools pagoda jair



fipagoda pay go query answering datalog reasoner

lubm n
uobm n
fly
npd
dbpedia
chembl
reactome
uniprot

axioms









rules









rules









rules









facts
n
n







table statistics test datasets
test ontologies queries
table summarises test data first two columns table indicate total
number dl axioms test ontology well total number rules
normalisation interested ontologies captured owl rl
hence cannot fully processed rdfox thus number rules containing existential
quantification disjunction especially relevant given third fourth
columns table respectively finally rightmost column lists number data
facts dataset
lubm uobm widely used reasoning benchmarks guo pan heflin
yang qiu xie pan liu ontology axioms benchmarks
manually created considered fixed whereas data synthetically generated
according parameter n determines size lubm uobm come
standard queries respectively make tests lubm challenging extended
benchmark additional queries datalog lower bound answers
guaranteed complete case standard queries
fly realistic ontology describes anatomy drosophila
currently integrated virtual fly brain tool although data rather small
compared test cases facts ontology rich existentially
quantified rules makes query answering especially challenging tested realistic
queries provided developers ontology
npd factpages ontology describing petroleum activities norwegian
continental shelf ontology comes realistic dataset containing million facts
unfortunately npd realistic queries tested atomic queries
signature ontology
dbpedia contains information wikipedia entries although dataset rather
large ontology axioms simple captured owl rl provide
challenging test used ontology matching system logmap jimenezruiz cuenca grau extend dbpedia tourism ontology containing
http www virtualflybrain org site vfb site overview htm



fizhou cuenca grau nenov kaminski horrocks

existential disjunctive rules case npd example test queries
focused evaluation atomic queries
chembl reactome uniprot realistic ontologies made publicly available european bioinformatics institute ebi linked data platform
ontologies especially interesting testing purposes one hand
ontology axioms data realistic used number applications
hand ontologies rich existentially quantified disjunctive rules
datasets extremely large furthermore ebi website provides number
example queries ontologies order test scalability datasets
well compare pagoda systems implemented data sampling
random walks leskovec faloutsos computed subsets data
increasing size used evaluation example queries correspond cqs
well atomic queries relevant signature
comparison systems
compared pagoda four ontology reasoners hermit v pellet v
trowl bgp v hydrowl v single exception trowl
systems implement sound complete standard reasoning tasks owl
dl ontologies including ontology consistency checking concept instance retrieval
additionally hermit provide support sparql queries
pointed section many systems answer queries
ontologies however systems generally designed specific fragments
owl incomplete ontologies outside fragments although trowl
incomplete owl included evaluation
one hand widely used system semantic web applications hand
similar pagoda exploits ontology approximation techniques follows
describe capabilities systems detail
hermit fully fledged owl reasoner hypertableau calculus motik
et al glimm et al hermit focuses standard reasoning tasks dls
provide sparql conjunctive query answering api capable
answering atomic queries unary predicates checking fact entailment
pellet tableau owl dl reasoner support cq answering sirin et al
pellet provides sparql api hence compute set ground
answers arbitrary conjunctive queries expressed sparql pellet capable
computing certain answers internalisable conjunctive queries rolling
technique see section
trowl system approximated reasoning accepts input arbitrary
owl dl ontology cq sparql aims computing ground answers
given query thomas et al trowl exploits technique approximates
input ontology owl ql profile provide completeness guarantees
http www ebi ac uk rdf platform



fipagoda pay go query answering datalog reasoner

correct

incomplete

unsound

error

kmeout

cannot handle








tr

tr

pe hy

pe hy

tr

pe hy

tr

tr

pe hy

pe hy

tr

pe hy

tr

pe hy

tr

pe hy

tr

pe hy

tr

pe hy









pr
ot
un


em


ac


e




bl





db
pe


ia
ch

np


fa

ct
pa
ge


le
du
p
ro
l

fl


ro
l

le
du
p


uo
bm

uo
bm

le
du
p

ro
l
lu
bm

lu
bm





figure quality answers computed system four bars ontology
represent trowl pellet hermit hydrowl respectively
hydrowl stoilos hybrid reasoning system similar spirit pagoda
see section detailed comparison hydrowl integrates triple store owlim
hermit accepts input arbitrary owl ontology conjunctive queries rules
computes ground answers query
experiments
performed three dierent experiments first experiment compared
pagoda mentioned systems respect quality
answers e number correctly answered queries performance relative
pagoda second experiment evaluated scalability considering datasets
increasing size finally third experiment evaluated eectiveness
dierent reasoning techniques implemented pagoda
comparison systems
compared pagoda systems test ontologies used
lubm uobm since already rather hard systems similarly used relatively small samples ebi platform ontologies data
chembl uniprot reactome processed majority
systems test ontology computed ground answers corresponding
test queries whenever possible used internalisation see section additionally
compute certain answers case fly test queries yield empty set
ground answers case computed certain answers fly queries
internalised set timeouts minutes answering individual query
hours answering queries given ontology
figure summarises quality answers computed reasoner bar
figure represents performance particular reasoner w r given ontology


fipellet

hermit

hydrowl

db
pe


trowl

ct
pa
ge


zhou cuenca grau nenov kaminski horrocks










pr
ot
un


em


ac


e




bl





ia
ch

fa
np


le
du
p
ro
l

fl


ro
l

le
du
p


uo
bm

le
du
p

ro
l

uo
bm



lu
bm

lu
bm





figure performance comparison systems bar depicts total time
answer test queries relevant ontology comparison pagoda
set test queries use green indicate percentage queries reasoner
computed correct answers correctness determined majority voting
blue resp purple indicate percentage queries reasoner
incomplete resp unsound red orange grey indicate respectively percentage
queries reasoner reported exception execution accept
input query exceeded timeout criterion correctness pagoda
able correctly compute answers every query test ontology within given
timeouts consequently performance pagoda represented figure
figure summarises performance system relative pagoda
case considered queries relevant system yields answer even
computed answer unsound incomplete ideal chose
consider queries rather queries relevant system
yields correct answer resulting time measurement obviously closer
time would required correctly answer queries ii correctness
relative gold standard query answers ontology
reasoner corresponding bar shows logarithmic scale resp
total time required pagoda resp compared system compute answers
queries consideration missing bar indicates comparison system failed
answer queries within given timeout please note two dierent bars
ontology comparable may refer dierent sets queries bar
needs considered isolation
draw following conclusions experiments
trowl faster pagoda lubm rolling uobm rolling
fly rolling incomplete lubm queries
uobm queries chembl trowl exceeds timeout performing
satisfiability check remaining ontologies pagoda efficient spite
fact trowl incomplete queries even unsound several
uniprot queries


fipagoda pay go query answering datalog reasoner

pellet one robust systems evaluation although times
fly ontology succeeds computing answers remaining cases
observe however cases pellet significantly slower pagoda
sometimes two orders magnitude
hermit answer queries one distinguished variable could
evaluate atomic binary queries see hermit exceeds timeout many
cases tests hermit succeeds significantly slower pagoda
although hydrowl theoretically sound complete
found incomplete tests exceeded timeout queries
three ontologies ran memory queries another two
ontologies reported exception chembl remaining cases
significantly slower pagoda
scalability tests
tested scalability pagoda lubm uobm ontologies ebi
linked data platform lubm used datasets increasing size step n
uobm used increasingly large datasets step n
considered smaller step n hard queries finally case ebis datasets
implemented data sampling random walks computed subsets
data increasing sizes original dataset steps
used test queries described section ontologies
section computed ground answers whenever possible used internalisation
additionally compute certain answers test ontology measured following
pre processing time includes pre processing steps section well
satisfiability checking e query processing boolean unsatisfiability query
query processing time time perform query processing steps
query given ontology organise test queries following three
groups depending techniques exploited pagoda compute answers
g queries lower upper bounds coincide
g queries non empty gap summarisation able filter
remaining candidate answers
g queries fully fledged reasoner called ontology subset
least one test datasets
scalability test set timeout hours answering queries hours
individual query lubm uobm increased size dataset
pagoda exceeded timeout ontologies pagoda able answer
queries within timeout even largest dataset
pellet compared system found sound complete test
ontologies queries conducted scalability tests scalability
pellet however limited already failed lubm uobm well chembl




g



thousands seconds

thousands seconds

zhou cuenca grau nenov kaminski horrocks





q

q




















































b lubm query processing



g



thousands seconds

thousands seconds

lubm pre processing







g

q




























c uobm pre processing











uobm query processing

figure scalability tests benchmarks
uniprot dataset pellet managed process least two data
samples reactome succeeded samples smaller case
reactome discussed detail later
summarised figures ontology plot time
size input dataset query processing distinguish dierent groups
queries discussed pagoda behaves relatively uniformly queries g
g plot average time per query groups contrast pagodas
behaviour queries g quite variable plot time individual query
lubm n shown figure pre processing fast times appear scale linearly increasing dataset size lubm queries belong g g
latter group containing two queries figure b illustrates average query processing
time queries g never exceeds seconds well time
two queries g q q reaches seconds lubm
accounted hermit
uobm n shown figure c pre processing times significantly higher
lubm reflecting increased complexity ontology still appear scale linearly
dataset size lubm test queries contained g
processing times never exceeds seconds uobm uobm found one
query g processing times query somewhat longer g
reached uobm finally found one query q due uobms




g



seconds

thousands seconds

pagoda pay go query answering datalog reasoner























chembl pre processing
pellet

g



seconds

hundreds seconds

pagoda

b chembl query processing



g

q

pellet q




































c reactome pre processing
unsa sable

g



seconds

thousands seconds

satsiable

reactome query processing



g




















e uniprot pre processing









f uniprot query processing

figure scalability tests ebi linked data platform
randomised data generation dierent groups dierent datasets uobm
uobm uobm g hermit called relevant subsets
fully answer query uobm g hermit called
summary relevant subset remaining cases shown figure
g lower upper bounds coincided query timed uobm
due time taken hermit reason relevant subset shown
times remaining g g queries uobm
chembl shown figure pre processing times significant manageable
appear scale linearly dataset size test queries contained g



fizhou cuenca grau nenov kaminski horrocks

total
l u
l u
l u
l u

lubm







uobm







fly

npd

dbpedia



















chembl







reactome







uniprot







table queries answered dierent bounds
figure b illustrates average processing times queries less
datasets increases smoothly dataset size
reactome shown figure c pre processing times appear scale quite
smoothly groups g g contained one query remaining queries
belonging g query processing times shown figure average query processing time queries g never exceeded seconds average processing times g
queries appeared grow linearly size datasets average time never exceeded
seconds finally seen g query q much challenging
could still answered less seconds even largest dataset
already mentioned tested scalability pellet reactome pellet
able process samples size pre processing time pellet
datasets comparable pagoda shown figure c average queryprocessing times queries g g slightly higher pagoda
contrast times query q significantly higher reactome
respectively see figure processing times q pagoda
however grow smoothly thanks eectiveness subset extraction technique
able keep input fully fledged reasoner small even largest datasets
uniprot contrast cases uniprot whole unsatisfiable sampling
technique however produce satisfiable subset figure e illustrates pre processing
times seen drop abruptly unsatisfiable samples larger
unsatisfiability efficiently detected lower bound figure shows
time detect inconsistency even less
time dominated loading time performance varies run run query
processing times considered satisfiable samples see figure f
queries g four g observe average times queries
appear scale linearly data size groups
effectiveness implemented techniques
evaluated eectiveness reasoning techniques implemented
pagoda comparing numbers test queries fully answered
relevant technique
query bounds sections described dierent techniques computing lower
upper bound query answers table illustrates eectiveness bounds


fipagoda pay go query answering datalog reasoner

facts
rules

lubm



uobm



fly



npd



dbpedia



reactome



uniprot



table size largest subsets given percentage input rules facts
terms number queries bounds coincided test ontologies
table refer lower bound described section l aggregated
lower bound described section l similarly refer three upper bound
computation techniques discussed section u u u combined upper
bound u observe following experiments
basic lower upper bounds suffice answer queries many
test ontologies particular l u matched queries
lubm npd dbpedia
chembl uniprot
aggregated lower bound l eective case fly basic
bounds match query useful lubm yielding matching
bounds queries
refined treatment existential rules described section yields
upper bound u especially eective uobm reactome many
existentially quantified rules already satisfied lower bound materialisation
finally refined treatment disjunctive rules section yields combined upper bound u instrumental obtaining additional matching bounds
non horn ontologies could answer additional queries uobm
npd dbpedia chembl reactome uniprot
overall obtained matching bounds queries test ontologies
could answer queries chembl fly dbpedia
reactome lubm uobm uniprot npd
subset extraction table shows dataset maximum percentage facts
rules included relevant subset test queries non matching
bounds observe subset extraction eective cases terms facts
rules uniprot dbpedia reduction data size especially dramatic
interesting observe large reduction number rules fly
rather complex ontology finally subset extraction least eective npd
uobm even cases reduction almost one order magnitude
size ontology dataset
turn attention summarisation dependency analysis eectiveness
techniques measured number hard calls hermit required
fully answer query call hermit considered hard knowledge base
passed hermit summary first row table shows number gap


fizhou cuenca grau nenov kaminski horrocks

l u
sum
dep

lubm









uobm









fly




dbpedia




npd




reactome







uniprot




table number hard calls hermit fully answer query
answers query l u bounds match without optimisation
would call hermit number times fully answer query row
resp row shows number hard calls hermit applying summarisation resp
summarisation plus dependency analysis mentioned respectively
queries non matching bounds npd uniprot however
groups summarisation dependency analysis identical eects queries
group present one representative query ontology
summarisation already discussed summarisation enables pagoda fully answer
number test queries non empty gaps instrumental fully answering one
query uobm dbpedia reactome well queries npd
queries uniprot even cases summarisation suffice fully answer
query eective reducing size gap instance one queries
uobm obtained gap answers ruled summarisation
dependency analysis lubm two queries gap answers
answers respectively cases answers merged single group
hence single call hermit sufficed complete computation similarly uobm
single call hermit sufficient even though three queries gap
involved large number candidate answers fly answers remaining
verified summarisation hard calls hermit required finally
case reactome one query gap answers dependency analysis reduced
number calls hermit

conclusions
investigated novel pay go conjunctive query
answering combines datalog reasoner fully fledged reasoner key feature
delegates bulk computation datalog reasoner
resorts fully fledged reasoner necessary fully answer query
reasoning techniques proposed general applicable
wide range knowledge representation languages main goal practice however
realise highly scalable robust query answering system
owl dl ontologies called pagoda extensive evaluation
confirmed feasibility practice system pagoda
significantly ourperforms state art reasoning systems terms robustness
scalability particular experiments ontologies ebi linked data
platform shown pagoda capable fully answering queries highly complex
expressive ontologies realistic datasets containing hundreds millions facts


fipagoda pay go query answering datalog reasoner

acknowledgments
extended version conference publications zhou nenov cuenca grau
horrocks zhou nenov grau horrocks work supported
royal society royal society fellowship epsrc projects
score masi dbonto well eu fp project optique

references
abiteboul hull r vianu v eds foundations databases logical
level addison wesley longman publishing co inc boston usa
acciarri calvanese de giacomo g lembo lenzerini palmieri
rosati r quonto querying ontologies veloso kambhampati
eds aaai proceedings twentieth national conference artificial intelligence seventeenth innovative applications artificial intelligence
conference july pittsburgh pennsylvania usa pp aaai
press mit press
afrati f n cosmadakis yannakakis datalog vs polynomial time
j comput syst sci
alviano faber w greco g leone n magic sets disjunctive datalog
programs artificial intelligence
alviano faber w leone n manna b disjunctive datalog existential quantifiers semantics decidability complexity issues theory practice
logic programming
baader f brandt lutz c pushing el envelope ijcai
proceedings nineteenth international joint conference artificial intelligence
edinburgh scotland uk july august pp
baader f calvanese mcguinness l nardi patel schneider p f
description logic handbook theory implementation applications cambridge univ press
bagosi calvanese hardi j komla ebri lanti rezk rodriguez muro
slusnys xiao g ontop framework ontology data access zhao du j wang h wang p ji pan j z eds csws
proceedings semantic web web science th chinese conference wuhan
china august revised selected papers vol communications
computer information science pp springer
bancilhon f maier sagiv ullman j magic sets strange
ways implement logic programs silberschatz ed proceedings fifth
acm sigact sigmod symposium principles database systems march cambridge massachusetts usa pp acm
beeri c naqvi ramakrishnan r shmueli tsur sets negation
logic database language ldl vardi ed proceedings sixth


fizhou cuenca grau nenov kaminski horrocks

acm sigact sigmod sigart symposium principles database systems
march san diego california usa pp acm
bishop b kiryakov ognyano peikov tashev z velkov r
owlim family scalable semantic repositories semantic web
bourhis p morak pieris impact disjunction query answering guarded existential rules ijcai proceedings rd
international joint conference artificial intelligence beijing china august
pp aaai press
broekstra j kampman van harmelen f sesame generic architecture
storing querying rdf rdf schema horrocks hendler j
eds iswc proceedings semantic web first international semantic
web conference sardinia italy june proceedings vol lecture
notes computer science pp springer
bry f eisinger n eiter furche gottlob g ley c linse b pichler r wei
f foundations rule query answering antoniou g amann u
baroglio c decker henze n patranjan p tolksdorf r eds reasoning
web vol lecture notes computer science pp springer
cal gottlob g kifer taming infinite chase query answering
expressive relational constraints journal artificial intelligence

cal gottlob g lukasiewicz general datalog framework
tractable query answering ontologies j web sem
cal gottlob g lukasiewicz marnette b pieris datalog
family logical knowledge representation query languages applications
lics proceedings th annual ieee symposium logic computer
science july edinburgh united kingdom pp ieee computer
society
cal gottlob g pieris expressive languages ontological query
answering burgard w roth eds aaai proceedings twentyfifth aaai conference artificial intelligence san francisco california usa
august vol pp aaai press
calvanese de giacomo g lembo lenzerini poggi rodriguez muro
rosati r ruzzi savo f mastro system ontology
data access semantic web
calvanese de giacomo g lembo lenzerini rosati r tractable
reasoning efficient query answering description logics dl lite family
journal automated reasoning
chortaras trivela stamou g b optimized query rewriting owl
ql bjrner n sofronie stokkermans v eds cade proceedings
rd international conference automated deduction wroclaw poland july
august vol lecture notes computer science pp
springer


fipagoda pay go query answering datalog reasoner

console mora j rosati r santarelli v savo f eective computation
maximal sound approximations description logic ontologies iswc
proceedings semantic web th international semantic web conference
riva del garda italy october proceedings part ii pp
cuenca grau b horrocks krotzsch kupke c magka motik b wang z
acyclicity notions existential rules application query answering
ontologies journal artificial intelligence
cuenca grau b horrocks motik b parsia b patel schneider p f sattler u
owl next step owl journal web semantics
cuenca grau b motik b stoilos g horrocks completeness guarantees
incomplete ontology reasoners theory practice journal artificial intelligence

dantsin e eiter gottlob g voronkov complexity expressive
power logic programming acm computing surveys
dolby j fokoue kalyanpur kershenbaum schonberg e srinivas k
l scalable semantic retrieval summarization refinement
aaai proceedings twenty second aaai conference artificial intelligence july vancouver british columbia canada pp aaai
press
dolby j fokoue kalyanpur schonberg e srinivas k scalable highly
expressive reasoner sher journal web semantics
eiter fink tompits h woltran simplifying logic programs
uniform strong equivalence lpnmr proceedings logic programming
nonmonotonic reasoning th international conference fort lauderdale fl
usa january proceedings pp
eiter lutz c ortiz simkus query answering description logics
transitive roles boutilier c ed ijcai proceedings st
international joint conference artificial intelligence pasadena california usa
july pp
eiter ortiz simkus conjunctive query answering description
logic sh knots journal computer system sciences

erling mikhailov virtuoso rdf support native rdbms virgilio
r giunchiglia f tanca l eds semantic web information management
model perspective pp springer
glimm b horrocks motik b stoilos g wang z hermit owl
reasoner journal automated reasoning
glimm b lutz c horrocks sattler u conjunctive query answering
description logic shiq journal artificial intelligence

grosof b n horrocks volz r decker description logic programs
combining logic programs description logic hencsey g white b chen
r kovacs l lawrence eds www proceedings twelfth


fizhou cuenca grau nenov kaminski horrocks

international world wide web conference budapest hungary may
pp acm
guo pan z heflin j lubm benchmark owl knowledge base
systems journal web semantics
haarslev v hidde k moller r wessel racerpro knowledge representation reasoning system semantic web
horrocks kutz sattler u even irresistible sroiq kr
proceedings tenth international conference principles knowledge
representation reasoning lake district united kingdom june
pp
horrocks patel schneider p f van harmelen f shiq rdf
owl making web ontology language journal web semantics

horrocks tessaris conjunctive query language description logic
aboxes kautz h porter b w eds aaai iaai proceedings
seventeenth national conference artificial intelligence twelfth conference
innovative applications artificial intelligence july august austin
texas usa pp aaai press mit press
hustadt u motik b sattler u reasoning description logics reduction
disjunctive datalog journal automated reasoning
jimenez ruiz e cuenca grau b logmap logic scalable ontology
matching aroyo l welty c alani h taylor j bernstein kagal l noy
n f blomqvist e eds iswc semantic web th international
semantic web conference bonn germany october proceedings part
vol lecture notes computer science pp springer
kemp b srivastava stuckey p j bottom evaluation query
optimization well founded theoretical computer science

kollia glimm b optimizing sparql query answering owl ontologies
journal artificial intelligence
kontchakov r lutz c toman wolter f zakharyaschev combined ontology data access walsh ed ijcai
proceedings nd international joint conference artificial intelligence
barcelona catalonia spain july pp ijcai aaai
leone n pfeifer g faber w eiter gottlob g perri scarcello f
dlv system knowledge representation reasoning acm transactions
computational logic
leskovec j faloutsos c sampling large graphs kdd proceedings
twelfth acm sigkdd international conference knowledge discovery
data mining philadelphia pa usa august pp



fipagoda pay go query answering datalog reasoner

lutz c complexity conjunctive query answering expressive description logics armando baumgartner p dowek g eds ijcar
proceedings th international joint conference automated reasoning sydney
australia august vol lecture notes computer science pp
springer
lutz c seylan toman wolter f combined obda
taming role hierarchies filters alani h kagal l fokoue groth p
biemann c parreira j x aroyo l noy n f welty c janowicz k eds
iswc proceedings semantic web th international semantic web
conference sydney nsw australia october proceedings part vol
lecture notes computer science pp springer
lutz c toman wolter f conjunctive query answering description logic el relational database system boutilier c ed ijcai
proceedings st international joint conference artificial intelligence
pasadena california usa july pp
l yang qiu z xie g pan liu towards complete owl
ontology benchmark sure domingue j eds eswc semantic
web applications rd european semantic web conference budva
montenegro june proceedings vol lecture notes computer
science pp springer
manola f miller e rdf primer w c recommendation available
http www w org tr rdf primer
marnette b generalized schema mappings termination tractability
pods proceedings twenty eigth acm sigmod sigact sigart
symposium principles database systems june july providence
rhode island usa pp
mcbride b jena implementing rdf model syntax specification
semweb proceedings second international workshop semantic
web
moller r neuenstadt c ozcep l wandelt advances accessing
big data expressive ontologies timm j thimm eds ki
proceedings advances artificial intelligence th annual german conference
ai koblenz germany september vol lecture notes
computer science pp springer
motik b cuenca grau b horrocks wu z fokoue lutz c owl
web ontology language profiles second edition w c recommendation available
http www w org tr owl profiles
motik b nenov piro r horrocks olteanu parallel materialisation
datalog programs centralised main memory rdf systems brodley c e
stone p eds aaai proceedings twenty eighth aaai conference
artificial intelligence july quebec city quebec canada pp
aaai press


fizhou cuenca grau nenov kaminski horrocks

motik b shearer r horrocks hypertableau reasoning description logics
journal artificial intelligence
ortiz rudolph simkus query answering horn fragments
description logics shoiq sroiq ijcai proceedings nd
international joint conference artificial intelligence barcelona catalonia spain
july pp
pan j z thomas e approximating owl dl ontologies aaai
proceedings twenty second aaai conference artificial intelligence july
vancouver british columbia canada pp
perez urbina h motik b horrocks tractable query answering rewriting
description logic constraints journal applied logic
prudhommeaux e carothers g rdf turtle w c recommendation
available http www w org tr turtle
robinson j voronkov eds handbook automated reasoning
volumes elsevier mit press
rodriguez muro calvanese high performance query answering
dl lite ontologies brewka g eiter mcilraith eds kr
proceedings principles knowledge representation reasoning thirteenth
international conference rome italy june pp aaai press
rosati r prexto query rewriting extensional constraints dl lite
simperl e cimiano p polleres corcho presutti v eds eswc
proceedings semantic web applications th extended
semantic web conference heraklion crete greece may vol
lecture notes computer science pp springer
rudolph glimm b nominals inverses counting conjunctive queries
infinity friend journal artificial intelligence
schaerf complexity instance checking concept languages
existential quantification komorowski h j ras z w eds ismis
proceedings methodologies intelligent systems th international symposium trondheim norway june vol lecture notes computer
science pp springer
sirin e parsia b cuenca grau b kalyanpur katz pellet practical
owl dl reasoner journal web semantics
staab studer r eds handbook ontologies international handbooks
information systems springer
stefanoni g motik b answering conjunctive queries el knowledge bases
transitive reflexive roles bonet b koenig eds aaai
proceedings th aaai conference artificial intelligence austin tx usa
aaai press appear
stefanoni g motik b horrocks introducing nominals combined
query answering approaches el aaai proceedings twenty seventh
aaai conference artificial intelligence pp


fipagoda pay go query answering datalog reasoner

stefanoni g motik b krotzsch rudolph complexity answering
conjunctive navigational queries owl el knowledge bases journal
artificial intelligence
stoilos g hydrowl hybrid query answering system owl dl ontologies
rr proceedings web reasoning rule systems th international
conference athens greece september pp
stoilos g b ontology data access rewriting owl rl systems
repairing presutti v damato c gandon f daquin staab tordai
eds semantic web trends challenges th international conference
eswc anissaras crete greece may proceedings vol
lecture notes computer science pp springer
stoilos g stamou g b hybrid query answering owl ontologies
schaub friedrich g osullivan b eds ecai st european conference artificial intelligence august prague czech republic including prestigious applications intelligent systems pais vol frontiers
artificial intelligence applications pp ios press
thomas e pan j z ren trowl tractable owl reasoning infrastructure
eswc proceedings semantic web applications th
extended semantic web conference heraklion crete greece may june
part ii pp
tserendorj rudolph krotzsch hitzler p approximate owlreasoning screech calvanese lausen g eds rr proceedings
web reasoning rule systems second international conference karlsruhe
germany october november vol lecture notes computer
science pp springer
w c sparql working group sparql overview w c recommendation
available http www w org tr sparql overview
wandelt moller r wessel towards scalable instance retrieval
ontologies international journal software informatics
wu z eadon g das chong e kolovski v annamalai srinivasan j
implementing inference engine rdfs owl constructs user defined
rules oracle alonso g blakeley j chen l p eds icde
proceedings th international conference data engineering april
cancun mexico pp ieee
zhou nenov cuenca grau b horrocks pay go owl query
answering triple store proceedings twenty eighth aaai conference
artificial intelligence
zhou nenov grau b c horrocks complete query answering
horn ontologies triple store semantic web iswc th
international semantic web conference sydney nsw australia october
proceedings part pp




