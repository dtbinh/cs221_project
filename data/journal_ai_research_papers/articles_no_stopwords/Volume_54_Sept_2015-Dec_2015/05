journal artificial intelligence

submitted published

expressiveness two valued semantics
abstract dialectical frameworks
hannes strass

strass informatik uni leipzig de

computer science institute leipzig university
augustusplatz leipzig germany

abstract
analyse expressiveness brewka woltrans abstract dialectical frameworks
two valued semantics expressiveness mean ability encode desired set
two valued interpretations given propositional vocabulary atoms
compare adfs expressiveness two valued semantics
abstract argumentation frameworks normal logic programs propositional logic
computational complexity two valued model existence
languages almost languages form neat hierarchy
respect expressiveness demonstrate hierarchy collapses
allow introduce linear number vocabulary elements finally analyse
compare representational succinctness adfs two valued model semantics
capability represent two valued interpretation sets space efficient manner

introduction
often different knowledge representation languages conceptually similar partially overlapping intended application areas faced
application choice several possible knowledge representation languages
could used application one first axes along compare different
formalisms comes mind computational complexity language computationally expensive considering sizes typically encountered practice
clear criterion exclusion available language candidates
computational complexity expressiveness computationalcomplexity sense kinds formalism solve
need fine grained notion expressiveness use notion
study expressiveness abstract dialectical frameworks adfs brewka woltran
brewka ellmauthaler strass wallner woltran recent generalisation
abstract argumentation frameworks afs dung
argumentation frameworks de facto standard formalism abstract argumentation field studies abstract arguments relate terms directed
conflicts attacks conflicts resolved without looking
arguments afs popular well studied noted many times
literature expressive capabilities somewhat limited recently
made technically precise dunne dvorak linsbichler woltran
basically showed introducing purely technical arguments sometimes inevitable afs representation purposes however due nature
dialectical meaning technical arguments might ironically debatable
c

ai access foundation rights reserved

fistrass

surprisingly quite number generalisations afs proposed
overview refer brewka polberg woltran one general af
alternatives aforementioned abstract dialectical frameworks adfs emerged
formalism arguments called statements abstract links
arguments afs links necessarily attacks adfs statement
associated acceptance condition boolean function parent statements
specifies exactly statement accepted way acceptance
conditions ultimately express meaning links adf even restricted subclass
bipolar adfs intuitively links supporting attacking proper
generalisation afs quite expressive one shall see
adfs could called lovechild afs logic programs since combine
intuitions semantics dung style abstract argumentation well logic programming brewka et al strass alviano faber abstract
level adfs intended function argumentation middleware sufficiently expressive target formalism translations concrete application formalisms
part adf success story mention reconstruction carneades model
argument brewka gordon instantiation simple defeasible theories
adfs strass recent applications adfs legal reasoning reasoning
cases al abdulkarim atkinson bench capon
abstract dialectical frameworks knowledge representation
formalisms since used represent knowledge arguments relationships
arguments employ view analyse representational capabilities
adfs due roots afs logic programs compare representational capabilities formalisms setting initial study restrict
looking two valued semantics specifically adf stable model semantics corresponds af stable extension semantics supported stable
model semantics logic programs add propositional logic well known reference point analysing precise formalisms additionally makes sense us
computational complexity respective model existence
one exception
afs deciding stable extension existence np complete dimopoulos nebel
toni
normal logic programs deciding existence supported stable npcomplete bidoit froidevaux marek truszczynski
adfs deciding existence supported np complete brewka
et al deciding existence stable p complete general
adfs brewka et al np complete subclass bipolar adfs strass
wallner
propositional satisfiability np complete
view almost identical complexities use alternative measure
expressiveness knowledge representation formalism f given set two valued
interpretations knowledge base f exact model set notion


fiexpressiveness two valued semantics adfs

lends straightforwardly compare different formalisms gogic kautz papadimitriou
selman
formalism f least expressive formalism f every
knowledge base f equivalent knowledge base f
expressiveness understood terms realisability kinds model sets
formalism express model theory known definability
easy see propositional logic express set two valued interpretations
universally expressive easy less easy see normal logic programs
supported model semantics normal logic programs stable model semantics
clear model sets expressed since two different stable
incomparable respect subset relation study
expressiveness properties mentioned formalisms different semantics
turns languages form less strict expressiveness hierarchy afs
bottom adfs lps stable semantics higher adfs lps
supported model semantics top together propositional logic
language f least expressive language f mainly
use two different techniques best case use syntactic compact faithful
translation knowledge bases f f compact means translation
change vocabulary introduce atoms faithful means
translation exactly preserves knowledge base respective semantics
two languages second best case assume knowledge base f
given form set x desired construct semantic realisation x
f knowledge base f model set precisely x language
f strictly expressive f additionally present knowledge base kb
f prove f cannot express model set kb
analysing expressiveness argumentation formalisms quite recent strand
work ascent attributed dunne et al studied realisability
argumentation frameworks allowing introduce arguments long
never accepted likewise dyrkolbotn analysed af realisability projection
allowing introduce arguments three valued semantics baumann dvorak linsbichler strass woltran studied expressiveness subclass compact
afs argument accepted least finally recently puhrer
analysed realisability three valued semantics adfs previous preliminary works include brewka dunne woltran translated adfs
afs adf model af stable extension semantics however translation
introduces additional arguments therefore compact strass
studied syntactic intertranslatability adfs lps look
expressiveness realisability
gain achieved analysis increased
clarity fundamental properties knowledge representation languages
formalisms express actually several applications dunne
et al remarked major application constructing knowledge bases aim
however stable model semantics becomes universally expressive allow nested expressions
form p rule bodies lifschitz tang turner lifschitz razborov



fistrass

encoding certain model set necessary prerequisite must known
intended model set realisable first place example recent
revising argumentation frameworks coste marquis konieczny mailly marquis
authors avoid assuming produce collection afs whose model sets
union produce desired model set work dunne et al showed
indeed necessary case afs stable extension semantics work shows
adfs model semantics single knowledge base adf enough
realise given model set assume intended model set
given form propositional formula size realising adf
linear size formula one example several occasions
consider sizes realisations uncommon logic ai darwiche
marquis lifschitz razborov french van der hoek iliev kooi shen
zhao indeed representation size fundamental practical aspect knowledge
representation languages universal expressiveness little use model sets express
require exponential size knowledge bases even best case
course fact languages study computational complexity
means principle exist polynomial intertranslations respective decision
intertranslations may involve introduction polynomial number
atoms theory increase n atoms nk atoms k
consequence practice profound impact number n atoms directly
influences search space implementation potentially cover step
n
k n
k
k
n n n n
amounts exponential increase search space size able realise model set
compactly without atoms therefore attests formalism f certain basic
kind efficiency property sense f realisation model set
unnecessarily enlarge search space operating
might seem restricting assumption view formalisms sets f knowledge bases kb f associated two valued semantics however language
representation model universal sense another way expressing languages sets words n element vocabulary binary word w x x xn length n encoded set mw ai xi
example vocabulary binary word length corresponds set consequently set ln words length n
represented set xln subsets xln mw w ln
example vocabulary word set l represented model
set xl conversely sequence xn n sets

xn uniquely determines language l n ln n n
ln wm xn wm x x xn n xi
ai xi ai
use language refer object level
languages formalism refers meta level languages propositional logic
argumentation frameworks abstract dialectical frameworks logic programs
formally syntax adfs defined via boolean functions however interested representations adfs fix representation adfs via fixing


fiexpressiveness two valued semantics adfs

representation boolean functions choose use unrestricted propositional formulas customary literature brewka woltran brewka et al
polberg et al polberg gaggl strass linsbichler strass
wallner puhrer gaggl rudolph strass exceptions custom
works brewka et al use boolean circuits one strass
used characteristic used representation equivalent
representing formulas disjunctive normal form subclass bipolar adfs
yet uniform representation exists another question address
propositional formulas vocabulary mean formulas boolean
basis trees whose leaves sinks atoms logical constants
true false internal nodes unary binary make
occasional use boolean circuits trees replaced directed acyclic
graphs particular allow unbounded fan reusing sub circuits usual
depth formula circuit length longest path root leaf
sink figure shows formula circuit examples depth



p



















q

p

q

p

q

figure representing p q q p formula tree left circuit right

analysing expressive power representation size boolean circuits established sub field computational complexity arora barak led
number language classes whose members recognised boolean circuits satisfying

certain restrictions need class ac contains languages l n ln
exist k n n n exists boolean circuit cn
depth size nk cn exactly express ln
words every language l ac recognised family polynomial size boolean
circuits fixed maximal depth independent word length
proceeds follows first define notion expressiveness succinctness formally introduce formalisms study reviewing several
intertranslatability languages step wise obtain lead
expressiveness hierarchy times looking representational efficiency
finally allowing linearly expand vocabulary leads collapse
hierarchy concludes discussion possible future work

precise n n cn exactly xln turn expresses ln



fistrass

background
presume finite set atoms statements arguments vocabulary knowledge
representation formalism interpreted set f two valued semantics

f mapping f assigns sets two valued knowledge bases
kb f implicit strictly speaking two valued interpretation mapping
set atoms two truth values true false technical ease
represent two valued interpretations sets containing atoms true
write f kb kb f intuitively f set interpretation sets
formalism f express knowledge base whatsoever example f pl

propositional logic mod usual model semantics pl since
obviously set realisable propositional logic leads us compare
different pairs languages semantics respect semantics range
concept formalism concentrates semantics decidedly remains abstract
first define expressiveness relation among formalisms
definition let finite vocabulary f f formalisms interpreted


f f two valued semantics define
f e f

iff

f f

intuitively formalism f semantics least expressive formalism f
semantics model sets f express contained
f produce semantics clear context
omit holds particular argumentation frameworks propositional logic
look single semantics usual
f e f iff f e f f e f
f
e f iff f e f f e f
relation e reflexive transitive definition necessarily antisymmetric
might different formalisms f f equally expressive f
e f
next introduce succinctness relation defined gogic et al
definition let finite vocabulary let f f formalisms interpreted size measures kk kk two valued semantics
respectively define f f k n kb f
kb f f kb f kb kb kkb k kkb kk
intuitively f f means f least succinct f
put another way f f hold knowledge base f equivalent
counterpart f must equivalent counterpart polynomially larger
note succinctness talks model sets express
meaningful comparing languages equally expressive whenever
set x simply define x
mod x x

w

x





v





v

aa

clearly

fiexpressiveness two valued semantics adfs

f f usual define f f iff f f f f f
f
iff f f f f relation reflexive necessarily antisymmetric
transitive
final general definition formalisms polynomially expressing languages
already make use previously introduced bijection interpretations
binary words use term languages synonymously refer

definition formalism f polynomially express language l n ln


semantics f k n positive n n
knowledge base kbn f formalism kbn ln kkbn k nk
next introduce specific object level languages use first
language parity contains odd element subsets vocabulary formally
n
parityn n

explained parity nn n parityn textbook parity
expressible polynomial size propositional formulas jukna example
define parity
n set

parity
parity
parity

n
n
n
parity
parity

n
n


n n n n construction yields formula logarithmic depth
therefore polynomial size textbook although nearly easy
see parity cannot expressed depth bounded polynomial size circuits
parity
ac jukna
another important class threshold languages defined n k n n
k n
thresholdn k k
thresholdn k contains
interpretations n atoms least k atoms
true special case k n leads majority languages
majorityn thresholdn n e


contain interpretations least half atoms vocabulary true
next introduce particular knowledge representation languages study
make use vocabulary considered
parametric given vocabulary
logic programs
vocabulary define accordingly set literals
normal logic program rule form b
b set b called body rule abbreviate b b


fistrass

b b logic program lp p set logic program rules
interpretation satisfies body b rule b p iff b
b supported model p iff b p satisfies b
logic program p denote set supported su p intuition
behind semantics atoms true model
kind support
however support might cyclic self support instance logic program
two supported latter undesired many
application domains alternative gelfond lifschitz proposed stable
model semantics allow self support set stable model p iff
least supported model p p obtained p eliminating
rule whose body contains literal deleting literals
form bodies remaining rules gelfond lifschitz
write st p set stable p follows definition st p
antichain st p
p size measure define
ka bk b rules kp k rp krk programs
example consider vocabulary b c logic program
p b b c su p c b st p c
argumentation frameworks
dung introduced argumentation frameworks pairs f r set
abstract arguments r relation attack arguments
purpose semantics argumentation frameworks determine sets arguments called
extensions acceptable according standards given extension
arguments considered accepted attacked
argument considered rejected others neither status
undecided interested called stable extensions sets arguments
attack attack arguments set stable extensions
argument accepted rejected definition thus semantics two valued
formally set arguments conflict free iff b b r
set stable extension r iff conflict free
argument b b r af f denote set stable extensions
st f follows definition stable extension set st f
antichain size argumentation framework f r kf k r
example af f b c b b b c visualised
c set stable extensions st f c b
b
directed graph
abstract dialectical frameworks
abstract dialectical framework tuple l c set statements
representing positions one take take debate l set links
representing dependencies positions c ca aa collection total
functions ca par f one statement function ca called
acceptance condition expresses whether accepted given acceptance


fiexpressiveness two valued semantics adfs

status parents par represent ca propositional formula
par mentioned earlier propositional formulas built negation
conjunction disjunction connectives material implication logical equivalence
exclusive disjunction regarded abbreviations specify acceptance
condition take ca par hold iff model
brewka woltran introduced useful subclass adfs adf l c
bipolar iff links l supporting attacking link b l supporting iff par ca implies ca b
symmetrically link b l attacking iff par
ca b implies ca link b supporting attacking
b influence link redundant violate bipolarity
sometimes use circumstance searching adfs simply assume
l links actually needed expressed acceptance conditions make redundant
numerous semantics adfs interested two
supported stable set model iff
iff ca definition stable inspired logic
programming slightly complicated brewka et al define operator
x ac x x x
ac x z x z ca z
x z x z ca z f
intuition behind operator follows pair x represents partial interpretation set statements x accepted true rejected
false x neither operator checks statement
whether total interpretations possibly arise x agree truth
value acceptance condition accepted matter
statements x interpreted acc x set rej x defined
symmetrically pair acc x rej x constitutes refinement x
reduced adf dm lm c defined lm l
setting
replacing b
false
b b
acceptance formula model stable model iff least fixpoint
operator dm given usual su st denote respective model
sets adf
p related adf stable cannot size adf
given kdk aa ka k size kk formula number
nodes
example adf consider vocabulary b c acceptance formulas
c b c c b single supported model su b c
st since atoms model support circularly
translations formalisms
review known translations mentioned formalisms
operator closely related ultimate approximation operators denecker marek
truszczynski observed earlier strass



fistrass

afs badfs
brewka woltran showed translate afs adfs af fv r
define adf associated f df r c c aa b r b
clearly resulting adf bipolar parents attacking brewka
woltran proved translation faithful af stable extension adf
model semantics proposition brewka et al later proved af
stable extension adf stable model semantics theorem easy see
translation computed polynomial time induces linear blowup
adfs pl
brewka woltran showed adfs supported model semantics
faithfully translated propositional logic acceptance conditions statements represented propositional formulas supported
adf given classical propositional formula set

afs pl
combination previous two translations yield

n polynomial
v
fifaithfulotranslation

chain afs propositional logic r
b r b
adfs lps
earlier work strass showed adfs faithfully translated normal
logic programs adf l c standard lp
pd par ca
follows lemma strass translation preserves supported
model semantics translation size preserving acceptance condition representation strass via characteristic representing acceptance conditions
via propositional formulas cannot guaranteed later
afs lps
translation chain afs adfs lps compact faithful af stable
semantics lp stable semantics osorio zepeda nieves cortes af stable
semantics lp supported semantics strass size preserving since single
rule atom contains attackers p r b b r
already complexity reasons cannot expect translation faithful stable
semantics indeed adf stable model
standard logic program p stable model however holds
st p st denecker et al strass



fiexpressiveness two valued semantics adfs

lps pl
well known logic programs supported model semantics translated
propositional logic clark logic program p becomes propositional theory p






p
b
b
abp

bb

bb

stable model semantics additional formulas added extended
translation works lin zhao
lps adfs
clark completion normal logic program directly yields equivalent adf
signature brewka woltran clearly translation computable
polynomial time blowup respect original logic program
linear resulting translation faithful supported model semantics follows
lemma strass
representing bipolar boolean functions
bipolarity hitherto predominantly defined used context
adfs brewka woltran easy define concept boolean functions
general let set atoms f f boolean function atom
supporting iff f implies f write sup f
atom attacking iff f f implies f f
write att f boolean function f f semantically bipolar iff
supporting attacking throughout sometimes take boolean
function given interpretation set say set bipolar
define bipolar propositional formulas representing bipolar adfs
important study since three valued semantics bipolarity
key badfs low complexity comparison general adfs strass wallner
usually assumed specify bipolar adf addition statements
links acceptance conditions user specifies link whether supporting
attacking strass wallner introduce arguably simpler way
support attack represented syntax propositional formula encoding
acceptance function
formally polarity atom formula determined number
negations path root formula tree atom polarity positive
number even negative number odd
definition propositional formula syntactically bipolar
atom occurs positively negatively
recall use formulas basis thus hidden
negations e g material implication formulas negation normal form
negation applied atomic formulas polarities atoms read
formula directly


fistrass

address question represent bipolar boolean functions clearly
boolean functions represented propositional formulas modify construction
later thus reproduce boolean function f f associated
formula







f


f

aa

exactly one model f enumerates
particular bipolar boolean functions represented propositional formulas well however guarantees us existence representations
gives us way actually obtain first fundamental shows
construct syntactically bipolar propositional formula given semantically bipolar
boolean function converse straightforward thus two notions bipolarity
closely related formula associated boolean function f returns
gets input model
theorem let set atoms
syntactically bipolar formula boolean function f semantically
bipolar
semantically bipolar boolean function f f syntactically bipolar
formula f f given
f








f



aatt f











aa
asup f



proof
obvious every atom occurring positively supporting every atom occurring negatively attacking
let f f semantically bipolar note first
easy see f syntactically bipolar since f
semantically bipolar attacking supporting
occurs negatively f supporting attacking occurs
positively f supporting attacking occur f
remains f f f
f f let v f v f
f v clearly v vm get v
thus v f
f f model v f f
v model f model f
f model v model f let n
contains exactly n literals corresponding
k n k n contains exactly n k literals two


fiexpressiveness two valued semantics adfs

interpretations v f v f define difference
v v v v note n
v v n use induction k following
f v f v v vm k
v f covers v f since v vm
thus establishes claim
k v vm implies v vm whence v f vm f vm
definition f
k
k let f v f v
v vm k since k v vm
v vm
supporting attacking necessarily v v f
vm v implies vm whence
v f contradiction define interpretation w f
w f w c v c c clearly v w
w vm k hence induction hypothesis applies w
w f w f v w f since supporting v f
b attacking supporting symmetric opposite case
c supporting attacking define interpretation w f
w vm w c v c c follows
w vm k whence induction hypothesis applies w
w f since supporting attacking thus redundant
get v f w f

paves way analysing succinctness bipolar adfs since
quite natural way representing

relative expressiveness
analyse compare relative expressiveness argumentation frameworks
afs bipolar abstract dialectical frameworks b adfs normal logic programs lps
propositional logic pl first look different families semantics supported
stable isolation afterwards combine two semantics
formalisms f adf lp supported stable semantics
indicate semantics via superscript definition afs consider
stable semantics date semantics afs interpretations
guaranteed map arguments true accepted false rejected e attacked
accepted argument propositional logic pl consider usual model semantics
syntactic translations reviewed previous section currently
following expressiveness relationships supported semantics
af e badfsu e adfsu
e lpsu e pl
stable semantics


fistrass

af e lpst e pl af e badfst e adfst e pl
note lpst e pl adfst e pl hold since sets stable antichain
property contrast model sets propositional logic
succinctness relation
af badfsu adfsu pl lpsu adfsu
supported semantics
depicted know expressiveness afs propositional logic
decrease however yet clear relationships strict follows
two strict working way top least
expressive
adf vs pl
first adfs realise set showing given propositional
formula used construct equivalent adf linear size
theorem pl e adfsu pl adfsu
proof let propositional formula vocabulary define adf
setting

thus ka k kk whence kd k kk remains tovshow su mod
recall adf su mod aa applying
definition yields
v
aa
formula vis equivalent proof case
distinction thus equivalent aa follows
su mod mod

example consider vocabulary b propositional formula b
canonical construction yields adf acceptance formulas b
b b b
b b b b b
intuitively b expresses cannot false true b true
symmetrical argument acceptance formula b equivalent b readily
checked su b desired since know section
converse translation possible adfsu pl get following
corollary pl
adfsu
consider vocabulary part input size increase quadratic



fiexpressiveness two valued semantics adfs

acceptance conditions written propositional formulas construction
realise x proof theorem defines space efficient equivalent





x

x




acceptance formula footnote
adf vs lp
since adfs supported semantics faithfully translated logic programs
likewise translated propositional logic following
corollary adfsu
e lpsu
e pl
however extend succinctness relation logic programs stipulate
particular syntactic form essentially fixed depth circuit specifically
easy see language polynomially expressible normal logic programs
supported semantics ac stable semantics called canonical logic
programs recently shown shen zhao proposition
case interested supported semantics works similarly still present
proof completeness main technical towards proving lemma showing
turn logic program equivalent boolean circuit fixed depth
lemma every normal logic program p exists circuit cp basis

cp accepts supported p
size cp linear size p
cp depth
proof let vocabulary p clark completion p
ai ai
v dnfs literals clearly circuit p
must compute cp ai ai ai replaced ai ai
cnf literals construction depicted follows
inner layers shown one dotted lines represent potential edges

ai






















ai




ai

ai












fistrass

follows since su p mod p cp accepts p
p contains p rules kp k total number inner gates
bounded n n kp k clear

statement lemma actually much stronger gives constant upper
bound resulting circuit depth arbitrarily sized logic programs readily follows
set polynomially logic program expressible languages subset languages
expressible alternating boolean circuits unbounded fan constant depth
proposition l polynomially expressible normal logic programs supported
semantics l ac
follows immediately normal logic programs cannot polynomially express
language parity supported semantics counterpart theorem shen
zhao
corollary parity polynomial size normal logic program representation
proof proposition parity
ac jukna



follows propositional logic strictly succinct normal logic programs
supported semantics
corollary pl lpsu thus lpsu pl
considerations since theorem follows small conjunctive
normal form conjunction clauses disjunctive normal form disjunction monomials representation small normal logic program representation
mod
adf vs badf
quite obvious canonical adf constructed theorem bipolar since
well every atom mentioned occurs positively negatively
raises question whether construction adapted bipolar adfs
turns subclass bipolar adfs strictly less expressive towards
proof start concept conjugate model set
respect atom concept used characterise adf realisability
precisely captures part adfs supported model semantics
translation adf propositional logic v
cf section see
basically conjunction equivalences aa conjunction part
captured set intersection conjugate capture equivalence part
definition let vocabulary x conjugate x set
hai x x
x

logic programs supported universally expressive express parity
polynomial size



fiexpressiveness two valued semantics adfs

alternatively could write hai x x intuitively hai x
contains interpretations containment coincides exactly containment x formulated terms propositional formulas x model set
formula hai x model set formula note vocabulary
implicit conjugate function
example consider vocabulary b functions hai hbi operate

set interpretation sets shown table


b
b
b
ab

b

b
b
ab
ab
b
ab
ba


hai

b
b
b
ab

ab

b
b
b
ba
b
ab
ab


hbi
b
b
b
b
ba
ab

b



ab
b
ab
ab
b

table conjugation functions b interpretation sets represented
formulas connective denotes exclusive disjunction xor
two valued adf semantics conjugation function plays essential semantical
role since provides bridge acceptance functions
adf interesting first properties conjugation
function associated atom since used proof later first
involution inverse thus particular bijection next
compatible complement operation logical negation formula level
finally preserves evenness cardinality input set
proposition let vocabulary x
hai hai x x

involution

hai x hai x


compatible negation

x even iff hai x even

preserves evenness

proof let n x


fistrass

let
hai hai x iff hai x
iff x
iff x
iff x
denote
x
x



x


x



observe




x
hai x


denotes disjoint union

hai x




x

x






afim
x
x

hai x
x hai x even firstly







n thus

whence fis fis







x hai x fis fis






fis fis


n
even



current purpose characterising expressiveness bipolar adfs
use concept conjugation make adf realisability model semantics slightly
accessible adf realisation model set x n element
vocabulary equivalently characterised n tuple yn supersets x
whose intersection exactly x crux proof acceptance
conditions realising adf yi related conjugation function


fiexpressiveness two valued semantics adfs

proposition let vocabulary x set interpretations denote adf sequence n acceptance formulas
n formula acceptance formula ai define
cx mod mod n su n x




n



yx yn yn
yi x



sets cx yx one one correspondence particular cx yx
proof provide bijection cx yx consider function
n
n
b bn ha b han bn

f
involution proposition section get
mod mod n cx iff su n x



iff mod
ai x


iff



mod ai x



iff



hai mod x



iff ha mod han mod n yx
iff f mod mod n yx
thus f cx yx whence f yx f f cx cx f cx cx yx bijective



one one correspondence important since later analyse precise
number realisations given model sets furthermore shows role
conjugation function characterising two valued model realisability general adfs
adapt characterisation case bipolar adfs precisely
give several necessary sufficient conditions given model set bipolarly realisable
characterisation hand later specific interpretation set fails
necessary conditions thus cannot model set badf
fiwe denote

set supersets set x interpretation sets x x
proposition let vocabulary x set interpretations following equivalent
x bipolarly realisable
exist yn x

ni yi x


fistrass

b n set hai yi bipolar
exist yn x

ni yi x
b j n least one
yi ai aj yi ai aj
n n yi ai n n aj yi ai n aj
proof x bipolarly realisable exists bipolar adf l c
su x particular exist bipolar boolean functions c cn
x n ai iff ci
n define yt
hai ci assumption hai yi hai hai ci ci bipolar furthermore ni yi x follows
let n assume hai yi bipolar means
aj aj supporting attacking hai yi aj
supporting haj yi iff
hai yi aj hai yi
yi ai aj yi ai aj
similarly aj attacking hai yi iff n
n
hai yi n aj
hai yi
n yi ai n n aj yi ai n aj
thus aj least one following
yi ai aj yi ai aj
n n yi ai n n aj yi ai n aj
construct adf l c follows n define ci hai yi finally set l ci bipolar equivalences
established previous proof item su
x follows fact
hai ci hai hai yi yi presumption ni yi x


apply characterisation interpretation set
three atoms cannot realised bipolar adfs model semantics
smallest example terms number atoms actually one two smallest
examples interpretation sets binary vocabulary bipolarly realisable
proposition vocabulary bipolar adf realises
x even


fiexpressiveness two valued semantics adfs

proof assume contrary x bipolarly realisable exist x

proposition x candidates yi
every yi must form x z
z x
eleven sixteen model set candidates yi set hii yi
bipolar model set hii yi bipolar provide statement j
neither supporting attacking say statement dependent
x get h bipolar since
statement dependent supporting h would imply
h attacking
h would imply
h
remaining cases justifications specific statement dependent
equally easy read model set brevity indicate statements
x get h
bipolar since statement dependent
x get h bipolar since
statement dependent
case x symmetric previous one get model set
h bipolar since statement dependent
x get h
bipolar since statement dependent
x get h
bipolar since statement dependent
case x symmetric previous one
x get h bipolar since
statement dependent
x get h
bipolar since statement dependent
x get h
bipolar since statement dependent
x symmetric previous case
remains set c five candidates due symmetry
c x
x
x
x
x


fistrass

basically candidates least three four interpretations
contained addition already x clearly
assumption yi realise x

c

yi thus
yi x however x
contradiction thus yi exist x bipolarly realisable

interpretation set bipolarly realisable found
complement even parity language three atoms
proposition vocabulary bipolar adf realises
parity
together straightforward statement fact even realised
non bipolar adf proposition leads next
theorem badfsu e adfsu
proof model set even proposition realisable model semantics adf
deven acceptance conditions






however bipolar adf realising even witnessed proposition



another consequence characterisation two valued model realisability proposition get precise number distinct realisations given model set
significant illustrates rather intricate difficulty underlying bipolar non realisability cannot necessarily use model set even determine
single reason bipolar non realisability single link b neither supporting attacking realisations rather culprit might different
realisation bipolar non realisability prove realisations
necessarily exists reason non bipolarity number different adf
realisations given model set x considerable

proposition

let vocabulary n x interpretation set
x number distinct adfs su x

r n n
proof according proposition
realisation
tufi
x characterised
n
n tuples
ple yn x x ni yi since fix
however ttowards r n wrongly counts tuples yn ni yi x
ni yi x least remains subtract
n
n
overestimate number tuples yn x ni yi x
expression

n

q n
mi


counting adfs take account different link relations take l
count different acceptance functions redundant links modelled



fiexpressiveness two valued semantics adfs


seen follows let x fixed element set intuitively interpretation set x contains
interpretations many
mi sets
exactly


n
fii mi thus mi possible ways choose n
elements yn matter yj chosen intersection
contains thus least elements many however sets least
elements many counted twice subtracted subtract
q n counted sets least elements many
add q n
inclusion exclusion principle number
n etc hence

tuples yn x ni yi x given
r n q n q n q n q n

x

q n


x


n



mi





x

n mi




reordering factors


n



binomial theorem

main contributing factor number interpretations excluded
desired model set x proposition instance
adfs model set even according theorem none bipolar obvin
ously maximal number realisations achieved x whence r n n n
hand model set x exactly one realisation r n note
number syntactically distinct realisations universally expressive
formalisms logic programs propositional logic unbounded general since
add arbitrary number tautologies
finally reduction bipolar realisability propositional
satisfiability approaches another angle possible implementation
deciding bipolar realisability sat solver provides proof theorem
strass b contained work
given vocabulary set x set interpretations aim
construct propositional formula x satisfiable x bipolarly
realisable propositional signature use following
propositional variable pm
expresses whether ca allows
encode possible acceptance conditions statements enforce bipolarity
use additional variables model supporting attacking links b
b
variable pa b
sup saying supports b variable patt saying attacks b
vocabulary x given

n

b
b
p pm

p

p






b




sup att
guarantee desired set constrain acceptance conditions dictated
x desired set statement containment must correspond


fistrass

exactly whether ca encoded
x conversely undesired set

statement must correspondence
x expresses
enforce bipolarity state link must supporting attacking model
meaning support attack encode ground instances definitions
definition let vocabulary x set interpretations define
following propositional formulas


badf

x
x x bipolar







pm

pm


x
x



aa








x




x


bipolar





pm





pm


aa



b
b
b
pa b
sup patt sup att



ba

b
sup

pa b
sup

b
att

pa b
att





b



b



pm
b pb











pb

pm
b



corresponding shows reduction correct
theorem let vocabulary x set interpretations x bipolarly
realisable badf
satisfiable
x
proof let p model x define acceptance condition follows set ca iff pm
easy see bipolar
guarantees acceptance conditions bipolar adf given
su c remains model su
dx
x
x
su consider
let x model dx

since model
x pa thus definition
ca
thus definition
since model
x pa
ca f

let
x since model
x
ca f
ca case model
su
dx

let bipolar adf su x use define model x
first set pm
iff ca since bipolar link
supporting attacking b valuation pa b
sup
pa b


remains






model



x
att


fiexpressiveness two valued semantics adfs

model
x since realises x x model thus
ca iff

model
x model
x since realises x
thus witnessing model
ca f
ca

model bipolar straightforward since bipolar assumption



remarkably decision procedure give answer case
positive answer read badf realisation satisfying evaluation
constructed formula illustrate construction example seen earlier
example consider model set even
construction theorem yields formulas






even p p p


p



p

p
p





p



even p




p





p

p



p



p

p





p



p





p

p



p



p



p







p



p



remaining formulas bipolarity independent even
implemented translation proof theorem used solver
clasp gebser kaminski kaufmann ostrowski schaub schneider verify
even unsatisfiable
badf vs lp
earlier used language parity propositional logic thus
pl
adfsu general adfs exponentially succinct normal logic programs
supported however bipolar adfs proposition badf
model set su parity
badfs cannot even express parity fortunately majority language trick
case
theorem badfsu lpsu
proof language majority polynomially expressed badfsu
lpsu latter fact follows majority
ac jukna proposition first part constructing series badfs dn
n n n su dn majorityn use friedman boppana positive n n k n language thresholdn k
negation free propositional formulas threshold
polynomial size use
n k



bound boppana k n log n define n set k n
n
ai ai threshold
ai ai
n k


fistrass

intuitively formula ai checks whether remaining variables could achieve majority
without ai ai set arbitrarily otherwise ai must set true clearly
boolean function computed ai bipolar since ai supporting parents
attacking size dn observe


kdn k n threshold
n k

whence overall size polynomial remains su dn majorityn
let majorityn su dn iff
immediate let aj

j n aj since majorityn
k n n thresholdn k
threshold
aj aj
n k
together aj follows aj

let
majorityn n k particular
aj k implies n thresholdn k
aj aj whence follows
n thus threshold
n k
aj together aj conclude
su dn

since every badf adf size get
corollary adfsu lpsu
combination translation logic programs adfs implying relation
lpsu adfsu means adfs strictly succinct logic programs
corollary lpsu adfsu
badf vs af
comparably easy badf strictly expressive afs
since sets supported bipolar adfs antichain property
proposition af e badfsu
proof consider vocabulary badf
straightforward check model set su since model sets afs
stable extension semantics satisfy antichain property equivalent af


yields following overall relationships
af e badfsu e adfsu
e lpsu
e pl
concise overview relative succinctness present open
glance table
remark three open table really two easy adfs
propositional logic behave equivalently relation bipolar adfs since equally expressive
equally succinct holds adfsu badfsu pl badfsu



fiexpressiveness two valued semantics adfs

su

badf
adfsu
lpsu
pl

badfsu





adfsu






lpsu





pl






table relative succinctness bipolar adfs model semantics normal
logic programs supported semantics classical propositional logic entry
row f column f means f f
stable semantics
recall current state knowledge
af e badfst e adfst e pl af e lpst e pl
first badfs strictly expressive afs
proposition af e badfst
proof consider set x b c b c desired dunne et al
proved x realisable stable af semantics however model set x
realisable badf dx stable semantics
b c

b c

c b

let us exemplarily b stable model cases completely
symmetric reduct dm characterised two acceptance formulas b
b easily dm dm

intuitively argument af non realisability x follows since b occur
extension together attack holds
pairs c b c set b c conflict free thus must stable
extension containing three arguments allowed x reason afs
restriction individual attack set attack called joint collective attack suffices
realise x seen
construction used proof realize x comes work
eiter fink puhrer tompits woltran logic programming
generalised realise non empty model set satisfying antichain property
st l c c
definition let x define following badf dx

given






b
x

ba

thus l b x b


fistrass

next shows construction indeed works
st x
theorem let x
x antichain st dx

proof let
st st st use case distinction
let
x
su dx
x

n x n n consider
acceptance
v formula since n n x formula disjunct
n ba n b n implies n model
st
n thus model although
hence
su dx
n x n x implies let

v n x n acceptance formula contains disjunct
n ba n b assumption n x bn n
clearly bn n bn evaluated true hence n x
n disjunct n evaluated false thus false
st

su dx
st
let x first su dx
iff model
st
let
v construction dx contains disjunct
form ba b according interpretation b
false thus true whence true

let consider acceptance formula assume contrary
model v
n x n
model n ba n b n hence n
since n even n whence x antichain contradiction
thus model
st respect contains
consider reduct dm dx


disjunct b b
b replaced false
equivalent true thus true
whence

st
least fixpoint dm thus st dx


restriction non empty model sets immaterial relative expressiveness since
use construction theorem fact st su adf
realize empty model set stable model semantics adfs logic programs
antichain property get
corollary adfst e badfst lpst e badfst
leads following overall relationships
af e badfst
e adfst
e lpst e pl
remark antichain property provides characterisation realisability
stable semantics model set stable realisable iff antichain


fiexpressiveness two valued semantics adfs

supported vs stable semantics
put supported stable pictures together proof theorem
st antichain x supported
read canonical realisation dx
st st st x observation
stable semantics coincide su dx
x
bipolar adfs supported semantics realize antichain
proposition badfst e badfsu
seen proposition bipolar adfs supported model sets
antichains get
corollary badfst e badfsu
allows us close last gap put together big picture relative
expressiveness figure
adfsu
e pl
e lpsu
badfsu
badfst
e lpst
e adfst
af
figure expressiveness hierarchy expressiveness strictly increases bottom
top f denotes formalism f semantics su supported st
stable model semantics formalisms among afs argumentation frameworks adfs
abstract dialectical frameworks badfs bipolar adfs lps normal logic programs
pl propositional logic

allowing vocabulary expansion
considered compact realisations introduce vocabulary elements section allow introduction small number
atoms arguments statements precisely small means number linear
size source knowledge base representing model set wish realize
target language purpose realisability vocabulary elements projected
resulting
turns adding additional arguments already makes afs universally expressive
projection technically propositional formula
vocabulary exists af f expanded vocabulary
stable extensions f correspond one one roughly
possible since afs regarded syntactic variant classical propositional
logic connective logical gabbay brewka et al
connective negation expressed disjunction


fistrass

equivalences used translate arbitrary propositional formulas syntactical fragment guarantee
size increase linear introduce names subformulas tseitin
next definition combines ideas
definition let formula vocabulary define sets
r inductively follows


r



r

ap p ap p

rp p ap ap p p



r r

r r r


r r r

af associated given f r r
argument unattacked thus part every stable extension true every
interpretation argument attacks thus cannot part stable extension false every interpretation mutually attacking arguments p ap
p serve guess valuation guarantee
valuations lead stable extensions f intuitively must
attacked candidate arguments attacks boolean
connectives express usual truth theoretic semantics first technical
translation shows
lemma let formula vocabulary f associated af
stable extension f
iff

iff
iff one
iff neither
proof
definition attacker argument form argument
thus iff

attackers arguments case
iff
iff
consequently iff


iff
attacker argument similarly previous cases
iff

iff

combination iff


fiexpressiveness two valued semantics adfs

attackers arguments directly follows
iff neither

correspondences used induction newly introduced
arguments capture semantics formulas encode subformulas
lemma let formula f associated af stable extension
f iff model
proof let stable extension f use structural induction
trivial since attackers
trivial
since set conflict free
p trivial p iff p definition
iff iff
iff iff iff
iff iff iff iff
iff
iff iff iff iff
iff
iff iff

iff iff
iff

lets us main section namely af stable extension
semantics universally expressive projection
theorem let formula vocabulary f associated af
model exists stable extension e f e
stable extension e f set e model
proof

let model define set
e

observe e presumption e remains e
stable extension e conflict free attacks arguments b
e
e conflict free assume contrary attack r b r
b e definition cases
arbitrary b definition e get
contradiction
r p ap r ap p p definition e get
p p contradiction


fistrass

r definition e get
contradiction
r r
contradiction
r whence
contradiction
r r
contradiction
e attacks arguments e let b e argument
definition formula b use structural
induction
e attacks definition
whence e attacks definition
whence e e
case e attacks definition
whence e attacks definition
whence e e
case e attacks definition
let e stable extension f since e conflict free
e since e stable
e attacks yields e lemma e model

particular f stable extension iff unsatisfiable shows
construction definition works intended remains number
arguments linear formula size even total increase
size linear thus number arguments linear
proposition formula kf k kk
proof first note
kf k k r r k
r r
r
r
use structural induction formulas kk
r kk follows kf k kk kk kk

k k
r k k


fiexpressiveness two valued semantics adfs


kk
r kk

aa aa kak
ra aa aa kak

kk kk kk
r r r kk kk kk


kk kk kk kk
kk kk k k
r r r r r
kk kk kk kk
kk kk kk

kk kk
kk kk kk kk kk
r r r kk kk
kk kk kk kk kk



hence projection af stable extension semantics realise much propositional logic previous section af e pl means
allowing introduce linear number vocabulary elements later projected
languages considered equally universally expressive
however must note equal expressiveness mean equal efficiency
assume knowledge base size n leads search space size n
linear increase knowledge base size n c n constant c leads
polynomial increase search space size n cn n c


fistrass

discussion
compared expressiveness abstract argumentation frameworks abstract dialectical
frameworks normal logic programs propositional logic showed expressiveness
different semantics varies formalisms obtained neat expressiveness hierarchy inform us capabilities languages encode sets
two valued interpretations help us decide languages use specific applications furthermore seen sensitive vocabulary one
permitted use hierarchy collapses allow introduce even linear
number atoms
concerning succinctness shown adfs model semantics exponentially succinct normal logic programs supported model semantics
even bipolar adfs model semantics although less expressive
succinctly express model sets equivalent normal logic programs supported model semantics vocabulary must necessarily blow exponentially
size open whether converse direction holds whether badfs
exponentially succinct logic programs lpsu badfsu two
mutually incomparable terms succinctness lpsu badfsu stable semantics relative succinctness logic programs badfs completely open partly due
technical aspect two stable semantics conceptually different adfs
fact employ ultimate stable denecker et al brewka et al strass
wallner furthermore general adfs computational complexity
model existence stable semantics higher normal logic programs
succinctness comparison regard stable would limited significance
easy see afs somewhat special role representationally
succinct case vocabulary syntactically possibility specify knowledge base af exponential size since largest af size
k k n n thus polynomially large anything expressed af expressed reasonable space definition however
strength afs taken grain salt since comparably inexpressive addition presented already seen simple
counting argument even syntactically different afs semantically differ
ent could express n different model sets
n
increasing n negligible relation possible model sets
original gogic et al used relaxed version succinctness
allowed introduce linear number variables follows
section formalisms consider equally succinct relaxed
notion
parts expressiveness normal logic programs carry lp
classes example canonical logic programs provide limited form nesting allowing
literals form rule bodies lifschitz et al makes quite easy
see normal logic programs supported semantics translated equivalent
canonical logic programs namely replacing positive body atom
p
hard adfs strass wallner opposed np normal lps bidoit froidevaux
marek truszczynski



fiexpressiveness two valued semantics adfs

rule bodies recently shen zhao showed canonical logic programs
propositional logic programs succinctly incomparable assumption
provide interesting avenues succinctness studies add succinctness
questions firstly comparing disjunctive logic programs stable
general adfs stable since two equally complex
p complete model existence eiter gottlob brewka et al
alternative proposals stable model semantics adfs
strass definition later called approximate stable strass
wallner model existence np complete strass wallner
thus potentially easier stable brewka et al
called ultimate stable strass wallner
grounded model semantics bogaerts vennekens denecker definition whose model existence p complete bogaerts et al

f stable model semantics alviano faber definition
follows theorem bogaerts et al grounded f stable
coincide still demonstrably different approximate ultimate stable adfs alviano faber relative succinctness
comparison normal disjunctive logic programs unanalysed
potential work first nice characterisation bipolar
adf realisability still missing unsure whether much improvement proposition possible incidentally afs exact characterisation compact stable extension realisability constitutes major open dunne et al baumann et al
second semantics abstract dialectical frameworks whose expressiveness could studied dunne et al dyrkolbotn already analyse many
argumentation frameworks work thus start
done remaining semantics example admissible complete preferred
semantics defined afs b adfs lps strass brewka et al
puhrer already made huge step direction characterising realisability third formalisms abstract argumentation brewka et al
whose expressiveness large unexplored best knowledge finally
representational succinctness subclass bipolar adfs bipolar propositional
formulas represent supported model semantics mostly open cf table
evidence pointing toward meaningful capabilities

acknowledgements
combines extends improves previous work strass
b c wish thank stefan woltran providing useful pointer related

p nc poly
boolean circuit equivalent assumption np p
terminology alviano faber approximate stable strass called
stable ultimate stable brewka et al called b stable
shown different f stable



fistrass

work realisability logic programming bart bogaerts pointing grounded
f stable jorg puhrer several suggestions improvement manuscript frank loebe helpful discussions partially
supported deutsche forschungsgemeinschaft dfg project br

references
al abdulkarim l atkinson k bench capon j abstract dialectical
frameworks legal reasoning hoekstra r ed proceedings twentyseventh annual conference legal knowledge information systems jurix
vol frontiers artificial intelligence applications pp ios press
al abdulkarim l atkinson k bench capon j evaluating
reasoning cases abstract dialectical frameworks proceedings
fifteenth international conference artificial intelligence law icail
alviano faber w stable model semantics abstract dialectical frameworks revisited logic programming perspective yang q wooldridge
eds proceedings twenty fourth international joint conference artificial
intelligence ijcai pp buenos aires argentina ijcai aaai
arora barak b computational complexity modern cambridge
university press
baumann r dvorak w linsbichler strass h woltran compact
argumentation frameworks proceedings twenty first european conference
artificial intelligence ecai pp prague czech republic
bidoit n froidevaux c negation default unstratifiable logic programs
theoretical computer science
bogaerts b vennekens j denecker grounded fixpoints applications knowledge representation artificial intelligence
boppana r b threshold functions bounded depth monotone circuits journal
computer system sciences
brewka g dunne p e woltran relating semantics abstract dialectical frameworks standard afs proceedings twenty second international
joint conference artificial intelligence ijcai pp ijcai aaai
brewka g ellmauthaler strass h wallner j p woltran abstract
dialectical frameworks revisited proceedings twenty third international
joint conference artificial intelligence ijcai pp ijcai aaai
brewka g gordon f carneades abstract dialectical frameworks reconstruction proceedings third international conference computational
argument comma vol faia pp ios press
brewka g polberg woltran generalizations dung frameworks
role formal argumentation ieee intelligent systems special
issue representation reasoning


fiexpressiveness two valued semantics adfs

brewka g woltran abstract dialectical frameworks proceedings
twelfth international conference principles knowledge representation
reasoning kr pp
clark k l negation failure gallaire h minker j eds logic
data bases pp plenum press
coste marquis konieczny mailly j g marquis p revision
argumentation systems minimal change arguments statuses proceedings
fourteenth international conference principles knowledge representation
reasoning kr pp
darwiche marquis p knowledge compilation map journal artificial
intelligence
denecker marek v w truszczynski ultimate approximation
application nonmonotonic knowledge representation systems information
computation
dimopoulos nebel b toni f computational complexity
assumption argumentation default reasoning artificial intelligence

dung p acceptability arguments fundamental role
nonmonotonic reasoning logic programming n person games artificial intelligence
dunne p e dvorak w linsbichler woltran characteristics multiple
viewpoints abstract argumentation proceedings fourteenth international
conference principles knowledge representation reasoning kr pp
vienna austria
dunne p e dvorak w linsbichler woltran characteristics multiple
viewpoints abstract argumentation artificial intelligence
dyrkolbotn k argue anything enforcing arbitrary sets labellings
afs proceedings fourteenth international conference principles
knowledge representation reasoning kr pp vienna austria
eiter fink puhrer j tompits h woltran model recasting
answer set programming journal applied non classical logics
eiter gottlob g computational cost disjunctive logic programming
propositional case annals mathematics artificial intelligence

french van der hoek w iliev p kooi b succinctness
modal logics artificial intelligence
friedman j constructing n log n size monotone formulae k th elementary symmetric polynomial n boolean variables siam journal computing

gabbay dungs argumentation essentially equivalent classical propositional logic peirce quine dagger logica universalis


fistrass

gaggl strass h decomposing abstract dialectical frameworks parsons oren n reed c eds proceedings fifth international conference
computational argument comma vol faia pp
ios press
gaggl rudolph strass h computational complexity naivebased semantics abstract dialectical frameworks yang q wooldridge
eds proceedings twenty fourth international joint conference artificial
intelligence ijcai pp buenos aires argentina ijcai aaai
gebser kaminski r kaufmann b ostrowski schaub schneider
potassco potsdam answer set solving collection ai communications
available http potassco sourceforge net
gelfond lifschitz v stable model semantics logic programming
proceedings international conference logic programming iclp pp
mit press
gogic g kautz h papadimitriou c selman b comparative linguistics
knowledge representation proceedings fourteenth international joint
conference artificial intelligence ijcai pp morgan kaufmann
jukna boolean function complexity advances frontiers vol combinatorics springer
lifschitz v razborov many loop formulas acm transactions computational logic
lifschitz v tang l r turner h nested expressions logic programs annals
mathematics artificial intelligence
lin f zhao assat computing answer sets logic program sat
solvers artificial intelligence
linsbichler splitting abstract dialectical frameworks parsons oren n
reed c eds proceedings fifth international conference computational
argument comma vol faia pp ios press
marek v w truszczynski autoepistemic logic journal acm

osorio zepeda c nieves j c cortes u inferring acceptable arguments
answer set programming proceedings sixth mexican international
conference computer science enc pp
polberg extension semantics abstract dialectical frameworks endriss
u leite j eds proceedings seventh european starting ai researcher
symposium stairs vol faia pp ios press
polberg wallner j p woltran admissibility abstract dialectical
framework leite j son c torroni p van der torre l woltran
eds proceedings fourteenth international workshop computational logic
multi agent systems clima xiv vol lnai pp springer


fiexpressiveness two valued semantics adfs

puhrer j realizability three valued semantics abstract dialectical frameworks yang q wooldridge eds proceedings twenty fourth
international joint conference artificial intelligence ijcai pp ijcai aaai buenos aires argentina
shen zhao x canonical logic programs succinctly incomparable
propositional formulas proceedings fourteenth international conference
principles knowledge representation reasoning kr pp
vienna austria
strass h approximating operators semantics abstract dialectical frameworks artificial intelligence
strass h relative expressiveness argumentation frameworks normal
logic programs abstract dialectical frameworks konieczny tompits
h eds proceedings fifteenth international workshop non monotonic
reasoning nmr
strass h instantiating rule defeasible theories abstract dialectical frameworks beyond journal logic computation advance access published
february http dx doi org logcom exv
strass h b relative expressiveness abstract argumentation logic programming proceedings twenty ninth aaai conference artificial intelligence
aaai pp austin tx usa
strass h c representational succinctness abstract dialectical frameworks
black e modgil oren n eds proceedings third international workshop theory applications formal argumentation tafa
strass h wallner j p analyzing computational complexity abstract
dialectical frameworks via approximation fixpoint theory artificial intelligence

tseitin g complexity derivations propositional calculus structures constructive mathematics mathematical logic part ii seminars
mathematics translated russian




