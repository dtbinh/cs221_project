journal artificial intelligence

submitted published

compressing optimal paths run length encoding
ben strasser

strasser kit edu

karlsruhe institute technology
karlsruhe germany

adi botea

adibotea ie ibm com

ibm
dublin ireland

daniel harabor

daniel harabor nicta com au

nicta
sydney australia

abstract
introduce novel compressed path databases space efficient oracles used
quickly identify first edge shortest path achieves query running times
nanosecond scale significantly faster state art first move oracles
literature space consumption competitive due compression rearranges
rows columns first move matrix performs run length encoding rle
contents matrix one variant implemented system convincing margin
fastest entry grid path competition
give first tractability analysis compression scheme used
study complexity computing database minimum size general directed undirected
graphs cases np complete graphs
decomposed along articulation points decomposed independent
parts corresponding reduction level difficulty particular leads simple
tractable linear running time yield optimal compression trees

introduction
compressed path database cpd index data structure graphs used
quickly answer first move queries query takes input pair nodes namely source node
target node asks first edge shortest st path e path cpds
successfully applied number contexts important ai instance copa botea
cpd pathfinding one joint winners edition
grid path competition shorter gppc sturtevant b related
mtscopa fast method moving target search known partially known terrain botea
baier harabor hernandez baier botea harabor hernandez
given graph g v e trivial cpd consists square matrix dimensions
v v matrix constructed precomputation step stores cell
identity first edge shortest st path call first move matrix convention
say rows correspond fixed source nodes columns fixed target nodes
optimal terms query time v space consumption quickly becomes prohibitive
larger graphs challenge design compact representation trades small increase
query times large decrease space consumption
c

ai access foundation rights reserved

fis trasser b otea h arabor

number different techniques compress first move matrix suggested
purpose sankaranarayanan alborzi samet botea botea harabor
case objective conserve space grouping together entries share
common source node store first edge information
work present single row compression src multi row compression
mrc indexing compressing pairs shortest paths gppc src outperformed competitors terms query running time contributions presented article
go three main directions compressing first move matrix experiments
demonstrate advancing state art terms response time memory consumption
thorough theoretical analysis discussing np hardness islands tractability
introduce matrix compression technique run length encoding rle
main idea simple compute order nodes input graph
assign numeric ids nodes e g v order purpose ordering
nodes located close proximity graph small id difference ordering
used order rows columns first move matrix computed
preprocessing apply run length encoding rle row first move matrix
study three types heuristic orderings graph cut order depth first order input graph order
study two types run length encoding first involves straightforward application
row second type sophisticated multi row scheme eliminates
redundancies adjacent rle compressed rows answer first move queries employ
binary search fragment compressed
undertake detailed empirical analysis including comparisons techniques stateof art variants cpds botea hub labeling delling goldberg pajor werneck
copa recent fast cpd oracle among joint winners
international grid path competition gppc variety benchmarks
competition techniques improve copa terms storage query
time hub labeling technique initially developed speedup queries roads
work graphs gridmaps hub labeling best knowledge fastest
technique known roads experiments leads better query times
hub labeling graphs reasonably compute
technique relies pairs shortest path pre computation plays tradeoff
query response speed preprocessing time memory required store compressed
path database thus faster requires larger preprocessing time
memory techniques literature words memory
preprocessing time available technique provide state art speed performance hand larger larger graphs create memory preprocessing time
bottleneck techniques considered see detailed comparison experiments
section
theoretical analysis formally define study optimal rle compression first move
matrices produced input graphs consider case directed input graphs case
undirected weighted input graphs versions np complete focusing
distinct types graphs brings something compared related kou
oswald reinelt weaker less specific mohapatra rle
matrix compression available literature however known np hardness class
necessarily imply np hardness subset class thus despite


fic ompressing ptimal paths run l ength e ncoding

previous related mohapatra open question whether optimal rlecompression first move matrix computed input graph tractable
graphs decomposed along articulation points
decomposed independent subproblems optimal orderings available subproblems global optimal ordering easily obtained particular depth first preorder
optimal trees general ordering fixed parameter tractable size
largest connected component
part evaluation previously reported shorter conference
strasser harabor botea theoretical analysis topic another conference botea strasser harabor putting together current submission
provides unique source describes method performance theoretical properties
compared previous conference papers provide complete proofs theoretical
included details examples presentation better clarity
report additional performance pathfinding competition gppc
originally published competition sturtevant traish tulip uras
koenig strasser botea harabor rabin

related work
many techniques literature employed order quickly answer first move queries
standard examples include optimal graph search techniques dijkstras dijkstra
hart nilsson raphael significant improvements methods
achieved preprocessing input graph done cpds instance shortest paths
numerous applications fields plethora different preprocessing
proposed overview refer interested reader recent survey article bast
delling goldberg mullerhannemann pajor sanders wagner werneck common
consists adding online pruning rules dijkstras rely data computed preprocessing phase significantly reducing explored graphs size
significantly differs technique described omit details refer
interested reader aforementioned survey article
silc sankaranarayanan et al copa botea harabor cpd techniques fast first move computation silc employs recursive quad tree mechanism compression copa uses simpler effective botea decomposition rectangles
hub labels hl initially introduced hop labels cohen halperin kaplan zwick
nearly decade much topic abraham delling
goldberg werneck showed technique practical huge road networks
coined term hub labels realization drastically increased interest hl thus
spawned numerous follow works abraham delling goldberg werneck
delling goldberg werneck abraham delling fiat goldberg werneck akiba
iwata yoshida context relevant one probably rxl delling et al
hl variant authors works well road
graphs variety graphs different sources including graphs derived maps used
gppc compare rxl
hl index consists forward backward label node contains list hub
nodes exact distances st pair must exist meeting hub h


fis trasser b otea h arabor

forward hub backward hub shortest st path shortest distance query
node node answered enumerating common hubs labeling
good labels contain hubs computing labeling minimizing index size
np hard babenko goldberg kaplan savchenko weller
works consider hl general form consider restrictive variant
called hierarchical hub labels hhl term introduced abraham et al
labels used previous work abraham et al already hierarchical labeling called
hierarchical ordering vertices exists every hub h vertex v comes v
order given fixed node order optimal labeling computed efficiently abraham
et al difficult task hhl consists computing node order computing node
order minimizing index size np hard task babenko et al
hhl deeply coupled different popular speedup technique shortest path computations called contraction hierarchies ch geisberger sanders schultes delling ch
achieve query speeds hhl significantly smaller index sizes however
applications even ch query times already faster necessary makes ch
strong competitor ch iteratively contracts nodes inserting shortcuts maintain shortest
path distances remaining graph following inserted shortcuts small fraction
graph needs explored every node node order good ch search
spaces every node small computing optimal order np hard bauer columbus
katz krug wagner first hl road graphs abraham et al computed
label v explicitly storing nodes reachable v ch search space applying pruning rules later papers refined rules every hierarchical label
viewed explicitly stored pruned ch search space consequence node orders
good ch good hhl vice versa even though formal optimization
criteria differ therefore optimal order one respect criterion
slightly suboptimal
node orders used hhl original ch depend weights input graph
substantial changes weights requires recomputing node ordering recent work
bauer columbus rutter wagner dibbelt strasser wagner introduced
customizable contraction hierarchies cch shown node orders exist work well
depend structure input graph node orders exploit input graph
small balanced node separators comparative small treewidth
consider two types node orders first depth first search preorder
second small balanced edge cuts thus independent input
graphs weights however confuse orders cch node orders
interchangeable cch ordering bad performance technique
one node orders cch work well fact preorder cch
maximizes maximum search space terms vertices instead minimizing
order works well technique cch worst case node order orders
interchanged weight dependent orders needed hhl ch
described literature hl answers distance queries however hinted abraham
et al easy extend hub labels first move queries achieve entries
forward backward labels extended third component first move edge id h
forward hub corresponding entry extended first edge id shortest
sh path h backward hub entry extended first edge shortest ht path


fic ompressing ptimal paths run l ength e ncoding

st query first corresponding meeting hub h determined h first move
edge id stored forward label otherwise first move contained backward
label slightly increases memory consumption negligible impact
performance note distance values needed even one wishes compute first moves
need distances determine right hub several hubs common
context program analysis sometimes desirable construct oracle determines particular section code ever reached pwah van schaik de moor
one example similarly work authors precompute quadratic matrix employ
compression scheme run length encoding main difference reachability
oracles return yes answer every query rather identity first edge
another speedup technique low average query times transit node routing tnr bast
funke matijevic bast funke matijevic sanders schultes antsfeld harabor
kilby walsh however two independent studies abraham et al arz luxen
sanders come conclusion least roads tnr dominated hl
terms query time tnr optimize short range queries scenario often
arises unit chases another unit situations units tend close
many short range queries tnr rather ineffective scenario
bulitko bjornsson lawrence present subgoal pathfinding similarities work include preprocessing stage paths map precomputed
compressed stored database database used speed
response time path query posed system substantial differences
two approaches well method precomputes pairs shortest paths eliminating graph
search entirely production mode e stage system queried provide full
shortest paths fragments shortest paths contrast bulitko et al restrict precomputed
database subset nodes turn requires additional search production mode
compression method different case system provides optimal paths
guaranteed case bulitko et al method besides bulitko et al work pathfinding
sub goals turned popular successful idea recent work hernandez
baier bulitko rayner lawrence lawrence bulitko uras koenig
hernandez
pattern databases pdbs culberson schaeffer lookup tables provide heuristic
estimations true distance search node goal state obtained abstracting
original search space smaller space optimal distances abstracted space every
state pre established goal precomputed stored pattern database estimations
distances original space techniques memory enhancements
solution represented path graph several key
distinctions pdbs cpds pdbs lossy abstractions specific goal
subset goals cpds lossless compressions encode shortest paths every starttarget
pair given lossy nature pdbs need used heuristic within search
example opposed complete optimal method pdbs commonly
used large graphs implicitly defined search spaces exploring entire graph
preprocessing impractical pdbs coarseness abstraction impacts accurracy
heuristic estimations finer abstraction better quality larger pdb
work addressing bottleneck include compressing pattern databases felner korf meshulam


fis trasser b otea h arabor

holte samadi siabani felner holte contrast cpds compress pairs
shortest paths

preliminaries
denote g v e graph node set v edge set e v v denote
deg u number outgoing edges u maximum degree denoted node
order v v assigns every node v unique node id v going edges every
node ordered arbitrary fixed order position index ordering referred
edge id
weight function w e r st path sequence edges ak
starts ak ends tp
every edge ai ends node ai
starts weight cost path w ai st path shortest st path exists
strictly smaller weight distance two nodes weight shortest
st path one exists st path exists distance notice may multiple
shortest st paths weight
without loss generality assume duplicate edges multi edges exist
graphs could drop shortest edge edges used
shortest path similar argument assume without loss generality
reflexive loops exist
st first move first edge shortest st path multiple shortest
st paths may multiple st first moves st path exists st first move exists
formal consider following given pair nodes st first move
several valid first moves freely choose return
given oracle answers first move queries easily extract shortest paths compute
st first move words first edge shortest path next set end
long apply procedure iteratively notice works edge weights
guaranteed non zero allowed zero weights could run infinite loop
following example illustrates consider graph g two nodes x connected edges
xy yx weights zero denote node g valid xt first move xy
valid yt first move yx oracle returned two first moves
path extraction would oscillate x would terminate
depth first search dfs way traversing graph constructing special sort
spanning tree backtracking depth first preorder node order orders nodes
way dfs first sees search parameterized root node order
neighbors node visited work regularly refer depthfirst preorders without stating parameters implicitly assume root
arbitrary node neighbors visited arbitrary order
term arc used literature sometimes distinction made whether graph directed
case authors prefer say arcs undirected stick term edge cases
directed graph every ordered pair u v e outgoing edge u undirected graph every edge
incident u outgoing edge u
assume function e r able apply dijkstras preprocessing phase
however one could consider arbitrary weights without negative cycles replace every occurrence dijkstras
bellman ford bellman ford



fic ompressing ptimal paths run l ength e ncoding

run length encoding rle compresses string symbols representing compactly
substrings called runs consisting repetitions symbol instance string aabbbaaa
three runs namely aa bbb aaa run replaced pair contains start
value run start index first element substring whereas value
symbol contained substring example first run aa start value
run bbb start value b whereas last run start value
first last run value need encode first
run easily reconstructed constant time case first decide whether first run
removed done checking first run among preserved ones
start equal secondly needed reconstruct first run start position value
equal value last encoded run another way looking first
last run value allow merge wrapped around string
form cycle allow say cyclic runs otherwise never consider
merging ends string say use sequential runs see example
given ordered sequence elements string say two positions adjacent
next cyclic adjacent adjacent one first last
position ordering separated otherwise
let ordered sequence elements symbols dictionary alphabet given
symbol let run rle run containing symbol every string denote
n total number occurrences symbol number sequential runs
denoted rs number cyclic rc notice rs rc
words number sequential runs number cyclic runs never differ
finally denote rs total number sequential runs rc total number
cyclic runs assume first move compression uses cyclic runs unless
explicitly say otherwise
example consider string aabbbaaa compressing yields b
means position string consists similarily position bs
finally position elements string ends na nb
three sequential runs namely aa bbb aaa first third ones runs
whereas middle one b run thus ras rbs rs
time one cyclic run indeed put next two ends
string string cyclic occurrences string become one solid block e
one cyclic run thus rac rbc rc

basic idea
mentioned introduction starts building v v pairs first move
matrix entry position j ij first move central idea
compress row rle compression performed gradually matrix
rows computed uncompressed matrix kept memory
answer st first move query run binary search row however achieve
good compression ratio first reorder columns decrease total number runs
columns correspond nodes regard reordering columns
alternative encodings exist value followed run length e g b example



fis trasser b otea h arabor


b


e


c



input


f





ae f e
e ed c
f f dd
c c c c
b first move matrix








e f e
e c
f
c

c compressed path database

figure toy example
computing good node order computing optimal node order minimizes number
runs np hard theoretical analysis fortunately simple depth first preorder
works well practice
sometimes formal analysis technical details annoying sense
make presentation somewhat complicated question symbol
use example practical implementation say care
symbol never query reduce number runs therefore assign
value theoretical analysis make similar assumption e
dont care symbol sections state section assumption
symbol different edge symbol every case assumptions
purpose keeping analysis simple possible
example figure shows toy weighted undirected graph nodes edges
edge weight cost number unique label letter first move
matrix graph corresponding node ordering shown figure b
recall entry r c r row c column id first move
shortest path node r node c example e e first step ea
optimal path node node another optimal path would single step path b
ea b optimal weight cost thus free choose e
b prefer e leads better compression row since
first two symbols third row identical part rle run
section breaking ties optimal way feasible computationally easy
compression given node ordering equivalently matrix column ordering shown
figure c
notice ordering nodes impacts size compressed matrix example
swapping nodes illustrated figure would reduce number rle runs
row two e symbols become adjacent total number runs decreases
runs runs thus challenge optimal least good enough node ordering
objective function size compressed first move matrix
compression strategy rle illustrated example key component study theoretically next three sections showing computing optimal
node ordering np hard general identifying tractability islands present number
effective heuristic node orderings section variant implemented method called src


fic ompressing ptimal paths run l ength e ncoding


b


e


c



input


f





af e e
f f
e e dc
c c c c
b first move matrix








f e
f
e c
c

c compressed path database

figure toy example figure different node ordering e nodes
swapped
performs compression illustrated example another version program called
mrc goes beyond idea compressing row independently implementing multi row
compression strategy discussed section evaluated empirically section

first move compression directed graphs
recall ordering columns first move matrix affects number rle runs
matrix section obtaining optimal ordering intractable general
input graph directed construction works uniform edge weights simplicitly
therefore omit weights section
definition fmcomp first move compressiondirected
input directed graph g v e matrix size v v cell j encodes
first move optimal path node node j integer k
question ordering columns apply rle row
total number cyclic rle runs summed rows k
theorem fmcomp np complete
proof easy see belongs np solution guessed verified
polynomial time
np hardness shown reduction hamiltonian path hpp
undirected graph let gh vh eh arbitrary undirected graph define n vh
e eh starting gh build instance fmcomp according
definition instance includes directed graph call gf first move matrix
gf number
gf vf ef defined follows node u vh define node vf call
nodes vf type n nodes indicate created original nodes vh
edge u v eh define node nuv vf type e nodes node nuv define
two edges ef one nuv u one nuv v edges ef see
figure example
table shows first move matrix running example given type n node u
nodes unreachable u graph gf thus matrix row corresponding u


fis trasser b otea h arabor

nxy



x

x



w

z

nxw
w

z

nwz
figure left sample graph gh right gf built gh gf x w z type n nodes
nodes nij type e

x

w
z
nxy
nxw
nwz

x















w







z







nxy







nxw







nwz








nr cyclic runs








table first move matrix running example rows columns follow node
ordering x w z nxy nxw nwz
one non trivial symbol chose symbol denotes node
reachable rows one rle run regardless node ordering
matrix row corresponding type e node nuv three distinct non trivial symbols total
one symbol edge node u another symbol edge node v non reachable
symbol every node without generality loss use symbol edge u
symbol edge v easy see nodes u v cyclic adjacent given
ordering nuv row rle runs u v separated row rle runs
see table sample orderings
claim hpp solution iff fmcomp solution e rle runs let
vi vi vin solution hpp e hamiltonian path gh let p eh set
edges included solution node ordering vf starting vi vin
followed type e nodes arbitrary order e n en n
runs n runs total type e rows corresponding edges p e n runs
total remaining type e rows n runs total type n rows
trivial symbol mean dont care symbol recall impact number runs
simplicity safely ignore symbol discussion
say row type n type e iff associated node type



fic ompressing ptimal paths run l ength e ncoding

indeed edge u v p type e row corresponding node nuv vf
rle runs since u v adjacent ordering n edges hamiltonian
path total number rle runs n rows
edge u v
p two nodes separated therefore corresponding matrix row
runs sums e n rle runs rows corresponding edges
included hamiltonian path
conversely consider node ordering creates e n e n n rle
runs total ordering type n nodes contiguous block
ordering hamiltonian path gh equivalent saying exist n pairs
type n nodes u v u v cyclic adjacent ordering u v eh
proof contradiction assume p n pairs type n nodes u v
u v cyclic adjacent ordering u v edge eh
p pairs row corresponding type e node nuv rle runs remaining e p
type e rows rle runs mentioned earlier type n rows n runs total
regardless ordering thus total number rle runs p e p n e p n
e n n e contradiction

compression undirected weighted graphs
turn attention undirected weighted graphs showing computing optimal ordering
np complete
definition fmcomp uw first move compressionundirected weighted defined follows
input undirected weighted graph g v e matrix size v v cell j
stores first move optimal path node node j integer k
question ordering ms columns apply run length encoding rle
row total number cyclic rle runs matrix k
stepping stone proving np hardness fmcomp uw introduce
call simmini runs definition prove np completeness simmini runs inspired
work oswald reinelt studied complexity involving
called k augmented simultaneous consecutive ones property c sk matrix e
matrix two symbols definition matrix c sk property
replacing k columns rows matrix ordered
row column row column come one contiguous block
oswald reinelt proven checking whether matrix c sk property
np complete proof simmini runs related point later proof
given matrix ordering columns ordering rows let global
sequential runs count gs number sequential runs summed rows
columns
x
gs
r


notion contiguous block allows case part block end sequence
part beginning sequence cyclic



fis trasser b otea h arabor



r
r



c

c

c












figure running example matrix rows labelled ri whereas cj represent column
labels
iterated os rows columns instance gs matrix shown
figure
definition simultaneous mini runs simmini runs defined follows
input matrix every row column contain least one value integer k
question ordering columns ordering rows gs k
theorem simmini runs np complete
proof available appendix
lemma let string starts ends
r r c
proof case starts ends two end symbols different sequential
runs cyclic runs identical runs runs alternate numbers identical case
ii starts ends similar previous one
case iii ends runs runs alternate runs
ends follows r r r c
theorem fmcomp uw np complete
proof np hardness shown reduction simmini runs consider arbitrary
simmini runs instance rows n columns figure shows running example
build undirected weighted graph g v e follows v types nodes total
n nodes column generates one node v call c nodes row
generates one node well r nodes extra node p called hub node
one r node ri one c node cj connected unit cost edge iff ri cj
addition edge weight p every node edges
exist graph g see figure example
let first move matrix g row p fixed number runs namely n
regardless ordering ms columns let v c node r node apart vs adjacent
nodes nodes reached shortest path cost whose first move edge
v p matrix running example shown figure
let total number occurrences symbol matrix claim
ordering os rows columns k sequential runs summed rows
columns iff ordering columns resulting k n
recall ignore dont care symbol p p impact number rle runs



fic ompressing ptimal paths run l ength e ncoding

p

c

c

c

r

r

figure graph running example dashed edges weight whereas solid lines
unit cost edges

r



r



r









c
c
c
p

r

c

c

c

p

















figure first move matrix running example without generality loss move
towards p incident edges given node counted starting
cyclic rle runs total summed rows thus rows except ps row
k runs total
let ri rim cj cjn row column orderings k
sequential rle runs rows columns ordering ri rim cj cjn p
ms columns generates k n cyclic runs clearly every row column
corresponding row see figures example according
steps explained earlier illustrated figures obtained follows
original preserved original replaced distinct consecutive integers starting
addition padded one ends since one
ends follows r r c follows rc r c n r n
summing rc rows except ps row obtain
x
p

rc

x

r



x


n k

denotes set rows matrix set columns follows
ms rows k n cyclic rle runs total summed rows
conversely assume ordering ms columns k n cyclic rle runs
total rows means summing runs rows except node ps
row k runs exactly distinct runs different runs
r r c lemma r c r c construction



fis trasser b otea h arabor

follows k runs total
x
p

r c k

let ri rim cj cjn p arragement ms columns r nodes come
one contiguous block relative ordering preserved c nodes one contiguous block
relative ordering preserved
since g restricted c nodes r nodes bi partite rearrangement cannot possibly increase number rle runs anything could eliminate runs hard
prove example current matrix row corresponds r node source node
b every r node b since p b optimal path b
p rearrangement moves nodes b block cyclic adjacent p
create run case c node source similar
order os columns cj cjn os rows ri rim orderings
relation row column corresponding row follows
non zero values converted one ends cut
away since contains one ends r r c according lemma
follows
x
x
r
r c k


p

fighting complexity decomposition
far negative shown computing optimal order large
class graphs np hard section identify tractability islands
decomposed along articulation points related cuts size particular
implies shown section depth first preorder optimal node ordering trees
able construct optimal orders efficiently broader class graphs trees
fixed parameter tractable size largest component
graph articulation points
definition say node x graph g articulation point removing x adjacent edges g would split graph two disjoint connected subgraphs g gn
figure shows example rest section focus graphs g articulation
points x consider cyclic runs previous sections treated dont care symbol
impact number runs section make different assumption every cell
gets distinct symbol called singleton creates run
merged adjacent symbols common run makes proofs easier
clearly significant impact number runs
definition call x block ordering node ordering x comes first nodes g
come next contiguous block way block gn


fic ompressing ptimal paths run l ength e ncoding

figure graph articulation point x removing x would decompose graph four
disjoint components depicted g g

example shown figure ordering x b c e f g example
x block ordering
use g denote projection node ordering subset nodes corresponding
subgraph g g use denote subgraph induced nodes gi x
say order rotation another order obtained taking block
elements beginning appending end instance e f g x b c
rotation x b c e f g formally rotation two sub orders
exist
lemma let x articulation point graph g every node order rearranged
x block ordering without increasing number runs row
given graph g node ordering row subset let n g number runs
restricted subset clearly n g g total number runs
lemma given x block ordering
n g gi n gi
p
n g x n n x
p
n g g n n
proofs lemmas available appendix b
theorem given optimal order oi every subgraph induced construct
optimal global ordering g following obtain orderings rotating oi x
comes first removing x x n optimal
proof contradiction global ordering optimal notice optimal
assume strictly better ordering according lemma exists x block
subgraph induced subset nodes contains nodes edges whose ends belong



fis trasser b otea h arabor

ordering least good
n g g n

x

n

x

n





n

n g g n g g
contradiction strictly better e n g g n g g
lemma g tree depth first preorder g arbitrary root rotated
x block order every node x
proof every preorder induces rooted tree respect root every node x except root
parent p possibly empty sequence direct children c cn ordered way
depth first search visited removing x g decomposed subgraphs gp
gc gcn x root gp empty graph order following structure
nodes gp x nodes gc nodes gcn remaining nodes gp clearly
rotated x block ordering
theorem g v e tree depth first preorder g n g g v
proof direct consequence lemma every node v many runs v
v degree node comes v singleton thus
n g g

x
vv

v e v v

theorem computing optimal order graph g fixed parameter tractable size
largest two connected component g e largest component articulation points
proof recursively decompose g articulation points two connected parts left
size parts depend size g enumerate orders pick
best one given optimal orders every part use theorem construct optimal global
order
able decompose graphs along articulation points useful real world road networks
graphs tend large two connected component many small trees attached example europe graph made available th dimacs challenge demetrescu goldberg
johnson nodes total within largest twoconnected component allows us position nodes order fast optimally
local information


fic ompressing ptimal paths run l ength e ncoding

heuristic node orderings
sections shown computing optimal order np hard theory fortunately np hardness rule existence good heuristic orderings
computed quickly indeed simple depth first preorder works well practice observation partially explained fact shown section depth first preorder
optimal trees however explain informal intuitive terms
ordering good neighboring nodes graph assigned neighboring ids
consistent previous observation sankaranarayanan et al botea two
target nodes close chances first move current node towards
targets depth first preorder achieves goal assigning close ids
neighboring nodes low degree graphs node interior node root leaf
dfs tree nodes graph tend interior nodes depth first preorder
assign two neighboring nodes adjacent ids denote v internal node p parent
c first child v id p id v minus whereas id c id
v plus one guarantee nothing children however average node degree
low case example road graphs many children
besides depth first preorders propose another heuristic intuition assigning close ids close nodes cuts formulated intuitive
optimization criterion formulated following every edge endpoints
close id obviously fulfilled edges reason proposed ordering tries identify small set edges property may violated
balanced edge cuts given graph n nodes want assign ids range n
recursive bisection first step bisects graph two parts nearly
equal node counts small edge cut size divides id range middle assigns
lower ids one part upper ids part continues recursively bisecting
parts dividing associated id ranges parts constant size left
described far free decide part assigns lower
upper id ranges reason augment tracking every node v two counters h v
v representing number neighbors guaranteed higher lower ids initially
counters zero every bisection ranges assigned iterates
edge cut increasing counters border nodes deciding two parts p q
gets ranges uses counters estimate id distance parts nodes around
evaluates
x
x
x
x
h v
v
h v
v
vq

vq

vp

vp

assigns higher ids p condition holds encounters part
small bisected assigns ids ordered v h v

compression
let denote uncompressed row first move matrix stated previously src
compresses list runs ordered start compressed rows vary size need
additional index array maps source node onto memory offset first run


fis trasser b otea h arabor

row corresponding arrange rows consecutively memory therefore end ss
row start row therefore need store row ends
memory consumption
required node ids encodable bits edge ids bits encode runs
start upper bits bit machine word value lower bits total memory
consumption therefore v r bytes r total number runs rows
v number offsets index array notice implementation assume
bytes per index entry sufficient equivalent saying r formula
easily adapted sizes e number bits node ids edge ids index entries
instance sum one node id one edge id k bytes j bytes sufficient
encode index run words number r fits j bytes formula becomes
j v k r bytes
computing rows
rows computed individually running variant dijkstras one every
source node compressed described detail section however depending
graph possible shortest paths unique may differ first edge therefore
possible multiple valid uncompressed rows exist tie break paths differently rows
may differ number runs therefore different compressed sizes minimize
compressed size row instead dijkstras compute one specific row
modify compute sets valid first move edges require
shortest st path must exist uses first edge maintains alongside
tentative distance array node set valid first move edges
relaxes edge u v decreasing v performs av au u w u v v
performs av av au restricted degree node store
sets bit bitfields set union performed bitwise operation
compressing rows run length encoding
every target compression method given set valid first move edges may pick one
minimizes compressed size formalize subproblem following given sequence
sets sequence ai ai minimizes number runs
subproblem solved optimally greedy begins
determining longest run
includes
done scanning ai ai
intersection empty j aj j aj chooses
value intersection matter assigns ai continues
determining longest run starts contains ai way procedure
iterated rows end reached optimal
optimal solution longest first run exists valid solution longer first run
optimal solution shorter first run transformed increasing first runs length
decreasing second ones without modifying values subsequences exchanged
without affecting surroundings conclude greedy strategy optimal


fic ompressing ptimal paths run l ength e ncoding


b


e


c





f









f e
f
e c
c

input

b src







x
x f e
f
e c
z

c mrc per row info

x

z c

mrc per group info

figure mrc applied toy graph figure reproduced convenience left
part b illustrates src input full runs rs every row part c groups x
z row row specific runs r finally part depicts runs r g shared
rows group

merging rows groups
compress individual rows exploited shortest paths often
first move close similar observation made close source nodes
compressed rows tend resemble want compress
data exploiting redundancy call technique multi row compression mrc
illustrate figure partition nodes groups store group information
shared nodes group row store information unique denote
g unique group node two runs different rows start value
bit pattern denote rs set runs row instead storing
row
whole set rs store group h intersection rows

store r h ih ri row store r rs rg recall query target
consists finding max x rs x notice formula
rewritten basic set logic max max x r x max x r g x
implemented two binary searches r stored ordered arrays note
need second index array lookup r g groups g
computing row groups
design close source nodes close node ids thus neighbouring rows motivates
restricting row run groupings group h rows j
rows j belong group optimal row run grouping computed
dynamic programming denote n maximum number runs saved compared
group compression restricted first n rows notice given n
want compute n obviously n row must part thet
last group suppose
last group length save total n n n ri runs
n different values enumerate brute force possible values
resulting running time n observe intersection large
groups often seems nearly empty therefore test values resulting
n heuristic


fis trasser b otea h arabor

queries
given source node target node determines first edge
shortest st path first determining start end compressed row
index array runs binary search determine run containing
corresponding edge id precisely searches run largest start
still smaller equal recall encode run single bit machine word
higher bits runs start reinterpret bits unsigned integers
consists binary search ordered bit integer largest element
larger e higher bits lower bits set
extracting path cpds extremely simple recursive procedure beginning start
node extract first move toward target follow resultant edge neighbouring
node repeat process target reached

experimental setup
evaluate work consider two types graphs road graphs grid graphs
cases assume node ids encoded within bit integers assume
use distinct value indicate invalid edge allows us encode
edge ids within bits note concatenation node id edge id fits
single bit machine word
experiments performed quad core cpu ghz mb combined cache gb ram running ubuntu compiled g
reported query times use single core
grid graphs
chosen three benchmark sets drawn real computer games first two sets
benchmark instances appeared grid path competition third
benchmark set consists two worst case maps terms size two maps available part
nathan sturtevants extended repository http movingai com benchmarks
part competition set
first benchmark set features maps come game dragon age origins
maps k nodes k edges average
second benchmark set features maps come game starcraft
maps k nodes edges average
third benchmark set comprises two large grids evaluate separately
largest maps available two games extended dragon age origins
set choose map called ost k nodes edges
extended starcraft set choose map called thefrozensea
k nodes edges note ost largest dragon age
origins map smaller average starcraft map
grid maps evaluation undirected feature two types
edges straight edges
weight diagonal edges weight


fic ompressing ptimal paths run l ength e ncoding

road graphs
case road graphs chosen several smaller benchmarks made available
th dimacs challenge demetrescu et al
york city map henceforth ny k nodes k edges
san francisco bay area henceforth bay k nodes k edges
finally state colorado henceforth col k nodes edges
three graphs travel time weights denoted suffix geographic distance weights
denoted available
comparisons
implemented two variants single row compression src row
merging optimization multi row compression mrc optimization compare
approaches two recent state art methods copa botea harabor b
rxl delling et al evaluate two variants copa first variant
denote copa g appeared gppc optimised grid graphs use original
c implementation available competition repository sturtevant
second variant denote copa r optimised road graphs described
botea harabor used original c implementation program version
well
rxl newest version hub labeling asked original authors
run experiments us presented experiments carried xeon e ghz compensate lower clock speed compared test machine
scale query times rxl factor important note
implementation rxl computes path distances instead first moves discussed section
make significant difference query times however unclear us whether
possible incorporate additional data needed first move computation compression
schemes presented delling et al reported rxl database sizes therefore
regarded lower bounds


evaluate two src mrc terms preprocessing time compression
performance query performance study impact range heuristic node orderings
metrics three variants distinguished suffix suffix cut
indicates node ordering balanced edge separators graph cutting technique described
section suffix dfs indicates node ordering depth first search traversal
described section suffix input shorter inp indicates order nodes taken
associated input file case grid graphs ordered nodes lexicographically first
x coordinates applicable compare work state art
first move copa r copa g compare recent hub labeling
technique known rxl space efficient fast variant called crxl


fis trasser b otea h arabor

benchmark
dimacs
dragon age origins
starcraft
ost
thefrozensea

average preprocessing time seconds
compute order
single row compression
multi row compression
cut
dfs
input
cut
dfs
input
cut
dfs
input





























n


n


n


n


n


n

table preprocessing time road grid graphs give average time required
compute node ordering ii total time required compute entire database src
mrc values given nearest second ost thefrozensea preprocessing experiments
run amd opteron cores ghz accelerate apsp computation
experiments smaller graphs clearly input order fully dominated therefore omit
numbers two larger test graphs n stands measured
graph
v

e
v

copag

cut

min k

q
k
med
k
avg k
q
k
max k















min
q
med
avg
q
max















k
k
k
k
k
k








db size mb
query time nano seconds
mrc
src
mrc
src
um copag
dfs inp cut dfs inp
cut dfs inp cut dfs
dragon age origins maps






































starcraft maps



















inp













table performance src mrc grid graphs use two sets taken
gppc compare copa g one winners competition measure size
compressed database mb ii time needed extract first query nanos values
rounded nearest whole number mb nano respectively baseline column um shows
size naive non compressed first move matrix

preprocessing time
table gives average preprocessing time src mrc road graphs two
competition sets time case dominated need compute full apsp table
previously commented apsp compression central point work
apsp computation preprocessing involves executing dijkstras repeatedly
resulting total running time n log n sparse graphs non negative weights
modern apsp techniques e g delling goldberg nowatzyk werneck succeeded
significantly reducing hidden constants behind big able exploit specific
graphs structures e g road graphs get running time however techniques
give benefit repeatedly running dijkstras asymptotic worst case


fic ompressing ptimal paths run l ength e ncoding

graph
name

v

e
v

bay
bay
col
col
ny
ny

k
k
k
k
k
k








db size mb
query time nano seconds
copa hub labels
mrc
src
copa hub labels
mrc
src
um
r rxl crxl cut dfs cut dfs
r rxl crxl cut dfs cut dfs


















table comparative performance src mrc copa r two recent hub labeling
report size um uncompressed matrix test one six graphs th dimacs
challenge measure database sizes mb ii time needed extract first query nanos
values rounded nearest whole number graph sizes rounded nearest thousand nodes

creating node order fast dfs requires fractions second even cut order
requires seconds average metis karypis kumar meanwhile
difference running times src mrc indicate multi row compression
add small overhead total time test instances
recorded preprocessing overhead order seconds
compression query performance
table give overview compression query time performance copa g
range src mrc variants competition benchmark sets measure query
performance run random queries source target nodes picked uniformly random
average running times
mrc outperforms src terms compression expense query time node orders
significantly impact performance src mrc cases cut yields smaller database
faster queries src mrc cut dfs convincingly outperform copa g
majority test maps terms space consumption query time
naive non compressed first move matrix impractical due large memory requirements size uncompressed matrix would v bits reflecting assumption
outgoing edge stored bits tables specify column um memory consumption uncompressed matrix example ost game graph k
non compressed matrix requires bit gb memory two orders magnitude higher mb respectively mb src cut respectively mrc cut
need larger graphs difference striking example thefrozensea largest
game graph k nodes leads mb mrc cut database compared gb noncompressed matrix hand smaller graphs matrix would fit memory
fetching moves would extremely fast one table lookup per move comparison
fetch one move method performs binary search compressed string whose length
larger usually much smaller v
table look performance road graphs compare copa r src mrc
rxl crxl main observations road graphs dfs leads smaller cpds
cut surprisingly lower average row lengths yield faster query times copa r dominated rxl src mrc src cut outperforms competitors several factors terms


fis trasser b otea h arabor

graph
name
ost
frozensea

v

e
v

k
k




db size mb
mrc
src
um
rxl crxl cut dfs cut dfs









hub labels

query time nano seconds
hub labels
mrc
src
rxl crxl cut dfs cut dfs






table performance src mrc large grid graphs nathan sturtevants extended repository
compare hub labeling methods rxl crxl report size um uncompressed matrix run tests thefrozensea drawn game starcraft ost comes
game dragon age origins measure database sizes mb ii time needed extract
first query nanos values rounded nearest whole number rxl crxl exploit graphs
undirected src mrc directed graphs space consumption rxl would double

graph
bay
bay
col
col
ny
ny
frozensea
ost

average row label
length
space bytes
src
sampg
src
sampg
cut dfs plain cut dfs




































table report average number hubs per label length number runs per row length
average space usage per node sampg plain src

speed rxl wins terms database size however factor gained space smaller
factor lost query time compared src crxl clearly wins terms space two
orders magnitude slower competition road graphs distance weights harder
travel time weights already known exploit similar graph features
rxl however interesting seemingly unrelated first move compression
incur penalties
table evaluate performance src mrc rxl crxl larger game
maps dropped copa r experiments smaller graphs clear
fully dominated road graphs space consumption src mrc lower
cut order dfs cut order clearly superior dfs game maps
ost src mrc beat rxl terms query time space consumption
thefrozensea rxl needs less space src mrc however note game maps rxl
gains factor exploiting graphs undirected src mrc
crxl employs powerful compression techniques specific shortest paths rxl use
uncompressed uses basic encoding techniques delta encoding
basic hl variant stores nodes distances explicitly needs memory refer
basic variant sampg plain sampg ordering used rxl plain refers
rxl describes several node orders however sampg order suggest rxl
crxl numbers use sampg



fic ompressing ptimal paths run l ength e ncoding


b


e


f


c






input graph

b computing rectangles

c list rectangles

figure copas rectangle decomposition toy example figures first
moves source node similar decompositions needed every source node

elementary hl encoding bytes per hub id bytes per distance value want
comparse src sampg plain therefore report table average number hubs
per label average number runs per row src reported number hubs per
label note directed graphs every node needs two labels forward backward label
undirected graphs two labels coincide one stored contrasts
src cannot exploit input graph undirected numbers table therefore
assume two hl labels needed per node better comparability hl need store
bit distance value bit node id bit edge id times
two labels per node total space consumption thus h bytes h average
number hubs per label src need store bit node id bit edge id per
run r bytes r average number runs per row table
seen sampg plain consistently occupies space src even though experiments
thus far suggest rxl compact basic compression techniques rxl therefore
important enough make performance ordering tip respect
space consumption
rxl advantages visible tables example require computing
apsp preprocessing step significantly reducing preprocessing time computes
besides first move shortest path distance
discussion
compared src mrc copa rxl copa recent successful technique creating compressed path databases one joint winners grid path
competition gppc regard copa current state art range pathfinding
including efficient storage extraction optimal first moves rxl newest
version hub labeling knowledge state art terms minimizing query times road graphs


fis trasser b otea h arabor

src mrc illustrated figures figure illustrates copa
works preprocessing better understanding section without intention fully
detailed description copa assumes every node graph labelled x coordinates
toy example rows columns shown figure copa iterates
nodes graph let n current node source node given iteration copa splits
map rectangles labels rectangle id outgoing edge n
target belongs given rectangle optimal move n towards precisely label
rectangle figure shows map decomposition source node rectangles depicted
dashed line three rectangles constructed figure one bottom left
size label e one top left size label one bottom right
size label f part b rectangle represented symbols upper
row left column width height label rectangles source node
concatenated lists nodes rectangles safely removed list
trimming skip example columns figure treated
separate string compressed sliding window compression run length
encoding
performed experiments large number realistic grid graphs used gppc
src mrc significantly improve query time compression power
copa large number experiments broad range input maps able extract
first move tens hundreds nano seconds factor faster copa
two main reasons src mrc performant vs copa uses less memory
query running time logarithmic cf linear label size
requires less memory copa part explanation stems differences sizes building blocks src mrc building
block rle run represented two numbers start run node id
thus requires log v bits value run edge id requires log
bits copa building block rectangle requires log v log bits actual
implementations src mrc store single bit machine word per run allows graphs nodes copa code used grid path
competition stores rectangle bits corresponding max node count
clearly size building blocks reason different compression
number rle runs src mrc differ total number rectangles
copa one optimal edge exists src mrc select edge
improve compression whereas copa sticks one arbitrary optimal edge
hand besides rectangle decomposition copa implements additional compression methods
list trimming run length encoding sliding window compression performed top
original rectangle decomposition botea harabor
asymptotic query time log k k number compressed
labels must searched comparison given source node copa stores corresponding
list rectangles decreasing order size rectangles checked order
worst case total number rectangle checks linear size list average number
much improved due ordering mentioned botea botea harabor
reason cpd faster rxl due basic query
underlying rxl consists merge sort merge two integer arrays formed forward
label backward label fast cache friendly operation needs look


fic ompressing ptimal paths run l ength e ncoding

entry resulting inherently linear time operation src hand builds upon
binary search slightly less cache friendly memory accesses sequential
logarithmic running time
one regard compressed src rows one sided labels st pair first move
determined label hl hand needs forward label
backward label hl labels tend less entries src labels however
hl entry needs space need store distance values addition node ids

grid path competition
recently submitted src cut src dfs edition gridbased path competition gppc sturtevant section give brief overview
competition short summary full description methodology employed
organisers well full account given sturtevant et al
competition setup
grid path competition features one hundred grid maps
three hundred thousand distinct instances drawn individual maps differ size
ranging several thousand several million nodes topography maps varied
many maps originating computer games starcraft dragon age origins dragon
age maps appearing part competition synthetically generated grids mazes
rooms randomly placed obstacles varying density edition competition
total different entries submitted different teams several entries variants
submitted team
entries employ symmetry breaking speed search entries bljps bljps jps
jps bucket roughly described extensions jump point search harabor
grastien jps harabor grastien entry nsubgoal makes use
multi level subgoal graphs uras koenig finally entry named bljps sub
hybrid makes use jump point search subgoal graphs
entry ch employs variation contraction hierarchies dibbelt et al
entries directly improve performance use faster
priority queues bucket trading optimality speed ra ra subgoal
entries use compressed path databases two src dfs src cut
incremental return optimal path one segment time must
called repeatedly target location returned two src dfs
src cut non incremental queried return complete path
unfortunately entries contained bugs therefore finish instances
src cut one therefore omit tables discussion

summary competition given table observe following


fis trasser b otea h arabor

entry


ra
bljps
jps
bljps

ra subgoal
jps bucket
bljps sub
nsubgoal
ch
src dfs
src dfs

averaged query time test paths
slowest move
first moves
full path
path
path
extraction


































preprocessing requirements
db size
time
mb
minutes























table grid path competition figures summarised
official competition appear sturtevant et al entries denoted
indicate approximate guaranteed shortest path
measurments bold indicate entry performed best regard single criterion
entries whose name bold fully pareto dominated respect every
criterion preprocessing running times time needed process test maps
cpd entries fastest methods competition across query time metrics includes fastest average time required extract complete optimal path
fastest average time extract first steps optimal path fastest average
time required extract single step optimal path
performing first move query faster resolution competitions microsecond timer even iteratively extracting edges path barely
measurable without finer timer resolution testing observed significant
amount query running time spent within benchmarking code provided
competition therefore opted submit two variants src dfs extracts path
whole benchmarking code thus run per path hand src dfs
extracts path one edge time allows measuring time needed individual
first move query unfortunately requires executing benchmarking code per
edge difference path extraction running times src dfs src dfs e
time spent benchmarking code
competitor able answer first move queries faster
full path extraction
entries database driven require generous amounts preprocessing time
storage space src dfs therefore largest total preprocessing time largest
total storage cost entries competition

conclusion future work
study creating efficient compressed path database cpd shortest path
oracle given two nodes weighted directed graph returns first move


fic ompressing ptimal paths run l ength e ncoding

optimal path connecting starting pairs first move matrix assume
given create oracles compact answer arbitrary first move queries
optimally many orders faster otherwise possible conventional online graph search
techniques employ run length encoding rle compression scheme throughout analyse
theoretical perspective empirical one main idea simple
look order nodes e columns input first move matrix good way
rle compressed size subsequently reduced
theoretical side finding optimal node ordering
general case directed directed graphs np complete specific cases
graphs decomposed along articulation points efficiently tackled
solving series independent sub particular depth first traversal
tree provides optimal node ordering give first theoretical underpinning
creating space efficient cpds rle work extends theoretical
areas information processing databases oswald reinelt mohapatra
empirical side study efficacy three heuristic node orderings depth first
ordering ii graph cut ordering balanced edge separators iii naive baseline given
ordering specified input graph given ordering first move matrix describe
two novel approaches creating cpds first src uses simple run length encoding
compress individual rows matrix second mrc sophisticated
identifies commonalities sets labels compressed src
range experiments src mrc compress apsp matrix graphs
hundreds thousands nodes little mb associated query times regularly
require less nanoseconds compare approaches copa botea
botea harabor rxl delling et al range experiments grid
road graphs src mrc competitive copa often several
factors better terms compression query times src mrc
outperform rxl terms query time summarise grid
path competition particular report src fastest method
competition across query time metrics src performed better resolution
competitions microsecond timer
appear several promising directions current work could extended one
immediate possibility harness available efficient appproximate tsp
order compute better space efficient node orderings another immediate possibility
improve current mrc compression scheme devising optimizes
assignment first move ids
looking broadly strength cpds addition fast move extraction
compress kind path network distance optimal
multi agent pathfinding example sometimes useful guarantee properties must
local detour available wang botea another example turn costs road
graphs thus one possible possible direction future work create cpds store
paths satisfying constraints
weakness preprocessing apsp computation required
delling et al shown apsp sometimes computed reasonably fast
suboptimal paths however introduce additional challenge avoiding infinite loops extracting path
cpd



fis trasser b otea h arabor

graphs many nodes apsp remains inherently quadratic number nodes
graph class output size quadratic would therefore hugely profit
directly compute compressed cpd without first computing first move
matrix intermediate step

acknowledgments
thank patrik haslum akihiro kishimoto jakub marecek anika schumman jussi rintanen
feedback earlier versions parts work would thank daniel delling
thomas pajor running hub labeling experiments us

appendix proof theorem
theorem simmini runs np complete
proof membership np straightforward hardness proof uses reduction
hamiltonian path hpp undirected graph let g v e arbitrary undirected
graph without duplicate edges define n v e e figure shows toy graph used
running example
starting g build simmini runs instance follows define matrix
e rows n columns let r row corresponding edge u v let cu cv
columns associated nodes u v r cv r cu r c
columns notice least value every row column figure shows
matrix running example
x



w

z

figure sample graph g
let r matrix row corresponding edge u v easy see given
ordering columns nodes makes two nodes u v adjacent number sequential

x
x w
x z
w z

x











w





z





figure matrix built g


fic ompressing ptimal paths run l ength e ncoding

x z
w z
x w
x







x





w





z





figure matrix converting shown bold ii ordering columns
hamiltonian path iii ordering rows lexicographically

x z
w z
x w
x







x





w





z





figure matrix restoring back previously replaced shown bold
rle runs row r nodes adjacent number sequential rle runs
row r
claim hpp solution iff simmini runs solution e n rle
runs let vi vin solution hpp e hamiltonian path let p set
edges included solution running example let p contain x x w w z
every row corresponding edge contained p switch one two entries
order columns respect sequence nodes hamiltonian path
rearrange rows lexicographical order figure illustrates changes
construction matrix trick converting ordering
rows columns reused oswald reinelts proof hardness deciding
whether matrix c sk property oswald reinelt rest proof
coming significantly different
restore previously replaced shown figure e n
replaced restored adjacent matrix counts two
runs one horizontal one vertical sums total e n runs corresponding
replaced restored addition row column one run follows
matrix e n runs
conversely consider row column ordering creates e n rle runs total
matrix least e vertical runs regardless row ordering consider
rows order starting top first row introduces exactly vertical runs one
column contains value subsequent row introduces least one vertical
run otherwise row would identical previous one contradicts fact
graph duplicate edges
runs used proof sequential
adjacent column would imply two identical rows would mean
g duplicate edges adjacent row would mean edge hand belongs
hamiltonian path contradicts fact replaced restored complementary set edges



fis trasser b otea h arabor

least e vertical runs number horizontal runs
e n e e n column ordering hamiltonian path
assuming contrary p n edges nodes adjacent
ordering follows number horizontal runs p e p e p e n
contradiction

appendix b proofs lemma lemma
start pointing two simple important properties stemming notion articulation point
remark given graph g let x articulation point let g gn corresponding
connected components obtained removing x
given source node gi first optimal move towards anywhere outside gi

given two distinct components gi gj first optimal move x towards anywhere
gi different first optimal move x towards anywhere gj
remark follows easily obvious observation way going one
subgraph gi another subgraph gj passing x see figure illustration
lemma let x articulation point graph g every node order rearranged
x block ordering without increasing number runs row
proof construct desired ordering applying following steps
rotate x comes first
every n project resulting order onto gi obtaining suborder
define x n
clear construction nodes every subgraph gi consecutive remains
number runs per row grow
denote source node distinguish two cases
case gi rotation
step impact number

cyclic runs steps take nodes k gk put one two blocks
cyclic
adjacent x know remark point x n
nodes n k gk thus arrangement brings next x nodes n
first move symbol x clearly increase number runs
case x previous case rotation performed step increase
number cyclic runs step cyclic runs sequential runs equivalent since
first position contains distinct symbol namely x singleton steps separate
assuming split ties among optimal paths consistent manner easy ensure



fic ompressing ptimal paths run l ength e ncoding

gi contiguous block increase number sequential runs since
according remark point every two blocks corresponding gi gj j
common symbol follows number cyclic runs increase

lemma given x block ordering
n g gi n gi
p
n g x n n x
p
n g g n n
proof prove point follows
x block ordering nodes come order x g gi gn consider
node gi corresponding row first move matrix pointed remark
every path node outside gi pass x therefore first move
anywhere outside gi follows nodes sequence x g gi
together nodes sequence gi
gn form one cyclic run effect removing
consideration nodes contained k gk leaves number runs unchanged
completes proof case
case focused x start node according remark gi gj
first move x towards anywhere gi different first move x towards
anywhere gj follows two runs two adjacent subsets gi gi never merge
one run thus
x
n g x
n x


n

x


n x

case follows previous two standard arithmetic manipulation
x
n g g n g x
n g gi


n

x

n

x
n x n gi



n x

x



x
n
n x gi


n

x

n





n gi



fis trasser b otea h arabor

references
abraham delling fiat goldberg v werneck r f hldb locationbased services databases proceedings th acm sigspatial international
symposium advances geographic information systems gis pp acm
press best award
abraham delling goldberg v werneck r f hub labeling
shortest paths road networks proceedings th international symposium
experimental sea vol lecture notes computer science pp
springer
abraham delling goldberg v werneck r f hierarchical hub labelings
shortest paths proceedings th annual european symposium
esa vol lecture notes computer science pp springer
akiba iwata yoshida fast exact shortest path distance queries large networks pruned landmark labeling proceedings acm sigmod international
conference management data sigmod pp acm press
antsfeld l harabor kilby p walsh transit routing video game maps
aiide
arz j luxen sanders p transit node routing reconsidered proceedings
th international symposium experimental sea vol lecture
notes computer science pp springer
babenko goldberg v kaplan h savchenko r weller complexity hub labeling proceedings th international symposium mathematical
foundations computer science mfcs lecture notes computer science springer
baier j botea harabor hernandez c fast catching prey
quickly known partially known game maps computational intelligence ai
games ieee transactions pp
bast h delling goldberg v mullerhannemann pajor sanders p wagner
werneck r f route transportation networks tech rep abs
arxiv e prints
bast h funke matijevic ultrafast shortest path queries via transit nodes
shortest path ninth dimacs implementation challenge vol dimacs
book pp american mathematical society
bast h funke matijevic sanders p schultes transit constant shortestpath queries road networks proceedings th workshop engineering
experiments alenex pp siam
bauer r columbus katz b krug wagner preprocessing speed
techniques hard proceedings th conference complexity
ciac vol lecture notes computer science pp springer
bauer r columbus rutter wagner search space size contraction hierarchies proceedings th international colloquium automata languages


fic ompressing ptimal paths run l ength e ncoding

programming icalp vol lecture notes computer science pp
springer
bellman r routing quarterly applied mathematics
botea ultra fast optimal pathfinding without runtime search proceedings seventh aaai conference artificial intelligence interactive digital entertainment aiide pp aaai press
botea fast optimal pathfinding compressed path databases proceedings
symposium combinatorial search socs
botea baier j harabor hernandez c moving target search compressed
path databases proceedings international conference automated
scheduling icaps
botea harabor path compressed pairs shortest paths data
proceedings rd international conference automated scheduling
aaai press
botea harabor b path compressed pairs shortest paths data
proceedings international conference automated scheduling icaps
botea strasser b harabor complexity compressing optimal paths
proceedings national conference ai aaai
bulitko v bjornsson lawrence r case subgoaling real time heuristic
search video game pathfinding j artif intell res jair
bulitko v rayner c lawrence r case base formation real time heuristic
search proceedings eighth aaai conference artificial intelligence interactive digital entertainment aiide stanford california october
cohen e halperin e kaplan h zwick u reachability distance queries via
hop labels proceedings thirteenth annual acm siam symposium discrete
soda pp philadelphia pa usa society industrial applied mathematics
culberson j c schaeffer j pattern databases computational intelligence

delling goldberg v nowatzyk werneck r f phast hardwareaccelerated shortest path trees journal parallel distributed computing

delling goldberg v pajor werneck r f robust distance queries massive
networks proceedings nd annual european symposium esa
vol lecture notes computer science pp springer
delling goldberg v werneck r f hub label compression proceedings
th international symposium experimental sea vol
lecture notes computer science pp springer
demetrescu c goldberg v johnson eds shortest path ninth
dimacs implementation challenge vol dimacs book american mathematical
society


fis trasser b otea h arabor

dibbelt j strasser b wagner customizable contraction hierarchies proceedings
th international symposium experimental sea vol
lecture notes computer science pp springer
dijkstra e w note two connexion graphs numerische mathematik

felner korf r e meshulam r holte r c compressed pattern databases j
artif intell res jair
ford jr l r network flow theory tech rep p rand corporation santa monica
california
geisberger r sanders p schultes delling contraction hierarchies faster
simpler hierarchical routing road networks proceedings th international
conference experimental wea pp
harabor grastien online graph pruning pathfinding grid maps burgard w roth eds proceedings twenty fifth aaai conference artificial
intelligence aaai san francisco california usa august aaai press
harabor grastien improving jump point search chien b
fern ruml w eds proceedings twenty fourth international conference
automated scheduling icaps portsmouth hampshire usa june
aaai
hart p e nilsson n raphael b formal basis heuristic determination
minimum cost paths ieee transactions systems science cybernetics
hernandez c baier j fast subgoaling pathfinding via real time search
proceedings international conference automated scheduling icaps
karypis g kumar v metis software package partitioning unstructured graphs
partitioning meshes computing fill reducing orderings sparse matrices version
kou l polynomial complete consecutive information retrieval siam journal
computing
lawrence r bulitko v database driven real time heuristic search video game
pathfinding computational intelligence ai games ieee transactions

mohapatra optimal sort ordering column stores np complete tech rep stanford university
oswald reinelt g simultaneous consecutive ones theoretical computer science
samadi siabani felner holte r compressing pattern databases
learning proceedings conference ecai th european conference
artificial intelligence pp amsterdam netherlands netherlands ios
press


fic ompressing ptimal paths run l ength e ncoding

sankaranarayanan j alborzi h samet h efficient query processing spatial networks proceedings th annual acm international workshop geographic information systems gis pp
strasser b harabor botea fast first move queries run length encoding proceedings symposium combinatorial search socs
sturtevant n grid path competition https code google
com p gppc
sturtevant n b website grid path competition http
movingai com gppc
sturtevant n website grid path competition http
movingai com gppc
sturtevant n traish j tulip j uras koenig strasser b botea harabor
rabin grid path competition entries
proceedings th international symposium combinatorial search socs aaai
press
uras koenig identifying hierarchies fast optimal search brodley c e
stone p eds proceedings twenty eighth aaai conference artificial intelligence
july quebec city quebec canada pp aaai press
uras koenig hernandez c subgoal graphs optimal pathfinding eightneighbor grids proceedings international conference automated
scheduling icaps
van schaik j de moor memory efficient reachability data structure bit
vector compression proceedings acm sigmod international conference
management data sigmod pp york ny usa acm
wang k h c botea mapp scalable multi agent path
tractability completeness guarantees journal artificial intelligence jair





