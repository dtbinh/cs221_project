journal artificial intelligence

submitted published

exact query reformulation databases
first order description logics ontologies
enrico franconi
volha kerhet
nhung ngo

franconi inf unibz
kerhet inf unibz
ngo inf unibz

free university bozen bolzano italy

abstract
study general framework query rewriting presence arbitrary
first order logic ontology database signature framework supports deciding
existence safe range first order equivalent reformulation query terms
database signature provides effective construct reformulation interpolation standard theorem proving techniques e g tableau
since reformulation safe range formula effectively executable sql query
end present non trivial application framework ontologies
expressive alchoiq description logic providing effective means compute
safe range first order exact reformulations queries

introduction
address query reformulation expressive ontologies databases
ontology provides conceptual view database composed constraints
vocabulary extending basic vocabulary data querying database
terms richer ontology allows flexibility basic
vocabulary relational database directly
study develop query rewriting framework applicable knowledge
representation systems data stored classical finite relational database way
literature called locally closed world assumption etzioni golden
weld exact views marx nash segoufin vianu fan geerts
zheng dbox seylan franconi de bruijn franconi ibanez garcia
seylan dbox set ground atoms semantically behaves
database e interpretation database predicates dbox exactly equal
database relations dbox predicates closed e extensions
every interpretation whereas predicates ontology open e
extensions may vary among different interpretations consider
open interpretation database predicates called abox sound views
abox interpretation database predicates contains database relations possibly
notion less faithful representation database semantics since would
allow spurious interpretations database predicates additional unwanted tuples
present original database
general framework ontology set first order formulas queries
possibly open first order formulas within setting framework provides precise
semantic conditions decide existence safe range first order equivalent reformulac

ai access foundation rights reserved

fifranconi kerhet ngo

tion query terms database signature provides effective
construct reformulation sufficient conditions interested safe range reformulations queries range restricted syntax needed reduce original
query answering relational algebra evaluation e g via sql original
database abiteboul hull vianu framework points several conditions
ontologies queries guarantee existence safe range reformulation
conditions feasible practice provide efficient method
ensure validation standard theorem proving techniques used compute
reformulation
order complete framework applicable ontologies queries expressed
fragment first order logic enjoying finitely controllable determinacy nash et al
stronger property finite model property logic employed logic
enjoy finitely controllable determinacy would become sound
incomplete still effectively implementable standard theorem proving techniques
explored non trivial applications framework complete
application alchoiq ontologies concept queries discussed
check whether answers given query ontology solely determined
extension dbox predicates ii equivalent rewriting
query terms dbox predicates allow use standard database technology
answering query means benefit low computational complexity
size data answering queries relational databases addition possible
reuse standard techniques description logics reasoning rewritings
seylan et al
query reformulation received strong interest classical relational
database well modern knowledge representation studies differently
mainstream query reformulation halevy mostly
perfect maximally contained rewritings sound views relatively inexpressive constraints see e g dl lite artale calvanese kontchakov zakharyaschev focus exact rewritings exact views since characterises
precisely query answering ontologies databases case
exact semantics database must preserved example consider ground negative query given standard relational database adding ontology top
answer supposed changesince query uses signature database
additional constraints supposed change meaning querywhereas
database treated abox sound views answer may change presence
ontology may important application perspective dbox preserves
behaviour legacy application queries relational database moreover
focussing exact reformulations definable queries opposed considering certain
answer semantics arbitrary queries dl lite guarantee answers
queries subsequently composed arbitrary way may important legacy
database applications
work extends works exact rewritings exact views marx
nash et al focussing safe range reformulations conditions ensuring
existence considering general first order ontologies extending database
signature rather local view constraints database predicates halevy


fiexact query reformulation dbs fo dl ontologies

extends papers franconi kerhet ngo b
providing precise semantic characterisation existence exact reformulation
theorem opposed sufficient conditions considering much expressive description logic alchoiq providing proofs
organised follows section provides necessary formal background
definitions section introduces notion query determined database section introduces characterisation query reformulation sections
conditions allowing effective reformulation analysed sound complete compute reformulation introduced finally present case
alchoiq ontologies proofs presented details appendix

preliminaries
let fol c p classical function free first order language equality signature
c p c finite set constants p set predicates associated
arities rest refer arbitrary fragment fol c p
called l
denote p n set predicates occurring formulas n
c n set constants occurring formulas n sake
brevity instead p resp c write p resp c denote n
signature formulas n namely union p n c n
denote arity predicate p ar p given formula denote set
variables appearing var set free variables appearing
free may use notation x x free possibly empty
set free variables formula
database instance db finite set ground atoms form p c cn
p p n ary predicate ci c n set predicates appearing
database db denoted pdb set constants appearing db called
active domain db denoted cdb possibly empty finite set kb closed
formulas called ontology
usual interpretation hi includes non empty setthe domain
interpretation function defined constants predicates signature say
interpretations hi j hj j equal written j j
j interpretation embeds database db holds ai every
database constant cdb standard name assumption sna customary databases
see abiteboul et al c cn p p c cn db
denote set interpretations embedding database db e db
words every interpretation embedding db interpretation
database predicate given exactly content database
general case interpretation non database predicates
say database predicates closed predicates open
may interpreted differently different interpretations consider open
world assumption abox embedding database interpretation open
world interpretation soundly embeds database holds c cn p
p c cn db


fifranconi kerhet ngo

order allow arbitrary database embedded generalise standard
name assumption constants c implies domain interpretation
necessarily includes set constants c finiteness c corresponds
finite ability database system represent distinct constant symbols c meant
unknown advance since different database systems may different limits
see framework introduced depend choice c
given interpretation hi denote interpretation restricted
smaller signature p c e interpretation domain
interpretation function defined constants predicates set
semantic active domain signature p c interpretation denoted
adom set elements domain occurring interpretations
predicates constants
adom





p p





ci

c

pdb c interpretations j embedding db
adom adom j case introduce notation adom db
adom interpretation embedding database db intuitively
adom db includes constants db appearing relations corresponding predicates
let x set variable symbols set substitution total function x
assigning element variable x including empty substitution
x domain image range substitution written dom rng
respectively given subset set constants c c write formula x
true interpretation free variables substituted according substitution
x c x given interpretation hi subset
domain write formula x true free variables
interpreted according substitution x extension domain
asformula x respect interpretation defined set domain elements
rng dom x rng x
usual interpretation closed formula true called model
formula set formula resp kb denoted resp
kb database db legal ontology kb exists model kb embedding
db following consider consistent non tautological ontologies legal
databases
queries
query possibly closed formula given query q x define certain answer
kb db follows
definition certain answer certain answer query q x database db
ontology kb set substitutions constants
dom x rng c kb e db q x


fiexact query reformulation dbs fo dl ontologies

query answering defined entailment going
high complexity entailment
note query q closed e boolean query certain answer
q true ontology embedding database otherwise
following assume closed formula q x neither valid inconsistent
ontology kb given substitution x c assigning variables distinct constants
appearing q kb cdb would lead trivial reformulations
weaken standard name assumption constants
assuming unique names without changing certain answers said
interpretation satisfies standard name assumption ci c c c alternatively interpretation satisfies unique name assumption una ai bi
different b c denote set interpretations satisfying standard name
assumption sna denote set interpretations satisfying unique name
assumption una following proposition allows us freely interchange standard name unique name assumptions interpretations embedding databases
practical advantage since encode unique name assumption classical
first order logic reasoners many description logics reasoners support natively
unique name assumption extension owl
proposition sna vs una query q x ontology kb database db
dom x rng c sna kb e db q x
dom x rng c una kb e db q x
since query arbitrary first order formula answer may depend
domain know advance example query q x student x
database student student b domain b c answer x c
domain b c answer x c x therefore notion
domain independent queries introduced relational databases adapt
classical definitions avron abiteboul et al framework need
general version domain independence namely domain independence w r
ontology e restricted ontology
definition domain independence formula q x domain independent
respect ontology kb iff every two j kb e hi
j hj j agree interpretation predicates constants e
j every substitution x j
rng q x iff
rng j j q x
definition reduces classical definition domain independence whenever
ontology empty
weaker version domain independencewhich relevant open formulasis
following
definition ground domain independence formula q x ground domain independent iff q x domain independent every substitution x c


fifranconi kerhet ngo

example formula p x ground domain independent domain independent
checking whether fol formula domain independent undecidable
abiteboul et al well known safe range syntactic fragment fol introduced
codd equally expressive language indeed safe range formula domain independent domain independent formula easily transformed logically
equivalent safe range formula intuitively formula safe range variables
bounded positive predicates equalities full details see appendix
example formula x b x safe range queries x x x
check whether formula safe range formula transformed logically
equivalent safe range normal form range restriction computed according set
syntax rules range restriction formula subset free variables
coincides free variables formula said safe range abiteboul
et al similar domain independence formula ground safe range grounding formula safe range ontology kb safe range domain independent
every formula kb safe range domain independent
safe range fragment first order logic standard name assumption
equally expressive relational algebra core sql abiteboul et al


determinacy
certain answer query includes substitutions make query true
ontology embedding database substitution would make
query true model would discarded certain answer
words may case answer query necessarily among
ontology embedding database case query fully
determined given source data indeed answer possible
certain due indeterminacy query respect data complexity
compute certain answer general increases complexity entailment
logic focus case query answer
ontology embedding database namely information requested
query fully available source data without ambiguity way
indeterminacy disappears complexity process may decrease see section
determinacy query w r source database nash et al marx fan
et al called implicit definability formula query set
predicates database predicates beth
definition finite determinacy implicit definability query q x finitely
determined implicitly definable database predicates pdb kb iff
two j ontology kbboth finite interpretation
database predicates pdb whenever pdb c j pdb c every substitution
x q x iff j q x
intuitively answer implicitly definable query depend interpretation non database predicates database domain fixed never


fiexact query reformulation dbs fo dl ontologies

case substitution would make query true model ontology
false others since truth value implicitly defined query depends
interpretation database predicates constants domain
fixed practice focussing finite determinacy queries guarantee user
interpret answers certain exactnamely
whatever answer never part answer possible world
following focus ontologies queries fragments fol c p
determinacy finite interpretation database predicates finite
determinacy determinacy unrestricted interpretation database
predicates unrestricted determinacy coincide say fragments finitely
controllable determinacy require whenever query finitely determined
determined unrestricted reverse trivially true indeed
would fail finite determinacy unrestricted determinacy coincide
shown gurevich theorem fails consider
finite interpretation database predicates
example example database theory let p p r pdb p r
kb x z r x r x z z
x r x z r z x
x r x z r z x x p x
formula x r x z r z entailed first two formulas
finite interpretations r query q x finitely determined p equivalent
p x finite interpretation r determined
database predicate unrestricted interpretation r knowledge
base enjoy finitely controllable determinacy
exact reformulation query nash et al called explicit definition
beth formula logically equivalent query makes use database
predicates constants
definition exact reformulation explicit definability query q x explicitly definable database predicates pdb ontology kb iff
b x fol c p kb x q x q
b x q
b pdb call
formula q
b x exact reformulation q x kb pdb
formula q
determinacy query completely characterised existence exact reformulation query well known first order query determined database
predicates exists first order exact reformulation
theorem projective beth definability beth query q implicitly definable database predicates pdb ontology kb iff explicitly definable
b fol c p pdb kb
formula q
e formula obtained uniformly replacing
let q formula l q
every occurrence non database predicate p predicate pe extend
renaming operator e set formulas natural way one check whether query
implicitly definable following theorem
theorem testing determinacy beth query q x implicitly definable
g x q x q
e x
database predicates pdb ontology kb iff kb kb



fifranconi kerhet ngo

exact safe range query reformulation
section analyse conditions original query answering
corresponding entailment reduced systematically model checking
safe range formula database e g database system
sql given database signature pdb ontology kb query q x expressed l
determined database predicates goal safe range reformulation
b x q x fol c p evaluated relational algebra expression
q
legal database instance gives answer certain answer q x database
kb reformulated following
exact safe range query reformulation exact reformulation
b x q x kb safe range query fol c p pdb
q
since exact reformulation equivalent ontology original query
certain answer original query reformulated query identical
precisely following proposition holds
proposition given database db let q x implicitly definable pdb kb
b x exact reformulation q x kb pdb
let q
dom x rng c kb e db q x
b x
dom x rng c kb e db q
equation clear order answer exactly reformulated query
one may still need consider ontology embedding database e
still entailment solve following theorem states condition
reduce original query answering problembased entailmentto
checking validity exact reformulation single model condition
reformulation domain independent indeed one interpretation
particular domain embedding database signature restricted
database predicates
theorem adequacy exact safe range query reformulation let db
b x exact domain
database legal kb let q x query q
independent safe range reformulation q x kb pdb
dom x rng c kb e db q x
b db hc e db p
dom x rng adom q

db c

b x
q

safe range reformulation necessary transform first order query relational
algebra query evaluated sql techniques theorem
shows addition safe range sufficient property exact reformulation correctly evaluated sql query let us see example
cannot reduce answering exact reformulation model checking
database exact reformulation safe range
example let p p pdb p c
db p kb p
b x p x e x x
q x q


fiexact query reformulation dbs fo dl ontologies

c includes active domain cdb actually equal
db legal kb h p ai
obviously kb
dom x rng c kb e db q x
one take h b p ai b kb
e db possible substitution x p
however
b db hc e db p c q
b x
dom x rng adom q
db

x
seen answers query reformulation exists contain
constants active domain database query therefore ground statements ontology involving non database predicates non active domain constants
example abox statements play role final evaluation
reformulated query database

conditions exact safe range reformulation
seen importance getting exact safe range query reformulation
section going study conditions exact safe range query
reformulation exists
first focus semantic notion safe range namely domain independence implicit definability isas already knowa sufficient condition
existence exact reformulation guarantee alone existence domain
independent reformulation
example let p b pdb kb x b x x q b x
q implicitly definable pdb kb every exact reformulation q
pdb kb logically equivalent x domain independent
looking example seems reason non domain independent
reformulation lies fact ontology domain independent cannot guarantee existence exact domain independent reformulation non domain independent
query however let us consider following example
example let pdb c kb
b c x easy see kb
implicitly definable pdb kb
independent reformulation q

x x b x let query q
domain independent q q
b c x exact domain
q

obvious spite fact query q domain independent
domain independent respect ontology kb words case
ontology guarantees existence exact domain independent reformulation
queries domain independent respect ontology following
theorem holds giving semantic requirements existence exact domain
independent reformulation


fifranconi kerhet ngo

theorem semantic characterisation given set database predicates pdb
domain independent ontology kb query q x domain independent exact reformub x q x pdb kb exists q x implicitly definable
lation q
pdb kb domain independent respect kb
theorem shows us semantic conditions exact domain independent reformulation query give us method compute reformulation equivalent safe range form following theorem gives us sufficient
conditions existence exact safe range reformulation decidable fragment
fol c p finite unrestricted determinacy coincide gives us constructive
way compute exists
theorem constructive
g x q x q
e x q x implicitly definable
kb kb
q x safe range q x domain independent
kb safe range kb domain independent
b x q x safe range query fol c p
exists exact reformulation q
pdb kb obtained constructively
order constructively compute exact safe range query reformulation use
b x
tableau method craigs interpolant fitting compute q
gq
e x see section full details
validity proof implication kb q x kb
let us consider fully worked example adapted nash et al

example given p r v v v pdb v v v adom adom
active domain db
kb x v x z v r z x r z v r v
x v x z r x z r z
x v x z v r x z r z v r v
q x z v u r z x r z v r v u r u
conditions theorem satisfied q x implicitly definable pdb
kb q x safe range kb safe range
b
therefore tableau method one finds craigs interpolant compute q x
g
e
b
validity proof implication kb q x kb q x obtain q x
z v x z v v v z v v exact ground safe range reformulation since
b adom x
answer q active domain kb q x
b
adom kb q x q x adom x adom therefore z v x z
v v v z v v adom x adom exact safe range reformulation q x
pdb kb


fiexact query reformulation dbs fo dl ontologies

constructing safe range reformulation
section introduce method compute safe range reformulation implicitly
definable query conditions theorem satisfied method
notion interpolant introduced craig
definition interpolant sentence interpolant sentence
fol c p predicate constant symbols set predicate
constant symbols valid sentences
fol c p
theorem craigs interpolation valid sentence fol c p
neither valid exists interpolant
note beth definability theorem craigs interpolation theorem
hold fragments fol c p interpolant may expressed
fragment obviously fol c p theorem
interpolant used exact reformulation given implicitly definable
query follows
theorem interpolant definition let q x query n free variables
implicitly definable database predicates pdb ontology kb
closed formula c cn distinct constant symbols c appearing kb q x


g q
e x c c
kb q x c cn kb

n

b c c x exact reformulation q x kb
valid interpolant q
n

pdb
therefore exact reformulation implicitly definable query terms
database predicates enough interpolant implication
substitute constants c cn back free variables x original query
interpolant constructed validity proof automated theorem
proving techniques tableau resolution order guarantee safe range
property reformulation use tableau method book fitting
tableau method compute interpolant
section recall context tableau method compute interpolant fitting
assume valid therefore unsatisfiable closed tableau
corresponding order compute interpolant tableau one needs
modify biased tableau
definition biased tableau biased tableau formulas tree v e

v set nodes node labelled set biased formulas biased formula
expression form l r formula node n
n denotes set biased formulas labelling n


fifranconi kerhet ngo

root tree labelled l r
e set edges given nodes n n n n e iff biased
completion rule n n say biased completion rule n
n
applying rule x x refer l r
rules two possibilities choosing
n n x
let c set constants input formulas tableau c par extends c
infinite set constants constant occur anywhere
tableau notations following rules
propositional rules
x
x

negation rules
x
x

rule
x

x
x

x
x

rule
x
x x

first order rules
rule
x x

rule
x x

x
c par

x c
constant c

equality rules
reflexivity rule

replacement rule
x u


x


x
occurs

u

c par

node tableau closed contains x node closed
rule applied words becomes leaf tree branch closed
contains closed node tableau closed branches closed obviously
standard tableau fol closed biased tableau vice versa
given closed biased tableau interpolant computed applying interpolant rules
int
interpolant rule written formula
l l l n r r r
rules closed branches
int

int

r l l

r r r

int

int

r l

r r
int

int

r l r

r r l


fiexact query reformulation dbs fo dl ontologies

rules propositional cases
int
x
p

p

p

int

p

int

x
int
x x

x
int

int

p

x
int

x
x
int
int
l l
p

int

int

x
l
int
int
r r
int

r
rules first order cases
int
x p
f

f

f

f

f

p parameter occur

int

x x x
int
l c
int

c occurs n

l x x
int
r c
int

c occurs

r x x
int
l c
int

l x x x c x
int
r c
int

c occur n
c occur

r x x x c x
rules equality cases
int
x p x
e

e

int

int

e

x p
int
l u r u
int

x u x u
int

x x u
u occurs

l r u u
int
r u l u

u occurs
int
r l u u
int
l u r u
e
u occur
int
l r u u
int
r u l u
e
u occur
int
r l u u
e

summary order compute interpolant one first need generate
biased tableaux proof unsatisfiability biased completion rules
apply interpolant rules bottom leaves root
let us consider example demonstrate method works
example let p g u pdb u


fifranconi kerhet ngo

kb x x g x u x
x g x x
x u x x
x g x u x
q x g x
obviously q implicitly definable u since ontology states g
u partition follow tableau method exact reformulation
int
compactness use notation instead
l x x g x u x
l x g x x
l x u x x
l x g x u x
l g c
r x x g x u x
r x g x x
r x u x x
r x g x u x
r g c
applying rule removing implication
l c g c u c
l g c c
l u c c
l g c u c
l g c
r c g c u c
r g c c
r u c c
r g c u c
r g c
interpolant computed follows
r c c

r u c u c

r c u c c u c



r g c

c u c

b

l g c

l u c

c u c

l c

c u c

b

l g c

b



b
therefore c u c interpolant q x
x u x exact reformulation
q x


fiexact query reformulation dbs fo dl ontologies

safe range reformulation
input safe range kb safe range implicitly definable query q x
output exact safe range reformulation
b x theorem
compute interpolant q
b x
free variable x bounded positive predicate q
b x q
b x adom b x
q
q
b x
return q

safe range reformulation
want reformulation computed tableau method
condition theorem generates ground safe range query
theorem ground safe range reformulation let kb ontology let q
query implicitly definable pdb kb q safe range rewritten
b obtained tableau method described section ground safe range
query q
words conditions theorem guarantee quantified variables
reformulation range restricted need consider still unsafe free variables
theorem help us deal non range restricted free variables let us first
define active domain predicate query q safe range formula
adom q x
w
w
p pq z zar p p x z zar p p z zar p x
ccq x c

theorem range query let kb domain independent ontology let
q x xn query domain independent respect kb
kb x xn q x xn adom q x adom q xn
given safe range ontology safe range implicitly definable query obviously
domain independent respect ontology case theorem says
answer reformulation include active domain elements therefore active
domain predicate used guard free variables bounded
positive predicate
theorem theorem propose complete procedure construct
safe range reformulation

guarded negation fragment alchoiq
alchoiq extension description logic alc role hierarchies individuals
inverse roles qualified cardinality restrictions corresponds shoiq description logic without transitive roles logic basis owl syntax
semantics alchoiq concept expressions summarised figure
atomic concept c concepts individual name p atomic role
r p p forall qualified unqualified atmost operators
derived negation atleast operator usual way tbox alchoiq


fifranconi kerhet ngo

syntax


p
p
c
c ud
c td
nr
nr c

semantics
ai
oi
p
x x p
c
c di
c di
x x ri n
x x ri c n

figure syntax semantics alchoiq concepts roles
set concept inclusion axioms c v role inclusion axioms r v c
concepts r roles usual description logics semantics
section present application theorem introducing alchoiqgn
description logic guarded negation syntactic fragment alchoiq figure
happens express exactly domain independent concepts tboxes alchoiq
language restricts alchoiq prescribing negated concepts
guarded generalised atom atomic concept nominal unqualified atleast
number restriction e absolute negation forbidden similarly derived forall
atmost operators would guarded standard definition dual
atleast operator guarded negation alchoiqgn actually intersection gnfo fragment barany ten cate otto alchoiq see
appendix details gnfo
alchoiqgn important property coinciding domain independent fragment alchoiq therefore providing excellent candidate language
ontologies queries satisfying conditions theorem
theorem expressive power equivalence domain independent fragment
alchoiq alchoiqgn equally expressive
words theorem says domain independent tbox axiom
domain independent concept query alchoiq logically equivalent respectively
tbox axiom concept query alchoiqgn vice versa theorem provides
description logics version codds theorem codds theorem states safe range
syntactic fragment fol domain independent fragment fol precisely
equivalent expressive power database query formulated one language
expressed
r
b
c





p p
nr
b nr c nr c b u c c u c
figure syntax alchoiqgn concepts roles


fiexact query reformulation dbs fo dl ontologies

applying constructive theorem
want reformulate concept queries ontology dbox reformulated query evaluated sql query database represented dbox
context database dbox ontology alchoiqgn tbox
query alchoiqgn concept query concept query alchoiqgn
concept expression denoting open formula one free variable alchoiqgn
abox concept assertion denoting boolean query expected dbox includes ground
atomic statements form p b atomic concept p
atomic role theorem draw following corollary
corollary alchoiqgn tboxes concept queries domain independent
prove following theorem
theorem alchoiqgn tboxes concept queries finitely controllable determinacy
therefore satisfy conditions theorem language
expressive alchoiq description logic guarded negation
argue non guarded negation appear cleanly designed ontology
present fixed indeed use absolute negative informationsuch
e g non male female male v female discouraged clean
design methodology since subsumer would include sorts objects universe
ones subsumee type without obvious control guarded negative
information subsumee allowedsuch axiom non male person
female person u male v female
observation suggests fix non guarded negations every non guarded negation users asked replace guarded one guard may arbitrary
atomic concept nominal non qualified existential therefore user asked make
explicit type concept way make domain independent note
type could fresh atomic concept believe fix proposing
alchoiq reasonable one would make alchoiq ontologies eligible
used framework
complete procedure
alchoiqgn decidable logic feasible application general framework
given alchoiqgn ontology kb concept query q apply procedure
generate safe range reformulation database concepts roles
constructive theorem conditions satisfied exists
input alchoiqgn tbox kb concept query q alchoiqgn
database signature database atomic concepts roles
g q q
e
check implicit definability query q testing kb kb
standard owl reasoner alchoiqgn sublanguage owl continue
holds


fifranconi kerhet ngo

b tableau proof generated step see
compute safe range reformulation q
section implemented simple extension standard dl reasoner
even presence important optimisation techniques semantic
branching absorption backjumping explained seylan et al ten
cate franconi seylan
b expressed database signature
output safe range reformulation q
note procedure checking determinacy computing reformulation
could run offline mode compile time indeed could run atomic concept
ontology store persistently outcome reformulation
successful pre computation may expensive operation sinceas
seenit entailment complexity involves size ontology
data
order get idea size reformulations alcf description
logic tableau computing explicit definitions double
exponential size ten cate et al ten cate franconi seylan
optimal shown smallest explicit definition implicitly defined
concept may double exponentially long size input tbox
clearly similarly dl lite reformulations needed order optimise
reformulation step order make practical however note framework
presented clear advantage point view conceptual modelling since
implicit definitions queries general tboxes double exponentially
succinct acyclic concept definitions explicit queries database
another interesting open checking given database
legal respect given ontology remember database db legal
ontology kb exists model kb embedding db check involves heavy
computations optimised still unknown matter fact
known method today reduce satisfiability
database embedded tbox nominals franconi et al
needed order optimise reasoning nominals special case
appendix contains definitions theorems needed prove theorems


conclusion
introduced framework compute exact reformulation first order queries
database ontologies found exact conditions guarantee
safe range reformulation exists evaluated relational
algebra query database give answer original query
ontology non trivial case study presented field description logics
alchoiq language
implemented tool prover theorem prover mccune
given arbitrary first order ontology database signature arbitrary first order
query tptp syntax tool performs tests check whether reformulation computed computes optimal safe range reformulation


fiexact query reformulation dbs fo dl ontologies

framework useful data exchange scenarios target database
made determined relations materialised proper database
arbitrary queries performed achieved context non exact
rewritings preserving certain answers scenario description logics ontologies
rewritings concept queries pre computed offline shown framework works theory case arbitrary safe range first order queries tool
shows possible practice case description logics working
extending theoretical framework conjunctive queries need finitely controllable
determinacy conjunctive queries seems follow description logic
works barany gottlob otto rosati
future work would study optimisations reformulations practical perspective since might many rewritten queries one original query
selecting optimised query terms query evaluation important
fact one take account criteria used optimise
size rewritings numbers used predicates priority predicates number
relational operators clever usage duplicates tool plan evaluate
proposed technique real context
concurrently exploring fixing real ontologies order enforce
definability known case franconi ngo sherkhonov c
happens intuitively obvious answer query found
available data query definable database mediating
ontology entail definability introduce novel definability
abduction solve completely data exchange scenario
thank anonymous reviewers useful comments got earlier versions wish thank alex borgida tommaso di noia umberto straccia
david toman grant weddell fruitful discussions topics


appendix proofs
proofs section
proposition
proof

let

asna dom x rng c sna kb e db q x

auna dom x rng c una kb e db q x
since sna stricter una e sna una auna asna trivially
let asna
auna interpretation hi embedding
db satisfying una kb q x let us construct


interpretation j hj j embedding db follows


j ai c c


fifranconi kerhet ngo



constant c aj


every predicate p p pj constructed pi replacing element
ai pi constant
obviously j satisfies sna j isomorphic since first order logic sentences cannot distinguish two isomorphic structures j q x contradicts
assumption asna therefore auna
proofs section
proposition
b x exact reformulation q x kb x q x q
b x
proof since q

b x
model kb substitution x q x q
b x
equivalent q x q
let substitution dom x rng c kb
e db q x h model kb embedding db
let composition substitution interpretation
function e x iff x c c ci q x
b x q
b
b
q x q
x summing q x q x
b x
hence dom x rng c kb e db q
inverse inclusion proved similarly
theorem
proof first recall assume sna order prove theorem one needs
following two propositions
proposition domain independence query q x domain independent iff
every two interpretations hi j hj j agree interpretation
predicates pq constants c every substitution x j

rng q x
iff
rng j j q x
proof obviously second part proposition holds query domain
independent
suppose query domain independent let hi j hj j
two interpretations agree interpretation predicates pq
constants c pq c j pq c let us fix substitution x j
query closed omit everything concerns substitution
proof
rng q x



fiexact query reformulation dbs fo dl ontologies





let us consider interpretations hi j hj j pq c



pq c

j pq c j pq c p p pq p p j let us consider
domain interpret predicates constants occurring
q x equally therefore since q x q x
let us consider interpretations j construction agree interpretation predicates constants therefore apply definition domain
independence since
rng q x



rng j j q x




interpretations j j domain interpret predicates
constants occurring q x equally thus
rng j j q x



therefore similarly proposition proved

proposition q x domain independent interpretation h
substitution x q x following holds
rng adom q x
proof assume x x q one free variable x proof easily
extended general case
let us prove contradiction suppose exists substitution x b
x b q x b adom q x let us consider interpretation
h brand element appear x
b q x domain independence q x consider another interpretation

h occurrence b interpretation predicate replaced
element words n ary predicate p p q x


p iff b p since supposition b appear interpretations
predicates query interpretations predicates constants
satisfies sna even b c since x b q x
construction x q x changed interpretations
predicates appear query since domain
agree interpretations predicates q x constants following
holds x q x
let us consider interpretations h h
interpretation function therefore since q x domain independent x
q x rng x contradiction
supposition


fifranconi kerhet ngo

prove theorem
l dom x rng c kb e db q x
b db hc e db p
r dom x rng adom q

db c

b x
q

b
let l kb e db q x q
x
proposition
consider j hc embedding db j agree interpretations c
b p subset pdb
since sna predicates set q
b x domain independent proposition j q
b
since q
x since
b
b
b
q x pdb c j p c q
since q x domain independent proposition
db

x

b x j adom q
b x j adom q
b x db
rng adom q
b x pdb c therefore rng adom q
b x db
assume sna q
r hence l r
b x db j hc embedding db
let r rng adom q
b
b
j pdb c q
x j q x consider kb e db j
b
agree interpretations c since sna pdb since q
pdb c
x

b x domain independent proposition q
b
b
q
x since q x exact
reformulation q x kb pdb proposition q x
l hence r l
theorem proved completely
definitions proofs section
proposition let kb domain independent ontology interpretation hi
model kb j hj j j model kb
proof let sentence kb since model kb domain
independent kb domain independent hence since j j thus j
model sentence kb means j model kb

proposition let kb ontology let q x query domain independent
respect kb exact reformulation q x kb set predicates
domain independent respect kb
b x exact reformulation q x kb set predicates
proof let q


h j hj j two kb j
x j substitution
b x
rng q
b
since q x exact reformulation q x q x since q x
domain independent respect kb
rng j j q x
b x exact reformulation q x j q
b x thus q
b x
since q
domain independent respect kb definition



fiexact query reformulation dbs fo dl ontologies

lemma let kb domain independent ontology let q x query
domain independent respect kb h model kb
substitution x q x following holds
rng adom q x
proof without loss generality assume x x q one free variable x
proof easily extended general case
let us prove contradiction suppose x b q x b
adom q x since kb domain independent brand element
appear interpretation h model kb proposition
since q x domain independent respect kb
interpretation function x b q x

consider interpretation h constructed occurrence b interpretation predicate replaced element words

n ary predicate p p pq p iff b p since supposition
b appear interpretations predicates query
since x b q x construction x q x
since simply replace b appear neither constant q x
interpretations predicates q x since domain
agree interpretations predicates q x constants
since assume sna x q x
let us consider interpretations h h
kb interpretation function since q x domain
independent respect kb x q x x
q x definition domain independence respect ontology
contradiction supposition lemma proved
let set formulas adom defined similarly adom q q
query
lemma let kb domain independent ontology let q x x x xn
query domain independent respect kb following holds
kb x q x q x adom kbq
q x adom kbq q x adom kbq x adom kbq xn q x q x

every sub formula q x form x x replaced x x adom kbq x
every sub formula q x form x x replaced x adom kbq x
x
proof without loss generality prove lemma n case
write q x instead q x prove contradiction
assume model hi kb element x
q x x q x adom kbq


fifranconi kerhet ngo

construct interpretation j hadom ikbq c j predicate
p pkbq p j p predicate p p pkbq p j
since kb domain independent j model kb proposition
j x q x q domain independent respect kb consequence however j x q x adom kbq definition q x adom kbq
q x adom kbq safe range construction see definition hence domain
independent therefore x q x adom kbq contradiction
assume model hi kb element x
q x adom kbq x q x one lead contradiction similarly
therefore lemma proved
theorem
proof theorem proved theorem
direction lemma one see exact reformulations q x
exact reformulations q x adom kbq since q x adom kbq safe range
kb transformed logically equivalent safe range ontology kb
b x found theorem takes
obviously exact safe range reformulation q

kb q x adom kbq input exact domain independent reformulation
q x
direction
b x q x
suppose exists exact domain independent reformulation q
pdb kb domain independent respect kb hence
proposition q x domain independent respect kb since exists
exact reformulation q x q x implicitly definable pdb kb
theorem
theorem proved completely
order help readers follow easier recall formal definitions safe range
safe range normal form abiteboul et al
definition safe range normal form denoted srnf
first order formula transformed srnf following steps
variable substitution distinct pair quantifiers may employ variable
remove universal quantifiers
remove implications
push negation
flatten


fiexact query reformulation dbs fo dl ontologies

definition range restriction formula denoted rr
input formula srnf
output subset free
case
r e en rr set variables e en
x x constant rr x
x rr
rr rr rr
rr rr rr
x rr rr x rr rr rr x otherwise
rr rr
x rr rr x x rr rr otherwise
note z z z z
definition safe range formula safe range iff rr srnf free
definition ground safe range formula ground safe range iff substitution free variables constants becomes safe range
observation
query q x interpretation h following holds
adom iq adom q x
adom q x safe range
theorem
proof theorem proved theorem theorem
use following lemma proof
lemma kb ontology q x x x xn ground safe range query
kb x q x x n xn



b x q x x n xn
n n safe range formulas query q
b
safe range kb x q x q x


fifranconi kerhet ngo

proof let q x safe range normal form query q x e q x srnf q x
xy xy conjunctive normal form safe range normal form
query prenex normal form q x ground safe range kb q x q x
hence kb x q x x n xn let q x q x x n xn
xi srnf xi kb q x q x hand
b x q construction summing everything kb q
b x
kb x q
x

b x safe range
q x thing need prove q


one see q x xy x n xn safe range normal
b x since q xy ground safe range rr xy x
form q
x

exists conjunct x xy x x since
xi safe range definition range restriction rr xy x n xn
x rr xy x n xn x free q x therefore
b x safey xy x n xn safe range definition hence q
range
let us continue prove theorem
b
x q closed build exact safe range reformulation q
theorem
suppose x x xn since q x safe range implicitly definable
pdb apply theorem q x construct ground safe range rewriting q x expressed pdb kb x q x q x since q x domain independent
since safe range domain independent respect kb hence proposition q x domain independent respect kb moreover kb safe range
hence domain independent theorem
kb x q x adom q x adom q xn
second item observation adom q x safe range formula lemma
b x q adom q x adom q xn safe range kb x q
query q
x
x
b x since kb x q x q kb x q x q
b x therefore
q
x

b x one looking
constructed query q
theorem proved completely
proofs section
theorem
proof first prove q implicitly definable formula valid
g x q x q
g
applying syntactic definition implicit definability kb kb
x therefore


replace
x


set

constants
c


c


following
formula
valid

n
v
vg
e x c c consequence valid
kb kb
q x c cn q
n

b c c x q
b x c c craig internext prove kb q x q
n

n

b x c c interpolant
polant since q


n



fiexact query reformulation dbs fo dl ontologies

v
b x c c
kb q x c cn q
n

b x c c
kb q x c cn q
n

g q
e x c c
b x c c v kb
q
n
n


g q
b x c c q
e x c c
kb
n
n


b pdb relation kb q
b x c c q x c c holds well
since q
n
n


expected statement
b x c c pdb q
b c c x pdb
last least since q
n
n


b c c x really explicit definition q
statements q
n

theorem
proof need following propositions prove theorem
proposition safe range closed iff safe range closed
proof
rr rr rr
free free free
rr rr free
rr rr free
closed iff f ree free
closed iff free
closed iff free
safe range iff rr free
safe range iff rr free
safe range iff rr free
therefore
closed iff closed
closed safe range iff closed safe range

proposition safe range closed iff safe range closed
proof
rr rr rr


fifranconi kerhet ngo

free free free
rr rr free
rr rr free
closed iff free free
closed iff free
closed iff free
safe range iff rr free
safe range iff rr free
safe range iff rr free
therefore
closed iff closed
closed safe range iff closed safe range

proposition x x closed safe range closed safe range
constants
proof obviously x x closed closed
assume safe range since closed rr srnf
srnf must contain subformula form z z
z rr srnf z
srnf x must contain subformula form z x z
z rr srnf x z
srnf x must contain subformula form z x z
z rr srnf x z pushing negation effect formula

rr srnf x
rr srnf x x
rr srnf x x
x x safe range
contradiction
proposition x x closed safe range closed safe range
constants
proof undoubtedly x x closed closed
assume safe range since closed rr srnf
srnf must contain subformula form z z
z rr srnf z


fiexact query reformulation dbs fo dl ontologies

srnf x must contain subformula form z x z
z rr srnf x z
rr srnf x
rr srnf x x
x x safe range
contradiction
propositions prove theorem follows
first closed safe range valid
interpolant assume biased tableau therefore root node
l r tableau expansion rules propositions every expansion step l l n r r n
safe range closed
need prove interpolant step safe range closed
induction shape proof set rules section
rules closed branches trivial safe range closed

rules propositional case
rule p p p p nothing changes one need prove
rule p apply proposition holds
rule p apply proposition holds
rules first order case
rule f f f nothing changes one need prove
rule f since c occur n case c
int
contains r c therefore l c c since x x
safe range due x c x safe range
rule f since c occur case c
int
contains l c therefore r c c since x x
safe range due x c x safe range
rules equality input formulas closed contain
function symbols equations ground therefore influence
safe range property interpolant step
consequence q c kb kb q c closed safe range
b c kb q c kb q c
interpolant q
theorem
proof consequence lemma theorem holds


fifranconi kerhet ngo

definitions proofs section
safe range fragment alchoiq call axiom concept alchoiq
ground safe range corresponding logically equivalent open formula fol c p
ground safe range concept c denote corresponding logically equivalent
formula fol c p one free variable x c x unfortunately concept inclusion
axioms alchoiq ontologies may safe range example axiom male v
female safe range easy see axiom c v safe range
c x safe range x safe range observe axiom logically
equivalent formula x c x x fol c p actually saferange normal form following proposition provides recursive rules deciding whether
alchoiq concept safe range
proposition let atomic concept let c alchoiq concepts
let r atomic role inverse atomic role
nr nr c safe range
c u safe range c safe range safe range
c safe range c safe range safe range
c safe range c safe range
proof enough prove proposition atomic roles order
variables binary atoms first order logic translation alchoiq concept
affect safe range property translation therefore hereafter assume r
atomic role
since atomic concept x safe range
x x safe range
nr x x xn r x x r x xn x x xn xn safe range
nr c x x xn r x x r x xn c x c xn x
x xn xn safe range
let us prove c u x c x x safe range c x
safe range x safe range
let c x x safe range let safe range normal
forms
c x x safe range definition
let c x x safe range safe range normal form e c x
x safe range normal form let us prove contradiction suppose
c x x safe range c x x safe range definition
contradiction therefore c x safe range x safe range


fiexact query reformulation dbs fo dl ontologies

let us prove c x c x x safe range c x
safe range x safe range
let c x x safe range safe range normal forms
c x x safe range definition
let c x x safe range safe range normal form e c x
x safe range normal form let us prove contradiction suppose c x
x safe range c x x safe range definition
contradiction therefore c x safe range x safe range
let us prove c x safe range c x safe range
let c x safe range let us prove contradiction let c x saferange c x c x domain independent one easily see
looking definition domain independence impossible therefore
c x safe range need prove c x safe range
c x safe range
let us prove induction structure formula suppose item true
subformula formula c x
suppose c x safe range let us consider already proved items
possible cases c x safe range
c x r x r x r x safe range
possibly complex concept c x r x
safe range definition
suppose c x u f x safe range x safe range
f x safe range since x f x subformulas c x
applying current item get x f x safe range c x
x f x x f x safe range x f x
safe range
suppose c x f x safe range x safe range
f x safe range since x f x subformulas c x
applying current item get x f x safe range c x
x f x x f x safe range x f x
safe range
suppose c x x safe range need prove c x x
safe range let us prove contradiction suppose x safe range
since x subformula c x applying current item get
x c x safe range contradiction hence c x safe range
item proved completely
proposition proved completely
proposition alchoiq role inclusion axioms safe range


fifranconi kerhet ngo

proof let v r role inclusion axiom alchoiq formula x x
r x first order logic translation axiom x stands x
preceding role atomic x stands x preceding role inverse atomic
formula safe range
guarded negation first order logic recall definition guarded negation firstorder logic gnfo given barany et al gnfo fragment
first order logic consisting formulas generated following recursive definition
r tn x



ti variable constant atomic formula possibly
equality statement containing free variables
guarded negation fragment alchoiq consider alchoiqgn
guarded negation fragment alchoiq e intersection gnfo alchoiq
say
concept c alchoiqgn concept c alchoiq concept
corresponding first order logic translation c x expressed gnfo
concept inclusion axiom c v alchoiqgn concept inclusion axiom
c alchoiq concepts formula x c x x
equivalent first order translation c v expressed gnfo
role inclusion axiom v r alchoiqgn role inclusion axiom r
roles atomic inverse atomic formula x x r x
x stands x preceding role atomic x stands x
preceding role inverse atomic expressed gnfo
easy see alchoiq role inclusion axiom alchoiqgn role inclusion
axiom proposition following holds
proposition

alchoiqgn role inclusion axioms safe range

safe range role inclusion axioms alchoiq alchoiqgn
definition gnfo alchoiq follows complex concept c
logic alchoiqgn recursively defined follows
b nr
c b nr c nr c b u c c u c



atomic concept r atomic role inverse atomic role c
alchoiqgn concepts possibly complex
note general according definition gnfo formulas atleast
operator n gnfo non guarded inequality statements xi
xj fix assuming inequality relation actually special binary database
predicate assumption usual databases


fiexact query reformulation dbs fo dl ontologies

strictly speaking nr u c gnfo indeed formula
x xn r x x r x xn x x xn xn c x
gnfo r x stands p x r stands atomic role p r x stands
p x r stands inverse atomic role p easily transformed
logically equivalent gnfo one simply shifting parentheses x xn r x x
r x xn x x xn xn c x assume formula
nr u c alchoiqgn
proposition alchoiqgn concepts safe range
proof let us prove induction structure alchoiqgn concepts defined

nr nr c nr c c alchoiqgn concept safe range
item proposition
atomic concept individual role r natural number n
concepts u c u c nr u c safe range item
proposition since nr safe range first item
suppose alchoiqgn concepts c safe range concepts
c u c safe range items proposition respectively
proposition proved
lemma safe range concept c alchoiq following holds
c v b bn
bi appears subconcept c one following concepts
atomic concept
individual name
nr r atomic role inverse atomic role n natural number
proof let us prove proposition induction safe range concepts alchoiq
nr nr c safe range proposition v v nr v
nr nr c v nr
suppose c complex safe range concept proposition holds
safe range subconcepts c
c c u c safe range c c safe range let c safe range
hence c v b bm bi concept aforementioned type
c u c v c v b b
c c c safe range c c safe range hence c v b bk
c v bk bm bi concept aforementioned type
c c v b bk bk bm v b bm


fifranconi kerhet ngo

c safe range proposition possible saferange one following cases takes place
u reduced case item
u reduced case item
hence safe range subconcept
proposition holds hence c c
lemma proved completely
lemma alchoiq concept c exists alchoiqgn concept c
c c c c
proof suppose lemma holds alchoiq subconcepts alchoiq
concept c let us prove c
base nr alchoiqgn concepts definition alchoiqgn
concept
c nr alchoiqgn concept
c nr c nr nr nr
alchoiqgn concepts hence item proved
c alchoiqgn concept
c c item proved
c c u c c alchoiqgn concept c c c c c
alchoiqgn concept c c c c consider possible
cases
c c c c c c c c u c alchoiqgn
concept c c alchoiqgn concepts
b c c c c c c u c c c c
c c tc alchoiqgn concept c c alchoiqgn
concepts
c c c c c case c c c c similar
one c c u c since c alchoiqgn concept proposition
safe range hence lemma c v b bn bi
atomic concept r c c u b bn
hence c c u b bn u c c u b u c bn u c
disjunct bi u c alchoiqgn concept c alchoiqgn
concept definition alchoiqgn concepts c c u
b u c bn u c alchoiqgn concept c c item
proved
c c c c u c case reduced items


fiexact query reformulation dbs fo dl ontologies

lemma proved completely
corollary alchoiq concept c concept b atom
nr concept b u c equivalent alchoiqgn concept
proof lemma exists alchoiqgn concept c c c
c c b u c b u c b u c b u c b u c b u c
alchoiqgn concepts definition alchoiqgn concepts hence
corollary proved
proposition safe range alchoiq concept equivalent alchoiqgn
concept
proof let c safe range alchoiq concept lemma c v b bn
bi atom nr c c u b bn
b uct tbn uc corollary disjunct bi uc exists alchoiqgn
concept di bi u c di c dn concept dn
alchoiqgn concept disjunction alchoiqgn concepts hence proposition
proved
proposition alchoiqgn concept inclusion axioms safe range
proof let c v concept inclusion axiom alchoiqgn means
corresponding first order logic translation x c x x gnfo hence c x
x gnfo c u alchoiqgn easy see
x c x x safe range formula c x x safe range
corresponding alchoiqgn concept c u safe range
proposition alchoiqgn concept safe range proposition proved
lemma safe range alchoiq concept c alchoiq concept
concept c u equivalent alchoiqgn concept c u c
alchoiqgn concepts
proof since c safe range lemma c v b bn bi
atomic concept r c c u b bn hence c u
c u b bn u c u b u bn u corollary disjunct
bn ud alchoiqgn concept hence b udt tbn ud alchoiqgn
concept since c safe range proposition exists alchoiqgn concept
c c c c u c u c u alchoiqgn concept
c alchoiqgn concepts
proposition safe range alchoiq concept inclusion axiom c v transformed concept inclusion axiom c v c alchoiqgn
proof let c v safe range alchoiq concept inclusion axiom corresponding formula x c x x safe range first order logic formula
c x x safe range alchoiq concept c u saferange proposition c safe range safe range


fifranconi kerhet ngo

c safe range lemma exist two alchoiqgn concepts c
c u logically equivalent alchoiqgn concept c u
x c x x logically equivalent x c x x hence c v
logically equivalent c v c alchoiqgn concepts
safe range proof similar previous item
proposition proved completely
proposition two alchoiqgn concepts c axiom c v
alchoiqgn concept inclusion axiom
proof axiom c v logically equivalent first order logic formula x c x
x c x x gnfo x c x x gnfo hence
definition alchoiqgn concept inclusion axiom axiom c v
alchoiqgn concept inclusion axiom
propositions imply following
proposition safe range alchoiq concept inclusion axiom equivalent
alchoiqgn concept inclusion axiom
consider connection safe range fragment alchoiq guarded negation fragment alchoiq alchoiqgn say fragment mean
set tbox assertions concept role inclusion axioms concepts open formulas
alchoiq satisfying particular property e g safe range guarded negation taking
account propositions following theorem
proposition safe range fragment alchoiq alchoiqgn equally
expressive
proves theorem
theorem expressive power equivalence domain independent fragment
alchoiq alchoiqgn equally expressive
theorem alchoiqgn tboxes finitely controllable determinacy concept
queries
proof need prove alchoiqgn tbox ontology concept
query q alchoiqgn set database predicates pdb whenever query
finitely determined database predicates ontology determined
unrestricted
suppose q finitely determined pdb theorem
e fin p means entailment
follows te fin pdb q v q
db
e
finite interpretation database predicates hence particular te fin q v q
fin means entailment finite hereafter let one sentence
first order logic translation conjunction axioms tbox
aforementioned entailment
e
fin e
x q x q x




fiexact query reformulation dbs fo dl ontologies

e
proposition q x safe range hence q x q x
safe range hence
e safe range hence proposition exists
alchoiq concept q u q
e c x q x q x
e
alchoiqgn concept c q u q
x c x
following holds
fin e
x c x

x c x gnfo c x gnfo since axioms alchoiqgn
tbox axioms sentences e gnfo sentence e
gnfo
therefore right hand side entailment gnfo e

x c x gnfo entailment finite model
since gnfo finite model property e
x c x unsatisfiable hence
e
x c x
e
since x c x x q x q x
following holds
e
e
x q x q x
e theorem means query q determined
te q v q
unrestricted database predicates pdb ontology
proposition proved

references
abiteboul hull r vianu v foundations databases addison wesley
artale calvanese kontchakov r zakharyaschev dl lite family
relations j artif intell res jair
avron constructibility decidability versus domain independence absoluteness theor comput sci
barany v gottlob g otto querying guarded fragment proceedings
th annual ieee symposium logic computer science lics pp

barany v ten cate b otto queries guarded negation full version
corr abs
beth e padoas method theory definition indagationes mathematicae

craig w three uses herbrand gentzen theorem relating model theory
proof theory j symb log
etzioni golden k weld sound efficient closed world reasoning
artif intell
fan w geerts f zheng l view determinacy preserving selected information data transformations inf syst
fitting first order logic automated theorem proving nd edition springer


fifranconi kerhet ngo

franconi e ibanez garcia seylan inanc query answering dboxes
hard electronic notes theoretical computer science elsevier
franconi e kerhet v ngo n exact query reformulation shoq dboxes
proc international workshop description logics dl
franconi e kerhet v ngo n b exact query reformulation first order ontologies databases logics artificial intelligence th european conference
jelia pp
franconi e ngo n sherkhonov e c definability abduction
data exchange web reasoning rule systems th international conference
rr
gurevich toward logic tailored computational complexity computation
proof theory vol pp springer
halevy answering queries views survey vldb journal

marx queries determined views pack views proceedings th
acm symposium principles database systems pods pp
mccune w
prover

prover mace

http www cs unm edu mccune

nash segoufin l vianu v views queries determinacy rewriting
acm trans database syst
rosati r finite controllability conjunctive query answering databases
open world assumption j comput syst sci
seylan inanc franconi e de bruijn j effective query rewriting ontologies dboxes proc st international joint conference artificial
intelligence ijcai pp
ten cate b franconi e seylan inanc beth definability expressive description logics proc nd international joint conference artificial
intelligence ijcai pp
ten cate b franconi e seylan inanc beth definability expressive description logics journal artificial intelligence jair




