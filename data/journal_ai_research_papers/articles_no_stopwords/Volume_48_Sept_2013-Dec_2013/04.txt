Journal Artificial Intelligence Research 48 (2013)

Submitted 5/2013; published 12/2013

Exact Query Reformulation Databases
First-order Description Logics Ontologies
Enrico Franconi
Volha Kerhet
Nhung Ngo

franconi@inf.unibz.it
kerhet@inf.unibz.it
ngo@inf.unibz.it

Free University Bozen-Bolzano, Italy

Abstract
study general framework query rewriting presence arbitrary
first-order logic ontology database signature. framework supports deciding
existence safe-range first-order equivalent reformulation query terms
database signature, so, provides effective approach construct reformulation based interpolation using standard theorem proving techniques (e.g., tableau).
Since reformulation safe-range formula, effectively executable SQL query.
end, present non-trivial application framework ontologies
expressive ALCHOIQ description logic, providing effective means compute
safe-range first-order exact reformulations queries.

1. Introduction
address problem query reformulation expressive ontologies databases.
ontology provides conceptual view database composed constraints
vocabulary extending basic vocabulary data. Querying database using
terms richer ontology allows flexibility using basic
vocabulary relational database directly.
paper study develop query rewriting framework applicable knowledge
representation systems data stored classical finite relational database, way
literature called locally-closed world assumption (Etzioni, Golden,
& Weld, 1997), exact views (Marx, 2007; Nash, Segoufin, & Vianu, 2010; Fan, Geerts,
& Zheng, 2012), DBox (Seylan, Franconi, & de Bruijn, 2009; Franconi, Ibanez-Garcia,
& Seylan, 2011). DBox set ground atoms semantically behaves
database, i.e., interpretation database predicates DBox exactly equal
database relations. DBox predicates closed, i.e., extensions
every interpretation, whereas predicates ontology open, i.e.,
extensions may vary among different interpretations. consider
open interpretation database predicates (also called ABox sound views).
ABox, interpretation database predicates contains database relations possibly
more. notion less faithful representation database semantics since would
allow spurious interpretations database predicates additional unwanted tuples
present original database.
general framework ontology set first-order formulas, queries
(possibly open) first-order formulas. Within setting, framework provides precise
semantic conditions decide existence safe-range first-order equivalent reformulac
2013
AI Access Foundation. rights reserved.

fiFranconi, Kerhet, & Ngo

tion query terms database signature. provides effective approach
construct reformulation sufficient conditions. interested safe-range reformulations queries range-restricted syntax needed reduce original
query answering problem relational algebra evaluation (e.g., via SQL) original
database (Abiteboul, Hull, & Vianu, 1995). framework points several conditions
ontologies queries guarantee existence safe-range reformulation.
show conditions feasible practice provide efficient method
ensure validation. Standard theorem proving techniques used compute
reformulation.
order complete, framework applicable ontologies queries expressed
fragment first-order logic enjoying finitely controllable determinacy (Nash et al.,
2010), stronger property finite model property logic. employed logic
enjoy finitely controllable determinacy approach would become sound
incomplete, still effectively implementable using standard theorem proving techniques.
explored non-trivial applications framework complete; paper,
application ALCHOIQ ontologies concept queries discussed. show
(i) check whether answers given query ontology solely determined
extension DBox predicates and, so, (ii) find equivalent rewriting
query terms DBox predicates allow use standard database technology
answering query. means benefit low computational complexity
size data answering queries relational databases. addition, possible
reuse standard techniques description logics reasoning find rewritings,
paper Seylan et al. (2009).
query reformulation problem received strong interest classical relational
database research well modern knowledge representation studies. Differently
mainstream research query reformulation (Halevy, 2001), mostly based
perfect maximally contained rewritings sound views relatively inexpressive constraints (see, e.g., DL-Lite approach Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009), focus exact rewritings exact views, since characterises
precisely query answering problem ontologies databases, case
exact semantics database must preserved. example, consider ground negative query given standard relational database; adding ontology top it,
answer supposed changesince query uses signature database
additional constraints supposed change meaning querywhereas
database treated ABox (sound views) answer may change presence
ontology. may important application perspective: DBox preserves
behaviour legacy application queries relational database. Moreover,
focussing exact reformulations definable queries (as opposed considering certain
answer semantics arbitrary queries, DL-Lite), guarantee answers
queries subsequently composed arbitrary way: may important legacy
database applications.
work extends works exact rewritings exact views Marx (2007)
Nash et al. (2010) focussing safe-range reformulations conditions ensuring
existence, considering general first-order ontologies extending database
signature, rather local view constraints database predicates (Halevy,
886

fiExact Query Reformulation DBs FO DL Ontologies

2001). paper extends papers Franconi, Kerhet, Ngo (2012a, 2012b)
providing precise semantic characterisation existence exact reformulation
(Theorem 4) opposed sufficient conditions, considering much expressive description logic ALCHOIQ, providing proofs.
paper organised follows: section 2 provides necessary formal background
definitions; section 3 introduces notion query determined database; section 4 introduces characterisation query reformulation problem; sections 5 6
conditions allowing effective reformulation analysed, sound complete algorithm compute reformulation introduced. Finally, present case
ALCHOIQ ontologies. proofs presented details Appendix.

2. Preliminaries
Let FOL(C, P) classical function-free first-order language equality signature
= (C, P), C finite set constants P set predicates associated
arities. rest paper refer arbitrary fragment FOL(C, P),
called L.
denote P{1 ,...,n } set predicates occurring formulas 1 , . . . , n ,
C{1 ,...,n } set constants occurring formulas 1 , . . . , n ; sake
brevity, instead P{} (resp. C{} ) write P (resp. C ). denote (1 , . . . , n )
signature formulas 1 , . . . , n , namely union P{1 ,...,n } C{1 ,...,n } .
denote arity predicate P ar(P ). Given formula , denote set
variables appearing var(), set free variables appearing
free(); may use notation [X] , X = free() (possibly empty)
set free variables formula.
database (instance) DB finite set ground atoms form P (c1 , . . . , cn ),
P P, n-ary predicate, ci C (1 n). set predicates appearing
database DB denoted PDB , set constants appearing DB called
active domain DB, denoted CDB . (possibly empty) finite set KB closed
formulas called ontology.
usual, interpretation = hI , includes non-empty setthe domain
interpretation function defined constants predicates signature. say
interpretations = hI , J = hJ , J equal, written = J , = J
= J . interpretation embeds database DB, holds aI = every
database constant CDB (the standard name assumption (SNA), customary databases,
see Abiteboul et al., 1995) (c1 , . . . , cn ) P P (c1 , . . . , cn ) DB.
denote set interpretations embedding database DB E(DB).
words, every interpretation embedding DB interpretation
database predicate always given exactly content database;
is, general, case interpretation non-database predicates.
say database predicates closed, predicates open
may interpreted differently different interpretations. consider open
world assumption (the ABox ) embedding database interpretation. open
world, interpretation soundly embeds database holds (c1 , . . . , cn ) P
(but if) P (c1 , . . . , cn ) DB.
887

fiFranconi, Kerhet, & Ngo

order allow arbitrary database embedded, generalise standard
name assumption constants C; implies domain interpretation
necessarily includes set constants C. finiteness C corresponds
finite ability database system represent distinct constant symbols; C meant
unknown advance, since different database systems may different limits.
see framework introduced depend choice C.
Given interpretation = hI , i, denote I|S interpretation restricted
smaller signature P C, i.e., interpretation domain
interpretation function defined constants predicates set
S. semantic active domain signature 0 P C interpretation I, denoted
adom( 0 , I), set elements domain occurring interpretations
predicates constants 0 I:
adom( 0 , I) :=

[

[

P 0 (a1 ,...,an )P

{a1 , . . . , }

[

{cI }.

c 0

0 PDB C, interpretations J embedding DB have:
adom( 0 , I) = adom( 0 , J ); so, case introduce notation adom( 0 , DB) :=
adom( 0 , I), interpretation embedding database DB. Intuitively
adom( 0 , DB) includes constants 0 DB appearing relations corresponding predicates 0 .
Let X set variable symbols set; substitution total function : X 7
assigning element variable X, including empty substitution
X = . Domain image (range) substitution written dom() rng()
respectively. Given subset set constants C0 C, write formula [X]
true interpretation free variables substituted according substitution
: X 7 C0 (I |= [X/] ). Given interpretation = hI , subset
domain , write formula [X] true free variables
interpreted according substitution : X 7 (I, |= ). extension domain
aSformula [X] respect interpretation defined set domain elements
{rng() | dom() = X, rng() , I, |= [X] }.
usual, interpretation closed formula true called model
formula; set models formula (resp. KB) denoted () (resp.
(KB)). database DB legal ontology KB exists model KB embedding
DB. following, consider consistent non-tautological ontologies legal
databases.
2.1 Queries
query (possibly closed) formula. Given query Q[X] , define certain answer
KB DB follows:
Definition 1 (Certain Answer). (certain) answer query Q[X] database DB
ontology KB set substitutions constants:
{ | dom() = X, rng() C, (KB) E(DB) : |= Q[X/] }.
888

fiExact Query Reformulation DBs FO DL Ontologies

Query answering defined entailment problem, going
(high) complexity entailment.
Note, query Q closed (i.e., Boolean query), certain answer {}
Q true models ontology embedding database, otherwise.
following, assume closed formula Q[X/] neither valid inconsistent
ontology KB, given substitution : X 7 C assigning variables distinct constants
appearing Q, KB, CDB : would lead trivial reformulations.
show weaken standard name assumption constants
assuming unique names, without changing certain answers. said before,
interpretation satisfies standard name assumption cI = c c C. Alternatively, interpretation satisfies unique name assumption (UNA) aI 6= bI
different a, b C. denote set interpretations satisfying standard name
assumption I(SNA). denote set interpretations satisfying unique name
assumption I(UNA). following proposition allows us freely interchange standard name unique name assumptions interpretations embedding databases.
practical advantage, since encode unique name assumption classical
first-order logic reasoners, many description logics reasoners support natively
unique name assumption extension OWL.
Proposition 1 (SNA vs UNA). query Q[X] , ontology KB database DB,
{ | dom() = X, rng() C, I(SNA) (KB) E(DB) : |= Q[X/] } =
{ | dom() = X, rng() C, I(UNA) (KB) E(DB) : |= Q[X/] }.
Since query arbitrary first-order formula, answer may depend
domain, know advance. example, query Q(x) = Student(x)
database Student(a), Student(b), domain {a, b, c} answer {x = c},
domain {a, b, c, d} answer {x = c, x = d}. Therefore, notion
domain independent queries introduced relational databases. adapt
classical definitions (Avron, 2008; Abiteboul et al., 1995) framework: need
general version domain independence, namely domain independence w.r.t
ontology, i.e., restricted models ontology.
Definition 2 (Domain Independence). formula Q[X] domain independent
respect ontology KB iff every two models J KB (i.e., = hI ,
J = hJ , J i) agree interpretation predicates constants (i.e.
= J ), every substitution : X 7 J have:
rng() I, |= Q[X] iff
rng() J J , |= Q[X] .
definition reduces classical definition domain independence whenever
ontology empty.
weaker version domain independencewhich relevant open formulasis
following.
Definition 3 (Ground Domain Independence). formula Q[X] ground domain independent iff Q[X/] domain independent every substitution : X 7 C.
889

fiFranconi, Kerhet, & Ngo

example, formula P (x) ground domain independent, domain independent.
problem checking whether FOL formula domain independent undecidable
(Abiteboul et al., 1995). well known safe-range syntactic fragment FOL introduced
Codd equally expressive language; indeed safe-range formula domain independent, domain independent formula easily transformed logically
equivalent safe-range formula. Intuitively, formula safe-range variables
bounded positive predicates equalities (for full details see Appendix A.3).
example, formula A(x) B(x) safe-range, queries A(x) x. A(x)
not. check whether formula safe-range, formula transformed logically
equivalent safe-range normal form range restriction computed according set
syntax based rules; range restriction formula subset free variables,
coincides free variables formula said safe-range (Abiteboul
et al., 1995). Similar domain independence, formula ground safe-range grounding formula safe-range. ontology KB safe-range (domain independent),
every formula KB safe-range (domain independent).
safe-range fragment first-order logic standard name assumption
equally expressive relational algebra, core SQL (Abiteboul et al.,
1995).

3. Determinacy
certain answer query includes substitutions make query true
models ontology embedding database: so, substitution would make
query true model, would discarded certain answer.
words, may case answer query necessarily among
models ontology embedding database. case, query fully
determined given source data; indeed, answer possible,
certain. Due indeterminacy query respect data, complexity
compute certain answer general increases complexity entailment
logic. paper focus case query answer
models ontology embedding database, namely, information requested
query fully available source data without ambiguity. way,
indeterminacy disappears, complexity process may decrease (see section 4).
determinacy query w.r.t. source database (Nash et al., 2010; Marx, 2007; Fan
et al., 2012) called implicit definability formula (the query) set
predicates (the database predicates) Beth (1953).
Definition 4 (Finite Determinacy Implicit Definability). query Q[X] (finitely)
determined (or implicitly definable from) database predicates PDB KB iff
two models J ontology KBboth finite interpretation
database predicates PDB whenever I|PDB C = J |PDB C every substitution
: X 7 have: I, |= Q[X] iff J , |= Q[X] .
Intuitively, answer implicitly definable query depend interpretation non-database predicates. database domain fixed, never
890

fiExact Query Reformulation DBs FO DL Ontologies

case substitution would make query true model ontology
false others, since truth value implicitly defined query depends
interpretation database predicates constants domain (which
fixed). practice, focussing finite determinacy queries guarantee user
always interpret answers certain, exactnamely
whatever answer never part answer possible world.
following focus ontologies queries fragments FOL(C, P)
determinacy models finite interpretation database predicates (finite
determinacy) determinacy models unrestricted interpretation database
predicates (unrestricted determinacy) coincide. say fragments finitely
controllable determinacy: require whenever query finitely determined
determined unrestricted models (the reverse trivially true). Indeed, results
paper would fail finite determinacy unrestricted determinacy coincide:
shown (Gurevich, 1984) Theorem 1 fails consider models
finite interpretation database predicates.
Example 1 (Example database theory). Let P = {P, R, A}, PDB = {P, R},
KB = {x, y, z. R(x, y) R(x, z) = z,
x, y. R(x, y) z. R(z, x),
(x, y. R(x, y) z. R(y, z)) (x. A(x) P (x))}.
formula x, y. R(x, y) z. R(y, z) entailed first two formulas
finite interpretations R. query Q = A(x) finitely determined P (it equivalent
P (x) models finite interpretation R), determined
database predicate models unrestricted interpretation R. knowledge
base enjoy finitely controllable determinacy.
exact reformulation query (Nash et al., 2010) (also called explicit definition
Beth, 1953) formula logically equivalent query makes use database
predicates constants.
Definition 5 (Exact Reformulation Explicit Definability). query Q[X] explicitly definable database predicates PDB ontology KB iff
b[X] FOL(C, P), KB |= X.Q[X] Q
b[X] (Q)
b PDB . call
formula Q
b[X] exact reformulation Q[X] KB PDB .
formula Q
Determinacy query completely characterised existence exact reformulation query: well known first-order query determined database
predicates exists first-order exact reformulation.
Theorem 1 (Projective Beth definability, Beth, 1953). query Q implicitly definable database predicates PDB ontology KB, iff explicitly definable
b FOL(C, P) PDB KB.
formula Q
e formula obtained uniformly replacing
Let Q formula L Q
every occurrence non-database predicate P new predicate Pe. extend
renaming operator e set formulas natural way. One check whether query
implicitly definable using following theorem.
Theorem 2 (Testing Determinacy, Beth, 1953). query Q[X] implicitly definable
g |= X.Q[X] Q
e[X] .
database predicates PDB ontology KB iff KB KB

891

fiFranconi, Kerhet, & Ngo

4. Exact Safe-Range Query Reformulation
section analyse conditions original query answering problem
corresponding entailment problem reduced systematically model checking
problem safe-range formula database (e.g., using database system
SQL). Given database signature PDB , ontology KB, query Q[X] expressed L
determined database predicates, goal find safe-range reformulation
b[X] Q[X] FOL(C, P), evaluated relational algebra expression
Q
legal database instance, gives answer certain answer Q[X] database
KB. reformulated following problem:
Problem 1 (Exact safe-range Query Reformulation). Find exact reformulation
b[X] Q[X] KB safe-range query FOL(C, P) PDB .
Q
Since exact reformulation equivalent ontology original query,
certain answer original query reformulated query identical.
precisely, following proposition holds.
Proposition 2. Given database DB, let Q[X] implicitly definable PDB KB
b[X] exact reformulation Q[X] KB PDB , then:
let Q
{ | dom() = X, rng() C, (KB) E(DB) : |= Q[X/] } =
b[X/] }.
{ | dom() = X, rng() C, (KB) E(DB) : |= Q
equation clear order answer exactly reformulated query,
one may still need consider models ontology embedding database, i.e.,
still entailment problem solve. following theorem states condition
reduce original query answering problembased entailmentto problem
checking validity exact reformulation single model: condition
reformulation domain independent. Indeed one interpretation
(with particular domain) embedding database signature restricted
database predicates.
Theorem 3 (Adequacy Exact safe-range Query Reformulation). Let DB
b[X] exact domain
database legal KB, let Q[X] query. Q
independent (or safe-range) reformulation Q[X] KB PDB , then:
{ | dom() = X, rng() C, (KB) E(DB) : |= Q[X/] } =
b DB), = hC, E(DB) : I|P
{ | dom() = X, rng() adom((Q),

DB C

b[X/] }.
|= Q

safe-range reformulation necessary transform first-order query relational
algebra query evaluated using SQL techniques. theorem
shows addition safe-range sufficient property exact reformulation correctly evaluated SQL query. Let us see example
cannot reduce problem answering exact reformulation model checking
database, exact reformulation safe-range.
Example 2. Let P = {P, A}, PDB = {P }, C = {a},
DB = {P (a, a)}, KB = {y. P (a, y) A(y)},
b[X] = y. P (x, y) (i.e., X = {x}).
Q[X] = Q
892

fiExact Query Reformulation DBs FO DL Ontologies

C includes active domain CDB (it actually equal).
DB legal KB = h{a}, P = {(a, a)}, AI =
obviously, (KB).
{ | dom() = X, rng() C, (KB) E(DB) : |= Q[X/] } =
one take = h{a, b}, P = {(a, a)}, AI = {b}; (KB)
E(DB), possible substitution {x a} have: 6|= P (a, y).
However,
b DB), = hC, E(DB) : I|P C |= Q
b[X/] } =
{ | dom() = X, rng() adom((Q),
DB

{x a}
seen, answers query reformulation exists contain
constants active domain database query; therefore, ground statements ontology involving non-database predicates non-active domain constants
(for example, ABox statements) play role final evaluation
reformulated query database.

5. Conditions Exact Safe-Range Reformulation
seen importance getting exact safe-range query reformulation.
section going study conditions exact safe-range query
reformulation exists.
First all, focus semantic notion safe-range namely domain independence. implicit definability isas already knowa sufficient condition
existence exact reformulation, guarantee alone existence domain
independent reformulation.
Example 3. Let P = {A, B}, PDB = {A}, KB = {x.B(x) A(x)}, Q = B(x).
Q implicitly definable PDB KB, every exact reformulation Q
PDB KB logically equivalent A(x) domain independent.
looking example, seems reason non domain independent
reformulation lies fact ontology, domain independent, cannot guarantee existence exact domain independent reformulation non domain independent
query. However, let us consider following example:
Example 4. Let PDB = {A, C}, KB = {A(a),
B(y) C(x). easy see KB
implicitly definable PDB KB,
independent reformulation Q.

x. A(x) B(x)} let query Q =
domain independent Q not. Q
b = A(a) C(x) exact domain
Q

obvious spite fact query Q domain independent,
domain independent respect ontology KB. words, case
ontology guarantees existence exact domain independent reformulation.
queries domain independent respect ontology, following
theorem holds, giving semantic requirements existence exact domain
independent reformulation.
893

fiFranconi, Kerhet, & Ngo

Theorem 4 (Semantic Characterisation). Given set database predicates PDB ,
domain independent ontology KB, query Q[X] , domain independent exact reformub[X] Q[X] PDB KB exists Q[X] implicitly definable
lation Q
PDB KB domain independent respect KB.
theorem shows us semantic conditions exact domain independent reformulation query, give us method compute reformulation equivalent safe-range form. following theorem gives us sufficient
conditions existence exact safe-range reformulation decidable fragment
FOL(C, P) finite unrestricted determinacy coincide, gives us constructive
way compute it, exists.
Theorem 5 (Constructive). If:
g |= X. Q[X] Q
e[X] (that is, Q[X] implicitly definable),
1. KB KB
2. Q[X] safe-range (that is, Q[X] domain independent),
3. KB safe-range (that is, KB domain independent),
b[X] Q[X] safe-range query FOL(C, P)
exists exact reformulation Q
PDB KB, obtained constructively.
order constructively compute exact safe-range query reformulation use
b[X]
tableau based method find Craigs interpolant (Fitting, 1996) compute Q
gQ
e[X] ). See Section 6 full details.
validity proof implication (KB Q[X] ) (KB
Let us consider fully worked example, adapted paper Nash et al.
(2010).
Example 5. Given: P = {R, V1 , V2 , V3 , A}, PDB = {V1 , V2 , V3 , Adom} Adom
active domain DB,
KB = { x, y. V1 (x, y) z, v. R(z, x) R(z, v) R(v, y),
x, y. V2 (x, y) z. R(x, z) R(z, y),
x, y. V3 (x, y) z, v. R(x, z) R(z, v) R(v, y),
Q(x, y) = z, v, u. R(z, x) R(z, v) R(v, u) R(u, y)}.
conditions theorem satisfied: Q(x, y) implicitly definable PDB
KB; Q(x, y) safe-range; KB safe-range.
b y)
Therefore, tableau method one finds Craigs interpolant compute Q(x,
g
e
b
validity proof implication (KB Q[X] ) (KB Q[X] ) obtain Q(x, y) =
z. V1 (x, z) v. (V2 (v, z) V3 (v, y))an exact ground safe-range reformulation. Since
b y) Adom(x)
answer Q active domain, KB |= Q(x,
b
Adom(y). KB |= Q(x, y) Q(x, y) Adom(x) Adom(y). Therefore, z. V1 (x, z)
v. (V2 (v, z) V3 (v, y))Adom(x)Adom(y) exact safe-range reformulation Q(x, y)
PDB KB.
894

fiExact Query Reformulation DBs FO DL Ontologies

6. Constructing Safe-Range Reformulation
section introduce method compute safe-range reformulation implicitly
definable query conditions theorem 5 satisfied. method based
notion interpolant introduced Craig (1957).
Definition 6 (Interpolant). sentence interpolant sentence
FOL(C, P), predicate constant symbols set predicate
constant symbols , valid sentences
FOL(C, P).
Theorem 6 (Craigs interpolation). valid sentence FOL(C, P),
neither valid, exists interpolant.
Note, Beth definability (Theorem 1) Craigs interpolation theorem
hold fragments FOL(C, P): interpolant may always expressed
fragment itself, obviously FOL(C, P) (because Theorem 6).
interpolant used find exact reformulation given implicitly definable
query follows.
Theorem 7 (Interpolant definition). Let Q[X] query n 0 free variables
implicitly definable database predicates PDB ontology KB. Then,
closed formula c1 , ..., cn distinct constant symbols C appearing KB Q[X] :
^
^
g Q
e[X/c ,...,c ] )
(( KB) Q[X/c1 ,...,cn ] ) (( KB)
(1)
n
1
b[c ,...,c /X] exact reformulation Q[X] KB
valid, interpolant Q
n
1
PDB .
Therefore, find exact reformulation implicitly definable query terms
database predicates enough find interpolant implication (1)
substitute constants c1 , . . . , cn back free variables X original query.
interpolant constructed validity proof (1) using automated theorem
proving techniques tableau resolution. order guarantee safe-range
property reformulation, use tableau method book Fitting (1996).
6.1 Tableau-based Method Compute Interpolant
section recall context tableau based method compute interpolant (Fitting, 1996).
Assume valid, therefore unsatisfiable. closed tableau
corresponding . order compute interpolant tableau one needs
modify biased tableau.
Definition 7 (Biased tableau). biased tableau formulas tree = (V, E)
where:
V set nodes, node labelled set biased formulas. biased formula
expression form L() R() formula. node n,
S(n) denotes set biased formulas labelling n.
895

fiFranconi, Kerhet, & Ngo

root tree labelled {L(), R()}
E set edges. Given 2 nodes n1 n2 , (n1 , n2 ) E iff biased
completion rule n1 n2 . say biased completion rule n1
n2
() result applying rule X(), X refer L R
(for rules, two possibilities choosing ()),
S(n2 ) = (S(n1 ) \ {X()}) {Y ()}.
Let C set constants input formulas tableau. C par extends C
infinite set new constants. constant new occur anywhere
tableau. notations, following rules :
Propositional rules
X()
X()

Negation rules
X(>)
X()

rule
X(1 2 )

X()
X(>)

X(1 )
X(2 )

rule
X((1 2 ))
X(1 ) | X(2 )

First order rules
rule
X(x.)

rule
X(x.)

X((t))
C par

X((c))
new constant c

Equality rules
reflexivity rule

replacement rule
X(t = u)
((t))

X()


X(t = t)
occurs

((u))

C par

node tableau closed contains X() (). node closed,
rule applied. words, becomes leaf tree. branch closed
contains closed node tableau closed branches closed. Obviously,
standard tableau FOL closed biased tableau vice versa.
Given closed biased tableau, interpolant computed applying interpolant rules.
int
interpolant rule written I, formula
= {L(1 ), L(2 ), ..., L(n ), R(1 ), R(2 ), ..., R(m )}.
Rules closed branches
int

int

r1. {L(), L()}

r2. {R(), R()} >

int

int

r3. {L()}

r4. {R()} >
int

int

r5. {L(), R()}

r6. {R(), L()}
896

fiExact Query Reformulation DBs FO DL Ontologies

Rules propositional cases
int
{X()}
p1.

p4.

p6.

int

p2.

int

{X()}
int
{X(1 ), X(2 )}

{X(>)}
int

int

p3.

{X()}
int

{X()}
{X(>)}
int
int
{L(1 )} I1 {L(2 )} I2
p5.

int

int

{X(1 2 )}
{L((1 2 ))} I1 I2
int
int
{R(1 )} I1 {R(2 )} I2
int

{R((1 2 ))} I1 I2
Rules first order cases :
int
{X((p))}
f1.

f2.

f3.

f4.

f5.

p parameter occur

int

{X(x.(x))}
int
{L((c))}
int

c occurs {1 , ..., n }

{L(x.(x))}
int
{R((c))}
int

c occurs {1 , ..., }

{R(x.(x))}
int
{L((c))}
int

{L(x.(x))} x.I[c/x]
int
{R((c))}
int

c occur {1 , ..., n }
c occur {1 , ..., }

{R(x.(x))} x.I[c/x]
Rules equality cases
int
{X((p)), X(t = t)}
e1.

e3.

int

int

e2.

{X((p))}
int
{L((u)), R(t = u)}
int

{X((u)), X(t = u)}
int

{X((t)), X(t = u)}
u occurs (t), 1 , ...,

{L((t)), R(t = u)} = u
int
{R((u)), L(t = u)}

u occurs (t), 1 , ...,
int
{R((t)), L(t = u)} = u
int
{L((u)), R(t = u)}
e5.
u occur (t), 1 , ...,
int
{L((t)), R(t = u)} I[u/t]
int
{R((u)), L(t = u)}
e6.
u occur (t), 1 , ...,
int
{R((t)), L(t = u)} I[u/t]
e4.

summary, order compute interpolant , one first need generate
biased tableaux proof unsatisfiability using biased completion rules
apply interpolant rules bottom leaves root.
Let us consider example demonstrate method works.
Example 6. Let P = {S, G, U }, PDB = {S, U },
897

fiFranconi, Kerhet, & Ngo

KB = { x(S(x) (G(x) U (x)))
x(G(x) S(x))
x(U (x) S(x))
x(G(x) U (x))}
Q(x) = G(x)
Obviously, Q implicitly definable U , since ontology states G
U partition S. follow tableau method find exact reformulation.
int
compactness, use notation instead I.
S0 = {L(x(S(x) (G(x) U (x)))),
L(x(G(x) S(x))),
L(x(U (x) S(x))),
L(x(G(x) U (x))),
L(G(c)),
R(x(S(x) (G1 (x) U (x)))),
R(x(G1 (x) S(x))),
R(x(U (x) S(x))),
R(x(G1 (x) U (x))),
R(G1 (c))}
applying rule removing implication, have:
S1 = {L(S(c) G(c) U (c)),
L(G(c) S(c))),
L(U (c) S(c)),
L(G(c) U (c)),
L(G(c)),
R(S(c) G1 (c) U (c)),
R(G1 (c) S(c)),
R(U (c) S(c)),
R(G1 (c) U (c)),
R(G1 (c))}
interpolant S1 computed follows:
S4 {R(S(c)}S(c)

S4 {R(U (c))}U (c)

S4 = S3 {R(S(c) U (c))}(S(c)U (c))



S3 {R(G1 (c))}>

(S(c)U (c))

B.7

S2 {L(G(c))}

S3 = S2 {L(U (c))}

(S(c)U (c))

S2 = S1 {L(S(c))}

(S(c)U (c))

B.5

S1 {L(G(c))}

B.3

S1

b
Therefore, S(c)U (c) interpolant Q(x)
= S(x)U (x) exact reformulation
Q(x).
898

fiExact Query Reformulation DBs FO DL Ontologies

Algorithm 1 Safe-range Reformulation
Input: safe-range KB, safe-range implicitly definable query Q[X] .
Output: exact safe-range reformulation.
b[X] Theorem 7
1: Compute interpolant Q
b[X]
2: free variable x bounded positive predicate Q
b[X] := Q
b[X] Adom b (x)
Q
Q
b[X]
3: Return Q

6.2 Safe-Range Reformulation
want show reformulation computed tableau based method
condition Theorem 5 generates ground safe-range query.
Theorem 8 (Ground safe-range Reformulation). Let KB ontology, let Q
query implicitly definable PDB . KB Q safe-range rewritten
b obtained using tableau method described Section 6.1 ground safe-range.
query Q
words, conditions Theorem 8 guarantee quantified variables
reformulation range-restricted. need consider still unsafe free variables.
theorem help us deal non-range-restricted free variables. Let us first
define active domain predicate query Q safe-range formula:
Adom Q (x) :=
W
W
P PQ z1 , . . . , zar(P )1 . P (x, z1 , . . . , zar(P )1 ) . . . P (z1 , . . . , zar(P )1 , x)
cCQ (x = c).

Theorem 9 (Range query). Let KB domain independent ontology, let
Q[x1 ,...,xn ] query domain independent respect KB.
KB |= x1 , . . . , xn . Q[x1 ,...,xn ] Adom Q (x1 ) . . . Adom Q (xn ).
Given safe-range ontology, safe-range implicitly definable query obviously
domain independent respect ontology. case, Theorem 9 says
answer reformulation include active domain elements. Therefore, active
domain predicate used guard free variables bounded
positive predicate.
Based Theorem 8 Theorem 9, propose complete procedure construct
safe-range reformulation Algorithm 1.

7. Guarded Negation Fragment ALCHOIQ
ALCHOIQ extension description logic ALC role hierarchies, individuals,
inverse roles, qualified cardinality restrictions: corresponds SHOIQ description logic without transitive roles; logic basis OWL. syntax
semantics ALCHOIQ concept expressions summarised Figure 1,
atomic concept, C concepts, individual name, P atomic role,
R either P P . forall qualified unqualified atmost operators
derived using negation atleast operator usual way. TBox ALCHOIQ
899

fiFranconi, Kerhet, & Ngo

Syntax

{o}
P
P
C
C uD
C tD
nR
nR.C

Semantics
AI
{oI }
P
{(y, x)|(x, y) P }
\C
C DI
C DI
{x|#({y|(x, y) RI }) n}
{x|#({y|(x, y) RI } C ) n}

Figure 1: Syntax semantics ALCHOIQ concepts roles
set concept inclusion axioms C v role inclusion axioms R v (where C,
concepts R, roles) usual description logics semantics.
section, present application Theorem 5, introducing ALCHOIQGN
description logic, guarded negation syntactic fragment ALCHOIQ (Figure 2)
happens express exactly domain independent concepts TBoxes ALCHOIQ.
language restricts ALCHOIQ prescribing negated concepts
guarded generalised atom (an atomic concept, nominal, unqualified atleast
number restriction), i.e., absolute negation forbidden. Similarly, derived forall
atmost operators would guarded using standard definition dual
atleast operator, guarded negation. ALCHOIQGN actually intersection GNFO fragment (Barany, ten Cate, & Otto, 2012) ALCHOIQ (see
Appendix A.5 details GNFO).
ALCHOIQGN important property coinciding domain independent fragment ALCHOIQ, therefore providing excellent candidate language
ontologies queries satisfying conditions Theorem 5.
Theorem 10 (Expressive power equivalence). domain independent fragment
ALCHOIQ ALCHOIQGN equally expressive.
words theorem says domain independent TBox axiom
domain independent concept query ALCHOIQ logically equivalent, respectively,
TBox axiom concept query ALCHOIQGN , vice-versa. theorem provides
description logics version Codds theorem. Codds theorem states safe-range
syntactic fragment FOL domain-independent fragment FOL precisely
equivalent expressive power; is, database query formulated one language
expressed other.
R
B
C

::=
::=
::=

P | P
| {o} | nR
B | nR.C | nR.C | B u C | C u | C
Figure 2: Syntax ALCHOIQGN concepts roles
900

fiExact Query Reformulation DBs FO DL Ontologies

7.1 Applying Constructive Theorem
want reformulate concept queries ontology DBox reformulated query evaluated SQL query database represented DBox.
context, database DBox, ontology ALCHOIQGN TBox,
query ALCHOIQGN concept query. concept query either ALCHOIQGN
concept expression denoting open formula one free variable, ALCHOIQGN
ABox concept assertion denoting boolean query. expected, DBox includes ground
atomic statements form A(a) P (a, b) (where atomic concept P
atomic role). Theorem 10 draw following corollary.
Corollary 1. ALCHOIQGN TBoxes concept queries domain independent.
prove following theorem.
Theorem 11. ALCHOIQGN TBoxes concept queries finitely controllable determinacy.
Therefore, satisfy conditions Theorem 5, language
expressive ALCHOIQ description logic, guarded negation.
argue non-guarded negation appear cleanly designed ontology,
and, present, fixed. Indeed, use absolute negative informationsuch as,
e.g., non-male female ( male v female)should discouraged clean
design methodology, since subsumer would include sorts objects universe
(but ones subsumee type) without obvious control. guarded negative
information subsumee allowedsuch axiom non-male person
female (person u male v female).
observation suggests fix non-guarded negations: every non-guarded negation users asked replace guarded one, guard may arbitrary
atomic concept, nominal, non-qualified existential. Therefore, user asked make
explicit type concept, way make domain independent; note
type could fresh new atomic concept. believe fix proposing
ALCHOIQ reasonable one, would make ALCHOIQ ontologies eligible
used framework.
7.2 Complete Procedure
ALCHOIQGN decidable logic feasible application general framework.
Given ALCHOIQGN ontology KB concept query Q, apply procedure
generate safe-range reformulation database concepts roles (based
constructive theorem, conditions satisfied), exists.
Input: ALCHOIQGN TBox KB, concept query Q ALCHOIQGN ,
database signature (database atomic concepts roles).
g |= Q Q
e using
1. Check implicit definability query Q testing KB KB
standard OWL2 reasoner (ALCHOIQGN sublanguage OWL2). Continue
holds.
901

fiFranconi, Kerhet, & Ngo

b tableau proof generated step 1 (see
2. Compute safe-range reformulation Q
Section 6). implemented simple extension standard DL reasoner
even presence important optimisation techniques semantic
branching, absorption, backjumping explained Seylan et al. (2009) ten
Cate, Franconi, Seylan (2011).
b expressed database signature.
Output: safe-range reformulation Q
Note procedure checking determinacy computing reformulation
could run offline mode compile time. Indeed, could run atomic concept
ontology, store persistently outcome reformulation
successful. pre-computation may expensive operation, sinceas
seenit based entailment, complexity involves size ontology
data.
order get idea size reformulations, ALCF description
logic tableau-based algorithm computing explicit definitions double
exponential size (ten Cate et al., 2011; ten Cate, Franconi, & Seylan, 2013); algorithm
optimal shown smallest explicit definition implicitly defined
concept may double exponentially long size input TBox.
Clearly, similarly DL-Lite reformulations, research needed order optimise
reformulation step order make practical. However, note framework
presented clear advantage point view conceptual modelling since
implicit definitions (that is, queries) general TBoxes double exponentially
succinct acyclic concept definitions (that is, explicit queries database).
another interesting open problem checking given database
legal respect given ontology. Remember database DB legal
ontology KB exists model KB embedding DB. check involves heavy
computations optimised algorithm still unknown: matter fact,
known method today reduce problem satisfiability problem
database embedded TBox using nominals (Franconi et al., 2011). research
needed order optimise reasoning nominals special case.
Appendix A.5 contains definitions theorems needed prove theorems 10
11.

8. Conclusion
introduced framework compute exact reformulation first-order queries
database ontologies. found exact conditions guarantee
safe-range reformulation exists, show evaluated relational
algebra query database give answer original query
ontology. non-trivial case study presented field description logics,
ALCHOIQ language.
implemented tool based Prover9 theorem prover (McCune, 2011).
Given arbitrary first-order ontology, database signature, arbitrary first-order
query TPTP syntax, tool performs tests check whether reformulation computed, computes optimal safe-range reformulation.
902

fiExact Query Reformulation DBs FO DL Ontologies

framework useful data exchange-like scenarios, target database
(made determined relations) materialised proper database,
arbitrary queries performed. achieved context non-exact
rewritings preserving certain answers. scenario description logics ontologies,
rewritings concept queries pre-computed offline once. shown framework works theory case arbitrary safe-range first-order queries, tool
shows possible practice. case description logics, working
extending theoretical framework conjunctive queries: need finitely controllable
determinacy conjunctive queries, seems follow description logic
works Barany, Gottlob, Otto (2010) Rosati (2011).
future work, would study optimisations reformulations. practical perspective, since might many rewritten queries one original query,
problem selecting optimised query terms query evaluation important.
fact, one take account criteria used optimise, as:
size rewritings, numbers used predicates, priority predicates, number
relational operators, clever usage duplicates. tool, plan evaluate
proposed technique real context.
Concurrently, exploring problem fixing real ontologies order enforce
definability known case (Franconi, Ngo, & Sherkhonov, 2012c).
happens intuitively obvious answer query found
available data (that is, query definable database), mediating
ontology entail definability. introduce novel problem definability
abduction solve completely data exchange scenario.
thank anonymous reviewers useful comments got earlier versions paper. wish thank Alex Borgida, Tommaso Di Noia, Umberto Straccia,
David Toman, Grant Weddell fruitful discussions topics
paper.

Appendix A. Proofs
A.1 Proofs Section 2
Proposition 1
Proof.

Let

Asna = { | dom() = X, rng() C, I(SNA)M (KB)E(DB) : |= Q[X/] }

Auna = { | dom() = X, rng() C, I(UNA)M (KB)E(DB) : |= Q[X/] }
Since SNA stricter UNA, i.e. I(SNA) I(UNA), have: Auna Asna trivially.
Let Asna .
/ Auna interpretation = hI , embedding
DB satisfying UNA (KB) 6|= Q[X/] . Let us construct new


interpretation J = hJ , J embedding DB follows:


J := (I \ {aI | C}) C;
903

fiFranconi, Kerhet, & Ngo



constant C, aJ := a;


every predicate P P, PJ constructed PI replacing element
aI PI , constant, a.
Obviously, J satisfies SNA J isomorphic. Since first-order logic sentences cannot distinguish two isomorphic structures, J 6|= Q[X/] contradicts
assumption Asna . Therefore Auna .
A.2 Proofs Section 4
Proposition 2.
b[X] exact reformulation Q[X] , KB |= X.Q[X] Q
b[X] . Then,
Proof. Since Q

b[X] ,
model (KB) substitution : X 7 have: I, |= Q[X] Q
b[X] ).
equivalent (I, |= Q[X] I, |= Q
Now, let substitution { | dom() = X, rng() = C, (KB)
E(DB) : |= Q[X/] }, = h, model KB embedding DB (if
any). Let := composition substitution interpretation
function (i.e. (x) = iff (x) = c C cI = a). I, |= Q[X]
b[X] |= Q
b
b
|= Q[X/] I, |= Q
[X/] . Summing up: |= Q[X/] |= Q[X/] .
b[X/] }.
Hence, { | dom() = X, rng() = C, (KB) E(DB) : |= Q
inverse inclusion proved similarly.
Theorem 3.
Proof. First recall assume SNA. order prove theorem, one needs
following two propositions.
Proposition 3 (Domain Independence). query Q[X] domain independent iff
every two interpretations = hI , J = hJ , J agree interpretation
predicates PQ (and constants C), every substitution : X 7 J
have:
rng() I, |= Q[X]
iff
rng() J J , |= Q[X] .
Proof. () Obviously, second part proposition holds, query domain
independent.
() Suppose, query domain independent. Let = hI , J = hJ , J
two interpretations, agree interpretation predicates PQ
(and constants C), I|PQ C = J |PQ C . Let us fix substitution : X 7 J
(if query closed, omit everything, concerns substitution
proof) that:
rng() I, |= Q[X] .
(2)
904

fiExact Query Reformulation DBs FO DL Ontologies

0

0

Let us consider interpretations 0 = hI , J 0 = hJ , J i, I|PQ C =
0
0
0
0 |PQ C

= J |PQ C = J |PQ C , P P \ PQ : P = = P J . Let us consider
0 . domain interpret predicates constants, occurring
Q[X] equally. Therefore, since I, |= Q[X] (by (2)), 0 , |= Q[X] .
Let us consider interpretations 0 J 0 . construction, agree interpretation predicates constants. Therefore, apply definition domain
independence them. Then, since
rng() 0 , |= Q[X] ,

(3)

rng() J J 0 , |= Q[X] .

(4)

have,
interpretations J J 0 domain interpret predicates
constants, occurring Q[X] equally. Thus, (4),
rng() J J , |= Q[X] .

(5)

Therefore, (2) = (5). Similarly (5) = (2), proposition proved.

Proposition 4. Q[X] domain independent, interpretation = h,
substitution : X 7 , I, |= Q[X] , following holds:
rng() adom((Q[X] ), I).
Proof. Assume, X = {x}, Q one free variable x (the proof easily
extended general case).
Let us prove contradiction. Suppose, exists substitution {x b}
I, {x b} |= Q(x) b \ adom((Q(x)), I). Let us consider interpretation 0 =
h {a}, i, brand-new element, appear . 0 , {x
b} |= Q(x) domain independence Q(x). Consider another interpretation
00
00 = h {a}, occurrence b interpretation predicate replaced
element a. words, n-ary predicate P P \ (Q(x)), (. . . , a, . . .)
00
0
P iff (. . . , b, . . .) P (since supposition b appear interpretations
predicates query). Interpretations predicates constants
same. 00 satisfies SNA (even b C). Then, since 0 , {x b} |= Q[X] ,
construction 00 have: 00 , {x a} |= Q(x), changed interpretations
predicates, appear query. since 0 00 domain
agree interpretations predicates Q(x) constants, following
holds: 0 , {x a} |= Q(x).
Let us consider interpretations = h, 0 = h {a}, i.
interpretation function. Therefore, since Q(x) domain independent 0 , {x
a} |= Q(x), have: rng({x a}) . . contradiction,
supposition 6 .
905

fiFranconi, Kerhet, & Ngo

prove theorem itself.
L := { | dom() = X, rng() C, (KB) E(DB) : |= Q[X/] };
b DB), = hC, E(DB) : I|P
R := { | dom() = X, rng() adom((Q),

DB C

b[X/] }.
|= Q

b
Let L. (KB) E(DB) have: |= Q[X/] |= Q
[X/] ,
Proposition 2.
Consider J = hC, embedding DB. J agree interpretations C
b P subset PDB .
(since SNA) predicates set (Q)
b[X] domain independent, Proposition 3 have: J |= Q
b
Then, since Q
[X/] . Since
b
b
b
(Q[X] ) PDB C, J |P C |= Q
. Since Q[X] domain independent, Proposition
DB

[X/]

b[X] ), J ). adom((Q
b[X] ), J ) = adom((Q
b[X] ), DB),
4 have: rng() adom((Q
b[X] ) PDB C. Therefore, rng() adom((Q
b[X] ), DB).
assume SNA (Q
R and, hence, L R.
b[X] ), DB)). J = hC, embedding DB
Let R (rng() adom((Q
b
b
have: J |PDB C |= Q
[X/] . J |= Q[X/] . Consider (KB) E(DB). J
b
agree interpretations C (since SNA) PDB . Since (Q
) PDB C
[X/]

b[X] domain independent, Proposition 3 have: |= Q
b
b
Q
[X/] . Since Q[X] exact
reformulation Q[X] KB PDB , Proposition 2 have: |= Q[X/] .
L and, hence, R L.
Theorem 3 proved completely.
A.3 Definitions Proofs Section 5
Proposition 5. Let KB domain independent ontology. interpretation = hI ,
model KB, J = hJ , J i, = J , model KB.
Proof. Let sentence KB. Then, since model KB, |= . domain
independent, KB domain independent. Hence, since = J , J |= . Thus, J
model sentence KB. means, J model KB.

Proposition 6. Let KB ontology, let Q[X] query domain independent
respect KB. exact reformulation Q[X] KB (over set predicates)
domain independent respect KB.
b[X] exact reformulation Q[X] KB (over set predicates),
Proof. Let Q


= h , J = hJ , J two models KB = J ,
: X 7 J substitution
b[X] .
rng() I, |= Q
b
Then, since Q[X] exact reformulation Q[X] , have: I, |= Q[X] . Then, since Q[X]
domain independent respect KB, have:
rng() J J , |= Q[X] .
b[X] exact reformulation Q[X] , have: J , |= Q
b[X] . Thus, Q
b[X]
again, since Q
domain independent respect KB definition.

906

fiExact Query Reformulation DBs FO DL Ontologies

Lemma 1. Let KB domain independent ontology, let Q[X] query
domain independent respect KB. = h, model KB
substitution : X 7 I, |= Q[X] following holds:
rng() adom((Q[X] ), I).
Proof. Without loss generality assume, X = {x}, Q one free variable x
(the proof easily extended general case).
Let us prove contradiction. Suppose I, {x b} |= Q(x), b \
adom((Q[X] ), I). Since KB domain independent, brand-new element a,
appear , interpretation = h {a}, model KB Proposition
5. Then, since Q(x) domain independent respect KB
interpretation function, I, {x b} |= Q(x).
1
Consider new interpretation 1 = h {a}, constructed occurrence b interpretation predicate replaced element a. words,
1
n-ary predicate P P \ PQ , (. . . , a, . . .) P iff (. . . , b, . . .) P (since supposition
b appear interpretations predicates query).
Then, since I, {x b} |= Q(x) construction 1 have: 1 , {x a} |= Q(x)
(since simply replace b, appear neither constant Q(x)
interpretations predicates Q(x), a). Then, since 1 domain
{a} agree interpretations predicates Q(x) constants
(since assume SNA), have: I, {x a} |= Q(x).
Let us consider interpretations = h, = h {a}, i.
models KB interpretation function . So, since Q(x) domain
independent respect KB I, {x a} |= Q(x), have: I, {x
a} |= Q(x) definition domain independence respect ontology.
contradiction, supposition 6 . lemma proved.
Let set formulas. Adom defined similarly Adom Q , Q
query.
Lemma 2. Let KB domain independent ontology, let Q[X] (X = {x1 , ..., xn })
query domain independent respect KB. following holds:
KB |= X.Q[X] Q[X] |Adom KBQ
Q[X] |Adom KBQ Q0 [X] Adom KBQ (x1 ) ... Adom KBQ (xn ), Q0 [X] Q[X]
that:
Every sub-formula Q[X] form x.(x) replaced x.(x)Adom KBQ (x)
Every sub-formula Q[X] form x.(x) replaced x.Adom KBQ (x)
(x)
Proof. Without loss generality, prove lemma n = 1. case,
write Q(x) instead Q[X] . prove contradiction.
Assume model = hI , KB element I, {x
a} |= Q(x) I, {x a} 6|= Q(x)|Adom KBQ .
907

fiFranconi, Kerhet, & Ngo

construct new interpretation J = hAdom IKBQ C, J predicate
P PKBQ , P J := P , predicate P P \ PKBQ , P J := .
Since KB domain independent, J model KB Proposition 5. Then,
J , {x a} |= Q(x) Q domain independent respect KB. consequence, however, J , {x a} |= Q(x)|Adom KBQ definition Q(x)|Adom KBQ .
Q(x)|Adom KBQ safe-range construction (see Definition 10). Hence, domain
independent. Therefore I, {x a} |= Q(x)|Adom KBQ . Contradiction.
Assume model = hI , KB element I, {x
a} |= Q(x)|Adom KBQ I, {x a} 6|= Q(x). One lead contradiction similarly
above. Therefore, lemma proved.
Theorem 4.
Proof. theorem proved Theorem 5.
direction. Based Lemma 2, one see exact reformulations Q[X]
exact reformulations Q[X] |Adom KBQ . Since Q[X] |Adom KBQ safe-range
KB always transformed logically equivalent safe-range ontology KB 0 ,
b[X] found Theorem 5 takes
obviously exact safe-range reformulation Q
0
KB Q[X] |Adom KBQ input exact domain independent reformulation
Q[X] .
direction.
b[X] Q[X]
Suppose, exists exact domain independent reformulation Q
PDB KB. domain independent respect KB. Hence,
Proposition 6, Q[X] domain independent respect KB. Since exists
exact reformulation Q[X] , Q[X] implicitly definable PDB KB
Theorem 1.
theorem proved completely.
order help readers follow easier, recall formal definitions safe-range
safe-range normal form (Abiteboul et al., 1995).
Definition 8 (safe-range normal form). denoted SRNF
first order formula transformed SRNF following steps :
Variable substitution: distinct pair quantifiers may employ variable.
Remove universal quantifiers
Remove implications
Push negation
Flatten and/or
908

fiExact Query Reformulation DBs FO DL Ontologies

Definition 9 (Range restriction formula). denoted rr
Input : formula SRNF
Output : subset free()
Case
R(e1 , ..., en ) : rr() = set variables e1 , ..., en
x = = x, constant : rr() = {x}
x = : rr() =
1 2 : rr() = rr(1 ) rr(2 )
1 2 : rr() = rr(1 ) rr(2 )
1 x = : rr() = rr(1 ) {x, y} rr(1 ) = ; rr() = rr(1 ) {x, y} otherwise
1 : rr() = rr(1 )
x1 : rr() = rr(1 )\{x} x rr(1 ); rr() = otherwise
Note : Z = Z = \Z = Z\ =
Definition 10 (safe-range). formula safe-range iff rr(SRNF()) = free().
Definition 11 (ground safe-range). formula ground safe-range iff substitution free variables constants becomes safe-range.
Observation 1.
1. query Q[X] interpretation = h, following holds:
Adom IQ = adom((Q[X] ), I).
2. Adom Q (x) safe-range.
Theorem 5.
Proof. theorem proved Theorem 8 Theorem 9.
use following lemma proof.
Lemma 3. KB ontology, Q[X] (X = {x1 , . . . , xn }) ground safe-range query
KB |= X. Q[X] 1 (x1 ) . . . n (xn ),

(6)

b[X] := Q[X] 1 (x1 ). . .n (xn )
1 , . . . , n n safe-range formulas, query Q
b
safe-range KB |= X. Q[X] Q[X] .
909

fiFranconi, Kerhet, & Ngo

Proof. Let Q0[X] safe-range normal form query Q[X] , i.e. Q0[X] := SRNF(Q[X] ) =
Y. [XY] , [XY] conjunctive normal form (the safe-range normal form
query prenex normal form). Q0[X] ground safe-range, KB |= Q0[X] Q[X] .
Hence, KB |= X. Q0[X] 1 (x1 ) . . . n (xn ). Let Q00[X] := Q0[X] 10 (x1 ) . . . n0 (xn ),
i0 (xi ) = SRNF(i (xi )). 6, KB |= Q0[X] Q00[X] . hand
b[X] Q00 construction. Summing everything, have: KB |= Q
b[X]
KB |= X. Q
[X]

b[X] safe-range.
Q[X] thing need prove Q
00
0
One see, Q[X] Y. ([XY] 1 (x1 ). . .n0 (xn )) safe-range normal
b[X] . Since Q0 = Y. [XY] ground safe-range, rr([XY] ) \ X = Y0 Y,
form Q
[X]

Y\Y0 exists conjunct x = [XY] , x X. Then, since
i0 (xi ) safe-range, definition range restriction rr([XY] 10 (x1 ). . .n0 (xn )) =
X Y, rr(Y. ([XY] 10 (x1 ) . . . n0 (xn ))) = X = free(Q00[X] ). Therefore,
b[X] safeY. ([XY] 10 (x1 ) . . . n0 (xn )) safe-range definition, hence Q
range.
Let us continue prove theorem.
b using
X = , (Q closed) build exact safe-range reformulation Q
Theorem 8.
Suppose now, X = {x1 , . . . , xn }. Since Q[X] safe-range implicitly definable
PDB , apply Theorem 8 Q[X] construct ground safe-range rewriting Q0[X] expressed PDB KB |= X. Q[X] Q0[X] . Since Q[X] domain independent
(since safe-range), domain independent respect KB. Hence, Proposition 6, Q0[X] domain independent respect KB. Moreover, KB safe-range
and, hence, domain independent. Theorem 9:
KB |= X. Q0[X] Adom Q (x1 ) . . . Adom Q (xn ).
second item Observation 1 Adom Q (x) safe-range formula. Lemma 3
b[X] := Q0 Adom Q0 (x1 ) . . . Adom Q0 (xn ) safe-range KB |= X. Q0
query Q
[X]
[X]
b[X] . Since KB |= X. Q[X] Q0 , have: KB |= X. Q[X] Q
b[X] . Therefore,
Q
[X]

b[X] one looking for.
constructed query Q
Theorem 5 proved completely.
A.4 Proofs Section 6
Theorem 7.
Proof. First prove Q implicitly definable formula (1) valid.
g |= X.Q[X] Q
g
Applying syntactic definition implicit definability: KB KB
[X] . Therefore,


replace
X


set

constants
c
,
...,
c
,

following
formula
valid
1
n
V
Vg
e[X/c ,...,c ] ). consequence, (1) valid.
( KB KB)
(Q[X/c1 ,...,cn ] Q
n
1
b[c ,...,c /X] ) Q
b[X/c ,...,c ] Craig interNext, prove KB |= (Q[X] Q
n
0
n1
1
b[X/c ,...,c ] interpolant:
polant (1). Since Q
1

n

910

fiExact Query Reformulation DBs FO DL Ontologies

V
b[X/c ,...,c ]
1. (( KB) Q[X/c1 ,...,cn ] ) Q
n
1
b[X/c ,...,c ] )
: KB |= (Q[X/c1 ,...,cn ] Q
n
1
g Q
e[X/c ,...,c ] )
b[X/c ,...,c ] ((V KB)
2. Q
n
n
1
1
g |= (Q
b[X/c ,...,c ] Q
e[X/c ,...,c ] ).
: KB
n
n
1
1
b PDB , relation KB |= (Q
b[X/c ,...,c ] Q[X/c ,...,c ] ) holds well
Since (Q)
n
n
1
1
From(1)(2) expected statement.
b[X/c ,...,c ] ) PDB (Q
b[c ,...,c /X] ) PDB .
Last least, since (Q
n
n
1
1
b[c ,...,c /X] really explicit definition Q
statements, Q
n
1
Theorem 8.
Proof. need following propositions prove theorem.
Proposition 7. 1 2 safe-range closed iff 1 2 safe-range closed.
Proof. have:
rr(1 2 ) = rr(1 ) rr(2 )
free(1 2 ) = free(1 ) free(2 )
rr(1 ) = rr(1 ) free(1 )
rr(2 ) = rr(2 ) free(2 )
1 2 closed iff f ree(1 ) = free(2 ) =
1 closed iff free(1 ) =
2 closed iff free(2 ) =
1 2 safe-range iff rr(1 2 ) = free(1 2 )
1 safe-range iff rr(1 ) = free(1 )
1 safe-range iff rr(2 ) = free(2 )
Therefore:
1 2 closed iff 1 2 closed
1 2 closed, safe-range iff 1 2 closed, safe-range.

Proposition 8. 1 2 safe-range closed iff 1 2 safe-range closed.
Proof. have:
rr(1 2 ) = rr(1 ) rr(2 )
911

fiFranconi, Kerhet, & Ngo

free(1 2 ) = free(1 ) free(2 )
rr(1 ) = rr(1 ) free(1 )
rr(2 ) = rr(2 ) free(2 )
1 2 closed iff free(1 ) = free(2 ) =
1 closed iff free(1 ) =
2 closed iff free(2 ) =
1 2 safe-range iff rr(1 2 ) = free(1 2 )
1 safe-range iff rr(1 ) = free(1 )
1 safe-range iff rr(2 ) = free(2 )
Therefore:
1 2 closed iff 1 2 closed
1 2 closed, safe-range iff 1 2 closed, safe-range.

Proposition 9. ~x(~x) closed safe-range (~t) closed safe-range
~t constants.
Proof. Obviously, ~x(~x) closed (~t) closed.
Assume (~t) safe-range. Since closed rr(SRNF((~t))) =
SRNF((~t)) must contain subformula form ~z0 (~t, ~z)
~z 6 rr(SRNF(0 (~t, ~z)))
SRNF((~x)) must contain subformula form ~z0 (~x, ~z)
~z 6 rr(SRNF(0 (~x, ~z)))
SRNF((~x)) must contain subformula form ~z0 (~x, ~z)
~z 6 rr(SRNF(0 (~x, ~z))) pushing negation effect formula

rr(SRNF((~x))) =
rr(SRNF(~x(~x))) =
rr(SRNF(~x(~x))) =
~x(~x) safe-range
contradiction.
Proposition 10. ~x(~x) closed safe-range (~t) closed safe-range
~t constants.
Proof. Undoubtedly, ~x(~x) closed (~t) closed.
Assume (~t) safe-range. Since closed, rr(SRNF((~t))) =
SRNF((~t)) must contain subformula form ~z0 (~t, ~z)
~z 6 rr(SRNF(0 (~t, ~z)))
912

fiExact Query Reformulation DBs FO DL Ontologies

SRNF((~x)) must contain subformula form ~z0 (~x, ~z)
~z 6 rr(SRNF(0 (~x, ~z)))
rr(SRNF((~x))) =
rr(SRNF(~x(~x))) =
~x(~x) safe-range
contradiction.
Based propositions, prove Theorem 8 follows.
First, show closed safe-range valid
interpolant. Assume biased tableau . Therefore root node
= {L(), R()}. Based tableau expansion rules propositions, every expansion step = {L(1 ), ..., L(n ), R(1 ), ..., R(m )}, 1 , ..., n
1 , ..., safe-range closed(*) .
need prove interpolant step safe-range closed (**)
induction shape proof set rules Section 6.
Rules closed branches: trivial safe-range closed
(*)
Rules propositional case :
rule (p1)(p2)(p3)(p4) nothing changes, one need prove.
rule (p5), apply Proposition 8, (**) holds.
rule (p6), apply Proposition 7,(**) holds.
Rules first order case :
rule (f1) (f2) (f3) nothing changes, one need prove.
rule (f4), since c occur {1 , ..., n } case c
int
contains R((c)). Therefore {L((c))} = (c). Since x.(x)
safe-range (due (*)) x.I[c/x] safe-range
rule (f5), since c occur {1 , ..., } case c
int
contains L((c)). Therefore {R((c))} = (c). Since x.(x)
safe-range (due (*)) x.I[c/x] safe-range
Rules equality : input formulas closed contain
function symbols, equations ground. Therefore, influence
safe-range property interpolant step.
consequence, Q(~c), KB, KB 0 ,Q0 (~c) closed safe-range
b c) KB Q(~c) KB 0 Q0 (~c).
interpolant Q(~
Theorem 9.
Proof. consequence Lemma 1, Theorem 9 holds.
913

fiFranconi, Kerhet, & Ngo

A.5 Definitions Proofs Section 7
safe-range fragment ALCHOIQ. call axiom (concept) ALCHOIQ
(ground) safe-range, corresponding logically equivalent (open) formula FOL(C, P)
(ground) safe-range. concept C denote corresponding logically equivalent
formula FOL(C, P) one free variable x C(x). Unfortunately concept inclusion
axioms ALCHOIQ ontologies may safe-range: example, axiom male v
female safe-range. easy see axiom C v safe-range
C(x) safe-range D(x) safe-range: observe axiom logically
equivalent formula x. C(x) D(x) FOL(C, P) (which actually saferange normal form). following proposition provides recursive rules deciding whether
ALCHOIQ concept safe-range.
Proposition 11. Let atomic concept, let C ALCHOIQ concepts,
let R either atomic role inverse atomic role. Then:
1. A, {o}, nR, nR.C safe-range;
2. C u safe-range C safe-range safe-range;
3. C safe-range C safe-range safe-range;
4. C safe-range C safe-range.
Proof. enough prove proposition atomic roles order
variables binary atoms first-order logic translation ALCHOIQ concept
affect safe-range property translation. Therefore hereafter assume R
atomic role.
Since atomic concept, A(x) safe-range.
{o}(x) = (x = o) - safe-range.
( nR)(x) = x1 , . . . , xn . R(x, x1 ) . . . R(x, xn ) (x1 6= x2 ) . . . (xn1 6= xn ) safe-range.
( nR.C)(x) = x1 , . . . , xn . R(x, x1 ) . . . R(x, xn ) C(x1 ) . . . C(xn ) (x1 6=
x2 ) . . . (xn1 6= xn ) - safe-range.
Let us prove, (C u D)(x) = C(x) D(x) safe-range C(x)
safe-range D(x) safe-range.
) Let C(x) D(x) safe-range let safe-range normal
forms.
C(x) D(x) safe-range definition.
) Let C(x) D(x) safe-range safe-range normal form (i.e. C(x)
D(x) safe-range normal form). Let us prove contradiction. Suppose,
C(x) D(x) safe-range. C(x) D(x) safe-range definition.
contradiction. Therefore, C(x) safe-range D(x) safe-range.
914

fiExact Query Reformulation DBs FO DL Ontologies

Let us prove, (C D)(x) = C(x) D(x) safe-range C(x)
safe-range D(x) safe-range.
) Let C(x) D(x) safe-range safe-range normal forms.
C(x) D(x) safe-range definition.
) Let C(x) D(x) safe-range safe-range normal form (i.e. C(x)
D(x) safe-range normal form). Let us prove contradiction. Suppose, C(x)
D(x) safe-range. C(x) D(x) safe-range definition.
contradiction. Therefore, C(x) safe-range D(x) safe-range.
Let us prove, C(x) safe-range C(x) safe-range.
) Let C(x) safe-range. Let us prove contradiction. Let C(x) saferange. C(x) C(x) domain independent. one easily see
(looking definition domain independence), impossible. Therefore,
C(x) safe-range. ) need prove, C(x) safe-range,
C(x) safe-range.
Let us prove induction structure formula. Suppose, item true
subformula formula C(x).
Suppose, C(x) safe-range. Let us consider (using already proved items)
possible cases, C(x) safe-range.
C(x) = (R.D)(x) = y. R(x, y) D(y) y.R(x, y)D(y) - safe-range,
(possibly complex) concept. C(x) = y.R(x, y) D(y)
safe-range definition.
Suppose, C(x) = (D u F )(x) safe-range. D(x) safe-range
F (x) safe-range. Since D(x) F (x) subformulas C(x),
applying current item get: D(x) F (x) safe-range. C(x)
(D(x) F (x)) D(x) F (x) - safe-range, D(x) F (x)
safe-range.
Suppose, C(x) = (D F )(x) safe-range. D(x) safe-range
F (x) safe-range. Since D(x) F (x) subformulas C(x),
applying current item get: either D(x) F (x) safe-range. C(x)
(D(x) F (x)) D(x) F (x) - safe-range, either D(x) F (x)
safe-range.
Suppose, C(x) = D(x) safe-range. need prove, C(x) D(x)
safe-range. Let us prove contradiction. Suppose, D(x) safe-range.
Then, since D(x) subformula C(x), applying current item get:
D(x) C(x) safe-range. contradiction. Hence, C(x) safe-range.
item proved completely.
proposition proved completely.
Proposition 12. ALCHOIQ role inclusion axioms safe-range.
915

fiFranconi, Kerhet, & Ngo

Proof. Let v R role inclusion axiom ALCHOIQ. formula x, y. S(x, y)
R(x, y) first-order logic translation axiom, (x, y) stands (x, y)
preceding role atomic (x, y) stands (y, x) preceding role inverse atomic.
formula safe-range.
Guarded negation first-order logic. recall definition guarded negation firstorder logic (GNFO) given paper Barany et al. (2012). GNFO fragment
first-order logic consisting formulas generated following recursive definition:
::= R(t1 , . . . , tn ) | t1 = t2 | 1 2 | 1 2 | x. |

(7)

ti either variable constant, atomic formula (possibly
equality statement) containing free variables .
Guarded negation fragment ALCHOIQ. consider ALCHOIQGN -
guarded negation fragment ALCHOIQ (i.e. intersection GNFO ALCHOIQ).
say,
concept C ALCHOIQGN concept C ALCHOIQ concept
corresponding first-order logic translation C(x) expressed GNFO;
concept inclusion axiom C v ALCHOIQGN concept inclusion axiom
C ALCHOIQ concepts formula x. C(x) D(x) (which
equivalent first-order translation C v D) expressed GNFO;
role inclusion axiom v R ALCHOIQGN role inclusion axiom R
roles (atomic inverse atomic) formula x, y. S(x, y) R(x, y) ,
(x, y) stands (x, y) preceding role atomic (x, y) stands (y, x)
preceding role inverse atomic, expressed GNFO.
easy see, ALCHOIQ role inclusion axiom ALCHOIQGN role inclusion
axiom. Proposition 12 following holds.
Proposition 13.

ALCHOIQGN role inclusion axioms safe-range.

safe-range role inclusion axioms ALCHOIQ ALCHOIQGN .
definition GNFO ALCHOIQ follows, complex concept C
logic ALCHOIQGN recursively defined follows:
B ::= | {o} | nR
C ::= B | nR.C | nR.C | B u C | C u | C

(8)

atomic concept, R atomic role inverse atomic role, C
ALCHOIQGN concepts (possibly complex).
Note, general, according definition (7) GNFO formulas atleast
operator n 2 GNFO non-guarded inequality statements xi 6=
xj . fix assuming inequality relation actually special binary database
predicate. assumption usual databases.
916

fiExact Query Reformulation DBs FO DL Ontologies

strictly speaking nR u C GNFO. Indeed, formula
(x1 , . . . , xn . R(x, x1 ) . . . R(x, xn ) (x1 6= x2 ) . . . (xn1 6= xn )) C(x)
GNFO (R(x, y) stands P (x, y) R stands atomic role P , R(x, y) stands
P (y, x) R stands inverse atomic role P ), easily transformed
logically equivalent GNFO one simply shifting parentheses: x1 , . . . , xn . (R(x, x1 )
. . . R(x, xn ) (x1 6= x2 ) . . . (xn1 6= xn ) C(x)). So, assume, formula
nR u C ALCHOIQGN .
Proposition 14. ALCHOIQGN concepts safe-range.
Proof. Let us prove induction structure ALCHOIQGN concepts defined
(8).
1. A, {o}, nR, nR.C, nR.C (C ALCHOIQGN concept) safe-range
item 1 Proposition 11.
2. atomic concept A, individual role R natural number n
concepts u C, {o} u C nR u C safe-range item 3
Proposition 11 since A, {o} nR safe-range first item.
3. Suppose, ALCHOIQGN concepts C safe-range. concepts
C u C safe-range items 2 3 Proposition 11 respectively.
proposition proved.
Lemma 4. safe-range concept C ALCHOIQ following holds:
C v B1 . . . Bn ,
Bi appears subconcept C one following concepts:
atomic concept A;
{o}, individual name;
nR, R atomic role inverse atomic role, n natural number.
Proof. Let us prove proposition induction safe-range concepts ALCHOIQ.
A, {o}, nR, nR.C safe-range Proposition 11. v A, {o} v {o}, nR v
nR, nR.C v nR.
Suppose C complex safe-range concept proposition holds
safe-range subconcepts C.
1. C = C1 u C2 - safe-range. either C1 C2 safe-range. Let C1 safe-range.
Hence, C1 v B1 . . . Bm , Bi concept aforementioned type.
C1 u C2 v C1 v B 1 . . . B .
2. C = C1 C2 - safe-range. C1 C2 safe-range. Hence, C1 v B1 . . . Bk
C2 v Bk+1 . . . Bm , Bi concept aforementioned type.
C1 C2 v (B1 . . . Bk ) (Bk+1 . . . Bm ) v B1 . . . Bm .
917

fiFranconi, Kerhet, & Ngo

3. C = safe-range. Proposition 11 possible saferange. one following cases takes place.
= D1 u D2 . D1 D2 . reduced case item 2.
= D1 D2 . D1 u D2 . reduced case item 1.
= D1 . D1 D1 . Hence, D1 safe-range subconcept D.
proposition holds D1 and, hence, C, C D1 .
lemma proved completely.
Lemma 5. ALCHOIQ concept C exists ALCHOIQGN concept C 0
either C C 0 C C 0 .
Proof. Suppose lemma holds ALCHOIQ subconcepts ALCHOIQ
concept C. Let us prove C.
1. Base. A, {o}, nR ALCHOIQGN concepts definition ALCHOIQGN
concept (8).
2. C = nR.D D0 ALCHOIQGN concept D0
D0 . C nR.D0 C nR.D0 . nR.D0 nR.D0
ALCHOIQGN concepts. Hence, item proved.
3. C = D0 ALCHOIQGN concept D0 D0 .
C D0 C D0 D0 . item proved.
4. C = C1 u C2 C10 ALCHOIQGN concept C1 C10 C1 C10 , C20
ALCHOIQGN concept C2 C20 C2 C20 . Consider possible
cases.
(a) C1 C10 C2 C20 . C C 0 , C 0 = C10 u C20 ALCHOIQGN
concept (because C10 C20 ALCHOIQGN concepts).
(b) C1 C10 C2 C20 . C C10 u C20 (C10 C20 ) = C 0 ,
C 0 = C10 tC20 ALCHOIQGN concept (because C10 C20 ALCHOIQGN
concepts).
(c) C1 C10 C2 C20 (the case C1 C10 C2 C20 similar
one). C C10 u C20 . Since C10 ALCHOIQGN concept Proposition
14 safe-range and, hence, Lemma 4 C10 v B1 . . . Bn , Bi
either atomic concept {o} R. C10 C10 u (B1 . . . Bn ) and,
hence, C C10 u (B1 . . . Bn ) u C20 C10 u (B1 u C20 . . . Bn u C20 ).
disjunct Bi u C20 ALCHOIQGN concept (because C2 ALCHOIQGN
concept definition (8) ALCHOIQGN concepts). C 0 = C10 u
(B1 u C20 . . . Bn u C20 ) ALCHOIQGN concept. C C 0 . item
proved.
5. C = C1 C2 (C1 u C2 ). case reduced items 3 4.
918

fiExact Query Reformulation DBs FO DL Ontologies

lemma proved completely.
Corollary 2. ALCHOIQ concept C concept B, either atom
{o} nR, concept B u C equivalent ALCHOIQGN concept.
Proof. Lemma 5 exists ALCHOIQGN concept C 0 either C C 0
C C 0 . B u C B u C 0 B u C B u C 0 . B u C 0 B u C 0
ALCHOIQGN concepts (by definition (8) ALCHOIQGN concepts). Hence,
corollary proved.
Proposition 15. safe-range ALCHOIQ concept equivalent ALCHOIQGN
concept.
Proof. Let C safe-range ALCHOIQ concept. Lemma 4 C v B1 . . . Bn ,
Bi either atom {o} nR. C C u (B1 . . . Bn )
B1 uCt. . .tBn uC. corollary 2 disjunct Bi uC exists ALCHOIQGN
concept Di Bi u C Di . C D1 . . . Dn . concept D1 . . . Dn
ALCHOIQGN concept disjunction ALCHOIQGN concepts. Hence, proposition
proved.
Proposition 16. ALCHOIQGN concept inclusion axioms safe-range.
Proof. Let C v concept inclusion axiom ALCHOIQGN . means
corresponding first-order logic translation x. C(x) D(x) GNFO. Hence, C(x)
D(x) GNFO or, same, C u ALCHOIQGN . easy see,
x. C(x) D(x) safe-range formula C(x) D(x) safe-range,
corresponding ALCHOIQGN concept C u safe-range.
Proposition 14 ALCHOIQGN concept safe-range. proposition proved.
Lemma 6. safe-range ALCHOIQ concept C ALCHOIQ concept
concept C u equivalent ALCHOIQGN concept C 0 u D0 , C 0 D0
ALCHOIQGN concepts.
Proof. Since C safe-range Lemma 4 C v B1 . . . Bn , Bi either
atomic concept {o} R. C C u (B1 . . . Bn ) and, hence, C u
C u (B1 . . . Bn ) u C u (B1 u . . . Bn u D). corollary 2 disjunct
Bn uD ALCHOIQGN concept. Hence, D0 := B1 uDt. . .tBn uD ALCHOIQGN
concept. Since C safe-range Proposition 15 exists ALCHOIQGN concept
C 0 C C 0 . C u C 0 u D0 , C 0 u D0 ALCHOIQGN concept,
C 0 D0 ALCHOIQGN concepts.
Proposition 17. safe-range ALCHOIQ concept inclusion axiom C v transformed concept inclusion axiom C 0 v D0 , C 0 D0 ALCHOIQGN .
Proof. Let C v safe-range ALCHOIQ concept inclusion axiom. corresponding formula x. C(x) D(x) safe-range. first-order logic formula
C(x) D(x) safe-range, or, same, ALCHOIQ concept C u saferange. Proposition 11 C safe-range safe-range.
919

fiFranconi, Kerhet, & Ngo

C safe-range. Lemma 6 exist two ALCHOIQGN concepts C 0
D0 C u logically equivalent ALCHOIQGN concept C 0 u D0 .
x. C(x) D(x) logically equivalent x. C 0 (x) D0 (x). Hence, C v
logically equivalent C 0 v D0 (C 0 D0 ALCHOIQGN concepts).
safe-range. proof similar previous item.
proposition proved completely.
Proposition 18. two ALCHOIQGN concepts C axiom C v
ALCHOIQGN concept inclusion axiom.
Proof. axiom C v logically equivalent first-order logic formula x. C(x)
D(x), C(x) D(x) GNFO. x. C(x) D(x) GNFO. Hence,
definition ALCHOIQGN concept inclusion axiom axiom C v
ALCHOIQGN concept inclusion axiom.
Propositions 17 18 imply following.
Proposition 19. safe-range ALCHOIQ concept inclusion axiom equivalent
ALCHOIQGN concept inclusion axiom.
consider connection safe-range fragment ALCHOIQ guarded negation fragment ALCHOIQ, ALCHOIQGN . say fragment, mean
set TBox assertions (concept role inclusion axioms) concepts (open formulas)
ALCHOIQ satisfying particular property (e.g safe-range guarded negation). Taking
account propositions 14, 15, 16, 19 13, following theorem.
Proposition 20. safe-range fragment ALCHOIQ ALCHOIQGN equally
expressive.
proves Theorem 10:
Theorem 10 (Expressive power equivalence). domain independent fragment
ALCHOIQ ALCHOIQGN equally expressive.
Theorem 11. ALCHOIQGN TBoxes finitely controllable determinacy concept
queries.
Proof. need prove, ALCHOIQGN TBox (ontology), concept
query Q ALCHOIQGN set database predicates PDB , whenever query
finitely determined database predicates ontology determined
unrestricted models.
Suppose, Q finitely determined PDB . Theorem 2
e |=fin P means entailment models
follows, Te |=fin PDB Q v Q,
DB
e
finite interpretation database predicates. Hence, particular Te |=fin Q v Q,
|=fin means entailment finite models. Hereafter let one sentence,
first-order logic translation conjunction axioms TBox .
aforementioned entailment have:
e
|=fin ( e
) (x. Q(x) Q(x)).
920

(9)

fiExact Query Reformulation DBs FO DL Ontologies

e
Proposition 14 Q(x) safe-range. Hence, Q(x) Q(x)
safe-range, hence
e safe-range and, hence, Proposition 15 exists
ALCHOIQ concept Q u Q
e C 0 . x. Q(x) Q(x)
e
ALCHOIQGN concept C 0 Q u Q
x.C 0 (x)
following holds:
|=fin ( e
) (x.C 0 (x)).
(10)
x.C 0 (x) GNFO, C 0 (x) GNFO. Since axioms ALCHOIQGN
TBox axioms, sentences e GNFO. sentence e
GNFO.
Therefore right hand side entailment (10) GNFO. (( e
)
(x.C 0 (x))) GNFO entailment (10) finite model.
Then, since GNFO finite model property, (( e
) (x.C 0 (x))) unsatisfiable. Hence, have:
|= ( e
) (x.C 0 (x)).
e
Since x.C 0 (x) x. Q(x) Q(x),
following holds:
e
|= ( e
) (x. Q(x) Q(x)).
e Theorem 2 means, query Q determined
Te |= Q v Q.
unrestricted models database predicates PDB ontology .
proposition proved.

References
Abiteboul, S., Hull, R., & Vianu, V. (1995). Foundations Databases. Addison-Wesley.
Artale, A., Calvanese, D., Kontchakov, R., & Zakharyaschev, M. (2009). DL-Lite family
relations. J. Artif. Intell. Res. (JAIR), 36, 169.
Avron, A. (2008). Constructibility decidability versus domain independence absoluteness. Theor. Comput. Sci., 394, 144158.
Barany, V., Gottlob, G., & Otto, M. (2010). Querying guarded fragment. Proceedings
25th Annual IEEE Symposium Logic Computer Science (LICS 2010), pp.
110.
Barany, V., ten Cate, B., & Otto, M. (2012). Queries guarded negation (full version).
CoRR, abs/1203.0077.
Beth, E. (1953). Padoas method theory definition. Indagationes Mathematicae,
15, 330339.
Craig, W. (1957). Three uses Herbrand-Gentzen theorem relating model theory
proof theory. J. Symb. Log., 22 (3), 269285.
Etzioni, O., Golden, K., & Weld, D. S. (1997). Sound efficient closed-world reasoning
planning. Artif. Intell., 89, 113148.
Fan, W., Geerts, F., & Zheng, L. (2012). View determinacy preserving selected information data transformations. Inf. Syst., 37, 112.
Fitting, M. (1996). First-order logic automated theorem proving (2nd edition). Springer.
921

fiFranconi, Kerhet, & Ngo

Franconi, E., Ibanez-Garcia, Y. A., & Seylan, Inanc. (2011). Query answering DBoxes
hard. Electronic Notes Theoretical Computer Science, Elsevier, 278, 7184.
Franconi, E., Kerhet, V., & Ngo, N. (2012a). Exact query reformulation SHOQ DBoxes.
Proc. 2012 International workshop Description Logics (DL-2012).
Franconi, E., Kerhet, V., & Ngo, N. (2012b). Exact query reformulation first-order ontologies databases. Logics Artificial Intelligence - 13th European Conference,
JELIA 2012, pp. 202214.
Franconi, E., Ngo, N., & Sherkhonov, E. (2012c). definability abduction problem
data exchange. Web Reasoning Rule Systems - 6th International Conference
RR 2012.
Gurevich, Y. (1984). Toward logic tailored computational complexity. Computation
Proof Theory, Vol. 1104, pp. 175216. Springer.
Halevy, A. Y. (2001). Answering queries using views: survey. VLDB Journal, 10,
270294.
Marx, M. (2007). Queries determined views: pack views. Proceedings 26th
ACM symposium Principles Database Systems, PODS 07, pp. 2330.
McCune, W. (20052011).
prover9.

Prover9 Mace4.

http://www.cs.unm.edu/~mccune/

Nash, A., Segoufin, L., & Vianu, V. (2010). Views queries: Determinacy rewriting.
ACM Trans. Database Syst., 35, 21:121:41.
Rosati, R. (2011). finite controllability conjunctive query answering databases
open-world assumption. J. Comput. Syst. Sci., 77 (3), 572594.
Seylan, Inanc., Franconi, E., & de Bruijn, J. (2009). Effective query rewriting ontologies DBoxes. Proc. 21st International Joint Conference Artificial
Intelligence (IJCAI 2009), pp. 923925.
ten Cate, B., Franconi, E., & Seylan, Inanc. (2011). Beth definability expressive description logics. Proc. 22nd International Joint Conference Artificial
Intelligence (IJCAI 2011), pp. 10991106.
ten Cate, B., Franconi, E., & Seylan, Inanc. (2013). Beth definability expressive description logics. Journal Artificial Intelligence Research (JAIR), 48, 347414.

922


