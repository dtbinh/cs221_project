journal artificial intelligence

submitted published

tractability csp classes defined forbidden patterns
david cohen

dave cs rhul ac uk

department computer science
royal holloway university london
egham surrey uk

martin c cooper

cooper irit fr

irit
university toulouse iii toulouse france

paid creed

p creed qmul ac uk

school mathematical sciences
queen mary university london
mile end london uk

daniel marx

dmarx cs bme hu

computer automation institute
hungarian academy sciences mta sztaki
budapest hungary

andras z salamon

andras salamon ed ac uk

laboratory foundations computer science
school informatics university edinburgh uk

abstract
constraint satisfaction csp general central computer
science artificial intelligence although csp np hard general considerable
effort spent identifying tractable subclasses main two approaches consider
structural properties restrictions hypergraph constraint scopes relational
properties restrictions language constraint relations recently authors
considered hybrid properties restrict constraint hypergraph relations
simultaneously
key contribution novel concept csp pattern classes
defined forbidden patterns viewed forbidding generic sub
describe theoretical framework used reason classes
defined forbidden patterns framework generalises certain known
hybrid tractable classes
although close obtaining complete characterisation concerning
tractability general forbidden patterns prove dichotomy special case classes
arise forbid binary negative patterns generic subproblems disallowed tuples specified case finite
sets forbidden patterns define polynomial time solvable np complete classes
instances
c

ai access foundation rights reserved

ficohen cooper creed marx salamon

introduction
constraint satisfaction paradigm consider computational
assign values domain variables constraints constraint
limits simultaneous values list variables scope assigned
typical situation pair variables might represent starting times two jobs
machine shop scheduling reasonable constraint would require minimum time
gap values assigned two variables
constraint satisfaction proved useful modelling tool variety contexts
scheduling timetabling bio informatics computer vision
led development number successful constraint solvers unfortunately solving
general constraint satisfaction csp instances np hard
significant effort finding tractable fragments csp
principle stratify csp two quite distinct natural ways structure constraint scopes instance csp thought hypergraph
variables vertices generally relational structure
tractable classes restricting relational structure allowing arbitrary constraints
resulting scopes dechter pearl sub general constraint
obtained restrictions called structural alternatively set allowed assignments variables scope seen relation choose
allow specified kinds constraint relations allow interact arbitrary structure jeavons cohen gyssens restrictions called relational
language
structural subclasses defined specifying set hypergraphs relational structures allowed structures csp instances shown tractable
structural classes characterised limiting appropriate structural width measures
dechter pearl freuder gyssens jeavons cohen gottlob leone
scarcello marx b example tractable structural class binary
csps obtained whenever restrict constraint structure graph
case bounded tree width dechter pearl freuder fact
shown subject certain complexity theoretic assumptions structures
give rise tractable csps bounded hyper tree width dalmau
kolaitis vardi grohe marx b
relational subclasses defined specifying set constraint relations complexity subclass arising restriction precisely determined
called polymorphisms set relations bulatov jeavons krokhin cohen
jeavons polymorphisms specify whenever set tuples
constraint relation cannot case particular tuple applying
polymorphism constraint relation thus relationship allowed tuples disallowed tuples inside constraint relations key importance
relational tractability given class instances whilst general dichotomy
yet proven relational case many dichotomies sub
obtained instance bulatov bulatov et al bulatov


fitractability csp classes defined forbidden patterns

structural relational restrictions limits possible subclasses
defined allowing restrictions structure relations able
identify tractable classes call restrictions hybrid reasons tractability
several hybrid published binary csps jegou weigel bliek
cohen salamon jeavons cooper jeavons salamon cooper
zivny b instead looking set constraint scopes constraint language
captured tractability properties coloured microstructure
csp instances microstructure binary csp instance graph hv ei v
set possible assignments values variables e set pairs mutually
consistent variable value assignments jegou coloured microstructure
vertices representing assignment variable vi labelled colour representing
variable vi maintains distinction assignments different variables
coloured microstructure csp instance captures structure
relations csp instance natural place look tractable classes
neither purely structural purely relational coloured microstructure
properties three particular note first observed class instances
perfect microstructure tractable salamon jeavons proper
generalisation well known hybrid tractable csp class whose instances allow arbitrary
unary constraints every pair variables constrained equal regin
van hoeve hybrid class whose microstructure triangulated jegou
weigel bliek cohen perfect microstructure property excludes
infinite set induced subgraphs microstructure
secondly joint winner property jwp cooper zivny b applied csps
provides different hybrid class strictly generalises class csp instances
disequality constraint every pair variables arbitrary set
unary constraints forbidding single pattern subgraph coloured
microstructure jwp generalized hierarchies soft non binary constraints cooper zivny including example soft hierarchical global cardinality
constraints reduction minimum convex cost flow
thirdly called broken triangle property properly extends structural notion
acyclicity interesting hybrid class cooper et al broken triangle
property specified excluding particular pattern coloured microstructure
notion forbidden pattern study therefore work directly
csp instance equivalently coloured microstructure rather microstructure
abstraction simple graph allows us introduce language expressing
hybrid classes terms forbidden patterns providing framework search
novel hybrid tractable classes case binary negative patterns able
characterise tractable finite sets forbidden patterns state necessary
condition tractability finite set general patterns
contributions
generalise definition csp instance csp pattern
three types tuple constraint relations tuples explicitly al

ficohen cooper creed marx salamon

lowed disallowed tuples labelled unknown defining natural notion
containment patterns csp able describe defined forbidden
patterns class csp instances defined forbidding particular pattern exactly
instances contain use framework capture tractability
identifying local patterns allowed disallowed tuples within small groups connected
constraints whose absence enough guarantee tractability
concept forbidden patterns lay foundations theory
used reason classes csps defined hybrid properties since first
work kind primarily focus simplest case binary patterns tuples
disallowed unknown called negative patterns give large class binary
negative patterns give rise intractable classes
negative pattern defines tractable class must certain
structure able prove structure enough guarantee tractability
thus providing dichotomy tractability defined forbidding binary negative patterns
importantly intractability allow us give necessary condition
form general tractable patterns
remainder structured follows section define constraint
satisfaction give definitions used section
define notion csp pattern describe classes defined forbidden
patterns give examples tractable classes defined forbidden patterns three
variables section one must take size patterns account
notion maximal classes defined forbidding patterns general yet able
make conjecture concerning dichotomy hybrid tractability defined general
forbidden patterns however section able give necessary condition
class tractable section prove dichotomy negative patterns finally
section summarise discuss directions future

preliminaries
definition csp instance triple hv ci
v finite set variables n v
finite set called domain
c set constraints constraint c c pair c h
list distinct variables called scope c
relation arity called relation c set tuples
allowed c
solution csp instance p hv ci mapping v
h c represents tuple resulting application
component wise list variables
viewed natural generalisation csp three valued logic



fitractability csp classes defined forbidden patterns

simplicity presentation assume variables domains
unary constraints used impose different domains different variables
arity csp largest arity constraint scopes long term
aim identify tractable subclasses csp detected
polynomial time describe general theory forbidden patterns
arbitrary arity consider implications theory tractable classes
arity two binary specified finite sets forbidden patterns cases
certain class membership decided polynomial time
csp decision asks whether particular csp instance solution
already np complete binary csps example straightforward reduction
graph colouring set colours used domain
csp instance vertices graph map csp variables vi edges j map
disequality constraints vi vj
sometimes convenient use equivalent functional formulation
constraint alternative formulation scope constraint h abstracted set variables possible assignment seen function f
constraint relation alternative view function set possible
assignments set f convention tuples occur
constraint relation map follows assignment set
variables allowed h restriction mapped
definition function f x x notation f means
function domain satisfying f x f x x
given set v variables domain constraint functional representation
pair h v f csp instance functional representation triple hv ci c set constraints functional representation
solution csp instance hv ci functional representation mapping
v h c
functional formulation clearly equivalent relational formulation
use whichever seems appropriate throughout choice
clear context
following notions standard study csp binary csp instance
one maximum arity constraint scope two subproblem
variables u v instance hu cu cu set constraints h c
u instance arc consistent v v v solution
subproblem v extended solution subproblem v v
constraint graph binary csp instance hv ci graph vertices
v edges set scopes binary constraints c since often convenient
consider possibly irrelevant constraint exists every pair variables
introduce refined notion true constraint graph
definition binary constraint v v improper allows every pair
values allowed unary constraints v v proper otherwise
true constraint graph binary csp instance constraint graph
instance removing improper binary constraints


ficohen cooper creed marx salamon

may sometimes need disregard unary constraints following
definition binary reduction csp instance obtained removing
constraint set constraints whose scope arity two

forbidden patterns csp
explain define classes csp instances forbidding
occurrence certain patterns csp pattern generalisation csp instance
csp pattern define relations relative three valued logic f u meaning
pattern seen representing set csp instances undefined value u replaced f forbidding csp pattern equivalent
simultaneously forbidding instances sub
definition define three valued logic f u u stands unknown
undefined set f u partially ordered u u f f
incomparable let finite set k ary three valued relation function
dk f u given k ary three valued relations say realises
x dk x x
extend definition csp constraint pattern include additional structure set variable names set domain values set relations
set question adding structure makes patterns specific therefore capture larger hence interesting tractable classes example domain
totally ordered define tractable max closed class jeavons cooper
independent total order domain variable capture
renamable horn class green cohen placing order variables
pattern allow us define class tree structured csp instances
definition csp pattern quadruple hv c si
v set variables associated relational structure universe v
domain associated relational structure universe
c set constraint patterns constraint pattern c c pair c h
v scope c list distinct variables f u
three valued relation functional representation c constraint pattern
non trivial three valued relation maps least one tuple f
structure set consisting relational structures associated
variable set domain
arity csp pattern maximum arity constraint pattern h
basic type pattern one employs structure empty
frequently require patterns use disequality relation applied every pair


fitractability csp classes defined forbidden patterns

specified subset variables allow several subsets variables
structure
relations occurring structure arity two interpretation limited selected binary relations representing disequality partial
order structure variable set domain clear context
explicitly mention different kinds structure imposed csp patterns indeed
structures specified general relations would interesting area future study
weakest structure consider allows us say two variables
distinct thus structure csp pattern simply set disequalities
subsets variables denote disequalities neq v vr meaning
variables v v vr pairwise distinct pattern structure
called flat indeed mostly concerned flat patterns two
variables occur together scope constraint pattern assume
implicitly includes disequality neq v v
thus csp patterns defined relational structures three sorts variables
domain values variable value assignments constraint patterns csp
pattern three valued relations sort variable value assignments csp
pattern flat structure specifies relations sort variables partial order
variables relation sort variables partial orders domain
values relations sort domain values
simplicity presentation assume throughout two constraint
patterns c scope case csp instances two
constraints scope represent binary csp patterns simple diagrams oval represents domain variable dot domain value tuples
constraint patterns value f shown dashed lines value solid
lines value u depicted
definition constraint pattern h called negative never takes
value csp pattern negative every constraint pattern negative
patterns csps occurrence
csp instance implicitly assumed variables domain values
distinct equivalent existence implicit disequalities neq variable
names domain values csp instance csp pattern structure
variables domain values distinct three valued relations
constraint patterns never take value u decide possible tuple
whether relation furthermore csp instance pair
variables assume constraint exists scope explicit constraint
given scope assume relation complete e contains tuples
contrasted csp patterns absence explicit constraint
pair variables implies truth value tuple undefined
order define classes csp instances forbidding patterns require formal
definition occurrence containment pattern within instance define
general notion containment one csp pattern within another pattern informally
names variables domain elements csp pattern inconsequential


ficohen cooper creed marx salamon

containment allows renaming variables domain values variable
thus order define containment patterns firstly require formal definition
renaming arbitrary renaming unless explicitly prohibited disequality
structure two distinct variables may map variable two distinct domain
values may map domain value furthermore pattern occurs another
may use subset variables second pattern hence notion require
known renaming extension
domain labelling set variables assignment domain values
variables variable domain renaming induces mapping domain labellings
scopes constraints simply assign renamed domain values renamed variables natural way extend mapping domain labellings mapping
constraint pattern truth value mapped domain labelling
truth value original domain labelling however may occur two domain
labellings scope map domain labelling instead resulting value
taken greatest original truth values order process
well defined two domain labellings constraint mapped domain labelling original truth values must comparable leads following
formal definition renaming extension first step towards definition
containment
definition let hv c si hv c csp patterns
say renaming extension exist variable renaming function v v domain renaming function v
assignment renaming function f v v induced defined
f hv ai hs v v satisfy
constraint pattern h c two domain labellings
f f comparable f denotes
assignment f v f v v v
c hs h c assignment f f u
f f every f max f f otherwise
structure f preserve structure mapping induces
homomorphism relational structures variable sets mapping
induces homomorphism relational structures domains
particular neq v v v v neq v v
use patterns define sets csp instances forbidding occurrence containment patterns csp instances way able characterise
tractable subclasses csp informally pattern said occur csp instance
p sub q p formed taking subsets variables domains
realises q realises renaming variables domain values
constraint pattern realised corresponding constraint q definition
renaming extension extra variables domain values disequalities introduced thus need combine notions renaming extension realisation
formally define mean pattern occurring another pattern particular
csp instance


fitractability csp classes defined forbidden patterns

definition say csp pattern occurs csp pattern p hv c si
p contains denoted p renaming extension hv c si
every constraint pattern h c constraint pattern h c
furthermore realises
pattern

b
b

c



b




c





x


z



x



c




x

ii

iii

pattern
b





c


x

example example describes three simple containments consider three csp
patterns pattern iii patterns occur contained pattern
mappings f f f respectively describe
f simply bijection although patterns different valid containment
pattern pattern three valued relation pattern realisation
three valued relation pattern replacing b u b f
f maps x x b c maps
merging domain elements possible values three valued
constraint relation pattern ii comparable tuples involving assignments
furthermore restriction three valued relation pattern ii
two assignments realised three valued constraint relation
pattern b f example replacing u
similar manner pattern contained pattern simple
mapping f maps x b x x b c c
finally f maps c maps x z b pattern iii x x b respectively pattern merging variables pos

ficohen cooper creed marx salamon

sible three valued relations agree neq x z structure
pattern iii

pattern
z
b

b





z
c




x

c




x

neq x z


ii

throughout use notation neq v vr denote fact
variables v vr csp pattern distinct worth discussing structure
implies far definition concerned structure source pattern must
preserved target pattern thus pattern iii occurs pattern pattern
contained pattern iii since structure neq x z preserved target
pattern structure neq v v considered preserved renaming extension
even explicitly given implicit example due existence
non trivial constraint pattern h v v example consider
two csp patterns pattern ii pattern mapped pattern ii
simple bijection three valued relation pattern ii realisation
three valued relation pattern structure neq x z considered preserved
mapping due existence non trivial constraint pattern variables
x z pattern ii hence pattern occurs pattern ii
continuing need define mean say class csp
instances definable forbidden patterns
definition let c class csp instances maximum arity k say
c definable forbidden patterns set patterns x set
csp instances maximum arity k none patterns x occur precisely
instances c
notation let x set csp patterns maximum arity k use csp x
denote set csp instances element x occurs x singleton
use csp denote csp
consider classes csp x sets x csp patterns
binary sense constraint patterns scope size exactly two
x patterns x binary csp x closed arc consistency
sense arc consistency closure instance csp x belongs


fitractability csp classes defined forbidden patterns

csp x operation updates unary constraints indeed changing
unary constraints cannot introduce patterns x instance csp x
tractable patterns
define forbidding certain patterns tractable subclasses csp
furthermore give examples truly hybrid classes e classes definable
purely relational purely structural properties
definition finite set patterns x intractable csp x np hard
tractable polynomial time solve csp x single pattern
tractable intractable tractable intractable assume throughout
p np therefore sets tractable intractable patterns disjoint
worth observing classes csp instances defined forbidding patterns
fixed domain recall however csp instance finite domain
structure present csp instance assumed given part instance particular
variables csp instance assumed distinct finite sets patterns x
number possible renaming extensions particular instance p polynomial
size p hence determine whether instance lies csp x exhaustive
search polynomial time
need following simple lemmas proofs intractability later
sections
lemma
proof constraint pattern h maps constraint pattern h
realises transitivity follows following facts
realisation operation transitive
definition structure preserved
hence
lemma let x sets csp patterns suppose every pattern
pattern x csp x csp
proof let p csp x p x cannot p
since would imply exists x p hence
p lemma hence p csp
corollary let x sets csp patterns suppose every pattern
pattern x
csp intractable csp x intractable conversely
csp x tractable whenever csp tractable
finally give examples tractable patterns first example negative
pattern since truth values relations f u


ficohen cooper creed marx salamon

pattern simple negative pattern
v


x
c
c

w
b
neq v w x

example consider pattern defines class csps trivially tractable
forbidding pattern ensures paths two variables true
constraint graph thus forbidding pattern decomposed set
independent sub two variables

example cooper zivny b showed forbidding pattern negtrans
shown pattern describes tractable class csp instances seen generalisation well known tractable class alldifferent unary costa
regin van hoeve instance class consists set variables
v set arbitrary unary constraints v constraint v w defined pair
distinct variables v w v forbidding negtrans equivalent saying disallowed
tuples form transitive relation e hv ai hx bi hx bi hw ci disallowed
hv ai hw ci must disallowed thus negtrans occur binary csp
instance class alldifferent unary transitivity equality equality
exactly disallowed

pattern negative transitive pattern negtrans
v
x

w

neq v w x
cooper zivny b recently showed tractable class defined
forbidding pattern negtrans extended soft constraint


fitractability csp classes defined forbidden patterns

tractable patterns structure
primarily studies patterns weak structure conditions
imposed variables distinct however worth pointing adding
structure pattern allows us capture larger classes instances example
forbidden pattern capture class csps tree width
adding variable ordering pattern case pattern containment must preserve
total order ordered pattern consider unordered csp p
csp exists ordering variable set p forbidden
order define tractable class must possible ordering polynomial
time case patterns examples
pattern tree structure pattern tree

v
v
v
v v v
example consider pattern tree given pattern class
csp tree exactly set csps whose true constraint graph forest e tree
width first suppose p csp tree exists ordering v vn
variable shares proper constraint one variable preceding
ordering hand suppose p csp whose true constraint graph
tree ordering vertices according pre order traversal obtain ordering
variable shares proper constraint one variable preceding
ordering parent thus p csp tree

example forbidding pattern btp shown pattern known brokentriangle property cooper et al order capture class forbidden
pattern impose total order pattern variables cooper et al
proved class csp instances csp btp solved polynomial time
indeed csp instances csp btp unknown total ordering variables
recognised solved polynomial time

easy see tree shown pattern occurs btp truthvalues u changed follows lemma csp tree csp btp
hence class csp btp includes csp instances whose true constraint graph tree
however csp btp includes certain csp instances whose true constraint graph


ficohen cooper creed marx salamon

pattern broken triangle pattern btp

b

v


v
v
v v v

tree width r value r consider example csp instance r variables
identical constraint every pair variables simply disallows single
tuple h
tractable forbidden pattern order imposed variables
obtain another tractable class considering forbidding pattern without
ordering condition class obtained generally smaller easier establish
containment flat pattern example consider pattern flat version
pattern seen forbidding pattern gives rise class csp instances
paths length greater two true constraint graph
hand forbidding pattern gives much larger class csp instances
true constraint graph tree width
case broken triangle property obtain strictly smaller tractable
class forbidding pattern triples variables v v v irrespective order
easily exhibit csp instance shows inclusion strict example
variable csp instance boolean domains consisting two constraints v v
v v variable ordering v v v unordered version btp
recently used obtain dichotomy patterns consisting constraints cooper
escamocher

maximal tractable classes defined forbidden patterns
relational tractability define maximal tractable sub csp
given set possible relations class relations maximal possible
add even one relation without sacrificing tractability
case structural tractability picture less clear since measure
complexity infinite set hypergraphs generally relational structures
obtain tractability bound width measure structures whatever
width measure chosen containment class width bounded k inside
class width bounded k maximal class possible although
k unique maximal class structurally tractable instances section
case forbidden patterns situation similar


fitractability csp classes defined forbidden patterns

definition let hv c si hv c two flat csp patterns
dd
extend constraint pattern
form disjoint unions v v
setting value tuple including elements
c domain dd

u extend similarly constraint patterns c way define c c
forming disjoint union adding
define structure

disequalities neq v v v v v v set disjoint union
hv v
dd
c c



lemma let flat non empty e containing least one variable binary
csp patterns

csp csp csp
tractable whenever csp csp tractable
moreover csp
proof begin showing strict inclusion

csp csp csp
inclusion holds follows directly lemma among patterns
occurs let pattern smallest number variables define similarly
see inclusion strict observe occur csp pattern whose
domain disjoint union whose variable set size equal
larger variable sets csp instance containing pattern
neither csp csp however construct csp instance containing
structure
imposing disequalities
pattern contained csp

variables means contained pattern
simply enough variables
p csp csp p solved polynomial
suppose p csp
time tractability csp csp
may suppose p choose particular occurrence p let
denote set variables used containment consider assignment
let pt denote obtained making assignment enforcing
arc consistency resulting corresponds adding unary
constraints p
must occur p see observe
occurs pt
containment pm naturally induces containment p extends
p considering occurrence thus conclude
containment
pt csp solved polynomial time
construction solution pt extends solution p adding assignment
variables moreover every solution p corresponds solution pt
since size fixed iterate solutions polynomial
time p solution solution pt
pt solution know p solution thus since solve
pt polynomial time solve p polynomial time
corollary tractable class defined forbidding flat pattern maximal


ficohen cooper creed marx salamon

defined disjoint
proof let tractable flat pattern consider pattern

union two copies lemma csp
tractable

csp csp
hence csp maximal tractable class
follows cannot characterise tractable forbidden patterns exhibiting
maximal tractable classes defined forbidding pattern finite set patterns
since lemma finite set replaced single pattern indeed
consequence lemma construct infinite chain patterns
forbidding one gives rise slightly larger tractable class naturally place
upper bound size patterns finitely many patterns
consider maximal tractable classes defined forbidden patterns bounded size
necessarily exist

binary flat negative patterns
moment able make conjecture concerning complete characterisation complexity general forbidden patterns although conjecture
dichotomy exists nonetheless restricting attention special case forbidden
binary flat negative patterns able obtain dichotomy recall pattern
flat structure imposed variables distinct
negative constraint patterns h never takes value
begin defining three particular patterns one infinite class patterns
use patterns characterise large class intractable patterns prove
finite set flat negative patterns class simple structure one
patterns must contained one particular set patterns call pivots
means tractable set patterns must include pattern occurs
pivot pattern furthermore demonstrate forbidding pivot pattern gives rise
tractable class leads simple characterisation tractability finite
sets binary flat negative patterns
pattern cycle
c
c
v

v

v

v

v

neq v v



v

fitractability csp classes defined forbidden patterns

pattern valency
x

x

x

x

x

x
neq x x x x neq x x x

pattern path

v

v

v

w

w

w

neq v v v w neq w w w
definition define concept neg connected binary pattern
correspond binary patterns true constraint graph every realisation
binary csp instance connected graph first generalise notion true
constraint graph csp patterns call resulting graph negative structure graph
definition let binary pattern vertices negative structure
graph g variables pair vertices edge g form
scope whose constraint pattern assigns least one tuple value f say
pattern neg connected negative structure graph connected case
negative patterns use simpler term connected instead neg connected
pattern valency pattern path pattern valency path
connected note pattern connected may occur connected pattern
vice versa pattern shows cycle connected one example
generic pattern cycle k k structure cycle k
variables distinct except special case k structure
includes neq c c additional requirement means cycle composed
single binary constraint pattern containing two distinct disallowed tuples following
theorem uses patterns patterns intractable



ficohen cooper creed marx salamon

pattern valency path
v

v
w
v

w

w

x

neq v v v neq w w w neq x w
theorem let x finite set neg connected binary patterns x
least one cycle k k valency path valency path occurs
x intractable
proof let x finite set neg connected negative binary patterns let
number variables largest element x
assuming least one four patterns occurs x construct
class csps element x occurs polynomial time
reduction well known np complete sat garey johnson
construction involve three gadgets examples shown figure
gadgets serve particular purpose
cycle gadget shown figure special case variables enforces
cycle boolean variables v v vr take value
clause gadget figure b equivalent clause v v v since vc
value domain one three vi variables set true
obtain clauses three variables inverting domains vi
variables
line gadget figure c imposes constraint v v used
impose logically equivalent constraint v v
cycle gadget connected clause gadget via line gadgets three types
gadgets specified ensure one negative edge adjacent
vertex coloured microstructure except cycle gadget connected line
gadget
suppose instance sat n propositional variables
x xn clauses c cm
begin construction csp instance p solve sat instance
n copies cycle gadget figure variables n

variables along ith copy cycle denoted vi vi vi



fitractability csp classes defined forbidden patterns

v

f

v

vc
v

v

v


f
v

f

v


b


f
v

v
c

figure making copies variable v v v v b imposing
ternary constraint vc v v v c line constraints length
imposes v v

solution csp instance p constraints
variables vij j must value di therefore consider
vij copy xi
consider clause cw eight cases consider similar
details one case suppose cw xi xj xk
build clause gadget figure b three boolean variables ciw cjw ckw
invert domain ckw since occurs negatively cw solution
constructed csp must satisfy ciw cjw ckw
complete insertion cw csp instance adding line gadgets
length figure c connect cycle gadgets corresponding xi xj xk
w
clause gadget clause cw since xi xj xk occur cw connect vi
w
ciw since xi positive cw ciw possible vi



ficohen cooper creed marx salamon

w

solution similarly connect vj
cjw finally since xk occurs negatively
cw impose line constraints direction ensures ckw f
w
possible vk
f imposing constraints ensures solution
possible least one cycles corresponding variables xi xj xk
assigned value would make corresponding literal cw true
continue construction clause sat instance since constant
clearly polynomial reduction sat
csp instance p constructed manner described cannot contain pattern x showing neg connected
pattern containing cycle k k valency path valency path
occur instance sufficient csp instance p contain
patterns x
csp instance p constraint contains one disallowed tuple thus
x cycle cannot occur p furthermore p built
cycles length paths length cannot contain cycles less
vertices thus since maximum number vertices element x
follows x cycle k k occur p
define valency variable x number distinct variables share
constraint pattern x suppose valency x neg connected
possible require variable valency four pair
variables valency three connected path length negative structure
graph certainly p variables valency four moreover fact p
built paths length means two valency three variables joined
path length thus x occur p valency
next consider case path x neg connected must
two distinct possibly overlapping three variable lines disallowed tuples
constraint patterns match domain values separated variables
place disallowed tuples meet p connect line gadget
cycle gadget connection sites distance greater
conclude p whenever path
finally consider case valency path x neg connected
must variable valency least path constraint patterns
three variables intersecting disallowed tuples must connected path
less variables negative structure graph observed
places p disallowed tuples meeting line gadget meets
cycle gadget path least variables one points
every variable valency thus p whenever valency path
remains consider sets negative binary patterns could tractable
need define pivot patterns pivot r contain every tractable negative
binary pattern
definition let v p v vr w wr x xr b
neq p v vr w wr x xr define pattern pivot r


fitractability csp classes defined forbidden patterns

pattern pivot
v

v

v
w

w

w

p

x

x

x

b

neq p v v v w w w x x x

hv cp cv cw cx si
cp h p v ab h p w ab h p x bb
cv h vi vi ab r
cw h wi wi ab r
cx h xi xi ab r
ab b f ab u b bb b b f bb u
b b pattern pivot r structure variables
distinct see pattern example pivot
say pattern variables v vr distinct variable pattern
structure includes neq v vr following proposition characterises sets
connected binary flat negative distinct variable patterns theorem prove
intractable
proposition connected binary flat negative distinct variable pattern
contains cycle k k valency path valency path
occurs pivot r integer r
proof suppose contain patterns valency cycle k k
path valency path recall valency variable x number distinct
variables share constraint pattern x since contain valency
contain one variable valency three variables must valency
two moreover since cycle k k negative structure graph
contain cycles thus since connected negative structure graph
consists three disjoint paths joined single vertex two disallowed tuples


ficohen cooper creed marx salamon

distinct scopes intersect call union scopes footprint
intersection fact negative structure graph acyclic
contain path means pairs intersecting disallowed tuples must
footprint moreover fact contain valency path means
intersections must occur variable valency exists fact
flat negative means renaming extension pair disallowed tuples ha bi
hc di scope hu vi merged domain renaming function
e hu ai hu ci hv bi hv di follows occurs pivot r
r
corollary let x finite set connected binary flat negative distinct variable
patterns csp x tractable x occurs pivot r
integer r
prove patterns necessarily distinct variable
corollary let x finite set connected binary flat negative patterns
csp x tractable x occurs pivot r integer
r
proof connected binary flat negative pattern let dv denote set connected
binary flat negative distinct variable patterns occurs
domain variables use dv x denote union sets dv
x
lemma csp csp dv every csp instance p p
p dv follows csp dv csp hence
csp csp dv since csp x intersection csp x
csp dv x intersection csp dv x csp x
csp dv x
corollary csp dv x tractable pattern dv
x occurs pivot r r definition dv occurs
therefore csp x tractable occurs pivot r integer
r
arbitrary necessarily flat negative binary csp pattern denote
neg flat negative pattern obtained replacing truth values
u constraint patterns ignoring structure beyond disequalities
variables recall structure flat pattern contains disequality relations
variables neg flat pattern definition set patterns x
neg x naturally defined set neg x neg x clearly csp neg x
csp x following follows immediately corollary provides
necessary condition tractability general patterns
corollary let x finite set binary patterns x neg
connected csp x tractable x neg occurs
pivot r integer r


fitractability csp classes defined forbidden patterns

pivot theorem
theorem pivot r tractable r
theorem together corollary immediately provides dichotomy finite
sets connected binary flat negative patterns section devoted proof
theorem call pivot theorem conclude section giving
dichotomy finite sets flat negative patterns necessarily connected
need definitions graph theory
definition subdivision graph g graph obtained replacing edges
g simple paths
minor graph g graph obtained g deleting edges contracting
edges removing isolated vertices graph h topological minor graph g
subdivision h subgraph g
need use following well known theorem robertson seymour
theorem every planar graph h integer k graph
contain h minor tree width k
particular graph large tree width contains large grid minor
section consider hexagonal grid minors instead see figure reason
well known fact graph maximum degree three minor another graph
topological minor latter notion convenient proofs
illustrated figure h hexagonal grid graph composed hexagons honeycomb
pattern width h number hexagons horizontal vertical directions
definition let g r n every graph tree width least g r contains
r hexagonal grid topological minor
let us observe following simple property first
lemma three degree three vertices hexagonal grid width r begin disjoint
paths length r
proof vertex different row simply choose path
along row direction away nearest boundary grid see vertices
b c figure visualise typical situation
otherwise may possible rotating grid degrees get
three vertices lie different rows cannot separate vertices rotating
corners equilateral triangle x z p q r diagram
triangle interior row row x z diagram
extend two vertices along row drop third interior row
along row thus example path beginning would drop one row
continue along row
remaining case three vertices form equilateral triangle occupying
two adjacent rows p q r diagram case orientation
two vertices row lie along edge


ficohen cooper creed marx salamon

grid diagram rotate degrees achieve p q r
extend two three vertices along row third shift away
centre triangle order empty row along path
extended
row
b



x

row
row

z

row

c
row
row
row

r
p

q

figure hexagonal grid width rows picked bold numbered
following combinatorial crucial interesting
right
lemma let g connected graph tree width least g r let b c
distinct vertices g g contains pairwise vertex disjoint paths starting b c
respectively length r
proof let h r hexagonal grid definition g r graph g contains
h topological minor note h contains vertices degree boundary
cause complications proof avoid complication observe
h subdivision graph h whose every vertex degree focus
graph h instead

let hg
denote subdivision h appearing g let denote vertices

degree three hg
mengers theorem dirac vertex disjoint paths pa
pb pc g b c distinct vertices sa sb sc respectively choose paths

way total number edges used hg
minimized

let x two vertices correspond adjacent vertices h means

hg
contains path q endpoints x whose internal vertices disjoint
suppose say pa contains internal vertex q claim
x sa sb sc sa x pb pc disjoint q suppose
hold say x sa sb sc consider internal vertex q q closest x used


fitractability csp classes defined forbidden patterns

one paths reroute path q x without edges

outside hg
would create set paths smaller number edges outside


hg unless rerouted path use edges outside hg
q
possible path goes q q means one path
intersecting q path intersects q q x definition q
path uses vertices q thus case holds
lemma three independent paths length r vertices sa sb
sc non subdivided hexagonal grid h correspond paths xa xb xc

hg
use paths create three independent paths length least r b
c g definition path xa go sb sc therefore claim
previous paragraph xa disjoint pb pc xa uses path q x
sb sc x means neither happen pb pc intersects
q xa disjoint pa well create path ta simply concatenating
pa xa otherwise way xa intersect pa first subdivided edge
h xa goes place case claim happen
case create path ta following pa meets subdivided edge
following xa edge h corresponds edges h path ta could
meet edges h fewer xa path ta case meet
least r subdivided edges h length least r build tb tc
analogous fashion
require following technical lemma proofs
lemma let p binary csp instance suppose assignment x
extend solution p solution assigning x
path proper binary constraints x furthermore
path first constraint along path disallows tuple hd
last constraint disallows tuple hd
proof let sx solution p including assignment x similarly let sy
solution p including assignment
define graph g variables p edge x variable z
assignment x incompatible domain value z similarly
edge variable z assignment incompatible
domain value z finally edge two variables
x constraint proper
let cx component g containing x define assignment variables
p setting z sx z z cx z sy z otherwise solution
p since possible unsatisfied constraint would variable cx
variable cx choice cx cannot happen
hypothesis know required path proper
binary constraints
note lemma binary constraint x forbids
assigning x setting yields required path
proper binary constraints length one
first csp pivot r tractable special case restricted structure


ficohen cooper creed marx salamon

lemma subclass csp pivot r consisting instances
arc consistent binary reduction
unary constraints variables degree two constraint graph
true constraint graph subdivided three connected graph

time complexity n dg r

proof let p instance satisfying conditions lemma time nd
join binary constraints along subdivided edge eliminating intermediate variables
go obtain instance p whose constraint graph three connected
may improper binary constraints arbitrary unary constraints let g denote
true constraint graph p g three connected graph obtained g
contracting subdivided edges true constraint graph p subgraph g
vertex set

solve p csp negtrans time n n cooper zivny b

clearly n dg r since g r r furthermore g tree width

g r p solved time ndg r dechter pearl
case solution extended solution original instance p time nd
remaining case consider negtrans occurs p tree
width g least g r complete proof deriving contradiction
p csp pivot r order case cannot occur
suppose negtrans occurs p variables b c values da db dc
da

dc



c
db
b

lemma g contains vertex disjoint paths ta tb tc starting b c respectively length least r recall true constraint graph g
original instance p subdivided three connected graph p obtained
p joining binary constraints along subdivided edges let ta tb tc denote paths
g corresponding ta tb tc g recall negtrans occurs p variables
b c values da db dc
let c first vertices along subdivided edges b c
g embedding negtrans p shows hdb da disallowed join
arc consistent path b since path construction subdivision
edge p know unary constraints occur internal vertices know
arc consistency binary constraints assignments da b db
extend consistent assignment path b lemma know
value da domain hdb da disallowed p


fitractability csp classes defined forbidden patterns

constraint b similarly value dc hdb dc disallowed p
constraint c appending path b path ta
path b c tc together tb obtain three independent paths length
least r proper constraints p beginning variable b two beginning constraints
disallowing tuple value db b shown pivot r indeed occur
p done
csp pivot r places upper bound length chain dependencies
may followed discard partial solution cannot extended solution
informally speaking forbidding pivot r pattern bounds amount local search
may done extending partial solution larger partial solution
amount effort may required increases length chains inference
worst case behaviour quantified precisely following first
require definitions
definition let g graph u subset vertices g induced graph
g u g u graph vertex set u whose edges edges g
connect two vertices u
graphs g hv ei g hv e define g g hv v e e
graph g say hu u separation g g u g u neither
u u subset separator separation hu u u u
order u u minimal separator one minimal order
torso u separation hu u obtained induced graph g u
adding every edge vertices separator hu u

theorem class pivot r free instances solvable time n dg r
proof prove induction number variables
base case straightforward instance fewer g r variables
clearly solve exhaustive search time n dg r inductive case

assume solve smaller instances n k variables time n dg r
let p pivot r free instance n k variables first make p arc consistent
time n bessiere regin yap zhang since p arc consistent unary
constraints longer effect remove unary improper binary constraints
p time n let g true constraint graph resulting instance p
g separation order two three connected three
vertices three connected case solve p hence p time n dg r
lemma p three variables trivial solve time
assume g separation order two definition torso
size separator torso size separator g hence size separation
hu u torso u separation order two assume
torso u three connected three vertices
consider separator u u hu u empty p composed two smaller independent
pivot r free instances solved time


g r

g r
n
n
n n n n n n follows

solve p time n dg r done


ficohen cooper creed marx salamon

consider structure g u three connected
vertex degree least three case add unary constraint
lemma solve instance time n dg r hence time

dn dg r values variable extend variables u adding restriction unary constraint variable leaves induced instance u pivot r free

see induction solve p time dn dg r n dg r

n dg r done
finally must consider x since minimal know g u
connected path x u denote q csp instance
induced g u together path u x constraint graph
q subdivision torso u three connected three
vertices latter case q tree width two addition unary
constraints x solved time n dechter pearl torso
u three connected degrees x q least three
addition
unary constraints x lemma solve case time
n dg r hence solve q possible unary constraints x

allow one value x time n dg r
value variable x know whether extends solution
variables q similarly value variable know whether extends
solution variables q express two restrictions unary constraints
u x u x lastly binary constraint c x x
specifies precisely pairs values allowed u x u extend variables
u obtain solving subdivided three connected instance seeing
pairs disallowed subdivided edge u pairs set constraint
relation c x f
u x allows values x p solution stop
consider instance r induced p u together constraints
u x u c x construction p solution r solution
pivot occurring r must use pair values disallowed c x since cannot
occur p suppose hd disallowed c x follows assignment
x extend solution q assigning x
extend solution induced p u lemma path
proper constraints x g u furthermore first constraint along
path disallows tuple hd last constraint disallows tuple hd
follows cannot embed pivot r instance r induced u together
constraint c x otherwise would able embed
instance p
since r csp pivot r solve time n dg r inductive hypoth

esis thus final case complexity n dg r n dg r n dg r
done
theorem important gives us tractable class csps defined forbidding
negative pattern unlike csp tree contains unbounded tree width
cannot captured structural tractability true even pivot
example class csp instances csp pivot unbounded tree width
consider n variable csp instance pn domain n whose constraint graph


fitractability csp classes defined forbidden patterns

complete graph pair distinct values j n constraint
variables vi vj disallows single pair assignments hvi ji hvj ii since assignment hvi ji occurs single disallowed tuple pivot occur pn hence
pn csp pivot produce example class instances csp pivot
unbounded tree width csp negtrans modify pn
introducing boolean variable vij pair j replacing constraint
variables vi vj constraints vi vij vj vij former disallowing single pair
assignments hvi ji hvij latter pair assignments hvj ii hvij
pattern negtrans occurs triple assignments hvi ji hvij hvj ii
dichotomy finite sets connected binary flat negative patterns follows
directly theorem corollary
theorem let x finite set connected binary flat negative patterns x
tractable x contained pivot r integer
r
informally speaking dichotomy states bounding length problematic
pivot r style inference chains leads tractability moreover class
instances defined finite set forbidden flat patterns tractable must avoid
problematic inference chains form
dichotomy easily extends patterns necessarily connected
negative pattern connected decomposed connected patterns corresponding connected components negative structure graph call
patterns connected components
corollary let x finite set binary flat negative patterns x tractable
x connected components contained
pivot r integer r
proof let x finite set binary flat negative patterns let cc represent set
connected components pattern cc x union sets cc x
suppose x tractable consider arbitrary subset x cc x
set x contains exactly one connected component pattern x lemma
csp x csp x hence x tractable therefore corollary
pattern x occurs pivot r integer r way
true possible choices x x connected
components occur pivot r integer r
hand suppose x connected components
x occurs pivot r r let k number connected components
occurs disjoint union k copies pivot r tractable
theorem k applications lemma follows hence x
tractable

conclusion
described framework identifying classes csps terms forbidden
patterns used tool identifying tractable classes csp gave several
examples small patterns used define tractable classes csps


ficohen cooper creed marx salamon

search general restricted special case binary
patterns binary csps theorem showed csp x np hard every
pattern set x contains least one four patterns patterns moreover
showed binary flat negative pattern contain patterns
must contained within possibly several copies special type pattern called
pivot hence contained several copies pivot necessary condition
pattern tractable showed forbidding pivot pattern defines
tractable class
beyond dichotomy binary flat negative patterns interesting see
tractable classes defined general binary patterns non binary
patterns particular important area future determining maximal
tractable classes defined patterns fixed size given number
variables number variable value assignments avenue future
characterisation complexity patterns involving structure uses
disequalities groups variables total ordering variables

acknowledgments
authors acknowledge support anr project anr blan epsrc grants
ep f ep erc starting grant paramtight
epsrc platform grant ep f

references
bessiere c regin j c yap r h c zhang optimal coarse grained
arc consistency artificial intelligence pp doi
j artint
bulatov jeavons p krokhin classifying complexity constraints
finite algebras siam journal computing pp doi

bulatov tractable conservative constraint satisfaction lics
proceedings th ieee symposium logic computer science pp
doi lics
bulatov dichotomy theorem constraint satisfaction element set journal acm pp doi
cohen jeavons p complexity constraint languages rossi et al
rossi et al chap pp
cohen class binary csps arc consistency decision
procedure cp proceedings th international conference principles
practice constraint programming lecture notes computer
science pp springer verlag doi
cooper c escamocher g dichotomy constraint forbidden csp
patterns aaai proceedings twenty sixth aaai conference ar

fitractability csp classes defined forbidden patterns

tificial intelligence available https www aaai org ocs index php aaai
aaai view
cooper c jeavons p g salamon z generalizing constraint satisfaction
trees hybrid tractability variable elimination artificial intelligence
pp doi j artint
cooper c zivny hierarchically nested convex vcsp cp proceedings th international conference principles practice constraint
programming pp springer verlag doi
cooper c zivny b hybrid tractability valued constraint
artificial intelligence pp doi j artint

costa c persistency maximum cardinality bipartite matchings operations
letters pp doi
dalmau v kolaitis p g vardi constraint satisfaction bounded
treewidth finite variable logics cp proceedings th international conference principles practice constraint programming
lecture notes computer science pp springer verlag doi

dechter r pearl j network heuristics constraint satisfaction artificial intelligence pp doi
dechter r pearl j tree clustering constraint networks artificial intelligence pp doi
dirac g short proof mengers graph theorem mathematika pp
doi
freuder e c complexity k tree structured constraint satisfaction
aaai proceedings eighth national conference artificial intelligence
pp available http www aaai org library aaai aaai
php
garey r johnson computers intractability guide theory
np completeness w h freeman san francisco ca
gottlob g leone n scarcello f hypertree decompositions tractable
queries journal computer system sciences pp doi
jcss
green j cohen tractability approximating constraint languages
cp proceedings th international conference principles practice
constraint programming vol lecture notes computer science pp
springer verlag doi
grohe structure tractable constraint satisfaction mfcs
proceedings st symposium mathematical foundations computer science vol lecture notes computer science pp springer verlag
doi


ficohen cooper creed marx salamon

grohe complexity homomorphism constraint satisfaction
seen side journal acm pp doi

gyssens jeavons p g cohen decomposing constraint satisfaction
database techniques artificial intelligence pp doi

jeavons p cohen gyssens closure properties constraints journal
acm pp doi
jeavons p g cooper c tractable constraints ordered domains artificial
intelligence pp doi
jegou p decomposition domains micro structure finite
constraint satisfaction aaai proceedings eleventh national conference artificial intelligence pp available http
www aaai org library aaai aaai php
marx beat treewidth theory computing pp
doi toc v
marx b tractable hypergraph properties constraint satisfaction conjunctive queries stoc proceedings nd acm symposium theory
computing pp acm doi
regin j c filtering constraints difference csps aaai
proceedings twelfth national conference artificial intelligence vol pp
available http www aaai org library aaai aaai
php
robertson n seymour p graph minors v excluding planar graph journal combinatorial theory series b pp doi

rossi f van beek p walsh eds handbook constraint programming
foundations artificial intelligence elsevier
salamon z jeavons p g perfect constraints tractable cp
proceedings th international conference principles practice constraint programming vol lecture notes computer science pp
springer verlag doi
van hoeve w j alldifferent constraint survey proceedings th
annual workshop ercim working group constraints available
http arxiv org abs cs v
weigel r bliek c reformulation constraint satisfaction
ecai proceedings th european conference artificial intelligence pp





