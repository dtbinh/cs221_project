Journal Artificial Intelligence Research 45 (2012) 4778

Submitted 03/12; published 09/12

Tractability CSP Classes Defined Forbidden Patterns
David A. Cohen

dave@cs.rhul.ac.uk

Department Computer Science
Royal Holloway, University London
Egham, Surrey, UK

Martin C. Cooper

cooper@irit.fr

IRIT
University Toulouse III, 31062 Toulouse, France

Paid Creed

p.creed@qmul.ac.uk

School Mathematical Sciences
Queen Mary, University London
Mile End, London, UK

Daniel Marx

dmarx@cs.bme.hu

Computer Automation Research Institute
Hungarian Academy Sciences (MTA SZTAKI)
Budapest, Hungary

Andras Z. Salamon

andras.salamon@ed.ac.uk

Laboratory Foundations Computer Science
School Informatics, University Edinburgh, UK

Abstract
constraint satisfaction problem (CSP) general problem central computer
science artificial intelligence. Although CSP NP-hard general, considerable
effort spent identifying tractable subclasses. main two approaches consider
structural properties (restrictions hypergraph constraint scopes) relational
properties (restrictions language constraint relations). Recently, authors
considered hybrid properties restrict constraint hypergraph relations
simultaneously.
key contribution novel concept CSP pattern classes problems
defined forbidden patterns (which viewed forbidding generic sub-problems).
describe theoretical framework used reason classes problems
defined forbidden patterns. show framework generalises certain known
hybrid tractable classes.
Although close obtaining complete characterisation concerning
tractability general forbidden patterns, prove dichotomy special case: classes
problems arise forbid binary negative patterns (generic subproblems disallowed tuples specified). case show (finite
sets of) forbidden patterns define either polynomial-time solvable NP-complete classes
instances.
c
2012
AI Access Foundation. rights reserved.

fiCohen, Cooper, Creed, Marx & Salamon

1. Introduction
constraint satisfaction paradigm consider computational problems
assign values (from domain) variables, constraints. constraint
limits (simultaneous) values list variables (its scope) assigned.
typical situation pair variables might represent starting times two jobs
machine shop scheduling problem. reasonable constraint would require minimum time
gap values assigned two variables.
Constraint satisfaction proved useful modelling tool variety contexts,
scheduling, timetabling, planning, bio-informatics computer vision.
led development number successful constraint solvers. Unfortunately, solving
general constraint satisfaction problem (CSP) instances NP-hard
significant research effort finding tractable fragments CSP.
principle stratify CSP two quite distinct natural ways. structure constraint scopes instance CSP thought hypergraph
variables vertices, generally relational structure. find
tractable classes restricting relational structure, allowing arbitrary constraints
resulting scopes (Dechter & Pearl, 1987). Sub-problems general constraint
problem obtained restrictions called structural. Alternatively, set allowed assignments variables scope seen relation. choose
allow specified kinds constraint relations, allow interact arbitrary structure (Jeavons, Cohen, & Gyssens, 1997). restrictions called relational
language-based.
Structural subclasses defined specifying set hypergraphs (or relational structures) allowed structures CSP instances. shown tractable
structural classes characterised limiting appropriate (structural) width measures
(Dechter & Pearl, 1989; Freuder, 1990; Gyssens, Jeavons, & Cohen, 1994; Gottlob, Leone,
& Scarcello, 2002; Marx, 2010a, 2010b). example, tractable structural class binary
CSPs obtained whenever restrict constraint structure (which graph
case) bounded tree width (Dechter & Pearl, 1989; Freuder, 1990). fact,
shown that, subject certain complexity-theoretic assumptions, structures
give rise tractable CSPs bounded (hyper-)tree width (Dalmau,
Kolaitis, & Vardi, 2002; Grohe, 2006, 2007; Marx, 2010a, 2010b).
Relational subclasses defined specifying set constraint relations. complexity subclass arising restriction precisely determined
called polymorphisms set relations (Bulatov, Jeavons, & Krokhin, 2005; Cohen
& Jeavons, 2006). polymorphisms specify that, whenever set tuples
constraint relation, cannot case particular tuple (the result applying
polymorphism) constraint relation. thus relationship allowed tuples disallowed tuples inside constraint relations key importance
relational tractability given class instances. Whilst general dichotomy
yet proven relational case, many dichotomies sub-problems
obtained, instance Bulatov (2003), Bulatov et al. (2005) Bulatov (2006).
48

fiTractability CSP Classes Defined Forbidden Patterns

Using structural relational restrictions limits possible subclasses
defined. allowing restrictions structure relations able
identify new tractable classes. call restrictions hybrid reasons tractability.
Several hybrid results published binary CSPs (Jegou, 1993; Weigel & Bliek,
1998; Cohen, 2003; Salamon & Jeavons, 2008; Cooper, Jeavons, & Salamon, 2010; Cooper &
Zivny, 2011b). Instead looking set constraint scopes constraint language,
results captured tractability based properties (coloured) microstructure
CSP instances. microstructure binary CSP instance graph hV, Ei V
set possible assignments values variables E set pairs mutually
consistent variable-value assignments (Jegou, 1993). coloured microstructure,
vertices representing assignment variable vi labelled colour representing
variable vi . maintains distinction assignments different variables.
coloured microstructure CSP instance captures structure
relations CSP instance natural place look tractable classes
neither purely structural purely relational. results (coloured) microstructure
properties, three particular note. First observed class instances
perfect microstructure tractable (Salamon & Jeavons, 2008). proper
generalisation well known hybrid tractable CSP class whose instances allow arbitrary
unary constraints every pair variables constrained equal (Regin,
1994; van Hoeve, 2001), hybrid class whose microstructure triangulated (Jegou,
1993; Weigel & Bliek, 1998; Cohen, 2003). perfect microstructure property excludes
infinite set induced subgraphs microstructure.
Secondly, Joint Winner Property (JWP) (Cooper & Zivny, 2011b) applied CSPs
provides different hybrid class strictly generalises class CSP instances
disequality constraint (6=) every pair variables arbitrary set
unary constraints, forbidding single pattern (a subgraph) coloured
microstructure. JWP generalized hierarchies soft non-binary constraints (Cooper & Zivny, 2011a), including, example, soft hierarchical global cardinality
constraints, reduction minimum convex cost flow problem.
Thirdly, called broken-triangle property properly extends structural notion
acyclicity interesting hybrid class (Cooper et al., 2010). broken triangle
property specified excluding particular pattern coloured microstructure.
notion forbidden pattern study paper. therefore work directly
CSP instance (or equivalently coloured microstructure) rather microstructure
abstraction simple graph. allows us introduce language expressing
hybrid classes terms forbidden patterns, providing framework search
novel hybrid tractable classes. case binary negative patterns able
characterise tractable (finite sets of) forbidden patterns. state necessary
condition tractability (finite set of) general patterns.
1.1 Contributions
paper generalise definition CSP instance CSP pattern
three types tuple constraint relations, tuples explicitly al49

fiCohen, Cooper, Creed, Marx & Salamon

lowed/disallowed tuples labelled unknown1 . defining natural notion
containment patterns CSP, able describe problems defined forbidden
patterns: class CSP instances defined forbidding particular pattern exactly
instances contain . use framework capture tractability
identifying local patterns allowed disallowed tuples (within small groups connected
constraints) whose absence enough guarantee tractability.
Using concept forbidden patterns, lay foundations theory
used reason classes CSPs defined hybrid properties. Since first
work kind, primarily focus simplest case: binary patterns tuples
either disallowed unknown (called negative patterns). give large class binary
negative patterns give rise intractable classes problems and, using this, show
negative pattern defines tractable class problems must certain
structure. able prove structure enough guarantee tractability
thus providing dichotomy tractability defined forbidding binary negative patterns.
Importantly, intractability results allow us give necessary condition
form general tractable patterns.
remainder paper structured follows. Section 2 define constraint
satisfaction problems, give definitions used paper. Then, Section 3,
define notion CSP pattern describe classes problems defined forbidden
patterns. give examples tractable classes defined forbidden patterns three
variables. Section 4 show one must take size patterns account
notion maximal classes defined forbidding patterns. general, yet able
make conjecture concerning dichotomy hybrid tractability defined general
forbidden patterns. However, Section 5 able give necessary condition
class tractable Section 6 prove dichotomy negative patterns. Finally,
Section 7 summarise results discuss directions future research.

2. Preliminaries
Definition 2.1. CSP instance triple hV, D, Ci where:
V finite set variables (with n = |V |).
finite set called domain (with = |D|).
C set constraints. constraint c C pair c = h, where:
list distinct variables called scope c.
relation arity || called relation c. set tuples
allowed c.
solution CSP instance P = hV, D, Ci mapping : V where,
h, C s() (where s() represents tuple resulting application
component-wise list variables ).
1. viewed natural generalisation CSP three-valued logic.

50

fiTractability CSP Classes Defined Forbidden Patterns

simplicity presentation, assume variables domains.
Unary constraints used impose different domains different variables.
arity CSP largest arity constraint scopes. long-term
aim identify tractable subclasses CSP problem detected
polynomial time. paper describe general theory forbidden patterns
arbitrary arity consider implications new theory tractable classes
arity two (binary) problems specified finite sets forbidden patterns. cases
certain class membership decided polynomial time.
CSP decision problem, asks whether particular CSP instance solution,
already NP-complete binary CSPs. example, straightforward reduction
graph colouring problem set colours used domain
CSP instance, vertices graph map CSP variables vi , edges {i, j} map
disequality constraints vi 6= vj .
sometimes convenient paper use equivalent functional formulation
constraint. alternative formulation scope constraint h, abstracted set variables possible assignment seen function f : D.
constraint relation alternative view function set possible
assignments, , set {T, F } where, convention, tuples occur
constraint relation map . follows assignment set
variables allowed h, restriction mapped .
Definition 2.2. function f : X X, notation f |S means
function domain satisfying f |S (x) = f (x) x S.
Given set V variables domain D, constraint functional representation
pair h, V : {T, F }. CSP instance functional representation triple hV, D, Ci C set constraints functional representation.
solution (to CSP instance hV, D, Ci functional representation) mapping
: V where, h, C (s| ) = .
functional formulation clearly equivalent relational formulation
use whichever seems appropriate throughout paper. choice always
clear context.
following notions standard study CSP. binary CSP instance
one maximum arity constraint scope two. subproblem
variables U V instance hU, D, CU CU set constraints h, C
U . instance arc-consistent v1 , v2 V , solution
subproblem {v1 } extended solution subproblem {v1 , v2 }.
constraint graph binary CSP instance = hV, D, Ci graph vertices
V edges set scopes binary constraints C. Since often convenient
consider (possibly irrelevant) constraint exists every pair variables,
introduce refined notion true constraint graph.
Definition 2.3. binary constraint v1 v2 improper allows every pair
values allowed unary constraints v1 v2 , proper otherwise.
true constraint graph binary CSP instance constraint graph
instance removing improper binary constraints.
51

fiCohen, Cooper, Creed, Marx & Salamon

may sometimes need disregard unary constraints following.
Definition 2.4. binary reduction CSP instance obtained removing
constraint set constraints whose scope arity two.

3. Forbidden Patterns CSP
paper explain define classes CSP instances forbidding
occurrence certain patterns. CSP pattern generalisation CSP instance.
CSP pattern define relations relative three-valued logic {T, F, U }, meaning
pattern seen representing set CSP instances undefined value U replaced either F . Forbidding CSP pattern equivalent
simultaneously forbidding instances sub-problems.
Definition 3.1. define three-valued logic {T, F, U }, U stands unknown
undefined. set {T, F, U } partially ordered U < U < F F
incomparable. Let finite set. k-ary three-valued relation function
: Dk {T, F, U }. Given k-ary three-valued relations 0 , say realises 0
x Dk (x) 0 (x).
extend definition CSP constraint pattern include additional structure set variable names set domain values, set relations
set question. Adding structure makes patterns specific. therefore capture larger, hence interesting, tractable classes. example, domain
totally ordered define tractable max-closed class (Jeavons & Cooper, 1995);
independent total order domain variable capture
renamable Horn class (Green & Cohen, 2003); placing order variables
pattern allow us define class tree-structured CSP instances.
Definition 3.2. CSP pattern quadruple = hV, D, C, Si, where:
V set variables, associated relational structure universe V .
domain, associated relational structure universe D.
C set constraint patterns. constraint pattern c C pair c = h, i,
V , scope c, list distinct variables : {T, F, U }
three-valued relation (in functional representation) c. constraint pattern
non-trivial three-valued relation maps least one tuple {T, F }.
structure, set consisting relational structures associated
variable set domain.
arity CSP pattern maximum arity constraint pattern h, .
basic type pattern one employs structure, empty.
frequently require patterns use disequality relation 6=, applied every pair
52

fiTractability CSP Classes Defined Forbidden Patterns

specified subset variables, allow several subsets variables
structure.
paper relations occurring structure arity two, interpretation limited selected binary relations representing disequality partial
order. structure variable set domain clear context,
explicitly mention it. Different kinds structure imposed CSP patterns; indeed
structures specified general relations would interesting area future study.
weakest structure consider allows us say two variables
distinct. Thus structure CSP pattern simply set disequalities
subsets variables. paper denote disequalities NEQ(v1 , . . . , vr ) meaning
variables v1 , v2 , . . . , vr pairwise distinct. pattern structure
called flat. Indeed, paper mostly concerned flat patterns. two
variables occur together scope constraint pattern, assume
implicitly includes disequality NEQ(v1 , v2 ).
Thus CSP patterns defined using relational structures three sorts: variables,
domain values, variable-value assignments. constraint patterns CSP
pattern three-valued relations sort variable-value assignments. CSP
pattern flat structure specifies relations sort variables. partial order
variables relation sort variables, partial orders domain
values relations sort domain values.
simplicity presentation, assume throughout paper two constraint
patterns C scope (and that, case CSP instances, two
constraints scope). represent binary CSP patterns simple diagrams. oval represents domain variable, dot domain value. tuples
constraint patterns value F shown dashed lines, value solid
lines value U depicted all.
Definition 3.3. constraint pattern h, called negative never takes
value . CSP pattern negative every constraint pattern negative.
3.1 Patterns, CSPs Occurrence
CSP instance implicitly assumed variables domain values
distinct. equivalent existence implicit disequalities NEQ variable
names domain values. CSP instance CSP pattern (with structure
variables domain values distinct) three-valued relations
constraint patterns never take value U . is, decide possible tuple
whether relation not. Furthermore, CSP instance, pair
variables assume constraint exists scope; explicit constraint
given scope, assume relation complete, i.e. contains tuples.
contrasted CSP patterns absence explicit constraint
pair variables implies truth value tuple undefined.
order define classes CSP instances forbidding patterns, require formal
definition occurrence (containment) pattern within instance. define
general notion containment one CSP pattern within another pattern. Informally,
names variables domain elements CSP pattern inconsequential
53

fiCohen, Cooper, Creed, Marx & Salamon

containment allows renaming variables domain values variable.
Thus, order define containment patterns, firstly require formal definition
renaming. arbitrary renaming, unless explicitly prohibited disequality
structure, two distinct variables may map variable two distinct domain
values may map domain value. Furthermore, pattern occurs another,
may use subset variables second pattern; hence notion require
known renaming-extension.
domain labelling set variables assignment domain values
variables. Variable domain renaming induces mapping domain labellings
scopes constraints: simply assign renamed domain values renamed variables. natural way extend mapping domain labellings mapping
constraint pattern: truth-value mapped domain labelling
truth-value original domain labelling. However, may occur two domain
labellings scope map domain labelling, instead resulting value
taken greatest original truth-values. (In order process
well-defined, two domain labellings constraint mapped domain labelling, original truth-values must comparable.) leads following
formal definition renaming-extension first step towards definition
containment.
Definition 3.4. Let = hV, D, C, Si 0 = hV 0 , D0 , C 0 , 0 CSP patterns.
say 0 renaming-extension exist variable-renaming function : V V 0 domain-renaming function : V D0 s,
assignment-renaming function F : V V 0 D0 induced (s, t) defined
F (hv, ai) = hs(v), t(v, a)i satisfy:
constraint pattern h, C, two domain labellings `, `0
F (`) = F (`0 ), (`) (`0 ) comparable, F (`) denotes
assignment f : s() D0 v , f (s(v)) = t(v, `(v)).
C 0 = {hs(), 0 | h, C}, where, assignment f : s() D0 , 0 (f ) = U
F (`) 6= f every ` , 0 (f ) = max {(`) | F (`) = f } otherwise.
structure, s, F preserve structure. mapping induces
homomorphism relational structures variable-sets, mapping
induces homomorphism relational structures domains. (In
particular, NEQ(v1 , v2 ) S, s(v1 ) 6= s(v2 ) NEQ(s(v1 ), s(v2 )) 0 .)
use patterns define sets CSP instances forbidding occurrence (containment) patterns CSP instances. way able characterise
tractable subclasses CSP. Informally, pattern said occur CSP instance
P find sub-problem Q P (formed taking subsets variables domains)
realises . Q realises if, renaming variables domain values ,
constraint pattern realised corresponding constraint Q. Definition 3.4,
renaming-extension, extra variables, domain values disequalities introduced. Thus need combine notions renaming-extension realisation
formally define mean pattern occurring another pattern (and, particular,
CSP instance).
54

fiTractability CSP Classes Defined Forbidden Patterns

Definition 3.5. say CSP pattern occurs CSP pattern P = hV, D, C, Si
(or P contains ), denoted P , renaming-extension hV, D, C 0 , Si
where, every constraint pattern h, 0 C 0 constraint pattern h, C and,
furthermore, realises 0 .
Pattern 1
d0
b
b

c



b




c





x


z



x

(i)

c




x

(ii)

(iii)

Pattern 2
b





c


x

Example 3.6. example describes three simple containments. Consider three CSP
patterns, Pattern 1(i)(iii). patterns occur in, contained in, Pattern 2
mappings F1 , F2 , F3 , respectively, describe.
F1 simply bijection. Although patterns different, valid containment
Pattern 1(i) Pattern 2 three-valued relation Pattern 2 realisation
three-valued relation Pattern 1(i): replacing (b, d) 7 U (b, d) 7 F .
F2 maps (x, a), (x, b), (y, c) themselves, maps (y, d) (y, d0 )
(y, d). merging domain elements possible values three-valued
constraint relation Pattern 1(ii) comparable tuples involving assignments (y, d)
(y, d0 ) and, furthermore, restriction three-valued relation Pattern 1(ii)
either two assignments realised three-valued constraint relation
Pattern 2: (b, d) 7 F (a, d) 7 . example, replacing (a, d0 ) 7 U
(a, d) 7 . similar manner, Pattern 1(i) contained Pattern 2 simple
mapping F10 maps (x, b), (x, a) (x, b) (y, c), (y, d) (y, c).
Finally, F3 maps (y, c) (y, d) themselves, maps (x, a) (z, b) Pattern 1(iii) (x, a) (x, b), respectively, Pattern 2. merging variables pos55

fiCohen, Cooper, Creed, Marx & Salamon

sible three-valued relations agree NEQ(x, z) structure
Pattern 1(iii).

Pattern 3
z
b

b





z
c




x

c




x

NEQ(x, z)
(i)

(ii)

Throughout paper, use notation NEQ(v1 , . . . , vr ) denote fact
variables v1 , . . . , vr CSP pattern distinct. worth discussing structure
implies far Definition 3.4 concerned. Structure source pattern must
preserved target pattern. Thus Pattern 1(iii) occurs Pattern 3(i), Pattern 3(i)
contained Pattern 1(iii) since structure NEQ(x, z) preserved target
pattern. structure NEQ(v1 , v2 ) considered preserved renaming-extension
0 even explicitly given 0 implicit, example, due existence
non-trivial constraint pattern h, 0 v1 , v2 . example, consider
two CSP patterns, Pattern 3(i)(ii). Pattern 3(i) mapped Pattern 3(ii)
simple bijection three-valued relation Pattern 3(ii) realisation
three-valued relation Pattern 3(i). structure NEQ(x, z) considered preserved
mapping due existence non-trivial constraint pattern variables
x z Pattern 3(ii). Hence, Pattern 3(i) occurs Pattern 3(ii).
continuing need define mean say class CSP
instances definable forbidden patterns.
Definition 3.7. Let C class CSP instances maximum arity k. say
C definable forbidden patterns set patterns X set
CSP instances maximum arity k none patterns X occur precisely
instances C.
Notation: Let X set CSP patterns maximum arity k. use CSP(X )
denote set CSP instances element X occurs. X singleton
{} use CSP() denote CSP({}).
paper, consider classes CSP(X ) sets X CSP patterns
binary sense constraint patterns scope size exactly two.
X patterns X binary, CSP(X ) closed arc consistency
(in sense arc consistency closure instance CSP(X ) belongs
56

fiTractability CSP Classes Defined Forbidden Patterns

CSP(X )) operation updates unary constraints. Indeed, changing
unary constraints cannot introduce patterns X instance CSP(X ).
3.2 Tractable Patterns
paper define, forbidding certain patterns, tractable subclasses CSP.
Furthermore, give examples truly hybrid classes (i.e. classes definable
purely relational purely structural properties).
Definition 3.8. finite set patterns X intractable CSP(X ) NP-hard.
tractable polynomial-time algorithm solve CSP(X ). single pattern
tractable (intractable) {} tractable (intractable). (We assume throughout paper
P6= NP, therefore sets tractable intractable patterns disjoint.)
worth observing classes CSP instances defined forbidding patterns
fixed domain. Recall, however, CSP instance finite domain.
structure present CSP instance assumed given part instance. particular,
variables CSP instance assumed distinct. finite sets patterns X ,
number possible renaming-extensions particular instance P polynomial
size P . Hence determine whether instance lies CSP(X ) exhaustive
search polynomial time.
need following simple lemmas proofs intractability results later
sections paper.
Lemma 3.9. 1 2 2 3 , 1 3 .
Proof. 0 , constraint pattern h, maps constraint pattern h 0 , 0
0 realises . transitivity follows following facts:
realisation operation transitive.
1 2 2 3 , Definition 3.4, structure 1 preserved 2
hence 3 .
Lemma 3.10. Let X sets CSP patterns suppose every pattern
, pattern X . CSP(X ) CSP(T ).
Proof. Let P CSP(X ), 6 P X . cannot P
, since would imply exists X P hence
P Lemma 3.9. Hence, P CSP(T ).
Corollary 3.11. Let X sets CSP patterns suppose every pattern
, pattern X .
CSP(T ) intractable CSP(X ) intractable conversely,
CSP(X ) tractable whenever CSP(T ) tractable.
Finally, give examples tractable patterns. first example negative
pattern since truth-values relations F U .
57

fiCohen, Cooper, Creed, Marx & Salamon

Pattern 4 simple negative pattern.
v


x
c
c0

w
b
NEQ(v, w, x)

Example 3.12. Consider Pattern 4. defines class CSPs trivially tractable.
Forbidding Pattern 4 ensures paths two variables true
constraint graph. Thus, problem forbidding Pattern 4 decomposed set
independent sub-problems, two variables.

Example 3.13. Cooper Zivny (2011b) showed forbidding pattern Negtrans
shown Pattern 5 describes tractable class CSP instances. seen generalisation well-known tractable class problems, AllDifferent+unary (Costa,
1994; Regin, 1994; van Hoeve, 2001): instance class consists set variables
V , set arbitrary unary constraints V , constraint v 6= w defined pair
distinct variables v, w V . Forbidding Negtrans equivalent saying disallowed
tuples form transitive relation, i.e. (hv, ai , hx, bi) (hx, bi , hw, ci) disallowed
(hv, ai , hw, ci) must disallowed. Thus Negtrans occur binary CSP
instance class AllDifferent+unary transitivity equality (equality
exactly disallowed).

Pattern 5 Negative transitive pattern (Negtrans)
v
x

w

NEQ(v, w, x)
Cooper Zivny (2011b) recently showed tractable class defined
forbidding Pattern 5 (Negtrans) extended soft constraint problems.
58

fiTractability CSP Classes Defined Forbidden Patterns

3.3 Tractable Patterns Structure
paper primarily studies patterns weak structure conditions
imposed variables distinct. However, worth pointing adding
structure pattern allows us capture larger classes instances. Example 3.14
show forbidden pattern capture class CSPs tree width 1
adding variable-ordering Pattern 4. case pattern containment must preserve
total order. ordered pattern , consider unordered CSP P
CSP() exists ordering variable set P forbidden.
order define tractable class, must possible find ordering polynomial
time. case patterns Examples 3.14 3.15.
Pattern 6 Tree structure pattern (Tree)

v1
v3
v2
v1 < v2 < v3
Example 3.14. Consider pattern Tree, given Pattern 6. show class
CSP(Tree) exactly set CSPs whose true constraint graph forest (i.e. tree
width 1). First, suppose P CSP(Tree). Then, exists ordering = (v1 , . . . , vn )
variable shares proper constraint one variable preceding
ordering. hand, suppose P CSP whose true constraint graph
tree. ordering vertices according pre-order traversal, obtain ordering
variable shares proper constraint one variable preceding
ordering (its parent); thus, P CSP(Tree).

Example 3.15. Forbidding pattern BTP shown Pattern 7 known brokentriangle property (Cooper et al., 2010). order capture class forbidden
pattern impose total order pattern variables. Cooper et al. (2010)
proved class CSP instances CSP(BTP) solved polynomial time and,
indeed, CSP instances CSP(BTP) unknown total ordering variables
recognised solved polynomial time.

easy see Tree (shown Pattern 6) occurs BTP (with truthvalues U changed ). follows Lemma 3.10 CSP(Tree) CSP(BTP).
Hence class CSP(BTP) includes CSP instances whose true constraint graph tree.
However, CSP(BTP) includes certain CSP instances whose true constraint graph
59

fiCohen, Cooper, Creed, Marx & Salamon

Pattern 7 Broken triangle pattern (BTP)

b

v1


v3
v2
v1 < v2 < v3

tree width r value r: consider, example, CSP instance r + 1 variables
identical constraint every pair variables simply disallows single
tuple h0, 0i.
tractable forbidden pattern order imposed variables,
obtain another tractable class considering problems forbidding pattern without
ordering condition. class obtained generally smaller, easier establish
containment flat pattern. example, consider Pattern 4 flat version
Pattern 6. seen forbidding Pattern 4 gives rise class CSP instances
paths length greater two true constraint graph.
hand, forbidding Pattern 6 gives much larger class CSP instances
true constraint graph tree width 1.
case broken-triangle property, obtain strictly smaller tractable
class forbidding Pattern 7 triples variables v1 , v2 , v3 irrespective order.
easily exhibit CSP instance shows inclusion strict: example,
3-variable CSP instance Boolean domains consisting two constraints v1 = v2 ,
v1 = v3 variable ordering v1 < v2 < v3 . unordered version BTP
recently used obtain dichotomy patterns consisting 2 constraints (Cooper &
Escamocher, 2012).

4. Maximal Tractable Classes Defined Forbidden Patterns
relational tractability define maximal tractable sub-problem CSP problem
given set possible relations. class relations maximal possible
add even one relation without sacrificing tractability.
case structural tractability picture less clear, since measure
complexity infinite set hypergraphs (or, generally, relational structures).
obtain tractability bound width measure structures. Whatever
width measure chosen containment class width bounded k inside
class width bounded k +1 maximal class possible (although
k unique maximal class structurally tractable instances). section,
show case forbidden patterns situation similar.
60

fiTractability CSP Classes Defined Forbidden Patterns

Definition 4.1. Let = hV, D, C, Si = hV 0 , D0 , C 0 , 0 two flat CSP patterns.
0 DD
0 . Now, extend constraint pattern
form disjoint unions V V
0 setting value tuple including elements D0
C domain DD
0.
U , extend similarly constraint patterns C 0 : way define C C
0 forming disjoint union 0 adding
define structure
0
disequalities NEQ(v, v ) v V v 0 V 0 . set disjoint union
= hV V
0 , DD
0 , C C
0 ,
0 i.

Lemma 4.2. Let flat non-empty (i.e. containing least one variable) binary
CSP patterns.
).
CSP() CSP( ) ( CSP(
) tractable whenever CSP() CSP( ) tractable.
Moreover, CSP(
Proof. begin showing strict inclusion
).
CSP() CSP( ) ( CSP(
inclusion holds follows directly Lemma 3.10. Among patterns
occurs, let pattern smallest number variables. define similarly.
see inclusion strict, observe occur CSP pattern whose
domain disjoint union , whose variable set size equal
larger variable sets . CSP instance containing pattern
neither CSP() CSP( ). However, construct CSP instance containing
), structure
imposing disequalities
pattern contained CSP(

variables means contained pattern:
simply enough variables.
). P CSP() CSP( ) P solved polynomial
Suppose P CSP(
time, tractability CSP() CSP( ).
may suppose P . Choose particular occurrence P let
denote set variables used containment. Consider assignment :
D. Let Pt denote problem obtained making assignment enforcing
arc-consistency resulting problem. corresponds adding new unary
constraints P .
must occur P . see this, observe
show occurs Pt
containment Pm naturally induces containment P extends
P , considering occurrence . Thus, conclude
containment
Pt CSP( ), solved polynomial time.
construction, solution Pt extends solution P adding assignment
variables . Moreover, every solution P corresponds solution Pt
: D. Since size fixed, iterate solutions polynomial
time. P solution, find solution Pt . find
Pt solution, know P solution. Thus, since solve
Pt polynomial time, solve P polynomial time.
Corollary 4.3. tractable class defined forbidding flat pattern maximal.
61

fiCohen, Cooper, Creed, Marx & Salamon

defined disjoint
Proof. Let tractable flat pattern. Consider pattern

union two copies . Lemma 4.2 CSP()
tractable
,
CSP() ( CSP()
hence CSP() maximal tractable class.
follows cannot characterise tractable forbidden patterns exhibiting
maximal tractable classes defined forbidding pattern (or finite set patterns,
since Lemma 4.2 finite set replaced single pattern). Indeed,
consequence Lemma 4.2 construct infinite chain patterns,
forbidding one gives rise slightly larger tractable class. Naturally, place
upper bound size patterns finitely many patterns
consider, maximal tractable classes defined forbidden patterns bounded size
necessarily exist.

5. Binary Flat Negative Patterns
moment, able make conjecture concerning complete characterisation complexity general forbidden patterns, although conjecture
dichotomy exists. Nonetheless, restricting attention special case, forbidden
binary flat negative patterns, able obtain dichotomy. Recall pattern
flat structure imposed variables distinct,
negative constraint patterns h, i, never takes value .
begin defining three particular patterns one infinite class patterns.
use patterns characterise large class intractable patterns. prove
finite set flat negative patterns class simple structure: one
patterns must contained one particular set patterns, call pivots.
means tractable set patterns must include pattern occurs
pivot pattern. Furthermore, demonstrate forbidding pivot pattern gives rise
tractable class. leads simple characterisation tractability finite
sets binary flat negative patterns.
Pattern 8 Cycle(6)
c0
c
v1

v2

v3

v6

v5

NEQ(v1 , . . . , v6 )

62

v4

fiTractability CSP Classes Defined Forbidden Patterns

Pattern 9 Valency
x1

x01

x2

x02

x3

x03
NEQ(x1 , x2 , x3 , x01 ) NEQ(x01 , x02 , x03 )

Pattern 10 Path

v1

v2

v3

w1

w2

w3

NEQ(v1 , v2 , v3 , w1 ) NEQ(w1 , w2 , w3 )
Definition 5.1 below, define concept neg-connected binary pattern.
correspond binary patterns true constraint graph every realisation
binary CSP instance connected graph. first generalise notion true
constraint graph CSP patterns. call resulting graph negative structure graph.
Definition 5.1. Let binary pattern. vertices negative structure
graph G variables . pair vertices edge G form
scope whose constraint pattern assigns least one tuple value F . say
pattern neg-connected negative structure graph connected. case
negative patterns, use simpler term connected instead neg-connected.
Pattern 9 (Valency), Pattern 10 (Path) Pattern 11 (Valency+Path)
connected. Note pattern connected may occur connected pattern
(and vice versa). Pattern 8 shows Cycle(6) connected. one example
generic pattern Cycle(k) k 2. structure Cycle(k)
variables distinct, except special case k = 2 structure
includes NEQ(c, c0 ). additional requirement means Cycle(2) composed
single binary constraint pattern containing two distinct disallowed tuples. following
theorem uses patterns show patterns intractable.

63

fiCohen, Cooper, Creed, Marx & Salamon

Pattern 11 Valency+Path
v1

v2
w1
v3

w2

w3

x

NEQ(v1 , v2 , v3 ), NEQ(w1 , w2 , w3 ), NEQ(x, w2 )
Theorem 5.2. Let X finite set neg-connected binary patterns. If, X ,
least one Cycle(k) (for k 2), Valency, Path, Valency+Path occurs
, X intractable.
Proof. Let X finite set neg-connected negative binary patterns let `
number variables largest element X .
Assuming least one four patterns occurs X , construct
class CSPs element X occurs polynomial-time
reduction well-known NP-complete problem 3SAT (Garey & Johnson, 1979).
construction involve three gadgets, examples shown Figure 1.
gadgets serve particular purpose:
1. cycle gadget, shown Figure 1(a) special case 4 variables, enforces
cycle Boolean variables (v1 , v2 , . . . , vr ) take value.
2. clause gadget Figure 1(b) equivalent clause v1 v2 v3 , since vC
value domain one three vi variables set true.
obtain 3-clauses three variables inverting domains vi
variables.
3. line gadget Figure 1(c), imposes constraint v1 v2 . used
impose logically equivalent constraint v2 v1 .
cycle gadget connected clause gadget via line gadgets. three types
gadgets specified ensure one negative edge adjacent
vertex coloured microstructure, except cycle gadget connected line
gadget.
Now, suppose instance 3SAT n propositional variables
X1 , . . . , Xn clauses C1 , . . . , Cm .
begin construction CSP instance P solve 3SAT instance using
n copies cycle gadget (Figure 1(a)), m(` + 1) variables. = 1, . . . , n,
m(`+1)
variables along ith copy cycle denoted (vi1 , vi2 , . . . , vi
).
64

fiTractability CSP Classes Defined Forbidden Patterns

v1

F

v2

vC
v2

v1

v3


F
v3

F

v4
(a)

(b)


F
v1

v2
(c)

Figure 1: (a) Making copies variable (v1 = v2 = v3 = v4 ). (b) Imposing
ternary constraint vC = v1 v2 v3 . (c) line constraints length 4
imposes v1 v2 .

solution CSP instance P constraints,
variables vij , j = 1, . . . , m(` + 1) must value, di . therefore consider
vij copy Xi .
Consider clause Cw . eight cases consider similar
show details one case. Suppose Cw Xi Xj Xk .
build clause gadget (Figure 1(b)) three Boolean variables ciw , cjw ckw
invert domain ckw since occurs negatively Cw . solution
constructed CSP must satisfy s(ciw ) s(cjw ) s(ckw ) = .
complete insertion Cw CSP instance adding line gadgets
length ` + 1 (Figure 1(c)). connect cycle gadgets corresponding Xi , Xj Xk
w(`+1)
clause gadget clause Cw since Xi , Xj Xk occur Cw . connect vi
w(`+1)
ciw since Xi positive Cw , s(ciw ) = possible s(vi
) = ,
65

fiCohen, Cooper, Creed, Marx & Salamon

w(`+1)

solution s. Similarly, connect vj
cjw . Finally, since Xk occurs negatively
Cw , impose line constraints direction. ensures s(ckw ) = F
w(`+1)
possible s(vk
) = F . Imposing constraints ensures solution
possible least one cycles corresponding variables Xi , Xj , Xk
assigned value would make corresponding literal Cw true.
continue construction clause 3SAT instance. Since ` constant,
clearly polynomial reduction 3SAT.
show CSP instance P constructed manner described cannot contain pattern X . showing neg-connected
pattern containing Cycle(k) (for 2 k `), Valency, Path, Valency+Path
occur instance. sufficient show CSP instance P contain
patterns X .
CSP instance P constraint contains one disallowed tuple. Thus,
X Cycle(2) cannot occur P . Furthermore, P built
cycles length m(` + 1) paths length ` + 1, cannot contain cycles less
` + 1 vertices. Thus, since ` maximum number vertices element X ,
follows X Cycle(k) , k 3, occur P .
define valency variable x number distinct variables share
constraint pattern x. Suppose Valency , X neg-connected.
possible require variable valency four , pair
variables valency three connected path length ` negative structure
graph . Certainly P variables valency four. Moreover, fact P
built using paths length ` + 1 means two valency three variables joined
path length `. Thus, X occur P Valency .
Next, consider case Path , X neg-connected. must
two distinct (but possibly overlapping) three-variable lines (with disallowed tuples
constraint patterns match domain values) separated ` variables.
place disallowed tuples meet P connect line gadget
cycle gadget. connection sites always distance greater `,
conclude 6 P whenever Path .
Finally, consider case Valency+Path , X neg-connected.
Here, must variable valency least 3 path constraint patterns
three variables intersecting disallowed tuples, must connected path
less ` variables negative structure graph . observed above,
places P disallowed tuples meeting line gadget meets
cycle gadget, path least ` variables one points
every variable valency 3. Thus, 6 P whenever Valency+Path .
remains consider sets negative binary patterns could tractable.
this, need define pivot patterns, Pivot(r), contain every tractable negative
binary pattern.
Definition 5.3. Let V = {p} {v1 , . . . , vr } {w1 , . . . , wr } {x1 , . . . , xr }, = {a, b}
= {NEQ(p, v1 , . . . , vr , w1 , . . . , wr , x1 , . . . , xr )}. define pattern Pivot(r) =
66

fiTractability CSP Classes Defined Forbidden Patterns

Pattern 12 Pivot(3)
v3

v2

v1
w1

w2

w3

p

x3

x2

x1

b

NEQ(p, v1 , v2 , v3 , w1 , w2 , w3 , x1 , x2 , x3 )

hV, D, Cp Cv Cw Cx , Si,
Cp = {h(p, v1 ), ab , h(p, w1 ), ab , h(p, x1 ), bb i}
Cv = {h(vi , vi+1 ), ab | = 1, . . . , r 1}
Cw = {h(wi , wi+1 ), ab | = 1, . . . , r 1}
Cx = {h(xi , xi+1 ), ab | = 1, . . . , r 1}
ab (a, b) = F , ab (s, t) = U (for (s, t) 6= (a, b)), bb (b, b) = F , bb (s, t) = U
(for (s, t) 6= (b, b)). pattern Pivot(r) structure variables
distinct. See Pattern 12 example, Pivot(3).
say pattern variables v1 , . . . , vr distinct-variable pattern
structure includes NEQ(v1 , . . . , vr ). following proposition characterises sets
connected binary flat negative distinct-variable patterns Theorem 5.2 prove
intractable.
Proposition 5.4. connected binary flat negative distinct-variable pattern either
contains Cycle(k) (for k 3), Valency, Path, Valency+Path,
occurs Pivot(r) integer r ||.
Proof. Suppose contain patterns Valency, Cycle(k) (for k 3),
Path, Valency+Path. Recall valency variable x number distinct
variables share constraint pattern x. Since contain Valency
contain one variable valency three variables must valency
two. Moreover, since Cycle(k) 6 k 3, negative structure graph
contain cycles. Thus, since connected, negative structure graph
consists three disjoint paths joined single vertex. two disallowed tuples
67

fiCohen, Cooper, Creed, Marx & Salamon

distinct scopes intersect, call union scopes footprint
intersection. fact negative structure graph acyclic
contain Path means pairs intersecting disallowed tuples must
footprint. Moreover, fact contain Valency+Path means
intersections must occur variable valency 3, exists. fact
flat negative means renaming-extension pair disallowed tuples ha, bi,
hc, di scope hu, vi merged domain-renaming function t,
i.e. t(hu, ai) = t(hu, ci) t(hv, bi) = t(hv, di). follows occurs Pivot(r),
r ||.
Corollary 5.5. Let X finite set connected binary flat negative distinct-variable
patterns. CSP(X ) tractable X occurs Pivot(r),
integer r ||.
prove result patterns necessarily distinct-variable.
Corollary 5.6. Let X finite set connected binary flat negative patterns.
CSP(X ) tractable X occurs Pivot(r), integer
r ||.
Proof. connected binary flat negative pattern, let dv() denote set connected
binary flat negative distinct-variable patterns occurs,
domain || variables. use dv(X ) denote union sets dv()
X .
Lemma 3.10, CSP() CSP(dv()). every CSP instance P P ,
P dv(). follows CSP(dv()) CSP(), hence
CSP() = CSP(dv()). Since CSP(X ) intersection CSP() X
CSP(dv(X )) intersection CSP(dv()) X , CSP(X ) =
CSP(dv(X )).
Corollary 5.5, CSP(dv(X )) tractable pattern dv(),
X , occurs Pivot(r) r | |. But, definition dv(), occurs
| | ||. Therefore, CSP(X ) tractable occurs Pivot(r) integer
r ||.
arbitrary (not necessarily flat negative) binary CSP pattern , denote
neg() flat negative pattern obtained replacing truth-values
U constraint patterns ignoring structure beyond disequalities
variables. Recall structure flat pattern contains disequality relations
variables, neg() flat pattern definition. set patterns X ,
neg(X ) naturally defined set neg(X ) = {neg() : X }. Clearly CSP(neg(X ))
CSP(X ). following result follows immediately Corollary 5.6. provides
necessary condition tractability general patterns.
Corollary 5.7. Let X finite set binary patterns X , neg()
connected. CSP(X ) tractable X neg() occurs
Pivot(r), integer r ||.
68

fiTractability CSP Classes Defined Forbidden Patterns

6. Pivot Theorem
Theorem 6.1. Pivot(r) tractable r 1.
theorem together Corollary 5.6 immediately provides dichotomy finite
sets connected binary flat negative patterns. section devoted proof
theorem (which call pivot theorem). conclude section giving
dichotomy finite sets flat negative patterns necessarily connected.
need definitions graph theory.
Definition 6.2. subdivision graph G graph obtained replacing edges
G simple paths.
minor graph G graph obtained G deleting edges, contracting
edges removing isolated vertices. graph H topological minor graph G
subdivision H subgraph G.
need use following well-known theorem Robertson Seymour (1986).
Theorem 6.3. every planar graph H integer k > 0 graph
contain H minor, tree width k.
particular, graph large tree width, contains large grid minor.
section consider hexagonal grid minors instead (see Figure 2). reason
well-known fact graph maximum degree three minor another graph,
topological minor latter notion convenient proofs.
illustrated Figure 2, h hexagonal grid graph composed hexagons honeycomb
pattern: width h number hexagons horizontal vertical directions.
Definition 6.4. Let g : r N every graph tree width least g(r) contains
3(r + 4) hexagonal grid topological minor.
Let us observe following simple property first:
Lemma 6.5. three degree three vertices hexagonal grid width 3r begin disjoint
paths length r.
Proof. vertex different row simply choose path
along row (in direction away nearest boundary grid). See vertices
a, b c Figure 2 visualise typical situation.
Otherwise may possible, rotating grid 120 240 degrees get
three vertices lie different rows. cannot separate vertices rotating
corners equilateral triangle, x, y, z p, q, r diagram.
triangle interior row, Row 4 x, y, z diagram,
extend two vertices along row drop third interior row
along row. Thus, example, path beginning would drop one row
continue along Row 4.
remaining case three vertices form equilateral triangle occupying
two adjacent rows, p, q, r diagram. case orientation
two vertices row lie along edge
69

fiCohen, Cooper, Creed, Marx & Salamon

grid. diagram rotate either 120 240 degrees achieve p, q, r.
extend two three vertices along row third shift away
centre triangle order find empty row along path
extended.
Row 6
b



x

Row 5
Row 4

z

Row 3

c
Row 2
Row 1
Row 0

r
p

q

Figure 2: hexagonal grid width 6 rows picked bold numbered.
following combinatorial result crucial algorithm, interesting
right:
Lemma 6.6. Let G 3-connected graph tree width least g(r) let a, b, c
distinct vertices G. G contains 3 pairwise vertex disjoint paths starting a, b, c,
respectively, length r.
Proof. Let H 3(r + 4) hexagonal grid. definition g(r), graph G contains
H topological minor. Note H contains vertices degree 2 boundary,
cause complications proof. avoid complication, observe
H subdivision graph H whose every vertex degree 3 focus
graph H instead.

Let HG
denote subdivision H appearing G let denote vertices

degree three HG
. Mengers theorem (Dirac, 1966) vertex-disjoint paths Pa ,
Pb , Pc G a, b, c distinct vertices sa , sb , sc S, respectively. Choose paths

way total number edges used HG
minimized.

Let x, two vertices correspond adjacent vertices H . means

HG
contains path Q endpoints x whose internal vertices disjoint
S. Suppose that, say, Pa contains internal vertex Q. claim either (1)
x, {sa , sb , sc } (2) sa {x, y} Pb , Pc disjoint Q. Suppose (1)
hold, say, x 6 {sa , sb , sc }. Consider internal vertex q Q closest x used
70

fiTractability CSP Classes Defined Forbidden Patterns

one paths. reroute path q x without using edges

outside HG
. would create new set paths smaller number edges outside


HG , unless rerouted path use edges outside HG
q.
possible path goes q Q. means one path
intersecting Q: path intersects Q q x definition q
path uses vertices q y. Thus case (2) holds.
Lemma 6.5 three independent paths length r + 4 vertices sa , sb
sc (non subdivided) hexagonal grid H, correspond paths Xa , Xb , Xc

HG
. use paths create three independent paths length least r a, b
c G. definition, path Xa go sb sc . Therefore, claim
previous paragraph, Xa disjoint Pb Pc : Xa uses path Q x
y, sb , sc 6 {x, y} means neither (1) (2) happen Pb Pc intersects
Q. Xa disjoint Pa well, create new path Ta simply concatenating
Pa Xa . Otherwise, way Xa intersect Pa first subdivided edge
H Xa goes (this place case (2) claim happen).
case, create new path Ta following Pa meets subdivided edge
following Xa . edge H corresponds 4 edges H, path Ta could
meet 4 edges H fewer Xa does. path Ta will, either case, meet
least r subdivided edges H length least r. build Tb Tc
analogous fashion.
require following technical lemma proofs.
Lemma 6.7. Let P binary CSP instance. Suppose assignment x,
d0 extend solution P solution assigning x
d0 y. path proper binary constraints x y. Furthermore,
path first constraint along path disallows tuple hd, d1
last constraint disallows tuple hd2 , d0 i.
Proof. Let Sx solution P including assignment x similarly let Sy
solution P including assignment d0 y.
Define graph G variables P . edge x variable z
assignment x incompatible domain value z. Similarly,
edge variable z assignment d0 incompatible
domain value z. Finally edge two variables
x constraint proper.
Let Cx component G containing x. Define assignment variables
P setting S(z) = Sx (z) z Cx S(z) = Sy (z) otherwise. solution
P since possible unsatisfied constraint would variable Cx
variable Cx , choice Cx cannot happen.
hypothesis, know S(y) 6= d0 required path proper
binary constraints.
Note Lemma 6.7 binary constraint x forbids
assigning x d0 y, setting d1 = d0 d2 = yields required path
proper binary constraints, length one.
first show CSP(Pivot(r)) tractable special case restricted structure.
71

fiCohen, Cooper, Creed, Marx & Salamon

Lemma 6.8. subclass CSP(Pivot(r)) consisting instances:
arc-consistent binary reduction;
unary constraints variables degree two constraint graph;
true constraint graph subdivided three-connected graph,

time complexity n3 dg(r)+1 .

Proof. Let P instance satisfying conditions lemma. time nd2 ,
join binary constraints along subdivided edge eliminating intermediate variables
go, obtain instance P 0 , whose constraint graph three-connected,
may improper binary constraints arbitrary unary constraints. Let G denote
true constraint graph P G0 three-connected graph obtained G
contracting subdivided edges. true constraint graph P 0 subgraph G0
vertex-set.

solve P 0 CSP(Negtrans) time n2 d3 (n + d) (Cooper & Zivny, 2011b).

clearly n3 dg(r)+1 since g(r) 3 r. Furthermore, G0 tree width

g(r) P 0 solved time ndg(r)+1 (Dechter & Pearl, 1989). either
case solution extended solution original instance P time O(nd).
remaining case consider Negtrans occurs P 0 tree
width G0 least g(r). complete proof deriving contradiction
P 6 CSP(Pivot(r)), order show case cannot occur.
Suppose Negtrans occurs P 0 variables a, b, c values da , db , dc :
da

dc



c
db
b

Lemma 6.6, G0 contains 3 vertex-disjoint paths Ta , Tb , Tc starting a, b, c, respectively, length least r. Recall true constraint graph G
original instance P subdivided three-connected graph P 0 obtained
P joining binary constraints along subdivided edges. Let Ta , Tb , Tc denote paths
G corresponding Ta , Tb , Tc G0 . Recall Negtrans occurs P 0 variables
a, b, c values da , db , dc .
let c first vertices along subdivided edges b c
G. embedding Negtrans P 0 shows hdb , da disallowed join
arc-consistent path b a. Since path is, construction, subdivision
edge P 0 know unary constraints occur internal vertices. know,
arc consistency binary constraints, assignments = da b = db
extend consistent assignment path b. So, Lemma 6.7 know
value da domain hdb , da disallowed P
72

fiTractability CSP Classes Defined Forbidden Patterns

constraint b a. Similarly value dc hdb , dc disallowed P
constraint c. appending path b path Ta
path b c Tc , together Tb , obtain three independent paths length
least r proper constraints P , beginning variable b, two beginning constraints
disallowing tuple value db b. shown Pivot(r) indeed occur
P done.
CSP(Pivot(r)) places upper bound length chain dependencies
may followed discard partial solution cannot extended solution.
Informally speaking, forbidding Pivot(r) pattern bounds amount local search
may done extending partial solution larger partial solution.
amount effort may required increases length chains inference,
worst-case behaviour quantified precisely following result. first
require definitions.
Definition 6.9. Let G graph U subset vertices G. induced graph
G[U ] G U graph vertex set U whose edges edges G
connect two vertices U .
graphs G = hV, Ei G0 = hV 0 , E 0 define G G0 = hV V 0 , E E 0 i.
graph G say hU1 , U2 separation G = G[U1 ] G[U2 ] neither
U1 , U2 subset other. separator separation hU1 , U2 U1 U2
order |U1 U2 |. minimal separator one minimal order.
torso U1 separation hU1 , U2 obtained induced graph G[U1 ]
adding every edge vertices separator hU1 , U2 i.

Theorem 6.10. class Pivot(r)-free instances solvable time n3 dg(r)+3 .
Proof. prove result induction number variables.
base case straightforward. instance fewer g(r)+3 variables,
clearly solve exhaustive search time n3 dg(r)+3 . inductive case

assume solve smaller instances n < k variables time n3 dg(r)+3 .
Let P Pivot(r)-free instance n = k variables. First make P arc-consistent
time O(n2 d2 ) (Bessiere, Regin, Yap, & Zhang, 2005). Since P arc-consistent, unary
constraints longer effect. Remove unary improper binary constraints
P time O(n2 d2 ). Let G true constraint graph resulting instance, P 0 .
G separation order two either three-connected three
vertices. three-connected case solve P 0 , hence P , time n3 dg(r)+1
Lemma 6.8. P three variables trivial solve time O(d3 ).
So, assume G separation order two. definition torso
size-2 separator torso size-2 separator G. Hence find size-2 separation
hU1 , U2 torso U1 separation order two. assume
torso U1 either three-connected three vertices.
consider separator = U1 U2 hU1 , U2 i. empty P 0 composed two smaller independent
Pivot(r)-free instances solved time

3
g(r)+3
3
g(r)+3
n1
+ n2
n1 + n2 = n 1 n1 , n2 < n. follows

solve P time n3 dg(r)+3 , done.
73

fiCohen, Cooper, Creed, Marx & Salamon

= {m} consider structure G[U1 ]. three-connected,
vertex degree least three. case add unary constraint
and, Lemma 6.8, solve instance time n3 dg(r)+1 . Hence find, time

dn3 dg(r)+1 , values variable extend variables U1 . Adding restriction unary constraint variable leaves induced instance U2 Pivot(r)-free

see, induction, solve P 0 time dn3 dg(r)+1 + (n 1)3 dg(r)+3 =

n3 dg(r)+3 , done.
Finally must consider = {x, y}. Since minimal know G[U2 ]
connected path x U2 . Denote Q CSP instance
induced G[U1 ], together path U2 x y. constraint graph
Q subdivision torso U1 either three-connected three
vertices. latter case Q tree width two so, addition unary
constraints x y, solved time O(n2 d3 ) (Dechter & Pearl, 1989). torso
U1 three-connected degrees x Q least three.
addition
unary constraints x can, Lemma 6.8, solve case time
n3 dg(r)+1 . Hence solve Q possible unary constraints x

allow one value x y, time d2 n3 dg(r)+1 .
value variable x know whether extends solution
variables Q. Similarly, value variable know whether extends
solution variables Q. express two restrictions unary constraints,
u(x) u(y) x y. Lastly find binary constraint c(x, y) x
specifies precisely pairs values, allowed u(x) u(y), extend variables
U1 . obtain solving subdivided three-connected instance seeing
pairs disallowed subdivided edge U2 pairs set constraint
relation c(x, y) F .
u(x) allows values x P solution stop.
consider instance R, induced P 0 U2 together constraints
u(x), u(y) c(x, y). construction, P solution R solution.
Pivot(t) occurring R must use pair values disallowed c(x, y) since cannot
occur P 0 . Suppose hd, d0 disallowed c(x, y). follows assignment
x, d0 extend solution Q assigning x d0
extend solution problem induced P 0 U1 . Lemma 6.7 path
proper constraints x G[U1 ]. Furthermore, first constraint along
path disallows tuple hd, d1 last constraint disallows tuple hd2 , d0 i.
follows cannot embed Pivot(r) instance R induced U2 together
constraint c(x, y) (otherwise would able embed
instance P ).
Since R CSP(Pivot(r)), solve time n3 dg(r)+3 inductive hypoth

esis. Thus, final case, complexity d2 n3 dg(r)+1 + n3 dg(r)+3 = n3 dg(r)+3
done.
Theorem 6.1 important gives us tractable class CSPs defined forbidding
negative pattern which, unlike CSP(Tree), contains problems unbounded tree width,
cannot captured structural tractability. true even Pivot(1).
example class CSP instances CSP(Pivot(1)) unbounded tree width,
consider n-variable CSP instance Pn domain {1, . . . , n} whose constraint graph
74

fiTractability CSP Classes Defined Forbidden Patterns

complete graph and, pair distinct values i, j {1, . . . , n}, constraint
variables vi , vj disallows single pair assignments (hvi , ji , hvj , ii). Since assignment hvi , ji occurs single disallowed tuple, Pivot(1) occur Pn , hence
Pn CSP(Pivot(1)). produce example class instances CSP(Pivot(1))
unbounded tree width CSP(Negtrans), modify Pn
introducing Boolean variable vij pair < j replacing constraint
variables vi , vj constraints vi , vij vj , vij : former disallowing single pair
assignments (hvi , ji , hvij , 0i) latter pair assignments (hvj , ii , hvij , 0i).
pattern Negtrans occurs triple assignments (hvi , ji , hvij , 0i , hvj , ii).
dichotomy finite sets connected binary flat negative patterns follows
directly Theorem 6.1 Corollary 5.6.
Theorem 6.11. Let X finite set connected binary flat negative patterns. X
tractable X contained Pivot(r), integer
r ||.
Informally speaking, dichotomy states bounding length problematic
Pivot(r)-style inference chains leads tractability, moreover class
instances defined finite set forbidden flat patterns tractable, must avoid
problematic inference chains form.
dichotomy easily extends patterns necessarily connected.
negative pattern connected, decomposed connected patterns corresponding connected components negative structure graph . call
patterns connected components .
Corollary 6.12. Let X finite set binary flat negative patterns. X tractable
X , connected components contained
Pivot(r), integer r ||.
Proof. Let X finite set binary flat negative patterns. Let CC() represent set
connected components pattern , CC(X ) union sets CC() ( X ).
Suppose X tractable. Consider arbitrary subset X 0 CC(X )
set X 0 contains exactly one connected component pattern X . Lemma 3.10
CSP(X 0 ) CSP(X ), hence X 0 tractable. Therefore, Corollary 5.6,
pattern 0 X 0 occurs Pivot(r), integer r |0 |. way
true possible choices X 0 X connected
components occur Pivot(r), integer r ||.
hand, suppose X , connected components
X occurs Pivot(r), r ||. Let k number connected components
. occurs disjoint union k copies Pivot(r). tractable
Theorem 6.1 k 1 applications Lemma 4.2. follows , hence X ,
tractable.

7. Conclusion
paper described framework identifying classes CSPs terms forbidden
patterns, used tool identifying tractable classes CSP. gave several
examples small patterns used define tractable classes CSPs.
75

fiCohen, Cooper, Creed, Marx & Salamon

search general result, restricted special case binary
patterns binary CSPs. Theorem 5.2 showed CSP(X ) NP-hard every
pattern set X contains least one four patterns (Patterns 8, 9, 10, 11). Moreover,
showed binary flat negative pattern contain patterns
must contained within (possibly several copies of) special type pattern called
pivot. Hence, contained (several copies of) pivot necessary condition
pattern tractable. showed forbidding pivot pattern defines
tractable class.
Beyond dichotomy binary flat negative patterns, interesting see
new tractable classes defined general binary patterns non-binary
patterns. particular, important area future research determining maximal
tractable classes problems defined patterns fixed size (given number
variables number variable-value assignments). avenue future research
characterisation complexity patterns involving structure uses
disequalities groups variables, total ordering variables.

Acknowledgments
authors acknowledge support ANR Project ANR-10-BLAN-0210, EPSRC grants
EP/F011776/1 EP/I011935/1, ERC Starting Grant PARAMTIGHT (No. 280152),
EPSRC platform grant EP/F028288/1.

References
Bessiere, C., Regin, J.-C., Yap, R. H. C., & Zhang, Y. (2005). optimal coarse-grained
arc consistency algorithm. Artificial Intelligence, 165 (2), pp. 165185. doi:10.1016/
j.artint.2005.02.004.
Bulatov, A., Jeavons, P., & Krokhin, A. (2005). Classifying complexity constraints
using finite algebras. SIAM Journal Computing, 34 (3), pp. 720742. doi:10.
1137/S0097539700376676.
Bulatov, A. A. (2003). Tractable conservative constraint satisfaction problems. LICS 03:
Proceedings 18th IEEE Symposium Logic Computer Science, pp. 321330.
doi:10.1109/LICS.2003.1210072.
Bulatov, A. A. (2006). dichotomy theorem constraint satisfaction problems 3element set. Journal ACM, 53 (1), pp. 66120. doi:10.1145/1120582.1120584.
Cohen, D., & Jeavons, P. (2006). complexity constraint languages. Rossi et al.
(Rossi et al., 2006), chap. 8, pp. 245280.
Cohen, D. A. (2003). new class binary CSPs arc-consistency decision
procedure. CP 03: Proceedings 9th International Conference Principles
Practice Constraint Programming, No. 2833 Lecture Notes Computer
Science, pp. 807811. Springer-Verlag. doi:10.1007/978-3-540-45193-8_57.
Cooper, M. C., & Escamocher, G. (2012). Dichotomy 2-Constraint Forbidden CSP
Patterns. AAAI 12: Proceedings Twenty-Sixth AAAI Conference Ar76

fiTractability CSP Classes Defined Forbidden Patterns

tificial Intelligence. Available from: https://www.aaai.org/ocs/index.php/AAAI/
AAAI12/paper/view/4960/5225.
Cooper, M. C., Jeavons, P. G., & Salamon, A. Z. (2010). Generalizing constraint satisfaction
trees: Hybrid tractability variable elimination. Artificial Intelligence, 174 (9
10), pp. 570584. doi:10.1016/j.artint.2010.03.002.
Cooper, M. C., & Zivny, S. (2011a). Hierarchically nested convex VCSP. CP 11: Proceedings 17th International Conference Principles Practice Constraint
Programming, pp. 187194. Springer-Verlag. doi:10.1007/978-3-642-23786-7_16.
Cooper, M. C., & Zivny, S. (2011b). Hybrid tractability valued constraint problems.
Artificial Intelligence, 175 (910), pp. 15551569. doi:10.1016/j.artint.2011.02.
003.
Costa, M.-C. (1994). Persistency maximum cardinality bipartite matchings. Operations
Research Letters, 15 (3), pp. 143149. doi:10.1016/0167-6377(94)90049-3.
Dalmau, V., Kolaitis, P. G., & Vardi, M. Y. (2002). Constraint satisfaction, bounded
treewidth, finite-variable logics. CP 02: Proceedings 8th International Conference Principles Practice Constraint Programming, No. 2470
Lecture Notes Computer Science, pp. 310326. Springer-Verlag. doi:10.1007/
3-540-46135-3_21.
Dechter, R., & Pearl, J. (1987). Network-based heuristics constraint-satisfaction problems. Artificial Intelligence, 34 (1), pp. 138. doi:10.1016/0004-3702(87)90002-6.
Dechter, R., & Pearl, J. (1989). Tree clustering constraint networks. Artificial Intelligence, 38 (3), pp. 353366. doi:10.1016/0004-3702(89)90037-4.
Dirac, G. A. (1966). Short proof Mengers graph theorem. Mathematika, 13 (1), pp.
4244. doi:10.1112/S0025579300004162.
Freuder, E. C. (1990). Complexity K-Tree Structured Constraint Satisfaction Problems.
AAAI 90: Proceedings Eighth National Conference Artificial Intelligence,
pp. 49. Available from: http://www.aaai.org/Library/AAAI/1990/aaai90-001.
php.
Garey, M. R., & Johnson, D. S. (1979). Computers Intractability: Guide Theory
NP-Completeness. W. H. Freeman, San Francisco, CA.
Gottlob, G., Leone, N., & Scarcello, F. (2002). Hypertree decompositions tractable
queries. Journal Computer System Sciences, 64 (3), pp. 579627. doi:10.
1006/jcss.2001.1809.
Green, M. J., & Cohen, D. A. (2003). Tractability approximating constraint languages.
CP 03: Proceedings 9th International Conference Principles Practice
Constraint Programming, Vol. 2833 Lecture Notes Computer Science, pp. 392
406. Springer-Verlag. doi:10.1007/978-3-540-45193-8_27.
Grohe, M. (2006). structure tractable constraint satisfaction problems. MFCS 06:
Proceedings 31st Symposium Mathematical Foundations Computer Science, Vol. 4162 Lecture Notes Computer Science, pp. 5872. Springer-Verlag.
doi:10.1007/11821069_5.
77

fiCohen, Cooper, Creed, Marx & Salamon

Grohe, M. (2007). complexity homomorphism constraint satisfaction problems
seen side. Journal ACM, 54 (1), pp. 124. doi:10.1145/
1206035.1206036.
Gyssens, M., Jeavons, P. G., & Cohen, D. A. (1994). Decomposing constraint satisfaction
problems using database techniques. Artificial Intelligence, 66 (1), pp. 5789. doi:
10.1016/0004-3702(94)90003-5.
Jeavons, P., Cohen, D., & Gyssens, M. (1997). Closure properties constraints. Journal
ACM, 44 (4), pp. 527548. doi:10.1145/263867.263489.
Jeavons, P. G., & Cooper, M. C. (1995). Tractable constraints ordered domains. Artificial
Intelligence, 79 (2), pp. 327339. doi:10.1016/0004-3702(95)00107-7.
Jegou, P. (1993). Decomposition domains based micro-structure finite
constraint-satisfaction problems. AAAI 93: Proceedings Eleventh National Conference Artificial Intelligence, pp. 731736. Available from: http:
//www.aaai.org/Library/AAAI/1993/aaai93-109.php.
Marx, D. (2010a). beat treewidth?. Theory Computing, 6 (1), pp. 85112.
doi:10.4086/toc.2010.v006a005.
Marx, D. (2010b). Tractable hypergraph properties constraint satisfaction conjunctive queries. STOC 10: Proceedings 42nd ACM symposium Theory
computing, pp. 735744. ACM. doi:10.1145/1806689.1806790.
Regin, J.-C. (1994). filtering algorithm constraints difference CSPs. AAAI 94:
Proceedings Twelfth National Conference Artificial Intelligence, Vol. 1, pp.
362367. Available from: http://www.aaai.org/Library/AAAI/1994/aaai94-055.
php.
Robertson, N., & Seymour, P. D. (1986). Graph minors. V. Excluding planar graph. Journal Combinatorial Theory, Series B, 41, pp. 92114. doi:10.1016/0095-8956(86)
90030-4.
Rossi, F., van Beek, P., & Walsh, T. (Eds.). (2006). Handbook Constraint Programming.
Foundations Artificial Intelligence. Elsevier.
Salamon, A. Z., & Jeavons, P. G. (2008). Perfect constraints tractable. CP 08:
Proceedings 14th International Conference Principles Practice Constraint Programming, Vol. 5202 Lecture Notes Computer Science, pp. 524528.
Springer-Verlag. doi:10.1007/978-3-540-85958-1_35.
van Hoeve, W. J. (2001). alldifferent Constraint: Survey. Proceedings 6th
Annual Workshop ERCIM Working Group Constraints. Available from:
http://arxiv.org/abs/cs/0105015v1.
Weigel, R., & Bliek, C. (1998). reformulation constraint satisfaction problems.
ECAI 98: Proceedings 13th European Conference Artificial Intelligence, pp.
254258.

78


