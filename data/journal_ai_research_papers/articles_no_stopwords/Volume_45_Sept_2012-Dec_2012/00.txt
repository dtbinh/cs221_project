Journal Artificial Intelligence Research 45 (2012) 1-45

Submitted 11/11; published 9/12

Interactions Knowledge Time
First-Order Logic Multi-Agent Systems:
Completeness Results
F. Belardinelli
A. Lomuscio

f.belardinelli@imperial.ac.uk
a.lomuscio@imperial.ac.uk

Department Computing
Imperial College London, UK

Abstract
investigate class first-order temporal-epistemic logics reasoning multiagent systems. encode typical properties systems including perfect recall, synchronicity, learning, unique initial state terms variants quantified interpreted systems, first-order extension interpreted systems. identify several monodic
fragments first-order temporal-epistemic logic show completeness respect
corresponding classes quantified interpreted systems.

1. Introduction
reactive systems (Pnueli, 1977) traditionally specified using plain temporal logic,
well-established tradition Artificial Intelligence (AI) and, particular, MultiAgent Systems (MAS) research adopt expressive languages. Much tradition
inspired earlier, seminal work AI McCarthy (1979, 1990) others aimed
adopting intentional stance (Dennett, 1987) reasoning intelligent systems.
Specifically, logics knowledge (Fagin, Halpern, Moses, & Vardi, 1995), beliefs, desires,
intentions, obligations, etc., put forward represent informational
motivational attitudes agents system. Theoretical explorations focused
soundness completeness number axiomatisations well decidability
computational complexity corresponding logics.
great majority work lines focuses propositional languages. Yet, specifications supporting quantification increasingly required applications. example,
often necessary refer different individuals different instances time.
Quantified modal languages (Garson, 2001) long attracted considerable attention.
Early work included analysing philosophical logical implications different setups quantification domains, particularly combination temporal concepts.
recently, considerable attention given identifying suitable fragments
preserve completeness decidability, studying resulting computational complexity satisfiability problem. article follows direction.
detail, investigate meta-theoretical properties monodic fragments
quantified temporal-epistemic logic interactions quantifiers, time,
knowledge agents present. deep-rooted interest (Fagin et al., 1995;
Meyden, 1994) understanding implications interaction axioms context,
often express interesting properties MAS, including perfect recall, synchronicity,
c
2012
AI Access Foundation. rights reserved.

fiBelardinelli & Lomuscio

learning. features well-understood propositional level (Fagin,
Halpern, & Vardi, 1992; Halpern, van der Meyden, & Vardi, 2004) commonly used
several application areas. technical question paper aims resolve whether
similar range results provided presence (limited forms of) quantification.
shall demonstrate, answer question largely positive.
1.1 State Art
analysis application temporal-epistemic logic first-order setting
established tradition AI. One early contributions work Moore (1990),
presents theory action takes consideration epistemic preconditions
actions effects knowledge. recently, number first-order temporalepistemic logics reasoning MAS introduced Wooldridge et al. (2002,
2006, 1999), often context MABLE programming language agents.
authors introduced first-order branching time temporal logic MAS (Wooldridge
& Fisher, 1992), developed series papers (Wooldridge et al., 2002, 2006).
First-order multi-modal logics constitute conceptual base number
agent theories, BDI logics (Rao & Georgeff, 1991), KQML framework (Cohen
& Levesque, 1995), LORA framework (Wooldridge, 2000b). include
operators mental attitudes (e.g., knowledge, belief, intention, desire, etc.), well
temporal dynamic operators form quantification. However,
current literature far fallen short systematic analysis formal properties
frameworks. frameworks rich unlikely
finitely axiomatisable, let alone decidable. Still, earlier contributions inspiration
present investigation, among explicitly addressed
subject first-order temporal-epistemic languages MAS setting.
purely theoretical level, first-order temporal epistemic logics received increasing attention range contributions axiomatisability (Degtyarev
et al., 2003; Sturm et al., 2000; Wolter & Zakharyaschev, 2002), decidability (Degtyarev
et al., 2002; Hodkinson et al., 2000; Wolter & Zakharyaschev, 2001), complexity (Hodkinson, 2006; Hodkinson et al., 2003). Wolter Zakharyaschev (2001) introduced
monodic fragment quantified modal logic, modal operators restricted
formulas one free variable, proved decidability various fragments. Similar results obtained monodic fragments first-order temporal
logic (Hodkinson, 2002; Hodkinson et al., 2000), computational complexity
formalisms analysed (Hodkinson, 2006; Hodkinson et al., 2003). Further, Wolter
Zakharyaschev (2002) provided complete axiomatisation monodic first-order
validities natural numbers. monodic fragment first-order epistemic logic
explored (Sturm et al., 2000; Sturm, Wolter, & Zakharyaschev, 2002),
axiomatisation including common knowledge provided. lines research
constitute theoretical background research set.
contributions discussed previously used plain Kripke models underlying semantics. However, argued though applications computationallygrounded semantics (Wooldridge, 2000a) preferable, enables systems modelled directly. introduced quantified interpreted systems (QIS) fill gap (Belar2

fiInteractions Knowledge Time First-Order Logic MAS

dinelli & Lomuscio, 2009). enabled us provide complete axiomatisation
monodic fragment quantified temporal-epistemic logic linear time (Belardinelli & Lomuscio, 2011). However, interaction temporal epistemic modalities
studied. Preliminary investigations interactions temporal epistemic
operators first-order setting already appeared (Belardinelli & Lomuscio, 2010).
paper extend previous results consider epistemic languages containing
common knowledge operator.
1.2 Present Contribution
paper extends current state art first-order temporal-epistemic logic
introducing family provably complete calculi variety quantified interpreted systems characterising range properties including perfect recall, learning, synchronicity,
unique initial state. prove completeness presented first-order
temporal-epistemic logics via quasimodel construction, previously used
(Hodkinson, Wolter, & Zakharyaschev, 2002; Hodkinson et al., 2000) prove decidability
monodic fragments first-order temporal logic (FoTL). Quasimodels
applied first-order temporal well epistemic logic (Sturm et al., 2000; Wolter & Zakharyaschev, 2002). Wolter et al. (2002) present complete axiomatisation monodic
fragment FoTL natural numbers; similar result variety first-order epistemic logics common knowledge appeared (Sturm et al., 2000). However,
interaction temporal epistemic modalities first order setting
taken account yet, interpreted systems semantics. Nonetheless,
features essential applications multi-agent systems subject
analysis here.
1.2.1 Structure Paper.
Section 2 first introduce first-order temporal-epistemic languages Lm LCm
common knowledge set Ag = {1, . . . , m} agents. present relevant
classes QIS well monodic fragments Lm LCm . Sections 3 introduce
axiomatisations classes QIS, details completeness proofs
presented Sections 4 5. Finally, Section 6 elaborate results obtained
discuss possible extensions future work.

2. First-Order Temporal-Epistemic Logics
Interpreted systems standard semantics interpreting temporal-epistemic logics
multi-agent setting (Fagin et al., 1995; Parikh & Ramanujam, 1985). extend interpreted
systems first-order case enriching structures domain individuals.
first investigated static quantified interpreted systems, account
evolution system given (Belardinelli & Lomuscio, 2008, 2009). Then, fully-fledged
QIS language temporal modalities introduced (Belardinelli & Lomuscio,
2010, 2011). follow definition QIS provided references.
3

fiBelardinelli & Lomuscio

2.1 First-Order Temporal-Epistemic Languages
Given set Ag = {1, . . . , m} agents, first-order temporal-epistemic language Lm
contains individual variables x1 , x2 , . . ., individual constants c1 , c2 , . . ., n-ary predicate constants P1n , P2n , . . ., n N, propositional connectives , quantifier ,
linear time operators U, epistemic operator Ki agent Ag.
language LCm contains common knowledge operator C (Fagin et al., 1992).
simplicity consider one group agents common knowledge modality,
is, whole Ag; C really tantamount CAg . extension proper non-empty
subsets Ag problematic.
languages Lm LCm contain symbol functions; terms t1 , t2 , . . .
languages either individual variables constants.
Definition 1. Formulas Lm defined Backus-Naur form follows:
::= P k (t1 , . . . , tk ) | | 0 | x | | U 0 | Ki
language LCm extends Lm following clause:
formula LCm , C formula LCm .
formulas U0 read next step eventually 0
respectively. formula Ki represents agent knows , C stands
common knowledge set Ag agents.
define symbols , , , , G (always future), F (some time future)
standard. Further, introduce abbreviations. V
operator Ki dual Ki ,
is, Ki defined Ki , E shorthand iAg Ki . k N, E k
defined follows: E 0 = E k+1 = EE k . formulas Ki E read
agent considers possible every agent knows respectively.
Free bound variables defined standard. [~y ] mean ~y = y1 , . . . , yn
free variables . Additionally, [~y /~t] formula obtained substituting simultaneously some, possibly all, free occurrences ~y ~t = t1 , . . . , tn
renaming bound variables. sentence formula free variables.
2.2 Quantified Interpreted Systems
introduce quantified interpreted systems assume set Li local states li , li0 , . . .
agent Ag multi-agent system. consider set Le local states
environment e well. set Le L1 . . .Lm contains global states
multi-agent system. represent temporal evolution MAS consider
flow time N natural numbers; run function r : N S. Intuitively, run
represents one possible evolution MAS assuming N flow time. Given
above, define quantified interpreted systems languages Lm LCm follows:
Definition 2 (QIS). quantified interpreted system triple P = hR, D, Ii where:
R non-empty set runs;
non-empty set individuals;
4

fiInteractions Knowledge Time First-Order Logic MAS

r R, n N, first-order interpretation, is, function
every constant c, I(c, r(n)) D,
every predicate constant P k , I(P k , r(n)) k-ary relation D.
Further, every r, r0 R, n, n0 N, I(c, r(n)) = I(c, r0 (n0 )).
Notice assume unique domain interpretation, well fixed interpretation
individual constants; simply write I(c). Following standard notation (Fagin et al.,
1995), r R n N, pair (r, n) point P. r(n) = hle , l1 , . . . , lm
global state point (r, n) (n) = le ri (n) = li environments agent
local state (r, n) respectively. Further, Ag epistemic equivalence relation
defined (r, n) (r0 , n0 ) iff ri (n) = ri0 (n0 ). Clearly, equivalence
relation. Two points (r, n) (r0 , n0 ) said epistemically
reachable, simply

reachable, (r, n) (r0 , n0 ) transitive closure iAg .
paper consider following classes QIS.
Definition 3. quantified interpreted system P satisfies
synchronicity

iff

every Ag, points (r, n), (r0 , n0 ),
(r, n) (r0 , n0 ) implies n = n0

perfect recall agent

iff

points (r, n), (r0 , n0 ), (r, n) (r0 , n0 ) n > 0
either (r, n 1) (r0 , n0 )
k < n0 (r, n 1) (r0 , k)
k 0 , k < k 0 n0 implies (r, n) (r0 , k 0 )

learning agent

iff

points (r, n), (r0 , n0 ), (r, n) (r0 , n0 )
either (r, n + 1) (r0 , n0 )
k > n0 (r, n + 1) (r0 , k)
k 0 , k > k 0 n0 implies (r, n) (r0 , k 0 )

unique initial state

iff

r, r0 R, r(0) = r0 (0)

conditions extensively discussed literature (Halpern et al., 2004)
together equivalent formulations. Intuitively, QIS synchronous time part
local state agent. QIS satisfies perfect recall agent local state records
everything happened (from agents point view) far run.
learning dual perfect recall: agent acquire new knowledge run.
Finally, QIS unique initial state runs start global state.
QIS P satisfies perfect recall (resp. learning) P satisfies perfect recall (resp.
learning) agents. denote class QIS agents QIS ; superscripts
pr, nl, sync, uis denote subclasses QIS satisfying perfect recall, learning,
synchronicity, unique initial state respectively. instance, QIS sync,uis


class synchronous QIS agents unique initial state.
assign interpretation formulas Lm LCm means quantified
interpreted systems. Let assignment variables individuals D, valuation
5

fiBelardinelli & Lomuscio

(t) term defined (y) = y, (t) = I(c) = c. variant ax
assignment assigns x agrees variables.
Definition 4. satisfaction formula Lm point (r, n) P assignment
, denoted (P , r, n) |= , defined inductively follows:
(P , r, n) |= P k (t1 , . . . , tk )
(P , r, n) |=
(P , r, n) |= 0
(P , r, n) |= x
(P , r, n) |=
(P , r, n) |= U 0

iff
iff
iff
iff
iff
iff

(P , r, n) |= Ki

iff

hI (t1 ), . . . , (tk )i I(P k , r(n))
(P , r, n) 6|=
(P , r, n) 6|= (P , r, n) |= 0
x
D, (P , r, n) |=
(P , r, n + 1) |=
n0 n (P , r, n0 ) |= 0
(P , r, n00 ) |= n n00 < n0
r0 , n0 , (r, n) (r0 , n0 ) implies (P , r0 , n0 ) |=

LCm consider case common knowledge operator:
(P , r, n) |= C

iff

k N, (P , r, n) |= E k

truth conditions , , , , G F defined above.
definition follows (P , r, n) |= C iff (r0 , n0 ) reachable (r, n),
(P , r0 , n0 ) |= .
formula true point (r, n) satisfied (r, n) every assignment ;
true QIS P true every point P; valid class C QIS true
every QIS C. Further, formula satisfiable QIS P satisfied
point P, assignment ; satisfiable class C QIS satisfiable
QIS C.
considering combinations pr, nl, sync uis obtain 16 subclasses QIS
N. independent, axiomatisable. Indeed,
axiomatisable even propositional level (Halpern & Moses, 1992; Halpern &
Vardi, 1989). first column Table 1 group together classes QIS share
set validities languages Lm LCm . proofs equivalences
similar propositional case (Halpern et al., 2004) reported
here. Further, define languages PLm PLCm propositional fragments
Lm LCm respectively (formally, PLm PLCm obtained restricting atomic
formulas 0-ary predicate constants p1 , p2 , . . .). Table 1 summarises results Halpern
et al. (2004) concerning axiomatisability propositional validities PLm PLCm .
Observe that, regards language PLm , = 1 sets validities various
classes QIS axiomatisable, 2 axiomatisation given
QIS nl,uis
QIS nl,pr,uis
(Halpern & Vardi, 1986, 1989). language PLCm ,


restrict case 2, = 1 PLCm expressive power
PLm . 2 class validities PLCm recursive axiomatisation QIS ,
uis
sync,uis
QIS nl,sync,uis
, QIS nl,pr,sync,uis
.
QIS sync


, QIS , QIS
next section show axiomatisability results propositional level
lifted monodic fragment languages Lm LCm .
6

fiInteractions Knowledge Time First-Order Logic MAS

QIS
sync,uis
QIS , QIS sync
,
QIS uis

, QIS
pr,uis
QIS pr
, QIS
pr,sync
QIS
, QIS pr,sync,uis

nl
QIS
QIS nl,sync

QIS nl,pr

QIS nl,pr,sync

QIS nl,uis

QIS nl,pr,uis

QIS nl,sync,uis
, QIS nl,pr,sync,uis



PL1
X
X
X
X
X
X
X
X
X
X

PLm , 2
X
X
X
X
X
X
X
7
7
X

PLCm , 2
X
7
7
7
7
7
7
7
7
X

Table 1: Equivalences classes QIS axiomatisability results propositional fragments PLm PLCm . sign X indicates set validities
specific class axiomatisable; 7 indicates not.

2.3 Monodic Fragment
rest paper show sufficient condition lifting results
Table 1 first-order case restrict languages Lm LCm monodic
fragments.
Definition 5. monodic fragment L1m set formulas Lm subformula form Ki , , 1 U2 contains one free variable. Similarly,
1 set formulas LC
monodic fragment LCm
subformula
form Ki , C, , 1 U2 contains one free variable.
monodic fragments number first-order modal logics thoroughly
investigated literature (Hodkinson et al., 2000, 2003; Wolter & Zakharyaschev, 2001,
2002). case Lm LCm fragments quite expressive contain
formulas following:
C(zAvailable(y, z)UxRequest(x, y))

(1)

Ki xyz(Request(x, y) Available(y, z))
Ki xyz(Request(x, y) Available(y, z))

(2)

Formula (1) intuitively states common knowledge every resource
eventually requested somebody, time resource remains available
everybody. Notice free variable within scope modal operators U
C. Formula (2) represents agent knows next step every resource
available whenever requested, next step agent knows indeed
case. However, note formula
xKi (Process(x) yF Access(x, y))
7

fiBelardinelli & Lomuscio

intuitively means agent knows every process eventually try access
every resource, L1m x occur free within scope modal operator
F . Still, monodic fragments Lm LCm quite expressive contain
de dicto formulas, i.e., formulas free variable appears scope modal
operator, (2). So, limitation really de formulas.
stress fact formulas propositional equivalent
case interepreted quantified interpreted systems domain
quantification infinite, cardinality cannot bounded advance.
Finally, observe Barcan formulas x x Ki x xKi
true quantified interpreted systems, QIS includes unique domain
quantification. implies universal quantifier commutes temporal
modality epistemic modality Ki . Thus, case formulas
, 0 Lm , 0 validity, L1m 0
/ L1m . instance,
consider = xP (x, y) 0 = x P (x, y). see remark
interfere results.

3. Axiomatisations
section present sound complete axiomatisations sets monodic validities classes quantified interpreted systems Section 2. First, introduce
basic system QKTm extends first-order case multi-modal epistemic logic
S5m combined linear temporal logic LTL.
Definition 6. system QKTm contains following schemes axioms rules,
, formulas L1m = inference relation.
First-order logic

Temporal logic

Epistemic logic

Taut
MP
Ex
Gen
K
T1
T2
Nec
T3
K

4
5
Nec

classical propositional tautologies
, =
x [x/t]
[x/t] = x, x free
( ) ( )

U ( (U))
=
= (U)
Ki ( ) (Ki Ki )
Ki
Ki Ki Ki
Ki Ki Ki
= Ki

operator Ki S5 modality, next U operators axiomatised linear-time modalities (Fagin et al., 1995). add classical postulates
Ex Gen quantification, sound consider unique domain
individuals quantified interpreted systems.
8

fiInteractions Knowledge Time First-Order Logic MAS

Definition 7. system QKT Cm extends QKTm following schemes axioms
1 = inference
common knowledge, , formulas LCm
relation.
C1
C2

C ( EC)
( E) = C

consider standard definitions proof theorem; `S means formula
theorem formal system S. remark Barcan formula (BF ) 2x
x2 provable unary modal operator 2 axioms K Ex, rules
P Gen. notions soundness completeness system respect
class C QIS defined standard: sound w.r.t. C , ` implies C |= .
Similarly, complete w.r.t. C , C |= implies ` .
paper focus schemes axioms Table 2 specify key interactions
time knowledge (Halpern et al., 2004). use 1, . . . , 5 superscripts denote
KT1
KT2
KT3
KT4
KT5

Ki (Ki Ki ) Ki ((Ki )U((Ki )U))
Ki Ki
(Ki )UKi Ki ((Ki )UKi )
Ki Ki
Ki Kj
Table 2: axioms KT1-KT5.

systems obtained adding QKTm QKTCm combination KT1-KT5.
instance, system QKTC2,3
extends QKTCm axioms KT2 KT3.
straightforward check axioms QKTm QKTCm valid every
QIS inference rules preserve validity. However, axioms KT1-KT5 valid
specific classes QIS stated following Remark.
Remark 1. QIS P satisfies axioms KT1-KT5 first column P satisfies
corresponding semantical condition second column.
Axiom
KT1
KT2
KT3
KT4
KT5

Condition QIS
perfect recall
perfect recall, synchronicity
learning
learning, synchronicity
agents share knowledge, i.e.,
i, j Ag, (r, n) (r0 , n0 ) iff (r, n) j (r0 , n0 ).

results shown similar way propositional case (Halpern et al.,
2004); proofs omitted.
using Remark 1 prove soundness results first-order temporalepistemic systems.
Theorem 1 (Soundness). systems reported first second column following table sound w.r.t. corresponding classes QIS third column.
9

fiBelardinelli & Lomuscio

Systems
QKTm
QKT Cm
1
1
QKTm
QKT Cm
2
2
QKTm
QKT Cm
3
3
QKTm
QKT Cm
4
4
QKTm
QKT Cm
2,3
2,3
QKTm
QKT Cm
1,4
1,4
QKTm
QKT Cm
1,4,5
1,4,5
QKTm
QKT Cm

QIS
sync,uis
QIS , QIS sync
,
QIS uis

, QIS
pr,uis
QIS pr
, QIS
pr,sync
QIS
, QIS pr,sync,uis

nl
QIS , QIS nl,uis

QIS nl,sync

nl,pr,uis
QIS nl,pr
, QIS
nl,pr,sync
QIS
QIS nl,sync,uis
, QIS nl,pr,sync,uis



Proof. results follow Remark 1 line reasoning similar used
propositional case (Fagin et al., 1995; Halpern et al., 2004). Notice quantified
interpreted systems P satisfies learning, synchronicity, unique initial state,
P satisfies perfect recall, is, P QIS nl,sync,uis
implies P QIS nl,pr,sync,uis
.


Further, agents share knowledge, therefore KT5 holds P.
anticipated above, calculi complete w.r.t. corresponding classes
quantified interpreted systems Theorem 1. next theorem summarise
completeness results proved rest paper.
Theorem 2 (Completeness). systems reported first second column
following table complete w.r.t. corresponding classes QIS third column.
Systems
QKTm
QKT Cm
1
QKTm
2
QKTm
3
QKTm
4
QKTm
2,3
QKTm
1,4
QKTm
QKT12,3
1,4,5
1,4,5
QKTm
QKT Cm

QIS
sync,uis
uis
QIS , QIS sync
, QIS , QIS
pr
pr,uis
QIS , QIS
QIS pr,sync
, QIS pr,sync,uis


nl
QIS
QIS nl,sync

QIS nl,pr

QIS nl,pr,sync

QIS nl,uis
, QIS nl,pr,uis
1
1
nl,pr,sync,uis
QIS nl,sync,uis
,
QIS



observe that, regards language L1m , sets monodic validities axiomatisable classes introduced QIS nl,uis
QIS nl,pr,uis
. However, L11


QIS nl,uis
QIS nl,pr,uis
equivalent QIS nl,pr
. Thus, sets monodic
1
1
1
nl,pr,uis
nl,uis
validities QIS 1
QIS 1
axiomatised QKT2,3
1 .
1
regards language LCm , set monodic validities QIS , QIS sync
,
sync,uis
nl,sync,uis
nl,pr,sync,uis
QIS uis
,
QIS

axiomatisable,

well



QIS

QIS
.




classes recursively axiomatisable, case already propositional level (Halpern & Moses, 1992; Halpern & Vardi, 1986, 1989).
proving completeness results reported introduce Kripke models
generalisation quantified interpreted systems.
10

fiInteractions Knowledge Time First-Order Logic MAS

3.1 Kripke Models
prove completeness results Theorem 2, first introduce appropriate class
Kripke models generalisation QIS prove completeness models.
apply correspondence result Kripke models QIS obtain desired
results.
Definition 8 (Kripke model). Kripke model tuple = hW, RW , {i }iAg , D, Ii

W non-empty set states;
RW non-empty set functions r : N W ;
every agent Ag, equivalence relation W ;
non-empty set individuals;
every w W , first-order interpretation, is, function
every constant c, I(c, w) D,
every predicate constant P k , I(P k , w) k-ary relation D.
Further, every w, w0 W , I(c, w) = I(c, w0 ).
Notice Def. 8 differs notions Kripke model includes
set RW functions guarantee correspondence Kripke models
QIS one-to-one. assume unique domain interpretation, well fixed
interpretation individual constants, case simply write I(c). Kripke
models generalisation QIS specify inner structure states
W . Kripke models introduce points pairs (r, n) r RW n N.
point derives properties corresponding state; instance, (r, n) (r0 , n0 )
r(n) r0 (n0 ).
consider Kripke models satisfying synchronicity, perfect recall, learning,
unique initial state. definition subclasses analogous Def. 3.
Definition 9. Kripke model satisfies
synchronicity

iff

every Ag, points (r, n), (r0 , n0 ),
(r, n) (r0 , n0 ) implies n = n0

perfect recall agent

iff

points (r, n), (r0 , n0 ), (r, n) (r0 , n0 ) n > 0
either (r, n 1) (r0 , n0 )
k < n0 (r, n 1) (r0 , k)
k 0 , k < k 0 n0 implies (r, n) (r0 , k 0 ).

learning agent

iff

points (r, n), (r0 , n0 ), (r, n) (r0 , n0 )
either (r, n + 1) (r0 , n0 )
k > n0 (r, n + 1) (r0 , k)
k 0 , k > k 0 n0 implies (r, n) (r0 , k 0 ).

unique initial state

iff

r, r0 RW , r(0) = r0 (0).
11

fiBelardinelli & Lomuscio

let Km class Kripke models agents. Hereafter adopt
sync,uis
naming conventions QIS; instance, Km
class synchronous Kripke
models agents unique initial state. Further, inductive clauses
satisfaction relation |= respect assignment straightforwardly defined
QIS, well notions truth validity.
Definition 10. satisfaction formula Lm (resp. LCm ) point (r, n)
assignment , (M , r, n) |= , inductively defined follows:
(M , r, n) |= P k (t1 , . . . , tk )
(M , r, n) |=
(M , r, n) |= 0
(M , r, n) |= x
(M , r, n) |=
(M , r, n) |= U 0

iff
iff
iff
iff
iff
iff

(M , r, n) |= Ki
(M , r, n) |= C

iff
iff

hI (t1 ), . . . , (tk )i I(P k , r(n))
(M , r, n) 6|=
(M , r, n) 6|= (M , r, n) |= 0
x
D, (Ma , r, n) |=
(M , r, n + 1) |=
n0 n (M , r, n0 ) |= 0
n n00 < n0 implies (M , r, n00 ) |=
r0 , n0 , (r, n) (r0 , n0 ) implies (M , r0 , n0 ) |=
k N, (M , r, n) |= E k

formula true point (r, n) satisfied (r, n) every assignment ;
true Kripke model true every point M; valid class C
Kripke models true every Kripke model C. Further, formula satisfiable
Kripke model satisfied point M, assignment ;
satisfiable class C Kripke models satisfiable Kripke model C.
relate Kripke models quantified interpreted systems means map g :
Km QIS (Lomuscio & Ryan, 1998). Let = hW, RW , {i }iAg , D, Ii Kripke
model. every agent Ag, (r, n) M, let equivalence class [(r, n)]i = {(r0 , n0 ) |
(r, n) (r0 , n0 )} local state agent i; (r, n) local state
environment. define g(M) tuple hR0 , D, 0 R0 contains runs rr
r RW rr (n) = h(r, n), [(r, n)]1 , . . . , [(r, n)]m i. Further, M,
every constant c, 0 (c, rr (n)) = I(c, r(n)), 0 (P k , rr (n)) = I(P k , r(n)).
structure g(M) QIS satisfies following result:
Lemma 1. every Lm (resp. LCm ),
(M , r, n) |= iff (g(M) , rr , n) |=
Proof. proof induction structure . atomic formula P k (t1 , . . . , tk ), (M , r, n) |= iff hI (t1 ), . . . , (tk )i I(P k , r(n)), iff
hI 0 (t1 ), . . . , 0 (tk )i 0 (P k , rr (n)), iff (g(M) , rr , n) |= . inductive cases
propositional connectives quantifiers straightforward, well temporal operators U. = Ki , (M , r, n) |= iff (r, n) (r0 , n0 )
0
implies (M , r0 , n0 ) |= , (r, n) (r0 , n0 ) iff rri (n) = rri (n0 ). Thus, (M , r, n) |= iff
0
(rr , n) 0i (rr , n0 ) implies (M , r0 , n0 ) |= . Again, induction hypothesis (M , r, n) |=
0
0
iff (rr , n) 0i (rr , n0 ) implies (g(M) , rr , n0 ) |= , i.e., iff (g(M) , rr , n) |= . case
= C treated similarly considering epistemic reachability relation.

12

fiInteractions Knowledge Time First-Order Logic MAS

Notice satisfies synchronicity, perfect recall, learning, unique
initial state, g(M) satisfies property. follows fact
0
(r, n) (r0 , n0 ) iff (rri , n) 0i (rr , n0 ). Thus, g defines map 16 subclasses
Km outlined Def. 9 corresponding subclass QIS obtain following
corollary Lemma 1.
Corollary 1. Let X subset {pr, nl, sync, uis}. every monodic formula L1m
1 ), satisfiable KX , satisfiable QIS X .
(resp. LCm


reasoning monodic fragments Lm LCm dealing
learning perfect recall, introduce following class monodic friendly Kripke
models. structures motivated fact KT1 KT3 weak
enforce either perfect recall learning Kripke models axioms
restricted monodic formulas. However, suffice monodic friendly structures.
following, prove satisfiability Kripke models equivalent satisfability
monodic friendly structures restrict languages monodic formulas.
Definition 11 (mf-model). monodic friendly
Mmf = hW, RW , {i,a }iAg,aD , D, Ii

Kripke

model





tuple

W , RW , defined Kripke models;
Ag, D, i,a equivalence relation W .
define synchronicity, perfect recall, learning, unique initial state
mf-models parametrising Def. 9 relation i,a . instance, mf-model
satisfies perfect recall agent points (r, n), (r0 , n0 ), D, whenever
(r, n) i,a (r0 , n0 ) n > 0 either (r, n 1) i,a (r0 , n0 ) k < n0
(r, n 1) i,a (r0 , k) k 0 , k < k 0 n0 implies (r, n) i,a (r0 , k 0 ). regards
subclasses class MF mf-models agents, adopt naming
conventions QIS Kripke models. Notice Kripke models seen
mf-models Ag, a, b D, i,a equal i,b .
1 ) mf-model
Finally, satisfaction relation |= L1m (resp. LCm
mf
defined way Kripke models, except epistemic operators:
(Mmf , r, n) |= Ki [y]

iff

r0 , n0 , (r, n) i,(y) (r0 , n0 ) implies (Mmf , r0 , n0 ) |= [y]

appears free . Notice sentence, (Mmf , r, n) |= Ki
iff (r, n) i,a (r0 , n0 ) implies (Mmf , r0 , n0 ) |= D. case common
knowledge operator C straightforward definition E k . particular, two points (r, n)
0 0
(r0 , n0 ) epistemically reachable
D, simply reachable, (r, n) (r , n ),
transitive closure iAg i,a .
remark converse Barcan formula, CBF , Ki x xKi holds
mf-models; Barcan formula, BF , xKi Ki x not. check
consider mf-model = hW, RW , {i,a }iAg,aD , D, Ii Fig.1(a)
- W = {w, w0 , w00 }
- RW = {r, r0 , r00 } r(0) = w, r0 (0) = w0 , r00 (0) = w00
13

fiBelardinelli & Lomuscio

..
.

..
.

..
.

..
.

i,b

i,a

..
.

..
.
i,d

i,c

w0

w

w00

v0

v

P (a)

P (a), P (b)

P (b)

Q(c)

Q(c)

v 00

(b) mf-model M0 .

(a) mf-model M.

Figure 1: Arrows represent system runs; epistemically related states grouped
together.

- = {a, b}
- I(P 1 , r(0)) = {a, b}, I(P 1 , r0 (0)) = {a} I(P 1 , r00 (0)) = {b}
- i,a i,b equivalence relations (r, 0) i,a (r0 , 0) (r, 0) i,b (r00 , 0).
see (M, r, 0) |= xKi P (x), (M, r, 0) 6|= Ki xP (x) (r, 0) i,a (r0 , 0)
(M , r0 , 0) 6|= P (x) (x) = b.
Furthermore, K axiom Ki ( 0 ) (Ki Ki 0 ) valid mf-models
either. fact, consider mf-model M0 = hW 0 , R0W 0 , {0i,a }iAg,aD0 , D0 , 0 Fig.1(b)

- W 0 = {v, v 0 , v 00 }
- R0W 0 = {q, q 0 , q 00 } q(0) = v, q 0 (0) = v 0 , q 00 (0) = v 00
- D0 = {c, d}
- 0 (Q1 , q(0)) = {c}, 0 (Q1 , q 0 (0)) = {c} 0 (Q1 , q 00 (0)) =
- i,c i,d equivalence relations (q, 0) i,c (q 0 , 0) (q, 0) i,d (q 00 , 0).
Finally, let (x) = c. check (M , q, 0) |= (Q(x) xQ(x)) Q(x)
(M , q 0 , 0) |= (Q(x) xQ(x)) Q(x). Thus, (M , q, 0) |= Ki (Q(x) xQ(x)) Ki Q(x).
(M, q 00 , 0) 6|= xQ(x), (M , q, 0) 6|= Ki xQ(x).
prove following lemma, used completeness proof
systems satisfying perfect recall learning. lemma states that, deal
satisfability monodic formulas, mf-models suffice.
Lemma 2. Let MF K,BF
class mf-models validating formulas K BF .

1 ),
every monodic formula L1m (resp. LCm
Km |= iff MF K,BF
|=

14

fiInteractions Knowledge Time First-Order Logic MAS

Proof. implication right left follows fact class Km
Kripke models isomorphic subclass monodic friendly Kripke models
Ag, a, b D, i,a equal i,b . words, given Kripke model =
hW, RW , {i }iAg , D, Ii define mf-model M0 = hW, RW , {i,a }iAg,aD , D, Ii,
every D, i,a equal . straightforward see M0 validates
K BF (in particular, counterexamples Fig. 1 ruled out). Further,
6|= M0 6|= . Thus, MF K,BF
|= , Km |= .

implication left right, assume Mmf = hW, RW ,
{i,a }iAg,aD , D, Ii mf-model validating K BF (Mmf , r, n) 6|=
point (r, n) assignment . build Kripke model M0 =
hW 0 , R0W 0 , {0i }iAg , D0 , 0 Mmf (M0 , r, n) 6|= follows. start
assuming W 0 = W , SR0 = R D0 = D. Further, Ag, define 0i
transitive closure aD i,a . Finally, set 0 = I. check Kripke
model M0 well defined validate .
First all, point following issue associated construction above:
case point (q, k) monodic formula [x], happens
(Mmf , q, k) |= Ki [x], (q, k) i,(x) (q 0 , k 0 ) (q, k) i,(y) (q 00 , k 00 ) (x) 6= (y).
Further, suppose (Mmf , q 00 , k 00 ) 6|= [x], obviously (Mmf , q 0 , k 0 ) |=
[x]. definition 0i (M0 , q, k) 6|= Ki [x]; two models
satisfy formulas. solve problem modifying interpretation
according structure monodic formula [x], keeping truth value
[x] point (q, k). consider relevant cases according structure [x];
induction hypothesis consists fact able find interpretation
subformulas [x].
[x] = P (x) simply assume (x) I(P, q 00 (k 00 )), (M0 , q 00 , k 00 ) |=
[x] (M0 , q, k) |= Ki [x]. Note change truth value
epistemic formula (q, k) assumed (q, k) 6i,(x) (q 00 , k 00 ) (otherwise [x] would
satisfied (q 00 , k 00 )). cases propositional connectives modal operators
similarly dealt applying induction hypothesis. [x] = y[x, y]


b
, q 00 , k 00 ) 6|= [x, y].
(Mmf , q 00 , k 00 ) 6|= [x], therefore exists b (Mmf
consider 4 different cases depending whether (q, k) satisfies
4 formulas:

Ki x [x, y]

(3)

Ki x [x, y]

(4)

Ki x [x, y]

(5)

Ki x [x, y]

(6)

using axioms inference rules QKTm Formula (3) show
follows (where used entailment):
(Mmf , q, k) |= Ki y[x, y] Ki x[x, y]
(Mmf , q, k) |= xKi y[x, y] yKi x[x, y] Ex
(Mmf , q, k) |= Ki xy[x, y] Ki yx[x, y] zKi Ki z
(Mmf , q, k) |= Ki (xy[x, y] yx[x, y]) Ki ( ) Ki Ki
15

fiBelardinelli & Lomuscio

(Mmf , q, k) |= Ki (xu[x, u] yv[v, y])
(Mmf , q, k) |= Ki xyuv([x, u] [v, y])
(Mmf , q, k) |= Ki xy([x, y] [x, y])

change variables
prefixing
Ex

last formula contradiction; (3) cannot hold (q, k). Similarly, Formula
(4) cannot hold (q, k) either because:
(Mmf , q, k) |= Ki y[x, y] Ki x[x, y]
(Mmf , q, k) |= xKi y[x, y] Ki x[x, y]
(Mmf , q, k) |= Ki xy[x, y] Ki x[x, y]
(Mmf , q, k) |= Ki xy[x, y] Ki yx[x, y]
(Mmf , q, k) |= Ki (xy[x, y] yx[x, y])
(Mmf , q, k) |= Ki xy([x, y] [x, y])

Ex
zKi Ki z
z Ki Ki z
Ki Ki Ki ( )
similarly

Note derivations make use formulas K BF (for instance,
prove theorems Ki ( ) Ki Ki zKi Ki z). Finally, satify
Formulas (5) (6) (q, k), guarantee existence individual x
avoiding clash (x). So, introduce new individual a0 domain D0
a0 (x) satisfy formulas points. Thus, a0 seen copy
(x). Finally, induction hypothesis modify interpretation 0
(M0 , q 00 , k 00 ) |= [x, y].
case common knowledge operator derives one Ki . result,
obtain Kripke model M0 (M0 , r, n) 6|= .
Moreover, procedure described above, Mmf satisfies perfect recall, learning, synchronicity, unique initial state, M0 satisfies property.
Thus, Lemma 2 prove following result.
Corollary 2. Let X subset {pr, nl, sync, uis}. every monodic formula L1m
1 ), satisfiable MF X validating formulas K BF ,
(resp. LCm

X.
satisfiable Km
Proof. easy see Mmf satisfies either synchronicity unique
initial state, M0 well way defined. Further, suppose Mmf
satisfies perfect recall, (r, n) 0i (r0 , n0 ) n > 0. means sequence
a1 , . . . , ak individuals sequence (q1 , m1 ), . . . , (qk , mk ) points (i)
(r, n) = (q1 , m1 ) (r0 , n0 ) = (qk , mk ); (ii) (qj , mj ) i,aj (qj+1 , mj+1 ) j < k.
show result k = 3, case k > 3 follows straightforward generalisation.
(q1 , m1 1) i,a1 (q2 , m2 ), definition 0i (q1 , m1 1) 0i
(q3 , m3 ) well. Hence, Mmf satisfies perfect recall. Otherwise, suppose perfect
recall l2 < m2 (q1 , m1 1) i,a1 (q2 , l2 ), l20 , l2 < l20 m2
implies (q1 , m1 ) i,a1 (q2 , l20 ). consider l20 (h) = m2 h, 0 h < m2
l2 . perfect recall, either (i) exists p3 (h) (q2 , l20 (h)) i,a2 (q3 , p3 (h)),
p03 (h), p3 (h) < p03 (h) p3 (h 1) implies (q2 , l2 (h)) i,a2 (q3 , p03 (h)), (ii)
(q2 , l20 (h) 1) i,a2 (q3 , p3 (h 1)), p3 (1) = m3 . Notice cases,
definition 0i , (q1 , m1 ) 0i (q3 , p03 (h)) 0 h < m2 l2 , is,
(q1 , m1 ) 0i (q3 , p03 ) p3 [l2 + 1] < p03 m3 . Further, l2 , either (i) exists l3
16

fiInteractions Knowledge Time First-Order Logic MAS

(q2 , l2 1) i,a2 (q3 , l3 ), l30 , l3 < l30 p3 [l2 + 1] implies (q2 , l2 ) i,a2 (q3 , l30 ),
(ii) (q2 , l2 1) i,a2 (q3 , p3 [l2 + 1]). first case, l30 strictly less
m3 , l30 (q1 , m1 1) 0i (q3 , l30 ) l300 , l30 < l300 m3 implies
(q1 , m1 ) 0i (q3 , l300 ). Otherwise, (q1 , m1 1) 0i (q3 , m3 ). Hence, Mmf satisfies
perfect recall.
proof learning similar.
Finally, combining Corollaries 1 2 immediately obtain following result.
Corollary 3. Let X subset {pr, nl, sync, uis}. every monodic formula L1m
1 ), satisfiable MF X validating formulas K BF ,
(resp. LCm

satisfiable QIS X
m.
next section show indeed possible build mf-model.

4. Completeness Proof
section outline main steps completeness proof, based
quasimodel construction (Gabbay, Kurucz, Wolter, & Zakharyaschev, 2003; Hodkinson
et al., 2000). Differently contributions, explicitly take account
interaction temporal epistemic modalities. Intuitively, quasimodel
monodic formula relational structure whose points sets sets subformulas
. set sets subformulas describes possible state affairs, contains
sets subformulas defining individuals state. formally, given formula
LCn1 define
subC = sub {EC | C sub} {Ki C | C sub, Ag}
sub set subformulas . L1n , subC simply sub. Further,
define
subC = subC { | subC } { | subC } { | subC }
Observe subC closed negation modulo equivalences 1,
is, subC , form subC ; otherwise,
subC . Finally, let subn subset subC containing formulas
n free variables. So, sub0 set sentences subn . x variable occurring
, define subx = {[y/x] | [y] sub1 }. Clearly, x free variable
formulas subx . con denote set constants occurring . Table 3
report set suby equal Formula (1) thus abbreviated:
C(zAv(y, z)UxReq(x, y))
Further, k N define closures clk clk,i mutual recursion.

Definition 12. Let cl0 = subx k 0, clk+1 = iAg clk,i . k 0, Ag,
clk,i = clk {Ki (1 . . . n ), Ki (1 . . . n ) | 1 , . . . , n clk }.
17

fiBelardinelli & Lomuscio

suby

{, C(zAv(y, z)UxReq(x, y)), EC(zAv(y, z)UxReq(x, y)),
{Ki C(zAv(y, z)UxReq(x, y))}iAg , zAv(y, z)UxReq(x, y), zAv(y, z), xReq(x, y),
, C(zAv(y, z)UxReq(x, y)), EC(zAv(y, z)UxReq(x, y)),
{Ki C(zAv(y, z)UxReq(x, y))}iAg , zAv(y, z)UxReq(x, y), zAv(y, z),
xReq(x, y),
, C(zAv(y, z)UxReq(x, y)), EC(zAv(y, z)UxReq(x, y)),
{ Ki C(zAv(y, z)UxReq(x, y))}iAg , zAv(y, z)UxReq(x, y), zAv(y, z),
xReq(x, y),
, C(zAv(y, z)UxReq(x, y)), EC(zAv(y, z)UxReq(x, y)),
{ Ki C(zAv(y, z)UxReq(x, y))}iAg , zAv(y, z)UxReq(x, y), zAv(y, z),
xReq(x, y)}

Table 3: set suby equal Formula (1).


{, C(zAv(y, z)UxReq(x, y)), EC(zAv(y, z)UxReq(x, y)),
{Ki C(zAv(y, z)UxReq(x, y))}iAg , zAv(y, z)UxReq(x, y), zAv(y, z), xReq(x, y),
, C(zAv(y, z)UxReq(x, y)), EC(zAv(y, z)UxReq(x, y)),
{ Ki C(zAv(y, z)UxReq(x, y))}iAg , zAv(y, z)UxReq(x, y), zAv(y, z),
xReq(x, y)}
Table 4: type cl0 , equal Formula (1).

define ad() greatest number alternations distinct Ki along branch
parse tree (Halpern et al., 2004). Further, index finite sequence = i1 , . . . , ik
agents 6= in+1 , 1 n < k; length denoted ||. Also, ]i
absorptive concatenation indexes ]i = ik = i. Finally, K
shorthand Ki1 . . . Kik . let index || ad(). empty
sequence cl = clad() . = 0 ]i, cl = clk,i k = ad() ||.
introduce types quasimodels, intuitively seen individuals described
maximal consistent sets formulas.
Definition 13 (Type). -type maximal consistent subset cl , i.e.,
every monodic formulas 0 cl ,
(i) iff
/ t;
(ii) 0 iff , 0 t.
Two -types t, t0 said agree sub0 sub0 = t0 sub0 , i.e., share
sentences. Given -type constant c con, ht, ci indexed type
, abbreviated tc . Table 4 report type cl0 , equal Formula (1).
introduce state candidates, intuitively represent states quasimodel.
Definition 14 (State candidate). -state candidate pair C = hT, con

(i) set -types agree sub0 ;
(ii) con set containing c con indexed type tc .
18

fiInteractions Knowledge Time First-Order Logic MAS

introduce notion point, describes state candidate perspective particular type.
Definition 15 (Point). -point pair P = hC, ti
(i) C = hT, con -state candidate ;
(ii) -type.
Note that, slight abuse notation, call points pairs (r, n) QIS
pairs P = hC, ti. consistent previous work (Fagin et al., 1995; Halpern
et al., 2004); context disambiguate. Also, write C C = hT, con
. Similarly P. Given -state candidate C = hT, con point P = hC, ti
define formulas C P follows:
C :=

^

xt[x] x

tT

_
tT

t[x]

^

t[x/c]

tc con

P := C
distinguish type conjuction formulas contains.
-state candidate C S-consistent formula C consistent w.r.t. system S,
i.e., 0S C . Similarly, -point P S-consistent formula P consistent w.r.t. S.
refer plain consistency whenever system reference understood. Consistent
state candidates represent states quasimodels. define relations
suitability constitute relational part quasimodels.
Definition 16.
1 -type t1 2 -type t2 -suitable, t1 t2 , iff 1 = 2
t1 t2 consistent. i-suitable, t1 t2 , iff 1 ]i = 2 ]i t1 Ki t2
consistent.
1 -state candidate C1 2 -state candidate C2 -suitable, C1 C2 , iff
1 = 2 C1 C2 consistent. i-suitable, C1 C2 , iff 1 ]i = 2 ]i
C1 Ki C2 consistent.
1 -point P1 2 -point P2 -suitable, P1 P2 , iff 1 = 2 P1
P2 consistent. i-suitable, P1 P2 , iff 1 ]i = 2 ]i P1 Ki P2
consistent.
1 -point P1 = hC1 , t1 2 -point P2 = hC2 , t2 -suitable constant
c con, P1 c P2 , iff P1 P2 , tc1 T1con tc2 T2con . i-suitable
c, P1 ci P2 , iff P1 P2 , tc1 T1con tc2 T2con .
using axioms , 4 5 shown relation reflexive,
transitive symmetric, is, equivalence relation. Also, relation serial.
following lemma list properties relations useful
follows.
Lemma 3.

(i) Let subx , t1 t2 t1 iff t2 .
19

fiBelardinelli & Lomuscio

(ii) Let Ki subx let -type, Ki iff -types t0 , t0 implies
t0 . Moreover, let |]i| ad(), Ki iff ]i-types t0 , t0 implies
t0 .
Proof.
(i) proof similar one Lemma 9(i) work Wolter et al. (2002).
t1
/ t2 t2 since t1 t2 consistent,
consistent, contradiction. right left, t2
/ t1
t1 . Since t1 t2 consistent, consistent,
contradiction.
(ii) left right, Ki
/ t0 t0 since Ki t0 consistent,
Ki Ki consistent, contradiction. right left,
Ki
/ extend set {} { | Ki t} -type t0 . particular,
t0 t0 . Moreover, |]i| ad() similarly prove Ki
iff ]i-types t0 , t0 implies t0 .
present frame underlying quasimodel .
Definition 17 (Frame). frame F tuple hR, D, {i,a }iAg,aD ,
(i) R non-empty set indexes r, r0 , . . .;
(ii) non-empty set individuals;
(iii) every Ag, D, i,a equivalence relation set points (r, n)
r R n N;
(iv) f partial function associating point (r, n) consistent state candidate
f(r, n) = Cr,n
(a) domain f empty;
(b) f defined (r, n), defined (r, n + 1);
(c) f defined (r, n) (r, n) i,a (r0 , n0 ), f defined (r0 , n0 ).
function f partial take consideration case synchronous systems. Also,
straightforward introduce frames satisfying perfect recall, learning, synchronicity,
unique initial state, following definitions given mf-models. Next,
provide definition objects, correspond runs Gabbay et al. (2003).
choose terminology avoid confusion runs QIS.
Definition 18 (Object). Given individual D, object frame F map
con
associating type (r, n) Tr,n every (r, n) Dom(f) f(r, n) = Cr,n = hTr,n , Tr,n

1. (r, n) (r, n + 1)
2. (r, n) i,a (r0 , n0 ) (r, n) (r0 , n0 )
20

fiInteractions Knowledge Time First-Order Logic MAS

3. U (r, n) iff n0 n (r, n0 ) n00 , n n00 < n0
implies (r, n00 )
4. (r, n) -types, (r0 , n0 ), (r, n) i,a (r0 , n0 ) (r0 , n0 ) =
5. C (r, n) exists point (r0 , n0 ) reachable (r, n)
(r0 , n0 )
object+ satisfies (1), (2), (3), (5) (40 ) instead (4).
(40 ) (r, n) -type, ]i-type (r, n) t, (r0 , n0 ) i,a (r, n),
(r0 , n0 ) = t.
Intuitively, object identifies individual, represented types, across
different state candidates. elements give definition quasimodel.
Definition 19 (Quasimodel). quasimodel tuple Q = hR, O, {i, }iAg,O ,
hR, O, {i, }iAg,O , frame,
1. Tr,n Tr,n Cr,n
2. Cr,n Cr,n+1
3. (r, n) i, (r0 , n0 ) (r, n) (r0 , n0 )
4. every Tr,n exists object (r, n) =
con object O.
5. every c con, function c c (r, n) = tc Tr,n

quasimodel+ defined quasimodel clauses (4) (5) refer objects+
rather objects. define quasimodels (resp. quasimodel+ ) satisfying perfect recall,
learning, synchronicity, unique initial state, assuming corresponding
condition underlying frame. difference objects (resp. quasimodel)
objects+ (resp. quasimodel+ ) purely technical. particular, latter needed
systems satisfying perfect recall learning become apparent Section 5.
following lemma list properties quasimodels useful
follows.
Lemma 4. every quasimodel Q, every object O,
(i) Ki (r, n) iff (r0 , n0 ), (r0 , n0 ) i, (r, n) implies (r0 , n0 ).
(ii) C (r, n) iff points (r0 , n0 ) reachable (r, n) (r0 , n0 ).
Proof.
(i) implication left right follows fact (r0 , n0 ) i, (r, n) implies
(r, n) (r0 , n0 ). implication right left, Ki
/ (r, n)
Lemma 3(ii) -type (r, n) t. Definition 18
(r0 , n0 ), (r, n) i, (r0 , n0 ) (r0 , n0 ) = t.
21

fiBelardinelli & Lomuscio

(ii) implication left right proved induction length path
(r, n) (r0 , n0 ). base case inductive step follow axiom C1.
implication right left follows Definition 18.
state main result section, is, satisfability quasimodels implies
satisfability mf-models. follows quasimodel Q validates formula belongs
every type every state-candidate Q.
Theorem 3. quasimodel (resp. quasimodel+ ) Q monodic formula ,
satisfiable mf-model Mmf . Moreover, Q validates formulas K BF ,
Mmf . Finally, Q satisfies perfect recall, learning, synchronicity,
unique initial state, Mmf .
Proof. proof inspired Lemmas 11.72 12.9 work Gabbay
et al. (2003), consider monodic friendly Kripke models rather standard
Kripke models. First, every monodic formula form Ki , C, 1 U2
introduce k-ary predicate constant Pk k equal 0 1, depending whether
0 1 free variables . formula Pk (x) called surrogate . Given
monodic formula denote formula obtained substituting modal
subformulas within scope another modal operator surrogates.
Since every state candidate C quasimodel Q consistent system
first-order temporal-epistemic logic considered Section 3 based classical first-order
logic, formula C consistent respect first-order (non-modal) logic. Godels
completeness theorem first-order structure = hI, Di, non-empty set
individuals first-order interpretation D, satisfies C , i.e., |= C
assignment variables elements D. intend build mf-model
joining first-order structures. However, possible structures
different domains different cardinalities. solve problem, consider cardinal
number 0 greater cardinality set objects Q define
= {h, | O, < }
Then, (r, n) Q, -type Tr,n
|{h, | (r, n) = t}| =
method described Claim 11.24 Gabbay et al. (2003), expand
first-order structure obtain structure Ir,n = hIr,n , Di domain Ir,n
satisfies Cr,n

|{a | (x) = Ir,n
|= t[x]}| =

So, assume without loss generality first-order structures Ir,n share
domain D, every Tr,n , h, D,

(r, n) = iff Ir,n
|= t[x]

(x) = h, i. Equivalently, Tr,n , (x) = h, D,

(r, n) = { cl | Ir,n
|= [x]}

22

(7)

fiInteractions Knowledge Time First-Order Logic MAS

Moreover, Ir,n (c) = hc , 0i every c con.
define mf-model Mmf tuple hW, R, {i,a }iAg,aD , D, Ii W
set points (r, n) r R Q n N; R set runs N W
r(n) = (r, n); defined above; Ag h, D, i,h,i defined i, ;
interpretation obtained joining various first-order interpretations Ir,n ,
i.e., I(P, r(n)) = Ir,n (P ) every predicate constant P . prove following
result Mmf .
Lemma 5. mf-model Mmf obtained quasimodel Q described above,
every subx ,

Ir,n
|= iff (Mmf , r, n) |=

Moreover, Q quasimodel+ , f(r, n) -state candidate ad(K ) ad()

Ir,n
|= iff (Mmf , r, n) |=

Proof. proof similar Lemma 12.10 work Gabbay et al. (2003).
begin first part. base case induction follows definition interpretation mf-model. step propositional connectives quantifiers follows
induction hypothesis equations 1 2 = 1 2 , 1 = 1 , x1 = x1 .
let = [x] assume (x) = h, i, have:

Ir,n
|= [x]

iff

[x] (r, n)

(8)

iff

[x] (r, n + 1)

(9)

iff


Ir,n+1
|= [x]

(Mmf , r, n + 1) |= [x]
(Mmf , r, n) |= [x]

iff
iff

(10)
(11)

Steps (8) (10) follow Equation (7). Step (9) motivated Lemma 3(i),
step (11) follows induction hypothesis.
Let = (U0 )[x] (x) = h, i, have:

Ir,n
|= (U0 )[x] iff

iff

(U0 )[x] (r, n)
0

(12)
0

0

n n [x] (r, n )
[x] (r, n00 ) n n00 < n0

iff

0

n n



Ir,n
00


Ir,n
0

|=

(13)

0 [x]

00

|= [x] n n < n0
0

iff

n n

iff

(Mmf , r, n00 ) |= [x]
(Mmf , r, n) |= U0 [x]

(Mmf , r, n0 )

(14)
0

|= [x]
00

n n < n0

(15)

Steps (12) (14) follow Equation (7). Step (13) motivated Def. 18, step
(15) follows induction hypothesis.
23

fiBelardinelli & Lomuscio

Let = Ki [x] (x) = h, i, have:

Ir,n
|= Ki [x]

iff
iff

Ki [x] (r, n)
0

0

0

0

(16)
0

0

(r , n ) i, (r, n), [x] (r , n )

(17)

(r , n ) i,h,i (r, n), Ir0 ,n0 |= [x]
(r0 , n0 ) i,h,i (r, n), (Mmf , r0 , n0 )

iff



iff



iff

(Mmf , r, n)

(18)
|= [x]

(19)

|= Ki [x]

Steps (16) (18) follow Equation (7). Step (17) motivated Lemma 4(i), step
(19) follows induction hypothesis.
Let = C[x] (x) = h, i, have:

Ir,n
|= C[x]

iff
iff
iff

C[x] (r, n)
0

0

0

0

0

0

(20)
0

0

(r , n ) reachable (r, n), [x] (r , n )
(r , n ) reachable

(r, n), Ir0 ,n0

(21)

|= [x]

(22)

0

(23)

0

iff

(r , n ) reachable (r, n), (M, r , n ) |= [x]

iff

(M, r, n) |= C[x]

Steps (20) (22) follow Equation (7). Step (21) motivated Lemma 4(ii),
step (23) follows induction hypothesis.
prove second part lemma. cases identical first part,
except = Ki . Suppose f(r, n) -state candidate ad(K ) ad().
implication left right, (r, n) i, (r0 , n0 ) (r0 , n0 ) 0 -type
]i = 0 ]i. Thus, ad(K0 ) ad(K]i ) ad(K Ki ) ad(). So, apply
induction hypothesis. implication right left, ad(K Ki ) ad()
|]i| ad() Lemma 3(ii) ]i-type (r, n)
t. Def. 18 (r0 , n0 ) (r, n) i, (r0 , n0 ) (r0 , n0 ) = t. Since
ad(K]i ) = ad(K Ki ) ad() apply induction hypothesis.
complete proof Theorem 3, definition quasimodel
Tr,n Tr,n Cr,n . Therefore, satisfied mf-model Mmf point (r, n).
remark Q validates formulas K BF , Mmf . case
as, K BF belong every type every state-candidate Q, Lemma 5
Mmf validates K BF well.
Finally, Q satisfies perfect recall, learning, synchronicity, unique
initial state, mf-model obtained Q satisfies corresponding constraints
construction. show fact perfect recall: (r, n) i,h,i (r0 , n0 ) n > 0,
particular (r, n) i, (r0 , n0 ). Since Q satisfies perfect recall, either (r, n 1) i, (r0 , n0 ),
k < n0 (r, n 1) i, (r0 , k) k 0 , k < k 0 n0 implies
(r, n) i, (r0 , k 0 ). definition i,h,i obtain either (r, n 1) i,h,i (r0 , n0 ),
k < n0 (r, n 1) i,h,i (r0 , k) k 0 , k < k 0 n0 implies
(r, n) i,h,i (r0 , k 0 ), is, Mmf satisfies perfect recall well.
next show existence quasimodels monodic .
24

fiInteractions Knowledge Time First-Order Logic MAS

5. Dealing System
section consider completeness proof system Theorem 2. particular, show monodic formula consistent respect system S,
build quasimodel (or quasimodel+ specific cases) based frame
S. following sections symbol ` represents provability appropriate system
S. start lemmas useful construction quasimodel
system.
Lemma 6. (i) consistent monodic formula consistent -state candidate C = hT, con .
(ii) Let P = hC, ti consistent -point C = hT, con i, let c con.
Then,
(a) C C0 exists -point P0 = hC0 , t0 P P0 .
(b) tc con C C0 exists -point P0 = hC0 , t0 P c P0 .
(c) 1 U2 sequence -points Pj = hCj , tj j k
realises 1 U2 , i.e., P = P0 . . . Pk , 2 tk 1 tj j < k.
(d) 1 U2 tc sequence -points Pj = hCj , tj j k
c-realises 1 U2 , i.e., sequence realises 1 U2 P0 c . . . c Pk .
(e) Ki -point P0 = hC0 , t0 P P0 t0 .
(f ) Ki tc -point P0 = hC0 , t0 P ci P0 t0 .
(g) C sequence -points Pj = hCj , tj j k
P = P0 i0 . . . ik1 Pk tk .
(h) C tc sequence -points Pj = hCj , tj j k
P = P0 ci0 . . . cik1 Pk tk .
Proof. proof similar one Claims 11.75, 11.76 12.13 work
Gabbay et al. (2003), consider -state candidates -points. Let
disjunction formulas P -points P . Consider formula ,
obtained substituting subformulas form Ki , C, 1 U2
within scope another modal operator surrogates. check
true (non-modal) first-order structures. Since QKTm QKTCm
extend first-order logic, semantical completeness first-order logic
`

(24)

W
(i) Notice that, previous remark, ` = {P|P -point } P .
Moreover, consistent (24) consistent. Therefore,
disjunct P P consistent. So, P = hC, ti.
(a) (24) Nec ` . So, P consistent must
-point P0 P P0 consistent.
(b) proof similar (a).
25

fiBelardinelli & Lomuscio

(c) proof contradiction. Let U set -points P0
W exist points Pj = hCj , tj j < k P = P0 . . . Pk = P0 . Let = {P0 |P0 U } P0 .
show
` 2
(25)
otherwise, would sequence realising 1 U2 . Moreover, definition
U,
`
(26)
(25) obtain
` G G2
together (25) (26) derive
` (2 G2 )

(27)

consider P1 U P P1 . (27)
`

P1 (2 G2 )

`

P1 G2

`

(P P1 ) G2

(28)

hand, since 1 U2
` (P P1 ) F 2

(29)

(28) (29) contradict fact P P1 .
(d) proof similar (c).
(e) First remark P Ki ( ) consistent. Thus, exists -point
P0 = hC0 , t0 P Ki (P0 ) consistent. Hence, P P0 t0 .
(f) proof similar (e).
(g) proof contradiction. Let V minimal set -points DWsuch (i)
P V ; (ii) V D0 Ag, D0 V . Let = {D|DV } .
show
`
(30)
(30) hold, would sequence specified lemma. Moreover,
definition V ,
` Ki
(31)
Ag. (30) (31) obtain
` ( E)
axiom C2,
` C
definition P,
` P C
contradicts (32).
26

(32)

fiInteractions Knowledge Time First-Order Logic MAS

(h) proof similar (g).
following result always possible extend -suitability relation
types -suitability points.
Lemma 7. Suppose t0 -types t0 , -points
P = hC, ti P0 = hC0 , t0 P P0 . particular, c con,
-points P = hC, ti P0 = hC0 , t0 P c P0 .
W
Proof. Lemma 6 ` ` = {P|P -point } P .
Since t0 , ( t0 ) consistent. Thus, must -points P
P0 P (P0 t0 ) consistent. Then, case P = hC, ti
P0 = hC0 , t0 -state candidates C C0 . result, P P0 . second part
lemma proved similarly first observing t0 t[x/c] t[x/c]
consistent. Hence, t[x/c] ( t0 [x/c]) consistent. Thus, must
-points P P0 P t[x/c] (P0 t0 [x/c]) consistent. So, tc con
t0c 0con , is, P c P0 .
According Lemma 7 always extend possibly infinite sequence -types t0
t1 . . . possibly infinite sequence -points P0 P1 . . . Pk = hCk , tk i.
Definition 20. Let -sequence possibly infinite sequence C0 C1 . . . -state
candidates. -sequence acceptable k 0,
(i) 1 U2 tk , tk Ck , 1 U2 realised sequence -points Pj =
hCj , tj k j n;
(ii) 1 U2 tck , tck Ck , 1 U2 c-realised sequence -points Pj =
hCj , tj k j n.
following lemma entails completeness result.
Lemma 8. Every finite -sequence -state candidates extended infinite
acceptable -sequence.
Proof. Assume C0 . . . Cn finite -sequence 1 U2 tk Ck
k n. Either 1 U2 realised C0 . . . Cn , Lemma 6(ii)(c) extend
-sequence 0 realises 1 U2 . procedure repeated formulas
form 1 U2 appearing point -sequence. Thus, obtain (possibly
infinite) -sequence C0 C1 . . . property (i) Definition 20 satisfied.
satisfy property (ii) reason similarly using Lemma 6(ii)(d) instead.
let X new object, sequence X, . . . , X, Cn , Cn+1 , . . . acceptable n
starts n copies X Cn , Cn+1 , . . . acceptable -sequence.
consider completeness proof single class QIS.
uis
sync,uis
5.1 Classes QIS , QIS sync
, QIS QIS

start completeness proof systems QKTm QKTCm ,
interaction temporal epistemic operators.
27

fiBelardinelli & Lomuscio

monodic formula consistent, Lemma 6(i) consistent -state
candidate C = hT, con type . Also, Lemma 8
extend C infinite acceptable -sequence. So, set infinite acceptable sequences non-empty. Let R set -sequences acceptable n,
n N. r R, k N, define partial function f R N f(r, k) = Ck r
-sequence X, . . . , X, Cn , Cn+1 , . . . acceptable n k n, undefined otherwise.
Finally, let set functions associating every (r, n) Dom(f) type
(r, n) Tr,n
(A) (r, n) (r, n + 1);
(B) U (r, n) iff n0 n (r, n0 ) (r, n00 )
n n00 < n0 ;
(C) (r, n) -types, (r0 , n), (r0 , n) = t;
(D) C (r, n) exists point (r0 , n) sequence -points Pj =
hCj , tj j k, hf(r, n), (r, n)i = P0 i0 . . . ik1 Pk , tk , f(r0 , n) =
Ck (r0 , n) = tk .
show non-empty. Condition (A) guaranteed Lemma 6(ii)(a),
condition (B) fact r acceptable -sequence. regards (C) remark
(r, n) find consistent -point P = hC, ti reasoning similarly
Lemma 6(i), Lemma 8, C extended -sequence r0 acceptable
n. Finally, set (r0 , n) = t. (D) observe C (r, n)
Lemma 6(ii)(g) exists sequence -points Pj = hCj , tj j k,
hf(r, n), (r, n)i = P0 i0 . . . ik1 Pk tk . Now, Ck extended sequence r0 acceptable n (r0 , n) = tk . Finally, Ag, O, define
(r, n) i, (r0 , n0 ) iff (r, n) (r0 , n0 ) n = n0 .
Lemma 9. tuple hR, O, {i, }iAg,O , synchronous frame.
Proof. previously shown R non-empty. Also, i,
equivalence relation definition, f satisfies conditions Definition 17. Further,
frame synchronous definition i, .
prove main result.
Lemma 10. tuple hR, O, {i, }iAg,O , synchronous quasimodel
validates formulas K BF .
Proof. previous lemma, remains prove functions objects.
Conditions (1), (3), (4) (5) objects safisfied remarks (A)-(D) above. Condition (2) satisfied definition i, . Furthermore, conditions (1), (2) (3)
quasimodels satisfied definitions R, f i, . regards (4), extend
function (r, n) = Dom(f) using Lemma 6(ii)(a), (c), (e) (g). (5)
function c c (r, n) = tc object Lemma 6(ii)(b), (d), (f) (h).
Finally, Q validates formulas K BF , C, C Q, consistent
QKTm (resp. QKTCm ).
28

fiInteractions Knowledge Time First-Order Logic MAS

completeness QKTm QKTCm respect classes QIS QIS sync

quantified interpreted systems directly follows Lemma 10 together Theorem 3.
Thus, obtain following item Theorem 2.
Theorem 4 (Completeness). system QKTm (resp. QKTCm ) complete w.r.t.
classes QIS QIS sync
QIS.

sync,uis
prove completeness QIS uis
use next result,
QIS
extension propositional case (Halpern et al., 2004).
1 ) satisfiable
Remark 2. Suppose X subset {pr, sync}. L1m (resp. LCm
X
X,uis
QIS satisfiable QIS .

Thus, system QKTm (resp. QKTCm ) complete w.r.t. classes QIS uis

sync,uis
QIS
QIS.
pr,uis
5.2 Classes QIS pr
QIS

begin investigate systems interactions time knowledge
pr,uis
present. completeness proof QKT1m respect QIS pr
relies
QIS
following lemma.
Lemma 11. -points P1 = hC1 , t1 i, P2 = hC2 , t2 ]i-type t02 , P1 P2
t2 t02 ]i-point P02 = hC02 , t02 -sequence S1 . . . Sn = P02
]i-points Sk = hDk , sk i, s1 t1 sk t2 1 < k n. Further,
k n.
P1 c P2 sck TDcon
k
Proof. extend proof Halpern et al. (2004, Lemma 5.5) deal state
candidates monodic friendly Kripke frames. cited result prove
t1 t2 t2 t02 sequence ]i-types s1 . . . sn = t02
s1 t1 sk t2 1 < k n. Lemma 7 extend sequence
]i-types sequence ]i-points S1 . . . Sn Sk = hDk , sk
lemmas statement satisfied. particular, P1 c P2 Lemma 7 assume
without loss generality sck TDcon
k n.
k
consistent L1m define quasimodel+ establish completeness
QKT1m respect QIS pr
. Let R set acceptable -sequences, define
f f(r, k) = Ck r -sequence C0 , C1 , . . . . Finally, let set
functions associating every (r, n) Dom(f) type (r, n) Tr,n conditions
(A) (B) satisfied
(C) (r, n) -type, ]i-type (r, n) t, (r0 , n0 ), (r0 , n0 ) = t.
(E) (r, n) (r0 , n0 ) n > 0 either (a) (r, n 1) (r0 , n0 ) (b)
k < n0 (r, n 1) (r0 , k) k 0 , k < k 0 n0 implies (r, n)
(r0 , k 0 ).
Finally, Ag, O, define (r, n) i, (r0 , n0 ) iff (r, n) (r0 , n0 ).
following lemma shows set non-empty. particular, conditions (C)
(E) satisfied functions O.
29

fiBelardinelli & Lomuscio

Lemma 12. set functions satisfies conditions (A), (B), (C) (E)
non-empty.
Proof. Conditions (A) (B) follow respectively Lemma 6(ii)(a) fact
r acceptable -sequence. regards (C) (E), proof proceeds induction
n. result n = 0 immediate, take r0 acceptable -sequence
starting C C. Further, define (r0 , 0) = t. Thus, (r0 , 0) (r, 0)
(C) (E) satisfied.
suppose n > 0 result holds n 1. Since f(r, n 1) f(r, n)
(r, n) t, follows Lemma 11 ]i-point P = hC, ti -sequence
]i-points P0 S0 . . . Sk = P Sk0 = hDk0 , sk0 sk0 (r, n) k 0 k.
induction hypothesis, exists every ]i-type (r, n1) point
(r0 , n0 ) (r0 , n0 ) = s. case (a), take = t; (r, n 1) (r0 , n0 )
(r0 , n0 ) = t. Thus, case (r, n) (r0 , n0 ). case (b), take = t0 .
Hence, (r, n 1) (r0 , n0 ) (r0 , n0 ) = t0 . suppose r0 derived
acceptable -sequence v0 , v1 , . . .. Let r00 run derived acceptable sequence
initial segment v0 , . . . , vn0 , D0 , . . . , Dk . Again, run exists Lemma 8.
define (r00 , n0 + k + 1) = sk = t. Thus, (r, n) (r00 , n0 + k + 1) (C)
(E) satisfied.
prove following lemma.
Lemma 13. tuple hR, O, {i, }iAg,O , frame satisfies perfect recall.
Proof. Lemmas 6(i), 8 12 sets R non-empty. Also, f satisfies
conditions Definition 17. Finally, i, equivalence relation definition,
satisfies perfect recall definition functions O.
Finally, prove main result section.
Lemma 14. tuple hR, O, {i, }iAg,O , quasimodel+ perfect recall
validates formulas K BF .
Proof. previous lemma hR, O, {i, }iAg,O , frame satisfying perfect
recall; left prove functions objects+ . Conditions (1)-(4)
objects+ safisfied remarks (A)-(E) definition i, . Furthermore, conditions
(1), (2) (3) quasimodels+ satisfied definitions R, f i, .
regards (4), follows Lemma 11. Finally, condition (5) quasimodels+ holds
Lemma 6(ii)(b), (d), (f) (h) Lemma 11. Finally, Q validates formulas K
BF , C, C Q, consistent QKTm .
completes proof QIS pr
. Thus, obtain following item Theorem 2.
Theorem 5 (Completeness). system QKT1m complete w.r.t. class QIS pr
QIS.
completeness QKT1m respect QIS pr,uis
follows Remark 2.

5.3 Classes QIS pr,sync
QIS pr,sync,uis


completeness QKT2m respect QIS pr,sync
proved similarly previous

case using following lemma instead Lemma 11.
30

fiInteractions Knowledge Time First-Order Logic MAS

Lemma 15. -state candidates C1 , C2 ]i-state candidate C02 , ]i-state
candidate C01
C1 C2 C2 C02 C1 C01 C01 C02 .
c con, P1 = hC1 , t1 i, P2 = hC2 , t2 P02 = hC02 , t02 i, P1 c P2
P2 ci P02 P01 = hC01 , t01 i, P1 ci P01 P01 c P02 .
Proof. C1 C2 C2 C02 exist t1 C1 , t2 C2 t02 C02
t1 t2 t2 t02 . Moreover, without loss generality assume
0con . Following proof Halpern et
c con, tc1 T1con , tc2 T2con t0c
2 T2
0
al. (2004, Lemma 5.8) find ]i-type t1 t1 t01 t01 t02 . Define T10
0
0
0con
set t01 T10con set t0c
1 . show C1 = hT1 , T1
0
0
0
consistent ]i-state candidate C1 C1 , C1 C2 , c con, P1 ci P01
P01 c P02 .
consistent L1m define quasimodel+ establish complete. Let R set -sequences acceptness QKT2m respect QIS pr,sync

able n, n N, define f f(r, k) = Ck r -sequence
X, . . . , X, Cn , Cn+1 , . . . acceptable n k n, undefined otherwise. Finally, let
set functions associating every (r, n) Dom(f) type (r, n) Tr,n
conditions (A) (B) Section 5.1 satisfied
(C) (r, n) -type, ]i-type (r, n) t, (r0 , n), (r0 , n) = t.
(F) (r, n) (r0 , n) n > 0 (r, n 1) (r0 , n 1).
Finally, Ag, O, define (r, n) i, (r0 , n0 ) iff (r, n) (r0 , n0 ) n = n0 .
following remark shows set non-empty. particular, conditions (C)
(F) satisfied functions O.
Lemma 16. set functions satisfies condition (A), (B), (C) (F)
non-empty.
Proof. Conditions (A) (B) follow Lemma 6(ii)(a) fact r
acceptable -sequence. regards (C) (F), assume (r, n) f(r, n) -type,
]i-type (r, n) t. f(r, n) different (r, n) consider set
U = { | Ki s}. check U consistent extended ]i-type s0
s0 . define 0 collection s0 . Further, sc con ,
set s0c 0con . Let C0 = hT 0 , 0con i. Clearly, C C0 hC, si ci hC0 , s0 i. Lemma 15
construct -sequence C0 . . . Cn Cn = C0 f(r, k) Ck
k n. Lemma 8 extend -sequence infinite acceptable -sequence
r0 . particular, function extended k n, (r, k) (r0 , k)
(r0 , n) = t. Thus, (C) (F) satisfied.
show following lemma.
Lemma 17. tuple hR, O, {i, }iAg,O , frame satisfies perfect recall
synchronicity.
31

fiBelardinelli & Lomuscio

Proof. Lemmas 6(i), 8 16 sets R non-empty. Also, f satisfies
conditions Definition 17. Finally, i, equivalence relation definition,
satisfies perfect recall synchronicity definition functions O.
prove main result.
Lemma 18. tuple hR, O, {i, }iAg,O , quasimodel+ perfect recall
synchronicity, validates formulas K BF .
Proof. previous lemma hR, O, {i, }iAg,O , frame satisfying perfect
recall synchronicity; left prove functions objects+ .
Conditions (1)-(4) objects+ safisfied remarks (A)-(F) definition
i, . Furthermore, conditions (1), (2) (3) quasimodels+ satisfied
definitions R, f i, . regards condition (4), make use Lemma 15
show holds. Additionally, (5) holds Lemma 6(ii)(b), (d), (f) (h) Lemma
15. Finally, Q validates formulas K BF , C, C Q,
consistent QKTm .
completes proof QKT2m . Thus, obtain following item Theorem 2.
Theorem 6 (Completeness). system QKT2m complete w.r.t. class QIS pr,sync


QIS.
follows Remark 2.
completeness QKT2m respect QIS pr,sync,uis

5.4 Class QIS nl

First, give following definitions, used completeness proof.
Definition 21. -type, t,i conjunction -types t0 t0 .
Similarly, P -point, P,i set -points P0 P P0 .
Definition 22. Two sequences types 0 -concordant n N
(or n may ) non-empty consecutive intervals 1 , . . . , n 01 , . . . , 0n 0
j s0 0j s0 j n.
Two sequences 0 state candidates -concordant C, either
C C 0 , two sequences 0 types 0 respectively
-concordant.
prove completeness QKT3m respect QIS nl
need following lemma,
dual Lemma 11.
Lemma 19. -points P1 = hC1 , t1 i, P2 = hC2 , t2 ]i-type t01 , P1 P2
t1 t01 exists ]i-point P01 = hC01 , t01 -sequence P01 = S1 . . . Sn
]i-points Sk = hDk , sk i, sk t1 k < n, t2 sn . Further, P1 c P2
sck TDcon
k n.
k
Proof. adapting result Halpern et al. (2004, Lemma 5.11) types
prove t1 t2 t1 t01 sequence ]i-types t01 = s0 . . . sn
sk t1 k < n sn t2 . Lemma 7 extend sequence
]i-types sequence ]i-points S1 . . . Sn Sk = hDk , sk i. So,
32

fiInteractions Knowledge Time First-Order Logic MAS

statement lemma satisfied. particular, P1 c P2 Lemma 7
assume without loss generality sck TDcon
k n.
k
pointed Halpern et al. (2004), Lemma 19 sufficient construct
quasimodel+ satisfies learning. fact, given -sequence = C0 , C1 , . . . state candidates ]i-type t00 t0 t00 t0 C0 , Lemma 19 find
-sequence 0 = C00 , C01 , . . . t00 C00 learning satisfied. However,
follow acceptability 0 acceptable. So, propositional
case, work trees state candidates. Hereafter extend definitions
given Halpern et al. (2004) able deal points monodic friendly Kripke
models.
Definition 23. Let k ad(). k-tree state candidates set -state
candidates || k contains unique -state candidate, i.e., root,
every -point C ,
t0 ]i-type t0 |]i| k ]i-state candidate
C0 t0 C0 ;
= 0 ]i 0 -state candidate C0 0 -type t0 C0
t0 .
Similarly, define k-tree points set -points || k
contains unique -point, every -point P = hC, ti ,
t0 ]i-type t0 |]i| k, ]i-point P0 =
hC0 , t0 ;
= 0 ]i 0 -point P0 = hC0 , t0 t0 .
Intuitively, k-tree view epistemic state quasimodel particular
type t, k steps t. extend -suitability relation k-trees.
Definition 24. Let 0 k-trees state candidates . say f 0
whenever f function associating -state candidate C -type C
finite -sequences -state candidates 0 -types that:
1. f (C) = C0 . . . Ck (a) C = C0 (b) Cj j < k Ck 0 .
Similarly, f (t) = t0 . . . tk (a) = t0 (b) tj Cj j < k
k Ck .
2. Let C t0 C0 C, C0 . t0 f (t) f (t0 ) concordant;
3. least one C sequence f (C) length least 2.
Further, let 0 k-trees points . say f 0 whenever f
function associating -point P finite -sequence -points 0
that:
1. f (P) = P0 . . . Pk (a) P = P0 (b) Pj j < k Pk 0 ;
33

fiBelardinelli & Lomuscio

2. Let P = hC, ti P0 = hC0 , t0 . t0 f (t) f (t0 ) -concordant;
3. least one P sequence f (P) length least 2.
Finally, constant c con, say cf 0 whenever f 0 f (P) =
P0 c . . . c Pk .
Notice given k-tree state candidates root C C, obtain
k-tree points P0 = hC0 , t0 iff C0 . Also, , 0 k-tree state
candidates f 0 , f 0 0 k-trees points
based 0 respectively.
show obtain acceptable sequences state candidates sequences
trees. Given two sequences -state candidates = C0 , . . . , Ck = C00 , . . .,
finite, fusion defined C0 , . . . , Ck1 , C00 , . . . Ck = C00 . Further,
given infinite sequence = 0 f0 1 f1 . . . k-trees, say sequence
-state candidates compatible exists h N -state candidates
Ch , Ch+1 , . . ., Cj j j h, = fh (Ch ) fh+1 (Ch+1 ) . . .. sequence
acceptable every -sequence compatible infinite acceptable.
basic idea completeness proof define quasimodel+ starting
acceptable sequence . Next introduce definitions lemmas essential
completeness proof.
Given k-tree -point P inductively define formula tree,P
describes k-tree viewpoint P.
Definition 25. P -point, tree,P ::= P . P 0 ]i-point 0 6= 0 ]i

^
tree,P = P
Ki tree,P0
{0 point P0 |t0 t}

0 k-trees, P P0 0 , write (, P) + (0 , P0 )
sequence k-trees 0 , . . . , l functions f0 , . . . , fl1 (a) = 0 f0 . . . fl1
l = 0 ; (b) fj (P) = P j l 2 fl1 (P) = (P, P0 ). Similarly, (, P) c+ (0 , P0 )
(, P) + (0 , P0 ) (a) = 0 cf0 . . . cfl1 l = 0 .
prove following lemma, extends result Halpern et al. (2004, Lemma 5.12)
points.
Lemma 20. Suppose k-tree points P = hC, ti -point || = k,
(a) t0 -type tree,P (t0 ) consistent, k-tree 0
-point P0 = hC0 , t0 0 (, P) + (0 , P0 ) tree0 ,P0 consistent.
Further, tc con (, P) c+ (0 , P0 ).
W
(b) ` tree,P {(0 ,P0 )|(,P)+ (0 ,P0 )} tree0 ,P0
(c) tree,P U 0 consistent, sequence 0 , . . . , l k-trees
points P0 , . . . , Pl (i) Pj j j l; (ii) (0 , P0 ) = (, P); (iii)
(j , Pj ) + (j+1 , Pj+1 ) j < l; (iv) treej ,Pj consistent j < l; (v)
treel ,Pl 0 consistent. Further, tc con (iii) (j , Pj ) c+ (j+1 , Pj+1 )
j < l.
34

fiInteractions Knowledge Time First-Order Logic MAS

Proof. proceed induction k. case k = 0 immediate using standard
arguments tree,P P .
Assume k > 0 = 0 ]i 6= 0 . first prove part (a) = Ki 0 ,
part (b), general case (a), finally (c).
regards part (a) = Ki 0 , note tree,P (t0 Ki 0 ) implies
tree,P Ki P,i UKi ( 0 t0 ,i )
definition k-tree 0 -point P . Let
(k 1)-tree consisting -points | | k 1. axiom KT3
tree ,P Ki P,i UKi ( 0 t0 ,i ) consistent, part (c) sequence 0 , . . . , l
(k 1)-trees points P0 , . . . , Pl (i) Pj j j l; (ii) (0 , P0 ) =
( , P ); (iii) (j , Pj ) + (j+1 , Pj+1 ) j < l; (iv) treej ,Pj Ki P,i consistent
j < l; (v) treel ,Pl Ki ( 0 t0 ,i ) consistent.
Again, definition relation + sequence (k 1)-trees 0 , . . . ,
functions f0 , . . . , fm1 (a) = 0 = 0 f0 . . . fm1 = l . Moreover,
(k 1)-points u0 , . . . , um u0 = P , um = Pl , j < m, uj = Pj 0
j 0 j, uj = uj+1 fj (uj ) = uj , uj 6= uj+1 fj (uj ) = (uj , uj+1 ).
show define k-tree 0j extending j j < m. (iv)
uj Ki P,i consistent j < m, uj P. P 0j . Similarly,
um Ki t0 ,i consistent; exists P0 = hC0 , t0 P0 0m . Further,
saturate 0j conditions k-trees satisfied particular 00 = .
show construct fj0 j < m. point S0 = hD0 , s0 0j \ j must
exist point = hD, si j agent j 0 Ag j 0 s0 . Lemma 19
follows exists sequence S0 starting S0 j 0 -concordant fj (S).
Moreover, take Pj = (P) j < 1, Pm1 = (P, P0 ). define fj0
agrees fj j , S0 0j \ j fj0 (S0 ) = S0 .
Notice 00 = construction. > 0 follows immediately definition
(, P) + (m , P0 ) treem ,P0 Ki 0 consistent. = 0 easily
check P0 t0 . Since t, follows t0 .
define f f (u) = u every u 6= P f (P) = (P, P0 ). (, P) f (, P0 ).
Since P P0 (, P) + (, P0 ).
second part (a) follows similar line reasoning.
prove part (b), contradiction assume
_
0 tree,P
tree0 ,P0
{(0 ,P0 )|(,P)+ (0 ,P0 )}

V
tree,P {(0 ,P0 )|(,P)+ (0 ,P0 )} tree0 ,P0 consistent. temporal reasoning
must point u
^
tree,P (u
tree0 ,P0 )
(33)
{(0 ,P0 )|(,P)+ (0 ,P0 )}

W
consistent. Note tree0 ,P0 equivalent P0 {0 point P 0 |t t0 } Ki tree0 ,P .
Thus, consistency (33) implies tree 0 (, P) + (0 , u)
35

fiBelardinelli & Lomuscio

exists 0 -point P0 = hC0 , t0 t0 tu
^
tree,P (u Ki (

tree0 ,P0 ))

(34)

{0 |(,P)+ (0 ,P0 )}



+


consistent. part (a)
Vthere exists k tree P (, P) ( , P )
tree ,P u Ki ( {0 |(,P)+ (0 ,P 0 )} tree0 ,P0 ) consistent. means

P = u. Thus contradiction, since tree ,u Ki tree ,P inconsistent.
general case (a) follows (b). Part (c) follows (b).
following lemma correspondent Lemma 8 k-trees.

Lemma 21. L1m consistent QKT3m , exists acceptable sequence
ad()-trees state candidates belongs root first tree.
Proof. Lemma 8 key part proof consists showing that, given finite
sequence 0 f0 . . . fl1 l d-trees points -point P = hC, ti l
U 0 (resp. t), Lemmas 19 20 extend sequence trees
satisfy acceptability. Specifically, suppose U 0 t. Let include P 0 -points
P0 = hC0 , t0 l |0 | k = ||. Note k-tree. Further, Lemma 20
find sequence 0 , . . . , n k-trees points P0 , . . . , Pn (i) Pj j
j n; (ii) (0 , P0 ) = (, P); (iii) (j , Pj ) + (j+1 , Pj+1 ) j < l; (iv) treej ,Pj
consistent j < l; (v) treen ,Pl 0 consistent. using Lemma 19
extend sequence ad()-trees starting l satisfies U 0 proof
Lemma 20(a). argument similar. Since consistent, must
tree root C C; extend
complete proof.
consistent L1m define quasimodel+ establish completeness
QKT3m respect QIS nl
. Let R consist acceptable -sequences compatible
ad()-tree , function f given f(r, k) = Ck r acceptable
-sequence C0 , C1 , . . .. Further, let set functions associating every (r, n)
Dom(f) type (r, n) Tr,n conditions (A), (B) (C) given previously
satisfied following holds:
(G) (r, n) (r0 , n0 ) either (r, n + 1) (r0 , n0 ) exists k > n0
(r, n + 1) (r0 , k) k 0 , k > k 0 n0 implies (r, n) (r0 , k 0 ).
Finally, Ag, O, (r, n) i, (r0 , n0 ) iff (r, n) (r0 , n0 ).
previous cases following.
Lemma 22. set functions satisfies conditions (A), (B), (C) (G)
non-empty.
Proof. Conditions (A) (B) guaranteed Lemma 6(ii) fact r
acceptable -sequence respectively. regards (C) (G), assume (r, n)
-type, ]i-type (r, n) t. using proofs Lemmas 20 19
find acceptable -sequence r0 compatible d-tree f(r0 , 0)
(G) satisfied.
show following lemma.
36

fiInteractions Knowledge Time First-Order Logic MAS

Lemma 23. tuple hR, O, {i, }iAg,O , frame satisfies learning.
Proof. Lemmas 6(i), 21 22 sets R non-empty. Also, f satisfies
conditions Definition 17. Further, i, equivalence relation definition.
Finally, learning condition satisfied definition functions O.
Lemma 24. tuple hR, O, {i, }iAg,O , quasimodel+ satisfies
learning validates formulas K BF .
Proof. previous lemma hR, O, {i, }iAg,O , frame satisfying learning;
left prove functions objects+ . Conditions (1)-(4) objects+
safisfied remarks (A)-(G) definition i, . Furthermore, conditions (1), (2)
(3) quasimodels+ satisfied definitions R, f i, . regards (4)
use Lemma 19 show holds. Finally, (5) holds Lemma 6(ii)(b), (d), (f)
(h) Lemma 19. Finally, Q validates K BF , C, C Q,
consistent QKTm .
completes proof QKT3m . Thus, obtain following item Theorem 2.
Theorem 7 (Completeness). system QKT3m complete w.r.t. class QIS nl
QIS.
5.5 Class QIS nl,sync

show QKT4m complete axiomatisation QIS nl,sync
, analogously Lemma 15,

need following.
Lemma 25. -state candidate C1 , C2 ]i-state candidate C01 exists ]i-state
candidate C02
C1 C2 C1 C01 C01 C02 C2 C02 .
c con, P1 = hC1 , t1 i, P2 = hC2 , t2 P01 = hC01 , t01 i, P1 c P2
P1 ci P01 P01 c P02 P2 ci P02 .
Proof. proof similar Lemma 15. C1 C2 C1 C01 exist
t1 C1 , t2 C2 t01 C01 t1 t2 t1 t01 . Moreover, without loss
0con .
generality, assume c con, tc1 T1con , tc2 T2con t0c
1 T1
adapting proof Halpern et al. (2004, Lemma 5.18) find ]i-type t02
t2 t02 t01 t02 . define T20 set t02 T10con set t0c
2.
Clearly, C02 = hT20 , T20con consistent ]i-state candidate C2 C02 , C01 C02 ,
c con, P2 ci P02 P01 c P02 .
systems including axiom KT4m define synchronous version relation
k-trees.
Definition 26. 0 k-trees state candidates sync
0 iff
f
0
f C , f (C) exactly length 2. Similarly, 0
k-trees points sync
0 iff f 0 P , f (P) exactly
f
length 2.
37

fiBelardinelli & Lomuscio

c con, relation cf sync defined similarly. define sync-acceptable
sequence trees acceptable sequence relation substituted
relation sync , is, sequence acceptable every sync -sequence compatible
infinite acceptable. Similarly, given relations + c+ c con,
definitions sync,+ c sync,+ straightforward. state following result,
simplified version Lemma 20. proof analogous Lemma 20,
Lemma 25 used instead Lemma 19.
Lemma 26. Let k-tree points P -point || = k,
(a) t0 -type tree,P (t0 ) consistent, exists k-tree 0
-point P0 = hC0 , t0 0 (, P) sync,+ (0 , P0 ) tree0 ,P0
consistent. Further, tc con (, P) c sync,+ (0 , P0 ).
W
(b) ` tree,P {(0 ,P0 )|(,P)sync,+ (0 ,P0 )} tree0 ,P0
(c) tree,P U 0 consistent, exists sequence 0 , . . . , l k-trees
points P0 , . . . , Pl (i) Pj j j l; (ii) (0 , P0 ) = (, P); (iii)
(j , Pj ) sync,+ (j+1 , Pj+1 ) j < l; (iv) treej ,Pj consistent j < l;
(v) treel ,Pl 0 consistent. Further, tc con (iii) (j , Pj ) c sync,+
(j+1 , Pj+1 ) j < l.
Further, make use Lemma 26 adapt Lemma 21 obtain following result.
Lemma 27. L1m consistent QKT4m , exists sync-acceptable
sequence ad()-trees state candidates belongs root first tree.
consistent L1m define quasimodel+ establish completeness QKT4m respect QIS nl,sync
. Let X new object, sequence

X, . . . , X, Cn , Cn+1 , . . . sync-acceptable n starts n copies X Cn , Cn+1 , . . .
sync-acceptable -sequence compatible ad()-tree . Let R consist sequences sync-acceptable n, n N. function f defined f(r, k) = Ck
r -sequence X, . . . , X, Cn , Cn+1 , . . . sync-acceptable n k n; f(r, k) undefined otherwise. Further, Let set functions associating every (r, n) Dom(f)
type (r, n) Tr,n conditions (A), (B) (C) satisfied following
holds:
(H) (r, n) (r0 , n0 ) (r, n + 1) (r0 , n0 + 1).
Finally, Ag, O, (r, n) i, (r0 , n0 ) iff (r, n) (r0 , n0 ) n = n0 .
Similarly Lemma 22, show following.
Lemma 28. set functions satisfies conditions (A), (B), (C) (H)
non-empty.
Moreover, following result follows Lemmas 6(i), 27 28.
Lemma 29. tuple hR, O, {i, }iAg,O , frame satisfies learning
synchronicity.
38

fiInteractions Knowledge Time First-Order Logic MAS

Finally, adapting proof Lemma 24 state following result.
Lemma 30. tuple hR, O, {i, }iAg,O , quasimodel+ learning
synchronicity, validates formulas K BF .
completes proof QKT4m . Thus, obtain following item Theorem 2.
Theorem 8 (Completeness). system QKT4m complete w.r.t. class QIS nl,sync


QIS.
5.6 Classes QIS nl,pr
QIS nl,pr,uis

1
obtain completeness proof QIS nl,pr
combine results shown QIS pr


nl
QIS .
2,3
L1m consistent QKTm
Lemma 21 exists acceptable
sequence ad()-trees belongs root first tree. Let R
set acceptable -sequences suffix compatible ,
function f defined Section 5.2. Further, set functions associating
every (r, n) Dom(f) type (r, n) Tr,n satisfies conditions (A), (B), (C),
(E) (G). Finally, Ag, O, (r, n) i, (r0 , n0 ) iff (r, n) (r0 , n0 ).
Lemma 31. set functions satisfies conditions (A), (B), (C), (E) (G)
non-empty.
Proof. show conditions (C) satisfied similarly cases
nl
QIS pr
QIS . (C), suppose (r, n) -type f(r, n) ]i-type.
Also, sequence ad()-trees 0 f0 1 f1 . . . state candidates. run r
derived definition -sequence C0 , C1 , . . . suffix CN , CN +1 , . . .
compatible , f(r, n) = Cn . consider two cases.
n N , exists k N Cn k . Lemma 11 exists
-sequence S0 . . . Sh ]i-state candidates Sh S0 , . . . , Sh
-concordant C0 , . . . , Cn . Further, assume Sh k let Sh , Sh+1 , . . .
sequence compatible . consider -sequence S0 S1 . . ..
construction run r0 derived sequence R assume
(r0 , h) = t.
n < N , Lemma 11 exists -sequence S0 . . . Sh ]i-state
candidates Sh S0 , . . . , Sh -concordant C0 , . . . , Cn . Lemma 19
extend sequence -sequence S0 . . . Sk -concordant
C0 , . . . , CN . Since CN N, assume Sk
well. Let Sh , Sh+1 , . . . sequence compatible , consider -sequence
S0 S1 . . .. previous case, run r0 derived sequence R
construction assume (r0 , h) = t.
Lemmas 6(i), 21 31 obtain next result.
Lemma 32. tuple hR, O, {i, }iAg,O , frame satisfies perfect recall
learning.
Finally, state following lemma, whose proof follows lines corresponding
nl
proofs QIS pr
QIS Lemma 31.
39

fiBelardinelli & Lomuscio

Lemma 33. tuple hR, O, {i, }iAg,O , quasimodel+ satisfies perfect
recall learning, validates formulas K BF .
establishes completeness QKT2,3 . Thus, obtain following item
Theorem 2.
nl,pr
Theorem 9 (Completeness). system QKT2,3

complete w.r.t. class QIS
QIS.

completeness QKT2,3
respect QIS nl,pr,uis
follows following
1
1
remark, whose proof analogous propositional case.
Remark 3. formula L11 satisfiable QIS nl,pr
(resp. QIS nl,pr,sync
) iff
1
1
nl,pr,uis
nl,pr,sync,uis
satisfiable QIS 1
(resp. QIS 1
).
5.7 Class QIS nl,pr,sync

1,4
prove completeness QKTm
respect QIS nl,pr,sync
combine results

nl,pr
obtained QIS previous section QIS nl,sync
QIS pr,sync
.


1,4
1
Specifically, Lm consistent QKTm Lemma 27 construct syncacceptable sequence ad()-trees belongs root first tree. Let R
set sync-acceptable -sequences suffixes compatible ;
function f defined Section 5.2. Further, set functions associating
every (r, n) Dom(f) type (r, n) Tr,n satisfies conditions (A), (B), (C),
(F) (H). Finally, Ag, O, (r, n) i, (r0 , n0 ) iff (r, n) (r0 , n0 ) n = n0 .
adapting proof Lemma 31 means Lemmas 15 25 show
following result.

Lemma 34. set functions satisfies conditions (A), (B), (C), (F) (H)
non-empty.
Lemmas 6(i), 27 34 obtain following result.
Lemma 35. tuple hR, O, {i, }iAg,O , frame satisfies perfect recall,
learning synchronicity.
Finally, state following lemma whose proof follows lines corresponding
proofs QIS pr,sync
, QIS nl,sync
Lemma 34.


Lemma 36. tuple hR, O, {i, }iAg,O , quasimodel+ satisfies perfect
recall, learning synchronicity, validates formulas K BF .
completes proof QKT1,4
. Thus, obtain following item Theorem 2.
1,4
Theorem 10 (Completeness). system QKTm
complete w.r.t. class QIS nl,pr,sync

QIS.

40

fiInteractions Knowledge Time First-Order Logic MAS

5.8 Classes QIS nl,sync,uis
QIS nl,pr,sync,uis


1,4,5
show system QKTm
complete respect classes QIS nl,sync,uis

nl,pr,sync,uis
QIS
. completeness result follows next remark.

Remark 4. formula Lm valid QIS nl,sync,uis
iff valid QIS nl,pr,sync,uis
.


proof straightforward extension first-order result Halpern et al. (2004,
Proposition 5.22). Given remark axiom KT5 sufficient prove
completeness QKT1,4
respect QIS nl,pr,sync,uis
. result previous
1
1
1,4
nl,pr,sync
section, QKT1 indeed complete respect QIS 1
. desired result follows
Remark 3. Thus, obtain following item Theorem 2.
1,4
Theorem 11 (Completeness). system QKTm
complete w.r.t. classes QIS nl,sync,uis

QIS nl,pr,sync,uis

QIS.


6. Conclusions Work
paper investigated interaction axioms context monodic first-order
temporal-epistemic logic. Specifically, explored classes quantified interpreted systems
satisfying conditions synchronicity, learning, perfect recall, unique
initial state. contribution article concerns provably complete axiomatisation
classes.
results presented extend previous contributions first-order epistemic temporal logic interactions (e.g., see Belardinelli & Lomuscio, 2011, Sturm et al., 2000,
Wolter & Zakharyaschev, 2002), direction previously explored
propositional level (Halpern et al., 2004). findings show characterisation
axioms considered propositional level extended first-order monodic
setting.
temporal-epistemic logic first-order context far mostly attracted theoretical contributions, evidence literature increasingly embraced
applications. instance, active interest verifying artifact-centric systems
first-order modal specifications (Belardinelli, Lomuscio, & Patrizi, 2011a, 2011b;
Deutsch, Hull, Patrizi, & Vianu, 2009; Deutsch, Sui, & Vianu, 2007; Calvanese, Giacomo,
Lenzerini, & Rosati, 2012; Hariri, Calvanese, Giacomo, Masellis, & Felli, 2011).
Given this, remains importance investigate questions pertaining computational aspects formalisms introduced, including decidability computational complexity satisfiability model checking problems. Work far (including
Belardinelli & Lomuscio, 2011; Hodkinson al., 2000; Wolter & Zakharyaschev 2001)
focused fragments interaction present, know literature (Halpern et al., 2004) interactions make problems harder. leave
work, particularly connection addition epistemic modalities
(e.g., explicit algorithmic knowledge, see Halpern & Pucella, 2005), branching-time
modalities. Epistemic variants branching-time CTL well understood propositional level (Meyden & Wong, 2003) first-order extensions yet
explored.
41

fiBelardinelli & Lomuscio

Acknowledgments
research presented supported European Commission Marie
Curie Fellowship FoMMAS (grant n. 235329) STREP Project ACSI (grant
n. 257593), UK Engineering Physical Sciences Research Council Leadership
Fellowship Trusted Autonomous Systems (grant n. EP/I00520X/1).
would thank anonymous reviewers Mr. Andrew V. Jones valuable
comments paper.

References
Belardinelli, F., & Lomuscio, A. (2009). Quantified epistemic logics reasoning
knowledge multi-agent systems. Artificial Intelligence, 173 (9-10), 9821013.
Belardinelli, F., & Lomuscio, A. (2011). First-order linear-time epistemic logic group
knowledge: axiomatisation monodic fragment. Fundamenta Informaticae,
106 (2-4), 17590.
Belardinelli, F., & Lomuscio, A. (2008). complete quantified epistemic logic reasoning
message passing systems. Computational Logic Multi-Agent Systems, 8th
International Workshop, CLIMA VIII. Revised Selected Invited Papers, Vol. 5056
Lecture Notes Computer Science, pp. 248267. Springer.
Belardinelli, F., & Lomuscio, A. (2010). Interactions time knowledge firstorder logic multi-agent systems. Principles Knowledge Representation
Reasoning: Proceedings 12th International Conference, KR 2010. AAAI Press.
Belardinelli, F., Lomuscio, A., & Patrizi, F. (2011a). computationally-grounded semantics artifact-centric systems abstraction results. Proceedings 22nd
International Joint Conference Artificial Intelligence, IJCAI 2011, pp. 738743.
AAAI Press.
Belardinelli, F., Lomuscio, A., & Patrizi, F. (2011b). Verification deployed artifact systems via data abstraction. Service-Oriented Computing: Proceedings 9th
International Conference, ICSOC 2011, Vol. 7084 Lecture Notes Computer Science, pp. 142156. Springer.
Calvanese, D., Giacomo, G. D., Lenzerini, M., & Rosati, R. (2012). View-based query
answering description logics: Semantics complexity. Journal Computer
System Sciences, 78 (1), 2646.
Cohen, P., & Levesque, H. (1995). Communicative actions artificial agents. Proceedings 1st International Conference Multi-Agent Systems, ICMAS 1995, pp.
6572. AAAI Press.
Degtyarev, A., Fisher, M., & Konev, B. (2003). Monodic temporal resolution. Automated
Deduction: Proceedings 19th International Conference Automated Deduction,
CADE-19, Vol. 2741 Lecture Notes Computer Science, pp. 397411. Springer.
Degtyarev, A., Fisher, M., & Lisitsa, A. (2002). Equality monodic first-order temporal
logic. Studia Logica, 72 (2), 147156.
Dennett, D. (1987). Intentional Stance. MIT Press.
42

fiInteractions Knowledge Time First-Order Logic MAS

Deutsch, A., Hull, R., Patrizi, F., & Vianu, V. (2009). Automatic verification datacentric business processes. Database Theory: Proceedings 12th International
Conference, ICDT 2009, Vol. 361 ACM International Conference Proceeding Series,
pp. 252267. ACM Press.
Deutsch, A., Sui, L., & Vianu, V. (2007). Specification verification data-driven web
applications. Journal Computer System Sciences, 73 (3), 442474.
Fagin, R., Halpern, J. Y., Moses, Y., & Vardi, M. Y. (1995). Reasoning Knowledge.
MIT Press.
Fagin, R., Halpern, J. Y., & Vardi, M. Y. (1992). machines know?
properties knowledge distributed systems. Journal ACM, 39 (2), 328376.
Gabbay, D., Kurucz, A., Wolter, F., & Zakharyaschev, M. (2003). Many-Dimensional Modal
Logics: Theory Applications, Vol. 148 Studies Logic. Elsevier.
Garson, J. (2001). Quantification modal logic. Gabbay, D., & Guenthner, F. (Eds.),
Handbook Philosophical Logic, Vol. 3, pp. 267323. Reidel.
Halpern, J., & Moses, Y. (1992). guide completeness complexity modal logics
knowledge belief. Artificial Intelligence, 54, 319379.
Halpern, J., van der Meyden, R., & Vardi, M. (2004). Complete axiomatizations reasoning knowledge time. SIAM Journal Computing, 33 (3), 674703.
Halpern, J., & Vardi, M. (1986). complexity reasoning knowledge time.
ACM Symposium Theory Computing, STOC 1986, pp. 304315. ACM Press.
Halpern, J., & Vardi, M. (1989). complexity reasoning knowledge time
1: lower bounds. Journal Computer System Sciences, 38 (1), 195237.
Halpern, J., & Pucella, R. (2005). Probabilistic algorithmic knowledge. Logical Methods
Computer Science, 1 (3).
Hariri, B. B., Calvanese, D., Giacomo, G. D., Masellis, R. D., & Felli, P. (2011). Foundations
relational artifacts verification. Business Process Management: Proceedings
9th International Conference, BPM 2011, Vol. 6896 Lecture Notes Computer
Science, pp. 379395. Springer.
Hodkinson, I. (2002). Monodic packed fragment equality decidable. Studia Logica,
72, 185197.
Hodkinson, I. (2006). Complexity monodic guarded fragments linear real time.
Annals Pure Applied Logic, 138, 94125.
Hodkinson, I., Kontchakov, R., Kurucz, A., Wolter, F., & Zakharyaschev, M. (2003).
computational complexity decidable fragments first-order linear temporal logics.
Proceedings 10th International Symposium Temporal Representation
Reasoning / 4th International Conference Temporal Logic, TIME-ICTL 2003, pp.
9198. IEEE Computer Society Press.
Hodkinson, I., Wolter, F., & Zakharyaschev, M. (2000). Decidable fragment first-order
temporal logics. Annals Pure Applied Logic, 106 (1-3), 85134.
43

fiBelardinelli & Lomuscio

Hodkinson, I., Wolter, F., & Zakharyaschev, M. (2002). Decidable undecidable fragments first-order branching temporal logics. Proceedings 17th IEEE Symposium Logic Computer Science, LICS 2002, pp. 393402. IEEE Computer
Society Press.
Lomuscio, A., & Ryan, M. (1998). relation interpreted systems Kripke
models. Agent Multi-Agent Systems: Proceedings AI97 Workshop
theoretical practical foundations intelligent agents agent-oriented systems,
Vol. 1441 Lecture Notes Artificial Intelligence, pp. 4659. Springer.
McCarthy, J. (1979). Ascribing mental qualities machines. Ringle, M. (Ed.), Philosophical Perspectives Artificial Intelligence, pp. 161195. Harvester Press.
McCarthy, J. (1990). Artificial intelligence, logic formalizing common sense. Thomason, R. (Ed.), Philosophical Logic Artificial Intelligence, pp. 161190. Kluwer
Academic.
Meyden, R. (1994). Axioms knowledge time distributed systems perfect
recall. Proceedings 9th Annual IEEE Symposium Logic Computer
Science, LICS 1994, pp. 448457. IEEE Computer Society Press.
Meyden, R. v., & Wong, K. (2003). Complete axiomatizations reasoning knowledge
branching time. Studia Logica, 75 (1), 93123.
Moore, R. C. (1990). formal theory knowledge action. Allen, J., Hendler, J., &
Tate, A. (Eds.), Readings Planning, pp. 480519. Kaufmann.
Parikh, R., & Ramanujam, R. (1985). Distributed processes logic knowledge.
Logics Programs, Conference Proceedings, Vol. 193 Lecture Notes Computer
Science, pp. 256268. Springer.
Pnueli, A. (1977). temporal logic programs. Proceedings 18th International
Symposium Foundations Computer Science, FOCS 1977, pp. 4657.
Rao, A., & Georgeff, M. (1991). Deliberation role formation intentions.
Proceedings 7th Conference Uncertainty Artificial Intelligence, pp.
300307. Kaufmann.
Sturm, H., Wolter, F., & Zakharyaschev, M. (2000). Monodic epistemic predicate logic.
Logics Artificial Intelligence, European Workshop, JELIA 2000, Vol. 1919
Lecture Notes Computer Science, pp. 329344. Springer.
Sturm, H., Wolter, F., & Zakharyaschev, M. (2002). Common knowledge quantification.
Economic Theory, 19, 157186.
Wolter, F., & Zakharyaschev, M. (2001). Decidable fragments first-order modal logics.
Journal Symbolic Logic, 66 (3), 14151438.
Wolter, F., & Zakharyaschev, M. (2002). Axiomatizing monodic fragment first-order
temporal logic. Annals Pure Applies Logic, 118 (1-2), 133145.
Wooldridge, M. (2000a). Computationally grounded theories agency. Proceedings
International Conference Multi-Agent Systems, ICMAS 2000, pp. 1322. IEEE
Computer Society Press.
44

fiInteractions Knowledge Time First-Order Logic MAS

Wooldridge, M. (2000b). Reasoning Rational Agents. MIT Press.
Wooldridge, M., & Fisher, M. (1992). first-order branching time logic multi-agent
systems. Proceedings 10th European Conference Artificial Intelligence,
ECAI 1992, pp. 234238. John Wiley Sons.
Wooldridge, M., Fisher, M., Huget, M., & Parsons, S. (2002). Model checking multi-agent
systems MABLE. Proceedings 1st International Conference Autonomous Agents Multiagent Systems, AAMAS 2002, pp. 952959. ACM Press.
Wooldridge, M., Huget, M., Fisher, M., & Parsons, S. (2006). Model checking multiagent
systems: MABLE language applications. International Journal Artificial
Intelligence Tools, 15 (2), 195226.
Wooldridge, M. (1999). Verifying agents implement communication language.
Proceedings 16th National Conference Artificial Intelligence 11th Conference Innovative Applications Artificial Intelligence, pp. 5257. AAAI Press.

45


