Journal Artificial Intelligence Research 45 (2012) 79-124

Submitted 03/12; published 09/12

Approximative Inference Method Solving
Satisfiability Problems
Hanne Vlaeminck
Joost Vennekens
Marc Denecker
Maurice Bruynooghe

hanne.vlaeminck@cs.kuleuven.be
joost.vennekens@cs.kuleuven.be
marc.denecker@cs.kuleuven.be
maurice.bruynooghe@cs.kuleuven.be

Department Computer Science,
Celestijnenlaan 200a
3001 Heverlee, Belgium

Abstract
paper considers fragment second-order logic. Many interesting problems, conformant planning, naturally expressed finite domain satisfiability problems logic. satisfiability problems computationally hard (P
2 )
many problems often solved approximately. paper, develop general
approximative method, i.e., sound incomplete method, solving satisfiability
problems. use syntactic representation constraint propagation method firstorder logic transform satisfiability problem SO(ID) satisfiability
problem (second-order logic, extended inductive definitions). finite domain satisfiability problem latter language NP handled several existing
solvers. Inductive definitions powerful knowledge representation tool, motivates us approximate SO(ID) problems. order this, first show
perform propagation inductive definitions. Next, use approximate
SO(ID) satisfiability problems. provides general theoretical framework
number approximative methods literature. Moreover, show
use framework solving practical useful problems, conformant planning,
effective way.

1. Introduction
Finite model generation logical paradigm solving constraint problems. successful
instance field SAT, efficient solvers low level CNF language developed. instances, expressive languages, Answer Set Programming
(ASP) (Baral, 2003) model expansion (MX) (extensions of) first order logic. ASP,
e.g., finite Herbrand models answer set program computed (Baral, 2003). Model
expansion (MX) (Mitchell & Ternovska, 2005) generalizes Herbrand model generation
aims computing one models theory expand finite interpretation I0
(possibly empty) subset symbols . MX first order logic (MX(FO)) formally
equivalent finite domain satisfiability checking problem existential second-order
logic (SAT (SO))1 known Fagins celebrated theorem capture NP (Fagin,
1974). is, problems NP exactly precise sense equivalent
satisfiability problem, hence MX(FO) problem. range solvers exists
1. specifically, search problem witness problem.
c
2012
AI Access Foundation. rights reserved.

fiVlaeminck, Vennekens, Denecker & Bruynooghe

finite model generation, e.g., overview state-of-the-art ASP MX(FO()) solvers
(here, FO() refers family extensions FO) found reports
ASP competition (e.g., Denecker, Vennekens, Bond, Gebser, & Truszczynski, 2009).
Example 1.1. bounded planning problem modeled Finite Model Generation
problem. problem deliberately kept simple serve running example
paper: glass may clean not, cleaned action wiping.
represent dynamic domain following FO theory Tact :
: (Clean(t + 1) Clean(t) W ipe(t)).
Clean(0) InitiallyClean.

(1)
(2)

bounded planning problem considering turn dirty glass clean
one n steps, n N given constant. indeed formulated
Model Expansion problem: find model satisfies Tact InitiallyClean false,
Clean(n) true. formulate problem equivalently finite domain
satisfiability problem, namely satisfiability problem range [0 . . . n] time
points following formula:
W ipe, Clean, InitiallyClean : (act InitiallyClean Clean(n)),

(3)

act denote conjunction sentences Tact . n > 0, formula
indeed satisfiable suitable interpretation constants 0 n binary function
+, and, moreover, witness W satisfiability provides plan. instance, wiping
time point 0 job, verified witness W W ipeW = {0}
CleanW = {1, . . . , n}.
large number search problems indeed seen Finite Model Generation
problems, number problems higher complexity NP,
consequently cannot formulated MX(FO) problem. Indeed, paper
interested NP, next level P2 polynomial hierarchy. Perhaps
prototypical problem finite domain satisfiability SO: satisfaction finite
interpretations P2 every sentence P2 -hard sentences
(Immerman, 1998). interesting P2 problem conformant planning,
discuss detail Section 7, already introduce next example.
Example 1.2. Extending Example 1.1, suppose know whether object
initially clean dirty, still want plan guaranteed make clean, matter
initial situation was. longer standard planning problem, called
conformant planning problem. formulate following satisfiability
problem:
W ipe InitiallyClean, Clean : (act Clean(n)).
(4)
words, need assignment action W ipe goal Clean(n) satisfied
every initial situation InitiallyClean fluent Clean satisfy action theory.
Solving problems would require us make choice existentially quantified predicates check implication satisfied every interpretation
80

fiAn Approximative Inference Method

universally quantified predicates. done principle, practice
often expensive. paper, explore alternative based propagation
method first order logic developed Wittocx, Denecker, Bruynooghe (2010).
method computes polynomial time, given theory partial interpretation I,
approximation certainly true (= true models expand
I) certainly false (= false models). Now, interesting property
propagation method syntactically represented monotone inductive
definition (Denecker & Ternovska, 2008) defines (in approximative way) underestimates predicates complements. monotone inductive
definition essentially set propagation rules, similar definite logic program,
interpreted least fixpoint immediate consequence operator.
given theory obtain approximating definition linear transformation
original FO formula.
Returning example, need find interpretation action predicates, every interpretation predicates, implication act
Clean(n) satisfied, i.e., without knowing anything predicates, already certain implication satisfied. basic idea behind
method approximate problem form P Q , using approximate definition Wittocx et al. check whether interpretation existentially
quantified predicates P property making true, regardless predicates Q.
Essentially, reduces problem SO(ID) problem (where SO(ID)
refer extended inductive definitions).
Section 5, extend method SO(ID) problems. argued Denecker
Ternovska, inductive definitions useful tool knowledge representation.
example, many dynamic domains formulated naturally modular way using
inductive definitions, quite tedious FO. already mentioned conformant planning typical satisfiability problem. Typically, conformant
planning problems require modeling dynamic domain. come back
syntax semantics inductive definitions next section, dynamic domain
Example 1.1 can, alternative action theory Tact , formulated following
inductive definition act :


Clean(t + 1) Clean(t).

Clean(t + 1) W ipe(t).
(5)


Clean(0)
InitiallyClean.
conformant planning problem formulated alternatively satisfiability problem formula W ipe InitiallyClean, Clean : (act Clean(n)). However,
longer satisfiability problem, SO(ID) satisfiability problem.
motivates us see extend approximation method SO(ID)
satisfiability problems. purpose, first show symbolically represent propagation inductive definitions. Next, show use together
representation propagation FO approximate finite domain SO(ID) satisfiability
problems.
approximation method number benefits. First all, general method,
applied automatically approximately solve problem. Second,
81

fiVlaeminck, Vennekens, Denecker & Bruynooghe

required computation carried off-the-shelf MX(FO(ID)) solver, allowing
method benefit effortlessly improvements solver technology,
IDP system Marien, Wittocx, Denecker (2006). Finally, show Section 7,
method elegantly generalizes number approximate reasoning methods
literature (e.g., Baral, Gelfond, & Kosheleva, 1998; Son, Tu, Gelfond, & Morales, 2005;
Denecker, Cortes Calabuig, Bruynooghe, & Arieli, 2010; Doherty, Magnusson, & Szalas,
2006; Son et al., 2005).
Parts work already presented JELIA 2011 conference (Vlaeminck, Wittocx, Vennekens, Denecker, & Bruynooghe, 2010).

2. Preliminaries
assume familiarity classical first-order logic (FO) second-order logic (SO).
section introduce notations conventions used throughout paper.
2.1 First-order Logic
vocabulary finite set predicate symbols P function symbols F ,
associated arity. Constants function symbols arity 0. often denote symbol
arity n S/n. interpretation consists domain assignment
relation P Dn predicate symbol P/n assignment function
F : Dn function symbol F/n . assume P contains equality
predicate = interpreted identity relation. pre-interpretation consists
domain interpretation function symbols. -interpretation 0 ,
denote I|0 restriction symbols 0 . 1 2 two disjoint
vocabularies, 1 -interpretation domain J 2 -interpretation
domain, + J denotes unique (1 2 )-interpretation domain
(I + J)|1 = (I + J)|2 = J.
Terms formulas vocabulary defined usual. expression form
P n-ary predicate Dn called domain atom. domain literal
P (d)
negation P (d)
thereof. usual, denote formula
domain atom P (d)
[x] indicate set free variables subset x. formula without
free variables called sentence. satisfaction relation |= defined usual.

interpretation I, formula n free variables tuple n domain elements d,


use |= [d] shorthand I, [x : d] |= [x], variable assignment,
variable assignment except maps variables
[x : d]
define truth evaluation function ([d])
follows:
x domain elements d.





([d]) = iff |= [d] ([d]) = f otherwise. say formula negation
normal form contains implications equivalences, negations occur directly
front atoms. define inverse truth values follows: (f )1 = (t)1 = f .
define following strict order truth values: f <t t. truth order
point-wise extends interpretations: J two -interpretations, say
J every predicate symbol P tuple domain elements holds
P J (d).

P (d)
Similar real number r approximated interval [l, u] l r
u, paper approximate -interpretations K pair (I, J) -interpretations,
82

fiAn Approximative Inference Method

K J. denote [I, J] interval interpretations K.
interval empty 6t J. follows easily well-known monotonicity
results, evaluate positive occurrences (i.e., scope even number
negations) atoms formula I, negative occurrences (i.e., scope
odd number negations) J, underestimating truth interval
[I, J]. Conversely, evaluate positive occurrences J negative occurrences I,
overestimating truth [I, J]. state property formally,
introduce following notation.
Definition 2.1 (Pos-neg evaluation relation +IJ ). Let -formula let J
-interpretations. define pos-neg evaluation J, denoted +IJ ,
induction size :
atom = P (t), +IJ = ;
= , +IJ = ( +JI )1 ;
= 1 2 , +IJ = iff i+IJ = = 1, 2;
= x , +IJ = iff +I[x/d]J[x/d] = t.
indeed that, K [I, J], +IJ K +JI . Also,
K = +KK .
intimate connection approximation interpretation
pair interpretations Belnaps four-valued logic (1977). denote truth values
true, false, unknown inconsistent four-valued logic respectively t, f , u i.
truth values, truth order precision order p defined shown Figure
1.
four-valued relation arity n domain function Dn {t, f , u, i}.
four-valued interpretation vocabulary consists pre-interpretation P ,
four-valued relation arity n predicate symbol P/n . Again,
precision order pointwise extends interpretations: J two -interpretations,
say p J every predicate symbol P tuple domain elements
p P J (d).
Similarly, truth order extended interpretations.
holds P (d)
@t^
<t

<p

<t

u^

@i

<p

f_

<t

<t

@i^

?t
<p

<p

u

f

Figure 1: truth precision order
83

fiVlaeminck, Vennekens, Denecker & Bruynooghe

natural isomorphism Belnaps four truth values pairs two
standard truth values:
(t, t) = t;
(f , t) = u;
(t, f ) = i;
(f , f ) = f .
Intuitively, mapping interprets first argument underestimate real
truth value, second argument overestimate: underestimate f
overestimate t, real truth value indeed unknown; whereas, underestimate
overestimate f , cannot exist real truth value, since 6 f ,
end inconsistency. isomorphism extends obvious way isomorphism
pairs (I, J) two-valued interpretations four-valued interpretations
share pre-interpretations: (I, J) isomorphic iff, predicate
= (P (d),
P J (d)).
denote isomorphism .
P/n tuple Dn , P (d)
tight link pos-neg evaluation function +IJ Belnap
evaluation :
= (+IJ , +JI ), (I, J) = I.
three-valued structure (i.e., never assigns i) corresponds standard
Kleene evaluation (1952). rest paper, often omit isomorphism ,
and, e.g., simply denote four-valued truth value formula pair interpretations
(I, J) (I,J) . important property, already stated different notation,
(I,J) p K K [I, J].
natural well-known alternative way using interval [I, J]
J assign truth value formula : supervaluation (van Fraassen, 1966).
Definition 2.2 (Supervaluation sv(I,J) (.)). supervaluation sv(I,J) () sentence
pair interpretations (I, J) (or equivalently, three-valued interpretation (I, J))
defined
sv(I,J) () = glbp ({K |K [I, J]}).
easy see always sv(I,J) () p (I,J) . inequality may strict.
instance, take = Q Q interpretations J Q(I,J) = u,
sv(I,J) () = t, (I,J) = u. supervaluation following interesting property.
Let interpretation free vocabulary formula = Q , let (J1 , J2 )
=u
least precise pair interpretations Q domain (i.e., Q(J1 ,J2 ) (d)
n

Q/n Q ). sv(I+J1 ,I+J2 ) () = = t.
Key approach simulate four-valued truth evaluation pairs
interpretations encoding certainly true certainly false, using single
two-valued structure tf new vocabulary tf . show next section,
gives us convenient vocabulary syntactically represent construction
approximation. new vocabulary tf contains function symbols F and,
predicate P P , two symbols P ct P cf . interpretations P ct P cf
certainly true
tf contain, respectively, tuples P (d)
certainly false. Formally, vocabulary four-valued -interpretation
84

fiAn Approximative Inference Method

= (I, J), tf -interpretation tf pre-interpretation I, defined
by:
(P ct )I

tf

(d)
p t} = P ,
= {d|P

(P cf )I

tf

(d)
p f } = Dn \ P J .
= {d|P
tf

tf

interpretation three-valued iff (P ct )I (P cf )I disjoint P .
tf
tf
two-valued iff (P ct )I (P cf )I others complement Dn . Also, p J ,
tf
tf
tf
tf
then, P , (P ct )I (P ct )J (P cf )I (P cf )J .
Definition 2.3 (ct cf ). given -formula [x], let ct [x] tf -formula
obtained first reducing negation normal form replacing occurrences
positive literals P (t) P ct (t) negative literals P (t) P cf (t), let cf [x]
formula ([x])ct .
interesting property formulas ct cf contain negations.
Also, following proposition well-known.
Proposition 2.1 (Feferman, 1984). every -formula interpretation I, holds
p [d]
+IJ = (ct [d])
tf = t. Also, [d]
p f
[d]
tf
+JI
cf



[d]
= f ( [d])
= t.
2.2 FO(ID)
subsection recall FO(ID) (Denecker & Ternovska, 2008), extension FO
construct respresent common forms inductive definitions,
monotone induction, induction well-founded order iterated induction.
illustrated Denecker Ternovska, FO(ID) used represent different sorts
common knowledge, temporal dynamic domains, closed world assumption, defaults, causality, etc. paper, use definitions symbolically represent
propagation, FO formulas, already mentioned introduction,
propagation inductive definitions themselves.
definitional rule vocabulary expression form x P (t)
P (t) atomic formula FO formula. symbol new connective, called
definitional implication, distinguished FO material implication symbol
(or converse ). definition finite set definitional rules. predicate
symbol P head rule called defined predicate; predicate
function symbols called open symbols parameters definition;
set defined predicates denoted Def (), remaining symbols Open() (note
Open() therefore includes F ).
Given interpretation open predicates, definition unique model,
constructed firing rules appropriate order. defining
formally, first consider example.
Example 2.1. Reachability graph expressible FO. is, FO
formula vocabulary consisting two predicates Edge/2 Reach/2
model , (d1 , d2 ) ReachM iff non-empty path d1 d2
85

fiVlaeminck, Vennekens, Denecker & Bruynooghe

graph represented EdgeM . represent reachability inductive definition
however. following definition defines predicate Reach terms open predicate
Edge.
(
)
xy Reach(x, y) Edge(x, y).
xy Reach(x, y) z(Reach(x, z) Reach(z, y)).
). definition given Open()-interpretation O,
Definition 2.4 (Operator
two-valued Def ()-interpretations
define immediate consequence operator

(I) = J iff defined predicate P/n tuple Dn , holds
= iff exists rule x P (t) [x], t(O+I) = (O+I) [d]
= t.
P J (d)

model positive definition (i.e., defined predicates occur negatively
body rules) defined least fixpoint immediate consequence operator.
use odI|Open() () denote model definition extending restriction
open predicates function symbols . open predicates,
omit subscript simply use od(). postpone going detail
construct model general (non-monotonic) inductive definition Section
5. next two sections, use positive definitions.
FO(ID) formulas inductively defined rules standard FO formulas,
augmented one extra case:
definition FO(ID) formula (over )).
Note rule bodies contain definitions, rules occur inside definitions
FO(ID) formulas whereas definitions used FO(ID) formulas
anywhere atoms used.
define satisfaction relation |= FO(ID) using standard inductive
rules FO, augmented one extra rule:
|= = odI|Open() (),
on, assume without loss generality definition , holds
every defined predicate P Def () defined exactly one rule, denoted x(P (x)
P [x]). Indeed, definition brought form process similar
predicate completion. transformation consists first transforming rules form
x(P (t) ) equivalent rules y(P (y) x(y = )). Next, one merges rules
form x(P (x) [x]) x(P (x) 1 [x] . . . n [x]).

3. Propagation FO
section give general, symbolic representation propagation first-order logic.
this, base work Wittocx et al. (2010). come back
precise relation material presented section work end
section.
Suppose FO theory vocabulary , pre-interpretation ,
finite three-valued interpretation represents (incomplete) knowledge
86

fiAn Approximative Inference Method

(Clean(t + 1) (Clean(t) W ipe(t))).


A1
Act
1

Clean(t + 1) (Clean(t) W ipe(t))
= 3

Clean(t + 1)
f = 3

A2 (t)
Act
2 (3)

Clean(t) W ipe(t)
= 3

Clean(t)
= 3

A3 (t)
Act
3 (3)

Clean(t + 1)
Cleancf (4)

W ipe(t)
= 3

Clean(t)
Cleancf (3)

W ipe(t)
W ipecf (3)

Figure 2: Propagation FO.
predicates . would know implications knowledge, assuming
theory satisfied context I. find out, look set
models complete three-valued interpretation, i.e., = {M | |=
p }. Given partial information I, everything true
must certainly true according , everything false must
certainly false according . words, information allows us
derive captured greatest lower bound G = glbp M.
general, computing greatest lower bound may expensive (the data complexity P2 ) practical use. However, may still achieve useful results
computing approximation p p G. compute
approximation propagating three-valued interpretation parse tree
. illustrate following example.
Example 3.1. Consider sentence : Clean(t + 1) Clean(t) W ipe(t). Rewriting
negation normal form, becomes:
Clean(t + 1) (Clean(t) W ipe(t)).
Now, assume satisfied, know Clean false timepoint 4.
knowledge satisfied, immediately follows that, timepoints t,
disjunctive formula Clean(t + 1) (Clean(t) W ipe(t)) satisfied. Using fact
Clean false timepoint 4, deduce conjunction (Clean(t)
W ipe(t)) true timepoint 3. Therefore, models Clean false
timepoint 4, W ipe Clean false timepoint 3. reasoning process
illustrated left part Figure 2.
construct symbolic representation propagation process. First,
introduce additional vocabulary Aux refer different nodes parse
tree process operates. use additional vocabulary transform
FO formula equivalence normal form formula. similar Tseitin
transformation (1968) propositional logic.
Definition 3.1 (EN F ()). FO formula negation normal form, introduce
new predicate symbol arity n non-literal subformula [x] n
87

fiVlaeminck, Vennekens, Denecker & Bruynooghe

free variables. denote set new predicates Aux(). new
predicate symbols defined formula Eq(A ) follows. make notation simpler
assume 1 , . . . , n non-literal subformula. definitions analogous
whenever literal, instead Ai literal used body
definition.
[x] subformula form 1 [x1 ] 2 [x2 ] . . . n [xn ], Eq(A )
x (A (x) A1 (x1 ) A2 (x2 ) . . . (xn )).
[x] subformula form 1 [x1 ] 2 [x2 ] . . . n [xn ], Eq(A )
x (A (x) A1 (x1 ) A2 (x2 ) . . . (xn )).
[x] subformula form 1 [x, y], Eq(A ) equals x (A (x)
A1 (x, y)).
[x] subformula form 1 [x, y], Eq(A ) equals x (A (x)
A1 (x, y)).
define equivalence normal form set Eq(A ), denote
EN F ().
Example 3.2. According definition, EN F () theory Example 3.1 is:
A1 A2 (t).
A2 (t) Clean(t + 1) A3 (t).
A3 (t) Clean(t) W ipe(t).
illustrated right side Figure 2.
Using auxiliary vocabulary, write propagations shown
Figure 2 following implications.
A1
A2 (3) Clean(4)
A3 (3)
A3 (3)






A2 (3).
A3 (3).
Clean(3).
W ipe(3).

Note rules top-down rules, is, implications propagate information
subformula parse tree, component subformula (possibly
using information components subformula, implication
A2 (3)Clean(4) A3 (3)). general, bottom-up propagations course possible.
instance, Clean(4) could derive A2 (3). every predicate , derive
Eq(A ) set implications 1 2 , propagation corresponds
deriving consequent 2 antecedent 1 (so, different implications
logically equivalent). defined Table 1. last column table indicates
whether rule top-down (TD) bottom-up (BU).
Definition 3.2 (IN F ()). Given equivalence EN F () certain formula ,
denote Imp() set implications obtained Table 1.
define implication normal form , denoted F (), follows: F () = EN F () Imp().
88

fiAn Approximative Inference Method

= Eq(A )

Imp()

x (L L1 . . . Ln ).

x
x
x
x

(L1 . . . Ln L).
(Li L).
(L Li ).
(L L1 . . . Li1 Li+1 . . . Ln Li ).

1in
1in
1in

BU
BU
TD
TD

x (L L1 . . . Ln ).

x
x
x
x

(L1 . . . Ln L).
(Li L).
1in
(L Li ).
1in
(L L1 . . . Li1 Li+1 . . . Ln Li ). 1 n

BU
BU
TD
TD

x (L[x] L0 [x, y]).

x ((y L0 [x, y]) L[x]).
x(y L0 [x, y]) L[x]).
xy (L[x] L0 [x, y]).
xy ((L[x] z (y 6= z L0 [x, y][y/z])) L0 [x, y]).

BU
BU
TD
TD

x (L[x] L0 [x, y]).

x ((y L0 [x, y]) L[x]).
x(y L0 [x, y]) L[x]).
xy (L[x] L0 [x, y]).
xy ((L[x] z (y 6= z L0 [x, y][y/z])) L0 [x, y]).

BU
BU
TD
TD

Table 1: ENF INF

work Wittocx et al. (2010) proven models models F ()
true correspond, sense restriction model F ()
model , vice versa, every model extended model
F () . implications form core approximation method.
approximation could made complete adding implications
F (), definition tries strike balance completeness ease
automatically deriving implications.
Example 3.3. three formulas EN F () Example 3.2, following
table shows corresponding set implications Imp(). complete theory F ()
consists union three sets.
A1 A2 (t).
(t A2 (t)) A1 .
(t A2 (t)) A1 .
(A1 A2 (t)).
((A1 t0 (t 6= t0
A2 (t0 ))) A2 (t)).

(A2 (t) Clean(t + 1) A3 (t)).
(Clean(t + 1) A3 (t) A2 (t)).
(Clean(t + 1) A2 (t)).
(A3 (t) A2 (t)).
(A2 (t) Clean(t + 1)).
(A2 (t) A3 (t)).
(A2 (t) A3 (t) Clean(t + 1)).
(A2 (t) Clean(t + 1) A3 (t)).

(A3 (t) (Clean(t) W ipe(t))).
(Clean(t) W ipe(t) A3 (t)).
(Clean(t) A3 (t)).
(W ipe(t) A3 (t)).
(A3 (t) Clean(t)).
(A3 (t) W ipe(t)).
(A3 (t) W ipe(t) Clean(t)).
(A3 (t) Clean(t) W ipe(t)).

reader verify four implications representing propagation Example 3.1
indeed belong F ().
propagation process Example 3.1 described least fixpointcomputation, apply implications (i.e., infer head body
already inferred), longer infer new information. represent
fixpoint computation inductive definition syntax FO(ID). However,
two complications.
89

fiVlaeminck, Vennekens, Denecker & Bruynooghe

First, paper, always need implications F (). Indeed,
typically subset symbols already know
know. conformant planning example, instance, case
existentially quantified predicate W ipe/2, simply use model expansion
system guess complete interpretation predicate. job propagation
process figure consequences particular guess. this, implications predicate (i.e., W ipe/2) head obviously needed.
Second, fixpoint computation needs infer atoms true
false. However, syntax FO(ID) allow negative literals
heads rules. Therefore, definition contain rules predicates P
original vocabulary head, instead use predicates P ct P cf
tf -vocabulary. Since need rules fully known predicates head,
introduce P ct P cf predicates P \ .
ct
ct
given formula , therefore define ct
formula (see Definition 2.3) P
cf
replaced P P P every predicate P .
Definition 3.3 (Approx ()). formula , define Approx ()
inductive definition contains, every sentence x ( L[x]) F () L
ct
literal predicate , definitional rule x(L[x]ct
). define
TD
ApproxBU
() (and Approx ()) way Approx (), containing
definitional rules coming bottom-up (respectively, top-down) rules F ().
often assume without loss generality = . Whenever case
drop use Approx() rather Approx (), denote approximative
definition.
Example 3.4. Using implications F () Example 3.3, obtain definition
shown Figure 3 Approx(). take = {W ipe}, get definition
Approx () Figure 3, apart last seven definitional rules replaced
following five definitional rules.


..




.






ct
cf



(t)

Clean
(t)

W
ipe(t).


3


cf

ct
A3 (t)
Clean (t).


W ipe(t).
Acf

3 (t)




cf
ct




Clean
(t)


(t).
3






cf
ct
Clean (t) A3 (t) W ipe(t).
contrast Approx() definition longer approximates predicate W ipe.
definition Approx () used find certainly holds holds given two
valued interpretation predicates .
Example 3.5. larger example, look Example 1.1. Let us take
= act = {W ipe}. definition Approx () found Appendix
A.
approximative definition useful properties, formulate
next two theorems. first property that, using approximative definition
90

fiAn Approximative Inference Method

ct
A1



cf



1


ct


A2 (t)




Acf

2 (t)







Acf

2 (t)


ct



2 (t)

ct


A2 (t)



Cleancf (t + 1)


cf
A3 (t)
Cleanct (t + 1)




Act

3 (t)







Act

3 (t)


cf



3 (t)


cf



3 (t)


cf


Clean
(t)


cf


W
ipe
(t)




Cleanct (t)



W ipect (t)


Act

2 (t).




Acf
(t).
2


ct


A1 .


cf
0
0
ct 0

A1 (t 6= A2 (t )).







cf
cf
Clean (t + 1) A3 (t).



ct

Clean (t + 1).



ct

A3 (t).



cf


A2 (t).



cf
A2 (t).
cf

Act
2 (t) A3 (t).


ct


A2 (t) Cleancf (t + 1).






cf
cf

Clean (t) W ipe (t).




Cleanct (t).





W ipect (t).




Act
(t).
3




Act
(t).
3


cf

cf

A3 (t) W ipe (t).



cf
cf
A3 (t) Clean (t).

A1

A2 (t)


A3 (t)

Clean(t + 1)



Clean(t)

W ipe(t)

Figure 3: Example approximative definition
together encoding three-valued interpretation original vocabulary,
give exact characterization approximative definition computes. Indeed,
setting, ApproxBU () actually encodes three-valued Kleene evaluation
I. Moreover, adding top-down rules change this, since compute
actually anything, long information original vocabulary provided
input. formally state property, need define encode
four-valued interpretation definition. on, assume vocabulary
-pre-interpretation I, contains constant symbol Cd every domain element
domain I, pre-interpretation holds (Cd )I = d.
allows us identify Cd therefore, abusing notation, use denote Cd
follows.
Definition 3.4 (I ). Given four-valued -interpretation I, definition associated
denoted defined


=

| P (d)
p t}
{P ct (d)
cf



{P (d) | P (d) p f }

Theorem 3.1. Given -formula four-valued -interpretation I, following
holds:
a) case three-valued holds Approx() logically equivalent
ApproxBU () , is, od(Approx() ) = od(ApproxBU () )
91

fiVlaeminck, Vennekens, Denecker & Bruynooghe

b) Let od(Approx() ), v1 truth value Act
v2 truth

value Acf
, (v1 , v2 ) corresponds four-valued truth value , i.e.,
= (v1 , v2 ).

Proof. See Appendix B.
summary, theorem says that, first all, approximation always
computes four-valued Belnap evaluation four-valued structure I. Moreover,
computation done bottom-up rules approximation alone. threevalued, top-down rules actually effect all. four-valued,
may still serve purpose, however: bottom-up rules derived
subformula inconsistent, propagate information derive smaller
formulas inconsistent. see this, consider following formula P Q, take
four-valued interpretation P = Q = t. one verify
cf
bottom-up rules Approx() infer Act
P Q AP Q true.
However, top-down rules infer Qcf true.
theorem information add approximative definition
form definition , i.e., assert truth, resp. falsity domain atoms.
following definition allows us assert truth falsity grounded

subformula [d].
Definition 3.5 ( ). Given -formula , -pre-interpretation I, set
[x] subformula arity n Dn
formulas ()[d],
domain I, define follows:
cf



= {Act
(d) | [d] } {A (d) | [d] }.

assert way truth (or falsity) set grounded subformulas ,
obtain approximation everything holds (respectively, hold)
models . However, opposed theorem above, next theorem
give exact characterization approximation get.
Theorem 3.2. Given -formula , set defined subformula 0 [x0 ]
cf 0
0 0
0
. Let od(Approx() ). |= Act
0 (d ) (resp. A0 (d )), |= [d ]
(resp. |= 0 [d0 ]).
Note interesting special case theorem take equal {}
thus add Act
Approx(). definition gives approximation everything
certainly true resp. certainly false models .
Returning exact relationship work Wittocx et al. (2010)
content section, see Wittocx et al. interested special
case, i.e., approximating models theory. reason transformation
formula EN F () already includes formula t, cause rule
Act
always included approximating definition. soundness results
formulated proven setting. However, difficult see
proofs trivially adapted proof Theorem 3.2 general setting
used section.
92

fiAn Approximative Inference Method

4. Approximating SO-Satisfiability Problems
use approximate definition previous section approximate following problem. Take formula F = P Q : . ease presentation,
assume second-order formulas paper contain free predicate symbols,
results generalize setting free predicate symbols. assume
Q contains predicate symbols. follows, denote vocabulary
. question want answer whether formula F satisfied given
finite-domain pre-interpretation constant function symbols formula.
satisfiability problem boils deciding whether find witness
satisfiability formula, following sense.
Definition 4.1 (Witness). call J witness satisfiability formula P Q :
given finite pre-interpretation I, J interpretation \ Q extending (i.e., J
interpretation whole vocabulary without universally quantified predicates)
Q : satisfied J. Equivalently, J witness three-valued holds
interpretation J expands J assigning u domain atom Q(d),
svJ () = t.
goal section approximate satisfiability problems
satisfiability problem following sense.
Definition 4.2 (Sound approximation). Consider satisfiability problem
formula P Q : , FO formula alphabet . SO(ID) formula
form P R : 0 , 0 FO(ID) formula alphabet \ Q R, sound
approximation satisfiability problem if, whenever J witness satisfiability
P R : 0 , J|\Q witness satisfiability P Q : .
words, sound approximation G satisfiability problem
formula F stronger SO(ID) formula, i.e., one fewer witnesses P .
4.1 Naive Method
use results Theorem 3.1 construct sound approximation given
formula.
Definition 4.3 (APP(F )). Given formula F = P Q : . Take alphabet
function symbols predicates P . define APP(F ) formula
tf
P R : Approx () Act
vocabulary R, R = (Q Aux()) .
intuition -interpretation I, Approx () give result
four-valued evaluation -interpretation expands assigning unknown universally quantified predicates Q. entire FO formula evaluates
true four-valued interpretation, know satisfied interpretation expands (in words, every interpretation Q predicates), thus
witness satisfiability entire formula F . auxiliary predicates
Aux() introduced transformation ENF needed way
propagation works, value completely determined P .
93

fiVlaeminck, Vennekens, Denecker & Bruynooghe

Proposition 4.1. formula F form P Q : , holds APP(F )
sound approximation F .
Proof. follows immediately Theorem 3.1, take three-valued inter = u Q Q Dn ,
pretation, interpretation (Q(d))
= (P (d))
P P Dn , domain I.
(P (d))
example, take F formula P Q : = P Q, APP(F )
becomes:
ct

ct


P

Q






Acf P Qcf

cf
ct
cf
ct

P, Q , Q , , :
Act
.
ct Act P
Q







cf

Q Acf

start interpretation open predicate P definition Approx{P } ().
Let us take interpretation makes P true. unique model definition
ct
cf
extends interpretation assigns true Act
false Q , Q
ct
Acf
. Therefore, satisfies Approx{P } () . Hence, witness
satisfiability APP(F ), and, indeed, witness satisfiability original
formula P Q : P Q.
approximation method sound, many applications still incomplete.
Indeed, let us look following formula: F = Q : Q Q. APP(F ) becomes:



Qct Qcf
Act






cf
cf Qct




Q






Qct Act Qct

cf

:
,

Qct , Qcf , Act
Act

.
cf Acf



Q






cf


Qcf Act


Q




Qct Acf



definition entail Act
, APP(F ) unsatisfiable, even though original formula F clearly always satisfied. problem that, showed
previous section, definition encodes three-valued Kleene evaluation,
strong enough find formula F satisfied. this, need stronger
supervaluation.
Recall preliminaries saw supervaluation Kleene evaluation
general equal. However, formulas equal. literature, several
classes formulas agree proposed, e.g., context locally
closed databases (Denecker et al., 2010), context reasoning incomplete
first-order knowledge (Liu & Levesque, 1998). latter introduces normal form N F
first-order formulas, supervaluation coincides Kleene evaluation,
proves certain classes formulas normal form N F. One class
CNF formulas every two literals conflict-free: pair literals
conflict-free either polarity, use different predicates,
use different constants argument position. immediately follows
94

fiAn Approximative Inference Method

approximation complete formulas first-order formula satisfies
condition.
Proposition 4.2. formula F form P Q : , N F
normal form (according Liu & Levesque, 1998) satisfiable respect given finite
pre-interpretation SO-formula APP(F ) satisfiable w.r.t. I.
Proof. follows immediately results Liu Levesque Theorem 3.1.
4.2 Complete Method
Unfortunately, many applications give rise formulas first-order part falls
outside class N F, means completeness method guaranteed.
Particularly troublesome practice formulas common form P Q : 1 2 .
formulas, naive approximation method previous section tries find
interpretations P implication = (1 2 ) holds Q. However,
look details approximative definitions, find Act
defined rule
cf
ct
body 1 2 . words, approximation derive holds
Q either case 1 false Q 2 true Q. However,
rarely case. practical applications, witnesses interest
typically satisfy implication 1 2 always falsify 1 always
satisfy 2 , rather interpretation Q satisfies 1 satisfies 2.
instance, conformant planning example, always interpretations
fluents satisfy action theory act , arbitrarily assign
fluent value wrong initial value actions performed. Even
set actions completely correct conformant plan, therefore cannot make goal
certainly true, still unsatisfied wrong interpretations
fluents. course, bother good method finding conformant plans.
thing matter goal satisfied interpretations
fluents satisfy action theory.
Luckily, approximation method used discover kind witnesses.
thing required add approximative definition = Approx ()
rule Act
1 t. do, seed approximation assumption 1
holds. Starting assumption, top-down rules derive properties
predicates Q shared interpretations Q actually satisfy 1 .
bottom-up rules propagate information upwards discover whether
properties suffice ensure 2 holds. do, know 2 indeed
must hold every interpretation Q satisfies 1 therefore found
witness formula.
want find witnesses kind degenerate witnesses either make
1 false Q 2 true Q, could simply combine new method old
ct
ct
one check either whether Act
2 holds according {A1 t} whether holds
according itself. However, turns necessary: achieve
ct
effect checking whether {Act
1 t} implies . because, first,
ct
definition {Act
1 t} able derive whenever can:
ct
ct
derive A2 {A1 t} obviously still able so; would
95

fiVlaeminck, Vennekens, Denecker & Bruynooghe

ct
able derive Acf
1 , {A1 t} able so, simply
approximation flow information ct cf variants
formula, additional assumption Act
1 holds change original derivation
ct
ct
ct
Acf
1 . Second, {A1 t} derive A2 , derives , simply
cf
ct
contains rule Act
A1 A2 . Therefore, find kinds witnesses
ct
checking whether Act
implied single definition {A1 t}.

Definition 4.4 (APP (F )). formula F = P Q : ,
definition
form 1 2 , define APP (F ) P R : Act
,
ct
Approx (1 2 ) {A1 t}.
Note obtain Definition 4.3 special case taking trivial formula
1 . approximation method still sound, following proposition states.
Proposition 4.3. Given formula F form P Q : , = 1 2 ,
SO(ID) formula APP (F ) sound approximation F .
Proof. See Appendix C.
Since approximative definition APP (F ) contains rules Approx(F ),
hard see new approximation method least complete one
using APP(F ) (Definition 4.3). Moreover, seen following example,
strictly complete.
Example 4.1. Let us consider following formula F = P Q : (Q P ) Q.
P = clearly witness satisfiability problem. denote (Q P ) Q
1 (Q P ) 2 , APP(F ) following formula.

Act

1


cf






ct1
A2
P R :

Acf
2



ct

Q


cf
Q








ct
Acf
2 Q
ct
A2 Qcf
P Qct
P Qcf
Act
2 P
Acf
2











Act
1 .










Now, even P = t, definition body formula entail Act
1 = t.

Therefore, APP(F ) satisfiable. hand, APP (F ) formula
above, apart definition contains one rule, is, rule Act
2 t.
easy verify APP (F ) satisfiable, indeed P = witness.
Obviously, new method still complete formulas 1 2 , 1 2
satisfies normal form N F. However, method works many formulas outside
class. Unfortunately, difficult characterize precisely much complete
new method is. instance, one source loss completeness comes fact
current translation ENF cannot recognize multiple occurrences subformula,
introduce different Tseitin predicate occurrence. Even though cannot
96

fiAn Approximative Inference Method

guarantee completeness method general, always found solutions
conformant planning benchmarks considered Section 6.
final remark method approximative definition Approx (1
2 ) contains number rules superfluous context. Indeed, method,
definition takes input interpretation P together assumption
1 certainly true. uses bottom-up top-down rules derived 1
compute effect inputs predicates Q. Finally, rules derived 2
compute whether derived information Q suffices make 2 certainly true.
However, know Theorem 3.1, bottom-up rules 2 needed
this. Therefore, top-down rules 2 actually contribute nothing could

TD
well removed. Adapting Definition 4.4 use
BU = \ Approx (2 ) instead

leads following definition.
Definition 4.5 (APP
BU (F )). formula F = P Q : ,
ct

form 1 2 , define APP
BU (F ) P R : BU ,
TD
ct

BU = Approx (1 2 ) \ Approx (2 ) {A1 t}.

follows directly Theorem 3.1 Proposition 4.3 sound approximation. removed top-down rules approximation 2 , remaining
rules serve, already know, compute Kleene evaluation 2 .
computing Kleene evaluation subformula 2 , use
pt
Tseitin predicates Act
. alternative avoid Tseitin predicates
defining Act
2 directly single rule:
ct
Act
2 (2 )

variant summarized following definition.
Definition 4.6 (APP
BU,U nf (F )). formula F = P Q : ,
ct

1 2 , define APP
BU,U nf (F ) P R : BU,U nf ,
ct
ct
ct

BU,U nf = Approx () \ Approx (2 ) {A2 (2 ) } {A1 t}.

approximation actually equivalent Def. 4.5. follows
fact bottom-up rules 2 positive non-recursive, allows us
eliminate Tseitin predicates introduced parse tree 2 applying unfolding
procedure Tamaki Sato (1984). iteratively applying equivalence preserving
procedure, reduce rules generated approximate 2
ct
single rule Act
2 (2 ) .

5. Approximating SO(ID)-Satisfiability Problems
Inductive definitions important knowledge representation. argued Denecker
Ternovska (2008), inductive definitions used represent mathematical
concepts, sort common sense knowledge often represented logic
programs, dynamic domains, closed world assumption, defaults, causality, etc.
97

fiVlaeminck, Vennekens, Denecker & Bruynooghe

Therefore, inductive definitions make task representing problem logic considerably easier. example use inductively defined Situation Calculus
reasoning actions (Denecker & Ternovska, 2007). Recall introduction
showed represent Tact Example 1.1 inductive definition act :


Clean(t + 1) Clean(t).

Clean(t + 1) W ipe(t).
.


Clean(0)
InitiallyClean.
associated conformant planning problem expressed SO(ID) satisfiability problem:
W ipe Clean, InitiallyClean : act Clean(n).
show detail Section 7, general conformant planning problem
seen satisfiability problem form
F : (act init ) (prec goal ),
AI
predicates represent actions, initial fluents F fluents.
definition act defines fluents change terms action, init first
order formula initial situation, prec describes preconditions actions
goal goal. motivates extension approximation method formulas
including definitions. However, analyze general case definitions may
appear arbitrary locations formula, instead restrict attention formulas
form
P Q : ( 1 ) 2 ,
definition Def () Q 1 2 FO formulas. Even
though restrictions strictly necessary, allow us keep technical
details relatively simple (in particular, avoid need approximation rules infer
definition whole certainly true/false), still covering way
definitions typically used: assumption predicates indeed
definition formula 1 say be, 2 states properties
satisfy.
extend approximative method ( 1 ) 2 satisfiability problems,
need syntactic representation (i.e., approximative definition) describes sound
inferences made definition three-valued context. section
propose two ways obtain approximative definition, accordingly, two ways
approximate ( 1 ) 2 satisfiability problems. continue, first
need recall preliminaries.
5.1 Preliminaries Well-founded Semantics Inductive Definitions
Earlier, defined model positive inductive definition given two-valued interpretation open predicates. on, inductive definitions longer
positive definitions, model definition longer always computed
least fixpoint immediate consequence operator introduced Section 2. Moreover,
98

fiAn Approximative Inference Method

follows want use inductive definitions together four-valued information
open predicates (for example, information obtained propagation
first order theory). Therefore, recall (see, e.g., Denecker & Ternovska, 2008)
define well-founded model non-monotone inductive definition (that is, negation
body rules allowed), given four-valued information open predicates, denote W F MO (). order this, first need define
additional concepts. Recall P denotes body unique rule predicate P
head.
Definition 5.1 (Operator ). definition given (potentially 4-valued)
Open()-interpretation O, define operator 4-valued Def ()-interpretations
domain Open() (I) = J iff defined predicate P/n
n-tuple Dn , holds
= O+I [d]

P J (d)
P
Recall preliminaries defined isomorphism maps pair
interpretations (I, J) corresponding four-valued interpretation I.
Definition 5.2 (W F MO ()). define well-founded model 4-valued
O,
interpretation (I, J) (I, J) maximal oscillation pair operator ST


ST operator J(lf p(K(T (K, J)1 )). I.e., (I, J) least precise pair
2-valued interpretations


= ST
(J) J = ST
(I).

explanation order. First look operator K(TO (K, J)1 ). operator takes Def ()-structure K, turns 4-valued one combining J,
applies operator , projects result first argument. see
K(TO (K, J)1 ) = L iff defined predicate P/n n-tuple Dn , holds
= iff (P [d])
+(O1 +L)(O2 +J) =
P L (d)
words, positive occurrences atoms evaluated O1 + L, negative occurrences
O2 + J. J, operator K(TO (K, J)1 ) monotone, therefore
maps J least fixpoint. proven
least fixpoint. operator ST
operator antimonotone, therefore maximal oscillation pair. definition
nonof well-founded model maximal oscillation pair operator ST
constructive definition. maximal oscillation pair constructed iterating
following operator, starting least precise interpretation extends O,
reaches least fixpoint.

Definition 5.3 (Stable operator ST
). define operator ST pairs interpretations as:


ST
(I, J) = (ST (J), ST (I)).

stable operator monotone w.r.t. precision order p pairs interpretations
fixpoints therefore form complete lattice. fixpoints operator called
99

fiVlaeminck, Vennekens, Denecker & Bruynooghe

four-valued stable fixpoints , least precise fixpoints precisely
well-founded model given O.
define semantics inductive definitions general case.
reader easily verify indeed generalizes definition odO () positive
definitions gave Section 2.2.
Definition 5.4 (Satisfaction relation definitions). |= iff (I|Def () , I|Def () )
well-founded model I|Open() .
Note definition three-valued well-founded model every possible
interpretation open predicates Open(), definition model (i.e.
exists interpretation |= ). call definition total
two-valued well-founded model every possible two-valued interpretation open
predicates.
definitions generalize rather obvious way standard well-founded
semantics propositional logic programs strongly linked stable semantics (Gelfond & Lifschitz, 1988). case propositional logic program ,
Open() = {}, operator K(T (K, J)1 ) nothing else immediate consequence operator TJ Gelfond Lifschitz reduct J , operator maps
J lf p(K(T (K, J)1 ) stable operator . shown Van Gelder (1993),
maximal oscillation pair indeed well-founded model .
5.2 Approximating SO(ID)-Satisfiability Problems
Assume formula , FO(ID) formula instead FO.
concepts witness (Definition 4.1) sound approximation (Definition 4.2) straightforwardly generalised FO(ID) formula. allows us develop two
approaches. first one, Section 5.2.1, replaces definition completion
applies method Section 4. However, completion weaker
definition. Therefore, Section 5.2.2, develop another approach constructs
approximation conjunction definition FO formula.
5.2.1 Using Completion Definition
first approach based use completion (Clark, 1978). completion
definition conjunction equivalences x P (x) P (x) predicates
P Def (), P (x) body unique rule P head. useful
property definition implies completion compl(). Moreover, nonrecursive, two actually equivalent. Replacing definition completion
( 1 ) 2 obtain formula (comp() 1 ) 2 . every model
model comp(), every model (comp() 1 ) 2 model ( 1 ) 2
every witness (compl() 1 ) 2 satisfiability problem witness
( 1 ) 2 satisfiability problem. Hence use results Section 4
formulate following proposition.
Proposition 5.1. formula APP
BU ((compl() 1 ) 2 ) sound approximation
P Q( 1 ) 2 .
100

fiAn Approximative Inference Method

disadvantage using completion matter complete approximation method defined Definition 4.4 is, never able infer something
follows compl(). instance, inductive definition {P P }
entails P , completion P P not.
Denecker Ternovska (2008) proven that, addition non-recursive definitions, class recursive definitions equivalent completion. particular,
case definitions strict well-founded order 2 . therefore replace
definitions completion without losing precision. theory Tact Example
1.1 actually completion definition act . Since act recursive definition
strict well-founded order (we make use time argument predicates
construct well-founded order), act Tact equivalent.
Gaspipe conformant planning problem (Son et al., 2005), hand, uses
dynamic domain completion suffice. Summarized, objective
conformant planning problem start flame burner connected
gas tank pipe line. pipe line consists sections connected
valves. valve opened gas one side other, gas
spread far possible. formalized inductive definition
reachability relation pipe line:
(
)
x, Gas(x, t) Gas(y, t) v Connected(x, y, v) Open(v, t).
x, Gas(x, t) ank(x).
reachability definitions equivalent completion. Therefore, approximative method presented subsection work. problem completion
case correctly minimize defined predicates presence
recursion, would allow models loop pipe line filled gas even
connected tank. missing, therefore, unfounded set reasoning allows well-founded semantics correctly minimize defined predicates.
5.2.2 Using Certainly True/Possibly True Approximation
approximative definition Approx () used Section 4 nice property
defines, subformula (including itself), whether certainly true certainly
false. property allowed us find witnesses simply asserting Act

hold according definition. want apply method formulas
contain definition , construct approximative definition defines
whether subformulas (including itself) certainly true certainly
false. Section 5.2.1, naive method managed simply replacing
completion. want improve method constructing approximation
takes account unfounded set reasoning performed well-founded
semantics.
take aspect well-founded semantics account, however,
becomes difficult define definition whole certainly true certainly
false. Luckily, needed stick assumption definitions appear
antecedent implication . Indeed, approximate implications
2. order < well-founded infinite descending chains . . . < xn < xn1 < . . . < x1

101

fiVlaeminck, Vennekens, Denecker & Bruynooghe

assuming antecedent certainly true (Definition 4.4), really need
approximation consequences definition. end, transform
original definition approximative definition 0 well-founded
model 0 , given approximation open predicates , approximates
well-founded models given interpretation open predicates
approximated O. words, construct approximative definition 0 whose
two-valued well-founded model encodes potentially four-valued well-founded model
original definition , given potentially four-valued interpretation predicates
. therefore represent four-valued interpretation orginal vocabulary
two-valued interpretation larger vocabulary 0 . However, instead introducing,
predicate P , predicate P ct (P certainly true) P cf (P certainly false),
before, introduce predicates P ct P pt (P possibly true, i.e., P
certainly false). Let ct/pt denote vocabulary F {P ct | P } {P pt | P }.
four-valued -interpretation I, define corresponding ct/pt -interpretation ct/pt
ct/pt
interpretation pre-interpretation (P ct )I
= {d |
ct/pt

pt





P (d) p t} (P )
= {d | (P (d) p t)}.
Also, -formula , define formula ct/pt formula obtain
replacing positive occurrences predicate P P ct , negative occurrences
P pt , finally reducing negational normal form. easy see ct/pt
obtained ct replacing, every predicate P , occurrences P cf P pt .
Unlike ct , ct/pt always positive formula contain negations. particular,
P ct occurs positively P pt occurs negatively. subvocabulary ,
ct/pt

denotes ct/pt P ct P pt replaced P every predicate
P . Again, follows use denote predicates need
approximated two-valued information them.
ct/pt

ct/pt

Definition 5.5 (App ()). definition , define App
{Rct Rpt } Rct consists rules

() definition

x(P ct (x) ct/pt
)

Rpt consists rules
x(P pt (x) ()ct/pt
)

every definitional rule x (P (x) ) .
assume rest paragraph without loss generality empty,
ct/pt
drop notation App .
Example 5.1. Consider following inductive definition.


B B

Assume = {}.

Appct/pt

ct
B


ct

=
pt
B


pt






102

B ct Apt
Dpt
B pt Act
Dct









.

fiAn Approximative Inference Method

see three-valued interpretation {D = u}, translates {Dct = f , Dpt =
t}, approximative definition correctly infer B ct false B pt true.
take {D = f } interpretation open predicate D, see approximative
definition correctly infers B ct B pt false. example unfounded
set reasoning: known true, approximation detects B could
derived B therefore must false. kind reasoning could done
previous, completion-based approximation method, since sound w.r.t.
semantics definition itself, w.r.t. weaker completion.
example demonstrates use vocabulary ct/pt instead
ct/cf , since latter would yielded definition:
ct

B
B ct Acf



ct


Dcf
.
B cf B cf Act



cf


Dct
{D = f }, definition would fail infer B cf . Intuitively, reason
unfounded set reasoning well-founded semantics tries minimize extension
defined predicates making many atoms false possible. Using ct/cf
vocabulary, well-founded semantics approximating definition therefore attempts
possible, actually corresponds maximizing
falsify many atoms P cf (d)
possible extension original predicates P , instead minimizing well-founded
semantics original definition does.
two-valued interpretation double vocabulary ct/pt corresponds fourvalued interpretation original vocabulary . want establish link
ct/pt
well-founded model original definition App . complict/pt
cating factor that, example shows, definition App
longer
monotone therefore longer guaranteed two-valued well-founded model.
three-valued interpretation ct/pt longer corresponds even four-valued
interpretation original vocabulary , prove correspondence
ct/pt
well-founded model App
two-valued.
Theorem 5.2. Let four-valued interpretation open predicates definition
. Appct/pt () two-valued well-founded model given Oct/pt
unique four-valued stable fixpoint given O. Moreover, Appct/pt () two-valued wellfounded model I, unique four-valued stable fixpoint unique interpretation
ct/pt = I.
Proof. See Appendix D.
theorem requires unique four-valued stable model four-valued
input interpretation O. stronger requirement common condition
totality, requires definition two-valued well-founded model given
two-valued input interpretation O. following example shows, stronger condition
indeed necessary.
103

fiVlaeminck, Vennekens, Denecker & Bruynooghe

Example 5.2. Consider following definition:




B.

B C.




C O.
definition total, because, two-valued interpretation open predicate
O, ({A}, {A}) two-valued well-founded model. However, three-valued
interpretation ({}, {O}) (i.e., unknown) open predicate O, three-valued
well-founded model ({}, {O, A, B, C}) unique three-valued stable fixpoint, since
({A}, {O, A, C}) fixpoint. indeed, find
ct






B ct



C ct
ct/pt
App
() =

Apt



B pt



pt
C

B pt .






Apt C ct .


ct
pt
.

B ct .



ct
pt
C .


pt
ct
.

two-valued well-founded model given {Opt }. easiest way see
fill fact know Opt Oct f propagate information:
ct

B pt .






ct
pt
ct



B C .






C ct f t.



Apt B ct .








pt
ct
pt


B



C
.




pt

C f .

ct

B pt .






ct
pt



B f .









ct

B pt .


















ct

B pt .




















Apt B ct .








pt
ct


B



t.




pt

C


Apt f .







pt
ct


B


.




pt

C



Apt








pt
ct


B


.




pt

C

So, left loop negation, means Act B pt remain unknown
three-valued well-founded model ({Apt , C pt }, {Act , Apt , C pt , B pt }) definition.
computing three-valued well-founded model given O, approximative definition Appct/pt () produce precise results approximation compl();
particular detect atoms unfounded set must false, illustrated
Example 5.2 above. use Appct/pt () approximation () 2 -problem,
still need show combined approximation Approx ()
produce sound approximation . this, need combine one definition
ct/cf-predicates another definition ct/pt-predicates. achieve first merging
two definitions adding rules copy information one vocabulary
other.
104

fiAn Approximative Inference Method

Definition 5.6 (D ). Given vocabulary , subvocabulary , inductive
definition first-order formula . define following inductive definition.
ct/pt

App

{Ocf

()

Approx () {Act
t}

{Opt Ocf | every predicate Open() \ }

{P cf P pt | every predicate P Def () \ }

ct
f , f | every predicate Open() \ occur }

definition indeed contains rules approximation rules
approximation , is, Appct/pt () Approx() {Act
t}, respectively,
number extra rules make connection two approximations.
approximate defined predicate Q approximation uses pair predicates
Qct Qpt approximation uses Qct Qcf . Hence, number extra
rules needed transfer information predicates Qpt Qcf . rules
{Opt Ocf } transfer information approximation derived
truth open predicate (by means Ocf ) corresponding predicate Opt
approximation definition. rules {P cf P pt } turn propagate information
derived truth defined predicate approximation definition
corresponding predicate P cf approximation . Finally, rules {Ocf f , Oct
f } make sure Ocf Oct defined atoms (instead open ones)
default value u. following proposition relates well founded model
models .
Proposition 5.3. Given vocabulary , subvocabulary FO(ID) formula .
(resp. P cf (d)),
holds
Then, every -interpretation I, W F MI (D ) |= P ct (d)
(resp. |= P (d)).

every model extending |= P (d)
Proof. See Appendix E.
proposition analogue inductive definitions result Theorem 3.2
states FO formulas. One difference two results proposition always assumes definition holds, Theorem 3.2 makes
assumption FO formula approximated. discussed beginning
section, restriction problem, way approximate
implications allow definitions appear antecedent. second
difference Theorem 3.2 applies arbitrary subformulas ,
is, however, easy corrolary proposition
proposition considers atoms P (d).
result fact holds formula contains predicates defined
(or cf (d)),
every model
, i.e., whenever W F MI (D ) |= ct (d)
(resp. |= (d)).

extending I, holds |= (d)
introduced approximation Appct/pt () aim complete
completion-based approximation. long single definition considered
105

fiVlaeminck, Vennekens, Denecker & Bruynooghe

isolation, succeeded goal. However, incorporated
additional formula , longer case. instance, consider following FO(ID)
theory:


Q P Q.
Here, approximation cannot derive P certainly true, simply
ct/pt-approximation Appct/pt () contain rules head-to-body propagation, i.e.,
rules infer something body definitional rule, given information
head. contrast, approximation completion contain rules
therefore problems reaching conclusion. motivates us use
use D(compl()) instead. definition implies completion,
sound.
obtain sound approximation SO(ID) formula P Q = (
) 2 , need plug approximation D(compl())
suitable SO(ID) formula, similar one defined Definition 4.4
formula P Q 1 2 . small complication, however, that, discussed previously,
cf
approximation definition define predicates Act
tell us
definition whole certainly true certainly false. Therefore, longer
use normal approximation entire implication certainly true.
present approximation SO(ID), let us first introduce reformulation
original approximation SO, avoids use Act
.
Proposition 5.4. formula F = P Q : , form 1 2 ,
approximation defined Definition 4.4, i.e., formula
ct
P R : (Approx (1 2 ) {Act
1 t})

equivalent
cf
ct
P R : (Approx (1 ) Appox (2 ) {Act
1 t}) (A1 A2 )

Proof. obvious fact difference Approx (1 2 )
Approx (1 ) Appox (2 ) precisely set rules ensure Act
equivalent
ct
Acf
1 A2 .

approximation SO(ID) essentially consists replacing Approx (1 )
compl()
cf
{Act
Acf
form.
1 t} A1 respectively
Proposition 5.5. Given SO(ID) formula F = P Q ( ) 2 . define
APP wf (F ) following SO(ID) formula.
ct
P R : (Dcompl() Approx (2 )) (Acf
A2 ).

APP wf (F ) sound approximation F .
compl()

cases, approximating
instead gain us anything. instance, consider P Q( ) 2 problem, contains open
predicates (as case conformant planning problems consider next
106

fiAn Approximative Inference Method

sections). case, never need head-to-body propagation, therefore
compl()
complete
, therefore better using former.
case approximation method , well rules
definition APP wf necessary. Indeed, bottom-up rules Approx (2 )
needed, unfolded single rule. Therefore, define two
variants Definition 5.5.
Definition 5.7 (APP wf
BU (F )). Given SO(ID) formula F = P Q ( ) 2 .
wf
define APP BU (F ) following SO(ID) formula,
cf
ct
P R : (Dcompl() ApproxBU
(2 )) (A A2 ),

define APP wf
BU,U nf (F ) following SO(ID) formula,
ct
cf
ct
P R : (Dcompl() {Act
2 (2 ) }) (A A2 ).

6. Experimental Evaluation
paper seen number methods approximate SO(ID)
satisfiability problems. subsection, explore, number experiments,
use methods solve practically useful problems fast possible.
performed experiments number conformant planning benchmarks
paper Son et al. (2005). show Section 7, benchmarks
form F = , stratified definition, therefore equivalent
completion. Therefore, F equivalent formula compl() ,
denote F cp . experiments run dual core 2.4 Ghz CPU, 2.8 Gb RAM
Linux machine, using IDP model expansion system FO(ID) (Marien et al., 2006).
time-out twenty minutes used.
first question want answer whether definitions, completion
based approximation faster ct/pt approximation. hard see that, even
though Approx(compl()) linear size parse tree compl(), definition
may contain rules Appct/pt (), moreover, rules may contain lot
recursion. pose challenge current solvers, suggests likely
efficient use ct/pt approximation definitions. first column Table 2
shows times using completion definition , is, APP (F cp ),
second column, ct/pt-approximation used, is, APP wf (F ). expected,
ct/pt-approximation consistently faster.
Table 2 compares solving times full completion-based approximative definition
cp
(in first column) approximation APP
BU (F ) (Def. 4.5), topdown propagation rules removed (third column). see BT
BTC benchmarks get order magnitude improvement. fourth column
cp
Table 2 shows timings unfolded approximation 2 , APP
BU,U nf (F ),
intermediate Tseitin predicates removed (Def. 4.6). see unfolding
consistently provides speed-up.
results suggest combining techniques, is, using ct/pt
approximation unfolding bottom-up approximation 2 together,
107

fiVlaeminck, Vennekens, Denecker & Bruynooghe

APP (F cp )

APP wf (F )

cp
APP
BU (F )

cp
APP
BU,U nf (F )

APP wf
BU,U nf (F )

BT(2,2)
BT(4,2)
BT(6,2)
BT(8,4)
BT(10,4)

0,151
3,404
38,93
-

0,109
3,493
14,76
-

0,115
0,312
0,876
32,91
-

0,065
0,153
0,409
1,774
-

0,031
0,064
0,113
0,462
1,643

BTC(2,2)
BTC(4,2)
BTC(6,2)
BTC(8,4)

0,210
-

0,131
-

0,171
40,081
-

0,116
8,408
-

0,037
0,109
0,335
41,894

0,390
1,101
6,597
31,275
-

0,026
0,036
0,067
0,120
0,231

0,507
1,250
8,995
42,583
-

0,473
1,266
6,997
28,387
-

0,049
0,052
0,128
0,396
1,530

7,023
-

0,374
-

5,217
-

2,792
-

0,100
0,358
6,650
193,290
2485

Problem

Domino(100)
Domino(200)
Domino(500)
Domino(1000)
Domino(2000)
Ring(2)
Ring(4)
Ring(6)
Ring(8)
Ring(10)

Table 2: first column gives name benchmark ones different
execution times. second column gives execution time approximation
completion third cp/pt approximation. fourth fifth column use
variants completion approximation. fourth column, top-down rules
2 removed addition, fifth column, remaining bottom-up rules
unfolded. last column combines cp/pt approximation changes. -
means execution interrupted 20 minutes.
give us fastest way approximating ( 1 ) 2 satisfiability problems. Indeed,
formula APP wf
BU,U nf (F ) (Definition 5.7) does, results method
shown last column Table 2. expected, far fastest method.

7. Applications Related Work
literature, many examples found approaches perform kind
approximate reasoning models logical theory. Often, approaches,
specific problem hand, seem boil instantiation general
methods presented here. section give examples.
7.1 Conformant Planning
general, conformant planning problem planning problem non-deterministic
domain initial state may fully known. goal come
plan (i.e., sequence actions) nevertheless guaranteed work. hard
problem: decision problem deciding whether conformant plan fixed length
k exists P2 -complete3 (Baral, Kreinovich, & Trejo, 2000; Turner, 2002). Therefore, one
3. planning domains executability actions given state cannot determined polynomially, even P
3 (Turner, 2002)

108

fiAn Approximative Inference Method

typically attempts solve approximately. section, show apply
approximative methods solve conformant planning problems.
Example 7.1. Let us consider Clogged Bombs Toilet domain (McDermott, 1987;
Son et al., 2005). number packages toilet. packages may
contain bomb disarmed dunking package toilet. Dunking
package toilet clogs toilet cannot throw package clogged toilet.
Flushing toilet unclogs it. effects actions fluents modeled
following definition act , preconditions conjunction prec sentences
Tprec .

act



Clogged(0) Init Clogged.





Clogged(t + 1) p : Dunk(p, t) (Clogged(t) F lush(t)).

=


Armed(p, 0) Init Armed(p).






Armed(p, + 1) Armed(p, t) Dunk(p, t).

Tprec

p : Dunk(p, t) Clogged(t).
( p : Dunk(p, t) F lush(t)).
=
p p2 : Dunk(p, t) Dunk(p2 , t) p = p2 .
p t2 : Dunk(p, t) Dunk(p, t2 ) = t2 .

consider following regular planning problem: given completely specified initial
situation (specified formula init ), find plan packages disarmed.
formulate problem following formula:
A, F , : act prec init (t p Armed(p, t)),
A, denote action predicates {Dunk/2, F lush/1}, F denote
fluent predicates {Armed/2, Clogged/1} denote predicates used
describe initial situation {Init Clogged/0, Init Armed/1}. imagine initial
situation specified, want find plan works possible initial
situations, words conformant plan. formulate problem finding
plan follows.
F , : act (prec p Armed(p, t)).
formalized general follows.
Definition 7.1 (Conformant planning). Let vocabulary, consisting set
predicates A, denoting actions, I, denoting initial fluents, F denoting fluents. Let
Tact FO(ID) theory Tinit , Tprec Tgoal FO theories, , Tact
specifies values fluents given interpretation actions initial fluents,
Tinit theory specifying initial situation, Tprec contains preconditions actions,
Tgoal specifies goal planning problem. act denote conjunction
sentences possibly definitions Tact similarly theories.
problem conformant planning decide satisfiability following formula:
F : (act init ) (prec goal ).
109

(6)

fiVlaeminck, Vennekens, Denecker & Bruynooghe

AR :


Cloggedct (0)



ct (t + 1)

Clogged




Armedct (p, 0)




Armedct (p, + 1)




Cloggedpt (0)




Cloggedpt (t + 1)




Armedpt (p, 0)




Armedpt (p, + 1)




Init Cloggedct




Init
Armedct (p)

Init Cloggedpt


Init Cloggedcf




Init
Armedpt (p)




Armedcf
Init



cf (t)

Clogged



cf (p, t)

Armed




Act

2

































Init Cloggedct .
p : Dunk(p, t) (Cloggedct (t) F lush(t)).
Init Armedct (p).
Armed(p, t) Dunk(p, t).
Init Cloggedpt .
p : Dunk(p, t) (Cloggedpt (t) F lush(t)).
Init Armedpt (p).
Armed(p, t) Dunk(p, t).
f.
f.
Init Cloggedcf .
f.
Init Armedcf (p).
f.
Cloggedpt (t).
Armedpt (p, t).
pt : Dunk(p, t) Cloggedcf (t)
(pt : Dunk(p, t) F lush(t))
p1 p2 : Dunk(p, t) Dunk(p2 , t) p1 = p2
pt1 t2 : Dunk(p, t1 ) Dunk(p, t2 ) t1 = t2
tp : Armedcf (p, t).














































































Act
2 .

Figure 4: complete approximation Clogged Bombs Toilet example.
words, must plan (A), matter nondeterministic
F ), long specification effects actions (act )
aspects turn (I,
(partial) specification initial situation (init ) obeyed, plan
executable (prec ) achieve goal (goal ).
Formula 6 exactly form assumed above, thus use one
methods approximate conformant planning problems.
Example 7.1. (continued) Continuing Clogged Bombs Toilet example,
using ct/pt-approximation definition, unfolding constraint (prec
p Armed(p, t))ct , get approximating formula APP wf
BU,U nf (Definition 5.7),
shown Figure 4, R ct- cf-predicates introduced approximation
method.
result applying general approximation method conformant planning
problem, specified Tact , Tprec , Tgoal Tinit above, similar approximation AL action theory logic program work Son et al. (2005).
However, small differences details make difficult formally
compare two. Nevertheless, experiments discussed section, method
always finds correct solution (unless times out), method Son et al.
Moreover, two approaches found solutions comparable execution times.
detail, Table 3 presents following results. implemented conformant
planner iteratively calling IDP model generator FO(ID) (Marien et al., 2006)
approximation, giving increasing number timesteps either plan
110

fiAn Approximative Inference Method

Problem

IDP

Smodels

Cmodels

BT(2,2)
BT(4,2)
BT(6,2)
BT(8,4)
BT(10,4)

0.438
0.513
1.050
1.55
2.80

0.199
0.219
0.587
30.9
-

0.145
0.212
0.425
2.39
5.80

BTC(2,2)
BTC(4,2)
BTC(6,2)
BTC(8,4)

0.273
0.844
1.60
43.7

0.136
0.412
3.88
-

0.139
0.389
1.23
102

Cleaner(2,2)
Cleaner(2,5)
Cleaner(2,10)
Cleaner(4,2)
Cleaner(4,5)
Cleaner(4,10)
Cleaner(6,2)
Cleaner(6,5)

0.644
1.57
1.55
2460
8.30
-

0.226
72.5
13.8
-

0.376
1.36
1.13
6.16
-

Domino(100)
Domino(200)
Domino(500)
Domino(1000)
Domino(2000)

0.176
0.181
0.212
0.236
0.339

0.096
0.114
0.324
0.618
1.22

0.090
0.151
0.354
0.660
1.32

0.655
1.56
7.35
157
1537

0.285
2.092
19.1
-

0.296
0.937
3.542
19.860
232

Ring(2)
Ring(4)
Ring(6)
Ring(8)
Ring(10)

Table 3: Comparison IDP vs Cmodels vs Smodels

found maximum number timesteps reached. compared planner
CPASP conformant planner (Son et al., 2005), using experimental setup
Section 6. CPASP takes action theory action language AL, encodes
approximation transition diagram corresponding action theory, means
answer set program. answer set solver used find conformant plans.
Son et al., used ASP solver behind CPASP CModels (E. Giunchiglia &
Maratea, 2011) SModels (Niemela, Simons, & Syrjanen, 2000). Table 3 shows,
combination approximation IDP system comparable to, overall slightly
worse, combination CModels Son et al.s approximation. compared
approximation given SModels, method tends bit better.
results line results ASP competition (Denecker et al., 2009) concerning
performance SModels, CModels IDP general, suggesting that, conformant
planning, approximation Son et al. comparable quality.
Another approximative method solving conformant planning problems found
work Palacios Geffner (2009). paper, authors consider conformant
planning problems, specified language Strips extended conditional effects
negation. define transformation K0 transforms conformant planning
problem classical planning problem sound incomplete way. fluent
literal L conformant planning specification, two new literals KL KL created,
111

fiVlaeminck, Vennekens, Denecker & Bruynooghe

denoting L known true, resp. known true, initial situation,
action preconditions effects translated initial situation, preconditions
effects reference new knowledge literals. hard verify
approximation method generalizes transformation: take encoding
conformant planning problem P , approximation obtained method
interpreted classical planning problem ct/cf vocabulary. planning problem
exactly planning problem specified K0 (P ) (i.e., action preconditions
effects correspond), apart initial situation. K0 transformation
propagation knowledge initial situation: given initial situation (specified
set clauses), K0 (I) consists literals KL L unit clause
I. means that, e.g., initial situation = {P Q, P }, K0 (I) include
literal KQ, method able infer Qct holds (which means
approximation method complete K0 transformation).
general method, allow solving conformant planning problems, allows approximating number related problems temporal domains.
Consider, example, following problem: Given certain action happens
timepoint t, certainly lead property true ? formalized
following satisfiability problem, method applies again.
AIF : ((act init prec A(t)) ).
formula true possible plans A(t) happens, property holds.
variant problem so-called projection problem: Given exactly know
actions happened (we thus assume preconditions satisfied),
property hold ? order formulate problem satisfiability problem,
need express actions happened. done, example,
using inductive definition . projection problem expressed
AIF : ((act init ) ) satisfiability problem. Another variant following
problem: property 1 holds certain plan, property 2 hold?,
expressed AIF ((act init prec 1 ) 2 ) satisfiability problem.
7.2 Querying Reasoning Open Databases
Approximate methods similar used context databases without
complete information, particular databases without CWA, open databases
(Baral et al., 1998; Liu & Levesque, 1998) databases make forms local closed
world assumptions (Denecker et al., 2010; Doherty et al., 2006). papers
goal compute certain possible answers queries. task
high complexity (from CoNP locally closed database without integrity constraints
possibly P2 databases first-order constraints - assuming given finite domain),
approximate methods presented translate FO query approximate FO
FO(FP)4 query solved directly database tables using standard
(polynomial) query methods.
method presented paper provide similar functionality. Let DB
set ground literals, representing incomplete database. Let background theory:
4. FO(FP) extension FO least greatest fixpoint constructs.

112

fiAn Approximative Inference Method

may contain integrity constraints, view definitions (datalog view programs special
case FO(ID) definitions), local closed world statements expressed FO, etc. given
holds Herbrand models
FO query Q [x], goal find tuples Q [d]
DB . problem deciding whether given tuple answer corresponds
satisfiability problem formula

R(DB Q [d]),

(7)

directly use approximation method problem. allows us
answer yes/no queries well decide whether given tuple certain answer
query, approximation method directly provide method compute (an
approximation of) tuples.
However, let us look following satisfiability problem.
R0 : DDB ApproxBU (Q [x]),
looks much approximation ( 1 ) 2 satisfiability problems (as
formulated Proposition 5.5). definition DDB approximating
database DB background knowledge (note possibly contains definitions),
bottom evaluation query, constraint Act
Q dropped.
definition DDB ApproxBU (Q [x]) consists rules describing propagations allowed database theory , rules defining predicate symbol Act
Q ,
AQ Tseitin predicate representing query Q [x]. unique Herbrand model
definition, interpretation Act
Q contains tuples propagation
derive certainly satisfy query sound approximation full set
answers!
work Denecker et al. (2010), locally closed database LCDB assumed.
locally closed database consists standard database DB, i.e. set atoms, together
set local closed world assumptions LCWA(P (x), [x]). LCWA
statements expresses databases knowledge P complete tuples x
therefore true DB false
satisfy formula [x]. atom P (d)
holds domain
DB LCWA(P (x), [x]) [d]
discourse; otherwise unknown. authors present approximate reasoning
method query answering locally closed databases show approximate
query answering formulated fixpoint query. Basically, boils
following. One constructs following definition




...






P ct (x) P (x)

,
LCWA =
P cf (x) P ct (x) ct


P [x]






...
every relation P every local closed world assumption LCWA(P (x), [x]). Although
authors phrase form, method finding approximation
certain answers query Q [x] actually boils solving following satisfiability
problem:
R0 : DB CW A(DB) LCWA ApproxBU (Q [x]),
113

fiVlaeminck, Vennekens, Denecker & Bruynooghe

R0 denotes predicates auxiliary predicates occurring body existential formula. CW A(DB), denote formula expressing closed world assumption
database DB. presence closed world assumption might seem strange
first sight, since whole idea behind locally closed world databases assume CWA
per default. However, order correctly apply local closed world assumptions,
need exact specification database not, precisely
expressed DB CW A(DB). Indeed, given DB CW A(DB), LCWA
seen approximative definition certainly true false context
locally closed world assumptions. predicate Act
Q contain approximate
answer query Q [x], i.e., lower bound tuples query Q [x]
certainly true. Similarly, predicate Acf
Q contain lower bound tuples
query false.
limitation approach Denecker et al. extend method
one type integrity constraints, namely functional dependencies. way
functional dependencies handled extending LCWA extra propagation rules
taking functional dependencies account. contrast, general method
used easily extend arbitrary integrity constraints. works follows.
Let Tint set first-order integrity constraints. approximate problem
finding certain queries following satisfiability problem.
BU
ct t} DB CW A(DB) LCWA Approx
(Q [t]).
R0 : Approx(Tint ) {ATint

Again, predicate Act
Q contain approximate answer query Q [x].
Doherty et al. (2006), propose yet another approach asking queries incomplete
database. authors use term approximate database denote database, consisting
two layers: extentional intensional layer. layers external
representation towards user, internal representation.
extentional database consists positive negative literals, internally
stored classical database, using Feferman transformation. example, extentional database (EDB), entered user,
Color(Car1, Black), Color(Car1, Red), Color(Car2, Red),
internally stored
Colorct (Car1, Black), Colorcf (Car1, Red), Colorct (Car2, Red).
intentional database consists rules infer additional information facts
EDB. user write rules form ()P1 (x1 ). . .()Pn (xn ) ()P (x)),
internally stored (()P1 (x1 ))ct . . . (()Pn (xn ))ct (()P (x)))ct .
example IDB rule following rule
Color(x, y1 ) y1 6= y2 Color(x, y2 ),
internally stored
Colorct (x, y1 ) y1 6= y2 Colorcf (x, y2 ).
114

fiAn Approximative Inference Method

evaluate query, naive algorithm based exhaustively applying rules EDB
used.
rules IDB resemble F formulas sense describe valid
inferences made based incomplete information. internal representation
IDB indeed similar representation F formulas definitional rules.
However, key difference approach Doherty et al., user wants add
property database (e.g., car one color), write
inferences valid according property, approach inference
rules automatically generated property itself. Manually writing valid
inferences sanctioned property easy task. example, take property
car inspected suspect black paper Doherty
et al.. expressed FO formula = c(Suspect(c) Color(c, Black)
Investigate(c)). While, method, Approx() constructs approximation valid
inferences made formula, user write following
rules Doherty et al.s approach:
Suspect(c) Color(c, Black) Investigate(c)
Suspect(c) Investigate(c) Color(c, Black)
Suspect(c) Investigate(c)
...
method therefore generalizes work Doherty et al. deriving rules automatically general first-order theory.
Liu Levesque (1998) propose another type reasoning open databases.
consider simple form first order knowledge bases, called proper knowledge bases.
interesting feature knowledge bases easy obtain complete
characterization certainly true, resp. certainly false. terminology,
|= P ct (d)

means one construct definition , KB |= P (d)
cf

KB |= P (d) |= P . holds every two valued extension
three valued interpretation encoded model KB. Levesque et al. use
evaluation procedure based three-valued Kleene-evaluation check whether
query holds knowledge base. mentioned earlier, define normal form
N F queries, prove Kleene-evaluation complete. work
extends work, sense take general first order knowledge base
approximately solve queries, shown above. course, since general
longer guarantee complete characterization certainly true/false,
longer guarantee completeness, even query normal form N F. Another
difference work Liu Levesque work here, assume
fixed countable infinite domain, assume fixed finite domain. indeed
theoretical difference, practice make difference, since evaluation
method considers finite set domain elements determined up-front.

8. Conclusions Future Work
Even problem computationally hard general, specific instances might still
solved efficiently. approximate methods important: cannot solve
115

fiVlaeminck, Vennekens, Denecker & Bruynooghe

every instance, instances solve, solve quickly. computational
logic, hard problems arise quite readily. therefore surprising literature
contains numerous examples algorithms perform approximate reasoning tasks
various logical formalisms various specific contexts. Since many algorithms share
common ideas, natural question whether seen instances
general method general language.
paper presents method. start propagation method FO()
developed Wittocx, Marien, Denecker (2008) symbolic expression (Wittocx,
2010) generalize method approximating P2 -complete SO(ID) satisfiability problem solving NP problem. Importantly, syntactic method
transforms SO(ID) formula SO(ID) formula. affords us freedom
use off-the-shelf solver language perform approximative reasoning.
Moreover, makes significantly easier update method adding (or removing)
specific propagations.
Since method approximation, necessarily incomplete. Nevertheless,
experiments shown that, practice, often manage find solution.
interesting topic future work determine classes problems, method
shown complete.
summary, contributions paper (1) extended logical
representation describing propagation process general method approximating
SAT (SO) problems; (2) shown approximate inductive definitions, use
approximate class useful SAT (SO(ID))-problems; (3) examined
existing approximation methods fit general framework.

Acknowledgments
work supported Research Foundation - Flanders FWO-Vlaanderen, projects
G.0489.10 G.035712, Research Fund KULeuven, project GOA/08/008. Hanne
Vlaeminck supported IWT-Vlaanderen.

Appendix A. Example Approximation
Figure 5 shows full approximation act Example 1.1.

Appendix B. Proof Theorem 3.1
Proof. First, remark Feferman (1984) showed four-valued evaluation
formula interpretation simulated computing standard two-valued
evaluation ct cf tf . easy verify bottom-up rules Approx()
inductively encode evaluation. split proof two parts. First assume
three-valued. show case bottom-up rules used, i.e., leaving
top-down rules change model definition. proves first
part theorem, together remark proves second part
theorem case three-valued. Then, left prove,
second part theorem holds four-valued I.
116

fiAn Approximative Inference Method

























































































































































































Act
act
Acf
act
Acf
act
Act
0
Act
8
Acf
0
Acf
8









Act
0
Acf
0
Act
1 (t)
Acf
1 (t)
Acf
1 (t)
Acf
1 (t)
Act
1 (t)
Act
2 (t)
Acf
2 (t)
Act
5 (t)
Acf
5 (t)
Act
2 (t)
Act
2 (t)
Acf
2 (t)
Cleanct (t + 1)
Cleancf (t + 1)
Acf
4 (t)
Act
4 (t)
Act
4 (t)
Act
4 (t)
Acf
4 (t)
Cleancf (t)
Cleanct (t)
Act
5 (t)
Act
5 (t)
Acf
5 (t)
Acf
6 (t)
Act
6 (t)
Cleancf ((t + 1))
Cleanct ((t + 1))
Acf
6 (t)
Acf
6 (t)
Act
6 (t)
Cleancf (t)
Cleanct (t)





































Acf
8
Acf
8
Act
8
Act
9
Acf
9
Act
11
Acf
11
Act
9
(t : Act
Act
1 (t)).
9
(t : Acf
Acf
1 (t)).
9
Act
Cleanct (0)
0.
ct
cf
(Acf
0 (t1 : (t1 = A1 (t1 )))). Clean (0)
cf
Acf
(t).
InitiallyClean
2
cf
A5 (t).
InitiallyCleanct
ct
ct
(A2 (t) A5 (t)).
Act
11
Act
(t).
Act
1
11
ct
(Acf
Acf
1 (t) A5 (t)).
11
ct
A1 (t).
Acf
12
ct
(Acf
Act
12
1 (t) A2 (t)).
Cleancf ((t + 1)).
Cleancf (0)
Act
(t).
Cleanct (0)
4
cf
ct
(Clean (t + 1)) A4 (t)).
Act
12
cf
A2 (t).
Acf
12
cf
(Act
InitiallyCleancf
2 (t) A4 (t)).
cf
A2 (t).
InitiallyCleanct
ct
(Act
2 (t) Clean (t + 1)).
Cleanct (t).
W ipe(t).
(Cleancf (t) W ipe(t)).
Acf
4 (t).
(Act
4 (t) W ipe(t)).
Act
6 (t).
Cleanct (t + 1).
cf
(Acf
6 (t) Clean (t + 1)).
cf
A5 (t).
cf
(Act
5 (t) Clean (t + 1)).
cf
A5 (t).
cf
(Act
5 (t) A6 (t)).
ct
Clean (t).
W ipe(t).
(Cleancf (t) W ipe(t)).
Act
6 (t).
(Acf
6 (t) W ipe(t)).
ct
Act
0 A8 .
cf
A0 .
Acf
8 .
Act
act .
Act
act .
ct
Acf
act A8 .
cf
Aact Act
0.



























Acf
9 .
Acf
11 .
ct
(Act
9 A11 ).
ct
A8 .
ct
(Acf
8 A11 ).
ct
A8 .
ct
(Acf
8 A9 ).
cf
Clean (0).
InitiallyCleanct .
(Cleanct (0) InitiallyCleancf ).
Acf
9 .
cf
(Act
9 InitiallyClean ).
Acf
.
9
ct
(Act
9 Clean (0).
ct
A12 .
Cleanct (0).
cf
(Acf
12 Clean (0)).
cf
A11 .
cf
(Act
11 Clean (0)).
Acf
.
11
cf
(Act
11 A12 ).
InitiallyCleancf .
InitiallyCleanct .
Act
12 .
Acf
12 .

























































































































































































Figure 5: Approx{W ipe} (act ), act taken Example 1.1.
let us assume three-valued. prove od(ApproxBU () ) =
od(Approx() ) contradiction. Assume predicate Act
(the proof goes
cf
ct
analogously ) od(Approx() ) |= od(ApproxBU ()
) 6|= Act
. preliminaries recalled model positive inductive definition
. model
least-fixpoint immediate consequence operator
117

fiVlaeminck, Vennekens, Denecker & Bruynooghe

definition thus limit sequence applications immediate consequence
operator. One prove (see, e.g., Denecker & Ternovska, 2004)
apply immediate consequence operator complete definition every step. I.e.,
applying immediate consequence operator subset definition,
longer exists immediate consequence operator give something new, gives
model. Suppose take sequence first apply bottom-up
rules, bottom-up rules applicable try apply top-down rules.
Suppose Act
first atom infer top rules sequence. Obviously
Act
cannot
top-level atom Act

, since top-down rules this.
case study type (sub)formula occurs in, e.g., assume subformula
formula = 0 . fact Act
true, follows body
cf
cf
ct
ct
top rule A0 true, thus Act
A0 true.
ct
Since Act
first atom inferred top-down rule, since
ct
ct
ct
true, A0 must true. since became true last step
sequence, Act
0 must true already. means applying
cf
bottom-up rules Act
0 A0 true, contradiction fact
three-valued bottom-up rules encode four-valued evaluation.
proof analogous types subformulas.
case four-valued, three-valued longer case
bottom-up rules contribute model (i.e., od(ApproxBU () ) 6=
od(Approx() )). see this, consider following formula P Q, take
four-valued interpretation P = Q = t. one verify
cf
bottom-up rules Approx() infer Act
P Q AP Q true.
However, top-down rules infer Qcf true. happens
inconsistency inferred certain subformula, propagates back
parse-tree. However, similar above, case study structure
cf
prove (for top formula ) od(ApproxBU () ) |= Act

cf
BU () clearly direct
od(Approx() ) |= Act
. since since Approx
encoding four-valued evaluation, concludes proof.

Appendix C. Proof Proposition 4.3
Proof. Take witness satisfiability APP (F ). First let us remark
Open(Approx (1 2 ) {Act
1 t}) = . fact witness
satisfiability APP (F ) know model definition extending concf
tains Act
construction Approx (1 2 ) must contain either A1
Act
2 .
Assume first Acf
1 true . application Theorem 3.2 (where take
= {1 } 0 = 1 ) gives: extends |= 1 , 6|= 1 , assumption
|= 1 results contradiction hence 6|= 1 , case 1 2 holds
every extending I, thus witness satisfiability F .
Next, assume Act
2 true . applying Theorem 3.2 (where time
= {1 } 0 = 2 ) gives: extends |= 1 |= 2 , hence
118

fiAn Approximative Inference Method

case 1 2 hold every extending I, means witness
satisfiability F .

Appendix D. Proof Theorem 5.2
key ingredient proof Theorem 5.2 following property Appct/pt ().
Oct/pt
immediate consequence operator TApp
ct/pt () two-valued interpretations simulates
(O ,O )

immediate consequence operator 1 2 four-valued interpretations original
definition. made precise following lemma.
Definition D.1. pair -interpretations (I, J), use t(I, J) denote ct/pt interpretation (I, J)ct/pt .
Lemma D.1. (O1 , O2 ) (I, J),
(O1 ,O2 )



(O1 ,O2 )

Proof. Let (I 0 , J 0 )

t(O ,O )

(I, J) = t1 (TApp1ct/pt2 () (t(I, J))).
t(O ,O )

(I, J) let F = TApp1ct/pt2 () (t(I, J)). first show

F |ct = 0 . Since F |ct depends rules Appct/pt () predicate ct ,
discard rules head pt . result, left single copy
positive occurrences atoms replaced ct variant negative
ones pt variant. implies evaluation bodies remaining
rules according t(O1 I, O2 J) identical evaluation bodies
original rules (O1 I, O2 J) construction 0 , thus proving equality.
proof remaining equality F |pt = J 0 analoguous.
Proof Theorem 5.2. First, recall that, given partial knowledge (O1 , O2 ), threevalued well-founded models , resp. Appct/pt () least fixpoints operators
(O ,O )
t(O ,O2 )
ST 1 2 resp. ST App1ct/pt
(note since t(O1 , O2 ) two-valued, abuse notation
()
rest proof denote two-valued pair (t(O1 , O2 ), t(O1 , O2 ))
t(O1 , O2 )).
Now, latter operator rather peculiar, sense actually juggling four
different interpretations original alphabet . detail, element
domain looks this:


Ict
Jct
(I, J) = , .
Ipt
Jpt
Ict Jct interpret alphabet ct , Ipt Jpt interpret pt . apply
t(O ,O2 )
operator ST App1ct/pt
, obtain new pair:
()

0
0
Ict
Jct
(I 0 , J 0 ) = , .
0
0
Ipt
Jpt


119

fiVlaeminck, Vennekens, Denecker & Bruynooghe

0
0
general definition ST
construction, obvious Ict Ipt depends
Jct Jpt . However, particular case, operator exhibits even structure.
(O ,O2 )
operator STApp1ct/pt
(J) uses argument J fixed interpretation negative
()
occurrences, remains constant throughout least fixpoint computation
positive occurrences. Now, Appct/pt () contains two copies interact
negative occurrences (that is, occurrences pt predicate body rule
ct predicate head always negative ones, vice versa). means
long keep interpretation negative occurrence fixed constant value J,
0 , discard
two copies interact all. Consequently, construct Ict
rules pt predicate head. means left rules whose head
ct predicate whose body contains positive occurrences ct predicates
0 depends J . Moreover,
negative occurrences pt predicates. Therefore, Ict
pt
0 map symbols back original alphabet (let
value Ict
0 ) = ST (O1 ,O2 ) (orig(J )). Similarly,
orig( ct ) = orig( pt ) = ), orig(Ict
pt

obtain that:
(O1 ,O2 )

(orig(Jct )),

(O1 ,O2 )

(orig(Ipt )),

(O1 ,O2 )

(orig(Ict )).

0
orig(Ipt
) = ST

0
orig(Jct
) = ST

0
orig(Jpt
) = ST

words,
(O ,O2 )

0
0
(orig(Ict
), orig(Jpt
)) = ST 1
0
0
(orig(Ipt
), orig(Jct
)) = ST

(orig(Ict ), orig(Jpt )),

(O1 ,O2 )
(orig(Ipt ), orig(Jct )).


Now, consider construction well-founded model Appct/pt (),
sequence form:

1

2



0
0
1
2

Ict
Jct
Ict
Jct
Ict
Jct
Ict
Jct
, 7 , 7 , 7 7 , .
0
0
1
1
2
2


Ipt
Jpt
Ipt
Jpt
Ipt
Jpt
Ipt
Jpt
Let (I , J )i0 well-founded model construction original definition , i.e.,
0 = f
predicates P/n Def () domain tuples Dn (P (d))
J 0 = t, (I n+1 , J n+1 ) = ST (O1 ,O2 ) (I n , J n ) n 0. easy see
(P (d))

0 J 0 ) = (I , J ). provides base case, equation provides
t1 (Ict
0 0
pt
J ). words,
inductive step prove that, i, (I , J ) = t1 (Ict
pt
well-founded model construction original definition tracked elements
well-founded model construction Appct/pt ():
0

1

2



Ict

Ict

Ict

Ict

, 7 , 7 , 7 7 , .
0
1
2


Jpt

Jpt

Jpt

Jpt
diagonal? t1 (J0ct I0ct ) = (>, ),
precise element >p lattice pairs interpretations. Therefore, find
120

fiAn Approximative Inference Method

(O ,O )

diagonal actually tracks construction greatest fixpoint ST 1 2 .
Combining two results, see (L1 , L2 ) (G1 , G2 ) least greatest
fixpoint, respectively, well-founded model Appct/pt () looks this:


L1
G1
, .
G2
L2
Note unique four-valued stable fixpoint least greatest stable fixpoint
hence well-founded fixpoint. immediately concludes proof.

Appendix E. Proof Proposition 5.3
Lemma E.1. Given -definition , FO-formula . Let subset 0 (a
renamed copy ). Consider definition
= Appct/pt () {P ct P 0ct }P {Opt O0pt }OOpen(0 ) .
Assume three-valued interpretation approximates models .
holds W F MI ct/pt (D) approximates , i.e.,
W F ct/pt (D), |= ( ) P (d),

- P ct (d)

6 W F ct/pt (D), |= ( ) P (d).

- P pt (d)

Proof. prove induction well-founded model construction alternative
one described paper, found work Denecker
Vennekens (2007). Assume induction sequence (Ii )0in , four-valued Def (D)interpretations I0 interpretation everything completely unknown,
= W F MI ct/pt (D). prove every Ii sound approximation .
trivially case n = 0. assume Ik sound approximation
. prove case Ik+1 . need prove two things
cannot true Ik+1 P (d)
true models ,
this: first, atom P ct (d)
pt
cannot false Ik+1 false models
second, atom P (d)
. prove cases contradiction.
start first case. assume k-th well-founded induction step,
incorrectly deduced, i.e.,
certain predicate P domain tuple D, P ct (d)

inferred k-th step,
exists model |= , s.t. 6|= P (d). Since P ct (d)
ct
is, (P )ct [d]
already made
means body rule defining P (d),
true previous step. induction hypothesis tells us every model
semantics inductive definitions says
holds |= P [d],
|= P , contradiction assumption.
Next, consider second case. time, assume k-th well-founded
inferred false, exists model , s.t.
induction step, P pt (d)

|= P (d). Now, using alternative version well-founded semantics,
two ways domain atom become false. Indeed, domain atom become false
121

fiVlaeminck, Vennekens, Denecker & Bruynooghe

body defining rule already false, part unfounded
set.
made false body defining rule (P )pt already false,
P pt (d)
argument completely analogous one - using induction hypothesis -

gives contradiction assumption. now, left prove, P pt (d)
pt

cannot incorrectly made false application unfounded set rule. P (d)
made false application unfounded set rule, means
set U atoms, unknown Ik , made false bodies
rules defining atoms, Kleene evaluation bodies returns false. possible
verify always find U contains pt -atoms.
let us take model . obviously model

. Consider corresponding set U 0 , consisting domain atoms P (d),
pt
pt
pt


P (d) U S. every atom Q [d] body (P ) set U S, induction
(Qpt [d])
Ik . Similarly, every atom Qct
hypothesis actually tells us (Q[d])
pt
ct

k (Q[d])
. Now, since Qpt atoms occur
body (P ) , says (Q [d])
positively Qct negatively (P )pt , follows interprets literals
U 0 false way Ik . Thus, U 0 unfounded set (indeed,
turning atoms U 0 false make bodies defining rules false),
contradiction assumption, concludes
thus |= P (d),
proof lemma.

Proof Proposition 5.3. proof proposition easy proof induction
construction well-founded model , using lemma above,
soundness Approx().

References
Baral, C. (2003). Knowledge Representation, Reasoning, Declarative Problem Solving.
Cambridge University Press, New York, NY, USA.
Baral, C., Gelfond, M., & Kosheleva, O. (1998). Expanding queries incomplete databases
interpolating general logic programs. J. Log. Program., 35 (3), 195230.
Baral, C., Kreinovich, V., & Trejo, R. (2000). Computational complexity planning
approximate planning presence incompleteness. Artif. Intell., 122 (1-2), 241
267.
Belnap, N. D. (1977). useful four-valued logic. Dunn, J. M., & Epstein, G. (Eds.),
Modern Uses Multiple-Valued Logic, pp. 837. Reidel, Dordrecht. Invited papers
Fifth International Symposium Multiple-Valued Logic, held Indiana
University, Bloomington, Indiana, May 13-16, 1975.
Clark, K. L. (1978). Negation failure. Logic Data Bases, pp. 293322. Plenum
Press.
Denecker, M., Cortes Calabuig, A., Bruynooghe, M., & Arieli, O. (2010). Towards logical
reconstruction theory locally closed databases. ACM Transactions Database
Systems, 35 (3), 22:122:60.
122

fiAn Approximative Inference Method

Denecker, M., & Ternovska, E. (2004). logic non-monotone inductive definitions
modularity properties. Lifschitz, V., & Niemela, I. (Eds.), LPNMR, Vol. 2923
LNCS, pp. 4760. Springer.
Denecker, M., & Ternovska, E. (2007). Inductive situation calculus. Artificial Intelligence,
171 (5-6), 332360.
Denecker, M., & Ternovska, E. (2008). logic nonmonotone inductive definitions. ACM
Transactions Computational Logic (TOCL), 9 (2), Article 14.
Denecker, M., & Vennekens, J. (2007). Well-founded semantics algebraic theory
non-monotone inductive definitions. Baral, C., Brewka, G., & Schlipf, J. S. (Eds.),
LPNMR, Vol. 4483 LNCS, pp. 8496. Springer.
Denecker, M., Vennekens, J., Bond, S., Gebser, M., & Truszczynski, M. (2009). second
Answer Set Programming competition. Erdem, E., Lin, F., & Schaub, T. (Eds.),
LPNMR, Vol. 5753 LNCS, pp. 637654. Springer.
Doherty, P., Magnusson, M., & Szalas, A. (2006). Approximate databases: support tool
approximate reasoning. Journal Applied Non-Classical Logics, 16 (1-2), 87118.
E. Giunchiglia, Y. L., & Maratea, M. (2011). Cmodels homepage. http://www.cs.utexas.
edu/users/tag/cmodels.html.
Fagin, R. (1974). Generalized first-order spectra polynomial-time recognizable sets.
Complexity Computation, 7, 4374.
Feferman, S. (1984). Toward useful type-free theories. Journal Symbolic Logic, 49 (1),
75111.
Gelfond, M., & Lifschitz, V. (1988). stable model semantics logic programming.
Kowalski, R. A., & Bowen, K. A. (Eds.), ICLP/SLP, pp. 10701080. MIT Press.
Immerman, N. (1998). Descriptive Complexity. Springer Verlag.
Kleene, S. C. (1952). Introduction Metamathematics. Van Nostrand.
Liu, Y., & Levesque, H. J. (1998). completeness result reasoning incomplete
first-order knowledge bases. KR, pp. 1423.
Marien, M., Wittocx, J., & Denecker, M. (2006). IDP framework declarative problem
solving. Search Logic: Answer Set Programming SAT, pp. 1934.
McDermott, D. (1987). critique pure reason. Computational Intelligence, 3, 151160.
Mitchell, D. G., & Ternovska, E. (2005). framework representing solving NP
search problems. Veloso, M. M., & Kambhampati, S. (Eds.), AAAI, pp. 430435.
AAAI Press / MIT Press.
Niemela, I., Simons, P., & Syrjanen, T. (2000). Smodels: system answer set programming. Proceedings 8th International Workshop Non-Monotonic Reasoning,
Breckenridge, Colorado, USA. CoRR, cs.AI/0003033.
Palacios, H., & Geffner, H. (2009). Compiling uncertainty away conformant planning
problems bounded width. Journal Artificial Intelligence Research (JAIR), 35,
623675.
123

fiVlaeminck, Vennekens, Denecker & Bruynooghe

Son, T. C., Tu, P. H., Gelfond, M., & Morales, A. R. (2005). approximation action
theories application conformant planning. Baral, C., Greco, G., Leone,
N., & Terracina, G. (Eds.), LPNMR, Vol. 3662 LNCS, pp. 172184. Springer.
Tamaki, H., & Sato, T. (1984). Unfold/fold transformations logic programs. ICLP,
pp. 127138.
Tseitin, G. S. (1968). complexity derivation propositional calculus. Slisenko,
A. O. (Ed.), Studies Constructive Mathematics Mathematical Logic II, pp. 115
125. Consultants Bureau, N.Y.
Turner, H. (2002). Polynomial-length planning spans polynomial hierarchy. JELIA,
pp. 111124.
van Fraassen, B. (1966). Singular terms, truth-value gaps free logic. Journal Philosophy, 63 (17), 481495.
Van Gelder, A. (1993). alternating fixpoint logic programs negation. Journal
Computer System Sciences, 47 (1), 185221.
Vlaeminck, H., Wittocx, J., Vennekens, J., Denecker, M., & Bruynooghe, M. (2010).
approximate method solving problems. Fisher, M., van der Hoek, W.,
Konev, B., & Lisitsa, A. (Eds.), JELIA, Lecture Notes Computer Science, pp.
326338. Springer.
Wittocx, J. (2010). Finite Domain Symbolic Inference Methods Extensions FirstOrder Logic. Ph.D. thesis, Department Computer Science, K.U.Leuven, Leuven,
Belgium.
Wittocx, J., Denecker, M., & Bruynooghe, M. (2010). Constraint propagation extended
first-order logic. CoRR, abs/1008.2121.
Wittocx, J., Marien, M., & Denecker, M. (2008). Approximate reasoning first-order logic
theories. Brewka, G., & Lang, J. (Eds.), KR, pp. 103112. AAAI Press.

124


