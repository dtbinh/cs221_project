Journal Artificial Intelligence Research 45 (2012) 731-759

Submitted 06/12; published 12/12

Tractable Set Constraints
Manuel Bodirsky

bodirsky@lix.polytechnique.fr

Ecole Polytechnique, LIX
(UMR 7161 du CNRS)
91128 Palaiseau, France

Martin Hils

hils@math.univ-paris-diderot.fr

Institut de Mathematiques de Jussieu
(UMR 7586 du CNRS)
Universite Paris Diderot Paris 7
UFR de Mathematiques
75205 Paris Cedex 13, France

Abstract
Many fundamental problems artificial intelligence, knowledge representation,
verification involve reasoning sets relations sets modeled
set constraint satisfaction problems (set CSPs). problems frequently intractable,
several important set CSPs known polynomial-time tractable.
introduce large class set CSPs solved quadratic time. class,
call EI, contains previously known tractable set CSPs, new
ones crucial importance example description logics. class EI set
constraints elegant universal-algebraic characterization, use show
every set constraint language properly contains EI set constraints already
finite sublanguage NP-hard constraint satisfaction problem.

1. Introduction
Constraint satisfaction problems computational problems where, informally, input
consists finite set variables finite set constraints imposed variables;
task decide whether assignment values variables
constraints simultaneously satisfied. Set constraint satisfaction problems special
constraint satisfaction problems values sets, constraints might,
instance, force one set includes another set x, one set x disjoint another
set y. constraints might ternary (or, generally, finite arity),
constraint intersection two sets x contained z, symbols
px X yq z.
systematically study computational complexity constraint satisfaction problems, turned fruitful approach consider constraint satisfaction problems
CSPpq set allowed constraints formed fixed finite set relations
R Dk (possibly infinite) common domain D. example, equals Q,
rational numbers, tu usual order rationals, CSPpq
problem deciding whether given set (binary) constraints form x
common solution rational numbers. way parametrizing conc
2012
AI Access Foundation. rights reserved.

fiBodirsky & Hils

straint satisfaction problem constraint language led many strong algorithmic
results (e.g., Bulatov & Dalmau, 2006; Idziak, Markovic, McKenzie, Valeriote, & Willard,
2010; Barto & Kozik, 2009; Bodirsky & Kutz, 2007; Bodirsky & Kara, 2009), many
powerful hardness conditions large classes constraint satisfaction problems (Schaefer,
1978; Bulatov, Krokhin, & Jeavons, 2005; Bulatov, 2003, 2006; Bodirsky & Kara, 2009).
set constraint language set relations R pP pNqqk common domain
P pNq set subsets natural numbers; moreover, require
relation R defined Boolean combination equations signature [, \, c,
0, 1, function symbols intersection, union, complementation, empty
full set, respectively. Details formal definition set constraint languages
found Section 3. Section 4, give many examples set constraint languages.
choice N notational convenience; could selected infinite set
purposes, e.g., Rn instead N, natural choice spatial reasoning. One may even
replace P pNq infinite Boolean algebra (see Theorem 28).
following, set constraint satisfaction problem (set CSP) problem form
CSPpq finite set constraint language . shown Marriott Odersky
set CSPs contained NP.
Drakengren Jonsson (1998) initiated search set CSPs solved
polynomial time. showed CSPpt, ||, uq solved polynomial time,

x holds iff x subset equal y;
x || holds iff x disjoint sets;
x holds iff x distinct sets.
showed CSPpq solved polynomial time relations
defined formulas form
x1

y1 _ _ xk yk _ x0 y0

x1

y1 _ _ xk yk _ x0 || y0

form

x0 , . . . , xk , y0 , . . . , yk necessarily distinct variables (Drakengren & Jonsson,
1998, Thm. 20). call set relations defined way Drakengren Jonssons set constraint language. easy see algorithm
present runs time quadratic size input. hand, show
contains relation defined x1 y1 _ x2 y2 relation defined
x1 x0 _ x2 x0 problem CSPpq NP-hard (Drakengren & Jonsson, 1998,
Thm. 22).
1.1 Contributions Outline.
present significant extension Drakengren Jonssons (1998) set constraint language (Section 4) whose CSP still solved quadratic time input size (Section 5); call set constraint language EI. Unlike Drakengren Jonssons set
732

fiTractable Set Constraints

constraint language, language contains ternary relation defined px X q z,
relation particular interest description logics discuss
below. Moreover, show extension EI contains finite sublanguage
NP-hard set CSP (Section 6), using concepts model theory universal
algebra. sense, present maximal tractable class set constraint satisfaction
problems.
algorithm based concept independence constraint languages
discovered several times independently 90s (Lassez & McAloon, 1989; Jonsson &
Backstrom, 1998; Marriott & Odersky, 1996, see Koubarakis, 2001; Broxvall, Jonsson,
& Renz, 2002; Cohen, Jeavons, Jonsson, & Koubarakis, 2000); however, apply
concept twice novel, nested way, leads two level resolution procedure
implemented run quadratic time. technique use prove correctness
algorithm important contribution paper, believe similar
approach applied many contexts; technique inspired already
mentioned connection universal algebra.
1.2 Application Areas Related Literature
mention three different contexts set constraints appeared literature.
1.2.1 Set Constraints Programming Languages.
Set constraints find applications program analysis; here, set constraint form
X , X set expressions. Examples set expressions 0 (denoting
empty set), set-valued variables, union intersection sets, expressions
form f pZ1 , Z2 q f function symbol Z1 , Z2 set expressions.
Unfortunately, worst-case complexity reasoning tasks considered
setting high, often EXPTIME-hard (for survey this, see Aiken, 1994).
recently, shown quantifier-free combination set constraints (without
function symbols) cardinality constraints (quantifier-free Pressburger arithmetic)
satisfiability problem NP (Kuncak & Rinard, 2007). logic (called QFBAPA)
interesting program verification (Kuncak, Nguyen, & Rinard, 2006).
1.2.2 Tractable Description Logics.
Description logics family knowledge representation formalisms used
formalize reason concept definitions. computational complexity
computational tasks studied various formalisms usually quite high.
However, last years series description logics, example EL, EL , Horn-FL0 ,
various extensions fragments (Kusters & Molitor, 2002; Baader, 2003; Baader,
Brandt, & Lutz, 2005; Krotzsch, Rudolph, & Hitzler, 2006), discovered
crucial tasks e.g. entailment, concept satisfiability knowledge base satisfiability
decided polynomial time.
Two basic assertions made EL
Horn-FL0 C1 ||C2 (there
C1 C2 ) C1 X C2 C3 (every C1 C2 C3 ), concept
names C1 , C2 , C3 . EI set constraints, latter treated
733

fiBodirsky & Hils

framework Drakengren Jonsson. None description logics tractable
knowledge base satisfiability problem contains EI set constraints.
1.2.3 Spatial Reasoning.
Several spatial reasoning formalisms (like RCC-5 RCC-8) closely related set constraint satisfaction problems. formalisms allow reason relations
regions; fundamental formalism RCC-5 (see, e.g., Jonsson & Drakengren, 1997),
one think region non-empty set, possible (binary) relationships containment, disjointness, equality, overlap, disjunctive combinations thereof. Thus,
exclusion empty set prominent difference set constraint languages studied Drakengren Jonsson (1998) contained class set constraint
languages considered RCC-5 fragments. see Section 3
CSP RCC-5 CSPs reducts set CSPs (Proposition 2).

2. Constraint Satisfaction Problems
use existing terminology logic model theory, convenient describe
constraint languages structures (see, e.g., Hodges, 1993). structure tuple
pD; f1, f2, . . . , R1, R2, . . . q set (the domain ), function
Dki (where ki called arity ), Ri relation D, i.e., subset
Dli (where li called arity Ri ). function assume
function symbol denote , relation Ri relation symbol
denote Ri . Constant symbols treated 0-ary function symbols.
set relation function symbols structure called signature ,
say -structure. signature contains relation symbols
function symbols, say relational structure. context
constraint satisfaction, relational structures called constraint languages,
constraint language 1 called sublanguage (or reduct) constraint language
relations 1 subset relations (and called expansion 1 ).
Let relational structure domain finite signature . constraint
satisfaction problem following computational problem, denoted CSPpq:
given finite set variables V conjunction finitely many atomic formulas
form Rpx1 , . . . , xk q, x1 , . . . , xk P V R P , satisfiable ; is,
exist assignment : V every constraint Rpx1 , . . . , xk q input
pspx1 q, . . . , spxk qq P R ?
mapping called solution instance CSPpq, conjuncts
called constraints. Note introduce constraint satisfaction problems
CSPpq finite constraint languages, i.e., relational structures finite relational
signature.

Example 1. problem CSPppQ; qq problem deciding whether given set
constraints form x solution simultaneously satisfies constraints.
734

fiTractable Set Constraints

3. Set Constraint Languages
section, give formal definitions set constraint languages. Let structure domain P pNq, set subsets natural numbers, signature
t[, \, c, 0, 1u,



[ binary function symbol denotes intersection, i.e., [S X;
\ binary function symbol union, i.e., \S Y;

c unary function symbol complementation, i.e., cS function maps
N NzS;
0 1 constants (treated 0-ary function symbols) denoting empty set
full set N, respectively.

H

Sometimes, simply write [ function [S \ function \S , i.e.,
distinguish function symbol respective function. use symbols
[, \ symbols X, prevent confusion meta-mathematical usages X
text.
set constraint language relational structure whose relations quantifier-free
definition S. always allow equality first-order formulas, equality symbol
always interpreted true equality relation domain structure.
write x abbreviation x [ x.
Example 2. ternary relation px, y, z q
definition z [ px [ q x [ S.

P P pN q3 | x [ z

(

quantifier-free

Theorem 1 (See Marriott & Odersky, 1996, Proposition 5.8). Let set constraint
language finite signature. CSPpq NP.
easy see NP-hard set CSPs, shown next example.
Example 3. Consider set constraint language contains eight relations

tpx, y, zq | x 1 _ 1 _ z 1u
tpx, y, zq | x 1 _ 1 _ z 1u
tpx, y, zq | x 1 _ 1 _ z 1u
tpx, y, zq | x 1 _ 1 _ z 1u
tpx, y, zq | x 1 _ 1 _ z 1u
tpx, y, zq | x 1 _ 1 _ z 1u
tpx, y, zq | x 1 _ 1 _ z 1u
tpx, y, zq | x 1 _ 1 _ z 1u .
set CSP relations well-known 3-SAT problem, NPcomplete (Garey & Johnson, 1978).
well-known structure pP pNq; \, [, c, 0, 1q Boolean algebra,
735

fiBodirsky & Hils

0 playing role false, 1 playing role true;
c playing role


;

[ \ playing role ^ _, respectively.

refer work Koppelberg (1989) background Boolean algebras.
confuse logical connectives connectives Boolean algebras, always
use symbols [, \, c instead usual function symbols ^, _, Boolean
algebras. facilitate notation, write x instead cpxq, x instead
p x q.
assume terms functional signature
t[, \, c, 0, 1u written


(inner) conjunctive normal form (CNF), i.e., ni1 nj 1 lij lij either
form x form x variable x. Note every term t[, \, c, 0, 1u rewritten equivalent term form, using usual laws Boolean algebras (Boole,
1847). allow special
case n 0 (in case becomes 1), special case
ni
ni 0 (in case j 1 lij becomes 0). refer ci : tlij | 1 j ni u
(inner) clause t, lij (inner) literal ci . say set inner clauses
satisfiable exists assignment V P pNq inner clauses,

union evaluation literals equals N (this case formula
n
i1 ci 1 satisfying assignment).
Example 4. Inequality x P pNq equivalently written py \ xq[px \ q 1;
formula, two inner clauses, positive negative inner literal.
assume quantifier-free formulas signature
t[, \, c, 0, 1u written

mi
(outer) conjunctive normal form (CNF), i.e.,
j 1 Lij Lij either
i1
form 1 (a positive (outer) literal ) form 1 (a negative (outer) literal ).
Again, well-known easy see every quantifier-free formula find
formula form equivalent every Boolean algebra. refer
Ci : tLij | 1 j mi u (outer) clause , Lij (outer) literal Ci .
Whenever convenient, identify set clauses.
Example 5. Consider formula px ^ z q _ px ^ z q. rewritten
px _ z q^px _ z q. subsequently replace inequality literals x
py \ xq [ px \ q 1 (see Example 4), arrive formula discussed
normal form: two outer clauses, one two positive outer literals,
two negative outer literals.
mentioned introduction, CSPs reducts RCC-5 (and therefore
many reducts RCC-8) formulated set CSPs. network satisfaction problem RCC-5 seen CSP following structure RCC-5 domain
P pNqztHu binary relations given follows: relation R RCC-5
exists quantifier-free t\, [, c, 0, 1u-formula px1 , x2 q ps1 , s2 q P R
s1 s2 non-empty, ps1 , s2 q true S. clear
finitely many inequivalent quantifier-free formulas language t\, [, c, 0, 1u,
hence RCC-5 finitely many relations.
736

fiTractable Set Constraints

Proposition 2. Let reduct RCC-5. exists set constraint language
CSPpq CSPpq problem.
Proof. Let 1 , . . . , n formulas define relations (which domain
P pNqztHu). Let structure domain P pNq relations R1 , . . . , Rn defined
1 , . . . , n S. is, difference additional element
tHu, appears none relations . prove every finite
conjunction atomic formulas form Ri px1 , . . . , xk q satisfiable
conjunction satisfiable . satisfiable clearly satisfiable
since induced substructure . Conversely, satisfiable ,
solution must property spxi q H, xi appear
constraint (since constraints force arguments non-empty). Hence, setting
spxi q non-empty subset N still solution, implies claim.
Proposition 2 shows class set CSPs contains class CSPs reducts
RCC-5. inclusion clearly strict: set CSPs cannot formulated
CSPs reducts RCC-5, since relations set constraint languages arbitrary
arity, reducts RCC-5 contain binary relations.

4. Horn-Horn Set Constraints
section, study Horn-Horn set constraints, class set constraints admits
intuitive syntactic description thus easy define. Universal algebraic
considerations class Section 4.2 lead us another class set constraints, called
EI introduced Section 4.3. class strictly contains class Horn-Horn set
constraints. universal algebraic description key maximality result
prove Section 6. tractability, set constraint languages EI allow
(linear-time) reduction satisfiability Horn-Horn clauses (see Proposition 22). note
classes set constraints (Horn-Horn EI) studied before.
4.1 Horn-Horn Relations
Definition 3. quantifier-free formula called Horn-Horn
1. every outer clause outer Horn, i.e., contains one positive outer literal,
2. every inner clause positive outer literals inner Horn, i.e., contains one
positive inner literal.
relation R P pNqk called
outer Horn defined conjunction outer Horn clauses;
inner Horn defined formula form pc1 [ [ ck q
ci inner Horn;

1

Horn-Horn defined Horn-Horn formula S.
Example 6. Inequality

Horn-Horn: recall may defined py \ xq[px \ yq 1.
737

fiBodirsky & Hils

Example 7. Using previous example, relation
easily seen Horn-Horn, too.
Example 8. ternary relation tpx, y, z q | x [
Horn-Horn definition x \ \ z 1.

tpx, y, u, vq | x _ u vu

zu, encountered above,

Proposition 4. Drakengren Jonssons set constraint language contains Horn-Horn
relations.
Proof. disjointness relation || definition x \ 1, inner Horn.
inequality relation Horn-Horn since inner clauses definition py \ xq[px \ q
1 one positive inner literal. inclusion relation x definition
\ x 1, inner Horn.
Horn-Horn preserved adding additional outer disequality literals outer
clauses, relations considered Drakengren Jonssons language Horn-Horn.
4.2 Universal Algebraic Preliminaries
see section, class Horn-Horn formulas preserved several
important functions defined set subsets natural numbers.
Definition 5.
Let : pP pNqq2 P pNq function maps pair sets pS1 , S2 q
set t2a | P S1 u t2a 1 | P S2 u;

denote Fin set finite non-empty subsets N, let F : P pNq P pFin q,
F pS q : tS0

| S0 finite non-emptyu ;

let G : N Fin bijection (since sets countable, bijection exists);
let e : P pNq P pNq defined
epS q tG1 pT q |

P F pS qu ;

let ei function defined eipx, q epipx, qq.
Intuitively, functions e ei designed forget unions (this
formalized Definition 34), preserving basic operations (see Lemma
11 Proposition 8 case e).
Definition 6. Let f : pP pNqqk P pNq function, R P pNql relation.
say f preserves R following holds: a1 , . . . , ak P pP pNqql
pf pa11, . . . , ak1 q, . . . , f pa1l , . . . , akl qq P R ai P R k. f preserve R,
say f violates R. say f strongly preserves R a1 , . . . , ak P pP pNqql
pf pa11 , . . . , ak1 q, . . . , f pa1l , . . . , akl qq P R ai P R k.
first-order formula defines relation R S, f preserves (strongly preserves)
R, say f preserves (strongly preserves) . Finally, g : pP pNqql P pNq
function, say f preserves (strongly preserves) g preserves (strongly
preserves)
(
graph g, i.e., relation px1 , . . . , xl , g px1 , . . . , xl qq | x1 , . . . , xl N .
738

fiTractable Set Constraints

Note injective function f preserves function g, strongly preserves
g.
Example 9. Consider function f : pP pNqq2 P pNq, px, q x \ y. f preserves
, since x \ x1 \ y1 whenever x x1 y1 y. hand, f strongly
preserve , shown f pN, Hq f pH, Nq.
Fact 7. mapping isomorphism S2 S.
Proof. mapping
inverted mapping sends N ta | 2a P
u, ta | 2a 1 P u . straightforward verify strongly preserves 0, 1, c, \, [.
Clearly, ipx, q H x

H.

Similarly, since natural numbers partitioned even odd numbers,
ipx, q N x N.
Let S1 S2 subsets N. verify preserves c show
ipcpS1 , S2 qq, definition equal ipS1 , S2 q, equals cpipS1 , S2 qq. Suppose
2a1 . Then:
P pS 1 , 2 q 1

P S1

a1 R S1
2a1 R ipS1, S2q
P ipS1, S2q

argument 2a1
even strongly preserves c.

1 analogous. Thus, preserves c. Since injective,

Let pS1 , S2 q pT1 , T2 q pP pNq2 . show ippS1 , S2 q\pT1 , T2 qq,
definition equal ipS1 \ T1 , S2 \ T2 q, equals ipS1 , S2 q \ ipT1 , T2 q.
2a1 before:
P ipS1 \ T1 , S2 \ T2 q a1

P pS1 \ T1q

2a1 P ipS1, S2q \ ipT1, T2q

argument 2a1 1 analogous. Thus, preserves
injective, even strongly preserves \.
verification

\.

Since

[ similar \.

Proposition 8. function e following properties.
e injective,

[,
x, y, z P P pNq x \
epxq \ epy q epz q.

e strongly preserves 1, 0,


z, x

739



y,



x,

fiBodirsky & Hils

Proof. verify properties one one. Since G bijective, epxq epy q
x finite subsets. case x y, hence e
injective. Thus, prove e strongly preserves 1, 0, [, suffices check e
preserves 1, 0, [.
Since G bijective, GpNq equals set finite subsets N,
hence epNq N, shows e preserves 1. compute epHq G1 pF pHqq
G1 pHq H.
Next, verify x, P P pNq epxq [ epy q epx [ q. Let P N
arbitrary. P epxq [ epy q Gpaq P F pxq X F py q. definition F
since Gpaq finite subset N, case Gpaq P F px [ q.
case P epx [ q, concludes proof e preserves [.
verify x \ z, x y, x, epxq \ epy q epz q. First
observe u, v N u v epuq epv q since e preserves [.
implies epxq \ epy q epz q. Since x x, a, b P x,
R y, b P y, b R x. ta, bu P F pz q, ta, bu R F pxq F py q. Hence,
G1 pta, buq P epz q, G1 pta, buq R epxq \ epy q. shows epz q epxq \ epy q.
Note particular e preserves , , ||. Moreover, epcpxqq cpepxqq:
follows preservation ||, since x||cpxq, therefore epxq||epcpxqq, equivalent
inclusion above. e strongly preserve [, 0, 1, therefore ei
strongly preserves [, 0, 1.
following direct consequence fact isomorphisms k
preserve Horn formulas ; since simple proof instructive follows,
give special case relevant here.
Proposition 9. Outer Horn relations preserved i.
Proof. Let conjunction outer Horn clauses variables V . Let tt0 1, t1
1, . . . , tk 1u outer clause . Let u, v : V P pNq two assignments satisfy
clause. Let w : V P pNq given x ipupxq, v pxqq. Suppose w satisfies
tj 1 1 j k. Since injective must tj 1 u v
1 j k, therefore neither assignment satisfies negative literals. Hence, u v
must satisfy t0 1. Since isomorphism S2 S, preserves particular
t0 1, hence w satisfies t0 1.
Proposition 10. Inner Horn relations strongly preserved e.






Proof. Observe x \ p j j q 1 equivalent x [ p j yj q j yj , strongly
preserved e since e strongly preserves [. clearly implies statement.
Note Proposition 9 Proposition 10 imply ei strongly preserves inner Horn
relations. later need following.

N, k 1. following equivalent.
epx1 q \ \ epxk q \ epy1 q \ \ epyl q 1.

exists k xi \ p j j q 1.

Lemma 11. Let x1 , . . . , xk , y1 , . . . , yl
1.
2.

740

fiTractable Set Constraints

3. exists k epxi q \ p


j

epyj qq 1.

0, j yjl 1 jl epyj q 1.
Proof. implication
p1q p2q, suppose every k ai P N
ai R Xi : xi \ p j j q. Let c G1 ta1 , a2 , . . . , ak u . k,


c R epxi q \ j l epyj q. see this, first observe ai P j l yj [ xi . Therefore,
ta1, . . . , ak u P jl F pyj q [ F pxiq k. conclude c R epx1q \ \ epxk q \
epy1 q \ \ epyl q.
implication p2q p3q follows directly Proposition 10. implication p3q
p1q trivial. second statement direct consequence Proposition 10.
k

Proposition 12. Every Horn-Horn relation preserved e i, particular
ei.
Proof. Suppose R Horn-Horn definition variables V . Since R
particular outer Horn, preserved Proposition 9.
verify R preserved e. Let u : V P pNq assignment
satisfies . is, u satisfies least one literal outer clause . suffices
show assignment v : V P pNq defined x epupxqq satisfies outer
literal. Suppose first outer literal positive; Horn-Horn,
form x \ y1 \ \ yl 1 form y1 \ \ yl 1, preserved e
Lemma 11.
Now, suppose outer literal negative, is, form x1 \ \ xk \ y1 \
\ yl 1 k 0. treat case k 1, case similar.
Suppose contradiction v px1 q \
\ vpxk q \ vpy1q \ \ vpyl q 1. Lemma 11,
exists k upxi q \ p j upy j qq 1. particular
upx1 q \ \ upxk q \ upy1 q \ \ upyl q 1, contradiction assumption u
satisfies .
4.3 EI Set Constraints
section introduce class EI set constraints, show strictly contains
Horn-Horn relations, give several examples non-examples. present
algorithmic reduction CSPs EI set constraints satisfiability finite sets
Horn-Horn clauses.
Definition 13. set relations quantifier-free definition
preserved operation ei denoted EI.
Remark. Note definition operation ei (Definition 5) involved bijection G
N Fin ; see later (Proposition 36 Proposition 37) class
EI independent precise choice G.
Recall Proposition 12 EI contains Horn-Horn relations. present
examples relations EI, examples relations EI
Horn-Horn.
741

fiBodirsky & Hils

Example 10. give example relation clearly EI. relation
R tpx, q | x \ 1u violated ei: consider S1 t2a | P Nu S2 t2a
1 | P Nu. pS1 , S2 q P R, since isomorphism S2
pipS1 , S1 q, ipS2 , S2 qq P R. Since neither ipS1 , S1 q ipS2 , S2 q ipS2 , S2 q
ipS1 , S1 q, get epipS1 , S1 qq \ epipS2 , S2 qq ep1q 1 Proposition 8. Therefore,
peipS1, S1q, eipS2, S2qq R R wanted show.
Example 11. relation R tpx, y, z q | px q _ py z qu preserved
ei: note p0, 1, 1q, p0, 0, 1q P R, eip0, 0q, eip1, 0q, eip1, 1q pairwise distinct
since ei injective.
Example 12. formula

p x [ xq
^ px [ yq
^ pv 1 _ u 1 _ x \ 1q
clearly Horn-Horn. However, relation defined formula EI:
px1, y1, u1, u2q und px2, y2, u2, v2q relation, neither ipx1, x2q ipy1, y2q
ipy1 , y2 q ipx1 , x2 q. Proposition 8, peipx1 , x2 q, eipy1 , y1 q, eipu1 , u2 q, eipv1 , v2 qq satisfies
formula. equivalent Horn-Horn formula, since formula preserved
i.
Example 13. formula ppx \ 1q _ pu \ v 1qq ^ px \ 1q ^ px \ 1q
Horn-Horn. However, preserved e i: reason one clauses
negative literal x \ 1, conjuncts tx \ 1u tx \ 1u. Therefore,
every tuple P R tuple eptq satisfies x \ 1 R well. Proposition 9,
R preserved i. case, authors suspect equivalent Horn-Horn
formula. generally, open whether exist formulas preserved e
i, equivalent Horn-Horn formula.
Corollary 14. class Horn-Horn relations proper subclass EI.
Proof. Proposition 12 shows EI contains Horn-Horn relations. Example 12 shows
inclusion strict.
prepare results viewed partial converse Proposition 12.
Definition 15. quantifier-free formula (in syntactic form described end
Section 3) called reduced every formula obtained removing outer literal
equivalent S.
note slightly different notion reduced formula introduced
Bodirsky, Chen, Pinsker (2010). variant using better suited
purposes.
Lemma 16. structure S, every quantifier-free formula equivalent reduced
formula.
742

fiTractable Set Constraints

Proof. clear every quantifier-free formula written formula CNF
form discussed Theorem 1. remove successively outer
literals long results equivalent formula.
first prove partial converse Proposition 9.
Proposition 17. Let reduced formula preserved i. outer clause
Horn.
Proof. Let V set variables . Assume contradiction contains outer
clause two positive literals, t1 1 t2 1. remove literal t1 1
clause C, resulting formula inequivalent , hence assignment
s1 : V P pNq satisfies none literals C except t1 1. Similarly,
assignment s2 : V P pNq satisfies none literals C except t2 1.
injectivity i, since strongly preserves c, [, \, 1, assignment : V P pNq
defined x ips1 pxq, s2 pxqq satisfy two literals t1 1 t2 1. Since
strongly preserves c, \, [, none literals C satisfied mappings
well, contradiction assumption preserved i.
Definition 18. Let V set variables, : V P pNq mapping.
function V P pNq form x epspxqq called core assignment.
Lemma 19. every quantifier-free formula exists formula inner
clauses inner Horn, satisfying core assignments.
preserved ei, set satisfying core assignments closed
ei.
Proof. Suppose outer clause C positive outer literal 1
contains inner clause c : x1 \ \ xk \ 1 \ \ l Horn, i.e., k 2.
replace outer literal 1 k literals t1 1, . . . , tk 1 ti obtained
replacing c xi \ 1 \ \ l .
claim resulting formula 1 set satisfying core assignments.
Observe xi \ 1 \ \ l c, hence ti 1 implies 1. arbitrary satisfying
assignment 1 satisfies either one positive outer literals ti 1, case
observation shows satisfies , satisfies one outer literals C,
case satisfies literal . Hence, 1 implies . Conversely, let
satisfying core assignment . satisfies literal C 1,
satisfies literal 1 , satisfies 1 . Otherwise, must satisfy 1, hence
spx1 q\ \ spxk q\ spy1 q\ \ spyl q 1. Since core assignment, Lemma 11 implies
exists k spxi q \ spy1 q \ \ spyl q 1. satisfies 1 .
Suppose outer clause C negative outer literal 1
contains inner clause c : x1 \ \ xk \ 1 \ \ l Horn, i.e., k 2.
replace clause C k clauses C1 , . . . , Ck Ck obtained C
replacing c xi \ 1 \ \ l .
claim resulting formula 1 set satisfying core assignments.
Observe x1 \ \ xk \ 1 \ \ l 1 implies xi \ 1 \ \ l 1, every
k. observation shows arbitrary assignment assignment 1 .
743

fiBodirsky & Hils

Conversely, let satisfying core assignment 1 . satisfies one literals
C 1, satisfies . Otherwise, must satisfy xi \ 1 \ \ l 1
k, Lemma 11 satisfies x1 \ \ xk \ 1 \ \ l 1.
perform replacements obtain formula 1 inner clauses
Horn; formula satisfies requirements first statement lemma.
prove second statement, let u, v : V P pNq two satisfying core assignments
1 . Since 1 satisfying core assignments, u v satisfy .
mapping w : V P pNq given x eipupxq, v pxqq core assignment,
ei preserves , mapping w satisfies . Since 1 core assignments,
w satisfying assignment 1 , proves statement.
single technical condition guarantees, extra condition
(see Proposition 21) formulas satisfying certain universl algebraic property HornHorn. allow us perform reduction CSP associated (finite) set
constraint languages EI satisfiability Horn-Horn clauses.
Definition 20. quantifier-free formula (in syntactic form described end
Section 3) called strongly reduced every formula obtained removing outer
literal set satisfying core assignments S.
Proposition 21. Let strongly reduced formula whose inner clauses Horn.
set satisfying core assignments closed ei, Horn-Horn.
Proof. Let V set variables . suffices show clauses outer
Horn. Assume contradiction contains outer clause two positive literals,
t1 1 t2 1. remove literal t1 1 clause C, resulting formula
strictly less satisfying core assignments; shows existence core assignment
s1 : V P pNq satisfies none literals C except t1 1. Similarly, exists
core assignment s2 : V P pNq satisfies none literals C except t2 1.
assumption, inner clauses t1 t2 Horn. claim assignment
: V P pNq defined x eips1 pxq, s2 pxqq satisfy clause C. Since ei
strongly preserves inner Horn clauses, satisfy t1 1 _ t2 1.
reasons satisfy literals C; contradicts assumption
satisfying core assignments preserved ei.
Satisfiability Horn-Horn clauses computational problem decide whether,
given finite set Horn-Horn clauses, satisfying assignment S.
Proposition 22. Let finite set constraint language EI. CSPpq
reduced linear time satisfiability Horn-Horn clauses.
Proof. Let instance CSPpq, let V set variables appear
. constraint Rpx1 , . . . , xk q , let R definition R S.
Lemma 19, exists formula R satisfying core assignments R
inner clauses Horn; moreover, since R preserved ei, lemma
asserts set satisfying core assignments R preserved ei.
assume without loss generality R strongly reduced; seen similarly
Lemma 16. Proposition 21, formula R Horn-Horn.
744

fiTractable Set Constraints

Let set Horn-Horn clauses formulas R px1 , . . . , xk q obtained constraints Rpx1 , . . . , xk q described manner. claim satisfiable instance
CSPpq satisfiable. follows fact constraint
Rpx1 , . . . , xk q , formulas R R satisfying core assignments,
R R preserved ei (for R follows Proposition 12),
particular function x eipx, xq.
Note Proposition 22 reduce satisfiability EI satisfiability proper
subclass Horn-Horn set constraints: general Horn-Horn set constraints allow
inner clauses negative outer literals Horn, reduction produces HornHorn clauses inner clauses Horn.

5. Algorithm Horn-Horn Set Constraints
present algorithm takes input set Horn-Horn clauses decides
satisfiability pP pNq; \, [, c, 0, 1q time quadratic length input.
Proposition 22, section therefore conclude proof CSPpq tractable
relations EI.
mentioned introduction, algorithm based two procedures,
resolution-like. inner procedure essentially well-known positive unit resolution
procedure Horn-SAT, outer procedure basically algorithm
used literature independence constraint satisfaction (see, e.g., Jonsson &
Backstrom, 1998; Koubarakis, 2001; Broxvall et al., 2002; Cohen et al., 2000). contribution section way nest two algorithms obtain polynomial-time
decision procedure satisfiability Horn-Horn clauses.
start discussing first procedure algorithm, call inner
resolution algorithm. case Boolean positive unit resolution (Dowling & Gallier,
1984) one implement procedure Inner-Res runs linear time
input size.
Lemma 23. Let finite set inner Horn clauses. following equivalent.
1.



1 satisfiable S.

2. Inner-Respq Figure 1 accepts.
3.



1 solution whose image contained


tH, Nu.

Proof. obvious 1 unsatisfiable Inner-Respq rejects; fact,

inner clauses c derived Inner-Res , formula c 1 logically implied

1. Conversely, algorithm accepts set eliminated variables
N remaining variables H, satisfies clauses: removed clauses
positive literal satisfied, remaining clauses least one negative literal
final stage algorithm, clauses negative literals final stage
algorithm satisfied.




proof previous lemma shows 1 satisfiable
1 satisfiable two-element Boolean algebra. see following,
745

fiBodirsky & Hils

Inner-Res()
// Input: finite set inner Horn clauses
// Accepts iff 1 satisfiable
entire algorithm:
contains empty clause, reject.
Repeat := true
Repeat = true
Repeat := false
contains positive unit clause txu
Repeat := true
Remove clauses literal x occurs.
Remove literal x clauses.
End
Loop
Accept



Figure 1: Inner Resolution Algorithm.
holds generally (and inner Horn clauses). following
well-known, shown proof given Koppelberg (1989)
weaker Proposition 2.19 there. give proof convenience reader.
Fact 24. Let t1 , t2 terms

t[, \, c, 0, 1u. following equivalent:

1 ^ t2 1 satisfiable two-element Boolean algebra;
t1 1 ^ t2 1 satisfiable Boolean algebras;
t1 1 ^ t2 1 satisfiable Boolean algebra;
t1 1 ^ t2 1 satisfiable finite Boolean algebra.

1. t1
2.
3.
4.

Proof. Obviously, (1) implies (2), (2) implies (3).
(3) implies (4), assume t1 1 ^ t2 1 satisfying assignment
Boolean algebra C. Let x1 , . . . , xn variables occur t1 t2 , let xi ci
satisfying assignment. t1 1 ^ t2 1 satisfiable Boolean sub-algebra
n
C1 C generated tc1 , . . . , cn u, C1 finite (it 2p2 q elements).
(4) implies (1), first note finite Boolean algebra isomorphic Boolean
algebra pP pX q; [, \, c, 0, 1q subsets finite set X. x P X, consider map hx :
P pX q t0, 1u, hpY q : 1 x P , hpY q 0 otherwise. hx homomorphism
Boolean algebras. particular, shows every non-zero element finite
Boolean algebra C, homomorphism h C two-element Boolean algebra
hpaq 0. suppose (4), assume t1 1 ^ t2 1 satisfying
assignment finite Boolean algebra C. Let c element denoted t2 C
assignment, c 1. let h homomorphism C t0, 1u
hpcq 0, i.e. hpcq 1. construction, image satisfying assignment h
satisfying assignment t1 1 ^ t2 1 t0, 1u.
746

fiTractable Set Constraints

statement t1 1 instead t1 1 ^ t2 1 given Proposition
2.19 (Koppelberg, 1989). Fact 24 following consequence crucial way
use inner resolution procedure algorithm.
Lemma 25. Let finite set inner Horn clauses. following equivalent:
1. Inner-RespYtx1 , . . . , xk , y0 , . . . , yl uq rejects.


1 S.


Proof.
1 implies x1 \ \ xk \ 1 \ \ l 1

1 ^ x1 \
\ xk \ y1 \ \ yl 1 unsatisfiable S. Fact 24, case
1 ^ x1 \ \ xk \ 1 \ \
1 unsatisfiable 2-element
l
Boolean algebra, case 1 ^ x1 \ \ xk \ 1 \ \ l 0
2.

1 implies x1 \ \ xk \ 1 \ \ l

unsatisfiable two-element Boolean algebra. seen Lemma 23,
turn holds Inner-RespYtx1 1, . . . , xk 1, y1 1, . . . , yl 1uq rejects.
Outer-Res()
// Input: finite set Horn-Horn clauses
// Accepts iff satisfiable pP pNq; [, \, c, 0, 1q
entire algorithm:
contains empty clause, reject.
Repeat := true
Repeat = true
Repeat := false
Let set inner Horn clauses terms
positive unit clauses tt 1u .
Inner-Res rejects , reject.
negative literal 1 clauses
inner clause tx1 , . . . , xk , 1 , . . . , l u
Call Inner-Res
tx1 1, . . . , xk 1, y0 1, . . . , yl 1u
Inner-Res rejects remove clause
End
clauses removed,
Remove outer literal 1 clause
Repeat := true
End
Loop
Accept

Figure 2: Outer Resolution Algorithm.
Theorem 26. algorithm Outer-Res Figure 2 decides satisfiability sets HornHorn clauses quadratic time.
Proof. first argue algorithm rejects , indeed solution. First
note whole argument, set clauses satisfying tuples
747

fiBodirsky & Hils

(i.e., corresponding formulas equivalent): Observe negative literals get
removed clauses, negative literal 1 gets removed clause
Inner-Res rejects tx1 1, . . . , xk 1, y0 1, . . . , yl 1u inner clause
tx1, . . . , xk , y1, . . . , yl u t. Lemma 25, Inner-Res rejects Ytx1 1, . . . , xk 1, y0
1, . . . , yl 1u implies x1 \ \ xk \ 1 \ \ l 1. Hence, positive
unit clauses imply 1 therefore literal 1 removed clause
without changing set satisfying tuples. algorithm rejects either Inner-Res
rejects derives empty clause. cases clear satisfiable.
Thus, suffices construct solution algorithm accepts. Let set
inner clauses terms positive unit clauses final stage, algorithm
accepts. remaining negative outer literal tt 1u remaining inner clause
tx1 , . . . , xk , 1 , . . . , l u exists assignment V P pNq satisfies
Ytx1 \ \ xk \ 1 \ \ l 1u: otherwise, Lemma 25, inner resolution algorithm
would rejected tx1 1, . . . , xk 1, y0 1, . . . , yl 1u, would removed
inner clause t. Let D1 , . . . , Ds enumeration remaining inner clauses
appear remaining negative outer literals.
Write s-ary operation defined px1 , . . . , xs q ipx1 , ipx2 , . . . , ipxs1 , xs q qq
(where Fact 7). claim : V P pNq given
x pD1 pxq, . . . , Ds pxqq

satisfies clauses . Let C clause . assumption, final stage
algorithm, clause C still non-empty. note since formulas input
Horn-Horn, contain one positive literal. holds particular C,
therefore distinguish following cases:
final state algorithm, C still contains negative literal 1. Since 1
removed, remaining inner clause tx1 , . . . , xk , 1 , . . . , l u
t. Observe spx1 q \ \ spxk q \ spy1 q \ \ spyl q 1 Dj px1 q \
\ Dj pxk q \ Dj py1q \ \ Dj pyl q 1 1 j s. Hence, since
px1 q \ \ pxk q \ py1 q \ \ pyl q 1, satisfies 1. shows
satisfies C.
negative literals removed C algorithm. positive
literal t0 1 C inner clauses t0 Horn. part
, therefore t0 1 satisfied s. Indeed, assumption assignments Dj
satisfy , preserved i.
conclude solution . inner resolution algorithm linear time
complexity; outer resolution algorithm performs linear number calls
inner resolution algorithm, straightforward implement necessary data
structures outer resolution obtain running time quadratic input
size.
Combining Proposition 22 Theorem 26, obtain following.
Theorem 27. Let finite set constraint language EI. CSPpq
solved quadratic time.
748

fiTractable Set Constraints

6. Maximal Tractability
section show class EI maximal tractable set constraint language.
specifically, let set constraint language strictly contains EI relations.
show contains finite set relations 1 already problem
CSPp1 q NP-hard (Theorem 40).
6.1 Universal-Algebraic Approach
proof use so-called universal-algebraic approach complexity constraint satisfaction problems, requires re-formulate set CSPs constraint
satisfaction problems -categorical structures. detailed introduction
universal-algebraic approach -categorical structures (see Bodirsky, 2012). structure
countable domain called -categorical countable structures satisfy
first-order sentences isomorphic (see, e.g., Hodges, 1993).
theorem Ryll-Nardzewski, countable signatures, equivalent requiring
every relation preserved automorphisms1 first-order definable
(see, e.g., Hodges, 1993). useful consequence -categorical structure , whenever two tuples c pc1 , . . . , cn q pd1 , . . . , dn q satisfy
first-order formulas, automorphism maps c d.
example -categorical structure pQ; q (by Cantors theorem), nonexample given pZ; q. Note pQ; q pZ; q CSP; indeed, two
infinite linear orders share CSP, since even finite substructures.
characterisation infinite structures -categorical structure
CSP given Bodirsky, Hils, Martin (2011). Empirically,
observed constraint satisfaction problems studied temporal spatial
reasoning typically called qualitative formulated
-categorical template.
Set constraint languages general -categorical (this follows easily
mentioned theorem Ryll-Nardzewski). However, every set CSP formulated
CSP -categorical structure. see this, first recall basic facts
Boolean algebras. countable atomless2 Boolean algebras isomorphic (Koppelberg,
1989, Corollary 5.16; see Hodges, 1993, Example 4 page 100). Let denote
countable atomless Boolean algebra, let denote domain A. Again, use [
\ denote join meet A, respectively. Since axioms Boolean algebras
property atoms written first-order sentences, follows
-categorical. structure B quantifier elimination every first-order formula
B equivalent quantifier-free formula. well-known quantifier elimination
(see Hodges, 1993, Exercise 17 page 391). make use following.
Theorem 28 (Marriott & Odersky, 1996, Corollary 5.7). quantifier-free formula satisfiable infinite Boolean algebra satisfiable infinite Boolean
algebras.
1. isomorphism structure called automorphism .
2. atom Boolean algebra element x 0 x X
0. Boolean algebra contains atoms, called atomless.

749

x

fiBodirsky & Hils

particular, B infinite Boolean algebra 1 , . . . , n quantifier-free
formulas signature t[, \, c, 0, 1u, relational structure signature tR1 , . . . , Rn u Ri n defined B, CSPpq
depend choice B.
fundamental concept complexity theory constraint satisfaction problems
notion primitive positive definitions. first-order formula called primitive positive
(pp) form
Dx1, . . . , xn p1 ^ ^ mq
formula form Rpy1 , . . . , yl q form y1 y2 ,
R relation symbol y1 , y2 , . . . , yl either free variables tx1 , . . . , xn u.
say k-ary relation R Dk primitive positive definable (pp definable)
-structure domain iff exists primitive positive formula px1 , . . . , xk q
k free variables x1 , . . . , xk tuple pb1 , . . . , bk q R pb1 , . . . , bk q
true .
Example 14. relation tpx, q P P pNq2 | x u pp definable pP pNq; S, q
tpx, y, z q | x [ z u. pp definition px, x, q ^ x (the definition even
quantifier-free).
Example 15. relation tpx1 , x2 , x3 , q P P pNq4 | x1 [ x2 [ x3 u pp definable
pP pNq; q tpx, y, z q | x [ z u. pp definition Du pS px1 , x2 , uq ^
pu, x3 , qq.
every relation structure preserved operation f , f called
polymorphism . Note polymorphisms preserve relations pp
definition . following shown finite domain constraint satisfaction
Bulatov et al. (2005); easy proof works infinite domain constraint satisfaction.
Lemma 29. Let R relation primitive positive definition structure .
CSPpq CSP expansion relation R polynomial-time equivalent.
following theorem one reasons useful work -categorical
templates (when possible).
Theorem 30 (Bodirsky & Nesetril, 2006). Let -categorical structure. R
primitive positive definable R preserved polymorphisms .
previous next result together used translate questions
primitive positive definability
purely operational questions. Let set, let Opnq
pnq set operations finite arity.
Dn D, let 8
n1
p
n
q
operation P called projection fixed P t1, . . . , nu n-tuples
px1, . . . , xnq P Dn identity px1, . . . , xnq xi. composition k-ary
operation f k operations g1 , . . . , gk arity n n-ary operation defined

pf pg1, . . . , gk qqpx1, . . . , xnq

f g1px1, . . . , xnq, . . . , gk px1, . . . , xnq .
750

fiTractable Set Constraints

Definition 31. say F locally generates f : Dn every finite subset
operation g : Dn obtained operations F
projection maps composition f paq g paq P .
Theorem 32 (see Szendrei, 1986, Corollary 1.9; Bodirsky, 2012, Proposition 5.2.1). Let
F set operations domain D. operation f : Dk preserves
finitary relations preserved operations F F locally generates
f.
set automorphisms structure denoted Autpq. following,
always consider sets operations F contain AutpAq, therefore make following
convention. F O, say F generates f P F AutpAq locally generates f .
6.2 EI Set Constraints Atomless Boolean Algebra
previous subsection seen set CSPs formulated CSPs
-categorical structures. section, describe -categorical templates
correspond set CSPs EI set constraints. order so, define analogs
operations e i, defined instead P pNq.
Proposition 33. isomorphism A2 A.
Proof. straightforward verify A2 countable atomless Boolean algebra.

Motivated properties e described Lemma 11, make following definition.
Definition 34. Let B B1 two arbitrary Boolean algebras domains B B 1 ,
respectively, let g : B B 1 function strongly preserves [, 0, 1. say
g forgets unions k 1, l 0, x1 , . . . , xk , y1 , . . . , yl P B
epx1 q \ \ epxk q \ epy1 q \ \ epyl q 1
exists k xi \ y1 \ \ yl

1.

Proposition 35. exists injection e : strongly preserves
A, forgets unions.

[, 0, 1

Proof. construction e standard application Konigs tree lemma categorical structures (see, e.g., Bodirsky & Dalmau, 2012, Lemma 2); suffices show
injection f every finite induced substructure B f
strongly preserves [, 0, 1, forgets unions.
let B finite substructure A, let B domain B. Let C
pP pB q; [, \, c, 0, 1q Boolean algebra subsets B. claim g : B P pB q
given g p1q 1 g pxq tz | z 0 ^ z B xu x 1
preserves 0 1: definition;
751

fiBodirsky & Hils

preserves

[: x, P B (including case x 1 1)
g pxq [C g py q tz | z 0 ^ z B x ^ z B u
(
z | z 0 ^ z B px [B q
g p x [B q ;

injective: x,
x y;
strongly preserves

P B gpxq gpyq, x B B x, hence
[: follows previous two items;

forgets unions: shown analogously proof Lemma 11.






Indeed, one xi \ y1 \ \ yl 1 iff xi B j yj iff xi [ j yj j yj iff


g pxi q[ j g pyj q j g pyj q iff g pxi q\ g py1 q\ \ g pyl q 1. Thus, xi \ y1 \ \ yl 1
1 k implies g px1 q \ \ g pxk q \ g py1 q \ \ g pyl q 1.
prove converse, use finite Boolean algebra B may identified
pP pAq; [, \, c, 0, 1q finite set A. Xi : xi \ y1 \ \ yl 1 1, . . . , k,
may choose ai P AzXi , i.e. ai P j yj [ xi , 1, . . . , k. Let C : ta1 , . . . , ak u
A, C P B. construction, k one tC u R g pxi q \ g py1 q \ \ g pyl q.
particular, follows g px1 q \ \ g pxk q \ g py1 q \ \ g pyl q 1.
Clearly, embedding h C A. f : hpg q homomorphism
B forgets unions.
Proposition 36. Let quantifier-free formula signature t[, \, c, 0, 1u.
e preserves e preserves A. Moreover, every operation
strongly preserves [, 0, 1 forgets unions generates e, generated
e.
Proof. Let tuple elements A. Clearly, exists tuple b elements
P pNq b satisfy set quantifier-free formulas; follows
fact every finite Boolean algebra Boolean algebra subsets finite set.
observe whether tuple epbq satisfies quantifier-free formula
depends , Lemma 11. Since e strongly preserves [, 0, 1, forgets unions,
true quantifier-free formulas hold epaq. Hence, e preserves
e preserves S.
prove second part statement, use Theorem 32. Suppose c
tuples (of length) elements satisfy quantifier-free
formulas. Since quantifier-elimination, follows c satisfy firstorder formulas A. consequence theorem Ryll-Nardzewski mentioned

beginning Section 6.1, exists automorphism maps c d.
observations Theorem 32, implies operations strongly preserve
[, 0, 1, forget unions generate other.
r operation px, q epipx, qq.
Let ei
752

fiTractable Set Constraints

Proposition 37. Let quantifier-free formula signature t[, \, c, 0, 1u.
r preserves A. Moreover, every binary operation
ei preserves ei
r generated
g strongly preserves [, 0, 1, forgets unions generates ei,
r
ei.
Proof. arguments similar ones given proof Proposition 36. a1
a2 n-tuples elements A, n-tuples b1 , b2 elements P pNq
pa1 , a2 q pb1 , b2 q satisfy set quantifier-free formulas. Whether
eipb1 , b2 q satisfies quantifier-free formula depends , ei strongly preserves [,
r pa1 , a2 q, ei
r preserves
0, 1, forgets unions. holds ei
ei preserves S.
proof second part statement identical one Proposition 36.

6.3 Central Argument
give central argument maximal tractability EI, stated universalalgebraic language. say operation Ak depends argument
P t1, . . . , k u pk 1q-ary operation f 1 x1 , . . . , xk P
f px1 , . . . , xk q f 1 px1 , . . . , xi1 , xi

1 , . . . , xk

q.

equivalently characterize k-ary operations depend i-th argument
requiring x1 , . . . , xk P x1i P
f px1 , . . . , xk q f px1 , . . . , xi1 , x1i , xi

1 , . . . , xk

q.

following general fact injective maps.
Lemma 38. Let f : Ak function depends arguments,
locally generated set injective operations F. f injective.
Proof. first prove every term px1 , . . . , xn q formed operations F
variables x1 , . . . , xn every variable appears least defines injective
map. prove induction term structure. case n 1
x1 nothing show. Otherwise, form f pT1 , . . . , Tk q k-ary f P F
Tj Tj pxi1 , . . . , ximpj q q j k term operations F variables
xi1 , . . . , ximpj q appears least Tj . suppose a1 , . . . , P
b1 , . . . , bn P pa1 , . . . , q pb1 , . . . , bn q. want show ai bi
n. Since f injective must Tj pai1 , . . . , aimpj q q Tj pbi1 , . . . , bimpj q q
j k. Since every variable x1 , . . . , xn appears least once, variable
xi must appear Tj , j k. Since Tj defines injective operation inductive
assumptions, must ai bi . follows defines injective map.
suppose f operation locally generated F depends
arguments. Thus, ci1 , . . . , cin di f pci1 , . . . , cin q
f pci1 , . . . , cii1 , di , cii 1 , . . . , cin q. Let a1 , . . . , , b1 , . . . , bn P f pa1 , . . . , q
f pb1 , . . . , bn q. show a1 b1 , . . . , bn . Since f locally generated
753

fiBodirsky & Hils

F, exists term px1 , . . . , xn q composed variables x1 , . . . , xn operations F pe1 , . . . , en q f pe1 , . . . , en q elements e1 , . . . , en
set ta1 , . . . , , b1 , . . . , bn , c11 , . . . , cnn , d1 , . . . , dn u. i, variable xi must appear
px1 , . . . , xn q pci1 , . . . , cin q pci1 , . . . , cii1 , di , cii 1 , . . . , cin q. Hence, argument
beginning proof shows px1 , . . . , xn q defines injective map,
therefore a1 b1 , . . . , bn . shown f injective.
r u. either tf u generates ei,
r f
Theorem 39. Let f operation generated tei
generated teu.

r u.
Proof. show statement theorem, let f k-ary operation generated tei
sake notation, let x1 , . . . , xl arguments f depends, l k.
Let f 1 : Al operation given f 1 px1 , . . . , xl q f px1 , . . . , xl1 , xl , xl , . . . , xl q.
Observe f 1 depends arguments, locally generated injective operations;
Lemma 38, f 1 injective. Since f 1 generated operations preserve 0, 1,
[, f 1 preserves them. f 1 injective, even strongly preserves 0, 1, [.
Consider first case l 1, i.e., f 1 unary. finite subsets A,
operation f 1 equals automorphism A, f generated AutpAq
nothing show. assume otherwise; is, assume finite set
P AutpAq f 1 pxq apxq x P S. claim f 1 forgets
unions. see this, let u1 , . . . , um , v1 , . . . , vn f 1 pu1 q \ \ f 1 pum q \
u, term pxq composed
f 1 pv1 q \ \ f 1 pvn q 1. Since f 1 generated tei
r
ei, automorphisms A, single variable x f 1 pxq pxq
x P tu1 , . . . , um , v1 , . . . , vn u. choice S, term cannot composed
automorphisms alone, hence must P AutpAq operational terms T1 , T2
r f 1 pxq apei
r pT1 pxq, T2 pxqqq
composed automorphisms ei
r
x P S. ei forgets unions, exists k T1 pui q\ T1 pv1 q\ \ Tl pvn q 1.
Since T1 strongly preserves [, means ui \ v 1 \ \ v n 1 (see proof
Proposition 10), wanted show. Proposition 36 follows f 1
generated e. f generated e well.
Next, consider case l 1. Let g binary operation defined g px, q
1
f px, y, . . . , q. functions depends arguments, cannot generated
automorphisms alone. Hence, term form
r pT1 px, q, T2 px, qqq
px, q apei


P AutpAq,
r automorphisms A,
T1 T2 operational terms composed ei,
two variables x y,

g px, q px, q px, q P tu1 , . . . , um , v1 , . . . , vn u.

claim g forgets unions. Assume g pu1 q\ \ g pum q\ g pv1 q\ \ g pvn q 1
elements u1 pu11 , u21 q, . . . , um pu1m , u2m q, v1 pv11 , v12 q, . . . , vn pvn1 , vn2 q A2 .
r forgets unions, exists k T1 pui q\ T1 pv1 q\ \ T1 pvn q 1
Since ei
754

fiTractable Set Constraints

T2 pui q\T2 pv1 q\ \T2 pvn q 1. Suppose first T1 depends arguments. T1
defines injective operation strongly preserves [. follows ui \ v 1 \ \ v n 1
A2 since equations inner Horn. argue similarly T2 depends
arguments, cases established g forgets unions. Suppose
T1 T2 depend arguments. Consider first case
T1 depends first argument. function x T1 px, xq injective
strongly preserves [, T1 pui q \ T1 pv1 q \ \ T1 pvn q 1 derive
u1i \ v11 \ \ vn1 1 holds A. case, T2 must depend second argument,
since depends arguments. therefore u2i \ v12 \ \ vn2 1 holds
A. situation T1 depends second argument T2 depends
r
first argument analogous. g forgets unions. Proposition 37, g generates ei.
r
Consequently, f generates ei.
Theorem 40. Let set constraint language. Suppose contains relations
EI, contains relation EI. finite sublanguage 1
CSPp1 q NP-hard.
Proof. R1 , R2 , . . . relations , let 1 , 2 , . . . quantifier-free formulas
define R1 , R2 , . . . pP pNq; \, [, c, 0, 1q. Let R1A , R2A , . . . relations defined
1 , 2 , . . . A, let relational structure domain exactly
r contains
relations. Proposition 37, contains relation preserved ei,
r Consider set F polymorphisms .
relations preserved ei.
Theorem 32, operations F locally generated eri.
set F contain eri, since would contradict Theorem 32 fact
r Since F locally closed, follows
contains relation preserved ei.
Theorem 39 operations f P F generated e. relation
tpx, y, zq | x z _ x zu preserved operations F (we already seen
relation Example 5), hence pp definable Theorem 30. relation
NP-complete CSP (Bodirsky & Kara, 2008). Let 1 reduct contains
exactly relations appear pp definition tpx, y, z q | x z _ x z u
. Clearly, finitely many relations; denote corresponding relation
symbols 1 . Lemma 29, CSPp1 q NP-hard.
establishes hardness CSPpq: let 1 1 -reduct . claim
CSPp1 q CSPp1 q computational problem. show
conjunction atomic 1 -formulas satisfiable 1 true 1 .
Replacing atomic 1 -formula quantifier-free definition, follows
Theorem 28.

7. Concluding Remarks
introduced powerful set constraint language EI set constraints,
particular contains Horn-Horn set constraints previously studied tractable set
constraint languages. Constraint satisfaction problems EI solved polynomial
even quadratic time. tractability result complemented complexity result
shows tractability EI set constraints best-possible within large class
set constraint languages.
755

fiBodirsky & Hils

would remark algorithm test whether given finite set
constraint language (where relations language given quantifier-free formulas
signature t\, [, c, 0, 1u) contained EI. means so-called metaproblem EI set constraints decided effectively.
Proposition 41. algorithm test whether given quantifier-free formula
signature t\, [, c, 0, 1u defines relation EI.
Proof. clear effectively transformed normal form described
Section 3, assume conjunction outer clauses,
atomic formula form 1 inner conjunctive normal form.
Let n number variables . test two n-tuples u1 , u2
elements P pNq satisfy , n-tuple eipu1 , u2 q satisfies well. Note
whether tuple satisfies depends Boolean algebra generated
entries tuple S. Boolean algebra generated n elements size
n
22 ; therefore, finitely many cases check. pair Boolean
algebras generating tuples u1 , u2 , check whether eipu1 , u2 q satisfies follows.
Lemma 11, eipu1 , u2 q satisfies atomic formula 1 every inner clause
x1 \
\ xk \ epy1q \ \ epy1q exists k ipu1, u
2 q satisfies
xi \ j j 1. turn true u1 u2 satisfy xi \ j j 1.
truth value non-atomic formulas tuple eipu1 , u2 q computed
truth value atomic formulas usual way.

Finally would remark one analogously obtain tractability
class constraints inner clauses positive outer literals dual Horn
(i.e., one negative literal). statements proofs respective result
obtained dualizing following formal sense: dual relation R
definable Boolean algebra relation tcptq | P Ru. dual k-ary operation
f domain operation px1 , . . . , xk q cpf pcpx1 q, . . . , cpxk qqq. proofs
translate literally proofs dualized versions statements.

Acknowledgments
extended abstract article appeared proceedings IJCAI11 (Bodirsky, Hils,
& Krimkevitch, 2011)3 . want thank Francois Bossiere pointed mistakes
conference version paper. One mistake concerned reduction CSP
languages EI satisfiability Horn-Horn clauses; concerned problem
previous proof Theorem 26.
Manuel Bodirsky received funding ERC European Communitys
Seventh Framework Programme (FP7/2007-2013 Grant Agreement no. 257039).
3. third author conference version left author team preparation journal version.

756

fiTractable Set Constraints

References
Aiken, A. (1994). Set constraints: Results, applications, future directions. Proceedings
Second Workshop Principles Practice Constraint Programming,
pp. 326335.
Baader, F. (2003). Least common subsumers specific concepts description logic
existential restrictions terminological cycles. Proceedings International
Joint Conferences Artificial Intelligence (IJCAI), pp. 319324.
Baader, F., Brandt, S., & Lutz, C. (2005). Pushing EL envelope. International Joint
Conferences Artificial Intelligence (IJCAI), pp. 364369.
Barto, L., & Kozik, M. (2009). Constraint satisfaction problems bounded width.
Proceedings Annual Symposium Foundations Computer Science (FOCS),
pp. 595603.
Bodirsky, M. (2012). Complexity classification infinite-domain constraint satisfaction.
Memoire dhabilitation diriger des recherches, Universite Diderot Paris 7. Available
arXiv:1201.0856.
Bodirsky, M., Chen, H., & Pinsker, M. (2010). reducts equality primitive
positive interdefinability. Journal Symbolic Logic, 75 (4), 12491292.
Bodirsky, M., & Dalmau, V. (2012). Datalog constraint satisfaction infinite templates. appear Journal Computer System Sciences. preliminary
version appeared proceedings Symposium Theoretical Aspects
Computer Science (STACS05).
Bodirsky, M., Hils, M., & Krimkevitch, A. (2011). Tractable set constraints. Proceedings
International Joint Conferences Artificial Intelligence (IJCAI), pp. 510515.
Bodirsky, M., Hils, M., & Martin, B. (2011). scope universal-algebraic approach constraint satisfaction. appear Logical Methods Computer Science (LMCS), 9099. Available arXiv:0909.5097v3. extended abstract
announced results appeared proceedings Logic Computer
Science (LICS10).
Bodirsky, M., & Kara, J. (2008). complexity equality constraint languages. Theory
Computing Systems, 3 (2), 136158. conference version appeared proceedings
Computer Science Russia (CSR06).
Bodirsky, M., & Kara, J. (2009). complexity temporal constraint satisfaction problems. Journal ACM, 57 (2), 141. extended abstract appeared
Proceedings Symposium Theory Computing (STOC08).
Bodirsky, M., & Kutz, M. (2007). Determining consistency partial tree descriptions.
Artificial Intelligence, 171, 185196.
Bodirsky, M., & Nesetril, J. (2006). Constraint satisfaction countable homogeneous
templates. Journal Logic Computation, 16 (3), 359373.
Boole, G. (1847). Investigation Laws Thought. Walton, London. Reprinted
Philisophical Library, New York, 1954.
757

fiBodirsky & Hils

Broxvall, M., Jonsson, P., & Renz, J. (2002). Disjunctions, independence, refinements.
Artificial Intelligence, 140 (1/2), 153173.
Bulatov, A. A. (2003). Tractable conservative constraint satisfaction problems. Proceedings Symposium Logic Computer Science (LICS), pp. 321330, Ottawa,
Canada.
Bulatov, A. A. (2006). dichotomy theorem constraint satisfaction problems
3-element set. Journal ACM, 53 (1), 66120.
Bulatov, A. A., & Dalmau, V. (2006). simple algorithm Maltsev constraints. SIAM
Journal Computing, 36 (1), 1627.
Bulatov, A. A., Krokhin, A. A., & Jeavons, P. G. (2005). Classifying complexity
constraints using finite algebras. SIAM Journal Computing, 34, 720742.
Cohen, D., Jeavons, P., Jonsson, P., & Koubarakis, M. (2000). Building tractable disjunctive
constraints. Journal ACM, 47 (5), 826853.
Dowling, W. F., & Gallier, J. H. (1984). Linear-time algorithms testing satisfiability
propositional Horn formulae. Journal Logic Programming, 1 (3), 267284.
Drakengren, T., & Jonsson, P. (1998). Reasoning set constraints applied tractable
inference intuitionistic logic. Journal Logic Computation, 8 (6), 855875.
Garey, M., & Johnson, D. (1978). guide NP-completeness. CSLI Press, Stanford.
Hodges, W. (1993). Model theory. Cambridge University Press.
Idziak, P. M., Markovic, P., McKenzie, R., Valeriote, M., & Willard, R. (2010). Tractability
learnability arising algebras subpowers. SIAM Journal Computing, 39 (7), 30233037.
Jonsson, P., & Backstrom, C. (1998). unifying approach temporal constraint reasoning.
Artificial Intelligence, 102 (1), 143155.
Jonsson, P., & Drakengren, T. (1997). complete classification tractability RCC-5.
Journal Artificial Intelligence Research, 6, 211221.
Koppelberg, S. (1989). Projective boolean algebras. Handbook Boolean Algebras,
Vol. 3, pp. 741773. North Holland, Amsterdam-New York-Oxford- Tokyo.
Koubarakis, M. (2001). Tractable disjunctions linear constraints: Basic results applications temporal reasoning. Theoretical Computer Science, 266, 311339.
Krotzsch, M., Rudolph, S., & Hitzler, P. (2006). complexity Horn description
logics. OWL: Experiences Directions Workshop.
Kuncak, V., Nguyen, H. H., & Rinard, M. C. (2006). Deciding boolean algebra presburger arithmetic. Journal Automatic Reasoning, 36 (3), 213239.
Kuncak, V., & Rinard, M. C. (2007). Towards efficient satisfiability checking boolean
algebra presburger arithmetic. Proceedings International Conference
automated deduction (CADE), pp. 215230.
Kusters, R., & Molitor, R. (2002). Approximating specific concepts description
logics existential restrictions. AI Communications, 15 (1), 4759.
758

fiTractable Set Constraints

Lassez, J.-L., & McAloon, K. (1989). Independence negative constraints. International
Joint Conference Theory Practice Software Development (TAPSOFT), Volume 1, pp. 1927.
Marriott, K., & Odersky, M. (1996). Negative Boolean constraints. Theoretical Computer
Science, 160 (1&2), 365380.
Schaefer, T. J. (1978). complexity satisfiability problems. Proceedings
Symposium Theory Computing (STOC), pp. 216226.
Szendrei, A. (1986). Clones universal algebra. Seminaire de Mathematiques Superieures.
Les Presses de lUniversite de Montreal.

759


