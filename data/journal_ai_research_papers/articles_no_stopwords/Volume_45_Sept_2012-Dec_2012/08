journal artificial intelligence

submitted published

tractable set constraints
manuel bodirsky

bodirsky lix polytechnique fr

ecole polytechnique lix
umr du cnrs
palaiseau france

martin hils

hils math univ paris diderot fr

institut de mathematiques de jussieu
umr du cnrs
universite paris diderot paris
ufr de mathematiques
paris cedex france

abstract
many fundamental artificial intelligence knowledge representation
verification involve reasoning sets relations sets modeled
set constraint satisfaction set csps frequently intractable
several important set csps known polynomial time tractable
introduce large class set csps solved quadratic time class
call ei contains previously known tractable set csps
ones crucial importance example description logics class ei set
constraints elegant universal algebraic characterization use
every set constraint language properly contains ei set constraints already
finite sublanguage np hard constraint satisfaction

introduction
constraint satisfaction computational informally input
consists finite set variables finite set constraints imposed variables
task decide whether assignment values variables
constraints simultaneously satisfied set constraint satisfaction special
constraint satisfaction values sets constraints might
instance force one set includes another set x one set x disjoint another
set constraints might ternary generally finite arity
constraint intersection two sets x contained z symbols
px x yq z
systematically study computational complexity constraint satisfaction turned fruitful consider constraint satisfaction
csppq set allowed constraints formed fixed finite set relations
r dk possibly infinite common domain example equals q
rational numbers tu usual order rationals csppq
deciding whether given set binary constraints form x
common solution rational numbers way parametrizing conc

ai access foundation rights reserved

fibodirsky hils

straint satisfaction constraint language led many strong algorithmic
e g bulatov dalmau idziak markovic mckenzie valeriote willard
barto kozik bodirsky kutz bodirsky kara many
powerful hardness conditions large classes constraint satisfaction schaefer
bulatov krokhin jeavons bulatov bodirsky kara
set constraint language set relations r pp pnqqk common domain
p pnq set subsets natural numbers moreover require
relation r defined boolean combination equations signature c
function symbols intersection union complementation empty
full set respectively details formal definition set constraint languages
found section section give many examples set constraint languages
choice n notational convenience could selected infinite set
purposes e g rn instead n natural choice spatial reasoning one may even
replace p pnq infinite boolean algebra see theorem
following set constraint satisfaction set csp form
csppq finite set constraint language shown marriott odersky
set csps contained np
drakengren jonsson initiated search set csps solved
polynomial time showed csppt uq solved polynomial time

x holds iff x subset equal
x holds iff x disjoint sets
x holds iff x distinct sets
showed csppq solved polynomial time relations
defined formulas form
x

xk yk x

x

xk yk x

form

x xk yk necessarily distinct variables drakengren jonsson
thm call set relations defined way drakengren jonssons set constraint language easy see
present runs time quadratic size input hand
contains relation defined x x relation defined
x x x x csppq np hard drakengren jonsson
thm
contributions outline
present significant extension drakengren jonssons set constraint language section whose csp still solved quadratic time input size section call set constraint language ei unlike drakengren jonssons set


fitractable set constraints

constraint language language contains ternary relation defined px x q z
relation particular interest description logics discuss
moreover extension ei contains finite sublanguage
np hard set csp section concepts model theory universal
algebra sense present maximal tractable class set constraint satisfaction

concept independence constraint languages
discovered several times independently lassez mcaloon jonsson
backstrom marriott odersky see koubarakis broxvall jonsson
renz cohen jeavons jonsson koubarakis however apply
concept twice novel nested way leads two level resolution procedure
implemented run quadratic time technique use prove correctness
important contribution believe similar
applied many contexts technique inspired already
mentioned connection universal algebra
application areas related literature
mention three different contexts set constraints appeared literature
set constraints programming languages
set constraints applications program analysis set constraint form
x x set expressions examples set expressions denoting
empty set set valued variables union intersection sets expressions
form f pz z q f function symbol z z set expressions
unfortunately worst case complexity reasoning tasks considered
setting high often exptime hard survey see aiken
recently shown quantifier free combination set constraints without
function symbols cardinality constraints quantifier free pressburger arithmetic
satisfiability np kuncak rinard logic called qfbapa
interesting program verification kuncak nguyen rinard
tractable description logics
description logics family knowledge representation formalisms used
formalize reason concept definitions computational complexity
computational tasks studied formalisms usually quite high
however last years series description logics example el el horn fl
extensions fragments kusters molitor baader baader
brandt lutz krotzsch rudolph hitzler discovered
crucial tasks e g entailment concept satisfiability knowledge base satisfiability
decided polynomial time
two basic assertions made el
horn fl c c
c c c x c c every c c c concept
names c c c ei set constraints latter treated


fibodirsky hils

framework drakengren jonsson none description logics tractable
knowledge base satisfiability contains ei set constraints
spatial reasoning
several spatial reasoning formalisms rcc rcc closely related set constraint satisfaction formalisms allow reason relations
regions fundamental formalism rcc see e g jonsson drakengren
one think region non empty set possible binary relationships containment disjointness equality overlap disjunctive combinations thereof thus
exclusion empty set prominent difference set constraint languages studied drakengren jonsson contained class set constraint
languages considered rcc fragments see section
csp rcc csps reducts set csps proposition

constraint satisfaction
use existing terminology logic model theory convenient describe
constraint languages structures see e g hodges structure tuple
pd f f r r q set domain function
dki ki called arity ri relation e subset
dli li called arity ri function assume
function symbol denote relation ri relation symbol
denote ri constant symbols treated ary function symbols
set relation function symbols structure called signature
say structure signature contains relation symbols
function symbols say relational structure context
constraint satisfaction relational structures called constraint languages
constraint language called sublanguage reduct constraint language
relations subset relations called expansion
let relational structure domain finite signature constraint
satisfaction following computational denoted csppq
given finite set variables v conjunction finitely many atomic formulas
form rpx xk q x xk p v r p satisfiable
exist assignment v every constraint rpx xk q input
pspx q spxk qq p r
mapping called solution instance csppq conjuncts
called constraints note introduce constraint satisfaction
csppq finite constraint languages e relational structures finite relational
signature

example cspppq qq deciding whether given set
constraints form x solution simultaneously satisfies constraints


fitractable set constraints

set constraint languages
section give formal definitions set constraint languages let structure domain p pnq set subsets natural numbers signature
c u



binary function symbol denotes intersection e x
binary function symbol union e

c unary function symbol complementation e cs function maps
n nzs
constants treated ary function symbols denoting empty set
full set n respectively

h

sometimes simply write function function e
distinguish function symbol respective function use symbols
symbols x prevent confusion meta mathematical usages x
text
set constraint language relational structure whose relations quantifier free
definition allow equality first order formulas equality symbol
interpreted true equality relation domain structure
write x abbreviation x x
example ternary relation px z q
definition z px q x

p p pn q x z



quantifier free

theorem see marriott odersky proposition let set constraint
language finite signature csppq np
easy see np hard set csps shown next example
example consider set constraint language contains eight relations

tpx zq x z u
tpx zq x z u
tpx zq x z u
tpx zq x z u
tpx zq x z u
tpx zq x z u
tpx zq x z u
tpx zq x z u
set csp relations well known sat npcomplete garey johnson
well known structure pp pnq c q boolean algebra


fibodirsky hils

playing role false playing role true
c playing role




playing role respectively

refer work koppelberg background boolean algebras
confuse logical connectives connectives boolean algebras
use symbols c instead usual function symbols boolean
algebras facilitate notation write x instead cpxq x instead
p x q
assume terms functional signature
c u written


inner conjunctive normal form cnf e ni nj lij lij
form x form x variable x note every term c u rewritten equivalent term form usual laws boolean algebras boole
allow special
case n case becomes special case
ni
ni case j lij becomes refer ci tlij j ni u
inner clause lij inner literal ci say set inner clauses
satisfiable exists assignment v p pnq inner clauses

union evaluation literals equals n case formula
n
ci satisfying assignment
example inequality x p pnq equivalently written py xq px q
formula two inner clauses positive negative inner literal
assume quantifier free formulas signature
c u written

mi
outer conjunctive normal form cnf e
j lij lij

form positive outer literal form negative outer literal
well known easy see every quantifier free formula
formula form equivalent every boolean algebra refer
ci tlij j mi u outer clause lij outer literal ci
whenever convenient identify set clauses
example consider formula px z q px z q rewritten
px z q px z q subsequently replace inequality literals x
py xq px q see example arrive formula discussed
normal form two outer clauses one two positive outer literals
two negative outer literals
mentioned introduction csps reducts rcc therefore
many reducts rcc formulated set csps network satisfaction rcc seen csp following structure rcc domain
p pnqzthu binary relations given follows relation r rcc
exists quantifier free c u formula px x q ps q p r
non empty ps q true clear
finitely many inequivalent quantifier free formulas language c u
hence rcc finitely many relations


fitractable set constraints

proposition let reduct rcc exists set constraint language
csppq csppq
proof let n formulas define relations domain
p pnqzthu let structure domain p pnq relations r rn defined
n difference additional element
thu appears none relations prove every finite
conjunction atomic formulas form ri px xk q satisfiable
conjunction satisfiable satisfiable clearly satisfiable
since induced substructure conversely satisfiable
solution must property spxi q h xi appear
constraint since constraints force arguments non empty hence setting
spxi q non empty subset n still solution implies claim
proposition shows class set csps contains class csps reducts
rcc inclusion clearly strict set csps cannot formulated
csps reducts rcc since relations set constraint languages arbitrary
arity reducts rcc contain binary relations

horn horn set constraints
section study horn horn set constraints class set constraints admits
intuitive syntactic description thus easy define universal algebraic
considerations class section lead us another class set constraints called
ei introduced section class strictly contains class horn horn set
constraints universal algebraic description key maximality
prove section tractability set constraint languages ei allow
linear time reduction satisfiability horn horn clauses see proposition note
classes set constraints horn horn ei studied
horn horn relations
definition quantifier free formula called horn horn
every outer clause outer horn e contains one positive outer literal
every inner clause positive outer literals inner horn e contains one
positive inner literal
relation r p pnqk called
outer horn defined conjunction outer horn clauses
inner horn defined formula form pc ck q
ci inner horn



horn horn defined horn horn formula
example inequality

horn horn recall may defined py xq px yq


fibodirsky hils

example previous example relation
easily seen horn horn
example ternary relation tpx z q x
horn horn definition x z

tpx u vq x u vu

zu encountered

proposition drakengren jonssons set constraint language contains horn horn
relations
proof disjointness relation definition x inner horn
inequality relation horn horn since inner clauses definition py xq px q
one positive inner literal inclusion relation x definition
x inner horn
horn horn preserved adding additional outer disequality literals outer
clauses relations considered drakengren jonssons language horn horn
universal algebraic preliminaries
see section class horn horn formulas preserved several
important functions defined set subsets natural numbers
definition
let pp pnqq p pnq function maps pair sets ps q
set p u p u

denote fin set finite non empty subsets n let f p pnq p pfin q
f ps q ts

finite non emptyu

let g n fin bijection since sets countable bijection exists
let e p pnq p pnq defined
eps q tg pt q

p f ps qu

let ei function defined eipx q epipx qq
intuitively functions e ei designed forget unions
formalized definition preserving basic operations see lemma
proposition case e
definition let f pp pnqqk p pnq function r p pnql relation
say f preserves r following holds ak p pp pnqql
pf pa ak q f pa l akl qq p r ai p r k f preserve r
say f violates r say f strongly preserves r ak p pp pnqql
pf pa ak q f pa l akl qq p r ai p r k
first order formula defines relation r f preserves strongly preserves
r say f preserves strongly preserves finally g pp pnqql p pnq
function say f preserves strongly preserves g preserves strongly
preserves

graph g e relation px xl g px xl qq x xl n


fitractable set constraints

note injective function f preserves function g strongly preserves
g
example consider function f pp pnqq p pnq px q x f preserves
since x x whenever x x hand f strongly
preserve shown f pn hq f ph nq
fact mapping isomorphism
proof mapping
inverted mapping sends n ta p
u ta p u straightforward verify strongly preserves c
clearly ipx q h x

h

similarly since natural numbers partitioned even odd numbers
ipx q n x n
let subsets n verify preserves c
ipcps qq definition equal ips q equals cpips qq suppose

p ps q

p

r
r ips q
p ips q

argument
even strongly preserves c

analogous thus preserves c since injective

let ps q pt q pp pnq ipps q pt qq
definition equal ips q equals ips q ipt q

p ips q

p ps q

p ips q ipt q

argument analogous thus preserves
injective even strongly preserves
verification



since

similar

proposition function e following properties
e injective


x z p p pnq x
epxq epy q epz q

e strongly preserves


z x









x

fibodirsky hils

proof verify properties one one since g bijective epxq epy q
x finite subsets case x hence e
injective thus prove e strongly preserves suffices check e
preserves
since g bijective gpnq equals set finite subsets n
hence epnq n shows e preserves compute ephq g pf phqq
g phq h
next verify x p p pnq epxq epy q epx q let p n
arbitrary p epxq epy q gpaq p f pxq x f py q definition f
since gpaq finite subset n case gpaq p f px q
case p epx q concludes proof e preserves
verify x z x x epxq epy q epz q first
observe u v n u v epuq epv q since e preserves
implies epxq epy q epz q since x x b p x
r b p b r x ta bu p f pz q ta bu r f pxq f py q hence
g pta buq p epz q g pta buq r epxq epy q shows epz q epxq epy q
note particular e preserves moreover epcpxqq cpepxqq
follows preservation since x cpxq therefore epxq epcpxqq equivalent
inclusion e strongly preserve therefore ei
strongly preserves
following direct consequence fact isomorphisms k
preserve horn formulas since simple proof instructive follows
give special case relevant
proposition outer horn relations preserved
proof let conjunction outer horn clauses variables v let tt
tk u outer clause let u v v p pnq two assignments satisfy
clause let w v p pnq given x ipupxq v pxqq suppose w satisfies
tj j k since injective must tj u v
j k therefore neither assignment satisfies negative literals hence u v
must satisfy since isomorphism preserves particular
hence w satisfies
proposition inner horn relations strongly preserved e






proof observe x p j j q equivalent x p j yj q j yj strongly
preserved e since e strongly preserves clearly implies statement
note proposition proposition imply ei strongly preserves inner horn
relations later need following

n k following equivalent
epx q epxk q epy q epyl q

exists k xi p j j q

lemma let x xk yl





fitractable set constraints

exists k epxi q p


j

epyj qq

j yjl jl epyj q
proof implication
p q p q suppose every k ai p n
ai r xi xi p j j q let c g ta ak u k


c r epxi q j l epyj q see first observe ai p j l yj xi therefore
ta ak u p jl f pyj q f pxiq k conclude c r epx q epxk q
epy q epyl q
implication p q p q follows directly proposition implication p q
p q trivial second statement direct consequence proposition
k

proposition every horn horn relation preserved e particular
ei
proof suppose r horn horn definition variables v since r
particular outer horn preserved proposition
verify r preserved e let u v p pnq assignment
satisfies u satisfies least one literal outer clause suffices
assignment v v p pnq defined x epupxqq satisfies outer
literal suppose first outer literal positive horn horn
form x yl form yl preserved e
lemma
suppose outer literal negative form x xk
yl k treat case k case similar
suppose contradiction v px q
vpxk q vpy q vpyl q lemma
exists k upxi q p j upy j qq particular
upx q upxk q upy q upyl q contradiction assumption u
satisfies
ei set constraints
section introduce class ei set constraints strictly contains
horn horn relations give several examples non examples present
algorithmic reduction csps ei set constraints satisfiability finite sets
horn horn clauses
definition set relations quantifier free definition
preserved operation ei denoted ei
remark note definition operation ei definition involved bijection g
n fin see later proposition proposition class
ei independent precise choice g
recall proposition ei contains horn horn relations present
examples relations ei examples relations ei
horn horn


fibodirsky hils

example give example relation clearly ei relation
r tpx q x u violated ei consider p nu
p nu ps q p r since isomorphism
pips q ips qq p r since neither ips q ips q ips q
ips q get epips qq epips qq ep q proposition therefore
peips q eips qq r r wanted
example relation r tpx z q px q py z qu preserved
ei note p q p q p r eip q eip q eip q pairwise distinct
since ei injective
example formula

p x xq
px yq
pv u x q
clearly horn horn however relation defined formula ei
px u u q und px u v q relation neither ipx x q ipy q
ipy q ipx x q proposition peipx x q eipy q eipu u q eipv v qq satisfies
formula equivalent horn horn formula since formula preserved

example formula ppx q pu v qq px q px q
horn horn however preserved e reason one clauses
negative literal x conjuncts tx u tx u therefore
every tuple p r tuple eptq satisfies x r well proposition
r preserved case authors suspect equivalent horn horn
formula generally open whether exist formulas preserved e
equivalent horn horn formula
corollary class horn horn relations proper subclass ei
proof proposition shows ei contains horn horn relations example shows
inclusion strict
prepare viewed partial converse proposition
definition quantifier free formula syntactic form described end
section called reduced every formula obtained removing outer literal
equivalent
note slightly different notion reduced formula introduced
bodirsky chen pinsker variant better suited
purposes
lemma structure every quantifier free formula equivalent reduced
formula


fitractable set constraints

proof clear every quantifier free formula written formula cnf
form discussed theorem remove successively outer
literals long equivalent formula
first prove partial converse proposition
proposition let reduced formula preserved outer clause
horn
proof let v set variables assume contradiction contains outer
clause two positive literals remove literal
clause c resulting formula inequivalent hence assignment
v p pnq satisfies none literals c except similarly
assignment v p pnq satisfies none literals c except
injectivity since strongly preserves c assignment v p pnq
defined x ips pxq pxqq satisfy two literals since
strongly preserves c none literals c satisfied mappings
well contradiction assumption preserved
definition let v set variables v p pnq mapping
function v p pnq form x epspxqq called core assignment
lemma every quantifier free formula exists formula inner
clauses inner horn satisfying core assignments
preserved ei set satisfying core assignments closed
ei
proof suppose outer clause c positive outer literal
contains inner clause c x xk l horn e k
replace outer literal k literals tk ti obtained
replacing c xi l
claim resulting formula set satisfying core assignments
observe xi l c hence ti implies arbitrary satisfying
assignment satisfies one positive outer literals ti case
observation shows satisfies satisfies one outer literals c
case satisfies literal hence implies conversely let
satisfying core assignment satisfies literal c
satisfies literal satisfies otherwise must satisfy hence
spx q spxk q spy q spyl q since core assignment lemma implies
exists k spxi q spy q spyl q satisfies
suppose outer clause c negative outer literal
contains inner clause c x xk l horn e k
replace clause c k clauses c ck ck obtained c
replacing c xi l
claim resulting formula set satisfying core assignments
observe x xk l implies xi l every
k observation shows arbitrary assignment assignment


fibodirsky hils

conversely let satisfying core assignment satisfies one literals
c satisfies otherwise must satisfy xi l
k lemma satisfies x xk l
perform replacements obtain formula inner clauses
horn formula satisfies requirements first statement lemma
prove second statement let u v v p pnq two satisfying core assignments
since satisfying core assignments u v satisfy
mapping w v p pnq given x eipupxq v pxqq core assignment
ei preserves mapping w satisfies since core assignments
w satisfying assignment proves statement
single technical condition guarantees extra condition
see proposition formulas satisfying certain universl algebraic property hornhorn allow us perform reduction csp associated finite set
constraint languages ei satisfiability horn horn clauses
definition quantifier free formula syntactic form described end
section called strongly reduced every formula obtained removing outer
literal set satisfying core assignments
proposition let strongly reduced formula whose inner clauses horn
set satisfying core assignments closed ei horn horn
proof let v set variables suffices clauses outer
horn assume contradiction contains outer clause two positive literals
remove literal clause c resulting formula
strictly less satisfying core assignments shows existence core assignment
v p pnq satisfies none literals c except similarly exists
core assignment v p pnq satisfies none literals c except
assumption inner clauses horn claim assignment
v p pnq defined x eips pxq pxqq satisfy clause c since ei
strongly preserves inner horn clauses satisfy
reasons satisfy literals c contradicts assumption
satisfying core assignments preserved ei
satisfiability horn horn clauses computational decide whether
given finite set horn horn clauses satisfying assignment
proposition let finite set constraint language ei csppq
reduced linear time satisfiability horn horn clauses
proof let instance csppq let v set variables appear
constraint rpx xk q let r definition r
lemma exists formula r satisfying core assignments r
inner clauses horn moreover since r preserved ei lemma
asserts set satisfying core assignments r preserved ei
assume without loss generality r strongly reduced seen similarly
lemma proposition formula r horn horn


fitractable set constraints

let set horn horn clauses formulas r px xk q obtained constraints rpx xk q described manner claim satisfiable instance
csppq satisfiable follows fact constraint
rpx xk q formulas r r satisfying core assignments
r r preserved ei r follows proposition
particular function x eipx xq
note proposition reduce satisfiability ei satisfiability proper
subclass horn horn set constraints general horn horn set constraints allow
inner clauses negative outer literals horn reduction produces hornhorn clauses inner clauses horn

horn horn set constraints
present takes input set horn horn clauses decides
satisfiability pp pnq c q time quadratic length input
proposition section therefore conclude proof csppq tractable
relations ei
mentioned introduction two procedures
resolution inner procedure essentially well known positive unit resolution
procedure horn sat outer procedure basically
used literature independence constraint satisfaction see e g jonsson
backstrom koubarakis broxvall et al cohen et al contribution section way nest two obtain polynomial time
decision procedure satisfiability horn horn clauses
start discussing first procedure call inner
resolution case boolean positive unit resolution dowling gallier
one implement procedure inner res runs linear time
input size
lemma let finite set inner horn clauses following equivalent




satisfiable

inner respq figure accepts




solution whose image contained


th nu

proof obvious unsatisfiable inner respq rejects fact

inner clauses c derived inner res formula c logically implied

conversely accepts set eliminated variables
n remaining variables h satisfies clauses removed clauses
positive literal satisfied remaining clauses least one negative literal
final stage clauses negative literals final stage
satisfied




proof previous lemma shows satisfiable
satisfiable two element boolean algebra see following


fibodirsky hils

inner res
input finite set inner horn clauses
accepts iff satisfiable
entire
contains empty clause reject
repeat true
repeat true
repeat false
contains positive unit clause txu
repeat true
remove clauses literal x occurs
remove literal x clauses
end
loop
accept



figure inner resolution
holds generally inner horn clauses following
well known shown proof given koppelberg
weaker proposition give proof convenience reader
fact let terms

c u following equivalent

satisfiable two element boolean algebra
satisfiable boolean algebras
satisfiable boolean algebra
satisfiable finite boolean algebra






proof obviously implies implies
implies assume satisfying assignment
boolean algebra c let x xn variables occur let xi ci
satisfying assignment satisfiable boolean sub algebra
n
c c generated tc cn u c finite p q elements
implies first note finite boolean algebra isomorphic boolean
algebra pp px q c q subsets finite set x x p x consider map hx
p px q u hpy q x p hpy q otherwise hx homomorphism
boolean algebras particular shows every non zero element finite
boolean algebra c homomorphism h c two element boolean algebra
hpaq suppose assume satisfying
assignment finite boolean algebra c let c element denoted c
assignment c let h homomorphism c u
hpcq e hpcq construction image satisfying assignment h
satisfying assignment u


fitractable set constraints

statement instead given proposition
koppelberg fact following consequence crucial way
use inner resolution procedure
lemma let finite set inner horn clauses following equivalent
inner respytx xk yl uq rejects





proof
implies x xk l

x
xk yl unsatisfiable fact case
x xk
unsatisfiable element
l
boolean algebra case x xk l


implies x xk l

unsatisfiable two element boolean algebra seen lemma
turn holds inner respytx xk yl uq rejects
outer res
input finite set horn horn clauses
accepts iff satisfiable pp pnq c q
entire
contains empty clause reject
repeat true
repeat true
repeat false
let set inner horn clauses terms
positive unit clauses tt u
inner res rejects reject
negative literal clauses
inner clause tx xk l u
call inner res
tx xk yl u
inner res rejects remove clause
end
clauses removed
remove outer literal clause
repeat true
end
loop
accept

figure outer resolution
theorem outer res figure decides satisfiability sets hornhorn clauses quadratic time
proof first argue rejects indeed solution first
note whole argument set clauses satisfying tuples


fibodirsky hils

e corresponding formulas equivalent observe negative literals get
removed clauses negative literal gets removed clause
inner res rejects tx xk yl u inner clause
tx xk yl u lemma inner res rejects ytx xk
yl u implies x xk l hence positive
unit clauses imply therefore literal removed clause
without changing set satisfying tuples rejects inner res
rejects derives empty clause cases clear satisfiable
thus suffices construct solution accepts let set
inner clauses terms positive unit clauses final stage
accepts remaining negative outer literal tt u remaining inner clause
tx xk l u exists assignment v p pnq satisfies
ytx xk l u otherwise lemma inner resolution
would rejected tx xk yl u would removed
inner clause let ds enumeration remaining inner clauses
appear remaining negative outer literals
write ary operation defined px xs q ipx ipx ipxs xs q qq
fact claim v p pnq given
x pd pxq ds pxqq

satisfies clauses let c clause assumption final stage
clause c still non empty note since formulas input
horn horn contain one positive literal holds particular c
therefore distinguish following cases
final state c still contains negative literal since
removed remaining inner clause tx xk l u
observe spx q spxk q spy q spyl q dj px q
dj pxk q dj py q dj pyl q j hence since
px q pxk q py q pyl q satisfies shows
satisfies c
negative literals removed c positive
literal c inner clauses horn part
therefore satisfied indeed assumption assignments dj
satisfy preserved
conclude solution inner resolution linear time
complexity outer resolution performs linear number calls
inner resolution straightforward implement necessary data
structures outer resolution obtain running time quadratic input
size
combining proposition theorem obtain following
theorem let finite set constraint language ei csppq
solved quadratic time


fitractable set constraints

maximal tractability
section class ei maximal tractable set constraint language
specifically let set constraint language strictly contains ei relations
contains finite set relations already
cspp q np hard theorem
universal algebraic
proof use called universal algebraic complexity constraint satisfaction requires formulate set csps constraint
satisfaction categorical structures detailed introduction
universal algebraic categorical structures see bodirsky structure
countable domain called categorical countable structures satisfy
first order sentences isomorphic see e g hodges
theorem ryll nardzewski countable signatures equivalent requiring
every relation preserved automorphisms first order definable
see e g hodges useful consequence categorical structure whenever two tuples c pc cn q pd dn q satisfy
first order formulas automorphism maps c
example categorical structure pq q cantors theorem nonexample given pz q note pq q pz q csp indeed two
infinite linear orders share csp since even finite substructures
characterisation infinite structures categorical structure
csp given bodirsky hils martin empirically
observed constraint satisfaction studied temporal spatial
reasoning typically called qualitative formulated
categorical template
set constraint languages general categorical follows easily
mentioned theorem ryll nardzewski however every set csp formulated
csp categorical structure see first recall basic facts
boolean algebras countable atomless boolean algebras isomorphic koppelberg
corollary see hodges example page let denote
countable atomless boolean algebra let denote domain use
denote join meet respectively since axioms boolean algebras
property atoms written first order sentences follows
categorical structure b quantifier elimination every first order formula
b equivalent quantifier free formula well known quantifier elimination
see hodges exercise page make use following
theorem marriott odersky corollary quantifier free formula satisfiable infinite boolean algebra satisfiable infinite boolean
algebras
isomorphism structure called automorphism
atom boolean algebra element x x x
boolean algebra contains atoms called atomless



x

fibodirsky hils

particular b infinite boolean algebra n quantifier free
formulas signature c u relational structure signature tr rn u ri n defined b csppq
depend choice b
fundamental concept complexity theory constraint satisfaction
notion primitive positive definitions first order formula called primitive positive
pp form
dx xn p mq
formula form rpy yl q form
r relation symbol yl free variables tx xn u
say k ary relation r dk primitive positive definable pp definable
structure domain iff exists primitive positive formula px xk q
k free variables x xk tuple pb bk q r pb bk q
true
example relation tpx q p p pnq x u pp definable pp pnq q
tpx z q x z u pp definition px x q x definition even
quantifier free
example relation tpx x x q p p pnq x x x u pp definable
pp pnq q tpx z q x z u pp definition du ps px x uq
pu x qq
every relation structure preserved operation f f called
polymorphism note polymorphisms preserve relations pp
definition following shown finite domain constraint satisfaction
bulatov et al easy proof works infinite domain constraint satisfaction
lemma let r relation primitive positive definition structure
csppq csp expansion relation r polynomial time equivalent
following theorem one reasons useful work categorical
templates possible
theorem bodirsky nesetril let categorical structure r
primitive positive definable r preserved polymorphisms
previous next together used translate questions
primitive positive definability
purely operational questions let set let opnq
pnq set operations finite arity
dn let
n
p
n
q
operation p called projection fixed p nu n tuples
px xnq p dn identity px xnq xi composition k ary
operation f k operations g gk arity n n ary operation defined

pf pg gk qqpx xnq

f g px xnq gk px xnq


fitractable set constraints

definition say f locally generates f dn every finite subset
operation g dn obtained operations f
projection maps composition f paq g paq p
theorem see szendrei corollary bodirsky proposition let
f set operations domain operation f dk preserves
finitary relations preserved operations f f locally generates
f
set automorphisms structure denoted autpq following
consider sets operations f contain autpaq therefore make following
convention f say f generates f p f autpaq locally generates f
ei set constraints atomless boolean algebra
previous subsection seen set csps formulated csps
categorical structures section describe categorical templates
correspond set csps ei set constraints order define analogs
operations e defined instead p pnq
proposition isomorphism
proof straightforward verify countable atomless boolean algebra

motivated properties e described lemma make following definition
definition let b b two arbitrary boolean algebras domains b b
respectively let g b b function strongly preserves say
g forgets unions k l x xk yl p b
epx q epxk q epy q epyl q
exists k xi yl



proposition exists injection e strongly preserves
forgets unions



proof construction e standard application konigs tree lemma categorical structures see e g bodirsky dalmau lemma suffices
injection f every finite induced substructure b f
strongly preserves forgets unions
let b finite substructure let b domain b let c
pp pb q c q boolean algebra subsets b claim g b p pb q
given g p q g pxq tz z z b xu x
preserves definition


fibodirsky hils

preserves

x p b including case x
g pxq c g py q tz z z b x z b u

z z z b px b q
g p x b q

injective x
x
strongly preserves

p b gpxq gpyq x b b x hence
follows previous two items

forgets unions shown analogously proof lemma






indeed one xi yl iff xi b j yj iff xi j yj j yj iff


g pxi q j g pyj q j g pyj q iff g pxi q g py q g pyl q thus xi yl
k implies g px q g pxk q g py q g pyl q
prove converse use finite boolean algebra b may identified
pp paq c q finite set xi xi yl k
may choose ai p azxi e ai p j yj xi k let c ta ak u
c p b construction k one tc u r g pxi q g py q g pyl q
particular follows g px q g pxk q g py q g pyl q
clearly embedding h c f hpg q homomorphism
b forgets unions
proposition let quantifier free formula signature c u
e preserves e preserves moreover every operation
strongly preserves forgets unions generates e generated
e
proof let tuple elements clearly exists tuple b elements
p pnq b satisfy set quantifier free formulas follows
fact every finite boolean algebra boolean algebra subsets finite set
observe whether tuple epbq satisfies quantifier free formula
depends lemma since e strongly preserves forgets unions
true quantifier free formulas hold epaq hence e preserves
e preserves
prove second part statement use theorem suppose c
tuples length elements satisfy quantifier free
formulas since quantifier elimination follows c satisfy firstorder formulas consequence theorem ryll nardzewski mentioned

beginning section exists automorphism maps c
observations theorem implies operations strongly preserve
forget unions generate
r operation px q epipx qq
let ei


fitractable set constraints

proposition let quantifier free formula signature c u
r preserves moreover every binary operation
ei preserves ei
r generated
g strongly preserves forgets unions generates ei
r
ei
proof arguments similar ones given proof proposition
n tuples elements n tuples b b elements p pnq
pa q pb b q satisfy set quantifier free formulas whether
eipb b q satisfies quantifier free formula depends ei strongly preserves
r pa q ei
r preserves
forgets unions holds ei
ei preserves
proof second part statement identical one proposition

central argument
give central argument maximal tractability ei stated universalalgebraic language say operation ak depends argument
p k u pk q ary operation f x xk p
f px xk q f px xi xi

xk

q

equivalently characterize k ary operations depend th argument
requiring x xk p x p
f px xk q f px xi x xi

xk

q

following general fact injective maps
lemma let f ak function depends arguments
locally generated set injective operations f f injective
proof first prove every term px xn q formed operations f
variables x xn every variable appears least defines injective
map prove induction term structure case n
x nothing otherwise form f pt tk q k ary f p f
tj tj pxi ximpj q q j k term operations f variables
xi ximpj q appears least tj suppose p
b bn p pa q pb bn q want ai bi
n since f injective must tj pai aimpj q q tj pbi bimpj q q
j k since every variable x xn appears least variable
xi must appear tj j k since tj defines injective operation inductive
assumptions must ai bi follows defines injective map
suppose f operation locally generated f depends
arguments thus ci cin di f pci cin q
f pci cii di cii cin q let b bn p f pa q
f pb bn q b bn since f locally generated


fibodirsky hils

f exists term px xn q composed variables x xn operations f pe en q f pe en q elements e en
set ta b bn c cnn dn u variable xi must appear
px xn q pci cin q pci cii di cii cin q hence argument
beginning proof shows px xn q defines injective map
therefore b bn shown f injective
r u tf u generates ei
r f
theorem let f operation generated tei
generated teu

r u
proof statement theorem let f k ary operation generated tei
sake notation let x xl arguments f depends l k
let f al operation given f px xl q f px xl xl xl xl q
observe f depends arguments locally generated injective operations
lemma f injective since f generated operations preserve
f preserves f injective even strongly preserves
consider first case l e f unary finite subsets
operation f equals automorphism f generated autpaq
nothing assume otherwise assume finite set
p autpaq f pxq apxq x p claim f forgets
unions see let u um v vn f pu q f pum q
u term pxq composed
f pv q f pvn q since f generated tei
r
ei automorphisms single variable x f pxq pxq
x p tu um v vn u choice term cannot composed
automorphisms alone hence must p autpaq operational terms
r f pxq apei
r pt pxq pxqqq
composed automorphisms ei
r
x p ei forgets unions exists k pui q pv q tl pvn q
since strongly preserves means ui v v n see proof
proposition wanted proposition follows f
generated e f generated e well
next consider case l let g binary operation defined g px q

f px q functions depends arguments cannot generated
automorphisms alone hence term form
r pt px q px qqq
px q apei


p autpaq
r automorphisms
operational terms composed ei
two variables x

g px q px q px q p tu um v vn u

claim g forgets unions assume g pu q g pum q g pv q g pvn q
elements u pu u q um pu u q v pv v q vn pvn vn q
r forgets unions exists k pui q pv q pvn q
since ei


fitractable set constraints

pui q pv q pvn q suppose first depends arguments
defines injective operation strongly preserves follows ui v v n
since equations inner horn argue similarly depends
arguments cases established g forgets unions suppose
depend arguments consider first case
depends first argument function x px xq injective
strongly preserves pui q pv q pvn q derive
u v vn holds case must depend second argument
since depends arguments therefore u v vn holds
situation depends second argument depends
r
first argument analogous g forgets unions proposition g generates ei
r
consequently f generates ei
theorem let set constraint language suppose contains relations
ei contains relation ei finite sublanguage
cspp q np hard
proof r r relations let quantifier free formulas
define r r pp pnq c q let r r relations defined
let relational structure domain exactly
r contains
relations proposition contains relation preserved ei
r consider set f polymorphisms
relations preserved ei
theorem operations f locally generated eri
set f contain eri since would contradict theorem fact
r since f locally closed follows
contains relation preserved ei
theorem operations f p f generated e relation
tpx zq x z x zu preserved operations f already seen
relation example hence pp definable theorem relation
np complete csp bodirsky kara let reduct contains
exactly relations appear pp definition tpx z q x z x z u
clearly finitely many relations denote corresponding relation
symbols lemma cspp q np hard
establishes hardness csppq let reduct claim
cspp q cspp q computational
conjunction atomic formulas satisfiable true
replacing atomic formula quantifier free definition follows
theorem

concluding remarks
introduced powerful set constraint language ei set constraints
particular contains horn horn set constraints previously studied tractable set
constraint languages constraint satisfaction ei solved polynomial
even quadratic time tractability complemented complexity
shows tractability ei set constraints best possible within large class
set constraint languages


fibodirsky hils

would remark test whether given finite set
constraint language relations language given quantifier free formulas
signature c u contained ei means called metaproblem ei set constraints decided effectively
proposition test whether given quantifier free formula
signature c u defines relation ei
proof clear effectively transformed normal form described
section assume conjunction outer clauses
atomic formula form inner conjunctive normal form
let n number variables test two n tuples u u
elements p pnq satisfy n tuple eipu u q satisfies well note
whether tuple satisfies depends boolean algebra generated
entries tuple boolean algebra generated n elements size
n
therefore finitely many cases check pair boolean
algebras generating tuples u u check whether eipu u q satisfies follows
lemma eipu u q satisfies atomic formula every inner clause
x
xk epy q epy q exists k ipu u
q satisfies
xi j j turn true u u satisfy xi j j
truth value non atomic formulas tuple eipu u q computed
truth value atomic formulas usual way

finally would remark one analogously obtain tractability
class constraints inner clauses positive outer literals dual horn
e one negative literal statements proofs respective
obtained dualizing following formal sense dual relation r
definable boolean algebra relation tcptq p ru dual k ary operation
f domain operation px xk q cpf pcpx q cpxk qqq proofs
translate literally proofs dualized versions statements

acknowledgments
extended abstract article appeared proceedings ijcai bodirsky hils
krimkevitch want thank francois bossiere pointed mistakes
conference version one mistake concerned reduction csp
languages ei satisfiability horn horn clauses concerned
previous proof theorem
manuel bodirsky received funding erc european communitys
seventh framework programme fp grant agreement
third author conference version left author team preparation journal version



fitractable set constraints

references
aiken set constraints applications future directions proceedings
second workshop principles practice constraint programming
pp
baader f least common subsumers specific concepts description logic
existential restrictions terminological cycles proceedings international
joint conferences artificial intelligence ijcai pp
baader f brandt lutz c pushing el envelope international joint
conferences artificial intelligence ijcai pp
barto l kozik constraint satisfaction bounded width
proceedings annual symposium foundations computer science focs
pp
bodirsky complexity classification infinite domain constraint satisfaction
memoire dhabilitation diriger des recherches universite diderot paris available
arxiv
bodirsky chen h pinsker reducts equality primitive
positive interdefinability journal symbolic logic
bodirsky dalmau v datalog constraint satisfaction infinite templates appear journal computer system sciences preliminary
version appeared proceedings symposium theoretical aspects
computer science stacs
bodirsky hils krimkevitch tractable set constraints proceedings
international joint conferences artificial intelligence ijcai pp
bodirsky hils martin b scope universal algebraic constraint satisfaction appear logical methods computer science lmcs available arxiv v extended abstract
announced appeared proceedings logic computer
science lics
bodirsky kara j complexity equality constraint languages theory
computing systems conference version appeared proceedings
computer science russia csr
bodirsky kara j complexity temporal constraint satisfaction journal acm extended abstract appeared
proceedings symposium theory computing stoc
bodirsky kutz determining consistency partial tree descriptions
artificial intelligence
bodirsky nesetril j constraint satisfaction countable homogeneous
templates journal logic computation
boole g investigation laws thought walton london reprinted
philisophical library york


fibodirsky hils

broxvall jonsson p renz j disjunctions independence refinements
artificial intelligence
bulatov tractable conservative constraint satisfaction proceedings symposium logic computer science lics pp ottawa
canada
bulatov dichotomy theorem constraint satisfaction
element set journal acm
bulatov dalmau v simple maltsev constraints siam
journal computing
bulatov krokhin jeavons p g classifying complexity
constraints finite algebras siam journal computing
cohen jeavons p jonsson p koubarakis building tractable disjunctive
constraints journal acm
dowling w f gallier j h linear time testing satisfiability
propositional horn formulae journal logic programming
drakengren jonsson p reasoning set constraints applied tractable
inference intuitionistic logic journal logic computation
garey johnson guide np completeness csli press stanford
hodges w model theory cambridge university press
idziak p markovic p mckenzie r valeriote willard r tractability
learnability arising algebras subpowers siam journal computing
jonsson p backstrom c unifying temporal constraint reasoning
artificial intelligence
jonsson p drakengren complete classification tractability rcc
journal artificial intelligence
koppelberg projective boolean algebras handbook boolean algebras
vol pp north holland amsterdam york oxford tokyo
koubarakis tractable disjunctions linear constraints basic applications temporal reasoning theoretical computer science
krotzsch rudolph hitzler p complexity horn description
logics owl experiences directions workshop
kuncak v nguyen h h rinard c deciding boolean algebra presburger arithmetic journal automatic reasoning
kuncak v rinard c towards efficient satisfiability checking boolean
algebra presburger arithmetic proceedings international conference
automated deduction cade pp
kusters r molitor r approximating specific concepts description
logics existential restrictions ai communications


fitractable set constraints

lassez j l mcaloon k independence negative constraints international
joint conference theory practice software development tapsoft pp
marriott k odersky negative boolean constraints theoretical computer
science
schaefer j complexity satisfiability proceedings
symposium theory computing stoc pp
szendrei clones universal algebra seminaire de mathematiques superieures
les presses de luniversite de montreal




