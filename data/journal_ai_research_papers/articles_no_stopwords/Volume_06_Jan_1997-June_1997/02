journal artificial intelligence

submitted published

uniform framework concept definitions
description logics
giuseppe de giacomo

degiacomo dis uniroma

universita di roma la sapienza
via salaria roma italy

maurizio lenzerini

lenzerini dis uniroma

universita di roma la sapienza
via salaria roma italy

abstract

modern formalisms used databases artificial intelligence describing
application domain notions class concept relationship among
classes one interesting feature formalisms possibility defining class
e providing set properties precisely characterize instances class
many recent articles point several ways assigning meaning
class definition containing sort recursion argue instead
choosing single style semantics achieve better adopting formalism
allows different semantics coexist demonstrate feasibility argument
presenting knowledge representation formalism description logic alcq
characteristics addition constructs conjunction disjunction negation
quantifiers qualified number restrictions alcq includes special fixpoint constructs
express suitably interpreted recursive definitions constructs enable usual
frame descriptions combined definitions recursive data structures
directed acyclic graphs lists streams etc establish several properties alcq
including decidability computational complexity reasoning formulating
correspondence particular modal logic programs called modal mu calculus

introduction
modern formalisms used databases artificial intelligence representing
application domain notions class concept relationship among
classes example object oriented semantics data developed databases
describe data terms classes sometimes called entity types incorporate several
features establishing forms relationships classes hand
notion class often called concept frame link among classes provided
structured formalisms knowledge representation frame languages semantic
networks description logics etc finally notion present several type systems
programming languages specially object oriented paradigm
basically two ways describing classes concepts first one
call prescriptive description formalism allows expressing
number properties class thus prescribing constraints instances class
must satisfy second one call definitional formalism
allows providing definition class e set properties precisely character c ai access foundation morgan kaufmann publishers rights reserved

fide giacomo lenzerini

ize instances class prescriptive quite well understood
established definitional still subject interesting debate regarding
nature semantic foundation particular well known
ways assign meaning class definition contains sort recursion
baader nebel beneventano bergamaschi beeri
concerned semantic related definitional
arguing instead choosing single style semantics knowledge
representation formalism achieve better allowing different semantics coexist
discuss issue context description logics logics originally
developed knowledge representation provide formal reconstruction frame
languages description logics describe domain interest terms concepts
represent classes individuals roles binary relations used specify properties attributes individuals well links individuals nebel starting
atomic concepts denoted simply name complex concepts built suitable set constructs example expression parent u male u child male
denotes concept father male parent whose children male symbol u
denotes construct concept conjunction denotes universal role quantification
typically concepts structured hierarchies determined properties associated
hierarchical structure defined way specific concepts
inherit properties general ones
introduce description logic called alcq extends well known description logic alc schmidt schau smolka including called qualified
number restrictions general form cardinality constraints roles
special fixpoint constructs enable us capture semantics recursive
definitions within single formalism notably availability constructs makes
possible combine usual frame descriptions definitions recursive data
structures directed acyclic graphs lists streams etc
establish several properties alcq including decidability computational complexity reasoning formulating correspondence particular modal
logic programs called modal mu calculus
recent articles e g bergamaschi sartori borgida advocate use
description logics unifying framework several types database knowledge
representation formalisms indeed possible depending constructs semantics used one capture several database programming
language type systems description logics therefore study presented merely confined description logics applicable representation
formalisms
organized follows section present basic notions regarding
description logics fixpoints section motivate
detailed discussion different semantics concept definitions
considered literature argue formalism semantics
coexist section present one formalism namely logic alcq
called concept languages terminological languages



ficoncept definitions description logics

discuss several properties section study reasoning techniques alcq
expose correspondence modal mu calculus finally section draw
conclusions discuss open

preliminaries
section brie present basic notions regarding description logics
fixpoints interested reader referred nebel de bakker
complete introduction subjects

description logics

description logics allow one represent domain interest terms concepts
roles concepts model classes individuals roles model relationships classes
starting atomic concepts denoted atomic roles denoted r
concepts roles described simply name complex concepts roles built
means suitable constructs
section concentrate description logic alcq obtained description logic alc schmidt schau smolka including qualified number restrictions cardinality constraints role fillers general form
role fillers constraint applies selected means generic concept
expression qualifier
alcq concepts denoted c possibly subscript composed inductively
according following abstract syntax n denotes natural number

c j j j c j c u c j c c j r c j r c j n r c j n r c
constructs independent following equalities hold

r c r c n r c n r c

semantic point view concepts interpreted subsets abstract domain
roles interpreted binary relations domain precisely
interpretation consists domain interpretation interpretation
function mapping every atomic concept subset every atomic role r
subset
interpretation function extended complex concepts alcq note
alcq roles atomic follows



c
c u c
c c
r c
r c
n r c
n r c















c

c c
c c
fs j ri c g
fs j ri implies c g
fs j fs j ri c g ng
fs j fs j ri c g ng


fide giacomo lenzerini

denotes cardinality set
concept c satisfiable iff exists interpretation c otherwise
c unsatisfiable concept c subsumed concept c written c v c iff
every interpretation c c
knowledge expressed terms concepts roles assembled special
knowledge base traditionally called tbox consists finite possibly empty set
assertions order general possible assume every assertion
form inclusion assertion simply inclusion

c v c

without restriction form concepts c c pair inclusions
form fc v c c v c g often written c c called equivalence assertion
interpretation satisfies inclusion c v c iff c c interpretation
model tbox k iff satisfies inclusions k
let k tbox say concept c satisfiable k iff exists model
k c unsatisfiable otherwise say concept c subsumed
concept c k written k j c v c iff every model k c c

fixpoints

brie recall notions fixpoints consider equation
x f x
f operator denotes set subsets set every
solution e equation called fixpoint operator f every set e
f e e called pre fixpoint every set e e f e called post fixpoint
general equation one may solution finite number
solutions infinite number among solutions smallest
greatest solutions respect set inclusion prominent position exist
fundamental due tarski tarski guarantees existence uniqueness
solutions case f monotonic wrt set inclusion f monotonic
wrt whenever e e implies f e f e
theorem tarski let set f operator monotonic
wrt
exists unique least fixpoint f given tfe j f e eg
exists unique greatest fixpoint f given sfe j e f e g

concept definitions equations

analyze notion concept definition detail let us ignore moment
knowledge bases introduced previous section let us consider
different kind assertion definition statement let form definition statement
simply definition
def c


ficoncept definitions description logics

atomic concept cannot appear left hand side definition
statements c concept expression alcq principle def c intended
provide exact account concept terms c e define set
individuals satisfying c
specifying semantics definitions need distinguish two different
types atomic concepts namely primitive concepts defined concepts given set
definition statements primitive concepts atomic concepts appear
left hand side definition statement whereas defined concepts
appear left hand side definition statement
given interpretation interpretation function directly assigns
subset primitive concepts defined concepts meaning
defined concept assigned definition statement def c extending
interpretation function following requirement satisfied
ai c

consider example definition statement
parent def child
note defined concept parent appear body definition statement
definition statement provides definition concept parent
following sense interpretation parenti denotes single subset
exactly one denoted child e fs j childi g general concept
defined terms primitive already defined concepts every interpretation
exists unique way extend interpretation function defined concepts
hence doubt definition statement provides definition
consider following definition statement
def child
given interpretation statement interpreted equation
ai fs j childi ai g
however equation specify univocally extend interpretation function
defined concept since satisfies equation well set individuals
member infinite chain descendants members
general call recursive definition statements simply recursive definitions
definition statements form
def f
f stands concept subconcept according recursive
definition def f interpreted simply sort equation specifying given
terminological cycles baader nebel present discussion sake simplicity consider mutual recursive definitions def f b b def f shall come
back point later
subconcept concept c substring c including c concept according
syntax rules




fide giacomo lenzerini

interpretation subset tied defined concept must satisfy
equation ai f e must one solutions observe general
none one several subsets may exist solutions equation
another convenient way consider definition statement associate every
interpretation operator subsets subsets instead equation
fixpoints operator correspond solutions equation example
definition def child associate operator

fs j childi g
interpretation general none one multiple solutions exist
equation associated recursive definition none one multiple
fixpoints exist corresponding operator
situation word definition seems misleading body definition
give complete account defined concept additional criterion needed
selecting solutions associated equation equivalently fixpoints associated
operator words addition criterion needed extend univocally
interpretations defined concepts observation led semantics
interprets recursive definitions differently choosing priori
solutions equivalently fixpoints assigned defining
concept recursive definition

different semantics recursive definitions

literature description logics three semantics recursive definitions
proposed see nebel

descriptive semantics
least fixpoint semantics
greatest fixpoint semantics
semantics right one long standing matter debate
describe three semantics interprets recursive definitions present
examples showing choice semantics depends fact upon concept
defined first stressed descriptive semantics able
assign meaning general inclusion assertions c v c introduced previous section
according descriptive semantics recursive definition def f constraint stating ai solution equation ai f
descriptive semantics def child simply states individuals class
child class individuals child class
class better specified general descriptive semantics appropriate properly define recursive concepts sense given
remark non recursive definition interpreted semantics way since
every equation associated single solution



ficoncept definitions description logics

interpretation unable assign unique subset defined concept
recursive definition
fact descriptive semantics definition statements indistinguishable
equivalence assertions introduced previous section words meaning
assigned def f assigned equivalence assertion f
although equivalence assertions used specify constraints
provide proper definitions recursion involved example express
fact humans mammals parents humans converse
mammals parents humans humans terms
equivalence assertion

human mammal u parent u parent human
similarly may require horses satisfy analogous property

horse mammal u parent u parent horse
however two equivalence assertions define human horse shown

e g fact correctly imply humans horses vice versa
contrast happen fixpoint semantics used see
least fixpoint semantics interprets recursive definition statement def f
assigning smallest possible extension interpretation among
satisfy ai def f e least fixpoint corresponding operator fact
assumed operator associated definition statement monotonic
theorem applies least fixpoint exists unique e corresponding
equation unique smallest solution hence least fixpoint semantics
recursive definition statement def f defines concept easy verify
example def child least fixpoint semantics leads us identify
indeed empty set solution equation associated statement
obviously smallest solution similarly interpret definition statement
human def mammal u parent u parent human
least fixpoint semantics humani interpretation
observe adopt similar definition horse get horsei
trivially infer horse human
least fixpoint semantics particularly suitable providing inductive definitions
concepts example consider class list list defined follows
empty list list
node exactly one successor list list
nothing else list
first two conditions captured following recursive definition statement
list def emptylist node u succ u succ list
additionally specify two concepts emptylist node disjoint



fide giacomo lenzerini

succ forces succ function enforce third condition must
assign smallest possible extension list thus class lists naturally
defined means definition statement interpreted according least
fixpoint semantics
greatest fixpoint semantics interprets recursive definition statement def f
assigning largest possible extension interpretation among
satisfy ai def f e greatest fixpoint corresponding operator
assumed operator monotonic order guaranty existence unicity
greatest fixpoint theorem least fixpoint semantics greatest
fixpoint semantics recursive definition statement def f defines concept
example considering definition statement def child greatest fixpoint
semantics leads us interpret class individuals child
turn member
least fixpoint semantics naturally captures classes defined induction
greatest fixpoint semantics naturally captures classes individuals whose structure nonwell founded co inductive example class streams modeling linear data structure node first element rest
structure stream note streams similar lists except lists
considered finite sequences nodes streams infinite sequences nodes
class captured following recursive definition statement

stream def node u succ u succ stream
proviso greatest possible extension assigned stream
finally consider greatest fixpoint semantics recursive definition statements
human def mammal u parent u parent human
horse def mammal u parent u parent horse
although assign empty extension human horse least
fixpoint semantics rather counter intuitive consequence
human horse since humani horsei interpretation general
types fixpoint semantics particular name used denote defined concept
impact interpretation since meaning defined concept
completely specified definition statement

least greatest fixpoints concept constructs

considerations arguing right semantics recursive definitions really issue captures essential use recursive
equations descriptive semantics appropriate specify constraints concepts
one extends general inclusion assertions introduced section
least fixpoint semantics appropriate define structure inductively greatest fixpoint
semantics appropriate define non well founded structures generally may need
three knowledge base order model properties
different concepts


ficoncept definitions description logics

proposal exactly direction reconciling semantics
knowledge base pursued means logic incorporates two
constructs x f x x f x symbols x stand concept variables
denoting respectively least fixpoint greatest fixpoint operator associated
definition x def f x every smallest solution greatest
solution equation x f x
definition statements never appear tbox instead knowledge
base simply set inclusion assertions interpreted according descriptive semantics involve fixpoint constructs example order specify properties
concepts list stream human horse use following assertions
list
x emptylist node u succ u succ x
stream x node u succ u succ x

human mammal u parent u parent human
horse mammal u parent u parent horse

note add knowledge base equivalence assertion

mgm x mammal u parent u parent x
defining concept mgm mammal generated mammal correctly turns
human horse subsumed mgm

availability least greatest fixpoint constructs allowing different semantics
used tbox makes possible model abstract classes
inductively co inductively defined data structures lists streams
particularly important objective integrate class representation formalisms
programming systems declarative procedural order make formalisms
useful practice furthermore possibility nesting fixpoints thus
going beyond simple equational format motivated introduction
example consider following one
among inhabitants planet plonk disease called foo quite
common disease manifests two forms visible one
latent one rather intricate hereditary pattern individuals
visible form transmit visible form least one say first direct
descendant obviously direct descendant ill descendants
turn someone transmits latent form
disease precisely along chain descendants visible form
disease sooner later interrupted individual direct
descendant individual transmits descendant latent form
direct descendants individual latent form inherit
visible form pattern goes generation generation forever
hereditary pattern foo hp disease defined follows
foo hp x visible u child child
latent u child visible u x
include assertion emptylist v node specifying concepts emptylist node
disjoint



fide giacomo lenzerini

visible latent denote visible latent form respectively disease
assumed disjoint latent v visible

description logic alcq
provide formal account meaning fixpoint constructs introducing
description logic called alcq obtained adding constructs alcq
make use notions scope bound free occurrences variables closed
formulae etc definitions notions analogues first order
logic treating quantifiers addition use symbol abstraction

primitive symbols alcq atomic concepts concept variables denoted
x atomic roles roles admitted logic
concepts alcq formed inductively according following abstract syntax

c j j j c j c u c j c c j r c j r c j n r c j n r c j
x c j x c j x
denotes atomic concept r atomic role n natural number x variable
restriction variable x occurring positively c bounded
fixpoint x c say variable x occurs positively concept c every
free occurrence x scope even number negations considering concepts
c n r c scope one negation
two fixpoint constructs mutually definable x c x c x x
c x x concept obtained substituting free occurrences x concept
x
interpretation consists domain interpretation
interpretation function maps every atomic concept subset every
atomic role subset presence free variables allow us
extend interpretation function directly every concept logic reason
introduce valuations valuation interpretation mapping variables
subsets
given valuation denote x e valuation identical except
x e x e words every variable



x
x e e ifif yy
x
let interpretation valuation assign meaning concepts
logic associating extension function mapping concepts subsets
follows


ficoncept definitions description logics

xi
ai



c
c u c
c c
r c
r c
n r c
n r c

x c
x c















x
ai




ci
c c
c c
fs j ri ci g
fs j ri implies ci g
fs j fs j ri ci g ng
fs j fs j ri ci g ng

j ci x e e g
sfe
fe j e ci x e g

last two cases ci x e interpreted operator subsets e subsets
syntactic restriction enforced variables operator guaranteed
monotonic wrt notice free variables appearing concept interpreted
similarly atomic concepts
concept c satisfiable exists interpretation valuation
ci otherwise c unsatisfiable concept c subsumed concept c
written c v c every interpretation every valuation c c
alcq tbox finite possibly empty set inclusion assertions c v c
c c closed concepts alcq use equivalence assertions
form c c abbreviation fc v c c v c g
interpretation satisfies inclusion assertion c v c c c
valuation c c closed hence independent valuations
model tbox k satisfies inclusion assertions k say tbox
k satisfiable model observe inclusion assertions k interpreted
according descriptive semantics
say tbox k logically implies inclusion assertion c v c written k j
c v c every model k every valuation c c

properties fixpoint constructs

following use notation c x indicate variable x occurs free
concept c variables could occur free c well notation c
concept shorthand c x x e concept obtained substituting
free occurrences x c x concept
let us comment brie simple properties logic first concept
x c x equivalent concept c long free x c x second
extension function assign closed concept value independent actual
valuation hence x c x occur c equivalent c third since
x c x fixpoint c x c x equivalent x c x furthermore
concept x c x subsumed concept x c x


fide giacomo lenzerini

next property substantial consider class single source finite
directed acyclic graphs dags defined inductively follows
empty dag dag base step

node connections connections dags dag inductive
step

nothing else dag
consider alcq tbox k containing two equivalence assertions
dag student x emptydag student u arc u arc x
dag person x emptydag person u arc u arc x

define concepts dag student dag person classes dags whose
nodes students persons respectively assuming students persons want
able infer dags students dags persons well want

k j student v person implies k j dag student v dag person
turns alcq property holds prove introduce

following two theorems

theorem let k alcq tbox c two alcq concepts
variable x occurs free positively
k j c v implies k j x c v x
proof proceed contradiction assume ci di holds k
valuations suppose exists model k valuation
x c x

first prove let individual x c
x

x c iff e ci x e e implies e



x iff e di x e e e





set e following expression holds

ci x e di x e e




assume leaf dag node arcs leading special dag called empty dag
alternative one assume leaf dag node connection
latter case definition dag would simplify dag def node u arc dag general form
inductive definitions e base case inductive case less apparent
uniformity distinguish x occurs free obviously x occur free
trivial



ficoncept definitions description logics

hence e e impossible
proof similar let individual x c x


x c iff e e ci x e e



x iff e e di x e implies e





set e following expression holds

e ci x e di x e






hence e e impossible
defined means variable x occur positively concept c
similarly say variable x occurs negatively concept c every free occurrence
x scope odd number negations considering concepts c n r c
scope one negation

theorem let k alcq tbox x alcq concept variable x
free variable alcq concepts c c
k j c v c implies



k j c v c x occurs positively x
k j c v c x occurs negatively x

proof prove induction formation x

base case x x holds trivially
inductive cases x form x j n r c x occurs positively
negatively x negatively positively x induction hypothesis k j
ci v cj j f g j hence semantics constructs
k j cj v ci
x form x u x j x x j r x j n r x
x occurs positively negatively x x induction hypothesis
k j ci v cj hence semantics constructs k j ci v cj
remains prove x x x case
syntactic restriction enforced occurs positively x hence theorem
k j ci v cj implies k j ci v cj thus induction hypothesis
done
going back example fact infer dags students dags
persons indeed applying theorem theorem k j student v
person implies k j x emptydag studentu arc u arc x v x emptydag person u
arc u arc x


fide giacomo lenzerini

internalizing assertions

logical implication alcq tboxes thus satisfiability alcq
tboxes reducible unsatisfiability single alcq concept prove
introduce notions generated sub interpretation sub valuation
let interpretation
valuation individual



define interpretation valuation follows
fs j r rmi g
atomic role ri rii rii
atomic concept ai ai
variable x x x
call sub interpretation generated sub valuation generated

generated sub interpretations sub valuations state following lemma

lemma let c alcq concept interpretation valuation
individual
ci iff ciss
proof without loss generality consider concepts formed according following
simplified abstract syntax c j j c j c u c j r c j n r c j x c j x

prove induction number nested fixpoint constructs base
case c fixpoint constructs thesis proven induction
formation c
inductive case assume thesis holds concepts c k nested fixpoint
constructs prove concepts x c k recall tarskiknaster theorem fixpoints tarski x c iff exists ordinal
x c x c defined transfinite induction
x c

x c ci x x c
x c sff ffx c limit ordinal


hence proceed transfinite induction ordinals
base case transfinite induction x c defined thus trivially
x c iff x c iss
successor case transfinite induction want x c iff
x c iss reduces

ci x x c iff ciss x x c ss




together notions play role generated sub model modal logics





ficoncept definitions description logics

prove start showing

ciss x x c ss iff c x x c






notice two valuations may differ value x holds

xiss x x c ss iff x x x c






straightforward induction formation c holds well
let us prove write

x x c iss x iff x x c x
since reduces

x c iss iff x c
holds transfinite inductive hypothesis
since c contains k fixpoint constructs inductive hypothesis k

ci x x c iff c x x c




hence considering follows indeed x c iff x c iss
limit case transfinite induction let limit ordinal x c iff
exists ordinal x c transfinite induction hypothesis
holds x c iff x c iss thus

x c iff x c iss
completes transfinite induction ordinals holds

x c iff x c iss
induction nesting fixpoint constructs completed well hence
proven lemma
ready state mentioned

theorem let k fc v cq v dq g alcq tbox c two
alcq concepts k j c v alcq concept
x r x u u rm x u ck u c u

unsatisfiable r rm atomic roles appearing k ck c
u u cq dq


fide giacomo lenzerini

proof part contradiction assume satisfiable suppose
k j c v e exists interpretation valuation
model k ci di follows exists individual
ci hand fact model k implies
ck thus x r x u u rm x u ck
x r x u u rm x u ck u c u e satisfiable contradicting

hypotheses
part proceed contradiction assume k j c v suppose
satisfiable e exists interpretation valuation
individual x r x u u rm x u ck u c u
consider sub interpretation iss sub valuation
generated one hand clearly ck iss hence model
k hand lemma x r x u u rm x u ck u c u iss
follows satisfy subsumption c v contradicting hypotheses



states satisfiability alcq concepts logical implication
alcq tboxes thus satisfiability alcq tboxes distinct reasoning
tasks hence following limit attention concept satisfiability without
loss generality

reasoning fixpoints

section concentrate developing reasoning methods check satisfiability
concepts involving fixpoints particular exhibit correspondence alcq
well known logic programs called modal mu calculus kozen kozen
parikh streett emerson recently investigated
expressing temporal properties reactive parallel processes stirling larsen
cleaveland winsket dam
get better insight correspondence two logics first study
sublanguage alc obtained alcq leaving qualified number restrictions
study full logic alcq

reasoning alc

let us introduce modal mu calculus formally formulae modal mu calculus
formed inductively atomic formulae variables x according
following abstract syntax
j j j j j j hai j j x j x j x
generic element set labels l every bounded occurrence every
variable x must scope even number negation signs
observe theorem qualified number restrictions play role hence exactly reduction
logical implication unsatisfiability holds alc well allows us restrict attention
satisfiability



ficoncept definitions description logics

semantics modal mu calculus notions kripke structure
valuation kripke structure triple fri j lg v set states
ri binary relation v mapping atomic formulae subsets
valuation mapping variables subsets kripke structure
valuation associated extension function
defined inductively
follows
xm
x

v



















hai
fs j ra

g
ra implies g


f



j






x
sfe j x e e g
x
fe j e

x e g
formula satisfiable exists kripke structure valuation


following theorem basis correspondence alc modal
mu calculus

theorem exists one one linear time function q mapping concepts alc
formulae modal mu calculus alc concept c c satisfiable
q c satisfiable

proof define q following way q atomic concepts mapped
atomic formulae q x x q q q c q c q r c
hriq c atomic roles mapped labels q r c r q c q x c x q c
q x c x q c
interpretation equivalent kripke structure fri j
lg v l equal set names atomic roles interpreted
rr ri atomic role r v ai atomic concept
addition valuation equivalent valuation extension
function associated extension function associated
map respectively concept c corresponding formula q c subset
hence thesis follows
follows may transfer decidability complexity modal
mu calculus kozen parikh emerson jutla safra alc thus
immediately state complexity reasoning alc concepts
alc tboxes

theorem satisfiability alc concepts satisfiability alc tboxes logical
implication alc tboxes exptime complete


fide giacomo lenzerini

proof satisfiability modal mu calculus exptime complete emerson
jutla hence theorem theorem thesis follows

reasoning alcq
next exhibit mapping alcq concepts formulae variant modal mucalculus called deterministic modal mu calculus syntax modal
mu calculus interpreted deterministic kripke structures kripke structures fri j lg v relations ri partial functions streett
emerson
let us ignore moment qualified number restriction constructs formulae
alcq without qualified number restrictions fact formulae modal mucalculus shown previous section well known technique developed
propositional dynamic logic parikh nondeterministic modal mu calculus formulae reduced deterministic modal mu calculus formulae streett emerson
shown
use following notations usual operations binary relations chaining
exive transitive closure transitive closure converse use
following abbreviations
r
r



hr
hr

x r x
r r
x hrix
hrihr

reduction follows formula recursively replace subformulae
form r r rnew subformulae form hri hrih rnew
rnew symbol r rnew resulting formula interpreted
partial functions let us call resulting formula satisfiable
satisfiable
brie sketch reasoning behind proof statement direction
easy suces observe frdi j ld g v model
transform model fri j lg v defining
l ld rr rdr rdnew v v direction follows
recall nondeterministic deterministic modal mu calculus tree model
property streett emerson formula model tree model
e model form tree without loss generality restrict
attention tree one one transformation tree
frti j lt g v tree b b frbi j lb g v b
indeed put b v b v lb lt given state x
given model get tree model simply unfolding original one



ficoncept definitions description logics

rtr successors z zl put x z rbr zi zi rbrnew l
way x zi rtr x zi rbr rbrnew

remark required tree get b need recover
original rtr predecessor x state zi namely need rbr rbrnew
partial function otherwise given state zi would know
rbr rbrnew successors original rtr predecessor x therefore would
able reconstruct b
interpreting r rnew partial functions easy express qualified number
successors state example
restrictions constraints chain r rnew
r expressed
r rnew rnew rnew rnew
read everywhere along chain r rnew three states
holds corresponds exactly intended meaning similarly r
expressed

hrih rnew h rnew h rnew
read somewhere along chain r rnew least three states
holds corresponds exactly intended meaning
discussion allows us state following

theorem exists polynomial function mapping concepts alcq formulae
deterministic modal mu calculus alcq concept c c satisfiable

u c satisfiable

proof function defined inductively follows
u
u x
u c u c
u c c
u c
u x c
u x c
u r c
u r c


x
u c u c
u c u c
u c
x u c
x u c
hrih rnew iu c
r rnew u c
rnew role finally n r c n r c mapped following










formulae

implicitly assume finite branching tree model done without loss
generality since modal mu calculus finite model property hence unfolding finite model
get finite branching tree model note however would suce assume countable
branching tree model
note construction similar one often used programming reduce n ary trees
binary trees coding children node combination one child siblings



fide giacomo lenzerini

u n r c r rnew u c rnew u c
rnew u c rnew u c
number nested formulae form u c rnew n

u n r c hrih rnew u c h rnew u c
h rnew u c h rnew iu c
number nested formulae form u c h rnew n
u c clearly polynomial size c usual assumption numbers
c coded unary moreover following technique parikh streett emerson
exposed easy verify induction formation
concept c mapping preserves satisfiability
follows may transfer decidability complexity deterministic modal mu calculus streett emerson emerson jutla safra
alcq thus immediately state complexity reasoning
alcq concepts alcq tboxes

theorem satisfiability alcq concepts satisfiability alcq tboxes logical
implication alcq tboxes exptime complete
proof satisfiability deterministic modal mu calculus exptime complete

streett emerson emerson jutla safra hence theorem
theorem thesis follows

discussion conclusion

work presented stems de giacomo basic ideas
introducing explicit fixpoint first presented de giacomo lenzerini b
idea elaborated alcq first introduced
one main contributions work devise tight correspondence
description logics fixpoints modal mu calculus respect remark
alc corresponds directly modal mu calculus full alcq corresponds
variant modal mu calculus whose decidability complexity studied
precisely notion essentially equivalent qualified number restrictions
independently emerged modal logics namely graded modalities van der hoek
de rijke van der hoek fattorosi barnaba de caro fine
however combination fixpoints graded modalities investigated
setting modal logics given tight correspondence alc
modal mu calculus alcq considered modal mu calculus augmented graded
modalities hence apply logic well
reported bears several similarities one correspondence description logics propositional dynamic logics baader


ficoncept definitions description logics

schild de giacomo lenzerini de giacomo fact characterize description logics propositional dynamic logics role constructs
chaining choice test exive transitive closure roles limited
form fixpoint role constructs easily expressed explicit fixpoints
introduced suce resort following equivalences
r r c r r c
r r c r c r c
r c x c r x
id c c u
note r c x c u r x calvanese de giacomo lenzerini
implicit form fixpoint advocated called well founded role
construct wf r explicit fixpoints wf r expressed simply x r x
proposal allowing fixpoint constructs explicitly formalism shared
study independently carried schild schild main goal
work study expressive power computational complexity
subsumption satisfiability tboxes expressed alc fixpoint constructs
allow mutually recursive definitions end description logic defined
corresponds variant modal mu calculus mutual fixpoints allowed
restrictions nested fixpoints enforced vardi wolper well
known mutual fixpoints expressed means nested ones see example
park de bakker consequence observation follows logic
introduced expressive one analyzed schild since
one hand allows nesting fixpoints without restriction hand
makes possible state sophisticated forms cardinality constraints role fillers
means qualified number restrictions
present work extended along several directions conclude outlining
two
already noticed fixpoint constructs allow representing abstract
classes several data structures extensively used software development
believe characteristic important step towards satisfactory integration
description logics traditional declarative programming systems indeed
description logic proposed provides powerful mechanisms data structure
modeling particular properties stated section base formulate
notion parametric concept instance expression named dag z
x emptydag z u arc u arc x
z formal parameter denotes class dags whose nodes left unspecified
class used several ways tbox example instantiated
binding formal parameter actual parameters thus getting say dag student
dag person etc concepts inheriting properties dag z
schild number restrictions considered
note parametric concepts introduced simpler logics include fixpoint
constructs



fide giacomo lenzerini

although alcq powerful logic lacks construct inverse roles
needed example correctly capture notions finite tree binary tree etc
indeed define concept tree empty tree tree node
one parent children children trees tree nothing else
tree write tree x empty tree node u child u child u child x
child denotes inverse child notice introduction inverse roles
pose diculty semantical point view however impact
reasoning method needs investigated generally wide variety concept
constructs studied conjunction fixpoints description logics
related propositional dynamic logics de giacomo lenzerini calvanese
et al de giacomo may give us hints proceed along direction

references

baader f terminological cycles kl one knowledge representation languages proc th nat conf artificial intelligence aaai pp
boston
baader f augmenting concept languages transitive closure roles alternative terminological cycles proc th int joint conf artificial
intelligence ijcai sydney australia
beeri c formal object oriented databases data knowledge
engineering
beneventano bergamaschi subsumption complex object data
proc th int conf database theory icdt lecture
notes computer science pp springer verlag
bergamaschi sartori c taxonomic reasoning conceptual design acm
transaction database systems
borgida type systems knowledge representation natural semantics
specifications description logics journal intelligent cooperative information
systems
calvanese de giacomo g lenzerini structured objects modeling
reasoning proc th int conf deductive object oriented databases
dood lecture notes computer science springer verlag
cleaveland r tableaux model checking propositional mu calculus
acta informatica
dam ctl ectl fragments modal mu calculus proceeding
col trees algebra programming lecture notes computer
science pp springer verlag
de bakker j mathematical theory program correctness prentice hall


ficoncept definitions description logics

de giacomo g reconciling different semantics concept definition extended
abstract proc st compulog net meeting knowledge representation
reasoning systems cnkrr
de giacomo g decidability class knowledge representation formalisms
ph thesis dipartimento di informatica e sistemistica universita di roma la
sapienza
de giacomo g lenzerini boosting correspondence description
logics propositional dynamic logics proc th nat conf artificial
intelligence aaai pp aaai press mit press
de giacomo g lenzerini b concept language number restrictions
fixpoints relationship mu calculus proc th eur conf
artificial intelligence ecai pp john wiley sons
de giacomo g lenzerini aggregate foundation description
logics tuples set proc th int conf artificial intelligence
ijcai
emerson e jutla c complexity tree automata logics
programs proc th symp foundations computer science
focs pp
fattorosi barnaba de caro f graded modalities studia logica

fine k many possible worlds notre dame journal formal logic

kozen propositional mu calculus theoretical computer science

kozen parikh r decision procedure propositional mu calculus
proc nd work logic programs lecture notes computer
science pp springer verlag
larsen k j proof systems satisfiability hennessy milner logic recursion
theoretical computer science
nebel b reasoning revision hybrid representation systems
lecture notes artificial intelligence springer verlag
nebel b terminological cycles semantics computational properties sowa
j f ed principles semantic networks pp morgan kaufmann los
altos
parikh r propositional dynamic logic programs survey proc
st work logic programs lecture notes computer science pp
springer verlag


fide giacomo lenzerini

park finiteness mu ineffable theoretical computer science
safra complexity automata proc th symp
foundations computer science focs pp
schild k correspondence theory terminological logics preliminary report
proc th int joint conf artificial intelligence ijcai pp
sydney australia
schild k terminological cycles propositional calculus doyle j
sandewall e torasso p eds proc th int conf principles
knowledge representation reasoning kr pp bonn morgan
kaufmann los altos
schmidt schau smolka g attributive concept descriptions complements artificial intelligence
stirling c modal temporal logic abramsky gabbay maibaum
e eds handbook logic computer science pp clarendon press
oxford
streett r emerson e propositional mu calculus elementary
proc th int col automata languages programming
lecture notes computer science pp springer verlag
streett r emerson e automata theoretic decision procedure
propositional mu calculus information control
tarski lattice theoretical fixpoint theorem applications pacific journal
mathematics
van der hoek w semantics graded modalities journal applied
non classical logics
van der hoek w de rijke counting objects journal logic computation
vardi wolper p automata theoretic techniques modal logics
programs proc th symp foundations computer science
focs pp
winsket g note model checking modal calculus proc th
int col automata languages programming lecture notes
computer science pp springer verlag




