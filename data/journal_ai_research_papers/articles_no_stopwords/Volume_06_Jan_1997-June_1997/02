Journal Artificial Intelligence Research 6 (1997) 87-110

Submitted 7/96; published 3/97

Uniform Framework Concept Definitions
Description Logics
Giuseppe De Giacomo

degiacomo@dis.uniroma1.it

Universita di Roma \La Sapienza"
Via Salaria 113, 00198 Roma, Italy

Maurizio Lenzerini

lenzerini@dis.uniroma1.it

Universita di Roma \La Sapienza"
Via Salaria 113, 00198 Roma, Italy

Abstract

modern formalisms used Databases Artificial Intelligence describing
application domain based notions class (or concept) relationship among
classes. One interesting feature formalisms possibility defining class,
i.e., providing set properties precisely characterize instances class.
Many recent articles point several ways assigning meaning
class definition containing sort recursion. paper, argue that, instead
choosing single style semantics, achieve better results adopting formalism
allows different semantics coexist. demonstrate feasibility argument,
presenting knowledge representation formalism, description logic ALCQ,
characteristics. addition constructs conjunction, disjunction, negation,
quantifiers, qualified number restrictions, ALCQ includes special fixpoint constructs
express (suitably interpreted) recursive definitions. constructs enable usual
frame-based descriptions combined definitions recursive data structures
directed acyclic graphs, lists, streams, etc. establish several properties ALCQ,
including decidability computational complexity reasoning, formulating
correspondence particular modal logic programs called modal mu-calculus.

1. Introduction
modern formalisms used Databases Artificial Intelligence representing
application domain based notions class (or concept) relationship among
classes. example, object-oriented semantics data models developed Databases
describe data terms classes (sometimes called entity types) incorporate several
features establishing various forms relationships classes. hand,
notion class (often called concept frame) link among classes provided
structured formalisms Knowledge Representation (frame-based languages, semantic
networks, description logics, etc.). Finally, notion present several type systems
programming languages, specially based object-oriented paradigm.
basically two ways using describing classes (concepts). first one,
call prescriptive approach, description formalism allows expressing
number properties class, thus prescribing constraints instances class
must satisfy. second one, call definitional approach, formalism
allows providing definition class, i.e., set properties precisely character c 1997 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiDe Giacomo & Lenzerini

ize instances class. prescriptive approach quite well understood
established, definitional approach still subject interesting debate, regarding
nature semantic foundation. particular, well known
various ways assign meaning class definition contains sort recursion
(Baader, 1990, 1991; Nebel, 1991; Beneventano & Bergamaschi, 1992; Beeri, 1990).
paper, concerned semantic problems related definitional
approach, arguing that, instead choosing single style semantics knowledge
representation formalism, achieve better results allowing different semantics coexist.
discuss issue context Description Logics1 , logics originally
developed Knowledge Representation provide formal reconstruction frame-based
languages. Description logics describe domain interest terms concepts,
represent classes individuals, roles, binary relations used specify properties attributes individuals well links individuals (Nebel, 1990). Starting
atomic concepts, denoted simply name, complex concepts built using suitable set constructs. example, expression parent u male u 8child:male
denotes concept father (male parent) whose children male. symbol u
denotes construct concept conjunction, 8 denotes universal role quantification.
Typically, concepts structured hierarchies determined properties associated
them. hierarchical structure defined way specific concepts
inherit properties general ones.
introduce description logic, called ALCQ, extends well-known description logic ALC (Schmidt-Schau & Smolka, 1991) including called qualified
number restrictions, general form cardinality constraints roles,
special fixpoint constructs, enable us capture various semantics recursive
definitions within single formalism. Notably, availability constructs makes
possible combine usual frame-based descriptions definitions recursive data
structures directed acyclic graphs, lists, streams, etc.
establish several properties ALCQ, including decidability computational complexity reasoning, formulating correspondence particular modal
logic programs called modal mu-calculus.
Recent articles, (e.g., Bergamaschi & Sartori, 1992; Borgida, 1992), advocate use
description logics unifying framework several types database knowledge
representation formalisms. Indeed, possible show that, depending constructs semantics used, one capture several database models programming
language type systems using description logics. Therefore, study presented paper merely confined description logics, applicable representation
formalisms.
paper organized follows. Section 2, present basic notions regarding
description logics fixpoints. Section 3, motivate approach
detailed discussion different semantics concept definitions
considered literature, argue formalism various semantics
coexist. Section 4, present one formalism, namely logic ALCQ,
1. called Concept Languages Terminological Languages.

88

fiConcept Definitions Description Logics

discuss several properties. Section 5 study reasoning techniques ALCQ
expose correspondence modal mu-calculus. Finally, Section 6, draw
conclusions discuss open problems.

2. Preliminaries
section, brie present basic notions regarding description logics,
fixpoints. interested reader referred (Nebel, 1990) (de Bakker, 1980)
complete introduction subjects.

2.1 Description Logics

Description logics allow one represent domain interest terms concepts
roles. Concepts model classes individuals, roles model relationships classes.
Starting atomic concepts (denoted A) atomic roles (denoted R),
concepts roles described simply name, complex concepts roles built
means suitable constructs.
section, concentrate description logic ALCQ, obtained wellknown description logic ALC (Schmidt-Schau & Smolka, 1991) including qualified number restrictions. cardinality constraints role fillers general form,
role fillers constraint applies selected means generic concept
expression, qualifier.
ALCQ concepts (denoted C D, possibly subscript) composed inductively
according following abstract syntax (n denotes natural number):

C ::= j > j ? j :C j C1 u C2 j C1 C2 j 9R:C j 8R:C j ( n R:C ) j ( n R:C ):
constructs independent. following equalities hold: > = :A,

? = :>, 8R:C = :9R::C , ( n R:C ) = :( n + 1 R:C ).

semantic point view, concepts interpreted subsets abstract domain,
roles interpreted binary relations domain. precisely,
interpretation = (I ; ) consists domain interpretation , interpretation
function mapping every atomic concept subset every atomic role R
subset .
interpretation function extended complex concepts ALCQ (note
ALCQ roles always atomic) follows:

>I
?I
(:C )I
(C1 u C2 )I
(C1 C2 )I
(9R:C )I
(8R:C )I
( n R:C )I
( n R:C )I

=
=
=
=
=
=
=
=
=



;

, C

C1I \ C2I
C1I [ C2I
fs 2 j 9s0: (s; s0 ) 2 RI s0 2 C g
fs 2 j 8s0: (s; s0 ) 2 RI implies s0 2 C g
fs 2 j #fs0 j (s; s0) 2 RI s0 2 C g ng
fs 2 j #fs0 j (s; s0) 2 RI s0 2 C g ng
89

fiDe Giacomo & Lenzerini

#S denotes cardinality set .
concept C satisfiable iff exists interpretation C 6= ;, otherwise
C unsatisfiable. concept C1 subsumed concept C2, written C1 v C1, iff
every interpretation , C1I C2I .
knowledge expressed terms concepts roles assembled special
knowledge base, traditionally called TBox, consists finite (possibly empty) set
assertions. order general possible, assume every assertion
form inclusion assertion (or simply inclusion):

C1 v C2

without restriction form concepts C1 C2 . pair inclusions
form fC1 v C2 ; C2 v C1 g often written C1 C2 called equivalence assertion.
interpretation satisfies inclusion C1 v C2 iff C1I C2I . interpretation
model TBox K iff satisfies inclusions K.
Let K TBox. say concept C satisfiable K, iff exists model
K C 6= ;, unsatisfiable otherwise. say concept C1 subsumed
concept C2 K, written K j= C1 v C2 , iff every model K, C1I C2I .

2.2 Fixpoints

brie recall notions fixpoints. Consider equation:
X = f (X )
f operator 2S 2S (2S denotes set subsets set ). Every
solution E equation called fixpoint operator f (while every set E
f (E ) E called pre-fixpoint, every set E E f (E ) called post-fixpoint).
general, equation one may either solution, finite number
solutions, infinite number them. Among various solutions, smallest
greatest solutions (with respect set-inclusion) prominent position, exist.
fundamental result due Tarski (Tarski, 1955) guarantees existence uniqueness
solutions case f monotonic wrt set-inclusion (), f monotonic
wrt whenever E1 E2 implies f (E1 ) f (E2 ).
Theorem 1 (Tarski) Let set, f operator 2S 2S monotonic
wrt . Then:
exists unique least fixpoint f , given TfE j f (E ) Eg.
exists unique greatest fixpoint f , given SfE j E f (E )g.

3. Concept Definitions Equations

analyze notion concept definition detail. Let us ignore moment
knowledge bases introduced previous section, let us consider
different kind assertion: definition statement. Let form definition statement
(or simply definition) be:
=def C
90

fiConcept Definitions Description Logics

atomic concept cannot appear left-hand side definition
statements, C concept expression ALCQ. principle, =def C intended
provide exact account concept terms C , i.e., define set
individuals satisfying C .
specifying semantics definitions, need distinguish two different
types atomic concepts, namely, primitive concepts defined concepts. Given set
definition statements, primitive concepts atomic concepts appear
left-hand side definition statement, whereas defined concepts
appear left-hand side definition statement.
Given interpretation = (I ; ), interpretation function directly assigns
subset primitive concepts, defined concepts. meaning
defined concept assigned definition statement =def C , extending
interpretation function following requirement satisfied:
AI = C :
(1)
Consider, example, definition statement:
parent =def 9child:>:
Note defined concept parent appear body definition statement.
(1), definition statement provides definition concept parent,
following sense: interpretation = (I ; ), parentI denotes single subset ,
exactly one denoted (9child:>)I , i.e., fs j 9t:(s; t) 2 childI g. general, concept
defined terms primitive already defined concepts, every interpretation
exists unique way extend interpretation function defined concepts,
hence doubt definition statement provides definition A.
Now, consider following definition statement:
=def 9child:A:
Given interpretation = (I ; ), (1) statement interpreted equation:
AI = fs 2 j 9t:(s; t) 2 childI 2 AI g:
However equation specify univocally extend interpretation function
defined concept A, since ; satisfies equation well set individuals
member infinite chain descendants members.
general, call recursive definition statements2 (or simply recursive definitions),
definition statements form:
=def F (A)
F (A) stands concept subconcept3 . According (1), recursive
definition =def F (A) interpreted simply sort equation specifying that, given
2. Terminological cycles (Baader, 1990, 1991; Nebel, 1991). present discussion, sake simplicity, consider mutual recursive definitions, =def F (B ), B =def F (A). shall come
back point later on.
3. subconcept concept C substring C (including C itself) concept, according
syntax rules.
0

91

fiDe Giacomo & Lenzerini

interpretation , subset tied defined concept must satisfy
equation AI = F (A)I , i.e., must one solutions. Observe that, general, either
none, one, several subsets may exist solutions equation.
Another convenient way consider definition statement associate it, every
interpretation , operator subsets subsets instead equation,
fixpoints operator correspond solutions equation. example,
definition =def 9child:A associate operator:

S:fs 2 j 9t:(s; t) 2 childI 2 g
interpretation . general either none, one multiple solutions exist
equation associated recursive definition, either none, one multiple
fixpoints exist corresponding operator.
situation word \definition" seems misleading: body definition
give complete account defined concept. additional criterion needed
selecting solutions associated equation, equivalently, fixpoints associated
operator. words addition (1), criterion needed extend univocally
interpretations defined concepts. observation led various semantics,
interprets recursive definitions differently, choosing, priori
all, solutions, equivalently fixpoints, assigned defining
concept recursive definition4.

3.1 Different Semantics Recursive Definitions

literature description logics, three semantics recursive definitions
proposed (see Nebel, 1991):

Descriptive Semantics
Least Fixpoint Semantics
Greatest Fixpoint Semantics
semantics \right" one long standing matter debate.
describe three semantics interprets recursive definitions, present
examples showing choice semantics depends fact upon concept
defined. first, stressed descriptive semantics able
assign meaning general inclusion assertions C1 v C2 introduced previous section.
According Descriptive Semantics, recursive definition =def F (A) constraint stating that, , AI solution equation AI = F (A)I .
descriptive semantics, =def 9child:A simply states individuals class
child class A, individuals child class
class A, better specified. general descriptive semantics appropriate properly define recursive concepts, sense that, given
4. remark non-recursive definition interpreted various semantics way, since,
every , equation associated single solution.

92

fiConcept Definitions Description Logics

interpretation , unable assign unique subset defined concept
recursive definition.
fact descriptive semantics definition statements indistinguishable
equivalence assertions introduced previous section. words, meaning
assigned =def F (A) assigned equivalence assertion F (A).
Although equivalence assertions used specify if-and-only-if constraints,
provide proper definitions recursion involved. example, express
fact humans mammals parents humans, converse,
mammals parents humans humans themselves, terms
equivalence assertion:

human mammal u 9parent:> u 8parent:human:
Similarly may require horses satisfy analogous property:

horse mammal u 9parent:> u 8parent:horse:
However two equivalence assertions define human horse shown,

e.g., fact (correctly) imply humans horses vice-versa
(in contrast happen fixpoint semantics used, see below).
Least Fixpoint Semantics interprets recursive definition statement =def F (A)
assigning smallest possible extension interpretation , among
satisfy AI =def F (A)I { i.e., least fixpoint corresponding operator. fact
always assumed operator associated definition statement monotonic,
Theorem 1 applies least fixpoint exists unique, i.e., corresponding
equation unique smallest solution. Hence least fixpoint semantics
recursive definition statement =def F (A) defines concept A. easy verify
example =def 9child:A, least fixpoint semantics leads us identify ?.
Indeed empty set solution equation associated statement,
obviously smallest solution. Similarly interpret definition statement:
human =def mammal u 9parent:> u 8parent:human
least fixpoint semantics, humanI = ; interpretation .
Observe if, above, adopt similar definition horse, get horseI = ;,
trivially infer horse human.
least fixpoint semantics particularly suitable providing inductive definitions
concepts. example, consider class list (LIST) defined follows:
EMPTY-LIST LIST.
NODE exactly one successor LIST LIST.
Nothing else LIST.
first two conditions captured following recursive definition statement5 :
list =def emptylist (node u ( 1 succ:>) u 9succ:list)
5. Additionally specify two concepts emptylist node disjoint.

93

fiDe Giacomo & Lenzerini

( 1 succ:>) forces succ function. enforce third condition must
assign smallest possible extension list. Thus, class LISTs naturally
defined means definition statement, interpreted according least
fixpoint semantics.
Greatest Fixpoint Semantics interprets recursive definition statement =def F (A)
assigning largest possible extension interpretation , among
satisfy AI =def F (A)I { i.e., greatest fixpoint corresponding operator. Again,
assumed operator monotonic order guaranty existence unicity
greatest fixpoint (Theorem 1). least fixpoint semantics, greatest
fixpoint semantics recursive definition statement =def F (A) defines concept A.
example, considering definition statement =def 9child:A, greatest fixpoint
semantics leads us interpret class individuals child
turn member A.
least fixpoint semantics naturally captures classes defined induction,
greatest fixpoint semantics naturally captures classes individuals whose structure nonwell-founded co-inductive. example class STREAMs, modeling wellknown linear data structure NODE first element, rest
structure STREAM itself. Note streams similar lists except lists
considered finite sequences nodes, streams infinite sequences nodes.
class captured following recursive definition statement:

stream =def node u ( 1 succ:>) u 9succ:stream
proviso greatest possible extension assigned stream.
Finally, consider greatest fixpoint semantics recursive definition statements:
human =def mammal u 9parent:> u 8parent:human
horse =def mammal u 9parent:> u 8parent:horse:
Although assign empty extension human horse least
fixpoint semantics does, rather counter intuitive consequence
human horse, since humanI = horseI interpretation . general
types fixpoint semantics particular name used denote defined concept
impact interpretation it, since meaning defined concept
completely specified definition statement.

3.2 Least Greatest Fixpoints Concept Constructs

considerations show arguing \right" semantics recursive definitions really issue. captures essential use recursive
equations: descriptive semantics appropriate specify constraints concepts
one extends general inclusion assertions introduced Section 2;
least fixpoint semantics appropriate define structure inductively; greatest fixpoint
semantics appropriate define non-well-founded structures. Generally, may need
three knowledge base, order model various properties
different concepts.
94

fiConcept Definitions Description Logics

proposal paper exactly direction reconciling various semantics
knowledge base. pursued means logic incorporates two
constructs, X:F (X ) X:F (X ) (the symbols X; Y; : : : stand concept variables),
denoting, respectively, least fixpoint greatest fixpoint operator associated
definition X =def F (X ), is, every , smallest solution greatest
solution equation X = F (X )I .
approach, definition statements never appear TBox. Instead, knowledge
base simply set inclusion assertions (interpreted according descriptive semantics) involve fixpoint constructs. example, order specify properties
concepts list, stream, human horse use following assertions6 :
list
X:emptylist (node u ( 1 succ:>) u 9succ:X )
stream X:node u ( 1 succ:>) u 9succ:X

human mammal u 9parent:> u 8parent:human
horse mammal u 9parent:> u 8parent:horse:

Note that, add knowledge base equivalence assertion:

mgm X : mammal u 9parent:> u 8parent:X
defining concept mgm (mammal generated mammal), correctly turns
human horse subsumed mgm.

availability least greatest fixpoint constructs, allowing different semantics
used TBox, makes possible model abstract classes,
inductively co-inductively defined data structures, lists streams.
particularly important objective integrate class-based representation formalisms
programming systems (declarative procedural), order make formalisms
useful practice. Furthermore, possibility nesting fixpoints, thus
going beyond simple equational format motivated introduction.
example, consider following one:
Among inhabitants planet \Plonk", disease called \foo" quite
common. disease manifests two forms: \visible" one
\latent" one, rather intricate hereditary pattern. Individuals
visible form transmit visible form least one (say first) direct
descendant (obviously, direct descendant), ill descendants
turn same, on, someone transmits latent form
disease. precisely, along chain descendants, visible form
disease sooner later interrupted, either individual direct
descendant individual transmits descendant latent form.
direct descendants (if any) individual latent form inherit
visible form. pattern goes this, generation generation, forever.
hereditary pattern (foo hp) disease defined follows:
foo hp X:Y:((visible u (9child:Y 8child:?))t
(latent u 8child:(visible u X )))
6. include assertion emptylist v :node, specifying concepts emptylist node
disjoint.

95

fiDe Giacomo & Lenzerini

visible latent denote visible latent form respectively disease,
assumed disjoint (latent v :visible).

4. Description Logic ALCQ
provide formal account meaning fixpoint constructs introducing
description logic, called ALCQ, obtained adding constructs ALCQ.
make use notions scope, bound free occurrences variables, closed
formulae, etc. definitions notions analogues first-order
logic, treating quantifiers. addition, use symbol abstraction
either .
primitive symbols ALCQ atomic concepts, (concept) variables (denoted
X; Y; : : :), atomic roles roles admitted logic.
Concepts ALCQ formed inductively according following abstract syntax:

C ::= j > j ? j :C j C1 u C2 j C1 C2 j 9R:C j 8R:C j ( n R:C ) j ( n R:C ) j
X:C j X:C j X
denotes atomic concept, R atomic role, n natural number, X variable,
restriction variable X occurring positively C bounded
fixpoint X:C . say variable X occurs positively concept C , every
free occurrence X scope even number negations, considering concepts
C 0 ( n R:C 0 ) scope one negation.
two fixpoint constructs mutually definable: X:C = :X::C [X=:X ] (where
C [X=:X ] concept obtained substituting free occurrences X concept
:X ).
before, interpretation = (I ; ) consists domain interpretation ,
interpretation function , maps every atomic concept subset , every
atomic role subset . presence free variables allow us
extend interpretation function directly every concept logic. reason
introduce valuations. valuation interpretation mapping variables
subsets .
Given valuation , denote [X=E ] valuation identical except
[X=E ](X ) = E . words, every variable :

(

X
[X=E ](Y ) = E(Y ) ifif YY =
6= X
Let interpretation valuation . assign meaning concepts
logic associating extension function , mapping concepts subsets
, follows:
96

fiConcept Definitions Description Logics

XI
AI

>I
?I
(:C )I
(C1 u C2 )I
(C1 C2 )I
(9R:C )I
(8R:C )I
( n R:C )I
( n R:C )I

(X:C )I
(X:C )I

=
=
=
=
=
=
=
=
=
=
=
=
=

(X )
AI


;

, CI
(C1 )I \ (C2 )I
(C1 )I [ (C2 )I
fs 2 j 9s0: (s; s0 ) 2 RI s0 2 CI g
fs 2 j 8s0: (s; s0 ) 2 RI implies s0 2 CI g
fs 2 j #fs0 j (s; s0) 2 RI s0 2 CI g ng
fs 2 j #fs0 j (s; s0) 2 RI s0 2 CI g ng

j CI[X=E ] E g
SfE
fE j E CI[X=E ] g

last two cases CI[X=E ] interpreted operator subsets E subsets
. syntactic restriction enforced variables, operator guaranteed
monotonic wrt . Notice free variables appearing concept interpreted
similarly atomic concepts.
concept C satisfiable, exists interpretation valuation
CI 6= ;, otherwise C unsatisfiable. concept C1 subsumed concept C2 ,
written C1 v C2 , every interpretation every valuation , (C1 )I (C2 )I .
ALCQ TBox finite (possibly empty) set inclusion assertions C1 v C2
C1 C2 closed concepts ALCQ. before, use equivalence assertions
form C1 C2 abbreviation fC1 v C2 ; C2 v C1 g.
interpretation satisfies inclusion assertion C1 v C2 , (C1 )I (C2 )I ,
valuation (being C1 C2 closed, hence independent valuations).
model TBox K, satisfies inclusion assertions K. say TBox
K satisfiable, model. Observe inclusion assertions K interpreted
according descriptive semantics.
say TBox K logically implies inclusion assertion C1 v C2 , written K j=
C1 v C2, every model K every valuation , (C1 )I (C2 )I .

4.1 Properties Fixpoint Constructs

following, use notation C (X ) indicate variable X occurs free
concept C (other variables could occur free C well), notation C (D),
concept, shorthand C (X )[X=D] (i.e., concept obtained substituting
free occurrences X C (X ) concept D).
Let us comment brie simple properties logic. First, concept
X:C (X ) equivalent concept Y:C (Y ), long free X C (X ). Second,
extension function assign closed concept value independent actual
valuation . Hence X:C , X occur C , equivalent C . Third, since
X:C (X ) fixpoint C (X:C (X )) equivalent X:C (X ). Furthermore,
concept X:C (X ) always subsumed concept X:C (X ).
97

fiDe Giacomo & Lenzerini

next property substantial. Consider class single source finite
directed acyclic graphs (DAGs) defined inductively follows7:
EMPTY-DAG DAG (base step).

NODE connections connections DAGs, DAG (inductive
step).

Nothing else DAG.
Consider ALCQ TBox K containing two equivalence assertions:
dag student X : emptydag (student u 9arc:> u 8arc:X )
dag person X : emptydag (person u 9arc:> u 8arc:X )

define concepts dag student dag person classes DAGs whose
nodes students persons respectively. Assuming students persons, want
able infer DAGs students DAGs persons well. is, want:

K j= student v person implies K j= dag student v dag person:
turns ALCQ property holds. prove this, introduce

following two theorems.

Theorem 2 Let K ALCQ TBox, C two ALCQ concepts
variable X occurs free positively. Then:
K j= C v implies K j= X:C v X:D:
Proof proceed contradiction8 . Assume CI DI holds models K
valuations . suppose exists model K valuation
(X:C )I 6 (X:D)I .

First prove result = . Let individual (X:C )I
(X:D)I . Now, have:

2 (X:C )I iff 8E : (CI[X=E ] E implies 2 E )

(2)

62 (X:D)I iff 9E 0 : (DI[X=E ] E 0 62 E 0 ):

(3)

0

set E 0 (3), following expression holds:

CI[X=E ] DI[X=E ] E 0
0

0

7. assume leaf DAG NODE arcs leading special DAG called EMPTY-DAG.
alternative, one assume leaf DAG NODE connection all.
latter case, definition dag would simplify dag =def node u 8arc:dag (in general form
inductive definitions { i.e., base case inductive case { less apparent).
8. uniformity, distinguish X occurs free not. Obviously X occur free,
result trivial.

98

fiConcept Definitions Description Logics

hence (2) 2 E 0 (3) 62 E 0 , impossible.
proof = similar. Let individual (X:C )I (X:D)I .
Now, have:

2 (X:C )I iff 9E 00 : (E 00 CI[X=E ] 2 E 00)

(4)

62 (X:D)I iff 8E : (E DI[X=E ] implies 62 E ):

(5)

00

set E 00 (4), following expression holds:

E 00 CI[X=E ] DI[X=E
00

00

]

hence (4) 2 E 00 (5) 62 E 00 , impossible. 2
defined means variable X occur positively concept C .
Similarly say variable X occurs negatively concept C , every free occurrence
X scope odd number negations, considering concepts C 0 ( n R:C 0 )
scope one negation.

Theorem 3 Let K ALCQ TBox, D(X ) ALCQ concept variable X
free variable. Then, ALCQ concepts C1 C2 :
K j= C1 v C2 implies

(

K j= D(C1) v D(C2) X occurs positively D(X )
K j= D(C2) v D(C1) X occurs negatively D(X )

Proof prove result induction formation D(X ).

Base case. D(X ) = X , result holds trivially.
Inductive cases. D(X ) form :D0 (X ) j ( n R:C 0 ) , X occurs positively
(negatively) D0 (X ) negatively (positively) D(X ). induction hypothesis K j=
D0 (Ci ) v D0(Cj ) (where i; j 2 f1; 2g 6= j ) hence semantics constructs
K j= D(Cj ) v D(Ci).
D(X ) form D10 (X ) u D20 (X ) j D10 (X ) D20 (X ) j 8R:D0(X ) j ( n R:D0 (X )),
X occurs positively (negatively) D0 (X ) D(X ). induction hypothesis
K j= D0(Ci) v D0(Cj ) hence semantics constructs K j= D(Ci) v D(Cj ).
remains prove result D(X ) = Y:D0 (X ) (Y 6= X ). case,
syntactic restriction enforced, occurs positively D0 (X ) hence Theorem 2
K j= D0(Ci) v D0(Cj ) implies K j= Y:D0(Ci ) v Y:D0 (Cj ), thus induction hypothesis
done. 2
Going back example, can, fact, infer DAGs students DAGs
persons. Indeed, applying Theorem 3 Theorem 2, K j= student v
person implies K j= X:emptydag (studentu9arc:>u8arc:X ) v X:emptydag (person u
9arc:> u 8arc:X ).
99

fiDe Giacomo & Lenzerini

4.2 Internalizing Assertions

show logical implication ALCQ TBoxes (thus satisfiability ALCQ
TBoxes) reducible unsatisfiability single ALCQ concept. prove result,
introduce notions generated sub-interpretation sub-valuation9.
Let = (I ; ) interpretation,
valuation , 2 individual.



define interpretation = ( ; ), valuation s, follows:
= fs0 2 j (s; s0) 2 (R1I [ : : : [ RmI )g.
atomic role Ri, RiI = RiI \ (I ).
atomic concept A, AI = AI \ .
variable X , s(X ) = (X ) \ .
call sub-interpretation generated s, sub-valuation generated
s.
generated sub-interpretations sub-valuations state following lemma.

Lemma 4 Let C ALCQ concept. interpretation , valuation
, individual 2 , have:
8t 2 : 2 CI iff 2 CIss :
Proof Without loss generality, consider concepts formed according following
simplified abstract syntax: C ::= j ? j :C j C1 u C2 j 9R:C j ( n R:C ) j X:C j X:

prove result induction number nested fixpoint constructs. Base
case. C fixpoint constructs, thesis proven induction
formation C .
Inductive case. assume thesis holds concepts C k nested fixpoint
constructs, prove concepts X:C k + 1. recall that, TarskiKnaster Theorem fixpoints (Tarski, 1955), 2 (X:C )I iff exists ordinal
2 (ff X:C )I , (ff X:C )I defined transfinite induction as:
(0 X:C )I = ;

(ff+1 X:C )I = CI[X=(ff X:C ) ]
( X:C )I = Sff< (ffX:C )I , limit ordinal.


Hence proceed transfinite induction ordinals ff.
Base case transfinite induction. 0 X:C defined ?, thus trivially
2 (0 X:C )I iff 2 (0 X:C )Iss .
Successor case transfinite induction. want show 2 (ff+1 X:C )I iff 2
(ff+1 X:C )Iss , reduces to:

2 CI[X=(ff X:C ) ] iff 2 CIss[X=(ff X:C )ss ]:




9. Together notions play role generated sub-model modal logics.

100

(6)

fiConcept Definitions Description Logics

prove this, start showing that:

2 CIss[X=(ff X:C )ss ] iff 2 C(Is[X=(ff X:C ) ])s :




(7)

Notice two valuations may differ value X . holds that:

2 XIss[X=(ff X:C )ss ] iff 2 X(Is[X=(ff X:C ) ])s ;




(8)

straightforward induction formation C (7) holds well.
Let us prove (8). write as:

2 s[X=(ff X:C )Iss ](X ) iff 2 ([X=(ff X:C )I ])s (X );
since 2 , reduces

2 (ff X:C )Iss iff 2 (ff X:C )I :
holds transfinite inductive hypothesis.
Now, since C contains k fixpoint constructs, inductive hypothesis k, have:

2 CI[X=(ff X:C ) ] iff 2 C(Is[X=(ff X:C ) ])s :




Hence, considering (6) (7), follows indeed 2 (ff+1 X:C )I iff 2 (ff+1 X:C )Iss .
Limit case transfinite induction. Let limit ordinal, 2 ( X:C )I iff
exists ordinal < 2 (ff X:C )I . transfinite induction hypothesis,
holds that: 2 (ff X:C )I iff 2 (ff X:C )Iss , thus:

2 ( X:C )I iff 2 ( X:C )Iss :
completes transfinite induction. ordinals holds that:

2 (ff X:C )I iff 2 (ff X:C )Iss :
induction nesting fixpoint constructs completed well, hence
proven lemma. 2
ready state result mentioned above.

Theorem 5 Let K = fC1 v D1 ; : : : ; Cq v Dq g ALCQ TBox, C two
ALCQ concepts. K j= C v ALCQ concept:
X:(8R1 :X u : : : u 8Rm :X u CK) u C u :D
(9)
unsatisfiable, R1 ; : : : ; Rm atomic roles appearing K, CK = (:C1
D1 ) u : : : u (:Cq Dq ).
101

fiDe Giacomo & Lenzerini

Proof part. contradiction. Assume (9) satisfiable, suppose
K 6j= C v D, i.e., exists interpretation , valuation ,
model K CI 6 DI . follows that, exists individual 2
2 CI 2 (:D)I . hand, fact model K implies
(CK )I = , thus (X:(8R1 :X u : : : u 8Rm :X u CK ))I = .
2 (X:(8R1 :X u : : : u 8Rm:X u CK ) u C u :D)I , i.e., (9) satisfiable, contradicting

hypotheses.
part. proceed contradiction. Assume K j= C v D. suppose
(9) satisfiable, i.e., exists interpretation , valuation ,
individual 2 , 2 (X:(8R1 :X u : : : u 8Rm :X u CK ) u C u :D)I .
consider sub-interpretation = (I ; Iss ) sub-valuation
generated s. one hand, clearly (CK )Iss = , hence model
K. hand Lemma 4 2 (X:(8R1 :X u : : : u8Rm :X u CK ) u C u:D)Iss ,
follows satisfy subsumption C v D, contradicting hypotheses.

2

result states satisfiability ALCQ concepts logical implication
ALCQ TBoxes (and thus satisfiability ALCQ TBoxes) distinct reasoning
tasks. Hence following limit attention concept satisfiability without
loss generality.

5. Reasoning Fixpoints

section concentrate developing reasoning methods check satisfiability
concepts involving fixpoints. particular, exhibit correspondence ALCQ
well-known logic programs, called modal mu-calculus (Kozen, 1983; Kozen &
Parikh, 1983; Streett & Emerson, 1984, 1989), recently investigated
expressing temporal properties reactive parallel processes (Stirling, 1992; Larsen,
1990; Cleaveland, 1990; Winsket, 1989; Dam, 1992).
get better insight correspondence two logics, first study
sublanguage ALC obtained ALCQ leaving qualified number restrictions10 .
Then, study full logic ALCQ.

5.1 Reasoning ALC

Let us introduce modal mu-calculus formally. Formulae ; ; : : : modal mu-calculus
formed inductively atomic formulae A; : : : variables X; : : : according
following abstract syntax:
; ::= j > j ? j : j ^ j _ j hai j [a] j X: j X: j X
generic element set labels L, every bounded occurrence every
variable X must scope even number negation signs.
10. Observe that, Theorem 5 qualified number restrictions play role. Hence exactly reduction
logical implication unsatisfiability holds ALC well. allows us restrict attention
satisfiability only.

102

fiConcept Definitions Description Logics

semantics modal mu-calculus based notions (Kripke) structure
valuation. Kripke structure triple (S ; fRi j 2 Lg; V ), set states,
Ri binary relation , V mapping atomic formulae subsets
. valuation mapping variables subsets . Kripke structure
valuation M, associated extension function
defined inductively
follows:
XM
= (X )

= V (A)


>
=
?M
= ;

(:)M
= ,




( ^ )M
= \


( _ ) = [

(hai)M
= fs 2 j 9s0 : (s; s0 ) 2 Ra s0 2

g
0 : (s; s0 ) 2 Ra implies s0 2 g
([a])M
=
f

2

j
8





(X:)M
= SfE j [X=E ] E g
(X:)M
= fE j E

[X=E ] g
formula satisfiable exists Kripke structure valuation

6= ;.
following theorem basis correspondence ALC modal
mu-calculus.

Theorem 6 exists one-to-one linear-time function q mapping concepts ALC
formulae modal mu-calculus that: ALC concept C , C satisfiable
q(C ) satisfiable.

Proof define q following way: q(A) = (atomic concepts mapped
atomic formulae), q(X ) = X , q(>) = >, q(?) = ?, q(:C ) = :q(C ), q(9R:C ) =
hRiq(C ) (atomic roles mapped labels), q(8R:C ) = [R]q(C ), q(X:C ) = X:q(C ),
q(X:C ) = X:q(C ).
interpretation = (I ; ) equivalent Kripke structure = (S ; fRi j 2
Lg; V ) that: = ; L equal set names atomic roles interpreted
; RR = RI atomic role R; V (A) = AI atomic concept A.
addition, valuation equivalent valuation 0 M. extension
function associated extension function associated 0
map, respectively, concept C corresponding formula q(C ) subset
= . Hence thesis follows. 2
follows may transfer decidability complexity results modal
mu-calculus (Kozen & Parikh, 1983; Emerson & Jutla, 1988; Safra, 1988) ALC . Thus,
immediately state complexity reasoning ALC concepts
ALC TBoxes.

Theorem 7 Satisfiability ALC concepts, satisfiability ALC TBoxes, logical
implication ALC TBoxes EXPTIME-complete problems.
103

fiDe Giacomo & Lenzerini

Proof satisfiability problem modal mu-calculus EXPTIME-complete (Emerson
& Jutla, 1988), hence Theorem 6 Theorem 5 thesis follows. 2

5.2 Reasoning ALCQ
Next exhibit mapping ALCQ concepts formulae variant modal mucalculus, called deterministic modal mu-calculus, syntax modal
mu-calculus, interpreted deterministic Kripke structures, Kripke structures = (S ; fRi j 2 Lg; V ) relations Ri partial functions (Streett &
Emerson, 1984).
Let us ignore moment qualified number restriction constructs. Formulae
ALCQ without qualified number restrictions are, fact, formulae modal mucalculus, shown previous section. using well-known technique developed
propositional dynamic logic (Parikh, 1981), (nondeterministic) modal mu-calculus formulae reduced deterministic modal mu-calculus formulae (Streett & Emerson,
1984), shown below.
use following notations usual operations binary relations: chaining,
exive transitive closure, + transitive closure, , converse. use
following abbreviations:
[R ]
[R+ ]



hR
hR+i

X:( ^ [R]X )
[R][R ]
X:( _ hRiX )
hRihR i:

reduction follows: formula , recursively replace subformulae
form [R] [R][(Rnew ) ] subformulae form hRi hRih(Rnew ) i,
Rnew new symbol R Rnew resulting formula interpreted
partial functions. Let us call resulting formula 0 , satisfiable
0 satisfiable.
brie sketch reasoning behind proof statement. direction
easy: suces observe = (S ; fRDi j 2 LD g; V ) model 0 ,
transform model = (S ; fRi j 2 Lg; V ) defining = ,
L = LD , new, RR = RDR (RDnew ) , V = V . direction follows.
recall nondeterministic deterministic modal mu-calculus tree model
property (Streett & Emerson, 1989, 1984): formula model tree model,
i.e., model form tree11 . without loss generality restrict
attention tree models only. one-to-one transformation tree models
= (S ; fRTi j 2 LT g; V ) (tree) models B = (S B ; fRBi j 2 LB g; V B )
0 . Indeed, put B = , V B = V , LB = LT , given state x 2
11. Given model get tree model simply \unfolding" original one.

104

fiConcept Definitions Description Logics

RTR -successors z1; : : : ; zl ,12 put (x; z1 ) 2 RBR , (zi ; zi+1 ) 2 RBRnew , = 1; : : : ; l , 1.
way (x; zi ) 2 RTR (x; zi ) 2 RBR (RBRnew ) .13

remark required tree get B need recover
\original" RTR -predecessor x state zi , namely need (RBR (RBRnew ) ),
partial function, otherwise, given state zi , would know various
(RBR (RBRnew ) ), -successors original RTR -predecessor x, therefore would
able reconstruct B .
interpreting R Rnew partial functions, easy express qualified number
)-successors state. example:
restrictions constraints chain (R Rnew
( 3 R:) expressed
[R][(Rnew ) ](: _ [(Rnew )+ ](: _ [(Rnew )+ ](: _ [(Rnew )+ ]:)))
read \everywhere along chain R (Rnew ) three states
holds", corresponds exactly intended meaning. Similarly ( 3 R:)
expressed

hRih(Rnew ) i( ^ h(Rnew )+i( ^ h(Rnew )+ i))
read \somewhere along chain R (Rnew ) least three states
holds", corresponds exactly intended meaning.
discussion allows us state following result.

Theorem 8 exists polynomial function mapping concepts ALCQ formulae
deterministic modal mu-calculus that: ALCQ concept C , C satisfiable

u(C ) satisfiable.

Proof function defined inductively follows:
u(A)
u(X )
u(C1 u C1 )
u(C1 C2 )
u(:C )
u(X:C )
u(X:C )
u(9R:C )
u(8R:C )


X
u(C1 ) ^ u(C2 )
u(C1 ) _ u(C2 )
:u(C )
X:u(C )
X:u(C )
hRih(Rnew )iu(C )
[R][(Rnew ) ]u(C )
Rnew new role. Finally, ( n R:C ) ( n R:C ) mapped following
=
=
=
=
=
=
=
=
=

formulae:

12. implicitly assume finite branching tree model. done without loss
generality since modal mu-calculus finite model property, hence unfolding finite model
get finite branching tree model. Note however would suce assume countable
branching tree model.
13. Note construction similar one often used programming reduce n-ary trees
binary trees coding children node combination one child siblings.

105

fiDe Giacomo & Lenzerini

u(( n R:C )) =[R][(Rnew ) ](:u(C ) _ [(Rnew )+](:u(C )_
[(Rnew )+ ](: : : (:u(C ) _ [(Rnew )+ ]:u(C )) : : :)))
number nested formulae form :u(C ) _ [(Rnew )+ ] n,

u(( n R:C )) =hRih(Rnew ) i(u(C ) ^ h(Rnew )+i(u(C )^
h(Rnew )+i(: : : (u(C ) ^ h(Rnew )+iu(C )) : : :)))
number nested formulae form u(C ) ^ h(Rnew )+ n , 1.
u(C ) clearly polynomial size C (under usual assumption numbers
C coded unary). Moreover, following technique (Parikh, 1981; Streett & Emerson,
1984) exposed above, easy verify, induction formation
concept C , mapping preserves satisfiability. 2
follows may transfer decidability complexity results deterministic modal mu-calculus (Streett & Emerson, 1984; Emerson & Jutla, 1988; Safra,
1988) ALCQ. Thus, immediately state complexity reasoning
ALCQ concepts ALCQ TBoxes.

Theorem 9 Satisfiability ALCQ concepts, satisfiability ALCQ TBoxes, logical
implication ALCQ TBoxes EXPTIME-complete problems.
Proof Satisfiability deterministic modal mu-calculus EXPTIME-complete problem

(Streett & Emerson, 1984; Emerson & Jutla, 1988; Safra, 1988). Hence Theorem 8
Theorem 5 thesis follows. 2

6. Discussion Conclusion

work presented paper stems (De Giacomo, 1993), basic ideas
introducing explicit fixpoint first presented, (De Giacomo & Lenzerini, 1994b),
idea elaborated ALCQ first introduced.
One main contributions work devise tight correspondence
description logics fixpoints modal mu-calculus. respect remark
that, ALC corresponds directly modal mu-calculus, full ALCQ corresponds
variant modal mu-calculus whose decidability complexity studied.
precisely, notion essentially equivalent qualified number restrictions
independently emerged modal logics, namely graded modalities (Van der Hoek
& de Rijke, 1995; Van der Hoek, 1992; Fattorosi-Barnaba & De Caro, 1985; Fine, 1972).
However combination fixpoints graded modalities investigated
setting modal logics. Given tight correspondence ALC
modal mu-calculus, ALCQ considered modal mu-calculus augmented graded
modalities. Hence results paper apply logic well.
research reported paper bears several similarities one correspondence description logics propositional dynamic logics (Baader, 1991;
106

fiConcept Definitions Description Logics

Schild, 1991; De Giacomo & Lenzerini, 1994a, 1995; De Giacomo, 1995). fact characterize description logics based propositional dynamic logics role constructs
chaining, choice, test, exive transitive closure roles, limited
form fixpoint. role constructs easily expressed using explicit fixpoints
introduced here. suce resort following equivalences:
9R1 R2 :C = 9R1:9R2:C
9R1 R2:C = 9R1:C 9R2:C
9R:C = X:(C 9R:X )
9id(D):C = C u D:
Note 8R :C = X:(C u 8R:X ). (Calvanese, De Giacomo, & Lenzerini, 1995)
implicit form fixpoint advocated, called well-founded role
construct wf (R). explicit fixpoints, wf (R) expressed simply X:(8R:X ).
proposal allowing fixpoint constructs explicitly formalism shared
study independently carried Schild (Schild, 1994)14 . main goal
work study expressive power computational complexity
subsumption satisfiability TBoxes expressed ALC (no fixpoint constructs),
allow mutually recursive definitions. end, description logic defined
corresponds variant modal mu-calculus mutual fixpoints allowed
restrictions nested fixpoints enforced (Vardi & Wolper, 1984). well
known mutual fixpoints re-expressed means nested ones (see, example,
Park, 1976; de Bakker, 1980). consequence observation follows logic
introduced paper, expressive one analyzed (Schild, 1994) since,
one hand, allows nesting fixpoints without restriction, hand
makes possible state sophisticated forms cardinality constraints role fillers
means qualified number restrictions.
present work extended along several directions. conclude outlining
two them.
already noticed fixpoint constructs allow representing abstract
classes, several data structures extensively used software development.
believe characteristic important step towards satisfactory integration
description logics traditional declarative programming systems. Indeed
description logic proposed paper provides powerful mechanisms data structure
modeling. particular, properties stated Section 4.1 base formulate
notion parametric concept15 . instance, expression (named dag [Z ])
X : emptydag (Z u 9arc:> u 8arc:X )
Z formal parameter, denotes class DAGs whose nodes left unspecified.
class used several ways TBox. example, instantiated
binding formal parameter actual parameters, thus getting, say, dag [student],
dag [person], etc., concepts inheriting properties dag [Z ].
14. (Schild, 1994) number restrictions considered.
15. Note parametric concepts introduced simpler logics include fixpoint
constructs.

107

fiDe Giacomo & Lenzerini

Although ALCQ powerful logic, lacks construct inverse roles
needed example correctly capture notions (finite) TREE, BINARY-TREE, etc.
Indeed, define concept TREE (an EMPTY-TREE TREE; NODE
one parent, children, children TREEs, TREE; nothing else
TREE) write tree X : empty tree (node u ( 1 child, :>) u9child:>u8child:X
child, denotes inverse child. Notice introduction inverse roles
pose diculty semantical point view; however, impact
reasoning method needs investigated. generally, wide variety concept
constructs studied conjunction fixpoints. research description logics
related propositional dynamic logics (De Giacomo & Lenzerini, 1994a, 1995; Calvanese
et al., 1995; De Giacomo, 1995) may give us hints proceed along direction.

References

Baader, F. (1990). Terminological cycles KL-ONE-based knowledge representation languages. Proc. 8th Nat. Conf. Artificial Intelligence (AAAI-90), pp.
621{626 Boston, Ma.
Baader, F. (1991). Augmenting concept languages transitive closure roles: alternative terminological cycles. Proc. 12th Int. Joint Conf. Artificial
Intelligence (IJCAI-91) Sydney, Australia.
Beeri, C. (1990). formal approach object-oriented databases. Data Knowledge
Engineering, 5, 353{382.
Beneventano, D., & Bergamaschi, S. (1992). Subsumption complex object data models.
Proc. 4th Int. Conf. Database Theory (ICDT-92), No. 646 Lecture
Notes Computer Science, pp. 357{375. Springer-Verlag.
Bergamaschi, S., & Sartori, C. (1992). taxonomic reasoning conceptual design. ACM
Transaction Database Systems, 17 (3), 385{422.
Borgida, A. (1992). type systems knowledge representation: Natural semantics
specifications description logics. Journal Intelligent Cooperative Information
Systems, 1 (1), 93{126.
Calvanese, D., De Giacomo, G., & Lenzerini, M. (1995). Structured objects: modeling
reasoning. Proc. 4th Int. Conf. Deductive Object-Oriented Databases
(DOOD-95), Lecture Notes Computer Science. Springer-Verlag.
Cleaveland, R. (1990). Tableaux-based model checking propositional mu-calculus.
Acta Informatica, 27, 725{747.
Dam, M. (1992). CTL* ECTL* fragments modal mu-calculus. Proceeding
Col. Trees Algebra Programming, No. 581 Lecture Notes Computer
Science, pp. 145{164. Springer-Verlag.
de Bakker, J. (1980). Mathematical Theory Program Correctness. Prentice-Hall.
108

fiConcept Definitions Description Logics

De Giacomo, G. (1993). Reconciling different semantics concept definition (extended
abstract). Proc. 1st COMPULOG Net Meeting Knowledge Representation
Reasoning Systems (CNKRR-93).
De Giacomo, G. (1995). Decidability Class-Based Knowledge Representation Formalisms.
Ph.D. thesis, Dipartimento di Informatica e Sistemistica, Universita di Roma \La
Sapienza".
De Giacomo, G., & Lenzerini, M. (1994a). Boosting correspondence description
logics propositional dynamic logics. Proc. 12th Nat. Conf. Artificial
Intelligence (AAAI-94), pp. 205{212. AAAI-Press/the MIT-Press.
De Giacomo, G., & Lenzerini, M. (1994b). Concept language number restrictions
fixpoints, relationship mu-calculus. Proc. 11th Eur. Conf.
Artificial Intelligence (ECAI-94), pp. 411{415. John Wiley Sons.
De Giacomo, G., & Lenzerini, M. (1995). What's aggregate: foundation description
logics tuples set. Proc. 14th Int. Conf. Artificial Intelligence
(IJCAI-95).
Emerson, E. A., & Jutla, C. S. (1988). complexity tree automata logics
programs. Proc. 20th An. Symp. Foundations Computer Science
(FOCS-88), pp. 328{337.
Fattorosi-Barnaba, M., & De Caro, F. (1985). Graded modalities I. Studia Logica, 44,
197{221.
Fine, K. (1972). many possible worlds. Notre Dame Journal Formal Logic, 13 (4),
516{520.
Kozen, D. (1983). Results propositional mu-calculus. Theoretical Computer Science,
27, 333{355.
Kozen, D., & Parikh, R. (1983). decision procedure propositional mu-calculus.
Proc. 2nd Work. Logic Programs, No. 164 Lecture Notes Computer
Science, pp. 313{325. Springer-Verlag.
Larsen, K. J. (1990). Proof systems satisfiability Hennessy-Milner logic recursion.
Theoretical Computer Science, 72, 265{288.
Nebel, B. (1990). Reasoning Revision Hybrid Representation Systems. No. 422
Lecture Notes Artificial Intelligence. Springer-Verlag.
Nebel, B. (1991). Terminological cycles: Semantics computational properties. Sowa,
J. F. (Ed.), Principles Semantic Networks, pp. 331{361. Morgan Kaufmann, Los
Altos.
Parikh, R. (1981). Propositional dynamic logic programs: survey. Proc.
1st Work. Logic Programs, No. 125 Lecture Notes Computer Science, pp.
102{144. Springer-Verlag.
109

fiDe Giacomo & Lenzerini

Park, D. (1976). Finiteness mu-ineffable. Theoretical Computer Science, 3, 173{181.
Safra, S. (1988). complexity !-automata. Proc. 20th An. Symp.
Foundations Computer Science (FOCS-88), pp. 319{327.
Schild, K. (1991). correspondence theory terminological logics: Preliminary report.
Proc. 12th Int. Joint Conf. Artificial Intelligence (IJCAI-91), pp. 466{471
Sydney, Australia.
Schild, K. (1994). Terminological cycles propositional -calculus. Doyle, J.,
Sandewall, E., & Torasso, P. (Eds.), Proc. 4th Int. Conf. Principles
Knowledge Representation Reasoning (KR-94), pp. 509{520 Bonn. Morgan
Kaufmann, Los Altos.
Schmidt-Schau, M., & Smolka, G. (1991). Attributive concept descriptions complements. Artificial Intelligence, 48 (1), 1{26.
Stirling, C. (1992). Modal temporal logic. Abramsky, S., Gabbay, D. M., & Maibaum,
T. S. E. (Eds.), Handbook Logic Computer Science, pp. 477{563. Clarendon Press,
Oxford.
Streett, R. S., & Emerson, E. A. (1984). propositional mu-calculus elementary.
Proc. 6th Int. Col. Automata, Languages Programming, No. 172
Lecture Notes Computer Science, pp. 465{472. Springer-Verlag.
Streett, R. S., & Emerson, E. A. (1989). automata theoretic decision procedure
propositional mu-calculus. Information Control, 81, 249{264.
Tarski, A. (1955). lattice-theoretical fixpoint theorem applications. Pacific Journal
Mathematics, 5, 285{309.
Van der Hoek, W. (1992). semantics graded modalities. Journal Applied
Non-Classical Logics, 2 (1), 81{123.
Van der Hoek, W., & de Rijke, M. (1995). Counting objects. Journal Logic Computation, 5 (3), 325{345.
Vardi, M. Y., & Wolper, P. (1984). Automata theoretic techniques modal logics
programs. Proc. 16th An. Symp. Foundations Computer Science
(FOCS-84), pp. 446{456.
Winsket, G. (1989). note model checking modal -calculus. Proc. 11th
Int. Col. Automata, Languages Programming, No. 372 Lecture Notes
Computer Science, pp. 761{772. Springer-Verlag.

110


