Journal Artificial Intelligence Research 34 (2009) 675-706

Submitted 11/08; published 04/09

Planning Chain Causal Graphs Variables
Domains Size 5 NP-Hard
Omer Gimenez

omer.gimenez@upc.edu

Dept. de Llenguatges Sistemes Informatics
Universitat Politecnica de Catalunya
Jordi Girona, 1-3
08034 Barcelona, Spain

Anders Jonsson

anders.jonsson@upf.edu

Dept. Information Communication Technologies
Universitat Pompeu Fabra
Roc Boronat, 138
08018 Barcelona, Spain

Abstract
Recently, considerable focus given problem determining boundary
tractable intractable planning problems. paper, study complexity planning class Cn planning problems, characterized unary operators
directed path causal graphs. Although one simplest forms causal graphs
planning problem have, show planning intractable Cn (unless P = NP),
even domains state variables bounded size. particular, show plan
existence Ckn NP-hard k 5 reduction Cnf-Sat. Here, k denotes
upper bound size state variable domains. result reduces complexity
gap class Ckn cases k = 3 k = 4 only, since C2n known tractable.

1. Introduction
ongoing effort planning community determine complexity different classes planning problems. Known tractable classes usually characterized
simple causal graph structure accompanied additional restrictions variables
operators. However, boundary tractable intractable planning problems
still clearly established. present paper contributes novel complexity result
class planning problems simple causal graph structure literature,
effort reduce complexity gap.
problem determining tractable classes planning problems purely theoretical interest. instance, complex planning problems projected onto tractable
fragments planning problems generate heuristics used search (Katz &
Domshlak, 2008b). Also, causal graph heuristic (Helmert, 2006) exploits hierarchical structure planning problem transforming tractable form: first,
translates propositional variables multi-valued variables, process simplifies
causal graph problem; then, keeps relaxing problem causal graph
becomes acyclic.
present paper aims study complexity planning problems class Cn ,
defined Domshlak Dinitz (2001). class Cn contains planning problems
c
2009
AI Access Foundation. rights reserved.

fiGimenez & Jonsson

Ckn
k=2
k {3, 4}
k5

Plan generation
P
EXP
EXP

Macro plan generation
P
?
Intractable

Plan existence
P
?
NP-hard

Table 1: Overview complexity results class Ckn .

multi-valued variables chain causal graphs, i.e., causal graph directed path
(implying operators unary). notation n indicates number state
variables unbounded. particular, study complexity plan existence Cn ,
i.e., determining whether exists plan solves planning problem Cn .
Even though planning problems Cn exhibit extremely basic form causal structure, i.e., linear dependence state variables, solving planning problems Cn
necessarily tractable, even impose additional restrictions. Let Ckn subclass
Cn state variables domains size k. known class C2n
polynomial-time solvable (Brafman & Domshlak, 2003) plan existence class
Cn NP-hard (Gimenez & Jonsson, 2008a). aim study complexity plan
existence classes between, namely Ckn k 3.
Domshlak Dinitz (2001) showed solvable instances C3n require
exponentially long plans. means polynomial-time plan generation
algorithm Ckn k 3, case C2n . However, rule
existence polynomial-time algorithm determines plan existence class Ckn ,
even algorithm generates plans succinct form, Jonsson (2007)
Gimenez Jonsson (2008a). incompatible Cn NP-hard.
paper, prove plan existence class Ckn NP-hard k 5.
words, even causal graph directed path domains state
variables restricted contain 5 values, deciding whether plan
exists solving corresponding planning problem NP-hard. result implies
sufficient planning problem exhibit linear variable dependence restricted
variable domain sizes; additional restrictions necessary make planning tractable.
Table 1 shows overview complexity results class Ckn date.
Macro plan generation mean algorithm generating compact representation
solution, work Jonsson (2007) Gimenez Jonsson (2008a).
Intractable result column means complexity yet unknown
cannot P unless P = NP (else plan existence would P). row k = 2 due
Brafman Domshlak (2003), column plan generation due Domshlak
Dinitz (2001), contributions present paper marked boldface. Note
novel result subsumes Gimenez Jonsson (2008a), showed NP-hardness
k = O(n).
paper organized follows. Section 2 relate results previous work,
Section 3 introduce notation used throughout. Section 4 give formal
proof reduction Cnf-Sat planning problems C11
n . main result,
5
reduction Cnf-Sat planning problems Cn , proved Section 5. Although
11
result C5n subsumes C11
n , believe intuitive idea behind Cn
676

fiChain Causal Graphs Domains Size 5

reduction easier understand, may interest anyone trying prove hardness
results similar circumstances. Section 6 discuss complexity remaining
classes C3n C4n .
prove correctness third reduction, time Cnf-Sat C7n ,
7
Appendix A. reductions C11
n Cn previously appeared conference paper
(Gimenez & Jonsson, 2008b), present paper provides formal proof correctness.

2. Related Work
complexity planning studied extensively last twenty years (Bylander, 1994; Chapman, 1987; Erol, Nau, & Subrahmanian, 1995). Many tractable classes
planning problems exploit notion causal graph one way another. Knoblock
(1994) usually credited introducing causal graph work hierarchical
planning. Williams Nayak (1997) required planning problems acyclic causal
graphs effort ensure tractability. Jonsson Backstrom (1998) defined class
3S planning problems, acyclic causal graphs, showed plan existence
tractable class.
Domshlak Dinitz (2001) introduced class Cn planning problems studied
paper, well several related classes, particular causal graph
structure. Brafman Domshlak (2003) designed polynomial-time algorithm solving planning problems binary state variables polytree causal graphs bounded
indegree, proving planning tractable class C2n . Brafman Domshlak
(2006) presented complexity results related tree-width causal graph. Katz
Domshlak (2008a) used causal graph structure prove several complexity results
optimal planning.
Jonsson (2007) Gimenez Jonsson (2008a) designed polynomial-time algorithms
solve planning problems restricted causal graphs generating hierarchy
macros. Recently, Chen Gimenez (2008) showed complexity planning
intractable unless size largest connected component causal graph bounded
constant. Consequently, causal graph structure alone enough guarantee
tractability, implying additional restrictions needed.

3. Notation
Throughout paper, use [i..n] denote set {i, . . . , n}.
Let V set state variables, let D(v) finite domain state variable
v V . define state function V maps state variable v V
value s(v) D(v) domain. partial state p function subset Vp V
state variables maps state variable v Vp p(v) D(v). frequently use
notation (v1 = x1 , . . . , vk = xk ) denote partial state p defined Vp = {v1 , . . . , vk }
p(vi ) = xi vi Vp .
planning problem tuple P = hV, init, goal, Ai, V set variables, init
initial state, goal partial goal state, set operators. operator
= hpre(a); post(a)i consists partial state pre(a) called pre-condition
677

fiGimenez & Jonsson

v1

v2

v3

v4

v5

Figure 1: Example causal graph planning problem class Ck5 .
partial state post(a) called post-condition. Operator applicable state
s(v) = pre(a)(v) v Vpre(a) , applying operator state results
new state (v) = post(a)(v) v Vpost(a) (v) = s(v) otherwise.
partial plan planning problem P sequence operators a1 , . . . , ak Ak ,
k 0, a1 applicable initial state init and, [2..k], ai
applicable following application a1 , . . . , ai1 starting init. Note partial plan
necessarily solve P . plan solving P partial plan goal
state goal satisfied following application a1 , . . . , ak . P solvable
exists plan .
causal graph planning problem P directed graph (V, E) state
variables nodes. edge (u, v) E u 6= v exists
operator u Vpre(a) Vpost(a) v Vpost(a) . Figure 1 shows example
causal graph form directed path. structure causal graph implies
operator unary, i.e., post-condition specified single variable
v, pre-condition specified (at most) v predecessor v causal
graph.
paper study class Ckn planning problems, defined follows:
Definition 3.1. planning problem P belongs class Ckn causal
graph P directed path and, v V , |D(v)| k.
planning problems Ckn , domain transition graph, DTG, state variable
v labelled, directed graph (D(v), E ) values domain v nodes.
edge (x, y) E label l D(v ) exists operator
hv = l, v = x; v = yi A, v predecessor v causal graph. edge
without label indicates pre-condition corresponding operator defined v
alone. edge one label indicates existence multiple operators
pre- post-condition v different pre-conditions v .

4. C11
n NP-hard
section prove C11
n NP-hard reduction Cnf-Sat. words,
every CNF formula F associate planning instance P11 (F ) C11
n P11 (F )
solvable F satisfiable. first describe planning problem P11 (F ),
explain intuitive idea behind reduction, finally provide formal proof
correctness.
Let F = C1 Ck CNF formula k clauses n variables x1 , . . . , xn .
define planning problem P11 (F ) = (V, init, goal, A) follows. variable set V
{si | [1..2n 1]} {vs } {vij | [1..k], j [1..n]} {ve } {ei | [1..2n 1]},
domains D(si ) = D(ei ) = D(ve ) = {0, 1} [1..2n 1], D(vs ) = {0, 1, x},
D(vij ) = {gx , g0 , g1 , ax , a0 , a1 , b0 , b1 , cx , c0 , c1 } [1..k], j [1..n]. initial state
defined init(si ) = init(ei ) = init(ve ) = 0, [1..2n 1], init(vs ) = x, init(vij ) = ax
678

fiChain Causal Graphs Domains Size 5

s1

s2n1

vs

v1n

v11

vk1

vkn



e1

e2n1

Figure 2: Causal graph planning problem P11 (F ).
0
1
1

0

0
0

1

0
1

1

x
1
0

0 0

1
1

Figure 3: DTGs variables s1 , s2 , . . . , s2n1 , vs .
[1..k], j [1..n], goal state partial state defined goal(vin ) = gx
[1..k], goal(ve ) = 0, goal(ei ) = (i mod 2) [1..2n 1].
providing formal definition operators A, give intuitive overview
planning problem P11 (F ). this, present causal graph P11 (F ) well
DTGs state variable. reader interested formal proof
correctness reduction may skip Section 4.2, introduce formal
definitions operators order prove several theoretical properties P11 (F ).
4.1 Intuition
planning problem P11 (F ) associated CNF formula F consists three parts,
clearly defined role. three parts illustrated Figure 2, showing causal
graph P11 (F ). first part P11 (F ) corresponds state variables s1 , . . . , s2n1 , vs ,
second part corresponds state variables v11 , . . . , v1n , . . . , vk1 , . . . , vkn , third
part corresponds state variables , e1 , . . . , e2n1 . role first part generate
message corresponding assignment variables CNF formula F .
role second part verify whether assignment satisfies clause Ci ,
remember fact (using value state variable vin ). Finally, role third part
make sure message propagated way end chain.
DTGs state variables s1 , . . . , s2n1 , vs appear Figure 3. state variables
used generate assignment variables x1 , . . . , xn CNF formula F .
this, operators P11 (F ) defined way value vs change
x either 0 1, 0 1 change back x. Thus, applying
operators P11 (F ) possible generate sequence x, m1 , x, . . . , x, mn , x values
vs , mj {0, 1} j [1..n].
define message sequence m1 , . . . , mn n symbols (either 0 1) corresponding sequence values vs . follows, refer symbols
bits message. value x used separator distinguish consecutive
bits message. Given message m, assignment defined (xj ) = mj
j [1..n]. Thus, assignment x1 determined first choice whether
change value vs x 0 1, on. purpose remaining state
variables si first part restrict message contain n bits.
679

fiGimenez & Jonsson

(a)

(b)
a0

g0

a0

g0

c0

b0

c0

b0
a0,b0,g0

0

0

x
0

gx
1

ax

1

x
cx

x

gx
a1,b1,g1

1

x

ax,cx,gx

a0,b0,g0

x

ax,cx,gx

ax
ax,cx,gx

a0,b0,g0

ax,cx,gx

a1,b1,g1

ax,cx,gx

cx

x
a1,b1,g1

g1

a1

c1

b1

g1

a1

b1

ax,cx,gx
c1

(c)
a0

g0
a0,b0
c0,g0

cx,gx g
0
gx

c1,g1

cx,gx g1

ax

a1,b1
g1

c0

b0
ax,cx

c0

c0

cx

c1

cx

ax,cx
a1

cx

cx

c1
b1

cx
c1

Figure 4: DTGs (a) v11 , (b) vi1 > 1, (c) vij j > 1. Dashed edges
explained text.

DTGs state variables vij , [1..k] j [1..n], appear Figure 4.
dashed edges DTGs indicate corresponding operators depend CNF
formula F . example, assignment (x1 ) = 1 satisfies clause C1 , edge
v11 = ax label 1 Figure 4(a) points g1 , else points b1 . Likewise, (x1 ) = 0
satisfies C1 , edge v11 = ax label 0 points g0 , else points b0 .
Recall role second part check whether assignment generated
first part satisfies CNF formula F . clause Ci variable xj
F , main function state variable vij check whether assignment (xj ) = mj
satisfies Ci . this, state variable vij acts finite state automaton propagates
bit message keeping track j-th bit message arrives.
Since domain size state variables restricted, way vij count
number bits received. Instead, fact j-th bit arrived indicated
vi(j1) . Moreover, last state variable vin clause Ci remember
whether Ci satisfied assignment variable xj .
summary, state variable vij second part performs following functions
values operators:
1. Propagate message generated vs .
2. Check whether assignment xj (the j-th bit m) satisfies clause Ci .
680

fiChain Causal Graphs Domains Size 5

0

0
a0,a1,
b0,b1, 0
g0,g1

ax
cx
gx
1

0
1

1

0

1
1

Figure 5: domain transition graph variables , e1 , . . . , e2n1 .
3. Remember whether Ci satisfied assignment xl , l j.
4. j < n Ci satisfied, propagate fact.
5. j < n, let vi(j+1) know (j + 1)-th bit message arrived.
Note third function strictly necessary j = n. However, including
state variables makes reduction compact symmetry.
Next, briefly describe vij implements functions. value
domain vij subscript 0, 1, x. propagate message, vij always moves
value whose subscript matches predecessor (in case v11 , subscript
match value vs ). Unless Ci satisfied assignment xl , l < j,
value vij remains subdomain {a0 , a1 , ax } prior arrival j-th bit.
clause Ci encoded dashed edges DTGs variables vij .
operators j-th bit mj arrives, vij moves ax gmj
assignment (xj ) = mj satisfies Ci , bmj otherwise. fact value vij
subdomain {g0 , g1 , gx } indicates Ci satisfied assignment
xl , l j. fact propagated way vin since subsequent state variable
Ci forced move value subdomain {g0 , g1 , gx } whenever value
predecessor {g0 , g1 , gx }. Whether clause Ci satisfied checked
defining goal state vin = gx .
Finally, j < n vij moves bmj , vi(j+1) moves amj . there, vij
choice move cx , causing vi(j+1) return ax . next bit arrives, vij
moves either c0 c1 , correctly indicating vi(j+1) (j + 1)-th bit arrived.
Consequently, vi(j+1) moves either g0 (g1 ) b0 (b1 ), depending whether
assignment xj+1 satisfies Ci . Hence, values type b used delay transition
vi(j+1) value type either b g. mechanism allows
variable vij react j-th bit. clause Ci , operators vi1 defined
vi1 always reacts first bit.
DTGs state variables , e1 , . . . , e2n1 appear Figure 5. function
state variables make sure n bits message propagated end
causal graph. state variable (strictly speaking, planner solving planning
problem) never forced select operator, choose propagate bit
message instead wait next bit arrive acting. turn, may cause
another state variable incorrectly conclude clause (not) satisfied.
variables third part prevent happening, since goal state defined
way cannot reached unless bits message arrive end
causal graph.
681

fiGimenez & Jonsson

Variable
s1
si ,
[2..2n 1]
vs

Operator
hs1 = 0; s1 = 1i
hsi1 = 0, si = 0; si = 1i
hsi1 = 1, si = 1; si = 0i
hs2n1 = 0, vs = x; vs = mi
hs2n1 = 1, vs = m; vs = xi

Qualifier

{0, 1}
{0, 1}

Table 2: Operators variables s1 , s2 , . . . , s2n1 , vs .

4.2 Formal Proof
section, prove C11
n NP-hard showing planning problem P11 (F )
solvable formula F satisfying assignment. start with, provide
formal definitions operators P11 (F ). operators s1 , . . . , s2n1 , vs appear
Table 2, corresponding DTGs appear Figure 3. operators variables vij ,
[1..k] j [1..n], appear Table 3, DTGs appear Figure 4. Finally,
operators , e1 , . . . , e2n1 appear Table 4, DTGs appear Figure 5.
reduce space requirement use shorthand definitions operators.
words, hv = m, v = c; v = mi, {a, b}, denotes existence two operators
hv = a, v = c; v = ai hv = b, v = c; v = bi. Similarly, hv {a, b}, v = c; v = di denotes
existence two operators hv = a, v = c; v = di hv = b, v = c; v = di. state
variables vij introduce reference numbers allow us easily refer operators.
Furthermore, operators conditional properties CNF formula F ;
operator exists indicated property satisfied. example, operator
hv22 = c0 , v23 = ax ; v23 = g0 exists clause C2 satisfied x3 , operator
hv22 = c0 , v23 = ax ; v23 = b0 exists C2 satisfied x3 . use set notation
xj Ci denote literal xj appears clause Ci .
proof organized follows. begin series technical definitions
lemmas (4.14.6) related operators implications. Definition 4.7 introduces notion admissible plans, Lemma 4.8 states plan solving P11 (F )
admissible. Next, Lemma 4.10 establishes admissible plan corresponds
assignment variables CNF formula F , operator choices
plan forced given assignment. Finally, Lemma 4.13 determines exact sequence
values taken state variable execution admissible plan, making
possible check whether goal state reached end execution. Theorem
4.14 concludes admissible plans solving P11 (F ) corresponding
satisfying assignments F .
Definition 4.1. Given partial plan P11 (F ) variable v V , (v) number
times value v changed operators .
Lemma 4.2. partial plan P11 (F ), holds
(si ) [1..2n 1],
(vs ) 2n.
682

fiChain Causal Graphs Domains Size 5

Variable
v11

vi1 ,
[2..k]

vij ,
[1..k],
j [2..n]

Ref.
(1)
(2)
(3)
(4)
(5)
(6)
(7)
(8)
(9)
(1)
(2)
(3)
(4)
(5)
(6)
(7)
(8)
(9)
(10)
(11)
(12)
(13)
(14)
(15)
(16)
(17)
(18)
(19)
(20)
(21)

Operator
hvs = 1, v11 = ax ; v11 = g1
hvs = 1, v11 = ax ; v11 = b1
hvs = 0, v11 = ax ; v11 = g0
hvs = 0, v11 = ax ; v11 = b0
hvs = m, v11 = cx ; v11 = cm
hvs = m, v11 = gx ; v11 = gm
hvs = x, v11 = bm ; v11 = cx
hvs = x, v11 = cm ; v11 = cx
hvs = x, v11 = gm ; v11 = gx
hv(i1)n {a1 , b1 , g1 }, vi1 = ax ; vi1 = g1
hv(i1)n {a1 , b1 , g1 }, vi1 = ax ; vi1 = b1
hv(i1)n {a0 , b0 , g0 }, vi1 = ax ; vi1 = g0
hv(i1)n {a0 , b0 , g0 }, vi1 = ax ; vi1 = b0
hv(i1)n {am , bm , gm }, vi1 = cx ; vi1 = cm
hv(i1)n {am , bm , gm }, vi1 = gx ; vi1 = gm
hv(i1)n {ax , cx , gx }, vi1 = bm ; vi1 = cx
hv(i1)n {ax , cx , gx }, vi1 = cm ; vi1 = cx
hv(i1)n {ax , cx , gx }, vi1 = gm ; vi1 = gx
hvi(j1) = c1 , vij = ax ; vij = g1
hvi(j1) = c1 , vij = ax ; vij = b1
hvi(j1) = c0 , vij = ax ; vij = g0
hvi(j1) = c0 , vij = ax ; vij = b0
hvi(j1) {am , bm }, vij = ax ; vij =
hvi(j1) = gm , vij = ax ; vij = gm
hvi(j1) = cm , vij = cx ; vij = cm
hvi(j1) {cm , gm }, vij = gx ; vij = gm
hvi(j1) {ax , cx }, vij = ; vij = ax
hvi(j1) = cx , vij = bm ; vij = cx
hvi(j1) = cx , vij = cm ; vij = cx
hvi(j1) {cx , gx }, vij = gm ; vij = gx

Qualifier
x1 C1
x1
/ C1
x1 C1
x1
/ C1
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
x1 Ci
x1
/ Ci
x1 Ci
x1
/ Ci
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
xj Ci
xj
/ Ci
xj Ci
xj
/ Ci
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}

Table 3: Operators variables v11 , . . . , vkn .

Variable


hvkn

e1
ei , [2..2n 1]

Operator
{a0 , a1 , b0 , b1 , g0 , g1 },
hvkn {ax , cx , gx },
hve = 1, e1
hve = 0, e1
hei1 = 1, ei
hei1 = 0, ei

= 0; = 1i
= 1; = 0i
= 0; e1 = 1i
= 1; e1 = 0i
= 0; ei = 1i
= 1; ei = 0i

Table 4: Operators variables , e1 , . . . , e2n1 .

683

fiGimenez & Jonsson

Proof. induction i. = 1, variable s1 change once, (s1 ) 1.
[2..2n 1], follows inspection operators cannot change value
si twice without changing value si1 (the operator setting si
1 si1 = 0 pre-condition, operator resetting si 0 si1 = 1
pre-condition). Since change value si initial state without
first changing value si1 , follows (si ) (si1 ) + 1 (i 1) + 1 =
induction. argument holds variable vs predecessor s2n1 , (vs )
(s2n1 ) + 1 (2n 1) + 1 = 2n.
Lemma 4.3. partial plan P11 (F ) vij , [1..k] j [1..n],
holds (vij ) (v ), v predecessor vij causal graph.
Proof. before, follows inspection operators cannot change
value vij twice without changing value v between. see this, note
subscript value D(vij ) either x, 0, 1. operator vij either changes
value one subscript x one subscript 0 (1), v value
subscript 0 (1), one subscript 0 (1) one subscript x, v value
subscript x (the argument holds v11 , although values predecessor
vs x, 0, 1 without subscripts).
Note value vij cannot change initial state without first changing
value v , since v value subscript 0 1 value vij change
initial value ax . Consequently, value vij cannot change times
value v , (vij ) (v ) claimed.
Lemma 4.4. vij , [1..k] j [1..n], partial state (v = x, vij = y),
v predecessor vij causal graph, one applicable operator
changing value vij .
Proof. inspecting operators easy see pair operators vij
different pre-conditions. exception rule operators exist
simultaneously due properties CNF formula F (e.g. operators (1) (2)).
Lemma 4.5. partial plan P11 (F ), holds
(ve ) (vkn ),
(e1 ) (ve ),
(ei ) (ei1 ) [2..2n 1].
Proof. Let v variable among , e1 , . . . , e2n1 , let v predecessor causal
graph. before, cannot change value v twice without changing value v
between. v {e1 , . . . , e2n1 }, operator setting v 1 requires v = 1,
operator resetting v 0 requires v = 0. v = , operator setting v 1 requires
v value subscript 0 1, operator resetting v 0 requires v
value subscript x. Note that, either case, cannot change value v
initial state without first changing value v . Thus, (v) (v )
variables, claimed.
684

fiChain Causal Graphs Domains Size 5

turn problem finding plan solves P11 (F ).
Lemma 4.6. Let plan solves P11 (F ).
(ei ) 2n [1..2n 1],
(ve ) 2n.
Proof. descending induction i. = 2n 1, goal(e2n1 ) = 1, value
e2n1 change least initial value init(e2n1 ) = 0, implying (e2n1 )
1 = 2n (2n 1). [1..2n 2], assume (ei+1 ) 2n (i + 1) holds
induction. Lemma 4.5 follows (ei ) (ei+1 ) 2n (i + 1). However,
since goal(ei ) 6= goal(ei+1 ) since solves P11 (F ), follows (ei ) 6= (ei+1 ).
Hence (ei ) > (ei+1 ), follows (ei ) 2n i, claimed.
argument applies e1 predecessor , since goal(ve ) = 0 6= 1 = goal(e1 ), yielding
(ve ) 2n.
Definition 4.7. admissible plan planning problem P11 (F ) partial plan
(si ) = i, (vs ) = (v11 ) = . . . = (vkn ) = (ve ) = 2n, (ei ) = 2n i,
[1..2n 1].
Lemma 4.8. plan solves P11 (F ) admissible.
Proof. Lemmas 4.3 4.5 (vs ) (v11 ) (vkn ) (ve ). But,
Lemmas 4.2 4.6, values equal 2n, since 2n (vs ) (ve ) 2n.
proof Lemma 4.2 (si ) (si1 ) + 1, [2..2n 1],
(vs ) (s2n1 ) + 1, together Lemma 4.2 (vs ) = 2n implies (si ) = i,
[1..2n 1]. proof Lemma 4.6 (ve ) > (e1 ), (ei ) > (ei+1 ),
[1..2n 2], (e2n1 ) 1, together Lemma 4.6 (ve ) = 2n implies
(ei ) = 2n i, [1..2n 1].
Please note converse Lemma 4.8 true, is, admissible plans
solve planning problem P11 (F ).
consequence Lemma 4.8, find plan solves P11 (F ) need
consider admissible plans. particular, admissible plan changes value variable vs
exactly 2n times, generating sequence 2n + 1 values. Note value vs always
changes x either 0 1, back x.
Definition 4.9. Let admissible plan, let x, m1 , x, . . . , x, mn , x sequence
2n + 1 values variable vs takes execution , mj {0, 1}
j [1..n]. use denote message m1 , . . . , mn induced , use
denote formula assignment (xj ) = mj j [1..n].
turns out, operators part admissible plan completely
determined message induced .
Lemma 4.10. Let admissible plan P11 (F ) let induced message.
operators changing value variable vij , [1..k] j [1..n], well
sequence values variable vij takes execution , completely
determined .
685

fiGimenez & Jonsson

Proof. v {v11 , . . . , vkn }, let v causal graph predecessor. proof
Lemma 4.3 know cannot change value v twice without changing value
v between, initial state, change value v
change value v. definition admissible know (v ) = (v) = 2n.
way admissible plan change value v 2n times without changing
value v 2n times first change value v , v, v , on.
Now, Lemma 4.4 know that, given partial state (v = x, v = y),
one applicable operator changing value v. Thus, time admissible
plan changes value v value v , one operator so.
plan choice select operator since allowed change value
v changing value v. Consequently, sequence values taken
v completely determined, operators v, well sequence values
takes on, completely determined also. proof follows double induction
j, since sequence values taken vs (the predecessor v11 ) completely
determined message .
follows Lemma 4.10 relevant degree freedom admissible
plan selecting elements message , repeatedly deciding whether move
vs = 0 vs = 1 vs = x. selected, operator choices
forced, else plan admissible. particular, message unique
state executing admissible plan starting init results s. remains
determine whether unique state matches goal state.
Remark. Note Lemma 4.10 mention operator order admissible plan.
Indeed, change order operators admissible plan without making
plan inadmissible. example, let v1 , v2 , v3 three consecutive variables
causal graph, let ha11 , a12 , a13 , a21 , a22 , a23 subsequence operators changing
values, aji j-th operator changing value vi . subsequence

ha11 , a12 , a21 , a13 , a22 , a23 achieves result. long partial order haji , aji+1 , aj+1

respected j, change operator order please.
proceed determine sequence values variable vij , [1..k] j
[1..n], takes execution admissible plan induced message .
First, define satisficing index clauses, sequence values plan.
Definition 4.11. Let admissible plan induced message = m.
clause Ci , let satisficing index Ti [1..n+1] smallest number (xTi ) =
mTi satisfies Ci . number exists, Ti = n + 1.
Definition 4.12. Let admissible plan. clause Ci [1..2n + 1],
let sequence values Qti () vector n values representing, variable
vij , j [1..n], t-th value taken vij execution .
following lemma key understanding idea behind reduction C11
n , since
specifies sequences values admissible plan induces execution.
Lemma 4.13. Let assignment variables x1 , . . . , xn formula F .
686

fiChain Causal Graphs Domains Size 5

1) Existence. exists admissible plan planning problem P11 (F ) induced assignment = .
2) Claim. Let Qti sequences values described Part 3) lemma.
admissible plans = sequences values Qti () = Qti ,
[1..k] [1..2n + 1].
3) Sequence values. sequence values Qti , [1..k] [1..2n + 1],
follows.
a) j < Ti ,
nj

j1

z }| {
c x cx
Qi2j1 =
2j
Qi = cmj cmj
2j+1
=
c x cx
Qi

ax
bmj
cx

z }| {
ax ax
amj amj
ax ax

ax
gmj
gx

z }| {
ax ax
gmj gmj
gx gx

b) j = Ti ,
nj

j1

Qi2j1
Q2j

Q2j+1


z }| {
c x cx
=
= cmj cmj
=
c x cx

c) j > Ti ,
jTi

nj

z }| {
gx gx
gmj gmj
gx gx

z }| {
gx gx
gmj gmj
gx gx

Ti 1

Qi2j1
Q2j

Q2j+1


z }| {
=
c x cx
= cmj cmj
=
c x cx

gx
gmj
gx

Proof. proving lemma, must check definition Qti given Part 3
consistent. necessary due overlapping statements, namely, every
odd 1 2n + 1, sequence Qti defined twice, Qi2j1 j = 2t ,

another time Qi2j +1 j = 2t . However, sequences values well-defined
+1
definitions Qi2j1 Q2j
match combination j j = j 1,

shown following table.


j

Qi2j +1 = Qi2j1

Case (a)

z }| { z }| {
cx cx ax ax

Case (b)

z }| { z }| {
cx cx ax ax

Case (c)

z }| { z }| {
cx cx gx gx

Case (c)

z }| { z }| {
cx cx gx gx

j

j

1 < j < Ti :

Case (a)

j

1 < j = Ti :

Case (a)

Ti 1

j = Ti + 1 n:

Case (b)

Ti 1

Ti + 1 < j n:

Case (c)

687

nj

nj

nTi +1
nTi +1

fiGimenez & Jonsson

Now, prove Parts 2 3 lemma. Assume admissible plan induced
assignment = . proof proceeds double induction j. particular,
2j+1
prove validity three statements type Qi2j1 , Q2j
, assuming
, Qi




statements type Qi (for < t) statements type Qi2j 1 , Q2j


Qi2j +1 (for j < j) already hold. first prove validity Qi2j1 . j = 1,
Qi2j1 = Q1i = ax ax Cases (a) (b) corresponds initial state vi1 , . . . , vin
(note Case (c) cannot hold j = 1). j > 1 know that, since statements

consistent, Qi2j1 = Qi2j +1 j = j 1, hence correctness Qi2j1 follows
induction j.
2j+1
Next, prove statements relative Q2j
. Consider variable v
Qi
precedes vi1 causal graph, values number 2j 1, 2j, 2j + 1 takes
execution . = 1, v = vs values x, mj , x. > 1,
v = v(i1)n and, induction i, values ax , amj , ax j < Ti1 j < n;
ax , bmj , cx j = n < Ti1 ; ax , gmj , gx j = Ti1 ; gx , gmj , gx j > Ti1 .
proof divided 6 parts, depending values j Ti .
I) 1 = j < Ti . Consider following table, write instead mj = m1
simplify notation.
v
vi1
2j 1
{x, ax , gx }
ax
{m, , bm , gm }
2j
2j + 1 {x, ax , cx , gx }


vi2
ax








vin
ax



three rows table correspond values number 2j 1, 2j, 2j + 1
variables v , vi1 , . . . , vin . first column corresponds possible values
predecessor v vi1 take on. first row given Qi2j1 , second
2j+1
third rows, filled, correspond Q2j
.
Qi
Let A2j operator causing 2j-th value vi1 . According previous
table, pre-condition A2j must compatible
hv {m1 , am1 , bm1 , gm1 }, vi1 = ax
is, values variables v vi1 A2j applied. Since Ti > 1, (x1 ) =
m1 satisfy clause Ci , operator A2j must one labelled (2)
(4) Table 3. (Only one operators applicable, depending value
m1 whether v vs v(i1)n .) either case, application A2j causes
value vi1 become bm1 , fill blank previous table.
v
vi1
vi2
2j 1
{x, ax , gx }
ax
ax
2j
{m, , bm , gm } bm (2, 4)
2j + 1 {x, ax , cx , gx }








vin
ax



way, check A2j+1 , operator causing (2j + 1)-th value
vi1 , must one labelled (7) Table 3; new value vi1 cx .
688

fiChain Causal Graphs Domains Size 5

remaining variables, easy check variables vi2 , . . . , vin become am1 , due
operators type (14), become ax , due operators type (18).
table complete:
v
vi1
vi2 vin
2j 1
{x, ax , gx }
ax
ax ax
2j
{m, , bm , gm } bm (2, 4) (14)
2j + 1 {x, ax , cx , gx }
cx (7)
ax ax (18)
shows Case (a) Lemma 4.13 holds j = 1 Ti > 1.
II) 1 = j = Ti . proof similar Case (I). Since Ti = 1, (x1 ) = m1
satisfies clause Ci . result, admissible operators causing 2j-th value
vi1 labelled (1) (3). either case, value vi1 becomes gm1 .
Consequently, admissible operators vi2 , . . . , vin different before.
resulting table:
v
vi1
vi2 vin
2j 1
{x, ax , gx }
ax
ax ax
2j
{m, , bm , gm } gm (1, 3) gm gm (15)
2j + 1 {x, ax , cx , gx }
gx (9)
gx gx (21)
III) 1 < j < Ti . case, remaining ones, show resulting table.
always write = mj . follows, omit column v since possible
values always same.
vi1
vi2 vi(j1)
vij
vi(j+1) vin
2j 1 cx
c x cx
ax
ax ax
cm (5)
cm cm (16) bm (11, 13)
(14)
2j
2j + 1 cx (8)
cx cx (20) cx (19)
ax ax (18)
IV) 1 < j = Ti .
vi1
vi2 vi(j1)
vij
vi(j+1) vin
2j 1 cx
c x cx
ax
ax ax
cm (5)
cm cm (16) gm (10, 12)
gm gm (15)
2j
2j + 1 cx (8)
cx cx (20) gx (21)
gx gx (21)
V) 1 = Ti < j.
vi1
vi2 vin
2j 1 gx
gx gx
2j
gm (6) gm gm (17)
2j + 1 gx (9) gx gx (21)
VI) 1 < Ti < j.
vi1
vi2 vi(Ti 1)
viTi vin
2j 1 cx
c x cx
gx gx
2j
cm (5)
cm cm (16) gm gm (17)
cx cx (20) gx gx (21)
2j + 1 cx (8)
689

fiGimenez & Jonsson

remains check Case (a) Lemma 4.13 follows parts (I) (III),
Case (b) parts (II) (IV), Case (c) parts (V) (VI). proves Part
2 3 lemma.
Finally, note existence admissible plan directly follows previous
discussion, since always specified operators used every situation,
assumed existence. proves Part 1 lemma.
Theorem 4.14. exists plan solves planning problem P11 (F )
exists assignment satisfies CNF formula F .
Proof. : Given assignment satisfies F , construct admissible plan whose
induced formula assignment equals , choosing sequence values vs accordingly. follows Ti n clause Ci , since exists variable xj
(xj ) = mj satisfies Ci . Then, Q2n+1
form indicated Case (b) (c) Lemma

4.13. either case, (2n + 1)-th value variable vin gx , required goal state.
plan thus solves P11 (F ).
: Let plan solves planning problem P11 (F ). Lemma 4.8 plan
admissible. show contradiction = satisfies F . Assume not.
exists clause Ci satisfied , implying Ti = n + 1. Since n < Ti , (2n + 1)-th
value variable vin cx according Case (a) Lemma 4.13. contradicts solving
P11 (F ), since goal value vin cx gx .
Proposition 4.15. Plan existence C11
n NP-hard.
Proof. largest variable domains planning problem P11 (F ) variables
v11 , . . . , vkn , contain 11 values. proof follows immediately well-known
NP-hardness Cnf-Sat, Theorem 4.14, fact produce planning
problem P11 (F ) polynomial time given CNF formula F .
4.3 Example
illustrate reduction using small example CNF formula F = (x1 x2 ) one
clause two variables x1 x2 . variable set corresponding planning problem
P11 (F ) V = {s1 , s2 , s3 , vs , v11 , v12 , , e1 , e2 , e3 }. admissible plan induce
four different messages (0, 0), (0, 1), (1, 0), (1, 1). message (0, 0) corresponds
assignment satisfy F . plan solves P11 (F ) induced
message (0, 1) appears Table 5. Note that, following execution plan, goal state
goal = (v12 = gx , = 0, e1 = 1, e2 = 0, e3 = 1) satisfied desired; last value change
variable appearing goal state marked using boldface.

5. C5n NP-hard
section, describe reduction Cnf-Sat C5n . CNF formula F
associate planning problem P5 (F ). clause Ci variable xj F , P5 (F ) contains
1 , domain D(v 1 ) = {a , , , b }, v 2 , domain D(v 2 ) =
two state variables vij
x 0 1 x
ij
ij
ij
2 , D(v 2 ) = {a , b , b }.
{ax , a0 , a1 , b0 , b1 }. values a0 a1 omitted vin
x 0 1

690

fiChain Causal Graphs Domains Size 5

..
.
hs1 = 0, s2 = 0; s2 = 1i
hs2 = 1, s3 = 1; s3 = 0i
hs3 = 0, vs = x; vs = 1i
hvs = 1, v11 = cx ; v11 = c1
hv11 = c1 , v12 = ax ; v12 = g1
hv12 = g1 , = 0; = 1i
hve = 1, e1 = 0; e1 = 1i
hs1 = 0; s1 = 1i
hs1 = 1, s2 = 1; s2 = 0i
hs2 = 0, s3 = 0; s3 = 1i
hs3 = 1, vs = 1; vs = xi
hvs = x, v11 = c1 ; v11 = cx
hv11 = cx , v12 = g1 ; v12 = gx
hv12 = gx , = 1; = 0i

hs3 = 0, vs = x; vs = 0i
hvs = 0, v11 = ax ; v11 = b0
hv11 = b0 , v12 = ax ; v12 = a0
hv12 = a0 , = 0; = 1i
hve = 1, e1 = 0; e1 = 1i
he1 = 1, e2 = 0; e2 = 1i
he2 = 1, e3 = 0; e3 = 1i
hs2 = 0, s3 = 0; s3 = 1i
hs3 = 1, vs = 0; vs = xi
hvs = x, v11 = b0 ; v11 = cx
hv11 = cx , v12 = a0 ; v12 = ax
hv12 = ax , = 1; = 0i
hve = 0, e1 = 1; e1 = 0i
he1 = 0, e2 = 1; e2 = 0i
..
.

Table 5: plan solves planning problem P11 (F ) example formula F .
(a)

(b)

(c)

(d)

a0

a0

a0

a0
a0

x

0

b0

x

ax

bx

ax

x

x

b1

ax

ax b0

ax

ax b1

bx
ax

ax
a1

1

ax a0

ax

a1

ax bx

ax

ax
a1

a1

b0
a0

ax
a0

bx

ax

(e)
b0
ax bx

a1

ax a1
a1

ax bx
b1

ax bx

a1
b1

1 , (b) v 1 , > 1, (c) v 1 , j > 1, (d) v 2 , j < n, (e) v 2 .
Figure 6: DTGs (a) v11
i1
ij
ij


state variables s1 , . . . , s2n1 , vs , , e1 , . . . , e2n1 , well domains corresponding
2 .
operators, before, except predecessor vkn
1 ) = init(v 2 ) = , [1..k]
initial state new state variables init(vij
x
ij
1
j [1..n], goal state goal(vi1 ) = ax , [1..k]. Table 6 lists operators
1 v 2 , [1..k] j [1..n], Figure 6 shows corresponding DTGs.
variables vij
ij
Table 6 lists new operators variable , different pre-conditions
2 .
predecessor vkn
5.1 Intuition
reduction C5n based following idea: instead using explicit value
remember clause satisfied, goal remain initial value ax .
way able reduce size variable domains needed reduction.
Somewhat surprisingly, new reduction uses fewer total operators C11
n .
691

fiGimenez & Jonsson

Variable
1
v11

1,
vi1
[2..k]
1,
vij
[1..k],
j [2..n]
2,
vij
[1..k],
j [1..n 1]

2 ,
vin
[1..k]



Ref.
(1)
(2)
(3)
(4)
(5)
(6)
(7)
(8)
(9)
(10)
(11)
(12)
(13)
(14)
(15)
(16)
(17)
(18)
(19)
(20)
(21)
(22)

Operator
1 = ; v1 =
hvs = m, v11
x 11

1 = ; v1 =
hvs = x, v11
11
x
1 = ; v1 = b
hvs = x, v11
11
x
1 = ; v1 =
2
= bm , vi1
hv(i1)n
x i1

2
1 = ; v1 =
hv(i1)n
= ax , vi1
x
i1
2
1 = ; v1 = b
hv(i1)n
= ax , vi1
i1
x
1 = ; v1 =
2
= , vij
hvi(j1)

x ij
2
1 = ; v1 =
hvi(j1)
= ax , vij
ij
x
1 = b ; v1 =
2
= bm , vij
hvi(j1)

x ij
1
1
2
hvi(j1) = ax , vij = ; vij = bx
1 = , v2 = ; v2 =
hvij

x ij
ij
1 = , v2 = ; v2 =
hvij
x
x ij
ij
2
2
1
hvij = , vij = ax ; vij = bm
1 = , v2 = b ; v2 =
hvij
x
x ij
1 ij
1 = b , v2 = b ; v2 =
hvij
x ij
1 ij
x
1 = , v2 = b ; v2 =
hvij
x ij
0 ij
x
1 = b , v2 = b ; v2 =
hvij
x ij
0 ij
x
1 = , v2 = ; v2 = b
hvin

x

1 = , v2 = b ; v2 =
hvin
x
1
x
1 = b , v2 = b ; v2 =
hvin
x
1
x
1 = , v2 = b ; v2 =
hvin
x
x
0
1 = b , v2 = b ; v2 =
hvin
x
0
x
2 = b , v = 0; v = 1i
hvkn
e
e
2 = , v = 1; v = 0i
hvkn
x e
e

Qualifier
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
xnj+1 Ci
xnj+1
/ Ci
xnj+1 Ci
xnj+1
/ Ci
{0, 1}
x1 Ci
x1
/ Ci
x1 Ci
x1
/ Ci
{0, 1}

1 , v 2 , v , [1..k] j [1..n].
Table 6: Operators variables vij
e
ij

692

fiChain Causal Graphs Domains Size 5

reduction C5n uses another new idea. reduction C11
n , information
propagated forward, i.e., variable vij changed value according value
predecessor vi(j1) . reduction C5n , however, constructed information propagated forward (in particular, bits message) information
propagated backwards (the index bit currently checking). planning
problem arranged variable v may several applicable operators,
one satisfies pre-condition applicable action successor v . result
value v time + 1 depends value v time t.
explain planning problem P5 (F ) bit detail. Due backward
propagation mechanism, bits message checked reverse order.
words, vin checks first bit, vi(n1) checks second bit, vi1 checks n-th
2 check whether (n j + 1)-th bit satisfies clause C ,
bit. purpose vij

1 inform v 2
whereas purpose vij


(n

j
+
2)-th
bit

arrived.
i(j1)
1 keeps track whether C satisfied first (n j + 1)
Implicitly, vij

bits.
Assume without loss generality message 0 0. Let us see happens
corresponding assignment satisfy clause Ci . Upon arrival first bit,
2 move b . requires v 1 = pre-condition,
state variable vin
0
0

l , j [1..n 1] l {1, 2}, . Next, v 2
turn requires state variables vij
0

1 = b . turn, requires state
move back ax , requires pre-condition vin
x
l , j [1..n 1] l {1, 2}, . v 1 moves b
variables vij
x
x

2
a0 , requiring vi(n1) = b0 pre-condition.
1 b following (nj +1)We see that, long clause remains unsatisfied, vij
x
1 b following last bit. Assume
th bit. particular, means vi1
x
2 moves b , requires v 1
(n j + 1)-th bit satisfies clause Ci . vij
0
x
ij
1
move ax instead bx . there, way vi(j1)
bx following
1 following last bit, satisfying goal
(n j + 2)-th bit. particular, vi1
x
state.
5.2 Formal Proof
proof C5n organized much way C11
n . Note variables
s1 , . . . , s2n1 , vs , , e1 , . . . , e2n1 before, Lemmas 4.2 4.6 still apply
P5 (F ). easy check Lemmas 4.3, 4.5 4.8 hold P5 (F ). However,
Lemma 4.4 longer holds, since several operators share preconditions, namely
operators (2) (3), (5) (6), (8) (10), (11) (13). spite this,
operators sequences values admissible plan completely determined
induced message , P11 (F ) (as shown Lemma 4.10):
Lemma 5.1. Let admissible plan P5 (F ) let induced message.
l , [1..k], j [1..n], l {1, 2},
operators changing value variable vij
l takes execution ,
well sequence values variable vij
completely determined .
1 , assume without loss generality value .
Proof. First consider variable v11
0
1 , namely (2), changing value
Given (vs = x), two applicable operators v11

693

fiGimenez & Jonsson

ax , (3), changing value bx . first sight, admissible plan choose either.
2 pair
However, admissible, change value v11
1 . Note v 1 = , v 2 either two values, namely
value changes v11
0
11
11
2 , admissible operator v 2 (12),
a0 b0 . value v11
0
11
1 = . Thus, changes value v 1 b longer admissible,
pre-condition v11
x
x
11
2 b , correct choice depends
choose operator (2). value v11
0
2 (16)
CNF formula F . xn satisfies clause C1 , admissible operator v11
1 = , choose operator (2). Otherwise, admissible
pre-condition v11
x
2
1 = b , choose operator (3).
operator v11 (17) pre-condition v11
x
2 .
1
either case, operator choice v11 forced given value v11
1 , [2..k], v 1 , [1..k] j [2..k],
reasoning applies variables vi1
ij
2 , [1..k] j [1..n 1], corresponding operators share
vij
pre-conditions. degree freedom admissible plan selecting induced
message choosing operators vs accordingly. remaining operator choices
and, consequently, sequences values completely determined induced message
.
prove lemma similar Lemma 4.13, establishing sequence values taken
state variables P5 (F ) execution admissible plan.
Definition 5.2. Let admissible plan P5 (F ). clause Ci
[1..2n + 1], let sequence values Qti () vector 2n elements representing,
l , j [1..n] l {1, 2}, t-th value taken variable v l
variable vij
ij
l ]. define diagonal value
execution . Let us denote value Qt ()[vij
1
qji (), [1..k] j [1..n], value Q2j+1 ()[vi(nj+1)
].
Lemma 5.3. Let assignment variables x1 , . . . , xn formula F .
1) Existence. exists admissible plan planning problem P5 (F ) induced
assignment = .
2) Claim. Let qji described Part 3) lemma. admissible plans
= diagonal values qji () = qji [1..k] j [1..n].
3) Diagonal values. diagonal values qji , [1..k] j [1..n],
follows.
a) j < Ti , qji = bx .
b) j Ti , qji = ax .
Proof. Note that, according Lemma 5.1, diagonal values qji (),
full sequences values Qti (), completely determined admissible plan .
prove, then, admissible plans exist assignment , claimed Part 1,
diagonal values match expression given Part 3. prove two facts
careful, general analysis planning problem P5 (F ), explaining
analysis implies lemma. Incidentally, sequences values Qti ()
694

fiChain Causal Graphs Domains Size 5

obtained analysis; study important
purposes.
l variable P (F ). Clearly,
Let admissible plan, let v = vij
5

subscript t-th value Q ()[v] v takes depends parity t, since
operators affecting v change subscript x = {0, 1} back x.
Namely, subscript Qt ()[v] x = 2p 1, = 2p, p-th
bit message .
1,
Now, j [2..n 1] [1..k], consider t-th values variables vij
2 , v1
vij
i(j+1) take on, = 2p 1, 2p, 2p + 1. previous observation subscripts
implies (trivially) know something values.
1 ] Qt ()[v 2 ] Qt ()[v 1
Qt ()[vij
ij
i(j+1) ]
= 2p 1 {ax , bx }
ax
{ax , bx }
= 2p

{am , bm }

= 2p + 1 {ax , bx }
ax
{ax , bx }
1
] affects values diagonal,
study value Q2p1 ()[vi(j+1)
2p1
1
2p+1
1
2p
2
()[vi(j+1)
] = ax , check
()[vij ]. Q
namely Q ()[vij ] Q
one possible outcome.
1
2]
1]
Rule
]
Qt ()[vi(j+1)
Qt ()[vij
Qt ()[vij
= 2p 1 {ax , bx }
ax
ax
= 2p


(11)

(7)
= 2p + 1
ax
(8)
ax
(12)
{ax , bx }

is, value type ax propagated along diagonal another value ax .
call Propagation Rule I.
1
] = bx .
study possible outcomes Q2p1 ()[vi(j+1)
2p
2
2p+1
1
case, values Q ()[vij ] Q
()[vij ] diagonal depend whether
p-th bit message clause Ci satisfied xnj+1 = (c.f.
operators (14)(17) (18)(22) Table 6). Ci satisfied xnj+1 = m, follows
values must bm ax . Propagation Rule II.
1]
2]
1
Rule II
Qt ()[vij
Qt ()[vij
Qt ()[vi(j+1)
]
= 2p 1 {ax , bx }
ax
bx

bm
(13)

(9)
= 2p
= 2p + 1
ax
(8)
ax
(14, 16)
{ax , bx }

contrary, clause Ci satisfied, values must bm bx .
call Propagation Rule III.
1
2]
1]
Rule III Qt ()[vij
Qt ()[vi(j+1)
]
Qt ()[vij
= 2p 1 {ax , bx }
ax
bx
= 2p

bm
(13)

(9)
= 2p + 1
bx
(10)
ax
(15, 17)
{ax , bx }

695

fiGimenez & Jonsson

Finally, let us consider cases j = 1 j = n, treated
2 values type . note
previous analysis. Note variables vin

1 cannot take value b time < 2n + 1, cannot change further,
variables vi1
x
since pre-conditions operators (1)(3), = 1, (4)(6), [2..k],
1 = b . Thus, possible outcome two variables
compatible vi1
x
p < n following.
1
2 ]
1 ]
]
Qt ()[v(i+1)1
Qt ()[vin
Qt ()[vin
= 2p 1 {ax , bx }
ax
ax
= 2p

bm
(18)

(4)
ax
(19, 21; 20, 22)
ax
(5)
= 2p + 1 {ax , bx } (8; 10)
1
] either ax bx , using operators
Note that, p = n, value Q2p+1 ()[v(i+1)1
1 ,
(5) (6). reader check similar analysis applies variable v11
operators (1)(3) take role operators (4)(6).
Let us summarize previous analysis following table.

t=1
t=2
t=3
t=4
..
.

1
2
1
vi1
vi1
vi2

ax ax ax

ax

..
.

= 2n 2
= 2n 1 ax
= 2n

= 2n + 1





1 v2
2
1
vin
vi(n1)
vi(n1)

ax
ax ax ax
bm
ax
bm
..
.



bm
ax
bm
ax

first row previous table contains initial state planning problem:
variables set ax . leftmost column rightmost column contain values
1 v 2 . Then, values b right column propagated
taken variables vi1


along diagonals using three propagation rules already discussed: value type
yields values type according Rule I; value type b yields value type
clause satisfied Rule II, type b satisfied, Rule III.
applies propagating values first row: since type a,
values top-left triangle type a, according Rule I. Note longest
diagonal coincides diagonal values qji Definition 5.2.
discussion proceed prove lemma. Let assignment formula
F . existence plan = implied analysis already done
l ], since shown operators used case produce
values Qt [vij
actual changes value.
1 ],
Finally, consider diagonal values qji () j = 1, . . . , n, is, values Q3 ()[vin
5
1
2n+1
1
Q ()[vi(n1) ], . . ., Q
()[vi1 ]. Let j < Ti Case (a), is, first j bits
message , assigned variables x1 , . . . , xj , satisfy clause Ci . Consequently,

2j+1 ()[v 1
1 ], q = Q5 ()[v 1
diagonal values q1i = Q3 ()[vin
2
i(n+1j) ] must
i(n1) ], . . ., qj = Q
696

fiChain Causal Graphs Domains Size 5

bx , according Rule III. contrary, assume j Ti Case (b),
follows qpi = bx p < Ti due Rule III, qpi = ax p = Ti due Rule II,
qpi = ax j p > Ti due Rule I.
Theorem 5.4. exists valid plan solving planning problem P5 (F )
exists assignment satisfies CNF formula F .
Proof. : Lemma 5.3, existence assignment satisfies F implies
admissible plans = satisfy qji () = qji . Since Ti n [1..k], follows
qni = ax , required goal state P5 (F ). plan thus solves P5 (F ).
: Let plan solving planning problem P5 (F ). Since Lemma 4.8 holds
P5 (F ), plan admissible. show contradiction = satisfies F .
Assume not. exists clause Ci satisfied . Thus, Lemma 5.3 implies
1 following execution b .
qji () = bx j [1..n]. particular, value vi1
x
1)=a .
contradicts solving P5 (F ), since bx different goal state goal(vi1
x
Proposition 5.5. Plan existence C5n NP-hard.
Proof. largest variable domains planning problem P5 (F ) variables
2 , [1..k] j [1..n 1], contain 5 values. proof follows immediately
vij
NP-hardness Cnf-Sat, Theorem 5.4, fact produce
planning problem P5 (F ) polynomial time given CNF formula F .

6. Discussion
paper, shown problem determining whether solution plan exists
planning problems class Ckn NP-hard whenever k 5. contrast, Brafman
Domshlak (2003) developed polynomial-time algorithm generating plans solve
planning problems class C2n . said intermediate cases, namely
Ckn k {3, 4}? follows, sketch arguments tractability
cases. Although discussion mostly based intuition gained studying
classes, might prove helpful someone trying determine complexity.
one hand, seems likely us plan existence C4n NP-hard.
reduction C5n uses one type state variable whose domain larger 4, namely
2 . Finding reduction C4 seems possible, although likely difficult since
vij
n
available options become increasingly restricted state variable domains get smaller.
particular, tried failed find reduction C4n .
Domshlak Dinitz (2001) showed exist planning problems C3n
exponential length minimal solutions. Although often indicates planning class
difficult, imply plan existence intractable. exemplified
Jonsson Backstrom (1998) define class planning problems exponential
length minimal solutions plan existence could checked polynomial time.
present authors (Gimenez & Jonsson, 2008a) showed even plan generation
particular class could done polynomial time, resulting plans given
compact format macros.
second argument favor hardness C3n may multiple ways
transition two values variable. example, consider planning problem
697

fiGimenez & Jonsson

two actions changing value variable v 0 1, namely
= hv = 0, v = 0; v = 1i = hv = 1, v = 0; v = 1i. Since variables 3 values,
possible neither v = 0 v = 1 hold current state. planner would
thus choose whether satisfy v = 0 v = 1. contrast, C2n two
actions could replaced single action hv = 0; v = 1i since one always
applicable. consequence, even minimal plan length bounded planning
problem C3n , may exponentially many plans length (in fact,
main idea behind reductions).
Another observation regards number possible domain transition graphs
state variable. k 2, possible show state variable Ckn may
2
2k (k1) distinct domain transition graphs. words, number graphs grows
exponentially k. particular, state variables C2n 24 = 16 distinct
graphs, number C3n 218 . Although large number possibilities
guarantee hardness, clear expressive power C3n much higher
C2n .
evidence provided suggests C3n significantly harder C2n . However,
sure C3n hard enough intractable. State variables three
values lend well type reduction presented, since
propagating message requires three values. reduction C3n , idea
underlying may message-passing mechanism exploited.
hand, maybe way determine plan existence C3n polynomial time.
algorithm would take consideration multiple (but finite) combinations domain
transition graphs three values, well inherent structure graphs. know
expressive power domain transition graphs 5 values large handle
polynomial time; maybe case using 3 values.

Acknowledgments
work partially funded APIDIS MEC grant TIN2006-15387-C03-03.

Appendix A. C7n NP-hard
appendix, describe modify reduction C11
n resulting
planning problem, call P7 (F ), needs variable domains size 7. reduction previously appeared conference paper (Gimenez & Jonsson, 2008b), without
proof. main idea reduction same, construction used check
assignment satisfies clause Ci involved. Previously, used n variables {vij }j[1 . . n] whose role was, essentially, check whether j-th bit (xj )
propagated message satisfies Ci . modified reduction, variable vij replaced
1 , v 2 , v 3 , collectively play role. variables
three variables vij
ij
ij
s1 , . . . , s2n1 , vs , , e1 , . . . , e2n1 , well domains corresponding operators,
3 .
before, except predecessor vkn
1 ) = D(v 3 ) = {a , , , b , b , b , g }
domains new variables D(vij
x 0 1 x 0 1 x
ij
2
D(vij ) = {gx , g0 , g1 , ax , a0 , a1 , bx } [1..k], j [1..n]. initial state
1 ) = init(v 2 ) = init(v 3 ) = , [1..k] j [1..n], goal
variables init(vij
x
ij
ij
698

fiChain Causal Graphs Domains Size 5

Variable
1
v11

1,
vi1
[2..k]

1,
vij
[1..k],
j [2..n]

Ref.
(1)
(2)
(3)
(4)
(5)
(6)
(7)
(1)
(2)
(3)
(4)
(5)
(6)
(7)
(8)
(9)
(10)
(11)
(12)
(13)
(14)
(15)
(16)
(17)

Operator
1 = ; v1 = g
hvs = 1, v11
x
x 11
1 = ; v1 = b
hvs = 1, v11
x 11
1
1 = ; v1 = g
hvs = 0, v11
x
x 11
1 = ; v1 = b
hvs = 0, v11
x 11
0
1 = g ; v1 = b
hvs = m, v11
x 11

1 = b ; v1 = b
hvs = m, v11
x 11

1 = b ; v1 = b
hvs = x, v11
11
x
3
1 = ; v1 = g
hv(i1)n
{a1 , b1 }, vi1
x
x i1
1 = ; v1 = b
3
{a1 , b1 }, vi1
hv(i1)n
x i1
1
1
1
3
hv(i1)n {a0 , b0 }, vi1 = ax ; vi1 = gx
3
1 = ; v1 = b
hv(i1)n
{a0 , b0 }, vi1
x i1
0
3
1 = g ; v1 = b
hv(i1)n
{am , bm }, vi1
x i1

3
1 = b ; v1 = b
hv(i1)n
{am , bm }, vi1
x i1

1
1
3
hv(i1)n {ax , bx }, vi1 = bm ; vi1 = bx
3
1 = ; v1 = g
hvi(j1)
= b1 , vij
x ij
x
1
1
3
hvi(j1) = b1 , vij = ax ; vij = b1
3
1 = ; v1 = g
hvi(j1)
= b0 , vij
x ij
x
1 = ; v1 = b
3
= b0 , vij
hvi(j1)
x ij
0
3
1 = ; v1 = g
hvi(j1)
= gx , vij
x ij
x
1
1
3
hvi(j1) = , vij = ax ; vij =
3
1 = g ; v1 = b
hvi(j1)
= bm , vij

x ij
3
1 = b ; v1 = b
hvi(j1) = bm , vij
x ij

3
1 = ; v1 =
hvi(j1)
{ax , bx }, vij
x
ij
1 = b ; v1 = b
3
= bx , vij
hvi(j1)
ij
x

Qualifier
x1 C1
x1
/ C1
x1 C1
x1
/ C1
{0, 1}
{0, 1}
{0, 1}
x1 Ci
x1
/ Ci
x1 Ci
x1
/ Ci
{0, 1}
{0, 1}
{0, 1}
xj Ci
xj
/ Ci
xj Ci
xj
/ Ci
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}

1 , [1..k] j [1..n].
Table 7: Operators variables vij

2 ) = g , [1..k]. Table 7 shows operators variables v 1 , [1..k]
state goal(vin
x
ij
2 v 3 , [1..k]
j [1..n], Table 8 shows operators variables vij
ij
j [1..n]. Figures 7 8 shows corresponding domain transition graphs. Table 8
shows new operators variable , different pre-conditions
3 .
predecessor vkn

A.1 Intuition
intuition behind reduction C7n largely C11
n . planning
problem P7 (F ) corresponding CNF formula F consists three parts, first
third identical P11 (F ). Thus, difference lies second part. Recall
reduction C11
n , clause Ci variable xj F , planning
problem P11 (F ) contains state variable vij performs following functions:
1. Propagate message generated vs .
699

fiGimenez & Jonsson

Variable
2,
vij
[1..k],
j [1..n]

Ref.
(18)
(19)
(20)
(21)
(22)
(23)
(24)
(25)
(26)
(27)
(28)
(29)
(30)
(31)

3,
vij
[1..k],
j [1..n]



Operator
1 {a , b }, v 2 = ; v 2 =
hvij

x ij

ij
1 = g , v2 = ; v2 = g
hvij
x
x ij
x ij
1 = b , v2 = g ; v2 = g
hvij
ij
x ij

1 = b , v2 = b ; v2 =
hvij

x ij
ij
1 = , v2 = ; v2 =
hvij
x ij
ij
x
1 = b , v2 = ; v2 = b
hvij
x
ij
x ij
1 = b , v2 = g ; v2 = g
hvij
x ij
ij
x
2 = , v3 = ; v3 =
hvij
ij
x ij

2 = g , v3 = ; v3 = g
hvij
x
x ij
x ij
2 = g , v3 = g ; v3 = b
hvij
ij
x ij

2 {a , g }, v 3 = b ; v 3 = b
hvij

x ij

ij
2 = , v3 = ; v3 =
hvij
x ij
ij
x
3
3
2
hvij = bx , vij = ; vij = bx
2 {b , g }, v 3 = b ; v 3 = b
hvij
x
x x
ij
ij
3
hvkn {a0 , a1 , b0 , b1 }, = 0; = 1i
3 {a , b }, v = 1; v = 0i
hvkn
x x
e
e

Qualifier
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}
{0, 1}

2 , v 3 , v , [1..k] j [1..n].
Table 8: Operators variables vij
e
ij

(a)

(b)

(c)

b0

b0

a0

0
ax

0

0
bx

gx
1

x

ax
1

1

a0
a0,b0 b0

a0,b0

x

gx

a1, b1

a1, b1

ax
bx

b0

bx

ax

gx

a1
b1

ax
bx

b1
ax,bx

b1

b0
ax,bx

a0

b1

b0

b0

bx
bx

gx
b1

bx

b1

a1
a1

b1

1 , (b) v 1 [2..k], (c) v 1 [1..k], j [2..n].
Figure 7: DTGs (a) v11
ij
i1

2. Check whether assignment xj (the j-th bit m) satisfies clause Ci .
3. Remember whether Ci satisfied assignment xl , l j.
4. j < n Ci satisfied, propagate fact.
5. j < n, let vi(j+1) know (j + 1)-th bit message arrived.
first fourth function propagate information thus performed
state variables information lost. However, functions
performed different state variables. idea behind reduction C7n split vij
1 , performs second function, v 2 , performs third,
three variables: vij
ij
3
vij , performs fifth.
700

fiChain Causal Graphs Domains Size 5

(a)

(b)
a0

g0
b0

a0
bx

bx
a0,b0
gx

gx

g1

b0

ax

bx

ax
a1,b1

b1

bx

ax

a1

a0

ax

b0

bx

g0
a0,g0

ax

bx

gx

bx,gx
bx

gx
bx,gx

ax

b1

a1
a1

bx

a1,g1

g1
b1

2 (b) v 3 [1..k], j [1..n].
Figure 8: DTGs (a) vij
ij

before, message propagated using subscripts values domains
1 moves
state variables. j-th bit mj message arrives, state variable vij
1 moves
ax gx assignment (xj ) = mj satisfies Ci , bmj otherwise. vij
gx , forced move bmj next, forgetting Ci satisfied. However,
1 g , subsequent state variables C move g , propagating
value vij
x

x
2 able remember
fact Ci satisfied. Consequently, state variable vin
Ci satisfied remaining within subdomain {g0 , g1 , gx }.
1 moves b , causing v 2 v 3 move .
(xj ) = mj satisfy Ci , vij
mj
mj
ij
ij
1
3
2
1
there, vij , vij , vij move bx . next bit arrives, vij moves b0 (b1 ),
2 move (a ) v 3 b (b ). indicates v 1
causing vij
0
1
0
1
ij
i(j+1) (j + 1)-th
bit arrived, causing act accordingly. before, operators defined
1 always reacts first bit clause C .
vi1

A.2 Formal Proof
Since variables s1 , . . . , s2n1 , vs , , e1 , . . . , e2n1 before, Lemmas 4.2
4.6 apply P7 (F ). However, Lemma 4.3 violated since sometimes possible
change value variable twice without changing value predecessor (e.g.
using operators (1) (5)). Consequently, Lemma 4.8, states plans
solve P11 (F ) admissible, longer holds P7 (F ).
l ) variables middle
prove equivalent lemmas P7 (F ), redefine (vij
causal graph:
l , [1..k], j [1..n],
Definition A.1. Given partial plan variable vij
l ) number subscript changes v l execution .
l {1, 2, 3}, let (vij
ij
l , [1..k], j [1..n],
Lemma A.2. partial plan P7 (F ) vij
l ) (v ), v predecessor v l causal
l {1, 2, 3}, holds (vij
ij
graph.
l . operator
Proof. Follows immediately inspection operators vij
l
changes subscript vij z {0, 1, x} pre-condition v subscript z (or
1 predecessor v ). operators changing value
value z case v11

1 g pre-condition v subscript (or value) different x,
vij
x
1 since pre-condition v 1 .
operators change subscript vij
x
ij

701

fiGimenez & Jonsson

3 ).
Lemma A.3. partial plan P7 (F ), (ve ) (vkn
3 ) denotes
Proof. Note (ve ) still denotes number value changes , (vkn
3 . time change value v need
number subscript changes vkn
e
3
change subscript vkn between. addition, first value change requires
3 different initial state. Thus, (v ) (v 3 ).
subscript vkn
e
kn

Definition A.4. admissible plan planning problem P7 (F ) partial plan
1 ) = . . . = (v 3 ) = (v ) = 2n, (e ) = 2n i,
(si ) = i, (vs ) = (v11
e

kn
[1..2n 1].
Lemma A.5. plan solves planning problem P7 (F ) admissible.
1 ) (v 3 ) (v ).
Proof. Lemmas A.2 A.3 (vs ) (v11
e
kn
use Lemmas 4.2 4.6 apply reasoning proof Lemma
4.8.
l exactly 2n
words, admissible plan change subscript vij
l extra time moving g . However,
times, although change value vij
x
l ), cannot prove equivalent Lemma 4.10
even new definition (vij
l , l {1, 2}, choose follow predecessor g without
P7 (F ), since variable vij
x
making plan inadmissible. Consequently, sequences values Qti () admissible
plan longer completely determined induced message . Nevertheless,
still prove lemma similar Lemma 4.13.

Definition A.6. Let admissible plan. clause Ci [1..2n + 1],
let sequence values Qti () vector 3n elements representing, variable
l , j [1..n] l {1, 2, 3}, first value following (t 1)-th subscript change
vij
l execution .
vij
Lemma A.7. Let assignment variables x1 , . . . , xn formula F .
1) Existence. exists admissible plan planning problem P7 (F ) induced
assignment = .
2) Claim. Let Qti sequences values described Part 3) lemma.
satisfies F , exists admissible plan = Qti () = Qti ,
[1..2n+1] [1..k]. satisfy clause Ci , admissible
plans = Qti () = Qti , [1..2k + 1].
3) Sequence values. sequence values Qti , [1..k] [1..2n + 1],
follows.
a) j < Ti ,
j1

Qi2j1
Q2j

Q2j+1


nj
}|
{
z
z
}|
{
bx bx bx bx bx bx
ax ax ax
ax ax ax ax ax ax
=
= bm bm bm bm bm
=
bx bx bx bx bx bx
bx bx bx
ax ax ax ax ax ax

702

fiChain Causal Graphs Domains Size 5

b) j = Ti ,
j1

Qi2j1
Q2j

2j+1
Qi

nj
z
}|
{
z
}|
{
=
bx bx bx bx bx bx
ax ax ax
ax ax ax ax ax ax
= bm bm bm bm bm gm bm bm gm bm bm gm bm
=
bx bx bx bx bx bx
bx gx bx
bx gx bx bx gx bx

c) j > Ti ,
jTi

Ti 1

Qi2j1
Q2j

2j+1
Qi

nj

z
z
}|
{
}|
{
}|
{
z
bx gx bx bx gx bx bx gx bx bx gx bx bx gx bx
= bx bx bx bx bx bx
= bm bm bm bm bm gm bm bm gm bm bm gm bm bm gm bm bm gm bm
= bx bx bx bx bx bx
bx gx bx bx gx bx bx gx bx bx gx bx bx gx bx

Proof. Note similarity lemma Lemma 4.13. before, must show
operators, time Tables 7 8, whose post-conditions equal values
2j+1
given Qi2j1 , Q2j
. Again, must check consistency statements
Qi
2j +1
2j1

j = j 1. implies, Lemma 4.13, statements
Qi
Qi
Qi2j1 valid, due initial state ax ax induction j.
2j+1
remains show statements Q2j
valid.
Qi
proof divided six parts Lemma 4.13. Note that,
contrast lemma, aim show that, satisfies F , exists
admissible plan given Qti , admissible plans form.
sometimes execution plan one operator could chosen,
resulting plan would still admissible. tables follow, alike
proof Lemma 4.13, indicate operator choice leads
desired Qti , use boldface remark operators forced. add
extra row tables indicate sometimes need apply two operators
variable changing subscript. disparities respect Lemma 4.13
occur parts II IV proof, require Ti n, is, satisfying clause
Ci , fixed i. Thus, satisfy clause Ci , admissible plans
sequences values Qti [1..2n + 1].
I) 1 = j < Ti .
1 v2 v3
1 v 2 v 3 |k [2..n]
vi1
vik
i1 i1
ik ik
2j 1 ax ax ax
ax ax ax
2j
bm (2, 4; 18; 25) (13; 18; 25)
ax ax ax (16; 22; 29)
2j + 1 bx bx bx (7; 23; 30)

II) 1 = j = Ti .
1 v2 v3
1 v 2 v 3 |k [2..n]
vi1
vik
i1 i1
ik ik
2j 1 ax ax ax
ax ax ax
gx gx gx (1, 3; 19; 26)
gx gx gx (12; 19; 26)
2j
bm gm bm (5; 20; 27)
bm gm bm (14; 20; 27)
bx gx bx (7; 24; 31)
bx gx bx (17; 24; 31)
2j + 1

703

fiGimenez & Jonsson

III) 1 < j < Ti .
1 v 2 v 3 |k [1..j 1] v 1 v 2 v 3
1 v 2 v 3 |k [j + 1..n]
vik
vik
ij ij ij
ik ik
ik ik
2j 1
b x bx bx
ax ax ax
ax ax ax
2j
bm bm (6, 15; 21; 28) bm (9, 11; 18; 25) (13; 18; 25)
bx bx bx (7, 17; 23; 31)
bx bx bx (17; 23; 30)
ax ax ax (16; 22; 29)
2j + 1

IV) 1 < j = Ti .
1 v 2 v 3 |k [1..j 1] v 1 v 2 v 3
1 v 2 v 3 |k [j + 1..n]
vik
vik
ij ij ij
ik ik
ik ik
2j 1
b x bx bx
ax ax ax
ax ax ax
bm bm (6, 15; 21; 28) gx gx gx (8, 10; 19; 26)
gx gx gx (12; 19; 26)
2j
bm bm
bm gm bm (14; 20; 27)
bm gm bm (14; 20; 27)
2j + 1
bx bx bx (7, 17; 23; 31)
bx gx bx (17; 24; 31)
bx gx bx (17; 24; 31)

V) 1 = Ti < j.
1 v 2 v 3 |k [2..n]
1 v2 v3
vik
vi1
i1 i1
ik ik
2j 1
bx gx bx
bx gx bx
2j
bm gm bm (6; 20; 28) bm gm bm (15; 20; 28)
2j + 1
bx gx bx (7; 24; 31)
bx gx bx (17; 24; 31)

VI) 1 < Ti < j.
1 v 2 v 3 |k [1..T 1] v 1 v 2 v 3 |k [T ..n]
vik


ik ik
ik ik ik
2j 1
bx bx bx
bx gx bx
2j
bm bm (6, 15; 21; 28)
bm gm bm (15; 20; 28)
2j + 1
bx bx bx (7, 17; 23; 31)
bx gx bx (17; 24; 31)

Theorem A.8. exists plan solves planning problem P7 (F )
exists assignment satisfies CNF formula F .
Proof. : Given assignment satisfies F , construct admissible plan whose
induced formula assignment equals , choosing sequence values vs accordingly. follows clause Ci , Ti n, since exists variable xj
(xj ) = mj satisfies Ci . Since n Ti , exists admissible plan Qi2n+1
form indicated Case (b) (c) Lemma A.7. either case, (2n + 1)-th
2 g , required goal state. plan thus solves P (F ).
value variable vin
x
7
: Let plan solves planning problem P7 (F ). Lemma A.5 plan
admissible. show contradiction = satisfies F . Assume not.
exists clause Ci satisfied . Thus, Lemma A.7 applies sequence
2 following execution
values Q2n+1
. particular, means value vin

bx according Case (a) lemma. contradicts solving P7 (F ), since bx
2 )=g .
different goal state goal(vin
x
Proposition A.9. Plan existence C7n NP-hard.
704

fiChain Causal Graphs Domains Size 5

Proof. largest variable domains planning problem P7 (F ) variables
1 , . . . , v 3 , contain 7 values. proof follows immediately NP-hardness
v11
kn
Cnf-Sat, Theorem A.8, fact produce planning problem P7 (F )
polynomial time given CNF formula F .

References
Brafman, R., & Domshlak, C. (2003). Structure Complexity Planning Unary
Operators. Journal Artificial Intelligence Research, 18, 315349.
Brafman, R., & Domshlak, C. (2006). Factored Planning: How, When, Not.
Proceedings 21st National Conference Artificial Intelligence, pp. 809814.
Bylander, T. (1994). computational complexity propositional STRIPS planning.
Artificial Intelligence, 69, 165204.
Chapman, D. (1987). Planning conjunctive goals. Artificial Intelligence, 32(3), 333377.
Chen, H., & Gimenez, O. (2008). Causal Graphs Structurally Restricted Planning.
Proceedings 18th International Conference Automated Planning Scheduling, pp. 3643.
Domshlak, C., & Dinitz, Y. (2001). Multi-Agent Off-line Coordination: Structure Complexity. Proceedings 6th European Conference Planning, pp. 277288.
Erol, K., Nau, D., & Subrahmanian, V. (1995). Complexity, Decidability Undecidability
Results Domain-Independent Planning. Artificial Intelligence, 76(1-2), 7588.
Gimenez, O., & Jonsson, A. (2008a). Complexity Planning Problems Simple
Causal Graphs. Journal Artificial Intelligence Research, 31, 319351.
Gimenez, O., & Jonsson, A. (2008b). Search Tractability Boundary Planning
Problems. Proceedings 18th International Conference Automated Planning
Scheduling, pp. 99106.
Helmert, M. (2006). Fast Downward Planning System. Journal Artificial Intelligence
Research, 26, 191246.
Jonsson, A. (2007). Role Macros Tractable Planning Causal Graphs.
Proceedings 20th International Joint Conference Artificial Intelligence, pp.
19361941.
Jonsson, P., & Backstrom, C. (1998). Tractable plan existence imply tractable
plan generation. Annals Mathematics Artificial Intelligence, 22(34), 281296.
Katz, M., & Domshlak, C. (2008a). New Islands Tractability Cost-Optimal Planning.
Journal Artificial Intelligence Research, 32, 203288.
Katz, M., & Domshlak, C. (2008b). Structural Patterns Heuristics via Fork Decompositions. Proceedings 18th International Conference Automated Planning
Scheduling, pp. 182189.
Knoblock, C. (1994). Automatically generating abstractions planning. Artificial Intelligence, 68(2), 243302.
705

fiGimenez & Jonsson

Williams, B., & Nayak, P. (1997). reactive planner model-based executive.
Proceedings 15th International Joint Conference Artificial Intelligence, pp.
11781185.

706


