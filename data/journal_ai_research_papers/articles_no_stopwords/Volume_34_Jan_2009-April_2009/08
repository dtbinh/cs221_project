journal artificial intelligence

submitted published

chain causal graphs variables
domains size np hard
omer gimenez

omer gimenez upc edu

dept de llenguatges sistemes informatics
universitat politecnica de catalunya
jordi girona
barcelona spain

anders jonsson

anders jonsson upf edu

dept information communication technologies
universitat pompeu fabra
roc boronat
barcelona spain

abstract
recently considerable focus given determining boundary
tractable intractable study complexity class cn characterized unary operators
directed path causal graphs although one simplest forms causal graphs
intractable cn unless p np
even domains state variables bounded size particular plan
existence ckn np hard k reduction cnf sat k denotes
upper bound size state variable domains reduces complexity
gap class ckn cases k k since c n known tractable

introduction
ongoing effort community determine complexity different classes known tractable classes usually characterized
simple causal graph structure accompanied additional restrictions variables
operators however boundary tractable intractable
still clearly established present contributes novel complexity
class simple causal graph structure literature
effort reduce complexity gap
determining tractable classes purely theoretical interest instance complex projected onto tractable
fragments generate heuristics used search katz
domshlak b causal graph heuristic helmert exploits hierarchical structure transforming tractable form first
translates propositional variables multi valued variables process simplifies
causal graph keeps relaxing causal graph
becomes acyclic
present aims study complexity class cn
defined domshlak dinitz class cn contains
c

ai access foundation rights reserved

figimenez jonsson

ckn
k
k
k

plan generation
p
exp
exp

macro plan generation
p

intractable

plan existence
p

np hard

table overview complexity class ckn

multi valued variables chain causal graphs e causal graph directed path
implying operators unary notation n indicates number state
variables unbounded particular study complexity plan existence cn
e determining whether exists plan solves cn
even though cn exhibit extremely basic form causal structure e linear dependence state variables solving cn
necessarily tractable even impose additional restrictions let ckn subclass
cn state variables domains size k known class c n
polynomial time solvable brafman domshlak plan existence class
cn np hard gimenez jonsson aim study complexity plan
existence classes namely ckn k
domshlak dinitz showed solvable instances c n require
exponentially long plans means polynomial time plan generation
ckn k case c n however rule
existence polynomial time determines plan existence class ckn
even generates plans succinct form jonsson
gimenez jonsson incompatible cn np hard
prove plan existence class ckn np hard k
words even causal graph directed path domains state
variables restricted contain values deciding whether plan
exists solving corresponding np hard implies
sufficient exhibit linear variable dependence restricted
variable domain sizes additional restrictions necessary make tractable
table shows overview complexity class ckn date
macro plan generation mean generating compact representation
solution work jonsson gimenez jonsson
intractable column means complexity yet unknown
cannot p unless p np else plan existence would p row k due
brafman domshlak column plan generation due domshlak
dinitz contributions present marked boldface note
novel subsumes gimenez jonsson showed np hardness
k n
organized follows section relate previous work
section introduce notation used throughout section give formal
proof reduction cnf sat c
n main

reduction cnf sat cn proved section although

c n subsumes c
n believe intuitive idea behind cn


fichain causal graphs domains size

reduction easier understand may interest anyone trying prove hardness
similar circumstances section discuss complexity remaining
classes c n c n
prove correctness third reduction time cnf sat c n

appendix reductions c
n cn previously appeared conference
gimenez jonsson b present provides formal proof correctness

related work
complexity studied extensively last twenty years bylander chapman erol nau subrahmanian many tractable classes
exploit notion causal graph one way another knoblock
usually credited introducing causal graph work hierarchical
williams nayak required acyclic causal
graphs effort ensure tractability jonsson backstrom defined class
acyclic causal graphs showed plan existence
tractable class
domshlak dinitz introduced class cn studied
well several related classes particular causal graph
structure brafman domshlak designed polynomial time solving binary state variables polytree causal graphs bounded
indegree proving tractable class c n brafman domshlak
presented complexity related tree width causal graph katz
domshlak used causal graph structure prove several complexity
optimal
jonsson gimenez jonsson designed polynomial time
solve restricted causal graphs generating hierarchy
macros recently chen gimenez showed complexity
intractable unless size largest connected component causal graph bounded
constant consequently causal graph structure alone enough guarantee
tractability implying additional restrictions needed

notation
throughout use n denote set n
let v set state variables let v finite domain state variable
v v define state function v maps state variable v v
value v v domain partial state p function subset vp v
state variables maps state variable v vp p v v frequently use
notation v x vk xk denote partial state p defined vp v vk
p vi xi vi vp
tuple p hv init goal ai v set variables init
initial state goal partial goal state set operators operator
hpre post consists partial state pre called pre condition


figimenez jonsson

v

v

v

v

v

figure example causal graph class ck
partial state post called post condition operator applicable state
v pre v v vpre applying operator state
state v post v v vpost v v otherwise
partial plan p sequence operators ak ak
k applicable initial state init k ai
applicable following application ai starting init note partial plan
necessarily solve p plan solving p partial plan goal
state goal satisfied following application ak p solvable
exists plan
causal graph p directed graph v e state
variables nodes edge u v e u v exists
operator u vpre vpost v vpost figure shows example
causal graph form directed path structure causal graph implies
operator unary e post condition specified single variable
v pre condition specified v predecessor v causal
graph
study class ckn defined follows
definition p belongs class ckn causal
graph p directed path v v v k
ckn domain transition graph dtg state variable
v labelled directed graph v e values domain v nodes
edge x e label l v exists operator
hv l v x v yi v predecessor v causal graph edge
without label indicates pre condition corresponding operator defined v
alone edge one label indicates existence multiple operators
pre post condition v different pre conditions v

c
n np hard
section prove c
n np hard reduction cnf sat words
every cnf formula f associate instance p f c
n p f
solvable f satisfiable first describe p f
explain intuitive idea behind reduction finally provide formal proof
correctness
let f c ck cnf formula k clauses n variables x xn
define p f v init goal follows variable set v
si n vs vij k j n ei n
domains si ei n vs x
vij gx g g ax b b cx c c k j n initial state
defined init si init ei init n init vs x init vij ax


fichain causal graphs domains size



n

vs

v n

v

vk

vkn



e

e n

figure causal graph p f
















x








figure dtgs variables n vs
k j n goal state partial state defined goal vin gx
k goal goal ei mod n
providing formal definition operators give intuitive overview
p f present causal graph p f well
dtgs state variable reader interested formal proof
correctness reduction may skip section introduce formal
definitions operators order prove several theoretical properties p f
intuition
p f associated cnf formula f consists three parts
clearly defined role three parts illustrated figure showing causal
graph p f first part p f corresponds state variables n vs
second part corresponds state variables v v n vk vkn third
part corresponds state variables e e n role first part generate
message corresponding assignment variables cnf formula f
role second part verify whether assignment satisfies clause ci
remember fact value state variable vin finally role third part
make sure message propagated way end chain
dtgs state variables n vs appear figure state variables
used generate assignment variables x xn cnf formula f
operators p f defined way value vs change
x change back x thus applying
operators p f possible generate sequence x x x mn x values
vs mj j n
define message sequence mn n symbols corresponding sequence values vs follows refer symbols
bits message value x used separator distinguish consecutive
bits message given message assignment defined xj mj
j n thus assignment x determined first choice whether
change value vs x purpose remaining state
variables si first part restrict message contain n bits


figimenez jonsson



b


g



g

c

b

c

b
b g





x


gx


ax



x
cx

x

gx
b g



x

ax cx gx

b g

x

ax cx gx

ax
ax cx gx

b g

ax cx gx

b g

ax cx gx

cx

x
b g

g



c

b

g



b

ax cx gx
c

c


g
b
c g

cx gx g

gx

c g

cx gx g

ax

b
g

c

b
ax cx

c

c

cx

c

cx

ax cx


cx

cx

c
b

cx
c

figure dtgs v b vi c vij j dashed edges
explained text

dtgs state variables vij k j n appear figure
dashed edges dtgs indicate corresponding operators depend cnf
formula f example assignment x satisfies clause c edge
v ax label figure points g else points b likewise x
satisfies c edge v ax label points g else points b
recall role second part check whether assignment generated
first part satisfies cnf formula f clause ci variable xj
f main function state variable vij check whether assignment xj mj
satisfies ci state variable vij acts finite state automaton propagates
bit message keeping track j th bit message arrives
since domain size state variables restricted way vij count
number bits received instead fact j th bit arrived indicated
vi j moreover last state variable vin clause ci remember
whether ci satisfied assignment variable xj
summary state variable vij second part performs following functions
values operators
propagate message generated vs
check whether assignment xj j th bit satisfies clause ci


fichain causal graphs domains size





b b
g g

ax
cx
gx












figure domain transition graph variables e e n
remember whether ci satisfied assignment xl l j
j n ci satisfied propagate fact
j n let vi j know j th bit message arrived
note third function strictly necessary j n however including
state variables makes reduction compact symmetry
next briefly describe vij implements functions value
domain vij subscript x propagate message vij moves
value whose subscript matches predecessor case v subscript
match value vs unless ci satisfied assignment xl l j
value vij remains subdomain ax prior arrival j th bit
clause ci encoded dashed edges dtgs variables vij
operators j th bit mj arrives vij moves ax gmj
assignment xj mj satisfies ci bmj otherwise fact value vij
subdomain g g gx indicates ci satisfied assignment
xl l j fact propagated way vin since subsequent state variable
ci forced move value subdomain g g gx whenever value
predecessor g g gx whether clause ci satisfied checked
defining goal state vin gx
finally j n vij moves bmj vi j moves amj vij
choice move cx causing vi j return ax next bit arrives vij
moves c c correctly indicating vi j j th bit arrived
consequently vi j moves g g b b depending whether
assignment xj satisfies ci hence values type b used delay transition
vi j value type b g mechanism allows
variable vij react j th bit clause ci operators vi defined
vi reacts first bit
dtgs state variables e e n appear figure function
state variables make sure n bits message propagated end
causal graph state variable strictly speaking planner solving
never forced select operator choose propagate bit
message instead wait next bit arrive acting turn may cause
another state variable incorrectly conclude clause satisfied
variables third part prevent happening since goal state defined
way cannot reached unless bits message arrive end
causal graph


figimenez jonsson

variable

si
n
vs

operator
hs
hsi si si
hsi si si
hs n vs x vs mi
hs n vs vs xi

qualifier




table operators variables n vs

formal proof
section prove c
n np hard showing p f
solvable formula f satisfying assignment start provide
formal definitions operators p f operators n vs appear
table corresponding dtgs appear figure operators variables vij
k j n appear table dtgs appear figure finally
operators e e n appear table dtgs appear figure
reduce space requirement use shorthand definitions operators
words hv v c v mi b denotes existence two operators
hv v c v ai hv b v c v bi similarly hv b v c v di denotes
existence two operators hv v c v di hv b v c v di state
variables vij introduce reference numbers allow us easily refer operators
furthermore operators conditional properties cnf formula f
operator exists indicated property satisfied example operator
hv c v ax v g exists clause c satisfied x operator
hv c v ax v b exists c satisfied x use set notation
xj ci denote literal xj appears clause ci
proof organized follows begin series technical definitions
lemmas related operators implications definition introduces notion admissible plans lemma states plan solving p f
admissible next lemma establishes admissible plan corresponds
assignment variables cnf formula f operator choices
plan forced given assignment finally lemma determines exact sequence
values taken state variable execution admissible plan making
possible check whether goal state reached end execution theorem
concludes admissible plans solving p f corresponding
satisfying assignments f
definition given partial plan p f variable v v v number
times value v changed operators
lemma partial plan p f holds
si n
vs n


fichain causal graphs domains size

variable
v

vi
k

vij
k
j n

ref































operator
hvs v ax v g
hvs v ax v b
hvs v ax v g
hvs v ax v b
hvs v cx v cm
hvs v gx v gm
hvs x v bm v cx
hvs x v cm v cx
hvs x v gm v gx
hv n b g vi ax vi g
hv n b g vi ax vi b
hv n b g vi ax vi g
hv n b g vi ax vi b
hv n bm gm vi cx vi cm
hv n bm gm vi gx vi gm
hv n ax cx gx vi bm vi cx
hv n ax cx gx vi cm vi cx
hv n ax cx gx vi gm vi gx
hvi j c vij ax vij g
hvi j c vij ax vij b
hvi j c vij ax vij g
hvi j c vij ax vij b
hvi j bm vij ax vij
hvi j gm vij ax vij gm
hvi j cm vij cx vij cm
hvi j cm gm vij gx vij gm
hvi j ax cx vij vij ax
hvi j cx vij bm vij cx
hvi j cx vij cm vij cx
hvi j cx gx vij gm vij gx

qualifier
x c
x
c
x c
x
c





x ci
x
ci
x ci
x
ci





xj ci
xj
ci
xj ci
xj
ci









table operators variables v vkn

variable


hvkn

e
ei n

operator
b b g g
hvkn ax cx gx
hve e
hve e
hei ei
hei ei



e
e
ei
ei

table operators variables e e n



figimenez jonsson

proof induction variable change
n follows inspection operators cannot change value
si twice without changing value si operator setting si
si pre condition operator resetting si si
pre condition since change value si initial state without
first changing value si follows si si
induction argument holds variable vs predecessor n vs
n n n
lemma partial plan p f vij k j n
holds vij v v predecessor vij causal graph
proof follows inspection operators cannot change
value vij twice without changing value v see note
subscript value vij x operator vij changes
value one subscript x one subscript v value
subscript one subscript one subscript x v value
subscript x argument holds v although values predecessor
vs x without subscripts
note value vij cannot change initial state without first changing
value v since v value subscript value vij change
initial value ax consequently value vij cannot change times
value v vij v claimed
lemma vij k j n partial state v x vij
v predecessor vij causal graph one applicable operator
changing value vij
proof inspecting operators easy see pair operators vij
different pre conditions exception rule operators exist
simultaneously due properties cnf formula f e g operators
lemma partial plan p f holds
vkn
e
ei ei n
proof let v variable among e e n let v predecessor causal
graph cannot change value v twice without changing value v
v e e n operator setting v requires v
operator resetting v requires v v operator setting v requires
v value subscript operator resetting v requires v
value subscript x note case cannot change value v
initial state without first changing value v thus v v
variables claimed


fichain causal graphs domains size

turn finding plan solves p f
lemma let plan solves p f
ei n n
n
proof descending induction n goal e n value
e n change least initial value init e n implying e n
n n n assume ei n holds
induction lemma follows ei ei n however
since goal ei goal ei since solves p f follows ei ei
hence ei ei follows ei n claimed
argument applies e predecessor since goal goal e yielding
n
definition admissible plan p f partial plan
si vs v vkn n ei n
n
lemma plan solves p f admissible
proof lemmas vs v vkn
lemmas values equal n since n vs n
proof lemma si si n
vs n together lemma vs n implies si
n proof lemma e ei ei
n e n together lemma n implies
ei n n
please note converse lemma true admissible plans
solve p f
consequence lemma plan solves p f need
consider admissible plans particular admissible plan changes value variable vs
exactly n times generating sequence n values note value vs
changes x back x
definition let admissible plan let x x x mn x sequence
n values variable vs takes execution mj
j n use denote message mn induced use
denote formula assignment xj mj j n
turns operators part admissible plan completely
determined message induced
lemma let admissible plan p f let induced message
operators changing value variable vij k j n well
sequence values variable vij takes execution completely
determined


figimenez jonsson

proof v v vkn let v causal graph predecessor proof
lemma know cannot change value v twice without changing value
v initial state change value v
change value v definition admissible know v v n
way admissible plan change value v n times without changing
value v n times first change value v v v
lemma know given partial state v x v
one applicable operator changing value v thus time admissible
plan changes value v value v one operator
plan choice select operator since allowed change value
v changing value v consequently sequence values taken
v completely determined operators v well sequence values
takes completely determined proof follows double induction
j since sequence values taken vs predecessor v completely
determined message
follows lemma relevant degree freedom admissible
plan selecting elements message repeatedly deciding whether move
vs vs vs x selected operator choices
forced else plan admissible particular message unique
state executing admissible plan starting init remains
determine whether unique state matches goal state
remark note lemma mention operator order admissible plan
indeed change order operators admissible plan without making
plan inadmissible example let v v v three consecutive variables
causal graph let ha subsequence operators changing
values aji j th operator changing value vi subsequence

ha achieves long partial order haji aji aj

respected j change operator order please
proceed determine sequence values variable vij k j
n takes execution admissible plan induced message
first define satisficing index clauses sequence values plan
definition let admissible plan induced message
clause ci let satisficing index ti n smallest number xti
mti satisfies ci number exists ti n
definition let admissible plan clause ci n
let sequence values qti vector n values representing variable
vij j n th value taken vij execution
following lemma key understanding idea behind reduction c
n since
specifies sequences values admissible plan induces execution
lemma let assignment variables x xn formula f


fichain causal graphs domains size

existence exists admissible plan p f induced assignment
claim let qti sequences values described part lemma
admissible plans sequences values qti qti
k n
sequence values sequence values qti k n
follows
j ti
nj

j

z
c x cx
qi j
j
qi cmj cmj
j

c x cx
qi

ax
bmj
cx

z
ax ax
amj amj
ax ax

ax
gmj
gx

z
ax ax
gmj gmj
gx gx

b j ti
nj

j

qi j
q j

q j


z
c x cx

cmj cmj

c x cx

c j ti
jti

nj

z
gx gx
gmj gmj
gx gx

z
gx gx
gmj gmj
gx gx

ti

qi j
q j

q j


z

c x cx
cmj cmj

c x cx

gx
gmj
gx

proof proving lemma must check definition qti given part
consistent necessary due overlapping statements namely every
odd n sequence qti defined twice qi j j

another time qi j j however sequences values well defined

definitions qi j q j
match combination j j j

shown following table


j

qi j qi j

case

z z
cx cx ax ax

case b

z z
cx cx ax ax

case c

z z
cx cx gx gx

case c

z z
cx cx gx gx

j

j

j ti

case

j

j ti

case

ti

j ti n

case b

ti

ti j n

case c



nj

nj

nti
nti

figimenez jonsson

prove parts lemma assume admissible plan induced
assignment proof proceeds double induction j particular
j
prove validity three statements type qi j q j
assuming
qi




statements type qi statements type qi j q j


qi j j j already hold first prove validity qi j j
qi j q ax ax cases b corresponds initial state vi vin
note case c cannot hold j j know since statements

consistent qi j qi j j j hence correctness qi j follows
induction j
j
next prove statements relative q j
consider variable v
qi
precedes vi causal graph values number j j j takes
execution v vs values x mj x
v v n induction values ax amj ax j ti j n
ax bmj cx j n ti ax gmj gx j ti gx gmj gx j ti
proof divided parts depending values j ti
j ti consider following table write instead mj
simplify notation
v
vi
j
x ax gx
ax
bm gm
j
j x ax cx gx


vi
ax








vin
ax



three rows table correspond values number j j j
variables v vi vin first column corresponds possible values
predecessor v vi take first row given qi j second
j
third rows filled correspond q j

qi
let j operator causing j th value vi according previous
table pre condition j must compatible
hv bm gm vi ax
values variables v vi j applied since ti x
satisfy clause ci operator j must one labelled
table one operators applicable depending value
whether v vs v n case application j causes
value vi become bm fill blank previous table
v
vi
vi
j
x ax gx
ax
ax
j
bm gm bm
j x ax cx gx








vin
ax



way check j operator causing j th value
vi must one labelled table value vi cx


fichain causal graphs domains size

remaining variables easy check variables vi vin become due
operators type become ax due operators type
table complete
v
vi
vi vin
j
x ax gx
ax
ax ax
j
bm gm bm
j x ax cx gx
cx
ax ax
shows case lemma holds j ti
ii j ti proof similar case since ti x
satisfies clause ci admissible operators causing j th value
vi labelled case value vi becomes gm
consequently admissible operators vi vin different
resulting table
v
vi
vi vin
j
x ax gx
ax
ax ax
j
bm gm gm gm gm
j x ax cx gx
gx
gx gx
iii j ti case remaining ones resulting table
write mj follows omit column v since possible
values
vi
vi vi j
vij
vi j vin
j cx
c x cx
ax
ax ax
cm
cm cm bm

j
j cx
cx cx cx
ax ax
iv j ti
vi
vi vi j
vij
vi j vin
j cx
c x cx
ax
ax ax
cm
cm cm gm
gm gm
j
j cx
cx cx gx
gx gx
v ti j
vi
vi vin
j gx
gx gx
j
gm gm gm
j gx gx gx
vi ti j
vi
vi vi ti
viti vin
j cx
c x cx
gx gx
j
cm
cm cm gm gm
cx cx gx gx
j cx


figimenez jonsson

remains check case lemma follows parts iii
case b parts ii iv case c parts v vi proves part
lemma
finally note existence admissible plan directly follows previous
discussion since specified operators used every situation
assumed existence proves part lemma
theorem exists plan solves p f
exists assignment satisfies cnf formula f
proof given assignment satisfies f construct admissible plan whose
induced formula assignment equals choosing sequence values vs accordingly follows ti n clause ci since exists variable xj
xj mj satisfies ci q n
form indicated case b c lemma

case n th value variable vin gx required goal state
plan thus solves p f
let plan solves p f lemma plan
admissible contradiction satisfies f assume
exists clause ci satisfied implying ti n since n ti n th
value variable vin cx according case lemma contradicts solving
p f since goal value vin cx gx
proposition plan existence c
n np hard
proof largest variable domains p f variables
v vkn contain values proof follows immediately well known
np hardness cnf sat theorem fact produce
p f polynomial time given cnf formula f
example
illustrate reduction small example cnf formula f x x one
clause two variables x x variable set corresponding
p f v vs v v e e e admissible plan induce
four different messages message corresponds
assignment satisfy f plan solves p f induced
message appears table note following execution plan goal state
goal v gx e e e satisfied desired last value change
variable appearing goal state marked boldface

c n np hard
section describe reduction cnf sat c n cnf formula f
associate p f clause ci variable xj f p f contains
domain v b v domain v
two state variables vij
x x
ij
ij
ij
v b b
ax b b values omitted vin
x



fichain causal graphs domains size



hs
hs
hs vs x vs
hvs v cx v c
hv c v ax v g
hv g
hve e e
hs
hs
hs
hs vs vs xi
hvs x v c v cx
hv cx v g v gx
hv gx

hs vs x vs
hvs v ax v b
hv b v ax v
hv
hve e e
e e
e e
hs
hs vs vs xi
hvs x v b v cx
hv cx v v ax
hv ax
hve e e
e e



table plan solves p f example formula f


b

c












x



b

x

ax

bx

ax

x

x

b

ax

ax b

ax

ax b

bx
ax

ax




ax

ax



ax bx

ax

ax




b


ax


bx

ax

e
b
ax bx



ax


ax bx
b

ax bx


b

b v c v j v j n e v
figure dtgs v

ij
ij


state variables n vs e e n well domains corresponding

operators except predecessor vkn
init v k
initial state state variables init vij
x
ij

j n goal state goal vi ax k table lists operators
v k j n figure shows corresponding dtgs
variables vij
ij
table lists operators variable different pre conditions

predecessor vkn
intuition
reduction c n following idea instead explicit value
remember clause satisfied goal remain initial value ax
way able reduce size variable domains needed reduction
somewhat surprisingly reduction uses fewer total operators c
n


figimenez jonsson

variable

v


vi
k

vij
k
j n

vij
k
j n


vin
k



ref























operator
v
hvs v
x

v
hvs x v

x
v b
hvs x v

x
v

bm vi
hv n
x


v
hv n
ax vi
x


v b
hv n
ax vi

x
v

vij
hvi j

x ij

v
hvi j
ax vij
ij
x
b v

bm vij
hvi j

x ij



hvi j ax vij vij bx
v v
hvij

x ij
ij
v v
hvij
x
x ij
ij



hvij vij ax vij bm
v b v
hvij
x
x ij
ij
b v b v
hvij
x ij
ij
x
v b v
hvij
x ij
ij
x
b v b v
hvij
x ij
ij
x
v v b
hvin

x

v b v
hvin
x

x
b v b v
hvin
x

x
v b v
hvin
x
x

b v b v
hvin
x

x
b v v
hvkn
e
e
v v
hvkn
x e
e

qualifier













xnj ci
xnj
ci
xnj ci
xnj
ci

x ci
x
ci
x ci
x
ci


v v k j n
table operators variables vij
e
ij



fichain causal graphs domains size

reduction c n uses another idea reduction c
n information
propagated forward e variable vij changed value according value
predecessor vi j reduction c n however constructed information propagated forward particular bits message information
propagated backwards index bit currently checking
arranged variable v may several applicable operators
one satisfies pre condition applicable action successor v
value v time depends value v time
explain p f bit detail due backward
propagation mechanism bits message checked reverse order
words vin checks first bit vi n checks second bit vi checks n th
check whether n j th bit satisfies clause c
bit purpose vij

inform v
whereas purpose vij


n

j

th
bit

arrived
j
keeps track whether c satisfied first n j
implicitly vij

bits
assume without loss generality message let us see happens
corresponding assignment satisfy clause ci upon arrival first bit
move b requires v pre condition
state variable vin



l j n l next v
turn requires state variables vij


b turn requires state
move back ax requires pre condition vin
x
l j n l v moves b
variables vij
x
x


requiring vi n b pre condition
b following nj see long clause remains unsatisfied vij
x
b following last bit assume
th bit particular means vi
x
moves b requires v
n j th bit satisfies clause ci vij

x
ij

move ax instead bx way vi j
bx following
following last bit satisfying goal
n j th bit particular vi
x
state
formal proof
proof c n organized much way c
n note variables
n vs e e n lemmas still apply
p f easy check lemmas hold p f however
lemma longer holds since several operators share preconditions namely
operators spite
operators sequences values admissible plan completely determined
induced message p f shown lemma
lemma let admissible plan p f let induced message
l k j n l
operators changing value variable vij
l takes execution
well sequence values variable vij
completely determined
assume without loss generality value
proof first consider variable v

namely changing value
given vs x two applicable operators v



figimenez jonsson

ax changing value bx first sight admissible plan choose
pair
however admissible change value v
note v v two values namely
value changes v



admissible operator v
b value v


thus changes value v b longer admissible
pre condition v
x
x

b correct choice depends
choose operator value v


cnf formula f xn satisfies clause c admissible operator v
choose operator otherwise admissible
pre condition v
x

b choose operator
operator v pre condition v
x


case operator choice v forced given value v
k v k j k
reasoning applies variables vi
ij
k j n corresponding operators share
vij
pre conditions degree freedom admissible plan selecting induced
message choosing operators vs accordingly remaining operator choices
consequently sequences values completely determined induced message

prove lemma similar lemma establishing sequence values taken
state variables p f execution admissible plan
definition let admissible plan p f clause ci
n let sequence values qti vector n elements representing
l j n l th value taken variable v l
variable vij
ij
l define diagonal value
execution let us denote value qt vij

qji k j n value q j vi nj

lemma let assignment variables x xn formula f
existence exists admissible plan p f induced
assignment
claim let qji described part lemma admissible plans
diagonal values qji qji k j n
diagonal values diagonal values qji k j n
follows
j ti qji bx
b j ti qji ax
proof note according lemma diagonal values qji
full sequences values qti completely determined admissible plan
prove admissible plans exist assignment claimed part
diagonal values match expression given part prove two facts
careful general analysis p f explaining
analysis implies lemma incidentally sequences values qti


fichain causal graphs domains size

obtained analysis study important
purposes
l variable p f clearly
let admissible plan let v vij


subscript th value q v v takes depends parity since
operators affecting v change subscript x back x
namely subscript qt v x p p p th
bit message

j n k consider th values variables vij
v
vij
j take p p p previous observation subscripts
implies trivially know something values
qt v qt v
qt vij
ij
j
p ax bx
ax
ax bx
p

bm

p ax bx
ax
ax bx

affects values diagonal
study value q p vi j
p

p

p

vi j
ax check
vij q
namely q vij q
one possible outcome



rule

qt vi j
qt vij
qt vij
p ax bx
ax
ax
p





p
ax

ax

ax bx

value type ax propagated along diagonal another value ax
call propagation rule

bx
study possible outcomes q p vi j
p

p

case values q vij q
vij diagonal depend whether
p th bit message clause ci satisfied xnj c f
operators table ci satisfied xnj follows
values must bm ax propagation rule ii



rule ii
qt vij
qt vij
qt vi j

p ax bx
ax
bx

bm



p
p
ax

ax

ax bx

contrary clause ci satisfied values must bm bx
call propagation rule iii



rule iii qt vij
qt vi j

qt vij
p ax bx
ax
bx
p

bm



p
bx

ax

ax bx



figimenez jonsson

finally let us consider cases j j n treated
values type note
previous analysis note variables vin

cannot take value b time n cannot change
variables vi
x
since pre conditions operators k
b thus possible outcome two variables
compatible vi
x
p n following




qt v
qt vin
qt vin
p ax bx
ax
ax
p

bm



ax

ax

p ax bx

ax bx operators
note p n value q p v

reader check similar analysis applies variable v
operators take role operators
let us summarize previous analysis following table











vi
vi
vi

ax ax ax

ax




n
n ax
n

n





v


vin
vi n
vi n

ax
ax ax ax
bm
ax
bm





bm
ax
bm
ax

first row previous table contains initial state
variables set ax leftmost column rightmost column contain values
v values b right column propagated
taken variables vi


along diagonals three propagation rules already discussed value type
yields values type according rule value type b yields value type
clause satisfied rule ii type b satisfied rule iii
applies propagating values first row since type
values top left triangle type according rule note longest
diagonal coincides diagonal values qji definition
discussion proceed prove lemma let assignment formula
f existence plan implied analysis already done
l since shown operators used case produce
values qt vij
actual changes value

finally consider diagonal values qji j n values q vin


n

q vi n q
vi let j ti case first j bits
message assigned variables x xj satisfy clause ci consequently

j v
q q v
diagonal values q q vin

n j must
n qj q


fichain causal graphs domains size

bx according rule iii contrary assume j ti case b
follows qpi bx p ti due rule iii qpi ax p ti due rule ii
qpi ax j p ti due rule
theorem exists valid plan solving p f
exists assignment satisfies cnf formula f
proof lemma existence assignment satisfies f implies
admissible plans satisfy qji qji since ti n k follows
qni ax required goal state p f plan thus solves p f
let plan solving p f since lemma holds
p f plan admissible contradiction satisfies f
assume exists clause ci satisfied thus lemma implies
following execution b
qji bx j n particular value vi
x

contradicts solving p f since bx different goal state goal vi
x
proposition plan existence c n np hard
proof largest variable domains p f variables
k j n contain values proof follows immediately
vij
np hardness cnf sat theorem fact produce
p f polynomial time given cnf formula f

discussion
shown determining whether solution plan exists
class ckn np hard whenever k contrast brafman
domshlak developed polynomial time generating plans solve
class c n said intermediate cases namely
ckn k follows sketch arguments tractability
cases although discussion mostly intuition gained studying
classes might prove helpful someone trying determine complexity
one hand seems likely us plan existence c n np hard
reduction c n uses one type state variable whose domain larger namely
finding reduction c seems possible although likely difficult since
vij
n
available options become increasingly restricted state variable domains get smaller
particular tried failed reduction c n
domshlak dinitz showed exist c n
exponential length minimal solutions although often indicates class
difficult imply plan existence intractable exemplified
jonsson backstrom define class exponential
length minimal solutions plan existence could checked polynomial time
present authors gimenez jonsson showed even plan generation
particular class could done polynomial time resulting plans given
compact format macros
second argument favor hardness c n may multiple ways
transition two values variable example consider


figimenez jonsson

two actions changing value variable v namely
hv v v hv v v since variables values
possible neither v v hold current state planner would
thus choose whether satisfy v v contrast c n two
actions could replaced single action hv v since one
applicable consequence even minimal plan length bounded
c n may exponentially many plans length fact
main idea behind reductions
another observation regards number possible domain transition graphs
state variable k possible state variable ckn may

k k distinct domain transition graphs words number graphs grows
exponentially k particular state variables c n distinct
graphs number c n although large number possibilities
guarantee hardness clear expressive power c n much higher
c n
evidence provided suggests c n significantly harder c n however
sure c n hard enough intractable state variables three
values lend well type reduction presented since
propagating message requires three values reduction c n idea
underlying may message passing mechanism exploited
hand maybe way determine plan existence c n polynomial time
would take consideration multiple finite combinations domain
transition graphs three values well inherent structure graphs know
expressive power domain transition graphs values large handle
polynomial time maybe case values

acknowledgments
work partially funded apidis mec grant tin c

appendix c n np hard
appendix describe modify reduction c
n resulting
call p f needs variable domains size reduction previously appeared conference gimenez jonsson b without
proof main idea reduction construction used check
assignment satisfies clause ci involved previously used n variables vij j n whose role essentially check whether j th bit xj
propagated message satisfies ci modified reduction variable vij replaced
v v collectively play role variables
three variables vij
ij
ij
n vs e e n well domains corresponding operators

except predecessor vkn
v b b b g
domains variables vij
x x x
ij

vij gx g g ax bx k j n initial state
init v init v k j n goal
variables init vij
x
ij
ij


fichain causal graphs domains size

variable

v


vi
k


vij
k
j n

ref

























operator
v g
hvs v
x
x
v b
hvs v
x

v g
hvs v
x
x
v b
hvs v
x

g v b
hvs v
x

b v b
hvs v
x

b v b
hvs x v

x

v g
hv n
b vi
x
x
v b

b vi
hv n
x




hv n b vi ax vi gx

v b
hv n
b vi
x


g v b
hv n
bm vi
x


b v b
hv n
bm vi
x




hv n ax bx vi bm vi bx

v g
hvi j
b vij
x ij
x



hvi j b vij ax vij b

v g
hvi j
b vij
x ij
x
v b

b vij
hvi j
x ij


v g
hvi j
gx vij
x ij
x



hvi j vij ax vij

g v b
hvi j
bm vij

x ij

b v b
hvi j bm vij
x ij


v
hvi j
ax bx vij
x
ij
b v b

bx vij
hvi j
ij
x

qualifier
x c
x
c
x c
x
c



x ci
x
ci
x ci
x
ci



xj ci
xj
ci
xj ci
xj
ci






k j n
table operators variables vij

g k table shows operators variables v k
state goal vin
x
ij
v k
j n table shows operators variables vij
ij
j n figures shows corresponding domain transition graphs table
shows operators variable different pre conditions

predecessor vkn

intuition
intuition behind reduction c n largely c
n
p f corresponding cnf formula f consists three parts first
third identical p f thus difference lies second part recall
reduction c
n clause ci variable xj f
p f contains state variable vij performs following functions
propagate message generated vs


figimenez jonsson

variable

vij
k
j n

ref
















vij
k
j n



operator
b v v
hvij

x ij

ij
g v v g
hvij
x
x ij
x ij
b v g v g
hvij
ij
x ij

b v b v
hvij

x ij
ij
v v
hvij
x ij
ij
x
b v v b
hvij
x
ij
x ij
b v g v g
hvij
x ij
ij
x
v v
hvij
ij
x ij

g v v g
hvij
x
x ij
x ij
g v g v b
hvij
ij
x ij

g v b v b
hvij

x ij

ij
v v
hvij
x ij
ij
x



hvij bx vij vij bx
b g v b v b
hvij
x
x x
ij
ij

hvkn b b
b v v
hvkn
x x
e
e

qualifier













v v k j n
table operators variables vij
e
ij



b

c

b

b




ax




bx

gx


x

ax





b b

b

x

gx

b

b

ax
bx

b

bx

ax

gx


b

ax
bx

b
ax bx

b

b
ax bx



b

b

b

bx
bx

gx
b

bx

b




b

b v k c v k j n
figure dtgs v
ij


check whether assignment xj j th bit satisfies clause ci
remember whether ci satisfied assignment xl l j
j n ci satisfied propagate fact
j n let vi j know j th bit message arrived
first fourth function propagate information thus performed
state variables information lost however functions
performed different state variables idea behind reduction c n split vij
performs second function v performs third
three variables vij
ij

vij performs fifth


fichain causal graphs domains size



b


g
b


bx

bx
b
gx

gx

g

b

ax

bx

ax
b

b

bx

ax





ax

b

bx

g
g

ax

bx

gx

bx gx
bx

gx
bx gx

ax

b




bx

g

g
b

b v k j n
figure dtgs vij
ij

message propagated subscripts values domains
moves
state variables j th bit mj message arrives state variable vij
moves
ax gx assignment xj mj satisfies ci bmj otherwise vij
gx forced move bmj next forgetting ci satisfied however
g subsequent state variables c move g propagating
value vij
x

x
able remember
fact ci satisfied consequently state variable vin
ci satisfied remaining within subdomain g g gx
moves b causing v v move
xj mj satisfy ci vij
mj
mj
ij
ij




vij vij vij move bx next bit arrives vij moves b b
move v b b indicates v
causing vij




ij
j j th
bit arrived causing act accordingly operators defined
reacts first bit clause c
vi

formal proof
since variables n vs e e n lemmas
apply p f however lemma violated since sometimes possible
change value variable twice without changing value predecessor e g
operators consequently lemma states plans
solve p f admissible longer holds p f
l variables middle
prove equivalent lemmas p f redefine vij
causal graph
l k j n
definition given partial plan variable vij
l number subscript changes v l execution
l let vij
ij
l k j n
lemma partial plan p f vij
l v v predecessor v l causal
l holds vij
ij
graph
l operator
proof follows immediately inspection operators vij
l
changes subscript vij z x pre condition v subscript z
predecessor v operators changing value
value z case v

g pre condition v subscript value different x
vij
x
since pre condition v
operators change subscript vij
x
ij



figimenez jonsson


lemma partial plan p f vkn
denotes
proof note still denotes number value changes vkn
time change value v need
number subscript changes vkn
e

change subscript vkn addition first value change requires
different initial state thus v v
subscript vkn
e
kn

definition admissible plan p f partial plan
v v n e n
si vs v
e

kn
n
lemma plan solves p f admissible
v v
proof lemmas vs v
e
kn
use lemmas apply reasoning proof lemma

l exactly n
words admissible plan change subscript vij
l extra time moving g however
times although change value vij
x
l cannot prove equivalent lemma
even definition vij
l l choose follow predecessor g without
p f since variable vij
x
making plan inadmissible consequently sequences values qti admissible
plan longer completely determined induced message nevertheless
still prove lemma similar lemma

definition let admissible plan clause ci n
let sequence values qti vector n elements representing variable
l j n l first value following th subscript change
vij
l execution
vij
lemma let assignment variables x xn formula f
existence exists admissible plan p f induced
assignment
claim let qti sequences values described part lemma
satisfies f exists admissible plan qti qti
n k satisfy clause ci admissible
plans qti qti k
sequence values sequence values qti k n
follows
j ti
j

qi j
q j

q j


nj


z
z


bx bx bx bx bx bx
ax ax ax
ax ax ax ax ax ax

bm bm bm bm bm

bx bx bx bx bx bx
bx bx bx
ax ax ax ax ax ax



fichain causal graphs domains size

b j ti
j

qi j
q j

j
qi

nj
z


z



bx bx bx bx bx bx
ax ax ax
ax ax ax ax ax ax
bm bm bm bm bm gm bm bm gm bm bm gm bm

bx bx bx bx bx bx
bx gx bx
bx gx bx bx gx bx

c j ti
jti

ti

qi j
q j

j
qi

nj

z
z






z
bx gx bx bx gx bx bx gx bx bx gx bx bx gx bx
bx bx bx bx bx bx
bm bm bm bm bm gm bm bm gm bm bm gm bm bm gm bm bm gm bm
bx bx bx bx bx bx
bx gx bx bx gx bx bx gx bx bx gx bx bx gx bx

proof note similarity lemma lemma must
operators time tables whose post conditions equal values
j
given qi j q j
must check consistency statements
qi
j
j

j j implies lemma statements
qi
qi
qi j valid due initial state ax ax induction j
j
remains statements q j
valid
qi
proof divided six parts lemma note
contrast lemma aim satisfies f exists
admissible plan given qti admissible plans form
sometimes execution plan one operator could chosen
resulting plan would still admissible tables follow alike
proof lemma indicate operator choice leads
desired qti use boldface remark operators forced add
extra row tables indicate sometimes need apply two operators
variable changing subscript disparities respect lemma
occur parts ii iv proof require ti n satisfying clause
ci fixed thus satisfy clause ci admissible plans
sequences values qti n
j ti
v v
v v k n
vi
vik

ik ik
j ax ax ax
ax ax ax
j
bm
ax ax ax
j bx bx bx

ii j ti
v v
v v k n
vi
vik

ik ik
j ax ax ax
ax ax ax
gx gx gx
gx gx gx
j
bm gm bm
bm gm bm
bx gx bx
bx gx bx
j



figimenez jonsson

iii j ti
v v k j v v v
v v k j n
vik
vik
ij ij ij
ik ik
ik ik
j
b x bx bx
ax ax ax
ax ax ax
j
bm bm bm
bx bx bx
bx bx bx
ax ax ax
j

iv j ti
v v k j v v v
v v k j n
vik
vik
ij ij ij
ik ik
ik ik
j
b x bx bx
ax ax ax
ax ax ax
bm bm gx gx gx
gx gx gx
j
bm bm
bm gm bm
bm gm bm
j
bx bx bx
bx gx bx
bx gx bx

v ti j
v v k n
v v
vik
vi

ik ik
j
bx gx bx
bx gx bx
j
bm gm bm bm gm bm
j
bx gx bx
bx gx bx

vi ti j
v v k v v v k n
vik


ik ik
ik ik ik
j
bx bx bx
bx gx bx
j
bm bm
bm gm bm
j
bx bx bx
bx gx bx

theorem exists plan solves p f
exists assignment satisfies cnf formula f
proof given assignment satisfies f construct admissible plan whose
induced formula assignment equals choosing sequence values vs accordingly follows clause ci ti n since exists variable xj
xj mj satisfies ci since n ti exists admissible plan qi n
form indicated case b c lemma case n th
g required goal state plan thus solves p f
value variable vin
x

let plan solves p f lemma plan
admissible contradiction satisfies f assume
exists clause ci satisfied thus lemma applies sequence
following execution
values q n
particular means value vin

bx according case lemma contradicts solving p f since bx
g
different goal state goal vin
x
proposition plan existence c n np hard


fichain causal graphs domains size

proof largest variable domains p f variables
v contain values proof follows immediately np hardness
v
kn
cnf sat theorem fact produce p f
polynomial time given cnf formula f

references
brafman r domshlak c structure complexity unary
operators journal artificial intelligence
brafman r domshlak c factored
proceedings st national conference artificial intelligence pp
bylander computational complexity propositional strips
artificial intelligence
chapman conjunctive goals artificial intelligence
chen h gimenez causal graphs structurally restricted
proceedings th international conference automated scheduling pp
domshlak c dinitz multi agent line coordination structure complexity proceedings th european conference pp
erol k nau subrahmanian v complexity decidability undecidability
domain independent artificial intelligence
gimenez jonsson complexity simple
causal graphs journal artificial intelligence
gimenez jonsson b search tractability boundary
proceedings th international conference automated
scheduling pp
helmert fast downward system journal artificial intelligence

jonsson role macros tractable causal graphs
proceedings th international joint conference artificial intelligence pp

jonsson p backstrom c tractable plan existence imply tractable
plan generation annals mathematics artificial intelligence
katz domshlak c islands tractability cost optimal
journal artificial intelligence
katz domshlak c b structural patterns heuristics via fork decompositions proceedings th international conference automated
scheduling pp
knoblock c automatically generating abstractions artificial intelligence


figimenez jonsson

williams b nayak p reactive planner model executive
proceedings th international joint conference artificial intelligence pp





