Journal Artificial Intelligence Research 34 (2009) 499-520

Submitted 10/08; published 3/09

Exploiting Single-Cycle Symmetries
Continuous Constraint Problems
Vicente Ruiz de Angulo
Carme Torras

ruiz@iri.upc.edu
torras@iri.upc.edu

Institut de Robotica Informatica Industrial (CSIC-UPC)
Llorens Artigas 4-6, 08028-Barcelona, Spain.
WWW home page: www.iri.upc.edu

Abstract
Symmetries discrete constraint satisfaction problems explored exploited last years, symmetries continuous constraint problems received attention. focus permutations variables consisting
one single cycle. propose procedure takes advantage symmetries
interacting continuous constraint solver without interfering it. key concept
procedure classes symmetric boxes formed bisecting n-dimensional
cube point dimensions time. analyze classes
quantify function cube dimensionality. Moreover, propose simple
algorithm generate representatives classes number variables
high rates. problem example chemical field cyclic n-roots problem
used show performance approach practice.

1. Introduction
Symmetry exploitation discrete constraint satisfaction problems (CSPs) received
great deal attention lately. Since CSPs usually solved using AI search algorithms,
approaches dealing symmetries fall two groups: entail reformulating
problem adding constraints search (Flener, Frisch, Hnich, Kiziltan, & Miguel, 2002;
Puget, 2005), break symmetries along search (Meseguer & Torras, 2001;
Gent, 2002). Permutations variables, interchangeability values commonly
addressed symmetries repertoire techniques developed,
relying computational group theory.
contrary, symmetries largely disregarded continuous constraint
solving, despite important growth theory applications field
recently experienced (Sam-haroud & Faltings, 1996; Benhamou & Goualard, 2000; Jermann
& Trombettoni, 2003; Porta, Ros, Thomas, & Torras, 2005). Continuous (or numerical)
constraint solving often tackled using Branch-and-Prune (B&P) algorithms (Hentenryck,
Mcallester, & Kapur, 1997; Vu, Silaghi, Sam-Haroud, & Faltings, 2005), iteratively
locate solutions inside initial domain box, alternating box subdivision (branching)
box reduction (pruning) steps.
Motivated molecular conformation problem, paper deal
simple type box symmetry, namely domain variables (i.e., box dimensions) undergo single-cycle permutation leaving constraints invariant. clear,
cycle involves n variables, algorithm handles n 1 symmetries (excluding
c
2009
AI Access Foundation. rights reserved.

fiRuiz de Angulo & Torras

identity) generated cycle composition. Since computational gain
shown roughly proportional n, longest cycle appearing problem formulation chosen input algorithm.
single-cycle permutation leaves constraints unchanged form constraint symmetry terminology introduced Cohen, Jeavons, Jefferson, Petrie,
Smith (2006). Note constraint symmetry solution symmetry,
way around. Thus, symmetries deal subset possible solution
symmetries; advantage assessed (although perhaps difficult
find) problem formulation, therefore operative.
approach exploit symmetries continuous constraint problems requires
initial domain symmetric variables n-cube, starts subdividing
cube point along dimensions once. Since box symmetry transitive
relation, subboxes resulting subdivision fall equivalence classes. Then,
B&P algorithm (or similar continuous constraint solver) called subboxes
representatives symmetry equivalence class. Finally, solution found,
symmetric ones generated. Note symmetry handling doesnt interfere
inside workings constraint solver.

2. Symmetry Continuous Constraint Problems
interested solving following general continuous Constraint Satisfaction Problem (continuous CSP): Find points x = (x1 , . . . , xn ) lying initial box Rn satisfying
constraints f1 (x) C1 , . . . , fm (x) Cm , function : Rn R, Ci
interval R.
particular feature require Continuous Constraint Solver (CCS)
work axis-aligned box Rn input. Also, assume
CCS returns solution boxes. Note CCS returning solution points limit case still
contained framework.
say function : Rn Rn point symmetry problem exists
associated permutation (x) = f(i) (s(x)) Ci = C(i) , = 1, . . . , m.
consider symmetry property relates points equivalent regards
continuous CSP. Concretely, definition one conclude
x solution problem iff s(x) solution problem.
Let two symmetries continuous CSP associated permutations
. easy see composition symmetries s(t()) symmetry
associated permutation (t ()).
interesting type symmetries permutations (bijective functions set onto
itself) components x. Let finite set. cycle length k permutation
exist distinct elements a1 , . . . ak (ai ) = (a(i+1)mod k )
(z) = z element z D. cycle represented (a1 , . . . ak ).
Every permutation expressed composition disjoint cycles (i.e, cycles without
common elements), unique order factors. Composition cycles
represented concatenation, example (a1 , . . . ak )(b1 , . . . bl ). paper focus
particular type permutations, namely constituted single cycle.
500

fiExploiting Single-Cycle Symmetries

simplest form1 , s(x1 , x2 , . . . xn ) = (x(1) , x(2) , . . . x(n) ) = (x2 , x3 ...xn , x1 ),
(i) = (i + 1) mod n.
Example: n = 3, = 4, x = (x1 , x2 , x3 ) [1, 1] [1, 1] [1, 1],
f1 (x) :

x21 + x22 + x23 [5, 5] x21 + x22 + x23 = 5

f2 (x) :

2x1 x2 [0, ] 2x1 x2 > 0

f3 (x) :

2x2 x3 [0, ] 2x2 x3 > 0

f4 (x) :

2x3 x1 [0, ] 2x3 x1 > 0

exists symmetry s(x1 , x2 , x3 ) = (x2 , x3 , x1 ), need reordering variables. constraint permutation associated (1) = 1, (2) = 3,
(3) = 4, (4) = 2.
Generally unique symmetry given problem. exists symmetry
s, example s2 (x) = s(s(x)) another symmetry. general, using convention
denoting s0 (x) identity mapping, {si (x), = 0 . . . n1} set different symmetries
obtained composing s(x) itself, > n si (x) =
si mod n (x). Thus, single-cycle symmetry generates composition n 1 symmetries,
excluding trivial identity mapping. may different numbers cycles.
Imagine example continuous CSP n = 4 permutation variables (1
2 3 4) symmetry. Then, permutation obtained composing twice, (1 3)(2 4),
symmetry problem, different number cycles, longest
cycle length two instead four. Besides, former permutation cannot generated
latter. algorithm presented paper deals compositions
single-cycle symmetry, even single-cycle symmetries.
gain obtained proposed algorithm shown roughly proportional
number different compositions selected symmetry. Therefore, several
single-cycle symmetries exist continuous CSP problem, algorithm used
generating symmetries composition, i.e., longest
cycle. Note single-cycle permutations dealing need encompass
problem variables, since remaining ones considered fixed (unitary cycles).

3. Box Symmetry
Since continuous constraint solvers work boxes, turn attention set
points symmetric belonging box B Rn . 2
Let single-cycle symmetry corresponding circular variable shifting introduced preceding section, B = [x1 , x1 ]. . .[xn , xn ] box Rn . box symme1. general, variables must arranged suitable order one apply circular shifting. Thus, general form single-cycle symmetry s(x) = h1 (g(h(x))),
h(x1 , . . . xn ) = (x(1) , . . . , x(n) ), n general permutation orders variables,
g(x1 , . . . , xn ) = (x(1) , . . . x(n) ) circular shifting above. Thus, cycle defining symmetry expressed = 1 ((())). Since reordering change substantially
presented concepts algorithms, simplified notation paper assuming order
component variables appropriate one, i.e., = .
2. set {s(x) s.t. x B} box s(x) = (s1 (x), . . . , sn (x)) = (g1 (x(1) ), . . . , gn (x(n) )),
si i-th component s, arbitrary permutation, gi : R R function
interval R {gi (x) s.t. x I} interval R.

501

fiRuiz de Angulo & Torras

try function defined S(B) = {s(x) s.t. x B} = [x(1) , x(1) ] . . . [x(n) , x(n) ] =
[x2 , x2 ] . . . [xn , xn ] [x1 , x1 ]. box symmetry function associated constraint permutation , associated s. denote composed
times. say, then, B1 B2 symmetric boxes exists s.t. (B1 ) = B2 .
Box symmetry equivalence relation defining symmetry equivalence classes. Let
R(B) set different boxes symmetry class B, R(B) = {S (B), {0, . . . , n
1}}. instance, box B 0 = [0, 4] [2, 5] [2, 5] [0, 4] [2, 5] [2, 5], R(B 0 ) composed
0 (B 0 ) = B 0 , 1 (B 0 ) = [2, 5][2, 5][0, 4][2, 5][2, 5][0, 4] 2 (B 0 ) = [2, 5][0, 4]
[2, 5][2, 5][0, 4][2, 5]. Note 3 (B 0 ) B 0 subsequent applications
box symmetry would repeat sequence boxes. define period P (B)
box B P (B) = |R(B)|. easily shown R(B) = {S (B), {0, . . . , P (B) 1}}.
example, box B 0 , R(B 0 ) = {S 0 (B 0 ), 1 (B 0 ), 2 (B 0 )} P (B 0 ) = 3.
Box symmetry implications continuous CSP, direct consequence
point symmetry case:
solution inside box B, solution inside symmetric
boxes either.
box B B solution iff (B ) (B) solution box {1 . . . P (B)
1}.
Sketch proof first statement: Assume solution inside B
solution xsol inside (B). definition box symmetry exists point x0sol B
xsol = si (x0sol ). Using property highlighted Section 2 deduce x0sol
must solution, contradicts hypothesis.
Sketch proof second statement: solution box box least solution
point inside. Assume B B solution box containing solution point xsol . Inside
(B ) point si (xsol ) that, property highlighted Section 2, must
solution. Conversely, assume (B ) B solution box. Thus contains
least solution point, xsol . definition symmetric box, point symmetric
point x0sol B xsol = si (x0sol ). Using property Section 2 conclude
x0sol must solution and, thus, B solution box.
statements rephrased follows :
set solution boxes contained box B SolSet, set solution boxes
contained symmetric box (B) {S (B ) s.t. B SolSet}
means solutions inside B found, solutions inside
symmetric boxes (B), {1 . . . P (B) 1} available without hard calculations.
following sections show exploit property save much computing time
meta-algorithm uses CCS tool without interfering it.
3.1 Box Symmetry Classes Obtained Bisecting n-cube
algorithm propose exploit box symmetry makes use symmetry classes
formed bisecting n-dimensional cube n (i.e., period 1) dimensions
time point, resulting 2n boxes. denote L H
two subintervals original range divided. example, n = 2,
502

fiExploiting Single-Cycle Symmetries

following set boxes {L L, L H, H L, H H} whose periods 1, 2,
2 1, respectively. symmetry classes are: {L L}, {L H, H L},
{H H}. Representing two intervals L H 0 1, respectively, dropping
symbol, sub-boxes coded binary numbers. Let SRn set
representatives, formed choosing smallest box binary order class.
example, SR2 = {00, 01, 11}. Note cube n partitioned thought
set binary numbers length n, SRn nothing subset
whose elements different circular shift.
algorithm exploiting symmetries way uses SRn explained
next section. Afterwards, Sections 6 7, study many components SRn has,
distributed and, importantly, generated.

4. Algorithm Exploit Box Symmetry
Algorithm 1: CSym1 algorithm.
Input: n-cube, [xl , xh ] [xl , xh ].
single-cycle box symmetry, S.
Continuous Constraint Solver, CCS.
Output: set boxes covering solutions.

5

SolutionBoxSet EmptySet
x SelectBisectionPoint(xl , xh )
foreach b SRn
B GenerateSubBox(b, xl , xh , x )
SolutionBoxSet SolutionBoxSet ProcessRepresentative(B)

6

return SolutionBoxSet

1
2
3
4

symmetry exploitation algorithm propose uses CCS external routine.
internals CCS must modified known.
idea first divide initial box number symmetry classes. Next, one
needs process representative class CCS. end, applying
box symmetries solution boxes obtained way, one would get solutions
lying space covered whole classes, i.e., initial box. advantage
procedure CCS would process fraction initial box. Assuming
initial box n-cube covering interval [xl , xh ] dimensions,
directly apply classes associated SRn . procedure exploit single-cycle symmetries
way presented Algorithm 1.
Since SRn set codes real boxes need translation codes
boxes given initial box. operator GenerateSubBox(b, xl , xh , x ) returns
box V = V1 Vn corresponding code b = b1 . . . bn [xl , xh ] range
initial box dimensions x point interval bisected:
(
[xl , x ] bi = 0,
Vi =
(1)
[x , xh ] bi = 1.
503

fiRuiz de Angulo & Torras

point x calculated SelectBisectionPoint(xl , xh ) xl <
< xh , reasonable one (xl + xh )/2. iterations line 4 generate set
representative boxes that, together symmetries, cover initial n-cube.
ProcessRepresentative(B) returns solution boxes associated B, is,
solutions inside R(B), still words, solutions inside B inside symmetric
boxes. ProcessRepresentative(B) based property stated end Section
3, allows obtain solutions class B processing B
CCS. SolSet set solutions found inside representative box class, B.
ApplySymmetry(SolSet, ) calculates set solutions box (B) applying
boxes SolSet. Since number symmetries B P (B), benefits
exploiting symmetries class representative proportional period.
x

Algorithm 2: ProcessRepresentative function.
Input: box, B.
single-cycle box symmetry, S.
Continuous Constraint Solver, CCS.
Output: set solution boxes contained B symmetric boxes.

4

SolSet CCS(B)
otalSolSet SolSet
i=1: P (B) 1
otalSolSet otalSolSet ApplySymmetry(SolSet, )

5

return otalSolSet

1
2
3

correctness algorithm easy check. set boxes searches explicitly implicitly (by means symmetry) solutions U = {R(B) s.t. B representative}.
fact, U set boxes formed bisecting initial box dimensions
time point. U covers whole initial box and, thus, algorithm finds
solutions problem. Moreover, finds solution box once,
boxes U volume common (they share wall).
4.1 Discussion Efficiency CSYM1
CSym1 algorithm launches CCS algorithm |SRn | small boxes instead
original large one. Three factors affect efficiency compared standard
approach:
1. Fraction domain processed. fraction original domain directly
dealt CCS. fraction function periods SRn components. One element period p represents class formed p boxes, one
processed CCS. Since boxes classes equal size,
fraction calculated dividing number representatives
n|
P |SRn |
total number boxes classes, |SR
2n =
P (B) . expected time gain
P

BSRn

P (B)

n
inverse quantity, BSR
denoted IFDP (Inverse Fraction
|SRn |
Domain Processed). n grows (see Section 6), majority elements

504

fiExploiting Single-Cycle Symmetries

SRn period n, thus IFDP tends n. However, low n, IFDP
significantly smaller n. main factor determining efficiency
CSym1.
2. Smaller processed boxes. Since CCS initial boxes using CSym1 2n times
smaller original initial box, average size boxes processed
CCS smaller standard case. Prune (box reduction contraction)
step carried quickly smaller boxes Branch-and-Prune algorithms.
fact, best Branch-and-Prune algorithms box contraction operators exhibiting
second-order convergence, contraction rate requires small enough boxes
hold practice.
3. Number representatives. disadvantage fractioning excessively
initial domain. see noting that, using original large initial
box, contraction operator lowers upper bound symmetric variable,
information could used lower upper bound variable many
representative boxes SRn . commented above, contraction operator would
act strongly representatives themselves, loss parallelization
effect anyway present. factor irrelevant small-length cycle symmetries,
say n = 6, |SRn | small (see Section 6 again) compared
number boxes CCS must process general. However, n approaches
20, number representatives begins become overwhelming.

5. Two Illustrative Examples
two problems solved Branch-and-Prune CCS presented
Porta, Ros, Thomas, Corcho, Canto, Perez (2008). polytope-based method
similar Sherbrooke E. C. (1993) global consistency, exhibits quadratic
convergence. machine used carry experiments paper 2.5 Ghz
G5 Apple computer.
5.1 Cycloheptane
Molecules modeled mechanical chains making reasonable approximations.
two atoms joined chemical bond, one assume rigid link
them. Thus, first approximation bond lengths constant. second one
angles two consecutive bonds constant. words,
distances atoms subchain three atoms assumed constant.
configurations atoms molecule satisfy distance constraints, sometimes
denoted rigid-geometry hypothesis, valid conformations molecule kinematic
sense. constraints induced rigid-geometry hypothesis particularly strong
molecule topology forms loops, cycloalkanes. problem finding
valid conformations molecule formulated distance-geometry (Blumenthal,
1953) problem distances points (atoms) fixed known,
one must find set values unknown (variable) distances compatible
embedding points R3 . unknown distances found solving set
505

fiRuiz de Angulo & Torras

constraints consisting equalities inequalities determinants formed subsets
fixed variable distances (Blumenthal, 1953).

d2
d3

d1
d7

d5

d6

d4

Figure 1: Cycloheptane. Disks represent carbon atoms. Constant variable distances
atoms represented continuous dashed lines, respectively.

Figure 2: Three-dimensional projection cycloheptane solutions. lightest (yellow)
boxes solutions found inside representatives using CCS (line 1
Algorithm 2). colored boxes solutions obtained applying
symmetries yellow boxes (line 4 Algorithm 2).

Figure 1 displays known unknown distances cycloheptane, molecule basically composed ring seven carbon atoms. distance two consecutive atoms
ring constant equal everywhere. distance two atoms connected
506

fiExploiting Single-Cycle Symmetries

atom known constant matter atoms. problem underconstrained, infinite number solutions dimensionality 1. problem several
symmetries. use one them, s(d1 , . . . , d7 ) = (d(1) , d(2) , . . . , d(7) ) = (d2 , d3 . . . , d7 , d1 ).
length cycle symmetry n = 7, IFDP 6.4.
number boxes processed using raw CCS without symmetry handling 1269,
using CSym1 total number 196, giving ratio 6.47 IFDP. problem
solved 4.64 minutes using CSym1, compares favorably 31.6 minutes
spent using algorithm Porta et al. (2008) alone, reduction factor 6.81,
slightly greater IFDP. means that, although number representatives begins
relevant (|SR7 | = 20), factor 2 Section 4.1 determining factor 3
section, since (small) time overhead introduced handling box symmetries
included reported time. Figure 2 shows projection d1 , d2 d3
solutions obtained using CSym1. solutions found inside five representative boxes
period seven, containing 16, 1, 4, 64 1 solution boxes, respectively, chosen level
resolution. total number solutions boxes therefore 7(16+1+4+64+1)= 602.
5.2 Cyclic n-roots Problem
following polynomial equation system n = 5 instance so-called cyclic
n-roots problem described Bjorck Froberg (1991).

x1 + x2 + x3 + x4 + x5 = 0
x1 x2 + x2 x3 + x3 x4 + x4 x5 + x5 x1 = 0
x1 x2 x3 + x2 x3 x4 + x3 x4 x5 + x4 x5 x1 + x5 x1 x2 = 0
x1 x2 x3 x4 + x2 x3 x4 x5 + x3 x4 x5 x1 + x4 x5 x1 x2 + x5 x1 x2 x3 = 0

(2)

x1 x2 x3 x4 x5 1 = 0

ten real solutions problem. system single-cycle symmetry:
s(x1 , . . . , x5 ) = (x2 , x3 , x4 , x5 , x1 ), well multiple-cycle symmetry considered
paper. Thus, cycle length n = 5, |SR5 | = 8, IFDP 4. running
CCS alone using initial box [10, 10]5 , number processed boxes 399,
exploiting aforementioned symmetry CSym1 algorithm number reduces
66. last case, two solutions found representative box period 5,
symmetry led ten solutions. Running times 16.86 seconds (CCS alone)
2.08 seconds (CSym1) giving gain eight. double IFDP,
highlights benefits factor 2 Section 4.1 bring efficacy
approach. number representatives small compared number boxes
processed CCS alone, making factor 3 Section 4.1 irrelevant case.
Table 1 contains results n=4 n=8 cyclic n-roots problem [10, 10]n
domain, except n=8 domain [5, 5]8 . n=4 n=8
continuum solutions which, chosen resolution, produces 992 2435 solution
boxes, respectively. this, number processed boxes n=5 smaller
n=4, logically smaller n=6 n=8. Two observations
507

fiRuiz de Angulo & Torras

IFDP
number processed boxes CCS alone
number processed boxes CSym1
rate processed boxes
time CCS alone
time CSym1
time gain CSym1

n=4

n=5

n= 6

n=7

2.7
1855
500
3.7
12.0
3.0
4.0

4.0
399
66
6.0
16.9
2.1
8.1

4.5
3343
510
6.6
642.0
95.8
6.7

6.4
38991
5070
7.7
20442.0
2689.7
7.6

n=8
(reduced domain)
7.1
108647
13304
8.2
227355.2
27296.5
8.3

Table 1: Results n-cyclic roots problem. Times given seconds.

made. First, time gains always higher corresponding IFDPs, implying
preponderance factor 2 Section 4.1 factor 3. Second, time gain follows rather
accurately rate number processed boxes using CCS alone using
CSym1.
Tests cyclic n-roots problem using classical CCSP solver, RealPaver (Granvilliers & Benhamou, 2006), carried (Jermann, 2008). results preliminary difficult expose concisely, since great variability depending issues
pruning method used (RealPaver offers several options) problem
coded (factorized not). every case, however, observed time gains greater
expected IFDP.

6. Analysis SRn : Counting Number Classes
Let us define quantities interest:
-Nn : Number elements SRn .
-FP n : Number elements SRn correspond full-period boxes, i.e., boxes period
n.
-Nnm : Number elements SRn 1s.
-FP nm : Number elements SRn correspond full-period boxes 1s.
Polyas theorem (Polya & Read, 1987) could used determine quantities given n building possibly huge polynomial elucidating
coefficients. present simpler way calculating and, time, make
reader familiar concepts used algorithm generate SRn .
begin looking expression FP n . number 1s allowed,
total number binary numbers 2n . periods exist binary
numbers divisors n. Thus, following equation holds:
X

p FP p = 2n .

pdiv(n)

Segregating p = n,
508

(3)

fiExploiting Single-Cycle Symmetries

X

n FP n +

p FP p = 2n ,

(4)

p
FP p .
n

(5)

pdiv(n), p<n

solving FP n :
FP n =

2n

n

X
pdiv(n), p<n

recurrence simple baseline condition: FP 1 = 2.
Then, Nn follows easily
Nn =

X

FP p .

(6)

pdiv(n)

Segregating p = n, efficient formula obtained:
Nn =

2n
+
n

X
pdiv(n), p<n

np
FP p .
n

(7)

formula valid n > 1. remaining case N1 = 2.

n
use similar techniques obtain FP nm Nnm .
binary numbers
1s n 0s. binary numbers circular shifts others
(like 011010 110100). number shifted versions binary number period
box represented binary number. example, 1010, period 2,
another shifted version, 0101. binary number representing box period p
n
seen concatenation n/p numbers length n/p
= p period p. means

concatenated numbers full-period, n/p
1s. Thus, number
binary numbers period p shifted numbers counted (i.e., number
n
. common divisors n m, denote
classes period p) FP n/p
n/p
div(n, m), periods. Since p shifted versions binary number
period p, write

X
n
n
=
p FP n/p
.
(8)
n/p

pdiv(n,m)

change variable f = n/p get
X
f div(n,m)

n
FP nf mf =
f


n
.


(9)

Note index summation goes values before.
segregate case f = 1 summand,

X
n
n
n FP nm +
FP nf mf =
,
(10)
f

f div(n,m), f >1

and, finally, obtain
509

fiRuiz de Angulo & Torras

FP nm =

n




n

FP nf mf

X



f

f div(n,m), f >1

.

(11)

recurrence relation FP nm computed using following
baseline conditions:
(
0
=
1

FP nn , FP n0

n > 1
n = 1

(12)

Nnm obtained adding number classes period:
Nnm =

X

FP nf mf .

(13)

f div(n,m)

Segregating f = 1, efficient formula obtained:
Nnm =


n
+


X

n
)FP nf mf ,
f

(14)

(1 p)FP p mp ,

(15)

(1

f div(n,m), f >1

carrying change variable p = n/f :
Nnm =


n
+


X

n

pdiv(n,m), p<n

Note change summation range. equation valid whenever > 0
< n. Otherwise, Nnm = 1.
possible extend concept FP n (and FP nm ) reflect number members
p
):
SRn period p (and 1s), denote Nnp (Nnm
Nnp

p
Nnm

(
0
=
FP p

p
/ div(n)
otherwise

(
0
=
FP p, mp
n

p
/ div(n, m)
otherwise

(16)

(17)

Figure 3(a) displays number classes (Nn ) function n. curve indicates
exponential-like behavior. confirmed Figure 3(b) using larger logarithmic
scale, curve appears almost perfectly linear. Figure 4 example
distribution classes period n = 12. Figure 5 shows percentage full-period
classes SRn (100 Nnn /Nn ). One see percentage classes period different
n significant low n, approaches quickly 0 n grows. Finally, Figures 6(a)
6(b) display distribution classes SRn number 1s n = 12
n = 100, respectively. majority classes concentrates interval middle
graphic, around n/2. interval becomes relatively smaller n grows.
510

finumber classes symmetric boxes

350
300
250
200
150
100
50
0

2

4

6

8

10

12

1x1011
1x1010
1x109
1x108
1x107
1x106
1x105
1x104
1x103
1x102
1x101
1

0

5

box dimensionality (i.e., number variables)

10

15

20

25

30

(b)

Figure 3: Number elements SRn function n.

100

10

1

1

2

3

4

35

box dimensionality (i.e., number variables)

(a)

number classes symmetric boxes

number classes symmetric boxes

Exploiting Single-Cycle Symmetries

5

6

7

8

9

10

11

12

box period

Figure 4: Number elements SR12 distributed period.

511

40

fiRuiz de Angulo & Torras

7. Generating SRn , Classes Symmetric Boxes
naive procedure obtain SRn would initially generate boxes originated bisecting
n-dimensional cube point dimensions time. Then, one
check boxes set detect whether circular shift
others. complete process generating SRn way involves huge number
operations even rather small dimensions. Although SRn ns could precomputed stored database, suggest algorithm capable calculating
SRn fly without significant computational overhead.

percentage full-period classes

100

80

60

40

20

0
2

4

6

8

10

12

14

16

18

20

box dimensionality (i.e., number variables)

Figure 5: Percentage full-period elements SRn function n.

number classes symmetric boxes

number classes symmetric boxes

made counting, distinguish different subsets SRn basis number
1s period:
-SRnm : Subset elements SRn 1s.
-SRpnm : Subset elements SRn 1s period p.
SRpn : Subset elements SRn period p.
global point view, generation SRn carried follows. First,
SRn0 generated, constituted always unique member. Afterwards, SRnm

70
60
50
40
30
20
10
0

0

2

4

6

8

10

12

1x1027
8x1026
6x1026
4x1026
2x1026

0

0

20

40

60

80

100

number 1s code

number 1s code

(a)

(b)

Figure 6: Number elements SRn distributed number 1s. (a) n =12. (b) n=100.

512

fiExploiting Single-Cycle Symmetries

= 1 . . . n generated. generation SRnm divided SRpnm ,
p div(n, m), compose it. algorithm ClassGen described generates
full-period representatives given number variables n > 1 number ones
> 0, i.e., generates SRnnm . representatives lower period p div(n, m)
obtained concatenating one block n/p = f times. Therefore, order obtain
SRpnm , generate SRpp algorithm, concatenate elements
f

f times. Thus, without loss generality, follows describe workings
algorithm ClassGen computes codes full period, namely n.
use compact coding binary numbers representing boxes consisting
ordered lists chains numbers. first number code number 0s
appearing first 1 binary number. i-th number code > 1
number 0s (i1)-th i-th 1s binary number. example,
number 0100010111 codified 13100. length numerical codification
number 1s codified binary number, denoted m.
binary numbers cannot codified way, last digit
0. But, except zeros case, always element class
codified correctly (for example 0011 element class 0110). objective
representative class, rather advantage, half
boxes already eliminated beginning. zeros box, SRn0 , common
every n, generated separately, already mentioned.
codification allows determine box full-period way
binary representation: box period n iff number circular shifts lower
length numerical chain result never equal original. instance,
example full-period, 22, corresponding 001001, not. difference
that, new representation, shifts must compared.
code box seen number base n m. full-period box,
circular shifts code different numbers, arranged strictly increasing
numerical order. take representative box class largest element
class expressed code (which smallest expressed binary number).
example, class 130 two elements represented coding,
013 301, latter chosen representative class.
Note box belonging SRnm n 0s or, equivalently, sum
components code n m.
output algorithm codes length m, whose sum components
n m, representatives class full-period. Codes length
whose components sum desired number rather easy generate systematically.
representativeness full-period conditions difficult guarantee efficiently.
handle exploiting properties codes stated below, make
use definition i-compability.
say code i-compatible compatible position sub-chain
beginning position > 1 ending last position (thus length + 1)
strictly smaller numerical terms sub-chain length beginning
first position. example, 423423 compatible positions 2 3,
4-compatible.
513

fiRuiz de Angulo & Torras

Property 1 code class representative full-period iff i-compatible
s.t. 1 < 6 m.
Thus, instead comparing chains length (i.e., code shifted versions),
determine code validity comparing shorter sub-chains. second property helps
us devise still faster simpler algorithm:
Property 2 code i-compatible sub-chain position + l equal
sub-chain position 1 1 + l code compatible positions + 1
+ l.

Algorithm 3: CodeValidity algorithm.
Input: code length expressed array, A.
Output: boolean value indicating whether code valid, i.e., whether
full-period class representative.
1
2
3
4
5
6
7
8
9
10

i2
ctrol 1
V alidCode True
V alidCode & <
A[i] > A[ctrol] V alidCode F alse
else A[i] < A[ctrol] ctrol 1
else ctrol ctrol + 1;
ii+1

/* A[i] = A[ctrol] */

A[m] A[ctrol] V alidCode F alse
return ValidCode

property interesting permits checking validity code
travelling along once, shown Algorithm 3. trick decision
i-compatibility delayed position following numbers
beginning string, finally resolves positively, compatibility
intermediate numbers guaranteed. Hence, i-compatibility either resolved
simple comparison requires l comparisons. latter case, either compatibility
l positions resolved (if outcome positive) compatibility intermediate
positions doesnt matter (because outcome negative and, thus, code labelled
non valid without checks). ctrol variable charge maintaining last index
head sub-chain compared current compatibility check.
examining compatibility current position i, value lower
ctrol position, code sure i-compatible therefore must worry
(i + 1)-compatibility back-warding ctrol first position. value ctrol
position equal current position i, compatibility position still
ascertained, continue advancing current ctrol positions equality
disappears. words, condition must fulfilled non rejecting
invalid code position
514

fiExploiting Single-Cycle Symmetries

Algorithm 4: ClassGen algorithm.
Input: sum numbers remain written right (from
position pos m), sum.
index next position written, pos.
index current control element, whose value cannot surpassed

next position, ctrol.
length code, m.
Array class codes generated, A.
Output: set codes representing classes, SR.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18

SR EmptySet
pos =
sum < A[ctrol]
A[m] sum
SR {A};

/* otherwise, SR remain EmptySet */

else
pos = 1
LowerLimit = dsum/me
U pperLimit sum
else
LowerLimit = 0
U pperLimit Minimum(A[ctrol], sum)
= U pperLimit LowerLimit
A[pos]
= A[ctrol]Sand pos 6= 1
/* = A[ctrol] = U pperLimit */
SR SR ClassGen(sum i, pos + 1, ctrol + 1, m, A)
else
/* < A[ctrol] pos = 1 */

SR SR ClassGen(sum i, pos + 1, 1, m, A)

19
20

return SR

A[i] 6 A[ctrol],

(18)

condition transformed A[i] < A[ctrol] = resolve last
pending compatibility checks. aside, note codes general
raw binary numbers, representativeness full-periodness defined
way both. Therefore, three properties CodeValidity algorithm apply
raw binary numbers.
rather direct way generate SRnnm would generate codes length
whose sum components n (the number zeros expressed binary
number) filter CodeValidity. Instead, taken
515

fiRuiz de Angulo & Torras

efficient approach, generating codes satisfy conditions need
checked explicitly CodeValidity. Therefore, Algorithm 3 (presented clarity
purposes) used.
main procedure obtain full-period representatives 1s, i.e., SRnnm ,
recursive program presented Algorithm 4. ClassGen(n m, 1, 1, m, A),
array length m, must called obtain SRnnm , given n > 1, > 0.
call procedure writes single component code position indicated
parameter pos, beginning pos = 1, subsequently incremented
recursive call. recursion finishes rightmost end code, pos = m.
first parameter, sum, sum components code remain written.
range values written position pos limited LowerLimit U pperLimit,
except last position m. following show correctness algorithm
verifying limits chosen satisfy two requirements code:
sum numbers code completed algorithm must nm. First,
recall initial call algorithm done using parameter sum = n m.
position 1 pos < number written must greater
equal sum numbers still written, quantity represented sum,
subsequent positions possible write positive integers, least
zeros. condition imposed U pperLimit line 9 pos = 1 line 12
(juxtaposed code validity conditions) 1 < pos < m. number written
pos substracted sum parameter next recursive call. Finally,
pos = m, possibility satisfy sum condition assign value
sum last element code.
code validity conditions, CodeValidity, number
written position pos must smaller equal A[ctrol] 1 < pos < m,
strictly lower A[ctrol] pos = m. conditions reflected
U pperLimit assignments made lines 12 3, respectively. LowerLimit usually
(pos < 1, line 4) set smallest possible element codes, 0.
beginning code (pos = 1, line 8) tight value chosen since,
value lower upper rounded value dsum/me, way distribute
remains sum among positions code without putting value
greater initial one, would make code non-representative.
maintenance ctrol variable similar within CodeValidity
algorithm: write pos something strictly minor A[ctrol], ctrol back-warded
first position. Otherwise, ctrol incremented 1 next recursive call write
pos + 1.
output algorithm list valid codes decreasing numerical order.
instance, output obtained requesting SR993 ClassGen(6, 1, 1, 3, A) is: {600,
510, 501, 420, 411, 402, 330, 321, 312}. example, case recursion
arrives pos = without returning valid code frustrated code 222, whose last
number written code full-period.
Figure 7 displays quantitative results reflect efficiency ClassGen.
dashed line accounts complete times required generate class representatives
516

fiExploiting Single-Cycle Symmetries

total time
millions representatives per second

1.4

20

1.2

1
15
0.8
10

0.6

total time (seconds)

number representatives (millions/second)

25

0.4

5

0.2
0
5

10

15

20

25

30

0

dimensionality (number variables)

Figure 7: Total time (dashed line) generate SRn , rates generation (continuous
line) class representatives function n.

SRn n = 2 n = 30. worth noting SR30 requires second
entirely generated. continuous line encodes division |SRn | time required
generate SRn , measured millions class representatives generated second.
evident efficiency ClassGen high even grows slightly
n. behavior shows dead-ends recursion statistically insignificant,
proves tightness bounds used enforce values code numbers.

8. Conclusions
approached problem exploiting symmetries continuous constraint satisfaction problems using continuous constraint solvers. approach general make
use box-oriented CCS black-box procedure. particular symmetries
tackled single-cycle permutations problem variables.
suggested strategy bisect domain, n-cube initial box, simultaneously
dimensions point. forms set boxes grouped box
symmetry classes. representative class selected processed CCS
symmetries representative applied resulting solutions.
way, solutions within whole initial domain found, processed fraction set representatives CCS. time savings
obtained processing representative applying symmetries solutions tend
proportional number symmetric boxes representative. Therefore, symmetry exploitation complete full-period representatives, since maximum
number symmetric boxes. Another factor improves efficiency could
517

fiRuiz de Angulo & Torras

expected considerations smaller average size boxes processed
CCS approach.
studied automatic generation classes resulting bisecting
n-cube analyzed numerical properties. algorithm generating classes
powerful, eliminating convenience pre-calculated table. numerical
analysis classes revealed average number symmetries class representatives tends quickly n number variables, n, grows. good news,
since n maximum number symmetries attainable single-cycle symmetries
n variables, leading time reductions factor close n. Nevertheless, small n
still significant fraction representatives maximum number
symmetries. Another weakness proposed strategy exponential growth
number classes function n.
problems small large n tackled refined subdivision
initial domain box symmetry classes, left near future work.
currently approaching extension work deal permutations
problem variables composed several cycles. Another complementary research line
addition constraints search CCS. constraints specific
symmetry class. Finally, extension Branch-and-Bound algorithms nonlinear
optimization could envisaged.

Acknowledgments
extended version work presented CP 2007 (Ruiz de Angulo & Torras, 2007).
authors acknowledge support Generalitat de Catalunya consolidated
Robotics group, Spanish Ministry Science Education, project DPI200760858, Comunitat de Treball dels Pirineus project 2006ITT-10004.

References
Benhamou, F., & Goualard, F. (2000). Universally quantified interval constraints.
Springer-Verlag (Ed.), CP 02: Proceedings 6th International Conference
Principles Practice Constraint Programming, pp. 6782.
Bjorck, G., & Froberg, R. (1991). faster way count solutions inhomogeneous
systems algebraic equations, applications cyclic n-roots. J. Symb. Comput.,
12 (3), 329336.
Blumenthal, L. (1953). Theory aplications distance geometry. Oxford University
Press.
Cohen, D., Jeavons, P., Jefferson, C., Petrie, K. E., & Smith, B. M. (2006). Symmetry
definitions constraint satisfaction problems. Constraints, 11 (2-3), 115137.
Flener, P., Frisch, A., Hnich, B., Kiziltan, Z., & Miguel, I. (2002). Breaking row column
symmetries matrix models. CP 02: Proceedings 8th International Conference Principles Practice Constraint Programming, pp. 462476. Springer.
518

fiExploiting Single-Cycle Symmetries

Gent, I. P. (2002). Groups constraints: Symmetry breaking search.
Proceedings CP-02, LNCS 2470, pp. 415430. Springer.
Granvilliers, L., & Benhamou, F. (2006). Realpaver: interval solver using constraint
satisfaction techniques. ACM Trans. Mathematical Software, 32, 138156.
Hentenryck, P. V., Mcallester, D., & Kapur, D. (1997). Solving polynomial systems using
branch prune approach. SIAM Journal Numerical Analysis, 34, 797827.
Jermann, C., & Trombettoni, G. (2003). Inter-block backtracking : Exploiting structure continuous csps. In: 2nd International Workshop Global Constrained
Optimization Constraint Satisfaction, pp. 1530. Springer.
Jermann, C. (2008). Personal communication..
Meseguer, P., & Torras, C. (2001). Exploiting symmetries within constraint satisfaction
search. Artif. Intell., 129 (1-2), 133163.
Polya, G., & Read, R. (1987). Combinatorial enumeration groups, graphs chemical
compounds. Springer-Verlag.
Porta, J. M., Ros, L., Thomas, F., Corcho, F., Canto, J., & Perez, J. (2008). Complete
maps molecular loop conformational spaces. Journal Computational Chemistry,
29 (1), 144155.
Porta, J. M., Ros, L., Thomas, F., & Torras, C. (2005). branch-and-prune solver
distance constraints. IEEE Trans. Robotics, 21, 176187.
Puget, J.-F. (2005). Symmetry breaking revisited. Constraints, 10 (1), 2346.
Ruiz de Angulo, V., & Torras, C. (2007). Exploiting single-cycle symmetries branchand-prune algorithms. CP 07: Proceedings 13th International Conference
Principles Practice Constraint Programming, pp. 864871.
Sam-haroud, D., & Faltings, B. (1996). Consistency techniques continuous constraints.
Constraints, 1, 85118.
Sherbrooke E. C., P. N. M. (1993). Computation solution nonlinear polynomial
systems. Computer Aided Geometric Design, 10, 379405.
Vu, X.-H., Silaghi, M., Sam-Haroud, D., & Faltings, B. (2005). Branch-and-prune search
strategies numerical constraint solving. Tech. rep. LIA-Report 7, Swiss Federal
Institute Technology (EPFL).

519


