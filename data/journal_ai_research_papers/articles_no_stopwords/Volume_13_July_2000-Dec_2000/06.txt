Journal Artificial Intelligence Research 13 (2000) 305-338

Submitted 6/00; published 12/00

Conformant Planning via Symbolic Model Checking
cimatti@irst.itc.it

Alessandro Cimatti

ITC-irst

, Via Sommarive 18, 38055 Povo, Trento, Italy

roveri@irst.itc.it

Marco Roveri

ITC-irst

, Via Sommarive 18, 38055 Povo, Trento, Italy

DSI, University Milano, Via Comelico 39, 20135 Milano, Italy

Abstract

tackle problem planning nondeterministic domains, presenting new
approach conformant planning. Conformant planning problem finding sequence actions guaranteed achieve goal despite nondeterminism
domain. approach based representation planning domain finite
state automaton. use Symbolic Model Checking techniques, particular Binary Decision Diagrams, compactly represent eciently search automaton. paper
make following contributions. First, present general planning algorithm
conformant planning, applies fully nondeterministic domains, uncertainty
initial condition action effects. algorithm based breadth-first, backward search, returns conformant plans minimal length, solution planning
problem exists, otherwise terminates concluding problem admits conformant
solution. Second, provide symbolic representation search space based Binary
Decision Diagrams (Bdds), basis search techniques derived symbolic
model checking. symbolic representation makes possible analyze potentially large
sets states transitions single computation step, thus providing ecient
implementation. Third, present Cmbp (Conformant Model Based Planner), ecient
implementation data structures algorithm described above, directly based
Bdd manipulations, allows compact representation search layers
ecient implementation search steps. Finally, present experimental comparison approach state-of-the-art conformant planners Cgp, Qbfplan
Gpt. analysis includes planning problems distribution packages
systems, plus problems defined stress number specific factors. approach appears effective: Cmbp strictly expressive Qbfplan
Cgp and, problems comparison possible, Cmbp outperforms
competitors, sometimes orders magnitude.
1. Introduction

recent years, growing interest planning nondeterministic domains.
Rejecting fundamental (and often unrealistic) assumptions classical planning, domains considered actions uncertain effects, exogenous events possible,
initial state partly specified. challenge find strong plan,
guaranteed achieve goal despite nondeterminism domain, regardless
uncertainty initial condition effect actions. Conditional planning (Cassandra, Kaelbling, & Littman, 1994; Weld, Anderson, & Smith, 1998; Cimatti,
Roveri, & Traverso, 1998b) tackles problem searching conditional course
c 2000 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiCimatti & Roveri
actions, depends information gathered run-time. certain domains,
however, run-time information gathering may expensive simply impossible. Conformant planning (Goldman & Boddy, 1996) problem finding unconditioned
course actions, i.e. classical plan, depend run-time information gathering guarantee achievement goal. Conformant planning recognized
significant problem Artificial Intelligence since work Michie (1974): Blind
Robot problem requires program activity sensorless agent, positioned location given room, guaranteed achieve given
goal. Conformant planning seen problem control system
unobservable unknown state, microprocessor power-up, software
system black-box testing.
uncertainty, plan associated potentially many different executions,
must taken account order guarantee goal achievement. makes
conformant planning significantly harder classical planning (Rintanen, 1999a; De Giacomo & Vardi, 1999). Despite increased complexity, several approaches conformant
planning recently proposed, based (extensions of) main planning techniques classical planning. interesting Cgp (Smith & Weld, 1998) based
Graphplan, Qbfplan (Rintanen, 1999a) extends SAT-plan approach
QBF, Gpt (Bonet & Geffner, 2000) encodes conformant planning heuristic
search. paper, propose new approach conformant planning, based Symbolic Model Checking (McMillan, 1993). Symbolic Model Checking formal verification
technique, allows one analyze finite state automata high complexity, relying
symbolic techniques, Binary Decision Diagrams (Bdds) (Bryant, 1986) particular,
compact representation ecient search automaton. approach builds
planning via model checking paradigm presented Cimatti colleagues (1997,
1998b, 1998a), finite state automata used represent complex, nondeterministic
planning domains, planning based (extensions of) basic model checking steps.
make following contributions.

First, present general algorithm conformant planning, applies

nondeterministic domain uncertain action effects initial condition, expressed
nondeterministic finite-state automaton. algorithm performs breadth-first
search, exploring plans increasing length, plan found candidate
plans available. algorithm complete, i.e. returns failure
problem admits conformant solution. problem admits solution,
algorithm returns conformant plan minimal length.

Second, provide symbolic representation search space based Binary

Decision Diagrams, allows application search techniques derived
symbolic model checking. symbolic representation makes possible analyze
sets transitions single computation step. sets compactly represented eciently manipulated despite potentially large cardinality.
way possible overcome enumerative nature approaches
conformant planning, degree nondeterminism tends limiting
factor.
306

fiConformant Planning via Symbolic Model Checking

Third, developed Cmbp (Conformant Model Based Planner), ecient

implementation data structures algorithm described above. Cmbp developed top Mbp, planner based symbolic model checking techniques
developed Cimatti, Roveri Traveso (1998b, 1998a). Cmbp implements several
new techniques, directly based Bdd manipulations, compact search layers
optimize termination checking.
Finally, provide experimental evaluation state-of-the-art conformant planners, comparing Cmbp Cgp, Qbfplan Gpt. difference
expressivity, problems tackled Cmbp represented planners. However, problems direct comparison
possible, Cmbp outperforms competitors. particular, features better
qualitative behavior, directly related number initial states uncertain
action effects, stable respect use heuristics.
paper structured follows. Section 2 review representation (nondeterministic) planning domains finite state automata. Section 3 provide
intuitions formal definition conformant planning setting. Section 4
present planning algorithm, Section 5 discuss symbolic representation
search space, allows ecient implementation. Section 6 present
Cmbp planner, Section 7 present experimental results. Section 8
discuss related work. Section 9 draw conclusions discuss future
research directions.
2. Planning Domains Finite State Automata

interested complex, nondeterministic planning domains, actions
preconditions, conditional effects, uncertain effects, initial state
partly specified. rest paper, use simple though paradigmatic domain
explanatory purposes, variation Moore's bomb toilet domain (McDermott,
1987) (from called BTUC | BT Uncertain Clogging). two packages,
one contains armed bomb. possible dunk either package
toilet (actions Dunk1 Dunk2 ), provided toilet clogged. Dunking either
package uncertain effect clogging toilet. Furthermore, dunking package
containing bomb effect disarming bomb. action F lush effect
unclogging toilet.
represent domains finite state automata. Figure 1 depicts automaton
BTUC domain. state given number, contains propositions holding
state. instance, state 1 represents state bomb package 1,
defused, toilet clogged. Given one bomb, write In2
abbreviation negation In1 . Arrows states depict transitions
automaton, representing possible behavior actions. transition state 2
state 1 labeled F lush represents fact action F lush, executed state
2, effect removing clogging. execution Dunk1 state 1,
uncertain effect clogging toilet, represented multiple transitions
states 5 6. Since transition outgoing state 2 labelled Dunk1 ,
307

fiCimatti & Roveri
Flush
Flush

Dunk_1
In_1 5
Defused
!Clogged

In_1 1
!Defused
!Clogged

Dunk_1,
Dunk_2

Dunk_2
Flush

Flush
In_1 2
!Defused
Clogged

In_1 6
Defused
Clogged

Flush
Flush

Dunk_2
In_2 7
Defused
!Clogged

3

In_2
!Defused
!Clogged

Dunk_1,
Dunk_2

Dunk_1
Flush

Flush
In_2 8
Defused
Clogged

In_2 4
!Defused
Clogged

Figure 1: automaton BTUC domain
state 2 satisfy preconditions action Dunk1 , i.e. Dunk1 applicable
state 2.
formally define nondeterministic planning domains follows.
Definition 1 (Planning Domain) Planning Domain 4-tuple = (P ; ; A; R),

P (finite) set atomic propositions, 2P set states,
(finite) set actions, R transition relation.



Intuitively, proposition state holds state. following
assume planning domain given. use s, s0 s00 denote states D,
denote actions. R(s; ff; s0 ) holds iff executing action state
state s0 possible outcome. say action applicable iff least
one state s0 R(s; ff; s0 ) holds. say action deterministic iff
unique state s0 R(s; ff; s0 ) holds. action uncertain outcome
least two distinct states s0 s00 R(s; ff; s0 ) R(s; ff; s00 )
hold. described Cimatti colleagues (1997), automaton given domain
eciently built starting compact description given expressive high level
action language, instance AR (Giunchiglia, Kartha, & Lifschitz, 1997).
3. Conformant Planning

Conformant planning (Goldman & Boddy, 1996) described problem finding
sequence actions guaranteed achieve goal regardless nondeterminism
domain. is, possible initial states, uncertain action effects,
execution plan results goal state.
Consider following problem BTUC domain. Initially, bomb armed
position status toilet uncertain, i.e. initial state
states f1; 2; 3; 4g . goal reach state bomb defused, toilet
308

fiConformant Planning via Symbolic Model Checking

In_1 1
!Defused
!Clogged

In_1 2
!Defused
Clogged

In_2 3
!Defused
!Clogged

In_2 4
!Defused
Clogged

In_1 5
Defused
!Clogged

Flush

Flush

Flush

Flush

In_1 5
Defused
!Clogged

Flush

Flush
In_1 1
!Defused
!Clogged

Dunk_1

In_1 6
Defused
Clogged

In_1 5
Defused
!Clogged

Dunk_2

In_1 6
Defused
Clogged

In_2 3
!Defused
!Clogged

Dunk_2

In_2 7
Defused
!Clogged

Flush
In_2 3
!Defused
!Clogged

Dunk_1

In_2 3
!Defused
!Clogged

In_2 4
!Defused
Clogged

Flush

In_2 8
Defused
Clogged

Flush

Flush

Flush

In_1 5
Defused
!Clogged

In_2 7
Defused
!Clogged

Flush

Figure 2: conformant solution BTUC problem
clogged, i.e. set goal states f5; 7g. conformant plan solving problem

F lush; Dunk1 ; F lush ; Dunk2 ; F lush
(1)
Figure 2 outlines possible executions plan, possible initial states
uncertain action effects. initial uncertainty lies fact domain might
states f1; 2; 3; 4g . possible initial states planning domain
collected set dashed line. call set belief state. Intuitively, belief
state expresses condition uncertainty domain, collecting together
states indistinguishable point view agent reasoning
domain. first action, F lush, used remove possible clogging. reduces
uncertainty belief state f1; 3g. Despite remaining uncertainty (i.e. still
known package bomb is), action Dunk1 guaranteed applicable
precondition met states. Dunk1 effect defusing bomb
contained package 1, uncertain effect clogging toilet. resulting
belief state f3; 4; 5; 6g . following action, F lush, removes clogging, reducing
uncertainty belief state f3; 5g, guarantees applicability Dunk2 .
Dunk2 , bomb guaranteed defused, toilet might clogged (states
6 8 belief state f5; 6; 7; 8g ). final F lush reduces uncertainty belief
state f5; 7g, guarantees achievement goal.
general, order plan conformant solution, action must executed
states satisfy preconditions, state result
execution plan (for initial states uncertain action effects)
goal state. main diculty achieving conditions information
(assumed be) available run-time. Therefore, planning time face problem
reasoning action execution belief state, i.e. condition uncertainty.
Definition 2 (Action Applicability) Let Bs Belief State. action
applicable Bs iff Bs 6= ; applicable every state 2 Bs.
309

fiCimatti & Roveri
order action applicable belief state, require preconditions
must guaranteed notwithstanding uncertainty. words, reject \reckless"
plans, take chance applying action without guarantee applicability.
choice strongly motivated practical domains, possibly fatal consequences
follow attempt apply action preconditions might satisfied
(e.g. starting fix electrical device without sure powered). effect
action execution uncertain condition defined follows.
Definition 3 (Action Image) Let Bs belief state, let action applicable Bs. image (also called execution) Bs, written Image [ff](Bs), defined

follows.

Image [ff](Bs) =_

fs0 j exists 2 Bs R(s; ff; s0 )g

Notice image action combines uncertainty belief state uncertainty action effects. (Consider instance Image [Dunk1 ](f1; 3g)=f3; 4; 5; 6g .)
following, write Image [ff](s) instead Image [ff](fsg).
Plans elements , i.e. finite sequences actions. use 0-length
plan, denote generic plans, ; plan concatenation. notions
applicability image generalize plans follows.
Definition 4 (Plan Applicability Image) Let 2 , let Bs . applicable Bs iff one following holds:
1. = Bs 6= ;;
2. = ff; , applicable Bs, applicable Image [ff](Bs).
image (also called execution) Bs, written Image [](Bs), defined as:
1. Image [](Bs) =_ Bs;
2. Image [ff; ](Bs) =_ Image [](Image [ff](Bs));

planning problem formally characterized set initial goal states.
following definition captures intuitive meaning conformant plan given above.
Definition 5 (Conformant Planning) Let = (P ; ; A; R) planning domain.
Planning Problem triple (D; ; G ), ; 6= ; 6= G .
plan conformant plan (that is, conformant solution to) planning
problem (D; ; G ) iff following conditions hold:

(i) applicable ;
(ii) Image [](I ) G .
following, clear context, omit domain planning
problem, simply write (I ; G ).
310

fiConformant Planning via Symbolic Model Checking
4. Conformant Planning Algorithm

conformant planning algorithm based exploration space plans, limiting
exploration plans conformant construction. algorithm builds Belief
state-Plan (BsP) pairs form hBs : i, Bs non-empty belief state
plan. idea use BsP pair associate explored plan maximal
belief state applicable, guaranteed result goal states.
exploration based basic function SPreImage [ff](Bs), that, given belief state
Bs action ff, returns belief state containing states applicable,
whose image contained Bs.
Definition 6 (Strong Pre-Image) Let ; 6= Bs belief state let
action. strong pre-image Bs ff, written SPreImage [ff](Bs), defined
follows.

SPreImage [ff](Bs) =_ fs j applicable s; Image [ff](s)

Bsg

SPreImage [ff](Bs) empty, applicable it, conformant solution problem (SPreImage [ff](Bs); Bs). Therefore, plan conformant
solution problem (Bs; G ), plan ff; conformant solution problem
(SPreImage [ff](Bs); G ).
Figure 3 depicts space BsP pairs built algorithm solving BTUC
problem. levels built goal, right, towards initial states,
left. level 0, BsP pair hf5; 7g : i, composed set goal states indexed
0-length plan . (Notice conformant solution every problem goal set
f5; 7g initial states contained f5; 7g.) dashed arrows represent application
SPreImage . level 1, BsP pair hf5; 6; 7; 8g : F lushi built, since strong
pre-image belief state 0 actions Dunk1 Dunk2 empty. level 2,
three BsP pairs, (overlapping) belief states Bs2 , Bs3 Bs4 , indexed, respectively,
length 2 plans Dunk1 ; F lush, F lush; F lush Dunk2 ; F lush. (A plan associated
belief state Bsi sequence actions labeling path Bsi Bs0 .) Notice
Bs3 equal Bs1 , therefore deserves expansion. expansion
belief states 2 4 gives belief states 5 6, obtained strong pre-image
F lush, strong pre-image actions Dunk1 Dunk2 returns empty
belief states. expansion Bs5 results three belief states. one resulting
strong pre-image F lush reported, since equal Bs5 . Belief state
7 equal Bs2 , deserves expansion. Belief state 8 obtained
expanding Bs5 Bs6 . level 5, expansion produces Bs10 , contains
initial states. Therefore, corresponding plans conformant solutions
problem.
conformant planning algorithm ConformantPlan presented Figure 4.
takes input planning problem form set states G (the domain
assumed globally available). algorithm performs backwards breadth-first
search, exploring BsP pairs corresponding plans increasing length step.
status search (each level Figure 3) represented BsP table, i.e. set BsP
pairs
BsPT = fhBs1 : 1 i; : : : ; hBsn : n ig
311

fiCimatti & Roveri
Level

5

4

3

2

1

0

In_1 1
!Defused
!Clogged

In_1 1
!Defused
!Clogged
Dunk_1

In_1 1
!Defused
!Clogged

In_1 5
Defused
!Clogged

In_1 2
!Defused
Clogged

In_2 7
Defused
!Clogged

In_1 5
Defused
!Clogged

In_1 1
!Defused
!Clogged
Flush

In_1 5
Defused
!Clogged

Dunk_1

Bs 7

In_1 6
Defused
Clogged

In_1 2
!Defused
Clogged

In_2 7
Defused
!Clogged
Bs 2

In_2 3
!Defused
!Clogged

In_1 1
!Defused
!Clogged

In_2 4
!Defused
Clogged

In_2 3
!Defused
!Clogged

Flush

In_1 5
Defused
!Clogged

In_1 5
Defused
!Clogged

In_1 6
Defused
Clogged

In_2 7
Defused
!Clogged

In_2 7
Defused
!Clogged

In_1 5
Defused
!Clogged

Dunk_2
In_2 8
Defused
Clogged

In_1 6
Defused
Clogged

Bs 5

In_2 3
!Defused
!Clogged

Flush

In_1 6
Defused
Clogged

In_2 7
Defused
!Clogged

In_2 7
Defused
!Clogged

In_2 8
Defused
Clogged

In_2 8
Defused
Clogged

Flush

In_1 5
Defused
!Clogged

In_2 7
Defused
!Clogged
Bs 0

Dunk_1

Bs 8

In_1 5
Defused
!Clogged

In_2 4
!Defused
Clogged

Bs 3

Bs 1

7

In_2
Defused
!Clogged

In_1 5
Defused
!Clogged

In_2 3
!Defused
!Clogged

8

In_2
Defused
Clogged

Bs 10

In_2 3
!Defused
!Clogged

In_1 5
Defused
!Clogged

Flush

In_1 6
Defused
Clogged
Dunk_2

In_1 5
Defused
!Clogged

Dunk_2

In_2 7
Defused
!Clogged

In_2 7
Defused
!Clogged

Bs 4

In_2 7
Defused
!Clogged

In_2 8
Defused
Clogged
Bs 9

Bs 6

Figure 3: BsP tables BTUC problem
plans length, 6= j 1 j 6=i n.
call Bsi belief set indexed . ambiguity arises, write BsPT(i )
Bsi. array BsPTables used store BsP tables representing levels
search. algorithm first checks (line 4) plans length 0, i.e.
solution. conformant plan length exists ((P lans = ;) line 4),
loop entered. iteration, conformant plans increasing length explored
(lines 5 8). step line 6 expands BsP table BsPTables[i 1] stores
resulting BsP table BsPTables[i]. BsP pairs redundant respect
current search eliminated BsPTables[i] (line 7). possible solutions contained
BsPTables[i] extracted stored P lans (line 8). loop terminates either
plan found (P lans 6= ;), space conformant plans completely explored
(BsPTables[i] = ;).
definitions basic functions used algorithm reported Figure 5.
function ExpandBsPTable expands BsP table provided argument, containing
conformant plans length 1, returns BsP table conformant plans length
i. BsP input BsP table expanded ExpandBsPPair. possible
312

fiConformant Planning via Symbolic Model Checking

0
1
2
3
4
5
6
7
8
9
10
11
12
13

function ConformantPlan(I ,G )
begin

= 0;
BsPTables[0] := f hG : g;
Plans := ExtractSolution(I ; BsPTables[0]);
((BsPTables[i] 6= ;) ^ (P lans = ;))
:= + 1;
BsPTables[i] := ExpandBsPTable(BsPTables[i-1]);
BsPTables[i] := PruneBsPTable(BsPTables[i]; BsPTables; i);
Plans := ExtractSolution(I ; BsPTables[i]);

done
(BsPTables[i] = ;)
return Fail;
else return Plans;
end

Figure 4: conformant planning algorithm.
action ff, strong pre-image Bs computed, resulting belief state Bs0
empty, i.e. belief state guarantees achievement Bs,
plan extended hBs0 : ff; returned. expansion BsP table
union expansions BsP pair. function ExtractSolution takes
input BsP table returns (possibly empty) set plans index belief states
containing . PruneBsPTable takes input BsP table pruned, array
previously constructed BsP tables BsPTables, index current step. removes
BsP table input plans worth explored
corresponding belief states already visited.
algorithm following properties. First, always terminates. follows
fact set explored belief sets (stored BsPTables) monotonically
increasing | step proceed least one new belief state generated.
finiteness (the set accumulated belief states contained 2S
finite), fix point eventually reached. Second, correct, i.e. plan returned
conformant solution given problem. correctness algorithm follows
properties SPreImage : plan associated belief state
conformant, i.e. guaranteed applicable results
belief state contained goal. Third, algorithm optimal, i.e. returns plans
minimal length. property follows breadth-first style search. Finally,
algorithm able decide whether problem admits solution, returning Fail
cases. Indeed, conformant solution always associated belief state containing
initial states. SPreImage generates maximal belief state associated conformant
plan, new belief state generated exploration compared initial states
check solution, plan pruned equivalent plan already
explored.
313

fiCimatti & Roveri

(BsPT) =_

ExpandBsPTable

[
hBs : i2BsPT

(hBs : i)

ExpandBsPPair

(hBs : i) =_ fhBs0 : ff; ij Bs0 = SPreImage [ff](Bs) 6= ;g

ExpandBsPPair

(BsPT; BsPTables; i) =_
fhBs : 2 BsPT j j < i; hBs : 0 2 BsPTables[j ] (Bs0 = Bs)g
PruneBsPTable

(I ; BsPT) =_ f j exists hBs : 2 BsPT Bsg

ExtractSolution

Figure 5: primitives used conformant planning algorithm.
5. Conformant Planning via Symbolic Model Checking

Model checking formal verification technique based exploration finite state
automata (Clarke, Emerson, & Sistla, 1986). Symbolic model checking (McMillan, 1993)
particular form model checking using Binary Decision Diagrams compactly represent
eciently analyze finite state automata. introduction symbolic techniques
model checking led breakthrough size model could analyzed (Burch
et al., 1992), made possible model checking routinely applied industry,
especially logic circuits design (for survey see Clarke & Wing, 1996).
rest section, provide overview Binary Decision Diagrams,
describe representation planning domains, based Bdd-based
representation finite state automata used model checking. Then, discuss
extension allows symbolically represent BsP tables transformations, thus
allowing ecient implementation algorithm described previous section.
5.1 Binary Decision Diagrams

Reduced Ordered Binary Decision Diagram (Bryant, 1992, 1986) (improperly called Bdd)
directed acyclic graph (DAG). terminal nodes either rue F alse. nonterminal node associated boolean variable, two Bdds, called left right
branches. Figure 6 (a) depicts Bdd (a1 $ b1 ) ^ (a2 $ b2 ) ^ (a3 $ b3 ).
non-terminal node, right [left, respectively] branch depicted solid [dashed, resp.]
line, represents assignment value rue [F alse, resp.] corresponding
variable. Bdd represents boolean function. given truth assignment variables
Bdd, value function determined traversing graph root
leaves, following branch indicated value assigned variables1.
1. path root leaf visit nodes associated subset variables Bdd.
See instance path associated a1 ; :b1 Figure 6(a).

314

fiConformant Planning via Symbolic Model Checking

a1

a1

b1

a2

b1

a3

a2

b2

b2

b1

b1

a3

b1

b2

a3

a2

a3

b1

b1

b2

a3

b1

b2

b1

b2

b3

b3

b3

b3

True

False

True

False

(a)

b1

(b)

Figure 6: Two Bdds formula (a1 $ b1 ) ^ (a2 $ b2 ) ^ (a3 $ b3 ).
reached leaf node labeled resulting truth value. v Bdd, size jvj
number nodes. n node, var(n) indicates variable indexing node n.
Bdds canonical representation Boolean functions. canonicity follows
imposing total order < set variables used label nodes,
node n respective non-terminal child m, variables must ordered, i.e. var(n) <
var(m), requiring Bdd contains isomorphic subgraphs.
Bdds combined usual boolean transformations (e.g. negation, conjunction, disjunction). Given two Bdds, instance, conjunction operator builds
returns Bdd corresponding conjunction arguments. Substitution
represented Bdd transformations. following, v variable,
Bdds, indicate [v= ] Bdd resulting substitution v .
v1 v2 vectors (the number of) distinct variables, indicate [v1 =v2 ]
parallel substitution variables vector v1 (corresponding) variables
v2 .
Bdds allow transformations described quantifications, style Quantified Boolean Formulae (QBF). QBF definitional extension propositional logic,
propositional variables universally existentially quantified. terms Bdd
computations, quantification corresponds tranformation mapping Bdd
variable vi quantified Bdd resulting (propositional) formula.
formula, vi one variables, existential quantification vi , written
9vi:(v1 ; : : : ; vn ), equivalent (v1; : : : ; vn )[vi=F alse] _ (v1; : : : ; vn )[vi=T rue]. Analogously, universal quantification 8vi :(v1 ; : : : ; vn ) equivalent (v1 ; : : : ; vn )[vi =F alse]^
315

fiCimatti & Roveri
(v1 ; : : : ; vn )[vi =T rue]. QBF, quantifiers arbitrarily applied nested. general, QBF formula equivalent propositional formula, conversion subject
exponential blow-up.
time complexity algorithm computing truth-functional boolean transformation f1 <op> f2 O(jf1 j jf2 j). far quantifications concerned, time
complexity quadratic size Bdd quantified, linear number
variables quantified, i.e. O(jvj jf j2 ) (Bryant, 1992, 1986).
Bdd packages ecient implementations data structures algorithms (Brace
et al., 1990; Somenzi, 1997; Yang et al., 1998; Coudert et al., 1993). Basically, Bdd package deals single multi-rooted DAG, node represents boolean function.
Memory eciency obtained using \unique table", sharing common subgraphs
Bdds. unique table used guarantee time isomorphic subgraphs redundant nodes multi-rooted DAG. creating
new node, unique table checked see node already present,
case new node created stored unique table. unique table
allows perform equivalence check two Bdds constant time (since two
equivalent functions always share subgraph) (Brace et al., 1990; Somenzi, 1997).
Time eciency obtained maintaining \computed table", keeps track
results recently computed transformations, thus avoiding recomputation.
critical computational factor Bdds order variables used. (Figure 6
shows example impact change variable ordering size Bdd.)
certain class boolean functions, size corresponding Bdd exponential
number variables possible variable ordering (Bryant, 1991). many practical
cases, however, finding good variable ordering rather easy. Beside affecting memory
used represent Boolean function, finding good variable ordering big impact
computation times, since complexity transformation algorithms depends
size operands. Bdd packages provide heuristic algorithms finding good
variable orderings, called try reduce overall size stored Bdds.
reordering algorithms activated dynamically package, Bdd
computation, total number nodes package reaches predefined threshold
(dynamic reoredering).
5.2 Symbolic Representation Planning Domains
planning domain (P ; ; A; R) represented symbolically using Bdds, follows.

set (distinct) Bdd variables, called state variables, devoted representation
states domain. variables direct association proposition
domain P used description domain. instance, BTUC
domain, In1 , Defused Clogged associated unique Bdd variable.
following write x vector state variables. particular order
irrelevant performance issues, rest section distinguish
proposition corresponding Bdd variable.
state set propositions P (specifically, propositions intended
hold it). state s, corresponding assignment state variables
x , i.e. assignment variable corresponding proposition p 2 assigned
316

fiConformant Planning via Symbolic Model Checking
rue, variable assigned F alse. represent Bdd (s),
assignment unique satisfying assignment. instance, (6) =_ (In1 ^
Defused ^ Clogged) Bdd representing state 6, (4) =_ :In1 ^ :Defused ^
Clogged represents state 4, on. (Without loss generality, following
distinguish propositional formula corresponding Bdd.) representation
naturally extends set states Q follows:
(Q) =_

_ (s)

s2Q

words, associate set states generalized disjunction Bdds
representing states. Notice satisfying assignments (Q)
exactly assignment representations states Q. representation mechanism
natural. instance, Bdd (I ) representing set initial states
BTUC =_ f1; 2; 3; 4g :Defused, set goal states G =_ f5; 7g
corresponding Bdd Defused ^ :Clogged. Bdd used represent set
states domain automaton. BTUC, (S ) = rue = 2P .
different formulation, two independent propositions In1 In2 used represent
position bomb, (S ) would Bdd In1 $ :In2 .
general, Bdd represents set (states correspond to) models.
consequence, set theoretic transformations naturally represented propositional
operations, follows.
(SnQ)
=_ (S ) ^ : (Q)
(Q1 [ Q2 ) =_ (Q1 ) _ (Q2 )
(Q1 \ Q2 ) =_ (Q1 ) ^ (Q2 )

main eciency symbolic representation lies fact cardinality
represented set directly related size Bdd. instance, (G ) uses
two (non-terminal) nodes represent two states, (I ) uses one node represent four
states. limit cases, (S ) (fg) (the leaf Bdds) rue F alse, respectively.
advantage, symbolic representation extremely ecient dealing irrelevant
information. Notice, instance, variable Defused occurs (f5; 6; 7; 8g ).
reason, symbolic representation dramatic improvement explicit,
enumerative representation. allows symbolic, Bdd-based model checkers
handle finite state automata large number states (see instance Burch
et al., 1992). following, collapse set states Bdd representing it.
Another set Bdd variables, called action variables, written , used represent
actions. use one action variable possible action A. Intuitively, Bdd action
variable true corresponding action executed. assume
sequential encoding used, i.e. concurrent actions allowed, use Bdd,
Seq(ff ), express exactly one action variables must true time2 .
2. specific case sequential encoding, alternative approach using dlog jAje possible:
assignment action variables denotes specific action executed. Two assignments
mutually exclusive, constraint Seq(ff ) needs represented. cardinality
set actions power two, standard solution associate one assignment
certain values. optimized solution, actually used implementation, described
sake simplicity.

317

fiCimatti & Roveri
BTUC problem, contains three actions, use three Bdd variables Dunk1 ,
Dunk2 F lush, express serial encoding constraint following Bdd:

Seq(ff) =_ (Dunk1 _ Dunk2 _ F lush) ^:(Dunk1 ^ Dunk2 ) ^:(Dunk1 ^ F lush) ^:(Dunk2 ^ F lush)

state variables, referring Bdd action variables symbolic names
sake simplicity. practice, internally represented integers,
position ordering Bdd package totally irrelevant logical terms.
Bdd variables x represents set state-action pairs, i.e. relation
states actions. instance, applicability relation BTUC (i.e.,
actions possible states, except dunking actions require toilet
clogged) represented Bdd :(Clogged ^ (Dunk1 _ Dunk2 )). Notice
represents set 16 state-action pairs, associating state applicable action.
transition 3-tuple composed state (the initial state transition),
action (the action executed), state (the resulting state transition).
represent transitions, another vector x 0 Bdd variables, called next state variables,
allocated Bdd package. write 0 (s) representation state
next state variables. 0 (Q) denote construction Bdd corresponding
set states Q, using variable next state vector x 0 instead current
state variables x . require jx j = jx 0 j, assume i-th variable x
i-th variable x 0 correspond. define representation set states next
variables follows.
0 (s) =_ (s)[x =xx0 ]
call operation [x =xx0 ] \forward shifting", transforms representation
set \current" states representation set \next" states. dual operation
[x 0 =xx] called backward shifting. following, call x current state variables
distinguish next state variables. transition represented assignment
x , x 0 . BTUC, transition corresponding application action
Dunk1 state 1 resulting state 5 represented following Bdd
(h1; Dunk1 ; 5i) =_ (1) ^ Dunk1 ^ 0 (5)
transition relation R automaton corresponding planning domain
simply set transitions, thus represented Bdd Bdd variables x ,
x0 , satisfying assignment represents possible transition.
_
(R) =_ Seq(ff ) ^ (t)
t2R

rest paper, assume Bdd representation planning domain
given. particular, assume given vectors variables x ;xx0 ;ffff, encoding
functions 0 , simply call , R, G Bdd representing states
domain, transition relation, initial states goal states, respectively. write
(v) stress Bdd depends variables v. representation,
possible reason plans, simulating symbolically execution sets actions
sets states, means QBF transformations. Bdd representing applicability
relation directly obtained following computation.
ff) =_ 9x 0 :R(x ;ffff;xx0 )
Applicable(x ;ff
318

fiConformant Planning via Symbolic Model Checking
resulting Bdd, Applicable(x ;ffff), represents set state-action pairs
action applicable state. Bdd representing states reachable Q
one step obtained following computation.

9x:9ff:(R(x ;ffff;xx0 )^Q(x))[x 0=xx]
Notice that, single operation, symbolically simulate effect application
applicable action states Q. Similarly, following transformation allows symbolically compute SPreImage set states Q possible
actions one single computation:

8x0:(R(x ;ffff;xx0 ) ! Q(x )[x=xx0 ]) ^

(x ;ffff)

Applicable

resulting Bdd represents state-action pairs hx : ffi applicable
x execution x results states Q.
5.3 Symbolic Search Space Belief States

main strength symbolic approach allows perform symbolic breadthfirst search, provides way compactly representing eciently expanding
frontier. instance, plans constructed symbolic breadth-first search
space states, repeatedly applying strong pre-image goal states (Cimatti et al.,
1998b). However, machinery presented previous section cannot directly applied
tackle conformant planning. basic difference conformant planning
searching space belief states3 , therefore frontier search basically
set sets states. introduce way symbolically represent BsP tables. Basically,
seen construction demand, based algorithm steps, increasingly
large portions space belief states. key intuition BsP table

fhfs11 ; : : : ; s1n1 g : 1i; : : : ; hfsk1 ; : : : ; skn g : k ig
k

represented relation plans (of length) states, associating
plan directly state belief state indexed plan, follows:

fhs11 : 1i; : : : ; hs1n1 : 1i; : : : ; hsk1 : k i; : : : ; hskn : k ig
k

(2)

use additional variables represent plans BsP tables. order represent
plans increasing length, step algorithm, vector new Bdd variables,
called plan variables, introduced. vector plan variables introduced i-th step
algorithm written [i], j [i]j = jff j, used encode i-th last action
plan4. step one algorithm, introduce vector plan variables [1]
represent action corresponding 1-length possible conformant plan. BsP
3. principle, machinery symbolic search could used conformant planning applied
determinization domain automaton, i.e. automaton 2S state space. However,
would require introduction exponential number state variables, impractical
even small domains.
4. search performed backwards, plans need reversed found.

319

fiCimatti & Roveri
table BsPT1 level 1 built ExpandBsPTable performing following Bdd
computation starting BsP table level 0, i.e. G (x ):
(8x 0 :(R(x ;ffff;xx0 ) ! G (x )[x =xx0 ]) ^ Applicable(x ;ffff))[ff = [1]]
computation collects state-action pairs hx : (the action represented
by) applicable (the state represented by) x , resulting (states
represented by) x 0 goal states. replace vector action variables
first vector plan variables [1]. resulting Bdd, BsPT(x ; [1]), represents BsP
table containing plans length one form relation states plans
(2). general case, step 1, BsP table BsPTi 1 , associating belief states
plans length 1, represented Bdd state variables x plan
variables [i 1] ; : : : ; [1]. computation performed ExpandBsPTable step
implemented following Bdd transformation BsPTi 1
(8x 0 :(R(x ;ffff;xx0 ) ! BsPTi 1 (x ; [i 1]; : : : ; [1] )[x =xx0 ]) ^ Applicable(x ;ffff))[ff = [i]](3)
next state variables R BsPTi 1 (resulting forward shifting) disappear
universal quantification. action variables renamed newly
introduced plan variables [i], next step algorithm construction
repeated.
ExtractSolution extracts assignments plan variables corresponding set contains initial states. terms Bdd transformations, ExtractSolution
implemented follows:
8x:(I (x) ! BsPTi(x; [i]; : : : ; [1]))
(4)
result Bdd plan variables [i]; : : : ; [1]. Bdd F alse,
solutions length i. Otherwise, satisfying assignments resulting Bdd
represents conformant solution problem.
guarantee termination algorithm, step BsP table returned
ExpandBsPTable simplified PruneBsPTable removing belief states
deserve expansion. requires comparison belief states
contained BsP table belief states contained BsP tables built
previous levels. one crucial steps terms eciency. earlier implementation step logical Bdd transformations, following directly set-theoretical
definition PruneBsPTable, extremely inecient (Cimatti & Roveri, 1999). Furthermore, noticed serial encoding could yield BsP tables containing large
number equivalent plans, indexing exactly belief state. Often equivalent plans differ order independent actions, potential source
combinatorial explosion. occurs even simple version BTUC (in Figure 3,
two equivalent conformant plans associated Bs8 ). Therefore, developed new
implementation could tackle two problems operating directly BsP
table. idea depicted Figure 7. Initially, cache contains Bs1 , Bs2 Bs3 .
simplification performs traversal Bdd, accumulating subtrees representing
belief states, comparing ones built previous levels, inserting new
ones cache (in Figure 7, Bs4 , Bs5 Bs6 ). time path identified
320

fiConformant Planning via Symbolic Model Checking
BsP Table

Bs4

Bs2

Bs5

Pruned BsP Table

Bs6

Bs4

Bs5

Cached Belief States
Bs1

Bs2

Bs6

Cached Belief States

Bs3

Bs1

Bs2

Bs3

Bs4

Bs5

Bs6

Figure 7: example pruning BsP table
represents plan indexing already cached belief state, plan redundant
corresponding path pruned5. cost simplification linear size BsP
simplified highly effective pruning.
6. CMBP: BDD-based Conformant Planner

Cmbp (Conformant Model Based Planner) conformant planner implementing data
structures algorithms conformant planning described previous sections. Cmbp
inherits features Mbp (Cimatti et al., 1997, 1998b, 1998a), planner based
symbolic model checking techniques. Mbp built top NuSMV, symbolic model
checker jointly developed ITC-IRST CMU (Cimatti et al., 2000), uses
CUDD (Somenzi, 1997) state-of-the-art Bdd package. Mbp two-stage system.
first stage, internal Bdd-based representation domain built,
second stage planning problems solved. Currently, planning domains described
means high-level action language AR (Giunchiglia et al., 1997). AR allows
specify (conditional uncertain) effects actions means high level assertions.
instance, Figure 8 shows AR description BTUC problem6. semantics
AR yields serial encoding, i.e. exactly one action assumed executed

5. pruning mechanism actually weaker earlier one (Cimatti & Roveri, 1999).
require belief state must expanded twice search, earlier
version prune belief states contained previously explored ones. may increase number
explored belief states. However, allows much ecient implementation, without impacting
properties algorithm.
6. ! & stand negation conjunction, respectively. description slightly edited sake
readability. particular, Mbp currently accept parameterized AR descriptions. practice
use script language generate ground instances different complexity parameterized problem
description.

321

fiCimatti & Roveri

DOMAIN BTUC
ACTIONS Dunk_1, Dunk_2, Flush;
FLUENTS In_1, In_2, Defused, Clogged : boolean;
INERTIAL Clogged, Defused, In_1, In_2;
ALWAYS In_1 <-> !In_2;
Flush CAUSES !Clogged;
[1, 2] {
Dunk_<i> PRECONDITIONS !Clogged;
Dunk_<i> CAUSES Defused In_<i>;
Dunk_<i> POSSIBLY CHANGES Clogged;
}
INITIALLY !Defused;
CONFORMANT Defused & !Clogged;

Figure 8: AR description BTUC problem
time. automaton corresponding AR description obtained means
minimization procedure Giunchiglia (1996). procedure solves frame problem
ramification problem, eciently implemented Mbp (Cimatti et al., 1997).
separation domain construction planning phases, Mbp
bound AR. Standard deterministic domains specified Pddl (Ghallab et al.,
1998) given Mbp means (prototype) compiler. starting
investigate potential use C action language (Giunchiglia & Lifschitz, 1998),
allows represent domains parallel actions.
Different planning algorithms applied specified planning problems.
operate solely automaton representation, completely independent
particular language used specify domain. Mbp allows automatic construction
conditional plans total observability, implementing algorithms strong planning (Cimatti et al., 1998b), strong cyclic plannig (Cimatti et al., 1998a; Daniele,
Traverso, & Vardi, 1999). Cmbp, implemented ideas described previous
sections. primitives construct prune BsP tables required lot tuning,
particular ordering Bdd variables. found general ordering strategy
works reasonably well: action variables positioned top ordering, followed
plan variables, followed state variables, current state next state variables interleaved. specific ordering within action variables, plan variables, state variables
determined standard mechanism implemented NuSMV. Cmbp implements several
algorithms conformant planning. addition backward algorithm presented
322

fiConformant Planning via Symbolic Model Checking
Section 4, Cmbp implements algorithm based forward search, allows exploit
initial knowledge problem, sometimes resulting significant speed ups (Cimatti
& Roveri, 2000). Backward forward search combined, tackle exponential growth search time depth search. algorithms,
different options enable disable different versions termination check.
7. Experimental Evaluation

section present experimental evaluation approach, carried
comparing Cmbp state-of-the-art conformant planners. first describe
conformant planners considered analysis, present experimental
comparison carried out.
7.1 Conformant Planners

Cgp (Smith & Weld, 1998) extends ideas Graphplan (Blum & Furst, 1995, 1997)
deal uncertainty. Basically, planning graph built every possible sequence possible worlds, constraints among planning graphs propagated ensure conformance.
Cgp system takes input domains described extension Pddl (Ghallab et al.,
1998), possible specify uncertainty initial state. Cgp inherits
Graphplan ability deal parallel actions. Cgp first ecient conformant planner: shown outperform several planners Buridan (Peot,
1998) UDTPOP (Kushmerick, Hanks, & Weld, 1995). detailed comparison reported Smith Weld (1998) leaves doubt superiority Cgp respect
systems. Therefore, compared Cmbp Cgp consider
systems analyzed Smith Weld (1998). Cmbp expressive Cgp two
respects. First, Cgp handle uncertainty initial state. instance, Cgp
cannot analyze BTUC domain presented Section 3. Smith Weld (1998) describe
approach extended actions uncertain effects. Second, Cgp cannot
conclude planning problem conformant solutions.
Qbfplan (our name for) planning system Rintanen (1999a). Qbfplan generalizes idea SAT-based planning (Kautz, McAllester, & Selman, 1996; Kautz & Selman,
1996, 1998) nondeterministic domains, encoding problems QBF. Qbfplan
approach limited conformant planning, used conditional planning
uncertainty, partial observability: different encodings, corresponding
different structures resulting plan, synthesized. paper,
considering encodings enforce resulting plan sequence. Given bound
length plan, first QBF encoding problem generated, QBF
solver (Rintanen, 1999b) called. solution found, new encoding longer plan
must generated solved. Qbfplan able handle actions uncertain effects.
done introducing auxiliary (choice) variables, assignments different possible outcomes actions correspond. variables universally quantified
ensure conformance solution. Differently e.g. Blackbox (Kautz & Selman,
1998), Qbfplan heuristic guess \right" length plan. Given
limit length plan, generates encodings specified length,
repeatedly calls QBF solver encodings increasing length plan found.

323

fiCimatti & Roveri
Cgp, Qbfplan cannot conclude planning problem conformant solutions.
Similarly Cmbp, Qbfplan relies symbolic representation problem, although
QBF transformations performed theorem prover rather Bdds.
Gpt (Bonet & Geffner, 2000) general planning framework, conformant
planning problem seen deterministic search problem space belief states. Gpt
uses explicit representation search space, belief state represented
separate data structure. search based algorithm (Nilsson, 1980),
driven domain dependent heuristics automatically generated problem
description. Gpt accepts problem descriptions syntax based Pddl, extended deal
probabilities uncertainty. possible represent domains uncertain action
effects (although representation actions resulting large number different states
rather awkward). planning algorithm, Gpt able conclude given
planning problem conformant solution exhaustively exploring space belief
states.
7.2 Experiments Results

evaluation performed running systems number parameterized problem domains. considered problems Cgp Gpt distributions, plus
problems defined test specific features planners. considered
domains uncertainty limited initial state, domains uncertain action
effects. Besides problems admitting solution, considered problems admitting
solution, case measured effectiveness plannner returning
failure.
Given different expressivity, possible run systems
examples. Cmbp run classes examples, Gpt run one.
Cgp run problems admit solution, uncertainty limited
initial condition. Qbfplan run examples encoding
already available Qbfplan distribution. subset problems
expressible Cgp. main limiting factor low level input format
Qbfplan: problem descriptions must specified ML code generates QBF
encodings. Writing new encodings turned dicult task, especially due
lack documentation.
ran Cgp, Qbfplan Cmbp Intel 300MHz Pentium-II, 512MB RAM,
running Linux. comparison Cmbp Gpt run Sun Ultra Sparc
270MHz, 128Mb RAM running Solaris (Gpt available binary). However,
performance two machines comparable | run times Cmbp almost
identical. CPU time limited 7200 sec (two hours) test. avoid swapping,
memory limit fixed physical memory machine. following,
write \|" \===" test complete within time memory
limits, respectively. performance systems reported tables listing
search time. excludes time needed Qbfplan generate encodings,
time spent Cmbp construct automaton representation Bdd, time
needed Gpt generate source code internal representation, compile
it. Overall, significant time ignored automaton construction Cmbp.
324

fiConformant Planning via Symbolic Model Checking
Currently, automaton construction fully optimized. Even complex
examples, however, construction never required couple minutes7.
7.2.1 Bomb Toilet

Bomb Toilet. first domain tackled classical bomb toilet,
notion clogging. call problem BT(p), parameter p

number packages. uncertainty initial condition,
known package contains bomb. goal defuse bomb. results
BT problem shown Table 1. columns relative Cmbp length
plan (jPj), number cached belief states number hits cache (#BS
#NBS respectively), time (expressed seconds) needed searching automaton
Pentium/Linux (Time(L)) Sparc/Solaris (Time(S)). following,
clear context, execution platform omitted. columns relative Cgp
number levels planning graphs (jLj) search time. column relative
Gpt search time.
BT(2)
BT(3)
BT(4)
BT(5)
BT(6)
BT(7)
BT(8)
BT(9)
BT(10)

jPj

2
3
4
5
6
7
8
9
10

Cmbp

#BS/#BSH
2/2
6 / 11
14 / 36
30 / 103
62 / 266
126 / 641
254 / 1496
510 / 3463
1022 / 7862

Time(L)
0.000
0.000
0.000
0.000
0.010
0.010
0.030
0.070
0.150

Time(S)
0.000
0.000
0.000
0.000
0.010
0.030
0.030
0.070
0.140

jLj
1
1
1
1
1
1
1
1
1

Cgp

Time
0.000
0.000
0.000
0.000
0.010
0.010
0.020
0.020
0.020

Gpt

Time
0.074
0.077
0.080
0.087
0.102
0.139
0.230
0.481
1.018

Table 1: Results BT problems.
BT problem intrinsically parallel, i.e. depth planning graph always
one, packages dunked time. Cgp inherits Graphplan ability deal parallel actions eciently, therefore almost insensitive
problem size. problem Cgp outperforms Cmbp Gpt. Notice
number levels explored Cgp always 1, length plan produced
Cmbp Cgp grows linearly. Cmbp performs slightly better Gpt.
Bomb Toilet Clogging. call BTC(p) extension BT(p)
dunking package (always) clogs toilet, ushing remove clogging, clogging precondition dunking package. Again, p number packages. toilet
initially clogged. modification, problem longer allows parallel
solution. results problem listed Table 2. impact depth
plan length becomes significant systems. Cmbp Gpt outperform Cgp.
case Cmbp performs better Gpt, especially large instances (see BTC(16)).
7. precisely, maximum time building automaton required BMTC(10,6) examples
(88 secs.), RING(10) example (77 secs.), BMTC(9,6) examples (40 secs.), BMTC(10,5)
examples (41 secs.). examples, time required automaton construction
less 10 seconds.

325

fiCimatti & Roveri
Qbfplan

BTC(2)
BTC(3)
BTC(4)
BTC(5)
BTC(6)
BTC(7)
BTC(8)
BTC(9)
BTC(10)

jPj

3
5
7
9
11
13
15
17
19

Cmbp

Cgp

#BS/#BSH Time(L) Time(S) jLj Time
6/8
0.000
0.010 3
0.000
14 / 23
0.000
0.000 5
0.010
30 / 61
0.010
0.010 7
0.030
62 / 150
0.020
0.020 9
0.130
126 / 347
0.020
0.020 11
0.860
254 / 796
0.070
0.080 13
2.980
510 / 1844
0.150
0.160 15 13.690
1022 / 4149
0.320
0.330 17 41.010
2046 / 9190
0.710
0.700 19 157.590

BTC(16) 31 131070 / 921355

99.200

99.800

Gpt

Time
0.074
0.077
0.082
0.094
0.113
0.166
0.288
0.607
1.309
351.457

BTC(6)
jPj Time
1
0.00
2
0.01
3
0.26
4
0.63
5
1.53
6
2.82
7
6.80
8
14.06
9
35.59
10
93.34
11 (+) 2.48

BTC(10)
Time
1
0.02
2
0.03
3
0.78
4
2.30
5
4.87
6
8.90
7
22.61
8
52.72
9
156.12
10
410.86
11 1280.88
13 3924.96
14
|

jPj

:::
:::
18
|
19 (+) 16.84

Table 2: Results BTC problems.
comparison Qbfplan limited 6 10 package instances (the ones available distribution package). performance Qbfplan reported left
table Table 2. line reports time needed decide whether plan
length i. performance Qbfplan rather good tackling encoding admitting solution (in Table 2 entries labeled (+)). instance, BTC(10)
Qbfplan finds solution solving encodings depth 19 reasonably fast. However,
solution cannot found, i.e. QBF formula admits model, performance
Qbfplan degrades significantly (for depth 18 encoding, let solver run 10
CPU hours complete search). difference performance,
diculty writing new domains, rest comparison consider
Qbfplan.
Bomb Multiple Toilets. next domain, called BMTC(p,t), generalization
BTC problem case multiple toilets (p number packages,
number toilets). problem becomes parallelizable number
toilets increases. Furthermore, considered three versions problem increasing
uncertainty initial states. first class tests (\Low Uncertainty" columns),
uncertainty position bomb unknown, toilets known
clogged. \Mid Uncertainty" \High Uncertainty" columns show results
presence uncertainty initial state. second [third, respectively] class
tests, status every odd [every, resp.] toilet either clogged clogged.
increases number possible initial states.
results reported Table 3 (for comparison Cgp) Table 4
(for comparison Gpt). column represents number initial states
corresponding problem. Cgp able fully exploit parallelism problem.
However, Cgp never able explore 9 levels planning graph, depth
decreasing number initial states. results show Cmbp Gpt
much less sensitive number initial states Cgp. increasing initial
326

fi(p,t)
(2,2)
(3,2)
(4,2)
(5,2)
(6,2)
(7,2)
(8,2)
(9,2)
(10,2)
(2,3)
(3,3)
(4,3)
(5,3)
(6,3)
(7,3)
(8,3)
(9,3)
(10,3)
(2,4)
(3,4)
(4,4)
(5,4)
(6,4)
(7,4)
(8,4)
(9,4)
(10,4)
(2,5)
(3,5)
(4,5)
(5,5)
(6,5)
(7,5)
(8,5)
(9,5)
(10,5)
(2,6)
(3,6)
(4,6)
(5,6)
(6,6)
(7,6)
(8,6)
(9,6)
(10,6)

bmtc


2
3
4
5
6
7
8
9
10
2
3
4
5
6
7
8
9
10
2
3
4
5
6
7
8
9
10
2
3
4
5
6
7
8
9
10
2
3
4
5
6
7
8
9
10

2
4
6
8
10
12
14
16
18
2
3
5
7
9
11
13
15
17
2
3
4
6
8
10
12
14
16
2
3
4
5
7
9
11
13
15
2
3
4
5
6
8
10
12
14

jPj

Low Uncertainty
Cmbp
#BS/#BSH Time
10 / 18 0.000
26 / 84 0.000
58 / 250 0.020
122 / 652 0.030
250 / 1552 0.070
506 / 3586 0.180
1018 / 8262 0.400
2042 / 18484 0.940
4090 / 40676 1.820
18 / 42 0.000
47 / 202 0.010
110 / 736 0.030
237 / 2034 0.080
492 / 5106 0.230
1003 / 12128 0.560
2026 / 27836 1.300
4073 / 62470 3.330
8168 / 138046 7.280
29 / 75 0.010
92 / 492 0.020
206 / 1686 0.060
457 / 4987 0.190
964 / 12456 0.410
1983 / 29453 1.040
4026 / 68466 2.740
8117 / 153895 6.690
16304 / 339160 14.420
43 / 117 0.010
164 / 1031 0.040
416 / 4304 0.150
872 / 11763 0.490
1875 / 31695 1.300
3901 / 78009 3.990
7974 / 183036 9.670
16142 / 416333 24.250
32501 / 927329 54.910
60 / 168 0.010
270 / 1848 0.070
786 / 9294 0.300
1777 / 29075 1.160
3613 / 71123 3.290
7625 / 180127 9.060
15726 / 429198 20.710
32012 / 986188 50.610
64675 / 2.21106e+06 111.830
Time
0.000
0.020
0.030
1.390
3.490
508.510
918.960
|
0.010
0.010
0.110
0.170
0.340
6248.010
|

Cgp

327

Mid Uncertainty
Cmbp

#BS/#BSH Time
4
12 / 34 0.000
6
28 / 106 0.000
8
60 / 286 0.020
10
124 / 702 0.030
12
252 / 1614 0.080
14
508 / 3662 0.190
16
1020 / 8362 0.430
18
2044 / 18602 0.960
20
4092 / 40810 1.990
8
24 / 99 0.000
12
56 / 349 0.020
16
120 / 942 0.040
20
248 / 2335 0.110
24
504 / 5520 0.250
28
101 / 12673 0.590
32
204 / 28530 1.350
36
408 / 63331 3.370
40
818 / 139092 7.460
8
29 / 75 0.000
12
108 / 808 0.030
16
236 / 2356 0.080
20
492 / 5888 0.230
24
1004 / 13648 0.470
28
2028 / 31004 1.120
32
4076 / 70584 2.870
36
8172 / 15654 6.900
40
16364 / 34234 14.630
16
43 / 117 0.010
24
212 / 2008 0.080
32
475 / 6375 0.260
40
987 / 15928 0.700
48
2011 / 37759 1.890
56
4059 / 86716 4.480
64
8155 / 195055 10.590
72
16347 / 432408 25.600
80
32731 / 948279 56.420
16
60 / 168 0.010
24
270 / 1848 0.070
32
920 / 13810 0.500
40
1958 / 37636 1.940
48
4005 / 90111 4.080
56
8100 / 208050 10.130
64
16291 / 469277 22.620
72 32674 / 1.04173e+06 53.510
80 65441 / 2.28585e+06 116.440
0.020
0.290
0.730
|

1 0.200
1 0.830
2 30.630
2 30.140
2 57.300
2
|

1 0.130
2 3.540
2 6.320
2 37,959
2
|

1
2
2
2

0.090
0.200
0.990
|

2
2
3
3

2
3
4
5
5

Time
0.010
0.040
0.460
13,180
|

Cgp

jLj

Table 3: Results BMTC problems.

1
0.000
1
0.010
1
0.010
3
0.500
3
1.160
3
2.410
3
8.540
4
|
1
0.010
1
0.020
1
0.020
1
0.050
3
5.920
3 18.410
3 62.040
3 194.640
3 289,680
1
0.010
1
0.010
1
0.040
1
0.060
1
0.100
3 211.720
3 1015.160
3 3051.990
2
|

1
3
3
5
5
7
7
7
1
1
3
3
3
5
4

jLj

High Uncertainty
Cmbp

#BS/#BSH Time
8
12 / 40 0.000
12
28 / 112 0.010
16
60 / 294 0.010
20
124 / 710 0.040
24
252 / 1622 0.080
28
508 / 3670 0.190
32
1020 / 8372 0.450
36
2044 / 18612 0.950
40
4092 / 40820 2.030
16
24 / 126 0.010
24
56 / 373 0.020
32
120 / 972 0.040
40
248 / 2371 0.120
48
504 / 5562 0.240
56
1016 / 12721 0.640
64
2040 / 28584 1.330
72
4088 / 63391 3.390
80
8184 / 139158 7.430
32
48 / 332 0.020
48
112 / 960 0.040
64
240 / 2532 0.090
80
496 / 6092 0.240
96
1008 / 13876 0.470
112
2032 / 31260 1.160
128
4080 / 70912 2.910
144
8176 / 156904 6.970
160
16368 / 342736 14.770
64
93 / 751 0.030
96
224 / 2591 0.120
128
480 / 6740 0.260
160
992 / 16393 0.730
192
2016 / 38334 1.980
224
4064 / 87411 4.540
256
8160 / 195880 10.640
288
16352 / 433373 25.370
320
32736 / 949394 56.290
128
171 / 1533 0.040
192
448 / 6248 0.310
256
960 / 16344 0.690
320
1984 / 39710 2.120
384
4032 / 92772 4.600
448
8128 / 211370 10.400
512
16320 / 473328 23.000
576 32704 / 1.04658e+06 54.010
640 65472 / 2.29158e+06 116.240
1.610
8.690
32.190
|

0.170
0.690
|

Time
0.030
13.560
145.830
|

Cgp

2 337.604
2 1459.110
2 5643.450
2
|

2 21.120
2 138.430
2 551.210
2 1523.840
2
|

2
2
2
3

2
2
3

2
4
4
4

jLj

Conformant Planning via Symbolic Model Checking

fiCimatti & Roveri
bmtc

(p,t)
(2,2)
(3,2)
(4,2)
(5,2)
(6,2)
(7,2)
(8,2)
(9,2)
(10,2)
(2,4)
(3,4)
(4,4)
(5,4)
(6,4)
(7,4)
(8,4)
(9,4)
(10,4)
(2,6)
(3,6)
(4,6)
(5,6)
(6,6)
(7,6)
(8,6)
(9,6)
(10,6)

Low Unc.

Cmbp

Time
0.000
0.010
0.000
0.040
0.080
0.190
0.390
0.910
1.850
0.000
0.010
0.050
0.180
0.370
1.080
2.700
8.970
14.210
0.010
0.050
0.310
1.110
3.400
8.910
21.240
49.880
113.680

Gpt

Time
0.079
0.087
0.105
0.146
0.227
0.441
0.922
2.211
5.169
0.109
0.156
0.270
0.616
1.435
3.484
8.767
23.858
59.966
0.303
0.562
1.354
3.257
8.691
25.677
68.427
289.000
486.969

High Unc.

Cmbp

Time
0.010
0.010
0.020
0.040
0.070
0.200
0.400
0.950
1.900
0.010
0.040
0.100
0.240
0.460
1.190
2.830
6.920
114.690
0.060
0.260
0.620
2.060
4.660
10.430
23.860
54.190
118.590

Gpt

Time
0.079
0.091
0.121
0.198
0.376
0.850
1.966
4.743
10.620
0.121
0.284
1.016
3.282
9.374
27.348
72.344
180.039
440.308
0.482
2.471
17.406
74.623
243.113
701.431
===

Table 4: Results BMTC problems.
uncertainty, Cgp almost unable solve trivial problems. Gpt performs better
Cgp, suffers explicit representation search space.
Bomb Toilet Uncertain Clogging. BTUC(p) domain domain
described Section 2, clogging uncertain outcome dunking package.
kind problem cannot expressed Cgp. results Cmbp Gpt reported
Table 5. Although Cmbp performs better Gpt (by factor two three),
significant difference behavior. interesting compare results Cmbp
BTC BTUC problems. Gpt slight difference noticeable, resulting
increased branching factor search space due uncertainties effects
action executions. performance Cmbp, number uncertainties direct
factor | example, BTC(16) BTUC(16), performance almost same.
7.2.2 Ring Rooms

Simple Ring Room. considered another domain, robot move
ring rooms. room window, either open, closed locked.
robot move (either clockwise counterclockwise), close window room
is, lock closed. goal windows locked.
328

fiConformant Planning via Symbolic Model Checking
Cmbp

jPj

BTUC(2)
BTUC(3)
BTUC(4)
BTUC(5)
BTUC(6)
BTUC(7)
BTUC(8)
BTUC(9)
BTUC(10)
BTUC(16)

#BS/#BSH
6/8
14 / 23
30 / 61
62 / 150
126 / 347
254 / 796
510 / 1844
1022 / 4149
2046 / 9190
131070 / 921355

3
5
7
9
11
13
15
17
19
31

Time
0.000
0.000
0.010
0.010
0.030
0.050
0.170
0.310
0.720
98.270

Gpt

Time
0.076
0.078
0.085
0.098
0.128
0.205
0.380
0.812
1.828
486.252

Table 5: Results BTUC problems.
N-1

N

1

2

problem RING(r), r number rooms, uncertainty
initial condition: position robot status windows
uncertain. problems parallel solution, large number initial
states (r 3r ), corresponding full uncertainty position robot
status window. results8 reported left Table 6. Cmbp outperforms
RING(2)
RING(3)
RING(4)
RING(5)
RING(6)
RING(7)
RING(8)
RING(9)
RING(10)

jPj

5
8
11
14
17
20
23
26
29

Cmbp

#BS/#BSH
8 / 24
26 / 78
80 / 240
242 / 726
728 / 2184
2186 / 6558
6560 / 19680
19682 / 59046
59048 / 177144

Time
0.000
0.020
0.040
0.120
0.370
1.420
4.950
27.330
106.870

jLj
3
4

Cgp

Time
0.070
|

Gpt

Time
0.085
0.087
0.392
1.150
6.620
23.636
105.158
===


1
2
4
8
16

Cgp RING(5)

jLj
5
5
5
5
5

Time
0.010
0.060
0.420
6.150
|

jLj
9
9
9
9
9

Time
0.020
0.140
1.950
359.680
|

Table 6: results RING problems.
Cgp Gpt, although Gpt performs much better Cgp. Cgp Gpt
suffer increasing complexity problem. right Table 6, plot (for
RING(5) problem) dependency Cgp number initial states combined
number levels explored (different goals provided require
exploration different levels). clear number initial states depth
search critical factors Cgp.
8. times reported Cgp refer scaled-down version problem, locking taken
account, thus maximum number initial states r 2r .

329

fiCimatti & Roveri
Ring Rooms Uncertain Action Effects. considered variation

RING domain, called URING, first introduced Cimatti Roveri (1999),
expressible Cgp. window locked robot performing action
determine status (e.g. closing it), window open close nondeterministically. instance, robot moving room 1 room 2, windows
room 3 4 could open closed wind. domain clearly designed stress
ability planner deal actions large number resulting states.
worst case (e.g. move action performed window locked), 2r possible
resulting states. Although seemingly artificial, captures fact environments
practice highly nondeterministic. tried compare Cmbp Gpt URING
problem. principle Gpt able deal uncertainty action effects. However,
failed codify URING Gpt language, requires conditional description uncertain effects. Therefore, experimented variation RING
domain featuring higher degree nondeterminism, called NDRING following.
NDRING domain contains increasing number additional propositions, called
following noninertial propositions, initially unknown nondeterministically
altered action. number noninertial propositions, action 2i
NDRING(2)
NDRING(3)
NDRING(4)
NDRING(5)
NDRING(6)
NDRING(7)
NDRING(8)
NDRING(9)
NDRING(10)

jPj

5
8
11
14
17
20
23
26
29

Cmbp

#BS/#BSH
8 / 24
26 / 78
80 / 240
242 / 726
728 / 2184
2186 / 6558
6560 / 19680
19682 / 59046
59048 / 177144

Time (5)
0.000
0.020
0.040
0.110
0.350
1.350
4.990
27.060
103.760

Time (2)
0.140
0.256
1.046
4.550
18.758
108.854
===

Gpt

Time (3)
0.384
0.679
3.025
12.960
57.300
===

Time (4)
0.948
2.574
12.548
48.426
===

Time (5)
4.544
13.960
67.714
===

Table 7: results NDRING problems.
possible outcomes. results listed Table 7, columns labeled Time(i).
growing branching factor search major impact performance
Gpt, Cmbp insensitive kind uncertainty. (The performance Cmbp
lower number noninertial propositions reported basically
same.)
URING problem run Cmbp. results listed Table 8.
noticed performances Cmbp improve significantly respect RING
problem. explained considering that, despite larger number transitions,
number explored belief states significantly smaller (see Bs cache statistics
Tables 6 8).
7.2.3 Square Cube

following domains SQUARE(n) CUBE(n) Gpt distribution (Bonet
& Geffner, 2000). problems consist robot navigating square cube side
n. domains actions moving robot possible directions.
Moving robot boundary leaves robot position. original
330

fiConformant Planning via Symbolic Model Checking

URING(2)
URING(3)
URING(4)
URING(5)
URING(6)
URING(7)
URING(8)
URING(9)
URING(10)

jPj
5
8
11
14
17
20
23
26
29

Cmbp

#BS/#BSH
5 / 16
11 / 34
23 / 70
47 / 142
95 / 286
191 / 574
383 / 1150
767 / 2302
1535 / 4606

Time
0.000
0.010
0.020
0.040
0.080
0.190
0.410
0.980
2.2300

Table 8: Results URING problems.
problems, called CORNER following, require robot reach corner, starting
completely unspecified position. introduced two variations. first, called
FACE, initial position position given side [face] square [cube],
goal reach central position opposite side [face]. second, called
CENTER, initial position completely unspecified, goal center
square [cube]. corner problem, simple heuristic perform steps towards
corner, thus pruning half actions. variations designed allow
simple heuristic | instance, CENTER problem, action eliminated.
SQUARE(i)
SQUARE(2)
SQUARE(4)
SQUARE(6)
SQUARE(8)
SQUARE(10)
SQUARE(12)
SQUARE(14)
SQUARE(16)
SQUARE(18)
SQUARE(20)
CUBE(i)
CUBE(2)
CUBE(3)
CUBE(4)
CUBE(5)
CUBE(6)
CUBE(7)
CUBE(8)
CUBE(9)
CUBE(10)
CUBE(15)

jPj

3
6
9
12
15
18
21
24
27
42

jPj

2
6
10
14
18
22
26
30
34
38

CORNER
Cmbp
#BS/#BSH Time
2 / 4 0.000
15 / 37 0.000
35 / 93 0.000
63 / 173 0.020
99 / 277 0.030
143 / 405 0.050
195 / 557 0.070
255 / 733 0.080
323 / 933 0.120
399 / 1157 0.160

CORNER
Cmbp
#BS/#BSH Time
6 / 19 0.000
26 / 99 0.010
63 / 261 0.020
124 / 537 0.040
215 / 957 0.050
342 / 1551 0.100
511 / 2349 0.160
728 / 3381 0.330
999 / 4677 0.440
3374 / 16167 1.940

Gpt

Time
0.332
0.168
0.430
0.276
0.500
0.567
1.082
1.765
2.068
9.207

Gpt

Time
0.074
0.080
0.092
0.115
0.149
0.196
0.261
0.357
0.503
0.638

jPj

3
6
11
14
19
22
27
30
35
54

jPj

2
7
12
17
22
27
32
37
42
47

FACE
Cmbp
#BS/#BSH Time
2 / 4 0.000
33 / 83 0.000
86 / 232 0.020
163 / 453 0.040
264 / 746 0.090
389 / 1111 0.150
538 / 1548 0.230
711 / 2057 0.320
908 / 2638 0.540
1129 / 3291 0.650

Gpt

Time
0.058
0.065
0.089
0.139
0.228
0.371
0.582
0.908
1.343
1.883

jPj

2
8
14
20
26
32
38
44
50
56

CENTER
Cmbp
#BS/#BSH Time
2 / 4 0.000
76 / 190 0.010
218 / 592 0.040
432 / 1210 0.090
718 / 2044 0.190
1076 / 3094 0.360
1506 / 4360 0.560
2008 / 5842 0.820
2582 / 7540 1.330
3228 / 9454 1.790

Gpt

Time
0.060
0.083
0.216
0.695
2.135
5.340
12.284
26.241
52.091
94.204

FACE
CENTER
Cmbp
Gpt
Cmbp
Gpt
#BS/#BSH Time Time jPj #BS/#BSH Time Time
6 / 19 0.000 0.061 3
6 / 19 0.010 0.061
26 / 99 0.000 0.069 6
26 / 99 0.010 0.144
319 / 1360 0.050 0.193 12
722 / 3091 0.130 0.569
709 / 3095 0.220 0.412 15
1696 / 7402 0.430 2.010
1343 / 6116 0.430 1.479 21 3365 / 15432 0.910 10.717
2255 / 10377 0.840 3.323 24 5797 / 26814 1.860 34.074
3519 / 16464 1.400 8.161 30 9248 / 43541 3.520 109.852
5169 / 24331 2.810 16.272 33 13786 / 65237 7.260 701.910
7279 / 34564 4.550 32.226 39 19667 / 93898 9.990
===
26439 / 127825 28.560
=== 60 74041 / 359354 58.930

Table 9: Results SQUARE CUBE problems.
results problems reported Table 9. tests run
Cmbp Gpt. experiments highlight eciency Gpt strongly depends
quality heuristic function. If, first set experiments, heuristics
331

fiCimatti & Roveri
effective, Gpt almost good Cmbp. Otherwise, Gpt degrades significantly.
general, finding heuristics effective belief space appears nontrivial
problem. Cmbp appears stable9 , performs blind, breadth-first search,
relies cleverness symbolic representation achieve eciency.
7.2.4 Omelette

Finally, considered OMELETTE(i) problem (Levesque, 1996). goal
good eggs bad ones one two bowls capacity i. unlimited number
eggs, unpredictably good bad. eggs grabbed broken
bowl. content bowl discarded, poured bowl. Breaking
rotten egg bowl effect spoiling bowl. bowl always cleaned
discarding content. problem originally presented partial observability
problem, sensing action allowing test bowl spoiled not. considered
variation problem without sensing action: case conformant solution
exists. used OMELETTE problems test ability Cmbp Gpt discover
problem admits conformant solution. results reported Table 10.
table shows Cmbp effective checking absence conformant solution,
outperforms Gpt several orders magnitude.
OMELETTE(3)
OMELETTE(4)
OMELETTE(5)
OMELETTE(6)
OMELETTE(7)
OMELETTE(8)
OMELETTE(9)
OMELETTE(10)
OMELETTE(15)
OMELETTE(20)
OMELETTE(30)

# steps
9
11
13
15
17
19
21
23
33
43
63

CMBP
#BS/#BSH
15 / 34
19 / 42
23 / 50
27 / 58
31 / 66
35 / 74
39 / 82
43 / 90
63 / 130
83 / 170
123 / 250

Time
0.020
0.030
0.040
0.050
0.060
0.090
0.110
0.120
0.210
0.440
0.890

GPT
Time
0.237
0.582
1.418
2.904
5.189
10.307
18.744
32.623
225.530
===

Table 10: Results OMELETTE problems.
7.3 Summarizing Remarks

Overall, Cmbp appears implement effective approach conformant planning,
terms expressivity performance. Cgp able deal uncertainties
initial states, cannot conclude problem admit conformant
solution. main problem Cgp seems enumerative approach uncertainties,
increased number initial states severely affects performance (see Table 3
Table 6).
Qbfplan principle able deal uncertain action effects, cannot conclude
problem admit conformant solution. small number ex9. Consider problems increasingly dicult (see instance plan length).

332

fiConformant Planning via Symbolic Model Checking
periments could perform, approach implemented Qbfplan limited
Satplan style search: intermediate results obtained solving encoding
depth k reused solving encodings increasing depth. Furthermore,
solver appears specialized finding model, rather proving unsatisfiability.
However, latter ability needed encodings final one.
Gpt expressive system, allows eciently dealing wide class
planning problems. far conformant planning concerned, expressive
Cmbp. allows dealing uncertain action effects, conclude problem
conformant solution. However, Cmbp appears outperform Gpt
several respects. First, behaviour Gpt appears directly related number
possible outcomes action. Furthermore, eciency Gpt depends
effectiveness heuristic functions, sometimes dicult devise,
cannot help problem admit solution.
main strength Cmbp independence number uncertainties,
achieved use symbolic techniques. fully symbolic, Cmbp
exhibit enumerative behaviour competitors. Compared original approach
described Cimatti Roveri (1999), substantial improvement performance
obtained new implementation pruning step. disclaimer
order. well known Bdd based computations subject blow-up memory
requirements computing certain classes boolean functions, e.g. multipliers (Bryant,
1986). would trivial make example performance Cmbp degrades
exponentially. However, none examples considered, included
examples distribution Cgp Gpt, phenomenon occurred.
8. Related Work

term conformant planning first introduced Goldman (1996), presenting
formalism constructing conformant plans based extension dynamic logic. Recently, Ferraris Giunchiglia (2000) presented another conformant planner based SAT
techniques. system available direct comparison Cmbp. effectiveness approach dicult evaluate, limited testing described (Ferraris &
Giunchiglia, 2000). performance claimed comparable Cgp. However,
results reported enconding corresponding solution, behaviour
Qbfplan reported Table 2 suggests kind analysis might limited.
Several works share idea planning based automata theory. closely
related works lines planning via model checking (Cimatti et al., 1997), upon
work based. approach allows, instance, automatically construct
universal plans guaranteed achieve goal finite number steps (Cimatti
et al., 1998b), implement trial-and-error strategies (Cimatti et al., 1998a; Daniele
et al., 1999). results obtained hypothesis total observability,
run-time observation available. main difference substantial extension required lift symbolic techniques search space belief states. De
Giacomo Vardi (1999) analyze several forms planning automata theoretic
framework. Goldman, Musliner Pelican (2000) present method model checking
timed automata interleaved plan formation activity, make sure
333

fiCimatti & Roveri
timing constraints met. Finally, Hoey colleagues (1999) use algebraic decision
diagrams tackle problem stochastic planning.
9. Conclusions Future Work

paper presented new approach conformant planning, based use
Symbolic Model Checking techniques. algorithm general, applies
complex planning domains, uncertainty initial condition action effects,
described finite state automata. algorithm based breadthfirst, backward search, returns conformant plans minimal length, solution
planning problem exists. Otherwise, terminates failure. algorithm designed
take full advantage symbolic representation based Bdds. implementation
approach Cmbp system highly optimized, particular crucial
step termination checking. performed experimental comparison approach
state art conformant planners Cgp, Qbfplan Gpt. Cmbp strictly
expressive Qbfplan Cgp. problems comparison
possible, Cmbp outperformed competitors terms run times, sometimes
orders magnitude. Thanks use symbolic data structures, Cmbp able deal
eciently problems large numbers initial states action outcomes.
hand, qualitative behavior Cgp Gpt seems depend heavily
enumerative nature algorithms. Differently Gpt, Cmbp independent
effectiveness heuristic used drive search.
research presented paper extended following directions. First,
investigating alternative approach conformant planning, breadthfirst style search given up. techniques appear extremely promising |
preliminary experiments led speed ups two orders magnitude
results presented paper problems admit solution. Second, tackle
problem conditional planning partial observability, hypothesis
limited amount information acquired run time. conformant planning,
problem seen search belief space. However, appears significantly
complicated need dealing run-time observation conditional plans. Finally, considering extension domain construction planner
expressive input language, C , invariant detection techniques.
Acknowledgements

Fausto Giunchiglia provided continuous encouragement feedback work.
thank Piergiorgio Bertoli, Blai Bonet, Marco Daniele, Hector Geffner, Enrico Giunchiglia,
Jussi Rintanen, David Smith, Paolo Traverso, Dan Weld valuable discussions conformant planning various comments paper. David Smith provided code
Cgp, large number examples, time-out mechanism used experimental
evaluation. Jussi Rintanen made Qbfplan available Linux.
334

fiConformant Planning via Symbolic Model Checking
References

Blum, A. L., & Furst, M. L. (1995). Fast planning planning graph analysis.
Proc. Ijcai.
Blum, A. L., & Furst, M. L. (1997). Fast planning planning graph analysis. Artificial Intelligence 1{2, 90, 279{298.
Bonet, B., & Geffner, H. (2000). Planning Incomplete Information Heuristic Se
arch Belief Space. Chien, S., Kambhampati, S., & Knoblock, C. (Eds.), 5th
International Conference Artificial Intelligence Planning Scheduling, pp. 52{
61. AAAI-Press.
Brace, K., Rudell, R., & Bryant, R. (1990). Ecient Implementation BDD Package. 27th ACM/IEEE Design Automation Conference, pp. 40{45 Orlando, Florida.
ACM/IEEE, IEEE Computer Society Press.
Bryant, R. E. (1986). Graph-Based Algorithms Boolean Function Manipulation. IEEE
Transactions Computers, C-35 (8), 677{691.
Bryant, R. E. (1991). complexity VLSI implementations graph representations
Boolean functions application integer multiplication. IEEE Transactions
Computers, 40 (2), 205{213.
Bryant, R. E. (1992). Symbolic Boolean manipulation ordered binary-decision diagrams. ACM Computing Surveys, 24 (3), 293{318.
Burch, J. R., Clarke, E. M., McMillan, K. L., Dill, D. L., & Hwang, L. J. (1992). Symbolic
Model Checking: 1020 States Beyond. Information Computation, 98 (2),
142{170.
Cassandra, A., Kaelbling, L., & Littman, M. (1994). Acting optimally partially observable
stochastic domains. Proc. AAAI-94. AAAI-Press.
Cimatti, A., Clarke, E., Giunchiglia, F., & Roveri, M. (2000). NuSMV : new symbolic
model checker. International Journal Software Tools Technology Transfer
(STTT), 2 (4).
Cimatti, A., Giunchiglia, E., Giunchiglia, F., & Traverso, P. (1997). Planning via Model
Checking: Decision Procedure AR. Steel, S., & Alami, R. (Eds.), Proceeding
Fourth European Conference Planning, No. 1348 Lecture Notes Artificial
Intelligence, pp. 130{142 Toulouse, France. Springer-Verlag. ITC-IRST Technical
Report 9705-02, ITC-IRST Trento, Italy.
Cimatti, A., & Roveri, M. (1999). Conformant Planning via Model Checking. Biundo,
S. (Ed.), Proceeding Fifth European Conference Planning, Lecture Notes
Artificial Intelligence Durham, United Kingdom. Springer-Verlag. ITC-IRST
Technical Report 9908-01, ITC-IRST Trento, Italy.
335

fiCimatti & Roveri
Cimatti, A., & Roveri, M. (2000). Forward Conformant Planning via Symbolic Model
Checking. Proceeding AIPS2k Workshop Model-Theoretic Approaches
Planning Breckenridge, Colorado.
Cimatti, A., Roveri, M., & Traverso, P. (1998a). Automatic OBDD-based Generation
Universal Plans Non-Deterministic Domains. Proceeding Fifteenth National
Conference Artificial Intelligence (AAAI-98) Madison, Wisconsin. AAAI-Press.
IRST-Technical Report 9801-10, Trento, Italy.
Cimatti, A., Roveri, M., & Traverso, P. (1998b). Strong Planning Non-Deterministic
Domains via Model Checking. Proceeding Fourth International Conference
Artificial Intelligence Planning Systems (AIPS-98) Carnegie Mellon University,
Pittsburgh, USA. AAAI-Press.
Clarke, E. M., & Wing, J. M. (1996). Formal methods: State art future directions.
ACM Computing Surveys, 28 (4), 626{643.
Clarke, E., Emerson, E., & Sistla, A. (1986). Automatic verification finite-state concurrent systems using temporal logic specifications. ACM Transactions Programming
Languages Systems, 8 (2), 244{263.
Coudert, O., Madre, J. C., & Touati, H. (1993). TiGeR Version 1.0 User Guide. Digital
Paris Research Lab.
Daniele, M., Traverso, P., & Vardi, M. Y. (1999). Strong Cyclic Planning Revisited.
Biundo, S. (Ed.), Proceeding Fifth European Conference Planning, Lecture
Notes Artificial Intelligence Durham, United Kingdom. Springer-Verlag.
De Giacomo, G., & Vardi, M. (1999). Automata-Theoretic Approach Planning Temporally Extended Goals. Biundo, S. (Ed.), Proceeding Fifth European Conference Planning, Lecture Notes Artificial Intelligence Durham, United Kingdom.
Springer-Verlag.
Ferraris, P., & Giunchiglia, E. (2000). Planning satisfiability nondeterministic domains. Proceedings Seventeenth National Conference Artificial Intelligence
(AAAI'00) Austin, Texas. AAAI Press.
Ghallab, M., Howe, A., Knoblock, C., McDermott, D., Ram, A., Weld, D., & Wilkins,
D. (1998). PDDL | Planning Domain Definition Language. Tech. rep. CVC
TR-98-003/DCS TR-1165, Yale Center Computational Vision Control.
Giunchiglia, E. (1996). Determining Ramifications Situation Calculus. Fifth
International Conference Principles Knowledge Representation Reasoning
(KR'96) Cambridge, Massachusetts. Morgan Kaufmann Publishers.

Giunchiglia, E., Kartha, G. N., & Lifschitz, V. (1997). Representing action: Indeterminacy
ramifications. Artificial Intelligence, 95 (2), 409{438.
336

fiConformant Planning via Symbolic Model Checking
Giunchiglia, E., & Lifschitz, V. (1998). action language based causal explanation:
Preliminary report. Proceedings 15th National Conference Artificial Intelligence (AAAI-98) 10th Conference Innovative Applications Artificial
Intelligence (IAAI-98), pp. 623{630 Menlo Park. AAAI Press.

Goldman, R. P., Musliner, D. J., & Pelican, M. J. (2000). Using Model Checking
Plan Hard Real-Time Controllers. Proceeding AIPS2k Workshop ModelTheoretic Approaches Planning Breckenridge, Colorado.
Goldman, R., & Boddy, M. (1996). Expressive Planning Explicit Knowledge.
Proceedings 3rd International Conference Artificial Intelligence Planning
Systems (AIPS-96), pp. 110{117. AAAI Press.

Hoey, J., St-Aubin, R., Hu, A., & Boutilier, C. (1999). Spudd: Stochastic planning using decision diagrams. Proceedings Fifteenth Conference Uncertainty
Articial Intelligence (1999), pp. 279{288. AAAI Press.
Kautz, H., & Selman, B. (1998). BLACKBOX: New Approach Application
Theorem Proving Problem Solving. Working notes Workshop Planning
Combinatorial Search Pittsburgh, PA, USA.
Kautz, H. A., McAllester, D., & Selman, B. (1996). Encoding Plans Propositional Logic.
Proc. KR-96.
Kautz, H. A., & Selman, B. (1996). Pushing Envelope: Planning, Propositional Logic,
Stochastic Search. Proc. AAAI-96.
Kushmerick, N., Hanks, S., & Weld, D. S. (1995). algorithm probabilistic planning.
Artificial Intelligence, 76 (1-2), 239{286.
Levesque, H. J. (1996). planning presence sensing?. Proceedings
Thirteenth National Conference Artificial Intelligence Eighth Innovative
Applications Artificial Intelligence Conference, pp. 1139{1146 Menlo Park. AAAI

Press / MIT Press.
McDermott, D. (1987). critique pure reason. Computational Intelligence, 3 (3), 151{
237.
McMillan, K. (1993). Symbolic Model Checking. Kluwer Academic Publ.
Michie, D. (1974). Machine Intelligence Edinburgh. Machine Intelligence, pp.
143{155. Edinburgh University Press.
Nilsson, N. (1980). Principles Artificial Intelligence. Morgan Kaufmann Publishers, Inc.,
Los Altos, CA.
Peot, M. (1998). Decision-Theoretic Planning. Ph.D. thesis, Dept. Engineering-Economic
Systems | Stanford University.
Rintanen, J. (1999a). Constructing conditional plans theorem-prover. Journal
Artificial Intellegence Research, 10, 323{352.
337

fiCimatti & Roveri
Rintanen, J. (1999b). Improvements Evaluation Quantified Boolean Formulae.
Dean, T. (Ed.), 16th Iinternational Joint Conference Artificial Intelligence, pp.
1192{1197. Morgan Kaufmann Publishers.
Smith, D. E., & Weld, D. S. (1998). Conformant graphplan. Proceedings 15th
National Conference Artificial Intelligence (AAAI-98) 10th Conference
Innovative Applications Artificial Intelligence (IAAI-98), pp. 889{896 Menlo

Park. AAAI Press.
Somenzi, F. (1997). CUDD: CU Decision Diagram package | release 2.1.2. Department
Electrical Computer Engineering | University Colorado Boulder.
Weld, D. S., Anderson, C. R., & Smith, D. E. (1998). Extending graphplan handle
uncertainty sensing actions. Proceedings 15th National Conference
Artificial Intelligence (AAAI-98) 10th Conference Innovative Applications Artificial Intelligence (IAAI-98), pp. 897{904 Menlo Park. AAAI Press.

Yang, B., Bryant, R. E., O'Hallaron, D. R., Biere, A., Coudert, O., Janssen, G., Ranjan,
R. K., & Somenzi, F. (1998). performance study BDD-based model checking.
Proceedings Formal Methods Computer-Aided Design, pp. 255{289.

338


