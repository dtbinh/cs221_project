journal artificial intelligence

submitted published

conformant via symbolic model checking
cimatti irst itc

alessandro cimatti

itc irst

via sommarive povo trento italy

roveri irst itc

marco roveri

itc irst

via sommarive povo trento italy

dsi university milano via comelico milano italy

abstract

tackle nondeterministic domains presenting
conformant conformant finding sequence actions guaranteed achieve goal despite nondeterminism
domain representation domain finite
state automaton use symbolic model checking techniques particular binary decision diagrams compactly represent eciently search automaton
make following contributions first present general
conformant applies fully nondeterministic domains uncertainty
initial condition action effects breadth first backward search returns conformant plans minimal length solution
exists otherwise terminates concluding admits conformant
solution second provide symbolic representation search space binary
decision diagrams bdds basis search techniques derived symbolic
model checking symbolic representation makes possible analyze potentially large
sets states transitions single computation step thus providing ecient
implementation third present cmbp conformant model planner ecient
implementation data structures described directly
bdd manipulations allows compact representation search layers
ecient implementation search steps finally present experimental comparison state art conformant planners cgp qbfplan
gpt analysis includes distribution packages
systems plus defined stress number specific factors appears effective cmbp strictly expressive qbfplan
cgp comparison possible cmbp outperforms
competitors sometimes orders magnitude
introduction

recent years growing interest nondeterministic domains
rejecting fundamental often unrealistic assumptions classical domains considered actions uncertain effects exogenous events possible
initial state partly specified challenge strong plan
guaranteed achieve goal despite nondeterminism domain regardless
uncertainty initial condition effect actions conditional cassandra kaelbling littman weld anderson smith cimatti
roveri traverso b tackles searching conditional course
c ai access foundation morgan kaufmann publishers rights reserved

ficimatti roveri
actions depends information gathered run time certain domains
however run time information gathering may expensive simply impossible conformant goldman boddy finding unconditioned
course actions e classical plan depend run time information gathering guarantee achievement goal conformant recognized
significant artificial intelligence since work michie blind
robot requires program activity sensorless agent positioned location given room guaranteed achieve given
goal conformant seen control system
unobservable unknown state microprocessor power software
system black box testing
uncertainty plan associated potentially many different executions
must taken account order guarantee goal achievement makes
conformant significantly harder classical rintanen de giacomo vardi despite increased complexity several approaches conformant
recently proposed extensions main techniques classical interesting cgp smith weld
graphplan qbfplan rintanen extends sat plan
qbf gpt bonet geffner encodes conformant heuristic
search propose conformant symbolic model checking mcmillan symbolic model checking formal verification
technique allows one analyze finite state automata high complexity relying
symbolic techniques binary decision diagrams bdds bryant particular
compact representation ecient search automaton builds
via model checking paradigm presented cimatti colleagues
b finite state automata used represent complex nondeterministic
domains extensions basic model checking steps
make following contributions

first present general conformant applies

nondeterministic domain uncertain action effects initial condition expressed
nondeterministic finite state automaton performs breadth first
search exploring plans increasing length plan found candidate
plans available complete e returns failure
admits conformant solution admits solution
returns conformant plan minimal length

second provide symbolic representation search space binary

decision diagrams allows application search techniques derived
symbolic model checking symbolic representation makes possible analyze
sets transitions single computation step sets compactly represented eciently manipulated despite potentially large cardinality
way possible overcome enumerative nature approaches
conformant degree nondeterminism tends limiting
factor


ficonformant via symbolic model checking

third developed cmbp conformant model planner ecient

implementation data structures described cmbp developed top mbp planner symbolic model checking techniques
developed cimatti roveri traveso b cmbp implements several
techniques directly bdd manipulations compact search layers
optimize termination checking
finally provide experimental evaluation state art conformant planners comparing cmbp cgp qbfplan gpt difference
expressivity tackled cmbp represented planners however direct comparison
possible cmbp outperforms competitors particular features better
qualitative behavior directly related number initial states uncertain
action effects stable respect use heuristics
structured follows section review representation nondeterministic domains finite state automata section provide
intuitions formal definition conformant setting section
present section discuss symbolic representation
search space allows ecient implementation section present
cmbp planner section present experimental section
discuss related work section draw conclusions discuss future
directions
domains finite state automata

interested complex nondeterministic domains actions
preconditions conditional effects uncertain effects initial state
partly specified rest use simple though paradigmatic domain
explanatory purposes variation moore bomb toilet domain mcdermott
called btuc bt uncertain clogging two packages
one contains armed bomb possible dunk package
toilet actions dunk dunk provided toilet clogged dunking
package uncertain effect clogging toilet furthermore dunking package
containing bomb effect disarming bomb action f lush effect
unclogging toilet
represent domains finite state automata figure depicts automaton
btuc domain state given number contains propositions holding
state instance state represents state bomb package
defused toilet clogged given one bomb write
abbreviation negation arrows states depict transitions
automaton representing possible behavior actions transition state
state labeled f lush represents fact action f lush executed state
effect removing clogging execution dunk state
uncertain effect clogging toilet represented multiple transitions
states since transition outgoing state labelled dunk


ficimatti roveri
flush
flush

dunk

defused
clogged


defused
clogged

dunk
dunk

dunk
flush

flush

defused
clogged


defused
clogged

flush
flush

dunk

defused
clogged




defused
clogged

dunk
dunk

dunk
flush

flush

defused
clogged


defused
clogged

figure automaton btuc domain
state satisfy preconditions action dunk e dunk applicable
state
formally define nondeterministic domains follows
definition domain domain tuple p r

p finite set atomic propositions p set states
finite set actions r transition relation



intuitively proposition state holds state following
assume domain given use denote states
denote actions r holds iff executing action state
state possible outcome say action applicable iff least
one state r holds say action deterministic iff
unique state r holds action uncertain outcome
least two distinct states r r
hold described cimatti colleagues automaton given domain
eciently built starting compact description given expressive high level
action language instance ar giunchiglia kartha lifschitz
conformant

conformant goldman boddy described finding
sequence actions guaranteed achieve goal regardless nondeterminism
domain possible initial states uncertain action effects
execution plan goal state
consider following btuc domain initially bomb armed
position status toilet uncertain e initial state
states f g goal reach state bomb defused toilet


ficonformant via symbolic model checking


defused
clogged


defused
clogged


defused
clogged


defused
clogged


defused
clogged

flush

flush

flush

flush


defused
clogged

flush

flush

defused
clogged

dunk


defused
clogged


defused
clogged

dunk


defused
clogged


defused
clogged

dunk


defused
clogged

flush

defused
clogged

dunk


defused
clogged


defused
clogged

flush


defused
clogged

flush

flush

flush


defused
clogged


defused
clogged

flush

figure conformant solution btuc
clogged e set goal states f g conformant plan solving

f lush dunk f lush dunk f lush

figure outlines possible executions plan possible initial states
uncertain action effects initial uncertainty lies fact domain might
states f g possible initial states domain
collected set dashed line call set belief state intuitively belief
state expresses condition uncertainty domain collecting together
states indistinguishable point view agent reasoning
domain first action f lush used remove possible clogging reduces
uncertainty belief state f g despite remaining uncertainty e still
known package bomb action dunk guaranteed applicable
precondition met states dunk effect defusing bomb
contained package uncertain effect clogging toilet resulting
belief state f g following action f lush removes clogging reducing
uncertainty belief state f g guarantees applicability dunk
dunk bomb guaranteed defused toilet might clogged states
belief state f g final f lush reduces uncertainty belief
state f g guarantees achievement goal
general order plan conformant solution action must executed
states satisfy preconditions state
execution plan initial states uncertain action effects
goal state main diculty achieving conditions information
assumed available run time therefore time face
reasoning action execution belief state e condition uncertainty
definition action applicability let bs belief state action
applicable bs iff bs applicable every state bs


ficimatti roveri
order action applicable belief state require preconditions
must guaranteed notwithstanding uncertainty words reject reckless
plans take chance applying action without guarantee applicability
choice strongly motivated practical domains possibly fatal consequences
follow attempt apply action preconditions might satisfied
e g starting fix electrical device without sure powered effect
action execution uncertain condition defined follows
definition action image let bs belief state let action applicable bs image called execution bs written image bs defined

follows

image bs

fs j exists bs r g

notice image action combines uncertainty belief state uncertainty action effects consider instance image dunk f g f g
following write image instead image fsg
plans elements e finite sequences actions use length
plan denote generic plans plan concatenation notions
applicability image generalize plans follows
definition plan applicability image let let bs applicable bs iff one following holds
bs
applicable bs applicable image bs
image called execution bs written image bs defined
image bs bs
image bs image image bs

formally characterized set initial goal states
following definition captures intuitive meaning conformant plan given
definition conformant let p r domain
triple g g
plan conformant plan conformant solution
g iff following conditions hold

applicable
ii image g
following clear context omit domain
simply write g


ficonformant via symbolic model checking
conformant

conformant exploration space plans limiting
exploration plans conformant construction builds belief
state plan bsp pairs form hbs bs non empty belief state
plan idea use bsp pair associate explored plan maximal
belief state applicable guaranteed goal states
exploration basic function spreimage bs given belief state
bs action returns belief state containing states applicable
whose image contained bs
definition strong pre image let bs belief state let
action strong pre image bs written spreimage bs defined
follows

spreimage bs fs j applicable image

bsg

spreimage bs empty applicable conformant solution spreimage bs bs therefore plan conformant
solution bs g plan conformant solution
spreimage bs g
figure depicts space bsp pairs built solving btuc
levels built goal right towards initial states
left level bsp pair hf g composed set goal states indexed
length plan notice conformant solution every goal set
f g initial states contained f g dashed arrows represent application
spreimage level bsp pair hf g f lushi built since strong
pre image belief state actions dunk dunk empty level
three bsp pairs overlapping belief states bs bs bs indexed respectively
length plans dunk f lush f lush f lush dunk f lush plan associated
belief state bsi sequence actions labeling path bsi bs notice
bs equal bs therefore deserves expansion expansion
belief states gives belief states obtained strong pre image
f lush strong pre image actions dunk dunk returns empty
belief states expansion bs three belief states one resulting
strong pre image f lush reported since equal bs belief state
equal bs deserves expansion belief state obtained
expanding bs bs level expansion produces bs contains
initial states therefore corresponding plans conformant solutions

conformant conformantplan presented figure
takes input form set states g domain
assumed globally available performs backwards breadth first
search exploring bsp pairs corresponding plans increasing length step
status search level figure represented bsp table e set bsp
pairs
bspt fhbs hbsn n ig


ficimatti roveri
level














defused
clogged


defused
clogged
dunk


defused
clogged


defused
clogged


defused
clogged


defused
clogged


defused
clogged


defused
clogged
flush


defused
clogged

dunk

bs


defused
clogged


defused
clogged


defused
clogged
bs


defused
clogged


defused
clogged


defused
clogged


defused
clogged

flush


defused
clogged


defused
clogged


defused
clogged


defused
clogged


defused
clogged


defused
clogged

dunk

defused
clogged


defused
clogged

bs


defused
clogged

flush


defused
clogged


defused
clogged


defused
clogged


defused
clogged


defused
clogged

flush


defused
clogged


defused
clogged
bs

dunk

bs


defused
clogged


defused
clogged

bs

bs




defused
clogged


defused
clogged


defused
clogged




defused
clogged

bs


defused
clogged


defused
clogged

flush


defused
clogged
dunk


defused
clogged

dunk


defused
clogged


defused
clogged

bs


defused
clogged


defused
clogged
bs

bs

figure bsp tables btuc
plans length j j n
call bsi belief set indexed ambiguity arises write bspt
bsi array bsptables used store bsp tables representing levels
search first checks line plans length e
solution conformant plan length exists p lans line
loop entered iteration conformant plans increasing length explored
lines step line expands bsp table bsptables stores
resulting bsp table bsptables bsp pairs redundant respect
current search eliminated bsptables line possible solutions contained
bsptables extracted stored p lans line loop terminates
plan found p lans space conformant plans completely explored
bsptables
definitions basic functions used reported figure
function expandbsptable expands bsp table provided argument containing
conformant plans length returns bsp table conformant plans length
bsp input bsp table expanded expandbsppair possible


ficonformant via symbolic model checking
















function conformantplan g
begin


bsptables f hg g
plans extractsolution bsptables
bsptables p lans

bsptables expandbsptable bsptables
bsptables prunebsptable bsptables bsptables
plans extractsolution bsptables

done
bsptables
return fail
else return plans
end

figure conformant
action strong pre image bs computed resulting belief state bs
empty e belief state guarantees achievement bs
plan extended hbs returned expansion bsp table
union expansions bsp pair function extractsolution takes
input bsp table returns possibly empty set plans index belief states
containing prunebsptable takes input bsp table pruned array
previously constructed bsp tables bsptables index current step removes
bsp table input plans worth explored
corresponding belief states already visited
following properties first terminates follows
fact set explored belief sets stored bsptables monotonically
increasing step proceed least one belief state generated
finiteness set accumulated belief states contained
finite fix point eventually reached second correct e plan returned
conformant solution given correctness follows
properties spreimage plan associated belief state
conformant e guaranteed applicable
belief state contained goal third optimal e returns plans
minimal length property follows breadth first style search finally
able decide whether admits solution returning fail
cases indeed conformant solution associated belief state containing
initial states spreimage generates maximal belief state associated conformant
plan belief state generated exploration compared initial states
check solution plan pruned equivalent plan already
explored


ficimatti roveri

bspt

expandbsptable


hbs bspt

hbs

expandbsppair

hbs fhbs ij bs spreimage bs g

expandbsppair

bspt bsptables
fhbs bspt j j hbs bsptables j bs bs g
prunebsptable

bspt f j exists hbs bspt bsg

extractsolution

figure primitives used conformant
conformant via symbolic model checking

model checking formal verification technique exploration finite state
automata clarke emerson sistla symbolic model checking mcmillan
particular form model checking binary decision diagrams compactly represent
eciently analyze finite state automata introduction symbolic techniques
model checking led breakthrough size model could analyzed burch
et al made possible model checking routinely applied industry
especially logic circuits design survey see clarke wing
rest section provide overview binary decision diagrams
describe representation domains bdd
representation finite state automata used model checking discuss
extension allows symbolically represent bsp tables transformations thus
allowing ecient implementation described previous section
binary decision diagrams

reduced ordered binary decision diagram bryant improperly called bdd
directed acyclic graph dag terminal nodes rue f alse nonterminal node associated boolean variable two bdds called left right
branches figure depicts bdd b b b
non terminal node right left respectively branch depicted solid dashed resp
line represents assignment value rue f alse resp corresponding
variable bdd represents boolean function given truth assignment variables
bdd value function determined traversing graph root
leaves following branch indicated value assigned variables
path root leaf visit nodes associated subset variables bdd
see instance path associated b figure



ficonformant via symbolic model checking





b



b





b

b

b

b



b

b







b

b

b



b

b

b

b

b

b

b

b

true

false

true

false



b

b

figure two bdds formula b b b
reached leaf node labeled resulting truth value v bdd size jvj
number nodes n node var n indicates variable indexing node n
bdds canonical representation boolean functions canonicity follows
imposing total order set variables used label nodes
node n respective non terminal child variables must ordered e var n
var requiring bdd contains isomorphic subgraphs
bdds combined usual boolean transformations e g negation conjunction disjunction given two bdds instance conjunction operator builds
returns bdd corresponding conjunction arguments substitution
represented bdd transformations following v variable
bdds indicate v bdd resulting substitution v
v v vectors number distinct variables indicate v v
parallel substitution variables vector v corresponding variables
v
bdds allow transformations described quantifications style quantified boolean formulae qbf qbf definitional extension propositional logic
propositional variables universally existentially quantified terms bdd
computations quantification corresponds tranformation mapping bdd
variable vi quantified bdd resulting propositional formula
formula vi one variables existential quantification vi written
vi v vn equivalent v vn vi f alse v vn vi rue analogously universal quantification vi v vn equivalent v vn vi f alse


ficimatti roveri
v vn vi rue qbf quantifiers arbitrarily applied nested general qbf formula equivalent propositional formula conversion subject
exponential blow
time complexity computing truth functional boolean transformation f op f jf j jf j far quantifications concerned time
complexity quadratic size bdd quantified linear number
variables quantified e jvj jf j bryant
bdd packages ecient implementations data structures brace
et al somenzi yang et al coudert et al basically bdd package deals single multi rooted dag node represents boolean function
memory eciency obtained unique table sharing common subgraphs
bdds unique table used guarantee time isomorphic subgraphs redundant nodes multi rooted dag creating
node unique table checked see node already present
case node created stored unique table unique table
allows perform equivalence check two bdds constant time since two
equivalent functions share subgraph brace et al somenzi
time eciency obtained maintaining computed table keeps track
recently computed transformations thus avoiding recomputation
critical computational factor bdds order variables used figure
shows example impact change variable ordering size bdd
certain class boolean functions size corresponding bdd exponential
number variables possible variable ordering bryant many practical
cases however finding good variable ordering rather easy beside affecting memory
used represent boolean function finding good variable ordering big impact
computation times since complexity transformation depends
size operands bdd packages provide heuristic finding good
variable orderings called try reduce overall size stored bdds
reordering activated dynamically package bdd
computation total number nodes package reaches predefined threshold
dynamic reoredering
symbolic representation domains
domain p r represented symbolically bdds follows

set distinct bdd variables called state variables devoted representation
states domain variables direct association proposition
domain p used description domain instance btuc
domain defused clogged associated unique bdd variable
following write x vector state variables particular order
irrelevant performance issues rest section distinguish
proposition corresponding bdd variable
state set propositions p specifically propositions intended
hold state corresponding assignment state variables
x e assignment variable corresponding proposition p assigned


ficonformant via symbolic model checking
rue variable assigned f alse represent bdd
assignment unique satisfying assignment instance
defused clogged bdd representing state defused
clogged represents state without loss generality following
distinguish propositional formula corresponding bdd representation
naturally extends set states q follows
q



q

words associate set states generalized disjunction bdds
representing states notice satisfying assignments q
exactly assignment representations states q representation mechanism
natural instance bdd representing set initial states
btuc f g defused set goal states g f g
corresponding bdd defused clogged bdd used represent set
states domain automaton btuc rue p
different formulation two independent propositions used represent
position bomb would bdd
general bdd represents set states correspond
consequence set theoretic transformations naturally represented propositional
operations follows
snq
q
q q q q
q q q q

main eciency symbolic representation lies fact cardinality
represented set directly related size bdd instance g uses
two non terminal nodes represent two states uses one node represent four
states limit cases fg leaf bdds rue f alse respectively
advantage symbolic representation extremely ecient dealing irrelevant
information notice instance variable defused occurs f g
reason symbolic representation dramatic improvement explicit
enumerative representation allows symbolic bdd model checkers
handle finite state automata large number states see instance burch
et al following collapse set states bdd representing
another set bdd variables called action variables written used represent
actions use one action variable possible action intuitively bdd action
variable true corresponding action executed assume
sequential encoding used e concurrent actions allowed use bdd
seq express exactly one action variables must true time
specific case sequential encoding alternative dlog jaje possible
assignment action variables denotes specific action executed two assignments
mutually exclusive constraint seq needs represented cardinality
set actions power two standard solution associate one assignment
certain values optimized solution actually used implementation described
sake simplicity



ficimatti roveri
btuc contains three actions use three bdd variables dunk
dunk f lush express serial encoding constraint following bdd

seq dunk dunk f lush dunk dunk dunk f lush dunk f lush

state variables referring bdd action variables symbolic names
sake simplicity practice internally represented integers
position ordering bdd package totally irrelevant logical terms
bdd variables x represents set state action pairs e relation
states actions instance applicability relation btuc e
actions possible states except dunking actions require toilet
clogged represented bdd clogged dunk dunk notice
represents set state action pairs associating state applicable action
transition tuple composed state initial state transition
action action executed state resulting state transition
represent transitions another vector x bdd variables called next state variables
allocated bdd package write representation state
next state variables q denote construction bdd corresponding
set states q variable next state vector x instead current
state variables x require jx j jx j assume th variable x
th variable x correspond define representation set states next
variables follows
x xx
call operation x xx forward shifting transforms representation
set current states representation set next states dual operation
x xx called backward shifting following call x current state variables
distinguish next state variables transition represented assignment
x x btuc transition corresponding application action
dunk state resulting state represented following bdd
h dunk dunk
transition relation r automaton corresponding domain
simply set transitions thus represented bdd bdd variables x
x satisfying assignment represents possible transition

r seq
r

rest assume bdd representation domain
given particular assume given vectors variables x xx ffff encoding
functions simply call r g bdd representing states
domain transition relation initial states goal states respectively write
v stress bdd depends variables v representation
possible reason plans simulating symbolically execution sets actions
sets states means qbf transformations bdd representing applicability
relation directly obtained following computation
x r x ffff xx
applicable x


ficonformant via symbolic model checking
resulting bdd applicable x ffff represents set state action pairs
action applicable state bdd representing states reachable q
one step obtained following computation

x r x ffff xx q x x xx
notice single operation symbolically simulate effect application
applicable action states q similarly following transformation allows symbolically compute spreimage set states q possible
actions one single computation

x r x ffff xx q x x xx

x ffff

applicable

resulting bdd represents state action pairs hx ffi applicable
x execution x states q
symbolic search space belief states

main strength symbolic allows perform symbolic breadthfirst search provides way compactly representing eciently expanding
frontier instance plans constructed symbolic breadth first search
space states repeatedly applying strong pre image goal states cimatti et al
b however machinery presented previous section cannot directly applied
tackle conformant basic difference conformant
searching space belief states therefore frontier search basically
set sets states introduce way symbolically represent bsp tables basically
seen construction demand steps increasingly
large portions space belief states key intuition bsp table

fhfs n g hfsk skn g k ig
k

represented relation plans length states associating
plan directly state belief state indexed plan follows

fhs hs n hsk k hskn k ig
k



use additional variables represent plans bsp tables order represent
plans increasing length step vector bdd variables
called plan variables introduced vector plan variables introduced th step
written j j jff j used encode th last action
plan step one introduce vector plan variables
represent action corresponding length possible conformant plan bsp
principle machinery symbolic search could used conformant applied
determinization domain automaton e automaton state space however
would require introduction exponential number state variables impractical
even small domains
search performed backwards plans need reversed found



ficimatti roveri
table bspt level built expandbsptable performing following bdd
computation starting bsp table level e g x
x r x ffff xx g x x xx applicable x ffff
computation collects state action pairs hx action represented
applicable state represented x resulting states
represented x goal states replace vector action variables
first vector plan variables resulting bdd bspt x represents bsp
table containing plans length one form relation states plans
general case step bsp table bspti associating belief states
plans length represented bdd state variables x plan
variables computation performed expandbsptable step
implemented following bdd transformation bspti
x r x ffff xx bspti x x xx applicable x ffff
next state variables r bspti resulting forward shifting disappear
universal quantification action variables renamed newly
introduced plan variables next step construction
repeated
extractsolution extracts assignments plan variables corresponding set contains initial states terms bdd transformations extractsolution
implemented follows
x x bspti x

bdd plan variables bdd f alse
solutions length otherwise satisfying assignments resulting bdd
represents conformant solution
guarantee termination step bsp table returned
expandbsptable simplified prunebsptable removing belief states
deserve expansion requires comparison belief states
contained bsp table belief states contained bsp tables built
previous levels one crucial steps terms eciency earlier implementation step logical bdd transformations following directly set theoretical
definition prunebsptable extremely inecient cimatti roveri furthermore noticed serial encoding could yield bsp tables containing large
number equivalent plans indexing exactly belief state often equivalent plans differ order independent actions potential source
combinatorial explosion occurs even simple version btuc figure
two equivalent conformant plans associated bs therefore developed
implementation could tackle two operating directly bsp
table idea depicted figure initially cache contains bs bs bs
simplification performs traversal bdd accumulating subtrees representing
belief states comparing ones built previous levels inserting
ones cache figure bs bs bs time path identified


ficonformant via symbolic model checking
bsp table

bs

bs

bs

pruned bsp table

bs

bs

bs

cached belief states
bs

bs

bs

cached belief states

bs

bs

bs

bs

bs

bs

bs

figure example pruning bsp table
represents plan indexing already cached belief state plan redundant
corresponding path pruned cost simplification linear size bsp
simplified highly effective pruning
cmbp bdd conformant planner

cmbp conformant model planner conformant planner implementing data
structures conformant described previous sections cmbp
inherits features mbp cimatti et al b planner
symbolic model checking techniques mbp built top nusmv symbolic model
checker jointly developed itc irst cmu cimatti et al uses
cudd somenzi state art bdd package mbp two stage system
first stage internal bdd representation domain built
second stage solved currently domains described
means high level action language ar giunchiglia et al ar allows
specify conditional uncertain effects actions means high level assertions
instance figure shows ar description btuc semantics
ar yields serial encoding e exactly one action assumed executed

pruning mechanism actually weaker earlier one cimatti roveri
require belief state must expanded twice search earlier
version prune belief states contained previously explored ones may increase number
explored belief states however allows much ecient implementation without impacting
properties
stand negation conjunction respectively description slightly edited sake
readability particular mbp currently accept parameterized ar descriptions practice
use script language generate ground instances different complexity parameterized
description



ficimatti roveri

domain btuc
actions dunk dunk flush
fluents defused clogged boolean
inertial clogged defused

flush causes clogged

dunk preconditions clogged
dunk causes defused
dunk possibly changes clogged

initially defused
conformant defused clogged

figure ar description btuc
time automaton corresponding ar description obtained means
minimization procedure giunchiglia procedure solves frame
ramification eciently implemented mbp cimatti et al
separation domain construction phases mbp
bound ar standard deterministic domains specified pddl ghallab et al
given mbp means prototype compiler starting
investigate potential use c action language giunchiglia lifschitz
allows represent domains parallel actions
different applied specified
operate solely automaton representation completely independent
particular language used specify domain mbp allows automatic construction
conditional plans total observability implementing strong cimatti et al b strong cyclic plannig cimatti et al daniele
traverso vardi cmbp implemented ideas described previous
sections primitives construct prune bsp tables required lot tuning
particular ordering bdd variables found general ordering strategy
works reasonably well action variables positioned top ordering followed
plan variables followed state variables current state next state variables interleaved specific ordering within action variables plan variables state variables
determined standard mechanism implemented nusmv cmbp implements several
conformant addition backward presented


ficonformant via symbolic model checking
section cmbp implements forward search allows exploit
initial knowledge sometimes resulting significant speed ups cimatti
roveri backward forward search combined tackle exponential growth search time depth search
different options enable disable different versions termination check
experimental evaluation

section present experimental evaluation carried
comparing cmbp state art conformant planners first describe
conformant planners considered analysis present experimental
comparison carried
conformant planners

cgp smith weld extends ideas graphplan blum furst
deal uncertainty basically graph built every possible sequence possible worlds constraints among graphs propagated ensure conformance
cgp system takes input domains described extension pddl ghallab et al
possible specify uncertainty initial state cgp inherits
graphplan ability deal parallel actions cgp first ecient conformant planner shown outperform several planners buridan peot
udtpop kushmerick hanks weld detailed comparison reported smith weld leaves doubt superiority cgp respect
systems therefore compared cmbp cgp consider
systems analyzed smith weld cmbp expressive cgp two
respects first cgp handle uncertainty initial state instance cgp
cannot analyze btuc domain presented section smith weld describe
extended actions uncertain effects second cgp cannot
conclude conformant solutions
qbfplan name system rintanen qbfplan generalizes idea sat kautz mcallester selman kautz selman
nondeterministic domains encoding qbf qbfplan
limited conformant used conditional
uncertainty partial observability different encodings corresponding
different structures resulting plan synthesized
considering encodings enforce resulting plan sequence given bound
length plan first qbf encoding generated qbf
solver rintanen b called solution found encoding longer plan
must generated solved qbfplan able handle actions uncertain effects
done introducing auxiliary choice variables assignments different possible outcomes actions correspond variables universally quantified
ensure conformance solution differently e g blackbox kautz selman
qbfplan heuristic guess right length plan given
limit length plan generates encodings specified length
repeatedly calls qbf solver encodings increasing length plan found



ficimatti roveri
cgp qbfplan cannot conclude conformant solutions
similarly cmbp qbfplan relies symbolic representation although
qbf transformations performed theorem prover rather bdds
gpt bonet geffner general framework conformant
seen deterministic search space belief states gpt
uses explicit representation search space belief state represented
separate data structure search nilsson
driven domain dependent heuristics automatically generated
description gpt accepts descriptions syntax pddl extended deal
probabilities uncertainty possible represent domains uncertain action
effects although representation actions resulting large number different states
rather awkward gpt able conclude given
conformant solution exhaustively exploring space belief
states
experiments

evaluation performed running systems number parameterized domains considered cgp gpt distributions plus
defined test specific features planners considered
domains uncertainty limited initial state domains uncertain action
effects besides admitting solution considered admitting
solution case measured effectiveness plannner returning
failure
given different expressivity possible run systems
examples cmbp run classes examples gpt run one
cgp run admit solution uncertainty limited
initial condition qbfplan run examples encoding
already available qbfplan distribution subset
expressible cgp main limiting factor low level input format
qbfplan descriptions must specified ml code generates qbf
encodings writing encodings turned dicult task especially due
lack documentation
ran cgp qbfplan cmbp intel mhz pentium ii mb ram
running linux comparison cmbp gpt run sun ultra sparc
mhz mb ram running solaris gpt available binary however
performance two machines comparable run times cmbp almost
identical cpu time limited sec two hours test avoid swapping
memory limit fixed physical memory machine following
write test complete within time memory
limits respectively performance systems reported tables listing
search time excludes time needed qbfplan generate encodings
time spent cmbp construct automaton representation bdd time
needed gpt generate source code internal representation compile
overall significant time ignored automaton construction cmbp


ficonformant via symbolic model checking
currently automaton construction fully optimized even complex
examples however construction never required couple minutes
bomb toilet

bomb toilet first domain tackled classical bomb toilet
notion clogging call bt p parameter p

number packages uncertainty initial condition
known package contains bomb goal defuse bomb
bt shown table columns relative cmbp length
plan jpj number cached belief states number hits cache bs
nbs respectively time expressed seconds needed searching automaton
pentium linux time l sparc solaris time following
clear context execution platform omitted columns relative cgp
number levels graphs jlj search time column relative
gpt search time
bt
bt
bt
bt
bt
bt
bt
bt
bt

jpj











cmbp

bs bsh










time l










time










jlj










cgp

time










gpt

time










table bt
bt intrinsically parallel e depth graph
one packages dunked time cgp inherits graphplan ability deal parallel actions eciently therefore almost insensitive
size cgp outperforms cmbp gpt notice
number levels explored cgp length plan produced
cmbp cgp grows linearly cmbp performs slightly better gpt
bomb toilet clogging call btc p extension bt p
dunking package clogs toilet ushing remove clogging clogging precondition dunking package p number packages toilet
initially clogged modification longer allows parallel
solution listed table impact depth
plan length becomes significant systems cmbp gpt outperform cgp
case cmbp performs better gpt especially large instances see btc
precisely maximum time building automaton required bmtc examples
secs ring example secs bmtc examples secs bmtc
examples secs examples time required automaton construction
less seconds



ficimatti roveri
qbfplan

btc
btc
btc
btc
btc
btc
btc
btc
btc

jpj











cmbp

cgp

bs bsh time l time jlj time


































btc





gpt

time











btc
jpj time






















btc
time

























jpj







table btc
comparison qbfplan limited package instances ones available distribution package performance qbfplan reported left
table table line reports time needed decide whether plan
length performance qbfplan rather good tackling encoding admitting solution table entries labeled instance btc
qbfplan finds solution solving encodings depth reasonably fast however
solution cannot found e qbf formula admits model performance
qbfplan degrades significantly depth encoding let solver run
cpu hours complete search difference performance
diculty writing domains rest comparison consider
qbfplan
bomb multiple toilets next domain called bmtc p generalization
btc case multiple toilets p number packages
number toilets becomes parallelizable number
toilets increases furthermore considered three versions increasing
uncertainty initial states first class tests low uncertainty columns
uncertainty position bomb unknown toilets known
clogged mid uncertainty high uncertainty columns
presence uncertainty initial state second third respectively class
tests status every odd every resp toilet clogged clogged
increases number possible initial states
reported table comparison cgp table
comparison gpt column represents number initial states
corresponding cgp able fully exploit parallelism
however cgp never able explore levels graph depth
decreasing number initial states cmbp gpt
much less sensitive number initial states cgp increasing initial


p














































bmtc






























































































jpj

low uncertainty
cmbp
bs bsh time












































e
time
















cgp



mid uncertainty
cmbp

bs bsh time






















































































e
e









































time






cgp

jlj

table bmtc































































jlj

high uncertainty
cmbp

bs bsh time






















































































e
e









time





cgp




























jlj

conformant via symbolic model checking

ficimatti roveri
bmtc

p




























low unc

cmbp

time




























gpt

time




























high unc

cmbp

time




























gpt

time


























table bmtc
uncertainty cgp almost unable solve trivial gpt performs better
cgp suffers explicit representation search space
bomb toilet uncertain clogging btuc p domain domain
described section clogging uncertain outcome dunking package
kind cannot expressed cgp cmbp gpt reported
table although cmbp performs better gpt factor two three
significant difference behavior interesting compare cmbp
btc btuc gpt slight difference noticeable resulting
increased branching factor search space due uncertainties effects
action executions performance cmbp number uncertainties direct
factor example btc btuc performance almost
ring rooms

simple ring room considered another domain robot move
ring rooms room window open closed locked
robot move clockwise counterclockwise close window room
lock closed goal windows locked


ficonformant via symbolic model checking
cmbp

jpj

btuc
btuc
btuc
btuc
btuc
btuc
btuc
btuc
btuc
btuc

bs bsh






















time











gpt

time











table btuc
n

n





ring r r number rooms uncertainty
initial condition position robot status windows
uncertain parallel solution large number initial
states r r corresponding full uncertainty position robot
status window reported left table cmbp outperforms
ring
ring
ring
ring
ring
ring
ring
ring
ring

jpj











cmbp

bs bsh










time










jlj



cgp

time



gpt

time
















cgp ring

jlj






time






jlj






time






table ring
cgp gpt although gpt performs much better cgp cgp gpt
suffer increasing complexity right table plot
ring dependency cgp number initial states combined
number levels explored different goals provided require
exploration different levels clear number initial states depth
search critical factors cgp
times reported cgp refer scaled version locking taken
account thus maximum number initial states r r



ficimatti roveri
ring rooms uncertain action effects considered variation

ring domain called uring first introduced cimatti roveri
expressible cgp window locked robot performing action
determine status e g closing window open close nondeterministically instance robot moving room room windows
room could open closed wind domain clearly designed stress
ability planner deal actions large number resulting states
worst case e g move action performed window locked r possible
resulting states although seemingly artificial captures fact environments
practice highly nondeterministic tried compare cmbp gpt uring
principle gpt able deal uncertainty action effects however
failed codify uring gpt language requires conditional description uncertain effects therefore experimented variation ring
domain featuring higher degree nondeterminism called ndring following
ndring domain contains increasing number additional propositions called
following noninertial propositions initially unknown nondeterministically
altered action number noninertial propositions action
ndring
ndring
ndring
ndring
ndring
ndring
ndring
ndring
ndring

jpj











cmbp

bs bsh










time










time








gpt

time







time






time





table ndring
possible outcomes listed table columns labeled time
growing branching factor search major impact performance
gpt cmbp insensitive kind uncertainty performance cmbp
lower number noninertial propositions reported basically

uring run cmbp listed table
noticed performances cmbp improve significantly respect ring
explained considering despite larger number transitions
number explored belief states significantly smaller see bs cache statistics
tables
square cube

following domains square n cube n gpt distribution bonet
geffner consist robot navigating square cube side
n domains actions moving robot possible directions
moving robot boundary leaves robot position original


ficonformant via symbolic model checking

uring
uring
uring
uring
uring
uring
uring
uring
uring

jpj










cmbp

bs bsh










time










table uring
called corner following require robot reach corner starting
completely unspecified position introduced two variations first called
face initial position position given side face square cube
goal reach central position opposite side face second called
center initial position completely unspecified goal center
square cube corner simple heuristic perform steps towards
corner thus pruning half actions variations designed allow
simple heuristic instance center action eliminated
square
square
square
square
square
square
square
square
square
square
square
cube
cube
cube
cube
cube
cube
cube
cube
cube
cube
cube

jpj












jpj












corner
cmbp
bs bsh time











corner
cmbp
bs bsh time











gpt

time











gpt

time











jpj












jpj












face
cmbp
bs bsh time











gpt

time











jpj












center
cmbp
bs bsh time











gpt

time











face
center
cmbp
gpt
cmbp
gpt
bs bsh time time jpj bs bsh time time

















table square cube
reported table tests run
cmbp gpt experiments highlight eciency gpt strongly depends
quality heuristic function first set experiments heuristics


ficimatti roveri
effective gpt almost good cmbp otherwise gpt degrades significantly
general finding heuristics effective belief space appears nontrivial
cmbp appears stable performs blind breadth first search
relies cleverness symbolic representation achieve eciency
omelette

finally considered omelette levesque goal
good eggs bad ones one two bowls capacity unlimited number
eggs unpredictably good bad eggs grabbed broken
bowl content bowl discarded poured bowl breaking
rotten egg bowl effect spoiling bowl bowl cleaned
discarding content originally presented partial observability
sensing action allowing test bowl spoiled considered
variation without sensing action case conformant solution
exists used omelette test ability cmbp gpt discover
admits conformant solution reported table
table shows cmbp effective checking absence conformant solution
outperforms gpt several orders magnitude
omelette
omelette
omelette
omelette
omelette
omelette
omelette
omelette
omelette
omelette
omelette

steps












cmbp
bs bsh












time












gpt
time











table omelette
summarizing remarks

overall cmbp appears implement effective conformant
terms expressivity performance cgp able deal uncertainties
initial states cannot conclude admit conformant
solution main cgp seems enumerative uncertainties
increased number initial states severely affects performance see table
table
qbfplan principle able deal uncertain action effects cannot conclude
admit conformant solution small number ex consider increasingly dicult see instance plan length



ficonformant via symbolic model checking
periments could perform implemented qbfplan limited
satplan style search intermediate obtained solving encoding
depth k reused solving encodings increasing depth furthermore
solver appears specialized finding model rather proving unsatisfiability
however latter ability needed encodings final one
gpt expressive system allows eciently dealing wide class
far conformant concerned expressive
cmbp allows dealing uncertain action effects conclude
conformant solution however cmbp appears outperform gpt
several respects first behaviour gpt appears directly related number
possible outcomes action furthermore eciency gpt depends
effectiveness heuristic functions sometimes dicult devise
cannot help admit solution
main strength cmbp independence number uncertainties
achieved use symbolic techniques fully symbolic cmbp
exhibit enumerative behaviour competitors compared original
described cimatti roveri substantial improvement performance
obtained implementation pruning step disclaimer
order well known bdd computations subject blow memory
requirements computing certain classes boolean functions e g multipliers bryant
would trivial make example performance cmbp degrades
exponentially however none examples considered included
examples distribution cgp gpt phenomenon occurred
related work

term conformant first introduced goldman presenting
formalism constructing conformant plans extension dynamic logic recently ferraris giunchiglia presented another conformant planner sat
techniques system available direct comparison cmbp effectiveness dicult evaluate limited testing described ferraris
giunchiglia performance claimed comparable cgp however
reported enconding corresponding solution behaviour
qbfplan reported table suggests kind analysis might limited
several works share idea automata theory closely
related works lines via model checking cimatti et al upon
work allows instance automatically construct
universal plans guaranteed achieve goal finite number steps cimatti
et al b implement trial error strategies cimatti et al daniele
et al obtained hypothesis total observability
run time observation available main difference substantial extension required lift symbolic techniques search space belief states de
giacomo vardi analyze several forms automata theoretic
framework goldman musliner pelican present method model checking
timed automata interleaved plan formation activity make sure


ficimatti roveri
timing constraints met finally hoey colleagues use algebraic decision
diagrams tackle stochastic
conclusions future work

presented conformant use
symbolic model checking techniques general applies
complex domains uncertainty initial condition action effects
described finite state automata breadthfirst backward search returns conformant plans minimal length solution
exists otherwise terminates failure designed
take full advantage symbolic representation bdds implementation
cmbp system highly optimized particular crucial
step termination checking performed experimental comparison
state art conformant planners cgp qbfplan gpt cmbp strictly
expressive qbfplan cgp comparison
possible cmbp outperformed competitors terms run times sometimes
orders magnitude thanks use symbolic data structures cmbp able deal
eciently large numbers initial states action outcomes
hand qualitative behavior cgp gpt seems depend heavily
enumerative nature differently gpt cmbp independent
effectiveness heuristic used drive search
presented extended following directions first
investigating alternative conformant breadthfirst style search given techniques appear extremely promising
preliminary experiments led speed ups two orders magnitude
presented admit solution second tackle
conditional partial observability hypothesis
limited amount information acquired run time conformant
seen search belief space however appears significantly
complicated need dealing run time observation conditional plans finally considering extension domain construction planner
expressive input language c invariant detection techniques
acknowledgements

fausto giunchiglia provided continuous encouragement feedback work
thank piergiorgio bertoli blai bonet marco daniele hector geffner enrico giunchiglia
jussi rintanen david smith paolo traverso dan weld valuable discussions conformant comments david smith provided code
cgp large number examples time mechanism used experimental
evaluation jussi rintanen made qbfplan available linux


ficonformant via symbolic model checking
references

blum l furst l fast graph analysis
proc ijcai
blum l furst l fast graph analysis artificial intelligence
bonet b geffner h incomplete information heuristic se
arch belief space chien kambhampati knoblock c eds th
international conference artificial intelligence scheduling pp
aaai press
brace k rudell r bryant r ecient implementation bdd package th acm ieee design automation conference pp orlando florida
acm ieee ieee computer society press
bryant r e graph boolean function manipulation ieee
transactions computers c
bryant r e complexity vlsi implementations graph representations
boolean functions application integer multiplication ieee transactions
computers
bryant r e symbolic boolean manipulation ordered binary decision diagrams acm computing surveys
burch j r clarke e mcmillan k l dill l hwang l j symbolic
model checking states beyond information computation

cassandra kaelbling l littman acting optimally partially observable
stochastic domains proc aaai aaai press
cimatti clarke e giunchiglia f roveri nusmv symbolic
model checker international journal software tools technology transfer
sttt
cimatti giunchiglia e giunchiglia f traverso p via model
checking decision procedure ar steel alami r eds proceeding
fourth european conference lecture notes artificial
intelligence pp toulouse france springer verlag itc irst technical
report itc irst trento italy
cimatti roveri conformant via model checking biundo
ed proceeding fifth european conference lecture notes
artificial intelligence durham united kingdom springer verlag itc irst
technical report itc irst trento italy


ficimatti roveri
cimatti roveri forward conformant via symbolic model
checking proceeding aips k workshop model theoretic approaches
breckenridge colorado
cimatti roveri traverso p automatic obdd generation
universal plans non deterministic domains proceeding fifteenth national
conference artificial intelligence aaai madison wisconsin aaai press
irst technical report trento italy
cimatti roveri traverso p b strong non deterministic
domains via model checking proceeding fourth international conference
artificial intelligence systems aips carnegie mellon university
pittsburgh usa aaai press
clarke e wing j formal methods state art future directions
acm computing surveys
clarke e emerson e sistla automatic verification finite state concurrent systems temporal logic specifications acm transactions programming
languages systems
coudert madre j c touati h tiger version user guide digital
paris lab
daniele traverso p vardi strong cyclic revisited
biundo ed proceeding fifth european conference lecture
notes artificial intelligence durham united kingdom springer verlag
de giacomo g vardi automata theoretic temporally extended goals biundo ed proceeding fifth european conference lecture notes artificial intelligence durham united kingdom
springer verlag
ferraris p giunchiglia e satisfiability nondeterministic domains proceedings seventeenth national conference artificial intelligence
aaai austin texas aaai press
ghallab howe knoblock c mcdermott ram weld wilkins
pddl domain definition language tech rep cvc
tr dcs tr yale center computational vision control
giunchiglia e determining ramifications situation calculus fifth
international conference principles knowledge representation reasoning
kr cambridge massachusetts morgan kaufmann publishers

giunchiglia e kartha g n lifschitz v representing action indeterminacy
ramifications artificial intelligence


ficonformant via symbolic model checking
giunchiglia e lifschitz v action language causal explanation
preliminary report proceedings th national conference artificial intelligence aaai th conference innovative applications artificial
intelligence iaai pp menlo park aaai press

goldman r p musliner j pelican j model checking
plan hard real time controllers proceeding aips k workshop modeltheoretic approaches breckenridge colorado
goldman r boddy expressive explicit knowledge
proceedings rd international conference artificial intelligence
systems aips pp aaai press

hoey j st aubin r hu boutilier c spudd stochastic decision diagrams proceedings fifteenth conference uncertainty
articial intelligence pp aaai press
kautz h selman b blackbox application
theorem proving solving working notes workshop
combinatorial search pittsburgh pa usa
kautz h mcallester selman b encoding plans propositional logic
proc kr
kautz h selman b pushing envelope propositional logic
stochastic search proc aaai
kushmerick n hanks weld probabilistic
artificial intelligence
levesque h j presence sensing proceedings
thirteenth national conference artificial intelligence eighth innovative
applications artificial intelligence conference pp menlo park aaai

press mit press
mcdermott critique pure reason computational intelligence

mcmillan k symbolic model checking kluwer academic publ
michie machine intelligence edinburgh machine intelligence pp
edinburgh university press
nilsson n principles artificial intelligence morgan kaufmann publishers inc
los altos ca
peot decision theoretic ph thesis dept engineering economic
systems stanford university
rintanen j constructing conditional plans theorem prover journal
artificial intellegence


ficimatti roveri
rintanen j b improvements evaluation quantified boolean formulae
dean ed th iinternational joint conference artificial intelligence pp
morgan kaufmann publishers
smith e weld conformant graphplan proceedings th
national conference artificial intelligence aaai th conference
innovative applications artificial intelligence iaai pp menlo

park aaai press
somenzi f cudd cu decision diagram package release department
electrical computer engineering university colorado boulder
weld anderson c r smith e extending graphplan handle
uncertainty sensing actions proceedings th national conference
artificial intelligence aaai th conference innovative applications artificial intelligence iaai pp menlo park aaai press

yang b bryant r e hallaron r biere coudert janssen g ranjan
r k somenzi f performance study bdd model checking
proceedings formal methods computer aided design pp




