Journal Artificial Intelligence Research 29 (2007) 191219

Submitted 07/2006; published 06/2007

Language Search
Jinbo Huang

jinbo.huang@nicta.com.au

Logic Computation Program
National ICT Australia

Adnan Darwiche

darwiche@cs.ucla.edu

Computer Science Department
University California, Los Angeles

Abstract
paper concerned class algorithms perform exhaustive search
propositional knowledge bases. show algorithms defines generates
propositional language. Specifically, show trace search interpreted
combinational circuit, search algorithm defines propositional language
consisting circuits generated across possible executions algorithm.
particular, show several versions exhaustive DPLL search correspond
well-known languages FBDD, OBDD, precisely-defined subset d-DNNF.
thus mapping search algorithms propositional languages, provide uniform
practical framework successful search techniques harnessed compilation
knowledge various languages interest, new methodology whereby power
limitations search algorithms understood looking tractability
succinctness corresponding propositional languages.

1. Introduction
Systematic search algorithms lie core wide range automated reasoning systems,
many based procedure branches node search tree
generated splitting possible values chosen variable. One prototypical example
DPLL algorithm (Davis, Logemann, & Loveland, 1962) propositional satisfiability
(SAT). Given propositional formula, problem SAT determine whether
formula satisfying assignmentan assignment Boolean values (0 1)
variables formula evaluates 1. example, (x1 = 0, x2 = 1, x3 = 0)
satisfying assignment following formula: (x1 x2 )(x1 x2 x3 )(x1 x2 x3 ).
determine satisfiability given formula , DPLL chooses variable x
formula, recursively determines whether satisfiable case x set 0, case x
set 1, declares satisfiable precisely least one two cases results
positive answer. effect, algorithm performs systematic search space
variable assignments terminates either finding satisfying assignment,
realizing assignment exists.
Despite simplicity, DPLL long remained basis SAT solvers
employ systematic search (Berre & Simon, 2005), finds natural counterparts
general constraint satisfaction problems, variables restricted
Boolean domain. Several decades sustained research greatly enhanced efficiency
scalability DPLL-based search algorithms, today routinely used solve

c
2007
AI Access Foundation. rights reserved.

fiHuang & Darwiche

practical problems several million variables (Zhang & Malik, 2002). algorithms
successful, indeed, become recent trend areas formal
verification modify produce solutions propositional formula (McMillan,
2002; Chauhan, Clarke, & Kroening, 2003; Grumberg, Schuster, & Yadgar, 2004),
alternative traditional practice (McMillan, 1993) converting formula
ordered binary decision diagram (OBDD) (Bryant, 1986). modifications thus involved
form DPLL search terminate finding first solution,
extended exhaust whole search space. formula shown earlier,
example output exhaustive search could following set three solutions
{(x1 = 0, x2 = 1, x3 = 0), (x1 = 1, x2 = 0, x3 = 0), (x1 = 1, x2 = 1)}. Note solution
defined assignment Boolean values (possibly all) variables
satisfies formula regardless values variables. last solution
set, example, represents two satisfying assignments variable x3 free
assume either value.
Producing solutions propositional formula is, course, one possible
computational tasks exhaustive search useful. tasks include
counting number satisfying assignments formula, known model counting
(Birnbaum & Lozinskii, 1999; Bayardo & Pehoushek, 2000; Bacchus, Dalmao, & Pitassi,
2003b; Sang, Bacchus, Beame, Kautz, & Pitassi, 2004; Sang, Beame, & Kautz, 2005),
processing certain types queries belief constraint networks (Dechter & Mateescu,
2004b, 2004a).
paper uncover fundamental connection class exhaustive
search algorithms, group propositional languages extensively studied field knowledge compilation (Darwiche & Marquis, 2002). Specifically, show
exhaustive search algorithm based variable splitting, run propositional
knowledge bases, defines generates propositional language precise sense:
trace single search, recorded graph, interpreted combinational
circuit logically equivalent propositional knowledge base search
run; search algorithm defines propositional language consisting
circuits generated legal executions algorithm. show, particular,
exhaustive DPLL corresponds language FBDD (free binary decision diagrams)
(Blum, Chandra, & Wegman, 1980), exhaustive DPLL fixed variable ordering corresponds language OBDD (ordered binary decision diagrams) (Bryant, 1986),
exhaustive DPLL decomposition corresponds well defined subset language
d-DNNF (deterministic decomposable negation normal form) (Darwiche, 2001).
establishment correspondence supplies bridge field knowledge compilation, areas automated reasoning, including propositional satisfiability, search algorithms extensively studied. particular, leads
following two sets theoretical practical benefits.
First, show class search algorithms described immediately
turned knowledge compilers respective propositional languages define,
simply recording trace search. realization provides uniform practical framework successful techniques developed context search
directly used compilation knowledge various languages interest. particular,
discuss recent advances DPLL search, including sophisticated conflict analysis,
192

fiThe Language Search

dependency-directed backtracking, clause learning, new variable ordering heuristics,
data structures faster constraint propagation, harnessed building efficient
practical knowledge compilers.
Second, show how, looking known properties propositional languages,
able answer fundamental level, concrete terms, two important questions
regarding power limitations class search algorithms:
algorithms do? not? Specifically, discuss tractability
propositional language defined search algorithm illustrates power algorithm,
succinctness constraints language illustrate limitations.
complement discussions relating results previous work knowledge compilation recent body work centering notion AND/OR search
(Dechter & Mateescu, 2004b, 2004a; Marinescu & Dechter, 2005). particular, discuss
similarities well differences AND/OR search d-DNNF compilation.
Finally, present experimental results implementations exhaustive search algorithms define distinct propositional languages. use programs compile set
propositional formulas respective languages, demonstrate practicality knowledge compilation framework, empirically illustrate variation
language succinctness response variation search strategy.
remainder paper organized follows. Section 2 reviews number
propositional languages concerned work theoretical roles relations
knowledge compilation. Section 3 discusses DPLL search algorithm propositional
satisfiability exhaustive extension, introduces notion interpreting
trace search combinational circuit. Section 4 detailed exposition mapping
variants exhaustive DPLL FBDD, OBDD, subset d-DNNF, well techniques involved transforming algorithms practical knowledge compilers
respective languages. Section 5 formalizes two fundamental principles relating intrinsic power limitations class exhaustive search algorithms, using recently proposed
model counting algorithms concrete examples. relate results previous work
Section 6, present experimental results Section 7, conclude Section 8. Proofs
theorems given appendix.

2. Propositional Languages Properties
study propositional languages (i.e., representations propositional theories)
central subject knowledge compilation, concerned task converting given knowledge base one language another certain reasoning
tasks become tractable compiled knowledge base (Selman & Kautz, 1991; del Val,
1994, 1995; Marquis, 1995; Selman & Kautz, 1996; Cadoli & Donini, 1997; Darwiche &
Marquis, 2002; Darwiche, 2002, 2004; Coste-Marquis, Berre, Letombe, & Marquis, 2005).
propositional theories compiled language OBDD, example,
equivalence tested time polynomial sizes OBDDs (Meinel &
Theobald, 1998), constant time OBDDs use variable order (Bryant, 1986).
recent applications compilation using language d-DNNF found
fields diagnosis (Barrett, 2004, 2005; Huang & Darwiche, 2005a; Elliott & Williams, 2006;
Siddiqi & Huang, 2007), planning (Barrett, 2004; Palacios, Bonet, Darwiche, & Geffner,
193

fiHuang & Darwiche

(a) NNF

(b) Decision Node



















X







X



(c) Alternatively
X



B

B



C





C





Figure 1: NNF circuit decision node.
2005; Huang, 2006; Bonet & Geffner, 2006), probabilistic reasoning (Chavira & Darwiche,
2005; Chavira, Darwiche, & Jaeger, 2006), query rewrites databases (Arvelo, Bonet,
& Vidal, 2006).
section review set propositional languages discuss established
body results concerning tractability succinctness (Darwiche & Marquis, 2002)
several languages resurface Section 4 exhaustive search
algorithms mapped, properties prove vital formalization Section 5
two fundamental principles relating power limitations exhaustive search
algorithms.
2.1 Propositional Languages
Following conventions Darwiche Marquis (2002), consider graph representations propositional theories, allow sharing subformulas compactness. Specifically, consider directed acyclic graphs (DAGs) internal node labeled
conjunction (and, ) disjunction (or, ), leaf labeled propositional
literal constant (true/f alse, 1/0). clear DAG effectively
combinational circuit and-gates, or-gates, inverters, inverters appear
next inputs (variables), property characteristic Negation Normal Form
(NNF) (Barwise, 1977). hence refer DAGs NNF circuits set
DAGs NNF language. Figure 1a depicts propositional theory represented
NNF circuit. next define interesting subsets NNF language.
popular language CNF (conjunctive normal form) defined
subset NNF satisfies (i) flatness: height DAG two; (ii)
simple-disjunction: disjunction leaf nodes (i.e., clause). Similarly,
DNF (disjunctive normal form) subset NNF satisfies flatness simpleconjunction: conjunction leaf nodes (i.e., term).
consider next set nested representations, starting DNNF (decomposable
negation normal form) language, set NNF circuits satisfying decomposability: conjuncts conjunction share variables. next language, d-DNNF,
satisfies decomposability determinism: disjuncts disjunction pairwise
logically inconsistent. NNF circuit shown Figure 1a, example, d-DNNF;
194

fiThe Language Search

x1





x2


X3

X1

x1

X2

(a) DNNF

x2

x3
x3

x3

x2

0

1

(b) FBDD

x2

0

1

(c) OBDD

Figure 2: circuit DNNF, FBDD, OBDD.
shown Figure 2a, contrast, DNNF d-DNNF neither two
disjunction nodes satisfies determinism.
FBDD language subset d-DNNF root every circuit
decision node, defined recursively either constant (0 1) disjunction
form Figure 1b X propositional variable decision nodes.
Note equivalent compact drawing decision node Figure 1c widely
used formal verification literature, FBDDs equivalently known BDDs
(binary decision diagrams) satisfy test-once property: variable appears
root-to-sink path (Gergov & Meinel, 1994).1 See Figure 2b FBDD
example using compact drawing.
OBDD language subset FBDD circuits satisfy ordering
property: variables appear order root-to-sink paths (Bryant, 1986). See
Figure 2c OBDD example (using compact drawing). particular
variable order <, write OBDD< denote corresponding OBDD subset
circuits use order <.
2.2 Succinctness Tractability Propositional Languages
Given choice languages knowledge base may represented, one needs
strike balance size representation support provides
reasoning task hand, two properties representation often run counter
other. CNF, example, often convenient compactly encoding knowledge
base since many applications behavior system naturally described
conjunction behaviors components. However, typical reasoning tasks
efficiently carried CNF representations. efficient algorithm determine,
example, whether arbitrary clause entailed CNF formula. story changes
propositional theory represented language known PI (prime implicates,
subset CNF): definition PI supports linear-time clausal entailment test.
downside is, unfortunately, PI representations exponentially larger
CNF equivalents worst case (Karnaugh, 1953; Forbus & de Kleer, 1993).
therefore interested formally analyzing succinctness tractability
languages, given required reasoning task, choose succinct language
1. FBDDs known read-once branching programs (Wegener, 2000).

195

fiHuang & Darwiche

supports set necessary operations polynomial time. following classical
definition succinctness:
Definition 1. (Succinctness) Let L1 L2 two subsets NNF. L1 least succinct
L2 , denoted L1 L2 , iff exists polynomial p every circuit L2 ,
exists logically equivalent circuit L1 || p(||). Here, || ||
sizes , respectively.
Intuitively, language L1 least succinct language L2 given circuit L2 ,
exists logically equivalent circuit L1 whose size blow up. One
define L1 strictly succinct L2 , denoted L1 < L2 , L1 L2 L2 6 L1 .
languages described Section 2.1 satisfy following succinctness relations: NNF
< DNNF < d-DNNF < FBDD < OBDD, NNF < CNF, DNNF < DNF (Darwiche &
Marquis, 2002). Note, however, L1 L2 imply L1 < L2 general.
words, imposing conditions representation necessarily reduce succinctness.
One example smoothness, requires disjuncts disjunction mention
set variablesit known condition, imposed d-DNNF, reduce
succinctness (Darwiche & Marquis, 2002).
turn tractability languages, refers set polynomial-time
operations support. According Darwiche Marquis (2002), one traditionally
distinguishes two types operations circuits given language: queries
transformations. difference two queries return information
circuits, normally change them, transformations modify circuits generate
new ones (in language).
known results Darwiche Marquis (2002) regarding tractability languages summarized Table 1 (queries) Table 2 (transformations).
abbreviations first row Table 1 stand following eight queries, respectively:
Consistency (is formula satisfiable), Validity (does formula evaluate 1
variable assignments), Clausal Entailment (does formula imply given clause),
Implicant (is formula implied given term), Equivalence (are two formulas logically equivalent), Sentential Entailment (does one formula imply other),
Model Counting (how many satisfying assignments formula have), Model Enumeration (what satisfying assignments formula). abbreviations
first row Table 2 stand following eight transformations, respectively: Conditioning (setting set variables constants), Forgetting (existentially quantifying set
variables), Single-Variable Forgetting (existentially quantifying single variable), Conjunction (conjoining set circuits), Bounded Conjunction (conjoining bounded
number circuits), Disjunction (disjoining set circuits), Bounded Disjunction
(disjoining bounded number circuits), Negation (negating circuit).
Interestingly, Table 1 offers one explanation popularity OBDDs formal verification efficient equivalence testing, among things, often critical. Although
succinct, d-DNNF FBDD known admit polynomial-time equivalence
test (a polynomial-time probabilistic equivalence test possible; see Blum et al., 1980;
Darwiche & Huang, 2002). Note although difference d-DNNF
FBDD extent table, question mark equivalence test (EQ) could
eventually resolved differently two languages.
196

fiThe Language Search

Table 1: Polynomial-time queries supported language ( means supported unless
P=NP ? means dont know).
Language
NNF
DNNF
d-DNNF
BDD
FBDD
OBDD
OBDD<
DNF
CNF

CO




VA




CE




IM




































EQ


?

?



SE








CT






























Table 2: Polynomial-time transformations supported language ( means supported, means supported unless P=NP, ? means dont know).
Language
NNF
DNNF
d-DNNF
BDD
FBDD
OBDD
OBDD<
DNF
CNF

CD










FO



SFO











C


BC































C



BC






















C


?







worth pointing tractability respect queries generally improves language becomes restrictive (has conditions imposed),
tractability respect transformations may not. DNNF, example, supports
subset queries supported OBDD according Table 1, therefore
less tractable OBDD point view. However, comes certain
transformations, operation Forgetting (existential quantification), DNNF becomes tractable OBDD according Table 2. key reason shift
advantage transformations operate circuits given propositional language,
require result languagethis requirement become burden
restrictive language conditions need satisfied result
transformation generated.

197

fiHuang & Darwiche

2.3 Connection Established
summarized discussed section rich body known results concerning
properties various propositional languages. results previously presented
guide task selecting suitable target compilation language applications
knowledge compilation. particular, suggest given reasoning task involving
knowledge compilation, one identify set operations required task,
select succinct target compilation language supporting operations (Darwiche
& Marquis, 2002).
following sections paper, wish establish fundamental connection
propositional languages distinct degrees succinctness tractability,
exhaustive search algorithms running distinct sets constraints. Specifically,
show trace exhaustive search interpreted circuit representing
compilation propositional knowledge base search run, search
algorithm defines propositional language consisting possible traces.
connection serve bridge field knowledge compilation
areas automated reasoning search algorithms extensively
studied, affording two related sets benefits follows.
first direction, show connection provides set practical algorithms
compilation knowledge various languages. Specifically, exhaustive search
algorithm directly turned knowledge compiler recording trace
execution graph, variations search algorithm nicely correspond
compilers different propositional languages. framework knowledge compilation
provides significant advantage many (past well future) advances search
automatically carry knowledge compilation. particular, discuss
knowledge compilers capitalize several important recent advances DPLL search
propositional satisfiability, including sophisticated conflict analysis, dependency-directed
backtracking, clause learning, new variable ordering heuristics, data structures faster
constraint propagation.
second direction, formulate two principles whereby intrinsic power
limitations given exhaustive search algorithm understood identifying
propositional language defined search algorithm. Specifically, tractability
language illustrates power (usefulness) search algorithm succinctness
constraints language illustrates limitations. Using group recently
proposed model counters concrete examples, show search algorithms used
model counters powerful enough support model counting query,
queries known tractable language d-DNNF,
probabilistic equivalence test (Darwiche & Huang, 2002). hand, two fundamental limitations identified algorithms, well exhaustive
search algorithms based variable splitting, first traces restricted
subset d-DNNF, potentially limiting efficiency search, second
inability produce traces without determinism, making overly constrained
compilation knowledge general languages d-DNNF, DNNF.

198

fiThe Language Search

proceed uncover connection search algorithms propositional
languages, starting systematic search algorithm propositional satisfiability,
exhaustive extension, notion trace search.

3. Systematic Search Satisfiability Exhaustive Extension
section introduce notion trace systematic exhaustive search,
show trace interpreted circuit, logically equivalent (and hence
compilation of) propositional knowledge base search run.
context systematically searching satisfying assignments propositional
formula, major approach problem propositional satisfiability (SAT)
come known DPLL (Davis et al., 1962).
3.1 DPLL Search Exhaustive Extension
Algorithm 1 summary DPLL SAT, takes propositional formula CNF,
return 1 (0) precisely formula satisfiable (unsatisfiable). works recursively case analysis assignment selected variable (Line 5): formula
satisfiable either case results satisfiable subformula (Line 6). two
subformulas denote |x=0 |x=1 , result replacing occurrences
x 0 1, respectively. keeping rules Boolean logic, assume
literal becomes evaluates 0 result variable instantiation,
removed every clause contains it; literal becomes evaluates 1,
clauses contain removed. (To facilitate subsequent discussion variants
DPLL, omitted use unit resolution pseudocode. programs
used Section 7, however, employ unit resolution.) effect, Algorithm 1 performs
search space variable assignments finds one satisfies given CNF
formula realizes satisfying assignments exist.
consider extending Algorithm 1 go space satisfying assignmentsby always exploring branches Line 6rather terminate finding first one. Figure 3a depicts search tree exhaustive version DPLL, particular variable ordering, following CNF formula:
(x1 x2 ) (x1 x2 x3 ) (x1 x2 x3 ). Note drawing branches
search use dotted (solid) line denote setting variable 0 (1)we refer
corresponding child search node low (high) child.
Algorithm 1 DPLL(CNF: ): returns satisfiability
1: empty clause
2:
return 0
3: variables
4:
return 1
5: select variable x
6: return DPLL(|x=0 ) DPLL(|x=1 )

199

fiHuang & Darwiche



x1


x1
x2



x2

unsat


sat

x3
unsat

0 x2

unsat




x2


x2


x3
sat


x1

x2 1





0 x3 x3 1 0 x3 x3 1
(b) Equivalent NNF circuit

sat

(a) Termination tree

Figure 3: trace exhaustive DPLL search.
tree depicted Figure 3a known termination tree search,
captures set paths search space explored
termination search. particular, leaf tree labeled sat gives
partial variable assignment satisfies propositional formula regardless values
unassigned variables, whole tree characterizes precisely set satisfying
assignments, algorithm set find succeeded finding.
3.2 Trace Search Issue Redundancy
alluded earlier, would view termination tree trace
search, make two important observations: First, trace
search depicted Figure 3a directly translated circuit NNF depicted
Figure 3b. involved rename sat/unsat 1/0 invoke identity
Figure 1b Figure 1c described Section 2.1. Second, NNF circuit
logically equivalent to, hence compilation of, CNF formula
search run. (Note notion trace different used earlier work
establish power DPLL proof system unsatisfiable CNF formulas.
example, earlier work shown unsatisfiable CNF formula, trace
DPLL converted tree-like resolution refutation (Urquhart, 1995).)
two observations imply exhaustive DPLL powerful knowledge
compiler, long one takes (small) trouble recording trace. viewpoint
knowledge compilation, however, search trace recorded present form may
immediately useful, typically size proportional amount work
done produce it. Answering even linear-time query (which may require single
traversal compiled representation) compilation, example, would
one running whole search again.
problem remedied first realizing quite bit redundancy
search trace drawn. Figure 3a, example, two subgraphs whose
roots labeled x3 isomorphic could merged one.
redundancy, course, present corresponding portions NNF circuit
shown Figure 3b.
200

fiThe Language Search

distinguish two levels dealing issue redundancy trace.
first level, remove redundancy trace reducing tree
DAG, repeated applications following two rules: (i) Isomorphic nodes (i.e.,
nodes label, low child, high child) merged; (ii)
node identical children deleted pointers redirected either one
children (Bryant, 1986). apply reduction rules tree Figure 3a (again
renaming sat/unsat 1/0), get DAG shown Figure 2c (in particular
example second rule apply). Note instead performing reduction
end search two reduction rules suggest, better integrating
rules trace recording process redundant portions trace
recorded first place. brings us technique known unique nodes (Brace,
Rudell, & Bryant, 1991; Somenzi, 2004), discuss detail next section.
Removing redundancy level ensures smallest possible compilation obtained given particular execution search algorithm; however, improve
time complexity search itself. Figure 3a, example, reason
two isomorphic subgraphs (rooted nodes labeled x3 ) first place
search run equivalent subproblems different paths. general case
nontrivial subproblems, solving one source great inefficiency. therefore refer second level dealing issue redundancy,
would able recognize equivalence subproblems avoid carrying
computation again. done using technique
formula caching (Majercik & Littman, 1998), discuss following section.

4. Language Search
established Section 3 notion interpreting trace exhaustive search
circuit. section continue study search algorithms showing
defines propositional language consisting possible traces. look
three algorithms particular: (i) original exhaustive DPLL, (ii) exhaustive DPLL
fixed variable ordering, (iii) exhaustive DPLL decomposition. algorithm
discuss propositional language defines, corresponding knowledge compiler
provides, well issues regarding efficiency knowledge compiler.
4.1 Mapping Exhaustive DPLL FBDD
seen Section 3 application reduction rules, trace exhaustive
DPLL example, depicted Figure 3a, stored compactly Figure 2c,
none circuit language FBDD (which happens
OBDD case).
formally show traces exhaustive DPLL across possible executions
algorithm form propositional language precisely language (reduced)
FBDD defined Section 2 (from assume circuits FBDD
OBDD always given reduced form application two reduction rules).
order first need formalism explicitly recording trace search
graph. purpose introduce Algorithm 2, exactly exhaustive
extension original DPLL (Algorithm 1) except newly introduced function,
201

fiHuang & Darwiche

get-node (given Algorithm 3), provides means recording trace search
form DAG. Specifically, get-node return decision node (in form
Figure 1b) labeled first argument, second argument low child,
third argument high child (Lines 2&4 modified
return terminal decision nodes, instead Boolean constants). Note that,
briefly mentioned Section 3, algorithm trace recorded directly
reduced from, instead producing redundant nodes removed later.
two reduction rules built means unique nodes table, well known
BDD community (Brace et al., 1991; Somenzi, 2004). Specifically, nodes created
get-node stored hash table get-node create new node (i) node
created already exists table (that existing node returned); (ii) second
third arguments (either argument returned). formally state
result follows:
Theorem 1. DAGs returned Algorithm 2 form language (reduced) FBDD.
Theorem 1 immediately provides us CNF-to-FBDD compiler, means
soon search finishes, answer polynomial time query
propositional theory, long query known tractable FBDD. According
Table 1, queries include consistency, validity, clausal entailment, implicant, model
counting, model enumeration. According Blum et al. (1980), one
test equivalence two propositional formulas probabilistically polynomial time
running Algorithm 2 both. hand, propositional theory given Algorithm 2 known polynomial-size representation FBDD, conclude
algorithm able finish polynomial time matter variable
ordering uses.
make Algorithm 2 practical FBDD compiler, need deal issue
redundant computation briefly mentioned Section 3. reason that, despite
use unique nodes controls space complexity, Algorithm 2 still time
complexity proportional size tree version search trace: Portions
DAG end explored multiple times. See Figure 4 example,
two different instantiations first three variables lead subformula,
would compiled twice, unnecessarily, Algorithm 2. alleviate problem,
one resorts technique formula caching (Majercik & Littman, 1998).
Algorithm 4 describes exhaustive DPLL search, caching.
result recursive call DPLLf () stored cache (Line 10) returned,
indexed key (computed Line 5) identifying ; subsequent call 0
Algorithm 2 dpllf (CNF: ): exhaustive DPLL
1: empty clause
2:
return 0-sink
3: variables
4:
return 1-sink
5: select variable x
6: return get-node(x, dpllf (|x=0 ), dpllf (|x=1 ))
202

fiThe Language Search

x5

x6

X1

0
x4

x5

x1

x3

x2

x3

x1

x2

1

x6
x4

x5

X2

1

0

X3
x3
x5
x4

X2

X3
1

1

x6
x5 x6

x4

x5

x6
x5 x6

Figure 4: Reaching subformula via different paths search.
immediately return existing compilation cache (Line 7) 0 found
equivalent (by key comparison Line 6). (Note introduction caching
change identity proposition language defined algorithm.
words, Theorem 1 applies Algorithm 4 well.)
practice, one normally focuses efficiently recognizing formulas syntactically
identical (i.e., set clauses). Various methods proposed
purpose recent years, starting Majercik Littman (1998) used caching
probabilistic planning problems, followed Darwiche (2002) proposed concrete
formula caching method context knowledge compilation, Bacchus, Dalmao,
Pitassi (2003a) Sang et al. (2004) context model counting,
Darwiche (2004) Huang Darwiche (2005b) proposed refinements
method Darwiche (2002).
4.2 Mapping Exhaustive DPLL Fixed Variable Ordering OBDD
Note Algorithm 4, DPLL free choose variable branch (Line 8).
corresponds use dynamic variable ordering heuristic typical SAT solver,
keeping spirit free binary decision diagrams (FBDD).
surprisingly, one switches dynamic static variable ordering, DAGs
produced algorithm restricted subset FBDD. Algorithm 5 implements
change, taking particular variable order second argument, making sure
order enforced choosing next branching point (see Line 8). Across
possible inputs variable orderings, algorithm indeed produce exactly set
circuits language (reduced) OBDD:
Algorithm 3 get-node(int: i, BDD: low, BDD: high)
1: low high
2:
return low
3: node (i, low, high) exists unique-table
4:
return unique-table[(i, low, high)]
5: result = create-bdd-node(i, low, high)
6: unique-table[(i, low, high)] = result
7: return result
203

fiHuang & Darwiche

Theorem 2. DAGs returned Algorithm 5 form language (reduced) OBDD.
therefore provided CNF-to-OBDD compiler Algorithm 5, means
soon search finishes, answer polynomial time query
propositional theory, long query known tractable OBDD.
notably, test equivalence two propositional formulas deterministically
polynomial time running Algorithm 5 both, could Algorithm 2
Algorithm 4. hand, propositional theory given Algorithm 5
known polynomial-size representation OBDD, hidden weighted bit
function (Bryant, 1991), conclude algorithm able finish
polynomial time matter variable ordering uses.
make Algorithm 5 practical OBDD compiler, need deal issue
redundant computation. Naturally, general formula caching method, ones
described earlier, applicable Algorithm 5. constrained search
algorithm, however, special method available shorter cache keys used
reduce cost manipulation. reader referred Huang Darwiche
(2005b) details method, allows one bound number distinct cache
keys, therefore providing space time complexity bound. particular,
specific caching scheme force, space time complexity Algorithm 5
shown exponential cutwidth given CNF formula. variant caching
scheme allows one show parallel complexity terms pathwidth (cutwidth
pathwidth comparable).
emphasize Algorithm 5 represents distinct way OBDD construction,
contrast standard method widely adopted formal verification one recursively
builds OBDDs components system (or propositional formula) compiled
combines using Apply operator (Bryant, 1986). well-known problem
latter method intermediate OBDDs arise process grow large
make manipulation impossible, even final result would tractable
size. Considering final OBDD really one after, Algorithm 5 affords
solution problem building exactly it, less (although may
work linear OBDD size, inconsistent subproblems
contribute OBDD size, caching complete). empirical
Algorithm 4 DPLLf (CNF: ): exhaustive DPLL caching
1: empty clause
2:
return 0-sink
3: variables
4:
return 1-sink
5: key = compute-key()
6: exists cache entry (key, result)
7:
return result
8: select variable x
9: result = get-node(x, DPLLf (|x=0 ), DPLLf (|x=1 ))
10: cache-insert(key, result)
11: return result
204

fiThe Language Search

ABC
ADE
BC
DE






BC



B C
E






DE

B



B





C




B

E
0






C

1

(a) Mixture decision conjunction nodes






B
E

(b) Equivalent NNF circuit

Figure 5: Trace exhaustive DPLL decomposition.
comparison compilation algorithm traditional OBDD construction method
found Huang Darwiche (2005b).
4.3 Mapping Exhaustive DPLL Decomposition Subset d-DNNF
observed, particular case model counting, efficiency exhaustive DPLL improved introducing decomposition, known component
analysis (Bayardo & Pehoushek, 2000; Bacchus et al., 2003b; Sang et al., 2004, 2005).
idea propositional formula breaks conjunction disjoint subformulas (i.e., share variables), subformula processed separately
results combined.
Algorithm 6 implements decomposition exhaustive DPLL relaxing constraint
Algorithm 4: Immediately Line 8 Algorithm 4, need insist
case analysis performed variable x formula; instead, examine
current formula, attempt decompose (Line 5) subsets share
Algorithm 5 DPLLo (CNF: , order: ): exhaustive DPLL fixed variable ordering
1: empty clause
2:
return 0-sink
3: variables
4:
return 1-sink
5: key = compute-key()
6: exists cache entry (key, result)
7:
return result
8: x = first variable order appears
9: result = get-node(x, DPLLo (|x=0 , ), DPLLo (|x=1 , ))
10: cache-insert(key, result)
11: return result
205

fiHuang & Darwiche

variable (we assume process nondeterministic; is, detect
decomposition points). search run subformulas separately
recursively (Lines 79), separate subtraces result connected
means and-node indicate results recursive call combined
(Line 10). case decomposition performed (Line 6 fails), branch selected
variable regular DPLL (Lines 14&15).
Figure 5a shows result example execution algorithm, instantiation first variable breaks CNF formula two disjoint clauses,
processed separately results combined and-node. Figure 5b shows
trace drawn equivalently explicit NNF circuit (for ease viewing constants
removed decision nodes bottom compacted corresponding literals
represent).
witnessed, use decomposition exhaustive DPLL resulted
new type node trace, returned get-and-node Line 10 Algorithm 6.
old get-node function (Line 15) still returns decision nodes (in relaxed sense,
children necessarily decision nodes) form Figure 1c. unique nodes
technique extended straightforward way isomorphic and-nodes,
well duplicate children and-node, created.
ready discuss proposition language defined Algorithm 6,
purpose first define following subset d-DNNF language, determinism
fulfilled means decision nodes (again, relaxed sense):
Definition 2. language decision-DNNF set d-DNNF circuits
disjunction nodes form Figure 1b, (x ) (x ), x variable.2
2. Note that, unlike FBDD, either conjunction disjunction node.

Algorithm 6 DPLLd (CNF: ): exhaustive DPLL decomposition
1: empty clause
2:
return 0-sink
3: variables
4:
return 1-sink
5: components = exhaustive partitions disjoint variable sets
6: |components| > 1
7:
conjuncts = {}
8:
c components
9:
conjuncts = conjuncts {DPLLd (c )}
10:
return get-and-node(conjuncts)
11: key = compute-key()
12: exists cache entry (key, result)
13:
return result
14: select variable x
15: result = get-node(x, DPLLd (|x=0 ), DPLLd (|x=1 ))
16: cache-insert(key, result)
17: return result
206

fiThe Language Search

formally state result (again, assume circuits always given
reduced form application appropriate reduction rules described earlier,
although allowed redundancy figures ease viewing):
Theorem 3. DAGs returned Algorithm 6 form language (reduced) decision-DNNF.
hence provided CNF-to-decision-DNNF compiler Algorithm 6,
serve d-DNNF compiler practice since decision-DNNF d-DNNF. means
search finishes, answer polynomial time query input
propositional formula, long query known tractable language dDNNF (see Table 1). hand, Algorithm 6 able finish polynomial
time propositional theory polynomial-size representation dDNNF (and decision-DNNF), matter variable ordering decomposition method
uses.
Again, one needs implement form formula caching make Algorithm 6
practical compiler. Several caching methods proposed d-DNNF compilation,
latest effective appeared Darwiche (2004). However, refer
reader Darwiche (2001) caching scheme specific decomposition method
based known dtrees (which discuss next). scheme effective
one Darwiche (2004) former may miss equivalences would
caught latter, yet allows one show space time complexity Algorithm 6, caching scheme force, exponential treewidth
CNF formula (as compared pathwidth cutwidth OBDD compilation discussed
Section 4.2). Considering model counting linear-time query supported
d-DNNF language, results Darwiche (2001) imply DPLL decomposition (such Algorithm 6) used count models time space complexity
exponential treewidth CNF formula; see Bacchus et al. (2003a)
alternative derivation complexity result. Interestingly, similar structure-based
measure complexity appears known FBDD compilation.
Finally, would briefly discuss distinction two possible methods
decomposition. Algorithm 6 suggests dynamic notion decomposition, disjoint
components recognized variable split. dynamic decomposition
initially proposed utilized Bayardo Pehoushek (2000) model counting
adopted recent model counters (Sang et al., 2004, 2005). Darwiche (2002, 2004)
proposed another method performing decomposition less dynamically preprocessing CNF formula generate dtree (decomposition tree), binary tree
whose leaves correspond clauses CNF formula. node dtree defines
set variables, called cutset, whose instantiation guaranteed decompose
CNF formula node disjoint components. rationale cost
dynamically computing partition (Line 5 Algorithm 6) many times search
replaced lesser cost computing static recursive partition
all. method decomposition allows one provide structure-based computational
guarantees discussed above. Moreover, instantiation variables cutset
performed dynamically, utilizing dynamic variable ordering heuristics typically done
SAT solvers. use dtrees, combined dynamic variable ordering, leads
almost static behavior highly structured problems, cutsets small. Yet, one
207

fiHuang & Darwiche

sees dynamic behavior less structured problems, random 3-SAT,
cutsets relatively large dynamic variable ordering tends dominate. Interestingly, static behavior dtrees (low overhead) orders magnitude efficient
purely dynamic behavior structured benchmarks, including ISCAS85 circuits.
hand, dynamic behavior dtrees lead competitive results
unstructured benchmarks, including random 3-SAT. One may obtain results effect
running model counter Sang et al. (2004), Cachet Version 1.1, d-DNNF
compiler Darwiche (2004), c2d Version 2.2, relevant benchmarks. noted
two programs differ aspects, decomposition method appears
one major differences.
4.4 Harnessing Search Techniques Knowledge Compilation
Research recent years greatly improved efficiency scalability systematic
search methods, particularly problem propositional satisfiability. Techniques contributing improvement include sophisticated conflict analysis, dependencydirected backtracking, clause learning, new variable ordering heuristics, data structures
faster constraint propagation, among things (Marques-Silva & Sakallah, 1996;
Marques-Silva, 1999; Aloul, Markov, & Sakallah, 2001; Moskewicz, Madigan, Zhao, Zhang,
& Malik, 2001; Zhang, Madigan, Moskewicz, & Malik, 2001; Goldberg & Novikov, 2002;
Zhang & Malik, 2002; Heule & van Maaren, 2004). hand, described
section uniform framework systematic search algorithms converted
knowledge compilers exhausting search space recording trace search.
framework affords opportunity many successful search techniques
carry knowledge compilation. refer reader Bayardo Pehoushek (2000),
Darwiche (2002, 2004), Huang Darwiche (2005b), Sang et al. (2004, 2005) detailed discussions issues arise implementation techniques
search extended exhaustion, trace search needs stored,
decomposition introduced.
Finally, note efficiency search addressed techniques (including caching particular) important practical issue, orthogonal
language generated search, main focus present paper. simple
example, one may two versions Algorithm 5 drastically different running
times input one much better caching method,
end day, bound produce exactly OBDD due canonicity
OBDDs. another example, learned clause provided conflict analysis reduce
number search nodes, affect final DAG (circuit) generated,
nodes avoided correspond contradictions (the constant 0) would
appear DAG anyway due reduction rules.

5. Power Limitations Exhaustive Search Algorithms
Sections 3 4 established notion interpreting trace exhaustive
search circuit, mapping search algorithm propositional language
consisting possible traces. notion provides new perspective intrinsic
power limitations search algorithms, illustrated Section 4
208

fiThe Language Search











B

C




C



B B
(a) General determinism




B

(b) Nondeterminism

Figure 6: DPLL unable produce general determinism nondeterminism.
discussing usefulness search algorithms knowledge compilers inherent
inefficiency certain classes inputs. section formalize
concepts illustrate using examples real implementations exhaustive
search algorithms.
Consider arbitrary exhaustive search algorithm based variable splitting, call
DPLLx , suppose traces form propositional language Lx . intrinsic power
limitations DPLLx identified following two principles, respectively:
1. DPLLx runs polynomial time class formulas, DPLLx (with trace
recorded) answer polynomial time query formulas known
tractable language Lx .
2. DPLLx run polynomial time formulas polynomial-size
representations exist Lx .
Take example model counters recently proposed Bayardo Pehoushek
(2000) Sang et al. (2004, 2005), employ techniques decomposition
(the latter also) formula caching. simple analysis model counters shows
traces language decision-DNNF.3 consider query testing
whether minimization theory implies particular clause , min() |= ,
min() defined theory whose models exactly minimum-cardinality models
. query heart diagnostic nonmonotonic reasoning known
tractable d-DNNF. Applying first principle above, noting decisionDNNF d-DNNF, conclude query answered polynomial time
class formulas model counters Bayardo Pehoushek (2000) Sang
et al. (2004, 2005) polynomial time complexity. Similarly, probabilistic equivalence
test performed polynomial time formulas models counters
polynomial time complexity.
example second principle above, first note neither
model counters finish polynomial time formulas polynomial-size
representations exist decision-DNNF. Furthermore, recall decision-DNNF defined
Definition 2 strict subset d-DNNF: Every disjunction decision-DNNF circuit
3. See DDP algorithm Bayardo Pehoushek (2000) Table 1 Sang et al. (2004).
example, variable splitting (Lines 59) Table 1 Sang et al. (2004) corresponds generation
decision node, ToComponents function (Line 6 Line 8) corresponds generation
and-node satisfies decomposability.

209

fiHuang & Darwiche

form (x ) (x ), d-DNNF allows disjunctions form
logically inconsistent, yet contradict particular
variable (Figure 6a gives one example). Recall model counting query remains
tractable one generalizes decision-DNNF d-DNNF. decision-DNNF turns
succinct d-DNNF, therefore, one may find another generation model
counters, well d-DNNF compilers exponentially efficient
current ones.
Finally, note DPLL traces inherently bound NNF circuits
deterministic decomposable. Decomposability alone, however, sufficient
tractability important tasks clausal entailment testing, existential quantification variables, cardinality-based minimization (Darwiche & Marquis, 2002). DPLL
cannot generate traces DNNF d-DNNF (Figure 6b example), since
variable splitting (the heart DPLL) amounts enforcing determinism. property determinism provides power needed model counting (#SAT),
essential applications probabilistic reasoning. one need
power, one go beyond DPLL-based procedures; otherwise one would solving
harder computational problem necessary.

6. Relation Previous Work
employed notion trace search paper provide theoretical
practical channel advances systematic search knowledge compilation. channel indeed active time, implicitly mostly one
direction: systematic search algorithms employed compile knowledge bases (see,
example, Darwiche, 2002, 2004; Huang & Darwiche, 2005b; Darwiche, 2005). fact,
techniques variable ordering, decomposition, caching extensively
used bodies work, used (some recently) pure search
algorithms.
key contribution paper formally explicating notion search
trace, proposing basis systematic framework compiling knowledge
bases subsets NNF. contrasted earlier systematic studies
NNF (Darwiche & Marquis, 2002), concerned describing various
properties compiled NNF representations without delving algorithmic nature
generating them. Another key contribution paper activating second
direction search/compilation channel: looking language membership search
traces formally characterize power limitations various search algorithms.
recent line work, centering notion AND/OR search,
concerned understanding power limitations various search techniques,
decomposition caching, measuring size explored search spaces (Dechter
& Mateescu, 2004b, 2004a; Marinescu & Dechter, 2005). premise work
traditional search algorithms (based branching) thought exploring
ORsearch space, recent search algorithms (employing decomposition) thought
exploring AND/ORsearch space. Here, space AND/OR search characterized graph (or tree caching used) alternating layers AND-nodes
OR-nodes, former representing decomposition latter branching. algorithms
210

fiThe Language Search

exploring AND/ORsearch space therefore exhibit behavior similar Algorithm 6, used compiling CNF d-DNNF (Darwiche, 2002, 2004, 2005)), except
Algorithm 6 records AND/ORsearch space explicitly circuit. Hence, AND/OR
search Algorithm 6 share limitations discussed DPLL: cannot take
advantage general notion determinism, rid determinism altogether.
note proposed algorithms AND/OR search proceed instantiating variables performing decomposition according pseudo tree (Freuder & Quinn,
1985), earlier work d-DNNF compilation uses decomposition tree two
tasks (corresponding choices Lines 5 14 Algorithm 6). Pseudo trees decomposition trees similar provide scheme instantiation
certain set variables lead decomposition problem. framework
proposed paper, however, make commitment either decomposition
variable ordering scheme, relevant discussion. One note
though commitment particular decomposition variable ordering scheme
significant practical implications. Specifically, search algorithm whose trace
d-DNNF may performing variable ordering decomposition way
prohibit possibility generating certain (space efficient) d-DNNF circuits.
Finally, one identify major difference AND/OR search d-DNNF
compilation, terms handling queries: execution AND/OR search
algorithm answers single query, executing d-DNNF compilation algorithm
results compact structure used repeatedly answer queries (for
knowledge base) known tractable. discussed earlier, traversing
compiled structure potentially much efficient repeating search
produced it. point view, separation search actual reasoning
task provides benefit amortizing search effort potentially large number
queries. provides, discussed, systematic methodology
independent advances search harnessed improve performance automated
reasoning systems.

7. Experimental Results
way experimentation, ran implementations Algorithm 5 using MINCE variable ordering heuristic (Aloul et al., 2001), Algorithm 4 using VSIDS variable ordering
heuristic (Moskewicz et al., 2001), Algorithm 6 using static decomposition hypergraph partitioning (Darwiche & Hopkins, 2001), compile set CNF formulas
OBDD, FBDD, d-DNNF, respectively (implementation details first third
programs found Huang & Darwiche, 2005b Darwiche, 2004). goal
experiments show practicality search-based compilation framework
illustrate improvement language succinctness response relaxation
constraints search process. benchmarks used include random 3-CNF
graph coloring problems Hoos Stutzle (2000), set ISCAS89 circuits.
results experiments shown Table 3, running times
given seconds based 2.4GHz CPU. size compilation reflects number
edges NNF DAG. dash indicates compilation succeed given
available memory (4GB) 900-second time limit. seen
211

fiHuang & Darwiche

Table 3: Compiling CNF OBDD, FBDD, d-DNNF.
CNF
Name
uf75-01
uf75-02
uf75-03
uf100-01
uf100-02
uf100-03
uf200-01
uf200-02
uf200-03
flat75-1
flat75-2
flat75-3
flat100-1
flat100-2
flat100-3
flat200-1
flat200-2
flat200-3
s820
s832
s838.1
s953
s1196
s1238
s1423
s1488
s1494

Number
Models
2258
4622
3
314
196
7064
112896
1555776
804085558
24960
774144
25920
684288
245376
11197440
5379314835456
13670940672
15219560448
8388608
8388608
73786976294838206464
35184372088832
4294967296
4294967296
2475880078570760549798248448
16384
16384

OBDD
Size
Time
10320
0.14
22476
0.15
450
0.02
2886
2.22
1554
0.91
12462
0.78
8364
651.04




23784
0.16
13374
0.28
84330
0.29
62298
0.78
88824
1.57
15486
0.15






1372536 72.99
1147272 76.55
87552
0.24
2629464 38.81
4330656 78.26
3181302 158.84


6188427 50.35
3974256 31.67

FBDD
Size
Time
3684
0.02
14778
0.04
450
0.02
2268
0.01
1164
0.07
9924
0.12
7182
35.93
12900
33.72
662238 56.61
10758
0.04
8844
0.04
26472
0.07
37704
0.10
39882
0.30
21072
0.09


134184 7.07
358092 4.13
364698 0.69
362520 0.70


1954752 4.01
4407768 12.49
4375122 12.14


388026 1.14
374760 1.07

d-DNNF
Size
Time
822
0.02
1523
0.03
79
0.01
413
0.02
210
0.04
1363
0.02
262
3.66
744
2.64
86696 10.64
2273
0.01
1838
0.01
4184
0.04
3475
0.03
6554
0.09
2385
0.02
184781 56.86
9859 23.81
9269
3.28
23347
0.07
21395
0.05
12148
0.02
85218
0.26
206830 0.44
293457 0.94
738691 4.75
51883
0.19
55655
0.18

instances, compilation smallest d-DNNF, FBDD, OBDD;
similar relation observed among running times. Also, number instances
successfully compiled largest d-DNNF, FBDD, OBDD. tracks
well theoretical succinctness relations three languages. (However, note
FBDD d-DNNF canonical representations therefore compilations smaller
reported perfectly possible; smaller OBDD compilations are, course,
possible different variable orderings.)
close section noting implementations knowledge compilers
bear witness advantage search-based compilation framework described
Section 4. first compiler based existing SAT solver (Moskewicz et al.,
2001), two implementation DPLL, three benefiting
techniques found success SAT, including conflict analysis, clause learning,
data structures efficient detection unit clauses.

212

fiThe Language Search

8. Conclusion
work concerned class exhaustive search algorithms run propositional knowledge bases. proposed novel methodology whereby trace search
identified combinational circuit search algorithm mapped propositional language consisting possible traces. mapping leads uniform
practical framework compilation propositional knowledge bases various languages
interest, time provides new perspective intrinsic power limitations exhaustive search algorithms. interesting examples, unveiled hidden
power several recent model counters, discussed one potential limitations,
pointed inability class algorithms produce traces without property
determinism, limits power knowledge compilation point view.
discussed generality results relation recent work AND/OR
search. Finally, presented experimental results demonstrate practicality
search-based knowledge compilation framework illustrate variation language
succinctness response variation search strategy.

Acknowledgments
Parts work presented DPLL Trace: SAT Knowledge
Compilation, Proceedings 19th International Joint Conference Artificial Intelligence (IJCAI), 2005, pages 156162. thank Rina Dechter anonymous reviewers
feedback earlier drafts paper. work partially supported
NSF grant IIS-9988543, MURI grant N00014-00-1-0617, JPL/NASA contract 442511DA-57765. National ICT Australia funded Australian Governments Backing
Australias Ability initiative, part Australian Research Council.

Appendix
Proof Theorem 1
first point recursion guaranteed terminate recursive call
(Line 6) accompanied disappearance one variable eventually either Line 2
Line 4 execute. Assuming compact drawing decision nodes Figure 1c,
show every DAG returned Algorithm 2 FBDD, every FBDD
generated execution Algorithm 2.
Part I: three return statements Algorithm 2: Lines 2, 4, 6. single
nodes returned Lines 2 4 trivial FBDDs. DAG returned get-node
Line 6, call G, decision node induction level recursion. Hence remains
show G satisfies test-once property (equivalent decomposability case
discussed Section 2.1), true Line 6, variable x replaced
constants two recursive calls, hence cannot appear two graphs
supplied second third arguments get-node. Finally, FBDDs returned
algorithm guaranteed reduced use unique nodes technique
get-node function (Brace et al., 1991).

213

fiHuang & Darwiche

Part II: Let G denote arbitrary (reduced) FBDD, root node. Define
following function (G) returns CNF formula (as set clauses) every G:


{the empty clause},




{},
(G)

{x c | c (G.low)} {x c | c (G.high)},



G 0-sink;
G 1-sink;
otherwise, node G
labeled variable x.

last line definition above, assume literal x (and x) always appended
front clause c. execute Algorithm 2 (G), Line 5 always choose
first variable clause (the first variable every clause must same).
DAG returned isomorphic G.
Proof Theorem 2
show every DAG returned Algorithm 5 OBDD, every OBDD
generated execution Algorithm 5.
Part I: First, DAG returned Algorithm 5 FBDD Algorithm 5
restricted version Algorithm 2. Second, DAG OBDD nonterminal
node N DAG must constructed Line 9, therefore virtue Line 8 satisfies
following property: variable x labels N appears variables
two subgraphs N variable order . Finally, OBDDs returned algorithm
guaranteed reduced use unique nodes technique get-node
function (Brace et al., 1991).
Part II: Given arbitrary (reduced) OBDD G, let variable order G.
using (G) defined previous proof, execute Algorithm 5 ((G), ). DAG
returned isomorphic G.
Proof Theorem 3
show every DAG returned Algorithm 6 decision-DNNF circuit,
every decision-DNNF circuit generated execution Algorithm 6.
Part I: Nodes returned get-and-node Line 10 conjunction nodes satisfy
decomposability components identified Line 5 share variables. Nodes
returned get-node Line 15 disjunction nodes form Figure 1c
definition get-node. Therefore whole DAG decision-DNNF. Finally, decisionDNNF circuits returned algorithm guaranteed reduced use
unique nodes technique get-node get-and-node functions.
Part II: Let G denote arbitrary (reduced) decision-DNNF circuit. assuming
compact drawing decision nodes Figure 1c, expand previous definition
(G) follows:


{the empty clause},




{},


[

(G)

(Gi ),







{x c | c (G.low)} {x c | c (G.high)},



214

G 0-sink;
G ^
1-sink;
G
Gi ;


otherwise, node G
labeled variable x.

fiThe Language Search

previous definition (G), assume last line definition above,
literal x (and x) always appended front clause c. Now, let literal
clause associated (possibly empty) list colors follows: lists
initially empty literals x x introduced last line definition;
third line definition, assign distinct color sets unioned,
set, append assigned color head list colors first literal
every clause. execute Algorithm 6 (G) resolve nondeterministic choices
Line 5 (decomposition) Line 14 (variable selection) follows: first literal
clause nonempty list colors, (the first literal every clause must
nonempty list colors) let Line 5 partition set clauses according first color
first literal remove color first literal every clause; otherwise,
(the first literal every clause must mention variable) let Line 5 return single
partition Line 14 choose first variable clause. DAG returned
isomorphic G.

References
Aloul, F., Markov, I., & Sakallah, K. (2001). Faster SAT smaller BDDs via common
function structure. International Conference Computer Aided Design (ICCAD),
pp. 443448.
Arvelo, Y., Bonet, B., & Vidal, M.-E. (2006). Compilation query-rewriting problems
tractable fragments propositional logic. Proceedings 21st National
Conference Artificial Intelligence (AAAI).
Bacchus, F., Dalmao, S., & Pitassi, T. (2003a). Algorithms complexity results
#SAT Bayesian inference. 44th Annual IEEE Symposium Foundations
Computer Science (FOCS), pp. 340351.
Bacchus, F., Dalmao, S., & Pitassi, T. (2003b). DPLL caching: new algorithm
#SAT Bayesian inference. Electronic Colloquium Computational Complexity
(ECCC), 10 (003).
Barrett, A. (2004). hybrid systems universal plans via domain compilation. Proceedings 14th International Conference Automated Planning Scheduling
(ICAPS), pp. 4451.
Barrett, A. (2005). Model compilation real-time planning diagnosis feedback.
Proceedings 19th International Joint Conference Artificial Intelligence
(IJCAI), pp. 11951200.
Barwise, J. (Ed.). (1977). Handbook Mathematical Logic. North-Holland.
Bayardo, R., & Pehoushek, J. (2000). Counting models using connected components.
Proceedings 17th National Conference Artificial Intelligence (AAAI), pp.
157162.
Berre, D. L., & Simon, L. (2005).
http://www.satcompetition.org/.



Annual

SAT

Competitions.

Birnbaum, E., & Lozinskii, E. (1999). good old Davis-Putnam procedure helps counting
models. Journal Artificial Intelligence Research, 10, 457477.
215

fiHuang & Darwiche

Blum, M., Chandra, A. K., & Wegman, M. N. (1980). Equivalence free Boolean graphs
decided probabilistically polynomial time. Information Processing Letters,
10 (2), 8082.
Bonet, B., & Geffner, H. (2006). Heuristics planning penalties rewards using compiled knowledge. Proceedings Tenth International Conference
Principles Knowledge Representation Reasoning (KR), pp. 452462.
Brace, K. S., Rudell, R. L., & Bryant, R. E. (1991). Efficient implementation BDD
package. Proceedings 27th Design Automation Conference (DAC), pp. 4045.
Bryant, R. E. (1986). Graph-based algorithms Boolean function manipulation. IEEE
Transactions Computers, C-35, 677691.
Bryant, R. E. (1991). complexity VLSI implementations graph representations
Boolean functions application integer multiplication. IEEE transactions
Computers, 40, 205213.
Cadoli, M., & Donini, F. M. (1997). survey knowledge compilation. AI Communications, 10, 137150.
Chauhan, P., Clarke, E. M., & Kroening, D. (2003). Using SAT based image computation
reachability analysis. Tech. rep. CMU-CS-03-151, School Computer Science,
Carnegie Mellon University.
Chavira, M., & Darwiche, A. (2005). Compiling Bayesian networks local structure.
Proceedings 19th International Joint Conference Artificial Intelligence
(IJCAI), pp. 13061312.
Chavira, M., Darwiche, A., & Jaeger, M. (2006). Compiling relational Bayesian networks
exact inference. International Journal Approximate Reasoning, 42 (1-2), 420.
Coste-Marquis, S., Berre, D. L., Letombe, F., & Marquis, P. (2005). Propositional fragments
knowledge compilation quantified Boolean formulae.. Proceedings
20th National Conference Artificial Intelligence (AAAI), pp. 288293.
Darwiche, A. (2001). tractability counting theory models application
belief revision truth maintenance. Journal Applied Non-Classical Logics,
11 (1-2), 1134.
Darwiche, A. (2002). compiler deterministic decomposable negation normal form.
Proceedings 18th National Conference Artificial Intelligence (AAAI), pp.
627634.
Darwiche, A. (2004). New advances compiling CNF decomposable negation normal form. Proceedings 16th European Conference Artificial Intelligence
(ECAI), pp. 328332.
Darwiche, A. (2005). c2d compiler user manual. Tech. rep. D-147, Computer Science
Department, UCLA. http://reasoning.cs.ucla.edu/c2d/.
Darwiche, A., & Hopkins, M. (2001). Using recursive decomposition construct elimination
orders, jointrees dtrees. Trends Artificial Intelligence, Lecture notes AI,
2143, pp. 180191. Springer-Verlag.

216

fiThe Language Search

Darwiche, A., & Huang, J. (2002). Testing equivalence probabilistically. Tech. rep. D-123,
Computer Science Department, UCLA.
Darwiche, A., & Marquis, P. (2002). knowledge compilation map. Journal Artificial
Intelligence Research, 17, 229264.
Davis, M., Logemann, G., & Loveland, D. (1962). machine program theorem proving.
Journal ACM, (5)7, 394397.
Dechter, R., & Mateescu, R. (2004a). impact AND/OR search spaces constraint
satisfaction counting. Proceedings 10th International Conference
Principles Practice Constraint Programming (CP), pp. 731736.
Dechter, R., & Mateescu, R. (2004b). Mixtures deterministic-probabilistic networks
AND/OR search spaces. Proceedings 20th Conference Uncertainty
Artificial Intelligence (UAI), pp. 120129.
del Val, A. (1994). Tractable databases: make propositional unit resolution complete compilation. Proceedings Fourth International Conference
Principles Knowledge Representation Reasoning (KR), pp. 551561.
del Val, A. (1995). analysis approximate knowledge compilation. Proceedings
14th International Joint Conference Artificial Intelligence (IJCAI), pp. 830836.
Elliott, P., & Williams, B. (2006). DNNF-based belief state estimation. Proceedings
21st National Conference Artificial Intelligence (AAAI).
Forbus, K. D., & de Kleer, J. (1993). Building Problem Solvers. MIT Press.
Freuder, E. C., & Quinn, M. J. (1985). Taking advantage stable sets variables
constraint satisfaction problems. Proceedings Ninth International Joint Conference Artificial Intelligence (IJCAI), pp. 10761078.
Gergov, J., & Meinel, C. (1994). Efficient analysis manipulation OBDDs
extended FBDDs. IEEE Transactions Computers, 43 (10), 11971209.
Goldberg, E., & Novikov, Y. (2002). BerkMin: fast robust SAT-solver. Design
Automation Test Europe (DATE), pp. 142149.
Grumberg, O., Schuster, A., & Yadgar, A. (2004). Memory efficient all-solutions SAT solver
application reachability analysis. Proceedings 5th International
Conference Formal Methods Computer-Aided Design (FMCAD), pp. 275289.
Heule, M., & van Maaren, H. (2004). Aligning CNF- equivalence reasoning. Proceedings Seventh International Conference Theory Applications Satisfiability Testing (SAT).
Hoos, H. H., & Stutzle, T. (2000). SATLIB: online resource research SAT.
I.P.Gent, H.v.Maaren, T.Walsh, editors, SAT 2000, pp. 283292. IOS Press. SATLIB
available online www.satlib.org.
Huang, J. (2006). Combining knowledge compilation search conformant probabilistic
planning. Proceedings 16th International Conference Automated Planning
Scheduling (ICAPS), pp. 253262.

217

fiHuang & Darwiche

Huang, J., & Darwiche, A. (2005a). compiling system models faster scalable
diagnosis. Proceedings 20th National Conference Artificial Intelligence
(AAAI), pp. 300306.
Huang, J., & Darwiche, A. (2005b). Using DPLL efficient OBDD construction.
Seventh International Conference Theory Applications Satisfiability Testing,
SAT 2004, Revised Selected Papers, Vol. 3542 Lecture Notes Computer Science,
pp. 157172.
Karnaugh, M. (1953). map method synthesis combinational logic circuits. Transactions AIEE, 72 (9), 593599.
Majercik, S. M., & Littman, M. L. (1998). Using caching solve larger probabilistic
planning problems. Proceedings 15th National Conference Artificial Intelligence (AAAI), pp. 954959.
Marinescu, R., & Dechter, R. (2005). AND/OR branch-and-bound graphical models.
Proceedings 19th International Joint Conference Artificial Intelligence
(IJCAI), pp. 224229.
Marques-Silva, J., & Sakallah, K. (1996). GRASPA new search algorithm satisfiability.
Proceedings International Conference Computer Aided Design (ICCAD),
pp. 220227.
Marques-Silva, J. (1999). impact branching heuristics propositional satisfiability
algorithms. Proceedings 9th Portuguese Conference Artificial Intelligence,
pp. 6274.
Marquis, P. (1995). Knowledge compilation using theory prime implicates. Proceedings
14th International Joint Conference Artificial Intelligence (IJCAI), pp. 837
843.
McMillan, K. (1993). Symbolic Model Checking. Kluwer Academic.
McMillan, K. L. (2002). Applying SAT methods unbounded symbolic model checking.
Proceedings 14th International Conference Computer Aided Verification
(CAV), pp. 250264.
Meinel, C., & Theobald, T. (1998). Algorithms Data Structures VLSI Design: OBDD
Foundations Applications. Springer.
Moskewicz, M., Madigan, C., Zhao, Y., Zhang, L., & Malik, S. (2001). Chaff: Engineering
efficient SAT solver. Proceedings 38th Design Automation Conference
(DAC), pp. 530535.
Palacios, H., Bonet, B., Darwiche, A., & Geffner, H. (2005). Pruning conformant plans
counting models compiled d-DNNF representations. Proceedings 15th
International Conference Automated Planning Scheduling (ICAPS), pp. 141
150.
Sang, T., Bacchus, F., Beame, P., Kautz, H., & Pitassi, T. (2004). Combining component
caching clause learning effective model counting. Proceedings Seventh
International Conference Theory Applications Satisfiability Testing (SAT),
pp. 2028.
218

fiThe Language Search

Sang, T., Beame, P., & Kautz, H. (2005). Heuristics fast exact model counting.
Proceedings Eighth International Conference Theory Applications
Satisfiability Testing (SAT), Lecture Notes Computer Science, pp. 226240.
Selman, B., & Kautz, H. (1991). Knowledge compilation using Horn approximation.
Proceedings Ninth National Conference Artificial Intelligence (AAAI), pp.
904909.
Selman, B., & Kautz, H. (1996). Knowledge compilation theory approximation. Journal
ACM, 43 (2), 193224.
Siddiqi, S., & Huang, J. (2007). Hierarchical diagnosis multiple faults. Proceedings
20th International Joint Conference Artificial Intelligence (IJCAI), pp. 581
586.
Somenzi, F. (2004).
CUDD: CU Decision Diagram Package, Release 2.4.0.
http://vlsi.colorado.edu/fabio/CUDD/cuddIntro.html.
Urquhart, A. (1995). complexity propositional proofs. Bulletin Symbolic Logic,
1 (4), 425467.
Wegener, I. (2000). Branching Programs Binary Decision Diagrams: Theory Applications. SIAM Monographs Discrete Mathematics Applications.
Zhang, L., Madigan, C., Moskewicz, M., & Malik, S. (2001). Efficient conflict driven learning
Boolean satisfiability solver. Proceedings International Conference
Computer Aided Design (ICCAD), pp. 279285.
Zhang, L., & Malik, S. (2002). quest efficient Boolean satisfiability solvers.
Proceedings 18th International Conference Automated Deduction (CADE),
Lecture Notes Computer Science, pp. 295313.

219


