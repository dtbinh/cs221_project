journal artificial intelligence

submitted published

language search
jinbo huang

jinbo huang nicta com au

logic computation program
national ict australia

adnan darwiche

darwiche cs ucla edu

computer science department
university california los angeles

abstract
concerned class perform exhaustive search
propositional knowledge bases defines generates
propositional language specifically trace search interpreted
combinational circuit search defines propositional language
consisting circuits generated across possible executions
particular several versions exhaustive dpll search correspond
well known languages fbdd obdd precisely defined subset dnnf
thus mapping search propositional languages provide uniform
practical framework successful search techniques harnessed compilation
knowledge languages interest methodology whereby power
limitations search understood looking tractability
succinctness corresponding propositional languages

introduction
systematic search lie core wide range automated reasoning systems
many procedure branches node search tree
generated splitting possible values chosen variable one prototypical example
dpll davis logemann loveland propositional satisfiability
sat given propositional formula sat determine whether
formula satisfying assignmentan assignment boolean values
variables formula evaluates example x x x
satisfying assignment following formula x x x x x x x x
determine satisfiability given formula dpll chooses variable x
formula recursively determines whether satisfiable case x set case x
set declares satisfiable precisely least one two cases
positive answer effect performs systematic search space
variable assignments terminates finding satisfying assignment
realizing assignment exists
despite simplicity dpll long remained basis sat solvers
employ systematic search berre simon finds natural counterparts
general constraint satisfaction variables restricted
boolean domain several decades sustained greatly enhanced efficiency
scalability dpll search today routinely used solve

c

ai access foundation rights reserved

fihuang darwiche

practical several million variables zhang malik
successful indeed become recent trend areas formal
verification modify produce solutions propositional formula mcmillan
chauhan clarke kroening grumberg schuster yadgar
alternative traditional practice mcmillan converting formula
ordered binary decision diagram obdd bryant modifications thus involved
form dpll search terminate finding first solution
extended exhaust whole search space formula shown earlier
example output exhaustive search could following set three solutions
x x x x x x x x note solution
defined assignment boolean values possibly variables
satisfies formula regardless values variables last solution
set example represents two satisfying assignments variable x free
assume value
producing solutions propositional formula course one possible
computational tasks exhaustive search useful tasks include
counting number satisfying assignments formula known model counting
birnbaum lozinskii bayardo pehoushek bacchus dalmao pitassi
b sang bacchus beame kautz pitassi sang beame kautz
processing certain types queries belief constraint networks dechter mateescu
b
uncover fundamental connection class exhaustive
search group propositional languages extensively studied field knowledge compilation darwiche marquis specifically
exhaustive search variable splitting run propositional
knowledge bases defines generates propositional language precise sense
trace single search recorded graph interpreted combinational
circuit logically equivalent propositional knowledge base search
run search defines propositional language consisting
circuits generated legal executions particular
exhaustive dpll corresponds language fbdd free binary decision diagrams
blum chandra wegman exhaustive dpll fixed variable ordering corresponds language obdd ordered binary decision diagrams bryant
exhaustive dpll decomposition corresponds well defined subset language
dnnf deterministic decomposable negation normal form darwiche
establishment correspondence supplies bridge field knowledge compilation areas automated reasoning including propositional satisfiability search extensively studied particular leads
following two sets theoretical practical benefits
first class search described immediately
turned knowledge compilers respective propositional languages define
simply recording trace search realization provides uniform practical framework successful techniques developed context search
directly used compilation knowledge languages interest particular
discuss recent advances dpll search including sophisticated conflict analysis


fithe language search

dependency directed backtracking clause learning variable ordering heuristics
data structures faster constraint propagation harnessed building efficient
practical knowledge compilers
second looking known properties propositional languages
able answer fundamental level concrete terms two important questions
regarding power limitations class search
specifically discuss tractability
propositional language defined search illustrates power
succinctness constraints language illustrate limitations
complement discussions relating previous work knowledge compilation recent body work centering notion search
dechter mateescu b marinescu dechter particular discuss
similarities well differences search dnnf compilation
finally present experimental implementations exhaustive search define distinct propositional languages use programs compile set
propositional formulas respective languages demonstrate practicality knowledge compilation framework empirically illustrate variation
language succinctness response variation search strategy
remainder organized follows section reviews number
propositional languages concerned work theoretical roles relations
knowledge compilation section discusses dpll search propositional
satisfiability exhaustive extension introduces notion interpreting
trace search combinational circuit section detailed exposition mapping
variants exhaustive dpll fbdd obdd subset dnnf well techniques involved transforming practical knowledge compilers
respective languages section formalizes two fundamental principles relating intrinsic power limitations class exhaustive search recently proposed
model counting concrete examples relate previous work
section present experimental section conclude section proofs
theorems given appendix

propositional languages properties
study propositional languages e representations propositional theories
central subject knowledge compilation concerned task converting given knowledge base one language another certain reasoning
tasks become tractable compiled knowledge base selman kautz del val
marquis selman kautz cadoli donini darwiche
marquis darwiche coste marquis berre letombe marquis
propositional theories compiled language obdd example
equivalence tested time polynomial sizes obdds meinel
theobald constant time obdds use variable order bryant
recent applications compilation language dnnf found
fields diagnosis barrett huang darwiche elliott williams
siddiqi huang barrett palacios bonet darwiche geffner


fihuang darwiche

nnf

b decision node



















x







x



c alternatively
x



b

b



c





c





figure nnf circuit decision node
huang bonet geffner probabilistic reasoning chavira darwiche
chavira darwiche jaeger query rewrites databases arvelo bonet
vidal
section review set propositional languages discuss established
body concerning tractability succinctness darwiche marquis
several languages resurface section exhaustive search
mapped properties prove vital formalization section
two fundamental principles relating power limitations exhaustive search

propositional languages
following conventions darwiche marquis consider graph representations propositional theories allow sharing subformulas compactness specifically consider directed acyclic graphs dags internal node labeled
conjunction disjunction leaf labeled propositional
literal constant true f alse clear dag effectively
combinational circuit gates gates inverters inverters appear
next inputs variables property characteristic negation normal form
nnf barwise hence refer dags nnf circuits set
dags nnf language figure depicts propositional theory represented
nnf circuit next define interesting subsets nnf language
popular language cnf conjunctive normal form defined
subset nnf satisfies flatness height dag two ii
simple disjunction disjunction leaf nodes e clause similarly
dnf disjunctive normal form subset nnf satisfies flatness simpleconjunction conjunction leaf nodes e term
consider next set nested representations starting dnnf decomposable
negation normal form language set nnf circuits satisfying decomposability conjuncts conjunction share variables next language dnnf
satisfies decomposability determinism disjuncts disjunction pairwise
logically inconsistent nnf circuit shown figure example dnnf


fithe language search

x





x


x

x

x

x

dnnf

x

x
x

x

x





b fbdd

x





c obdd

figure circuit dnnf fbdd obdd
shown figure contrast dnnf dnnf neither two
disjunction nodes satisfies determinism
fbdd language subset dnnf root every circuit
decision node defined recursively constant disjunction
form figure b x propositional variable decision nodes
note equivalent compact drawing decision node figure c widely
used formal verification literature fbdds equivalently known bdds
binary decision diagrams satisfy test property variable appears
root sink path gergov meinel see figure b fbdd
example compact drawing
obdd language subset fbdd circuits satisfy ordering
property variables appear order root sink paths bryant see
figure c obdd example compact drawing particular
variable order write obdd denote corresponding obdd subset
circuits use order
succinctness tractability propositional languages
given choice languages knowledge base may represented one needs
strike balance size representation support provides
reasoning task hand two properties representation often run counter
cnf example often convenient compactly encoding knowledge
base since many applications behavior system naturally described
conjunction behaviors components however typical reasoning tasks
efficiently carried cnf representations efficient determine
example whether arbitrary clause entailed cnf formula story changes
propositional theory represented language known pi prime implicates
subset cnf definition pi supports linear time clausal entailment test
downside unfortunately pi representations exponentially larger
cnf equivalents worst case karnaugh forbus de kleer
therefore interested formally analyzing succinctness tractability
languages given required reasoning task choose succinct language
fbdds known read branching programs wegener



fihuang darwiche

supports set necessary operations polynomial time following classical
definition succinctness
definition succinctness let l l two subsets nnf l least succinct
l denoted l l iff exists polynomial p every circuit l
exists logically equivalent circuit l p
sizes respectively
intuitively language l least succinct language l given circuit l
exists logically equivalent circuit l whose size blow one
define l strictly succinct l denoted l l l l l l
languages described section satisfy following succinctness relations nnf
dnnf dnnf fbdd obdd nnf cnf dnnf dnf darwiche
marquis note however l l imply l l general
words imposing conditions representation necessarily reduce succinctness
one example smoothness requires disjuncts disjunction mention
set variablesit known condition imposed dnnf reduce
succinctness darwiche marquis
turn tractability languages refers set polynomial time
operations support according darwiche marquis one traditionally
distinguishes two types operations circuits given language queries
transformations difference two queries return information
circuits normally change transformations modify circuits generate
ones language
known darwiche marquis regarding tractability languages summarized table queries table transformations
abbreviations first row table stand following eight queries respectively
consistency formula satisfiable validity formula evaluate
variable assignments clausal entailment formula imply given clause
implicant formula implied given term equivalence two formulas logically equivalent sentential entailment one formula imply
model counting many satisfying assignments formula model enumeration satisfying assignments formula abbreviations
first row table stand following eight transformations respectively conditioning setting set variables constants forgetting existentially quantifying set
variables single variable forgetting existentially quantifying single variable conjunction conjoining set circuits bounded conjunction conjoining bounded
number circuits disjunction disjoining set circuits bounded disjunction
disjoining bounded number circuits negation negating circuit
interestingly table offers one explanation popularity obdds formal verification efficient equivalence testing among things often critical although
succinct dnnf fbdd known admit polynomial time equivalence
test polynomial time probabilistic equivalence test possible see blum et al
darwiche huang note although difference dnnf
fbdd extent table question mark equivalence test eq could
eventually resolved differently two languages


fithe language search

table polynomial time queries supported language means supported unless
p np means dont know
language
nnf
dnnf
dnnf
bdd
fbdd
obdd
obdd
dnf
cnf

co




va




ce




im




































eq








se








ct






























table polynomial time transformations supported language means supported means supported unless p np means dont know
language
nnf
dnnf
dnnf
bdd
fbdd
obdd
obdd
dnf
cnf

cd










fo



sfo











c


bc































c



bc






















c










worth pointing tractability respect queries generally improves language becomes restrictive conditions imposed
tractability respect transformations may dnnf example supports
subset queries supported obdd according table therefore
less tractable obdd point view however comes certain
transformations operation forgetting existential quantification dnnf becomes tractable obdd according table key reason shift
advantage transformations operate circuits given propositional language
require languagethis requirement become burden
restrictive language conditions need satisfied
transformation generated



fihuang darwiche

connection established
summarized discussed section rich body known concerning
properties propositional languages previously presented
guide task selecting suitable target compilation language applications
knowledge compilation particular suggest given reasoning task involving
knowledge compilation one identify set operations required task
select succinct target compilation language supporting operations darwiche
marquis
following sections wish establish fundamental connection
propositional languages distinct degrees succinctness tractability
exhaustive search running distinct sets constraints specifically
trace exhaustive search interpreted circuit representing
compilation propositional knowledge base search run search
defines propositional language consisting possible traces
connection serve bridge field knowledge compilation
areas automated reasoning search extensively
studied affording two related sets benefits follows
first direction connection provides set practical
compilation knowledge languages specifically exhaustive search
directly turned knowledge compiler recording trace
execution graph variations search nicely correspond
compilers different propositional languages framework knowledge compilation
provides significant advantage many past well future advances search
automatically carry knowledge compilation particular discuss
knowledge compilers capitalize several important recent advances dpll search
propositional satisfiability including sophisticated conflict analysis dependency directed
backtracking clause learning variable ordering heuristics data structures faster
constraint propagation
second direction formulate two principles whereby intrinsic power
limitations given exhaustive search understood identifying
propositional language defined search specifically tractability
language illustrates power usefulness search succinctness
constraints language illustrates limitations group recently
proposed model counters concrete examples search used
model counters powerful enough support model counting query
queries known tractable language dnnf
probabilistic equivalence test darwiche huang hand two fundamental limitations identified well exhaustive
search variable splitting first traces restricted
subset dnnf potentially limiting efficiency search second
inability produce traces without determinism making overly constrained
compilation knowledge general languages dnnf dnnf



fithe language search

proceed uncover connection search propositional
languages starting systematic search propositional satisfiability
exhaustive extension notion trace search

systematic search satisfiability exhaustive extension
section introduce notion trace systematic exhaustive search
trace interpreted circuit logically equivalent hence
compilation propositional knowledge base search run
context systematically searching satisfying assignments propositional
formula major propositional satisfiability sat
come known dpll davis et al
dpll search exhaustive extension
summary dpll sat takes propositional formula cnf
return precisely formula satisfiable unsatisfiable works recursively case analysis assignment selected variable line formula
satisfiable case satisfiable subformula line two
subformulas denote x x replacing occurrences
x respectively keeping rules boolean logic assume
literal becomes evaluates variable instantiation
removed every clause contains literal becomes evaluates
clauses contain removed facilitate subsequent discussion variants
dpll omitted use unit resolution pseudocode programs
used section however employ unit resolution effect performs
search space variable assignments finds one satisfies given cnf
formula realizes satisfying assignments exist
consider extending go space satisfying assignmentsby exploring branches line rather terminate finding first one figure depicts search tree exhaustive version dpll particular variable ordering following cnf formula
x x x x x x x x note drawing branches
search use dotted solid line denote setting variable refer
corresponding child search node low high child
dpll cnf returns satisfiability
empty clause

return
variables

return
select variable x
return dpll x dpll x



fihuang darwiche



x


x
x



x

unsat


sat

x
unsat

x

unsat




x


x


x
sat


x

x





x x x x
b equivalent nnf circuit

sat

termination tree

figure trace exhaustive dpll search
tree depicted figure known termination tree search
captures set paths search space explored
termination search particular leaf tree labeled sat gives
partial variable assignment satisfies propositional formula regardless values
unassigned variables whole tree characterizes precisely set satisfying
assignments set succeeded finding
trace search issue redundancy
alluded earlier would view termination tree trace
search make two important observations first trace
search depicted figure directly translated circuit nnf depicted
figure b involved rename sat unsat invoke identity
figure b figure c described section second nnf circuit
logically equivalent hence compilation cnf formula
search run note notion trace different used earlier work
establish power dpll proof system unsatisfiable cnf formulas
example earlier work shown unsatisfiable cnf formula trace
dpll converted tree resolution refutation urquhart
two observations imply exhaustive dpll powerful knowledge
compiler long one takes small trouble recording trace viewpoint
knowledge compilation however search trace recorded present form may
immediately useful typically size proportional amount work
done produce answering even linear time query may require single
traversal compiled representation compilation example would
one running whole search
remedied first realizing quite bit redundancy
search trace drawn figure example two subgraphs whose
roots labeled x isomorphic could merged one
redundancy course present corresponding portions nnf circuit
shown figure b


fithe language search

distinguish two levels dealing issue redundancy trace
first level remove redundancy trace reducing tree
dag repeated applications following two rules isomorphic nodes e
nodes label low child high child merged ii
node identical children deleted pointers redirected one
children bryant apply reduction rules tree figure
renaming sat unsat get dag shown figure c particular
example second rule apply note instead performing reduction
end search two reduction rules suggest better integrating
rules trace recording process redundant portions trace
recorded first place brings us technique known unique nodes brace
rudell bryant somenzi discuss detail next section
removing redundancy level ensures smallest possible compilation obtained given particular execution search however improve
time complexity search figure example reason
two isomorphic subgraphs rooted nodes labeled x first place
search run equivalent subproblems different paths general case
nontrivial subproblems solving one source great inefficiency therefore refer second level dealing issue redundancy
would able recognize equivalence subproblems avoid carrying
computation done technique
formula caching majercik littman discuss following section

language search
established section notion interpreting trace exhaustive search
circuit section continue study search showing
defines propositional language consisting possible traces look
three particular original exhaustive dpll ii exhaustive dpll
fixed variable ordering iii exhaustive dpll decomposition
discuss propositional language defines corresponding knowledge compiler
provides well issues regarding efficiency knowledge compiler
mapping exhaustive dpll fbdd
seen section application reduction rules trace exhaustive
dpll example depicted figure stored compactly figure c
none circuit language fbdd happens
obdd case
formally traces exhaustive dpll across possible executions
form propositional language precisely language reduced
fbdd defined section assume circuits fbdd
obdd given reduced form application two reduction rules
order first need formalism explicitly recording trace search
graph purpose introduce exactly exhaustive
extension original dpll except newly introduced function


fihuang darwiche

get node given provides means recording trace search
form dag specifically get node return decision node form
figure b labeled first argument second argument low child
third argument high child lines modified
return terminal decision nodes instead boolean constants note
briefly mentioned section trace recorded directly
reduced instead producing redundant nodes removed later
two reduction rules built means unique nodes table well known
bdd community brace et al somenzi specifically nodes created
get node stored hash table get node create node node
created already exists table existing node returned ii second
third arguments argument returned formally state
follows
theorem dags returned form language reduced fbdd
theorem immediately provides us cnf fbdd compiler means
soon search finishes answer polynomial time query
propositional theory long query known tractable fbdd according
table queries include consistency validity clausal entailment implicant model
counting model enumeration according blum et al one
test equivalence two propositional formulas probabilistically polynomial time
running hand propositional theory given known polynomial size representation fbdd conclude
able finish polynomial time matter variable
ordering uses
make practical fbdd compiler need deal issue
redundant computation briefly mentioned section reason despite
use unique nodes controls space complexity still time
complexity proportional size tree version search trace portions
dag end explored multiple times see figure example
two different instantiations first three variables lead subformula
would compiled twice unnecessarily alleviate
one resorts technique formula caching majercik littman
describes exhaustive dpll search caching
recursive call dpllf stored cache line returned
indexed key computed line identifying subsequent call
dpllf cnf exhaustive dpll
empty clause

return sink
variables

return sink
select variable x
return get node x dpllf x dpllf x


fithe language search

x

x

x


x

x

x

x

x

x

x

x



x
x

x

x





x
x
x
x

x

x




x
x x

x

x

x
x x

figure reaching subformula via different paths search
immediately return existing compilation cache line found
equivalent key comparison line note introduction caching
change identity proposition language defined
words theorem applies well
practice one normally focuses efficiently recognizing formulas syntactically
identical e set clauses methods proposed
purpose recent years starting majercik littman used caching
probabilistic followed darwiche proposed concrete
formula caching method context knowledge compilation bacchus dalmao
pitassi sang et al context model counting
darwiche huang darwiche b proposed refinements
method darwiche
mapping exhaustive dpll fixed variable ordering obdd
note dpll free choose variable branch line
corresponds use dynamic variable ordering heuristic typical sat solver
keeping spirit free binary decision diagrams fbdd
surprisingly one switches dynamic static variable ordering dags
produced restricted subset fbdd implements
change taking particular variable order second argument making sure
order enforced choosing next branching point see line across
possible inputs variable orderings indeed produce exactly set
circuits language reduced obdd
get node int bdd low bdd high
low high

return low
node low high exists unique table

return unique table low high
create bdd node low high
unique table low high
return


fihuang darwiche

theorem dags returned form language reduced obdd
therefore provided cnf obdd compiler means
soon search finishes answer polynomial time query
propositional theory long query known tractable obdd
notably test equivalence two propositional formulas deterministically
polynomial time running could
hand propositional theory given
known polynomial size representation obdd hidden weighted bit
function bryant conclude able finish
polynomial time matter variable ordering uses
make practical obdd compiler need deal issue
redundant computation naturally general formula caching method ones
described earlier applicable constrained search
however special method available shorter cache keys used
reduce cost manipulation reader referred huang darwiche
b details method allows one bound number distinct cache
keys therefore providing space time complexity bound particular
specific caching scheme force space time complexity
shown exponential cutwidth given cnf formula variant caching
scheme allows one parallel complexity terms pathwidth cutwidth
pathwidth comparable
emphasize represents distinct way obdd construction
contrast standard method widely adopted formal verification one recursively
builds obdds components system propositional formula compiled
combines apply operator bryant well known
latter method intermediate obdds arise process grow large
make manipulation impossible even final would tractable
size considering final obdd really one affords
solution building exactly less although may
work linear obdd size inconsistent subproblems
contribute obdd size caching complete empirical
dpllf cnf exhaustive dpll caching
empty clause

return sink
variables

return sink
key compute key
exists cache entry key

return
select variable x
get node x dpllf x dpllf x
cache insert key
return


fithe language search

abc
ade
bc
de






bc



b c
e






de

b



b





c




b

e







c



mixture decision conjunction nodes






b
e

b equivalent nnf circuit

figure trace exhaustive dpll decomposition
comparison compilation traditional obdd construction method
found huang darwiche b
mapping exhaustive dpll decomposition subset dnnf
observed particular case model counting efficiency exhaustive dpll improved introducing decomposition known component
analysis bayardo pehoushek bacchus et al b sang et al
idea propositional formula breaks conjunction disjoint subformulas e share variables subformula processed separately
combined
implements decomposition exhaustive dpll relaxing constraint
immediately line need insist
case analysis performed variable x formula instead examine
current formula attempt decompose line subsets share
dpllo cnf order exhaustive dpll fixed variable ordering
empty clause

return sink
variables

return sink
key compute key
exists cache entry key

return
x first variable order appears
get node x dpllo x dpllo x
cache insert key
return


fihuang darwiche

variable assume process nondeterministic detect
decomposition points search run subformulas separately
recursively lines separate subtraces connected
means node indicate recursive call combined
line case decomposition performed line fails branch selected
variable regular dpll lines
figure shows example execution instantiation first variable breaks cnf formula two disjoint clauses
processed separately combined node figure b shows
trace drawn equivalently explicit nnf circuit ease viewing constants
removed decision nodes bottom compacted corresponding literals
represent
witnessed use decomposition exhaustive dpll resulted
type node trace returned get node line
old get node function line still returns decision nodes relaxed sense
children necessarily decision nodes form figure c unique nodes
technique extended straightforward way isomorphic nodes
well duplicate children node created
ready discuss proposition language defined
purpose first define following subset dnnf language determinism
fulfilled means decision nodes relaxed sense
definition language decision dnnf set dnnf circuits
disjunction nodes form figure b x x x variable
note unlike fbdd conjunction disjunction node

dplld cnf exhaustive dpll decomposition
empty clause

return sink
variables

return sink
components exhaustive partitions disjoint variable sets
components

conjuncts

c components

conjuncts conjuncts dplld c

return get node conjuncts
key compute key
exists cache entry key

return
select variable x
get node x dplld x dplld x
cache insert key
return


fithe language search

formally state assume circuits given
reduced form application appropriate reduction rules described earlier
although allowed redundancy figures ease viewing
theorem dags returned form language reduced decision dnnf
hence provided cnf decision dnnf compiler
serve dnnf compiler practice since decision dnnf dnnf means
search finishes answer polynomial time query input
propositional formula long query known tractable language ddnnf see table hand able finish polynomial
time propositional theory polynomial size representation ddnnf decision dnnf matter variable ordering decomposition method
uses
one needs implement form formula caching make
practical compiler several caching methods proposed dnnf compilation
latest effective appeared darwiche however refer
reader darwiche caching scheme specific decomposition method
known dtrees discuss next scheme effective
one darwiche former may miss equivalences would
caught latter yet allows one space time complexity caching scheme force exponential treewidth
cnf formula compared pathwidth cutwidth obdd compilation discussed
section considering model counting linear time query supported
dnnf language darwiche imply dpll decomposition used count time space complexity
exponential treewidth cnf formula see bacchus et al
alternative derivation complexity interestingly similar structure
measure complexity appears known fbdd compilation
finally would briefly discuss distinction two possible methods
decomposition suggests dynamic notion decomposition disjoint
components recognized variable split dynamic decomposition
initially proposed utilized bayardo pehoushek model counting
adopted recent model counters sang et al darwiche
proposed another method performing decomposition less dynamically preprocessing cnf formula generate dtree decomposition tree binary tree
whose leaves correspond clauses cnf formula node dtree defines
set variables called cutset whose instantiation guaranteed decompose
cnf formula node disjoint components rationale cost
dynamically computing partition line many times search
replaced lesser cost computing static recursive partition
method decomposition allows one provide structure computational
guarantees discussed moreover instantiation variables cutset
performed dynamically utilizing dynamic variable ordering heuristics typically done
sat solvers use dtrees combined dynamic variable ordering leads
almost static behavior highly structured cutsets small yet one


fihuang darwiche

sees dynamic behavior less structured random sat
cutsets relatively large dynamic variable ordering tends dominate interestingly static behavior dtrees low overhead orders magnitude efficient
purely dynamic behavior structured benchmarks including iscas circuits
hand dynamic behavior dtrees lead competitive
unstructured benchmarks including random sat one may obtain effect
running model counter sang et al cachet version dnnf
compiler darwiche c version relevant benchmarks noted
two programs differ aspects decomposition method appears
one major differences
harnessing search techniques knowledge compilation
recent years greatly improved efficiency scalability systematic
search methods particularly propositional satisfiability techniques contributing improvement include sophisticated conflict analysis dependencydirected backtracking clause learning variable ordering heuristics data structures
faster constraint propagation among things marques silva sakallah
marques silva aloul markov sakallah moskewicz madigan zhao zhang
malik zhang madigan moskewicz malik goldberg novikov
zhang malik heule van maaren hand described
section uniform framework systematic search converted
knowledge compilers exhausting search space recording trace search
framework affords opportunity many successful search techniques
carry knowledge compilation refer reader bayardo pehoushek
darwiche huang darwiche b sang et al detailed discussions issues arise implementation techniques
search extended exhaustion trace search needs stored
decomposition introduced
finally note efficiency search addressed techniques including caching particular important practical issue orthogonal
language generated search main focus present simple
example one may two versions drastically different running
times input one much better caching method
end day bound produce exactly obdd due canonicity
obdds another example learned clause provided conflict analysis reduce
number search nodes affect final dag circuit generated
nodes avoided correspond contradictions constant would
appear dag anyway due reduction rules

power limitations exhaustive search
sections established notion interpreting trace exhaustive
search circuit mapping search propositional language
consisting possible traces notion provides perspective intrinsic
power limitations search illustrated section


fithe language search











b

c




c



b b
general determinism




b

b nondeterminism

figure dpll unable produce general determinism nondeterminism
discussing usefulness search knowledge compilers inherent
inefficiency certain classes inputs section formalize
concepts illustrate examples real implementations exhaustive
search
consider arbitrary exhaustive search variable splitting call
dpllx suppose traces form propositional language lx intrinsic power
limitations dpllx identified following two principles respectively
dpllx runs polynomial time class formulas dpllx trace
recorded answer polynomial time query formulas known
tractable language lx
dpllx run polynomial time formulas polynomial size
representations exist lx
take example model counters recently proposed bayardo pehoushek
sang et al employ techniques decomposition
latter formula caching simple analysis model counters shows
traces language decision dnnf consider query testing
whether minimization theory implies particular clause min
min defined theory whose exactly minimum cardinality
query heart diagnostic nonmonotonic reasoning known
tractable dnnf applying first principle noting decisiondnnf dnnf conclude query answered polynomial time
class formulas model counters bayardo pehoushek sang
et al polynomial time complexity similarly probabilistic equivalence
test performed polynomial time formulas counters
polynomial time complexity
example second principle first note neither
model counters finish polynomial time formulas polynomial size
representations exist decision dnnf furthermore recall decision dnnf defined
definition strict subset dnnf every disjunction decision dnnf circuit
see ddp bayardo pehoushek table sang et al
example variable splitting lines table sang et al corresponds generation
decision node tocomponents function line line corresponds generation
node satisfies decomposability



fihuang darwiche

form x x dnnf allows disjunctions form
logically inconsistent yet contradict particular
variable figure gives one example recall model counting query remains
tractable one generalizes decision dnnf dnnf decision dnnf turns
succinct dnnf therefore one may another generation model
counters well dnnf compilers exponentially efficient
current ones
finally note dpll traces inherently bound nnf circuits
deterministic decomposable decomposability alone however sufficient
tractability important tasks clausal entailment testing existential quantification variables cardinality minimization darwiche marquis dpll
cannot generate traces dnnf dnnf figure b example since
variable splitting heart dpll amounts enforcing determinism property determinism provides power needed model counting sat
essential applications probabilistic reasoning one need
power one go beyond dpll procedures otherwise one would solving
harder computational necessary

relation previous work
employed notion trace search provide theoretical
practical channel advances systematic search knowledge compilation channel indeed active time implicitly mostly one
direction systematic search employed compile knowledge bases see
example darwiche huang darwiche b darwiche fact
techniques variable ordering decomposition caching extensively
used bodies work used recently pure search

key contribution formally explicating notion search
trace proposing basis systematic framework compiling knowledge
bases subsets nnf contrasted earlier systematic studies
nnf darwiche marquis concerned describing
properties compiled nnf representations without delving algorithmic nature
generating another key contribution activating second
direction search compilation channel looking language membership search
traces formally characterize power limitations search
recent line work centering notion search
concerned understanding power limitations search techniques
decomposition caching measuring size explored search spaces dechter
mateescu b marinescu dechter premise work
traditional search branching thought exploring
orsearch space recent search employing decomposition thought
exploring orsearch space space search characterized graph tree caching used alternating layers nodes
nodes former representing decomposition latter branching


fithe language search

exploring orsearch space therefore exhibit behavior similar used compiling cnf dnnf darwiche except
records orsearch space explicitly circuit hence
search share limitations discussed dpll cannot take
advantage general notion determinism rid determinism altogether
note proposed search proceed instantiating variables performing decomposition according pseudo tree freuder quinn
earlier work dnnf compilation uses decomposition tree two
tasks corresponding choices lines pseudo trees decomposition trees similar provide scheme instantiation
certain set variables lead decomposition framework
proposed however make commitment decomposition
variable ordering scheme relevant discussion one note
though commitment particular decomposition variable ordering scheme
significant practical implications specifically search whose trace
dnnf may performing variable ordering decomposition way
prohibit possibility generating certain space efficient dnnf circuits
finally one identify major difference search dnnf
compilation terms handling queries execution search
answers single query executing dnnf compilation
compact structure used repeatedly answer queries
knowledge base known tractable discussed earlier traversing
compiled structure potentially much efficient repeating search
produced point view separation search actual reasoning
task provides benefit amortizing search effort potentially large number
queries provides discussed systematic methodology
independent advances search harnessed improve performance automated
reasoning systems

experimental
way experimentation ran implementations mince variable ordering heuristic aloul et al vsids variable ordering
heuristic moskewicz et al static decomposition hypergraph partitioning darwiche hopkins compile set cnf formulas
obdd fbdd dnnf respectively implementation details first third
programs found huang darwiche b darwiche goal
experiments practicality search compilation framework
illustrate improvement language succinctness response relaxation
constraints search process benchmarks used include random cnf
graph coloring hoos stutzle set iscas circuits
experiments shown table running times
given seconds ghz cpu size compilation reflects number
edges nnf dag dash indicates compilation succeed given
available memory gb second time limit seen


fihuang darwiche

table compiling cnf obdd fbdd dnnf
cnf
name
uf
uf
uf
uf
uf
uf
uf
uf
uf
flat
flat
flat
flat
flat
flat
flat
flat
flat










number





























obdd
size
time
















































fbdd
size
time













































dnnf
size
time

















































instances compilation smallest dnnf fbdd obdd
similar relation observed among running times number instances
successfully compiled largest dnnf fbdd obdd tracks
well theoretical succinctness relations three languages however note
fbdd dnnf canonical representations therefore compilations smaller
reported perfectly possible smaller obdd compilations course
possible different variable orderings
close section noting implementations knowledge compilers
bear witness advantage search compilation framework described
section first compiler existing sat solver moskewicz et al
two implementation dpll three benefiting
techniques found success sat including conflict analysis clause learning
data structures efficient detection unit clauses



fithe language search

conclusion
work concerned class exhaustive search run propositional knowledge bases proposed novel methodology whereby trace search
identified combinational circuit search mapped propositional language consisting possible traces mapping leads uniform
practical framework compilation propositional knowledge bases languages
interest time provides perspective intrinsic power limitations exhaustive search interesting examples unveiled hidden
power several recent model counters discussed one potential limitations
pointed inability class produce traces without property
determinism limits power knowledge compilation point view
discussed generality relation recent work
search finally presented experimental demonstrate practicality
search knowledge compilation framework illustrate variation language
succinctness response variation search strategy

acknowledgments
parts work presented dpll trace sat knowledge
compilation proceedings th international joint conference artificial intelligence ijcai thank rina dechter anonymous reviewers
feedback earlier drafts work partially supported
nsf grant iis muri grant n jpl nasa contract da national ict australia funded australian governments backing
australias ability initiative part australian council

appendix
proof theorem
first point recursion guaranteed terminate recursive call
line accompanied disappearance one variable eventually line
line execute assuming compact drawing decision nodes figure c
every dag returned fbdd every fbdd
generated execution
part three return statements lines single
nodes returned lines trivial fbdds dag returned get node
line call g decision node induction level recursion hence remains
g satisfies test property equivalent decomposability case
discussed section true line variable x replaced
constants two recursive calls hence cannot appear two graphs
supplied second third arguments get node finally fbdds returned
guaranteed reduced use unique nodes technique
get node function brace et al



fihuang darwiche

part ii let g denote arbitrary reduced fbdd root node define
following function g returns cnf formula set clauses every g


empty clause





g

x c c g low x c c g high



g sink
g sink
otherwise node g
labeled variable x

last line definition assume literal x x appended
front clause c execute g line choose
first variable clause first variable every clause must
dag returned isomorphic g
proof theorem
every dag returned obdd every obdd
generated execution
part first dag returned fbdd
restricted version second dag obdd nonterminal
node n dag must constructed line therefore virtue line satisfies
following property variable x labels n appears variables
two subgraphs n variable order finally obdds returned
guaranteed reduced use unique nodes technique get node
function brace et al
part ii given arbitrary reduced obdd g let variable order g
g defined previous proof execute g dag
returned isomorphic g
proof theorem
every dag returned decision dnnf circuit
every decision dnnf circuit generated execution
part nodes returned get node line conjunction nodes satisfy
decomposability components identified line share variables nodes
returned get node line disjunction nodes form figure c
definition get node therefore whole dag decision dnnf finally decisiondnnf circuits returned guaranteed reduced use
unique nodes technique get node get node functions
part ii let g denote arbitrary reduced decision dnnf circuit assuming
compact drawing decision nodes figure c expand previous definition
g follows


empty clause









g

gi







x c c g low x c c g high





g sink
g
sink
g
gi


otherwise node g
labeled variable x

fithe language search

previous definition g assume last line definition
literal x x appended front clause c let literal
clause associated possibly empty list colors follows lists
initially empty literals x x introduced last line definition
third line definition assign distinct color sets unioned
set append assigned color head list colors first literal
every clause execute g resolve nondeterministic choices
line decomposition line variable selection follows first literal
clause nonempty list colors first literal every clause must
nonempty list colors let line partition set clauses according first color
first literal remove color first literal every clause otherwise
first literal every clause must mention variable let line return single
partition line choose first variable clause dag returned
isomorphic g

references
aloul f markov sakallah k faster sat smaller bdds via common
function structure international conference computer aided design iccad
pp
arvelo bonet b vidal e compilation query rewriting
tractable fragments propositional logic proceedings st national
conference artificial intelligence aaai
bacchus f dalmao pitassi complexity
sat bayesian inference th annual ieee symposium foundations
computer science focs pp
bacchus f dalmao pitassi b dpll caching
sat bayesian inference electronic colloquium computational complexity
eccc
barrett hybrid systems universal plans via domain compilation proceedings th international conference automated scheduling
icaps pp
barrett model compilation real time diagnosis feedback
proceedings th international joint conference artificial intelligence
ijcai pp
barwise j ed handbook mathematical logic north holland
bayardo r pehoushek j counting connected components
proceedings th national conference artificial intelligence aaai pp

berre l simon l
http www satcompetition org



annual

sat

competitions

birnbaum e lozinskii e good old davis putnam procedure helps counting
journal artificial intelligence


fihuang darwiche

blum chandra k wegman n equivalence free boolean graphs
decided probabilistically polynomial time information processing letters

bonet b geffner h heuristics penalties rewards compiled knowledge proceedings tenth international conference
principles knowledge representation reasoning kr pp
brace k rudell r l bryant r e efficient implementation bdd
package proceedings th design automation conference dac pp
bryant r e graph boolean function manipulation ieee
transactions computers c
bryant r e complexity vlsi implementations graph representations
boolean functions application integer multiplication ieee transactions
computers
cadoli donini f survey knowledge compilation ai communications
chauhan p clarke e kroening sat image computation
reachability analysis tech rep cmu cs school computer science
carnegie mellon university
chavira darwiche compiling bayesian networks local structure
proceedings th international joint conference artificial intelligence
ijcai pp
chavira darwiche jaeger compiling relational bayesian networks
exact inference international journal approximate reasoning
coste marquis berre l letombe f marquis p propositional fragments
knowledge compilation quantified boolean formulae proceedings
th national conference artificial intelligence aaai pp
darwiche tractability counting theory application
belief revision truth maintenance journal applied non classical logics

darwiche compiler deterministic decomposable negation normal form
proceedings th national conference artificial intelligence aaai pp

darwiche advances compiling cnf decomposable negation normal form proceedings th european conference artificial intelligence
ecai pp
darwiche c compiler user manual tech rep computer science
department ucla http reasoning cs ucla edu c
darwiche hopkins recursive decomposition construct elimination
orders jointrees dtrees trends artificial intelligence lecture notes ai
pp springer verlag



fithe language search

darwiche huang j testing equivalence probabilistically tech rep
computer science department ucla
darwiche marquis p knowledge compilation map journal artificial
intelligence
davis logemann g loveland machine program theorem proving
journal acm
dechter r mateescu r impact search spaces constraint
satisfaction counting proceedings th international conference
principles practice constraint programming cp pp
dechter r mateescu r b mixtures deterministic probabilistic networks
search spaces proceedings th conference uncertainty
artificial intelligence uai pp
del val tractable databases make propositional unit resolution complete compilation proceedings fourth international conference
principles knowledge representation reasoning kr pp
del val analysis approximate knowledge compilation proceedings
th international joint conference artificial intelligence ijcai pp
elliott p williams b dnnf belief state estimation proceedings
st national conference artificial intelligence aaai
forbus k de kleer j building solvers mit press
freuder e c quinn j taking advantage stable sets variables
constraint satisfaction proceedings ninth international joint conference artificial intelligence ijcai pp
gergov j meinel c efficient analysis manipulation obdds
extended fbdds ieee transactions computers
goldberg e novikov berkmin fast robust sat solver design
automation test europe date pp
grumberg schuster yadgar memory efficient solutions sat solver
application reachability analysis proceedings th international
conference formal methods computer aided design fmcad pp
heule van maaren h aligning cnf equivalence reasoning proceedings seventh international conference theory applications satisfiability testing sat
hoos h h stutzle satlib online resource sat
p gent h v maaren walsh editors sat pp ios press satlib
available online www satlib org
huang j combining knowledge compilation search conformant probabilistic
proceedings th international conference automated
scheduling icaps pp



fihuang darwiche

huang j darwiche compiling system faster scalable
diagnosis proceedings th national conference artificial intelligence
aaai pp
huang j darwiche b dpll efficient obdd construction
seventh international conference theory applications satisfiability testing
sat revised selected papers vol lecture notes computer science
pp
karnaugh map method synthesis combinational logic circuits transactions aiee
majercik littman l caching solve larger probabilistic
proceedings th national conference artificial intelligence aaai pp
marinescu r dechter r branch bound graphical
proceedings th international joint conference artificial intelligence
ijcai pp
marques silva j sakallah k graspa search satisfiability
proceedings international conference computer aided design iccad
pp
marques silva j impact branching heuristics propositional satisfiability
proceedings th portuguese conference artificial intelligence
pp
marquis p knowledge compilation theory prime implicates proceedings
th international joint conference artificial intelligence ijcai pp

mcmillan k symbolic model checking kluwer academic
mcmillan k l applying sat methods unbounded symbolic model checking
proceedings th international conference computer aided verification
cav pp
meinel c theobald data structures vlsi design obdd
foundations applications springer
moskewicz madigan c zhao zhang l malik chaff engineering
efficient sat solver proceedings th design automation conference
dac pp
palacios h bonet b darwiche geffner h pruning conformant plans
counting compiled dnnf representations proceedings th
international conference automated scheduling icaps pp

sang bacchus f beame p kautz h pitassi combining component
caching clause learning effective model counting proceedings seventh
international conference theory applications satisfiability testing sat
pp


fithe language search

sang beame p kautz h heuristics fast exact model counting
proceedings eighth international conference theory applications
satisfiability testing sat lecture notes computer science pp
selman b kautz h knowledge compilation horn approximation
proceedings ninth national conference artificial intelligence aaai pp

selman b kautz h knowledge compilation theory approximation journal
acm
siddiqi huang j hierarchical diagnosis multiple faults proceedings
th international joint conference artificial intelligence ijcai pp

somenzi f
cudd cu decision diagram package release
http vlsi colorado edu fabio cudd cuddintro html
urquhart complexity propositional proofs bulletin symbolic logic

wegener branching programs binary decision diagrams theory applications siam monographs discrete mathematics applications
zhang l madigan c moskewicz malik efficient conflict driven learning
boolean satisfiability solver proceedings international conference
computer aided design iccad pp
zhang l malik quest efficient boolean satisfiability solvers
proceedings th international conference automated deduction cade
lecture notes computer science pp




