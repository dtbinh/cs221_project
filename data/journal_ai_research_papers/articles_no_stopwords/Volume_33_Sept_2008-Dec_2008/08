journal artificial intelligence

submitted published

computational logic foundations kgp agents
antonis kakas

antonis ucy ac cy

department computer science university cyprus
kallipoleos str p box cy nicosia cyprus

paolo mancarella

paolo mancarella unipi

dipartimento di informatica universita di pisa
largo b pontecorvo pisa italy

fariba sadri

fs doc ic ac uk

department computing imperial college london
south kensington campus london sw az uk

kostas stathis

kostas cs rhul ac uk

department computer science royal holloway
university london egham surrey tw ex uk

francesca toni

ft doc ic ac uk

department computing imperial college london
south kensington campus london sw az uk

abstract
presents computational logic foundations model agency called
kgp knowledge goals plan model model allows specification
heterogeneous agents interact exhibit proactive
reactive behaviour allowing function dynamic environments adjusting
goals plans changes happen environments kgp provides highly
modular agent architecture integrates collection reasoning physical capabilities synthesised within transitions update agents state response reasoning
sensing acting transitions orchestrated cycle theories specify order
transitions executed taking account dynamic context agent
preferences well selection operators providing inputs transitions

introduction
widely acknowledged concept agency provides convenient powerful
abstraction describe complex software entities acting certain degree autonomy
accomplish tasks often behalf user wooldridge agent context
understood software component capabilities reacting
inter acting achieve goals environment situated
present model agency called kgp knowledge goals plan model
hierarchical highly modular allowing independent specifications collection
reasoning physical capabilities used equip agent intelligent decision making
adaptive behaviour model particularly suited open dynamic environments
agents adapt changes environment function
circumstances information incomplete
c

ai access foundation rights reserved

fikakas mancarella sadri stathis toni

development kgp model originally motivated existing gap modal logic specifications rao georgeff bdi agents bratman israel
pollack implementation example see issues raised rao
another motivation development kgp comes participation socs
project socs need agent model satisfies several requirements specifically aimed agent model rich enough allow
intelligent adaptive heterogeneous behaviour formal could lent well
formal analysis implementable way implementation sufficiently
close formal specification allow verification although several agency
proposed none satisfies requirements
bridge gap specification implementation kgp model
computational logic cl focus work extend synthesise number
useful computational logic techniques produce formal executable specifications
agents purpose model integrates abductive logic programming alp kakas
kowalski toni logic programming priorities kakas mancarella dung
prakken sartor constraint logic programming jaffar maher
techniques explored right modular integration
within kgp model explores extensions well providing high level agent
reasoning capabilities
kgp model provides hierarchical architecture agents specifies collection
modular knowledge bases formalised cl knowledge bases support collection reasoning capabilities reactivity goal decision
given formal specifications model includes specification physical capabilities
comprising sensing actuating capabilities utilised within transitions
model state agent changes reasoning sensing acting
transitions use selection operators providing inputs control component called
cycle theory formalised cl specifies order transitions executed depending environment state agent preferences agent
cycle theory takes agent control beyond one size fits used
agent allows us specify agents different preferences profiles behaviour sadri toni particular whereas majority existing agent
rely upon observe plan act means cycle theory model behaviours
observe revise goals planact observe plan sense action preconditions act
observe plan act plan act provide one example cycle theory refer
normal allowing behaviours depending different circumstances environment agent situated preferences note respect
agent kgp model allows agents revise goals life time
observing environment according two modalities active passive observation
agent built kgp architecture dynamically determines goals plans partially achieve goals interleaves action executions making
observations environment receiving messages agents adapts
goals plans information receives changes observes generates appropriate reactions
number publications already described aspects initial version
kgp agents precursor overall model described kakas mancarella


ficomputational logic foundations kgp agents

sadri stathis toni b component presented mancarella
sadri terreni toni cycle theory developed kakas mancarella
sadri stathis toni implementation discussed stathis et al
yip forth stathis kakas bracciali endriss demetriou
kakas lu stathis provide full formal specification
components kgp model thus offering complete technical account
kgp one place providing full formal specification adjusted
developed model particular notion state definition novel
reasoning capabilities simplified added physical
capabilities extended include actuating formally defined transitions
selection operators formally defined full
rest structured follows sections give outline
model review background information necessary full description
sections respectively describe internal state kgp agents reasoning physical capabilities transitions section describe selection
operators used cycle theory described section following
detailed description kgp agents illustrate model series examples
section compare model others literature section finally
conclude section

kgp model outline
section give overview kgp agent model components
provide informal examples functioning model relies upon
internal mental state holding agent knowledge base beliefs goals desires plans intentions
set reasoning capabilities
set physical capabilities
set transition rules defining state agent changes defined
terms capabilities
set selection operators enable provide appropriate inputs transitions
cycle theory providing control deciding transitions applied

model defined modular fashion different activities encapsulated
within different capabilities transitions control separate module
model hierarchical structure depicted figure
internal state
tuple hkb f c


fikakas mancarella sadri stathis toni

cycle
theory

transitions




selection
operators


e
reasoning

capabilities

physical capabilities

figure graphical overview kgp model
kb holds beliefs agent external world situated
including past communications well record actions already
executed
f forest trees whose nodes goals may executable
tree forest gives hierarchical presentation goals tree represents
construction plan root tree set leaves tree f
forms currently chosen plan achieving root tree executable goals
actions may physical communicative sensing simplicity assume
actions atomic duration non executable goals may
mental sensing non executable mental goals may children forming
partial plans actions children tree f goal
associated time variable implicitly existentially quantified within overall
state serves two purposes indicating time goal achieved
instantiated goal achieved appropriate time providing
unique identifier goal remainder often use
following terminology goals f want emphasise role
nature roots trees f referred top level goals executable
goals referred actions non executable goals top level
goals referred sub goals top level goals classified reactive
non reactive explained later note top level reactive goals
may actions
roughly speaking reactive goals generated response observations e g communications received
agents changes environment example repair plans already
generated non reactive goals hand chosen desires agent



ficomputational logic foundations kgp agents

c temporal constraint store namely set constraint atoms given
underlying constraint language constrain time variables goals f
example may specify time window time action
instantiated execution time
set equalities instantiating time variables time constants example
time variables actions instantiated action execution time records
instantiations kept
reasoning capabilities
kgp supports following reasoning capabilities
generates plans mental goals given input plans consist
temporally constrained sub goals actions designed achieving input goals
reactivity used provide reactive top level goals reaction
perceived changes environment current plans held agent
goal decision used revise non reactive top level goals adapting
agents state changes environment
identification preconditions identification effects actions used
determine appropriate sensing actions checking whether actions may safely
executed preconditions known hold whether recently executed
actions successful checking known effects hold
temporal reasoning allows agent reason evolving environment
make predictions properties including non executable goals holding
environment partial information agent acquires lifetime
constraint solving allows agent reason satisfiability
temporal constraints c
concrete realisation kgp model provide chosen
realise capabilities extensions logic programming paradigm
particular use conventional logic programming identification preconditions
effects abductive logic programming constraints see section
reactivity temporal reasoning logic programming priorities see section
goal decision
physical capabilities
addition reasoning capabilities kgp agent equipped physical capabilities linking agent environment consisting
sensing capability allowing agent observe properties hold
hold agents executed actions
actuating capability executing physical communicative actions


fikakas mancarella sadri stathis toni

transitions
state hkb f c agent evolves applying transition rules employ
capabilities follows
goal introduction gi possibly changing top level goals f goal
decision
plan introduction pi possibly changing f c
reactivity possibly changing reactive top level goals f c
reactivity capability
sensing introduction si possibly introducing sensing actions f checking
preconditions actions already f
passive observation introduction poi updating kb recording unsolicited information coming environment sensing
active observation introduction aoi possibly updating kb recording
outcome actively sought sensing actions sensing
action execution ae executing types actions consequence updating
kb actuating
state revision sr possibly revising f temporal reasoning constraint solving
cycle selection operators
behaviour agent given application transitions sequences repeatedly
changing state agent sequences determined fixed cycles behaviour conventional agent architectures rather reasoning cycle theories
cycle theories define preference policies order application transitions
may depend environment internal state agent rely upon
use selection operators detecting transitions enabled inputs
follows
action selection inputs ae selection operator uses temporal reasoning
constraint solving capabilities
goal selection inputs pi selection operator uses temporal reasoning
constraint solving capabilities
effect selection inputs aoi selection operator uses identification
effect reasoning capability
precondition selection inputs si selection operator uses identification
preconditions temporal reasoning constraint solving capabilities


ficomputational logic foundations kgp agents

provision declarative control agents form cycle theories highly
novel feature model could principle imported agent systems
concrete realisation kgp model provide chosen
realise cycle theories framework logic programming priorities
constraints see section use goal decision
relationships capabilities transitions selection operators
summarised tables table indicates capabilities rows
used transitions selection operators table indicates selection
operators used compute possible inputs transitions cycle theory

sensing
actuating
plan
pre
gd
react
r
cs
ef f

ae
x
x

transitions
aoi gi p oi
x
x

pi



sr

si

selection operators
fgs fas fes fp

x
x

x

x
x

x
x

x
x
x

x
x

x

x
x

x

table tabular overview use capabilities transitions selection operators
plan pre gd react r cs ef f stand respectively
identification preconditions goal decision reactivity temporal reasoning constraint solving identification effects reasoning capabilities
fgs fas fes fp stand respectively goal action effect precondition
selection operators

ae
fgs
fas
fes
fp

aoi

gi

p oi

pi
x



sr

si

x
x
x

table tabular overview connections selection operators transitions
required cycle theory fgs fas fes fp stand respectively
goal action effect precondition selection operators
provide components though introduce informally scenario
examples used illustrate technical details kgp agent


fikakas mancarella sadri stathis toni

model throughout full formal presentation well additional
examples given throughout section
examples
draw examples ubiquitous computing scenario call san
vincenzo scenario presented de bruijn stathis summarised follows
businessman travels work purposes italy order make trip easier
carries personal communicator namely device hybrid mobile phone
pda device businessmans kgp agent agent considered
personal service agent mamdani pitt stathis psa short
provides proactive information management flexible connectivity smart services
available global environment within businessman travels within
setting
businessmans psa requests san vincenzo station agent svs arrival time
train tr rome svs information answers
refusal later svs receives information arrival time tr train
central office agent co psa requests arrival time tr svs
accept request provide information
first example requires one use reactivity capability model rules interaction transition achieve interaction amongst agents b specify
dynamic adjustments agents behaviour changes allowing different reactions
request depending current situation agent interaction
form negotiation resources amongst agents resources items information
thus current situation agents amounts resources information agents
currently
example requires combination transitions poi ae achieve
expected agents behaviours follows
psa makes initial request applying ae
svs becomes aware request performing poi changing kb accordingly
svs decides reply refusal performing adding corresponding
action plan f
svs utters refusal performing ae
svs becomes aware poi arrival time modifying kb accordingly
psa makes second request applying ae
svs decides reply requested information performing adding
corresponding action plan f communicates information
performing ae


ficomputational logic foundations kgp agents

sequence transitions given called normal cycle theory
see section
setting
preparation businessmans next trip psa aims getting plane ticket
madrid denver well obtaining visa usa one possible way buy plane
tickets internet buying tickets way usually possible
destinations depending whether airlines flying destinations sell tickets
internet without internet connection psa currently
connection information denver indeed destination tickets
bought online plans buy ticket internet nonetheless conditionally
checks conditions executing planned action successfully buying
ticket psa focuses second goal obtaining visa achieved
applying usa embassy madrid application requires address
usa address obtained arranging hotel denver
example illustrates form partial adopted kgp model
non executable sub goals well actions may part plans shows
combination transition pi si ae allows psa agent deal partial
information generate conditional plans plans several layers follows
psa initially equipped top level goals get ticket denver
obtain visa earlier application gi
pi first goal psa adds partial plan f buying ticket online
subject sub goals internet connection available online
tickets bought denver sub goals sensing goals
si sensing actions added f evaluate sensing sub goals environment
sensing actions executed ae kb modified accordingly
depending sensed values sensing sub goals buying action may
may executed ae let us assume remainder example
action executed
sr applied eliminate actions since already executed subgoals top level goal getting ticket denver since achieved
pi remaining top level goal obtaining visa psa adds plan fill
application form action acquiring residence address denver sub goal
action cannot executed psa knows businessman resident
usa pi introduces plan sub goal booking hotel action
subgoal acquiring residence address denver
ae executes booking action


fikakas mancarella sadri stathis toni

ae executes action applying visa
sr eliminates actions since already executed sub goal toplevel goal getting visa since achieved

background
section give necessary background reasoning capabilities cycle
theory kgp agents namely
constraint logic programming pervasive whole model
abductive logic programming heart reactivity temporal
reasoning capabilities
logic programming priorities heart goal decision capability
cycle theories
constraint logic programming
constraint logic programming clp jaffar maher extends logic programming
constraint predicates processed ordinary logic programming predicates
defined rules checked satisfiability simplified means built
black box constraint solver predicates typically used constrain values
variables conclusion rule take together unification
treated via equality constraint predicate kgp model constraints used
determine value time variables goals actions suitable temporal
constraint theory
clp framework defined structure consisting domain set
constraint predicates includes equality together assignment relations
constraint predicate clp constraints built first order
formulae usual way primitive constraints form c tn c
constraint predicate symbol tn terms constructed domain
values rules constraint logic program p take form rules
conventional logic programming given
h l ln
h ordinary atom l ln literals n literals positive namely
ordinary atoms negative namely form b b ordinary atom
constraint atoms negation symbol indicates negation failure first
introduced clark variables h li implicitly universally quantified
scope entire rule h called head conclusion l ln called
body conditions rule form n rule called fact
valuation set variables mapping variables domain
natural extension maps terms valuation set
variables appearing set constraints c called solution c iff c obtained
applying c satisfied e c evaluates true given interpretation


ficomputational logic foundations kgp agents

constraint predicates terms denoted c set c called solvable
satisfiable denoted c iff least one solution e c
valuation
one way give meaning constraint logic program p consider grounding program herbrand base possible valuations
constraint variables rule ground constraints c body evaluated true rule kept constraints c dropped otherwise whole
rule dropped let ground p resulting ground program meaning p
given meaning lp ground p many different possible
choices kakas kowalski toni resulting overall semantics constraint
logic program p referred lp precisely given constraint logic
program p conjunction n c n conjunction non constraint literals
c conjunction constraint atoms remainder write
p lp n c
denote exists ground substitution variables n c
c
ground p lp n
abductive logic programming constraints
abductive logic program constraints tuple h p ii
structure section
p constraint logic program namely set rules form
h l ln
section
set abducible predicates language p predicates
occurring head clause p without loss generality see kakas et al
atoms whose predicate abducible referred abducible atoms
simply abducibles
set integrity constraints set sentences language p
integrity constraints kgp model implicative form
l ln n
li literals case rules aj atoms possibly special
atom f alse disjunction referred head constraint
conjunction l ln referred body variables integrity
constraint implicitly universally quantified outside except variables
occurring head implicitly existentially quantified scope
head
n l ln represents special atom true



fikakas mancarella sadri stathis toni

given abductive logic program constraints h p ii formula query
q implicitly existentially quantified conjunction literals language
p purpose abduction possibly minimal set ground abducible
atoms together p entails appropriate ground instantiation q
respect notion entailment language p equipped
extension p satisfies see kakas et al possible notions
integrity constraint satisfaction notion entailment combined
semantics lp discussed section
formally given query q set possibly non ground abducible atoms
set c possibly non ground constraints pair c abductive answer
constraints q respect abductive logic program constraints h p ii
iff groundings variables q c c holds
p lp q
ii p lp e b h p lp b p lp h
plays role earlier informal description abductive answer note
ii integrity constraints classical implications
note representing knowledge abductive logic program one needs
decide go logic program integrity constraints
abducibles intuitively integrity constraints normative need
enforced making sure head holds whenever body condition ii
whereas logic programming rules enable help abducibles derivation
given goals condition finally abducibles chosen amongst literals
cannot derived means logic programming rules represent reactive constraints condition action rules forcing reactive behaviour
agents integrity constraints thus extent addressing knowledge representation challenge posed abductive logic programming imposing sort structure
abductive logic programs use
notion abductive answer extended take account initial set
possibly non ground abducible atoms initial set possibly non ground
constraint atoms c extension abductive answer q respect
h p ii c
pair c

ii c c
iii c c abductive answer q respect h p ii
earlier sense
worth noticing abductive answer c query true respect
h p ii c


ficomputational logic foundations kgp agents

read fact abducibles along constraints
c c guarantee overall consistency respect integrity constraints given
used specification capabilities kgp agents
remainder simplicity omit abductive logic
programs written simply triples hp ii addition abductive logic
programs present kgp variants core event calculus kowalski sergot
define section
logic programming priorities
purposes logic program priorities constraint structure
referred consists four parts
low level basic part p consisting logic program constraints rule
p assigned name term e g one rule could
n x p x q x r
name n x naming ground instance rule
ii high level part h specifying conditional dynamic priorities amongst rules p
h e g one priority could
h x x n x c x
read instance condition c x holds corresponding instance rule named x given higher priority
corresponding instance rule named n x rule named h x
iii auxiliary part constraint logic program defining auxiliary predicates
occurring conditions rules p h conclusions rule
p h
iv notion incompatibility purposes assumed given
set rules defining predicate incompatible e g
incompatible p x p x
read instance literal p x incompatible corresponding
instance literal p x assume incompatibility symmetric
includes r incompatible r two rule names r refer
set incompatibility rules
concrete lpp framework equipped notion entailment denote pr defined top underlying logic programming constraints
semantics lp defined differently different approaches lpp
share following pattern given logic program priorities hp h ii
conjunction ground non auxiliary atoms pr iff
exists subset p basic part p p lp


fikakas mancarella sadri stathis toni

ii p preferred wrt h subset p p derives lp
conclusion incompatible wrt
framework way specifying meant one sub theory p
preferred another sub theory p example existing literature kakas et al
prakken sartor kowalski toni kakas moraitis pr
defined via argumentation adopt relying notion
admissible argument sub theory consistent incompatible
conclusions ii whose rules lower priority respect high level
part h theory sub theory incompatible conclusions
precise definition sets rules compared matter
choice specific framework lpp
given concrete definition admissible sub theories preference entailment
pr given
exists maximal admissible sub theory lp
ii incompatible exist admissible sub theory
lp
first condition satisfied say theory credulously prefers possibly prefers conditions satisfied say
theory sceptically prefers

state kgp agents
section define formally concept state kgp agent introduce
notation use rest order refer state components
necessary try exemplify discussion simple examples
preliminaries
kgp model assume possibly infinite vocabularies
fluents indicated f f
action operators indicated
time variables indicated
time constants indicated standing natural numbers
often use constant indicate current time
names agents indicated c c
constants ones mentioned normally indicated lower case
letters e g r r


ficomputational logic foundations kgp agents

given constraint language including constraint predicates respect structure e g natural numbers equipped notion
constraint satisfaction see section
assume set fluents partitioned two disjoint sets
mental fluents intuitively representing properties agent able plan
satisfied observed
sensing fluents intuitively representing properties control
agent observed sensing external environment
example f ixed resource may represent mental fluents namely
properties given fixed given resource obtained whereas request accepted connection may represent sensing fluents namely
properties request given resource accepted given
connection active note important distinguish mental sensing
fluents treated differently control agent mental fluents need
planned whereas sensing fluents observed clarified later

assume set action operators partitioned three disjoint sets
physical action operators representing actions agent performs order
achieve specific effect typically causes changes environment
communication action operators representing actions involve communications
agents
sensing action operators representing actions agent performs establish
whether fluent sensing fluent expected effect action
holds environment whether agent performed action
example sense connection action literal representing act sensing whether network connection time clear table action literal representing physical action removing every item given table
tell c c request r action literal representing communication action
expresses agent c requesting agent c resource r within dialogue
identifier time
fluent action operator associated arity assume arity
greater equal one argument last one convention
time point given fluent holds given action takes place time point
may time variable time constant given fluent f arity n refer
f sn x f sn x si constant x time
variable time constant timed fluent literals given fluent literal denote
role dialogue identifier become clearer section intuitively used link
communication actions occurring within dialogue
note represents classical negation negation failure occurs model within
knowledge bases agents supporting reasoning capabilities cycle theory negations
state understood classical negations



fikakas mancarella sadri stathis toni

complement namely f sn x f sn x f sn x
f sn x examples fluent literals resource pen representing
certain resource pen obtained time well ground
box table representing time certain box certain
table
note assume fluent literals ground except time parameter
allow us keep notation simpler highlight crucial role played
time parameter given simplification often denote timed fluent literals simply
x
given action operator arity n refer sn x si
constant x time variable time constant timed action literal similarly
case fluent literals simplicity assume timed action literals
ground except possibly time hence often denote timed action literals
x
adopt special syntax sensing actions form x
time variable time constant
sense f x f fluent
sense c x c name agent action operator
first case sensing action allows agent inspect external environment
order check whether fluent f holds time x sensing second
case sensing action allows agent determine whether time x another agent c
performed action
define formally concept state hkb f c agent
forest f
node tree f
non executable goal namely non ground timed fluent literal
executable goal namely non ground timed action literal
example tree f given figure p given
agent c needs fix getting two resources r r agent
already decided get r agent c already planned ask c
communication action tell c c request r example san vincenzo
scenario p may transfer airport needs arranged r may taxi c
taxi company needed transportation train station finally r may
train ticket
note time variable non executable goals actions tree
f understood variable existentially quantified within whole state
agent whenever goal action introduced within state time variable
understood distinguished fresh variable serving identifier


ficomputational logic foundations kgp agents

f ixed p





ppp

pp


p

pp
pp

resource r

resource r

tell c c request r

figure example tree f
indicated section roots trees referred top level goals executable
goals often called simply actions non executable goals may top level goals subgoals example figure node identifier top level goal nodes
identifiers sub goals node identifier action
notation given forest f tree f
node n parent n children n ancestors n siblings n
descendents n indicate parent node n children n
etc leaf n value true n leaf false otherwise
node n f parent n f children n f ancestors n f siblings n f
descendents n f leaf n f indicate parent n tree f
n occurs etc unique due uniqueness time variable identifying
nodes
nodes represent set nodes nodes f represent set

nodes f f nodes
indicated section top level goal tree f
reactive non reactive see section reactive top level goals introduced state transition whereas non reactive top level goals introduced gi transition example f agent c may consist tree
figure root non reactive goal well tree root reactive goal action


fikakas mancarella sadri stathis toni

tell c c accept request r action may reply planned agent c
request resource r agent c example san vincenzo scenario r
may meeting requested colleague
notation given forest f
rootsr f resp rootsnr f denote set reactive resp non reactive
top level goals f
nodesr f resp nodesnr f denote subset nodes f consisting nodes
trees whose root rootsr f resp rootsnr f
r f resp nr f stands reactive resp non reactive part f namely
set trees f whose root rootsr f resp rootsnr f
trivially r f nr f disjoint f r f nr f
temporal constraint store c
set constraint atoms referred temporal constraints given underlying
constraint language temporal constraints refer time constants well time variables
associated goals currently previously state
example given forest tree figure c may contain
indicating top level goal fixing p needs achieved within time
interval indicating resources r r need acquired
top level goal deemed achieved indicating
agent needs ask agent c first note need impose
executed order namely c may contain neither
agents dynamic knowledge base kb
kb set logic programming facts state agent recording actions
executed agent others time execution well
properties e fluents negation observed time
observation formally facts following forms
executed ground action literal meaning action
executed agent time
observed ground fluent literal meaning observed
hold time
observed c c agents name different name agent
whose state defining time constants ground action
literal means given agent observed time agent c
executed action time
see construction case note time executed
actions time observation typically different concrete implementation
kgp model depend example time execution transitions within
operational trace agent



ficomputational logic foundations kgp agents

note facts kb variable free time variables occur facts
first kind record actions executed agent facts
second kind record observations made agent environment excluding actions
executed agents represented instead facts third kind
example action labelled figure executed ae transition
time executed tell c c request r added kb moreover
time c observes e g transition poi resource r observation
observed resource r added kb finally kb may contain
observed c tell c c request r
represent agent c become aware time agent c requested
earlier time resource r c
instantiation time variables
time variable occurring non executable goal action f
instantiated time constant e g action execution time actual instantiation
recorded component state agent example action
labelled figure executed time added
use allows one record instantiation time variables
time keeping different goals fluent distinguished clearly time
variable exists one equality
notation given time variable denote time constant

worth pointing valuation temporal constraint c c
take equalities account namely ground valuation temporal
variables c must agree temporal variables assigned
example given c suitable valuation
whereas

reasoning capabilities
section give detailed specifications reasoning capabilities specified within framework ordinary logic programming temporal reasoning
identification preconditions effects abductive logic programming constraints section reactivity logic programming priorities
constraints section goal decision constraint programming section
constraint solving
reasoning capabilities defined means notion entailment respect
appropriate knowledge base time point appropriate follows


fikakas mancarella sadri stathis toni

r kbt r temporal reasoning kbt r constraint logic program
variant framework event calculus ec reasoning actions
events changes kowalski sergot

plan kbplan kbplan abductive logic program
constraints extending kbt r

react kbreact reactivity kbreact extension kbplan incorporating additional integrity constraints representing reactive rules
pre kbpre kbpre logic program contained kbt r
ef f kbef f kbef f logic program contained kbt r

gd kbgd kbgd logic program priorities constraints
constraint solving capability defined terms entailment cs
basically defined section
temporal reasoning reactivity identification preconditions
effects ec capabilities
reasoning capabilities specified within framework event calculus
ec reasoning actions events changes kowalski sergot
first give core ec use define capabilities
section
preliminaries core event calculus
nutshell ec allows one write meta logic programs talk objectlevel concepts fluents events interpret action operators time points
main meta predicates formalism
holds f fluent f holds time
clipped f fluent f clipped holding holding times

declipped f fluent f declipped holding holding
times
initially f fluent f holds initial time say time
happens operation happens time
initiates f fluent f starts hold operation time
sophisticated abductive logic programming version r kbt r given bracciali
kakas
section use original event calculus terminology events instead operators
rest



ficomputational logic foundations kgp agents

terminates f fluent f ceases hold operation time
roughly speaking last two predicates represent cause effects links operations fluents modelled world use meta predicate
precondition f fluent f one preconditions executability
operation
fluent literals agents state mapped onto ec follows ec representation fluent literal f resp f agents state atom holds f
resp holds f moreover arguments time variable need
considered ec representation fluent literal f x xn resp f x xn
holds f x xn resp holds f x xn
similarly action literals state agent represented ec
straightforward way given action literal ec representation happens
arguments time considered e g x xn ec representation given happens x xn
remainder abuse terminology sometimes refer
f x xn f x xn interchangeably fluent literals fluents although
strictly speaking fluent literals x xn interchangeably action
literals action operators although strictly speaking action literals
ec allows one represent wide variety phenomena including operations
indirect effects non deterministic operations concurrent operations shanahan
core ec use consists two parts domain independent rules
domain dependent rules basic domain independent rules directly borrowed
original ec
holds f
holds f
holds f
holds f
clipped f
declipped f

happens initiates f
clipped f
happens terminates f
declipped f
initially f clipped f
initially f declipped f
happens terminates f
happens initiates f

domain dependent rules define initiates terminates initially e g case
setting section may
initiates tell c svs inf orm q inf svs q
holds trustworthy c
initially inf svs arrival tr
note write holds f x xn instead holds f x xn done e g
shanahan want reason object level properties true false
environment use within meta level axioms event calculus see implement
persistence



fikakas mancarella sadri stathis toni

initially trustworthy co
namely action agent c providing information concerning query q
agent svs san vincenzo station agent initiates agent svs information
q provided c trustworthy moreover initially agent co central office
agent trustworthy agent svs information arrival time tr
conditions rule defining initiates seen preconditions effects
operator tell take place preconditions executability operators specified
means set rules facts defining predicate precondition e g
precondition tell svs c inf orm q inf svs q
namely precondition agent svs inform agent c q svs indeed
information q
notice presence language fluents negation e g f f
poses inconsistencies e may case holds f
holds f derived axioms set events e given set
happens atoms however easily shown never case provided
domain dependent part contain two conflicting statements form
initially f initially f since inconsistencies cannot caused except initial
time point see e g miller shanahan p
remainder assume domain dependent part
consistent agents
allow agents draw conclusions contents kb represents
narrative part agents knowledge add domain independent rules
following bridge rules
holds f
holds f
happens
happens

observed f clipped f
observed f declipped f
executed
observed

notice bridge rules make explicit translation state representation
ec representation fluents actions mentioned earlier section
note assume fluent holds time observed hold
choice dictated rationale observations considered reasoned
upon moment agent makes hand actions agents
effect time executed
introduced ability reason narratives events observations
need face inconsistency due conflicting observations e g agent
may observe fluent negation hold time done
time action unknown observation time last rule may replaced
happens observed
namely value fluent changed according observations moment observations
made



ficomputational logic foundations kgp agents

set initially atoms assume external world consistent
e never happen observed f observed f belong kb
fluent f time point
however still need cope frame consistency arises e g
given observations observed f observed f issue analogous
case two different events happen time point initiate
terminate fluent original ec suitable axioms predicates clipped
declipped added given avoid fluent negation holding
time happening two events time adopt
similar solution cope observations namely adding following two axioms
domain independent part
clipped f
declipped f

observed f
observed f

solution may naive circumstances sophisticated solutions may
adopted e g one proposed bracciali kakas
temporal reasoning
temporal reasoning capability invoked components kgp model
namely goal decision capability state revision transition selection operators see section prove disprove given possibly temporally
constrained fluent literal holds respect given theory kbt r purposes
kbt r ec theory composed domain independent domaindependent parts given section narrative part given kb
given state fluent literal possibly empty set temporal constraints c
temporal reasoning capability r defined
r c iff kbt r lp holds c
example given ec formulation section setting section
state hkb f c agent svs contains
kb observed co tell co svs inf orm arrival tr
r inf svs arrival tr

number abductive variants ec proposed literature deal
e g one proposed shanahan propose novel
variant somewhat inspired e language kakas miller allow situated
agents generate partial plans dynamic environment
refer kbplan hpplan aplan iplan abductive logic program
remainder sets seen conjunctions appropriate



fikakas mancarella sadri stathis toni

aplan assume holds assume happens namely consider two abducible predicates corresponding assuming fluent holds action occurs respectively certain time point
pplan obtained adding core ec axioms narrative given kb
following rules
happens assume happens
holds f assume holds f
iplan contains following set integrity constraints
holds f holds f f alse
assume happens precondition p holds p
assume happens executed time
integrity constraints iplan prevent generation partial plans
unfeasible first integrity constraint makes sure plan generated entails
fluent negation hold time second integrity constraint makes
sure plan requires action occur certain time point goal
enforcing preconditions action hold time point taken account
plan means preconditions already known hold
plan need accommodate actions guarantee hold time
execution action finally last integrity constraint forces assumed unexecuted
actions plan executable future predicate time meant
return current time
worth recalling concrete situations pplan iplan contain domaindependent rules constraints domain dependent rules may needed define
initiates terminates initially precondition may contain additional
rules integrity constraints expressing ramifications e g
holds f holds f holds fn
specific fluents domain moreover integrity constraints may represent
specific properties actions fluents domain example domain dependent
constraint could express two actions type cannot executed time
e g
holds tell c x accept request r
holds tell c x ref use request r f alse
intuitively constructing partial plan goal given leaf node
current forest amounts identifying actions sub goals allowing achieve
goal assuming nodes forest executable non executable
feasible concretely abductive logic program kbplan supports partial
follows whenever plan given goal requires agent execute action say
corresponding atom assume happens assumed amounts intending
execute action concrete time instantiating hand
plan given goal requires plan sub goal say corresponding atom
assume holds may assumed amounts setting requirement
needed sub goal notice total plans taken
account atoms form assume holds ever generated


ficomputational logic foundations kgp agents

kb
formally let kbplan
plan time time constant intuitively time capability invoked capability


plan specified follows

let hkb f c state g mental goal labeling leaf node
tree f let
ca assume happens nodes f
cg assume holds nodes f

ca cg
c c

g
plan xs c
iff
xs assume happens assume holds
c
c abductive answer holds wrt kbplan


abductive answer exists g




used


indicate
failure
plan
e abductive answer exists

example consider setting section domain dependent part
kbplan agent psa looking businessman scenario contains
initiates buy ticket online f rom ticket f rom
precondition buy ticket online f rom available connection
precondition buy ticket online f rom available destination
goal g ticket madrid denver assume f consists single tree
consisting solely root g thus ca cg g
plan xs c
xs buy ticket online madrid denver
available connection available destination denver
c
reactivity
capability supports reasoning reacting stimuli external environment
well decisions taken
knowledge base kbreact supporting reactivity adopt extension knowledge
base kbplan follows kbreact hpreact areact ireact
preact pplan
simplicity present case single goals



fikakas mancarella sadri stathis toni

areact aplan
ireact iplan rr
rr set reactive constraints form
body reaction c

reaction assume holds timed fluent literal
assume happens timed action literal
body non empty conjunction items form x timed fluent
literal x timed action literal x
observed
ii observed c
iii executed
iv holds
v assume holds
vi happens
vii assume happens
viii temporal constraints
contains least one item one ii iii
c temporal constraints
integrity constraints abductive logic programming variables body
implicitly universally quantified whole reactive constraint variables
reaction c occurring body implicitly existentially quantified righthand
side reactive constraint
notice body must contain least trigger e condition evaluated
kb intuitively reactive constraint body reaction c interpreted
follows instantiation observations body hold kb
corresponding instantiation remaining conditions body hold appropriate instantiation reaction associated appropriate instantiation
abuse notation use notions timed fluent action literals liberally
allow non ground even though defined timed fluent action literals ground
except possibly time parameter
strictly speaking syntactically reactive constraints integrity constraints due presence
conjunction represented rather disjunction head however reactive constraint
body reaction c transformed integrity constraint body n ew clause
n ew reaction c preact thus abuse notation treat reactive constraints
integrity constraints



ficomputational logic foundations kgp agents

temporal constraints c added f c respectively notice reaction
abducible performed reactivity capability
theory kb
formally let kbreact
react time time
constant intuitively time capability invoked reactivity capability
react specified follows let hkb f c state let

ca assume happens nodesnr f
cg assume holds nodesnr f

ca cg
c c


react xs c
iff
xs assume happens assume holds
c
c abductive answer query true wrt kbreact



abductive answer exists react used indicate failure
e abductive answer exists

example consider setting section kbplan given sections
let rr agent svs consist
observed c tell c svs request q holds inf svs q
assume happens tell svs c inf orm q
observed c tell c svs request q holds inf svs q
assume happens tell svs c ref use q
given hkb f c
kb observed co tell co svs inf orm arrival tr
observed psa tell psa svs request arrival tr
obtain

react tell svs psa inf orm arrival tr
identification preconditions
capability used kgp agents determine preconditions executability
actions planned preconditions defined domain dependent
part ec means set rules form precondition f representing
fluent f precondition executability action action operator see
let kbpre subset kbt r containing rules defining precondition


fikakas mancarella sadri stathis toni

identification preconditions capability pre specified follows given state
hkb f c timed action literal
pre cs
iff
cs

v

kbpre lp precondition

identification effects
capability used kgp agents determine effects actions already
executed order check whether actions successful note
actions may unsuccessful could executed executed
expected effect possible situations agent
full knowledge environment situated
effects defined domain dependent part ec means set
rules defining predicates initiates terminates let kbef f theory consisting
domain dependent domain independent parts ec well narrative
part kb identification effects ef f specified follows given state
hkb f c action operator
ef f
iff
f kbef f lp initiates f
f kbef f lp terminates f
constraint solving
constraint solving capability simply defined terms structure
notion presented section namely given state hkb f c
set constraints c
cs c iff c c
exists total valuation cs c iff exists total valuation
c c
goal decision
goal decision reasoning capability allows agent decide given time point
non reactive top level goals pursued go generate
plans aiming achieving generated goals goals current preferred
interest interest may change time
assume

v

true



ficomputational logic foundations kgp agents

goal decision capability operates according theory kbgd agent
represents goal preference policy kbgd includes kbt r thus dynamic observed
knowledge kb current state agent kbgd expressed variant lpp
described section whereby rules lower basic part p lpp theory
form possibly empty sequence variables
n g b c

time variable existentially quantified scope head rule
member
variables except universally quantified scope rule
head g rule consists fluent literal conjoined possibly
empty set temporal constraints represented h c
b non empty conjunction literals set auxiliary predicates
include atoms form holds timed fluent literal
atom time variables
conditions rule constrained possibly empty temporal constraints
c
rule represents ground instances total valuation
variables satisfies constraints c ground instance named
corresponding ground instance n intuitively conditions one rule
satisfied time grounds variable current time
capability applied goal head rule sanctioned one goals
agent would possibly prefer achieve time decision whether
goal indeed preferred would depend high level strategy part h kbgd
containing priority rules described section rules lower part
rules h priority rules include temporal atoms form
holds atom time conditions
accommodate form rules need extend notion incompatibility
defined conclusions h c simplify notation
remainder often write h ci instead h c
incompatibility defined different ways example relatively weak
notion incompatibility given follows two pairs h c h c
incompatible iff every valuation c c satisfied ground
instances incompatible stronger notion would require
sufficient one valuation exist makes corresponding ground
literals incompatible
theory kb
let us denote kbgd
gd time time
constant goal decision capability
gd defined directly terms
preference entailment pr lpp see section follows
given state hkb f c

gd gs


fikakas mancarella sadri stathis toni


gs g g gn n gi h ci n
iff gs maximal set

kbgd
pr h c h n n cn

means set goals gs generated currently sceptically preferred
goal preference policy represented kbgd current information kb
note two goals gs necessarily compatible two
special cases sceptically preferred goals time first one
concerns case goals currently sanctioned lower part
kbgd
gd returns empty set goals n second special
case occurs least two goals separately credulously preferred
goals incompatible
gd used
indicate failure identifying goals pursued
example consider san vincenzo scenario psa agent needs decide whether return home recharge battery agents goals categorised
assigned priority according category possibly factors kbgd
expressing given follows
low level part contains rules

n rh hreturn home
holds f inished work
holds home
time

n rb hrecharge battery
holds low battery
time

auxiliary part contains addition kbt r kb following rules
specify category goal relative urgency categories

typeof return home required
typeof recharge battery operational
urgent wrt type operational required



ficomputational logic foundations kgp agents

incompatibility part consists
incompatible return home recharge battery
namely two goals pairwise incompatible e agent one
goals time
high level part contains following priority rule

gd pref x n x n typeof x xt
typeof
urgent wrt type xt
current state hkb f c finished work
away home hold temporal reasoning time

gd hreturn home
suppose instead kb contains observed low battery weak
notion incompatibility requiring
every cs
holds incompatible return home recharge battery


gd hreturn home hrecharge battery
indeed incompatible return home recharge battery
hold however stronger notion incompatibility requiring
exists cs
holds incompatible return home recharge battery


gd hrecharge battery
suppose kbgd contains second operational goal hreplace part
sanctioned rule lower part time stronger
form incompatibility goal decision capability return
operational goals credulously preferred none sceptically preferred


fikakas mancarella sadri stathis toni

physical capabilities
addition reasoning capabilities defined far agent equipped
physical capabilities allow experience world situated world
consists agents objects provide environment agents
interact communicate
identify two types physical capabilities sensing actuating representing
capabilities abstract away sensors actuators agent would
typically rely upon access affect environment assume
sensors actuators part agents body classify implementation
issue stathis et al
physical sensing capability way agent interacts external
environment order inspect e g whether fluent holds
given time hand physical actuating capability way
agent interacts external environment order affect physically executing
actions
represent sensing physical capability agent function form
sensing l l

l possibly empty set
fluent literals f
terms form c meaning agent c performed action
sensed concrete time
l possibly empty set elements
term f v f fluent v true f alse meaning fluent f
observed value v namely true f alse time

term form c c agent name action
meaning agent c performed action time
note physical sensing requires time stamp specify time
applied within transitions note given non empty set l sensing l may
partial e g fluent f l neither f true l f f alse l
similarly represent physical actuating capability function
actuating

set action literals n agent instructs body
actuate time


ficomputational logic foundations kgp agents

subset actions body actually managed perform
meaning action belonging belonging physical
actuators agents body able perform current situation worth
pointing action belongs necessarily mean effects
successfully reached indeed preconditions executed
action may wrongly believed agent true execution time
agents may interfered ii agent may unaware
preconditions example confirmed availability agent may
booked hotel sending e mail agent booked last available
room meanwhile ii agent provide credit card number secure
booking words beliefs agent held kb may incorrect
incomplete
section section see aoi active observation introduction
used check effects actions identified fes effect selection operator
turn ef f reasoning capability actions executed moreover si
sensing introduction used check preconditions actions identified fp
precondition selection operator turn pre reasoning capability
executed make sure actions indeed executable overall following
cases may occur
action belongs executed
preconditions held time execution effects hold environment execution
preconditions wrongly believed hold time execution
agent partial knowledge environment kbplan incorrect
consequence effects hold execution
preconditions known hold time execution e g
agent observed planned hold
time replan consequence effects hold execution
action belongs executed body could execute

actuating physical capability check preconditions effects left
capabilities called within transitions transition invoking
actuating way body carry actions
implementation issue stathis et al

transitions
kgp model relies upon state transitions gi pi si poi aoi ae sr defined
following representation


hkb f c
x





hkb f c


fikakas mancarella sadri stathis toni

name transition hkb f c agents state transition applied x input transition time application
transition hkb f c revised state resulting application transition input x time state hkb f c please note transitions
modify components state transitions namely gi
poi sr input x empty omitted transitions
namely pi si aoi ae input non empty see section selected
appropriate selection operator see section
define transition formally defining hkb f c note
assume transition takes care possible renaming time variables output
capabilities capability used transition order guarantee
goal action forest univocally identified time variable
goal introduction
transition takes empty input calls goal decision capability determine
non reactive top level goals agent capability returns set goals
means circumstances possibly changed preferred top level goals
agent transition reflect changing forest state
consist one tree non reactive goal hand goal decision
capability return non reactive goals namely returns state left
unchanged although goals current state longer sceptically preferred
may still credulously preferred since others replace
agent carry current plans achieve
gi

hkb f c

hkb f c

given hkb f c

gd
f f
c c
ii otherwise
gd gs gs
f defined follows
nr f tg hg gs tg tree consisting solely
root g
r f
c c h ci gs
transition drops top level goals become semantically irrelevant due
changed circumstances agent changes environment replaces
relevant goals see section goals dropped


ficomputational logic foundations kgp agents

book keeping activities state revision sr transition transition
never add set goals
note gi replace whole forest old state forest
possible agent looses valuable information achieving goals
one preferred goals agent equivalent current goal
effect though minimized calling cycle theory gi transition
certain times e g current goals achieved timed alternatively
earlier formalisation gi transition could modified case ii
goals gs already occur modulo temporal variables associated temporal
constraints roots non reactive trees f trees kept f simple way
characterise goals follows let

xs hg c

hg ci gs
g rootsnr f
cs c iff cs c c

gs hg ci

hg c xs

constraints goals gs equivalent old constraints c example
gs may contain
g hhave ticket madrid denver
ticket madrid denver rootsnr f c
g definitely belongs gs let
newc



c

h c ixs

case ii redefined follows definitions xs gs newc
ii otherwise
gd gs gs case cs c newc
f c defined earlier case ii otherwise cs c newc
f defined follows
nr f tg hg gs gs f xs
tg tree consisting solely root g
f xs set trees f roots goals form g
hg xs
r f
c c c h ci gs gs newc
note keep temporal constraints state prior application gi
force variables goals remain state gi rewritten
old identifiers goals


fikakas mancarella sadri stathis toni

reactivity
transition takes empty input calls reactivity capability order determine
top level reactive goals state leaving non reactive part unchanged
reactive goals exist reactive part state empty
hkb f c

hkb f c


given hkb f c

react
f defined follows
r f
nr f nr f
c c

ii otherwise
react x c
f defined follows
nr f nr f
r f tx x x
tx tree consisting solely root x
c c c
note asymmetry case ii gi case ii gi
eliminates reactive goals case whereas leaves non reactive goals unchanged
indeed reactive goals may due choice specific non reactive goals
latter change former need evaluated instead non reactive goals affected
newly acquired reactive goals outcome enforcing reactive rules
note case ii similarly gi replaces whole reactive forest
old state reactive forest possible agent loses valuable
information achieving reactive goals one reactive goals
equivalent current goal variant case ii mirroring
variant given earlier gi cs well defined avoid
plan introduction
transition takes input non executable goal state selected
goal selection operator see section produces state calling agents
capability selected goal mental goal simply introducing
sensing action goal sensing goal
pi

hkb f c
g



hkb f c

g input goal selected tree f thus leaf see
section


ficomputational logic foundations kgp agents

f f g leaf n ew
c c c
n ew c obtained follows hkb f c
g mental goal let g
plan p
p
n ew c
p x c
n ew obtained adding element x
child g
ii g sensing goal child goal g
n ew node labelled sense child g
time variable
c
iii g sensing goal root
n ew tree consisting solely root labelled sense
time variable
c
sensing introduction
transition takes input set fluent literals preconditions actions
state produces state adding sensing actions leaves appropriate
trees forest component note si invoked input fluent literals
selected precondition selection operator chosen amongst preconditions
actions already known true see section
si

hkb f c
sp



hkb f c

sp non empty set preconditions actions form pairs precondition
action trees f given
n ew h sense h ai sp fresh variable
addsibling sa denotes tree obtained adding elements sa
siblings tree leaf

f f leaf h ai sp
addsibling sa leaf
sa sense h sense n ew
c c h sense n ew


fikakas mancarella sadri stathis toni

basically fluent literal selected precondition selection operator
precondition action sensing action added sibling
constraint expressing sensing action must performed added
current set temporal constraints
passive observation introduction
transition updates kb adding observed facts reflecting changes environment observations deliberately made agent rather
forced upon agent environment observations may properties
form positive negative fluents example battery running actions
performed agents example messages addressed agent
hkb f c

hkb f c

poi
sensing l
kb kb

observed f f true l
observed f f f alse l
observed c c l
active observation introduction
transition updates kb adding facts deliberately observed agent
seeks establish whether given fluents hold given time fluents
selected effect selection operator see section given input transition
whereas poi decided agent agent interrupted forced
observation environment aoi deliberate moreover poi may observe fluents
actions whereas aoi considers fluents effects actions executed
agent see section section
aoi

hkb f c
sf


hkb f c

sf f fn n set fluents selected actively sensed
effect selection operator sensing sf l
kb kb
observed f f true l
observed f f f alse l
action execution
transition updates kb recording execution actions agent actions
executed selected action selection operator see section prior
transition given input transition


ficomputational logic foundations kgp agents

ae

hkb f c
sas

hkb f c

sas non empty set actions selected execution action selection
operator
let subset non sensing actions sas subset sensing
actions sas
let sensing l f sense f
let sensing l c sense c
let actuating

kb kb
executed
observed f f true l
observed f f f alse l
observed c c l
cs c sense c

sas
sense f sas f l
c l cs c sense c
state revision
sr transition revises state removing timed goals actions goals
actions become obsolete one ancestors already believed
achieved make use following terminology
notation given state timed fluent literal timed fluent literal action
operator x time point
achieved stands
exists total valuation cs r
timed x stands
exists total valuation cs


fikakas mancarella sadri stathis toni

specification transition follows
sr

hkb f c

hkb f c

f set trees f pruned nodes f biggest subset
nodes f consisting goals actions x tree f
hkb f c
timed x
ii x action operator case executed x kb

iii x fluent literal achieved x
iv every siblings x f
siblings x f
siblings x f
fluent literal achieved
action literal executed kb

v x sensing action operator x sense
exists siblings x f precondition e
pre cs cs c
exists siblings x f sensing fluent
c
vi x top level goal parent x f p p nodes f
conditions specify sr keeps trees forest state intuitively conditions may understood terms prevent remaining
trees
condition removes timed goals actions
condition ii removes actions already executed
condition iii removes goals already achieved
condition iv removes goals actions whose siblings already timed
thus deleted condition
condition v removes sensing actions preconditions actions
deleted sensing goals deleted
condition vi recursively removes actions goals whose ancestors removed
following example illustrates sr used provide adjustment agents
goals plans light newly acquired information


ficomputational logic foundations kgp agents

setting
agent psa goal museum ticket state run museum
businessman wants visit plan buy ticket executing plan psa
observes european heritage day ehd short via appropriate message
another agent mus representing museum stating state run museums
europe give free tickets anybody walking day psas goal
already achieved goal plan deleted state
let agents initial state hkb f c
kb
f



c
consists top level goal g ticket two children
g money buy ticket



assuming kbt r contains
initiates ehd ticket
initiates buy
precondition buy money
remaining knowledge bases play useful role purposes
example therefore considered empty message museum
agent mus added kb via poi e g time following form
observed mus ehd
e time observed time mus announced state run museums
europe free day via sr time say g g eliminated
f g already achieved

selection operators
kgp model relies upon selection operators
fgs goal selection used provide input pi transition
fp precondition selection used provide input si transition
fes effect selection used provide input aoi transition
fas action selection used provide input ae transition
g reactive matter example



fikakas mancarella sadri stathis toni

selection operators defined terms capabilities namely temporal
reasoning identification preconditions effects constraint solving
high level description selection operators seen returning set
items given initial set satisfy certain number conditions example
given state hkb f c goal selection operator returns set non executable
goals trees f satisfy conditions precondition selection operator returns
set pairs consisting timed fluent literal precondition
action tree f ii action satisfying conditions effect
selection operator returns set fluent literals effects actions already
executed recorded kb satisfy conditions action selection operator
returns set actions trees f satisfy conditions
selection operators formally defined
goal selection
informally set conditions goal selection operator follows given state
hkb f c time point set goals selected fgs singleton set
consisting non executable goal g tree f time
g timed
ancestor g timed
child ancestor g timed
neither g ancestor g tree f already achieved
g leaf
intuitively condition ensures g already timed conditions impose
g belongs still feasible plan top level goal f condition makes
sure considering g wasteful
note already mentioned section simplicity select single goal
formally given state hkb f c time point let g set
non executable goals nodes f
timed
timed g g ancestors f
timed x x nodes f x child p
ancestors f
achieved g g ancestors f
leaf g f
g
fgs g g g
otherwise fgs


ficomputational logic foundations kgp agents

effect selection
informally set conditions effect selection operator follows given state
hkb f c time point fes selects fluents f f f one
effects action recently executed
note f f may occur f could observable
effect executed action necessarily goal action
contributes achieving example order check whether internet connection
available agent may want observe access skype network even though
really interested opening browser needs browser order perform
booking online
formally given state hkb f c time point set timed
fluents selected fes set timed fluents f action
operator
executed kb sufficiently
small number left parameter
ef f f f
action selection
informally set conditions action selection operator follows given state
hkb f c time point set actions selected fas defined
follows let x set actions trees f
executed
ancestor timed
child ancestor timed
ancestor already satisfied
precondition known false
already executed
fas x actions fas executable concurrently

intuitively conditions impose belongs still feasible plan toplevel goals f note condition definition x logically redundant
imposed definition fas however condition serves first
filter thus useful practice
formally given state hkb f c time point set actions
selected fas defined follows let x set actions occurring
leaves trees f


fikakas mancarella sadri stathis toni

exists total valuation cs
timed g g ancestors f
timed x x children g f g ancestors f
achieved g g ancestors f
let pre cs cs n
n n exists total valuation cs
r
exists executed kb
formalisation condition allows instances action
executed
fas x
exists total valuation variables c
cs
note definition action selection operator extended take
account notion urgency respect temporal constraints however
extension beyond scope work
precondition selection
informally set conditions precondition selection operator follows given
state hkb f c time point set preconditions actions
f selected fp set pairs hc ai timed preconditions c actions
nodes f
c precondition
c known true
one actions could selected execution fas would called
current time
reason selection operator returns pairs rather simply preconditions
transition si makes use outputs selection operator needs
know actions associated preconditions si introduces sensing
actions precondition returned place sensing actions siblings
associated actions f seen section
formally given state hkb f c time point set preconditions
actions selected fp set pairs hc ai timed preconditions c actions
nodes f
pre cs c conjunct cs


ficomputational logic foundations kgp agents

exists total valuation variables c cs
r c
x x defined section

cycle theory
behaviour kgp agents application transitions sequences
repeatedly changing state agent sequences fixed priori
conventional agent architectures determined dynamically reasoning
declarative cycle theories giving form flexible control cycle theories given
framework logic programming priorities lpp discussed section
formalisation cycle theories
use following notations
x represent application transition time state given
input x resulting state
x represent transition potentially chosen next transition
state input x
recall transitions x may empty set indicated section
formally cycle theory tcycle consists following parts
initial part tinitial determines possible transitions agent could
perform starts operate concretely tinitial consists rules form
x c x
refer via name r x rules sanction conditions
c hold initial state initial transition could applied state
input x example rule
r gi gi empty f orest
sanctions initial transition gi forest initial state
empty
note c x may empty non empty c x may refer
current time via condition time example rule
r p g p g gs fgs gs g gs time
sanctions initial transition pi forest initial state
contains goal planned current time goal
selection operator picks goal
basic part tbasic determines possible transitions following given transitions
consists rules form
x x ec x


fikakas mancarella sadri stathis toni

refer via name rt x rules sanction transition executed starting time state resulting state
conditions ec evaluated satisfied transition could
next transition applied input x ec enabling conditions
determine applied determine input x
via calls selection operators initial part tcycle ec may empty
may refer current time example rule
rae p g p g ae
gs fgs gs g gs time
sanctions pi follow ae current time goal
current state selected goal selection function
behaviour part tbehaviour contains rules describing dynamic priorities amongst
rules tbasic tinitial rules tbehaviour form
rt x rt x bc x x
refer via name ptt recall rt
rt names rules tbasic tinitial note abuse notation
could case one rule used specify priority first
transition take place words priority rules tinitial
rules tbehaviour sanction transition conditions bc hold
prefer next transition conditions bc behaviour
conditions give behavioural profile agent example rule

pgit
rt gi rt x empty f orest

sanctions gi preferred transition transition
state empty forest components tcycle
conditions bc may refer current time
auxiliary part including definitions predicates occurring enabling
behaviour conditions
incompatibility part effect expressing one instance transition
chosen one time
hence tcycle lpp theory p tinitial tbasic ii h tbehaviour
operational trace
cycle theory tcycle agent responsible behaviour induces
operational trace agent namely typically infinite sequence transitions
x ti si xi si ti ti si xi si ti

note order determine possible transition rule earlier form
one needs know applied resulted state conveyed
choice name rt x words prolog notation could represented
rule x ec x thus rule markovian



ficomputational logic foundations kgp agents

given initial state
ti given clock system ti ti
tcycle tbasic time pr x

tcycle tinitial ti si xi si ti time ti pr ti si xi
namely non final transition sequence followed preferred transition
specified tcycle stage preferred transition determined pr
unique choose one arbitrarily
normal cycle theory
normal cycle theory concrete example cycle theory specifying pattern
operation agent prefers follow sequence transitions allows achieve
goals way matches expected normal behaviour examples possible
cycle theories found literature kakas mancarella sadri stathis toni
sadri toni
basically normal agent first introduces goals none start via gi
reacts via repeats process via pi
executing part chosen plans via ae revising state via sr goals
dealt successfully revised away point agent returns introducing
goals via gi repeating process whenever process agent
interrupted via passive observation via poi chooses introduce goals via
gi take account changes environment whenever actions
unreliable sense preconditions definitely need checked
agent senses via si executing action whenever actions
unreliable sense effects definitely need checked agent actively
introduces actions aim sensing effects via aoi executed
original actions initially agent equipped goals would plan
straightaway pi
full definition normal cycle theory given appendix used
provide control examples next section note although normal
cycle theory classic observe plan act cycle agent control generalises
several ways giving flexibility agent behaviour adapt changing
environment example goals agent need fixed dynamically
changed depending newly acquired information let us illustrates feature
brief example suppose current state agent contains top level nonreactive goal hreturn home poi occurs adds observation
observed low battery time subsequent gi transition generated normal
cycle theory introduces goal hrecharge battery depending
details kbgd replaces previous goal adds additional goal
normal cycle theory next choose pi transition urgent
goal recharging battery


fikakas mancarella sadri stathis toni

examples
section revisit examples introduced section used throughout
illustrate components kgp model overall aim
illustrate interplay transitions interplay provides variety
behaviours afforded kgp model including reaction observations generation
execution conditional plans dynamic adjustment goals plans
unless specified differently assume tcycle normal cycle theory
presented section provide domain dependent definition auxiliary
part tcycle explicitly required
setting formalised
formalise initial state knowledge bases behaviour svs setting
described section
initial state
simplicity observations goals plan svs assumed empty
initially concretely let initial state svs
kb
f



c


knowledge bases
following section formulate reactivity knowledge base agent svs terms
utterances query ref ref use inf orm inspired fipa specifications communicative acts fipa b however although use names
communicative acts fipa specification adopt mentalistic
svs formulated
semantic interpretation terms pre post conditions thus kbreact

observed c tell c svs query ref q holds inf q
assume happens tell svs c inf orm q
observed c tell c svs query ref q holds inf q
assume happens tell svs c ref use q
assume happens tell svs c inf orm q
assume happens tell svs c ref use q
f alse
assume happens executable f alse
executable tell svs c c svs


ficomputational logic foundations kgp agents

initially inf arrival tr
precondition tell svs c inf orm q inf q
initiates tell c svs inf orm q inf q
terminates tell c svs inf orm q inf q
behaviour
illustrate behaviour psa assume agent requests svs
time say arrival time tr svs receives request psa time arrival
time tr via poi time svs records kb
observed psa tell psa svs query ref arrival tr
dialogue identifier via time say svs modifies state
adding f tree rooted action answer psa action refusal
represented
tell svs psa ref use arrival tr
temporal constraint added c
refusal action generated via reactivity capability svs
information requested arrival time svs executes planned action time
say via ae transition instantiating execution time adding following record
kb
executed tell svs psa ref use arrival tr
updating adding
suppose svs makes two observations follows time svs receives
information arrival time tr train co via poi svs records
kb
observed co tell co svs inf orm arrival tr
assume time svs receives another request psa arrival
time tr via poi svs records kb
observed psa tell psa svs query ref arrival tr
dialogue identifier leads different answer svs query
psa svs adds action state answer psa arrival time done
via say time tree added f rooted reactive action
tell svs psa inf orm arrival tr
temporal constraint added c
via ae svs executes action instantiating execution time say adding
following record
identifier dialogue within utterance performed would typically
different earlier



fikakas mancarella sadri stathis toni

executed tell svs psa inf orm arrival tr
kb adding
eventually sr clear planned executed actions f component
state svs
setting formalised
formalise initial state knowledge bases behaviour psa setting
described section
initial state
let us assume initially state psa follows
kb
f



c

consist goals respectively
g ticket madrid denver
g visa usa
knowledge bases
psa
plan goal g kbplan
contains

initiates buy ticket online f rom ticket f rom
precondition buy ticket online f rom available connection
precondition buy ticket online f rom available destination
psa
plan goal g kbplan
contains

initiates apply visa usa visa usa
precondition apply visa usa address usa
initiates book hotel l address usa holds l usa
behaviour
pi called state time say generates partial plan goal
changing state follows goal g acquires three children
g available connection
g available destination denver
buy ticket online madrid denver
consequently set temporal constraints updated
c


ficomputational logic foundations kgp agents

action generated action initiates goal g moreover every plan
generated must satisfy integrity constraints kbplan particular precondition
actions tree already hold must generated sub goals tree
g g generated tree
via transition si following sensing actions added siblings
action
sense available connection
sense available destination denver
constraints

added c
via ae two sensing actions executed original action
kb updated sensing follows suppose two actions
executed time consider first action senses fluent available connection
fluent confirmed physical sensing capability e available connection true
x
sensing available connection available destination x
observed available connection added kb hand
available connection f alse
x observed available connection added kb cases
added
neither cases occurs e sensing capability cannot confirm
available connection available connection fact added kb similarly
precondition available destination let us assume step ae
kb becomes
observed available connection
observed available destination denver
ae execute original action note agent might decide execute
action even one preconditions known satisfied sensing
g achieved sr eliminate g g state
resulting state f pi called say time generating
partial plan g changing state root g children
apply visa usa
g address usa
added c pi say time introduces
book hotel denver
assume auxiliary part tcycle contains rule
unreliable pre buy ticket online



fikakas mancarella sadri stathis toni

child g adding c ae time executes adding
kb ae time executes updating kb finally sr eliminates
actions goals returns empty f state

related work
many proposals exist architectures individual agents computational logic foundations see e g survey fisher bordini hirsch torroni
proposals logic programming example impact arisha ozcan ross subrahmanian eiter kraus subrahmanian bonatti dix
eiter kraus ozcan ross aaa balduccini gelfond baral gelfond
dali costantini tocchio minerva leite alferes pereira
golog levesque reiter lesperance lin scherl indigolog de giacomo
levesque sardina proposals modal logic first order logic
approaches example bdi model bratman et al rao georgeff
extensions deal normative reasoning broersen dastani hulstijn huang
van der torre agent shoham agentspeak rao variants
apl hindriks de boer van der hoek meyer variants dastani hobo
meyer
high level comparison similarities objectives existing
computational logic agency kgp aim specifying knowledgerich agents certain desirable behaviours similarities finer
details kgp model related work well differences
feature kgp best knowledge novel declarative
context sensitive specification agents cycle avoid static cycle control
rao georgeff rao kgp relies upon cycle theory determines
run time given circumstances individual profile agent next
step cycle theory sensitive solicited unsolicited information
agent receives environment helps agent adapt behaviour
changes experiences closest work apl hindriks
et al extended dastani de boer dignum meyer provides
meta programming constructs specifying cycle agent goal selection
plan expansion execution well else loop statements unlike
imperative constructs apl kgp uses set selection operators extended
model different behaviours types agents flexible ordering transitions
obtained preference reasoning transitions applied specific
point time preferences may change according external events changes
knowledge agent
another central distinguishing feature kgp model comparison existing
including logic programming modular integration within
single framework abductive logic programming temporal reasoning constraint logic
programming preference reasoning logic programming priorities order
support diverse collection capabilities one specified declaratively
equipped provably correct computational counterpart see bracciali


ficomputational logic foundations kgp agents

demetriou endriss kakas lu mancarella sadri stathis terreni toni
detailed discussion
compared existing logic programming approaches kgp two main similarities
minerva leite et al architecture exploits computational logic
gives declarative operational semantics agents unlike kgp minerva
agent consists several specialised possibly concurrent sub agents performing
tasks relies upon mdlp multidimensional dynamic logic programming leite et al
mdlp basic knowledge representation mechanism agent minerva
extension answer set programming explicit rules updating
agents knowledge base kgp instead integrate abductive logic programming
logic programming priorities combined temporal reasoning
closely related work kgp logic agent architecture reasoning
agents baral gelfond architecture assumes state agents
environment described set fluents evolve time terms transitions
labelled actions agent assumed capable correctly observing state
environment performing actions remembering history happened
agents knowledge base consists action description part specifying internal
agent transitions domain specific generic kgp knowledge
base contains agent observes environment including actions
kgps kb temporal aspects agent transitions specified action
language al implemented prolog language logic programs answerset programming semantics answer sets domain specific programs specified al
correspond plans kgp hypothetical narratives abductive event calculus
control agent static observe think act cycle instance kgp
cycle theories recent refined account overall given rise
aaa architecture see balduccini gelfond overview
dali costantini tocchio logic programming language designed executable specification logical agents kgp dali attempts provide constructs
represent reactivity proactivity agent extended logic programs dali
agent contains reactive rules events actions aimed interacting external
environment behaviour terms reactivity proactivity dali agent triggered
different event types external internal present past events events
actions time stamped record occur external events
observations kgp past events past observations however kgp
support internal events instead idea transitions called cycle
theory trigger reactive proactive behaviour
indigolog de giacomo et al high level programming language robots
intelligent agents supports kgp line sensing plan execution
dynamic incompletely known environments member golog family
languages levesque et al use situation calculus theory action perform
reasoning required executing program instead kgp model rely
abductive logic programming logic programming priorities combined temporal reasoning instead situation calculus kgp use event calculus
temporal reasoning use event calculus prerequisite model
interrap muller fischer pischel replaced another temporal


fikakas mancarella sadri stathis toni

reasoning framework needed apart difference use situation event calculi indigolog goals cannot decided dynamically whereas
kgp model change dynamically according specifications goal decision
capability
obvious similarity kgp model bdi model bratman et al
given correspondence kgps knowledge goals plan bdis
beliefs desires intentions respectively apart fact bdi model
modal logic kgp knowledge beliefs bdi partitioned modules
support reasoning capabilities kgp tries bridge gap
specification practical implementation agent gap criticized
bdi rao developed agentspeak l language computational
model agentspeak l formally studied dinverno luck
recent implementations agentspeak interpreter incorporated jason
platform bordini hubner kgp implementation prosocs bracciali
et al jason implementation seeks narrow gap specification
executable bdi agent programs jason extends bdi features belief
revision alechina bordini hubner jago logan
particular line work bdi padgham lambrix investigate
notion capability integrated bdi logic rao georgeff
bdi agent reason capabilities capability work
informally understood ability act rationally towards achieving particular goal
sense abstract plan type believed achieve goal formally
bdi logic rao georgeff extended incorporate modality capabilities
constrains agent goals intentions compatible agent believes
capabilities set compatibility axioms presented detailing semantic
conditions capture desired inter relationships among agents beliefs capabilities
goals intentions work summarises extensions bdi model
implemented adapting bdi interpreter include capabilities arguing
benefits extension original bdi interpreter rao georgeff
kgp capabilities equate reasoning capabilities agent allow agent
plan actions given state react incoming observations decide upon
goals adopt however kgp use capabilities level agents
domain specific knowledge guide agent determining whether rational
adopt particular goal
issue separation specification implementation exists
kgp model agent shoham later refinement placa thomas
two differences kgp agent placa explicit
links exist kgp model amongst goals structuring forest
agent state richer theories kgp specify priorities amongst potential
goals restricted temporal orderings explicit links exploited
revising goals state via revision transition light information
passage time
boid architecture broersen et al extends well known bdi model rao
georgeff obligations thus giving rise four main components representing
agent beliefs obligations intentions desires focus boid ways


ficomputational logic foundations kgp agents

resolving conflicts amongst components order define agent types
including well known types agent theories realistic selfish social simple
minded agents agent types differ give different priorities rules
four components instance simple minded agent gives higher priority
intentions compared desires obligations whereas social agent gives higher priority
obligations desires use priorities propositional logic formulae specify
four components agent types
existing kgp model already resolves conflicts boid tries address example conflict belief prior intention means
intended action longer executed due changes environment
kgp agent notice give higher priority belief prior
intention allowing agent effect retract intended action time permitting
replan goals kgp model includes notion priority used goal
decision capability cycle theory controls behaviour agent
kgp model extended deal normative concepts extended model
known n kgp sadri stathis toni n kgp common boid
seeks extend kgp addition obligations n kgp model
extends notion priorities incorporating amongst different types goals
actions detailed comparison n kgp related work presented sadri stathis
toni
features included approaches absent
kgp model bdi impact system arisha et al subrahmanian
et al allow agents knowledge bases representations knowledge
agents systems allow agents degree introspection
ability reason agents beliefs reasoning kgp model date
include features impact allows incorporation legacy systems possibly diverse languages richer knowledge base language including
deontic concepts probabilities similarly apl system combination
imperative logic programming languages includes optimisation component
absent kgp component apl includes rules identify given
situation agent pursuing suboptimal plan help agent better way
achieving goals apl includes additional functionalities learning van
otterlo wiering dastani meyer model currently support
apl dastani et al extension apl goals goal plan rules well
external internal events apl customisable via graphical interface cycle
fixed customised

conclusions
presented computational logic foundations kgp model agency
model allows specification heterogeneous agents interact
exhibit proactive reactive behaviour allowing function dynamic
environments adjusting goals plans changes happen environments kgp incorporates highly modular agent architecture integrates collection


fikakas mancarella sadri stathis toni

reasoning sensing capabilities synthesised within transitions orchestrated cycle
theories take account dynamic context agent preferences
formal specification kgp components within computational logic
major advantage facilitating formal analysis model direct verifiable
implementation formal analysis started sadri toni
give formal analysis kgp agents exploring effectiveness terms goal
achievement reactive awareness impact reasoning capabilities towards
progress goal achievement implementation precursor model described
kakas et al b already developed within prosocs platform
stathis et al upon provably correct computational counterparts defined
component model given kakas et al b concrete choices
computational counterparts described bracciali et al resulting
development framework allows deployment testing functionality earlier
variant kgp agents deployment agents relies upon agent template designed
stathis et al builds upon previous work head body metaphor
described steiner et al haugeneder et al mind body architecture introduced bell recently used huang eliens de bra
development platform applied number practical applications
particular ambient intelligence stathis toni sadri
provided guidelines specifying applications kgp agents future work includes implementing deploying revised kgp model given envisage
pose limited conceptual challenges able capitalise experience
implementing deploying precursor model
sadri stathis toni explored precursor kgp agent
model augmented normative features allowing agents reason
choose social personal goals prohibitions obligations would
interesting continue work finalised kgp model given
sadri toni developed number different profiles behaviour
defined terms specific cycle theories formally proved advantages given
circumstances would interesting explore dimension characterise
different agent personalities provide guidance formal properties
type personality needed applications
future work includes extending model incorporate reasoning capabilities including knowledge revision e g inductive logic programming
sophisticated forms temporal reasoning including identifying explanations unexpected
observations ii introspective reasoning reasoning beliefs agents
iii experimentation model via implementation iv development
concurrent implementation

acknowledgments
work supported eu fet global computing initiative within socs
project ist wish thank colleagues socs useful discussions
development kgp grateful chitta baral anonymous
referees helpful comments earlier version


ficomputational logic foundations kgp agents

appendix normal cycle theory
give main parts normal tcycle exclude others example
definitions incompatible auxiliary part including definitions predicates
empty f orest unreliable pre etc details see kakas et al
tinitial consists following rules
r gi gi empty f orest
r ae ae empty non executable goals fas
time
r p g p g gs fgs gs g gs time
tbasic consists following rules
rules deciding might follow ae transition follows
rae p g p g ae gs fgs gs
g gs time


rae ae ae ae fas
time
rae aoi f aoi f ae f fes
f time
rae sr sr ae
rae gi gi ae
namely ae could followed another ae pi aoi sr
gi poi
rules deciding might follow sr follows
rsr p g p g sr gs fgs gs g gs
time
rsr gi gi sr gs fgs gs
time

rsr ae ae sr fgs
time
namely sr followed pi gi ae depending whether
goals plan state
rules deciding might follow pi follows
rp ae ae p g fas
time

rp si p si p p g p fp p time
second rule allow possibility sensing preconditions action
execution
rules deciding might follow gi follows
rgi gi
rgi p g p g gi gs fgs gs g gs
time
namely gi followed pi goals plan
rules deciding might follow follows


fikakas mancarella sadri stathis toni

rre p g p g gs fgs gs g gs
time
rre si p si p p fp p
time
rules deciding might follow si follows
rsi ae ae si p fas
time

rsi sr sr si p
rules deciding might follow aoi follows
raoi ae ae aoi f fas
time

raoi sr sr aoi f
raoi si p si p aoi f p fp p
time
rules deciding might follow poi follows
rp oi gi gi p oi
tbehaviour consists following rules
gi given higher priority trees state

pgit
rt gi rt x empty f orest
transitions gi possibly indicating
trees initial state agent gi first transition
gi given higher priority poi
p oi r


pgit
p oi gi rp oi
transitions gi
gi transition given higher priority
gi
pret
rgi rgi x
transitions
transition pi given higher priority
ppre
rre p g rre x
transitions p
pi transition ae given higher priority unless actions
actions selected execution whose preconditions unreliable need checking
case si given higher priority
pi
paet
rp ae rp x unreliable pre
transitions ae
pi
rp si p rp ae unreliable pre
psiae
si transition ae given higher priority
si
rsi ae rsi x
paet
transitions ae
ae transition ae given higher priority
actions execute state case aoi sr given higher
priority depending whether actions unreliable sense
effects need checking


ficomputational logic foundations kgp agents

ae
paet
rae ae rae x
transitions ae note definition tbasic transition ae applicable
still actions executed state
ae
ae
paoit
rae aoi f rae x bcaoi
f time
ae
transitions aoi behaviour condition bcaoi f defined
auxiliary part
ae
bcaoi
f empty executable goals unreliable ef f ect
similarly
ae time
ae
rae sr rae x bcsr
psrt
transitions sr
ae empty executable goals unreliable ef f ect
bcsr
assume auxiliary part tcycle specifies whether given set actions
contains unreliable action sense expressed unreliable ef f ect defines
predicate empty executable goals

sr transition pi higher priority
ppsr
rsr p g rsr x
transitions p
note definition tbasic transition pi applicable still goals
plan state actions goals left state rule rgi
would apply
initial state pi given higher priority
pp r p g r x
transitions p note definition tinitial transition pi
applicable initially goals plan initial state



fikakas mancarella sadri stathis toni

references
alechina n bordini r h hubner j f jago logan b belief revision
agentspeak agents nakashima h wellman p weiss g stone p
eds th international joint conference autonomous agents multiagent
systems aamas pp hakodate japan acm
arisha k ozcan f ross r subrahmanian v eiter kraus
impact platform collaborating agents ieee intelligent systems

balduccini gelfond aaa architecture overview aaai
spring symposium architectures intelligent theory agents aita
baral c gelfond reasoning agents dynamic domains logic
artificial intelligence pp kluwer academic publishers norwell usa
bell j theory practical rationality proceedings aaai
fall symposium rational agency pp aaai press
bordini r h hubner j f bdi agent programming agentspeak jason
tutorial toni f torroni p eds computational logic multiagent systems th international workshop clima vi lecture notes computer
science pp springer
bracciali kakas frame consistency reasoning explanations
proceedings th international workshop non monotonic reasoning
nmr whistler bc canada
bracciali demetriou n endriss u kakas c lu w mancarella p sadri f
stathis k terreni g toni f kgp model agency global
computing computational model prototype implementation priami c
quaglia p eds global computing pp rovereto italy springer
bracciali endriss u demetriou n kakas c lu w stathis k
crafting mind prosocs agents applied artificial intelligence

bratman israel pollack plans resource bounded practical reasoning computational intelligence
broersen j dastani hulstijn j huang z van der torre l boid
architecture conficts beliefs obligations intentions desires proceedings fifth international conference autonomous agents agents pp
acm press montreal canada
clark k l negation failure gallaire h minker j eds logic
data bases pp plenum press
costantini tocchio dali logic programming agent oriented language alferes j j leite j eds proceedings th european conference logics artificial intelligence jelia vol lecture notes
computer science pp springer


ficomputational logic foundations kgp agents

dastani de boer f dignum f meyer j j programming agent deliberation illustrated apl language autonomous agents
mult agent systems aamas pp australia
dastani hobo meyer j j practical extensions agent programming
languages proceedings sixth international joint conference autonomous
agents multiagent systems aamas acm press
de bruijn stathis k socio cognitive grids net universal human
resource kameas streitz n eds proceedings conference tales
disappearing computer pp santorini cti press
de giacomo g levesque h j sardina incremental execution guarded
theories acm transactions computational logic
dinverno luck engineering agentspeak l formal computational
model j log comput
fipa communicative act library specification experimental specification
xc h foundation intelligent physical agents http www fipa org
fipa query interaction protocol b experimental specification xc f foundation intelligent physical agents http www fipa org
fisher bordini r hirsch b torroni p computational logics agents
road map current technologies future trends computational intelligence

haugeneder h steiner mccabe f imagine framework building
multi agent systems deen ed proceedings international
working conference cooperating knowledge systems ckbs pp
dake centre university keele uk
hindriks k v de boer f van der hoek w meyer j c agent programming apl autonomous agents multi agent systems
huang z eliens de bra p architecture web agents proceedings
euromedia scs
jaffar j maher constraint logic programming survey journal logic
programming
kakas c kowalski r toni f role abduction logic programming gabbay hogger c j robinson j eds handbook logic
artificial intelligence logic programming vol pp oxford university
press
kakas c mancarella p dung p acceptability semantics logic
programs proceedings eleventh international conference logic programming pp cambridge usa mit press
kakas c miller r simple declarative language describing narratives
actions logic programming


fikakas mancarella sadri stathis toni

kakas c moraitis p argumentation decision making autonomous
agents rosenschein j sandholm wooldridge yokoo eds
proceedings second international joint conference autonomous agents
multiagent systems aamas pp melbourne victoria acm press
kakas mancarella p sadri f stathis k toni f declarative agent
control leite j torroni p eds clima v computational logic multiagent systems vol lecture notes artificial intelligence lnai pp
springer verlag
kakas c kowalski r toni f abductive logic programming j log
comput
kakas c mancarella p sadri f stathis k toni f declarative agent
control leite j torroni p eds computational logic multi agent systems th international workshop clima v vol lecture notes computer
science pp springer
kakas c mancarella p sadri f stathis k toni f b kgp model
agency de mantaras r l saitta l eds proceedings th eureopean
conference artificial intelligence ecai pp ios press
kowalski r sergot logic calculus events generation
computing
kowalski r toni f abstract argumentation artificial intelligence law
journal special issue logical argumentation kluwer
academic publishers
leite j alferes j j pereira l min erva dynamic logic programming agent architecture intelligent agents viii th international workshop
atal seattle wa usa revised papers vol lecture notes artificial intelligence pp
levesque h j reiter r lesperance lin f scherl r b golog
logic programming language dynamic domains journal logic programming

mamdani e h pitt j stathis k connected communities standpoint
multi agent systems generation computing
mancarella p sadri f terreni g toni f partially situated
agents leite j torroni p eds computational logic multi agent systems th international workshop clima v vol lecture notes computer
science pp springer
miller r shanahan alternative formulations event calculus
kakas c sadri f eds computational logic logic programming
beyond essays honour robert kowalski vol lecture notes
computer science pp springer
muller j fischer k pischel pragmatic bdi architecture huhns
n singh p eds readings agents pp morgan kaufmann
publishers


ficomputational logic foundations kgp agents

padgham l lambrix p formalisations capabilities bdi agents autonomous agents multi agent systems
prakken h sartor g system defeasible argumentation defeasible
priorities international conference formal applied practical reasoning
springer lecture notes ai pp
prakken h sartor g argument extended logic programming defeasible priorities journal applied non classical logics
rao agentspeak l bdi agents speak logical computable language
van hoe r ed agents breaking away th european workshop modelling
autonomous agents multi agent world maamaw eindhoven netherlands january proceedings vol lecture notes computer
science pp springer verlag
rao georgeff p modeling rational agents within bdi architecture
fikes r sandewall e eds proceedings knowledge representation
reasoning kr r pp morgan kaufmann publishers
rao georgeff p modeling rational agents within bdi architecture
huhns n singh p eds readings agents pp morgan
kaufmann publishers san francisco ca usa
rao georgeff p abstract architecture rational agents nebel
b rich c r swartout w eds rd international conference principles
knowledge representation reasoning kr pp cambridge
usa morgan kaufmann
sadri f kgp model agency design applications tutorial
toni f torroni p eds computational logic multi agent systems th
international workshop clima vi vol lecture notes computer science
pp springer
sadri f stathis k toni f normative kgp agents computational mathematical organization theory
sadri f toni f variety behaviours profiles logic agents
toni f torroni p eds computational logic multi agent systems th
international workshop clima vi vol lecture notes computer science
pp springer
sadri f toni f formal analysis kgp agents fisher van der hoek
w konev b lisitsa eds logics artificial intelligence th european
conference jelia vol lecture notes computer science pp
springer
shanahan solving frame mit press
shanahan prediction deduction explanation abduction proceedings
th international joint conference artificial intelligence pp
shoham agent oriented programming artificial intelligence


fikakas mancarella sadri stathis toni

socs societies computees computational logic model description
analysis verification global open societies heterogeneous computees
http lia deis unibo socs
stathis k child c lu w lekeas g k agents environments
tech rep technical report ist city dn socs consortium
ist city dn
stathis k kakas lu w demetriou n endriss u bracciali
prosocs platform programming software agents computational logic
muller j petta p eds proceedings agent theory agent implementation ai emcsr session pp vienna austria
stathis k toni f ambient intelligence kgp agents markopoulos p
eggen b aarts e h l crowley j l eds ambient intelligence proceedings
second european symposium eusai vol lecture notes computer
science pp springer
steiner e haugeneder h mahling collaboration knowledge bases
via knowledge collaboration deen ed ckbs proceedings
international working conference cooperating knowledge systems pp
springer verlag
subrahmanian v bonatti p dix j eiter kraus ozcan f ross r
heterogeneous agent systems mit press aaai press cambridge usa
thomas r placa agent programming language wooldridge j
jennings n r eds intelligent agents pp berlin springer verlag
van otterlo wiering dastani meyer j j characterization
sapient agents hexmoor h ed international conference integration
knowledge intensive multi agent systems kimas pp boston massachusetts ieee
wooldridge introduction multiagent systems john wiley sons
yip forth j stathis k kakas c software anatomy kgp agent
gleizes p kaminka g nowe ossowski tuyls k verbeeck k
eds eumas proceedings third european workshop multi agent
systems pp koninklijke vlaamse academie van belie voor wetenschappen
en kunsten




