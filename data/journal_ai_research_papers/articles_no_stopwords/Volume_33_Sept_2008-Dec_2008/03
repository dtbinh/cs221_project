journal artificial intelligence

submitted published

multi valued decision diagrams aomdds
graphical
robert mateescu

mateescu paradise caltech edu

electrical engineering department
california institute technology
pasadena ca usa

rina dechter

dechter ics uci edu

donald bren school information computer science
university california irvine
irvine ca usa

radu marinescu

r marinescu c ucc ie

cork constraint computation centre
university college cork ireland

abstract
inspired recently introduced framework search spaces graphical propose augment multi valued decision diagrams mdd nodes order
capture function decomposition structure extend compiled data structures general weighted graphical e g probabilistic present multi valued
decision diagram aomdd compiles graphical model canonical form supports polynomial e g solution counting belief updating constant time e g equivalence
graphical queries provide two compiling aomdd graphical
model first search works applying reduction rules trace memory
intensive search second inference uses bucket elimination
schedule combine aomdds input functions via apply operator
compilation time size aomdd worst case exponential
treewidth graphical model rather pathwidth known ordered binary decision
diagrams obdds introduce concept semantic treewidth helps explain
size decision diagram often much smaller worst case bound provide
experimental evaluation demonstrates potential aomdds

introduction
extends decision diagrams multi valued decision diagrams aomdds
shows graphical compiled data structures work presented
two existing frameworks search spaces graphical
decision diagrams
search spaces
search spaces dechter mateescu b proven unifying
framework classes search graphical main characteristic
exploitation independencies variables search provide exponential
speedups traditional search methods viewed traversing structure
c

ai access foundation rights reserved

fim ateescu echter arinescu

nodes capture decomposition independent subproblems nodes represent branching according variable values spaces accommodate dynamic variable
ordering however current work focuses static decomposition examples
search trees graphs appear later example figures
search space idea originally developed heuristic search nilsson
context graphical search dechter mateescu inspired
search advances introduced sporadically past three decades constraint satisfaction
recently probabilistic inference optimization tasks specifically resembles
pseudo tree rearrangement freuder quinn adapted subsequently distributed constraint satisfaction collin dechter katz recently
modi shen tambe yokoo shown related graph backjumping dechter work extended bayardo miranker bayardo
schrag recently applied optimization tasks larrosa meseguer sanchez
another version viewed exploring graphs presented recently constraint satisfaction terrioux jegou b optimization terrioux jegou
similar principles introduced recently probabilistic inference recursive conditioning darwiche well value elimination bacchus dalmao pitassi
b currently core advanced sat solvers sang bacchus
beame kautz pitassi
decision diagrams
decision diagrams widely used many areas especially software hardware
verification clarke grumberg peled mcmillan bdd represents boolean
function directed acyclic graph two terminal nodes labeled every internal
node labeled variable exactly two children low high isomorphic
nodes merged would full search tree called shannon tree
usual full tree explored backtracking tree ordered variables encountered
order along every branch compressed merging isomorphic nodes
e label identical children eliminating redundant nodes e whose
low high children identical celebrated reduced ordered binary decision
diagram obdd short introduced bryant however underlying structure
initial shannon tree tree search trees reduced node
merging redundant nodes elimination get compact search graph viewed
bdd representation augmented nodes
knowledge compilation graphical
combine two ideas creating decision diagram structure thus exploiting decomposition detail number values increased
two constant context constraint networks decision diagrams used
represent whole set solutions facilitating solutions count solution enumeration queries
equivalence constraint networks benefit moving structure
lower complexity size compiled structure typically moves
bounded exponentially pathwidth pw characteristic chain decompositions
linear structures exponentially bounded treewidth w characteristic tree


fiand ulti valued ecision iagrams aomdd g raphical odels

structures bodlaender gilbert holds w pw pw w log n
n number variables model cases compactness achieved
practice often far smaller bounds suggest
decision diagram offers compilation propositional knowledge base extension
obdds provided algebraic decision diagrams add bahar frohm gaona hachtel
macii pardo somenzi terminal nodes take values
arbitrary finite domain knowledge compilation become important
direction automated reasoning past decade selman kautz darwiche marquis
cadoli donini typically knowledge representation language compiled
compact data structure allows fast responses queries accordingly computational
effort divided offline online phase work pushed
offline compilation used generate compact building blocks used online
multiple times macro operators compiled prior search viewed
light korf felner graphical building blocks functions
whose compact compiled representations used effectively across many tasks
one example consider product configuration tasks imagine user chooses sequential options configure product naive system user would allowed choose valid
option current level initial constraints product configured
else dead end encountered system would backtrack previous state
continue would fact search space possible partial configurations needless say would unpractical would offer user guarantee
finishing limited time system compilation would actually build backtrack free
search space offline phase represent compact manner online phase
valid partial configurations e extended full valid configuration allowed
depending query type response time guarantees offered terms size
compiled structure
numerous examples diagnosis formulated
graphical could benefit compilation palacios bonet darwiche geffner
huang darwiche diagnosis compilation facilitate fast detection possible faults
explanations unusual behavior formulated graphical
compilation would allow swift adjustments according changes environment
probabilistic one used types graphical basic query
compute conditional probabilities variables given evidence compact compilation
probabilistic model would allow fast response queries incorporate evidence acquired time
example two important tasks bayesian networks computing probability
evidence computing maximum probable explanation mpe model
variables become assigned evidence tasks performed time linear compilation size practice many cases smaller upper bound treewidth
pathwidth graph formal verification another example compilation heavily used
compare equivalence circuit design check behavior circuit binary decision
diagram bdd bryant arguably widely known used compiled structure
contributions made knowledge compilation general decision diagrams particular following
formally describe multi valued decision diagram aomdd prove
canonical representation constraint networks given pseudo tree


fim ateescu echter arinescu

extend aomdd general weighted graphical
give compilation search saves trace memory
intensive search reduces one bottom pass
present apply operator combines two aomdds complexity
quadratic input never worse exponential treewidth
give scheduling order building aomdd graphical model starting
aomdds functions variable elimination
guarantees complexity exponential induced width treewidth along
ordering
aomdds relate earlier recent compilation frameworks providing unifying perspective methods
introduce semantic treewidth helps explain compiled decision diagrams
often much smaller worst case bound
provide experimental evaluation data structure
structure follows section provides preliminary definitions description
binary decision diagrams bucket elimination section gives overview
search spaces section introduces aomdd discusses properties section
describes search compiling aomdd section presents compilation
bucket elimination schedule apply operation section proves
aomdd canonical representation constraint networks given pseudo tree section
extends aomdd weighted graphical proves canonicity section ties
canonicity concept semantic treewidth section provides experimental
evaluation section presents related work section concludes proofs
appear appendix

preliminaries
notations reasoning defined terms set variables taking values finite
domains set functions defined variables denote variables subsets
variables uppercase letters e g x values variables lower case letters e g
x sets usually denoted bold letters example x x xn set
variables assignment x x xn xn abbreviated x hx x
hxn xn x x xn subset variables dy denotes cartesian product
domains variables projection assignment x x xn subset
denoted xy x denote short assignment values
variables respective domains denote functions letters f g h etc
scope set arguments function f scope f
graphical
efinition graphical model graphical model tuple hx f


fiand ulti valued ecision iagrams aomdd g raphical odels

x x xn finite set variables
dn set respective finite domains values
f f fr set positive real valued discrete functions e domains
listed defined subset variables si x called scope denoted
scope
q p
combination operator e g product sum join take
input two real valued discrete functions produce another real valued discrete
function
graphical model represents combination functions ri
several examples graphical appear later example figure shows constraint
network figure shows belief network
order define equivalence graphical useful introduce notion
universal graphical model defined single function
efinition universal equivalent graphical model given graphical model

hx f universal equivalent model u hx f f
two graphical equivalent represent function namely
universal model
efinition weight full partial assignment given graphical model
hx weight full assignment x x xn defined w x
f f f x scope f given subset variables x weight partial assignment
combination functions whose scopes included denoted fy evaluated
assigned values namely w f fy f scope f
consistency graphical range functions special zero value
absorbing relative combination operator e g multiplication combining anything
yields value expresses notion inconsistent assignments primary
concept constraint networks defined relative graphical
element
efinition consistent partial assignment solution given graphical model
element partial assignment consistent cost non zero solution consistent assignment variables
efinition primal graph primal graph graphical model undirected graph
variables vertices edge connects two variables appear scope
function
primal graph captures structure knowledge expressed graphical model
particular graph separation indicates independency sets variables given assignments
variables advanced graphical exploit graphical structure
heuristically good elimination order tree decomposition similar method
use concept pseudo tree resembles tree rearrangements introduced freuder
quinn
combination operator defined axiomatically shenoy



fim ateescu echter arinescu

e







e

b


f

b

g

f

c

g
c

graph coloring

b constraint graph

figure constraint network
efinition pseudo tree pseudo tree graph g x e rooted tree
set nodes x every arc e backarc path rooted tree starts
root ends one leaf two nodes connected backarc exists path
contains
use common concepts parameters graph theory characterize connectivity graph close tree chain induced width graphical model
governs complexity solving bucket elimination dechter shown
bound search graph memory used cache solved subproblems dechter
mateescu
efinition induced graph induced width treewidth pathwidth ordered graph
pair g g x xn e undirected graph x xn
ordering nodes width node ordered graph number neighbors
precede ordering width ordering denoted w maximum width
nodes induced width ordered graph w width induced ordered graph
obtained follows node last first preceding neighbors connected
clique induced width graph w minimal induced width orderings
induced width equal treewidth graph pathwidth pw graph
treewidth restricted class orderings correspond chain decompositions
reasoning tasks queries defined graphical defined formally marginalization operators projection summation minimization
however since goal present compilation graphical model independent
queries posed discuss tasks informal manner
information see work kask dechter larrosa dechter
throughout use two examples graphical constraint networks
belief networks case constraint networks functions understood relations words functions called constraints take two values
f alse true value indicates corresponding assignment variables inconsistent allowed value indicates consistency belief networks example
general case graphical called weighted graphical functions case
conditional probability tables values function real numbers interval



fiand ulti valued ecision iagrams aomdd g raphical odels

example figure shows graph coloring modeled constraint network given map regions color region one given colors red
green blue neighboring regions different colors variables
regions one domain red green blue constraints relation
different neighboring regions figure b shows constraint graph solution
red b blue c green green e blue f blue g red given figure
detailed example given later example
propositional satisfiability special case csp propositional satisfiability sat formula conjunctive normal form cnf conjunction clauses clause
disjunction literals propositions negations example p q r
clause p q r propositions p q r literals sat
decide whether given cnf theory model e truth assignment propositions
violate clause propositional satisfiability sat defined csp
propositions correspond variables domains constraints represented clauses
example clause b relation propositional variables allows tuples
b except b
cost networks immediate extension constraint networks cost networks set
functions real valued cost functions primary task optimization gai nets
generalized additive independence fishburn used represent utility functions
example cost functions appear figure
efinition
p cost network combinatorial optimization cost network tuple
hx c x set variables x x xn associated set
discrete valued domains dn set cost functions c c cr
ci real valued function defined subset variables si x combination operator
p
reasoning minimum cost solution

belief networks pearl provide formalism reasoning partial beliefs conditions uncertainty defined directed acyclic graph vertices representing random
variables interest e g temperature device gender patient feature object occurrence event arcs signify existence direct causal influences
linked variables quantified conditional probabilities attached cluster parentschild vertices network
q
efinition belief networks belief network bn graphical model p hx pg
x x xn set variables domains dn given directed acyclic graph g x nodes pg p pn pi p xi pa xi
conditional probability tables cpts short associated xi pa xi
parents xi
qacyclic graph g belief network represents probability distribution x
p x xn ni p xi xpa xi evidence set e instantiated subset variables
formulated graphical model functions f denote conditional probability tables
scopes functions determined directed acyclic graph g function
q
ranges variable xi parents g combination operator product
primal graph belief network viewed undirected model called moral graph
connects two variables appearing cpt


fim ateescu echter arinescu

season

sprinkler b

watering



c rain

b

f wetness



g slippery

c

f

g

directed acyclic graph

b moral graph

figure belief network
example figure gives example belief network variables figure b
shows moral graph example expresses causal relationship variables season
configuration automatic sprinkler system b amount rain expected
c amount manual watering necessary wetness pavement f
whether pavement slippery g belief network expresses probability distribution p b c f g p p b p c p b p f c b p g f
another example belief network cpts appears figure
two popular tasks belief networks defined
efinition belief updating probable explanation mpe given belief network
evidence e belief updating task compute posterior marginal probability variable
xi conditioned evidence namely
x

bel xi xi p xi xi e

n


p xk e xpak

x xi xi xn e e xi xi k

normalization constant probable explanation mpe task
complete assignment agrees evidence highest probability among
assignments namely assignment xo xon
p xo xon maxx xn

n


p xk e xpak

k

binary decision diagrams review
decision diagrams widely used many areas represent decision processes
particular used represent functions due fundamental importance boolean
functions lot effort dedicated study binary decision diagrams bdds
extensively used software hardware verification clarke et al mcmillan
earliest work bdds due lee introduced binary decision program understood linear representation bdd e g depth first search ordering
nodes node branching instruction indicating address next instruction value test variable akers presented actual graphical


fiand ulti valued ecision iagrams aomdd g raphical odels











b









c









f abc













b

c

c



c



table



b

b





b





b

c





b unordered tree

c





c





c







c ordered tree

figure boolean function representations
representation developed bdd idea however bryant introduced
called ordered binary decision diagram obdd restricted order variables along path diagram presented importantly apply procedure combines two obdds operation time complexity quadratic
sizes input diagrams obdds fundamental applications large binary functions
especially many practical cases provide compact representations
bdd representation boolean function given b boolean function
f bn b n arguments x xn boolean variables takes boolean
values
example figure shows table representation boolean function three variables
explicit representation straightforward costly due exponential
requirements function represented binary tree shown figure b
exponential size number variables internal round nodes represent
variables solid edges high value dotted edges low value
leaf square nodes value function assignment along path tree
shown b unordered variables appear order along path
building obdd first condition variables appear order b c
along every path root leaves figure c shows ordered binary tree function
order imposed two reduction rules transform decision diagram
equivalent one
isomorphism merge nodes label children
redundancy eliminate nodes whose low high edges point node connect
parent removed node directly child removed node
applying two reduction rules exhaustively yields reduced obdd sometimes denoted
robdd use obdd assume completely reduced
example figure shows binary tree figure c isomorphic terminal nodes
leaves merged highlighted nodes labeled c isomorphic figure
b shows merged highlighted nodes labeled c b
redundant removing gives obdd figure c
bucket elimination review
bucket elimination dechter well known variable elimination inference graphical describe terminology constraint networks


fim ateescu echter arinescu





b

b

c

c

c







b

c

b

c

c



isomorphic nodes

b

c





b redundant nodes



c obdd

figure reduction rules



c ac
c ab
c abe

b

c

c bcd

h

b

c ab

e

c abe



h ab

h ab

ab bucket b
ab

abe

c
e



constraint network



c ac

h bc

bucket



bucket e

ab

abc bucket c
bc

bcd bucket

c bcd

b execution

c bucket tree

figure bucket elimination
applied graphical model consider constraint network r hx ci
ordering x x xn ordering dictates elimination order last
first variable associated bucket constraint c placed bucket
latest variable buckets processed xn x eliminating bucket variable
constraints residing bucket joined together bucket variable projected
placing resulting constraint called message bucket latest variable
execution renders network backtrack free solution produced assigning
variables along produce solutions count marginalization done summation
rather projection functional representation constraints join substituted
multiplication
constructs bucket tree linking bucket xi destination bucket
message called parent bucket node bucket tree typically bucket variable
collection constraints scope union scopes constraints nodes
bucket tree replaced respective bucket variables easy see obtain pseudo
tree
example figure shows network four constraints figure b shows execution
bucket elimination along b e c buckets processed figure
c shows bucket tree pseudo tree corresponding order given fig
representation figure reverses top bucket processing described earlier papers dechter



fiand ulti valued ecision iagrams aomdd g raphical odels

procedure generatepseudotree g






input graph g x e order x xn
output pseudo tree
make x root
condition x eliminate x incident edges g let g gp resulting connected
components g
p
ti generatepseudotree gi gi
make root ti child x

return

orderings pseudo trees
given ordering structural information captured primal graph scopes
functions f f fr used create unique pseudo tree corresponds
mateescu dechter precisely bucket tree elimination tree
created variables processed reverse pseudo tree created
conditioning primal graph processing variables order described procedure
generatepseudotree following gi restriction order nodes
graph gi

overview search space graphical
search space recently introduced dechter mateescu b
unifying framework advanced algorithmic schemes graphical main virtue consists exploiting independencies variables search provide exponential
speedups traditional search methods oblivious structure since mdds
search spaces need provide comprehensive overview sake
completeness
search trees
search tree guided pseudo tree primal graph idea exploit
decomposition independent subproblems search assigning value
variable known conditioning equivalent graph terms removing variable
incident edges primal graph partial assignment therefore lead decomposition
residual primal graph independent components searched solved
separately pseudo tree captures precisely decompositions given order variable
instantiation
efinition search tree graphical model given graphical model
hx primal graph g pseudo tree g associated search tree
alternating levels nodes nodes labeled xi correspond
variables nodes labeled hxi xi simply xi correspond value assignments
structure search tree root node labeled
root children node xi nodes labeled assignments hxi xi



fim ateescu echter arinescu





b



b

b


e

e



c




c



e








pseudo tree




c

e
















c

e















c
















b search tree

figure search tree
consistent assignments along path root children node
hxi xi nodes labeled children variable xi pseudo tree
example figure shows example search tree graphical model given
figure assuming tuples consistent variables binary valued tuples
inconsistent paths tree exist figure gives pseudo tree
guides search top bottom indicated arrows dotted arcs backarcs
primal graph figure b shows search tree alternating levels
circle square nodes structure indicated pseudo tree
search tree traversed depth first search thus linear
space already shown freuder quinn bayardo miranker darwiche
dechter mateescu
heorem given graphical model n variables pseudo tree depth
size search tree n k k bounds domains variables
graphical model treewidth w pseudo tree depth w log n therefore

search tree size n k w log n
search tree expresses set possible assignments variables
solutions difference traditional search space solution longer
path root leaf rather tree defined follows
efinition solution tree solution tree search tree contains root node
every node contains one child nodes nodes contains
child nodes leaf nodes consistent
search graph
search tree may contain nodes root identical subproblems nodes said
unifiable unifiable nodes merged search space becomes graph size
becomes smaller expense additional memory search depth first
search therefore modified cache previously computed retrieve
nodes encountered notion unifiable nodes defined formally next



fiand ulti valued ecision iagrams aomdd g raphical odels

efinition minimal graph isomorphism two search graphs g g
isomorphic exists one one mapping vertices g vertices g
vertex v v v v v root identical subgraphs relative
graph called minimal isomorphic subgraphs merged isomorphic nodes
root isomorphic subgraphs said unifiable
shown dechter mateescu
heorem graphical model unique minimal search graph relative
pseudo tree
minimal graph graphical model g relative pseudo tree denoted
mt g note definition minimality used work dechter mateescu
isomorphism reduction extend including elimination
redundant nodes previous theorem shows given graph merge
operator fixed point minimal graph
aomdd canonical representation namely two equivalent graphical
represented unique aomdd given accept pseudo tree
aomdd minimal terms number nodes
unifiable nodes identified contexts define graph
contexts nodes nodes expressing set ancestor variables
completely determine conditioned subproblem however shown caching
contexts makes caching contexts redundant vice versa
use caching value assignment context x separates subproblem x
rest network
efinition context given pseudo tree search space
context x x xp set ancestors x ordered descendingly connected primal graph x descendants x
efinition context unifiable nodes given search graph two nodes n
n context unifiable variable label x assignments
contexts identical namely partial assignment variables along path n
partial assignment variables along path n restriction context
x context x context x
depth first search traverses search tree modified
traverse graph enough memory available could allocate cache table variable x
scope table context x size cache table x therefore product
domains variables context variable x possible assignment
context corresponding conditioned subproblem solved computed
value saved cache table whenever context assignment encountered
value subproblem retrieved cache table traverses
called context minimal graph
efinition context minimal graph context minimal graph obtained search tree merging context unifiable nodes


fim ateescu echter arinescu

r

f

g

b



c


j

k

c

h

c

l

ck



ch

n

ckl

b

cha



ckln

p

cko

h
e
c



l

e

chab

r

hab

j

chae

f

ar



cej

g

af



cd

k

n
p


primal graph

b pseudo tree
c





k

h

k









l

l

l

l

h

















































n

n

n

n

n

n

n

n

b

b

b

b

b

b

b

b



































































e





e

e

e





e

e

e





e

e

e

e





e

e

e

e



e







r

r

r





r

r

r

r



r



p

p

p

p

p

p

p





p
j

j

j

j

j

j

j

j

j

j

j

j

j

j

j

j




















f

f

f

f







g

g

g

g












c context minimal graph

figure search graph
already shown bayardo miranker dechter mateescu
heorem given graphical model primal graph g pseudo tree size
context minimal search graph therefore size minimal

search graph n k wt g wt g induced width g depth first traversal
k bounds domain size

example lets look impact caching size search space examining larger
example figure shows graphical model binary variables figure b pseudo tree
drives search context node given square brackets context
minimal graph given figure c note far smaller search tree
nodes level alone depth pseudo tree
shaded rectangles size cache table equal number nodes
appear one cache entry useful whenever one incoming edges
node incidentally caches useful namely nodes one incoming
arc called dead caches darwiche determined pseudo


fiand ulti valued ecision iagrams aomdd g raphical odels

tree inspection therefore cache table need allocated context minimal graph
explain execution along pseudo tree equivalently along depth
first traversal order buckets shaded rectangles processing done bottom
number possible assignments bucket equals number nodes appear
message scope identical context bucket variable message
identical corresponding cache table details relationship
search see work mateescu dechter
weighted graphs
previous subsections described structure trees graphs order
use solve reasoning task need define way input function values
traversal graph realized placing weights costs
arcs dictated function values functions relevant contribute
arc weight captured buckets relative pseudo tree
efinition buckets relative pseudo tree given graphical model hx f
pseudo tree bucket xi relative denoted bt xi set functions whose
scopes contain xi included patht xi set variables root xi
namely
bt xi f f xi scope f scope f patht xi

function belongs bucket variable xi iff scope fully instantiated
xi assigned combining values functions bucket current assignment gives weight arc
efinition weights given graph graphical model
weight w n xi xi arc n xi labels n xi labels combination
functions bt xi assigned values along current path node
formally w n xi xi f bt xi f asgn scope f
efinition weight solution tree given weighted graph graphical model
given solution tree set arcs arcs weight defined
w earcs w e
example start straightforward case constraint networks since functions
take values combination product join relations follows orto arc weight example given figure figure shows
constraint graph b pseudo tree c four relations define constraint
figure shows tree traversed depth first search
checks consistency input functions e constraint propagation used
similar obdd representation arcs weight denoted dotted
lines tree unfolded since contain solution arcs
weight drawn solid lines


fim ateescu echter arinescu


b
c





f

b

e

constraint graph










b









b









c rabc

















c









c

e



f

b pseudo tree

rbcd



























b









e rabe



























e









f raef

















c relations










b

b









c

c

e





c

e

c

e

e







































































f
























f



f

























f

f

































tree

figure search tree constraint networks
example figure shows weighted tree belief network figure shows
directed acyclic graph dotted arc bc added moralization figure b shows pseudo
tree c shows conditional probability tables figure shows weighted
tree
constraint networks move weighted search trees
weighted search graphs merging unifiable nodes case arc labels
considered determining unifiable subgraphs yield context minimal weighted
search graphs minimal weighted search graphs

multi valued decision diagrams aomdds
section begin describing contributions context minimal
graph definition offers effective way identifying unifiable nodes execution search namely context unifiable nodes discovered
paths root without actually solving corresponding subproblems however merging context complete means may still exist unifiable nodes
search graph identical contexts moreover nodes context


fiand ulti valued ecision iagrams aomdd g raphical odels

p









p b

p







p c




b



b



p b c

b
b

b





c

e
e

c




belief network

c





p e b












c



c



b pseudo tree







b





e





e





c cpts











b

b






c




e
















































c



e






















e

c









e


















c







































weighted tree

figure weighted search tree belief networks
minimal graph may redundant example set solutions rooted variable xi dependant specific value assigned xi situation detectable
context sometimes termed interchangeable values symmetrical values
overviewed earlier dechter mateescu defined complete minimal
graph graph whose unifiable nodes merged dechter mateescu
proved canonicity non weighted graphical
propose augment minimal search graph removing redundant variables common obdd representation well adopt notational conventions
common community yields data structure call bdd exploits
decomposition nodes present extension multi valued variables yielding
mdd aomdd define general weighted graphical subsequently
present two compiling canonical aomdd graphical model first
search uses memory intensive graph search generate context minimal
graph reduces bottom applying reduction rules second inferencebased uses bucket elimination schedule combine aomdds initial functions
apply operations similar apply obdds approaches
worst case complexity graph search context caching
complexity bucket elimination namely time space exponential treewidth

n k w benefit generation schemes discussed



fim ateescu echter arinescu







obdd





k

b mdd

figure decision diagram nodes












aobdd



k







b aomdd

figure decision diagram nodes
search graphs decision diagrams
search graph g graphical model hx f represents set
possible assignments variables solutions costs sense g
viewed representing function f f defines universal equivalent graphical
model u definition full assignment x x xn x solution expressed
tree tx f x w tx earcs tx w e definition otherwise f x
assignment inconsistent solution tree tx consistent assignment x read g
linear time following assignments root x inconsistent dead end
encountered g attempting read solution tree tx f x therefore g
viewed decision diagram determines values f every complete assignment x
see process search graph reduction rules similar
case obdds order obtain representation minimal size case obdds
node labeled variable name example low dotted line high solid
line outgoing arcs capture restriction function assignments
determine value function one needs follow one
outgoing arcs see figure straightforward extension obdds multi valued
variables multi valued decision diagrams mdds presented srinivasan kam malik
brayton node structure use given figure b outgoing arc
associated one k values variable
generalize obdd mdd representations demonstrated figures
b allowing outgoing arc arc arc connects node set
nodes captures decomposition independent components number
arcs emanating node two case aobdds figure domain size
variable general case figure b given node k arcs
connect possibly different number nodes depending decomposes
particular assignment arcs depicted shaded sector connects
outgoing lines corresponding independent components



fiand ulti valued ecision iagrams aomdd g raphical odels










k





nonterminal meta node





b terminal meta node

c terminal meta node

figure meta nodes
define decision diagram representation search graphs
useful maintain semantics figure especially need express
redundancy nodes therefore introduce meta node data structure defines small
portions graph node children
efinition meta node meta node u search graph
terminal node labeled nonterminal node consists node labeled
x therefore var u x k children labeled x xk correspond value
assignments x node labeled xi stores list pointers child meta nodes denoted
u childreni case weighted graphical node xi stores toand arc weight w x xi
rectangle figure meta node variable domain size k note
similar figure small difference information value
corresponds outgoing arc stored nodes meta node
showing weights figure larger example graph meta nodes
appears later figure
terminal meta nodes play role terminal nodes obdds terminal metanode shown figure b indicates inconsistent assignments terminal meta node
shown figure c indicates consistent ones
search graph viewed diagram meta nodes simply grouping
nodes children adding terminal meta nodes appropriately
defined meta nodes easier see variable redundant respect outcome function current partial assignment variable redundant
assignments leads set solutions
efinition redundant meta node given weighted search graph g represented
meta nodes meta node u var u x x k redundant iff
u children u childrenk
b w x x w x xk
graph g contains redundant meta node u transformed equivalent graph g replacing incoming arc u common list children u children
absorbing common weight w x x combination weight parent meta node
corresponding incoming arc removing u outgoing arcs g
value x x picked arbitrarily isomorphic u root


fim ateescu echter arinescu

procedure redundancyreduction
graph g redundant meta node u var u x list meta node parents u
denoted p arents u
output reduced graph g elimination u
p arents u empty

return independent graphs rooted meta nodes u children constant w x x
input

forall v p arents u assume var v

forall

u v childreni

v childreni v childreni u

v childreni v childreni u children

w yi w yi w x x
remove u
return reduced graph g

procedure isomorphismreduction
graph g isomorphic meta nodes u v list meta node parents u denoted
p arents u
output reduced graph g merging u v
forall p p arents u
u p childreni
p childreni p childreni u
p childreni p childreni v

input






remove u
return reduced graph g

graph common weight w x x stored separately constant procedure
redundancyreduction formalizes redundancy elimination
efinition isomorphic meta nodes given weighted search graph g represented
meta nodes two meta nodes u v var u var v x x k
isomorphic iff
u childreni v childreni k
b wu x xi wv x xi k wu wv weights u v
procedure isomorphismreduction formalizes process merging isomorphic metanodes naturally graph obtained merging isomorphic meta nodes equivalent
original one define multi valued decision diagram
efinition aomdd multi valued decision diagram aomdd weighted
search graph completely reduced isomorphic merging redundancy removal
namely
contains isomorphic meta nodes
contains redundant meta nodes



fiand ulti valued ecision iagrams aomdd g raphical odels





k



b

c







k

z






z

k





c







b eliminating b
meta node

fragment aomdd

figure redundancy reduction





k





k

b


c









c




b

k



e





k

c


k




k







fragment aomdd



k

e





b merging isomorphic c meta nodes

figure isomorphism reduction
example figure shows example applying redundancy reduction rule portion
aomdd left side figure meta node variable b redundant
dont weights arcs avoid cluttering figure values
k b lead set meta nodes c coupled
arc therefore meta node b eliminated shown figure b
meta nodes c z coupled arc outgoing
figure example applying isomorphism reduction rule case
meta nodes labeled c figure isomorphic omit weights
merging shown figure b
examples aomdds appear figures note weight toand arc zero descendant terminal meta node namely current path
dead end cannot extended solution therefore linked directly

search generate aomdds
section described transform graph aomdd applying
reduction rules section describe explicit takes input graphi

fim ateescu echter arinescu

cal model performs search context caching obtain context minimal
graph section give procedure applies reduction rules bottom
obtain aomdd
earch aomdd
called earch aomdd compiles graphical model aomdd
memory intensive context caching search used create context minimal graph see definition input earch aomdd graphical
model pseudo tree defines context variable
variable xi associated cache table whose scope context xi
ensures trace search context minimal graph list denoted lxi
see line used variable xi save pointers meta nodes labeled xi
lists used procedure performs bottom reduction per layers
graph one layer contains nodes labeled one given variable fringe search
maintained stack called open current node node denoted
n parent p current path n children current node denoted
successors n node n boolean attribute consistent n indicates current path
extended solution information useful pruning search space
two mutually recursive steps forward beginning line
backtrack beginning line call search terminates
forward phase graph expanded top two types nodes
treated differently according semantics
node expanded cache table variable checked line entry
null link created already existing node roots graph equivalent
current subproblem otherwise node expanded generating descendants
weight see definition computed line value xi xi checked
consistency line least expensive check verify weight non zero
however deterministic inconsistent assignments extracted form constraint
network level constraint propagation performed step e g look ahead arc
consistency path consistency consistency etc computational overhead increase
hope pruning search space aggressively note constraint propagation
crucial complexity guarantees maintained even simple
weight check performed consistent nodes added list successors n line
inconsistent ones linked terminal meta node line
node n labeled hxi xi expanded line structure pseudo
tree xi leaf n linked terminal meta node line otherwise
node created child xi line
forward step continues long current node dead end still unevaluated
successors backtrack phase triggered node empty set successors line
note successor processed removed set successors line
backtrack reaches root line search complete context minimal graph
generated procedure b ottom u p r eduction called
backtrack step processes node line saves pointer cache
adds pointer corresponding meta node list lxi consistent attribute



fiand ulti valued ecision iagrams aomdd g raphical odels

earch aomdd
input hx pseudo tree rooted x parents pai context every variable xi
output aomdd
forall xi x
initialize context cache table cachexi pai null entries

create node labeled xi consistent true push top open
open

n top open remove n open
forward

successors n

n node labeled xi
expand
cachexi asgn n pai null

connect parent n cachexi asgn n pai

use cached pointer











else
forall xi di
create node labeled hxi xi
w x xi

f asgn n pai
f bt xi

hxi xi consistent n
consistent true
add successors n
else
consistent f alse
make terminal child










n node labeled hxi xi
childrent xi
make terminal child n
else
forall childrent xi
create node labeled
consistent f alse
add successors n








add successors n top open
successors n
let p parent n
n node labeled xi
xi x
call bottomupreduction procedure








constraint propagation

expand

backtrack

search complete
begin reduction aomdd

cache asgn n pai n
add meta node n list lxi
consistent p consistent p consistent n
consistent p f alse
remove successors p open
successors p




n node labeled hxi xi
consistent p consistent p consistent n




remove n successors p
np



save cache

check p dead end

fim ateescu echter arinescu

procedure bottomupreduction
graphical model hx pseudo tree primal graph rooted x context
minimal graph lists lxi meta nodes level xi
output aomdd
let x xn depth first traversal ordering
n
let h hash table initially empty
forall meta nodes n lxi
h xi n children n childrenki wn xi x wn xki xki returns meta node
p
merge n p graph
input














else n redundant
eliminate n graph
combine weight parent
else
hash n table h
h xi n children n childrenki wn xi x wn xki xki n

return reduced graph

parent p updated conjunction consistent n parent p becomes
inconsistent necessary check remaining successors line backtrack
step processes node line consistent attribute parent p updated
disjunction consistent n
search usually maintains value node corresponding task
solved include values description aomdd equivalent
representation original graphical model task solved traversal
aomdd however user include information meta nodes e g
number solutions subproblem
reducing context minimal graph aomdd
procedure bottomupreduction processes variables bottom relative pseudo tree
use depth first traversal ordering line bottom ordering good
outer loop starting line goes level context minimal graph
level contains nodes labeled variable words
contains meta nodes variable efficiency ensure complexity guarantees
prove hash table initially empty used level inner loop starting
line goes metanodes level saved pointers saved
list lxi meta node n list lxi line hash table h checked
verify node isomorphic n already exists hash table h already contains node p corresponding hash key xi n children n childrenki wn xi x wn xki xki
p n isomorphic merged otherwise meta node n redundant
eliminated graph none previous two conditions met
meta node n hashed table h



fiand ulti valued ecision iagrams aomdd g raphical odels




g

c

b

f

e



h

b
c




f
e

g

h

b

figure constraint graph c c c c f h c h
c b g c f g c b f c e c c e c c
c b c b pseudo tree bucket tree ordering b c e f g h

proposition output procedure bottomupreduction aomdd along
pseudo tree namely resulting graph completely reduced
note explicated procedure bottomupreduction separately clarity practice actually included earch aomdd reduction rules
applied whenever search backtracks maintain hash table variable search store pointers meta nodes search backtracks
node already check redundancy meta node look hash table
check isomorphism therefore reduction graph done
search output aomdd
theorem proposition conclude
heorem given graphical model pseudo tree primal graph g aomdd

corresponding size bounded n k wt g computed

earch aomdd time n k wt g wt g induced width g
depth first traversal k bounds domain size

bucket elimination generate aomdds
section propose use bucket elimination type guide compilation
graphical model aomdd idea express graphical model functions
aomdds combine apply operations schedule apply
similar obdds bryant adapted search graphs
takes input two functions represented aomdds pseudo tree outputs
combination initial functions represented aomdd pseudo tree
describe detail section
start example constraint networks easier understand
weights arcs therefore depicted figures solid dashed
lines respectively
example consider network defined x b h da dh
constraints denotes xor c f h c ah c abg c f g


fim ateescu echter arinescu















b






c


c












c








b

b





f

c


b






f






f


b

f









b

c





g

e
















g




h










e





f

h


g










b

c



c

















c

c






f

b















g













h




b

f


g




f

f



f






b


b


e






b





h



h




f


c











c

c



e



c










e





c












g









c





c

c

















b

h










h



g

e

c









g


g

f

f


b

g

h







b



c









e

e





c






















c



h




f



f





g

c

c

h

figure execution aomdds







b


b




b



b

c
c


c




c




c




f




f




f




c











e









e




g




g




h




c

c

f







e

f

h




e

f

f

f



g

g

g

g

h







h





g



b

figure final aomdd b obdd corresponding
c b f c e c c e c c c b c constraint graph
shown figure consider ordering b c e f g h pseudo tree
bucket tree induced given fig b figure shows execution aomdds
along ordering initially constraints c c represented aomdds placed
bucket latest variable scope original constraint appears



fiand ulti valued ecision iagrams aomdd g raphical odels

aomdd
graphical model hx x x xn f f fr order
x xn
output aomdd representing
generatepseudotree g
r
place functions buckets

place gfaomdd


bucket


latest
variable



input

n
message xi g aomdd


bucket xi

pick gfaomdd bucket xi




process buckets
initialize aomdd
combine aomdds bucket xi

bucket xi bucket xi gfaomdd
message xi apply message xi gfaomdd
add message xi bucket parent xi

return message x

path root leaf pseudo tree therefore original constraint represented
aomdd chain e branching independent components point
chain scope constraint ordered according bi valued variables
original constraints represented obdds multiple valued variables mdds note
depict meta nodes one node two children appear inside gray
node dotted edge corresponds value low edge obdds solid edge
value high edge redundancy notation keeping value nodes
arc types dotted arcs solid arcs
scheduling used process buckets reverse order bucket processed
joining aomdds inside apply operator however step elimination
bucket variable omitted want generate full aomdd example
messages c c c c still chains therefore
obdds note contain variables h g eliminated however
message c obdd anymore see follows
structure pseudo tree f two children g h nodes corresponding
f two outgoing edges value
processing continues manner final output coincides
shown figure obdd ordering shown fig
b notice aomdd nonterminal nodes edges obdd
nonterminal nodes edges
aomdd
called aomdd creates aomdd graphical model schedule apply operations given order variables first pseudo tree created

primal graph initial function represented aomdd denoted gfaomdd

placed bucket obtain aomdd function scope function ordered
according search tree chain represents generated reduced
procedure bottomupreduction proceeds exactly difference combination functions realized apply variables


fim ateescu echter arinescu

eliminated carried destination bucket messages buckets initialized
dummy aomdd denoted g aomdd neutral combination
order create compilation graphical model graphs necessary
traverse graph top bottom similar inward outward
message passing tree decomposition note aomdd describes bottom traversal
explicitly top phase actually performed apply operation two
aomdds combined top chain portion pseudo tree processed remaining
independent branches attached participate newly restricted set solutions
amounts exchange information independent branches equivalent
top phase
aomdd apply operation
describe combine two aomdds apply operator takes input two
aomdds representing functions f f returns aomdd representing f f
obdds apply operator combines two input diagrams variable ordering
likewise order combine two aomdds assume pseudo trees identical
condition satisfied two aomdds bucket aomdd however
present version apply general relaxing previous condition
identical compatible pseudo trees namely pseudo tree
embedded general pseudo tree induces strict partial order variables
parent node precedes child nodes
efinition compatible pseudo trees strict partial order x set x
consistent strict partial order set x x x
x x x x two partial orders compatible iff exists partial
order consistent two pseudo trees compatible iff partial orders induced
via parent child relationship compatible
simplicity focus restricted notion compatibility sufficient
schedule apply operator combine input aomdds described
section apply present extended general notion
compatibility
efinition strictly compatible pseudo trees pseudo tree set nodes x
embedded pseudo tree set nodes x x x obtained
deleting node x x connecting parent descendents two
pseudo trees strictly compatible exists
embedded
apply takes input one node gfaomdd list nodes
ggaomdd initially node gfaomdd root node list nodes ggaomdd fact
made one node root sometimes identify aomdd root
node pseudo trees tf tg strictly compatible target pseudo tree
list nodes ggaomdd special property node
ancestor another refer variable meta node therefore list z zm


fiand ulti valued ecision iagrams aomdd g raphical odels

apply v z zm
input aomdds gfaomdd nodes vi ggaomdd nodes zj strictly compatible pseudo
trees tf tg embedded
var v ancestor var z var zm
var zi var zj ancestor descendant relation j
output v z zm
h v z zm null return h v z zm
cache
v z zm return
v return
return v
nothing combine
create nonterminal meta node u
var u var v call xi domain di x xki
j ki
u childrenj
children j th node u
assign weight v
wu xi xj wv xi xj
var v var z xi
temp children z childrenj
combine input weights
wu xi xj wv xi xj wz xi xj


















else







group nodes v childrenj temp children several v z z r
v z z r
apply v z z r

u childrenj break




temp children z zm

else
u childrenj u childrenj





u children u childrenki wu xi x wu xi xki
promote wu xi x parent
return u children
redundancy




h xi u children u childrenki wu xi x wu xki xki null
return h xi u children u childrenki wu xi x wu xki xki
isomorphism

let h v z zm u
let h xi u children u childrenki w u xi x w u xki xki u
return u

add u h
add u h

g expresses decomposition respect nodes appear different branches
employ usual techniques obdds make operation efficient first one
arguments safely return second hash table h used store nodes
already processed nodes v z zr therefore never need
make multiple recursive calls arguments third hash table h used detect
isomorphic nodes typically split separate tables variable end
recursion returning value discover meta node variable
children weights already created dont need store simply
return existing node fourth end recursion discover created
redundant node children weights dont store
return instead one identical lists children promote common weight


fim ateescu echter arinescu











b









c









f abc




















b
c








c









b



b



b

b












c










b
b



b





b






g abc


























b


b



b











b



b

b

b





c


b



b











b




b






b








figure example apply operation
note v ancestor z zm consider variable
ancestor self explaining checks performed lines line specific
multiplication needs changed combination operations creates
meta node u whose variable var v xi recall var v highest closest root
among v z zm possible value xi line starts building list
children
one important steps happens line two lists meta nodes one
original aomdd f g refer variables appear
lists important property mentioned nodes ancestors
union two lists grouped maximal sets nodes highest node
set ancestor others follows root node set belongs one
original aomdd say v f others say z z r g example
suppose pseudo tree fig b two lists c g h f e f
g grouping line create c e f g h sometimes may
case newly created group contains one node means nothing join
recursive calls return via line single node one
input aomdds traversed important complexity apply discussed

example figure shows combining two boolean functions operation
product input functions f g represented aomdds chain pseudo
trees pseudo tree expresses decomposition variables
b instantiated apply operator performs depth first traversal two input
aomdds generates resulting aomdd output pseudo tree similar
case obdds function aomdd identified root meta node example
input meta nodes labels b b etc output meta node labeled b


fiand ulti valued ecision iagrams aomdd g raphical odels

root diagram represents function obtained combining functions rooted
b
complexity apply aomdd
provide characterization complexity apply different criteria
following propositions inspired govern obdd apply complexity
adapted pseudo tree orderings
aomdd along pseudo tree regarded union regular mdds restricted
full path root leaf pseudo tree let path
definition strictly compatible pseudo trees corresponding paths tf tf tg tg
mdds f g corresponding tf tg combined regular mdd
apply process repeated every path resulting mdds one path
need synchronized common parts intersection paths
proposed processing depth first search traversal inputs
construction give first characterization complexity aomdd apply
governed complexity mdd apply
proposition let l set paths enumerated left right let gfi
ggi mdds restricted path size output aomdd apply

p
p bounded
g n max g g time complexity bounded
g
g
g

g
g
g
f
f
f
n maxi gfi ggi
second characterization complexity given similar mdd case terms
total number nodes inputs
proposition given two aomdds gfaomdd ggaomdd strictly compatible pseudo trees
size output apply gfaomdd ggaomdd
detail previous proposition follows given aomdds gfaomdd ggaomdd
compatible pseudo trees tf tg common pseudo tree define intersection pseudo tree tf g obtained following two steps mark
subtrees whose nodes belong tf tg leaves subtree
leaves remove subtrees marked step steps applied
recursively part aomdd gfaomdd corresponding variables tf g
denoted gff g similarly ggaomdd denoted ggf g
proposition time complexity
gfaomdd ggaomdd

apply

size output gff g ggf g

turn complexity aomdd bucket associated
bucket pseudo tree top chain bucket pseudo tree variable xi contains
variables context xi variables appear bucket pseudo tree
associated buckets already processed original functions belong bucket
xi scope included context xi therefore associated aomdds


fim ateescu echter arinescu

chains functions appear bucket xi messages received independent branches therefore two functions bucket xi share variables
context xi forms top chain bucket pseudo tree therefore characterize
complexity apply terms treewidth context size bucket variable
proposition given two aomdds bucket aomdd time space complexity apply exponential context size bucket variable
namely number variables top chain bucket pseudo tree
bound complexity aomdd output size
heorem space complexity aomdd size output aomdd

n k w n number variables k maximum domain size w treewidth

bucket tree time complexity bounded r k w r number initial
functions

aomdds canonical representations
well known obdds canonical representations boolean functions given ordering
variables bryant namely strict ordering cnf specification
boolean function yield identical obdd property extends mdds srinivasan
et al linear ordering variables defines chain pseudo tree captures
structure obdd mdd case aobdds aomdds canonicity
respect pseudo tree transitioning total orders correspond linear ordering
partial orders correspond pseudo tree ordering one hand gain ability
compact compiled structure hand canonicity longer respect
equivalent graphical relative graphical consistent
pseudo tree used specifically start strict ordering generate chain
aomdd canonical relative equivalent graphical however want
exploit additional decomposition use partial ordering captured pseudo tree create
compact aomdd aomdd however canonical relative equivalent graphical
accept pseudo tree guided aomdd general aomdd
viewed flexible framework compilation allows partial total orderings
canonicity restricted subset graphical whose primal graph agrees partial
order relevant larger set orderings consistent pseudo tree
following subsection discuss canonicity aomdd constraint networks
case general weighted graphical discussed section
aomdds constraint networks canonical representations
case constraint networks straightforward weights
arcs equivalent constraint networks admit
pseudo tree aomdd start proposition help prove
main theorem
proposition let f function zero defined constraint network x given
partition x xm set variables x namely xi xj j x


fiand ulti valued ecision iagrams aomdd g raphical odels




x f f fm f g gm scope scope gi x
gi namely f decomposed
given partition decomposition unique

ready aomdds constraint networks canonical representations
given pseudo tree
heorem aomdds canonical given pseudo tree given constraint network
pseudo tree constraint graph unique isomorphism aomdd represents minimal number meta nodes
constraint network defined relations functions exist equivalent constraint
networks defined different sets functions even different scope signatures
however equivalent constraint networks define function ask aomdd
different equivalent constraint networks following corollary derived
immediately theorem
corollary two equivalent constraint networks admit pseudo tree
aomdd

canonical aomdds weighted graphical
theorem ensures aomdd canonical constraint networks namely functions
take values proof relied fact weights
proposition ensured unique decomposition function defined
constraint network
section turn general weighted graphical first observe proposition longer valid general functions valid solutions strictly
positive weight weight decomposed one way product positive
weights
therefore raise issue recognizing nodes root graphs represent
universal function even though graphical representation different see
aomdd weighted graphical model unique current definitions
slightly modify obtain canonicity note canonicity aomdds
weighted graphical e g belief networks far less crucial case obdds
used formal verification even sometimes may useful eliminate
redundant nodes order maintain simpler semantics graph represents
model
loss canonicity aomdd weighted graphical happen
weights arcs suggest possible way enforcing compact
canonical representation needed
example figure shows weighted graphical model defined two cost functions
f b g b c assuming order b c figure shows search
tree left arcs labeled function values leaves value
corresponding full assignment product numbers arcs path


fim ateescu echter arinescu


















b
b
c

c











b f b



























b









c g b c

















figure weighted graphical model





















b



b















c

c












c




















b







c





b







c

b







c

c







































b



















c















b




c





b



c



















c

c























figure search tree context minimal graph

see value gives rise function leaves two
subtrees values however two subtrees identified representing
function usual reduction rules right part figure shows context minimal
graph compact representation subtree share parts
would case method recognizing left right subtrees
corresponding represent function normalizing
values level processing bottom figure left values
arcs normalized variable normalization constant promoted
value figure right normalization constants promoted upwards
multiplication process change value full assignment therefore
produces equivalent graphs
see already nodes labeled c merged producing graph
figure left continuing process obtain aomdd weighted graph
shown figure right
define aomdd weighted graphical model follows
efinition aomdd weighted graphical model aomdd weighted graphical
model graph meta nodes meta node weights sum
root meta node constant associated completely reduced namely
isomorphic meta nodes redundant meta nodes



fiand ulti valued ecision iagrams aomdd g raphical odels
















b



b

b















































































b











c





b



c





b



c




b



c






b




c

c











c



c


















figure normalizing values bottom

























b






b











b







b









c















b



b











c













c









c










figure aomdd weighted graph
procedure transforming weighted graph aomdd similar
procedure b ottom u p r eduction section difference layer
processed first meta node weights normalized promoted parent
procedure continues usual reduction rules
heorem given two equivalent weighted graphical accept common pseudo tree
normalizing arc values together exhaustive application reduction rules yields
graph aomdd
finite precision arithmetic implementation described section may
prove challenging machines used finite precision arithmetic since weights
real valued repeated normalization may lead precision errors one possible
used experiments define tolerance user defined sufficiently
small consider weights equal within

semantic treewidth
graphical model represents universal function f function f may represented
different graphical given particular pseudo tree captures structural
information f interested graphical accept pseudo tree namely
primal graphs contain edges backarcs since size aomdd f
bounded worst case induced width graphical model along
define semantic treewidth


fim ateescu echter arinescu








b
c

c


b
















c








b





b










two solutions

c






















b c







b









c







b first model



b



b

c

b c





c



c second model

figure queen
efinition semantic treewidth semantic treewidth graphical model relative
pseudo tree denoted swt smallest treewidth taken r
equivalent accept pseudo tree formally defined swt
minr u r u wt r u universal function wt r induced
width r along semantic treewidth graphical model minimal semantic
treewidth pseudo trees express universal function
computing semantic treewidth shown np hard
heorem computing semantic treewidth graphical model np hard
theorem shows computing semantic treewidth hard likely actual
complexity even higher however semantic treewidth explain sometimes minimal
graph obdd much smaller exponential treewidth pathwidth upper
bounds many cases could huge disparity treewidth semantic
treewidth along
example figure shows two solutions queen expressed complete graph treewidth given figure b figure c shows equivalent
e set solutions treewidth semantic treewidth
queen
fact aomdd canonical representation universal function
graphical model conclude size aomdd bounded exponentially
semantic treewidth along pseudo tree rather treewidth given graphical model
representation
proposition size aomdd graphical model bounded n k swt
n number variables k maximum domain size swt semantic
treewidth along pseudo tree
thank david eppstein proof



fiand ulti valued ecision iagrams aomdd g raphical odels




b

b

c

c

b







c

n



p





obdd representation

b primal graph hidden
variables n p

figure parity function
example consider constraint network n variables every two variables constrained equality x one graph representation complete graph another chain
another tree specified complete graph use linear order
obdd linear size exists representation pathwidth
rather n
semantic treewidth yield much better upper bound aomdd
bad bound well known parity function n variables compact
chain obdd representation yet constraint network representation parity function
function namely complete graph variables whose treewidth semantic
treewidth number variables n obdd representation parity function suggests
addition hidden variables simplify presentation example figure
left side figure obdd representation parity function
four binary variables graphical model would represent function complete graph
four variables however could add extra variables n p figure b sometimes
called hidden variables help decompose model case form constraint
together b represents parity b namely b
parity xor operator similarly n would capture parity c p
would capture parity n would give parity initial four variables
two structures surprisingly similar would interesting study connection
hidden variables compact aobdds leave future work

experimental evaluation
experimental evaluation preliminary stages already encouraging ran search compile recording trace search
reducing resulting graph bottom applied reduction isomorphism still kept redundant meta nodes implemented
c ran experiments ghz intel core duo gb ram running windows



fim ateescu echter arinescu

benchmarks
tested performance search compilation random bayesian networks instances bayesian network repository subset networks uai
inference evaluation dataset
random bayesian networks random bayesian networks generated parameters
n k c p n number variables k domain size c number conditional
probability tables cpts p number parents cpt structure network
created randomly picking c variables n randomly picking p parents
preceding variables relative ordering remaining n c variables called root
nodes entries probability table generated randomly uniform distribution
table normalized possible control amount determinism
network forcing percentage det cpts entries
bayesian network repository bayesian network repository contains collection belief
networks extracted real life domains often used benchmarking probabilistic inference
uai inference evaluation dataset uai inference evaluation dataset contains
collection random well real world belief networks used first uai
inference evaluation contest purpose selected subset networks derived
iscas digital circuits benchmark iscas circuits common benchmark used
formal verification diagnosis circuits converted bayesian network
removing flip flops buffers standard way creating deterministic conditional probability
table gate putting uniform distributions input signals

consider two search compilation denoted aomdd bcp aomddsat respectively reduce context minimal graph explored via isomorphism
exploiting determinism present network take handling
determinism unit resolution cnf encoding e propositional clauses zero
probability tuples cpts idea unit resolution search bayesian networks first explored allen darwiche aomdd bcp conservative applies
unit resolution node search graph whereas aomdd sat aggressive
detects inconsistency running full sat solver used zchaff sat solver moskewicz
madigan zhao zhang malik unit resolution well full satisfiability
comparison ran version aomdd bcp called mdd bcp
reference report obtained ace compiler ace compiles bayesian
network arithmetic circuit ac uses ac answer multiple queries respect network arithmetic circuit representation equivalent graphs
mateescu dechter time ace compiler invoked uses one two
basis compilation first elimination order generated network





http www cs huji ac il compbio repository
http ssli ee washington edu bilmes uai inferenceevaluation
available http www fm vslib cz kes asic iscas
available http reasoning cs ucla edu ace



fiand ulti valued ecision iagrams aomdd g raphical odels

network

w h

n k

ace
nodes time

mdd w bcp
aomdd w bcp
aomdd w sat
meta cm time
meta cm
time meta cm
time
bayesian network repository
alarm








cpcs





cpcs



cpcs b
diabetes

hailfinder






mildew


mm




munin

munin

munin

pathfinder


pigs


water




uai evaluation dataset
bn



bn



bn



bn



bn





bn







bn








bn







bn







bn










bn








bn



bn







bn






bn




bn






positive random bayesian networks n k p c
r





r





r





r







r





r





r





r





r







r







deterministic random bayesian networks n k p c det cpts containing entries
r



r


r

r


r

r

r

r



r


r



table experiments bayesian networks classes w
treewidth h depth pseudo tree n number variables k domain size time
given seconds bold types highlight best across rows



fim ateescu echter arinescu

sufficiently small induced width tabular variable elimination used basis
similar one discussed chavira darwiche uses tables represent factors rather adds induced width large logical model counting
used basis tabular variable elimination typically efficient width small cannot
handle networks width larger logical model counting hand incurs
overhead tabular variable elimination handle many networks larger treewidth
tabular variable elimination logical model counting produce acs exploit local structure leading efficient online inference logical model counting invoked proceeds
encoding bayesian network cnf chavira darwiche chavira darwiche
jaeger simplifying cnf compiling cnf dnnf extracting ac
compiled dnnf dtree cnf clauses drives compilation step
experiments report compilation time seconds time number
nodes context minimal graph explored cm number meta nodes resulting
aomdd meta well size ac compiled ace nodes network
specify number variables n domain size k induced width w pseudo tree depth h
stands exceeding gb memory limit respective best performance
points highlighted
evaluation bayesian networks
table reports obtained experiments bayesian networks aomdd
compilers well ace used min fill heuristic kjaerulff construct guiding
pseudo tree dtree respectively
bayesian n etworks r epository
see ace overall fastest compiler domain outperforming aomdd bcp
aomdd sat several orders magnitude e g mildew pigs however
diagrams compiled ace aomdd bcp resp aomdd sat comparable size
cases aomdd bcp aomdd sat able compile much smaller diagrams
ace example diagram produced aomdd bcp mildew network times
smaller one compiled ace principle output produced ace aomdd
similar guided pseudo tree dtree scheme viewed
compilation alternative extends decision diagrams mimics traces search
properties may make representation accessible compiler mdd bcp able
compile test instances sizes far larger produced
aomdd bcp instance pathfinder network aomdd bcp outputs decision
diagram almost orders magnitude smaller mdd bcp
uai dataset
uai dataset instances picked randomly variables instantiated
evidence see ace best performing compiler dataset aomdd bcp
competitive ace terms compile time test instances aomdd sat
able compile smallest diagrams networks e g bn bn bn bn
bn bn difference size compiled data structures produces
mdd bcp aomdd bcp orders magnitude favor latter


fiand ulti valued ecision iagrams aomdd g raphical odels

r andom n etworks
instances denoted r r generated class random
belief networks parameters n k p c similarly instances denoted
r r belong class parameters n k p c
latter case det cpts deterministic namely contain
probability tuples test instances compiled without evidence see
domain aomdd bcp aomdd sat able compile smallest diagrams
average times smaller produced ace however ace fastest
compiler notice compiler mdd bcp ran memory test cases
impact variable ordering
theory dictates aomdd size influenced quality guiding pseudo tree
addition min fill heuristic considered hypergraph heuristic constructs
pseudo tree recursively decomposing dual hypergraph associated graphical model
idea explored darwiche constructing dtrees guide ace
since min fill hypergraph partitioning heuristics randomized namely ties
broken randomly size aomdd guided resulting pseudo tree may vary significantly one run next figure displays aomdd size hypergraph min fill
pseudo trees networks selected table independent runs record
average induced width depth obtained pseudo trees see header plot
figure see two heuristics dominate namely variance output
size quite significant cases
memory usage
table shows memory usage mbytes ace aomdd bcp aomdd sat respectively bayesian networks table see cases aomdd compilers require far less memory ace example mildew network aomddbcp aomdd sat use mb memory compile decision diagram
ace requires much mb memory moreover compiled aomdd
case one order magnitude fewer nodes constructed ace comparing
two search compilers observe networks significant amount
determinism uai evaluation dataset aomdd sat uses average two
times less memory aomdd bcp dramatic savings memory usage due aggressive constraint propagation employed aomdd sat compared aomdd bcp
seen bn network case difference memory usage aomdd sat
aomdd bcp orders magnitude favor former

related work
related work viewed along two directions work related search
idea graphical work related compilation graphical exploits
structure
extensive discussion provided previous work dechter mateescu
since focus mention idea origi

fim ateescu echter arinescu

figure effect variable ordering



fiand ulti valued ecision iagrams aomdd g raphical odels

network

ace
aomdd w bcp
aomdd w sat
nodes memory mb nodes memory mb nodes memory mb
bayesian network repository
alarm






cpcs




cpcs





cpcs b

diabetes


hailfinder





mildew




mm




munin


munin


munin

n
pathfinder





pigs




water




uai evaluation dataset
bn

n


bn

n


bn

n


bn

n


bn

n



bn

n



bn

n




bn

n



bn

n



bn

n




bn

n




bn

n



bn

n



bn

n



bn

n



bn

n



positive random bayesian networks parameters n k p c
r




r




r




r





r




r




r




r




r





r





deterministic random bayesian networks parameters n k p c
r




r



r



r



r



r



r



r




r



r




table memory usage mbytes ace aomdd bcp aomdd sat bayesian
networks table bold types highlight best performance across rows n
indicates respective memory usage statistic available aces output



fim ateescu echter arinescu

nally developed heuristic search nilsson mentioned introduction
search graphical pseudo tree spans graph model similar
tree rearrangement freuder quinn idea adapted distributed
constraint satisfaction collin et al recently modi et al
shown related graph backjumping dechter work extended
bayardo miranker bayardo schrag recently applied optimization tasks larrosa et al another version viewed exploring
graphs presented recently constraint satisfaction terrioux jegou b optimization terrioux jegou similar principles introduced recently probabilistic
inference recursive conditioning darwiche well value elimination
bacchus et al b currently core advanced sat solvers sang
et al
direction lines related formal verification literature
beginning work bryant contains large number papers dedicated
study bdds however bdds fact structures underlying pseudo tree chain
take advantage decomposition explicit way complexity bounds
obdds pathwidth rather treewidth
noted earlier work bertacco damiani disjoint support decomposition
dsd related bdds ways main common aspect approaches structure decomposition exploited bdd representation dsd
focused boolean functions exploit refined structural information inherent boolean functions contrast bdds assume structure conveyed
constraint graph therefore broadly applicable constraint expression
graphical general allow simpler higher level exposition yields graphbased bounds overall size generated aomdd full relationship two
formalisms studied
mcmillan introduced bdd trees along operations combining
w
circuits bounded tree width bdd trees linear space upper bound g w
g size circuit g typically linear number variables w treewidth
bound hides large constants claim linear dependence g w bounded
however mcmillan maintains input function cnf expression bdd trees
bounds bdds namely exponential treewidth
sketch short comparison mcmillans bdd trees aommds consider
example simple pseudo tree root left child right child
nodes may stand set variables bdd trees assignments grouped
equivalence classes according cofactors generated remaining
example assignments equivalent generate function
node represented bdd whose leaves cofactors done
node represented matrix bdds column corresponds cofactor
line cofactor contrast aomdd represents node bdd whose
leaves cofactors number distinct functions cofactor
root decomposition node moreover representations
descendants different cofactor shared much possible goes
high level description becomes slightly complicated redundant nodes
eliminated idea remains


fiand ulti valued ecision iagrams aomdd g raphical odels

structure restricted propositional theories similar deterministic decomposable negation normal form dnnf darwiche marquis darwiche
recently huang darwiche b used trace dpll generate obdd
compared typical formal verification combining obdds input
function according schedule structures investigated case still
idea extended present work search compilation
mcallester collins pereira introduced case factor diagrams cfd subsume markov random fields bounded tree width probabilistic context free grammars pcfg
cfds much related graphs cfds target minimal representation
exploiting decomposition similar nodes exploiting context sensitive information allowing dynamic ordering variables context cfds eliminate
redundant nodes part cause use zero suppression claim
cfds canonical forms description combine two cfds
numerous variants decision diagrams designed represent integer valued
real valued functions comprehensive view refer reader survey drechsler
sieling algebraic decision diagrams adds bahar et al provide compilation general real valued rather boolean functions main drawback
size increases fast number terminals becomes large several approaches
try alleviate however structure capture still
exploit decomposition alternatives introduce edge values weights enable
subgraph sharing edge valued binary decision diagrams evbdds lai sastry
use additive weights multiplicative weights allowed called factored
evbdds fevbdds tafertshofer pedram another type bdds called k bmds
drechsler becker ruppertz use integer weights additive multiplicative
parallel adds extended affine adds sanner mcallester
affine transformations achieve compression shown beneficial
probabilistic inference tree clustering still exploit
structure
recently independently parallel work graphs dechter mateescu b fargier vilarem fargier marquis proposed compilation csps tree driven automata many similarities work
main focus transition linear automata tree automata similar
possible savings tree structured networks hyper trees constraints
due decomposition compilation guided tree decomposition
guided variable elimination well known bucket elimination
cluster tree decomposition principle dechter pearl
wilson extended obdds semi ring bdds semi ring treatment restricted
search spaces allows dynamic variable ordering otherwise similar aim
scope aomdd restricting aomdd graphs two closely related
except express bdds shenoy shafer axiomatization centered two
operation combination marginalization rather semi ring formulation minimality
formulation wilson general allowing merging nodes different values
therefore capture symmetries called interchangeability
another framework similar aomdds became aware recently probabilistic decision graphs pdg jaeger work preceded relevant work


fim ateescu echter arinescu

discussed fargier vilarem wilson went somewhat unnoticed perhaps due notational cultural differences however similar motivation framework
proposed believe framework accessible define framework multi valued domains provide greater details complexity analysis
make explicit connection search frameworks fully address issues canonicity well
provide empirical demonstration particular claim canonicity pdgs similar
one make aomdds weighted relative trees forests
represent given probability distribution
another line drechsler group e g zuzek drechsler thornton
use graphs boolean function representation may seem similar
however semantics purpose graphs different
constructed technique recursive learning used perform boolean reasoning
e explore logic consequences given assumption structure circuit
especially derive sets implicants meaning case related
meaning gates functions case meaning related semantic
functions enumeration tree circuit according zuzek et al
related decomposition discuss

conclusion
propose multi valued decision diagram aomdd emerges study
search spaces graphical dechter mateescu b mateescu
dechter dechter mateescu ordered binary decision diagrams obdds bryant
data structure used compile graphical model
graphical search compiled data structures bdds
differ primarily choices time vs memory move regular search
space search space spectrum available improved time
vs memory decisions believe search space clarifies available choices
helps guide user making informed selection would fit best
particular query asked specific input function available computational resources
contribution work formally describe aomdd prove
canonical representation constraint network extend aomdd general weighted
graphical give compilation search saves
trace memory intensive search context minimal graph reduces
one bottom pass describe apply operator combines two aomdds
operation complexity quadratic input never worse exponential
treewidth give scheduling order building aomdd graphical model
starting aomdds functions variable elimination
guarantees complexity exponential induced width treewidth along
ordering aomdds relate earlier recent compilation frameworks
providing unifying perspective methods introduce semantic treewidth
helps explain compiled decision diagrams often much smaller worst case
bound finally provide preliminary empirical demonstration power current
scheme



fiand ulti valued ecision iagrams aomdd g raphical odels

acknowledgments
work done robert mateescu radu marinescu university california irvine authors would thank anonymous reviewers constructive
suggestions improve david eppstein useful discussion complexity issues
lars otten natasha flerova comments final version manuscript work
supported nsf grants iis iis initial part radcliffe fellowship partner program harvard undergraduate student john cobb

appendix
proof proposition
consider level variable xi meta nodes list lxi one pass
meta nodes lxi inner loop two meta nodes level xi
graph isomorphic would merged line
pass meta nodes lxi redundant meta nodes lxi eliminated
line processing meta nodes level xi create redundant isomorphic
meta nodes levels processed follows resulting
graph completely reduced
proof theorem
bound size follows directly theorem aomdd size smaller

size context minimal graph bounded n k wt g prove
time bound rely use hash table assumption efficient implementation allows access time constant time bound earch aomdd

n k wt g theorem takes time linear output assume
constraint propagation performed search procedure b ottom u p r eduction procedure takes time linear size context minimal graph therefore aomdd

computed time n k wt g performs
reduction search
proof proposition
complexity obdd mdd apply known quadratic input namely
number nodes output product number nodes input therefore
number nodes appear along one path output aomdd product
number nodes input along path gfi ggi summing paths
gives
proof proposition
argument identical case mdds recursive calls apply lead combinations
one node gfaomdd one node ggaomdd rather list nodes number
total possible combinations gfaomdd ggaomdd
proof proposition
recursive calls apply generate one meta node output combination


fim ateescu echter arinescu

nodes gff g ggf g lets look combinations nodes gff g ggaomdd ggf g
meta nodes ggaomdd ggf g participate combinations lets call set
levels variables right tf g mechanics
recursive calls apply whenever node f belongs gff g combined node
g belongs line apply expands node f node nodes
remain happen nodes f combined
node nodes point apply simply copy remaining portion
output ggaomdd size therefore proportional ggf g layer
metanodes immediately ggf g similar argument valid symmetrical case
combinations nodes ggaomdd ggf g ggaomdd ggf g bound follows
arguments
proof proposition
apply operation works constructing output aomdd root leaves first creates
meta node root variable recursively creates children metanodes apply
corresponding children input worst case happen output
reduced recursive call made possible descendant corresponds
unfolding full search tree context variables exponential
context size apply finishes context variables arrives first branching
bucket pseudo tree remaining branches independent similar case obdds
one function occupies single place memory apply simply create link
corresponding branches inputs happens line apply
therefore time space complexity exponential context size
proof theorem
space complexity governed since aomdd never requires space

full exponential table tree follows aomdd needs space n k w
size output aomdd bounded per layers number assignments
context layer namely size context minimal graph therefore

context size bounded treewidth follows output size n k w
time complexity follows proposition fact number functions
bucket cannot exceed r original number functions

proof proposition
suffices prove proposition general obtained induction
essential function defined constraint network e values
function takes value least one assignment value denotes consistent assignments solutions denotes inconsistent assignments suppose f f f lets denote
x full assignment x x x projection x x x respectively
write x x x concatenation partial assignments follows f x f x f x
therefore f x must f x f x claim x
f x exists x f x x suppose contradiction
exist x f x f x x x since f zero



fiand ulti valued ecision iagrams aomdd g raphical odels

follows f zero therefore must x f x
leads contradiction therefore functions f f uniquely defined f
proof theorem
proof structural induction depth pseudo tree follows canonicity
proofs obdds bryant mdds srinivasan et al extends linear
orderings tree orderings capture function decomposition according pseudo tree
depth along paths root leaf actually size dependency set
set variables value function depends remember aomdd
graph completely reduced use word function denoted f refer
universal relation characteristic function defined constraint network
assume depth means function depend variable
must one constants suppose function constant must
aomdd contain terminal meta node since nodes must reachable
along path would mean function evaluate suppose aomdd
contains nonterminal meta node say labeled x x take k different values must
k children meta nodes x terminal meta node one
terminal aomdd completely reduced one follows
meta node labeled x redundant therefore follows aomdd
representing constant made terminal unique contains smallest
number nodes similar argument applies constant
suppose statement theorem holds constraint network admits
pseudo tree depth strictly smaller p constraint network pseudo
tree depth equal p p let x root domain x xk
denote k functions defined restricted constraint network
x xi namely f x xi let ym children x suppose two
aomdds f denoted g g two graphs isomorphic
functions decomposed according pseudo tree root x removed
fact forest independent pseudo trees share variables rooted
ym proposition unique decomposition fiy fiym

k induction hypothesis function j unique aomdd
graphs g g look subgraphs descending x xi
completely reduced define function therefore exists isomorphic mapping
let v root metanode g v root g claim g g
isomorphic according following mapping

v
u v
u
u u subgraph rooted hx xi
prove well defined isomorphic mapping
meta node u g contained subgraphs rooted hx xi hx xj
graphs rooted u j u isomorphic one rooted u therefore
since g completely reduced contain isomorphic subgraphs therefore
u j u therefore well defined
bijection one one assume two distinct metanodes u u g u u subgraphs rooted u u isomorphic


fim ateescu echter arinescu

subgraph rooted u therefore since g completely reduced must
u u fact onto isomorphic mapping follows definition
fact onto node root meta node since aomdds
contain one root meta node one root would lead conclusion root
meta nodes isomorphic merged conclude g g isomorphic
finally among graphs representing f aomdd
minimal number meta nodes suppose g graph represents f minimal
number meta nodes without aomdd namely completely reduced
reduction rule would transform g graph smaller number meta nodes
leading contradiction therefore g must unique aomdd represents f
proof corollary
proof theorem rely scopes define constraint network long
network admits decomposition induced pseudo tree universal function defined
constraint network aomdd therefore constraint network
equivalent admits aomdd
proof theorem
constant associated root actually sum weights solutions
derived definition weighted aomdd weights meta node
normalized sum therefore values computed node search
task computing
p sum solution weights therefore constant
weighted aomdd x w x regardless graphical model prove
weighted aomdds canonical functions normalized
assume two different weighted aomdds denoted g g normalized function f let root variable domain ak let x denote full
assignment variables similar argument root constant
p
meta nodes normalized weights follows w w x f x
superscript w w indicates aomdd summation possible assignments restricted follows root meta nodes identical value
root variable restricted functions represented g g identical recursively
apply argument
however proof complete discuss case restricted function
decomposed independent functions according pseudo tree suppose two
independent components rooted b c one function follows
entire function prove meta nodes b g g identical b
one value b extendable solution weight must meta nodes meta nodes
identical b one value suppose without loss generality weights
different first value b
w b b w b b



since f must value c c b b c c extended full
solution sum weights possible extensions
x
f x w b b w c c w b b w c c

x b b c c



fiand ulti valued ecision iagrams aomdd g raphical odels

equations fact weight non zero follows
w c c w c c



equation fact b one value fact weights b
normalized follows value b
w b b w b b



equations follows
w b b w c c w b b w c c



however sides
p equation represent sum weights solutions b
b c c namely x b b c c f x leading contradiction therefore must
equation false continuing argument values b follows metanodes b identical similarly meta nodes c identical
decomposition two components argument applies b
first component c meta variable combines components

proof theorem
consider well known np complete coloring given graph g
coloring g namely color vertices three colors two
adjacent vertices different colors reduce coloring computing
semantic treewidth graphical model let h graph colorable nontrivial semantic treewidth easy build examples h g colorable g h
colorable non trivial semantic treewidth adding g simplify
task describing colorings h however g colorable g h
colorable semantic treewidth zero
proof proposition
since aomdds canonical representations graphical follows graphical
model actual semantic treewidth realized aomdd
therefore aomdd bounded exponentially semantic treewidth

references
akers binary decision diagrams ieee transactions computers c
allen darwiche advances inference recursive conditioning proceedings nineteenth conference uncertainty artificial intelligence uai pp

bacchus f dalmao pitassi complexity sat
bayesian inference proceedings th annual ieee symposium foundations
computer science focs pp


fim ateescu echter arinescu

bacchus f dalmao pitassi b value elimination bayesian inference via backtracking search proceedings nineteenth conference uncertainty artificial
intelligence uai pp
bahar r frohm e gaona c hachtel g macii e pardo somenzi f algebraic decision diagrams applications ieee acm international conference
computer aided design iccad pp
bayardo r miranker complexity analysis space bound learning
constraint satisfaction proceedings thirteenth national conference
artificial intelligence aaai pp
bayardo r j schrag r c csp look back techniques solve real world sat
instances proceedings fourteenth national conference artificial intelligence
aaai pp
bertacco v damiani disjunctive decomposition logic functions
ieee acm international conference computer aided design iccad pp
bodlaender h l gilbert j r approximating treewidth pathwidth minimum
elimination tree height tech rep utrecht university
bryant r e graph boolean function manipulation ieee transactions computers
cadoli donini f survey knowledge compilation ai communications

chavira darwiche compiling bayesian networks local structure
proceedings nineteenth international joint conference artificial intelligence ijcai pp
chavira darwiche compiling bayesian networks variable elimination
proceedings twentieth international joint conference artificial intelligence ijcai pp
chavira darwiche jaeger compiling relational bayesian networks exact
inference international journal approximate reasoning
clarke e grumberg peled model checking mit press
collin z dechter r katz feasibility distributed constraint satisfaction
proceedings twelfth international conference artificial intelligence ijcai
pp
collin z dechter r katz self stabilizing distributed constraint satisfaction
chicago journal theoretical computer science special issue self stabilization
darwiche recursive conditioning artificial intelligence



fiand ulti valued ecision iagrams aomdd g raphical odels

darwiche logical factoring belief networks proceedings
eighth international conference principles knowledge representation reasoning
kr pp
darwiche marquis p knowledge compilation map journal artificial intelligence jair
dechter r constraint networks encyclopedia artificial intelligence
dechter r bucket elimination unifying framework reasoning artificial intelligence

dechter r mateescu r search spaces graphical artificial intelligence
dechter r mateescu r mixtures deterministic probabilistic networks
search space proceedings twentieth conference uncertainty artificial intelligence uai pp
dechter r mateescu r b impact search spaces constraint satisfaction counting proceedings tenth international conference principles
practice constraint programming cp pp
dechter r pearl j tree clustering constraint networks artificial intelligence

drechsler r becker b ruppertz k bmds data structure verification
proceedings european conference design test ed tc pp
drechsler r sieling binary decision diagrams theory practice international
journal software tools technology transfer sttt
fargier h marquis p use partially ordered decision graphs knowledge
compilation quantified boolean formulae proceedings twenty first national
conference artificial intelligence aaai pp
fargier h marquis p valued negation normal form formulas proceedings
twentieth international joint conference artificial intelligence ijcai pp
fargier h vilarem compiling csps tree driven automata interactive solving constraints
fishburn p c utility theory decision making wiley newyork
freuder e c quinn j taking advantage stable sets variables constraint
satisfaction proceedings ninth international joint conference artificial
intelligence ijcai pp
freuder e c quinn j use lineal spanning trees represent constraint
satisfaction tech rep university hampshire durham


fim ateescu echter arinescu

huang j darwiche compiling system faster scalable diagnosis proceedings th national conference artificial intelligence aaai
pp
huang j darwiche b dpll trace sat knowledge compilation
proceedings nineteenth international joint conference artificial intelligence
ijcai pp
jaeger probabilistic decision graphs combining verification ai techniques
probabilistic inference international journal uncertainty fuzziness knowledgebased systems
kask k dechter r larrosa j dechter unifying cluster tree decompositions
reasoning graphical artificial intelligence
kjaerulff u triangulation graph giving small total state space tech
rep university aalborg denmark
korf r felner disjoint pattern database heuristics artificial intelligence

lai sastry edge valued binary decision multi level hierarchical verification
proceedings twenty nineth design automation conference pp
larrosa j meseguer p sanchez pseudo tree search soft constraints
proceedings european conference artificial intelligence ecai pp
lee c representation switching circuits binary decision programs bell system
technical journal
mateescu r dechter r relationship search variable elimination proceedings twenty first conference uncertainty artificial intelligence
uai pp
mateescu r dechter r multi valued decision diagrams aomdds
weighted graphical proceedings twenty third conference uncertainty
artificial intelligence uai pp
mcallester collins pereira f case factor diagrams structured probabilistic
modeling proceedings twentieth conference uncertainty artificial intelligence uai pp
mcmillan k l symbolic model checking kluwer academic
mcmillan k l hierarchical representation discrete functions application model
checking computer aided verification pp
modi p j shen w tambe yokoo adopt asynchronous distributed constraint optimization quality guarantees artificial intelligence



fiand ulti valued ecision iagrams aomdd g raphical odels

moskewicz madigan c zhao zhang l malik chaff engineering
efficient sat solver proceedings thirty eighth design automation conference pp

nilsson n j principles artificial intelligence tioga palo alto ca
palacios h bonet b darwiche geffner h pruning conformant plans counting compiled dnnf representations proceedings th international
conference scheduling icaps pp
pearl j probabilistic reasoning intelligent systems morgan kaufmann
sang bacchus f beame p kautz h pitassi combining component caching
clause learning effective model counting proceedings seventh international
conference theory applications satisfiability testing sat
sanner mcallester affine algebraic decision diagrams aadds application structured probabilistic inference proceedings nineteenth international
joint conference artificial intelligence ijcai pp
selman b kautz h knowledge compilation theory approximation journal
acm
shenoy p valuation systems bayesian decision analysis operations

srinivasan kam malik brayton r k discrete function
manipulation international conference cad pp
tafertshofer p pedram factored edge valued binary decision diagrams formal
methods system design
terrioux c jegou p bounded backtracking valued constraint satisfaction
proceedings ninth international conference principles practice
constraint programming cp pp
terrioux c jegou p b hybrid backtracking bounded tree decomposition constraint networks artificial intelligence
wilson n decision diagrams computation semiring valuations proceedings
nineteenth international joint conference artificial intelligence ijcai pp

zuzek drechsler r thornton boolean function representation spectral
characterization graphs integration vlsi journal




