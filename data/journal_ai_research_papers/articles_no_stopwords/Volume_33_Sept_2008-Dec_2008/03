Journal Artificial Intelligence Research 33 (2008) 465-519

Submitted 05/08; published 12/08

AND/OR Multi-Valued Decision Diagrams (AOMDDs)
Graphical Models
Robert Mateescu

MATEESCU @ PARADISE . CALTECH . EDU

Electrical Engineering Department
California Institute Technology
Pasadena, CA 91125, USA

Rina Dechter

DECHTER @ ICS . UCI . EDU

Donald Bren School Information Computer Science
University California Irvine
Irvine, CA 92697, USA

Radu Marinescu

R . MARINESCU @4 C . UCC . IE

Cork Constraint Computation Centre
University College Cork, Ireland

Abstract
Inspired recently introduced framework AND/OR search spaces graphical models, propose augment Multi-Valued Decision Diagrams (MDD) nodes, order
capture function decomposition structure extend compiled data structures general weighted graphical models (e.g., probabilistic models). present AND/OR Multi-Valued
Decision Diagram (AOMDD) compiles graphical model canonical form supports polynomial (e.g., solution counting, belief updating) constant time (e.g. equivalence
graphical models) queries. provide two algorithms compiling AOMDD graphical
model. first search-based, works applying reduction rules trace memory
intensive AND/OR search algorithm. second inference-based uses Bucket Elimination
schedule combine AOMDDs input functions via APPLY operator.
algorithms, compilation time size AOMDD are, worst case, exponential
treewidth graphical model, rather pathwidth known ordered binary decision
diagrams (OBDDs). introduce concept semantic treewidth, helps explain
size decision diagram often much smaller worst case bound. provide
experimental evaluation demonstrates potential AOMDDs.

1. Introduction
paper extends decision diagrams AND/OR multi-valued decision diagrams (AOMDDs)
shows graphical models compiled data-structures. work presented
paper based two existing frameworks: (1) AND/OR search spaces graphical models
(2) decision diagrams.
1.1 AND/OR Search Spaces
AND/OR search spaces (Dechter & Mateescu, 2004a, 2004b, 2007) proven unifying
framework various classes search algorithms graphical models. main characteristic
exploitation independencies variables search, provide exponential
speedups traditional search methods viewed traversing structure.
c
2008
AI Access Foundation. rights reserved.

fiM ATEESCU , ECHTER & ARINESCU

nodes capture problem decomposition independent subproblems, nodes represent branching according variable values. AND/OR spaces accommodate dynamic variable
ordering, however current work focuses static decomposition. Examples AND/OR
search trees graphs appear later, example Figures 6 7.
AND/OR search space idea originally developed heuristic search (Nilsson, 1980).
context graphical models, AND/OR search (Dechter & Mateescu, 2007) inspired
search advances introduced sporadically past three decades constraint satisfaction
recently probabilistic inference optimization tasks. Specifically, resembles
pseudo tree rearrangement (Freuder & Quinn, 1985, 1987), adapted subsequently distributed constraint satisfaction Collin, Dechter, Katz (1991, 1999) recently
Modi, Shen, Tambe, Yokoo (2005), shown related graph-based backjumping (Dechter, 1992). work extended Bayardo Miranker (1996) Bayardo
Schrag (1997) recently applied optimization tasks Larrosa, Meseguer, Sanchez
(2002). Another version viewed exploring AND/OR graphs presented recently constraint satisfaction (Terrioux & Jegou, 2003b) optimization (Terrioux & Jegou,
2003a). Similar principles introduced recently probabilistic inference, algorithm Recursive Conditioning (Darwiche, 2001) well Value Elimination (Bacchus, Dalmao, & Pitassi,
2003b, 2003a), currently core advanced SAT solvers (Sang, Bacchus,
Beame, Kautz, & Pitassi, 2004).
1.2 Decision Diagrams
Decision diagrams widely used many areas research, especially software hardware
verification (Clarke, Grumberg, & Peled, 1999; McMillan, 1993). BDD represents Boolean
function directed acyclic graph two terminal nodes (labeled 0 1), every internal
node labeled variable exactly two children: low 0 high 1. isomorphic
nodes merged, would full search tree, called Shannon tree,
usual full tree explored backtracking algorithm. tree ordered variables encountered
order along every branch. compressed merging isomorphic nodes
(i.e., label identical children), eliminating redundant nodes (i.e., whose
low high children identical). result celebrated reduced ordered binary decision
diagram, OBDD short, introduced Bryant (1986). However, underlying structure
OR, initial Shannon tree tree. AND/OR search trees reduced node
merging redundant nodes elimination get compact search graph viewed
BDD representation augmented nodes.
1.3 Knowledge Compilation Graphical Models
paper combine two ideas, creating decision diagram AND/OR structure, thus exploiting problem decomposition. detail, number values increased
two constant. context constraint networks, decision diagrams used
represent whole set solutions, facilitating solutions count, solution enumeration queries
equivalence constraint networks. benefit moving structure AND/OR
lower complexity algorithms size compiled structure. typically moves
bounded exponentially pathwidth pw , characteristic chain decompositions
linear structures, exponentially bounded treewidth w , characteristic tree
466

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

structures (Bodlaender & Gilbert, 1991) (it always holds w pw pw w log n,
n number variables model). cases, compactness result achieved
practice often far smaller bounds suggest.
decision diagram offers compilation propositional knowledge-base. extension
OBDDs provided Algebraic Decision Diagrams (ADD) (Bahar, Frohm, Gaona, Hachtel,
Macii, Pardo, & Somenzi, 1993), terminal nodes 0 1, take values
arbitrary finite domain. knowledge compilation approach become important research
direction automated reasoning past decade (Selman & Kautz, 1996; Darwiche & Marquis,
2002; Cadoli & Donini, 1997). Typically, knowledge representation language compiled
compact data structure allows fast responses various queries. Accordingly, computational
effort divided offline online phase work pushed
offline. Compilation used generate compact building blocks used online
algorithms multiple times. Macro-operators compiled prior search viewed
light (Korf & Felner, 2002), graphical models building blocks functions
whose compact compiled representations used effectively across many tasks.
one example, consider product configuration tasks imagine user chooses sequential options configure product. naive system, user would allowed choose valid
option current level based initial constraints, either product configured,
else, dead-end encountered, system would backtrack previous state
continue there. would fact search space possible partial configurations. Needless say, would unpractical, would offer user guarantee
finishing limited time. system based compilation would actually build backtrack-free
search space offline phase, represent compact manner. online phase,
valid partial configurations (i.e., extended full valid configuration) allowed,
depending query type, response time guarantees offered terms size
compiled structure.
Numerous examples, diagnosis planning problems, formulated
graphical models could benefit compilation (Palacios, Bonet, Darwiche, & Geffner, 2005;
Huang & Darwiche, 2005a). diagnosis, compilation facilitate fast detection possible faults
explanations unusual behavior. Planning problems formulated graphical
models, compilation would allow swift adjustments according changes environment.
Probabilistic models one used types graphical models, basic query
compute conditional probabilities variables given evidence. compact compilation
probabilistic model would allow fast response queries incorporate evidence acquired time.
example, two important tasks Bayesian networks computing probability
evidence, computing maximum probable explanation (MPE). model
variables become assigned (evidence), tasks performed time linear compilation size, practice many cases smaller upper-bound based treewidth
pathwidth graph. Formal verification another example compilation heavily used
compare equivalence circuit design, check behavior circuit. Binary Decision
Diagram (BDD) (Bryant, 1986) arguably widely known used compiled structure.
contributions made paper knowledge compilation general decision diagrams particular following:
1. formally describe AND/OR Multi-Valued Decision Diagram (AOMDD) prove
canonical representation constraint networks, given pseudo tree.
467

fiM ATEESCU , ECHTER & ARINESCU

2. extend AOMDD general weighted graphical models.
3. give compilation algorithm based AND/OR search, saves trace memory
intensive search reduces one bottom pass.
4. present APPLY operator combines two AOMDDs show complexity
quadratic input, never worse exponential treewidth.
5. give scheduling order building AOMDD graphical model starting
AOMDDs functions based Variable Elimination algorithm.
guarantees complexity exponential induced width (treewidth) along
ordering.
6. show AOMDDs relate various earlier recent compilation frameworks, providing unifying perspective methods.
7. introduce semantic treewidth, helps explain compiled decision diagrams
often much smaller worst case bound.
8. provide experimental evaluation new data structure.
structure paper follows. Section 2 provides preliminary definitions, description
binary decision diagrams Bucket Elimination algorithm. Section 3 gives overview
AND/OR search spaces. Section 4 introduces AOMDD discusses properties. Section
5 describes search-based algorithm compiling AOMDD. Section 6 presents compilation
algorithm based Bucket Elimination schedule APPLY operation. Section 7 proves
AOMDD canonical representation constraint networks given pseudo tree, Section
8 extends AOMDD weighted graphical models proves canonicity. Section 9 ties
canonicity new concept semantic treewidth. Section 10 provides experimental
evaluation. Section 11 presents related work Section 12 concludes paper. proofs
appear appendix.

2. Preliminaries
Notations reasoning problem defined terms set variables taking values finite
domains set functions defined variables. denote variables subsets
variables uppercase letters (e.g., X, Y, . . .) values variables lower case letters (e.g.,
x, y, . . .). Sets usually denoted bold letters, example X = {X1 , . . . , Xn } set
variables. assignment (X1 = x1 , . . . , Xn = xn ) abbreviated x = (hX1 , x1 i, . . . ,
hXn , xn i) x = (x1 , . . . , xn ). subset variables Y, DY denotes Cartesian product
domains variables Y. projection assignment x = (x1 , . . . , xn ) subset
denoted xY x[Y]. denote = (or short) assignment values
variables respective domains. denote functions letters f , g, h etc.,
scope (set arguments) function f scope(f ).
2.1 Graphical Models
EFINITION 1 (graphical model) graphical model 4-tuple, = hX, D, F, i, where:
468

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

1. X = {X1 , . . . , Xn } finite set variables;
2. = {D1 , . . . , Dn } set respective finite domains values;
3. F = {f1 , . . . , fr } set positive real-valued discrete functions (i.e., domains
listed), defined subset variables Si X, called scope, denoted
scope(fi ).
Q P
4. combination operator1 (e.g., { , , 1} product, sum, join), take
input two (or more) real-valued discrete functions, produce another real-valued discrete
function.
graphical model represents combination functions: ri=1 .
Several examples graphical models appear later, example: Figure 1 shows constraint
network Figure 2 shows belief network.
order define equivalence graphical models, useful introduce notion
universal graphical model defined single function.
EFINITION 2 (universal equivalent graphical model) Given graphical model
=
hX, D, F1 , universal equivalent model u(M) = hX, D, F2 = {fi F1 }, i.
Two graphical models equivalent represent function. Namely,
universal model.
EFINITION 3 (weight full partial assignment) Given graphical model =
hX, D, Fi, weight full assignment x = (x1 , . . . , xn ) defined w(x) =
f F f (x[scope(f )]). Given subset variables X, weight partial assignment
combination functions whose scopes included (denoted FY ) evaluated
assigned values. Namely, w(y) = f FY f (y[scope(f )]).
Consistency graphical models, range functions special zero value 0
absorbing relative combination operator (e.g., multiplication). Combining anything
0 yields 0. 0 value expresses notion inconsistent assignments. primary
concept constraint networks defined relative graphical models
0 element.
EFINITION 4 (consistent partial assignment, solution) Given graphical model 0
element, partial assignment consistent cost non-zero. solution consistent assignment variables.
EFINITION 5 (primal graph) primal graph graphical model undirected graph
variables vertices edge connects two variables appear scope
function.
primal graph captures structure knowledge expressed graphical model.
particular, graph separation indicates independency sets variables given assignments
variables. advanced algorithms graphical models exploit graphical structure,
using heuristically good elimination order, tree decomposition similar method.
use concept pseudo tree, resembles tree rearrangements introduced Freuder
Quinn (1985):
1. combination operator defined axiomatically (Shenoy, 1992).

469

fiM ATEESCU , ECHTER & ARINESCU

E







E

B


F

B

G

F

C

G
C

(a) Graph coloring problem

(b) Constraint graph

Figure 1: Constraint network
EFINITION 6 (pseudo tree) pseudo tree graph G = (X, E) rooted tree
set nodes X, every arc E backarc (A path rooted tree starts
root ends one leaf. Two nodes connected backarc exists path
contains both).
use common concepts parameters graph theory, characterize connectivity graph, close tree chain. induced width graphical model
governs complexity solving Bucket Elimination (Dechter, 1999), shown
bound AND/OR search graph memory used cache solved subproblems (Dechter &
Mateescu, 2007).
EFINITION 7 (induced graph, induced width, treewidth, pathwidth) ordered graph
pair (G, d), G = ({X1 , . . . , Xn }, E) undirected graph, = (X1 , . . . , Xn )
ordering nodes. width node ordered graph number neighbors
precede ordering. width ordering d, denoted w(d), maximum width
nodes. induced width ordered graph, w (d), width induced ordered graph
obtained follows: node, last first d, preceding neighbors connected
clique. induced width graph, w , minimal induced width orderings.
induced width equal treewidth graph. pathwidth pw graph
treewidth restricted class orderings correspond chain decompositions.
Various reasoning tasks, queries defined graphical models. defined formally using marginalization operators projection, summation minimization.
However, since goal present compilation graphical model independent
queries posed it, discuss tasks informal manner only.
information see work Kask, Dechter, Larrosa, Dechter (2005).
Throughout paper, use two examples graphical models: constraint networks
belief networks. case constraint networks, functions understood relations. words, functions (also called constraints) take two values, {0, 1},
{f alse, true}. 0 value indicates corresponding assignment variables inconsistent (not allowed), 1 value indicates consistency. Belief networks example
general case graphical models (also called weighted graphical models). functions case
conditional probability tables, values function real numbers interval [0, 1].

470

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

Example 1 Figure 1(a) shows graph coloring problem modeled constraint network. Given map regions, problem color region one given colors {red,
green, blue}, neighboring regions different colors. variables problems
regions, one domain {red, green, blue}. constraints relation
different neighboring regions. Figure 1(b) shows constraint graph, solution
(A=red, B=blue, C=green, D=green, E=blue, F=blue, G=red) given Figure 1(a).
detailed example given later Example 8.
Propositional Satisfiability special case CSP propositional satisfiability (SAT). formula conjunctive normal form (CNF) conjunction clauses 1 , . . . , , clause
disjunction literals (propositions negations). example, = (P Q R)
clause, P , Q R propositions, P , Q R literals. SAT problem
decide whether given CNF theory model, i.e., truth-assignment propositions
violate clause. Propositional satisfiability (SAT) defined CSP,
propositions correspond variables, domains {0, 1}, constraints represented clauses,
example clause (A B) relation propositional variables allows tuples
(A, B) except (A = 1, B = 0).
Cost Networks immediate extension constraint networks cost networks set
functions real-valued cost functions, primary task optimization. Also, GAI-nets
(generalized additive independence, Fishburn, 1970) used represent utility functions.
example cost functions appear Figure 19.
EFINITION
P8 (cost network, combinatorial optimization) cost network 4-tuple,
hX, D, C, i, X set variables X = {X1 , . . . , Xn }, associated set
discrete-valued domains, = {D1 , . . . , Dn }, set cost functions C = {C1 , . . . , Cr }.
Ci real-valued function defined subset variables Si X. combination operator,
P
. reasoning problem find minimum cost solution.

Belief Networks (Pearl, 1988) provide formalism reasoning partial beliefs conditions uncertainty. defined directed acyclic graph vertices representing random
variables interest (e.g., temperature device, gender patient, feature object, occurrence event). arcs signify existence direct causal influences
linked variables quantified conditional probabilities attached cluster parentschild vertices network.
Q
EFINITION 9 (belief networks) belief network (BN) graphical model P = hX, D, PG , i,
X = {X1 , . . . , Xn } set variables domains = {D1 , . . . , Dn }. Given directed acyclic graph G X nodes, PG = {P1 , . . . , Pn }, Pi = {P (Xi | pa (Xi ) ) }
conditional probability tables (CPTs short) associated Xi , pa(Xi )
parents Xi
Qacyclic graph G. belief network represents probability distribution X,
P (x1 , . . . , xn ) = ni=1 P (xi |xpa(Xi ) ). evidence set e instantiated subset variables.
formulated graphical model, functions F denote conditional probability tables
scopes functions determined directed acyclic graph G: function
Q
ranges variable Xi parents G. combination operator product, = .
primal graph belief network (viewed undirected model) called moral graph.
connects two variables appearing CPT.
471

fiM ATEESCU , ECHTER & ARINESCU

Season

Sprinkler B

Watering



C Rain

B

F Wetness



G Slippery

C

F

G

(a) Directed acyclic graph

(b) Moral graph

Figure 2: Belief network
Example 2 Figure 2(a) gives example belief network 6 variables, Figure 2(b)
shows moral graph . example expresses causal relationship variables Season
(A), configuration automatic sprinkler system (B), amount rain expected
(C), amount manual watering necessary (D), wetness pavement (F )
Whether pavement slippery (G). belief network expresses probability distribution P (A, B, C, D, F, G) = P (A) P (B|A) P (C|A) P (D|B, A) P (F |C, B) P (G|F ).
Another example belief network CPTs appears Figure 9.
two popular tasks belief networks defined below:
EFINITION 10 (belief updating, probable explanation (MPE)) Given belief network
evidence e, belief updating task compute posterior marginal probability variable
Xi , conditioned evidence. Namely,
X

Bel(Xi = xi ) = P (Xi = xi | e) =

n


P (xk , e|xpak ),

{(x1 ,...,xi1 ,xi+1 ,...,xn )|E=e,Xi =xi } k=1

normalization constant. probable explanation (MPE) task find
complete assignment agrees evidence, highest probability among
assignments. Namely, find assignment (xo1 , . . . , xon )
P (xo1 , . . . , xon ) = maxx1 ,...,xn

n


P (xk , e|xpak ).

k=1

2.2 Binary Decision Diagrams Review
Decision diagrams widely used many areas research represent decision processes.
particular, used represent functions. Due fundamental importance Boolean
functions, lot effort dedicated study Binary Decision Diagrams (BDDs),
extensively used software hardware verification (Clarke et al., 1999; McMillan,
1993). earliest work BDDs due Lee (1959), introduced binary-decision program, understood linear representation BDD (e.g., depth first search ordering
nodes), node branching instruction indicating address next instruction 0 1 value test variable. Akers (1978) presented actual graphical
472

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS


0
0
0
0
1
1
1
1

B
0
0
1
1
0
0
1
1

C
0
1
0
1
0
1
0
1

f(ABC)
0
0
0
1
0
1
0
1





B

C

C

0

C

0

(a) Table

0

B

B

1

0

B

0

1

B

C

1

0

(b) Unordered tree

C

0

0

C

1

0

C

1

0

1

(c) Ordered tree

Figure 3: Boolean function representations
representation developed BDD idea. However, Bryant (1986) introduced
called Ordered Binary Decision Diagram (OBDD). restricted order variables along path diagram, presented algorithms (most importantly apply procedure, combines two OBDDs operation) time complexity quadratic
sizes input diagrams. OBDDs fundamental applications large binary functions,
especially many practical cases provide compact representations.
BDD representation Boolean function. Given B = {0, 1}, Boolean function
f : Bn B, n arguments, X1 , , Xn , Boolean variables, takes Boolean
values.
Example 3 Figure 3(a) shows table representation Boolean function three variables.
explicit representation straightforward, costly due exponential
requirements. function represented binary tree, shown Figure 3(b),
exponential size number variables. internal round nodes represent
variables, solid edges 1 (or high) value, dotted edges 0 (or low) value.
leaf square nodes show value function assignment along path. tree
shown 3(b) unordered, variables appear order along path.
building OBDD, first condition variables appear order (A,B,C)
along every path root leaves. Figure 3(c) shows ordered binary tree function.
order imposed, two reduction rules transform decision diagram
equivalent one:
(1) isomorphism: merge nodes label children.
(2) redundancy: eliminate nodes whose low high edges point node, connect
parent removed node directly child removed node.
Applying two reduction rules exhaustively yields reduced OBDD, sometimes denoted
rOBDD. use OBDD assume completely reduced.
Example 4 Figure 4(a) shows binary tree Figure 3(c) isomorphic terminal nodes
(leaves) merged. highlighted nodes, labeled C, isomorphic, Figure
4(b) shows result merged. Now, highlighted nodes labeled C B
redundant, removing gives OBDD Figure 4(c).
2.3 Bucket Elimination Review
Bucket Elimination (BE) (Dechter, 1999) well known variable elimination algorithm inference graphical models. describe using terminology constraint networks,
473

fiM ATEESCU , ECHTER & ARINESCU





B

B

C

C

C

0

1



B

C

B

C

C

0

(a) Isomorphic nodes

B

C

1

0

(b) Redundant nodes

1

(c) OBDD

Figure 4: Reduction rules
A:


C1(AC)
C2(AB)
C3(ABE)

B

C

C4(BCD)

h4(A)

B:

C2(AB)

E:

C3(ABE)



h3(AB)

h2(AB)

AB bucket-B
AB

ABE

C:
E



(a) Constraint network

D:

C1(AC)

h1(BC)

bucket-A



bucket-E

AB

ABC bucket-C
BC

BCD bucket-D

C4 (BCD)

(b) execution

(c) Bucket tree

Figure 5: Bucket Elimination
applied graphical model. Consider constraint network R = hX, D, Ci
ordering = (X1 , X2 , . . . , Xn ). ordering dictates elimination order BE, last
first. variable associated bucket. constraint C placed bucket
latest variable d. Buckets processed Xn X1 eliminating bucket variable (the
constraints residing bucket joined together, bucket variable projected out)
placing resulting constraint (also called message) bucket latest variable d.
execution, renders network backtrack free, solution produced assigning
variables along d. produce solutions count marginalization done summation
(rather projection) functional representation constraints, join substituted
multiplication.
constructs bucket tree, linking bucket Xi destination bucket
message (called parent bucket). node bucket tree typically bucket variable,
collection constraints, scope (the union scopes constraints). nodes
bucket tree replaced respective bucket variables, easy see obtain pseudo
tree.
Example 5 Figure 5(a) shows network four constraints. Figure5(b) shows execution
Bucket Elimination along = (A, B, E, C, D). buckets processed A.2 Figure
5(c) shows bucket tree. pseudo tree corresponding order given Fig. 6(a).
2. representation Figure 5 reverses top bucket processing described earlier papers (Dechter, 1999).

474

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

Procedure GeneratePseudoTree(G, d)
1
2
3
4
5

input : graph G = (X, E); order = (X1 , . . . , Xn )
output : Pseudo tree
Make X1 root
Condition X1 (eliminate X1 incident edges G). Let G1 , . . . , Gp resulting connected
components G
= 1 p
Ti = GeneratePseudoTree (Gi , d|Gi )
Make root Ti child X1

6 return

2.4 Orderings Pseudo Trees
Given ordering d, structural information captured primal graph scopes
functions F = {f1 , . . . , fr } used create unique pseudo tree corresponds
(Mateescu & Dechter, 2005). precisely bucket tree (or elimination tree),
created (when variables processed reverse d). pseudo tree created
conditioning primal graph, processing variables order d, described Procedure
GeneratePseudoTree. following, d|Gi restriction order nodes
graph Gi .

3. Overview AND/OR Search Space Graphical Models
AND/OR search space recently introduced (Dechter & Mateescu, 2004a, 2004b, 2007)
unifying framework advanced algorithmic schemes graphical models. main virtue consists exploiting independencies variables search, provide exponential
speedups traditional search methods oblivious problem structure. Since AND/OR MDDs
based AND/OR search spaces need provide comprehensive overview sake
completeness.
3.1 AND/OR Search Trees
AND/OR search tree guided pseudo tree primal graph. idea exploit
problem decomposition independent subproblems search. Assigning value
variable (also known conditioning), equivalent graph terms removing variable (and
incident edges) primal graph. partial assignment therefore lead decomposition
residual primal graph independent components, searched (or solved)
separately. pseudo tree captures precisely decompositions given order variable
instantiation.
EFINITION 11 (AND/OR search tree graphical model) Given graphical model =
hX, D, Fi, primal graph G pseudo tree G, associated AND/OR search tree
alternating levels nodes. nodes labeled Xi correspond
variables. nodes labeled hXi , xi (or simply xi ) correspond value assignments.
structure AND/OR search tree based . root node labeled
root . children node Xi nodes labeled assignments hXi , xi

475

fiM ATEESCU , ECHTER & ARINESCU





B

1

B

B

0
E

E

0

C



1
C

0 1

E

0

1


0 1

(a) Pseudo tree

0 1

0
C

E

0

1





0 1

0 1

0 1

1
C

E

0

1





0 1

0 1

0 1

C
0

1







0 1

0 1

0 1

(b) Search tree

Figure 6: AND/OR search tree
consistent assignments along path root. children node
hXi , xi nodes labeled children variable Xi pseudo tree .
Example 6 Figure 6 shows example AND/OR search tree graphical model given
Figure 5(a), assuming tuples consistent, variables binary valued. tuples
inconsistent, paths tree exist. Figure 6(a) gives pseudo tree
guides search, top bottom, indicated arrows. dotted arcs backarcs
primal graph. Figure 6(b) shows AND/OR search tree, alternating levels
(circle) (square) nodes, structure indicated pseudo tree.
AND/OR search tree traversed depth first search algorithm, thus using linear
space. already shown (Freuder & Quinn, 1985; Bayardo & Miranker, 1996; Darwiche, 2001;
Dechter & Mateescu, 2004a, 2007) that:
HEOREM 1 Given graphical model n variables, pseudo tree depth m,
size AND/OR search tree based O(n k ), k bounds domains variables.
graphical model treewidth w pseudo tree depth w log n, therefore

AND/OR search tree size O(n k w log n ).
AND/OR search tree expresses set possible assignments problem variables
(all solutions). difference traditional search space solution longer
path root leaf, rather tree, defined follows:
EFINITION 12 (solution tree) solution tree AND/OR search tree contains root node.
every node, contains one child nodes nodes contains
child nodes, leaf nodes consistent.
3.2 AND/OR Search Graph
AND/OR search tree may contain nodes root identical subproblems. nodes said
unifiable. unifiable nodes merged, search space becomes graph. size
becomes smaller expense using additional memory search algorithm. depth first
search algorithm therefore modified cache previously computed results, retrieve
nodes encountered again. notion unifiable nodes defined formally next.

476

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

EFINITION 13 (minimal AND/OR graph, isomorphism) Two AND/OR search graphs G G0
isomorphic exists one one mapping vertices G vertices G0
vertex v, (v) = v 0 , v v 0 root identical subgraphs relative .
AND/OR graph called minimal isomorphic subgraphs merged. Isomorphic nodes
(that root isomorphic subgraphs) said unifiable.
shown Dechter Mateescu (2007) that:
HEOREM 2 graphical model unique minimal AND/OR search graph relative
pseudo-tree .
minimal AND/OR graph graphical model G relative pseudo tree denoted
MT (G). Note definition minimality used work Dechter Mateescu (2007)
based isomorphism reduction. extend including elimination
redundant nodes. previous theorem shows given AND/OR graph, merge
operator fixed point, minimal AND/OR graph. show paper
AOMDD canonical representation, namely two equivalent graphical models
represented unique AOMDD given accept pseudo tree,
AOMDD minimal terms number nodes.
unifiable nodes identified based contexts. define graph based
contexts nodes nodes, expressing set ancestor variables
completely determine conditioned subproblem. However, shown using caching
based contexts makes caching based contexts redundant vice versa,
use caching. value assignment context X separates subproblem X
rest network.
EFINITION 14 (OR context) Given pseudo tree AND/OR search space,
context(X) = [X1 . . . Xp ] set ancestors X , ordered descendingly, connected primal graph X descendants X.
EFINITION 15 (context unifiable nodes) Given AND/OR search graph, two nodes n1
n2 context unifiable variable label X assignments
contexts identical. Namely, 1 partial assignment variables along path n1 ,
2 partial assignment variables along path n2 , restriction context
X same: 1 |context(X) = 2 |context(X) .
depth first search algorithm traverses AND/OR search tree, modified
traverse graph, enough memory available. could allocate cache table variable X,
scope table context(X). size cache table X therefore product
domains variables context. variable X, possible assignment
context, corresponding conditioned subproblem solved computed
value saved cache table, whenever context assignment encountered again,
value subproblem retrieved cache table. algorithm traverses
called context minimal AND/OR graph.
EFINITION 16 (context minimal AND/OR graph) context minimal AND/OR graph obtained AND/OR search tree merging context unifiable nodes.
477

fiM ATEESCU , ECHTER & ARINESCU

R

F

G

B

[]

C


J

K

[C]

H

[C]

L

[CK]



[CH]

N

[CKL]

B

[CHA]



[CKLN]

P

[CKO]

H
E
C



L

E

[CHAB]

R

[HAB]

J

[CHAE]

F

[AR]



[CEJ]

G

[AF]



[CD]

K

N
P


(a) Primal graph

(b) Pseudo tree
C

0

0

K

H

K

0

1

0

1

L

L

L

L

H

0

1



0



1





0

1

0

1

0

1

0

1

0

1

0

1

0

1

0

1

N

N

N

N

N

N

N

N

B

B

B

B

B

B

B

B

0

1

0

1

0

1

0

1

0

1

0

1

0

1

0

1

































0

E

0

1

E

E

E

0

1

E

E

E

0

1

E

E

E

E

0

1

E

E

E

E

1

E

0

0

1

R

R

R

0

1

R

R

R

R

1

R

0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
0 1 0 1 0 1 0 1 0 1
P

P

P

P

P

P

P

0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1

0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1

P
J

J

J

J

J

J

J

J

J

J

J

J

J

J

J

J

0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1









0 1 0 1 0 1 0 1







F

F

F

F

0 1 0 1 0 1 0 1



0 1 0 1 0 1 0 1

G

G

G

G

0 1 0 1 0 1 0 1








0 1 0 1 0 1 0 1

(c) Context minimal graph

Figure 7: AND/OR search graph
already shown (Bayardo & Miranker, 1996; Dechter & Mateescu, 2004a, 2007) that:
HEOREM 3 Given graphical model M, primal graph G pseudo tree , size
context minimal AND/OR search graph based , therefore size minimal AND/OR

search graph, O(n k wT (G) ), wT (G) induced width G depth first traversal
, k bounds domain size.

Example 7 Lets look impact caching size search space examining larger
example. Figure 7(a) shows graphical model binary variables Figure 7(b) pseudo tree
drives AND/OR search. context node given square brackets. context
minimal graph given Figure 7(c). Note far smaller AND/OR search tree,
28 = 256 nodes level alone (because depth 8 pseudo tree).
shaded rectangles show size cache table, equal number nodes
appear one. cache entry useful whenever one incoming edges
node. Incidentally, caches useful (namely nodes one incoming
arc), called dead caches (Darwiche, 2001), determined based pseudo
478

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

tree inspection, therefore cache table need allocated them. context minimal graph
explain execution along pseudo tree (or, equivalently, along depth
first traversal order). buckets shaded rectangles, processing done bottom up.
number possible assignments bucket equals number nodes appear
it. message scope identical context bucket variable, message
identical corresponding cache table. details relationship AND/OR
search see work Mateescu Dechter (2005).
3.3 Weighted AND/OR Graphs
previous subsections described structure AND/OR trees graphs. order
use solve reasoning task, need define way using input function values
traversal AND/OR graph. realized placing weights (or costs)
OR-to-AND arcs, dictated function values. functions relevant contribute
OR-to-AND arc weight, captured buckets relative pseudo tree:
EFINITION 17 (buckets relative pseudo tree) Given graphical model = hX, D, F,
pseudo tree , bucket Xi relative , denoted BT (Xi ), set functions whose
scopes contain Xi included pathT (Xi ), set variables root Xi
. Namely,
BT (Xi ) = {f F|Xi scope(f ), scope(f ) pathT (Xi )}.

function belongs bucket variable Xi iff scope fully instantiated
Xi assigned. Combining values functions bucket, current assignment, gives weight OR-to-AND arc:
EFINITION 18 (OR-to-AND weights) Given AND/OR graph graphical model M,
weight w(n,m) (Xi , xi ) arc (n, m) Xi labels n xi labels m, combination
functions BT (Xi ) assigned values along current path node m, .
Formally, w(n,m) (Xi , xi ) = f BT (Xi ) f (asgn(m )[scope(f )]).
EFINITION 19 (weight solution tree) Given weighted AND/OR graph graphical model
M, given solution tree OR-to-AND set arcs arcs(t), weight defined
w(t) = earcs(t) w(e).
Example 8 start straightforward case constraint networks. Since functions
take values 0 1, combination product (join relations), follows ORto-AND arc weight 0 1. example given Figure 8. Figure 8(a) shows
constraint graph, 8(b) pseudo tree it, 8(c) four relations define constraint
problem. Figure 8(d) shows AND/OR tree traversed depth first search algorithm
checks consistency input functions (i.e., constraint propagation used).
Similar OBDD representation, OR-to-AND arcs weight 0 denoted dotted
lines, tree unfolded them, since contain solution. arcs
weight 1 drawn solid lines.
479

fiM ATEESCU , ECHTER & ARINESCU


B
C





F

B

E

(a) Constraint graph

0
0
0
0
1
1
1
1

B
0
0
1
1
0
0
1
1

B
0
0
0
0
1
1
1
1

C RABC
0
1
1
1
0
0
1
1
0
1
1
1
0
1
1
0

C
0
0
1
1
0
0
1
1

C

E



F

(b) Pseudo tree

RBCD
0
1
1
1
0
1
1
0
0
1
1
0
0
1
1
1


0
0
0
0
1
1
1
1

B
0
0
1
1
0
0
1
1

E RABE
0
1
1
0
0
1
1
1
0
0
1
1
0
1
1
0


0
0
0
0
1
1
1
1

E
0
0
1
1
0
0
1
1

F RAEF
0
0
1
1
0
1
1
1
0
1
1
1
0
1
1
0

(c) Relations


1

1

0

1

B

B

1

1

1
1

0
C

C

E

1
1

0
C

E

C

E

E

1

1

1

0

0

1

1

1

1

1

0

1

1

0

1

0

0

1

0

1

0

1

0

1

0

1

0

1

0

1

0

1







F

1

1 1

0 0

1

0

1

1

1

0

0

1
0

F



F

1 0

1 1

1

1

1

1

1

0

0

0





F

F

1 1

0

1

0

1

0

1

1

0

1

0

1

0

1
0

1
1

(d) AND/OR tree

Figure 8: AND/OR search tree constraint networks
Example 9 Figure 9 shows weighted AND/OR tree belief network. Figure 9(a) shows
directed acyclic graph, dotted arc BC added moralization. Figure 9(b) shows pseudo
tree, 9(c) shows conditional probability tables. Figure 9(d) shows weighted AND/OR
tree.
constraint networks, move weighted AND/OR search trees
weighted AND/OR search graphs merging unifiable nodes. case arc labels
considered determining unifiable subgraphs. yield context-minimal weighted
AND/OR search graphs minimal weighted AND/OR search graphs.

4. AND/OR Multi-Valued Decision Diagrams (AOMDDs)
section begin describing contributions paper. context minimal AND/OR
graph (Definition 16) offers effective way identifying unifiable nodes execution search algorithm. Namely, context unifiable nodes discovered based
paths root, without actually solving corresponding subproblems. However, merging based context complete, means may still exist unifiable nodes
search graph identical contexts. Moreover, nodes context
480

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

P(A)




0
1



P(B | A)

P(A)
.6
.4


0
1

P(C | A)

0
1

B=1
.6
.9

B=0
.4
.1

P(D | B,C)

B
B

B
0
0
1
1

C

E
E

C




(a) Belief network

C
0
1
0
1

P(E | A,B)
D=1
.8
.9
.7
.5

D=0
.2
.1
.3
.5

C=1
.8
.3

C=0
.2
.7

(b) Pseudo tree


0
0
1
1

B
0
1
0
1

E=0
.4
.5
.7
.2

E=1
.6
.5
.3
.8

(c) CPTs



.6

.4

0

1

B

B

.4
0

0

C

.6
1

E

.2

.8

.5

0

1

0



.2
0

1



.8
1

.1
0

.2

.8

.7

0

1

0



.9
1

.3
0

C

0

E

.3

.7

.3

1

0

1





.7 .5
1

1

E

C

.5

.9

0

1

E

.4

.1

.6

.2

.5

0

1

.2
0

C

.8

.7

.3

1

0

1



.8
1



.1
0

.9
1

.3
0



.7 .5
1

0

.5
1

(d) Weighted AND/OR tree

Figure 9: Weighted AND/OR search tree belief networks
minimal AND/OR graph may redundant, example set solutions rooted variable Xi dependant specific value assigned Xi (this situation detectable based
context). sometimes termed interchangeable values symmetrical values.
overviewed earlier, Dechter Mateescu (2007, 2004a) defined complete minimal AND/OR
graph AND/OR graph whose unifiable nodes merged, Dechter Mateescu
(2007) proved canonicity non-weighted graphical models.
paper propose augment minimal AND/OR search graph removing redundant variables common OBDD representation well adopt notational conventions
common community. yields data structure call AND/OR BDD, exploits
decomposition using nodes. present extension multi-valued variables yielding
AND/OR MDD AOMDD define general weighted graphical models. Subsequently
present two algorithms compiling canonical AOMDD graphical model: first
search-based, uses memory intensive AND/OR graph search generate context minimal
AND/OR graph, reduces bottom applying reduction rules; second inferencebased, uses Bucket Elimination schedule combine AOMDDs initial functions
APPLY operations (similar apply OBDDs). show, approaches
worst case complexity AND/OR graph search context based caching,
complexity Bucket Elimination, namely time space exponential treewidth

problem, O(n k w ). benefit generation schemes discussed.

481

fiM ATEESCU , ECHTER & ARINESCU





1

(a) OBDD

2



k

(b) MDD

Figure 10: Decision diagram nodes (OR)




1







(a) AOBDD

2

k







(b) AOMDD

Figure 11: Decision diagram nodes (AND/OR)
4.1 AND/OR Search Graphs Decision Diagrams
AND/OR search graph G graphical model = hX, D, F, represents set
possible assignments problem variables (all solutions costs). sense, G
viewed representing function f = F defines universal equivalent graphical
model u(M) (Definition 2). full assignment x = (x1 , . . . , xn ), x solution expressed
tree tx , f (x) = w(tx ) = earcs(tx ) w(e) (Definition 19); otherwise f (x) = 0 (the
assignment inconsistent). solution tree tx consistent assignment x read G
linear time following assignments root. x inconsistent, dead-end
encountered G attempting read solution tree tx , f (x) = 0. Therefore, G
viewed decision diagram determines values f every complete assignment x.
see process AND/OR search graph reduction rules similar
case OBDDs, order obtain representation minimal size. case OBDDs,
node labeled variable name, example A, low (dotted line) high (solid
line) outgoing arcs capture restriction function assignments = 0 = 1.
determine value function, one needs follow either one (but both)
outgoing arcs (see Figure 10(a)). straightforward extension OBDDs multi-valued
variables (multi-valued decision diagrams, MDDs) presented Srinivasan, Kam, Malik,
Brayton (1990), node structure use given Figure 10(b). outgoing arc
associated one k values variable A.
paper generalize OBDD MDD representations demonstrated Figures 10(a)
10(b) allowing outgoing arc arc. arc connects node set
nodes, captures decomposition problem independent components. number
arcs emanating node two case AOBDDs (Figure 11(a)), domain size
variable general case (Figure 11(b)). given node A, k arcs
connect possibly different number nodes, depending problem decomposes based
particular assignment A. arcs depicted shaded sector connects
outgoing lines corresponding independent components.

482

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS


1



2



k





(a) Nonterminal meta-node

0

1

(b) Terminal meta-node 0

(c) Terminal meta-node 1

Figure 12: Meta-nodes
define AND/OR Decision Diagram representation based AND/OR search graphs.
find useful maintain semantics Figure 11 especially need express
redundancy nodes, therefore introduce meta-node data structure, defines small
portions AND/OR graph, based node children:
EFINITION 20 (meta-node) meta-node u AND/OR search graph either: (1)
terminal node labeled 0 1, (2) nonterminal node, consists node labeled
X (therefore var(u) = X) k children labeled x1 , . . . , xk correspond value
assignments X. node labeled xi stores list pointers child meta-nodes, denoted
u.childreni . case weighted graphical models, node xi stores OR-toAND arc weight w(X, xi ).
rectangle Figure 12(a) meta-node variable A, domain size k. Note
similar Figure 11, small difference information value
corresponds outgoing arc stored nodes meta-node.
showing weights figure. larger example AND/OR graph meta-nodes
appears later Figure 16.
terminal meta-nodes play role terminal nodes OBDDs. terminal metanode 0, shown Figure 12(b), indicates inconsistent assignments, terminal meta-node 1,
shown figure 12(c) indicates consistent ones.
AND/OR search graph viewed diagram meta-nodes, simply grouping
nodes children, adding terminal meta-nodes appropriately.
defined meta-nodes, easier see variable redundant respect outcome function based current partial assignment. variable redundant
assignments leads set solutions.
EFINITION 21 (redundant meta-node) Given weighted AND/OR search graph G represented
meta-nodes, meta-node u var(u) = X |D(X)| = k redundant iff:
(a) u.children1 = . . . = u.childrenk
(b) w(X, x1 ) = . . . = w(X, xk ).
AND/OR graph G, contains redundant meta-node u, transformed equivalent graph G 0 replacing incoming arc u common list children u.children1 ,
absorbing common weight w(X, x1 ) combination weight parent meta-node
corresponding incoming arc, removing u outgoing arcs G.
value X = x1 picked arbitrarily, isomorphic. u root
483

fiM ATEESCU , ECHTER & ARINESCU

Procedure RedundancyReduction
: AND/OR graph G; redundant meta-node u, var(u) = X; List meta-node parents u,
denoted P arents(u).
output : Reduced AND/OR graph G elimination u.
1 P arents(u) empty
2
return independent AND/OR graphs rooted meta-nodes u.children1 , constant w(X, x1 )
input

3 forall v P arents(u) (assume var(v) == )
4
forall {1, . . . , |D(Y )|}
5
u v.childreni
6
v.childreni v.childreni \ {u}
7
v.childreni v.childreni u.children1
8
w(Y, yi ) w(Y, yi ) w(X, x1 )
9 remove u
10 return reduced AND/OR graph G

Procedure IsomorphismReduction
: AND/OR graph G; isomorphic meta-nodes u v; List meta-node parents u, denoted
P arents(u).
output : Reduced AND/OR graph G merging u v.
forall p P arents(u)
u p.childreni
p.childreni p.childreni \ {u}
p.childreni p.childreni {v}

input

1
2
3
4

5 remove u
6 return reduced AND/OR graph G

graph, common weight w(X, x1 ) stored separately constant. Procedure
RedundancyReduction formalizes redundancy elimination.
EFINITION 22 (isomorphic meta-nodes) Given weighted AND/OR search graph G represented
meta-nodes, two meta-nodes u v var(u) = var(v) = X |D(X)| = k
isomorphic iff:
(a) u.childreni = v.childreni {1, . . . , k}
(b) wu (X, xi ) = wv (X, xi ) {1, . . . , k}, (where wu , wv weights u v).
Procedure IsomorphismReduction formalizes process merging isomorphic metanodes. Naturally, AND/OR graph obtained merging isomorphic meta-nodes equivalent
original one. define AND/OR Multi-Valued Decision Diagram:
EFINITION 23 (AOMDD) AND/OR Multi-Valued Decision Diagram (AOMDD) weighted
AND/OR search graph completely reduced isomorphic merging redundancy removal,
namely:
(1) contains isomorphic meta-nodes;
(2) contains redundant meta-nodes.

484

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS





2k

1

B

c

2



2

k

z


1

1

z

k





c







(b) eliminating B
meta-node

(a) Fragment AOMDD

Figure 13: Redundancy reduction

1



2k

1

2

k

B
1

C

2



2

1

C


1

B

k

1

e

2



k

C


k

2


k

1





(a) Fragment AOMDD

2

k

e





(b) merging isomorphic C meta-nodes

Figure 14: Isomorphism reduction
Example 10 Figure 13 shows example applying redundancy reduction rule portion
AOMDD. left side, Figure 13(a), meta-node variable B redundant (we
dont show weights OR-to-AND arcs, avoid cluttering figure). values
{1, . . . , k} B lead set meta-nodes {c, d, . . . , y}, coupled
arc. Therefore, meta-node B eliminated. result shown Figure 13(b),
meta-nodes {c, d, . . . , y} z coupled arc outgoing = 1.
Figure 14 show example applying isomorphism reduction rule. case,
meta-nodes labeled C Figure 14(a) isomorphic (again, omit weights). result
merging shown Figure 14(b).
Examples AOMDDs appear Figures 16, 17 18. Note weight OR-toAND arc zero, descendant terminal meta-node 0. Namely, current path
dead-end, cannot extended solution, therefore linked directly 0.

5. Using AND/OR Search Generate AOMDDs
Section 4.1 described transform AND/OR graph AOMDD applying
reduction rules. Section 5.1 describe explicit algorithm takes input graphi485

fiM ATEESCU , ECHTER & ARINESCU

cal model, performs AND/OR search context-based caching obtain context minimal
AND/OR graph, Section 5.2 give procedure applies reduction rules bottom
obtain AOMDD.
5.1 Algorithm AND/OR-S EARCH -AOMDD
Algorithm 1, called AND/OR-S EARCH -AOMDD, compiles graphical model AOMDD.
memory intensive (with context-based caching) AND/OR search used create context minimal AND/OR graph (see Definition 16). input AND/OR-S EARCH -AOMDD graphical
model pseudo tree , defines OR-context variable.
variable Xi associated cache table, whose scope context Xi .
ensures trace search context minimal AND/OR graph. list denoted LXi
(see line 35), used variable Xi save pointers meta-nodes labeled Xi .
lists used procedure performs bottom reduction, per layers AND/OR
graph (one layer contains nodes labeled one given variable). fringe search
maintained stack called OPEN. current node (either node) denoted
n, parent p, current path n . children current node denoted
successors(n). node n, Boolean attribute consistent(n) indicates current path
extended solution. information useful pruning search space.
algorithm based two mutually recursive steps: Forward (beginning line 5)
Backtrack (beginning line 29), call (or themselves) search terminates.
forward phase, AND/OR graph expanded top down. two types nodes,
OR, treated differently according semantics.
node expanded, cache table variable checked (line 8). entry
null, link created already existing node roots graph equivalent
current subproblem. Otherwise, node expanded generating descendants.
OR-to-AND weight (see Definition 18) computed line 13. value xi Xi checked
consistency (line 14). least expensive check verify OR-to-AND weight non-zero.
However, deterministic (inconsistent) assignments extracted form constraint
network. level constraint propagation performed step (e.g., look ahead, arc
consistency, path consistency, i-consistency etc.). computational overhead increase,
hope pruning search space aggressively. note constraint propagation
crucial algorithm, complexity guarantees maintained even simple
weight check performed. consistent nodes added list successors n (line
16), inconsistent ones linked terminal 0 meta-node (line 19).
node n labeled hXi , xi expanded (line 20) based structure pseudo
tree. Xi leaf , n linked terminal 1 meta-node (line 22). Otherwise,
node created child Xi (line 24).
forward step continues long current node dead-end still unevaluated
successors. backtrack phase triggered node empty set successors (line 29).
Note that, successor processed, removed set successors line 42.
backtrack reaches root (line 32), search complete, context minimal AND/OR graph
generated, Procedure B OTTOM U P R EDUCTION called.
backtrack step processes node (line 31), saves pointer cache,
adds pointer corresponding meta-node list LXi . consistent attribute

486

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

Algorithm 1: AND/OR EARCH - AOMDD
input : = hX, D, Fi; pseudo tree rooted X1 ; parents pai (OR-context) every variable Xi .
output : AOMDD M.
1 forall Xi X
Initialize context-based cache table CacheXi (pai ) null entries
2
3 Create new node t, labeled Xi ; consistent(t) true; push top OPEN
4 OPEN 6=
5
n top(OPEN); remove n OPEN
// Forward
6
successors(n)
7
n node labeled Xi
// OR-expand
CacheXi (asgn(n )[pai ]) 6= null
8
Connect parent n CacheXi (asgn(n )[pai ])
9
// Use cached pointer
10
11
12
13
14
15
16
17
18
19

else
forall xi Di
Create new node t, labeled hXi , xi
w(X, xi )

f (asgn(n )[pai ])
f BT (Xi )

hXi , xi consistent n
consistent(t) true
add successors(n)
else
consistent(t) f alse
make terminal 0 child

20
21
22
23
24
25
26
27

n node labeled hXi , xi
childrenT (Xi ) ==
make terminal 1 child n
else
forall childrenT (Xi )
Create new node t, labeled
consistent(t) f alse
add successors(n)

28
29
30
31
32
33

Add successors(n) top OPEN
successors(n) ==
let p parent n
n node labeled Xi
Xi == X1
Call BottomUpReduction procedure

34
35
36
37
38
39

// Constraint Propagation

// AND-expand

// Backtrack

// Search complete
// begin reduction AOMDD

Cache(asgn(n )[pai ]) n
Add meta-node n list LXi
consistent(p) consistent(p) consistent(n)
consistent(p) == f alse
remove successors(p) OPEN
successors(p)

40
41

n node labeled hXi , xi
consistent(p) consistent(p) consistent(n);

42
43

remove n successors(p)
np

487

// Save cache

// Check p dead-end

fiM ATEESCU , ECHTER & ARINESCU

Procedure BottomUpReduction
: graphical model = hX, D, Fi; pseudo tree primal graph, rooted X1 ; Context
minimal AND/OR graph, lists LXi meta-nodes level Xi .
output : AOMDD M.
Let = {X1 , . . . , Xn } depth first traversal ordering
n 1
Let H hash table, initially empty
forall meta-nodes n LXi
H(Xi , n.children1 , . . . , n.childrenki , wn (Xi , x1 ), . . . , wn (Xki , xki )) returns meta-node
p
merge n p AND/OR graph
input

1
2
3
4
5
6
7
8
9
10
11
12

else n redundant
eliminate n AND/OR graph
combine weight parent
else
hash n table H:
H(Xi , n.children1 , . . . , n.childrenki , wn (Xi , x1 ), . . . , wn (Xki , xki )) n

13 return reduced AND/OR graph

parent p updated conjunction consistent(n). parent p becomes
inconsistent, necessary check remaining successors (line 38). backtrack
step processes node (line 40), consistent attribute parent p updated
disjunction consistent(n).
AND/OR search algorithm usually maintains value node, corresponding task
solved. include values description AOMDD equivalent
representation original graphical model M. task solved traversal
AOMDD. however user include information meta-nodes (e.g.,
number solutions subproblem).
5.2 Reducing Context Minimal AND/OR Graph AOMDD
Procedure BottomUpReduction processes variables bottom relative pseudo tree .
use depth first traversal ordering (line 1), bottom ordering good.
outer loop (starting line 2) goes level context minimal AND/OR graph
(where level contains nodes labeled variable, words
contains meta-nodes variable). efficiency, ensure complexity guarantees
prove, hash table, initially empty, used level. inner loop (starting
line 4) goes metanodes level, saved (or pointers saved)
list LXi . new meta-node n list LXi , line 5 hash table H checked
verify node isomorphic n already exists. hash table H already contains node p corresponding hash key (Xi , n.children1 , . . . , n.childrenki , wn (Xi , x1 ), . . . , wn (Xki , xki )),
p n isomorphic merged. Otherwise, new meta-node n redundant,
eliminated AND/OR graph. none previous two conditions met,
new meta-node n hashed table H.

488

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS




G

C

B

F

E



H

B
C


(a)

F
E

G

H

(b)

Figure 15: (a) Constraint graph C = {C1 , . . . , C9 }, C1 = F H, C2 = H,
C3 = B G, C4 = F G, C5 = B F , C6 = E, C7 = C E, C8 = C D,
C9 = B C; (b) Pseudo tree (bucket tree) ordering = (A, B, C, D, E, F, G, H)

Proposition 1 output Procedure BottomUpReduction AOMDD along
pseudo tree , namely resulting AND/OR graph completely reduced.
Note explicated Procedure BottomUpReduction separately clarity. practice, actually included Algorithm AND/OR-S EARCH -AOMDD, reduction rules
applied whenever search backtracks. maintain hash table variable, AND/OR search, store pointers meta-nodes. search backtracks
node, already check redundancy meta-node, look hash table
check isomorphism. Therefore, reduction AND/OR graph done
AND/OR search, output AOMDD M.
Theorem 3 Proposition 1 conclude:
HEOREM 4 Given graphical model pseudo tree primal graph G, AOMDD

corresponding size bounded O(n k wT (G) ) computed Algorithm

AND/OR-S EARCH -AOMDD time O(n k wT (G) ), wT (G) induced width G
depth first traversal , k bounds domain size.

6. Using Bucket Elimination Generate AOMDDs
section propose use Bucket Elimination (BE) type algorithm guide compilation
graphical model AOMDD. idea express graphical model functions
AOMDDs, combine APPLY operations based schedule. APPLY
similar OBDDs (Bryant, 1986), adapted AND/OR search graphs.
takes input two functions represented AOMDDs based pseudo tree, outputs
combination initial functions, represented AOMDD based pseudo tree.
describe detail Section 6.2.
start example based constraint networks. easier understand
weights arcs 1 0, therefore depicted figures solid dashed
lines, respectively.
Example 11 Consider network defined X = {A, B, . . . , H}, DA = . . . = DH = {0, 1}
constraints (where denotes XOR): C1 = F H, C2 = AH, C3 = ABG, C4 = F G,
489

fiM ATEESCU , ECHTER & ARINESCU

m7



m7



0

0

1

B
0

1

0

C
0

C
1

0

1

0

0

1

C
1

0



1

B

B

0

0

F

C
1

B
1

0

1

F
1

0

1

F
1

B

F

0

1

0

1

B

C

0



G

E
1

0

0

0

1

0

1

m6

G
1

0

H
1

0

0

1



E

1

m3

F

H
1

G

m3

m6


0

0

B

C

0

C
0



1

0

1


1

0

0

C

C
1

0

0

F

B

0

1

0



1

0

0

G

1

0

0

1

0

0

H
0

1

B

F
1

G
1

1

F

F

1

F
0

1



B
1

B
1

E


1

1

B



0

H

1

H
1

0

F
1

C

0 1

0

1

0

m5

C9

C

0

E

0

C


1

0

0

0

E



1

C
1

0

1

0

0

1

G

1

0

1

0

C



0 1

C6

C7

1

0

1

0

1

0

1

0

B

H

0 1

1


1

0

H

1

G

E

C3

0

1



1

G
0

G

F

F
0

B

G

H

m1

m1

1

B

0 1

C8

m2





1

E

E

1

0

C5

m2


1







m4

m5
0

0 1

1
m4

C4

0

H
1

0

F

1

F

0 1

0 1

G

C1

C2

H

Figure 16: Execution AOMDDs

0



1

B
0

B
1

0

B

1

B

C
C
0

C
1

0

C
1

0

C
1

0

F
1

0

F
1

0

F
1

0

C

1

0



1



E


0


1

0

E
1

0

G
1

0

G
1

0

H
1

0

C

C

F

0





E

F

H
1



E

F

F

F

1

G

G

G

G

H

0



1

H

1

(a)

G

0

(b)

Figure 17: (a) final AOMDD; (b) OBDD corresponding
C5 = B F , C6 = E, C7 = C E, C8 = C D, C9 = B C. constraint graph
shown Figure 15(a). Consider ordering = (A, B, C, D, E, F, G, H). pseudo tree (or
bucket tree) induced given Fig. 15(b). Figure 16 shows execution AOMDDs
along ordering d. Initially, constraints C1 C9 represented AOMDDs placed
bucket latest variable d. scope original constraint always appears

490

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

Algorithm 2: BE-AOMDD
: Graphical model = hX, D, Fi, X = {X1 , . . . , Xn }, F = {f1 , . . . , fr } ; order
= (X1 , . . . , Xn )
output : AOMDD representing
1 = GeneratePseudoTree(G, d);
2 1 r
// place functions buckets
3
place Gfaomdd


bucket


latest
variable



input

4 n 1
message(Xi ) G1aomdd
5
6
bucket(Xi ) 6=
7
pick Gfaomdd bucket(Xi );
8
9
10

// process buckets
// initialize AOMDD 1 ;
// combine AOMDDs bucket Xi

bucket(Xi ) bucket(Xi ) \ {Gfaomdd };
message(Xi ) APPLY(message(Xi ), Gfaomdd )
add message(Xi ) bucket parent Xi

11 return message(X1 )

path root leaf pseudo tree. Therefore, original constraint represented
AOMDD based chain (i.e., branching independent components point).
chain scope constraint, ordered according d. bi-valued variables,
original constraints represented OBDDs, multiple-valued variables MDDs. Note
depict meta-nodes: one node two children, appear inside gray
node. dotted edge corresponds 0 value (the low edge OBDDs), solid edge
1 value (the high edge). redundancy notation, keeping value nodes
arc-types (dotted arcs 0 solid arcs 1).
scheduling used process buckets reverse order d. bucket processed
joining AOMDDs inside it, using APPLY operator. However, step elimination
bucket variable omitted want generate full AOMDD. example,
messages m1 = C1 ./ C2 m2 = C3 ./ C4 still based chains, therefore
OBDDs. Note contain variables H G, eliminated. However,
message m3 = C5 ./ m1 ./ m2 OBDD anymore. see follows
structure pseudo tree, F two children, G H. nodes corresponding
F two outgoing edges value 1.
processing continues manner. final output algorithm, coincides
m7 , shown Figure 17(a). OBDD based ordering shown Fig.
17(b). Notice AOMDD 18 nonterminal nodes 47 edges, OBDD 27
nonterminal nodes 54 edges.
6.1 Algorithm BE-AOMDD
Algorithm 2, called BE-AOMDD, creates AOMDD graphical model using schedule APPLY operations. Given order variables, first pseudo tree created based
,
primal graph. initial function represented AOMDD, denoted Gfaomdd

placed bucket. obtain AOMDD function, scope function ordered
according d, search tree (based chain) represents generated, reduced
Procedure BottomUpReduction. algorithm proceeds exactly BE, difference combination functions realized APPLY algorithm, variables
491

fiM ATEESCU , ECHTER & ARINESCU

eliminated carried destination bucket. messages buckets initialized
dummy AOMDD 1, denoted G1aomdd , neutral combination.
order create compilation graphical model based AND/OR graphs, necessary
traverse AND/OR graph top bottom up. similar inward outward
message passing tree decomposition. Note BE-AOMDD describes bottom traversal
explicitly, top phase actually performed APPLY operation. two
AOMDDs combined, top chain portion pseudo tree processed, remaining
independent branches attached participate newly restricted set solutions.
amounts exchange information independent branches, equivalent
top phase.
6.2 AOMDD APPLY Operation
describe combine two AOMDDs. APPLY operator takes input two
AOMDDs representing functions f1 f2 returns AOMDD representing f1 f2 .
OBDDs apply operator combines two input diagrams based variable ordering.
Likewise, order combine two AOMDDs assume pseudo trees identical.
condition satisfied two AOMDDs bucket BE-AOMDD. However,
present version APPLY general, relaxing previous condition
identical compatible pseudo trees. Namely, pseudo tree
embedded. general, pseudo tree induces strict partial order variables
parent node always precedes child nodes.
EFINITION 24 (compatible pseudo trees) strict partial order d1 = (X, <1 ) set X
consistent strict partial order d2 = (Y, <2 ) set Y, x1 , x2 X Y,
x1 <2 x2 x1 <1 x2 . Two partial orders d1 d2 compatible iff exists partial
order consistent both. Two pseudo trees compatible iff partial orders induced
via parent-child relationship, compatible.
simplicity, focus restricted notion compatibility, sufficient
using schedule APPLY operator combine input AOMDDs (as described
Section 6). APPLY algorithm present extended general notion
compatibility.
EFINITION 25 (strictly compatible pseudo trees) pseudo tree T1 set nodes X1
embedded pseudo tree set nodes X X1 X T1 obtained
deleting node X \ X1 connecting parent descendents. Two
pseudo trees T1 T2 strictly compatible exists T1 T2
embedded .
Algorithm APPLY (algorithm 3) takes input one node Gfaomdd list nodes
Ggaomdd . Initially, node Gfaomdd root node, list nodes Ggaomdd fact
made one node, root. sometimes identify AOMDD root
node. pseudo trees Tf Tg strictly compatible, target pseudo tree .
list nodes Ggaomdd always special property: node
ancestor another (we refer variable meta-node). Therefore, list z1 , . . . , zm
492

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

APPLY (v1 ; z1 , . . . , zm )
input : AOMDDs Gfaomdd nodes vi Ggaomdd nodes zj , based strictly compatible pseudo
trees Tf , Tg embedded .
var(v1 ) ancestor var(z1 ), . . . , var(zm ) .
var(zi ) var(zj ) ancestor-descendant relation , 6= j.
output : v1 (z1 . . . zm ), based .
H1 (v1 , z1 , . . . , zm ) 6= null return H1 (v1 , z1 , . . . , zm );
// cache
(any v1 , z1 , . . . , zm 0) return 0
(v1 = 1) return 1
(m = 0) return v1
// nothing combine
create new nonterminal meta-node u
var(u) var(v1 ) (call Xi , domain Di = {x1 , . . . , xki } )
j 1 ki
u.childrenj
// children j-th node u
// assign weight v1
wu (Xi , xj ) wv1 (Xi , xj )
( (m = 1) (var(v1 ) = var(z1 ) = Xi ) )
temp Children z1 .childrenj
// combine input weights
wu (Xi , xj ) wv1 (Xi , xj ) wz1 (Xi , xj )

Algorithm 3:

1
2
3
4
5
6
7
8
9
10
11
12
13
14

else

15
16
17
18
19

group nodes v1 .childrenj temp Children several {v 1 ; z 1 , . . . , z r }
{v 1 ; z 1 , . . . , z r }
APPLY(v 1 ; z 1 , . . . , z r )
(y = 0)
u.childrenj 0; break

20
21

temp Children {z1 , . . . , zm }

else
u.childrenj u.childrenj {y}

22
23
24

(u.children1 = . . . = u.childrenki ) (wu (Xi , x1 ) = . . . = wu (Xi , xki ))
promote wu (Xi , x1 ) parent
return u.children1
// redundancy

25
26

(H2 (Xi , u.children1 , . . . , u.childrenki , wu (Xi , x1 ), . . . , wu (Xki , xki )) 6= null)
return H2 (Xi , u.children1 , . . . , u.childrenki , wu (Xi , x1 ), . . . , wu (Xki , xki ))
// isomorphism

27 Let H1 (v1 , z1 , . . . , zm ) = u
28 Let H2 (Xi , u.children1 , . . . , u.childrenki , w u (Xi , x1 ), . . . , w u (Xki , xki )) = u
29 return u

// add u H1
// add u H2

g expresses decomposition respect , nodes appear different branches.
employ usual techniques OBDDs make operation efficient. First, one
arguments 0, safely return 0. Second, hash table H1 used store nodes
already processed, based nodes (v1 , z1 , . . . , zr ). Therefore, never need
make multiple recursive calls arguments. Third, hash table H2 used detect
isomorphic nodes. typically split separate tables variable. end
recursion, returning value, discover meta-node variable,
children weights already created, dont need store simply
return existing node. fourth, end recursion discover created
redundant node (all children weights same), dont store
it, return instead one identical lists children, promote common weight.
493

fiM ATEESCU , ECHTER & ARINESCU


0
0
0
0
1
1
1
1

B
0
0
1
1
0
0
1
1

C
0
1
0
1
0
1
0
1

f(ABC)
0
0
0
1
0
1
0
1


0
0
0
0
1
1
1
1


B
C



A1
0

0

C

A3

*

0

A4

B2

A5

B3

0

B

B





1


1



C


0

0

0



A1B1
B

1

B4



1

B
0

1

1

g(ABC)
0
0
0
1
0
1
1
0


0

1

0


0
1
0
1
0
1
0
1

B1
1

B

A2

B
0
0
1
1
0
0
1
1

0

B6

=

B

A2B2

B7

0

1

C
0

B5

0

A4B6

1

A4

1

1



B4
1

0

B
0

1



B7
1

0

1

1

Figure 18: Example APPLY operation
Note v1 always ancestor z1 , . . . , zm . consider variable
ancestor itself. self explaining checks performed lines 1-4. Line 2 specific
multiplication, needs changed combination operations. algorithm creates
new meta-node u, whose variable var(v1 ) = Xi recall var(v1 ) highest (closest root)
among v1 , z1 , . . . , zm . Then, possible value Xi , line 7, starts building list
children.
One important steps happens line 15. two lists meta-nodes, one
original AOMDD f g, refer variables, appear .
lists important property mentioned above, nodes ancestors
other. union two lists grouped maximal sets nodes, highest node
set ancestor others. follows root node set belongs one
original AOMDD, say v 1 f , others, say z 1 , . . . , z r g. example,
suppose pseudo tree Fig. 15(b), two lists {C, G, H} f {E, F }
g. grouping line 15 create {C; E} {F ; G, H}. Sometimes, may
case newly created group contains one node. means nothing join
recursive calls, algorithm return, via line 4, single node. on, one
input AOMDDs traversed, important complexity APPLY, discussed
below.
Example 12 Figure 18 shows result combining two Boolean functions operation
(or product). input functions f g represented AOMDDs based chain pseudo
trees, results based pseudo tree expresses decomposition variables
B instantiated. APPLY operator performs depth first traversal two input
AOMDDs, generates resulting AOMDD based output pseudo tree. Similar
case OBDDs, function AOMDD identified root meta-node. example
input meta-nodes labels (A1 , A2 , B1 , B2 , etc.). output meta-node labeled A2 B2
494

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

root diagram represents function obtained combining functions rooted A2
B2 .
6.3 Complexity APPLY BE-AOMDD
provide characterization complexity APPLY, based different criteria.
following propositions inspired results govern OBDD apply complexity,
adapted pseudo tree orderings.
AOMDD along pseudo tree regarded union regular MDDs, restricted
full path root leaf pseudo tree. Let path . Based
definition strictly compatible pseudo trees, corresponding paths Tf Tf Tg Tg .
MDDs f g corresponding Tf Tg combined using regular MDD
apply. process repeated every path . resulting MDDs, one path
need synchronized common parts (on intersection paths). algorithm
proposed processing once, depth first search traversal inputs. Based
construction, give first characterization complexity AOMDD APPLY
governed complexity MDD apply.
Proposition 2 Let 1 , . . . , l set paths enumerated left right let Gfi
Ggi MDDs restricted path , size output AOMDD apply

P
P bounded
| |G | n max |G | |G |. time complexity bounded
| |G |
|G
|G

g
g
g
f
f
f
n maxi |Gfi | |Ggi |.
second characterization complexity given, similar MDD case, terms
total number nodes inputs:
Proposition 3 Given two AOMDDs Gfaomdd Ggaomdd based strictly compatible pseudo trees,
size output APPLY O(| Gfaomdd | | Ggaomdd |).
detail previous proposition follows. Given AOMDDs Gfaomdd Ggaomdd ,
based compatible pseudo trees Tf Tg common pseudo tree , define intersection pseudo tree Tf g obtained following two steps: (1) mark
subtrees whose nodes belong either Tf Tg (the leaves subtree
leaves ); (2) remove subtrees marked step (1) . Steps (1) (2) applied
(that is, recursively). part AOMDD Gfaomdd corresponding variables Tf g
denoted Gff g , similarly Ggaomdd denoted Ggf g .
Proposition 4 time complexity
|Gfaomdd | + |Ggaomdd |).

APPLY

size output O(|Gff g | |Ggf g | +

turn complexity BE-AOMDD algorithm. bucket associated
bucket pseudo tree. top chain bucket pseudo tree variable Xi contains
variables context(Xi ). variables appear bucket pseudo tree,
associated buckets already processed. original functions belong bucket
Xi scope included context(Xi ), therefore associated AOMDDs based
495

fiM ATEESCU , ECHTER & ARINESCU

chains. functions appear bucket Xi messages received independent branches below. Therefore, two functions bucket Xi share variables
context(Xi ), forms top chain bucket pseudo tree. therefore characterize
complexity APPLY terms treewidth, context size bucket variable.
Proposition 5 Given two AOMDDs bucket BE-AOMDD, time space complexity APPLY exponential context size bucket variable
(namely number variables top chain bucket pseudo tree).
bound complexity BE-AOMDD output size:
HEOREM 5 space complexity BE-AOMDD size output AOMDD

O(n k w ), n number variables, k maximum domain size w treewidth

bucket tree. time complexity bounded O(r k w ), r number initial
functions.

7. AOMDDs Canonical Representations
well known OBDDs canonical representations Boolean functions given ordering
variables (Bryant, 1986), namely strict ordering CNF specification
Boolean function yield identical OBDD, property extends MDDs (Srinivasan
et al., 1990). linear ordering variables defines chain pseudo tree captures
structure OBDD MDD. case AOBDDs AOMDDs, canonicity
respect pseudo tree, transitioning total orders (that correspond linear ordering)
partial orders (that correspond pseudo tree ordering). one hand gain ability
compact compiled structure, hand canonicity longer respect
equivalent graphical models, relative graphical models consistent
pseudo tree used. Specifically, start strict ordering generate chain
AOMDD canonical relative equivalent graphical models. however want
exploit additional decomposition use partial ordering captured pseudo-tree create
compact AOMDD. AOMDD however canonical relative equivalent graphical
models accept pseudo tree guided AOMDD. general, AOMDD
viewed flexible framework compilation allows partial total orderings.
Canonicity restricted subset graphical models whose primal graph agrees partial
order relevant larger set orderings consistent pseudo-tree.
following subsection discuss canonicity AOMDD constraint networks.
case general weighted graphical models discussed Section 8.
7.1 AOMDDs Constraint Networks Canonical Representations
case constraint networks straightforward, weights OR-to-AND
arcs 0 1. show equivalent constraint networks, admit
pseudo tree , AOMDD based . start proposition help prove
main theorem.
Proposition 6 Let f function, always zero, defined constraint network X. Given
partition {X1 , . . . , Xm } set variables X (namely, Xi Xj = , 6= j, X =
496

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS




i=1 X ), f = f1 . . . fm f = g1 . . . gm , scope(fi ) = scope(gi ) = X
{1, . . . , m}, = gi {1, . . . , m}. Namely, f decomposed
given partition, decomposition unique.

ready show AOMDDs constraint networks canonical representations
given pseudo tree.
HEOREM 6 (AOMDDs canonical given pseudo tree) Given constraint network,
pseudo tree constraint graph, unique (up isomorphism) AOMDD represents it, minimal number meta-nodes.
constraint network defined relations (or functions). exist equivalent constraint
networks defined different sets functions, even different scope signatures.
However, equivalent constraint networks define function, ask AOMDD
different equivalent constraint networks same. following corollary derived
immediately Theorem 6.
Corollary 1 Two equivalent constraint networks admit pseudo tree
AOMDD based .

8. Canonical AOMDDs Weighted Graphical Models
Theorem 6 ensures AOMDD canonical constraint networks, namely functions
take values 0 1. proof relied fact OR-to-AND weights
0 1, Proposition 6 ensured unique decomposition function defined
constraint network.
section turn general weighted graphical models. first observe Proposition 6 longer valid general functions. valid solutions (having strictly
positive weight) weight decomposed one way product positive
weights.
Therefore raise issue recognizing nodes root AND/OR graphs represent
universal function, even though graphical representation different. see
AOMDD weighted graphical model unique current definitions,
slightly modify obtain canonicity again. note canonicity AOMDDs
weighted graphical models (e.g., belief networks) far less crucial case OBDDs
used formal verification. Even that, sometimes may useful eliminate
redundant nodes, order maintain simpler semantics AND/OR graph represents
model.
loss canonicity AOMDD weighted graphical models happen
weights OR-to-AND arcs, suggest possible way re-enforcing compact
canonical representation needed.
Example 13 Figure 19 shows weighted graphical model, defined two (cost) functions,
f (M, A, B) g(M, B, C). Assuming order (M,A,B,C), Figure 20 shows AND/OR search
tree left. arcs labeled function values, leaves show value
corresponding full assignment (which product numbers arcs path).
497

fiM ATEESCU , ECHTER & ARINESCU




0
0
0
0
1
1
1
1






B
B
C

C


0
0
1
1
0
0
1
1

B f(M,A,B)
0
12
1
5
0
18
1
2
0
4
1
10
0
6
1
4


0
0
0
0
1
1
1
1

B
0
0
1
1
0
0
1
1

C g(M,B,C)
0
3
1
5
0
14
1
12
0
9
1
15
0
7
1
6

Figure 19: Weighted graphical model

0

1

0

1









0

1

B

0

B

5

18

2

0

1

0

1

C

C

5

0

1

36 60

14
0

C

3

5

1

0

1

70 60

54 90

14
0

0

B

4

10

0

C

12

1

B

12

3



C

B

6

1

0

C

C

9

15

7

6

9

15

7

1

0

1

0

1

0

1

0

36 60

70 60

54 90

0

B

12

5

18

2

1

0

1

0

1

C

6
1

28 24

5

0

1

14
0

B

4
0

C

3

1

B

4

C

12

28 24

1

10

6

4

1

0

1

C

C

12

9

15

7

6

1

0

1

0

1

36 60

Figure 20: AND/OR search tree context minimal graph

see either value (0 1) gives rise function (because leaves two
subtrees values). However, two subtrees identified representing
function usual reduction rules. right part figure shows context minimal
graph, compact representation subtree, share parts.
would case method recognizing left right subtrees
corresponding = 0 = 1 represent function. normalizing
values level, processing bottom up. Figure 21 left, values OR-to-AND
arcs normalized, variable, normalization constant promoted
value. Figure 21 right, normalization constants promoted upwards
multiplication. process change value full assignment, therefore
produces equivalent graphs.
see already nodes labeled C merged, producing graph
Figure 22 left. Continuing process obtain AOMDD weighted graph,
shown Figure 22 right.
define AOMDD weighted graphical model follows:
EFINITION 26 (AOMDD weighted graphical model) AOMDD weighted graphical
model AND/OR graph, meta-nodes, that: (1) meta-node, weights sum
1; (2) root meta-node constant associated it; (3) completely reduced, namely
isomorphic meta-nodes, redundant meta-nodes.

498

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS




0

1





0

1

B

0

B

B

12

5

18

2

0

1

0

1

8
3/8
0

5/8

14/26

1

0

12/26

3/8

6

4

1

0

1

1

0

14/26

1

0

1

26*5

0

1

3/8

26*2

0

1

1

0

7/13

1

0

B

24*4

13*10

0

24*6

1

C

5/8

1

B

8*18

C

12/26

0

B

8*12

13 C
5/8



B

10

24 C

1


0

B

4
0

26 C

C

1

0

13*4

0

1

C

6/13

C

3/8

1

5/8

0

7/13

1

0

6/13
1

Figure 21: Normalizing values bottom
844



1/2
0



1/2

1
0



1




0

1

B

96
0

0

B

130

144

1

0

1

B

52
1

96
0

B

130

144

1

0

C

3/8
0

1

7/13
0

196/422

0

1

B

52

B

96/226

1

130/226

0

1

C

5/8

226/422

144/196

52/196

0

1

C

6/13

3/8

1

0

C

5/8
1

7/13
0

6/13
1

Figure 22: AOMDD weighted graph
procedure transforming weighted AND/OR graph AOMDD similar
Procedure B OTTOM U P R EDUCTION Section 5. difference new layer
processed, first meta-node weights normalized promoted parent,
procedure continues usual reduction rules.
HEOREM 7 Given two equivalent weighted graphical models accept common pseudo tree
, normalizing arc values together exhaustive application reduction rules yields
AND/OR graph, AOMDD based .
Finite Precision Arithmetic implementation algorithm described section may
prove challenging machines used finite precision arithmetic. Since weights
real-valued, repeated normalization may lead precision errors. One possible approach,
used experiments, define -tolerance, user defined sufficiently
small , consider weights equal within other.

9. Semantic Treewidth
graphical model represents universal function F = . function F may represented
different graphical models. Given particular pseudo tree , captures structural
information F , interested graphical models accept pseudo tree, namely
primal graphs contain edges backarcs . Since size AOMDD F
based bounded worst case induced width graphical model along ,
define semantic treewidth be:
499

fiM ATEESCU , ECHTER & ARINESCU

1


2

3

B
C

C


B



1

2



3

4




C








B

4



B
1 3
1 4
2 4
3 1
4 1
4 2




(a) two solutions

C
1 2
1 4
2 1
2 3
3 2
3 4
4 1
4 3


1 2
1 3
2 1
2 3
2 4
3 1
3 2
3 4
4 2
4 3


B C
1 3
1 4
2 4
3 1
4 1
4 2

B
1 2
1 4
2 1
2 3
3 2
3 4
4 1
4 3

C
1 3
1 4
2 4
3 1
4 1
4 2

(b) First model



B
2 4
3 1

B

C

B C
1 4
4 1



C
1 3
4 2

(c) Second model

Figure 23: 4-queen problem
EFINITION 27 (semantic treewidth) semantic treewidth graphical model relative
pseudo tree denoted swT (M), smallest treewidth taken models R
equivalent M, accept pseudo tree . Formally, defined swT (M) =
minR,u(R)=u(M) wT (R), u(M) universal function M, wT (R) induced
width R along . semantic treewidth graphical model, M, minimal semantic
treewidth pseudo trees express universal function.
Computing semantic treewidth shown NP-hard.3
HEOREM 8 Computing semantic treewidth graphical model NP-hard.
Theorem 8 shows computing semantic treewidth hard, likely actual
complexity even higher. However, semantic treewidth explain sometimes minimal
AND/OR graph OBDD much smaller exponential treewidth pathwidth upper
bounds. many cases, could huge disparity treewidth semantic
treewidth along .
Example 14 Figure 23(a) shows two solutions 4-queen problem. problem expressed complete graph treewidth 3, given Figure 23(b). Figure 23(c) shows equivalent
problem (i.e., set solutions), treewidth 1. semantic treewidth
4-queen problem 1.
Based fact AOMDD canonical representation universal function
graphical model, conclude size AOMDD bounded exponentially
semantic treewidth along pseudo tree, rather treewidth given graphical model
representation.
Proposition 7 size AOMDD graphical model bounded O(n k swT (M )),
n number variables, k maximum domain size swT (M) semantic
treewidth along pseudo tree .
3. thank David Eppstein proof.

500

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS




B

B

C

C

B







C

N



P

0

1

(a) OBDD representation

(b) Primal graph hidden
variables M, N P .

Figure 24: parity function
Example 15 Consider constraint network n variables every two variables constrained equality (X = ). One graph representation complete graph, another chain
another tree. problem specified complete graph, use linear order,
OBDD linear size exists representation pathwidth 1
(rather n).
semantic treewidth yield much better upper bound AOMDD,
bad bound. well known parity function n variables compact,
chain-like OBDD representation. Yet, constraint network representation parity function
function (namely complete graph variables), whose treewidth semantic
treewidth number variables, n. OBDD representation parity function suggests
addition hidden variables simplify presentation. show example Figure
24. left side, Figure 24(a) OBDD representation parity function
four binary variables. graphical model would represent function complete graph
four variables. However, could add extra variables M, N P Figure 24(b), sometimes
called hidden variables, help decompose model. case form constraint
together B represents parity B, namely = 1 B = 1,
parity (XOR) operator. Similarly, N would capture parity C, P
would capture parity N D, would give parity initial four variables.
two structures surprisingly similar. would interesting study connection
hidden variables compact AOBDDs, leave future work.

10. Experimental Evaluation
experimental evaluation preliminary stages, results already encouraging. ran search-based compile algorithm, recording trace AND/OR search,
reducing resulting AND/OR graph bottom up. results applied reduction isomorphism still kept redundant meta-nodes. implemented algorithms
C++ ran experiments 2.2GHz Intel Core 2 Duo 2GB RAM, running Windows.

501

fiM ATEESCU , ECHTER & ARINESCU

10.1 Benchmarks
tested performance search-based compilation algorithm random Bayesian networks, instances Bayesian Network Repository subset networks UAI06
Inference Evaluation Dataset.
Random Bayesian Networks random Bayesian networks generated using parameters
(n, k, c, p), n number variables, k domain size, c number conditional
probability tables (CPTs) p number parents CPT. structure network
created randomly picking c variables n and, each, randomly picking p parents
preceding variables, relative ordering. remaining n c variables called root
nodes. entries probability table generated randomly using uniform distribution,
table normalized. possible control amount determinism
network forcing percentage det CPTs 0 1 entries.
Bayesian Network Repository Bayesian Network Repository4 contains collection belief
networks extracted various real-life domains often used benchmarking probabilistic inference algorithms.
UAI06 Inference Evaluation Dataset UAI 2006 Inference Evaluation Dataset5 contains
collection random well real-world belief networks used first UAI 2006
Inference Evaluation contest. purpose selected subset networks derived
ISCAS89 digital circuits benchmark.6 ISCAS89 circuits common benchmark used
formal verification diagnosis. circuits converted Bayesian network
removing flip-flops buffers standard way, creating deterministic conditional probability
table gate, putting uniform distributions input signals.
10.2 Algorithms
consider two search-based compilation algorithms, denoted AOMDD-BCP AOMDDSAT, respectively, reduce context minimal AND/OR graph explored via isomorphism,
exploiting determinism (if any) present network. approach take handling
determinism based unit resolution CNF encoding (i.e., propositional clauses) zero
probability tuples CPTs. idea using unit resolution search Bayesian networks first explored Allen Darwiche (2003). AOMDD-BCP conservative applies
unit resolution node search graph, whereas AOMDD-SAT aggressive
detects inconsistency running full SAT solver. used zChaff SAT solver (Moskewicz,
Madigan, Zhao, Zhang, & Malik, 2001) unit resolution well full satisfiability.
comparison, ran version AOMDD-BCP, called MDD-BCP.
reference report results obtained ACE7 compiler. ACE compiles Bayesian
network Arithmetic Circuit (AC) uses AC answer multiple queries respect network. arithmetic circuit representation equivalent AND/OR graphs
(Mateescu & Dechter, 2007). time ACE compiler invoked, uses one two algorithms
basis compilation. First, elimination order generated network
4.
5.
6.
7.

http://www.cs.huji.ac.il/compbio/Repository/
http://ssli.ee.washington.edu/bilmes/uai06InferenceEvaluation
Available at: http://www.fm.vslib.cz/kes/asic/iscas/
Available at: http://reasoning.cs.ucla.edu/ace

502

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

Network

(w*, h)

(n, k)

ACE
#nodes time

MDD w/ BCP
AOMDD w/ BCP
AOMDD w/ SAT
#meta #cm(OR) time
#meta #cm(OR)
time #meta #cm(OR)
time
Bayesian Network Repository
alarm
(4, 13) (37, 4)
1,511 0.01 208,837 682,195 73.35
320
459
0.05
320
459
0.22
cpcs54
(14, 23) (54, 2)
196,933 0.06
- 65,158 66,405
6.97 65,158 66,405
6.97
cpcs179
(8, 14) (179, 4)
67,919 0.05
9,990 32,185 46.56 9,990 32,185 46.56
cpcs360b (20, 27) (360, 2) 5,258,826 1.72
diabetes
(4, 77) (413, 21) 7,615,989 1.81
hailfinder (4, 16) (56, 11)
8,815 0.01
2,068
2,202
0.34 1,893
2,202
1.48
mildew
(4, 13) (35, 100) 823,913 0.39
- 73,666 110,284 1367.81 62,903 65,599 3776.82
mm
(20, 57) (1220, 2)
47,171 1.49
- 38,414 58,144
4.54 30,274 52,523 99.55
munin2
(9, 32) (1003, 21) 2,128,147 1.91
munin3
(9, 32) (1041, 21) 1,226,635 1.27
munin4
(9, 32) (1044, 21) 2,423,009 4.44
pathfinder (6, 11) (109, 63)
18,250 0.05 610,854 1,303,682 352.18
6,984 16,267 30.71 2,265 15,963 50.36
pigs
(11, 26) (441, 3) 636,684 0.19
- 261,920 294,101 174.29 198,284 294,101 1277.72
water
(10, 15) (32, 4)
59,642 0.52 707,283 1,138,096 95.14 18,744 20,926
2.02 18,503 19,225
7.45
UAI06 Evaluation Dataset
BN 42
(21, 62) (851, 2)
4,860 1.35
- 107,025 341,428 53.50 42,445 43,280 57.36
BN 43
(26, 65) (851, 2)
10,373 1.62
- 1,343,923 1,679,013 1807.63 313,388 314,669 434.38
BN 44
(25, 56) (851, 2)
4,235 1.31
- 155,588 187,589 20.90 47,222 48,540 66.09
BN 45
(22, 54) (851, 2)
12,319 1.50
- 390,795 487,593 68.81 126,182 126,929 177.50
BN 46
(20, 46) (851, 2)
5,912 2.90 1,125,658 1,228,332 94.93 16,711 17,532
1.31 7,337
7,513
5.54
BN 47
(39, 57) (632, 2)
1,448 1.17 42,419 47,128 2.87
1,873
2,663
0.24 1,303
2,614
2.36
BN 49
(40, 60) (632, 2)
1,408 1.16 18,344 19,251 1.32
1,205
1,539
0.19
952
1,515
1.34
BN 51
(41, 68) (632, 2)
1,467 1.15 63,851 68,005 4.22
4,442
5,267
0.50 3,653
5,195
4.58
BN 53
(47, 87) (532, 2)
1,357 0.91 14,210 19,162 1.49
4,819
9,561
0.74 1,365
1,719
1.36
BN 55
(49, 92) (532, 2)
1,288 0.93
5,168
6,088 0.57
1,972
2,816
0.26
790
904
0.75
BN 57
(49, 85) (532, 2)
1,276 0.90 48,436 51,611 3.52
4,036
5,089
0.37
962
1,277
1.01
BN 59
(52, 87) (511, 2)
1,749 0.93 332,030 353,720 25.61 22,963 29,146
2.14 10,655 18,752 14.17
BN 61
(41, 64) (638, 2)
1,411 1.10 20,459 20,806 1.45
1,244
1,589
0.17 1,016
1,528
1.37
BN 63
(53, 95) (511, 2)
1,324 0.90 11,461 17,087 1.28
7,182 14,048
1.07 1,419
2,177
1.69
BN 65
(56, 86) (411, 2)
1,184 0.75
- 20,764 23,102
1.52 12,569 19,778 12.90
BN 67
(54, 88) (411, 2)
1,031 0.74
- 179,067 511,031 154.91
716
1,169
0.78
Positive Random Bayesian Networks (n=75, k=2, p=2, c=65)
r75-1
(12, 22) (75, 2)
67,737 0.31
- 21,619 21,619
2.59 21,619 21,619
2.59
r75-2
(12, 23) (75, 2)
46,703 0.29
- 18,083 18,083
1.88 18,083 18,083
1.88
r75-3
(11, 26) (75, 2)
53,245 0.30
- 18,419 18,419
1.86 18,419 18,419
1.86
r75-4
(11, 19) (75, 2)
28,507 0.29
8,363
8,363
1.16 8,363
8,363
1.16
r75-5
(13, 24) (75, 2)
149,707 0.36
- 42,459 42,459
4.61 42,459 42,459
4.61
r75-6
(14, 24) (75, 2)
132,107 1.19
- 62,621 62,621
6.95 62,621 62,621
6.95
r75-7
(12, 24) (75, 2)
89,913 0.36
- 21,583 21,583
2.42 21,583 21,583
2.42
r75-8
(14, 24) (75, 2)
86,183 0.36
- 49,001 49,001
6.23 49,001 49,001
6.23
r75-9
(11, 19) (75, 2)
29,025 0.30
7,681
7,681
0.81 7,681
7,681
0.81
r75-10
(10, 24) (75, 2)
20,291 0.28
5,905
5,905
0.63 5,905
5,905
0.63
Deterministic Random Bayesian Networks (n=100, k=2, p=2, c=90) det = 25% CPTs containing 0 1 entries
r100d25-1 (13, 31) (100, 2)
68,398 0.38
- 34,035 34,075
2.94 34,035 34,075 12.77
r100d25-2 (16, 28) (100, 2) 150,134 0.46
- 70,241 70,931
7.72 70,241 70,931 27.17
r100d25-3 (16, 29) (100, 2) 705,200 0.96
- 134,079 135,203 13.80 134,079 135,203 50.51
r100d25-4 (16, 31) (100, 2) 161,902 0.54
- 79,366 79,488
7.26 79,366 79,488 28.06
r100d25-5 (16, 29) (100, 2) 185,348 0.53
- 140,627 140,636 14.57 140,627 140,636 49.42
r100d25-6 (18, 28) (100, 2) 148,835 0.66
- 204,232 210,066 17.56 197,134 210,066 92.24
r100d25-7 (16, 29) (100, 2) 264,629 0.60
- 134,344 135,008 14.26 133,850 135,008 55.60
r100d25-8 (17, 27) (100, 2)
65,186 0.46
- 36,857 36,887
2.95 36,857 36,887 11.97
r100d25-9 (14, 27) (100, 2) 140,014 0.40
- 58,421 59,791
6.88 58,172 59,791 23.21
r100d25-10 (16, 27) (100, 2) 173,808 0.58
- 69,110 69,136
7.50 69,110 69,136 26.50

Table 1: Results experiments 50 Bayesian networks 3 problem classes; w =
treewidth, h = depth pseudo tree, n = number variables, k = domain size, time
given seconds; bold types highlight best results across rows.

503

fiM ATEESCU , ECHTER & ARINESCU

sufficiently small induced width, tabular variable elimination used basis.
algorithm similar one discussed Chavira Darwiche (2007), uses tables represent factors rather ADDs. induced width large, logical model counting
used basis. Tabular variable elimination typically efficient width small cannot
handle networks width larger. Logical model counting, hand, incurs
overhead tabular variable elimination, handle many networks larger treewidth.
tabular variable elimination logical model counting produce ACs exploit local structure, leading efficient online inference. logical model counting invoked, proceeds
encoding Bayesian network CNF (Chavira & Darwiche, 2005; Chavira, Darwiche, &
Jaeger, 2006), simplifying CNF, compiling CNF d-DNNF, extracting AC
compiled d-DNNF. dtree CNF clauses drives compilation step.
experiments report compilation time seconds (time), number
nodes context minimal graph explored (#cm), number meta-nodes resulting
AOMDD (#meta), well size AC compiled ACE (#nodes). network
specify number variables (n), domain size (k), induced width (w ) pseudo tree depth (h).
- stands exceeding 2GB memory limit respective algorithm. best performance
points highlighted.
10.3 Evaluation Bayesian Networks
Table 1 reports results obtained experiments 50 Bayesian networks. AOMDD
compilers well ACE used min-fill heuristic (Kjaerulff, 1990) construct guiding
pseudo tree dtree, respectively.
10.3.1 BAYESIAN N ETWORKS R EPOSITORY
see ACE overall fastest compiler domain, outperforming AOMDD-BCP
AOMDD-SAT several orders magnitude (e.g., mildew, pigs). However,
diagrams compiled ACE AOMDD-BCP (resp. AOMDD-SAT) comparable size.
cases, AOMDD-BCP AOMDD-SAT able compile much smaller diagrams
ACE. example, diagram produced AOMDD-BCP mildew network 13 times
smaller one compiled ACE. principle output produced ACE AOMDD
similar guided pseudo tree/dtree. scheme viewed
compilation alternative (1) extends decision diagrams (2) mimics traces search
properties may make representation accessible. compiler MDD-BCP able
compile 3 14 test instances, sizes far larger produced
AOMDD-BCP. instance, pathfinder network, AOMDD-BCP outputs decision
diagram almost 2 orders magnitude smaller MDD-BCP.
10.3.2 UAI06 DATASET
UAI06 Dataset instances picked randomly 30 variables instantiated
evidence. see ACE best performing compiler dataset. AOMDD-BCP
competitive ACE terms compile time 9 16 test instances. AOMDD-SAT
able compile smallest diagrams 6 networks (e.g., BN 47, BN 49, BN 55, BN 57,
BN 61, BN 67). before, difference size compiled data-structures produces
MDD-BCP AOMDD-BCP 2 orders magnitude favor latter.
504

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

10.3.3 R ANDOM N ETWORKS
problem instances denoted r75-1 r75-10 generated class random
belief networks parameters (n = 75, k = 2, p = 2, c = 65). Similarly, instances denoted
r100d25-1 r100d25-10 belong class parameters (n = 100, k = 2, p = 2, c =
90). latter case, det = 25% CPTs deterministic, namely contain 0
1 probability tuples. test instances compiled without evidence. see
domain AOMDD-BCP/AOMDD-SAT able compile smallest diagrams,
average 2 times smaller produced ACE. However, ACE fastest
compiler. Notice compiler MDD-BCP ran memory test cases.
10.4 Impact Variable Ordering
theory dictates, AOMDD size influenced quality guiding pseudo tree.
addition min-fill heuristic considered hypergraph heuristic constructs
pseudo tree recursively decomposing dual hypergraph associated graphical model.
idea explored Darwiche (2001) constructing dtrees guide ACE.
Since min-fill hypergraph partitioning heuristics randomized (namely ties
broken randomly), size AOMDD guided resulting pseudo tree may vary significantly one run next. Figure 25 displays AOMDD size using hypergraph min-fill
based pseudo trees 6 networks selected Table 1, 20 independent runs. record
average induced width depth obtained pseudo trees (see header plot
Figure 25). see two heuristics dominate other, namely variance output
size quite significant cases.
10.5 Memory Usage
Table 2 shows memory usage (in MBytes) ACE, AOMDD-BCP AOMDD-SAT, respectively, Bayesian networks Table 1. see cases AOMDD based compilers require far less memory ACE. example, mildew network, AOMDDBCP AOMDD-SAT use 22 MB memory compile AND/OR decision diagram,
ACE requires much 218 MB memory. Moreover, compiled AOMDD
case one order magnitude fewer nodes constructed ACE. comparing
two AND/OR search-based compilers, observe networks significant amount
determinism, UAI06 Evaluation dataset, AOMDD-SAT uses average two
times less memory AOMDD-BCP. dramatic savings memory usage due aggressive constraint propagation employed AOMDD-SAT compared AOMDD-BCP
seen BN 67 network. case, difference memory usage AOMDD-SAT
AOMDD-BCP 2 orders magnitude favor former.

11. Related Work
related work viewed along two directions: (1) work related AND/OR search
idea graphical models (2) work related compilation graphical models exploits
problem structure.
extensive discussion (1) provided previous work Dechter Mateescu
(2007). Since focus paper, mention AND/OR idea origi505

fiM ATEESCU , ECHTER & ARINESCU

Figure 25: Effect variable ordering.

506

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

Network

ACE
AOMDD w/ BCP
AOMDD w/ SAT
#nodes memory (MB) #nodes memory (MB) #nodes memory (MB)
Bayesian Network Repository
alarm
1,511
0.00
320
0.0206
320
0.0206
cpcs54
196,933
4.00 65,158
3.4415 65,158
3.4415
cpcs179
67,919
5.00
9,990
1.9263 9,990
1.9263
cpcs360b 5,258,826
204.00
diabetes
7,615,989
449.00
hailfinder
8,815
0.00
2,068
0.1576 1,893
0.1740
mildew
823,913
218.00 73,666
22.5781 62,903
22.1467
mm
47,171
369.00 38,414
1.5719 30,274
1.3711
munin2
2,128,147
202.00
munin3
1,226,635
150.00
munin4
2,423,009
n/a
pathfinder
18,250
10.00
6,984
0.6009 2,265
0.3515
pigs
636,684
31.00 261,920
23.3761 198,284
17.7096
water
59,642
161.00 18,744
1.09578 18,503
1.3258
UAI06 Evaluation Dataset
BN 42
4,860
n/a 107,025
4.5622 42,445
1.9323
BN 43
10,373
n/a 1,343,923
57.8422 313,388
14.2828
BN 44
4,235
n/a 155,588
6.5613 47,222
2.1628
BN 45
12,319
n/a 390,795
17.9325 126,182
5.7958
BN 46
5,912
n/a
16,711
0.6929 7,337
0.3401
BN 47
1,448
n/a
1,873
0.0720 1,303
0.0583
BN 49
1,408
n/a
1,205
0.0449
952
0.0409
BN 51
1,467
n/a
4,442
0.1689 3,653
0.1633
BN 53
1,357
n/a
4,819
0.1814 1,365
0.0587
BN 55
1,288
n/a
1,972
0.0723
790
0.0336
BN 57
1,276
n/a
4,036
0.1495
962
0.0411
BN 59
1,749
n/a
22,963
0.8501 10,655
0.4587
BN 61
1,411
n/a
1,244
0.0463 1,016
0.0445
BN 63
1,324
n/a
7,182
0.2728 1,419
0.0607
BN 65
1,184
n/a
20,764
0.7539 12,569
0.5384
BN 67
1,031
n/a 179,067
6.9603
716
0.0304
Positive Random Bayesian Networks parameters (n=75, k=2, p=2, c=65)
r75-1
67,737
1.00 21,619
1.2503 21,619
1.2503
r75-2
46,703
1.00 18,083
0.9957 18,083
0.9957
r75-3
53,245
1.00 18,419
0.9955 18,419
0.9955
r75-4
28,507
1.00
8,363
0.5171 8,363
0.5171
r75-5
149,707
3.00 42,459
2.3299 42,459
2.3299
r75-6
132,107
3.00 62,621
3.4330 62,621
3.4330
r75-7
89,913
2.00 21,583
1.1942 21,583
1.1942
r75-8
86,183
2.00 49,001
2.8130 49,001
2.8130
r75-9
29,025
1.00
7,681
0.4124 7,681
0.4124
r75-10
20,291
1.00
5,905
0.3261 5,905
0.3261
Deterministic Random Bayesian Networks parameters (n=100, k=2, p=2, c=90)
r100d25-1
68,398
5.00 34,035
1.6290 34,035
1.7149
r100d25-2 150,134
10.00 70,241
3.6129 70,241
3.7810
r100d25-3 705,200
40.00 134,079
6.6372 134,079
6.9873
r100d25-4 161,902
22.00 79,366
3.8113 79,366
4.0079
r100d25-5 185,348
15.00 140,627
7.0839 140,627
7.4660
r100d25-6 148,835
37.00 204,232
9.1757 197,134
9.6542
r100d25-7 264,629
19.00 134,344
6.9619 133,850
6.9961
r100d25-8
65,186
21.00 36,857
1.6872 36,857
1.8278
r100d25-9 140,014
6.00 58,421
3.1058 58,172
3.2055
r100d25-10 173,808
27.00 69,110
3.5578 69,110
3.6636

Table 2: Memory usage MBytes ACE, AOMDD-BCP AOMDD-SAT 50 Bayesian
networks Table 1. Bold types highlight best performance across rows. n/a
indicates respective memory usage statistic available ACEs output.

507

fiM ATEESCU , ECHTER & ARINESCU

nally developed heuristic search (Nilsson, 1980). mentioned introduction, AND/OR
search graphical models based pseudo tree spans graph model, similar
tree rearrangement Freuder Quinn (1985, 1987). idea adapted distributed
constraint satisfaction Collin et al. (1991, 1999) recently Modi et al. (2005),
shown related graph-based backjumping (Dechter, 1992). work extended
Bayardo Miranker (1996), Bayardo Schrag (1997) recently applied optimization tasks Larrosa et al. (2002). Another version viewed exploring AND/OR
graphs presented recently constraint satisfaction (Terrioux & Jegou, 2003b) optimization (Terrioux & Jegou, 2003a). Similar principles introduced recently probabilistic
inference, algorithm Recursive Conditioning (Darwiche, 2001) well Value Elimination
(Bacchus et al., 2003b, 2003a), currently core advanced SAT solvers (Sang
et al., 2004).
direction (2), various lines related research. formal verification literature,
beginning work Bryant (1986) contains large number papers dedicated
study BDDs. However, BDDs fact structures (the underlying pseudo tree chain)
take advantage problem decomposition explicit way. complexity bounds
OBDDs based pathwidth rather treewidth.
noted earlier, work Bertacco Damiani (1997) Disjoint Support Decomposition
(DSD) related AND/OR BDDs various ways. main common aspect approaches show structure decomposition exploited BDD-like representation. DSD
focused Boolean functions exploit refined structural information inherent Boolean functions. contrast, AND/OR BDDs assume structure conveyed
constraint graph, therefore broadly applicable constraint expression
graphical models general. allow simpler higher level exposition yields graphbased bounds overall size generated AOMDD. full relationship two
formalisms studied further.
McMillan (1994) introduced BDD trees, along operations combining them.
2w
circuits bounded tree width, BDD trees linear space upper bound O(|g|2w2 ),
|g| size circuit g (typically linear number variables) w treewidth.
bound hides large constants claim linear dependence |g| w bounded.
However, McMillan maintains input function CNF expression BDD-trees
bounds AND/OR BDDs, namely exponential treewidth only.
sketch short comparison McMillans BDD trees AOMMDs, consider
example simple pseudo tree root , left child right child .
nodes may stand set variables. BDD trees, assignments grouped
equivalence classes according cofactors generated remaining .
example assignments 1 2 equivalent generate function .
node represented BDD whose leaves cofactors. done .
node represented matrix BDDs, column corresponds cofactor
line cofactor . contrast, AOMDD represents node BDD whose
leaves cofactors (the number distinct functions ) cofactor
root decomposition (an node) . Moreover, representations (as
descendants different cofactor ) shared much possible goes .
high level description, becomes slightly complicated redundant nodes
eliminated, idea remains same.
508

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

AND/OR structure restricted propositional theories similar deterministic decomposable negation normal form (d-DNNF) (Darwiche & Marquis, 2002; Darwiche, 2002).
recently, Huang Darwiche (2005b) used trace DPLL algorithm generate OBDD,
compared typical formal verification approach combining OBDDs input
function according schedule. structures investigated case still OR.
idea extended present work AND/OR search compilation algorithm.
McAllester, Collins, Pereira (2004) introduced case factor diagrams (CFD), subsume Markov random fields bounded tree width probabilistic context free grammars (PCFG).
CFDs much related AND/OR graphs. CFDs target minimal representation,
exploiting decomposition (similar nodes) exploiting context sensitive information allowing dynamic ordering variables based context. CFDs eliminate
redundant nodes, part cause use zero suppression. claim
CFDs canonical forms, description combine two CFDs.
numerous variants decision diagrams designed represent integer-valued
real-valued functions. comprehensive view refer reader survey Drechsler
Sieling (2001). Algebraic decision diagrams (ADDs) (Bahar et al., 1993) provide compilation general real-valued rather Boolean functions. main drawback
size increases fast number terminals becomes large. several approaches
try alleviate problem. However structure capture still OR,
exploit decomposition. alternatives introduce edge values (or weights) enable
subgraph sharing. Edge-valued binary decision diagrams (EVBDDs) (Lai & Sastry, 1992)
use additive weights, multiplicative weights allowed called factored
EVBDDs (FEVBDDs) (Tafertshofer & Pedram, 1997). Another type BDDs called K*BMDs
(Drechsler, Becker, & Ruppertz, 1996) use integer weights, additive multiplicative
parallel. ADDs extended affine ADDs (Sanner & McAllester, 2005),
affine transformations achieve compression. result shown beneficial
probabilistic inference algorithms, tree clustering, still exploit
structure.
recently, independently parallel work AND/OR graphs (Dechter & Mateescu, 2004a, 2004b), Fargier Vilarem (2004) Fargier Marquis (2006, 2007) proposed compilation CSPs tree-driven automata, many similarities work.
main focus transition linear automata tree automata (similar
AND/OR), possible savings tree-structured networks hyper-trees constraints
due decomposition. compilation approach guided tree-decomposition
guided variable-elimination based algorithms. well known Bucket Elimination
cluster-tree decomposition principle (Dechter & Pearl, 1989).
Wilson (2005) extended OBDDs semi-ring BDDs. semi-ring treatment restricted
search spaces, allows dynamic variable ordering. otherwise similar aim
scope AOMDD. restricting AOMDD graphs only, two closely related,
except express BDDs using Shenoy-Shafer axiomatization centered two
operation combination marginalization rather semi-ring formulation. Minimality
formulation Wilson (2005) general allowing merging nodes different values
therefore capture symmetries (called interchangeability).
Another framework similar AOMDDs, became aware recently, Probabilistic Decision Graphs (PDG) Jaeger (2004). work preceded relevant work
509

fiM ATEESCU , ECHTER & ARINESCU

discussed (Fargier & Vilarem, 2004; Wilson, 2005) went somewhat unnoticed, perhaps due notational cultural differences. however similar motivation, framework
proposed algorithms. believe AND/OR framework accessible. define framework multi-valued domains, provide greater details algorithms complexity analysis,
make explicit connection search frameworks, fully address issues canonicity well
provide empirical demonstration. particular, claim canonicity PDGs similar
one make AOMDDs weighted models, relative trees (or forests)
represent given probability distribution.
another line research Drechsler group (e.g. Zuzek, Drechsler, & Thornton,
2000), use AND/OR graphs Boolean function representation, may seem similar
approach. However, semantics purpose AND/OR graphs different.
constructed based technique recursive learning used perform Boolean reasoning,
i.e. explore logic consequences given assumption based structure circuit,
especially derive sets implicants. meaning case related
meaning gates/functions, case meaning related semantic
functions. AND/OR enumeration tree results circuit according Zuzek et al.
(2000) related AND/OR decomposition discuss.

12. Conclusion
propose AND/OR multi-valued decision diagram (AOMDD), emerges study
AND/OR search spaces graphical models (Dechter & Mateescu, 2004a, 2004b; Mateescu &
Dechter, 2005; Dechter & Mateescu, 2007) ordered binary decision diagrams (OBDDs) (Bryant,
1986). data-structure used compile graphical model.
Graphical models algorithms search-based compiled data-structures BDDs
differ primarily choices time vs. memory. move regular search
space AND/OR search space spectrum algorithms available improved time
vs. memory decisions. believe AND/OR search space clarifies available choices
helps guide user making informed selection algorithm would fit best
particular query asked, specific input function available computational resources.
contribution work is: (1) formally describe AOMDD prove
canonical representation constraint network. (2) extend AOMDD general weighted
graphical models. (3) give compilation algorithm based AND/OR search, saves
trace memory intensive search (the context minimal AND/OR graph), reduces
one bottom pass. (4) describe APPLY operator combines two AOMDDs
operation show complexity quadratic input, never worse exponential
treewidth. (5) give scheduling order building AOMDD graphical model
starting AOMDDs functions based Variable Elimination algorithm.
guarantees complexity exponential induced width (treewidth) along
ordering. (6) show AOMDDs relate various earlier recent compilation frameworks,
providing unifying perspective methods. (7) introduce semantic treewidth,
helps explain compiled decision diagrams often much smaller worst case
bound. Finally, (8) provide preliminary empirical demonstration power current
scheme.

510

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

Acknowledgments
work done Robert Mateescu Radu Marinescu University California, Irvine. authors would thank anonymous reviewers constructive
suggestions improve paper, David Eppstein useful discussion complexity issues,
Lars Otten Natasha Flerova comments final version manuscript. work
supported NSF grants IIS-0412854 IIS-0713118, initial part Radcliffe fellowship 2005-2006 (through partner program), Harvard undergraduate student John Cobb.

Appendix
Proof Proposition 1
Consider level variable Xi , meta-nodes list LXi . one pass
meta-nodes LXi (the inner loop), two meta-nodes level Xi
AND/OR graph isomorphic, would merged line 6. Also,
pass meta-nodes LXi redundant meta-nodes LXi eliminated
line 8. Processing meta-nodes level Xi create new redundant isomorphic
meta-nodes levels processed before. follows resulting AND/OR
graph completely reduced. 2
Proof Theorem 4
bound size follows directly Theorem 3. AOMDD size smaller

size context minimal AND/OR graph, bounded O(n k wT (G) ). prove
time bound, rely use hash table, assumption efficient implementation allows access time constant. time bound AND/OR-S EARCH -AOMDD

O(n k wT (G) ), Theorem 3, takes time linear output (we assume
constraint propagation performed search). Procedure B OTTOM U P R EDUCTION (procedure 1) takes time linear size context minimal AND/OR graph. Therefore, AOMDD

computed time O(n k wT (G) ), result algorithm performs
reduction search. 2
Proof Proposition 2
complexity OBDD (and MDD) apply known quadratic input. Namely,
number nodes output product number nodes input. Therefore,
number nodes appear along one path output AOMDD product
number nodes input, along path, |Gfi | |Ggi |. Summing paths
gives result. 2
Proof Proposition 3
argument identical case MDDs. recursive calls APPLY lead combinations
one node Gfaomdd one node Ggaomdd (rather list nodes). number
total possible combinations O(| Gfaomdd | | Ggaomdd |). 2
Proof Proposition 4
recursive calls APPLY generate one meta-node output combination
511

fiM ATEESCU , ECHTER & ARINESCU

nodes Gff g Ggf g . Lets look combinations nodes Gff g Ggaomdd \ Ggf g .
meta-nodes Ggaomdd \ Ggf g participate combinations (lets call set A)
levels (of variables) right Tf g . mechanics
recursive calls APPLY. Whenever node f belongs Gff g combined node
g belongs A, line 15 APPLY expands node f , node (or nodes)
remain same. happen nodes f combined
node (or nodes) A, point APPLY simply copy remaining portion
output Ggaomdd . size therefore proportional | Ggf g | (because layer
metanodes immediately Ggf g ). similar argument valid symmetrical case.
combinations nodes Ggaomdd \ Ggf g Ggaomdd \ Ggf g . bound follows
arguments. 2
Proof Proposition 5
APPLY operation works constructing output AOMDD root leaves. first creates
meta-node root variable, recursively creates children metanodes using APPLY
corresponding children input. worst case happen output
reduced all, recursive call made possible descendant. corresponds
unfolding full AND/OR search tree based context variables, exponential
context size. APPLY finishes context variables, arrives first branching
bucket pseudo tree, remaining branches independent. Similar case OBDDs,
one function occupies single place memory, APPLY simply create link
corresponding branches inputs (this happens line 4 APPLY algorithm).
Therefore, time space complexity exponential context size. 2
Proof Theorem 5
space complexity governed BE. Since AOMDD never requires space

full exponential table (or tree), follows BE-AOMDD needs space O(n k w ).
size output AOMDD bounded, per layers, number assignments
context layer (namely, size context minimal AND/OR graph). Therefore,

context size bounded treewidth, follows output size O(n k w ).
time complexity follows Proposition 5, fact number functions
bucket cannot exceed r, original number functions.
2
Proof Proposition 6
suffices prove proposition = 2. general result obtained induction.
essential function defined constraint network (i.e., values 0 1),
function takes value 1 least one assignment. value 1 denotes consistent assignments (solutions), 0 denotes inconsistent assignments. Suppose f = f1 f2 . Lets denote
x full assignment X, x1 x2 projection x X1 X2 , respectively.
write x = x1 x2 (concatenation partial assignments). follows f (x) = f1 (x1 ) f2 (x2 ).
Therefore, f (x) = 1, must f1 (x1 ) = 1 f2 (x2 ) = 1. claim x1 ,
f1 (x1 ) = 1 exists x2 f (x1 x2 ) = 1. Suppose contradiction
exist x1 f1 (x1 ) = 1 f (x1 x2 ) = 0 x2 . Since f always zero,

512

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

follows f2 always zero, therefore must x2 f2 (x2 ) = 1.
leads contradiction, therefore functions f1 f2 uniquely defined f . 2
Proof Theorem 6
proof structural induction depth pseudo tree . follows canonicity
proofs OBDDs (Bryant, 1986) MDDs (Srinivasan et al., 1990), extends linear
orderings tree orderings capture function decomposition according pseudo tree .
depth , along paths root leaf, actually size dependency set,
set variables value function depends. Remember AOMDD
AND/OR graph completely reduced. use word function, denoted f , refer
universal relation, characteristic function, defined constraint network.
Assume depth 0. means function depend variable,
must one constants 0 1. Suppose function constant 0. Then, must
AOMDD contain terminal meta-node 1, since nodes must reachable
along path, would mean function evaluate 1. Suppose AOMDD
contains nonterminal meta-node, say labeled X, X take k different values. must
k children meta-nodes X terminal meta-node 0. one
terminal 0, AOMDD completely reduced. one 0, follows
meta-node labeled X redundant. Therefore, above, follows AOMDD
representing constant 0 made terminal 0. unique, contains smallest
number nodes. similar argument applies constant 1.
Now, suppose statement theorem holds constraint network admits
pseudo tree depth strictly smaller p, constraint network pseudo
tree depth equal p, p > 0. Let X root , domain {x1 , . . . , xk }.
denote , {1, . . . , k}, functions defined restricted constraint network
X = xi , namely = f |X=xi . Let Y1 , . . . , Ym children X . Suppose two
AOMDDs f , denoted G G 0 . show two AND/OR graphs isomorphic.
functions decomposed according pseudo tree root X removed.
fact forest independent pseudo trees (they share variables), rooted
Y1 , . . . , Ym . Based Proposition 6, unique decomposition = fiY1 . . . fiYm ,

{1, . . . , k}. Based induction hypothesis, function j unique AOMDD.
AND/OR graphs G G 0 , look subgraphs descending X = xi ,
completely reduced define function, , therefore exists isomorphic mapping
them. Let v root metanode G v 0 root G 0 . claim G G 0
isomorphic according following mapping:
0
v,
u = v;
(u) =
(u), u subgraph rooted hX, xi i.
prove this, show well defined, isomorphic mapping.
meta-node u G contained subgraphs rooted hX, xi hX, xj i,
AND/OR graphs rooted (u) j (u) isomorphic one rooted u, therefore
other. Since G 0 completely reduced, contain isomorphic subgraphs, therefore
(u) = j (u). Therefore well defined.
show bijection. show one-to-one, assume two distinct metanodes u1 u2 G, (u1 ) = (u2 ). Then, subgraphs rooted u1 u2 isomorphic
513

fiM ATEESCU , ECHTER & ARINESCU

subgraph rooted (u1 ), therefore other. Since G completely reduced, must
u1 = u2 . fact onto isomorphic mapping follows definition
fact onto new node root meta-node. Since AOMDDs
contain one root meta-node (more one root would lead conclusion root
meta-nodes isomorphic merged), conclude G G 0 isomorphic.
Finally, show among AND/OR graphs representing f , AOMDD
minimal number meta-nodes. Suppose G AND/OR graph represents f , minimal
number meta-nodes, without AOMDD. Namely, completely reduced.
reduction rule would transform G AND/OR graph smaller number meta-nodes,
leading contradiction. Therefore, G must unique AOMDD represents f . 2
Proof Corollary 1
proof Theorem 6 rely scopes define constraint network. long
network admits decomposition induced pseudo tree , universal function defined
constraint network always AOMDD, therefore constraint network
equivalent admits AOMDD. 2
Proof Theorem 7
constant associated root actually sum weights solutions.
derived definition weighted AOMDD. weights meta-node
normalized (they sum 1), therefore values computed node AND/OR search
always 1 (when task computing
P sum solution weights). Therefore, constant
weighted AOMDD always x w(x) regardless graphical model. prove
weighted AOMDDs canonical functions normalized.
Assume two different weighted AOMDDs, denoted G 1 G 2 , normalized function f . Let root variable A, domain {a1 , . . . , ak }. Let x denote full
assignment variables. Similar argument root constant,
P
meta-nodes normalized weights, follows w1 (A, a1 ) = w2 (A, a1 ) = x|A=a1 f (x).
superscript w1 w2 indicates AOMDD, summation possible assignments restricted = a1 . follows root meta-nodes identical. value
root variable, restricted functions represented G 1 G 2 identical, recursively
apply argument above.
However, proof complete, discuss case restricted function
decomposed independent functions, according pseudo tree. Suppose two
independent components, rooted B C. one 0 function, follows
entire function 0. prove meta-nodes B G 1 G 2 identical. B
one value b1 extendable solution, weight must 1 meta-nodes, meta-nodes
identical. B one value, suppose without loss generality weights
different first value b1 ,
w1 (B, b1 ) > w2 (B, b1 ).

(1)

Since f 6= 0, must value C = c1 B = b1 , C = c1 extended full
solution. sum weights possible extensions
X
f (x) = w1 (B, b1 ) w1 (C, c1 ) = w2 (B, b1 ) w2 (C, c1 ).
(2)
x|B=b1 ,C=c1

514

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

Equations 1 2 fact weight non-zero, follows
w1 (C, c1 ) < w2 (C, c1 ).

(3)

Equation 1, fact B one value fact weights B
normalized, follows value b2
w1 (B, b2 ) < w2 (B, b2 ).

(4)

Equations 3 4, follows
w1 (B, b2 ) w1 (C, c1 ) < w2 (B, b2 ) w2 (C, c1 ).

(5)

However, sides
P Equation 5 represent sum weights solutions B =
b2 , C = c1 , namely x|B=b2 ,C=c1 f (x), leading contradiction. Therefore, must
Equation 1 false. Continuing argument values B, follows metanodes B identical, similarly meta-nodes C identical.
decomposition two components, argument applies, B
first component C meta-variable combines components.
2
Proof Theorem 8
Consider well known NP-complete problem 3- COLORING: Given graph G,
3-coloring G? Namely, color vertices using three colors, two
adjacent vertices different colors? reduce 3- COLORING problem computing
semantic treewidth graphical model. Let H graph 3-colorable, nontrivial semantic treewidth. easy build examples H. G 3-colorable, G H
3-colorable non-trivial semantic treewidth, adding G simplify
task describing colorings H. However, G 3-colorable, G H
3-colorable, semantic treewidth zero. 2
Proof Proposition 7
Since AOMDDs canonical representations graphical models, follows graphical
model actual semantic treewidth realized AOMDD M,
therefore AOMDD bounded exponentially semantic treewidth. 2

References
Akers, S. (1978). Binary decision diagrams. IEEE Transactions Computers, C-27(6), 509516.
Allen, D., & Darwiche, A. (2003). New advances inference recursive conditioning. Proceedings Nineteenth Conference Uncertainty Artificial Intelligence (UAI03), pp.
210.
Bacchus, F., Dalmao, S., & Pitassi, T. (2003a). Algorithms complexity results #SAT
Bayesian inference. Proceedings 44th Annual IEEE Symposium Foundations
Computer Science (FOCS03), pp. 340351.
515

fiM ATEESCU , ECHTER & ARINESCU

Bacchus, F., Dalmao, S., & Pitassi, T. (2003b). Value elimination: Bayesian inference via backtracking search. Proceedings Nineteenth Conference Uncertainty Artificial
Intelligence (UAI03), pp. 2028.
Bahar, R., Frohm, E., Gaona, C., Hachtel, G., Macii, E., Pardo, A., & Somenzi, F. (1993). Algebraic decision diagrams applications. IEEE/ACM International Conference
Computer-Aided Design (ICCAD93), pp. 188191.
Bayardo, R., & Miranker, D. (1996). complexity analysis space-bound learning algorithms
constraint satisfaction problem. Proceedings Thirteenth National Conference
Artificial Intelligence (AAAI96), pp. 298304.
Bayardo, R. J., & Schrag, R. C. (1997). Using CSP look-back techniques solve real world SAT
instances. Proceedings Fourteenth National Conference Artificial Intelligence
(AAAI97), pp. 203208.
Bertacco, V., & Damiani, M. (1997). disjunctive decomposition logic functions.
IEEE/ACM International Conference Computer-Aided Design (ICCAD97), pp. 7882.
Bodlaender, H. L., & Gilbert, J. R. (1991). Approximating treewidth, pathwidth minimum
elimination tree height. Tech. rep., Utrecht University.
Bryant, R. E. (1986). Graph-based algorithms Boolean function manipulation. IEEE Transactions Computers, 35, 677691.
Cadoli, M., & Donini, F. M. (1997). survey knowledge compilation. AI Communications,
10(3-4), 137150.
Chavira, M., & Darwiche, A. (2005). Compiling Bayesian networks local structure.
Proceedings Nineteenth International Joint Conference Artificial Intelligence (IJCAI05), pp. 13061312.
Chavira, M., & Darwiche, A. (2007). Compiling Bayesian networks using variable elimination.
Proceedings Twentieth International Joint Conference Artificial Intelligence (IJCAI07), pp. 24432449.
Chavira, M., Darwiche, A., & Jaeger, M. (2006). Compiling relational Bayesian networks exact
inference. International Journal Approximate Reasoning, 42(1-2), 420.
Clarke, E., Grumberg, O., & Peled, D. (1999). Model Checking. MIT Press.
Collin, Z., Dechter, R., & Katz, S. (1991). feasibility distributed constraint satisfaction.
Proceedings Twelfth International Conference Artificial Intelligence (IJCAI91),
pp. 318324.
Collin, Z., Dechter, R., & Katz, S. (1999). Self-stabilizing distributed constraint satisfaction.
Chicago Journal Theoretical Computer Science, 115, special issue self-stabilization.
Darwiche, A. (2001). Recursive conditioning. Artificial Intelligence, 125(1-2), 541.

516

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

Darwiche, A. (2002). logical approach factoring belief networks. Proceedings
Eighth International Conference Principles Knowledge Representation Reasoning
(KR02), pp. 409420.
Darwiche, A., & Marquis, P. (2002). knowledge compilation map. Journal Artificial Intelligence Research (JAIR), 17, 229264.
Dechter, R. (1992). Constraint networks. Encyclopedia Artificial Intelligence, 276285.
Dechter, R. (1999). Bucket elimination: unifying framework reasoning. Artificial Intelligence,
113, 4185.
Dechter, R., & Mateescu, R. (2007). AND/OR search spaces graphical models. Artificial Intelligence, 171(2-3), 73106.
Dechter, R., & Mateescu, R. (2004a). Mixtures deterministic-probabilistic networks
AND/OR search space. Proceedings Twentieth Conference Uncertainty Artificial Intelligence (UAI04), pp. 120129.
Dechter, R., & Mateescu, R. (2004b). impact AND/OR search spaces constraint satisfaction counting. Proceedings Tenth International Conference Principles
Practice Constraint Programming (CP04), pp. 731736.
Dechter, R., & Pearl, J. (1989). Tree clustering constraint networks. Artificial Intelligence, 38,
353366.
Drechsler, R., Becker, B., & Ruppertz, S. (1996). K*BMDs: new data structure verification.
Proceedings 1996 European conference Design Test (ED&TC96), pp. 28.
Drechsler, R., & Sieling, D. (2001). Binary decision diagrams theory practice. International
Journal Software Tools Technology Transfer (STTT), 3(2), 112136.
Fargier, H., & Marquis, P. (2006). use partially ordered decision graphs knowledge
compilation quantified boolean formulae. Proceedings Twenty-First National
Conference Artificial Intelligence (AAAI06), pp. 4247.
Fargier, H., & Marquis, P. (2007). valued negation normal form formulas. Proceedings
Twentieth International Joint Conference Artificial Intelligence (IJCAI07), pp. 360365.
Fargier, H., & Vilarem, M. (2004). Compiling CSPs tree-driven automata interactive solving. Constraints, 9(4), 263287.
Fishburn, P. C. (1970). Utility Theory Decision Making. Wiley, NewYork.
Freuder, E. C., & Quinn, M. J. (1985). Taking advantage stable sets variables constraint
satisfaction problems. Proceedings Ninth International Joint Conference Artificial
Intelligence (IJCAI85), pp. 10761078.
Freuder, E. C., & Quinn, M. J. (1987). use lineal spanning trees represent constraint
satisfaction problems. Tech. rep. 87-41, University New Hampshire, Durham.
517

fiM ATEESCU , ECHTER & ARINESCU

Huang, J., & Darwiche, A. (2005a). compiling system models faster scalable diagnosis. Proceedings 20th National Conference Artificial Intelligence (AAAI05),
pp. 300306.
Huang, J., & Darwiche, A. (2005b). DPLL trace: SAT knowledge compilation.
Proceedings Nineteenth International Joint Conference Artificial Intelligence
(IJCAI05), pp. 156162.
Jaeger, M. (2004). Probabilistic decision graphs - combining verification AI techniques
probabilistic inference. International Journal Uncertainty, Fuzziness KnowledgeBased Systems, 12, 1942.
Kask, K., Dechter, R., Larrosa, J., & Dechter, A. (2005). Unifying cluster-tree decompositions
reasoning graphical models. Artificial Intelligence, 166 (1-2), 165193.
Kjaerulff, U. (1990). Triangulation graph-based algorithms giving small total state space. Tech.
rep., University Aalborg, Denmark.
Korf, R., & Felner, A. (2002). Disjoint pattern database heuristics. Artificial Intelligence, 134(1-2),
922.
Lai, Y.-T., & Sastry, S. (1992). Edge-valued binary decision multi-level hierarchical verification.
Proceedings Twenty Nineth Design Automation Conference, pp. 608613.
Larrosa, J., Meseguer, P., & Sanchez, M. (2002). Pseudo-tree search soft constraints.
Proceedings European Conference Artificial Intelligence (ECAI02), pp. 131135.
Lee, C. (1959). Representation switching circuits binary-decision programs. Bell System
Technical Journal, 38, 985999.
Mateescu, R., & Dechter, R. (2005). relationship AND/OR search variable elimination. Proceedings Twenty First Conference Uncertainty Artificial Intelligence
(UAI05), pp. 380387.
Mateescu, R., & Dechter, R. (2007). AND/OR multi-valued decision diagrams (AOMDDs)
weighted graphical models. Proceedings Twenty Third Conference Uncertainty
Artificial Intelligence (UAI07), pp. 276284.
McAllester, D., Collins, M., & Pereira, F. (2004). Case-factor diagrams structured probabilistic
modeling. Proceedings Twentieth Conference Uncertainty Artificial Intelligence (UAI04), pp. 382391.
McMillan, K. L. (1993). Symbolic Model Checking. Kluwer Academic.
McMillan, K. L. (1994). Hierarchical representation discrete functions application model
checking. Computer Aided Verification, pp. 4154.
Modi, P. J., Shen, W., Tambe, M., & Yokoo, M. (2005). ADOPT: asynchronous distributed constraint optimization quality guarantees. Artificial Intelligence, 161, 149180.

518

fiAND/OR ULTI -VALUED ECISION IAGRAMS (AOMDD ) G RAPHICAL ODELS

Moskewicz, M., Madigan, C., Zhao, Y., Zhang, L., & Malik, S. (2001). Chaff: Engineering
efficient SAT solver. Proceedings Thirty Eighth Design Automation Conference, pp.
530535.
Nilsson, N. J. (1980). Principles Artificial Intelligence. Tioga, Palo Alto, CA.
Palacios, H., Bonet, B., Darwiche, A., & Geffner, H. (2005). Pruning conformant plans counting models compiled d-DNNF representations. Proceedings 15th International
Conference Planning Scheduling (ICAPS05), pp. 141150.
Pearl, J. (1988). Probabilistic Reasoning Intelligent Systems. Morgan Kaufmann.
Sang, T., Bacchus, F., Beame, P., Kautz, H., & Pitassi, T. (2004). Combining component caching
clause learning effective model counting. Proceedings Seventh International
Conference Theory Applications Satisfiability Testing (SAT04).
Sanner, S., & McAllester, D. (2005). Affine algebraic decision diagrams (AADDs) application structured probabilistic inference. Proceedings Nineteenth International
Joint Conference Artificial Intelligence (IJCAI05), pp. 13841390.
Selman, B., & Kautz, H. (1996). Knowledge compilation theory approximation. Journal
ACM, 43(2), 193224.
Shenoy, P. (1992). Valuation-based systems Bayesian decision analysis. Operations Research,
40, 463484.
Srinivasan, A., Kam, T., Malik, S., & Brayton, R. K. (1990). Algorithms discrete function
manipulation. International conference CAD, pp. 9295.
Tafertshofer, P., & Pedram, M. (1997). Factored edge-valued binary decision diagrams. Formal
Methods System Design, 10(2-3), 243270.
Terrioux, C., & Jegou, P. (2003a). Bounded backtracking valued constraint satisfaction
problems. Proceedings Ninth International Conference Principles Practice
Constraint Programming (CP03), pp. 709723.
Terrioux, C., & Jegou, P. (2003b). Hybrid backtracking bounded tree-decomposition constraint networks. Artificial Intelligence, 146, 4375.
Wilson, N. (2005). Decision diagrams computation semiring valuations. Proceedings
Nineteenth International Joint Conference Artificial Intelligence (IJCAI05), pp.
331336.
Zuzek, A., Drechsler, R., & Thornton, M. (2000). Boolean function representation spectral
characterization using AND/OR graphs. Integration, VLSI journal, 29, 101116.

519


