journal artificial intelligence

submitted published

learning partially observable deterministic action
eyal illinois edu

eyal amir
computer science department
university illinois urbana champaign
urbana il usa

allenc yahoo com

allen chang
latham st apartment
mountainview ca usa

abstract
present exact identifying deterministic actions effects preconditions
dynamic partially observable domains apply one know action model
way actions affect world domain must learn partial observations time
scenarios common real world applications challenging ai tasks
traditional domain structures underly tractability e g conditional independence fail
e g world features become correlated work departs traditional assumptions
partial observations action particular focuses actions
deterministic simple logical structure observation features observed
frequency yield tractable modified domains
take sequences partial observations time input output deterministic action could lead observations output one
depending choice exact model misclassified given
observations take polynomial time number time steps state features
traditional action classes examined ai literature e g strips actions
contrast traditional approaches hmms reinforcement learning inexact exponentially intractable domains experiments verify theoretical tractability guarantees
identify action exactly several applications autonomous
exploration adventure game playing already use promising
probabilistic settings partially observable reinforcement learning diagnosis

introduction
partially observable domains common real world involve situations one
cannot observe entire state world many examples situations available
walks life e g physical worlds observe position items rooms
internet observe web time inter personal communications observe state mind partners
autonomous agents actions involve special kind partial observability domains
agents explore domain e g one goes building meets person
limited knowledge action actions preconditions effects action change time may depend state features agents act
intelligently learn actions affect world use knowledge respond
goals
c

ai access foundation rights reserved

fia mir c hang

learning action important goals change agent acted
use accumulated knowledge actions domain make better decisions thus learning
action differs reinforcement learning enables reasoning actions instead
expensive trials world
learning actions effects preconditions difficult partially observable domains
difficulty stems absence useful conditional independence structures domains
fully observable domains include structures e g markov property independence
state time state time given observed state time
fundamental tractable solutions learning decision making
partially observable domains structures fail e g state world time
depends state time observe state time complex
approximate approaches feasible path reasons much work far
limited fully observable domains e g wang pasula zettlemoyer kaelbling
hill climbing em approaches unbounded error deterministic domains e g ghahramani boyen friedman koller approximate action dawsey minsker
amir hill minsker amir kuffner lavalle thrun
examines application old structure learning partially observable
domains namely determinism logical formulation focuses deterministic domains tractable learning feasible shows traditional assumption form
determinism strips assumption generalized adl pednault leads tractable
learning state estimation learning domains immediate applications e g exploration shahaf chang amir chang amir serve
basis learning stochastic domains thus fundamental advance application
structure important opening field approaches broader applicability
following details technical aspects advance
main contribution called slaf simultaneous learning
filtering exact learning actions partially observable deterministic domains
determines set possible transition relations given execution sequence actions
partial observations example input could come watching another agent act
watching actions execution online updates
propositional logical formula called transition belief formula formula represents possible
transition relations world states every time step way similar spirit bayesian
learning hmms e g ghahramani logical filtering amir russell
present differ range applicability computational
complexity first present deduction applicable nondeterministic
learning takes time worst case exponential number domain fluents
present update logical encoding consistent transition relations
polynomial time per step limited applicability special classes deterministic
actions
one set polynomial time present applies action learning scenarios
actions adl pednault conditional effects one following
holds action model already preconditions known observe action failures e g
perform actions domain b actions execution succeeds e g
expert tutor performs actions


fil earning partially bservable eterministic action odels

output transition belief formula represents possible transition relations
states partial observations state actions updating component
formula separately linear time thus updating transition belief formula every
action execution observation takes linear time size input formula
processing sequence action executions observations takes time n case
b main reason linear growth representation size transition belief
formula time iterative process updates formula would process formula
size linear
case processing sequence length takes polynomial time n k
observe every feature domain every k steps expectation fixed k reason
transition belief formula kept k cnf k conjunctive normal
v form
w thus
size nk recall propositional formula k cnf form im jk li j
every li j propositional variable negation case b takes time n
assumption
another set polynomial time present takes linear time representation
size case actions known injective e map states bound
computation time steps nk approximate transition belief formula
representation k cnf formula
contrast work learning dynamic bayesian networks e g boyen et al reinforcement learning pomdps e g littman inductive logic programming ilp
e g wang approximate solution unbounded error deterministic domains
n
take time inapplicable domains larger features
better respect scale polynomially practically domains features
section provides comparison works
conduct set experiments verify theoretical experiments
faster better qualitatively related approaches example
learn adl actions effects domains features exactly efficiently
important distinction must made learning action traditional creation
ai operators perspective ai action
explicit modeling taking account modeling decisions contrast learning action
deducing possible transition relations compatible set partially observed
execution trajectories
particular action preconditions typically used knowledge engineer control
granularity action model leave aside specification unwanted cases example
driving truck insufficient fuel one site another might generate unexpected situations
modeller want consider simple precondition used avoid considering case intention mimic modeling perspective instead
action generate sound states starting sound state sound state
state system practice namely ones observations real executions
reflect
technical advance deterministic domains important many applications
automatic software interfaces internet agents virtual worlds games applications
robotics human computer interfaces program machine diagnosis use deterministic
action approximations finally understanding deterministic case better help us


fia mir c hang

develop better stochastic domains e g approaches boutilier
reiter price hajishirzi amir
following section defines slaf precisely section provides deduction exact
slaf section presents tractable action model update section gives sufficient conditions keeping action model representation compact thus overall
polynomial time section presents experimental

simultaneous learning filtering slaf
simultaneous learning filtering slaf tracking dynamic system
sequence time steps partial observations systems complete
dynamics initially solution slaf representation combinations action
could possibly given rise observations input representation
corresponding states system may sequence time steps
given input occurs
computing solution slaf done recursive fashion dynamic programming
determine slaf time step solution slaf time section
define slaf formally recursive fashion
ignoring stochastic information assumptions slaf involves determining set possible
ways actions change world possible transition defined formally
set states system might transition model determines set possible states
solution slaf transition model associated possible states
define slaf following formal tools borrowing intuitions work bayesian
learning hidden markov hmms ghahramani logical filtering amir
russell
definition transition system tuple hp ri
p finite set propositional fluents
p ow p set world states
finite set actions
r transition relation transition model
thus world state subset p contains propositions true state omitted
propositions false state r means state possible action
state goal r given known p sequence actions
partial observations logical sentences subset p
another equivalent representation use following
literal proposition p p negation p complete term p conjunction
literals p every fluent appears exactly every state corresponds complete
term p vice versa reason sometime identify state term e g
states disjunction complete terms corresponding respectively
transition belief state set tuples hs ri state r transition relation
let r p ow set possible transition relations let r
hold transition belief state consider every tuple hs ri possible



fil earning partially bservable eterministic action odels

figure locked door unknown key domain
example consider domain agent room locked door see figure
possession three different keys suppose agent cannot tell observation
key opens door goal agent unlock door
domain represented follows let set variables defining state space
p locked locked true door locked let set states
locked state door locked
door unlocked let unlock unlock unlock three actions wherein agent
tries unlocking door three keys
let r hs unlock hs unlock hs unlock represent transition relation key unlocks door keys define r r similar
fashion e g r key unlocks door keys transition belief state
represents set possibilities consider consistent observations far consider
transition belief state given hs r hs r hs r e state world
fully known action model partially known
would agent able open door despite knowing key opens
agent learn actual action model e key opens door general
learning action model useful achieving immediate goal knowledge
useful agent attempts perform tasks domain
definition slaf semantics let transition belief state slaf
actions observations haj oj jt defined
slaf
hs ri hs r hs ri
slaf hs ri true
slaf haj oj iijt
slaf haj oj ii jt slaf oi slaf ai
step progression step filtering
example consider domain example progression action unlock
given slaf unlock hs r hs r hs r likewise filtering
observation locked door became unlocked given slaf locked hs r


fia mir c hang

example slightly involved example following situation presented figure
two rooms light bulb switch action flipping switch observation e east room real states world action
respectively shown top part known us
west

east


psfrag replacements

west


sw lit e




sw

r



east

sw lit e
r

r

r
r

r



r



figure top two rooms flipping light switch bottom slaf semantics progressing
action arrows map state transition pairs filtering observation
crossing pairs
bottom figure demonstrates knowledge evolves performing action sw
hs r hs r hs r r r e r includes hs sw identity full details r r r irrelevant omit
resulting transition belief state action sw observation e
slaf sw e
assume observations observation model relating observations state fluents
given us logical sentences fluents performing action denoted

transition belief states generalizes version spaces action e g
wang follows current state known version spaces lattice contains
set transition relations r hs ri thus perspective version spaces
slaf semantics equivalent set version spaces one state might
semantics generalizes belief states transition relation r known
belief state set possible states r hs ri read restricted r logical
filtering amir russell belief state action equal thus define
f ilter slaf hs ri r
thus slaf semantics equivalent holding set belief states conditioned transition
relation similar saying transition relation r belief state set states r

learning logical inference
learning transition definition directly intractable requires space
many cases reason explicit representation large set possible
transition state pairs instead section rest represent transition belief states compactly propositional logic many scenarios amount
structure exploited make propositional representation compact
p



fil earning partially bservable eterministic action odels

combinatorial argument implies encoding compact sets nonetheless
motivated success propositional logical approaches logical filtering amir russell
shahaf amir logical database regression reiter observe
propositional logic represents compactly natural sets exponential size
section define slaf operation propositional logical formulas
propositional formula output slafs input propositional formula represents transition
belief state slaf computes transition belief formula input sequence
actions observations
want slaf manipulate input formula produce correct
output use general purpose logical inference task section later sections
sidestep expensive general purpose inference make assumptions lead tractable rest focus deterministic transition relations namely transition
relations partial functions every action one outcome state every state
representing transition relations logic
initial solving slaf presented momentarily compact
representation transition belief states present logical encoding transition belief states
first define deduction next section
use following general terminology propositional logical languages terminological conventions apply without subscripts superscripts l denotes vocabulary e
set propositional variables use present context l denotes language e set
propositional sentences script greek letters stand propositional formulas
language present context f g stand formulas restricted context
see l denotes vocabulary l l denotes language built propositions
l standard propositional connectives l shorthand l l
represent deterministic transition relations propositional vocabulary l whose
propositions form afg f literal p g logical formula f
effect afg g precondition afg proposition afg takes truth value true
intended meaning g holds present state f holds state
executing
let f p p p p set effects f consider let g
set preconditions g consider rest section section assume
g represents single state recall identify state complete term
conjunction literals hold state use representation states write fs
instead afg later build definition consider gs general formulas
assumption g stated conclude l p p
propositional variables prove fundamental language set axioms
disregarding size language moment section focuses decreasing language
size computational efficiency
semantics vocabulary la lets every interpretation truth assignment la correspond transition relation rm every transition relation least one possibly
interpretation corresponds correspondence surjective onto injective
every propositional sentence l la specifies set transition follows


fia mir c hang

set satisfying interpretations interpretation la
specifies corresponding set transition relations rm
informally assume propositions afs afs k la take value true
propositions precondition
v take value false r action takes

state state satisfies ik identical otherwise exists e g
fj j k rm takes thus executable according
rm
following paragraphs interpretations l correspond transition relations
culminate precise definition correspondence formulas l l p
transition belief states
e nterpretation la c orresponds u nique ransition r elation
every interpretations la defines unique transition relation rm follows let interpretation la every state action define unique state
hs rm decide hs rm
gives interpretation every proposition afs f fluent negation
fluent p p aps ap
true truth value according interpretation
decide hs rm otherwise define
p p aps p ap

left hand side consider cases p p ps ap

right hand side treat cases p p aps ap
f alse
called inertia p keeps previous value lack specifications put another way

p aps p ap
view interpretation p rm well defined e
one rm every
e ransition r elation
la



l east ne c orresponding nterpretation



possible rm rm occurs two circumstances cases
hs rm b aps ap
f alse inertia
p
p


p p inertia
example first circumstance let p fluent let interpretation

aps ap
g define interpretation identical propositions
p p
p

besides follows define opposite truth assignment aps false
p
instead true true instead false define ap

rm rm map pairs way particular state
corresponds g hs rm similarly hs rm
finally every transition relation r least one interpretation r r see
define mr every hs r interpretation aps p fluent mr aps ru e iff
finally
p hs define mr ap
f alse iff p
p
p
define mr mr ru e r rmr
overload word model multiple related meanings model refers satisfying interpretation logical
formula transition model defined definition transition relation transition system action model
define introduction section well defined specification actions preconditions effects



fil earning partially bservable eterministic action odels

e ransition r elation efines f ormula la
every deterministic transition relation r defines logical formula whose set map
r many possible formulas define general one logical
equivalence make use inertia
define h r follows
f


h r afs af
la hs r f
p
p
h r p p

w


h r pp aps ap
hs r
h r h r h r h

h addresses fluent changes h addresses fluent innertia effectively disallowing innertia
definition h addresses conditions actions executable thus h r
includes model every interpretation satisfies rm r requires inertia
definition rm represents r satisfies rm r
illuminating see modeling decisions throughout section lead
last definition one hand choose every interpretation l correspond
transition relation simplify later arguments logical entailment consequently associate interpretations afs af
f alse transition relations r keep value f fixed inertia f
hand define h r choose axioms exclude thus
avoid include inertia simplifies later discussion learning
summary consider every interpretation la representing exactly one transition relation consider set axioms defining r define directly e without inertia
without afs af
f alse
ransition b elief tates c orrespond f ormulas la p
thus every
w transition belief state define formula l l p corresponds
h hs ri h r formulas exist would characterize similar way
equivalent stronger formulas l l
h r h r every model satisfies rm r
similarly every formula l la p define transition belief state hm p
rm e state transition pairs satisfy p restricted
p viewed complete term p say formula transition belief formula
h note h holds
transition formula filtering
section computing transition belief formula slaf successful
action transition belief formula equivalent logical consequence finding operation
characterization slaf consequence finding permits consequence finding
slaf important later proving correctness
tractable specialized
let cnl denote set logical consequences restricted vocabulary l
l
cn contains set prime implicates contain propositions set l


fia mir c hang

recall implicate formula clause entailed recall prime implicate formula implicate subsumed entailed implicates

consequence finding process computes cnl input example propositional resolution davis putnam chang lee efficient consequence finder
used properly lee del val marquis surveys prime implicates consequence finding thus cn l l l
set propositions p let p represent set propositions every proposition primed e proposition f annotated become f typically use primed
fluent denote value unprimed fluent one step future taking action let
p p denote formula primed fluents replaced unprimed counterparts example formula b p p equal b b p see section
discussion comparison relevant formal verification techniques
following lemma shows logical equivalence existential quantification quantified
boolean formulas consequence finding restricted vocabulary recall quantified boolean
formulas qbf propositional formulas addition existential universal quantifiers
propositions informally qbf x true given interpretation
exists true false valuation x makes true assignment lemma prove
useful showing equivalence slaf consequence finding
lemma x cnl x propositional logic formula propositional variable x
p roof
see section b
lemma extends easily case multiple variables
corollary formula set propositional variables x x cn l x
present updating transition belief formulas whose output equivalent
slaf slaf applied equivalent transition belief state applies
consequence finding input transition belief formula together set axioms define
transitions time steps present set axioms first
deterministic possibly conditional action action model time axiomatized
v
teff lf gg alg g l
w
v

l

lf l gg ag g

first part says assuming executes time causes l g holds g
holds time l holds time second part says l holds execution
must alg holds g holds current state two parts similar
fact somewhat generalize effect axioms explanation closure axioms used situation
calculus see mccarthy hayes reiter
ready describe zeroth level slaf slaf transition
belief formula let l p la vocabulary includes fluents time effect
propositions la recall definition slaf two operations progression
action filtering observation time apply progression given action
current transition belief formula apply filtering current observations


fil earning partially bservable eterministic action odels



slaf ot cnl teff p p ot



identical definition slaf semantics replacing

stated slaf implement cnl consequence finding
resolution variants e g simon del val mcilraith amir
lee iwanuma inoue following theorem shows formula slaf correct exact
theorem representation transition belief formula action
slaf hs ri hs ri satisfies
hs ri hs ri satisfies slaf
p roof
see section b
theorem allows us identify slaf slaf throughout rest
particular polynomial time slaf special cases correct
showing output logically equivalent slaf
u sing



utput



slaf

output slaf transition belief formula logical formula way
use formula answering questions slaf depends query form
output formula wish transition model state possible wish see
interpretation l p la output slaf
answer found simple model checking example check
interpretation satisfies logical formula assign truth values variables interpretation formula computing truth value formula done linear time
thus type query slaf takes linear time size output formula
slaf final query propositional interpretation propositional formula
wish transition model possible state possible
propositional satisfiability sat solver e g moskewicz madigan zhao zhang
malik similarly wish answer whether possible satisfy property
use sat solver
example recall example discuss locked door three combinations let
locked let slaf unlock locked wish implies trying
unlock door key fails open equivalent asking consistent
give value true unlock locked
locked
answer query taking slaf output formula checking
unlock locked
locked sat model follows deduction theorem propositional logic
iff sat
one example application goal achievement chang amir
relies sat potential plans given partial knowledge encoded
transition belief formula
model checking sense used formal verification literature model transition
model checking done updating formula obdd transformations



fia mir c hang

zeroth level may enable compact representation guarantee
guarantee tractable computation fact maintain compact representation tractable computation general deciding clause true slaf
conp hard similar decision logical filtering conp hard eiter gottlob amir russell even deterministic actions input representation
includes initial belief state formula cnf input representation filtering
includes propositional encoding cnf known transition relation
representation transition belief states uses poly p propositions grows exponentially number time steps p starting transition belief states action
sequences actions allowed nondeterministic question whether exponential growth must happen deterministic actions flat formula representations e g cnf
dnf etc see darwiche marquis open logical circuits known give solution
deterministic actions representation given terms fluents time shahaf et al


factored formula update
update representation hard must consider set interactions parts
representation operations used slaf consider interactions manipulate
add many interactions processing broken independent
pieces computation scales linearly number pieces e computation time
total times takes piece separately important decompositions
enable independent pieces computation hereforth examine one type decomposition
namely one follows logical connectives
learning world easier slaf distributes logical connectives function
f distributes logical connective f f f computation
slaf becomes tractable distributes bottleneck computation case
becomes computing slaf part separately
section examine conditions guarantee distribution present linear time
gives exact solution cases
gives weaker transition belief formula distribution possible
distribution properties hold slaf follow set theoretical considerations
theorem
theorem transition belief formulas action
slaf slaf slaf
slaf slaf slaf
p roof
see appendix b
stronger distribution properties hold slaf whenever hold logical filtering
theorem let transition belief states
slaf slaf slaf
follows theorem filtering amir russell even provide proper axiomatization
note axiomatization deterministic actions



fil earning partially bservable eterministic action odels

iff every r
r
r
r
f ilter r
f ilter f ilter

conclude following corollary theorems theorems amir russell

corollary transition belief formulas action slaf slaf
slaf every relation r one following holds
r maps states
r conditional effects includes prime implicates observe
fails
state known r one hs ri
condition combines semantics syntax particularly useful correct computation
slaf later sections states particular syntactic form namely together
include joint prime implicates simple enough necessarily
computation slaf broken separate slaf
figure presents procedure factored slaf computes slaf exactly conditions corollary hold consequently factored slaf returns exact solution whenever
actions known actions conditional effects success failure
observed modified factored slaf solve exactly see section
procedure factored slaf hai oi
ai action oi observation transition belief formula

set step slaf oi ai
b eliminate subsumed clauses
return
procedure step slaf
observation formula l p action transition belief formula
literal return oliteral slaf
return step slaf step slaf
return step slaf step slaf
procedure literal slaf
action proposition lt negation

return cnl teff p p

figure slaf distribution
pre compute cache n possible responses literal slaf every time step
procedure requires linear time representation size transition belief formula
time step significant improvement super exponential time taken
straightforward potentially exponential time taken general purpose
consequence finding used zeroth level slaf procedure
theorem step slaf returns formula slaf every run
literal slaf takes time c step slaf takes time c recall syntactic
representation size finally assume one assumptions corollary
slaf


fia mir c hang

belief state formula transition belief formula effect propositions e includes fluent variables propositions form fg identical traditional
use term belief state formula e g amir russell give closed form solution slaf belief state formula procedure literal slaf figure makes
procedure literal slaf tractable avoiding general purpose inference filtering single literal
allows us examine structure belief state formulas detail
v
theorem belief state formula l p action ca gg lf alg al
g
g gm g terms g gi
slaf






li
li ag
ca


l lm f

v

l lm f means conjunction possible combinations selections literals
f
p roof
see appendix b
theorem significant says write slaf
prescribed form form still potentially exponential size boils simple
computations proof follows straightforward though little long derivation possible
prime implicates slaf
consequence theorem implement procedure literal slaf
equivalence


theorem
l l p
slaf l
l slaf true otherwise

notice computation theorem l literal simple g gm
complete terms l p include l computation require general purpose
consequence finder instead need answer n queries initialization phase namely
storing table values slaf l l p l p p p
l true
general could high p number complete terms g finding g gm
may take time exponential p still simplicity computation formula provide
basic ingredients needed efficient computations following sections restricted cases
give guidelines future developments slaf

compact model representation
previous sections presented potentially intractable long sequences actions
observations example theorem could high p number complete
terms g consequently clauses may exponential length n p may
super exponential number clauses
section focus learning action efficiently presence action preconditions failures important agents partial domain knowledge
therefore likely attempt inexecutable actions
restrict attention deterministic actions conditional effects provide
overall polynomial bound growth representation size many steps


fil earning partially bservable eterministic action odels

time taken compute resulting model class actions generalizes strips fikes hart
nilsson apply large part ai literature
give efficient learning non conditional deterministic action effects
preconditions well efficient learning actions effects presence
action failures
actions limited effect
many domains assume every action affects k fluents small k
common assume actions strips may fail without us knowing
leaving world unchanged assumptions together allow us progress slaf limited
polynomial factor growth formula size
use language similar one section uses action propositions
alg g
fluent term size k instead fluent term size n g semantically
v
l
al lk lk ln ln
theorem let l p belief state formula strips action k fluents
affected precondition term let g k set terms k fluents l p
consistent
slaf



k


li
li ag
ca



g gk g k
g gk
l lk f

v
refers conjunction possible combinations selections literals
f g gk g k g gk
p roof
see section b
main practical difference theorem theorem smaller number
terms need checked practical computation limited language enables entails
limited number terms play specifically k literals
preconditions need check combinations k terms g gk g k computation
bounded exp k iterations
proof uses two insights first one case change occurs every
clause theorem subsumed clause entailed slaf one
algi per literal li e li lj j gi fluent term disjunctions second every
alg g term equivalent formula algi gi terms length k affects k
fluents
thus encode clauses conjunction subset extended action
effect propositions alg g term size k nk terms nk
propositions every clause length k identity clause determined

first half set action effect propositions consequently slaf takes nk k k

space represent nk k clauses length k


fia mir c hang

actions conditional effects revised language
thisssection reformulate representation presented section let
l f aa af af af f f every f p let vocabulary formulas representing transition belief states defined l p l f intuition behind propositions
vocabulary follows
v
al causes l literal l formally al ss als
v
af keeps f formally af ss f afs f af

v

thus l
l causes false l formally l ss l als al

precondition executing must hold executes
model transition belief formula l valuation fluents p defines
state valuation propositions l f defines unconditional deterministic transition
relation follows action proposition af af true action transition
relation causes f f hold executed action proposition f true
action affect fluent f action proposition f f true f f
precondition assume existence logical axioms disallow inconsistent
impossible axioms
af af af
af af af af af af


f f

possible f p first two axioms state every action model exactly one
af af af must hold thus causes f negation keeps f unchanged last axiom
disallows interpretations f f hold state axioms
need represent constraints explicitly transition belief formula
use set theoretic propositional logic notations transition belief states interchangeably note vocabulary defined sufficient describing unconditional
strips action model deterministic action model general
example consider domain example transition belief state represented transition belief formula
locked
unlock locked unlock locked unlock locked
unlock locked unlock locked unlock locked
unlock locked unlock locked unlock locked

provide axiomatization equivalent slaf special case eff
notation p p recall intend primed fluents represent
value fluent immediately action taken


fil earning partially bservable eterministic action odels

eff



prea f effa f

f p

prea f





l l

l f f

effa f





al af l l l al af l

l f f

prea f describes precondition action states literal l occurs precondition
literal l must held state taking formula eff f describes effects
action states fluents taking action must consistent according
action model defined propositions af af af
revised axiomatization action eff leads equivalent
definition slaf within restricted action


theorem successful action slaf cn lp eff p p
p roof

see appendix b

successful non conditional actions
ready present learns effects actions conditional
effects allows actions preconditions fully known still
assumes filtered actions executed successfully without failures cannot effectively
learn preconditions e g would know knew originally
preconditions seeing sequence events sequence actions might example
generated expert agent whose execution traces observed
maintains transition belief formulas special fluent factored form defined maintaining formulas special form certain logical consequence
finding operations performed efficiently formula fluent factored conjunction formulas f f concerns one fluent f action propositions
every fluent f f conjunction positive element negative element
neutral one f f explf f explf af explf explf af formulae action
propositions af af f f af possibly multiple different actions intuition
explf explf possible explanations f true false respectively
af holds knowledge actions effects preconditions f knowledge
depend f current value note formula l l f represented fluentfactored formula nonetheless translation sometimes leads space blowup maintain
representation form construction
learning strips slaf shown figure simplify exposition
described case single action observation pair though obvious
apply sequences actions observations whenever action taken first
subformulas af explf explf f updated according steps c
strips slaf extends ae strips slaf amir allowing preconditions actions



fia mir c hang

strips slaf ha oi
inputs
v successful action observation term fluent factored transition belief formula
f p f

returns fluent factored transition belief formula slaf ha oi
every f p
set af f explf f explf af
b set explf af af f explf
c set explf af af f explf

f f observed seta f f f af explf
e f set f f f af explf note f
f nothing beyond earlier steps
simplify e g eliminate subsumed clauses
return
term f explf f explf appear without simplification
conform step emphasizes syntactic nature procedure
implicit logical simplification assumed

figure slaf successful strips actions
observation received f updated according observation according steps
e step merely indicates implementations likely simplification
procedure used formula subsumption elimination however use
simplification procedure strictly necessary order theoretical guarantees
hold
example know nothing actions affect f e g start exploration
f f ru e f ru e ru e representation slaf f
conjunction f explf f explf af computed step procedure strips slaf
similar formula holds observations
following theorem shows correctness shows steps taken
produce equivalent logical consequence finding characterization
slaf theorem
theorem slaf ha oi strips slaf ha oi fluent factored formula
successfully executed action observation term
p roof
see appendix b
time space complexity procedure strips slaf given following
theorem time guarantee shown procedure takes linear time size input
formula condition receives observations often enoughspecifically


fil earning partially bservable eterministic action odels

every fluent observed least every k calls procedureit possible
transition belief formula remains k cnf indefinitely recall k cnf
fixed k conjunction clauses size k thus regardless length actionobservation input sequence output strips slaf value throughout
computation k cnf amounts space guarantee size formula
theorem following true strips slaf
procedure takes linear time size input formula single action observation
pair input
every fluent every k steps observation fluent one steps
input formula k cnf resulting formula arbitrary number
steps k cnf
input strips slaf fluent factored output
p roof
see appendix b
following corollary follows immediately
corollary order process steps actions observations strips slaf requires
p time additionally
every fluentis observed every k steps resulting
formula size p k
corollary holds theorem guarantees bound size belief state
formula point

learning actions may fail
many partially observable domains decision making agent cannot know beforehand whether
action decides take fail succeed section consider possible action failure
assume agent knows whether action attempts fails succeeds trying
action
precisely assume additional fluent ok observed agent
ok true action succeeded failed action case may viewed
extra observation agent preconditions action met
action failure equivalent observation


f f f f

f p

action failures make performing slaf operation considerably difficult particular
observations form cause interactions fluents value particular fluent
might longer depend action propositions fluent action propositions
fluents well transition belief states longer represented convenient fluentfactored formulas cases becomes difficult devise give
useful time space performance guarantees


fia mir c hang

pre strips slaf
inputs action observation
term transition belief formula following facv w
tored form j j j fluent factored formula
returns filtered transition belief formula
ok
w
set f li li literals appearing precondition
f l v
fluent factored formula equivalent l e f l l l
f p f f

b set j strips slaf j j
else ok
j

set j strips slaf p j p precondition
ii set j strips slaf ha oi j
j factored ai j bi j bi j contains clauses containing
fluent p
w exists b j b j b replace
w


b

j ai j
j j
simplify j e g remove subsumed clauses
return
figure handling action failures preconditions known
shall demonstrate action failures dealt tractably assume action
preconditions known agent agent must learn effects actions
take need learn preconditions actions particular means
action given access formula precisely logical term p describing
precondition action clearly need learn preconditions
actions restrict action proposition vocabulary used describe belief states
ones forms af af af longer need action propositions forms f
f
present procedure pre strips slaf figure performs slaf transition belief
formulas presence action failures actions non conditional effects maintains transition belief
conjunctions disjunctions fluent factored formulas formulas
v formulas
w
form j j j fluent factored naturally formulas superset
fluent factored formulas
pre strips slaf essentially identical cnf slaf shahaf et al



fil earning partially bservable eterministic action odels

operates follows action executes successfully ensuing observation received component fluent factored formulas j filtered separately
according strips slaf procedure action observation pair step
hand action fails disjunction fluent factored formulas appended transition
belief formula step component disjunction corresponds one possible reasons action failed e one literals occurring actions precondition finally
observations accumulated learning collapses disjunctions fluent factored
formulas occurring belief formula together step simplifies generally step
decreasing total size formula case strips slaf simplification
steps necessary order time space guarantees hold
proof correctness pre strips slaf relies distribution
section theorem corollary
proceed correctness pre strips slaf following theorem shows
procedure returns filtered transition belief formula logically weaker
exact produces safe approximation additionally theorem shows
conditions corollary filtered transition belief formula exact
theorem following true
slaf pre strips slaf
pre strips slaf slaf corollary holds
p roof
see appendix b
consider time space complexity following theorem shows
procedure time efficient given frequent enough observations theorem
space efficient transition belief formula stays indefinitely compact
theorem following true pre strips slaf
procedure takes time linear size formula single action observation pair
input
every fluent observed every k steps input formula k cnf
filtered formula k cnf maximum number literals action
precondition
p roof
see appendix b
therefore get following corollary
corollary order process steps actions observations pre strips slaf requires
p time every fluent
observed least
frequently every k steps resulting
mk
formula size p


building
section describe briefly one might extend include elaborate
observation model bias parametrized actions


fia mir c hang

expressive observation model
observation model use throughout simple every state fluent
observed value v value current state consider observation
model general
observation model set logical sentences relates propositions set obs
fluents p obs includes propositions appear p independent
previous following state times given fluents time
slaf conjoining cnlt oo e finding prime implicates
conjoining embed extension slaf
maintain structures use k cnf every step
observe variable finding prime implicates easy embedding
transition belief formula done conjunction prime implicates formula
removal subsumed clauses resulting formula still fluent factored input
fluent factored remain applicable time complexity
replacing ot prime implicates ot ot
model described provide exact solution slaf
tuples hs ri solution consistent observations compute
solution slaf represented logical formula use sat solver e g moskewicz
et al answer queries formula checking entails f action
fluent f would consistent action makes f value true
number variables formula independent linear p
therefore use current sat solvers treat domains
features
preference probabilistic bias many times information leads us prefer
possible action others example sometimes assume actions change
fluents suspect action e g open door affect features e g
position normally represent bias preference model e g mccarthy
ginsberg probabilistic prior transition relations e g robert celeux diebolt

add bias end slaf computation get exact solution
compute effect bias together logical formula efficiently preferential biases
studied fit easily e g use implementations
doherty lukaszewicz szalas inference bias
inference probabilistic bias logical sentences emerging
used hajishirzi amir challenge enumerate
tentative explicitly challenge overcome success work hajishirzi
amir similar task filtering use apply probabilistic
bias resulting logical formula
example given probabilistic graphical model e g bayesian networks set propositional logical sentences consider logical sentences observations


logical sentence gives rise characteristic function
x
x satisfies
otherwise conjunction clauses get set functions one per clause thus
inference combined probabilistic logical system probabilistic inference example


fil earning partially bservable eterministic action odels

one consider variable elimination e g dechter additional potential
functions
parametrized actions many systems situations natural use parametrized actions
action schemas whose effect depend parameters definition applies
identically instantiations
example move b x action moves b position x position
b x parameters action common systems e g strips
pddl situation calculus complete treatment parameterized actions outside scope
give guidelines generalization current actions
consider domain set fluent predicates universe named objects propositional fluents defined domain ground instantiations predicate fluents slaf
work set propositional fluents instantiated actions manner


rest action propositions x lg instantiated every vector object names


x




lg
different treatment comes additional axioms say
x

x lg
inference transition belief state axioms able join information collected
different instantiations actions expect thorough treatment
able provide efficient whose time complexity depend number action
schemas instead number instantiated actions
several approaches already start address including work nance vogel
amir filtering work shahaf amir slaf

experimental evaluation
previous sections discussed settings consider solutions showed modifying traditional settings learning dynamic partially observable
domains important determinism alone lead tractability additional assumptions simple logical action structure bounded frequency observations fluents
specifically far showed time space computing slaf length time
sequence n fluents polynomial n
section considers practical considerations involved slaf procedures
particular examines following questions
much time space slaf computations take practice
much time required extract model logical formula
slaf procedures
quality learned model taking arbitrary consistent model far
true generating model
conditions correctness hold practice
learned model used successful execution learning
procedures fit execution
implemented ran experiments strips slaf following domains taken rd international competition ipc drivelog zenotravel
blocksworld depots details domains learning appear appendix c


fia mir c hang

experiment involves running chosen sequence randomly generated
action observation sequences steps information recorded every steps
random sequence generator receives correct description domain specified
pddl ghallab howe knoblock mcdermott ram veloso weld wilkins fox long
plannig domain description language size domain starting state
size domain number propositional fluents set specification
number objects domain number arity predicates domain generates
valid sequence actions observations domain starting state e sequence
consistent input pddl generator actions may fail action failure
consistent pddl action attempted state canot execute
experiments chose observations follows every time step select
fluents uniformly random observe applied additional restrictions making sure
fluent observed every fixed k steps
slaf receives sequences actions observations domain
information otherwise e g receive size domain fluents starting state
pddl starting knowledge empty knowledge true
domain ran different numbers propositional fluents
fluents collected time space taken slaf computation plotted
function input sequence length dividing total computation time steps
time space shown figures graphs broken different
domains compare time space taken different domain sizes time slaf time
without cnf simplification e g remove subsumed clauses
much time space slaf computations take practice answer first
question observe figures time per step remains relatively constant
throughout execution consequently time taken perform slaf different domains grows
linearly number time steps see time slaf grows domain
size scales easily moderate domain sizes ms per step slaf domains fluents
much time required extract model logical formula
slaf procedures slaf procedures return logical formula sequence actions
observations need apply work extract candidate consistent model
formula computation done sat solver cnf formulas
quality learned model taking arbitrary consistent model far
true generating model sometimes many possible little
bias must consider possible likely decided introduce one
bias namely actions instances actions schemas thus actions assumed
effect parameters objects given properties parameters thus
actions effects assumed independent identity parameter
vanilla implementation propositions look
stack
stack
stack
stack
etc

e
e



g
g
b


causes
causes
causes
causes






e
g



g
e
b




fil earning partially bservable eterministic action odels

slaf time step blocksworld domain






time ms



fluents
fluents
fluents
fluents
fluents
























input sequence length

slaf time step depots domain






time ms



fluents
fluents
fluents
fluents
fluents
























input sequence length

figure slaf time without cnf simplification domains blocksworld depots

instead replace ground propositions schematized propositions
stack x causes x
stack x causes x
stack x causes x
etc
thus belief state formula looks something


fia mir c hang

slaf time step driverlog domain




time ms


fluents
fluents
fluents
fluents
fluents





















input sequence length

slaf time step zeno travel domain






time ms


fluents
fluents
fluents
























input sequence length

figure slaf time without cnf simplification domains driverlog zeno travel



e g
stack x causes x
stack x keeps x
stack x needs x



fil earning partially bservable eterministic action odels

slaf space blocksworld domain
k

space lisp symbols

k

k
fluents
fluents
fluents
fluents
fluents

k

k

k

k














input sequence length

slaf space depots domain
k

k

space lisp symbols

k

k

fluents
fluents
fluents
fluents
fluents

k

k

k

k

k














input sequence length

figure slaf space domains blocksworld depots

example fragment model complete output given appendix c consistent
training data
blocksworld domain
fluents
randomly selected actions
fluents observed per step
schematized learning


converting cnf
clause count
variable count
adding clauses
calling zchaff

fia mir c hang

slaf space driverlog domain
k

space lisp symbols

k

k

fluents
fluents
fluents
fluents
fluents

k

k

k














input sequence length

slaf space zeno travel domain
k

space lisp symbols

k

k
fluents
fluents
fluents

k

k

k

k














input sequence length

figure slaf space domains driverlog zeno travel

precondition heuristics

parsing
slaf time
inference time
learned model

unstack needs clear underob
unstack needs clear ob
unstack needs arm empty


fil earning partially bservable eterministic action odels

unstack
unstack
unstack
unstack
unstack
unstack
unstack
unstack
unstack
unstack
unstack
unstack
unstack


needs holding ob
needs ob underob
causes clear underob
causes clear ob
causes arm empty
causes holding ob
causes ob underob
keeps table underob
keeps table ob
keeps holding underob
keeps underob underob
keeps ob ob
keeps underob ob

sometimes multiple possible schematized propositions correspond ground
action proposition case disjoin propositions together replacement
e single ground propositional symbol gets replaced disjunction schema propositions
replacement simple procedure one effective deriving information fewer steps speeding model finding slaf formula implemented
run slaf runs one could sat solving portion
equivalent
regarding latter ran scaling issues sat solver zchaff moskewicz et al
tang yinlei yu malik common lisp compiler large experiments got
around issues applying replacement scheme thus reducing greatly number
variables sat solver handles
another issue ran sat solver tended choose blank preconditions sequences used experiments include action failure preconditions never eliminated add bias extracted action model
added axioms following form
causes f needs f
causes f needs f
axioms state action causes fluent f hold requires f hold
precondition similarly analagous axiom f intuitively axioms cause
sat solver favor action got idea heuristic work wu
yang jiang uses somewhat similar set axioms bias terms
learning preconditions clearly axioms dont hold one see
learned preconditions often inaccurate
inaccuracies learned action reasonable example fluent
never changes course action sequence may infer arbitrary action
causes fluent hold
conditions correctness hold practice scenarios
report conditions guarantee correctness hold experiments assumed main conditions hold namely actions


fia mir c hang

deterministic preconditions enforce observations every fluent
every fixed k steps latter condition necessery correctness
necessary guarantee polynomial time computation experiments verify necessary practice indeed case polynomial time guarantee
modified observation
earlier work hlubocky amir included modified version stripsslaf architecture tested suite adventure game virtual environments
generated random include arbitrary numbers places objects kinds
configurations settings agents task exit house starting
knowledge state space available actions effects characteristics objects
experiments agent learns effects actions efficiently agent
makes decisions learned knowledge inference resulting representation fast
fraction second per sat domains including object modes
locations
learned model used successful execution learning
procedures fit execution learned model used
translating pddl however model correct one domain
plan may feasible may lead required goal cases interleave
execution learning described work chang amir
one finds short plan consistent action model executes plan collects observations
applies slaf plan failure detected e g goal achieved
chang amir guarantee joint execution learning procedure
would reach goal bounded amount time bounded time fact linear length
longest plan needed reaching goal exponential complexity action
model need learn

comparison related work
hmms boyen koller boyen et al murphy ghahramani used
estimate stochastic transition model observations initially expected compare
work hmm implementation murphy uses em hill climbing
unfortunately hmms require explicit representation state space smallest domain features requires transition matrix entries prevents initializing hmms
procedures current computer
structure learning approaches dynamic bayes nets dbns e g ghahramani jordan
friedman murphy russell boyen et al use em additional approximations e g factoring variation sampling tractable however still
limited small domains e g features ghahramani jordan boyen et al
unbounded errors discrete deterministic domains usable settings
simple learning transition devised work holmes
charles lee isbell deterministic pomdps transition observation
deterministic close represents hidden state possible finite structure looping prediction suffix tree structure seen
related representation grow relate action histories possible
transition work interactions realized recursive structure


fil earning partially bservable eterministic action odels

transition belief formula built strips slaf e g
af af f explf
explf refers similar formula created previous time step
main difference draw work holmes charles
lee isbell latter refers states explicitly whereas work refers features
consequently representation provably compact procedures scale larger
domains theoretically practice furthermore procedure provably maintains reference possible data insufficient determine single model whereas
work holmes charles lee isbell focuses limit case enough information determining single consistent model side procedure consider
stochasticity belief state remains area development
similar relationship holds work littman sutton singh
work model representation given size linear number states model
predictive state representation psr action observation histories predicts behavior histories work prefers low dimensional vector basis instead featurebased representation states one traditional hallmarks knowledge representation
necessary correspondence basis vectors intuitive features real world necessarily enables representation world closely
behavior
learning psrs james singh nontrivial one needs good lowdimensional vector basis stage called discovery tests stage learning psrs requires
matrices size n states spaces size n
work advances line work providing correct time polylogarithmic number states specifically work learns deterministic transition
polynomial time state features thus taking time poly log n
reinforcement learning rl approaches sutton barto bertsekas tsitsiklis
compute mapping world states preferred actions highly intractable
partially observable domains kaelbling littman cassandra approximation e g
kearns mansour ng meuleau peshkin kim kaelbling even dar kakade
mansour mccallum practical small domains e g features
small horizon time
contrast hmms dbns rl exact tractable large domains
features take advantages properties common discrete domains determinism
limited effects actions observed failure
previous work learning deterministic action ai literature assumes
fully observable deterministic domains learn parametrized strips actions e g version spaces gil wang general classifiers oates cohen hill climbing
ilp benson recently work pasula et al gave learns stochastic actions conditional effects work schmill oates cohen approximates
partial observability assuming world fully observable apply partially
observable learning sometimes space belief states instead world states
increases size exponentially practical
finally recent learning action partially observable domains includes
works yang wu jiang shahaf amir works yang et al


fia mir c hang

example plan traces encoded weighted maximum sat
candidate strips action model extracted general may many possible action
given set example traces therefore nature approximate contrast
identifies exact set possible action work introduces
additional approximations form heuristic rules meant rule unlikely action
work shahaf amir presents solving slaf logicalcircuit encodings transition belief states performs tractable slaf general deterministic present section requires sat solvers
logical circuits sat solvers optimized nowadays comparison cnf sat
solvers overall performance answering questions slaf lower
importantly representation given shahaf amir grows linearly number
time steps still hinder long sequences actions observations comparison
transition belief formula bounded size independent number time steps
track
encoding language la typical methods software hardware verification
testing relevant books methods e g clarke grumberg peled closely related
representation achieve applicable vice versa
main distinction draw work done formal methods e g model
checking bounded model checking able conclude size bounds logical formulas involved computation obdds used success model checking
cnf representations used success bounded model checking little
bounds sizes formulas theory practice conditions available ai applications
used current manuscript deliver bounds yield tractability scalability
theoretical practical significance
interestingly methods use linear temporal logics ltl cannot distinguish
happen actually happens calvanese giacomo vardi thus cannot
consider causes occurence method similar consider alternate
futures state explicitly however use extended language namely l makes
alternatives explicit allows us forego limitations ltl produce needed

conclusions
presented framework learning effects preconditions deterministic actions
partially observable domains differs earlier methods focuses determining exact set consistent action earlier methods showed several
common situations done exactly time polynomial sometime linear number time steps features add bias compute exact solution large domains
hundreds features many cases furthermore number action observation
traces must seen convergence polynomial number features domain
positive contrast difficulty encountered many approaches learning
dynamic reinforcement learning partially observable domains
presented promising many applications including reinforcement
learning agents virtual domains hmms already work applied autonomous
agents adventure games exploration guided transition belief state compute


fil earning partially bservable eterministic action odels

information gain criteria future plan extend stochastic domains
domains continuous features

acknowledgments
wish thank megan nance providing code samples sequence generator
wish thank dafna shahaf encouraging collaboration enhanced development understanding first author wishes acknowledge stimulating
discussion brian hlubocky related topics wish acknowledge support daf
air force laboratory award fa darpa real program second
author wishes acknowledge support university illinois urbana champaign college
engineering fellowship finally first author acknowledges support joint fellowship
center advanced studies beckman institute university
illinois urbana champaign
earlier versions manuscript appeared conference proceedings amir
shahaf et al

appendix representation domain descriptions
transition relation rm interpretation la defined section way
similar interpretation domain descriptions domain descriptions common method
specifying structured deterministic domains fagin ullman vardi lifschitz
pednault gelfond lifschitz methods equivalent contexts
include successor state axioms reiter fluent calculus thielscher
relevance influence work merit separate exposition relationship work
domain description finite set effect rules form causes f g describe effects actions f g state formulas propositional combinations fluent
names say f head effect g precondition rule write
causes f causes f true denote ed set effect rules action
effect rule e let ge precondition fe effect rule e active state
ge taken interpretation p
every domain description defines unique transition relation r follows
v
let f conjunction effects rules active e fe e
ed ge set f ru e rule active
let set fluents affected e f p e
ed ge f
l fe
define recalling world states sets fluents





rd hs

f

thus action effect false cannot execute
definition applies inertia fluent keeps value fluents appear active rule
contexts useful specify inertia explicitly extra effect rules form
keeps f g fluent f p shorthand writing two rules causes f f g
causes f f g includes inertia keeps statements say
complete domain description


fia mir c hang

example consider scenario figure assume actions observations occur
figure actions assumed deterministic conditional effects preconditions
must holds execute successfully every action affects every fluent negatively
positively thus every transition relation complete domain description
includes rules form causes l keeps l l fluent literal fluent
negation
time step
action
location
bulb
switch



go w

e

sw


e
lit


go e


e

sw

sw


e

sw

go w


e
lit


go e


e

sw

figure action observation sequence table entries observations legend e east e
west lit light lit light sw switch sw switch

consequently every transition relation r completely defined domain description
viewing tuple set elements




causes e causes sw causes lit

causes e causes sw causes lit
r



keeps e

keeps lit
keeps sw
go w








go e



sw

say initially know effects go e go w know sw
transition filtering starts product set r possible relations possible
states time step know world state exactly e lit sw try sw
get f ilter sw includes set transition relations
transition relations projecting state e lit sw appropriate choice
receive observations e sw time step f ilter f ilter sw
removes transition belief state relations gave rise e sw left
transition relations satisfying one tuples




sw causes lit


sw causes e
sw causes lit
sw causes sw
sw keeps e


sw keeps lit

finally perform action go w update set states associated every
transition relation set pairs receive observations time step
conclude f ilter f ilter go w





sw keeps e
sw causes e


e
e










sw causes sw
sw causes sw
lit
lit




sw causes lit
sw causes lit










sw
sw





go e
go e



fil earning partially bservable eterministic action odels

appendix b proofs
b proof lemma consequence finding existential quantification
p roof
consider cnf form suppose clauses containing literal x x
x clauses suppose clauses containing literal x
x x b v
suppose clauses
containing x x c note
v
l x
cn
ic ia jb j formula produced adding
resolvents variable x removing clauses belonging l l x since
resolution complete consequence finding
necessity x cnl x consider model x definition
extended l e assigning value x extend
case suppose contradiction model cn l x cannot
case k k contradiction must case
j j b therefore j
model x x j thus
j contradiction
sufficiency cnl x x consider model cnl x suppose
contradiction x extended l extend
l x cannot case k k since
cnl x x cannot case x j j
therefore x therefore j
j n must j j alter x
satisfies contradiction
b proof theorem
p roof
sides equality relation sets state transition relation pairs
two sets elements first left hand side equality
contained right hand side
take hs ri slaf hs ri hs ri satisfies definition
hs ri satisfies hs r words
hs ri satisfies hs r
prove hs ri satisfies slaf need teff model
rm r interprets p let interprets p interprets p mr
interpreting la previous
section interpretation

wsatisfy formula
v
v
one conjuncts lf gg alg g l lf l gg alg g falsified
cannot case choice
assume contradiction alg g l fails l alg g hold l
false portion interprets la built according mr r since hs r
know satisfies l construction mr contradicts l false
interprets p according therefore conclude alg g l every l
w
similarly assume contradiction l gg alg g fails l l holds
als fails way constructed mr must als takes value
corresponds l truth value thus must als takes value true
done first direction


fia mir c hang

opposite direction showing right hand side contained left hand side take
hs ri satisfies slaf
hs ri slaf hs ri hs ri satisfies
hs ri slaf implies corollary hs r si
teff r interpreting p la p respectively similar argument one give
first part shows hs r hs ri slaf hs ri hs ri satisfies

b proof theorem distribution slaf connectives
first part sets slaf slaf
slaf identical
take model slaf let model slaf
model model without loss generalization assume
model thus slaf follows model slaf
slaf
direction take model slaf slaf model
slaf model slaf without loss generalization assume
model slaf take model slaf
follows slaf
similar argument follows case take model slaf let
model slaf model thus
slaf slaf follows model slaf slaf

b proof theorem closed form slaf belief state formula
p roof sketch
follow characterization offered theorem formula
take teff resolve literals time resolution guaranteed generate
set consequences equivalent cnlt teff
v
assuming teff logically equivalent teff lf gg g alg gt
v
lt lf gg g lt gt alg follows two observations first notice
implies g g g get gt alg alg gt lt
antecedent notwhold formula true second notice
v second part
original teff gg g alg gt equivalent assuming gg g gt alg
resolving literals time teff consider
resolutions clauses gt term form alg gt lt clauses form
lt gt alg yields equivalent





lit

g
wgm g
im gi
l lm f



li
algi
ag



eliminate w
literals time resolve together sets clauses matching gi gi formula encodes resulting clauses chosen


fil earning partially bservable eterministic action odels

li

set g gm chosen set literals l lm reason including al
gi agi
choose clause gi li specific type one includes alg
one produces al
g
finally get formula theorem afg af
g g characterizes exactly one
state fact one set g gm stronger rest entails
rest g gm complete terms set complete fluent assignments g
satisfy

b proof theorem closed form k affected fluents
p roof sketch
literal l clause c conjunction theorem aggregate
action propositions single action proposition algl g disjunction complete
preconditions l c notice cannot ls negation c tautology
lemma b shows gl equivalent fluent term first prove restricted lemma
b
w
li

clause formula theorem let gl
lemma b let c
ag
li

w
gi li l gi li literal l assume effect deterministic
one case term precondition case hold nothing changes g l
equivalent term
p roof
gl disjunction complete state terms gi represents set states
corresponds gi intuition apply
w
lit algi
c
w
vm

algi
li

l
gl l c
c part c affect l reason complete terms g know
li
l

al
gi agi thus choice g includes conditions l
changes assume precondition algl
compute action model l updating copy g l let li fluent literal
set glt gl
gl glt gl li terms glt include li thus
glt glt li algl algl li thus add li conjunct glt
otherwise gl glt gl li terms glt include li
thus glt glt li algl algl li thus add li conjunct glt
otherwise know li li value fluent l changes l
true since assume value l changes single case preconditions
e conditional effects succeeds change fails change
li cannot part preconditions e every term g glt replace li
li vice versa precondition would still entail l action thus
algl algl l glt li replacing li li true






related literal l proof



fia mir c hang

replacements term glt consistent consistent
original gl satisfies case algl algl


w
li

cl
lemma b let c
ag
clause formula theorem let g
li

w
gi li l literal l assume effect deterministic one case
cl equivalent
term precondition case hold nothing changes g
cl
term c subsumed another clause entailed formula g
equivalent term
gl

cl
p roof
consider gl lemma b let gl complete fluent term g
l
l
l
thus g l let gt term equivalent g according lemma b
clause c equivalent algl al
however algl already asserts change l l
gl






action al
asserts change different condition l l thus
gl


get subsuming clause c c al
way
case algl al
gl
gl






remove c literals algi gi gl

cl however clause c
process left clause c gl g
form theorem gi missing represent
theorem must allow gi missing

proof theorem continues thus representation c clause takes space n
propositional symbol encoded n space assuming constant encoding every
fluent p p
however number propositional symbols still large n fluent terms
encoding still requires n n preconditions effects propositional symbols
notice limit attention clauses c k literals l whose action
proposition algl satisfies gl l k propositions c
v
w
l
say algi l ik c ki algi l agk
im lit subsumed
l


k
v
l


latter


sentence
true assume change
ki algi l agk
l


k

k fluents agk
asserts lk remains algi l asserts li changes
lk

one conditions satisfied gli
v
l
state k effects
clauses form ki algi l agk
l
l



k

l

resolve away agj l j k every clause c original conjunction thus
j
w
v
left clauses form c ki algi l im lit since choice literals

l lk independent rest clause every polarity
fluents get clauses resolve combinations literals
subsumed
k


lit

c algi l






ik

fil earning partially bservable eterministic action odels

thus get conjunction clauses form g li k fluent term
conjunction clauses theorem equivalent conjunction clauses
clause k literals thus space required represent clause kn
finally use fact every action dependent k fluents every proposition asserts change li equivalent conjunction literals stating none
possible k preconditions consistent affect li example alli lk lu implies

alli lk alli lk lu similarly one elements conjunction implies

alli lk lu

b proof theorem equivalent restricted definition action axioms
p roof
let p eff claim successful actions
slaf

p p see consider model valuation fluents f p l f define
transition relation r valuation fluents p define state hs ri
definition hs ri exists hs ri eff satisfied finally note eff satisfied preconditions action met
consistent effects action applied eff satisfied
hs r together observations corollary yield theorem
b proof theorem strips slaf correct
p roof
let shorthand notation c denote c cnl p p
definition slaf ha oi slaf slaf theorem
slaf c eff formula equivalent c eff may generated
resolving
v fluents p following procedure proof lemma suppose
f p f fluent factored form may rewrite c eff




slaf












f p



f p



f p



f p



c prea f c effa f c f





c prea f effa f


c f prea f


c f effa f

equivalence holds resolvents generated resolving literals p c
eff still generated formula pair clauses possibly resolved together fluent p resolved eff generate
consequence c eff appear together one c components


fia mir c hang

every clause eff contains one literal p see possible consequences
generated
note effa f may rewritten follows
effa f





al af l l l al af l



l f f





l l al l al af

l f f

straightforward verify equivalence rewritten formula original formula note
performing rewriting may discard clauses form f af af must
true every consistent model given axioms described section
consider consequences generated component may compute
consequences performing resolution c pre f f f
may discard clauses inconsistent action violate clause
definition fluent factored formulas c f af next remaining components
computed straightforwardly

c effa f
l al af
l f f

c f prea f c f c prea f



l expll

l f f

c prea f effa f c prea f c effa f



l al l

l f f

c f effa f c f c effa f



l al expll

l f f

finally difficult see steps c procedure sets following formula
fluent factored form


slaf
af
l expll l al af l expll
f p

l f f

note slaf slaf slaf note term
slaf made fluent factored performing unit resolution exactly
steps e
b proof theorem strips slaf complexity
p roof
consider size formula returned strips slaf overview note
formula cnf integer filtered formula one step
cnf note every observation fluent f resets f part belief state
formula cnf thus
details first part call procedure appends
one literal existing clauses formula clauses length k


fil earning partially bservable eterministic action odels

generated additionally every fluent observed every k steps transition belief
formula stays k cnf e indefinitely compact existing clauses may grow
length literal per timestep augmented steps c appropriate fluent
observed steps e clauses stop growing finally easy see
steps e performed polynomial time
b proof theorem pre strips slaf correct
p roof
consider semantics slaf filtering strips action known precondition case action failure world filtered transition belief state
world meet action precondition satisfies observation clearly step
performs filtering conjoining belief formula negation action
precondition converted logically equivalent disjunction fluent factored formulas
case action success filtering performed first removing worlds
satisfy action precondition remaining worlds action executable
filtering remaining worlds strips slaf moreover theorem
corollary follows filtering formula performed filtering
subformulas j separately furthermore slaf ha oi pre strips slaf ha oi
pre strips slaf ha oi slaf ha oi conditions corollary
filtering subformula performed steps
finally note steps serve simplify belief formula produce logically
equivalent formula
b proof theorem pre strips slaf complexity
p roof
note call strips slaf subformula takes time linear size
subformula steps involving strips slaf performed linear time
thus total time complexity linear additionally note every fluent observed every
k steps every fluent factored subformula j belief formula k cnf
theorem amir
w action preconditions contain literals disjunction
form j j contains disjuncts therefore entire belief formula stays
k cnf indefinitely

appendix c experiments outputs
experiments section examine properties learning action
learning tractable exact appendix section bring generating
learned detailed comparison reader recall
output representation set possible given input bring
one satisfying model learned formula
experiments include following domains international competition
ipc drivelog zenotravel blocksworld depots
c driverlog domain
driverlog domain following generating pddl
define domain driverlog



fia mir c hang

requirements typing
types
location locatable object
driver truck obj locatable
predicates
obj locatable loc location
obj obj obj truck
driving driver v truck
path x location
empty v truck
action load truck
parameters
obj obj
truck truck
loc location
precondition
truck loc obj loc
effect
obj loc obj truck
action unload truck
parameters
obj obj
truck truck
loc location
precondition
truck loc obj truck
effect
obj truck obj loc
action board truck
parameters
driver driver
truck truck
loc location
precondition
truck loc driver loc empty truck
effect
driver loc driving driver truck
empty truck
action disembark truck
parameters
driver driver
truck truck
loc location
precondition
truck loc driving driver truck
effect
driving driver truck driver loc
empty truck
action drive truck
parameters
truck truck
loc location
loc location
driver driver
precondition
truck loc
driving driver truck
path loc loc
effect
truck loc truck loc
action walk
parameters
driver driver
loc location
loc location
precondition
driver loc path loc loc
effect
driver loc driver loc

one learned model one possible satisfying model formula random sequence
input driverlog domain following brought together experimental parameters
driverlog domain
ipc
fluents
randomly selected actions
fluents observed per step



fil earning partially bservable eterministic action odels

schematized learning
precondition heuristics
action distribution
board truck drive truck disembark truck
walk unload truck load truck
converting cnf
clause count
variable count
adding clauses
calling zchaff
parsing
slaf time
inference time
learned model
walk needs driver loc
walk needs driver loc
walk causes driver loc
walk causes driver loc
walk keeps path loc loc
walk keeps path loc loc
walk keeps path loc loc
walk keeps path loc loc
drive truck needs truck loc
drive truck needs truck loc
drive truck causes truck loc
drive truck causes truck loc
drive truck keeps driver loc
drive truck keeps driver loc
drive truck keeps driving driver truck
drive truck keeps path loc loc
drive truck keeps path loc loc
drive truck keeps path loc loc
drive truck keeps path loc loc
drive truck keeps empty truck
disembark truck needs driver loc
disembark truck needs driving driver truck
disembark truck needs empty truck
disembark truck causes driver loc
disembark truck causes driving driver truck
disembark truck causes empty truck
disembark truck keeps truck loc
disembark truck keeps path loc loc
board truck needs driver loc
board truck needs driving driver truck
board truck needs empty truck
board truck causes driver loc
board truck causes driving driver truck
board truck causes empty truck
board truck keeps truck loc
board truck keeps path loc loc
unload truck needs obj loc
unload truck needs obj truck
unload truck causes obj loc



fia mir c hang

unload truck causes obj truck
unload truck keeps truck loc
unload truck keeps path loc loc
unload truck keeps empty truck
load truck needs obj loc
load truck needs obj truck
load truck causes obj loc
load truck causes obj truck
load truck keeps truck loc
load truck keeps path loc loc
load truck keeps empty truck

c zeno travel domain
zeno travel domain following generating pddl
define domain zeno travel
requirements typing
types aircraft person city flevel object
predicates x person aircraft c city
p person aircraft
fuel level aircraft l flevel
next l l flevel
action board
parameters p person aircraft c city
precondition p c c
effect p c p
action debark
parameters p person aircraft c city
precondition p c
effect p p c
action fly
parameters aircraft c c city l l flevel
precondition c fuel level l next l l
effect c c fuel level l
fuel level l
action zoom
parameters aircraft c c city l l l flevel
precondition c fuel level l next l l
next l l
effect c c fuel level l
fuel level l
action refuel
parameters aircraft c city l flevel l flevel
precondition fuel level l next l l c
effect fuel level l fuel level l

one learned model one possible satisfying model formula random sequence
input zeno travel domain following brought together experimental parameters
zenotravel domain



fil earning partially bservable eterministic action odels









ipc
fluents possible unique actions
actions learned action sequence
observed fluents per step
schematized learning
precondition heuristics
action distribution zoom fly refuel
board debark

converting cnf
clause count
variable count
adding clauses
calling zchaff
parsing
slaf time
inference time
learned model
refuel needs fuel level l
refuel needs fuel level l
refuel causes fuel level l
refuel causes fuel level l
refuel keeps next l l
refuel keeps next l l
refuel keeps next l l
refuel keeps next l l
zoom needs fuel level l
zoom needs fuel level l
zoom causes fuel level l
zoom causes fuel level l
zoom keeps fuel level l
zoom keeps next l l
zoom keeps next l l
zoom keeps next l l
zoom keeps next l l
zoom keeps next l l
zoom keeps next l l
zoom keeps next l l
zoom keeps next l l
zoom keeps next l l
fly needs fuel level l
fly needs fuel level l
fly causes fuel level l
fly causes fuel level l
fly keeps next l l
fly keeps next l l
fly keeps next l l
fly keeps next l l
debark needs p
debark causes p
board needs p
board causes p



fia mir c hang

c blocks world domain
blocksworld domain following generating pddl
define domain blocksworld
requirements strips
predicates clear x object
table x object
arm empty
holding x object
x object
action pickup
parameters ob object
precondition clear ob table ob arm empty
effect holding ob clear ob table ob
arm empty
action putdown
parameters ob object
precondition holding ob
effect clear ob arm empty table ob
holding ob
action stack
parameters ob object
underob object
precondition clear underob holding ob
effect arm empty clear ob ob underob
clear underob holding ob
action unstack
parameters ob object
underob object
precondition ob underob clear ob arm empty
effect holding ob clear underob ob underob
clear ob arm empty

one learned model one possible satisfying model formula random sequence
input blocksworld domain following brought together experimental parameters
blocksworld domain
fluents
randomly selected actions
fluents observed per step
schematized learning
precondition heuristics
converting cnf
clause count
variable count
adding clauses
calling zchaff
parsing
slaf time
inference time



fil earning partially bservable eterministic action odels

learned model
unstack needs clear underob
unstack needs clear ob
unstack needs arm empty
unstack needs holding ob
unstack needs ob underob
unstack causes clear underob
unstack causes clear ob
unstack causes arm empty
unstack causes holding ob
unstack causes ob underob
unstack keeps table underob
unstack keeps table ob
unstack keeps holding underob
unstack keeps underob underob
unstack keeps ob ob
unstack keeps underob ob
stack needs clear underob
stack needs clear ob
stack needs arm empty
stack needs holding ob
stack needs ob underob
stack causes clear underob
stack causes clear ob
stack causes arm empty
stack causes holding ob
stack causes ob underob
stack keeps table underob
stack keeps table ob
stack keeps holding underob
stack keeps underob underob
stack keeps ob ob
stack keeps underob ob
putdown needs clear ob
putdown needs table ob
putdown needs arm empty
putdown needs holding ob
putdown causes clear ob
putdown causes table ob
putdown causes arm empty
putdown causes holding ob
putdown keeps ob ob
pickup needs clear ob
pickup needs table ob
pickup needs arm empty
pickup needs holding ob
pickup causes clear ob
pickup causes table ob
pickup causes arm empty
pickup causes holding ob
pickup keeps ob ob



fia mir c hang

c depot domain
depot domain following generating pddl
define domain depot
requirements typing
types place locatable object
depot distributor place
truck hoist surface locatable
pallet crate surface
predicates x locatable place
x crate surface
x crate truck
lifting x hoist crate
available x hoist
clear x surface
action drive
parameters x truck place z place
precondition x
effect x x z
action lift
parameters x hoist crate z surface p place
precondition x p available x p z
clear
effect p lifting x clear
available x clear z z
action drop
parameters x hoist crate z surface p place
precondition x p z p clear z lifting x
effect available x lifting x p
clear z clear z
action load
parameters x hoist crate z truck p place
precondition x p z p lifting x
effect lifting x z available x
action unload
parameters x hoist crate z truck p place
precondition x p z p available x z
effect z available x lifting x

one learned model one possible satisfying model formula random sequence
input depot domain following brought together experimental parameters
depots domain
ipc
fluents
randomly selected actions
fluents observed per step
schematized learning
precondition heuristics
converting cnf



fil earning partially bservable eterministic action odels

clause count
variable count
adding clauses
calling zchaff
parsing
slaf time
inference time
learned model
unload needs z
unload needs lifting x
unload needs available x
unload causes z
unload causes lifting x
unload causes available x
unload keeps z p
unload keeps p
unload keeps x p
unload keeps
unload keeps clear
load needs z
load needs lifting x
load needs available x
load causes z
load causes lifting x
load causes available x
load keeps z p
load keeps p
load keeps x p
load keeps
load keeps clear
drop needs p
drop needs z
drop needs lifting x
drop needs available x
drop needs clear z
drop needs clear
drop causes p
drop causes z z
drop causes z z
drop causes z
drop causes z
drop causes z
drop causes lifting x
drop causes lifting x z
drop causes lifting x z
drop causes available x
drop causes clear z
drop causes clear
drop keeps z p
drop keeps x p
drop keeps z z
drop keeps z
drop keeps
drop keeps lifting x z



fia mir c hang

lift needs p
lift needs z
lift needs lifting x
lift needs available x
lift needs clear z
lift needs clear
lift causes p
lift causes z
lift causes z z
lift causes z z
lift causes z
lift causes z
lift causes lifting x
lift causes lifting x z
lift causes lifting x z
lift causes available x
lift causes clear z
lift causes clear
lift keeps z p
lift keeps x p
lift keeps
lift keeps z z
lift keeps z
lift keeps lifting x z
drive needs x
drive needs x z
drive causes x
drive causes x z

references
amir e learning partially observable deterministic action proc nineteenth
international joint conference artificial intelligence ijcai pp international joint conferences artificial intelligence
amir e russell logical filtering proc eighteenth international joint conference
artificial intelligence ijcai pp morgan kaufmann
benson inductive learning reactive action proceedings th international conference machine learning icml
bertsekas p tsitsiklis j n neuro dynamic programming athena scientific
boutilier c reiter r price b symbolic dynamic programming first order mdps
proc seventeenth international joint conference artificial intelligence ijcai pp
morgan kaufmann
boyen x friedman n koller discovering hidden structure complex dynamic
systems proceedings th conference uncertainty artificial intelligenceuai
pp morgan kaufmann available http www cs stanford edu xb uai
boyen x koller approximate learning dynamic kearns solla
kohn eds advances neural information processing systems proceedings conferencenips pp cambridge mit press available http www cs stanford edu xb nips


fil earning partially bservable eterministic action odels

calvanese giacomo g vardi reasoning actions
ltl action theories principles knowledge representation reasoning proc eighth
intl conference kr pp morgan kaufmann
chang amir e goal achievement partially known partially observable domains
proceedings th intl conf automated scheduling icaps
aaai press
chang c l lee r c symbolic logic mechanical theorem proving academic
press
clarke e grumberg peled model checking mit press
darwiche marquis p knowledge compilation map journal artificial intelligence
davis putnam h computing procedure quantification theory journal
acm
dawsey w minsker b amir e real time assessment drinking water systems
bayesian networks world environmental water resources congress
dechter r bucket elimination unifying framework reasoning artificial intelligence

del val method consequence finding compilation restricted language proc national conference artificial intelligence aaai pp
aaai press mit press
doherty p lukaszewicz w szalas computing circumscription revisited reduction journal automated reasoning
eiter gottlob g complexity propositional knowledge base revision updates counterfactuals artificial intelligence
even dar e kakade mansour reinforcement learning pomdps
proc nineteenth international joint conference artificial intelligence ijcai pp
international joint conferences artificial intelligence
fagin r ullman j vardi semantics updates databases
proceedings second acm sigact sigmod symposium principles database
systems pp atlanta georgia
fikes r hart p nilsson n learning executing generalized robot plans artificial
intelligence
fox long pddl extension pddl expressing temporal
domains http www dur ac uk p long ipc pddl html used aips competition
friedman n murphy k russell learning structure dynamic probabilistic
networks proc fourteenth conference uncertainty artificial intelligence uai
morgan kaufmann
gelfond lifschitz v action languages electronic transactions artificial intelligence http www etaij org nr


fia mir c hang

ghahramani z introduction hidden markov bayesian networks international journal pattern recognition artificial intelligence
ghahramani z jordan factorial hidden markov machine learning

ghallab howe knoblock c mcdermott ram veloso weld wilkins
pddl domain definition language version tech rep cvc
tr dcs tr yale center computational vision control
gil learning experimentation incremental refinement incomplete domains proceedings th international conference machine learning icml
pp
ginsberg l readings nonmonotonic reasoning chap pp morgan kaufmann los altos ca
hajishirzi h amir e stochastic filtering probabilistic action proc national conference artificial intelligence aaai
hill j minsker b amir e real time bayesian anomaly detection environmental
sensor data nd congress international association hydraulic engineering
iahr
hlubocky b amir e knowledge gathering agents adventure games aaai
workshop challenges game ai aaai press
holmes p charles lee isbell j looping suffix tree inference partially
observable hidden state proceedings rd international conference machine
learning icml pp acm press
iwanuma k inoue k minimal answer computation sol logics artificial
intelligence proceedings eighth european conference vol lnai pp
springer verlag
james singh learning discovery predictive state representations dynamical systems reset proceedings st international conference machine
learning icml pp acm press
kaelbling l p littman l cassandra r acting partially
observable stochastic domains artificial intelligence
kearns mansour ng approximate large pomdps via reusable
trajectories proceedings th conference neural information processing systems
nips published pp mit press
kuffner j j lavalle rrt connect efficient single query path
ieee international conference robotics automation icra pp

lee r c completeness theorem computer program finding theorems
derivable given axioms ph thesis university california berkeley
lifschitz v semantics strips allen j f hendler j tate eds
readings pp morgan kaufmann san mateo california


fil earning partially bservable eterministic action odels

littman l sequential decision making ph thesis department
computer science brown university technical report cs
littman l sutton r singh predictive representations state proceedings
th conference neural information processing systems nips published
mit press
marquis p consequence finding gabbay smets p eds handbook defeasible reasoning uncertainty management systems vol
defeasible uncertain reasoning kluwer
mccallum r instance utile distinctions reinforcement learning hidden
state proceedings th international conference machine learning icml
morgan kaufmann
mccarthy j applications circumscription formalizing common sense knowledge
artificial intelligence
mccarthy j hayes p j philosophical standpoint artificial intelligence meltzer b michie eds machine intelligence pp
edinburgh university press
mcilraith amir e theorem proving structured theories proc seventeenth
international joint conference artificial intelligence ijcai pp morgan
kaufmann
meuleau n peshkin l kim k e kaelbling l p learning finite state controllers
partially observable environments proc fifteenth conference uncertainty artificial
intelligence uai morgan kaufmann
moskewicz w madigan c f zhao zhang l malik chaff engineering
efficient sat solver proceedings th design automation conference dac
murphy k dynamic bayesian networks representation inference learning ph
thesis university california berkeley
nance vogel amir e reasoning partially observed actions proc national conference artificial intelligence aaai aaai press
oates cohen p r searching operators context dependent
probabilistic effects proc national conference artificial intelligence aaai pp
aaai press
pasula h zettlemoyer l kaelbling l p learning probabilistic relational
rules proceedings th intl conf automated scheduling
icaps aaai press
pednault e p adl exploring middle ground strips situation
calculus proc first international conference principles knowledge representation
reasoning kr pp
reiter r knowledge action logical foundations describing implementing
dynamical systems mit press


fia mir c hang

reiter r frame situation calculus simple solution sometimes
completeness goal regression lifschitz v ed artificial intelligence
mathematical theory computation papers honor john mccarthy pp
academic press
robert c p celeux g diebolt j bayesian estimation hidden markov chains
stochastic implementation statist prob letters
schmill oates cohen p r learning operators real world partially observable environments proceedings th intl conf ai
scheduling aips pp aaai press
shahaf amir e learning partially observable action schemas proc national
conference artificial intelligence aaai aaai press
shahaf amir e logical circuit filtering proc twentieth international joint conference artificial intelligence ijcai pp international joint conferences
artificial intelligence
shahaf chang amir e learning partially observable action efficient
proc national conference artificial intelligence aaai aaai press
simon l del val efficient consequence finding proc seventeenth international
joint conference artificial intelligence ijcai pp morgan kaufmann
sutton r barto g reinforcement learning introduction mit press
tang yinlei yu r malik analysis search satisfiability quantified boolean formulas arising circuit state space diameter
proceedings seventh international conference theory applications satisfiability testing sat
thielscher introduction fluent calculus electronic transactions artificial
intelligence http www etaij org nr
thrun robotic mapping survey exploring artificial intelligence millennium pp morgan kaufmann
wang x learning observation practice incremental operator acquisition proceedings th international conference machine learning
icml pp morgan kaufmann
wu k yang q jiang arms automatic knowledge engineering tool learning
action ai knowledge engineering review
yang q wu k jiang learning actions plan examples incomplete
knowledge biundo myers k l rajan k eds icaps pp aaai




