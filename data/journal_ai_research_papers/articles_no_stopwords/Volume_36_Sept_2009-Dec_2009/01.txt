Journal Artificial Intelligence Research 36 (2009) 71

Submitted 12/08; published 10/09

Prime Implicates Prime Implicants:
Propositional Modal Logic
Meghyn Bienvenu

meghyn@informatik.uni-bremen.de

Department Mathematics Computer Science
University Bremen, Germany

Abstract
Prime implicates prime implicants proven relevant number areas
artificial intelligence, notably abductive reasoning knowledge compilation.
purpose paper examine notions might appropriately extended
propositional logic modal logic K. begin paper considering number
potential definitions clauses terms K. different definitions evaluated
respect set syntactic, semantic, complexity-theoretic properties characteristic
propositional definition. compare definitions respect properties
notions prime implicates prime implicants induce.
definition perfectly generalizes propositional notions, show
exist one definition satisfies many desirable properties propositional
case. second half paper, consider computational properties
selected definition. end, provide sound complete algorithms generating
recognizing prime implicates, show prime implicate recognition task
Pspace-complete. prove upper lower bounds size number prime
implicates. paper focuses logic K, results hold equally well
multi-modal K concept expressions description logic ALC.

1. Introduction
Prime implicates prime implicants important notions artificial intelligence.
given rise significant body work automated reasoning applied
number different sub-areas AI. Traditionally, concepts studied
context propositional logic, considered many-valued
(Ramesh & Murray, 1994) first-order logic (Marquis, 1991a, 1991b). much
known, however, prime implicates prime implicants logics. particular,
definition prime implicate prime implicant ever proposed modal
description logic, shown reasonable definition provided.
Given increasing interest modal description logics knowledge representation
languages, one naturally wonders whether notions suitably generalized
expressive logics.
recall propositional logic prime implicates formula defined
logically strongest clausal consequences. restriction clauses made order
reduce redundant elements formulas set consequences: use keeping
around consequence b one already consequences b. decision
consider logically strongest clausal consequences motivated desire
eliminate irrelevant weaker consequences: already consequence a,
c
2009
AI Access Foundation. rights reserved.

fiBienvenu

point retaining consequences b b. Prime implicates thus provide
complete yet compact representation set logical consequences formula.
particularly nice representation makes many computational tasks
simpler: satisfiability, tautology, entailment, equivalence queries conditioning
forgetting transformations tractable formulae represented prime
implicates (Darwiche & Marquis, 2002). prime implicates considered
interesting target language knowledge compilation (Cadoli & Donini, 1997; Darwiche
& Marquis, 2002). Prime implicates proved relevant sub-areas AI,
distributed reasoning (Adjiman, Chatalic, Goasdoue, Rousset, & Simon, 2006), belief
revision (Bittencourt, 2007; Pagnucco, 2006), non-monotonic reasoning (cf. Przymusinski,
1989), characterizations relevance (Lakemeyer, 1995; Lang, Liberatore, & Marquis,
2003).
dual notion prime implicates prime implicants, defined
logically weakest terms (= conjunctions literals) imply given formula. main
application domain prime implicants abduction diagnosis. recall
abduction, one given background theory observation, objective
find explanation observation. logical terms, explanation formula
logically entails observation taken together background theory.
set explanations abduction problem large, important question
select representative subset explanations. One common approach
use prime implicants: relevant explanations observation respect
background theory taken prime implicants (de Kleer, Mackworth,
& Reiter, 1992; Eiter & Makino, 2002).
many applications AI, expressive power propositional logic proves insufficient. First-order logic provides much greater level expressivity, price
undecidability. Modal description logics offer interesting trade-off expressivity complexity, generally expressive propositional logic yet
better-behaved computationally first-order logic. explains growing trend
towards using languages knowledge representation.
prototypical description logic ALC, extends propositional logic restricted
forms universal existential quantification. example expression ALC
F emale hasChild.F emale hasChild.(Doctor P rof essor) hasP et.Dog
describes set individuals female, least one daughter one
pet dog, children either doctors professors.
concept expression represented equally well modal logic K2 formula:
F emale 31 F emale 21 (Doctor P rof essor) 32 Dog
Schild (1991) proved general result showed description logic ALC n
binary relations fact notational variant multi-modal logic Kn . means
results concerning Kn transferred ALC, vice-versa.
paper, investigate notions prime implicates prime implicants
modal logic K = K1 , actually results hold formulae Kn , hence
concept expressions ALC. decision present results terms K
72

fiPrime Implicates Prime Implicants Modal Logic

rather terms Kn ALC motivated solely desire simplify notation
increase readability proofs.
question notions prime implicates prime implicants suitably
defined logic K clearly interest theoretical point view. argue,
however, question practically relevant. support claim, briefly
discuss two application areas study prime implicates prime implicants
K might prove useful.
first domain application consider abductive reasoning K. noted
above, one key foundational issues abductive reasoning selection
interesting subset explanations. issue especially crucial logics K
allow infinite number non-equivalent formulae, since means number
non-equivalent explanations abduction problem large fact infinite,
making simply impossible enumerate entire set explanations. prime implicants
widely-accepted means characterizing relevant explanations propositional logic,
reasonable starting point research abductive reasoning logic K study
different possible definitions prime implicant K properties.
investigation prime implicates K relevant development knowledge compilation procedures K. recall knowledge compilation (cf. Darwiche
& Marquis, 2002) general technique coping intractability reasoning
consists off-line phase knowledge base rewritten equivalent
knowledge base allows tractable reasoning, followed online phase
reasoning performed compiled knowledge base. idea initial cost
compiling knowledge base offset computational savings later queries.
Currently, work knowledge compilation restricted propositional logic, even
though technique could prove highly relevant modal description logics,
generally suffer even higher computational complexity propositional logic.
prime implicates one better-known mechanisms compiling formulae propositional logic, certainly makes sense investigate whether approach knowledge
compilation fruitfully extended logics K.
paper organized follows. preliminaries, consider appropriately generalize notions clauses terms K. obvious definition,
enumerate list syntactic, semantic, complexity-theoretic properties propositional definitions, use compare different candidate definitions.
next consider different definitions light notions prime implicate prime
implicant induce. again, list basic properties propositional
case would satisfy, see different definitions measure up.
second half paper, investigate computational properties
satisfactory definition prime implicates. consider problems prime implicate
generation recognition, provide sound complete algorithms tasks.
study complexity prime implicate recognition problem, showing
Pspace-complete thus complexity satisfiability deduction K.
conclude paper discussion relevance results two application
areas cited directions future research. order enhance readability paper, proofs omitted body text. Full proofs
found appendix.
73

fiBienvenu

2. Preliminary Definitions Notation
briefly recall basics modal logic K (refer Blackburn, de Rijke, & Venema,
2001; Blackburn, van Benthem, & Wolter, 2006, good introductions modal logic).
Formulae K built set propositional variables V, standard logical
connectives (, , ), modal operators 2 3. call formula
form 2 (resp. 3) 2-formula (resp. 3-formula). convenient use
abbreviation . adopt shorthand 2k (resp. 3k ) refer
formula consisting preceded k copies 2 (resp. 3), convention
20 = 30 = . use var() refer set propositional variables appearing
formula . modal depth formula , written (), defined maximal
number nested modal operators appearing , e.g. (3(a 2a) a) = 2. define
length formula , written ||, number occurrences propositional variables,
logical connectives, modal operators . example, would |(a b)| = 4
|3(a b) 2a| = 8.
Negation normal form (NNF) defined propositional logic: formula said
NNF negation appears directly propositional variables. Every formula
K transformed equivalent formula NNF using recursive procedure
Nnf defined follows:
Nnf (l)=l (for propositional literals l)
Nnf (1 2 )=Nnf (1 )Nnf (2 )
Nnf ((1 2 ))=Nnf (1 )Nnf (2 )
Nnf (1 2 )=Nnf (1 )Nnf (2 )
Nnf ((1 2 ))=Nnf (1 )Nnf (2 )

Nnf (2)=2Nnf ()
Nnf (2)=3Nnf ()
Nnf (3)=3Nnf ()
Nnf (3)=2Nnf ()
Nnf ()=Nnf ()

example, applying Nnf formula 2(a 3(b c)) results formula 3(a
2(b c)) NNF. transformation Nnf takes linear time, yields formula
double size original formula modal depth
propositional variables original.
model K tuple = hW, R, vi, W non-empty set possible worlds,
R W W binary relation worlds, v : W V {true, f alse} valuation
propositional variables world. Models understood labelled directed
graphs, vertices correspond elements W, directed edges represent
binary relation R, vertices labeled propositional valuations specify
propositional variables true corresponding possible world.
Satisfaction formula model world w (written M, w |= ) defined
inductively follows:
M, w |= v(w, a) = true
M, w |= M, w 6|=
M, w |= M, w |= M, w |=
M, w |= M, w |= M, w |=
M, w |= 2 M, w |= w wRw
74

fiPrime Implicates Prime Implicants Modal Logic

M, w |= 3 M, w |= w wRw
think models labeled directed graphs, determining satisfaction
formula 2 vertex w consists evaluating vertices reached
w via edge; 2 satisfied w case holds
successor vertices. Similarly, order decide whether formula 3 holds vertex w,
consider successors w graph check whether least one
vertices satisfies .
formula said tautology, written |= , M, w |= every model
world w. formula satisfiable model world w
M, w |= . w M, w |= , called unsatisfiable,
write |= .
Ladner (1977) showed satisfiability unsatisfiability K Pspace-complete.
Pspace membership, Ladner exhibited polynomial space tableaux-style algorithm
deciding satisfiability K formulae. Pspace-hardness proven means reduction
QBF validity (the canonical Pspace-complete problem).
modal logic, notion logical consequence (or entailment) defined one
two ways:
formula global consequence whenever M, w |= every world w
model M, M, w |= every world w
formula local consequence M, w |= implies M, w |= every model
world w
paper, consider notion local consequence, take |=
mean local consequence . |= , say entails .
Two formulae called equivalent, written , |= |= .
formula said logically stronger |= 6|= .
highlight basic properties logical consequence equivalence K
play important role proofs results.
Theorem 1. Let , 1 , ..., , , 1 , ..., n formulae K, let propositional
formula.
1. |= |= |=
2. |= 3 |= 3 2 |= 2
3. 31 ...3m 21 ...2n |= ( |= 1 ...n |= i)
4. |= 31 ... 3m 21 ... 2n (|= |= 1 ... i)
5. 2 |= 21 ... 2n |=
6. 31 ... 3m 21 ... 2n
31 ... 3m 2(1 1 ... ) ... 2(n 1 ... )
75

fiBienvenu

Statement 1 Theorem 1 shows three reasoning tasks entailment, unsatisfiability, tautology-testing rephrased terms one another. Statement 2 tells us
entailment two 2- 3-formulae reduced entailment
formulae first modality removed. Statements 3 4 define conditions
conjunction (resp. disjunction) propositional literals 2- 3-formulae
unsatisfiable (resp. tautology). Statement 5 gives us conditions
2-formula implies disjunction 2-formulae. Statement 6 demonstrates interaction
2- 3-formulae disjunction.
Theorem 2. Let disjunction propositional literals 2- 3-formulae.
following statements holds:
1. |= non-tautological propositional clause , every disjunct
either propositional literal unsatisfiable 3-formula
2. |= 31 ... 3n , every disjunct 3-formula
3. |= 21 ... 2n 6|= 21 ... 2n , every disjunct either
2-formula unsatisfiable 3-formula
Theorem 3. Let = 31 ... 3m 21 ... 2n = 31 ... 3p
21 ... 2q formulae K. propositional 6|= ,

|=
1 ... |= 1 ... p
|=

every j |= 1 ... p j
Theorems 2 3 concern entailment relations formulae disjunctions
propositional literals 2- 3-formulae. Theorem 2 tells us kinds formulae
type entail propositional clause, disjunction 3-formulae, disjunction
2-formulae, Theorem 3 outlines conditions two formulae
type related entailment relation. illustrate Theorem 3
small example.
Example 4. Consider formula = b 3(a 3c) 3(d 2a) 2(c d).
according Theorem 3, have:
|= b 3(a d) 2c, since b |= b (a 3c) (d 2a) |=
c |= c (a d)
6|= 3c, since b 6|=
6|= b 3(a c), since (a 3c) (d 2a) 6|= c
6|= b 3(a 2a) 2c, since c 6|= c (a 2a)
76

fiPrime Implicates Prime Implicants Modal Logic

3. Literals, Clauses, Terms K
seen introduction, notions prime implicates implicants
straightforwardly defined using notions clauses terms. Thus, aim provide
suitable definitions prime implicates implicants logic K, first need decide
upon suitable definition clauses terms K. Unfortunately, whereas clauses
terms standard notions propositional first-order logic1 , generally
accepted definition clauses terms K. Indeed, several quite different notions
clauses terms proposed literature different purposes.
Instead blindly picking definition hoping appropriate, prefer
list number characteristics literals, clauses, terms propositional logic, giving
us principled means comparing different candidate definitions. properties
describes something literal, clause, term propositional logic.
Although list cannot considered exhaustive, believe covers principal
syntactic, semantic, complexity-theoretic properties propositional definition.
P1 Literals, clauses, terms negation normal form.
P2 Clauses contain , terms contain , literals contain neither .
P3 Clauses (resp. terms) disjunctions (resp. conjunctions) literals.
P4 negation literal equivalent another literal. Negations clauses (resp.
terms) equivalent terms (resp. clauses).
P5 Every formula equivalent finite conjunction clauses. Likewise, every formula
equivalent finite disjunction terms.
P6 task deciding whether given formula literal, term, clause accomplished polynomial-time.
P7 task deciding whether clause (resp. term) entails another clause (resp. term)
accomplished polynomial-time.
One may wonder whether exist definitions literals, clauses, terms K
satisfying properties. Unfortunately, show impossible.
Theorem 5. definition literals, clause, terms K satisfies properties P1
P2 cannot satisfy P5.
proof Theorem 5 makes use fact distribute 3
distribute 2, means impossibility result holds equally
well standard modal description logics.
consider variety possible definitions evaluate respect
criteria. first definition consider proposed Cialdea
1. One might wonder simply translate formulae K first-order formulae
put clausal form. reason simple: looking define clauses terms within
language K, clauses obtain passing first-order logic generally expressible K.
Moreover, define clauses K first-order clauses representable K,
would obtain set clauses containing 3 modalities, thereby losing much expressivity K.

77

fiBienvenu

Mayer Pirri (1995) paper abductive reasoning modal logic. define terms
formulae constructed propositional literals using , 2,
3. Modal clauses literals used paper defined analogously,
yielding following definition2 :
D1

L ::= | | 2L | 3L
C ::= | | 2C | 3C | C C
::= | | 2T | 3T |

easy see inspection definition satisfies properties P1-P2, P4, P6.
Property P3 satisfied, however, since clauses disjunctions
literals take instance 2(a b). Theorem 5 fact P1 P2
satisfied, conclude property P5 cannot hold. first glance, may seem
entailment clauses terms could accomplished polynomial time,
case. fact, show problem NP-complete. proof relies
strong resemblance terms D1 concept expressions description
logic ALE (for unsatisfiability deduction known NP-complete).
using slightly different definition, gain P3:
D2

L ::= | | 2L | 3L
C ::= L | C C
::= L |

easily verified definition D2 satisfies properties P1-P4 P6. definition
D1 satisfy P5, definition D2 even less expressive, follows D2
satisfy P5 either. reduced expressiveness however improve computational
complexity: property P7 still satisfied show entailment
clauses terms NP-complete using reduction used definition D1.
fact even extremely inexpressive definition D2 allow polynomial
entailment clauses terms suggests property P7 cannot satisfied
reasonable definition clauses terms K.
Let us consider expressive options. begin following definition
clauses proposed Enjalbert Farinas del Cerro (1989) purpose
modal resolution:
D3
C ::= | | 2C | 3ConjC | C C
ConjC ::= C | ConjC ConjC
definition clauses extended definition terms literals satisfies
P3 P4, extension satisfies properties. Let us first consider
one possible extensions satisfies P4 maximal subset P1-P7:
D3a

L ::= | | 2L | 3L
C ::= | | 2C | 3ConjC | C C
ConjC ::= C | ConjC ConjC
::= | | 2DisjT | 3T |
DisjT ::= | DisjT DisjT

2. Note follows, let range propositional variables L, C, range
sets literals, clauses, terms, respectively.

78

fiPrime Implicates Prime Implicants Modal Logic

definition satisfies P1 P4-P6 (satisfaction P5 shown Enjalbert & Farinas
del Cerro, 1989). satisfy P3 clauses disjunctions
literals take example 2(a b). Given definition D3a strictly expressive
definitions D1 D2, follows entailment clauses terms must
NP-hard, means D3a satisfy P7. fact, show entailment
clauses terms definition D3a Pspace-complete. so, modify
polynomial translation QBF K used prove Pspace-hardness K
translated formula conjunction clauses respect D3a. notice
formula unsatisfiable 3 entails 3(a a). thus reduce QBF
validity entailment clauses, making task Pspace-hard, hence (being
subproblem entailment K) Pspace-complete. idea used show Pspacecompleteness definitions D3b D5 below.
instead extend D3 enforce property P3, obtain following definition:
L ::= | | 2C | 3ConjC
C ::= | | 2C | 3ConjC | C C
ConjC ::= C | ConjC ConjC
::= L |
definition satisfies properties except P2, P4, P7. Property P4 fails
hold negation literal 3(a b) equivalent literal. proof
P5 holds constructive: use standard logical equivalences rewrite formulae
equivalent conjunctions clauses disjunctions terms (this
definitions D4 D5 below).
consider two rather simple definitions satisfy properties P3, P4, P5.
first definition, inspired notion modal atom proposed Giunchiglia
Sebastiani (1996), defines literals set formulae NNF cannot decomposed propositionally.
D3b

L ::= | | 2F | 3F
C ::= L | C C
::= L |
F ::= | | F F | F F | 2F | 3F
D4 satisfies properties except P2 P7. P7, note arbitrary formula NNF unsatisfiable (a Pspace-complete problem) 3 |= 3(a a).
Definition D4 liberal, imposing structure formulae behind modal operators. define literals formulae NNF cannot decomposed modally
(instead propositionally), obtain much stricter definition satisfies exactly
properties D4.
D4

D5

L ::= | | 2C | 3T
C ::= L | C C
::= L |

summary analysis different definitions respect properties P1-P7
provided following table.
Theorem 6. results Figure 1 hold.
79

fiBienvenu

P1
P2
P3
P4
P5
P6
P7

D1
D2
yes
yes
yes
yes

yes
yes
yes


yes
yes
(unless P=NP)

D3a D3b D4 D5
yes
yes
yes yes





yes
yes yes
yes

yes yes
yes
yes
yes yes
yes
yes
yes yes
(unless P=Pspace)

Figure 1: Properties different definitions literals, clauses, terms.

Clearly deciding different candidate definitions complicated counting number properties definitions satisfy, simple reason
properties important others. Take instance property P5
requires clauses terms expressive enough represent formulae K.
use standard propositional definition clauses terms (thereby disregarding
modal operators), find satisfies every property except P5, hence
properties definitions considered section, yet would
hard-pressed find someone considers propositional definition appropriate definition K. demonstrates expressiveness particularly important property,
important fact willing sacrifice properties P2 P7 keep it.
Among definitions satisfy P5, prefer definitions D4 D5 definitions D3a
D3b, latter definitions less common propositional definition
present advantages D4 D5.
course, comes it, choice definition must depend
particular application mind. may well circumstances less
expressive less elegant definition may prove suitable. paper
using clauses terms define prime implicates prime implicants, us
important criteria choosing definition quality notions prime
implicates prime implicants definition induces.

4. Prime Implicates/Implicants K
definition clauses terms fixed, define prime implicates
prime implicants exactly manner propositional logic:
Definition 7. clause implicate formula |= . prime
implicate if:
1. implicate
2. implicate |= , |=
Definition 8. term implicant formula |= . prime
implicant if:
1. implicant
80

fiPrime Implicates Prime Implicants Modal Logic

2. implicant |= , |=
course, notion prime implicate (resp. implicant) get determined definition clause (resp. term) chosen. compare different definitions using following well-known properties prime implicates/implicants
propositional logic:
Finiteness number prime implicates (resp. prime implicants) formula finite
modulo logical equivalence.
Covering Every implicate formula entailed prime implicate formula.
Conversely, every implicant formula entails prime implicant formula.
Equivalence model model model prime
implicates model prime implicant 3 .
Implicant-Implicate Duality Every prime implicant formula equivalent
negation prime implicate negated formula. Conversely, every prime
implicate formula equivalent negation prime implicant negated
formula.
Distribution prime implicate 1 ... n , exist prime implicates
1 , ..., n 1 , ..., n 1 ... n . Likewise, prime implicant
1 ... n , exist prime implicants 1 , ..., n 1 , ..., n
1 ... n
Finiteness ensures prime implicates/implicants formula finitely
represented, Covering means prime implicates provide complete representation
formulas implicates. Equivalence guarantees information lost replacing formula prime implicates/implicants, whereas Implicant-Implicate Duality
allows us transfer results algorithms prime implicates prime implicants,
vice-versa. Finally, Distribution relates prime implicates/implicants formula
prime implicates/implicants sub-formulae. property play key role
prime implicate generation algorithm presented next section.
show definition D4 satisfies five properties. Finiteness Covering, first demonstrate every implicate formula entailed implicate
var( ) var() depth () + 1 (and similarly implicants). finitely many non-equivalent formulae finite language
bounded depth, follows finitely many prime implicates/implicants
given formula, infinite chains increasingly stronger implicates (or increasingly weaker implicants). Equivalence follows directly Covering
property P5 previous section: use P5 rewrite conjunction
clauses, implied prime implicate Covering.
property Implicant-Implicate Duality immediate consequence duality
3. property Equivalence commonly taken mean formula equivalent conjunction prime implicates disjunction prime implicants. chosen model-theoretic
formulation order allow possibility set prime implicates/implicants infinite.

81

fiBienvenu

clauses terms (P4). Distribution shown using Covering plus
fact disjunction clauses clause conjunction terms term (P3).
Theorem 9. notions prime implicates prime implicants induced definition
D4 satisfy Finiteness, Covering, Equivalence, Implicant-Implicate Duality,
Distribution.
remark way contrast first-order logic notion prime implicate induced standard definition clauses shown falsify Finiteness, Covering,
Equivalence (Marquis, 1991a, 1991b).
show definition D4 one definitions satisfy five
properties. definitions D1 D2, show Equivalence hold.
fairly straightforward consequence fact definitions satisfy
property P5.
Theorem 10. notions prime implicates prime implicants induced definitions
D1 D2 satisfy Equivalence.
notions prime implicates induced definitions D3a, D3b, D5, show
appendix clause 2 3k 3(a b 2k a) prime implicate 2(a b)
every k 14 . thereby demonstrate definitions admit formulae
infinitely many distinct prime implicates allow seemingly irrelevant
clauses counted prime implicates. gives us strong grounds dismissing
definitions much utility prime implicates applications comes ability
eliminate irrelevant consequences.
Theorem 11. notions prime implicates prime implicants induced D3a, D3b,
D5 falsify Finiteness.
comparison last section suggested D5 least suitable
D4 definition clauses terms, results section rule D5 suitable
definition prime implicates prime implicants. remainder paper,
concentrate attention notions prime implicates prime implicants induced
definition D4, shown satisfactory generalizations
propositional case.

5. Prime Implicate Generation Recognition
section, investigate computational aspects modal prime implicates.
primarily focusing notion prime implicate induced definition D4,
remainder paper use words clause, term, prime implicate
mean clause, term, prime implicate respect definition D4, except
explicitly stated otherwise.
remark that, without loss generality, restrict attention prime implicates since Implicant-Implicate Duality (Theorem 9) algorithm generating
recognizing prime implicates easily adapted algorithm generating
recognizing prime implicants.
4. D4, prime implicate 2(a b) itself.

82

fiPrime Implicates Prime Implicants Modal Logic

Function Dnf -4()
Input: formula
Output: set D4-terms
Return set terms output Iter-Dnf-4({Nnf ()}).
Function Iter-Dnf -4(S)
Input: set formulae NNF
Output: set D4-terms, output one-by-one
= { } , Iter-Dnf -4(S {} {})
Else = { } , Iter-Dnf -4(S {}), Iter-Dnf -4(S {})
V
Else output consistent (and nothing otherwise)
Figure 2: Helper functions Dnf -4 Iter-Dnf -4.

5.1 Generating Prime Implicates
start considering problem generating set prime implicates given
formula. task important want produce abductive explanations, want
compile formula set prime implicates.
generation algorithm, require means transforming input formula
equivalent disjunction simpler formulae. end, introduce Figure 2
helper function Dnf -4() returns set satisfiable terms respect D4
whose disjunction equivalent . function Dnf -4 defined terms another
function Iter-Dnf -4 takes input set formulae NNF returns
iterative fashion set satisfiable terms whose disjunction equivalent S. following
lemmas highlight important properties functions.
Lemma 12. Iter-Dnf-4 terminates requires polynomial space size
input.
Lemma 13. output Dnf-4 input set satisfiable terms respect
D4 whose disjunction equivalent .
Lemma 14. 2|| terms Dnf-4(). terms length
2||, depth (), contains propositional variables appearing
var().
present Figure 3 algorithm GenPI computes set prime implicates
given formula. algorithm works follows: Step 1, check whether
unsatisfiable, outputting contradictory clause case. satisfiable ,
set equal set satisfiable terms whose disjunction equivalent .
Distribution, know every prime implicate equivalent disjunction
prime implicates terms . Step 2, set (T ) equal propositional
83

fiBienvenu

Function GenPI()
Input: formula
Output: set clauses
(1) unsatisfiable, return {3(a a)}. Otherwise, set = Dnf -4().
(2) : let LT set propositional literals let DT
set formulae 3 . literals
form 2 , set (T ) = LT {3 | DT }. Otherwise, set (T ) =
LT {2T } {3( ) | DT }
conjunction
formulae 2 .
W
(3) Set Candidates = { | (T )}.
(4) j Candidates: remove j Candidates k |= j
k Candidates k < j, j |= k j 6|= k k > j.
(5) Return Candidates.
Figure 3: Algorithm prime implicate generation.

literals (LT ) plus strongest 2-literal implied (2T ) plus strongest 3literals implied ({3( ) | DT }). hard see every prime
implicate must equivalent one elements (T ). means
Step 3 guaranteed every prime implicate input formula equivalent
candidate prime implicate Candidates. comparison phase Step 4,
non-prime candidates eliminated, exactly one prime implicate equivalence
class retained.
illustrate behavior GenPI example:
Example 15. run GenPI input = ((3(b c) 3b) (3b 3(c d) 2e 2f )).
Step 1: satisfiable, call function Dnf -4 , returns two terms
T1 = 3(b c) 3b T2 = 3b 3(c d) 2e 2f .
Step 2: LT1 = {a}, DT1 = {b c, b}, 2-literals T1 ,
get (T1 ) = {a, 3(b c), 3b}. T2 , LT2 = {a}, DT2 = {b, c d},
T2 = e f , giving us (T2 ) = {a, 2(e f ), 3(b e f ), 3((c d) e f )}.
Step 3: set Candidates contain different possible disjunctions elements
(T1 ) elements (T2 ), 12: aa, a2(ef ), a3(bef ),
3((c d) e f ), 3(b c) a, 3(b c) 2(e f ), 3(b c) 3(b e f ),
3(bc)3((cd)ef ), 3ba, 3b2(ef ), 3b3(bef ), 3b3((cd)ef ).
Step 4: remove Candidates clauses 2(e f ), 3(b e f ),
3((c d) e f ), 3(b c) a, 3b since strictly weaker
a. eliminate clauses 3b 2(e f ), 3b 3(b e f ),
84

fiPrime Implicates Prime Implicants Modal Logic

3b 3((c d) e f ) since weaker clauses 3(b c) 2(e f ),
3(b c) 3(b e f ), 3(b c) 3((c d) e f ).
Step 5: GenPI return four remaining clauses Candidates, a,
3(b c) 2(e f ), 3(b c) 3(b e f ), 3(b c) 3((c d) e f ).
algorithm shown sound complete procedure generating prime
implicates.
Theorem 16. algorithm GenPI always terminates outputs exactly set
prime implicates input formula.
examining prime implicates produced algorithm, place upper
bound length formulas prime implicates.
Theorem 17. length smallest clausal representation prime implicate
formula single exponential length formula.
upper bound optimal find formulae exponentially large prime
implicates. situation contrasts propositional logic, length prime
implicates linearly bounded number propositional variables formula.
Theorem 18. length smallest clausal representation prime implicate
formula exponential length formula.
interesting note formula used proof Theorem 18 depth
1, means cannot avoid worst-case spatial complexity restricting
attention formulae shallow depth. escape exponential worst-case
spatial complexity dropping one less expressive notions prime implicates
examined previous section, following theorem attests.
Theorem 19. prime implicates defined using either D1 D2, length
smallest clausal representation prime implicate formula exponential
length formula.
examination set candidate prime implicates constructed algorithm
allows us place bound maximal number non-equivalent prime implicates
formula possess.
Theorem 20. number non-equivalent prime implicates formula
double exponential length formula.
bound shown optimal. situation contrasts propositional
logic, single exponentially many non-equivalent prime implicates
given formula.
Theorem 21. number non-equivalent prime implicates formula may double
exponential length formula.
Again, worst-case result robust improved neither restricting depth formulae, using less expressive notions prime implicate,
following theorem demonstrates.
85

fiBienvenu

Theorem 22. prime implicates defined using either D1 D2, number
non-equivalent prime implicates formula may double exponential length
formula.
Theorems 19 22 together suggest definitions D1 D2 yield especially interesting approximate notions prime implicate, induce significant loss
expressivity without improvement size number prime implicates
worst-case.
generation algorithm GenPI corresponds simplest possible implementation
distribution property, quite clear represent practicable
way producing prime implicates. One major source inefficiency large number
clauses generated, want design efficient algorithm, need
find ways generate fewer candidate clauses. couple different techniques
could used. One simple method could yield smaller number clauses
eliminate (T ) elements prime implicates , thereby
decreasing cardinalities (T ) hence Candidates. this, simply
test whether tautology (and remove is) compare 3-literals
(T ), discarding weaker elements. apply technique Example 15, would
remove 3b (T1 ), thereby reducing cardinality Candidates 12 8.
substantial savings could achieved using technique developed framework propositional logic (cf. Marquis, 2000) consists calculating prime implicates T1 , prime implicates T1 T2 , T1 T2 T3 ,
get prime implicates full disjunction terms. interleaving comparison
construction, eliminate early partial clause cannot give rise prime
implicates instead producing extensions partial clause deleting
one one comparison phase. example, two terms,
imagine third term T3 . applying technique, would
first produce 4 prime implicates T1 T2 would compare 4|(T3 )|
candidate clauses T1 T2 T3 . Compare current algorithm generates
compares 12|(T3 )| candidate clauses.
Given number elements Candidates double exponential
length input, cutting size input GenPI could yield significant
savings. One obvious idea would break conjunctions formulae conjuncts,
calculate prime implicates conjuncts. Unfortunately, however,
cannot apply method every formula prime implicates conjuncts
necessarily prime implicates full conjunction. One solution proposed
context approximation description logic concepts (cf. Brandt & Turhan, 2002)
identify simple syntactic conditions guarantee get result
break formula conjuncts. instance, one possible condition
conjuncts share propositional variables. formula example satisfies
condition since variables ((3(b c) 3b) (3b 3(c d) 2e 2f ))
disjoint. generating prime implicates conjuncts separately, directly
identify prime implicate a, 6 candidate clauses ((3(b c) 3b)
(3b 3(c d) 2e 2f )) compare. remove weaker elements (Ti )
86

fiPrime Implicates Prime Implicants Modal Logic

suggested above, get 3 candidate clauses ((3(bc)3b)(3b3(cd)2e2f )),
prime implicates .
Another important source inefficiency algorithm comparison phase
compare candidate clauses one-by-one order identify strongest ones.
problem course worst-case double exponential
number candidate clauses, simply may double exponentially many
distinct prime implicates, prime implicate must equivalent candidate
clause. Keeping double exponentially many clauses memory generally
feasible. Fortunately, however, necessary keep candidate clauses
memory since generate demand sets (T ). Indeed,
demonstrate appendix, implementing algorithm clever fashion,
obtain algorithm outputs prime implicates iteratively requiring
single-exponential space (the output algorithm could course double exponentially
large Theorem 21).
Theorem 23. exists algorithm runs single-exponential space size
input incrementally outputs, without duplicates, set prime implicates
input formula.
Although modified algorithm much better spatial complexity original,
still yield practicable means generating prime implicates. reason
still need compare candidate clauses candidate clauses
order decide whether candidate prime implicate not. Given set
candidate clauses may double exponential number, means algorithm may
need perform double exponentially many entailment tests producing even single
prime implicate. much promising approach would test directly whether
candidate clause prime implicate without considering candidate clauses.
order implement approach, must course come procedure
determining whether given clause prime implicate. objective
following section.
5.2 Recognizing Prime Implicates
focus section problem recognizing prime implicates, is, problem
deciding whether clause prime implicate formula . discussed
previous subsection, problem central importance, algorithm
generating prime implicates must contain (implicitly explicitly) mechanism
ensuring generated clauses indeed prime implicates.
propositional logic, prime implicate recognition BH2 -complete (Marquis, 2000),
hard satisfiability deduction. K, satisfiability unsatisfiability
Pspace-complete, cannot hope find prime implicate recognition algorithm
complexity less Pspace.
Theorem 24. Prime implicate recognition Pspace-hard.
order obtain first upper bound, exploit Theorem 17 tells us
exists polynomial function f every prime implicate formula
87

fiBienvenu

equivalent clauses length 2f (||) . leads simple procedure
determining clause prime implicate formula . simply check every
clause length 2f (||) whether implicate implies
implied . case, prime implicate (we found logically
stronger implicate ), otherwise, exists stronger implicate, prime
implicate. hard see algorithm carried exponential
space, gives us Expspace upper bound.
course, problem naive approach take
account structure , end comparing huge amount irrelevant clauses,
exactly hoping avoid. algorithm propose later
section avoids problem exploiting information input formula clause
order cut number clauses test. key algorithm
following theorem shows general problem prime implicate recognition
reduced specialized tasks prime implicate recognition propositional
formulae, 2-formulae, 3-formulae. simplify presentation theorem,
let () refer set prime implicates , use notation \ {l1 , ..., ln }
refer clause obtained removing literals li . example
(a b 3c) \ {a, 3c} refers clause b.
Theorem 25. Let formula K, let = 1 ... k 31 ... 3n 21 ...
2m (j propositional literals) non-tautologous clause (a) 1 ...n
i, (b) literal l \ {l}. ()
following conditions hold:
1. 1 ... k ( ( \ {1 , ..., k }))
2. 2(i 1 ... n ) ( ( \ {2i })) every
3. 3(1 ... n ) ( ( \ {31 , ..., 3n }))
remark restriction clauses 1 ...
6 \ {l} l required. drop first requirement,
non-prime implicates satisfy three conditions, drop second,
prime implicates fail satisfy one conditions5 . restrictions
without loss generality however since every clause transformed equivalent
clause satisfying them. first condition, replace 2i 2(i 1 ... ),
thereby transforming clause 1 ... k 31 ...3m 21 ... 2n equivalent
1 ... k 31 ...3m 2(1 1 ... ) ... 2(n 1 ... ). make
clause satisfy second condition, simply remove literals
\ {l} literal remains.
Theorem 25 shows prime implicate recognition split three specialized sub-tasks, tell us carry tasks. Thus, order turn
5. first restriction, consider formula = 3(abc)2a clause = 3(ab)2(ab).
easily shown implicate , prime implicate since exist
stronger implicates (e.g. itself). Nonetheless, verified 2(a b (a b))
( ( \ {2(a b)})) 3(a b) ( ( \ {3(a b)})). second restriction, consider
formula 2a clause 2a2(ab). 2(ab) 6 (2a(2a)) even though 2a2(ab) 2a
prime implicate 2a.

88

fiPrime Implicates Prime Implicants Modal Logic

theorem algorithm prime implicate recognition, need figure
test whether propositional clause, 2-formula, 3-formula prime implicate
formula.
Determining whether propositional clause prime implicate formula K
conceptually difficult determining whether propositional clause prime
implicate propositional formula. first ensure clause implicate
formula make sure literals appearing clause necessary.
Theorem 26. Let formula K, let non-tautologous propositional clause
|= literal l \ {l}. ()
6|= \ {l} l .
move problem deciding whether clause form 2 prime
implicate formula . remark 2 implied , must implied
terms Ti Dnf -4(). Ti |= 2, Theorem 1, must
case conjunction 2-literals Ti implies 2. means formula
21 ... 2n (where conjunction formulae 2 Ti )
implicate implies 2, moreover strongest implicate. follows
2 prime implicate case 2 |= 21 ... 2n ,
true |= (by Theorem 1). Thus, comparing formula
formulae associated terms , decide whether 2
prime implicate .
Theorem 27. Let formula K, let = 2 non-tautologous clause
|= . () exists term Dnf-4()
|= , conjunction formulae 2 .
Finally let us turn problem deciding whether clause 3 prime implicate
formula . know Covering 3 implicate , must
prime implicate implies 3. follows Theorem 2 must

W disjunction 3-literals, Theorem 16 equivalent disjunction
Dnf -4() 3dT 3dT element (T ) every (refer back Figure 3
definition (TW
)). According Definition 7, 3 aWprime implicate
case 3 |= Dnf -4() 3dT , equivalently |= Dnf -4() dT . Thus, 3
prime implicate W
case isWa choice 3dT (T )
6|= Dnf -4() dT .
Dnf -4() Dnf -4() dT |= W
Testing directly whether entails formula Dnf -4() dT could take exponential
space worst case since may exponentially many terms Dnf -4(). Luckily,
W however, get around problem exploiting structure formula
Dnf -4() dT . remark way (T ) defined formula dT must
conjunction formulae 2 3 appears Nnf () outside scope
modal operators use X W
denote set formulae satisfying condition.
show appendix
6|= Dnf -4() dT implies existence subset X
W
(a) 6|= (b) every dT least W
one conjunct set S. Conversely,
existence subset X implies 6|= Dnf -4() dT . observation
basis algorithm Test3PI given Figure 4. basic idea behind algorithm
try different subsets X order see whether subset satisfies
89

fiBienvenu

Function Test3PI(3, )
Input: clause 3 formula |= 3
Output: yes
(1) |= , return yes |= otherwise.
(2) Set X equal set formulae 2 3 appears Nnf () outside
scope modal operators.
(3) W
X , test whether following two conditions hold:
(a) 6|=
(b) Ti Dnf -4(), exists conjuncts 3i , 2i,1 , ..., 2i,k(i) Ti
that:
(i) {i , i,1 , ..., i,k(i) } 6=
(ii) 3(i i,1 ... i,k(i) ) |= 3
Return satisfies conditions, yes otherwise.
Figure 4: Algorithm identifying prime implicates form 3.

aforementioned conditions. find suitable subset, proves 3 prime
implicate, subset exists, sure stronger implicate
3. algorithm shown run polynomial space since
|| elements X , consider terms Dnf -4() one time.
Theorem 28. Let formula, let 3 implicate . algorithm
Test3PI returns yes input (3, ) 3 prime implicate .
Theorem 29. algorithm Test3PI runs polynomial space.
illustrate algorithm Test3PI two examples.
Example 30. use Test3PI test whether clause = 3(ab) prime implicate
= (2(b c) 2(e f )) 3(a b).
Step 1: satisfiable, pass directly Step 2.
Step 2: set X equal set formulae 2 3 appears Nnf ()
outside scope modal operators. case, set X = {b c, e f, b}
since =Nnf () b c, e f , b formulae satisfying
requirements.
Step 3: examine different subsets X determine whether satisfy
conditions (a) (b). particular, consider subset = {b c, e f }.
remark subset satisfies condition (a) since b 6|= (b c) (e f ). order
check condition (b), first call function Dnf -4 returns two
terms T1 = 2(b c) 3(a b) T2 = 2(e f ) 3(a b). notice
conjuncts 3(a b) 2(b c) T1 satisfy conditions (i) (ii) since b c
3(a b (b c)) |= . notice conjuncts 3(a b) 2(e f )
T2 satisfy conditions (i) (ii) since e f 3(a b (e f )) |= .
90

fiPrime Implicates Prime Implicants Modal Logic

Function TestPI(, )
Input: clause formula
Output: yes
(1) 6|= , return no.
(2) |= , return yes |= not.
|= , return yes |= otherwise.
(3) li = l1 ... ln , test \ {li } , so, remove li .
Let = {31 , ..., 3m } set 3-literals . non-empty, replace
disjunct 2 literal 2( 1 ... ).
(4) Let P set propositional literals disjuncts .
l P, check whether |= \ {l}, return so.
(5) Let B set 2-formulae appearing disjuncts . Check 2
B whether Dnf -4( ( \ {2})) formula
2( 1 ... k ) implies conjunction 2-literals , return
not.
W
(6) empty, return yes, otherwise return Test3PI(3(
i=1 ), ( \ D)).
Figure 5: Algorithm identifying prime implicates.

means found subset X satisfies conditions (a) (b),
algorithm returns no. correct output since 3(a b ((b c) (e f )))
implicate strictly stronger .
Example 31. use Test3PI test whether clause = 3(a b c) prime
implicate = (2(b c) 2(e f )) 3(a b) 2(e f (a b c)).
Step 1: proceed directly Step 2 since satisfiable.
Step 2: set X = {b c, e f, b, e f (a b c))} since Nnf ()=a (2(b
c) 2(e f )) 3(a b) 3(e f (a b c)).
Step 3: check whether subset X satisfying conditions (a) (b).
claim subset. see why, notice 2(b c) 3(a b)
3(e f (a b c)) term Dnf -4(). Moreover, one
set conjuncts term implies 3(a b c), namely {3(a b), 2(b c)}.
means must contain either b b c order satisfy condition
(b)(i). b c implies b b c, guaranteed b c
imply disjunction elements S, thereby falsifying condition (a). follows
subset X satisfying necessary conditions, Test3PI returns
yes, desired result.
Figure 5, present algorithm testing whether clause prime implicate
formula . first two steps algorithm treat limit cases
implicate one tautology contradiction. Step 3,
91

fiBienvenu

apply equivalence-preserving transformations make satisfy requirements
Theorem 25. Steps 4, 5, 6 use procedures Theorems 26, 27,
28 test whether three conditions Theorem 25 verified. three tests
succeed, Theorem 25, clause prime implicate, return yes.
test fails, return clause shown prime implicate.
Theorem 32. algorithm TestPI always terminates, returns yes input (,
) prime implicate .
demonstrate use TestPI example.
Example 33. use TestPI test clauses 1 = b, 2 = 2b 2(e f ), 3 = 3c,
4 = 3(a b), 5 = 3(a b c) 3(a b c f ) 2(e f ) prime implicates
= (2(b c) 2(e f )) 3(a b).
1 : output Step 1 since 6|= 1 .
2 : skip Steps 1 2 since |= 2 neither |= |= 2 . Step 3,
make changes 2 since contains redundant literals 3-literals.
skip Step 4 since 2 propositional disjuncts. Step 5, return since
Dnf -4( (2 \ {2b})) = {a 2(b c) 3(a b) 3(e f )} 2b 6|= 2(b c).
3 : proceed directly Step 3 since |= 3 , 6|= , 6|= 3 . modifications
made 3 Step 3 contain redundant literals 2-literals.
Step 4, test whether |= 3 \ {a}. 6|= 3c, proceed Step
5, directly Step 6 since 3 contains 2-literals. Step 6, call
Test3PI(3c, (3 \ {3c})), outputs since (3 \ {3c}) |=
c 6|= .
4 : Steps 1-5 inapplicable, skip directly Step 6. step, call
Test3PI input clause 3(a b) formula (4 \{3(a b)}) = .
already seen Example 30 Test3PI returns input,
means TestPI returns no.
5 : proceed directly Step 3, delete redundant literal 3(a b c f )
modify literal 2(ef ). end step, 5 = 3(abc)
2((ef )(abc)). Step 4 applicable since propositional disjuncts
5 . Step 5, continue since Dnf -4( (5 \ {2((e f (a b c))})) =
{a2(ef )3(ab)2(abc)}, 2(((ef (abc))(abc)) |=
2(e f ) 2(a b c). Step 6, return yes since call Test3PI input
(3(a b c), (5 \ {3(a b c)})), previously shown Example
31 Test3PI returns yes input.
show appendix algorithm TestPI runs polynomial space.
already shown TestPI decides prime implicate recognition, follows
problem Pspace:
Theorem 34. Prime implicate recognition Pspace.
92

fiPrime Implicates Prime Implicants Modal Logic

putting together Theorems 24 34, obtain tight complexity bound
prime implicate recognition task.
Corollary 35. Prime implicate recognition Pspace-complete.

6. Conclusion Future Work
first contribution work detailed comparison several different possible
definitions clauses, terms, prime implicates, prime implicants modal logic K.
results investigation largely positive: although shown
perfect definition exists, exhibit simple definition (D4) satisfies
desirable properties propositional case. second contribution work
thorough investigation computational aspects selected definition D4.
end, presented sound complete algorithm generating prime implicates, well
number optimizations improve efficiency algorithm. examination
structure prime implicates generated algorithm allowed us place upper
bounds length prime implicates number prime implicates formula
possess. showed bounds optimal exhibiting matching lower bounds,
proved lower bounds hold even much less expressive notions prime implicates. Finally, constructed polynomial-space algorithm deciding
prime implicate recognition, thereby showing problem Pspace-complete,
lowest complexity could reasonably expected. Although focus paper
logic K, results easily lifted multi-modal K concept
expressions well-known description logic ALC.
mentioned introduction, one main applications prime implicants
propositional logic area abductive reasoning, prime implicants play
role abductive explanations. results paper directly applied
problem abduction K: notion prime implicants used definition
abductive explanations K, prime implicate generation algorithm provides means
producing abductive explanations given abduction problem. Moreover,
notion term underlying definition abductive explanations
expressive used Cialdea Mayer Pirri (1995), able find explanations
overlooked method. instance, look explanation
observation c given background information 2(a b) c, obtain 2(a b), whereas
framework yields 2a 2b. argument favor approach since
generally abduction one looking find weakest conditions guaranteeing truth
observation given background information.
interest results size number prime implicates,
yield corresponding lower bounds size number abductive explanations.
particular, results imply abductive explanations Cialdea Mayer Pirri
(1995) exponential size double exponentially many number worst
case, thus behave better respects notion abductive explanation
induced preferred definition D4. Moreover, fact lower bounds hold
even case extremely inexpressive notion abductive explanations induced
definition D2 suggests high worst-case complexity results really cannot
93

fiBienvenu

avoided. light intractability results, interesting question future research
would study problem generating single prime implicate, since applications may prove sufficient produce single minimal explanation observation.
Another interesting subject future work relevant point view abduction investigation notion prime implicate fixed vocabulary.
development generation algorithms refined notion prime implicate would
allow one generate abductive explanations built given set
propositional variables.
second domain application mentioned introduction
area knowledge compilation. propositional logic, one well-known target language
knowledge compilation prime implicate normal form, formula represented
conjunction prime implicates. natural idea would use selected
definition prime implicate define analogous manner notion prime implicate
normal form K formulae. Unfortunately, normal form obtain satisfies
nice properties propositional case. instance, find entailment two
formulae prime implicate normal form easier arbitrary K formulae.
see why, consider pair formulae negation normal form. formulae
3 3 prime implicates hence prime implicate normal form
according naive definition. |= case 3 |= 3, reduce
entailment arbitrary K formulae NNF entailment formulae prime
implicate normal form. former problem known Pspace-complete, follows
latter Pspace-complete well.
first sight, appears quite disappointing result one would hope
computational difficulty representing formula prime implicates would offset
good computational properties resulting formula. turns out, however,
problem lies definition prime implicates rather naive way
defining prime implicate normal form. Indeed, continuation present work (Bienvenu, 2008), proposed sophisticated definition prime implicate normal form,
specify many different clausal representations prime implicate
used. normal form shown enjoy number desirable properties
make interesting viewpoint knowledge compilation. notably,
proven entailment formulae K prime implicate normal form
carried polynomial time using simple structural comparison algorithm
reminiscent structural subsumption algorithms used subpropositional description
logics. noted proof results Bienvenu (2008) make
ample use material presented current paper.
work, studied prime implicates respect local consequence relation,
natural direction future work would investigation prime implicates respect global consequence relation. question particularly interesting given
global consequence type consequence used description logic ontologies. Unfortunately, preliminary investigations suggest defining generating prime implicates
respect global consequence relation likely prove difficult
local consequence relation. one thing, use definition clause reasonably
94

fiPrime Implicates Prime Implicants Modal Logic

expressive, notion prime implicate obtain satisfy Covering since
construct infinite sequences stronger stronger implicates. Take instance
formula (a b) (b 3b) implies (using global consequence relation)
increasingly stronger clauses infinite sequence 3b, 3(b 3b),
3(b 3(b 3b)), ... familiar situation description logic practitioners since
infinite sequences responsible non-existence specific concepts
many common DLs (cf. Kusters & Molitor, 2002) lack uniform interpolation
ALC TBoxes (Ghilardi, Lutz, & Wolter, 2006). standard solution problem
simply place bound depth formulae considered, effectively blocking
problematic infinite sequences. allow us regain Covering, give
us weaker version property, sufficient applications.
development generation algorithms global consequence relation may prove
challenging, since unclear point whether able draw inspiration
pre-existing methods. Despite potential difficulties, feel subject worth
exploring since could contribute development flexible ways accessing
structuring information description logic ontologies.
Finally, another natural direction future research would extend investigation prime implicates prime implicants popular modal description logics.
Particularly interest modal logics knowledge belief expressive description
logics used semantic web. confident experience gained
investigation prime implicates prime implicants K prove valuable asset
exploration modal description logics.

Acknowledgments
paper corrects significantly extends earlier conference publication (Bienvenu,
2007). paper written author PhD student working IRIT,
Universite Paul Sabatier, France. author would thank thesis supervisors
Andreas Herzig, Jerome Lang, Jerome Mengin, well anonymous reviewers
helpful feedback.

Appendix A. Proofs
Theorem 1 Let , 1 , ..., , , 1 , ..., n formulae K, let propositional
formula.
1. |= |= |=
2. |= 3 |= 3 2 |= 2
3. 31 ...3m 21 ...2n |= ( |= 1 ...n |= i)
4. |= 31 ... 3m 21 ... 2n (|= |= 1 ... i)
5. 2 |= 21 ... 2n |=
95

fiBienvenu

6. 31 ... 3m 21 ... 2n
31 ... 3m 2(1 1 ... ) ... 2(n 1 ... )
Proof. first statement well-known property local consequence, prove
completeness:
|=






M, w |= implies M, w |= M, w
M, w 6|= M, w |= M, w
M, w |= M, w |= M, w
|=
M, w 6|= M, w
|=

second statement, 6|= , M, w M, w |= .
Create new model adding new world w placing single arc
w w. , w |= 3 2, means 3 2 satisfiable hence
3 6|= 3 (since 2 3). direction, suppose 3 6|= 3.
exists M, w M, w |= 3 3 3 2. means
w , hence 6|= . complete proof, use following chain
equivalences: 2 |= 2 2 |= 2 3 |= 3 |= |= .
3, suppose 31 ... 3m 21 ... 2n 6|= . exist M, w
M, w |= 31 ...3m 21 ... 2n . M, w |= , cannot
|= , 1 ... n |= since w
M, w |= 1 ... n . direction suppose
1 ... n satisfiable. propositional model w ,
i, find Mi , wi Mi , wi |= 1 ... n . construct new
Kripke structure contains models Mi world w arcs
going w wi . hard see new model Mnew
Mnew , w |= 31 ...3m 21 ...2n , 31 ...3m 21 ... 2n 6|= .
Statement 4 follows easily third statement. simply notice 31
... 3m 21 ... 2n tautology case negation 31
... 3n 21 ... 2m unsatisfiable.
5, use statements 1 4 get following chain equivalences:
2 |= 21 ... 2n
|= 3 21 ... 2n
|=
|=
first implication equivalence 6 immediate since 31 ... 3m |=
31 ... 3m 2i |= 2(i 1 ... ) i. direction, remark
using statements 1 3, get following equivalences:
2(i 1 ... ) |= 2i 31 ... 3m
2(i 1 ... ) (2i 31 ... 3m ) |=
2(i 1 ... ) 3i 21 ... 2m |=
(i 1 ... ) 1 ... |=
96

fiPrime Implicates Prime Implicants Modal Logic

(i 1 ... ) 1 ... clearly unsatisfiable, follows
2(i 1 ... ) |= 2i 31 ... 3m every hence 31 ... 3m
2(1 1 ... ) ... 2(n 1 ... ) |= 31 ... 3m 21 ... 2n ,
completing proof.
Theorem 2 Let disjunction propositional literals 2- 3-formulae.
following statements holds:
1. |= non-tautological propositional clause , every disjunct
either propositional literal unsatisfiable 3-formula
2. |= 31 ... 3n , every disjunct 3-formula
3. |= 21 ... 2n 6|= 21 ... 2n , every disjunct either
2-formula unsatisfiable 3-formula
Proof. (1), let non-tautologous propositional clause |= , suppose
contradiction contains disjunct 2 disjunct 3 6|= .
first case, 2 |= , hence |= 3 . follows Theorem 1
|= , contradicting assumption tautology. second case,
3 |= , thus |= 2 . Theorem 1, either |= |= . cases,
reach contradiction since assumed 6|= 6|= . follows
cannot 2-formulae satisfiable 3-formulae disjuncts.
proofs (2) (3) proceed similarly.
Theorem 3 Let = 31 ... 3m 21 ... 2n = 31 ... 3p
21 ... 2q formulae K. propositional 6|= ,

|=

1 ... |= 1 ... p
|=

every j |= 1 ... p j
Proof. Since 6|= , know 6|= 6|= 1 ... p i. Using
information together Theorem 1, get following equivalences:
|=


31 ... 3m |=



2i |=



|= 31 ... 3p 21 ... 2m
|=
|=
3(1 ... ) |=
|= 31 ... 3p 2(1 ... ) 21 ... 2q
|= 1 ... p (1 ... )
1 ... |= 1 ... p
|= 3(1 ... p ) 21 ... 2q
j |= 1 ... p j
j |= 1 ... p j

complete proof, use fact |= |= , 31 ... 3m |= ,
2i |= every i.
97

fiBienvenu

Theorem 5 definition literals, clause, terms K satisfies properties P1
P2 cannot satisfy P5.
Proof. remark set clauses (resp. terms) respect definition D1
precisely set formulae NNF contain (resp. ), i.e. D1
expressive definition satisfying P1 P2. Thus, show result, suffices
show D1 satisfy P5.
Suppose contradiction D1 satisfy P5. must exist clauses 1 , ..., n
3(a b) 1 ... n . clauses disjunction li,1 .... li,pi .
distributing , obtain following:
n
^

_

3(a b)

li,ji

(j1 ,...,jn){1,...,p1 }...{1,...,pn} i=1

infer (j1 , ..., jn ) {1, ..., p1 } ... {1, ..., pn }
n
^

li,ji |= 3(a b)

i=1

Vn

Consider (j1 , ..., jn ) i=1 li,ji consistent (there must least one
tuple, otherwise would 3(a b) ). formulae li,ji eitherVpropositional
literals formulae form 2 3 clause . follows ni=1 li,ji must
following form:
1 ... k 31 ... 3m 21 ... 2n
1 , ..., k propositional
literals 1 , ...,
V , 1 , ..., n clauses respect
V
D1. know ni=1 li,ji |= 3(a b) ni=1 li,ji 6|= , Theorem 1, must
3q
3q 21 ... 2n |= 3(a b)
show 3q 6|= 3(a b) (and hence 6|= 1 ... n ). Suppose
contradiction case. must q |= q |= b.
Theorem 1, every disjunct q (which recall D1-clause) must either unsatisfiable
equal b. latter
V impossible, follows q |= ,
contradiction since assumed ni=1 li,ji satisfiable. follows order
get 3q 21 ... 2n |= 3(a b), must r tautology.
let us consider formula
_
=
2j1 ,...,jn
{(j1 ,...,jn)|

Vn

i=1 li,ji 6}

V
2j1 ,...,jn non-tautological 2-formula appearing ni=1 li,ji (we shown
formula must exist). Clearly must case
n
^

_

(j1 ,...,jn){1,...,p1 }...{1,...,pn} i=1

98

li,ji |=

fiPrime Implicates Prime Implicants Modal Logic

get:
3(a b) |=
according Theorem 2, satisfiable 3-formula cannot imply disjunction 2formulae unless disjunction tautology, must |= . However,
impossible since would imply (Theorem 1) j1 ,...,jn tautology,
contradicting earlier assumption contrary. thus conclude
set clauses 1 , ..., n respect D1 3(a b) 1 ... n , hence
definition satisfies P1 P2 cannot satisfy P5.
order prove Theorem 6, make use following lemmas:
Lemma 6.1 Definition D5 satisfies P5.
Proof. demonstrate formula K NNF equivalent conjunction
clauses respect definition D5. restriction formulae NNF without loss
generality every formula equivalent formula NNF. proof proceeds
induction structural complexity formulae. base case propositional literals,
already conjunctions clauses since every propositional literal clause
respect D5. suppose statement holds formulae 1 2 show
holds complex formulae.
first consider = 1 2 . assumption, find clauses j
1 1 ... n 2 1 ... . Thus, equivalent formula
1 ... n 1 ... , conjunction clauses respect D5.
Next consider = 1 2 . induction hypothesis, 1 1 ... n
2 1 ... clauses j . Thus, (1 ... n ) (1 ... ),
written equivalently (i,j){1,...,n}{1,...,m}(i j ). Since union
two clauses produces another clause, j clauses, completing proof.
consider case = 21 . assumption, 1 1 ... n ,
clause. 2(1 ...n ). know 2(1 ...n ) 21 ...2n .
follows equivalent 21 ... 2n , conjunction clauses since
2i clauses.
Finally, consider = 31 . Using induction hypothesis, 3(1
... n ) clauses . since clauses, disjunction literals
li,1 ... li,pi . distributing 3, find equivalent
formula
_
3(l1,j1 l2,j2 ... ln,jn )
(j1 ,...,jn){1,...,p1 }...{1,...,pn}

clause respect D5.
proof every formula equivalent disjunction terms respect D5
proceeds analogously.
Lemma 6.2 Every clause (resp. term) respect D5 clause (resp. term)
respect definitions D3a, D3b, D4.
Proof. show induction structural complexity formulae that:
99

fiBienvenu

1. every clause C respect D5 clause respect definitions D3a, D3b,
D4 disjunction terms respect D3a
2. every term respect D5 term respect definitions D3a, D3b,
D4 conjunction clauses respect D3a D3b
require stronger formulation statement prove sub-cases.
base case induction propositional literals, clauses
terms respect D5. easy see (1) (2) verified since propositional
literals clauses terms respect definitions D3a, D3b, D4 (and
hence disjunctions terms respect D3a conjunctions clauses
respect D3a D3b).
induction step, show statements hold arbitrary clauses
terms respect D5 assumption statments hold
proper sub-clauses sub-terms.
begin clauses. Let C D5-clause proper sub-clauses subterms C satisfy (1) (2). since C clause respect D5, either
propositional literal formula form C1 C2 clauses C1 C2 , 2C1
clause C1 , 3T1 term T1 . case C propositional literal
already treated base case. Let us thus consider case C = C1 C2 .
first part (1) holds since induction hypothesis C1 C2 clauses
respect definitions D3a, D3b, D4, three definitions disjunction
two clauses clause. second half (1) verified since C1 C2
disjunctions terms respect D3a, thus disjunction C1 C2 .
next consider case C = 2C1 clause C1 respect D5. first
part (1) follows easily know C1 must clause respect D3a,
D3b, D4, definitions putting 2 clause yields another
clause. second part (1) holds well since C1 disjunction terms respect
D3a thus 2C1 term respect definition. suppose
C = 3T1 term T1 respect D5. definitions D3a D3b, know
induction hypothesis T1 conjunction clauses respect D3a
D3b hence 3T1 clause respect definitions. D4, result
obviously holds since allowed put formula NNF behind 3. second part
(1) holds since induction hypothesis T1 term respect D3a hence
3T1 term respect definition.
next consider terms. Let D5-term proper sub-clauses subterms satisfy (1) (2). must either propositional literal formula
form T1 T2 terms T1 T2 , 2C1 clause C1 , 3T1 term T1 .
= T1 T2 , first half (2) holds since know T1 T2 terms respect
D3a, D3b, D4, conjunctions terms terms three definitions.
second half verified since T1 T2 assumed conjunctions clauses
respect D3a D3b, means conjunction clauses
respect definitions. Next suppose = 2C1 . definitions D3b D4,
easy see literal hence term. D3a, induction hypothesis tells us
C1 disjunction terms, deduce 2C1 term. Moreover,
since C1 known clause respect D3a D3b, 2C1 must
100

fiPrime Implicates Prime Implicants Modal Logic

clause respect definitions, conjunction clauses respect
D3a D3b. Finally, treat case = 3T1 . D3a, use fact
T1 term respect D3a, means 3T1 must term. D3b,
use supposition T1 conjunction clauses respect D3b,
get 3T1 literal hence term. first part (2) clearly holds D4
since formula behind 3 yields literal thus term. second half (2) follows
fact induction hypothesis T1 conjunction clauses respect
D3a D3b, 3T1 clause (and hence conjunction clauses) respect
definitions.

U ,S = 1,1 ... 1,m
i,j defined inductively follows

3i+1,j , either n, ui Sj , > n uin Sj
i,j =
2i+1,j , either n, ui 6 Sj , > n uin 6 Sj
{1, ..., 2n} 2n+1,j = , = 2...2
| {z } .
2n

Figure 6: formula U ,S codes instance U = {u1 , ..., un }, = {S1 , ..., Sm }
exact cover problem.

Lemma 6.3 Entailment terms clauses NP-complete definitions D1
D2.
Proof. proofs NP-membership NP-hardness, exploit relationship terms respect definitions D1 D2 concept expressions
description logic ALE (cf. Baader, McGuiness, Nardi, & Patel-Schneider, 2003).
recall concept expressions logic constructed follows (we use modal logic
syntax assume single modal operator order facilitate comparison
formalisms):
::= | | | | | 2 | 3
semantics symbols one would expect: M, w |= M, w 6|=
every model world w. semantics atomic literals, conjunctions, universal
existential modalities exactly K.
hard see every term respect D1 D2 concept expression
ALE. entailment ALE expressions decidable nondeterministic polynomial
time (cf. Donini, Lenzerini, Nardi, Hollunder, Nutt, & Marchetti Spaccamela, 1992),
follows deciding entailment terms respect either D1 D2
accomplished nondeterministic polynomial time, i.e. problems belong NP.
remains shown problems NP-hard. prove this, show
polynomial-time reduction Donini (2003) (adapted original NP-hardness
proof Donini et al., 1992) NP-complete exact cover (XC) problem (Garey &
101

fiBienvenu

Johnson, 1979) unsatisfiability ALE modified give polynomial-time
reduction XC entailment terms respect D1 D2.
exact cover problem following: given set U = {u1 , ..., un } set =
{S1 , ..., Sm } subsets U, determine whether exists
Sqan exact cover, is, subset
{Si1 , ..., Siq } Sih Sik = h 6= k k=1 Sik = U. Donini proven
(2003) U, exact cover formula U ,S pictured Figure 6
unsatisfiable. Notice U ,S term respect either D1 D2 uses
symbols . would find similar formula term respect
definitions satisfiable U ,S is. Consider formula
U ,S = 1,1 ... 1,m
i,j defined exactly i,j except replace
a. easy verify U ,S indeed term respect D1
D2. Moreover, hard see 1,1 ... 1,m |= 32n
1,1 ... 1,m |= 32n hence U ,S U ,S equisatisfiable. U,
exact cover U ,S unsatisfiable, U ,S unsatisfiable case
U ,S is, follows U, exact cover U ,S unsatisfiable. Moreover,
U ,S produced linear time U ,S , polynomial-time reduction
XC unsatisfiability terms D1 D2. formula unsatisfiable
case entails term a. So, XC polynomially-reduced entailment
terms respect either D1 D2, making problems NP-hard hence
NP-complete.
order show NP-completeness clausal entailment, remark
definitions D1 D2, function Nnf transforms negations clauses terms
negations terms clauses. means test whether clause entails
clause testing whether term Nnf ( ) entails term Nnf (). Likewise,
test whether term entails another term testing whether clause Nnf ( )
entails clause Nnf (). NNF transformation polynomial, follows
entailment clauses exactly difficult entailment terms, clausal
entailment NP-complete.
Lemma 6.4 definition D5, entailment clauses terms Pspace-complete.
Proof. Membership Pspace immediate since entailment arbitrary formulae
K decided polynomial space. prove Pspace-hardness, adapt existing
proof Pspace-hardness K.
Figure 7 presents encoding QBF = Q1 p1 ...Qm pm K-formula f ()
used section 6.7 (Blackburn et al., 2001) demonstrate Pspace-hardness
K. formula f () property satisfiable case
QBF-validity. formula f () generated polynomial-time ,
QBF-validity problem known Pspace-hard, follows satisfiability formulae
K Pspace-hard well.
Figure 8, show modified encoding. claim following:
(1) f () f () logically equivalent
102

fiPrime Implicates Prime Implicants Modal Logic

(i) q0
Vm
(ii) i=0 ((qi j6=i qj ) 2(qi j6=i qj ) ... 2m (qi j6=i qj ))
Vm
(iiia) i=0 ((qi 3qi+1 ) 2(qi 3qi+1 ) ... 2m (qi 3qi+1 ))
V
(iiib) {i|Qi =} 2i (qi (3(qi+1 pi+1 ) 3(qi+1 pi+1 )))
V
Vm1 j
(iv) m1
i=1 ( j=i 2 ((pi 2pi ) (pi 2pi )))

(v) 2m (qm )

Figure 7: formula f () conjunction formulae.
(i) q0
Vm V
(ii) i=0 ( j6=i ((qi qj ) 2(qi qj ) ... 2m (qi qj )))
Vm
(iiia) i=0 ((qi 3qi+1 ) 2(qi 3qi+1 ) ... 2m (qi 3qi+1 ))
V
(iiib) {i|Qi =} 2i (qi 3(qi+1 pi+1 )) 2i (qi 3(qi+1 pi+1 ))
Vm1 Vm1
(iv) i=1 ( j=i (2j (pi 2pi ) 2j (pi 2pi )))

(v) 2m (qm 1 ) .... 2m (qm l )

Figure 8: formula f () conjunction formulae, formulae
(v) propositional clauses 1 ... l .

(2) CNF, f () conjunction clauses respect D5
(3) CNF, f () generated polynomial time f ()
show (1), suffices show (i)(i), (ii)(ii), (iiia)(iiia), (iiib)(iiib), (iv)(iv),
(v)(v). first equivalence immediate since (i) (i) identical. (ii)(ii)
follows fact 2k (qi j6=i qj ) j6=i 2k (qi qj ). (iiia)(iiia) holds
since (iiia) (iiia) qi 3qi+1 replaced qi 3qi+1 . (iiib)(iiib)
since 2i (qi (3(qi+1 pi+1 ) 3(qi+1 pi+1 ))) 2i (qi 3(qi+1 pi+1 )) 2i (qi
3(qi+1 pi+1 )). equivalence (iv)(iv) holds 2j ((pi 2pi ) (pi 2pi ))
2j (pi 2pi ) 2j (pi 2pi ). Finally, (v)(v) since 1 ... l . Thus, f ()
f () logically equivalent.
prove (2), show component formulae f () conjunction
clauses respect D5, provided CNF. Clearly case (i)
(i) propositional literal. formula (ii) conjunction clauses
respect D5 since conjunction formulae form 2k (qi qj ). Similarly,
(iiia), (iiib), (iv) conjunctions clauses since formulae 2k (qi 3qi+1 ),
2i (qi 3(qi+1 pi+1 )), 2i (qi 3(qi+1 pi+1 )), 2k (pi 2pi ), 2k (pi 2pi )
clauses respect D5. formula (v) must conjunction clauses since
assumed propositional clauses, making 2m (qm ) clause
respect D5, (v) conjunction clauses respect D5.
103

fiBienvenu

(3), clear transform (i), (iiia), (iiib), (iv) (i), (iiia), (iiib),
(iv) polynomial time transformations involve simple syntactic operations
resulting formulae twice large. transformation (ii) (ii)
slightly involved, hard see resulting formula
times large original (and greater length f ()).
step could potentially result exponential blow-up transformation
(v) (v), put CNF. assumption already CNF,
transformation executed polynomial time space,
separate conjuncts rewrite (qm ) (qm ).
let = Q1 p1 ...Qm pm QBF = 1 ... l propositional
clauses . Let f () formula defined Figure 8. (2) above, know
f () = 1 ... p clauses respect D5. consider following
formula
= 3(21 ... 2p 32(a a))
show f () satisfiable satisfiable follows:
unsatisfiable
21 ... 2p 32(a a) unsatisfiable
1 ... p 2(a a) unsatisfiable
1 ... p unsatisfiable
f () unsatisfiable
know (1) f () f (), (Blackburn et al., 2001)
f () satisfiable case QBF validity. easy see
satisfiable entail contradiction 3(a a). Putting
altogether, find valid case entail 3(a a).
3(a a) clauses terms respect D5, shown
QBF-validity problem QBF propositional formulae CNF reduced
problems entailment clauses terms respect D5. Moreover,
polynomial time reduction since follows (3) transformation
accomplished polynomial time. suffices show Pspace-hardness, since
well-known QBF-validity remains Pspace-hard even restrict propositional
part formula CNF (cf. Papadimitriou, 1994).
Theorem 6 results Figure 1 hold.
Proof. satisfaction dissatisfaction properties P1 P2 immediately
determined inspection definitions, satisfaction P3 definitions D2,
D3b, D4, D5. Counterexamples P3 definitions D1 D3a provided
body paper: formula 2(a b) clause disjunction literals
respect definitions.
order show definition D3b satisfy P4, remark negation
literal 3(a b) equivalent 2(a b) cannot expressed literal
D3b. definitions, shown (by straightforward inductive
proof) Nnf (L) literal whenever L literal, Nnf (C) term whenever
104

fiPrime Implicates Prime Implicants Modal Logic

C clause, Nnf (T ) clause whenever term. enough prove
definitions satisfy P4 since Nnf () equivalent .
Since know definitions D1 D2 satisfy properties P1 P2, follows
Theorem 5 definitions satisfy P5. seen Lemma 6.1
definition D5 satisfy P5, i.e. every formula equivalent conjunction
clauses respect D5 disjunction terms respect D5. every
clause (resp. term) D5 clause (resp. term) respect definitions D3a, D3b,
D4 (by Lemma 6.2), follows every formula equivalent conjunction
clauses disjunction terms respect definitions, means
satisfy P5.
easy see property P6 satisfied definitions since
definitions context-free grammars, well-known deciding membership
context-free grammars accomplished polynomial time (cf. Younger, 1967).
Lemma 6.3, know deciding entailment clauses terms
respect either D1 D2 NP-complete (and hence P, unless P=NP). Entailment
clauses/terms Pspace-complete D5 (Lemma 6.4). every clause (resp.
term) D5 clause (resp. term) respect definitions D3a, D3b, D4
(from Lemma 6.2), follows entailment clauses terms Pspace-hard
definitions. Membership Pspace immediate since entailment arbitary
K formulae Pspace.
prove Theorem 9 several steps:
Lemma 9.1 notions prime implicates prime implicants induced D4 satisfy
Implicant-Implicate Duality.
Proof. Suppose contradiction prime implicant formula
equivalent negation prime implicate . Let clause
equivalent (there must exist clause property P4, cf. Theorem
6). clause implicate since |= . assumed
prime implicate, must implicate |=
6|= . let term equivalent (here use P4). must
implicant since |= . Moreover, strictly weaker since |=
6|= . means cannot prime implicant,
contradicting earlier assumption. Hence, conclude every prime implicant
formula equivalent negation prime implicate . proof
every prime implicate formula equivalent negation prime implicant
proceeds analogously.
Lemma 9.2 clauses terms defined according definition D4, every implicate formula entailed implicate var( ) var()
depth () + 1, every implicant entails implicant
var( ) var() depth () + 1.
Proof. intend show following statement holds: formula
implicate , exists clause |= |= var( ) var()
105

fiBienvenu

() () + 1. let arbitrary formula, let implicate .
tautology, set = (where var()). , set
= 3(a a) (where var()), clause verifies necessary conditions.
consider case neither tautology falsehood,
show construct clause . first thing use Dnf-4 rewrite
disjunction satisfiable terms Ti respect D4 Ti contain
variables appearing depth ():
= T1 ... Tz
|= , must case Ti |= every Ti . aim find clause
terms Ti Ti |= |= var(i ) var(Ti ) (i ) (Ti ).
consider Ti . Since Ti term, form 1 ... k 31 ... 3m 21
... 2n , 1 , ..., k propositional literals. clause, must form
1 ... p 31 ... 3q 21 ... 2r , 1 , ..., p propositional literals.
Ti |= , must case formula
1 ... k 31 ... 3m 21 ... 2n
1 ... p 21 ... 2q 31 ... 3r
unsatisfiable. Theorem 1, one following must hold:
(a) exists u v u v
(b) exists u u 1 ... n 1 ... q |=
(c) exists u u 1 ... n 1 ... q |=
(a) holds, set = u since Ti |= u |= , (u ) = 0 (Ti ), var(u )
var(Ti ). (b) holds, must case
u 1 ... n |= 1 ... q
hence
3(u 1 ... n ) |= 31 ... 3q |=
set = 3(u 1 ... n ), since Ti |= 3(u 1 ... n ) |= , (3(u 1
... n )) (Ti ), var(3(u 1 ... n )) var(Ti ). Finally, (c) holds,
must case
1 ... n |= 1 ... q u
hence
2(1 ... n ) |= 31 ... 3q 2u |=
set = 2(1 ... n ), Ti |= 2(1 ... n ) |= , (2(1 ... n )) (Ti ),
var(2(1 ... n )) var(Ti ). Thus, shown every Ti ,
Ti |= |= var(i ) var(Ti ) (i ) (Ti ). 1 ... z
clause implied every Ti , hence , var(i ) var(Ti ) var()
(i ) maxi (Ti ) ().
let implicant , let formula Nnf (). know
NNF transformation equivalence-preserving, hence , straightforward
106

fiPrime Implicates Prime Implicants Modal Logic

show must clause respect D4. implicate ,
must clause var( ) var() = var() depth
() + 1 = () + 1 |= |= . Let Nnf ( ). easily verified
term. Moreover, properties NNF transformation, ,
var( ) = var( ) = var( ), ( ) = ( ) = ( ). term
var( ) var(), ( ) () + 1, |= |= .
Lemma 9.3 notions prime implicates prime implicants induced D4 satisfy
Finiteness.
Proof. Consider arbitrary formula . Lemma 9.2, know prime
implicate , must implicate containing propositional
atoms appearing ( ) () + 1 |= . since prime
implicate, must |= hence . Thus, every prime implicate
equivalent clause built finite set propositional symbols
depth () + 1. finitely many non-equivalent formulae
finite alphabet fixed depth, follows finitely many
distinct prime implicates. Lemma 9.1, every prime implicant equivalent
negation prime implicate . follows every formula
finitely many distinct prime implicants.
Lemma 9.4 notions prime implicates prime implicants induced D4 satisfy
Covering.
Proof. Let arbitrary formula. Lemma 9.2, know every implicate
entailed implicate whose propositional variables contained var()
whose depth () + 1. consider following set
= { | |= , clause, var() var(), () () + 1}
define another set follows:
= { | 6 . |= 6|= }
words, set logically strongest implicates depth
() + 1 built propositional letters . claim following:
(1) every prime implicate
(2) every implicate , |=
begin proving (1). Suppose (1) hold, is,
prime implicate . Since definition implicate , follows
must implicate |= 6|= . Lemma 9.2,
implicate ( ) () + 1, var( ) var(), |= .
means element implies implied , contradicting
assumption . thus conclude every element must
prime implicate .
107

fiBienvenu

(2): let implicate . Lemma 9.2, exists clause
|= . , done. Otherwise, must exist
|= 6|= . , done, otherwise, find another stronger
member . finitely many elements modulo equivalence, finite number
steps, find element implies . Since
seen members prime implicates , follows every implicate
implied prime implicate .
second part Covering, let implicant , let clause
equivalent (there must one D4 satisfies P4). since |= , must
|= . According shown, must prime
implicate |= |= . Lemma 9.1, must equivalent
negation prime implicant . since |= ,
follows |= , completing proof.
Lemma 9.5 notions prime implicates prime implicants induced D4 satisfy
Equivalence.
Proof. Let formula K, suppose model every prime implicate
. D4 known satisfy property P5 (by Theorem 6), find conjunction
clauses equivalent . Covering (Lemma 9.3), clauses implied
prime implicate , must model clauses. follows
model . direction, simply note definition
prime implicates model , must model every prime implicate
. thus shown model model every prime
implicate . Using similar argument, show model
model prime implicant .
Lemma 9.6 notions prime implicates prime implicants induced D4 satisfy
Distribution.
Proof. Let prime implicate 1 ... n . , must |= .
Covering, know must exist prime implicate
|= . means formula 1 ... n (which clause
disjunction clauses) entails . since prime implicate, must case
|= 1 ... n , hence 1 ... n . proof prime implicants entirely
similar.
Theorem 9 notions prime implicates prime implicants induced definition
D4 satisfy Finiteness, Covering, Equivalence, Implicant-Implicate Duality,
Distribution.
Proof. Follows directly Lemmas 9.1-9.6.
Theorem 10 notions prime implicates prime implicants induced definitions
D1 D2 satisfy Equivalence.
108

fiPrime Implicates Prime Implicants Modal Logic

Proof. proof definitions. Suppose Equivalence holds.
every formula , set prime implicates equivalent . means
set {} inconsistent, hence compactness K (cf. Blackburn et al.,
2001, p. 86) finite subset {} inconsistent. 6 ,
know set must contain set prime implicates
cannot inconsistent. conjunction elements \ {} conjunction
clauses equivalent . follows every formula equivalent
conjunction clauses. shown earlier proof Theorem 5
formulae equivalent conjunction clauses respect D1 D2,
follows Equivalence cannot hold definitions.
Theorem 11 notions prime implicates prime implicants induced definitions
D3a, D3b, D5 satisfy Finiteness.
Proof. Suppose clauses defined respect definition D3a, D3b, D5 (the
proof three definitions). Consider formula = 2(a b). follows
Theorem 3 implies k = 2(3k a) 3(a b 2k a) every k 1.
formulae k clauses (with respect D3a, D3b, D5), k implicates
. complete proof, show every k prime implicate . Since k
mutually non-equivalent (because 2p 6|= 2q whenever p 6= q), follows
infinitely many prime implicates modulo equivalence.
Consider k implicate = 31 ... 3m 21 ... 2n
implies (by Theorem 2 cannot propositional literals ). Using Theorem 3
fact |= |= k , get following:
(a) b |= ...
(b) |= (3k a) (a b 2k a) every
(c) 1 ... |= b 2k
Let b |= ... . remark must satisfiable since
otherwise combine (a) (c) get b |= b 2k a. (b), know
|= (3k a) (a b 2k a) hence (2k a) (a b 3ka) inconsistent.
follows (2k a) (2k a) b inconsistent. Using Theorem 1,
find either |= 3k |= b. satisfiable clause respect
definitions D3a, D3b, D5, cannot imply b, must |= 3k a.
putting (a) (c) together, find
b |= 1 ... |= b 2k
follows |= 2k a, i.e. 3k |= . thus 3k 1 ...
b 2k a. 3k |= b 2k |= 1 ... , Theorem 3 get
2(3k a) 3(a b 2k a) |= 2i 3i ... 3m |= hence k . thus
shown implicate implies k must equivalent k . means
k prime implicate , completing proof.
109

fiBienvenu

Lemmas 12, 13, 14 follow easily known properties disjunctive normal
form transformation propositional logic (cf. Bienvenu, 2009, ch. 2).
proof Theorem 16, make use following lemmas:
Lemma 16.1 algorithm GenPI always terminates.
Proof. know Lemma 12 algorithm Dnf -4 always terminates returns
finite set formulae. means finitely many terms consider.
, set (T ) contains finitely many elements (this immediate given
definition (T )), means set Candidates finite cardinality.
final step, compare pair elements Candidates.
comparison always terminates, finitely many pairs check, follows
algorithm GenPI terminates.
Lemma 16.2 algorithm GenPI outputs exactly set prime implicates input
formula.
Proof. first prove every prime implicate satisfiable term equivalent
element (T ). Let = 1 ... k 31 ... 3m 21 ... 2n
satisfiable term, let = 1 ... p 31 ... 3q 21 ... 2r one
prime implicates. restrict attention interesting case
non-tautologous. |= , must case
1 ... k 31 ... 3m 21 ... 2n
1 ... p 21 ... 2q 31 ... 3r
unsatisfiable. Theorem 1, one following must hold:
(a) exists u v u v
(b) exists u u 1 ... n |= 1 ... q
(c) exists u 1 ... n |= u 1 ... q
(a) holds, u |= , must equivalent u else would found
stronger implicate, contradicting assumption prime implicate .
result holds since u (T ). (b) holds, formula 3(u 1 ... n )
implicate implies , 3(u 1 ... n ). done since
3(u 1 ... r ) member (T ). Finally consider case (c) holds.
case, 2(1 ... n ) implicate implies , equivalent (as
prime implicate). desired result since 2(1 ... n ) one
elements (T ). Thus conclude every prime implicate term
equivalent element (T ). Lemma 13, elements Dnf -4() terms,
disjunction equivalent . D4 satisfies Distribution, follows every
prime implicate input equivalent element Candidates. means
element Candidates prime implicate , prime
implicate implies implied , hence j Candidates
j |= 6|= j . Thus, comparison phase, clause
removed Candidates. suppose clause prime implicate .
110

fiPrime Implicates Prime Implicants Modal Logic

know must Candidates , moreover,
choose j j < j |= . final step
compare clauses j j 6= i, never find j |= j < i,
j |= 6|= j j > i, otherwise would prime implicate. follows
remains set Candidates returned algorithm.
thus shown set formulae output GenPI input precisely set
prime implicates .
Theorem 16 algorithm GenPI always terminates outputs exactly set prime
implicates input formula.
Proof. Follows directly Lemmas 16.1 16.2.
Theorem 17 length smallest clausal representation prime implicate
formula single exponential length formula.
Proof. Prime implicates generated GenPI 2|| disjuncts
2|| terms Dnf -4() Lemma 14. Moreover, disjunct length
2|| (also Lemma 14). gives us total 2|| 2|| symbols, must
add 2|| 1 disjunction symbols connecting disjuncts. thus find
length smallest representation prime implicate formula
2|| 2|| + (2|| 1).
Theorem 18 length smallest clausal representation prime implicate
formula exponential length formula.
Proof. Consider formula
=

n
^

(2ai,1 2ai,2 )

i=1

clause
=

_

(j1 ,...,jn

2(a1,j1 a2,j2 ... an,jn )

){1,2}n

ak,l 6= am,p whenever k 6= l 6= p. difficult see
equivalent, means must prime implicate . remains
shown clause equivalent must length least ||. yields result
since clearly size exponential n, whereas length linear n.
Let shortest clause equivalent . equivalent , follows
Theorem 2 disjunction 2-literals inconsistent 3-literals.
since assumed shortest representation , cannot contain inconsistent
3-literals redundant 2-literals, since could remove find equivalent
shorter clause. must form 21 ... 2m , l 6|= k whenever l 6= k.
since |= , every disjunct 2p must imply . disjunction 2-literals,
follows Theorem 3 every disjunct 2p implies disjunct 2q .
means every 2p must length least 2n + 1, since p satisfiable
formula implies conjunction n distinct propositional variables. know
every disjunct 2q implies disjunct 2p since |= . wish
111

fiBienvenu

show two disjuncts imply disjunct . Suppose
case, is, distinct disjuncts 21 22 disjunct 2p
21 |= 2p 22 |= 2p . since 21 22 distinct disjuncts,
must 21 |= ai,1 22 |= ai,2 21 |= ai,2 22 |= ai,1 .
know 2p |= 2q q , every q implies either ai1 ai2 , either
2p |= 2ai1 2p |= 2ai2 . know 2q imply either 2ai,1 2ai,2
both, one 21 22 must imply 2p . contradicts earlier
assumption 21 |= 2p 22 |= 2p , disjunct must imply distinct
disjunct . thus demonstrated contains many disjuncts .
already shown disjuncts shorter disjuncts ,
follows | | ||, hence | | = ||. conclude every clause equivalent
length least ||, completing proof.
Theorem 19, prove following clause
_
=
2q1 ...qn c
(q1 ,...,qn){3,2}n

prime implicate (with respect D1 D2) formula


=

( 23(b0 b1 ) 22(b0 b1 ) )

n
^

( 2i 3bi 2i 2bi )

i=2



n1
^

2i+1 ( (bi1 bi ) 2bi ) 2n+1 ( (bn1 bn ) c )

i=1

moreover shorter way represent .
proof Theorem 19 makes use following lemmas.
Lemma 19.1 Let l1 ... lm D1-clause implies q1 ...qn a, qi {2, 3}
propositional variable. l1 ... lm q1 ...qn a.
Proof. proof, make use fact every D1-clause satisfiable.
straightforwardly shown structural induction. base case propositional
literals, clearly satisfiable. induction step, consider D1-clause
proper sub-clauses satisfiable. three possibilities: either
form 2 3 satisfiable D1-clause, disjunction 1 2
satisfiable D1-clauses 1 2 . three cases, find must satisfiable.
proof lemma induction n. n = 0, l1 ... lm |= a.
According Theorem 2, every disjunct l1 ... lm must either unsatisfiable
formula. shown previous paragraph every D1-clause satisfiable,
l1 ... lm a.
suppose result holds whenever n k, suppose l1 ... lm |=
q1 ...qk+1 a. every li , must li |= q1 ...qk+1 a, hence |= li q1 ...qk+1 a. Using
Theorem 1, arrive following four possibilities:
112

fiPrime Implicates Prime Implicants Modal Logic

(a) |= q1 ...qk+1
(b) li
(c) q1 = 3 li 3li li |= q2 ...qk+1
(d) q1 = 2 li 2li li |= q2 ...qk+1
eliminate case (a) since 6|= q1 ...qk+1 every string modalities q1 ...qk+1 .
eliminate (b) since li must satisfiable D1-clauses. remark
(c) holds, according induction hypothesis, li 3q2 ...qk+1 a. Similarly,
(d) holds, li 2q2 ...qk+1 a. follows li equivalent q1 ...qk+1 a,
l1 ... lm q1 ...qk+1 a.
V
n , let = 2q (b b ) ( n
k
Lemma
19.2
Fix
(q
,
...,
q
)

{2,
3}
1
n
1
0
1
k=2 2 qk bk )
Vn1 k+1
( (bk1 bk ) 2bk ) 2n+1 ( (bn1 bn ) c ). |= 2r1 ...rn c
k=1 2
rk = qk 1 k n.
Proof. begin showing 1 n 1 formula
bi1 bi (

n
^

n1
^

2ki1 qk bk ) (

k=i+1

2ki ((bk1 bk ) 2 bk ) ) 2ni ((bn1 bn ) c)

k=i

entails formula ri+1 ...rn c case qi+1 ...qn = ri+1 ...rn .
proof induction i. base case = n 1.
bn2 bn1 qn bn ((bn2 bn1 ) 2bn1 ) 2((bn1 bn ) c) |= rn c

(1)


bn2 bn1 qn bn 2bn1 2((bn1 bn ) c) |= rn c
(Theorem 1) either
qn = 3 rn = 2 bn1 ((bn1 bn ) c) |= c

qn = rn bn1 bn ((bn1 bn ) c) |= c
bn1 ((bn1 bn ) c) 6|= c, cannot first alternative. follows
Equation (1) holds, second alternative must hold, case get qn = rn ,
desired. direction, simply note bn1 bn ((bn1 bn ) c) |= c
valid entailment, means qn = rn implies Equation (1).
Next let us suppose statement holds 1 < j n 1, let us
prove statement holds = j 1.
bj2 bj1 (

n
^

kj

2

qk bk ) (

k=j

n1
^

2kj+1 (bk1 bk 2bk ) )

k=j1

2nj+1 ((bn1 bn ) c)

|= rj ...rn c
113

(2)

fiBienvenu

one following holds:
(a) qj = 3 rj = 2
bj1 (

n
^

n1
^

2kj1 qk bk ) (

k=j+1

2kj ((bk1 bk ) 2bk ) ) 2nj ((bn1 bn ) c)

k=j

|= rj+1 ...rn c

(b) qj = rj
bj1 bj (

n
^

n1
^

2kj1 qk bk ) (

k=j+1

2kj ((bk1 bk ) 2bk )) 2nj ((bn1 bn ) c)

k=j

|= rj+1 ...rn c

first show entailment (a) hold. Consider model =
hW, R, vi defined follows:
W = {wj , ..., wn }
R = {(wj , wj+1 ), ..., (wn1 , wn )}
v(c, w) = f alse w W
w 6= wj : v(bk , w) = true w = wk
v(bk , wj ) = true k = j 1
Notice since world (excepting wn ) exactly one successor, 2- 3quantifiers behaviour (except wn ). easily verified M, wj
satisfies left-hand side aboveV
entailment tuple qj+1 ...qn : M, wj |=
bj1 definition, M, wj |= nk=j+1 2kj1 qk bk M, wk |= bk k 6= j,
Vn1 kj
M, wj |= k=j
2 ((bk1 bk ) 2bk ) ) since M, wj 6|= bj M, wk 6|= bk1
k 6= j, finally M, wj |= 2nj ((bn1 bn ) c) since wn 6|= bn1 . However,
right-hand side rj+1 ...rn c satisfied wj : world accessible wj n j
steps wn satisfy c.
shown case (a) cannot hold, means Equation (2) holds
(b) does. apply induction hypothesis entailment (b),
find holds case qj+1 ...qn = rj+1 ...rn . follows Equation (2)
qj ...qn = rj ...rn , desired. completes proof statement.
proceed proof lemma. Theorem 1,
2q1 (b0 b1 ) (

n
^

n1
^

2k qk bk ) (

k=2

2k+1 ( (bk1 bk ) 2bk ) 2n+1 ( (bn1 bn ) c )

k=1

|= 2r1 ...rn c

holds case
q1 (b0 b1 ) (

n
^

k=2

2k1 qk bk )

n1
^

2k ( (bk1 bk ) 2bk ) 2n ( (bn1 bn ) c )

k=1

|= r1 ...rn c
114

fiPrime Implicates Prime Implicants Modal Logic

turn holds one following statements holds:
(i) q1 = 3 r1 = 2
(

n
^

n1
^

2k2 qk bk ) (

k=2

2k1 ((bk1 bk ) 2bk ) ) 2n1 ((bn1 bn ) c) |= r2 ...rn c

k=1

(ii) q1 = r1
b0 b1 (

n
^

k=2

n1
^

2k2 qk bk ) (

2k1 ((bk1 bk ) 2bk ) ) 2n1 ((bn1 bn ) c)

k=1

|= r2 ...rn c

remark set j = 1 (a) above, left-hand side entailment (i)
logically weaker (a), right-hand side matches (a).
already shown entailment (a) hold, follows entailment
(i) cannot hold either. Thus, find desired entailment relation statement
lemma holds (ii) does. completes proof since already
shown induction entailment (ii) holds q2 ...qn = r2 ...rn ,
i.e. (ii) true case q1 ...qn = r1 = rn .
Lemma 19.3 D1-clause equivalent strictly smaller size .
Proof. Let D1-clause equivalent . Suppose furthermore
shortest clause. non-tautologous contains 2-literals disjuncts,
follows every disjunct must either unsatisfiable 2-literal (cf. Theorem 2).
D1-clauses always satisfiable (cf. proof Lemma 19.1), must contain
2-literals.
Since |= , every disjunct 2l must imply disjunct 2q1 ...qn c . Also,
every disjunct 2l must implied disjunct 2q1 ...qn c , since otherwise
could remove 2l preserving equivalence .
follows disjunct implied disjunct implies
disjunct . since disjuncts imply (because Lemma
19.1), follows disjunct equivalent disjunct , moreover
every disjunct equivalent disjunct .
completes proof since clear disjuncts 2q1 ...qn c cannot
compactly represented.
proof works equally well D2, since every D2-clause D1-clause.
Theorem 19 prime implicates defined using either D1 D2, length
smallest clausal representation prime implicate formula exponential
length formula.
Proof. begin definition D1. Let defined page 112. begin
distributing order transform equivalent disjunction D4-terms:
_

Tq1 ,...,qn
(q1 ,...,qn){2,3}n

115

fiBienvenu

Tq1 ,...,qn equal
2q1 (b0 b1 ) (

n
^

2 q bi )

n1
^

2i+1 ( (bi1 bi ) 2bi ) 2n+1 ( (bn1 bn ) c )

i=1

i=2

Lemma 19.2, Tq1 ,...,qn |= 2q1 ...qn c, hence Tq1 ,...,qn |= . thus |= .
show stronger clause respect D1 implied
. Let D1-clause |= |= . non-tautologous disjunction
2-literals, know Lemma 2 every disjunct must form 2l
l D1-clause l |= r1 ...rn c quantifier string r1 ...rn . according
Lemma 19.1, l |= r1 ...rn c, l equivalent r1 ...rn c. follows equivalent
clause disjuncts forms 2r1 ...rn c.
|= , must case terms Tq1 ,...,qn implies , equivalently
Tq1 ,...,qn |= . shown disjuncts 2-literals,
follows Theorem 1 term implies disjunct . Moreover, know
preceding paragraph disjuncts equivalent formula
form 2r1 ...rn c. Lemma 19.2, formula type implied
Tq1 ,...,qn formula 2q1 ...qn c. means every tuple quantifiers (q1 , ..., qn ),
disjunct equivalent 2q1 ...qn c. follows every disjunct
equivalent disjunct , giving us |= . thus conclude
prime implicate .
completes proof, since already shown Lemma 19.3
shorter D1-clause equivalent itself.
proof works definition D2 since every D2-clause D1-clause.
particular means D2-clause prime implicate respect D1
prime implicate respect D2, D2-clause shortest
among equivalent D1-clauses shortest among D2-clauses.
Theorem 20 number non-equivalent prime implicates formula double
exponential length formula.
Proof. know Theorem 16 every prime implicateWof equivalent
clause returned GenPI. Every clause form Dnf -4()
(T ). 2|| terms Dnf -4() Lemma 14, clauses
2|| disjuncts. Moreover, 2|| choices disjunct
since cardinality (T ) bounded size , know Lemma
||
1.3 2||. follows (2||)2 clauses returned
||
GenPI, hence (2||)2 non-equivalent prime implicates .
Theorem 21 number non-equivalent prime implicates formula may double
exponential length formula.
Proof. Let n natural number, let a11 , a12 , ..., an1 , an2 , b11 , b12 , b12 , ..., bn1 ,
bn2 4n distinct propositional variables. Consider formula defined
n
^

((3ai1 2bi1 ) (3ai2 2bi2 ))

i=1

116

fiPrime Implicates Prime Implicants Modal Logic

hard see 2n terms Dnf -4(), corresponding 2n ways
deciding {1, ..., n} whether take first second disjunct. term
Dnf -4() form
n
^

(3ai f (i,T ) 2bi f (i,T ) )

i=1

f (i, ) {1, 2} i. , denote D(T ) set formulae {3(a f (i,T )
b1 f (1,T ) ... bn f (n,T ) )) | 1 n}. consider set clauses C defined
{

_

dT | dT D(T )}

Dnf -4()
n

Notice n2 clauses C since clause corresponds choice one
n elements D(T ) 2n terms Dnf -4(). number double
exponential || since length linear n. order complete proof,
show (i) clauses C prime implicates (ii) clauses C
mutually non-equivalent.
begin showing 1 6|= 2 every pair distinct elements 1 2 C.
immediately gives us (ii) prove useful proof (i). Let 1 2
distinct clauses C. 1 2 distinct, must term Dnf -4()
1 2 choose different elements D(T ). Let d1 element
D(T ) appearing disjunct 1 , let d2 element D(T ) disjunct
2 , let aj,k a-literal appears d2 (and hence d1 ). Consider
formula = 2(aj,k b1,k1 ... bn,kn ), tuple (k1 , ..., kn ) tuple
associated except 1s 2s inversed. Clearly d1 consistent,
since variables appear d1 . inconsistent every disjunct
2 , since construction every disjunct 2 contains literal whose negation appears
. follows 2 |= 1 6|= , hence 1 6|= 2 .
prove (i). Let clause C, let prime implicate
implies . Theorem 16, know must equivalent one clauses output
GenPI, specifically clause output GenPI disjunction
3-literals (because Theorem 2). remark set C composed exactly
candidate clauses disjunctions 3-literals, must equivalent
clause C. shown element C implies itself.
follows , means prime implicate .
Theorem 22 prime implicates defined using either D1 D2, number
non-equivalent prime implicates formula may double exponential length
formula.
Proof. Let defined page 112. Set equal formula obtained
replacing c last conjunct c d. Set equal set clauses
obtained replacing zero occurrences c d. example, n = 1,
n
= {23c 22c, 23d 22c, 23c 22d, 23d 22d}. 22 elements
since choose 2n disjuncts whether change c d. intend
117

fiBienvenu

show clauses pairwise non-equivalent prime implicates .
proof every element indeed prime implicate (with respect D1
D2) proceeds quite similarly proof prime implicate (see proof
Theorem 19), repeat here. Instead show elements
pairwise non-equivalent. so, consider two distinct elements
. Since distinct, must string quantifiers q1 ...qn
disjunct 2q1 ...qn ( {c, d}) disjunct . |= ,
would 2q1 ...qn |= , hence 2q1 ...qn |= 2r1 ...rn disjunct r1 ...rn .
using Lemma 19.1, see happen r1 ...rn = q1 ...qn = ,
i.e. 2q1 ...qn disjunct . contradiction, must 6|= . follows
elements pairwise non-equivalent, hence possesses double
exponential number prime implicates.
Theorem 23 exists algorithm runs single-exponential space size
input incrementally outputs, without duplicates, set prime implicates
input formula.
Proof. Let sets Candidates function defined Figure 3.
assume ordered: = {T1 , ..., Tn }. Ti , let max denote
number elements (Ti ), assume ordering elements (Ti ):
(Ti ) = {i,1 , ..., i,max }. Notice tuples {1, .., max 1 } ... {1, ..., max n }
ordered using standard lexicographic ordering <lex : (a1 , ..., ) <lex (b1 , ..., bn )
1 j n aj < bj ak bk 1 k j 1.
set maxindex = ni=1 maxi , let f : {1, .., max 1 } ... {1, ..., max n } {1, ..., maxindex }
bijection defined follows: f (a1 , ..., ) = (a1 , ..., ) m-th
tuple lexicographic ordering {1, .., max 1 } ... {1, ..., max n }. denote
unique clause form 1,a1 ... n,an f (a1 , ..., ) = m. remark
given index {1, ..., maxindex } sets (T1 ), ..., (Tn ), possible
generate polynomial space (in size sets (T1 ), ..., (Tn )) clause .
make use fact modified version algorithm GenPI, defined follows:
Function IterGenPI()
(1) GenPI.
(2) GenPI.
(3) = 1 maxindex : j 6|= j < either j 6|= |= j
every < j maxindex , output .
proofs termination, correctness, completeness IterGenPI similar corresponding results GenPI (Theorem 16), omit details.
instead focus spatial complexity IterGenPI. first step IterGenPI
clearly runs single-exponential space ||, since deciding satisfiability takes
polynomial space ||, generating elements Dnf -4() takes
single-exponential space || (refer Lemma 14). Step 2 uses singleexponential space ||, since sets (T ) associated term Ti
polynomial size Ti . Finally, Step 3, use observation generation given index done polynomial space size sets
118

fiPrime Implicates Prime Implicants Modal Logic

(T1 ), ..., (Tn ), hence single-exponential space ||. sufficient since
comparisons Step 3, need keep two candidate clauses memory
one time, deciding whether one candidate clause entails another accomplished
single-exponential space (since clauses single-exponential size ||).
Theorem 24 Prime implicate recognition Pspace-hard.
Proof. reduction simple: formula unsatisfiable 3(a a)
prime implicate . suffices problem checking unsatisfiability formulae
K known Pspace-complete.
need following two lemmas Theorem 25:
Lemma 25.1 Let formula K, let = 1 ... k 31 ... 3m
21 ... 2n (j propositional literals) non-tautologous clause. Suppose furthermore
literal l \ {l}. (), 1 ... k
( ( \ {1 , ..., k })) 3(1 ... n ) ( ( \ {31 , ..., 3m })) every
i, 2(i 1 ... ) ( ( \ {2i })).
Proof. prove contrapositive: 1 ... k 6 ( ( \ {1 , ..., k }))
3(1 ... n ) 6 ( ( \ {31 , ..., 3m })) 2(i 1
... ) 6 ( ( \ {2i })), 6 (). consider case
|= 6|= immediately get 6 ().
Let us first suppose 1 ...k 6 ((\{1 , ..., k })). Since |= , must
(\{1 , ..., k }) |= 1 ...k , 1 ...k implicate (\{1 , ..., k }).
1 ... k known prime implicate ( \ {1 , ..., k }), follows
must clause ( \ {1 , ..., k }) |= |= 1 ... k 6|= .
consider clause = 31 ... 3m 21 ... 2n . know |= since
( \ {1 , ..., k }) |= , |= |= 1 ... k . 6|=
since must equivalent propositional clause (by Theorem 2) propositional
part (namely 1 ... k ) imply . follows |= |= 6|= ,
6 ().
Next suppose 3(1 ... n ) 6 ( ( \ {31 , ..., 3m })). 3(1 ... n )
must implicate ( \ {31 , ..., 3m }) since assumed |= .
3(1 ... n ) prime implicate ( \ {31 , ..., 3m }), follows
( \ {31 , ..., 3m }) |= |= 3(1 ... n ) 6|= . Let
= 1 ...k 21 ...2n . Theorem 2, know disjunction
3-literals, according Theorem 3 must 6|= since 3(1 ... n ) 6|= .
know |= since ( \ {31 , ..., 3m }) |= |= since
|= 3(1 ... n ). means |= |= 6|= , 6 ().
Finally consider case 2(i 1 ... ) 6
( ( \ {2i })). know |= hence ( \ {2i }) |= 2i .
Moreover, since ( \ {2i }) |= 3j j, ( \ {2i }) |= 2(i
1 ... ). Thus, 2(i 1 ... ) 6 ( ( \ {2i })), must mean
( \ {2i }) |= |= 2(i 1 ... ) 6|= .
assumption, tautology, 2(i 1 ... ) cannot tautology
119

fiBienvenu

either. |= 2(i 1 ... ) 2(i 1 ... ) tautology,
follows Theorem 2 equivalent formula 21 ... 2p . Let
= 1 ... k 31 ... 3m 21 ... 2i1 (21 ... 2p ) 2i+1 ... 2n .
( \ {2i }) |= 21 ... 2p , must case |= . Also, know
j |= j 1 ... otherwise would
1 ... |= j hence 2(i 1 ... ) |= 21 ... 2p . Similarly,
k 6= 2i |= 2(k 1 ... ) would mean
\ {2i }, contradicting assumption superfluous disjuncts
. follows Theorem 3 6|= . Thus, |= |= 6|= , means
6 ().
Lemma 25.2 Let formula K, let = 1 ...k 31 ...3m 21 ...2n
(j propositional literals) non-tautologous clause. Suppose furthermore
literal l \ {l}. 6 (), either 1 ... k 6 ( ( \
{1 , ..., k })) 3(1 ... ) 6 ( (1 ... k 2(1 1 ... ) ... 2(n
1 ... ))) 2(i 1 ... ) 6 ( ( \ {2i })) i.
Proof. consider case |= 6|= immediately
get result. Suppose 6 () |= . Definition 7, must
= 1 ...o 31 ... 3p 21 ... 2q |= |= 6|= . Since 6|= ,
Proposition 3 know either 1 ... k 6|= 1 ... 1 ... 6|= 1 ... p
6|= j 1 ... p j.
begin case 1 ... k 6|= 1 ... . |= , Theorem 3,
1 ...p |= 1 ...m every j |= 1 ...m j .
follows (also Theorem 3) |= |= 1 ...o 31 ...3m 21 ...2n ,
hence (\{1 , ..., k }) |= 1 ...o . 1 ...o |= 1 ...k 6|= 1 ...o ,
found implicate ( \ {1 , ..., k }) stronger 1 ... k ,
1 ... k 6 ( ( \ {1 , ..., k })).
Next suppose 1 ...m 6|= 1 ...p . |= , follows Theorem 3

1 ...o |= 1 ...k every j |= 1 ...m j .
thereby obtain |= |= 1 ... k 31 ... 3p 2(1 1 ... ) ...
2(n 1 ... ). this, infer (1 ... k 2(1 1 ...
) ... 2(n 1 ... )) |= 31 ... 3p |= 31 ... 3m 6|= 31 ... 3p .
31 ... 3m 3(1 ... ), follows 3(1 ... ) 6 ( (1 ...
k 2(1 1 ... ) ... 2(n 1 ... ))).
Finally suppose 6|= j 1 ... p j furthermore 1 ... |=

1 ... p (we already shown result holds 1 ... 6|= 1 ...
p ). 2(i 1 ... ) implicate ( \ {2i })) show
2(i 1 ... ) prime implicate ( \ {2i })), must find
stronger implicate. Consider set = {s {1, ..., q} : |= 1 ... 6|=
k 1 ...m k 6= i}. note must least one element
assumed 6|= \ {2i }. since 1 ... |= 1 ... k , 1 ... p |= 1 ... m,
... , |= S,
every 6 r 6= sW|= r 1 W

get |= W
|= 1 ...k 31 ...3m ( j6=i 2j )( W
sS 2s ). follows (\

{2i }) |= sS 2(s 1 ...m ), means sS 2(s 1 ...m )
120

fiPrime Implicates Prime Implicants Modal Logic

W
implicate (\{2i }). Moreover, sS 2(s 1 ...m ) |= 2(i 1 ...m )
since construction |= 1 ... every S.
W
remains shown 2(i 1 ... ) 6|= sS 2(s 1 ... ).
Suppose
contradiction contrary holds. 2(i 1 ... ) |=
W

sS 2(s 1 ... ), Theorem 1, must
1 ... |= 1 ... . |= 1 ... , thus
|= 1 ... p since assumed 1 ... |= 1 ... p . contradicts
earlier assumption W
6|= j 1 ... p j. Thus, shown
2(i 1 ... ) 6|= sS 2(s 1 ... ), 2(i 1 ... ) 6
( ( \ {2i })).
Theorem 25 Let formula K, let = 1 ...k 31 ...3n 21 ...2m
(j propositional literals) non-tautologous clause (a) 1 ... n
i, (b) literal l \ {l}. ()
following conditions hold:
1. 1 ... k ( ( \ {1 , ..., k }))
2. 2(i 1 ... n ) ( ( \ {2i })) every
3. 3(1 ... n ) ( ( \ {31 , ..., 3n }))
Proof. forward direction shown Lemma 25.1. direction follows
Lemma 25.2 together hypothesis 1 ... n (which
ensures (1 ... k 2(1 1 ... ) ... 2(n 1 ... ))
( \ {31 , ..., 3n })).
Theorem 26 Let formula K, let non-tautologous propositional clause
|= literal l \ {l}. ()
6|= \ {l} l .
Proof. Consider formula non-tautologous propositional clause |=
literal l \ {l}. Suppose |= \ {l}
l . know 6 \ {l}, follows \ {l} implicate
strictly stronger , prime implicate .
direction, suppose 6 (). must case clause
|= |= 6|= . Since |= , follows Theorem 2 literal
propositional literal inconsistent. literals inconsistent,
must inconsistent, clearly |= \ {l} every l . Otherwise,
equivalent propositional clause, specifically propositional clause
containing literals appearing (since |= ). strictly stronger ,
must literal l appear . means |= \ {l}
|= \ {l}, completing proof.
Theorem 27 Let formula K, let = 2 non-tautologous clause
|= . () exists term Dnf-4()
|= , conjunction formulae 2 .
121

fiBienvenu

Proof. Let formula, let = 2 non-tautologous clause |= .
first direction, suppose term Dnf -4() |= ,
conjunction formulae 2 . two cases: either
terms Dnf -4() unsatisfiable, terms none satisfy
condition. first case, 2 prime implicate , since contradictory
clause
W
(e.g. 3(a a)) stronger. second case, consider clause = 2T ,
conjunction formulae 2 . every must
W
2T |= 2, otherwise would 6|= 2, hence
W 6|= 2. Moreover, |= 2T
since |= 2T every . Theorem 1, 2 6|= 2T since 6|= .
|= |= 6|= , means prime implicate .
direction, suppose 2 prime implicate 6|= .

must |= 2 Dnf -4(),
W Dnf -4() non-empty. |= 2, W
2T implies 2. show
. let
W 2T primeWimplicate W
implicate implies 2T . since |= 2T 2T
non-tautologous, follows Theorem 2 21 ... 2n formulae .
|= , must |= 21 ... 2n W
Dnf -4().
Wbe
case 2T |= 21 ... 2n , W
means 2T |= 21 ... 2n . 2T
implies every implicate W
implies it, 2T must prime implicate .
means 2 6|= 2T , since assumed 2 prime implicate
. follows Theorem 1 6|= Dnf -4().
order show Theorem 28 need following lemmas:
Lemma 28.1 3 implicate prime implicate, algorithm
Test3PI returns input (3, ).
Proof. Suppose 3 prime implicate . unsatisfiable, must
satisfiable, return first step. satisfiable, since
assumed 3 implicate , must clause |= |= 3
3 6|= . |= 3, follows Theorem 2 equivalent disjunction
3-formulae, hence clause 3 .
know Lemma 13 equivalent disjunction terms Dnf -4().
must thus case Ti |= 3 Ti Dnf -4(). Since Ti satisfiable
conjunction propositional literals 2- 3-formulae, follows exists set
{3i , 2i,1 , ..., 2i,k(i) } conjuncts Ti 3(i i,1 ...i,k(i) ) |= 3 , otherwise
Ti would fail imply 3 . Moreover, elements {3i , 2i,1 , ..., 2i,k(i) } must
appear NNF outside modal operators, formulae , i,1 , ..., i,k(i) must
elements set X . immediate
3

_
(i i,1 ... i,k(i) ) |= 3 |= 3



3 6|= 3

_

(i i,1 ... i,k(i) )



122

(3)

fiPrime Implicates Prime Implicants Modal Logic

W
latter implies formula 3 (3 (i i,1 ... i,k(i) )) must consistent,
means
_
^
( (i i,1 ... i,k(i) )) (i i,1 ... i,k(i) )




must consistent well. itVmust case select
{i , i,1 , ..., i,k(i) } consistent. Let set . set
satisfies condition algorithm since:
SX
6|=

W



(because know

V



consistent)

Ti Dnf -4(), conjuncts 3i , 2i,1 , ..., 2i,k(i) Ti that:
{i , i,1 , ..., i,k(i) } 6= (since contains {i , i,1 , ..., i,k(i) })
3(i i,1 ... i,k(i) ) |= 3 (follows (3) above)
Since exists set X satisfying conditions, algorithm returns no.
Lemma 28.2 algorithm Test3PI returns input (3, ), 3
prime implicate .
Proof. Suppose Test3PI returns input (3, ). happens first
step, must case unsatisfiable 3 unsatisfiable, case 3
prime implicate . possibility algorithm returns Step 3,
means W
must X satisfying:
(a) 6|=
(b) Ti Dnf -4(), exist conjuncts 3i , 2i,1 , ..., 2i,k(i) Ti
that:
(i) {i , i,1 , ..., i,k(i) } 6=
(ii) 3(i i,1 ... i,k(i) ) |= 3
W
Let clause 3(i i,1 W
... i,k(i)
W ). remark Ti , Ti |=
3(i i,1 ...i,k(i) ), hence

|=


3(i i,1 ...i,k(i) ).
W
W definition
Dnf -4(), Ti . immediately follows |= 3(i i,1 ...i,k(i) )
hence W
|= . 2 (b) (ii), 3(i i,1 ... i,k(i) ) |= 3 every i,
hence 3(i i,1 ... i,k(i)) |= 3 yields |= 3. 2 (b) (i),
{i , i,1 , ..., i,k(i) } 6= hence every
W

W
i,1 ... i,k(i)W|= . infer 3(i i,1 ... i,k(i) ) |= W
3,
hence |= 3 . know 2 (a) Theorem 1 3 6|= 3 .
follows 3 6|= . Putting together, see exists clause
|= |= 3 3 6|= , hence 3 prime implicate .
Theorem 28 Let formula, let 3 implicate . algorithm
Test3PI returns yes input (3, ) 3 prime implicate .
123

fiBienvenu

Proof. clear Test3PI terminates since unsatisfiability testing NNF transformation always terminate, finitely many Ti . Lemmas 28.1
28.2 show us algorithm always gives correct response.
Theorem 29 algorithm Test3PI runs polynomial space.
Proof. remark sum lengths elements X bounded
length formula Nnf(), hence Lemma 14 sum theW lengths
elements particular X cannot exceed 2||. Testing whether 6|= thus
accomplished polynomial V
space length involves testing
satisfiability formula whose length clearly polynomial .
let us turn Step 3 (b). notice necessary keep Ti
memory once, since generate terms Ti one time using polynomial
space Lemma 12. Lemma 14, length Ti Dnf -4() 2||.
follows checking whether {i , i,1 , ..., i,k(i) } 6= , whether 3(i i,1 ...
i,k(i) ) |= 3 accomplished polynomial space length .
conclude algorithm Test3PI runs polynomial space.
order show Theorem 32, use following lemmas:
Lemma 32.1 clause prime implicate , TestPI outputs
input.
Proof. Let us begin considering formula clause prime
implicate . two possible reasons this: either implicate ,
implicate exists stronger implicate. first case, TestPI returns
Step 1, desired. focus case implicate
prime implicate. begin treating limit cases one
tautology contradiction. Given know non-prime implicate ,
two possible scenarios: either 6|= |= , |= 6|= . cases,
algorithm returns Step 2.
implicate , neither tautology contradiction,
algorithm continue Step 3. step, redundant literals deleted
, contains 3-literals, add extra disjunct 2-literals
satisfies syntactic requirements Theorem 25. Let 1 ...k 31 ... 3m 21
... 2n clause end Step 3 modifications made.
transformations Step 3 equivalence-preserving (Theorem 1), modified
equivalent original, still non-tautologous non-prime implicate .
means satisfy conditions Theorem 25. follows one
following holds:
(a) 1 ... k 6 ( ( \ {1 , ..., k })
(b) 2(i 1 ... n ) 6 ( ( \ {2i }))
(c) 3(1 ... n ) 6 ( ( \ {31 , ..., 3n }))
124

fiPrime Implicates Prime Implicants Modal Logic

Suppose (a) holds. 1 ... k non-tautologous propositional clause implied
( \ {1 , ..., k }) contains redundant literals. means ( \
{1 , ..., k }) 1 ...k satisfy conditions Theorem 26. According theorem,
1 ... k 6 ( ( \ {1 , ..., k }), must j ( \
{1 , ..., k }) |= 1 ... j1 j+1 ... k . means |= \ {j }, algorithm
returns Step 4.
Suppose next (b) holds, let 2(i 1 ... n ) 6 (
( \ {2i })). Theorem 27, means Dnf -4()
2(i 1 ... n ) entails conjunction 2-formulae conjuncts . follows
algorithm returns Step 5.
Finally consider case
Step 6,
Wm neither (a) (b) holds (c)Wdoes.

call Test3PI(3( i=1 ), ( \ {31 , ..., 3m })). 3( i=1 ) prime
implicate (\{31 , ..., 3m })) shown Test3PI correct (Theorem
28), Test3PI return no, TestPI return well. covered
possible cases, conclude clause prime implicate ,
TestPI outputs no.
Lemma 32.2 TestPI outputs input (, ) clause,
prime implicate .
Proof. 5 different ways TestPI return (these occur Steps 1, 2, 4, 5,
6). Let us consider turn. first way algorithm return
Step 1 find 6|= . correct since cannot prime implicate
consequence . Step 2, return unsatisfiable not,
tautology not. correct since cases cannot prime
implicate since exist stronger implicates (any contradictory clause ,
non-tautologous implicate ). Step 3, may modify , resulting
formula equivalent original, prime implicate case
original clause was. Let 1 ...k 31 ... 3m 21 ... 2n clause end
Step 3. Step 4, return find propositional literal l
|= \{l}. since Step 3, removed redundant literals , sure
\ {l} strictly stronger . |= \ {l} |= 6|= \ {l},
means prime implicate . consider Step 5 TestPI. step,
return disjunct 2i term Dnf -4((\{2i }))
2(i 1 ... ) entails conjunction 2-literals . According Theorem 27,
means 2(i 1 ... ) prime implicate ( \ {2i }),
means prime implicate
W Theorem 25. . step, return
Test3PI returns input (3( ki=1 ), ( \ {31 , ..., 3m })). Theorem 28,
W
know happens case 3( ki=1 ) prime implicate
( \ {31 , ..., 3m }). follows Theorem 25 prime implicate
.
Theorem 32 algorithm TestPI always terminates, returns yes input (,
) prime implicate .
125

fiBienvenu

Proof. algorithm TestPI clearly terminates Steps 1 5 involve finite number
syntactic operations finite number entailment checks. Moreover, call
Test3PI Step 6 known terminate (Theorem 28). Correctness completeness
already shown Lemmas 32.1 32.2.
make use following lemma proof Theorem 34:
Lemma 34.1 algorithm TestPI provided Figure 5 runs polynomial space
length input.
Proof. clear steps 1 5 carried polynomial space length
input, since simply involve testing satisfiability formulae whose lengths
polynomial ||+||. Step 6
W carried polynomial space since Theorem
29 deciding whether formula 3(W
i=1 ) prime implicate ( \ {1 , ..., }))
takes polynomial space |3(
i=1 )| + | ( \ {31 , ..., 3m }))|, hence
|| + ||. thus conclude algorithm TestPI runs polynomial space
length input.
Theorem 34 Prime implicate recognition Pspace.
Proof. show Theorem 32 TestPI always terminates returns yes whenever clause prime implicate otherwise. means TestPI decision
procedure prime implicate recognition. Since algorithm shown run
polynomial space (Lemma 34.1), conclude prime implicate recognition
Pspace.
Corollary 35 Prime implicate recognition Pspace-complete.
Proof. Follows directly Theorems 24 34.

References
Adjiman, P., Chatalic, P., Goasdoue, F., Rousset, M.-C., & Simon, L. (2006). Distributed
reasoning peer-to-peer setting: Application semantic web. Journal
Artificial Intelligence Research, 25, 269314.
Baader, F., McGuiness, D. L., Nardi, D., & Patel-Schneider, P. (Eds.). (2003). Description Logic Handbook. Cambridge University Press.
Bienvenu, M. (2007). Prime implicates prime implicants modal logic. Proceedings
Twenty-Second Conference Artificial Intelligence (AAAI07), pp. 397384.
Bienvenu, M. (2008). Prime implicate normal form ALC concepts. Proceedings
Twenty-Third Conference Artificial Intelligence (AAAI08), pp. 412417.
Bienvenu, M. (2009). Consequence Finding Modal Logic. Ph.D. thesis, Universite de
Toulouse.
Bittencourt, G. (2007). Combining syntax semantics prime form representation. Journal Logic Computation, 18 (1), 1333.
126

fiPrime Implicates Prime Implicants Modal Logic

Blackburn, P., de Rijke, M., & Venema, Y. (2001). Modal logic. Cambridge University
Press.
Blackburn, P., van Benthem, J., & Wolter, F. (Eds.). (2006). Handbook Modal Logic.
Elsevier.
Brandt, S., & Turhan, A. (2002). approach optimized approximation. Proceedings
KI-2002 Workshop Applications Description Logics (KIDLWS01).
Cadoli, M., & Donini, F. M. (1997). survey knowledge compilation. AI Communications, 10 (3-4), 137150.
Cialdea Mayer, M., & Pirri, F. (1995). Propositional abduction modal logic. Logic
Journal IGPL, 3 (6), 907919.
Darwiche, A., & Marquis, P. (2002). knowledge compilation map. Journal Artificial
Intelligence Research, 17, 229264.
de Kleer, J., Mackworth, A. K., & Reiter, R. (1992). Characterizing diagnoses systems.
Artificial Intelligence, 56, 197222.
Donini, F. M. (2003). Description Logic Handbook, chap. Complexity Reasoning.
Cambridge University Press.
Donini, F. M., Lenzerini, M., Nardi, D., Hollunder, B., Nutt, W., & Marchetti Spaccamela,
A. (1992). complexity existential qualification concept languages. Artificial
Intelligence, 53, 309327.
Eiter, T., & Makino, K. (2002). computing abductive explanations. Proceedings
Eighteenth National Conference Artificial Intelligence (AAAI02), pp. 6267.
Enjalbert, P., & Farinas del Cerro, L. (1989). Modal resolution clausal form. Theoretical
Computer Science, 65 (1), 133.
Garey, M. R., & Johnson, D. S. (1979). Computers intractability. guide theory
NP-completeness. W. H. Freeman.
Ghilardi, S., Lutz, C., & Wolter, F. (2006). damage ontology? case conservative extensions description logics. Proceedings Tenth International
Conference Principles Knowledge Representation Reasoning (KR06), pp.
187197.
Giunchiglia, F., & Sebastiani, R. (1996). SAT-based decision procedure ALC.
Proceedings Fifth International Conference Principles Knowledge Representation Reasoning (KR96), pp. 304314.
Kusters, R., & Molitor, R. (2002). Approximating specific concepts logics
existential restrictions. AI Communications, 15 (1), 4759.
Ladner, R. (1977). computational complexity provability systems modal propositional logic. SIAM Journal Computing, 6 (3), 467480.
Lakemeyer, G. (1995). logical account relevance. Proceedings Fourteenth
International Joint Conference Artificial Intelligence (IJCAI95), pp. 853861.
127

fiBienvenu

Lang, J., Liberatore, P., & Marquis, P. (2003). Propositional independence: Formulavariable independence forgetting. Journal Artificial Intelligence Research, 18,
391443.
Marquis, P. (1991a). Contribution letude des methodes de construction dhypotheses en
intelligence artificielle. french, Universite de Nancy I.
Marquis, P. (1991b). Extending abduction propositional first-order logic. Proceedings Fundamentals Artificial Intelligence Research Workshop, pp. 141155.
Marquis, P. (2000). Handbook Defeasible Reasoning Uncertainty Management Systems, Vol. 5, chap. Consequence Finding Algorithms, pp. 41145. Kluwer.
Pagnucco, M. (2006). Knowledge compilation belief change. Proceedings
Nineteenth Australian Conference Artificial Intelligence (AI06), pp. 9099.
Papadimitriou, C. (1994). Computational Complexity. Addison Welsey.
Przymusinski, T. (1989). algorithm compute circumscription. Artificial Intelligence,
38 (1), 4973.
Ramesh, A., & Murray, N. (1994). Computing prime implicants/implicates regular logics.
Proceedings Twenty-Fourth IEEE International Symposium MultipleValued Logic, pp. 115123.
Schild, K. (1991). correspondence theory terminological logics: Preliminary report.
Proceedings Twelth International Joint Conference Artificial Intelligence
(IJCAI91), pp. 466471.
Younger, D. H. (1967). Recognition parsing context-free languages time n3 .
Information Control, 10 (2), 189208.

128


