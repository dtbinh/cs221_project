Journal Artificial Intelligence Research 36 (2009) 415-469

Submitted 03/09; published 12/09

Friends Foes? Planning Satisfiability
Abstract CNF Encodings
Carmel Domshlak

dcarmel@ie.technion.ac.il

Technion Israel Institute Technology,
Haifa, Israel

Jorg Hoffmann

joerg.hoffmann@inria.fr

INRIA,
Nancy, France

Ashish Sabharwal

sabhar@cs.cornell.edu

Cornell University,
Ithaca, NY, USA

Abstract
Planning satisfiability, implemented in, instance, SATPLAN tool,
highly competitive method finding parallel step-optimal plans. bottleneck
approach prove absence plans certain length. Specifically, optimal plan
n steps, typically costly prove plan length n1.
pursue idea leading proof within solution length preserving abstractions (overapproximations) original planning task. promising abstraction
may much smaller state space; related methods highly successful model
checking. particular, design novel abstraction technique based one can,
several widely used planning benchmarks, construct abstractions exponentially
smaller state spaces preserving length optimal plan.
Surprisingly, idea turns appear quite hopeless context planning
satisfiability. Evaluating idea empirically, run experiments almost benchmarks
international planning competitions IPC 2004, find even hand-made
abstractions tend improve performance SATPLAN. Exploring findings
theoretical point view, identify interesting phenomenon may cause
behavior. compare various planning-graph based CNF encodings original
planning task CNF encodings abstracted planning task. prove that,
many cases, shortest resolution refutation never shorter .
suggests fundamental weakness approach, motivates investigation
interplay declarative transition-systems, over-approximating abstractions,
SAT encodings.

1. Introduction
areas model checking AI planning well-known closely related
develop tools automatic behavior analysis large-scale, declaratively specified transition systems. particular, planning model checking safety
propertieschecking reachability non-temporal formulasproblems given description transition system, initial system state, target condition.
solution problem corresponds legal path transitions bringing system
initial state state satisfying target condition.
c
2009
AI Access Foundation. rights reserved.

fiDomshlak, Hoffmann, & Sabharwal

model checking problem, solution corresponds error path system,
is, unwanted system behavior. Proving absence error paths ultimate
goal system verification, thus traditional focus field exactly that.
Besides clever symbolic representations state space, key technique accomplish
ambitious task abstraction. System abstraction corresponds over-approximation
considered transition system, thus abstraction preserves transitions
original system. Hence, abstract transition system contain solution,
neither original system. key success model checking that, many cases,
one prove absence solutions rather coarse abstractions comparatively
small state space. Techniques kind explored depth long time.
Arguably wide-spread instance model checking predicate abstraction (Graf
& Sadi, 1997), system states form equivalence classes defined terms truth
values number expressions (the predicates), linear expressions integer
system variables. Predicates learned analyzing spurious error paths too-coarse
abstractions (Clarke, Grumberg, Jha, Lu, & Veith, 2003). Methods kind
extremely successful verification temporal safety properties (e.g., Ball, Majumdar,
Millstein, & Rajamani, 2001; Chaki, Clarke, Groce, Jha, & Veith, 2003; Henzinger, Jhala,
Majumdar, & McMillan, 2004).
contrast system verification, focus AI planning finding solutions
instances assumed solvable. particular, optimizing planning, task
find solution optimizes certain criterion (the focus analysis
here) sequential/parallel length solution path. Unlike general planning
solution good enough, main bottleneck length-optimizing planning always
prove absence solutions certain length. particular, optimal plan
n steps, hardest bit typically prove plan length n 1.
Note plan actually proved optimal, length-optimizing
planner avoid constructing proof, matter computational techniques
based on.
agenda research apply idea model checking lengthoptimizing planning. lead optimality proofnon-existence plan length n1
within abstraction. particular, focus interplay abstraction
proving optimality parallel step-optimal planning satisfiability. approach
originally proposed Kautz Selman (1992), later developed SATPLAN tool
(Kautz & Selman, 1999; Kautz, 2004; Kautz, Selman, & Hoffmann, 2006). SATPLAN
performs iteration satisfiability tests CNF formulas b encoding existence
parallel plan length b, b starts 0 increased incrementally.
n first satisfiable formula, n equals length optimal parallel plan,
hence SATPLAN parallel optimal, step-optimal, planner. class planners,
SATPLAN highly competitive. particular, SATPLAN 1st prizes optimal
planners International Planning Competition (IPC), namely IPC 2004 (Kautz,
2004; Hoffmann & Edelkamp, 2005) IPC 2006 (Kautz et al., 2006). One property
CNF encodings employed SATPLAN plays key role analysis later
based planning graph structure (Blum & Furst, 1995, 1997).
course, objective closely relates many approaches developed planning
computing lower bounds based over-approximations, (e.g., Haslum & Geffner, 2000;
416

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

Edelkamp, 2001; Haslum, Botea, Helmert, Bonet, & Koenig, 2007; Helmert, Haslum, &
Hoffmann, 2007; Katz & Domshlak, 2008; Bonet & Geffner, 2008). key difference,
however, focus exact lower bounds, is, attempt actually prove optimality
within abstraction. want able prove optimality within abstraction,
abstraction must term solution length preserving: abstraction must
introduce solutions shorter optimal solution original problem.
lower bound step-optimal planning exact, support
SATPLANs iteration n 1, constitutes main bottleneck.
follows, briefly explain initial motivation behind work,
summarize empirical theoretical results.
1.1 Initial Motivation
would course interesting explore whether predicate abstraction applied
planning. Indeed, initial idea. However, discussions
idea lead nowhere,1 instead made different discovery. Planning state spaces
often dramatically reduced, without introducing shorter solutions, based
abstraction technique call variable domain abstraction. technique essentially
adapts work Hernadvolgyi Holte (1999) propositional STRIPS formalism.
abstract STRIPS task distinguishing certain values multiplevalued variables underlying STRIPS encoding. is, p q propositions
corresponding non-distinguished values, abstracted STRIPS task acts p q
same. Note generalizes abstraction used Edelkamp (2001) which,
multi-valued variable, either abstracts away completely abstract
all; see details Section 2.
first example noticed compression power variable domain abstraction classical Logistics domain. domain, packages must transported within
cities using trucks cities using airplanes. Actions load/unload packages,
move vehicles. Importantly, constraints (either of) vehicle capacities, fuel,
travel links. consequence, package p starts city destination
city B, cities C 6= A,B completely irrelevant p. is, one choose
arbitrary location x city C, replace facts form at(p,l), l
location outside B, at(p,x). Also, in(p,t), truck outside B,
replaced at(p,x). One completely abstract away positions packages
destination, minor optimizations possible. way
lose many distinctions different positions objectswithout introducing shorter
solution! optimal plan rely storing package p city ps origin
destination. state space reduction dramatic: abstracted state space contains
least (((C 2) S) 1)P states less, C, S, P respectively number
cities, city size (number locations city), number packages. Similar
1. still skeptical prospects. Software artifacts (rigid control structure, numeric expressions
essential flow control) rather different nature planning problems (loose control
structure, numeric expressions non-existent mostly used encode resource consumption). example, major advantage predicate abstraction capture loop invariantsa great feature,
seemingly rather irrelevant plan generation.

417

fiDomshlak, Hoffmann, & Sabharwal

abstractions made, similar state space reductions obtained, IPC
domains Zenotravel, Blocksworld, Depots, Satellite, Rovers (see Section 3).
1.2 Summary Empirical Results
first experiment, implemented Logistics-specific abstraction abstracting set planning tasks level description, modifying actions
initial state. planning tasks feature 2 airplanes, 2 locations city,
6 packages. number cities scales 1 14. account variance
hardness individual instances, took average values 5 random instances
problem size. increasing number cities introduces increasing amount
irrelevance, measure percentage RelFrac facts considered relevant (not
abstracted). Note additional cities irrelevant individual packagesthey cant removed completely task standard irrelevance
detection mechanisms, e.g. RIFO (Nebel, Dimopoulos, & Koehler, 1997), would try do.
provided abstracted tasks three optimizing planners, namely Mips.BDD
(Edelkamp & Helmert, 1999), IPP (Hoffmann & Nebel, 2001), SATPLAN04,2 order examine abstraction affects different approaches optimizing planning.
Mips.BDD searches blindly exploiting sophisticated symbolic representation
state space. IPP equivalent parallel state-space heuristic search widely
used h2 heuristicthe parallel version h2 originally introduced Graphplan (Blum &
Furst, 1997; Haslum & Geffner, 2000). Thus, Mips.BDD, IPP, SATPLAN04 represent
orthogonal approaches optimizing planning.3 abstract task planner,
measured runtime, compared latter time taken planner
original task. Time-out set 1800 seconds, used value
average computation time-out occurred. stopped evaluating planner 2
time-outs within 5 instances one size.
Figure 1(a), (b), (c) respectively show results Mips.BDD, IPP, SATPLAN04. Comparing performance original abstracted tasks, apparent
Figure 1 proving optimality within abstraction dramatically improved
performance Mips.BDD, significantly improved performance IPP. right
end scale (with 14 cities), Mips.BDD using abstraction find optimal sequential
plans almost fast SATPLAN04 find step-optimal plans. Given usually
much harder find optimal sequential plans optimal parallel plans, especially highly
parallel domains Logistics, performance improvement quite remarkable. (In
addition reduced state space size, Mips.BDD benefits small state encoding,
stops growing point maximal number locations relevant
package constant.)
findings Mips.BDD IPP line original intuition and,
SATPLAN04 well, expected see much improved runtime behavior within
abstraction. surprise, not. appears Figure 1(c), improvement
obtained SATPLAN04 proving optimality within abstraction hardly dis2. SATPLAN04 version SATPLAN competed 2004 International Planning Competition.
3. Importantly, Mips.BDD sequentially optimal SATPLAN04 IPP step-optimal. Hence
one compare performance planners directly, particular
purpose here. focus planners reacts abstraction.

418

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

10000

100

Mips.BDD-abstract
Mips.BDD-real
RelFrac

10000

1000

80

100

IPP-abstract
IPP-real
RelFrac

90

90

1000

80

70
100

70

60

100

60

50
10

50

40

10

40

30
1

30

20

1

20

10
0.1

10

0
1

2

3

4

5

6

7

8

9

10

11

12

13

0.1

14

0
1

2

3

4

5

6

(a)

7

8

9

10

11

12

13

14

(b)
10000

100

SATPLAN-abstract
SATPLAN-real
RelFrac

90

1000

80
70

100

60
50

10

40
30

1

20
10

0.1

0
1

2

3

4

5

6

7

8

9

10

11

12

13

14

(c)

Figure 1: Runtime performance (a) MIPS, (b) IPP, (c) SATPLAN04, (abstract) without (real) hand-made variable domain abstraction,
Logistics instances explicitly scaled increase amount irrelevance. Horizontal axis scales number cities, left vertical axis shows total runtime
seconds, right vertical axis shows percentage RelFrac relevant facts.

cernible. right end scale, abstraction yields humble speed-up factor 2.8.
particularly insignificant since speed-up obtained drastically small
RelFrac value 24%in IPC 2000 Logistics benchmarks, RelFrac 42% average.
latter corresponds 6 cities Figure 1, SATPLAN04 slight advantage
original tasks.
investigate broadly, conducted experiments almost STRIPS
domains used international planning competitions (IPC) IPC 2004. many
cases, tailored abstraction domain hand. results exhaustive
evaluation (discussed detail Section 3) significantly depart
Logistics-specific abstraction above. Mips.BDD almost consistently obtained
significant improvement. IPP improvements happened rarely, typically
substantial. (While IPP improved Figure 1, note that, IPC419

fiDomshlak, Hoffmann, & Sabharwal

average RelFrac 42%, improvement yet strong.) Finally, SATPLAN04,
hardly ever obtained improvement.
causes difference profiting abstraction three different
planning techniques? intuitive interpretation results informedness
abstraction must compete informedness search itself. words,
better planner exploiting structure particular example, difficult
abstraction exploit structure already exploited. intuition
good correspondence Logistics results Figure 1: optimizing exactly
measure, original examples, SATPLAN04 faster IPP, inverse
relation holds regarding planner profits abstraction. said,
intuitive interpretations results are, point, mere speculation. left open
future research determine accurately precisely causes difference. Herein,
concentrate planning satisfiability, identify fundamental weakness
approach respect profiting abstraction.
1.3 Summary Theoretical Results
Intrigued results SATPLAN04,4 wondered kind effect abstraction
actually CNF encoding planning task formulated Boolean satisfiability
problem instance. Recall abstractions over-approximations, is,
action sequence applicable original task applicable abstract task,
plan original task plan abstract task. So, intuitively, abstract task
generous original task. mind, consider CNF formula
n1 encoding existence plan one step shorter optimal plan, consider
formula, n1 , generated abstract task. need prove n1
unsatisfiable. (Note n1 is, fact, unsatisfiable solution length preserving
abstraction.) Intuitively, constrained formula is, easier lead
proof. n1 generous, hence less constrained, n1 . mean
actually harder refute n1 refute n1 ?
abstraction methods, fact trivial see answer question
yes. Say abstract n1 ignoring clauses. n1 sub-formula
n1 , immediately implying resolution refutation n1 resolution
refutation n1 . particular, shortest possible refutation cannot shorter
n1 . similar situation sometimes occurs interplay abstractions CNF
encodings planning problems. instance, suppose abstract ignoring subset
goals. CNF encodings planning, particular planning-graph
based CNF encodings (Kautz & Selman, 1999) underlying SATPLAN, goal fact yields
one clause CNF. Hence, goal ignoring abstraction, n1 sub-formula
n1 , above.
complex example would correspond abstraction ignoring preconditions
delete effects. encodings used SATPLAN, one several clauses related
ignored precondition/delete effect disappear. However, CNF changes ways
because, one precondition/delete effect less, actions facts become possible
later time steps. Intuitively, additional actions facts help proving
4. Translation: Deeply frustrated results SATPLAN04, . . .

420

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

unsatisfiability n1 . formal proof intuitive statement, however, less obvious
one goal ignoring abstraction above. Matters complicated,
much less intuitive, Edelkamps (2001) abstraction variable domain abstraction,
changes made abstract task affect add effects actions. Recall
variable domain abstraction special interest likely satisfy
constraint solution length preservation.
investigate issues detail, one consider various possible combinations
CNF encodings abstraction methods. Many different encodings planning SAT
proposed. focus planning-graph based encodings used
SATPLAN system, appearances international planning competitions (Kautz & Selman, 1999; Long, Kautz, Selman, Bonet, Geffner, Koehler, Brenner,
Hoffmann, Rittinger, Anderson, Weld, Smith, & Fox, 2000; Kautz, 2004; Kautz et al., 2006).
Indeed, according Kautz Selman (Kautz & Selman, 1999; Long et al., 2000),
CNF encodingsin particular mutex relations computed Graphplanare vital
SATPLANs performance. recent results effective encodings may challenge
assessment (Rintanen, Heljanko, & Niemela, 2006; Chen, Huang, Xing, & Zhang, 2009;
Robinson, Gretton, Pham, & Sattar, 2008), even graphplan-based encodings
interest simply widely used almost decade. remains
course important question whether extent results carry alternative CNF encodings. discuss issue depth concluding paper
Section 5.
consider four different encodings, three used edition
IPC; fourth encoding considered sake completeness. encodings
differ two parameters: whether use action variables, action well fact
variables; whether include planning graph mutexes actions
direct interferences. (The latter motivated fact often enormous
amount action mutexes, seriously blowing size formula.)
abstractions side, focus abstraction methods formulated
manipulating planning tasks language level, i.e., modifying tasks actions and/or
initial/goal states. Many commonly used abstractions propositional STRIPS
formulated way. consider six abstractions, namely (1) removing goals, (2)
adding initial facts, (3) removing preconditions, (4) removing delete effects, (5) Edelkamps
(2001) abstraction (removing entire facts), (6) variable domain abstraction.
24 combinations CNF encoding abstraction method, prove
shortest possible resolution refutation exponentially longer n1 n1 .
20 combinations involving abstractions variable domain abstraction,
prove shortest possible resolution refutation cannot shorter n1
n1 . abstraction (1), trivial outlined above. abstractions (2)(4),
proof exploits fact abstractions lead larger planning graphs containing
actions facts. abstraction (5), reasoning work
facts disappear planning graph. However, one start removing fact
goal action preconditions; afterwards fact irrelevant one remove
initial state action effects.
Matters complicated abstraction (6), is, variable domain abstraction.
encoding action variables full mutexes, show that, before,
421

fiDomshlak, Hoffmann, & Sabharwal

shortest possible resolution refutation cannot shorter n1 n1 .
encoding action variables direct action mutexes, show
possible improvement bounded effort takes recover indirect
action mutexes. two encodings action fact variables, remains
open question whether bounds exist.5
Importantly, proofs valid general resolution, many
known restricted variants resolution, particular tree-like resolution refutations generated DPLL (Davis & Putnam, 1960; Davis, Logemann, & Loveland, 1962).
Naturally, proofs separate combinations, rather exploit
exhibit common features.
practical significance theoretical results is, extent, debatable
direct connection best-case resolution refutation size empirical
SAT solver performance. Even large refutation may easy find mostly
consists unit resolutions. Vice versa, small refutation exists,
mean SAT solver find it. notwithstanding, appears unlikely best-case
resolution refutation size practical SAT solver performance completely unrelated
(beyond obvious lower bound). One example indicates opposite planning
graph mutexes. Mutexes reduce best-case refutation size work
resolution even invoked.6 words, SAT solvers exploit mutexes
prune search trees effectively. aware explicit empirical proof
tends happen often, seems little doubt does.
suggested explicitly Kautz Selman (Kautz & Selman, 1999; Long et al., 2000)
ways explaining improved performacce system run graphplan-based
encodings.
interesting situation arises (all) experiments. use variable domain abstraction encoding action variables direct action mutexes (as
employed SATPLANs IPC04 version). setting, resolution refutations get
shorter principle, although effort takes recover indirect action mutexes. Further, employ trivial post-abstraction simplification methods (such
removing action duplicates) which, show, potential shorten resolution refutations. Still, reported above, discernible empirical improvement.
reason might SAT solver find shorter refutations,
shorter refutations actually appear significant scale. evidence
indicating latter: mutex recovery becomes necessary rather special situations,
abstraction turns indirect mutex direct one. typically concern small fraction indirect mutexes. addition, mutex recovery
simplifications, well-designed variable domain abstraction affected actions
typically irrelevant anyway. example, hand-made Logistics abstraction,
5. reason complications answering question requires determining, planning-graph
based encodings general, whether fact variables syntactic sugar may lead succinct
refutations. proof appears quite challenging; say Section 4.
6. General resolution recover mutexes effectively, c.f. related investigations Brafman (2001)
Rintanen (2008). seem likely case tree-like resolution,
best knowledge yet known.

422

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

effect potential improvements limited actions appearing redundant
plans. get back detail Section 4.
view, theoretical results would potential importance even
evidence empirical relevance, simply quite surprising. moment
thought, clear resolution refutation become easier ignoring goals.
However, variable domain abstraction domains Logistics deflates state spaces
immensely, point tiny fraction original size.
performing work, would never expected best-case refutation size remain
same.
paper organized follows. Section 2 discusses preliminaries, covering employed notions planning, planning graphs, propositional encodings, resolution, abstraction methods; particular, formally defines variable domain abstraction. Section 3
summarizes empirical results. Section 4 presents results regarding resolution refutations abstract CNF encodings. Related work discussed text appropriate. conclude Section 5. Appendix contains proofs, replaced
brief proof sketches main body text. Additional empirical data
found online appendix (see JAIR web page article).

2. Preliminaries
begin discussion various concepts needed rest paper: propositional
STRIPS planning, planning graphs, propositional CNF encodings planning problems,
resolution proofs unsatisfiability, abstraction methods used planning. general
rule notation, use variants of: P planning tasks; F, A, G sets facts,
actions, goals, respectively; abstractions; P G planning graphs;
propositional formulas encodings.
2.1 STRIPS Planning Graphs
Classical planning devoted goal reachability analysis state transition models deterministic actions complete information. model tuple = hS, s0 , SG , A,
finite set states, s0 initial state, SG set alternative
goal states, finite set actions, : transition function,
(s, a) specifying state obtained applying s. solution, plan,
state transition model sequence actions a1 , . . . , generate sequence
states s0 , . . . , sm that, 0 < m, (si , ai+1 ) = si+1 , sm SG .
AI planning targets large-scale state transition models huge numbers
states, models assumed described concise manner via intuitive
declarative language. use propositional fragment STRIPS language (Fikes
& Nilsson, 1971). brevity, refer fragment STRIPS herein. Informally,
planning task planning instance STRIPS consists set propositional facts,
hold initially must hold simultaneously end plan
execution. state system time defined set propositional facts
hold time. task specifies set actions, defined
set precondition facts, set facts added state, set facts
removed state, action taken. Formally, STRIPS planning task
423

fiDomshlak, Hoffmann, & Sabharwal

given quadruple P = (P, A, I, G) fact set P , initial state description P , goal
description G P , action set every action pre(a), add (a),
del (a), subset P . planning task defines state transition
model = hS, s0 , SG , A, state space = 2P , initial state s0 = I,
S, SG iff G s. S, A(s) = {a | pre(a) s}
actions applicable s, A(s), (s, a) = (s \ del (a)) add (a).
assume actions reasonable sense add (a) del (a) = .
satisfied known planning benchmarks; particular satisfied benchmarks
used experiments.7
Many planning algorithms, including SATPLAN, employ form approximate
reachability analysis. One primary tools purpose planning graph, first
introduced scope Graphplan planner (Blum & Furst, 1997). length bound
b, planning graph P G(P) associated P layered graph two kinds nodes:
fact nodes action nodes. layers alternate fact layers F (0), F (1), . . . , F (b),
action layers A(0), A(1), . . . , A(b 1), pair layers F (t), A(t) forming
time step t. first vertex layer F (0) contains initial state. A(t) F (t + 1)
0 < b action sets fact sets, respectively, available time step + 1.
precisely, A(t) includes actions pre(a) F (t) pair
facts p, p0 pre(a) mutex layer (c.f. below); further, A(t) contains standard noop
action every fact F (t).8 F (t + 1) contains union add effects
actions A(t). Obviously, A(t) A(t + 1) F (t) F (t + 1). goal facts G
label appropriate vertices F (b). P G(P) four kinds edges:
(1) Epre (t) F (t) A(t) connect actions A(t) preconditions F (t),
(2) Eadd (t) A(t) F (t + 1) connect actions A(t) add effects F (t + 1),
(3) Ea-mutex (t) A(t) A(t) capture pair-wise mutual exclusion relation actions A(t); (a(t), a0 (t)) Ea-mutex (t), actions a0 cannot applied
simultaneously time t,
(4) Ef -mutex (t) F (t) F (t) capture pair-wise mutual exclusion relation facts
F (t); (f (t), f 0 (t)) Ef -mutex (t), facts f f 0 cannot hold together time
t.
Note P G(P) explicit edges deletion effects actions;
effects captured mutual exclusion relation (e.g., p add (a1 ) del (a2 ),
(a1 , a2 ) Ea-mutex times). mutex edges Emutex = Ea-mutex Ef -mutex
computed iterative calculation interfering action fact pairs (Blum & Furst,
1997). Namely, two actions (directly) interfere effects one contradict effects
other, one deletes precondition other. Two actions competing
7. IPC-2002 domain Rovers, operators add delete artificial fact order prevent
parallel application. implement restriction via duplicating respective operators
sequentializing original duplicate via two artificial facts. Similar fixes implemented
couple domains well.
8. fact p P , associated noop(p) delete effects, {p} preconditions
add effects. dummy actions simply propagate facts one fact layer next.

424

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

needs mutex preconditions. Combining two scenarios together, say
two actions mutex either (directly) interfere competing needs.
similar spirit, two facts mutex non-mutex pair actions (in graph
layer directly below) together achieving facts. variant interest
planning graph which, iterative computation, Ea-mutex reduced contain
directly interfering actions. call reduced planning graph, denote
P Gred (P). motivation considering that, often, reduced planning
graph results much smaller SAT encodings; get back below.
2.2 Propositional Encodings
consider three CNF encodings used (one version of) SATPLAN, well
fourth encoding fits naturally picture. encodings takes input
planning task P length bound b, creates formula standard Conjunctive
Normal Form (CNF). CNF formula solved off-the-shelf SAT solver.
process constitutes basic step SAT-based approach planning implemented
SATPLAN (Kautz & Selman, 1992, 1996, 1999), one starts b = 0 iteratively
increments b CNF becomes satisfiable first time. plan corresponding
satisfying assignment plan minimal b, hence optimal
sense.9
CNF formula logically conjunction (and) clauses, clause disjunction (or) literals, literal propositional (Boolean) variable negation.
CNF formulas often written set clauses, clause written set literals, underlying logical conjunction disjunction, respectively, implicit.
propositional encodings bounded-length planning tasks specified terms various
kinds clauses generated encoding method.
Encoding (A) constructed P G(P) uses propositional action variables
{a(t) | 0 < b, A(t)}. goal fact g goal clause form
{a1 (b 1), . . . , al (b 1)}, a1 , . . . al actions A(b 1) add g.
Similarly, every a(t) > 0 every p pre(a) precondition clause
{a(t), a1 (t 1), . . . , al (t 1)}, a1 , . . . al actions A(t 1) add p.
Finally, mutex clause {a(t), a0 (t)} every (a, a0 ) Ea-mutex (t).
(Note dependence initial state taken account already
terms actions contained sets A(t), need stated
explicitly CNF.)
Encoding (B) similar (A) except uses variables (and appropriate clauses)
facts. specifically, addition action variables, fact
variables {f (t) | 0 b, f F (t)}. goal fact g, goal clause simply
unit clause asserting g(b). > 0 fact f (t), effect clause
form {f (t), a1 (t 1), . . . , al (t 1)}, a1 , . . . al actions A(t 1)
add f . every a(t) every p pre(a) precondition clause,
9. versions SATPLAN use naive incremental update b, shown
clever strategies, exploiting typical distribution runtime different values b (Rintanen,
2004; Streeter & Smith, 2007).

425

fiDomshlak, Hoffmann, & Sabharwal

takes form {a(t), p(t)}. action mutex clauses {a(t), a0 (t)} every
(a, a0 ) Ea-mutex (t), fact mutex clauses {f (t), f 0 (t)} every
(f, f 0 ) Ef -mutex (t). Finally, fact f F (0), initial state clause
{f (0)} (these strictly necessary implemented SATPLAN
include here).
Encoding (C) (A) except based reduced planning graph P Gred (P),
mutex clauses present action pairs whose preconditions effects
interfere directly.
Encoding (D) (B) except that, (C), based P Gred (P), mutex
clauses action pairs whose preconditions effects interfere directly. Note,
however, fact mutexes full planning graph, P G(P).
encodings reasonable ways turning planning graph CNF formula. encodings essentially underly competition implementations SATPLAN.
detail below. First, note different encodings different benefits
drawbacks. First, observe encodings characterized two decisions: (1)
include action mutexes Graphplan, direct interferences? (2)
include action variables, action fact variables? Regarding (1),
empirical observation mutexes help one major observations
design SATPLAN (then called Blackbox) (Kautz & Selman, 1999; Long et al., 2000),
particular comparison earlier encoding methods (Kautz, McAllester, & Selman, 1996).
hand, since mutexes talk pairs facts actions, encodings may
become quite largethere one clause every pair mutex actions mutex facts.
particularly critical actions, many planning benchmarks
thousands (compared hundred facts). Indeed, turns action mutexes often consume critically large amounts memory. uncommon CNF
formulas millions clauses, action mutexes (Kautz & Selman, 1999;
Kautz, 2004; Kautz et al., 2006). motivates encodings (C) (D). question
(2), make much difference, empirically, planning benchmarks.
consider distinction used versions SATPLAN.
Let us say words clarify exactly encodings (A)(D) relate SATPLAN
literature implementations. Due long history SATPLAN, well
imprecisions literature, little complicated. foremost reference
actual program code underlying SATPLAN04 SATPLAN06, i.e., recent
versions used 2004 2006 competitions. encoding methods versions
implemented one authors paper. four different encoding
methods: action-based, graphplan-based, skinny action-based, skinny graphplan-based.
action-based encoding exactly (A), graphplan-based encoding exactly (B),
skinny graphplan-based encoding exactly (D).10 skinny action-based encoding
(C) except that, save runtime, planning graph implementation
propagate mutexes (after all, direct interferences present final encoding),
effectively computing relaxed planning graph (Hoffmann & Nebel, 2001). use normal
10. 2004 version, skinny graphplan-based encoding feature fact mutexes.
consequence encoding used 2004 competition.

426

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

planning graph (C) sake readabilitythe greater similarity
encodings significantly simplifies write-up, theoretical results hold stated
relaxed planning graphs.
SATPLAN encodings develop historically, reflected literature, encodings used competitions? answer questions
extent necessary explaining encodings (A)(D). original paper SATPLAN
(Kautz & Selman, 1992) introduced rather different encodings. Graphplan-based encodings
direct action mutexes introduced next, observed yield performance
comparable Graphplan (Kautz & Selman, 1996). Subsequently, observed
modern SAT solvers profit full (fact action) mutex relations actually
beat planners, several domains (Kautz & Selman, 1999).11 Consequently,
graphlan-based encoding, i.e., encoding (B), used 1998 2000 competitions (Long et al., 2000). Prior 2004 competition, encoding methods
re-implemented, yielding four methods explained above. IPC04 booklet paper
SATPLAN04 (Kautz, 2004) describes four encodings.12 version run competition skinny action-based encoding (for theoretical results) equivalent
encoding (C). running planner IPC 2006, turned full
fact mutexes helped domains, encoding (D) used instead (Kautz et al.,
2006). consider encoding (A) sake completeness.
2.3 Resolution Refutations
theoretical results respect resolution proof system (Robinson, 1965),
forms basis complete SAT solvers around today (cf. Beame, Kautz,
& Sabharwal, 2004). sound complete proof system, studied extensively theoretical practical reasons. works CNF formulas one
simple rule inference: given clauses {A, x} {B, x}, one derive clause {A, B}
resolving upon variable x. B shorthands arbitrary lists literals.
Note choice clauses resolve arbitrary, long share variable,
opposite signs. resolution derivation clause C formula consists series
applications resolution rule starting clauses one eventually
derives C; C (unsatisfiable) empty clause, {}, called resolution proof
(of unsatisfiability) refutation . size number applications
resolution rule . unsatisfiable, RC() denotes resolution complexity ,
i.e., size smallest resolution proof unsatisfiability . interested
whether applying abstraction planning task convert encoding one
smaller resolution complexity.
commonly studied sub-class (still sound complete) resolution derivations
tree-like resolution derivations, derived clause used
whole derivation; underlying graph structure proof tree.
11. Kautz Selman (1999) cite graphplan-based encodings earlier work (which used action
mutexes). However, Blackbox program code includes functions generate full mutexes, Kautz
Selman explicitly emphasize importance mutexes.
12. paper abstract little imprecise description: initial state, goal, fact
mutex clauses mentioned; skinny action-based encoding stated identical
encoding (C), i.e., based full planning graph rather relaxed planning graph.

427

fiDomshlak, Hoffmann, & Sabharwal

interesting sub-classes resolution include regular resolution, provably exponentially powerful tree-like resolution variable resolved upon
path root leaf underlying proof graph, ordered
resolution, addition variables respect fixed ordering root-to-leaf path.
Tree-like resolution captures proofs unsatisfiability generated SAT solvers
based DPLL procedure (Davis & Putnam, 1960; Davis et al., 1962) dont employ so-called clause learning techniques; latter kind SAT solvers provably
exponentially powerful even regular resolution although still within realm
general resolution (Beame et al., 2004).
note arguments presented paper general (unrestricted) resolution. However, since aour constructions affect rely structural
properties resolution refutations consideration, results hold stated (except slight weakening case Lemma 4.14) known variants resolution
setting variables True False replacing one variable another preserves
proof structure. variants include tree-like (DPLL), regular, ordered resolution.
state standard property resolution proofs use arguments,
pointing certain modifications (such variable restrictions shortening
clauses) given formula cause proofs become longer general resolution
natural sub-classes, including mentioned above. Let x variable
True, False, another (possibly negated) variable . variable restriction
x transformation replaces x throughout , simplifies
resulting formula removing clauses containing True variable negation,
removing False duplicate literals clauses. words, variable restriction
involves fixing value variable identifying another literal, simplifying
formula. sequence variable restrictions , | denote
outcome applying .
following proposition combines two basic facts together form useful
us: (1) variable restrictions cannot increase resolution complexity formula,
(2) lengthening clauses and/or removing clauses cannot decrease resolution complexity
formula.
Proposition 2.1. Let CNF formulas. exists sequence variable
restrictions every clause | contains sub-clause clause ,
RC() RC( ).
explanation proposition use order. notation
used chosen match way eventually utilize proposition
proofs; below. conditions proposition imply one may obtain
applying restriction , possibly throwing away literals
clauses, possibly adding new clauses. Intuitively, three modifications
reduce number solutions cannot make harder prove
formula unsatisfiable. property resolution refutations propositional formulas
previously used (at least indirectly) various contexts. completeness, include
proof Appendix A, based folklore ideas proof complexity literature.
alternative proof, somewhat different notation, may found appendix
recent article Hoffmann, Gomes, Selman (2007).
428

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

way use proposition following: CNF encoding
abstracted planning task, encoding original planning task,
carefully chosen restriction bring focus variables already
appearing . Proposition 2.1 imply original encoding harder
refute, using resolution natural sub-classes, abstracted encoding.
2.4 Abstraction Planning
Abstraction methods various kinds put use planning, often quite successfully. One line work uses abstraction methods problem decomposition (cf. Sacerdoti,
1973; Knoblock, 1990; Koehler & Hoffmann, 2000). best knowledge,
approachexamining abstract state space order prove absence solutions
pursued before. line work relevant work domainindependent heuristic functions (cf. McDermott, 1999; Bonet & Geffner, 2001; Hoffmann &
Nebel, 2001; Edelkamp, 2001; Haslum et al., 2007; Helmert et al., 2007; Katz & Domshlak,
2008). There, abstraction means over-approximation state space, work;
differs abstractions used. course, kinds over-approximations
useful either purpose differ lot. use abstraction
paper, one define over-approximations preserve, large extent, real
structure problem. particular, ideal goal find abstractions preserve length optimal solutionsomething one definitely wouldnt expect
abstraction underlying heuristic function, since solved every search state.
briefly review over-approximation methods used
planning far; formally introduce novel one, variable domain abstraction.
use Logistics domain illustrative example.13
One wide-spread over-approximation method planning 2-subset relaxation
underlying computation made planning graph (Blum & Furst, 1997), generalized m-subset relaxation Haslum Geffner (2000). nutshell, one assumes
achieving set facts hard achieving hardest m-subset. known
that, domains, including Logistics, 2-subset solution length (corresponding
length planning graph constructed first fact layer containing mutexes
goal facts) typically strictly lower length optimal plan.
> 2, hand, computing m-subset solution length typically costly,
still, = o(|P |) one typically guarantee solution length preservation (Helmert
& Mattmuller, 2008).
second wide-spread over-approximation method ignoring delete lists (McDermott,
1999; Bonet & Geffner, 2001). approximation, one simply removes (some of)
negative effects actions. negative effects removed, problem
becomes solvable time linear instance size. latter basis heuristic
functions used many modern planners (cf. Bonet & Geffner, 2001; Hoffmann & Nebel,
2001; Gerevini, Saetti, & Serina, 2003). Ignoring deletes likely introduce shorter
solutions. example, Towers Hanoi problem, leads plans length n instead
2n 1 (Hoffmann, 2005). Logistics, one ignores deletes moving actions
13. stated, open topic explore model checking abstractions, particular predicate abstraction
(Graf & Sadi, 1997; Clarke et al., 2003), instead planning abstractions.

429

fiDomshlak, Hoffmann, & Sabharwal

plans may get shorter vehicles never move back abstraction.
Interestingly, ignoring deletes load/unload decrease plan length, since
actions never undone optimal plan. use observation
experiments.
third abstraction introduced Edelkamp (2001) pattern database
heuristic. approximation, one completely removes facts problem
description, notably facts corresponding values multi-valued variables.
enough facts removed, task becomes sufficiently simple. Obviously, approximation hardly solution length preserving. Logistics, remove, example,
fact at(package1,airport2) then, particular, package1 loaded onto airplane
airport2 without actually precondition removed. optimal
plan make package pop anywhere.
fourth abstraction, finally, involves removing preconditions (Sacerdoti, 1973)
and/or goal facts. Edelkamps abstraction, cannot expected solution
length preserving interesting cases.
calls new abstraction method, designed following Hernadvolgyi
Holte (1999). Considering STRIPS-like state transition systems multiple-valued
(instead Boolean) variables, propose reduce variable domains distinguishing certain values. example, content cell 8-puzzle
{blank , 1, 2, 3, 4, 6, 7, 8} may replaced {blank , 1, 2, 3} {3, . . . , 8}
mapped onto 3. observation that, many planning benchmarks, done
without introducing shorter plans. example, Logistics unnecessary distinguish
positions packages irrelevant cities. Therefore, replace domain at(p),
{A1 , A2 , B1 , B2 , C1 , C2 , . . . }, B initial goal cities p Ai , Bi , . . .
locations cities A, B, . . ., abstract domain {A1 , A2 , B1 , B2 , C1 }. STRIPS,
amounts replacing set irrelevant facts at(p, l) single fact at(p, C1 ).
formalize idea.
Let persistently mutex denote standard notion two facts mutex
fixpoint layer planning graph: typically, different values multiple-valued variable.
Definition 2.2. Let P = (P, A, I, G) STRIPS planning task, p, p0 P pair
persistently mutex facts that, A, ({p, p0 } del (a)) pre(a).
((P ), {(a)|a A}, (I), (G)) called variable domain abstraction P,
defined follows:
1. fact set F , (F ) = F p0 6 F ; otherwise, (F ) = (F \ {p0 }) {p}.
2. action = (pre, add , del ), (a) = ((pre), (add ), (del )) p 6 (add )(del );
otherwise, (a) = ((pre), (add ), (del ) \ {p}).
words, Definition 2.2 simply says replace p0 p. p appears
add list delete list action, remove delete list.14
situation arise, instance, action moves package one irrelevant position
14. reader may wonder p remains add list, although prerequisite p (pre). reason
distinguish abstractions simplifications: change planning task;
abstractions, simplifications, way may alter tasks semantics. However,
simplifications may well affect resolution complexity. get back later paper.

430

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

another irrelevant position. operation, p equivalent originally
p p0 : p True abstracted action sequence p p0 True
corresponding real action sequence. particular, Proposition 2.3 states variable
domain abstraction over-approximation usual sense.
Proposition 2.3. Let P = (P, A, I, G) STRIPS planning task, let (P) =
((P ), {(a) | A}, (I), (G)) variable domain abstraction P. Then, whenever
ha1 , . . . , plan P, h(a1 ), . . . , (an )i plan (P).
Proof. Let state models induced P (P). First, let us show
that, state M, action M, applicable s, (i)
(a) applicable (s), (ii) p ((s), (a)) {p, p0 } (s, a) 6= .
Note that, since abstraction effect facts {p, p0 }, (ii) implies
((s), (a)) = ((s, a)). Thus, together, (i) (ii) imply (iii) homomorphic
. Finally, straightforward Definition 2.2 (iv) initial state
(I), goal states exactly {(s) | SG }. Together, (iii) (iv)
imply claim Proposition 2.3.
Let = (pre, add , del ). applicability (a) (s) straightforward; p0 6 pre,
(pre) = pre (s)(pre) = spre, otherwise (pre) = (pre\{p0 }){p}
(s) = (s \ {p0 }) {p}. cases, pre implies (pre) (s). Consider
sub-claim (ii) case-by-case basis.
{p0 , p} add = , {p0 , p} del = p 6 add ((a)) p 6 del ((a)), thus
p ((s), (a)) iff p (s) iff {p, p0 } 6= iff (see assumption del case)
{p, p0 } (s, a) 6= .
{p0 , p} add 6= , {p0 , p} del = p add ((a)) p 6 del ((a)), thus
p ((s), (a)). hand, {p, p0 } (s, a) 6= trivially holds here.
{p0 , p} add = , {p0 , p} del 6= p 6 add ((a)) p del ((a)), thus
p 6 ((s), (a)). hand, since p, p0 persistently mutex facts P,
{p0 , p} del = {p0 , p} pre, {p, p0 } (s, a) = .
{p0 , p} add 6= , {p0 , p} del 6= p add ((a)) p 6 del ((a)), thus
p ((s), (a)). hand, add del = {p0 , p} add 6=
immediately {p, p0 } (s, a) 6= .
completes proof (ii).
Arbitrarily coarse variable domain abstractions may generated iterating application Definition 2.2. Note variable domain abstraction refinement Edelkamps
(2001) abstractioninstead acting irrelevant positions could totally ignored,
distinguish whether package currently position. makes
difference preserving optimal solution length not.15
hinted above, variable domain abstraction may able apply
simplifications. simplification, terminology, similar abstraction
15. topic future work explore whether refined abstraction lead better pattern database
heuristics STRIPS problems.

431

fiDomshlak, Hoffmann, & Sabharwal

manipulates planning task language level. However, abstractions may alter
tasks semantics, simplifications not; i.e., simplifications introduce new
transitions goal states. Concretely, consider two simplifications. planning task
P = (P, A, I, G) duplicate actions exist a, a0 pre(a) = pre(a0 ),
add (a) = add (a0 ), del (a) = del (a0 ).16 simplified planning task P except
a0 removed. planning task P = (P, A, I, G) irrelevant add effects
exists pre(a) add (a) 6= . simplified planning task P except
remove pre(a) add (a).
Obviously, duplicate actions irrelevant add effects may arise outcome variable domain abstraction. example latter action moving package
irrelevant location irrelevant truck. example former two actions loading
package onto airplane distinct irrelevant locations.17 implementation,
simple post-abstraction processing perform simplifications.
shall see Section 4.3, simplifications lead decreased resolution complexity, thereby offsetting result abstractions such, many cases, cannot.
may seem little artificial distinguish abstractions simplifications way, seeing
many abstractions bound enable us simplify. However, note distinction
serves identify borderline can, cannot, reduce resolution
complexity. Anyhow, shall see next section, abstraction tend help
empirically performance SATPLAN even post-abstraction simplifications.

3. Empirical Results
performed broad empirical evaluation effect abstractions efficiency
optimizing planning algorithms. mostly focus variable domain abstraction,
Definition 2.2, since clearly promising obtaining solution length preserving
abstractions.
Section 3.1 explains specific variable domain abstractions employ experiments. Section 3.2 explains experimental setting chose present huge
data set results. Section 3.3 describes experiments variable domain abstraction IPC benchmarks, Section 3.4 discusses results domain-specific
abstractions hand-made instances certain benchmark domains amount
irrelevance controlled. Section 3.5 briefly summarizes findings abstraction
methods variable domain abstraction.
3.1 Variable Domain Abstractions
designed three different methods automatically generate variable domain abstractions. methods listed based increasingly conservative approximations
16. Note define actions triples pre, add , del , components; hence
two actions identical pre, add , del may contained set A. reflects practical planner
implementations, actions names and/or unique IDs, checks duplicate actions
usually performed.
17. similar fashion, duplicate actions may arise outcome Edelkamps (2001) pattern database
abstraction.

432

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

relevance. common relevance approximations (cf. Nebel et al., 1997), algorithmic basis is, cases, simplified backchaining goals.
1Support starts first layer planning graph contains goal facts (possibly
mutexes them). goal fact layer, selects one achiever
preceding action layer marks preconditions action new sub-goals;
process iterated created sub-goals.
AllSupports proceeds similarly 1Support except selects achievers
(sub-)goal.
AllSupportsNonMutex proceeds similarly AllSupports except starts backchaining first plan graph layer contains goals without mutexes.
three methods, selected set relevant facts R P taken set
goals sub-goals created backchaining. set facts turned
variable domain abstraction follows. First, compute partition problems
fact set P subsets P1 , . . . , Pk pairwise persistently mutex facts. take
subsets correspond underlying multiple-valued variables (e.g., position
package). perform abstraction within Pi values relevant,
i.e., Pi \ R 6= . Within subset Pi , arbitrarily choose one irrelevant fact p, i.e.,
p Pi \ R. replace irrelevant facts, i.e., q Pi \ R q 6= p,
p.
example, Logistics, 1Support abstracts away in(p, v) facts package p except vehicles v selected supportin particular, single
airplane. contrast, AllSupports mark in(p, v) relevant airplanes v unless
special case applies (e.g., p must transported within origin city only). Finally,
AllSupportsNonMutex even conservative covers special cases
AllSupports abstracts in(p, v) fact away. Note identifying positions inside
airplanes positions outside airplanes may well affect length optimal plan.
addition domain-independent, automatic variable domain abstractions, six
IPC domains designed domain-specific solution length preserving variable domain
abstractions hand. Logistics, domain-specific abstraction explained
introduction. Zenotravel, use similar abstraction exploiting irrelevant object positions. Blocksworld, on(A, B) considered irrelevant B neither initial
goal position A, B initially clear.18 Depots, combination Logistics
Blocksworld, abstraction combination two individual abstractions.
Satellite, abstraction performs simple analysis goal relevance detect directions
irrelevant satellite turn to. direction relevant satellites initial direction, goal direction, potential goal camera calibration target.
Similarly, Rovers, waypoint (location) considered relevant rover
either initial position, relevant needed rock sample/soil sample/image,
necessarily lies path rover must traverse reach relevant location.
18. last conditions necessary avoid possibility clearing block C moving
away C although actually placed third block.

433

fiDomshlak, Hoffmann, & Sabharwal

3.2 Experiment Setup Presentation
presented data generated set work stations running Linux, Pentium 4 processor running 3 GHz 1 GB RAM. used time cutoff 30 minutes.
experimented plan-length optimizing planners SATPLAN04, IPP (Koehler,
Nebel, Hoffmann, & Dimopoulos, 1997), Mips-BDD (Edelkamp & Helmert, 1999).19
choice SATPLAN04 rather SATPLAN06 arbitrary, except that, using
naive encoding (C), resolution best case SATPLAN04 improved variable domain abstractionmaking bad empirical results even significant.
Note that, although SATPLAN06 could considered recent, contains
developments beyond SATPLAN04, switching back older version
encoding method.
test examples, took, exceptions listed below, STRIPS domains used
international planning competitions including IPC-2004. Precisely, use
(IPC-2004) Airport, Dining Philosophers, Optical Telegraph, Pipesworld NoTankage,
Pipes- world Tankage, PSR.
(IPC-2002) Depots, Driverlog, Freecell, Rovers, Satellite, Zenotravel.
(IPC-2000) Blocksworld Logistics. (Miconic-STRIPS simple version
Logistics, Freecell part IPC-2002 set.)
(IPC-1998) Grid, Mprime, Mystery. (Movie trivial, Gripper variable domain
abstraction cannot preserve solution length, Logistics part IPC-2000 set.)
measurements aimed highlighting potential abstraction principle
speeding computation information task. Concretely, given
planning task , create abstract version , run planner X it.
three possible outcomes:
(1) X finds plan , abstract plan, happens real plan (that is, plan
). record time taken find plan, along time taken X
find plan given original task .
(2) X finds plan real plan. Since planners optimize plan
length, information still gain length optimal abstract plan,
lower bound length real plan. record time taken compute
bound (for example, SATPLAN04, time taken last unsatisfiable
iteration), along time taken X compute lower bound given
original task .
(3) X runs time memory. case, one could record time taken
last lower bound proved successfully. sake readability, omit
consider cases (1) (2) above.
19. SATPLAN04 IPP optimize step-length plan, Mips-BDD optimizes sequential plan
length. However, again, performance planners stand comparative evaluation
here, refer three simply plan-length optimizing planners.

434

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

Note that, spirit optimistic usefulness abstraction,
include time taken create abstract task . Note actually obtain
several results pair X, namely one result every particular variable domain
abstraction. sake readability, include distinctions results
(the distinctions mostly inconclusive uninteresting anyway), instead present
results following best abstraction perspective. skip abstract tasks
either solved, abstract since facts considered relevant.
abstract task remains, skip instance. Otherwise, select abstract task
providing best information instance: best case abstract plan
real, else select highest lower bound.20 several abstractions providing
best information, choose one lowest runtime.
3.3 IPC Benchmarks
Due sheer size experiments3 planners multiplied 17 domainsdiscussing
entire result set neither feasible would useful. online Appendix (see JAIR
web page article) contains detailed data three optimal planners. Herein,
provide summary analysis showing main points, particular focus SATPLAN04.
Detailed data SATPLAN04 4 17 IPC domains given Table 1:
Depots Satellite selected table 2 17
domains abstraction brings somewhat significant advantage.
Logistics selected illustrative example.
PSR selected due interesting caseunusually, current optimal planners well (or badly) PSR current sub-optimal (satisficing) planners.
domain, selected 13 challenging instances, challenging
measured runtime taken original task. Note problem-instance selection
criterion presentation optimistic point view abstraction.
instance, Table 1 first specifies whether found abstract plan real plan not.
characterizes problem instance terms cases (1) (2) explained above,
corresponding runtimes SATPLAN04 abstract real tasks given
rows ta tr . table specifies lower bound lg proved real task
planning graph (that is, F (t) first fact layer contain goal facts
mutexes them), lower bound la proved SATPLAN04 abstract task,
and, finally, actual length lr optimal plans real task. last row RelFrac
table specifies percentage facts considered relevant.
Depots, best-case data shown Table 1 scattered across four kinds
variable domain abstractions, automatic abstractions sometimes
sometimes less aggressive handmade abstraction. example, instances numbers
11 15 best case aggressive 1Support strategy. time
20. Note quality information essential. abstraction tells us plan
must least n 1 steps, real plan length n, must still prove bound n,
typically takes time bounds together.

435

fiDomshlak, Hoffmann, & Sabharwal

Index
IsReal?
ta
tr
lg , l , L
RelFrac
Abs

Index
IsReal?
ta
tr
lg , l , L
RelFrac
Abs

Index
IsReal?
ta
tr
lg , l , L
RelFrac
Abs

Index
IsReal?
ta
tr
lg , l , L
RelFrac
Abs

2

64.43
74.26
6,12,12
37%
1S

16
N
0.63
0.8
5,15,15
47%
ASnm

10

0.99
2.14
10,15,15
33%
1S

3

73.29
45.77
11,12,12
88%


4

112.30
104.05
6,10,10
91%
HM

22

64.29
71.86
7,25,25
75%
ASnm

13

91.43
75.28
9,13,13
48%
ASnm

4

429.74
472.01
12,14,14
88%


5

53.06
51.53
4,7,7
95%
HM

29

11.16
12.05
7,18,18
79%
ASnm

14

25.41
32.87
9,12,12
48%
ASnm

7

10.44
12.25
7,10,10
77%
ASnm

8

310.76
250.08
4,8,8
90%
HM

31
N
1.04
8.38
5,16,16
49%
ASnm

15
N
70.57
68.12
9,13,13
55%
ASnm

8
N
228.30
22.52
9,13,14
76%


9

34.35
40.65
4,6,6
84%
HM

33
N
0.93
1.33
5,16,16
48%
ASnm

16
N
111.66
75.79
9,13,13
47%
ASnm

10

47.77
33.11
8,10,10
87%
ASnm

Depots
11
13
N

49.73
9.07
2.13
12.42
13,10,?
9,9,9
27%
85%
1S
ASnm
Logistics
17
18
N
N
150.37
770.44
106.61
642.97
9,13,14 9,15,15
44%
42%
ASnm
HM
PSR
36
37


2.44
2.4
4.96
2.26
8,16,16 7,19,19
90%
60%
ASnm
ASnm
Satellite
10
11


168.03
84.47
176.47
160.03
4,8,8
4,8,8
85%
74%
HM
HM
12

874.84

6,14,14
76%
HM

40
N
0.9
6.39
5,14,15
48%
ASnm

19
N
684.19
672.25
9,15,15
30%
HM

14
N
118.90
12.72
9,9,?
50%
HM

13

931.17

4,13,13
76%
HM

42
N
0.73
0.87
5,16,16
53%
ASnm

20
N
820.59
721.73
9,15,15
33%
HM

15
N
56.83
4.45
10,8,?
20%
1S

14

256.16
425.44
4,8,8
78%
HM

47

17.75
17.41
4,23,23
47%
ASnm

21
N
615.01
430.95
9,14,?
48%


16

13.81
6.54
8,8,8
89%
ASnm

15

282.79
429.81
4,8,8
75%
HM

48

125.49
131.94
7,26,26
80%
ASnm

22
N
929.64
721.82
9,15,?
28%
HM

17

18.4
17.41
6,7,7
58%
ASnm

17

65.79
152.37
4,6,6
67%
HM

49
N
3.02
3.11
8,19,?
37%
1S

23
N
965.49
769.36
9,15,?
43%


19

460.75

8,10,10
92%


18

112.50
217.76
4,8,8
74%
HM

50

0.59
1.03
4,16,16
30%
ASnm

39
N
1.1
1.9
9,8,?
14%
1S

21
N
342.20
55.70
7,7,7
51%
HM

Table 1: Full results, selected domains, SATPLAN04 variable domain abstraction (best-of, see text). Notations: Index:
index (number) instance respective IPC suite; IsReal: whether abstract plan real (Y) (N); L: length
optimal plan (? known), lg : lower bound plan length proved planning graph, la lower bound proved abstract task;
ta : runtime (secs) needed prove lower bound la abstract task; tr runtime (secs) needed prove lower bound la
real task; RelFrac: fraction facts considered relevant; dashes: time-out; Abs: corresponding form variable
domain abstraction, 1Support (1S), AllSupports (AS), AllSupportsNonMutex (ASnm), handmade (HM).

436

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

Domain
Airport
Blocksworld
Depots
Dining Philosophers
Driverlog
Freecell
Grid
Logistics
Mprime
Mystery
Optical Telegraph
Pipesworld NoTankage
Pipesworld Tankage
PSR
Rovers
Satellite
Zenotravel

Index
20
7
19
29
13
1
2
23
5
20
13
12
8
48
8
12
13

ta
33.9
118.3
460.8
6.2
342.0
0.8
96.4
965.5
6.2
180.7
43.6
521.7
393.8
125.5
74.6
874.8
338.4

SATPLAN04
tr
IsReal?
lg , l , l r
29.5

25,32,32
11.2

16,20,20


8,10,10
5.5

7,11,11
113.7
N
9,11,12
0.8

4,5,5
3.1
N
19,13,?
769.4
N
9,15,15
5.2

6,6,6
112.4

7,7,7
32.0
N
11,13,13
455.5

8,14,14
143.4
N
5,6,?
131.9

7,26,26
97.8

5,9,9


6,14,14
244.8
N
4,7,7

RelFrac
73%
47%
92%
71%
61%
82%
10%
43%
78%
76%
53%
86%
89%
80%
87%
76%
67%

Table 2: Results SATPLAN04 best-case variable domain abstraction
challenging successful instances domain. Notation Table 1.

runtime better original task, yet cases abstraction
brings quite significant advantage. notably, instance number 19 SATPLAN04
runs time original task, solves abstract task, finding real plan, within
minutes. Logistics, best-case data mostly, though exclusively, due
conservative AllSupportsNonMutex handmade abstractions. abstract runtime
worse three cases (nos. 10, 14, 39), slightly better. PSR, best
cases almost exclusively due conservative AllSupportsNonMutex abstraction.
runtimes, abstraction usually faster, marginally. Satellite one
17 domains abstraction brings significant (and largely consistent) runtime
advantage. best cases almost exclusively due hand-made abstraction.
abstract plans real plans, often found significantly faster original task.
unclear us results good Satellite, but, example, Logistics,
state space reduction much larger.
Next, Table 2 provides overview results SATPLAN04 17 IPC
domains. make data presentation feasible, select one instance per domainthe
challenging successful instance. successful, mean least one abstract
task instance solved (abstract plan found), abstract task indeed
abstract (not facts relevant). challenging, mean maximum runtime original
task.21
21. Another strategy would select task maximizes tr ta , time advantage given
abstraction. However, cases strategy would select trivial instance: namely, tr ta
consistently negative, maximal easiest tasks.

437

fiDomshlak, Hoffmann, & Sabharwal

Domain
Airport
Blocksworld
Depots
Dining Philosophers
Driverlog
Grid
Logistics
Mprime
Mystery
Optical Telegraph
Pipesworld NoTankage
PipesworldTankage
PSR
Rovers
Satellite
Zenotravel

Index
8
7
17
5
9
1
8
2
2
2
5
7
10
6
7
12

ta
67.9
3.1
254.4
170.4
1.1
0.1
0.2
0.6
0.4
15.7
0.0
32.2
0.0
592.5
100.3
344.3

tr
0.3
0.0
268.4
138.0
0.7
0.2
1.0
1.0
0.7
5.2
0.0
0.6
0.0
375.7
2010.7
322.4

IPP
IsReal?




N
N

N
N
N

N
N
N



lg , l , l r
25,26,26
16,20,20
6,7,7
7,11,11
7,10,10
14,7,14
9,11,11
5,4,5
5,4,5
11,13,13
4,6,6
4,5,6
5,4,5
7,12,12
4,6,6
4,6,6

RelFrac
77%
47%
58%
71%
84%
43%
49%
62%
60%
53%
88%
82%
37%
90%
87%
67%

Table 3: Similar Table 2, IPP planner.

useful discuss 17 domains groups similar behavior. Depots, Logistics,
PSR, Satellite already discussed. Airport, Dining Philosophers,
Driverlog, Mystery, Mprime, Optical Telegraph, Pipesworld NoTankage, Pipesworld
Tankage, SATPLAN04 runtimes consistently lower original tasks, exceptions mostly among easiest instances. picture less consistent qualitatively
similar Zenotravel. degree advantage varies. relatively moderate
Dining Philosophers (up 7% less runtime original task), Optical Telegraph (up
23%), Airport (up 28%), Pipesworld Tankage (up 28%), Mprime (up 36%);
much stronger Zenotravel (up 75%), Mystery (up 80%), Driverlog (up 89%),
Pipesworld NoTankage (up 92%).
Rovers, runtime results inconclusive, minor advantages abstract
real depending instance. Blocksworld, SATPLAN04 solves abstract tasks
7 blocks only, independently abstraction used; dont know causes
bad behavior. Freecell, time AllSupports AllSupportsNonMutex
abstract anything, abstractions generated 1Support, SATPLAN04 runs
time, leaving instance number 1 successful case, shown Table 2. Grid,
finally, IPC 1998 test suite contains 5 instances, become huge quickly.
SATPLAN04 solve (abstract real) instances numbers 1 2, latter
shown Table 2.
Tables 3 4 provide similar snapshot results IPP Mips.BDD,
respectively. picture IPP is, roughly, similar SATPLAN04. main
difference is, fact, IPP weaker solver SATPLAN04 many domains,
effect domains contain interesting data. Specifically, Driverlog,
Mprime, Mystery, Pipesworld NoTankage, PSR, IPP either solves instances
time, all. SATPLAN04, see advantage abstraction Depots
438

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

Domain
Airport
Blocksworld
Depots
Dining Philosophers
Driverlog
Freecell
Grid
Logistics
Mprime
Mystery
Optical Telegraph
Pipesworld NoTankage
Pipesworld Tankage
PSR
Rovers
Satellite
Zenotravel

Index


2

ta


1.1

Mips.BDD
tr
IsReal?







lg , l , l r


7,15,15

RelFrac


81%

10

1
12



503.6

1.8
7.2












N




5,17,17

14,7,?
10,42,42



84%

43%
43%



25
7

0.7
142.6

13.5
340.6




4,9,9
5,18,18

37%
86%

11

271.0





4,14,14

66%

Table 4: Similar Tables 23, Mips.BDD planner.

Satellite, note Satellite difference consistently huge.
see vague advantage abstraction Logistics. Mips.BDD, even domains
gave meaningful data. domains dashed Table 4, Mips.BDD runs
time even smallest instances. domains left empty, either could run
Mips.BDD technical reasons, stopped abnormally. remaining data
set 7 domains, however, abstractions (as expected) bring consistent advantage
Mips.BDD. particular, consider behavior Logistics, Rovers, Zenotravelin
domains, Mips.BDD vastly improved abstraction SATPLAN04 IPP
less inconclusive.
3.4 Constructed Benchmarks
shown use abstractionof variable domain abstraction, least
speed state art planning systems varies quite promising Mips.BDD
rather hopeless SATPLAN04. ran number focused experiments examine
subtle reasons phenomenon. experiments done three
IPC benchmarksLogistics, Rovers, Zenotravelwhere results IPC test
suites relatively bad, although possession hand-made abstractions.
wanted test happens scale instances irrelevance. respective
experiment Logistics, Figure 1, discussed introduction. Rovers, tried
large number instance size parameters, even minor modifications operators,
could find setting contained lot irrelevance challenging
SATPLAN04 IPP. short, appears Rovers domain amenable
abstraction techniques. Zenotravel, obtained picture shown Figure 2.
439

fiDomshlak, Hoffmann, & Sabharwal

10000

100

10000

100

90
1000

90

80

1000

80

70
100

70

60

100

60

50
10

50

40

10

40

30
1

30

20
Mips.BDD-abstract
Mips.BDD-real
RelFrac

0.1
2

3

4

5

6

7

8

9

10

11

1

20
IPP-abstract
IPP-real
RelFrac

10
0

12

0.1

13

2

3

4

5

6

(a)

7

8

9

10

11

12

10
0
13

(b)
10000

100
90

1000

80
70

100

60
50

10

40
30

1

20
SATPLAN-abstract
SATPLAN-real
RelFrac

0.1
2

3

4

5

6

7

8

9

10

11

12

10
0
13

(c)
Figure 2: Runtime performance Mips.BDD (a), IPP (b), SATPLAN04 (c),
(abstract) without (real) hand-made variable domain abstraction,
Zenotravel instances explicitly scaled increase amount irrelevance.
Horizontal axis scales number cities, left vertical axis shows total runtime
seconds, right vertical axis shows percentage RelFrac relevant facts.

shown Zenotravel instances always feature 2 airplanes 5 persons. number
cities scales 2 13. Logistics, generated 5 random instances per size,
show average values time-out 1800 seconds, stopping plots 2 timeouts occurred instance size. all, relative behavior abstract real
curves planner quite similar observed Figure 1 Logistics.
SATPLAN04 IPP, abstraction slight disadvantage high RelFrac,
becomes much efficient RelFrac decreases. Mips.BDD, advantage brought
abstraction much pronounced, decreasing RelFrac consistently widens
gap solving abstract real tasks. average value RelFrac IPC
2000 Zenotravel benchmarks 64%, lying 5 cities (67%) 6 cities (63%)
Figure 2, yet much gained abstraction.
440

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

summary, appears planning benchmarks (like Rovers) good
abstractions, others (like Logistics Zenotravel) enough irrelevance
IPC test suites.
important note situation may quite bad unsolvable examples. Consider IPC benchmarks Dining Philosophers Optical Telegraph (Edelkamp,
2003). Dining Philosophers extremely basic benchmark cannot abstracted
much further. contrast, Optical Telegraph essentially version Dining Philosophers
complex inner life (exchanging data two hands philosopher).
inner life affect existence solution (deadlock situation), depends exclusively outer interfaces philosophers, is, taking releasing
forks. However, inner life does, course, affect length solution, one exists.
constructed unsolvable version domain (without deadlock situation) giving
philosophers flexibility releasing forks. one would expect, setting
abstracting inner life away gives huge savings, i.e., tasks proved unsolvable
much efficiently. suggests may easier abstract unsolvable tasks,
without invalidating property interest. Exploring topic future work.
planning benchmark domains naturally contain unsolvable instances,
over-subscription planning issue may become relevant (Sanchez & Kambhampati, 2005;
Meuleau, Brafman, & Benazera, 2006).
3.5 Abstractions
discussed earlier, one cannot expect removing preconditions, goals, entire facts
preserves plan length interesting cases. are, however, certain cases
delete effects safely ignored. Specifically: Driverlog, Logistics, Mprime, Mystery,
Zenotravel, one ignore deletes load unload actions state
object longer origin location (load) respectively object
longer inside vehicle (unload); Rovers one ignore deletes actions taking
rock soil samples, namely deletes stating sample longer origin
location. ran planners respective abstracted tasks. results
summarized follows.
SATPLAN04 clear loss runtime using abstraction Driverlog (e.g.,
task number 15 solved abstract vs. real 693.0 vs. 352.3 sec).
IPP vast gain abstraction Logistics (e.g., 52.8 vs 5540.1 sec number 12),
vast loss Zenotravel (e.g., 318.5 vs 2.5 sec number 12).
Mips.BDD vast loss abstraction Driverlog, Logistics, Zenotravel (e.g.,
163.8 vs. 8.3 sec Zenotravel number 8).
results inconclusive planner/domain pairs.

4. Resolution Complexity
discussed introduction, surprised see little improvement SATPLAN experiments, despite dramatic state space reductions brought
441

fiDomshlak, Hoffmann, & Sabharwal

variable domain abstraction. shed light issue, examining resolution
complexity original vs. abstracted planning tasks. Throughout section,
consider situation plan length boundthe number time steps CNF
encodingis small, thus CNFs unsatisfiable. Note case
one SAT tests performed SATPLAN. particular, case
SAT tests SATPLAN proves optimality plan, is, non-existence
plan n 1 steps n length optimal plan. proof typically
costly, accounting large fraction runtime taken SATPLAN.
consider abstraction methods introduced Section 2.4, plus (for completeness)
hypothetical abstraction method adds new initial facts. show Section 4.1 that,
many cases, resolution complexity cannot improved delegating optimality
proof within abstraction. Section 4.2 show that, considered cases,
resolution complexity become exponentially worse. Section 4.3 briefly examines
effect post-abstraction simplifications. sake readability, herein proofs
replaced proof sketches. full proofs available Appendix A.
Recall resolution complexity defined length shortest possible resolution refutation. proofs, arguments general (unrestricted) resolution.
However, constructions affect structure resolution refutations,
hence results hold stated (except slight weakening case Lemma 4.14)
many known variants resolution, including tree-like (DPLL), regular, ordered
resolution. general, results hold variant resolution setting variables True False replacing one variable another preserves proof structure (the
slightly exceptional status Lemma 4.14 explained discuss
result).
remainder paper, P planning task abstraction,
P denote respective abstracted planning task, is, planning task
results applying P.
4.1 Resolution Complexity Become Better?
prove three main results, captured Theorems 4.14.3 below. first
result holds four SAT encodings (A)(D) listed Section 2.2; two
results apply encodings (A) (C), respectively. respective encodings
abstraction methods, results essentially say resolution complexity cannot decrease
applying abstraction. outlined introduction, catchy (if imprecise) intuition
behind results over-approximations (abstractions) result less constrained
formulas, harder refute. encoding (C), result offset effort
required recover Graphplan mutexes; get back below. theorems
follow, recall Section 2.3 RC() denotes resolution complexity , i.e.,
size smallest resolution proof unsatisfiability .
Theorem 4.1. Let P planning task. Assume use encoding methods
(A)(D). Let abstraction P consists combination of:
(a) adding initial facts;
(b) ignoring preconditions, goals, deletes;
442

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

(c) removing fact completely.
Let n length shortest plan P , let b < n. Let encodings
b-step plan existence P P , respectively. RC() RC( ).
Theorem 4.2. Let P planning task. Assume use encoding method (A). Let
abstraction P consists combination of:
(a) adding initial facts;
(b) ignoring preconditions, goals, deletes;
(c) removing fact completely;
(d) variable domain abstraction.
Let n length shortest plan P , let b < n. Let encodings
b-step plan existence P P , respectively. RC() RC( ).
Theorem 4.3. Let P planning task. Assume use encoding method (C). Let
abstraction P consists combination of:
(a) adding initial facts;
(b) ignoring preconditions, goals, deletes;
(c) removing fact completely;
(d) variable domain abstraction.
Let n length shortest plan P , let b < n. Let encodings
b-step plan existence P P , respectively. Let number resolution steps
required infer additional mutex clauses appear ,
encoding b-step plan existence P per encoding (A). RC() RC( ) + .
Note theorems n, defined length shortest plan P ,
necessarily satisfies n length shortest plan P. Hence,
n b m, satisfiable. Detecting finding P plan length b
give us information length shortest plan P. 0 b < n,
however, unsatifiable, tells us b + 1 lower bound plan length P.
Hence, theorems say this: either b n coarse disprove existence
plan length b; b < n decrease resolution complexity
disproofat least complexity deriving additional mutexes,
case Theorem 4.3.
Let us first linger bit Theorem 4.3. general intuition results
abstractions induce less constrained formulas, hence resolution complexity cannot decrease. hold encoding (A) stated Theorem 4.2 not, strict
sense (see Proposition 4.13 later section), encoding (C)? Basically, answer
intuition imprecise general formulation, devil details.
particular case, issue variable domain abstraction makes use mutex
443

fiDomshlak, Hoffmann, & Sabharwal

relations encoding (C) aware of. Sometimes, indirect mutex original
task (omitted encoding (C)) becomes direct mutex abstraction (included encoding (C)). Refuting might involve recovering mutex, refutation
need do. Hence, potential improvement resolution complexity may stem
power mutex relations. upper bound specified Theorem 4.3 shows
thing improvement due to. Proposition 4.13 provides example
mutex must recovered, hence proves analogue Theorem 4.2
hold encoding (C).
open question whether analogue Theorem 4.2 holds encoding (B),
whether analogue Theorem 4.3 holds encoding (D). discuss
below, open questions appear related intricate properties Graphplanbased encodings vs. without fact variables. know mutexes may
need recovered encoding (D): example provided Proposition 4.13 works
encodings (C) (D). Further, establish connection two open
questions: analogue Theorem 4.2 holds encoding (B), immediately get
analogue Theorem 4.3 holds encoding (D).
consider detail. Note that, far removal goals concerned,
theorems actually trivial: four encoding methods, removes part
goals, sub-formula . abstraction methods, latter
case. treat removal goals together methods since treament
cause overhead, goal clauses need discussed anyway (the set
achievers goal may change).
proofs, need helper notion captures over-approximated planning graphs. Assume planning task P planning graph P G(P), assume
abstraction. P G(P ) typically many vertices P G(P).
captures fact P allows fewer (and often more) facts actions P
does. will, general, result many constraints propositional translation
planning task. constraints, may seem abstraction could,
principle, make possible derive easier/shorter proof fact plan exists
within specified bound. However, closer inspection restricted facts actions
already available original planning graph reveals one often ends fewer
weaker constraints original task. introduce notations
make formal.
Definition 4.4. planning task P abstraction it, P G (P) defined
subgraph P G(P ) induced vertices P G(P). Similarly, P Gred (P) defined
subgraph P Gred (P ) induced vertices P Gred (P).
Definition 4.5. Let P planning task. abstraction called planning graph
abstraction P P G (P) P G(P) identical sets vertices following
conditions hold:
(1) Eadd (P G (P)) Eadd (P G(P)),
(2) Epre (P G (P)) Epre (P G(P)),
(3) Emutex (P G (P)) Emutex (P G(P)),
444

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

(4) (G) G,
G (G) goal states P P , respectively. abstraction called
reduced planning graph abstraction conditions hold P Gred (P) P Gred (P)
instead.
Lemma 4.6. Let P planning task. Assume use encoding method (A) (B). Let
planning graph abstraction P. Let n length shortest plan P ,
let b < n. Let encodings b-step plan existence P P , respectively.
RC() RC( ).
Proof Sketch. Say set False variables appear , i.e.,
fix value variables 0. way defined P G (P),
yields precisely propositional encoding P G (P). show that, variable
restriction, clauses surviving present , either stronger
form (i.e., fewer literals). example, encoding (A) precondition clause
C corresponding clause C due condition (2) Definition 4.5,
states introduce new preconditions. C C due condition
(1) Definition 4.5, states preserves add effectshence set actions
achieving precondition P contains corresponding set P. similar observation
holds effect clauses encoding (B), similar arguments apply
kinds clauses. claim follows Proposition 2.1.
Lemma 4.7. Let P planning task. Assume use encoding method (C) (D). Let
reduced planning graph abstraction P. Let n length shortest plan
P , let b < n. Let encodings b-step plan existence P P ,
respectively. RC() RC( ).
Proof. argument identical proof Lemma 4.6, except underlying
planning graph encodings (C) (D) reduced planning graph, resulting potentially fewer mutex clauses encodings (A) (B), respectively. This, however,
way affect proof arguments.
Lemma 4.8. Let P planning task. Let modification P respects
following behavior:
(a) shrink list initial facts,
(b) grow set goal facts,
(c) preserves add lists unchanged,
(d) grow pre del lists.
planning graph abstraction P well reduced planning graph abstraction
P.
445

fiDomshlak, Hoffmann, & Sabharwal

Proof Sketch. proof straightforward, little tedious details. Suppose
abstraction P satisfying prerequisites. must argue P G (P) P Gred (P)
satisfy conditions Definition 4.5. Condition (4) involving goal states easily follows
property (b) . P G(P) P G (P) (as well reduced counterparts)
shown set vertices, conditions (1) (2) involving precondition
effect relations follow directly properties (c) (d). hence remains prove
facts actions available P G(P) available P G (P) (showing (1)
(2) said), new mutex relations created facts
actions mutex P G(P) (showing (3)). proof little tedious, proceeding
inductively construction planning graph. underlying intuition, however,
simple: P G (P) layer abstracts P G(P) layer t, properties (a), (c)
(d) respected , necessarily P G (P) layer + 1 abstracts P G(P)
layer + 1. concludes argument.
following immediate consequence Lemmas 4.6, 4.7, 4.8.
Corollary 4.9. Let P planning task. Assume use encoding methods
(A)(D). Let abstraction P consists combination of:
(a) adding initial facts;
(b) ignoring preconditions, goals, deletes.
Let n length shortest plan P , let b < n. Let encodings
b-step plan existence P P , respectively. RC() RC( ).
result essentially states rather intuitive fact that, abstraction anything yields larger planning graph, resulting Graphplan-based encodings
less constrained hence higher resolution complexity (if anything).
Matters become much less intuitive consider abstractions remove entire
factsclearly, longer result over-approximated planning graphs, since remove vertices. words, condition Definition 4.5 P G (P)
P G(P) identical sets vertices hold, need slightly different line
reasoning rely strictly abstracted planning graphs. first show
harmless remove fact appear goal pre del list.
rely Corollary 4.9 reason requirement fact easily achieved.
Lemma 4.10. Let P planning task. Assume use encoding methods
(A)(D). Let p fact appear goal pre del lists,
let abstraction P removes p initial facts add lists. Let
n length shortest plan P , let b < n. Let encodings
b-step plan existence P P , respectively. RC() = RC( ).
Proof Sketch. key point that, p appear goal never required
deleted action, p completely irrelevant planning task, particular
resolution refutations consider here. Concretely, first prove every layer
planning graph, available facts mutex fact pairs remain same,
facts fact pairs involving p. is, thing lost fact layers
446

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

P G (P) p. Since p occur precondition, action layers remain exactly
same; since p occur preconditions delete effects, action mutexes
remain exactly (they caused p).
discussion implies precondition clauses encodings
identical. Given p appear goal, true goal clauses.
Since action mutexes unchanged, follows actually identical
encodings (A) (C). encodings (B) (D), difference
contain initial state, effect, mutex clauses involving p.
However, clauses never participate resolution refutation : effect
mutex clauses contain p polarity (negative); initial state clause
positive form {p(0)}, time index different p effect mutex
clauses. Hence every variable corresponding p occurs one polarity. concludes
argument.
Corollary 4.11. Let P planning task. Assume use encoding methods
(A)(D). Let abstraction P removes fact completely. Let n length
shortest plan P , let b < n. Let encodings b-step plan existence
P P , respectively. RC() RC( ).
Proof. equivalent following two steps. First, remove p goal facts (if
present) pre del lists. Corollary 4.9, step cannot improve resolution
complexity. Second, p removed goal pre del lists,
remove p problem completely removing initial facts add lists
well. Lemma 4.10, step well cannot improve resolution complexity,
done.
Corollaries 4.9 4.11 together prove first main result, Theorem 4.1.
move variable domain abstraction, matters complicated,
interesting abstraction method enables us construct solution length
preserving abstractions exponentially smaller state spaces, many benchmarks. First
show that, original form, result holds encoding (A).
Lemma 4.12. Let P planning task. Assume use encoding method (A). Let
variable domain abstraction P. Let n length shortest plan P , let
b < n. Let encodings b-step plan existence P P , respectively.
RC() RC( ).
Proof Sketch. combines two persistently mutex facts p p0 single fact p. first
show action pair (a, a0 ) mutex P , mutex P.
way (a, a0 ) become mutex per requires, w.l.o.g., P, p del (a) pre(a)
p0 pre(a0 ) add (a0 ). Supposing (a, a0 ) mutex P, p 6 del (a0 ) p
mutex fact pre(a0 ). then, (noop(p), a0 ) mutex P hence
(p, p0 ) persistent mutex, contradiction.
hand, derive property rather similar planning graph
abstractions given Definition 4.5. above, know abstract encoding
mutexes appear . Further, set actions achieving
fact grows applying abstraction, goal shrink.
447

fiDomshlak, Hoffmann, & Sabharwal

subtle issue regards precondition clauses. action p0 precondition P,
replaced p P , direct correspondence two. However,
lack correspondence affect precondition clause encoding (A),
takes form {a, a1 , . . . , ak }; omits actual precondition fact achieved,
matter whether fact p0 p.
Next, proof Lemma 4.6, set variables False appear
. arguments, difficult see clauses surviving
present , either stronger form (i.e., fewer literals).
mutex clauses, obvious. goal clauses, argument exactly
proof sketch Lemma 4.6 given above. precondition clauses, observe a1 , . . . , ak
contain achievers p0 plus achievers p. claim follows
Proposition 2.1.
Corollaries 4.9 4.11 together Lemma 4.12 prove second main result, Theorem 4.2. encodings (B)(D), matters complicated.
Consider first encodings (B) (D), differ (A)
fact variables. changes precondition clauses. action P p0
precondition, p P , longer get clause {a, a1 , . . . , ak } proof
sketch. Instead, get clause {a, p}. clause, correspondence .
particular, consider case two actions P, action precondition
p action a0 precondition p0 . gives us clauses {a, p}, {a0 , p0 }
clauses {a, p}, {a0 , p} . Now, distinguish achievers
p p0 , problem regard. fact two
clauses share literalwhich dont exploited obtain shorter resolution
refutations? open question; discuss implications little detail
end sub-section.
Consider encoding (C), differs (A) includes direct action
mutexes. invalidates different argument proof Lemma 4.12. still true
that, action pair (a, a0 ) marked mutex P , mutex P.
However, happen (a, a0 ) mutex P due direct interference
a0 , (a, a0 ) mutex P due mutex preconditions, rather direct
interference. Since encoding (C) accounts direct interferences,
mutex appear . result improved resolution complexity
. following proposition proves formally.
Proposition 4.13. Assume use encoding method (C). exist planning task P,
variable domain abstraction P, b < n RC() > RC( ), n
length shortest plan P , encodings b-step plan existence
P P , respectively.
Proof Sketch. construct P, , b specified. key property construction
two actions, getg1 getg2 , needed achieve goal facts
g1 g2 , respectively. precisely, getg1 = ({x}, {g1 , p0 }, {x}) getg2 = ({p, y},
{g2 }, {p}). task constructed, along help actions, way
x, p, p0 pairwise persistently mutex. variable domain abstraction replaces
p0 p, b set 2. action layer directly beneath goal layer, i.e., action
448

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

layer A(1), planning graph marks getg1 getg2 mutex preconditions
mutex. Encoding (C), however, include mutex clause
direct conflict. situation changes abstraction. getg1 adds p instead p0 ,
hence direct conflict delete effect getg2 . consequence,
abstraction two resolution steps suffice: applying getg1 getg2 A(1)
option achieve goals, new mutex clause immediately excludes option.
encoding original task, required mutex must first
derived reasoning preconditions x p.
Note reason get shorter refutation variable domain abstraction turns indirect action mutex (due competing preconditions)
direct interference. so, abstraction exploits knowledge p p0
persistently mutexa fact ignored encoding (C). Hence positive result stated
Proposition 4.13 less related power abstraction power planning
graph mutexes. capture formally. follows, note using
plan length bound, CNF formula per encoding (C) sub-formula CNF
formula per encoding (A), additional clauses (A) inferred it.
Lemma 4.14. Let P planning task. Let variable domain abstraction P.
Let n length shortest plan P , let b < n. Let C
encodings b-step plan existence P per encoding (A) (C), respectively. Let C
encoding b-step plan existence P per encoding (C). Let number
resolution steps required infer C additional mutex clauses appear .
RC(C ) RC(C ) + .
Proof. Denote encoding b-step plan existence P per encoding (A).
have:
(1) preconditions lemma, RC(C ) RC(A ) + : resolution steps,
C turned , hence shortest resolution refutation
construct one C steps longer.
(2) Lemma 4.12, RC(A ) RC(A ).
(3) C sub-formula , hence RC(A ) RC(C ).
Combining observations, have:
RC(C ) RC(A ) +

observation (1)

RC(A ) +
RC(C ) +

observation (2)




observation (3)

finishes proof.
Clearly, proof argument applies combination variable domain
abstraction abstractions. Hence Corollaries 4.9 4.11 together
Lemmas 4.12 4.14 prove third main result, Theorem 4.3. Note latter
result hold variants resolution. claim Lemma 4.14,
449

fiDomshlak, Hoffmann, & Sabharwal

number resolution steps takes derive action mutexes present original
encoding. used resolution refutation. variant resolution
consideration is, say, DPLL tree-like resolution, deriving mutex clause
enoughit must re-derived many times used tree-like resolution
refutation. Hence effective value variants resolution would larger.
Note case DPLL solver learns mutex clauses virtue
wide-spread clause learning technique.
Lemma 4.14 particularly relevant empirical results, SATPLAN04 uses
encoding (C) experiments mostly focus variable domain abstraction.
explicit empirical proof (and proof would difficult come by, requiring
deep analysis SAT solvers search spaces), seems reasonable assume that,
least extent, disappointing results SATPLAN04 due whats proved
Lemma 4.14. abstraction cannot improve resolution complexity beyond effort
required recover indirect action mutexes. Note bound given
lemma rather pessimistic. mutex (a, a0 ) needs recovered case
a0 competing needs P, replacing p0 p results direct
interference incur simplifications. Logistics domain, example,
abstraction happens actions loading package onto airplane two
different irrelevant cities. Since load actions involved redundant
solutions anyway, seems doubtful mutexes play role resolution complexity.
generally, interesting consider upper bounds Lemma 4.14.
many resolution steps take recover indirect action mutexes? general resolution, number steps polynomially bounded, since inference process conducted
planning graph simulated (for related investigation, see Brafman, 2001).
restricted variants resolution, matters complicated. particular interest
behavior DPLL+clause learning, c.f. above. far known formula DPLL+clause learning proofs provably substantially worse general
resolution proofs; would rather surprising planning graph mutexes
first. Also, Rintanen (2008) provides related investigation, showing mutexes
recovered polynomial time particular 2-step lookahead procedure, related
(but identical) clause learning.
Concluding sub-section, let us turn attention encodings (B) (D).
mentioned before, open question whether analogue Theorem 4.2 holds
encoding (B), whether analogue Theorem 4.3 holds encoding (D).
facing two problematic issues:
(I) Fact variables. encoding (B) (D), fact variables addition
action variables used encodings (A) (C).
(II) Mutexes. encoding (C), may happen variable domain abstraction
converts implicit mutex encoding (D) original task explicit one
abstraction.
consider first issue (II). situation exactly encoding (C), regard.
Proposition 4.13 holds stated encoding (D) well; indeed proved using
450

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

exactly example minor adaptations proof arguments.22 Similarly, Lemma 4.14 holds encoding (D), exactly proof argumentsprovided
analogue Lemma 4.12 (and hence analogue Theorem 4.2) holds encoding (B).
Namely, proof arguments Lemma 4.14 remain valid, except need refer
encoding (B) rather (A), accordingly need corresponding version
Lemma 4.12. brings us issue (I).
Variable domain abstraction perceived gluing sets facts together. Recall
example clauses {a, p}, {a0 , p0 } sharing literals, clauses
{a, p}, {a0 , p} sharing literal p; discussed explain
proof Lemma 4.12 work encodings (B) (D). k + 1 facts glued
together, groups k clauses become linked together fashion. question
is:
(*) resolution fruitfully exploit increased linkage?
issue appears related quite intricate properties Graphplan-based
encodings vs. without fact variables. encoding (A), differs encoding
(B) use fact variables, Lemma 4.12 tells us resolution cannot
exploit variable domain abstraction. Now, appears reasonable think adding fact
variables help lot, intuition being:
(**) Whatever one encoding (B), one easily simulate encoding (A).
statement (**) true, answer question (*) no, yes
answer would contradict Lemma 4.12. Hence, initial attempt prove answer,
tried prove statement (**). However, initial investigation indicated
explicitly keeping fact variables (and non-trivial constraints them) around, encoding (B)
might facilitate significantly shorter resolution derivations general, hence statement
(**) might false. Namely, appear families formulas suitably
encoded planning tasks yield exponential separation encodings (A)
(B). true, suggests reasoning presence fact variables might
powerful hence might indeed able exploit linkage gain yielded
variable domain abstraction.
Since purpose paper compare relative power various
Graphplan-based encodings (such (A) (B)), detail progress
towards disproving statement (**). Besides, note that, statement (**) indeed false,
immediate implications answer question (*). definite
answer (*) left open future research.
4.2 Resolution Complexity Become Worse?
answer title sub-section definite yes. four encodings,
abstractions consider may exponentially deteriorate resolution complexity.
Formally, following theorem.
22. include full proof (C) (D) Appendix A.

451

fiDomshlak, Hoffmann, & Sabharwal

Theorem 4.15. Assume use encoding methods (A)(D). exist
infinite sequence planning tasks P(i), abstractions (i) P(i), b(i) < n(i)
RC( (i)) exponential RC((i)) constant independent i, n(i)
length shortest plan P (i), (i) (i) encodings b(i)-step plan
existence P(i) P (i) respectively, (i) consists one of:
(a) adding initial facts;
(b) ignoring preconditions, goals, deletes;
(c) removing fact completely;
(d) variable domain abstraction.
Proof Sketch. idea construct P(i) planning task consists two separate
sub-tasks, whose overall goal achieve goals sub-tasks.
sub-tasks infeasible within given plan length bound b(i). (The
tasks bounds constructed size grows polynomially i.) However,
first sub-task constructed require exponential size resolution refutations,
second allows constant size refutations. abstraction over-approximates easy-torefute sub-task way becomes feasible within b(i) steps, resolution
refutation overall task must rely hard-to-refute sub-task. leads
exponential growth, i, resolution complexity (i), opposed constant resolution complexity (i). single one listed abstractions, feasibility
easy-to-refute sub-task accomplished simple manner, hence proving theorem.
order construct planning tasks whose CNF encodings require exponential size
resolution refutations, resort pigeon hole problem formula PHP(i). well
known resolution proof PHP(i) must size exponential (Haken, 1985).
construct simple pigeon hole planning task PP HP (i) capture problem.
show that, four encoding methods (A)(D), CNF encoding b(i) = 1
either identical PHP(i), transforms PHP(i) variable restrictions. Hence,
Proposition 2.1, resolution refutation must size exponential i. final
construction uses combination two tasks: PP HP (i) serves hard-to-refute
sub-task, PP HP (1) disjoint sets pigeon hole objects serves easy-to-refute
sub-task.
Essentially, Theorem 4.15 states intuitive fact abstractions make bad
choices, approximating away concise reason planning task cannot
solved particular number steps. illustrate significance this, consider
comparison mutex relations. analogue Theorem 4.15 hold
them: adding mutex clause CNF encoding improve resolution complexity.
sense, mutex relations considerably less risky abstractions consider
here.
pigeon hole problem used proof Theorem 4.15 may seem artificial,
indeed contained sub-problem wide-spread domains concerned
transportation. example, Gripper, available time steps serve holes
actions picking/dropping balls pigeons (for related investigation, see
452

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

Hoffmann et al., 2007). seems quite natural planning task may consist two
disconnected parts, one complex one easy prove unsolvable
given number steps. think transporting two packages, one
close many vehicles requires one step bound allows,
one already inside vehicle needs transported along single path road
connections much longer bound (a concrete example latter situation
formalized Hoffmann et al., 2007).
4.3 Note Simplifications
pointed Section 2.4, may actions abstraction obviously
simplified without altering semantics planning task. particular, abstraction
might create duplicate actions (that is, actions identical preconditions effects),
well redundant add effects (that contained respective actions precondition).
turns natural post-abstraction simplification planning task lead
lower resolution complexity.
Proposition 4.16. Assume use encoding methods (A)(D). exist
planning task P, planning task P 0 identical P except either irrelevant
add affect duplicate action removed, b < n RC() > RC(0 ),
n length shortest plan P, 0 encodings b-step plan
existence P P 0 , respectively.
Proof Sketch. show claim duplicate actions, consider task P 0 encoding
pigeon hole problem 3 pigeons 2 holes, actions put pigeon p hole h.
plan length bound 1. point proof works solvable tasks P,
extra action a, whose preconditions two goals achieves third goal,
ensures solvability two steps. three goals, one pigeon,
mutex clauses direct action interference, pair goals
achieved three them. particular, every resolution refutation must resolve
three goal clauses. obtain P adding duplicate action one pigeons
one holes. respective goal clause becomes one literal longer.
refutation must get rid literal, hence necessitating one step. construction
works four encodings.
show claim removal redundant add effects, slightly modify P 0 , replacing
effect new fact x including another action achieves third goal given
precondition x. optimal plan length 3, length bound 2.
refutation must resolve three goal clauses. If, P, give one preconditions
additional add effect, refutations become longer respective goal
clause does. Again, construction works four encodings.
easy modify constructions used proof Proposition 4.16 way
duplicate action, respectively redundancy add effect, arise
outcome variable domain abstraction. Hence, via enabling simplifications, variable
domain abstraction may improve resolution best-case behavior. duplicate actions,
true Edelkamps (2001) pattern database abstraction. open question
453

fiDomshlak, Hoffmann, & Sabharwal

whether improvement may exponential, whether bounded polynomially.
conjecture latter case, least unrestricted resolution.
notable examples proof Proposition 4.16 specifically
constructed include duplicate actions/redundant add effects actions relevant
solving problem form part optimal solution. well-constructed variable
domain abstraction likely happen since abstraction target facts
irrelevant solution length. Consider Logistics domain example.
actions simplifications apply loads/unloads packages to/from locations
cities packages origin destination. actions involved
redundant solutions, seems doubtful simplification affects resolution
complexity. course, simplifications might help SAT solvers anyway. This, however,
observed, least significantly, experiments.

5. Conclusion
Abstractions, used here, power allow proving certain properties within much
smaller state spaces. particular, abstraction preserves length optimal
solution, optimality proved within abstraction. designed novel abstraction method STRIPS planning suitable purpose. Surprisingly,
approach yields little benefits planning-as-satisfiability approach represented SATPLAN, even domains featuring hand-made abstractions exponentially smaller state spaces. Towards explaining this, shown that, many cases,
abstraction method (as well commonly used abstractions) lacks ability introduce shorter resolution refutationsother exploiting mutexes,
enabling certain post-abstraction simplifications. contrast, shown
abstractions may exponentially increase size shortest resolution refutations.
Several questions left open theoretical results. know whether variable domain abstraction improve resolution complexity combination encoding
(B), whether polynomial upper bound improvement variable domain
abstraction bring encoding (D), whether polynomial upper bound
improvement result simplifications. Apart answering questions, importantly remains seen extent results generalize. Bluntly
stated, intuition behind results over-approximations usually result less
constrained formulas harder refute. However, actual technicalities
results depend quite lot detailsof encoding method abstraction
hence largely unclear extent intuitive statement captures reality.
particular: hold encodings planning SAT?
would interesting, e.g., look alternative encodings described Kautz
Selman (1992), Kautz et al. (1996), Kautz Selman (1996), Ernst, Millstein,
Weld (1997). Many encodings based unit clauses initial goal state,
action clauses stating action implies effects preconditions.
structureand lack mechanism planning graph propagates
changessome properties proved herein obvious. Removing goals initial state
facts corresponds directly removing clauses; true preconditions. Removing
fact completely may cases simply correspond removing clauses mention
454

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

fact. Hence, encodings, seems proving results might indeed
comparatively easy. challenging subject may recent developments,
encodings Rintanen et al. (2006) often give substantial speed-ups
novel notions parallelity, encodings Chen et al. (2009) introduce
long-distance mutex relations, encodings Robinson et al. (2008) make use
effective operator splitting factoring methods.
generally: results hold methods employed fields? particular,
hold model-checking, abstraction (e.g., Graf & Sadi, 1997; Clarke
et al., 2003) SAT encodings (e.g., Clarke, Biere, Raimi, & Zhu, 2001; Prasad, Biere,
& Gupta, 2005) highly successful? one example actually obvious
results hold. Gupta Strichman (2005) abstract ignoring clauses CNF
encoding original transition system (the motivation much smaller CNF
formula causes less overhead SAT solver).
ambitiously: define generic framework formal notions declarative
transition systems, CNF encodings, abstractions suitable capture
results, prove generic statements? questions appear worthwhile
research challenges. Indeed, think key contribution work may lie asking
question resolution complexity vs. without abstraction.
practical perspective, see mainly four lines research. First,
important question whether observations carry modified/extended planningas-SAT systems, one Ray Ginsberg (2008) guarantees plan
optimality branching restrictions within single SAT call, rather
calling SAT solver iteratively. Second, remains open explore whether different
abstraction techniquesbased e.g. predicate abstractioncan suitably adapted
planning. Third, important note empirical results entirely negative.
Mips.BDD often substantially improved, even point where, Figure 1,
optimal sequential planner highly competitive strong optimal parallel planner
SATPLAN, highly parallel domain Logistics. direction
may well worth exploring depth. Finally, effective abstraction methods may
exist unsolvable examples, could potentially play crucial role over-subscription
planning (Sanchez & Kambhampati, 2005; Meuleau et al., 2006).

Acknowledgments
thank anonymous reviewers, whose detailed comments helped greatly improve
paper. preliminary version work appeared ICAPS06, 16th International
Conference Automated Planning Scheduling (Hoffmann, Sabharwal, & Domshlak,
2006). work Carmel Domshlak supported Israel Science Foundation (ISF)
Grants 2008100 2009580, well C. Wellner Research Fund. part
work, Jorg Hoffmann employed Max Planck Institute Computer Science,
Saarbrucken, Germany, SAP Research, Karlsruhe, Germany. work Ashish
Sabharwal supported IISI, Cornell University (AFOSR Grant FA9550-04-1-0151),
National Science Foundation (NSF) Expeditions Computing award (Computational
455

fiDomshlak, Hoffmann, & Sabharwal

Sustainability Grant 0832782), NSF IIS award (Grant 0514429), Defense Advanced
Research Projects Agency (DARPA, REAL Grant FA8750-04-2-0216).

Appendix A. Proof Details
Proof Proposition 2.1. Suppose sequence transformations consists ` restrictions, 1 , 2 , . . . , ` . Further, let 0 strengthening transformation replaces
clause | (not necessarily strict) sub-clause clause ;
transformation exists assumptions proposition. Observe
` + 1 transformation steps together convert (not necessarily strict) sub-formula
. show ` + 1 transformation steps individually increase
resolution complexity underlying formula. Without loss generality,
prove fact single restriction transformation generic strengthening
transformation. Since individually shown increase resolution
complexity formula, applied sequence combination, number
times, without increasing resolution complexity. would prove, particular,
resolution complexity sub-formula , implying
resolution complexity (as additional initial clauses
cannot hurt resolution refutation), desired.
start single restriction transformation x y. ease notation,
assume initial formula F = {C1 , C2 , . . . , Cm } resulting simplified
0 }, m0 m. Without loss
formula transformation F 0 = {C10 , C20 , . . . , Cm
0
0
generality, assume Ci equals empty clause {} duplicate
clauses F 0 . Let = (C1 , C2 , . . . , Cm , Cm+1 , . . . , CM = {}) resolution refutation
F smallest possible size; note involves initial clauses resolution
steps. , construct resolution refutation 0 F 0 size larger
. following three steps.
Step 1. Transform = (C1 , . . . , Cm , Cm+1 , . . . , CM = {}), Ci defined
follows. application transformation x results Ci containing True
variable negation, Ci equals True; results Ci containing
False duplicate literals, Ci consists Ci False duplicate literal removed;
otherwise Ci = Ci . Note Ci contain x either True, empty
clause, non-empty (not necessarily strict) sub-clause C. key property
Ci still logical implicant Cj Ck Ci derived resolving
Cj Ck original proof . Ci may necessarily usual resolution
resolvent Cj Ck , next two steps fix.
Step 2. Transform = (C1 , . . . , Cm , Cm+1 , . . . , CM = {}), Ci equals Ci
> defined sequentially, increasing i, follows. Suppose
Ci derived resolving clauses Cj Ck , j < k < i. Assume
without loss generality already defined Cj Ck . Ci equals
True, Ci equals True well; otherwise, one two clauses Cj Ck
equals True, Ci equals clause; otherwise, Cj Ck resolved
together variable Ci resolvent two clauses. key
property here, seen easily considering sequential nature
456

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

transformation, Ci either True (not necessarily proper) subclause Ci ; particular, CM = {}. Further, Ci equal True
either resolution resolvent Cj Ck , equals {} one Cj Ck
{}.
Step 3. Finally, transform 0 simply removing clauses equal True
occur previously clause sequence, stopping sequence soon
first empty clause encountered. construction, , , exactly
clauses 0 clauses. Further, first m0 clauses
0 exactly clauses F 0 0 resolution refutation starting
initial clauses, desired.
consider strengthening transformation 0 , essentially replaces
clause formula sub-clause (thereby strengthening clause). show
applying 0 increase resolution complexity underlying formula.
Again, ease notation, let initial formula F = {C1 , C2 , . . . , Cm } resolution
refutation = (C1 , C2 , . . . , Cm , Cm+1 , . . . , CM = {}) smallest possible size.
argument along lines simpler restriction transformations.
Transform = (C1 , . . . , Cm , Cm+1 , . . . , CM = {}), m, Ci equals
sub-clause Ci 0 maps Ci to, > m, Ci defined sequentially, increasing
i, follows. Suppose Ci derived resolving clauses Cj Ck variable x,
j < k < i. Assume without loss generality already defined Cj
Ck . x present Cj Ck , Ci simply resolution resolvent
two clauses; otherwise, x present Cj , Ci equals Cj ; otherwise x must
present Ck set Ci equal Ck . key property here, seen
easily considering sequential nature transformation, Ci (not
necessarily proper) sub-clause Ci ; particular, CM = {}. Further, Ci either Cj
Ck resolution resolvent two. transform 0 simply removing
clauses occur previously clause sequence. construction,
exactly clauses 0 clauses. Further, first m0 clauses
0 exactly clauses F 0 0 resolution refutation starting initial
clauses, desired.
Proof Lemma 4.6. Let P planning task abstraction abstracts
P G(P) applied. Let , denote propositional encodings P P , respectively,
use either action-only encoding (A) action-fact encoding (B)
. Let U denote set variables variables . Finally,
let variable restriction sets every variable U False. setting,
propositional formula | nothing CNF encoding planning graph P G (P)
(using encoding method, (A) (B), used ). particular,
clauses correspond actions facts P G(P) trivially satisfied
, contain negation variable U , set False . Call
remaining, yet unsatisfied clauses | surviving clauses. argue
surviving clause already present, perhaps stronger weaker form,
itself, showing easier prove | unsatisfiable prove
unsatisfiable.
457

fiDomshlak, Hoffmann, & Sabharwal

First consider encoding (A). conditions (2) (4) Definition 4.5, every surviving
precondition goal clause | corresponding clause itself. Further,
condition (1) concerning facts added action, precondition
goal clause | contains sub-clause corresponding clause . Finally,
surviving mutex clauses | , condition (3), present mutex clause .
observations, follows every surviving clause | contains (possibly
non-strict) sub-clause corresponding clause . Applying Proposition 2.1, obtain
RC() RC( ), finishing proof encoding (A).
consider encoding (B). First, Definition 4.5 P G (P) P G(P)
identical sets vertices, particular fact vertices F (0) same, hence
surviving initial state clause | present initial state clause . Further, precondition clauses binary and, condition (2) Definition 4.5, surviving
precondition clause | present precondition clause . Similarly,
goal clause unit clause and, condition (4), surviving goal clause |
present goal clause . similar vein, surviving mutex clause |
present mutex clause . Finally, surviving effect clause | , condition
(1), contains sub-clause corresponding effect clause | . Hence see
every surviving clause | contains (possibly non-strict) sub-clause corresponding clause . Applying Proposition 2.1 before, obtain RC() RC( ),
finishing proof encoding (B).
Proof Lemma 4.8. Let P planning task abstraction respects
behavior specified lemma applied. show four conditions
Definition 4.5 hold P G (P) P Gred (P). Observe condition (4)
Definition 4.5 trivially holds property (b) . therefore focus showing
V (P G(P)) = V (P G (P)), V (P Gred (P)) = V (P Gred (P)), conditions (1)(3)
Definition 4.5 hold. fact, show P G (P) P Gred (P) set
vertices original (reduced) planning graph, conditions (1) (2) Definition 4.5
would immediately satisfied due properties (c)23 (d) , would
remain would condition (3), saying new mutex clauses added applying .
Hence, task reduced proving following four new properties hold
step 0, 1, . . . , b planning task:
(i) F (t) F (t),
(ii) (t) A(t),
(iii) Ef-mutex (t)|F (t) Ef -mutex (t),

(iv) Ea-mutex
(t)|A(t) Ea-mutex (t).

F (t), A(t), Ef -mutex (t), Ea-mutex (t) denote sets facts, actions (including
noops), fact mutexes, action mutexes generated P step t, -versions
denote corresponding sets P . F (t), Ef-mutex (t)| denotes {(f1 , f2 )
23. one needs add lists shrink applying . However, another argument
shortly require add lists grow either, justifying strict requirement property (c).

458

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings


Ef-mutex (t) | f1 , f2 }, subset Ef-mutex (t) restricted facts . Ea-mutex
(t)|

defined similarly (t).
order prove four properties hold, give inductive argument t,
alternating F (t) Ef -mutex (t) one hand, A(t) Ea-mutex (t)
other. base case = 0, note F (0) F (0) property (a)
Ef-mutex (0)|F (0) Ef -mutex (0) sets empty.
words, goal prove certain facts actions available P
certain step, remain available P . Similarly, two facts actions mutually
compatible P, remain mutually compatible P . seems intuitively justifiable
given properties . following argument formalizes intuition. terms
notation, use pre, del , add specify actions P pre , del , add
specify actions P .
first part inductive step, suppose F (t) F (t) Ef-mutex (t)|F (t)

Ef -mutex (t). show (t) A(t) Ea-mutex
(t)|A(t) Ea-mutex (t), inductively
proving conditions (ii) (iv).
Let A(t). pre (a) F (t) F (t). Further, f, f 0 pre (a) pre(a)
F (t), (f, f 0 ) 6 Ef -mutex (t) Ef-mutex (t)|F (t) hence (f, f 0 ) 6 Ef-mutex (t).
Therefore (t), proving (t) A(t).
let a, a0 A(t) (a, a0 ) 6 Ea-mutex (t). reduced planning graph

(t) due properties
direct mutexes, immediately (a, a0 ) 6 Ea-mutex

(c) (d) , done proving Ea-mutex (t)|A(t) Ea-mutex (t). Otherwise,
general mutexes, several things hold. First, pre (a) pre(a) F (t) F (t),
a0 . Likewise, del (a) del (a) del (a0 ) del (a0 ). Finally,
property (c), add (a) add (a). Hence (c.1) (pre (a) add (a)) del (a0 )
(pre(a)add (a))del (a0 ) = ; last equality holds (a, a0 ) 6 Ea-mutex (t). Similarly,
(c.2) (pre (a0 )add (a0 ))del (a) = . Finally, f pre (a) pre(a) F (t) F (t)
f 0 pre (a0 ) pre(a0 ) F (t) F (t), (f, f 0 ) 6 Ef -mutex (t)
Ef-mutex (t)|F (t) , implies (c.3) (f, f 0 ) 6 Ef-mutex (t). (c.1), (c.2), (c.3),


(a, a0 ) 6 Ea-mutex
(t), proving Ea-mutex
(t)|A(t) Ea-mutex (t).

second part inductive step, suppose (t) A(t) Ea-mutex
(t)|A(t)


Ea-mutex (t). show F (t+1) F (t+1) Ef -mutex (t+1)|F (t+1) Ef -mutex (t+
1), proving conditions (i) (iii).


Let f F (t + 1). f aA(t) add (a) aA (t) add (a). (Recall noop
actions included A(t), need explicitly include F (t) F (t + 1).)
follows f F (t + 1), proving F (t + 1) F (t + 1).
let f, f 0 F (t + 1) (f, f 0 ) 6 Ef -mutex (t + 1). must exist
0
a, A(t) (t) (c.1) f add (a) add (a), (c.2) f 0 add (a0 ) add (a),


(a, a0 ) 6 Ea-mutex (t) Ea-mutex
(t)|A(t) , implies (c.3) (a, a0 ) 6 Ea-mutex
(t).
0


(c.1), (c.2), (c.3), (f, f ) 6 Ef -mutex (t + 1), proving Ef -mutex (t +
1)|F (t+1) Ef -mutex (t + 1).
finishes inductive argument, showing conditions (i)(iv) outlined
hold. earlier reasoning, proves vertices P G(P) P G (P),
well reduced counterparts, (so conditions (1) (2)
Definition 4.5 follow directly properties (c) (d) ) mutex relations
P red (P), restricted facts actions P, subset mutex relations

459

fiDomshlak, Hoffmann, & Sabharwal

reduced mutex relations, respectively, P (so condition (3) Definition 4.5
holds). Hence abstracts planning graph well reduced planning graph
P.
Proof Lemma 4.10. Let abstraction removes p initial facts
add lists given planning task P p appear goal facts
pre del lists. proof Lemma 4.6, let , denote propositional
encodings P P , respectively, use one encodings (A), (B), (C),
(D) . show encodings (A) (C), fact
identical, encodings (B) (D), differ clauses cannot part
resolution proof.
end, use planning graph notation proof Lemma 4.8
begin arguing induction F (t) = F (t) \ {p}, Ef-mutex (t) = Ef -mutex (t) \ {(p, p0 ) |

p0 F (t)}, (t) = A(t), Ea-mutex
(t) = Ea-mutex (t). base case = 0,

F (0) = F (0)\{p} definition , Ef-mutex (t) = Ef -mutex (0)\{(p, p0 ) | p0 F (0)}
sets empty. first part induction, suppose
inductive conditions F Ef -mutex hold time step t. Since p pre list,
implies (t) = A(t) well. Further, since p del list,

Ea-mutex
(t) = Ea-mutex (t). Hence conditions Ea-mutex hold time step
t. second part induction, suppose inductive conditions
Ea-mutex hold time step t. implies F (t + 1) consists F (t + 1) possibly
p. Further, Ef -mutex (t + 1) Ef-mutex (t + 1) far mutexes involving
p concerned. follows conditions F Ef -mutex hold time step + 1,
finishing induction.

summarize, shown every step, sets A, Ea-mutex , Ea-mutex
exactly same, sets F, F Ef -mutex , Ef-mutex facts
pairs facts involving p. words, new actions facts become available mutually excluded planning graph , everything involving p remains
unchanged. Given this, observe four encodings, goal precondition clauses P exactly P p appear goal

pre lists all. Similarly, Ea-mutex
(t) = Ea-mutex (t) Ef-mutex (t) = Ef -mutex (t)

implies action mutexes P , fact mutexes present encoding,
P well. Therefore, encodings (A) (C), = .
Finally, encodings (B) (D), initial state, effect, mutex clauses
get removed applying , i.e., present . However,
clauses mention propositional variables corresponding p,
variables appears one polarity throughout . Namely, initial state clause
{p(0)} clause may contain p positive polarity; effect mutex clauses
contain p time index > 0. that, clauses cannot part
resolution refutation every variable appearing resolution refutation must
eventually resolved away order derive empty clause. follows
respect resolution refutations.
Proof Lemma 4.12. Let P planning task , variable domain abstraction,
applied. combines two persistently mutex facts p p0 single fact p.
brevity, let G denote P G(P). Define G 0 graph obtained unifying p
460

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

p0 fact vertices fact layer G single vertex p layer, similarly
noop(p) noop(p0 ) vertices action layers. Finally, let G denote subgraph
P G(P ) induced vertices G 0 . show G abstracted planning
graph sense similar Definition 4.5.
begin arguing action pair (a, a0 ) mutex P , mutex
P. see this, observe way (a, a0 ) become mutex per requires,
w.l.o.g., P, p del (a) pre(a) p0 pre(a0 ) add (a0 ). Suppose sake
contradiction (a, a0 ) already mutex P. particular, means
p 6 del (a0 ) p mutex fact pre(a0 ). This, however, implies
(noop(p), a0 ) mutex P fact pair (p, p0 ) mutex next layer
P G(P), contradiction p p0 persistently mutex. follows edges
Ea-mutex G subset G.
Since G 0 P initial facts, argument implies actions
facts available layer G 0 available layer P G(P ). particular,
G , construction, exactly set vertices G 0 . Further, since variable
domain abstraction, edges Eadd Epre G 0 G exactly same.
Define , , U, proof Lemma 4.6. | CNF encoding (A)
planning graph G , clauses corresponding actions facts
G trivially satisfied . Call remaining clauses | surviving clauses
before.
observation edges Ea-mutex G G, surviving mutex clauses
| mutex clauses . surviving precondition goal clauses involving
p appear unchanged . Since considering variable domain abstraction,
actions achieving p G precisely actions achieving either p p0 G. Hence,
surviving precondition goal clauses | involving p contain sub-clause
precondition goal clause itself. follows Proposition 2.1 RC()
RC( ).
Proof Proposition 4.13. example planning task, denoted P, works
encoding (C) encoding (D). Let denote variable domain abstraction applied.
example uses following six facts: facts p p0 , glued together ;
goal facts g1 g2 ; helper facts x, y. Based facts, task P defined
follows:
Initial state {p}; Goal {g1 , g2 }
Action set containing five actions:
getx = ({p}, {x}, {p}),
gety = (, {y}, ),
getg1 = ({x}, {g1 , p0 }, {x}),
getg2 = ({p, y}, {g2 }, {p}),
getp = ({p0 }, {p}, {p0 }).
plan length bound 2, makes problem infeasible: shortest (parallel)
plan requires 4 steps: h{getx, gety}, {getg1 }, {getp}, {getg2 }i. Observe pairs
actionsexcept (getg1 , getg2 ) pair involves getydirectly interfere
461

fiDomshlak, Hoffmann, & Sabharwal

therefore mutex. P G(P), get following fact action sets
step 2:
F (0) = {p}, A(0) = {noop(p), getx, gety}
F (1) = {p, x, y}, A(1) = {noop(p), noop(x), noop(y), getx, gety, getg1 , getg2 }
F (2) = {p, x, y, g2 , g1 , p0 }
easy verify, iteratively, that, P G(P): p x mutex F (1); p x
mutex F (2); p p0 mutex F (2); x p0 mutex F (2); mutexes
get F (3), planning graph reaches fixpoint. particular,
getg1 getg2 always (indirectly) mutex preconditions x p
persistently mutex. variable domain abstraction glue p p0 , converting
conflict getg1 getg2 direct interference, thereby allowing shorter
resolution refutation.
Consider encoding (C) P G(P). contains two goal clauses: {getg1 (1)}
{getg2 (1)}. clauses clearly must used resolution refutation formula, possible achieve goal individually within given time bound,
together. Hence, shortest refutation must involve least two steps.
argue shortest refutation achieved abstracted task P
P itself.
P , get fact action sets planning graph, except F (2) =
{p, x, y, g1 , g2 }, i.e., p0 course present, A(0) A(1) contain getp
acts similarly noop(p). corresponding encoding (C) consists exactly
clauses (plus clauses noop(p) mirrored getp), except
get additional clause {getg1 (1), getg2 (1)}. mutex clauses arises
getg1 interferes directly getg2 (rather indirectly incompatible preconditions), getg1 adds p instead p0 , p deleted getg2 . yields
trivial two-step (tree-like) resolution proof P , using two goal clauses mutex
clause (namely, resolve second goal clause mutex clause deriving {getg1 (1)},
resolve clause first goal clause). hand, original
task P, getg1 getg2 marked mutex layer A(1), dont directly
interfere. Therefore, corresponding mutex clause immediately available,
resolution proof takes two steps must reason involve x.
Encoding (D) works similarly, lets us derive new mutex clause discussed
above. goal clauses case simply {g1 (2)} {g2 (2)}. these, using
two corresponding effect clauses, derive two goal clauses encoding (C) two
steps. here, two-step refutation discussed derives empty clause. Thus,
four-step resolution refutation P encoding (D). similarly small
resolution refutation P itself, refutation must, mentioned earlier,
reason x figure getg1 (1) getg2 (1) cannot True.
Proof Theorem 4.15. construct family STRIPS tasks whose CNF encodings
similar pigeon hole problem formula PHP(i). well known
resolution proof PHP(i) must size exponential (Haken, 1985). Concretely,
PHP(i) unsatisfiable formula encoding fact way assign + 1
462

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

pigeons holes pigeon assigned least one hole hole gets
one pigeon. formula i(i + 1) variables xp,h p {1, . . . , + 1}, h
{1, . . . , i}. pigeon p, pigeon clause (xp,1 , xp,2 , . . . , xp,n ), pair
pigeons {p, q} hole h, hole clause {xp,h , xq,h }.
pigeon hole planning task PP HP (i) defined follows. pigeon p,
fact assigned (p). hole h, fact free(h). initial state contains free
facts assigned facts. goal state contains i+1 assigned facts. available
actions (other noops) put(p, h), puts pigeon p free hole h,
h longer remains free. Formally, put(p, h) = ({free(h)}, {assigned (p)}, {free(h)}).
plan length bound b(i) set 1.
Consider one four encoding methods (A)(D), let (i) encoding
PP HP (i). Restrict (i) setting noop variables False; real restrictive
implication terms planning since plan length bound 1 none goal facts
available time step 0. action-only encodings (A) (C), identifying
action variables put(p, h) PHP(i) variables xp,h immediately yields precisely
clauses PHP(i): goal clauses (i) become pigeon clauses PHP(i)
action mutex clauses become hole clauses. action-fact encodings (B) (D),
fix free fact variables time step 0 well assigned fact variables time step 1
True, identify put(p, h) action variables xp,h . yields precisely
clauses PHP(i). follows resolution hardness PHP(i) Proposition 2.1
resolution proof fact planning task PP HP (i) plan
length 1 must require size exponential i.
claim follows planning task P 0 (i) consists combination two
disconnected pigeon hole planning sub-tasks, PP HP (i) PP HP (1), two separate sets
pigeon hole objects. goal P 0 (i) naturally defined follows: put first
set + 1 pigeons first set holes put second set two pigeons
second set holes (which consists single hole). overall CNF encoding
0 (i) P 0 (i) logical conjunction encodings (i) (1) (on disjoint sets
variables) PP HP (i) PP HP (1). Observe 0 (i) proved unsatisfiable
proving unsatisfiability either two pigeon hole problems. particular,
constant size resolution refutation 0 (i) involves refuting (1) component.
hand, argue listed abstractions make one-hole
component P 0 (i) trivially satisfiable, resolution refutation abstracted
task must resort proof unsatisfiability i-hole component (i) P 0 (i),
shown requires exponential size. Hence single example P 0 (i) serves show
claim combinations abstraction method CNF encoding.
easily verified PP HP (1) becomes solvable ignoring precondition
free(1) put(1, 1) put(2, 1): put pigeons single hole.
happens ignoring delete effect free(1) put(1, 1) put(2, 1).When
ignoring goal assigned (2), inserting assigned (2) initial state,
completely removing assigned (2), one-hole component P 0 (i) requires assign
one pigeon, course possible. Finally, variable domain abstraction, note
assigned (1) assigned (2) persistently mutex PP HP (1) actions
achieving put(1, 1) put(2, 1), respectively. According Definition 2.2,
hence replace assigned (2) assigned (1). resulting planning task,
463

fiDomshlak, Hoffmann, & Sabharwal

single goal assigned (1) achieved 1 step by, example, put(1, 1) action.
concludes argument.
Proof Proposition 4.16. first consider removal duplicate actions. example planning task, denoted P 0 , works four encodings; P 0 defined follows:
Fact set {r1 , r2 , g1 , g2 , g3 }
Initial state {r1 , r2 }; Goal {g1 , g2 , g3 }
Action set containing seven actions:
1 1 = ({r1 }, {g1 }, {r1 }),
1 2 = ({r1 }, {g2 }, {r1 }),
1 3 = ({r1 }, {g3 }, {r1 }),
2 1 = ({r2 }, {g1 }, {r2 }),
2 2 = ({r2 }, {g2 }, {r2 }),
2 3 = ({r2 }, {g3 }, {r2 }),
help = ({g1 , g2 }, {g3 }, ).
planning task, actions applicable initial state consume one
two resources r1 r2 . actions achieves one goals, pair
goals reached, three them. solution perform two steps,
second help action serves accomplish g3 . set plan length
bound 1.
planning graph P G(P 0 ) step 1 mutex relations direct
mutexes actions competing resource. Hence, encoding (A) identical
encoding (C), encoding (B) identical encoding (D). properties clearly
hold planning task P P 0 except additional action 1 10
identical 1 1.
Consider encoding (A) P 0 . goal clauses {1 1(0), 2 1(0)}, {1 2(0), 2 2(0)},
{1 3(0), 2 3(0)}. clauses mutex clauses form {i j, k}.
difficult verify shortest resolution refutation involves 12 steps. One
derivation proceeds via deriving {2 2(0), 2 1(0)}, {2 3(0), 2 1(0)}, {2 1(0)}, {1 2(0)},
{1 3(0)}, {}; derived, sequence, 2 steps involving resolution
one mutex clause. P, thing changes clause
{1 1(0), 1 10 (0), 2 1(0)} instead {1 1(0), 2 1(0)}, plus additional mutex clauses. Now,
obviously every resolution refutation must resolve three goal clauses. end
empty clause, hence additionally need get rid literal 1 10 (0). Clearly,
way resolve literal away additional step involving
one new mutex clauses. Hence shortest possible resolution refutation
13 steps.
encoding (B), resolution proofs first need make three steps resolving goal
clauses {g1 (1)}, {g2 (1)}, {g3 (1)} respective effect clauses {g1 (1), 1 1(0), 2 1(0)},
{g2 (1), 1 2(0), 2 2(0)}, {g3 (1), 1 3(0), 2 3(0)}; thereafter, matters
before.
show claim removal redundant add effects, slightly modify example,
define P 0 follows:
464

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

Fact set {r1 , r2 , g1 , g2 , g3 , x}
Initial state {r1 , r2 }; Goal {g1 , g2 , g3 }
Action set containing eight actions:
1 1 = ({r1 }, {g1 }, {r1 }),
1 2 = ({r1 }, {g2 }, {r1 }),
1 3 = ({r1 }, {g3 }, {r1 }),
2 1 = ({r2 }, {g1 }, {r2 }),
2 2 = ({r2 }, {g2 }, {r2 }),
2 3 = ({r2 }, {g3 }, {r2 }),
help1 = ({g1 , g2 }, {x}, ),
help2 = ({x}, {g3 }, ).
task, single help action replaced two help actions need
applied consecutively. set plan length bound 2. before, planning graph
P G(P 0 ) mutex relations direct mutexes actions competing
resource; encodings (A)/(C) (B)/(D) respectively identical.
properties clearly hold planning task P P 0 except help1
additional add effect g1 .
Consider encoding (A) P 0 . goal clauses {1 1(1), 2 1(1), noop(g1 )(1)}, {1 2(1),
2 2(1), noop(g2 )(1)}, {1 3(1), 2 3(1), noop(g3 )(1)}. Refuting involves showing
three goals cannot achieved step 1, step 0, combination
two. refutation needs resolve three clauses. before, P get
additional literal first clause, {1 1(1), 2 1(1), help1 , noop(g1 )(1)}.
Clearly, getting rid additional literal involves least one resolution step.
encoding (B), matters essentially except first need resolve goal
fact clauses respective effect clauses.

References
Ball, T., Majumdar, R., Millstein, T., & Rajamani, S. (2001). Automatic predicate abstraction C programs. PLDI2001: Programming Language Design Implementation, pp. 203213.
Beame, P., Kautz, H., & Sabharwal, A. (2004). Towards understanding harnessing
potential clause learning. Journal Artificial Intelligence Research, 22, 319351.
Beck, C., Hansen, E., Nebel, B., & Rintanen, J. (Eds.). (2008). Proceedings 18th
International Conference Automated Planning Scheduling (ICAPS-08). AAAI
Press.
Blum, A., & Furst, M. (1997). Fast planning planning graph analysis. Artificial
Intelligence, 90 (1-2), 279298.
Blum, A. L., & Furst, M. L. (1995). Fast planning planning graph analysis.
Mellish, S. (Ed.), Proceedings 14th International Joint Conference Artificial
Intelligence (IJCAI-95), pp. 16361642, Montreal, Canada. Morgan Kaufmann.
465

fiDomshlak, Hoffmann, & Sabharwal

Boddy, M., Fox, M., & Thiebaux, S. (Eds.). (2007). Proceedings 17th International
Conference Automated Planning Scheduling (ICAPS-07). AAAI Press.
Bonet, B., & Geffner, H. (2001). Planning heuristic search. Artificial Intelligence, 129 (1
2), 533.
Bonet, B., & Geffner, H. (2008). Heuristics planning penalties rewards formulated logic computed circuits. Artificial Intelligence, 172 (12-13),
15791604.
Brafman, R. (2001). reachability, relevance, resolution planning satisfiability approach. Journal Artificial Intelligence Research, 14, 128.
Chaki, S., Clarke, E., Groce, A., Jha, S., & Veith, H. (2003). Modular verification software
components C. ICSE2003: Int. Conf. Software Engineering, pp. 385395.
Chen, Y., Huang, R., Xing, Z., & Zhang, W. (2009). Long-distance mutual exclusion
planning. Artificial Intelligence, 173 (2), 365391.
Clarke, E. M., Biere, A., Raimi, R., & Zhu, Y. (2001). Bounded model checking using
satisfiability solving. Formal Methods System Design, 19 (1), 734.
Clarke, E. M., Grumberg, O., Jha, S., Lu, Y., & Veith, H. (2003). Counterexample-guided
abstraction refinement symbolic model checking. Journal Association
Computing Machinery, 50 (5), 752794.
Davis, M., Logemann, G., & Loveland, D. (1962). machine program theorem proving.
Communications ACM, 5 (7), 394397.
Davis, M., & Putnam, H. (1960). computing procedure quantification theory. Journal
Association Computing Machinery, 7 (3), 201215.
Edelkamp, S. (2001). Planning pattern databases. Cesta, A., & Borrajo, D. (Eds.),
Recent Advances AI Planning. 6th European Conference Planning (ECP01),
pp. 1324, Toledo, Spain. Springer-Verlag.
Edelkamp, S. (2003). Promela planning. Ball, T., & Rajamani, S. (Eds.), Proceedings
10th International SPIN Workshop Model Checking Software (SPIN-03),
pp. 197212, Portland, OR. Springer-Verlag.
Edelkamp, S., & Helmert, M. (1999). Exhibiting knowledge planning problems minimize state encoding length. Biundo, S., & Fox, M. (Eds.), Recent Advances AI
Planning. 5th European Conference Planning (ECP99), Lecture Notes Artificial
Intelligence, pp. 135147, Durham, UK. Springer-Verlag.
Ernst, M., Millstein, T., & Weld, D. (1997). Automatic sat-compilation planning problems. Pollack, M. (Ed.), Proceedings 15th International Joint Conference
Artificial Intelligence (IJCAI-97), pp. 11691176, Nagoya, Japan. Morgan Kaufmann.
Fikes, R. E., & Nilsson, N. J. (1971). STRIPS: new approach application theorem
proving problem solving. Artificial Intelligence, 2 (34), 198208.
Gerevini, A., Saetti, A., & Serina, I. (2003). Planning stochastic local search
temporal action graphs. Journal Artificial Intelligence Research, 20, 239290.
466

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

Graf, S., & Sadi, H. (1997). Construction abstract state graphs PVS. CAV1997:
Computer Aided Verification, pp. 7283.
Gupta, A., & Strichman, O. (2005). Abstraction refinement bounded model checking.
Etessami, K., & Rajamani, S. (Eds.), Proceedings 17th International Conference
Computer Aided Verification (CAV05), Lecture Notes Computer Science, pp.
112124, Edinburgh, UK. Springer-Verlag.
Haken, A. (1985). intractability resolution. Theoretical Computer Science, 39, 297
308.
Haslum, P., & Geffner, H. (2000). Admissible heuristics optimal planning. Chien, S.,
Kambhampati, R., & Knoblock, C. (Eds.), Proceedings 5th International Conference Artificial Intelligence Planning Systems (AIPS-00), pp. 140149, Breckenridge, CO. AAAI Press, Menlo Park.
Haslum, P., Botea, A., Helmert, M., Bonet, B., & Koenig, S. (2007). Domain-independent
construction pattern database heuristics cost-optimal planning. Proceedings
Twenty-Second AAAI Conference Artificial Intelligence (AAAI-2007), pp.
10071012. AAAI Press.
Helmert, M., & Mattmuller, R. (2008). Accuracy admissible heuristic functions selected planning domains. Proceedings 23rd AAAI Conference Artificial
Intelligence, pp. 938943, Chicago, IL. AAAI Press.
Helmert, M., Haslum, P., & Hoffmann, J. (2007). Flexible abstraction heuristics optimal
sequential planning.. Boddy et al. (Boddy, Fox, & Thiebaux, 2007), pp. 176183.
Henzinger, T., Jhala, R., Majumdar, R., & McMillan, K. (2004). Abstractions proofs.
POPL2004: Principles Programming Languages, pp. 232244.
Hernadvolgyi, I., & Holte, R. (1999). PSVN: vector representation production systems.
Tech. rep. 1999-07, University Ottawa.
Hoffmann, J., & Edelkamp, S. (2005). deterministic part IPC-4: overview. Journal
Artificial Intelligence Research, 24, 519579.
Hoffmann, J., & Nebel, B. (2001). planning system: Fast plan generation
heuristic search. Journal Artificial Intelligence Research, 14, 253302.
Hoffmann, J. (2005). ignoring delete lists works: Local search topology planning
benchmarks. Journal Artificial Intelligence Research, 24, 685758.
Hoffmann, J., Gomes, C., & Selman, B. (2007). Structure problem hardness: Goal asymmetry dpll proofs sat-based planning. Logical Methods Computer Science,
3 (1:6).
Hoffmann, J., Sabharwal, A., & Domshlak, C. (2006). Friends foes? AI planning
perspective abstraction search.. Long, & Smith (Long & Smith, 2006), pp.
294303.
Katz, M., & Domshlak, C. (2008). Structural pattern heuristics via fork decomposition..
Beck et al. (Beck, Hansen, Nebel, & Rintanen, 2008), pp. 182189.
467

fiDomshlak, Hoffmann, & Sabharwal

Kautz, H., & Selman, B. (1999). Unifying SAT-based graph-based planning. Pollack, M. (Ed.), Proceedings 16th International Joint Conference Artificial
Intelligence (IJCAI-99), pp. 318325, Stockholm, Sweden. Morgan Kaufmann.
Kautz, H. (2004). SATPLAN04: Planning satisfiability. Edelkamp, S., Hoffmann,
J., Littman, M., & Younes, H. (Eds.), Proceedings 4th International Planning
Competition (IPC-04), Whistler, BC, Canada.
Kautz, H., Selman, B., & Hoffmann, J. (2006). SATPLAN: Planning satisfiability.
Gerevini, A., Dimopoulos, Y., Haslum, P., Saetti, A., Bonet, B., & Givan, B. (Eds.),
Proceedings 5th International Planning Competition (IPC-06), Ambleside, UK.
Kautz, H. A., McAllester, D., & Selman, B. (1996). Encoding plans propositional logic.
Aiello, L. C., Doyle, J., & Shapiro, S. (Eds.), Principles Knowledge Representation
Reasoning: Proceedings 5th International Conference (KR-96), pp. 374384,
Cambridge, MA. Morgan Kaufmann.
Kautz, H. A., & Selman, B. (1992). Planning satisfiability. Neumann, B. (Ed.),
Proceedings 10th European Conference Artificial Intelligence (ECAI-92),
pp. 359363, Vienna, Austria. Wiley.
Kautz, H. A., & Selman, B. (1996). Pushing envelope: Planning, propositional logic,
stochastic search. Proceedings 13th National Conference American
Association Artificial Intelligence (AAAI-96), pp. 11941201, Portland, OR. MIT
Press.
Knoblock, C. A. (1990). Learning abstraction hierarchies problem solving. Proceedings
8th National Conference American Association Artificial Intelligence
(AAAI-90), pp. 923928, Boston, MA. MIT Press.
Koehler, J., Nebel, B., Hoffmann, J., & Dimopoulos, Y. (1997). Extending planning graphs
ADL subset.. Steel, & Alami (Steel & Alami, 1997), pp. 273285.
Koehler, J., & Hoffmann, J. (2000). reasonable forced goal orderings use
agenda-driven planning algorithm. Journal Artificial Intelligence Research,
12, 338386.
Long, D., Kautz, H. A., Selman, B., Bonet, B., Geffner, H., Koehler, J., Brenner, M.,
Hoffmann, J., Rittinger, F., Anderson, C. R., Weld, D. S., Smith, D. E., & Fox, M.
(2000). aips-98 planning competition. AI Magazine, 21 (2), 1333.
Long, D., & Smith, S. (Eds.)., ICAPS-06 (2006). Proceedings 16th International Conference Automated Planning Scheduling (ICAPS-06), Ambleside, UK. Morgan
Kaufmann.
McDermott, D. (1999). Using regression-match graphs control search planning. Artificial Intelligence, 109 (1-2), 111159.
Meuleau, N., Brafman, R., & Benazera, E. (2006). Stochastic over-subscription planning
using hierarchies MDPs.. Long, & Smith (Long & Smith, 2006), pp. 121130.
Nebel, B., Dimopoulos, Y., & Koehler, J. (1997). Ignoring irrelevant facts operators
plan generation.. Steel, & Alami (Steel & Alami, 1997), pp. 338350.
468

fiFriends Foes? Planning Satisfiability Abstract CNF Encodings

Prasad, M. R., Biere, A., & Gupta, A. (2005). survey recent advances sat-based
formal verification. International Journal Software Tools Technlogy Transfer,
7 (2), 156173.
Ray, K., & Ginsberg, M. L. (2008). complexity optimal planning efficient
method finding solutions.. Beck et al. (Beck et al., 2008), pp. 280287.
Rintanen, J. (2004). Evaluation strategies planning satisfiability. Saitta, L. (Ed.),
Proceedings 16th European Conference Artificial Intelligence (ECAI-04), pp.
682687, Valencia, Spain. Wiley.
Rintanen, J. (2008). Planning graphs propositional clause-learning. Brewka, G., &
Doherty, P. (Eds.), Principles Knowledge Representation Reasoning: Proceedings 11th International Conference (KR-08), pp. 535543, Sydney, Australia.
AAAI Press.
Rintanen, J., Heljanko, K., & Niemela, I. (2006). Planning satisfiability: parallel plans
algorithms plan search, artificial intelligence. Artificial Intelligence, 170 (12-13),
10311080.
Robinson, J. A. (1965). machine oriented logic based resolution principle. Journal
Association Computing Machinery, 12 (1), 2341.
Robinson, N., Gretton, C., Pham, D.-N., & Sattar, A. (2008). compact efficient sat
encoding planning.. Beck et al. (Beck et al., 2008), pp. 296303.
Sacerdoti, E. (1973). Planning hierarchy abstraction spaces. Proceedings
3rd International Joint Conference Artificial Intelligence (IJCAI-73), pp. 412422,
Stanford, CA. William Kaufmann.
Sanchez, R., & Kambhampati, S. (2005). Planning graph heuristics selecting objectives over-subscription planning problems. Biundo, S., Myers, K., & Rajan, K.
(Eds.), Proceedings 15th International Conference Automated Planning
Scheduling (ICAPS-05), pp. 192201, Monterey, CA, USA. Morgan Kaufmann.
Steel, S., & Alami, R. (Eds.). (1997). Recent Advances AI Planning. 4th European Conference Planning (ECP97), Vol. 1348 Lecture Notes Artificial Intelligence,
Toulouse, France. Springer-Verlag.
Streeter, M., & Smith, S. (2007). Using decision procedures efficiently optimization..
Boddy et al. (Boddy et al., 2007), pp. 312319.

469


