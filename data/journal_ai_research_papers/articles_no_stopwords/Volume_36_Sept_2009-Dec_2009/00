Journal Artificial Intelligence Research 36 (2009) 169

Submitted 04/09; published 10/09

DL-Lite Family Relations
Alessandro Artale
Diego Calvanese

artale@inf.unibz.it
calvanese@inf.unibz.it

KRDB Research Centre
Free University Bozen-Bolzano
Piazza Domenicani, 3 I-39100 Bolzano, Italy

Roman Kontchakov
Michael Zakharyaschev

roman@dcs.bbk.ac.uk
michael@dcs.bbk.ac.uk

Department Computer Science Information Systems
Birkbeck College
Malet Street, London WC1E 7HX, U.K.

Abstract
recently introduced series description logics common moniker DLLite attracted attention description logic semantic web communities due
low computational complexity inference, one hand, ability represent
conceptual modeling formalisms, other. main aim article carry
thorough systematic investigation inference extensions original DL-Lite
logics along five axes: (i) adding Boolean connectives (ii) number restrictions
concept constructs, (iii) allowing role hierarchies, (iv) allowing role disjointness, symmetry,
asymmetry, reflexivity, irreflexivity transitivity constraints, (v) adopting dropping unique name assumption. analyze combined complexity satisfiability
resulting logics, well data complexity instance checking answering
positive existential queries. approach based embedding DL-Lite logics suitable fragments one-variable first-order logic, provides useful insights
properties and, particular, computational behavior.

1. Introduction
Description Logic (cf. Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003
references therein) family knowledge representation formalisms developed
past three decades and, recent years, widely used various application areas as:
conceptual modeling (Bergamaschi & Sartori, 1992; Calvanese et al., 1998b, 1999;
McGuinness & Wright, 1998; Franconi & Ng, 2000; Borgida & Brachman, 2003; Berardi, Calvanese, & De Giacomo, 2005; Artale et al., 1996, 2007, 2007b),
information data integration (Beeri, Levy, & Rousset, 1997; Levy & Rousset,
1998; Goasdoue, Lattes, & Rousset, 2000; Calvanese et al., 1998a, 2002a, 2002b,
2008; Noy, 2004; Meyer, Lee, & Booth, 2005),
ontology-based data access (Dolby et al., 2008; Poggi et al., 2008a; Heymans et al.,
2008),
Semantic Web (Heflin & Hendler, 2001; Horrocks, Patel-Schneider, & van Harmelen, 2003).
c
2009
AI Access Foundation. rights reserved.

fiArtale, Calvanese, Kontchakov & Zakharyaschev

Description logics (DLs, short) underlie standard Web Ontology Language OWL,1
process standardized W3C second edition, OWL 2.
widespread use DLs flexible modeling languages stems fact that,
similarly traditional modeling formalisms, structure domain interest
classes (or concepts, DL parlance) objects common properties. Properties
associated objects means binary relationships (or roles) objects.
Constraints available standard DLs resemble used conceptual modeling
formalisms structuring information: is-a hierarchies (i.e., inclusions) disjointness
concepts roles, domain range constraints roles, mandatory participation
roles, functionality general numeric restrictions roles, covering within concept
hierarchies, etc. DL knowledge base (KB), constraints combined form
TBox asserting intensional knowledge, ABox collects extensional knowledge
individual objects, whether object instance concept, two objects
connected role. standard reasoning services DL KB include checking
consistency (or satisfiability), instance checking (whether certain individual instance
concept), logic entailment (whether certain constraint logically implied
KB). sophisticated services emerging support modular development
ontologies checking, example, whether one ontology conservative extension
another respect certain vocabulary (see, e.g., Ghilardi, Lutz, & Wolter, 2006;
Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008; Kontchakov, Wolter, & Zakharyaschev,
2008; Kontchakov, Pulina, Sattler, Schneider, Selmer, Wolter, & Zakharyaschev, 2009).
Description logics recently used provide access large amounts data
high-level conceptual interface, relevance data integration
ontology-based data access. setting, TBox constitutes conceptual, high-level
view information managed system, ABox physically stored
relational database accessed using standard relational database technology (Poggi
et al., 2008a; Calvanese et al., 2008). fundamental inference service case answering queries ABox constraints TBox taken account. kind
queries often considered first-order conjunctive queries,
correspond commonly used Select-Project-Join SQL queries. key properties
approach viable practice (i) efficiency query evaluation,
ideal target traditional database query processing, (ii) query evaluation
done leveraging relational technology already used storing data.
objectives mind, series description logicsthe DL-Lite familyhas
recently proposed investigated Calvanese, De Giacomo, Lembo, Lenzerini,
Rosati (2005, 2006, 2008a), later extended Artale, Calvanese, Kontchakov,
Zakharyaschev (2007a), Poggi, Lembo, Calvanese, De Giacomo, Lenzerini, Rosati
(2008a). logics family meet requirements and, time,
capable representing many important types constraints used conceptual modeling.
particular, inference various DL-Lite logics done efficiently size
data (data complexity) overall size KB (combined complexity):
shown KB satisfiability logics polynomial combined complexity,
answering queries AC0 data complexitywhich, roughly, means that, given
1. http://www.w3.org/2007/OWL/

2

fiThe DL-Lite Family Relations

conjunctive query KB, query TBox rewritten (independently
ABox) union conjunctive queries ABox alone. (It emphasized
data complexity measure important application context DL-Lite
logics, since one reasonably assume size data largely dominates size
TBox.) Query rewriting techniques implemented various systems
QuOnto2 (Acciarri, Calvanese, De Giacomo, Lembo, Lenzerini, Palmieri, & Rosati, 2005;
Poggi, Rodriguez, & Ruzzi, 2008b), ROWLKit (Corona, Ruzzi, & Savo, 2009), Owlgres
(Stocker & Smith, 2008) REQUIEM (Perez-Urbina, Motik, & Horrocks, 2009).
demonstrated (Kontchakov et al., 2008) developing, analyzing re-using
DL-Lite ontologies (TBoxes) supported efficient tools capable checking various
types entailment ontologies respect given vocabularies, particular,
minimal module extraction tools (Kontchakov et al., 2009)which yet exist
richer languages.
significance DL-Lite family testified fact forms basis
OWL 2 QL, one three profiles OWL 2.3 OWL 2 profiles fragments
full OWL 2 language designed standardized specific application
requirements. According (the current version of) official W3C profiles document,
purpose OWL 2 QL language choice applications use large
amounts data query answering important reasoning task.
common denominator DL-Lite logics constructed far follows: (i) quantification roles inverses qualified (in words, concepts
form R.C must C = >) (ii) TBox axioms concept inclusions cannot represent kind disjunctive information (say, two concepts cover whole
domain). DL-Lite-related dialects designedwith aim capturing
conceptual modeling constraints, somewhat ad hoc mannerby extending
core language number constructs global functionality constraints,
role inclusions restricted Boolean operators concepts (see Section 4 details).
Although attempts made (Calvanese et al., 2006; Artale et al., 2007a;
Kontchakov & Zakharyaschev, 2008) put original DL-Lite logics general
perspective investigate extensions variety DL constructs required
conceptual modeling, resulting picture still remains rather fragmentary far
comprehensive. systematic investigation DL-Lite family relatives become
even urgent challenging view choice constructs included
specification OWL 2 QL profile4 (in particular, OWL make
unique name assumption, UNA, usually adopted DL-Lite, uses equalities
inequalities object names instead).
main aim article fill gap provide thorough comprehensive understanding interaction various DL-Lite constructs impact
computational complexity reasoning. achieve goal, consider spectrum
logics, classified according five mutually orthogonal features:
(1) presence absence role inclusions;
2. http://www.dis.uniroma1.it/quonto/
3. http://www.w3.org/TR/owl2-profiles/
4. http://www.w3.org/TR/owl2-profiles/#OWL_2_QL

3

fiArtale, Calvanese, Kontchakov & Zakharyaschev

(2) form allowed concept inclusions, consider four classes, called core,
Krom, Horn, Bool, exhibit different computational properties;
(3) form allowed numeric constraints, ranging none, global functionality
constraints only, arbitrary number restrictions;
(4) presence absence unique name assumption (and equalities inequalities object names, assumption dropped);
(5) presence absence standard role constraints disjointness, symmetry,
asymmetry, reflexivity, irreflexivity, transitivity.
resulting cases, investigate combined data complexity KB satisfiability instance checking, well data complexity query answering.
obtained tight complexity results summarized Section 3.4 (Table 2 Remark 3.1).
already mentioned, original motivation distinguishing feature logics
DL-Lite family lite-ness sense low computational complexity
reasoning tasks (query answering AC0 data complexity tractable KB satisfiability
combined complexity). broader perspective take here, logics
meet requirement, particular, Krom Bool concept inclusions.5 However,
identify another distinguishing feature regarded natural logic-based
characterization DL-Lite family: embeddability one-variable fragment firstorder logic without equality function symbols. allows us relate complexity
DL-Lite logics complexity corresponding fragments first-order logic, thus
obtain deep insight underlying logical properties DL-Lite variant.
example, upper complexity bounds established follow embedding
well-known results classical decision problem (see, e.g., Borger, Gradel, & Gurevich,
1997) descriptive complexity (see, e.g., Immerman, 1999).
One interesting findings article number restrictions, even
expressed locally, instead global role functionality, added original DL-Lite
logics (under UNA without role inclusions) free, is, without changing
computational complexity. first-order approach shows cases
extend DL-Lite logics role constraints mentioned above, keeping
complexity. gives framework analyze effect adopting dropping
UNA using (in)equalities object names. example, observe
equality allowed language DL-Lite (which makes sense without UNA)
query answering becomes LogSpace-complete data complexity, therefore
first-order rewritable. turns dropping UNA results P-hardness
reasoning (for combined data complexity) presence functionality constraints (NLogSpace-hardness shown Calvanese et al., 2008), NP-hardness
arbitrary number restrictions allowed.
Another interesting finding dramatic impact role inclusions, combined
number restrictions (or even functionality constraints), computational complexity reasoning. already observed Calvanese et al. (2006), combination increases data complexity instance checking membership LogSpace
5. Note, way, logics Bool concept inclusions turn quite useful conceptual
modeling reasonably manageable computationally (Kontchakov et al., 2008).

4

fiThe DL-Lite Family Relations

NLogSpace-hardness. show situation actually even worse: data
complexity, instance checking turns P-complete case core Horn
logics coNP-complete case Krom Bool logics; moreover, KB satisfiability,
NLogSpace-complete combined complexity simplest core casei.e., efficiently tractable, role inclusions number restrictions used separatelybecomes
ExpTime-completei.e., provably intractable, used together.
retain role inclusions functionality constraints language keep
complexity within required limits, Poggi et al. (2008a) introduced another DL-Lite
dialect, called DL-LiteA , restricts interaction role inclusions functionality constraints. extend result showing DL-Lite logics
limited interaction role inclusions number restrictions still embedded one-variable fragment first-order logic, exhibit behavior
fragments role inclusions number restrictions.
article structured following way. Section 2, introduce logics
extended DL-Lite family illustrate features conceptual modeling formalisms.
Section 3, discuss reasoning services complexity measures analyzed
follows, give overview obtained complexity results. Section 4,
place introduced DL-Lite logics context original DL-Lite family,
discuss relationship OWL 2. Section 5, study combined complexity
KB satisfiability instance checking, Section 6, consider data complexity
problems. Section 7, study data complexity query answering.
Section 8, analyze impact dropping UNA adding (in)equalities
object names complexity reasoning. Section 9 concludes article.

2. Extended DL-Lite Family Description Logics
Description Logic (Baader et al., 2003) family logics studied
used knowledge representation reasoning since 1980s. DLs, elements
domain interest structured concepts (unary predicates), properties
specified means roles (binary predicates). Complex concept role expressions
(or simply concepts roles) constructed, starting set concept role
names, applying suitable constructs, set available constructs depends
specific description logic. Concepts roles used knowledge base
assert knowledge, intensional level, so-called TBox (T terminological),
extensional level, so-called ABox (A assertional). TBox typically
consists set axioms stating inclusion concepts roles. ABox, one
assert membership objects (i.e., constants) concepts, pair objects
connected role. DLs supported reasoning services, satisfiability checking
query answering, rely logic-based semantics.
2.1 Syntax Semantics Logics DL-Lite Family
introduce (extended) DL-Lite family description logics, initially
proposed aim capturing typical conceptual modeling formalisms, UML
class diagrams ER models (see Section 2.2 details), maintaining good computational properties standard DL reasoning tasks (Calvanese et al., 2005). begin
5

fiArtale, Calvanese, Kontchakov & Zakharyaschev

defining logic DL-LiteHN
bool , regarded supremum original
DL-Lite family (Calvanese et al., 2005, 2006, 2007b) lattice description logics.
HN
DL-LiteHN
bool . language DL-Litebool contains object names a0 , a1 , . . . , concept names
A0 , A1 , . . . , role names P0 , P1 , . . . . Complex roles R concepts C language
defined follows:

Pk ,

R

::=

Pk

|

B

::=



|

Ak

|

q R,

C

::=

B

|

C

|

C1 u C2 ,

q positive integer. concepts form B called basic.
DL-LiteHN
bool TBox, , finite set concept role inclusion axioms (or simply
concept role inclusions) form:
C1 v C2



R1 v R2 ,

ABox, A, finite set assertions form:
Ak (ai ),

Ak (ai ),

Pk (ai , aj )



Pk (ai , aj ).

Taken together, constitute DL-LiteHN
bool knowledge base K = (T , A).
following, denote role(K) set role names occurring A, role (K)
set {Pk , Pk | Pk role(K)}, ob(A) set object names A. role R,
set:
(
Pk , R = Pk ,
inv(R) =
Pk , R = Pk .
usual description logic, interpretation, = (I , ), consists nonempty
domain interpretation function assigns object name ai element
aIi , concept name Ak subset AIk domain, role name
Pk binary relation PkI domain. Unless otherwise stated, adopt
unique name assumption (UNA):
aIi 6= aIj



6= j.

(UNA)

However, shall always indicate results depend UNA
not, depend assumption, discuss consequences
dropping (see Sections 4 8).
role concept constructs interpreted standard way:
(Pk )I = {(y, x) | (x, y) PkI },






( q R)

= ,


= x | ]{y | (x, y) RI } q ,

(C)I = \ C ,


(C1 u C2 )

=

C1I



(inverse role)
(the empty set)
(at least q R-successors)
(not C)

C2I ,

(both C1 C2 )

6

fiThe DL-Lite Family Relations

]X denotes cardinality X. use standard abbreviations
C1 C2 = (C1 u C2 ),

> = ,

R = ( 1 R),

q R = ( q + 1 R).

Concepts form q R q R called number restrictions, form
R called existential concepts.
satisfaction relation |= standard:
|= C1 v C2

iff

C1I C2I ,

|= R1 v R2

iff

R1I R2I ,

|= Ak (ai )

iff aIi AIk ,

|= Pk (ai , aj )

iff

(aIi , aIj ) PkI ,

|= Ak (ai )

iff aIi
/ AIk ,

|= Pk (ai , aj )

iff

(aIi , aIj )
/ PkI .

knowledge base K = (T , A) said satisfiable (or consistent) interpretation, I, satisfying members A. case write |= K (as well
|= |= A) say model K (and A).
languages DL-Lite family investigate article obtained restricting language DL-LiteHN
bool along three axes: (i) Boolean operators (bool )
concepts, (ii) number restrictions (N ) (iii) role inclusions, hierarchies (H).
Similarly classical logic, adopt following definitions. DL-LiteHN
bool TBox
called Krom TBox 6 concept inclusions restricted to:
B1 v B2 ,

B1 v B2



B1 v B2

(Krom)

(here Bi B basic concepts). called Horn TBox
concept inclusions restricted to:
l
Bk v B
(Horn)
k

(by definition, empty conjunction >). Finally, call core TBox
concept inclusions restricted to:
B1 v B2



B1 v B2 .

(core)

B1 v B2 equivalent B1 u B2 v , core TBoxes regarded sitting
intersection Krom Horn TBoxes.
Remark 2.1 sometimes use conjunctions
right-hand side concept includ
sions restricted languages: C v k Bk . Clearly, syntactic sugar add
extra expressive power.
HN
HN
HN
DL-LiteHN
krom , DL-Litehorn DL-Litecore . fragments DL-Litebool Krom,
HN
HN
Horn, core TBoxes denoted DL-Litekrom , DL-Litehorn DL-LiteHN
core , respectively. fragments obtained limiting use number restrictions role
inclusions.

6. Krom fragment first-order logic consists formulas prenex normal form whose quantifier-free
part conjunction binary clauses.

7

fiArtale, Calvanese, Kontchakov & Zakharyaschev

HN
DL-LiteH
. fragment DL-Lite , {core, krom, horn, bool}, without number
restrictions q R, q 2, (but role inclusions) denoted DL-LiteH
. Note
H
that, DL-Lite , still use existential concepts R (that is, 1 R).
HF
DL-LiteHF
fragment DL-LiteHN
number
. Denote DL-Lite

restrictions q R, existential concepts (with q = 1) q = 2
occur concept inclusions form 2 R v . inclusion called
global functionality constraint states role R functional (more precisely,
|= ( 2 R v ) (x, y) RI (x, z) RI , = z).
F
DL-LiteN
, DL-Lite DL-Lite . role inclusions excluded language,
{core, krom, horn, bool} obtain three fragments: DL-LiteN
(with arbitrary number restrictions), DL-LiteF
(with
functionality
constraints

existential
concepts

R), DL-Lite (without number restrictions different R).

shall see later article, logics form DL-LiteHF
DL-LiteHN

,
even = core, turn computationally rather costly interaction
role inclusions functionality constraints (or, generally, number restrictions). hand, purpose conceptual modeling one may need
constructs; cf. example Section 2.2. compromise found artificially
limiting interplay role inclusions number restrictions way similar
logic DL-LiteA proposed Poggi et al. (2008a).
TBox , let vT denote reflexive transitive closure relation


(R, R0 ), (inv(R), inv(R0 )) | R v R0
let R R0 iff R vT R0 R0 vT R. Say R0 proper sub-role R
R0 vT R R0
6 R.
(HN )

(HN )

DL-Lite . introduce logics DL-Lite ,
{core, krom, horn, bool},
HN
which, one hand, restrict logics DL-Lite limiting interaction
role inclusions number restrictions order reduce complexity reasoning, and,
hand, include additional constructs, limited qualified existential quantifiers, role disjointness, (a)symmetry (ir)reflexivity constraints, increase
expressive power logics affect computational properties.
(HN )
DL-Lite
TBoxes must satisfy conditions (A1 )(A3 ) below. (We remind
reader occurrence concept right-hand (left-hand) side concept
inclusion called negative scope odd (even) number negations ;
otherwise occurrence called positive.)
(A1 ) may contain positive occurrences qualified number restrictions q R.C,
C conjunction concepts allowed right-hand side -concept
inclusions;
(A2 ) q R.C occurs , contain negative occurrences number
restrictions q 0 R q 0 inv(R) q 0 2;
(A3 ) R proper sub-role , contain negative occurrences
q R q inv(R) q 2.
8

fiThe DL-Lite Family Relations

role
role
constraints inclusions






yes

disj.
(a)sym.
(ir)ref.
disj.
(a)sym.
(ir)ref.
tran.
a)

number
restrictions
R
R/funct.
qR
R
R/funct.
qR

concept inclusions
Krom
Horn
DL-Litekrom DL-Litehorn
DL-LiteF
DL-LiteF
krom
horn
N
DL-Litekrom DL-LiteN
horn
H
DL-LiteH
DL-Lite
krom
horn
HF
DL-Litekrom DL-LiteHF
horn
HN
DL-LiteHN
DL-Lite
krom
horn

core
DL-Litecore
DL-LiteF
core
DL-LiteN
core
DL-LiteH
core
DL-LiteHF
core
DL-LiteHN
core

(HF )

Bool
DL-Litebool
DL-LiteF
bool
DL-LiteN
bool
DL-LiteH
bool
DL-LiteHF
bool
DL-LiteHN
bool

(HF )

(HF )

)
R.C/funct.a) DL-Lite(HF
DL-Litekrom DL-Litehorn DL-Litebool
core
(HN )
(HN )
(HN )
(HN )
a)
q R.C
DL-Litecore
DL-Litekrom DL-Litehorn DL-Litebool

yes

+

)
R.C/funct.a) DL-Lite(HF
core

yes

q R.C a)

(HF )+

DL-Litekrom

+

(HN )+

)
DL-Lite(HN
DL-Litekrom
core

(HF )+

DL-Litehorn

(HN )+

DL-Litehorn

(HF )+

DL-Litebool

(HN )+

DL-Litebool

restricted (A1 )(A3 ).

Table 1: extended DL-Lite family.
(HN )

(It follows DL-Lite
TBox contain both, say, functionality constraint
2 R v occurrence q R.C, q 1.)
(HN )
Additionally, DL-Lite
TBoxes contain role constraints (or axioms) form:
Dis(R1 , R2 ),

Asym(Pk ),

Sym(Pk ),

Irr(Pk ),



Ref(Pk ).

meaning new constructs defined usual: interpretation = (I , ),


( q R.C)I = x | ]{y C | (x, y) RI } q ;
|= Dis(R1 , R2 )
|= Asym(Pk )
|= Sym(Pk )
|= Irr(Pk )
|= Ref(Pk )

iff
iff

iff
iff
iff

R1I R2I = (roles R1 R2 disjoint);
PkI (Pk )I = (role Pk asymmetric);

PkI = (Pk )I

(Pk symmetric);

(x, x)
/ PkI x
(x, x) PkI x

(Pk irreflexive);
(Pk reflexive).

emphasized extra constructs often used conceptual modeling
(HN )
introduction DL-Lite
motivated OWL 2 QL proposal. (Note
(HN )
DL-Lite
contains DL-LiteH

DL-LiteN

proper fragments.)
(HN )+

(HN )+

DL-Lite
.
{bool, horn, krom, core}, denote DL-Lite
extension
(HN )
DL-Lite
role transitivity constraints form Tra(Pk ), meaning
expected:
|= Tra(Pk )

iff

(x, y) PkI (y, z) PkI imply (x, z) PkI , x, y, z
(Pk transitive).
9

fiArtale, Calvanese, Kontchakov & Zakharyaschev

DL-Litebool

DL-LiteHN


@

@
DL-Litehorn






DL-Litekrom






@

@

DL-Litecore

PP


6
DL-LiteHF

6
DL-LiteH


DL-LiteN


(HN ) )+
DL-Lite
DL-Lite(HN


1
6
6

6
PP



1

DL-LiteF


6





iP
P
DL-Lite

)+
(HF ) DL-Lite
DL-Lite(HF



Figure 1: Language inclusions extended DL-Lite family.
remind reader standard restriction limiting use transitive roles DLs
(see, e.g., Horrocks, Sattler, & Tobies, 2000):
simple roles R allowed concepts form q R, q 2,
simple role given TBox understand role without transitive sub-roles
(including itself). particular, contains Tra(P ) P P simple,
cannot contain occurrences concepts form q P q P , q 2.
(HF )

(HF )+

(HF )

DL-Lite
DL-Lite .
define languages DL-Lite
sub-languages
(HN )
DL-Lite ,
number restrictions form R, R.C functionality
constraints 2 R v allowedprovided, course, satisfy (A1 )(A3 );
(HF )+
particular, R.C allowed R functional. before, DL-Lite
extensions
(HF )
DL-Lite
role transitivity constraints (satisfying restriction above).
Thus, extended DL-Lite family consider article consists 40 different
logics collected Table 1. inclusions logics shown Figure 1.
obtained taking product left- right-hand parts picture,
subscript right-hand part ranges {core, krom, horn, bool}, i.e.,
subscripts left-hand part, similarly, superscript left-hand part
ranges { , F, N , H, HF, HN , (HF), (HN ), (HF)+ , (HN )+ }, i.e., superscripts
right-hand part.
position logics relative DL-Lite logics known literature
OWL 2 QL profile discussed Section 4. starting Section 5, begin
thorough investigation computational properties logics extended DLLite family, without UNA. illustrate expressive
power DL-Lite logics concrete example.
2.2 DL-Lite Conceptual Modeling
tight correspondence conceptual modeling formalisms, ER model
UML class diagrams, various description logics pointed various
papers (e.g., Calvanese et al., 1998b, 1999; Borgida & Brachman, 2003; Berardi et al.,
2005). give example showing DL-Lite logics used conceptual
modeling purposes; details see work Artale et al. (2007b).
10

fiThe DL-Lite Family Relations

1..1

Employee

1..*

empCode: Integer
salary: Integer

worksOn
boss
3..*
Project

Manager

projectName: String

1..*
1..1
{disjoint, complete}

AreaManager

manages
TopManager

1..1

Figure 2: UML class diagram.
Let us consider UML class diagram depicted Figure 2 representing (a portion
of) company information system. According diagram, managers employees partitioned area managers top managers. information
represented means following concept inclusions (where brackets specify
minimal DL-Lite language inclusion belongs to):
Manager v Employee

(DL-Litecore )

AreaManager v Manager

(DL-Litecore )

TopManager v Manager

(DL-Litecore )

AreaManager v TopManager

(DL-Litecore )

Manager v AreaManager TopManager

(DL-Litebool )

employee two functional attributes, empCode salary, integer values.
Unlike OWL, distinguish abstract objects data values. Hence
model datatype, Integer , means concept, attribute,
employees salary, means role. Thus, salary represented follows:
Employee v salary
salary



(DL-Litecore )

v Integer

(DL-Litecore )
(DL-LiteF
core )

2 salary v

functional attribute empCode values Integer represented way.
binary relationship worksOn Employee domain Project range:
worksOn v Employee
worksOn



(DL-Litecore )

v Project

(DL-Litecore )

binary relationship boss domain Employee range Manager treated analogously. employee works project exactly one boss, project must
11

fiArtale, Calvanese, Kontchakov & Zakharyaschev

involve least three employees:
Employee v worksOn

(DL-Litecore )

Employee v boss

(DL-Litecore )
(DL-LiteF
core )

2 boss v
Project v 3 worksOn

(DL-LiteN
core )

top manager manages exactly one project works project, project
managed exactly one top manager:
manages v TopManager
manages



v Project

(DL-Litecore )

TopManager v manages
Project v manages

(DL-Litecore )
(DL-Litecore )



(DL-Litecore )

2 manages v

(DL-LiteF
core )

2 manages v

(DL-LiteF
core )
(DL-LiteH
core )

manages v worksOn

all, languages extended DL-Lite family capable representing
(HN )
UML class diagram Figure 2 DL-LiteHN
bool DL-Litebool . Note, however, except covering constraint, Manager v AreaManager TopManager , concept
inclusions DL-Lite translation UML class diagram belong variants
(HN )
core fragments DL-LiteHN
core DL-Litecore . hard imagine situation
one needs Horn concept inclusions represent integrity constraints UML class diagrams, example, express (together axioms) chief executive
officer may work five projects manager one them:
CEO u ( 5 worksOn) u manages v

(DL-LiteN
horn )

context UML class diagrams, Krom fragment DL-Litekrom (with variants)
seems useless: extends DL-Litecore concept inclusions form B1 v B2
or, equivalently, > v B1 B2 , rarely used conceptual modeling. Indeed,
would correspond partitioning whole domain interest two parts,
general useful covering constraints form B v B1 Bk require full
Bool language. hand, Krom fragments important pinpointing
borderlines various complexity classes description logics DL-Lite family
extensions; see Table 2.

3. Reasoning DL-Lite Logics
discuss reasoning problems consider article, mutual relationships, complexity measures adopt. provide overview complexity
results DL-Lite logics obtained article.

12

fiThe DL-Lite Family Relations

3.1 Reasoning Problems
concentrate three fundamental standard reasoning tasks description
logics: satisfiability (or consistency), instance checking, query answering.
DL L extended DL-Lite family, define L-concept inclusion
concept inclusion allowed L. Similarly, define notions L-KB L-TBox.
Finally, define L-concept concept occur right-hand side
L-concept inclusion conjunction concepts.
Satisfiability. KB satisfiability problem check, given L-KB K, whether
model K. Clearly, satisfiability minimal requirement ontology.
well known DL (Baader et al., 2003), many reasoning tasks description logics
reducible satisfiability problem. Consider, example, subsumption problem:
given L-TBox L-concept inclusion C1 v C2 , decide whether |= C1 v C2 ,
is, C1I C2I , every model . reduce problem (un)satisfiability, take
fresh concept name A, fresh object name a, set K = (T 0 , A),
0 = {A v C1 , v C2 }

= {A(a)}.

easy
see |= C1 v C2 iff K satisfiable. core, Krom Horn KBs,
C2 = k Dk , Dk (possibly negated) basic concept, checking unsatisfiability
K amounts checking unsatisfiability KBs Kk = (Tk , A), Tk =
{A v C1 , v Dk } (for Horn KBs, replace v B equivalent u B v ).
concept satisfiability problemgiven L-TBox L-concept C, decide
whether C 6= model easily reducible KB satisfiability. Indeed,
take fresh concept name A, fresh object name a, set K = (T 0 , A),
0 = {A v C}

= {A(a)}.

C satisfiable respect iff K satisfiable.
Instance checking. instance checking problem decide, given object name a,
L-concept C L-KB K = (T , A), whether K |= C(a), is, aI C , every
model K. Instance checking reducible (un)satisfiability: object
instance L-concept C every model K = (T , A) iff KB K0 = (T 0 , A0 ),
0 = {A v C}



A0 = {A(a)},

notdsatisfiable, fresh concept name. core, Krom Horn KBs,
C = k Dk , Dk (possibly negated) basic concept, proceed
subsumption: checking unsatisfiability K0 amounts checking unsatisfiability
KB Kk0 = (Tk0 , A0 ) Tk0 = {A v Dk }.
Conversely, KB satisfiability reducible complement instance checking: K
satisfiable iff K 6|= A(a), fresh concept name fresh object a.
Query answering. positive existential query q(x1 , . . . , xn ) first-order formula
(x1 , . . . , xn ) constructed means conjunction, disjunction existential quantification starting atoms Ak (t) Pk (t1 , t2 ), Ak concept name, Pk
13

fiArtale, Calvanese, Kontchakov & Zakharyaschev

role name, t, t1 , t2 terms taken list variables y0 , y1 , . . . list
object names a0 , a1 , . . . (i.e., positive existential formula). precisely,


::=

yi

|



::=

Ak (t)

ai ,
|

Pk (t1 , t2 )

|

1 2

|

1 2

|

yi .

free variables called distinguished variables q bound ones nondistinguished variables q. write q(x1 , . . . , xn ) query distinguished variables
x1 , . . . , xn . conjunctive query positive existential query contains disjunction
(it constructed atoms means conjunction existential quantification only).
Given query q(~x) = (~x) ~x = x1 , . . . , xn n-tuple ~a object names,
write q(~a) result replacing every occurrence xi (~x) ith member
~a. Queries containing distinguished variables called ground (they known
Boolean).
Let = (I , ) interpretation. assignment function associating
every variable element a(y) . use following notation: aI,a
= aIi

I,a = a(y). satisfaction relation positive existential formulas respect
given assignment defined inductively taking:
|=a Ak (t)

iff

tI,a AIk ,

|=a Pk (t1 , t2 )

iff

I,a

(tI,a
1 , t2 ) Pk ,

|=a 1 2

iff

|=a 1 |=a 2 ,

|=a 1 2

iff

|=a 1 |=a 2 ,

|=a yi

iff

|=b , assignment b may differ yi .

ground query q(~a), satisfaction relation depend assignment a,
write |= q(~a) instead |=a q(~a). answer query either yes
no.
KB K = (T , A), say tuple ~a object names certain answer
q(~x) respect K, write K |= q(~a), |= q(~a) whenever |= K. query
answering problem formulated follows: given L-KB K = (T , A), query q(~x),
tuple ~a object names A, decide whether K |= q(~a).
Note instance checking problem special case query answering: object
instance L-concept C respect KB K iff answer query A(a)
respect K0 yes, K0 = (T 0 , A) 0 = {C v A}, fresh
concept name. Horn-concepts B1 u u Bk , consider query A1 (a) Ak (a)
respect K0 , K0 = (T 0 , A) 0 = {B1 v A1 , . . . , Bk v Ak },
Ai fresh concept names. Similarly, deal Krom-concepts D1 u u Dk ,
Di possibly negated basic concept. core-concepts, reduction holds
conjunctions basic concepts.
3.2 Complexity Measures: Data Combined Complexity
computational complexity reasoning problems discussed analyzed
respect different complexity measures, depend parameters
14

fiThe DL-Lite Family Relations

problem regarded input (i.e., vary) regarded
fixed. satisfiability instance checking, parameters consider size
TBox size ABox A, number symbols A,
denoted |T | |A|, respectively. size |K| knowledge K = (T , A) simply given
|T | + |A|. query answering, one parameter consider would size
query. However, analysis adopt standard database assumption size
queries always bounded reasonable constant and, case, negligible
respect size TBox size ABox. Thus count
query part input.
Hence, consider reasoning problems two complexity measures. whole
KB K regarded input, deal combined complexity. If, however,
ABox counted input, TBox (and query) regarded
fixed, concern data complexity (Vardi, 1982). Combined complexity interest
still designing testing ontology. hand, data complexity
preferable cases TBox fixed size (and size query)
negligible compared size ABox, case, instance, context
ontology-based data access (Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, & Rosati,
2007) data intensive applications (Decker, Erdmann, Fensel, & Studer, 1999; Noy,
2004; Lenzerini, 2002; Calvanese et al., 2008). Since logics DL-Lite family
tailored deal large data sets stored relational databases, data complexity
instance checking query answering particular interest us.
3.3 Remarks Complexity Classes LogSpace AC0
paper, deal following complexity classes:
AC0 ( LogSpace NLogSpace P NP ExpTime.
definitions found standard textbooks (e.g., Garey & Johnson, 1979;
Papadimitriou, 1994; Vollmer, 1999; Kozen, 2006). remind reader
two smallest classes LogSpace AC0 .
problem belongs LogSpace two-tape Turing machine that,
starting input length n written read-only input tape, stops accepting rejecting state used log n cells (initially blank) read/write work
tape. LogSpace transducer three-tape Turing machine that, started
input length n written read-only input tape, writes result (of polynomial size)
write-only output tape using log n cells (initially blank) read/write
work tape. LogSpace-reduction reduction computable LogSpace transducer;
composition two LogSpace transducers LogSpace transducer (Kozen,
2006, Lemma 5.1).
formal definition complexity class AC0 (see, e.g., Boppana & Sipser, 1990;
Vollmer, 1999 references therein) based circuit model, functions
represented directed acyclic graphs built unbounded fan-in And,
gates (i.e., gates may unbounded number incoming edges).
definition assume decision problems encoded alphabet {0, 1}
regarded Boolean functions. AC0 class problems definable using
15

fiArtale, Calvanese, Kontchakov & Zakharyaschev

family circuits constant depth polynomial size, generated
deterministic Turing machine logarithmic time (in size input); latter
condition called LogTime-uniformity. Intuitively, AC0 allows us use polynomially
many processors run-time must constant. typical example AC0 problem
evaluation first-order queries databases (or model checking first-order sentences
finite models), database (first-order model) regarded input
query (first-order sentence) assumed fixed (Abiteboul, Hull, & Vianu, 1995;
Vollmer, 1999). hand, undirected graph reachability problem known
LogSpace (Reingold, 2008) AC0 . Boolean function f : {0, 1}n {0, 1}
called AC0 -reducible (or constant-depth reducible) function g : {0, 1}n {0, 1}
(LogTime-uniform) family constant-depth circuits built And, Or,
g gates computes f . case say AC0 -reduction. Note
reductions considered Section 3.1 AC0 -reductions. Unless otherwise indicated,
follows write reduction AC0 -reduction.
3.4 Summary Complexity Results
article, aim investigate (i) combined data complexity satisfiability instance checking problems (ii) data complexity query answering
problem logics extended DL-Lite family, without UNA.
(HF )+
obtained known results first 32 logics Table 1 (the logics DL-Lite
(HN )+
DL-Lite
included) summarized Table 2 (we remind reader
satisfiability instance checking reducible complements
instance checking special case query answering). fact, results
table follow lower upper bounds marked [] [], respectively (by
taking account hierarchy languages DL-Lite family): example,
NLogSpace membership satisfiability DL-LiteN
krom Theorem 5.7 implies
N
F
upper bound DL-Litekrom , DL-Litekrom , DL-Litecore , DL-LiteF
core DL-Litecore
.
sub-languages DL-LiteN
krom
Remark 3.1 Two complexity results noted (they included
Table 2):
(i) equality object names allowed language DL-Lite,
makes sense UNA dropped, AC0 memberships Table 2 replaced LogSpace-completeness (see Section 8, Theorem 8.3 8.9); inequality
constraints affect complexity.
(ii) extend languages role transitivity constraints combined complexity satisfiability remains same, data complexity, instance
checking query answering become NLogSpace-hard (see Lemma 6.3), i.e.,
membership AC0 data complexity replaced NLogSpace-completeness,
complexity results remain same.
either case, property first-order rewritabilitythat is, possibility rewriting
given query q given TBox single first-order query q0 returning certain
answers q (T , A) every ABox A, ensures query answering problem
AC0 data complexityis lost.
16

fiThe DL-Lite Family Relations

Complexity
Languages

UNA

Combined complexity
Satisfiability

|H]
DL-Lite[core
[ |H]
DL-Litehorn
[ |H]
DL-Litekrom
[ |H]
DL-Litebool
|N |(HF )|(HN )]
DL-Lite[F
core
[F |N |(HF )|(HN )]
DL-Litehorn
[F |N |(HF )|(HN )]
DL-Litekrom
[F |N |(HF )|(HN )]
DL-Litebool
[F |(HF )]
DL-Litecore/horn
[F |(HF )]
DL-Litekrom
[F |(HF )]
DL-Litebool
[N |(HN )]
DL-Litecore/horn
[N |(HN )]
DL-Litekrom/bool
DL-LiteHF
core/horn
DL-LiteHF
krom/bool
DL-LiteHN
core/horn
HN
DL-Litekrom/bool

yes/no

yes



yes/no

Data complexity
Instance checking
0

Query answering

NLogSpace [A]

AC

AC0

P [Th.8.2] [A]

AC0

AC0 [C]

0

NLogSpace [Th.8.2]

AC

coNP [B]

NP [Th.8.2] [A]

AC0 [Th.8.3]

coNP

0

NLogSpace

AC

AC0

P [Th.5.8, 5.13]

AC0

AC0 [Th.7.1]

NLogSpace [Th.5.7,5.13]

AC0

coNP

0

NP [Th.5.6, 5.13]

AC [Cor.6.2]

coNP

P [Cor.8.8] [Th.8.7]

P [Th.8.7]

P

P [Cor.8.8]

P

coNP

NP

P [Cor.8.8]

coNP

NP [Th.8.4]

coNP [Th.8.4]

coNP

NP [Th.8.5]

coNP

coNP

ExpTime [Th.5.10]

P [Th.6.7]

P [D]

ExpTime

coNP [Th.6.5]

coNP

ExpTime

coNP [Th.6.6]

coNP

ExpTime [F]

coNP

coNP [E]

[A] complexity respective fragment propositional Boolean logic
[B] follows proof data complexity result instance checking ALE (Schaerf, 1993)
[C] (Calvanese et al., 2006)
[D] follows Horn-SHIQ (Hustadt, Motik, & Sattler, 2005; Eiter, Gottlob, Ortiz, & Simkus, 2008)
[E] follows SHIQ (Ortiz, Calvanese, & Eiter, 2006, 2008; Glimm, Horrocks, Lutz, & Sattler, 2007)
[F] follows SHIQ (Tobies, 2001)

Table 2: Complexity DL-Lite logics (all complexity bounds save AC0 tight).

1 ||n ]
means DL-Lite1 , . . . , DL-Liten
DL-Lite[

(in particular, DL-Lite[ |H] either DL-Lite DL-LiteH
).

DL-Litecore/horn means DL-Litecore DL-Litehorn (likewise DL-Litekrom/bool ).
[X] ( [X]) means upper (respectively, lower) bound follows [X].

Detailed proofs results given Sections 58. variants logics
involving number restrictions, upper bounds hold assumption
numbers q concepts form q R given binary. (Intuitively, follows
fact proofs use numbers explicitly occur KB.)
lower bounds remain unary coding, since corresponding proofs
use numbers exceeding 4.
next section consider extended DL-Lite family general context
identifying place among DL-Lite-related logics, particular OWL 2 profiles.
17

fiArtale, Calvanese, Kontchakov & Zakharyaschev

4. Landscape DL-Lite Logics
original family DL-Lite logics created two goals mind: identify
description logics that, one hand, capable representing basic features
conceptual modeling formalisms (such UML class diagrams ER diagrams) and,
hand, computationally tractable, particular, matching AC0 data
complexity database query answering.
saw Section 2.2, represent UML class diagrams one need typical quantification constructs basic description logic ALC (Schmidt-Schau & Smolka,
1991), namely, universal restriction R.C qualified existential quantification R.C: one
always take role filler C >. Indeed, domain range restrictions
relationship P expressed concepts inclusions P v B1 P v B2 , respectively. Thus, almost concept inclusions required capturing UML class diagrams
form B1 v B2 B1 v B2 . observations motivated introduction
Calvanese et al. (2005) first DL-Lite logic, new nomenclature corresponds
DL-LiteF
core . main results polynomial-time upper bound combined
complexity KB satisfiability LogSpace upper bound data complexity
conjunctive query answering (under UNA). results extended Calvanese
H
et al. (2006) two larger languages: DL-LiteF
horn DL-Litehorn , originally
called DL-Liteu,F DL-Liteu,R , respectively. Calvanese et al. (2007b) introduced another member DL-Lite family (named DL-LiteR ), extended DL-LiteH
core
role disjointness axioms form Dis(R1 , R2 ). computational behavior new
logic turned DL-LiteH
core . may worth mentioning
DL-LiteH
covers

DL
fragment

RDFS
(Klyne
& Carroll, 2004; Hayes, 2004). Note
core
Calvanese et al. (2006) considered variants DL-Liteu,F DL-Liteu,R
arbitrary n-ary relations (not usual binary roles) showed query answering still LogSpace data complexity. conjecture similar results
obtained DL-Lite logics introduced paper. Artale et al. (2007b)
demonstrated n-ary relations represented DL-LiteF
core means reification.
variant DL-Lite, called DL-LiteA (A attributes), introduced
Poggi et al. (2008a) aim capturing many features conceptual modeling
formalisms possible, still maintaining computational properties basic
variants DL-Lite. One features DL-LiteA , borrowed conceptual modeling
formalisms adopted OWL, distinction (abstract) objects data
values, consequently, concepts (sets objects) datatypes (sets data
values), roles (i.e., object properties OWL, relating objects objects)
attributes (i.e., data properties OWL, relating objects data values). However,
far results paper concerned, distinction concepts
datatypes, roles attributes impact reasoning whatsoever, since
datatypes simply treated special concepts mutually disjoint
disjoint proper concepts. Instead, relevant reasoning possibility
express DL-LiteA role inclusions functionality, i.e., DL-LiteA includes
F
HF
DL-LiteH
core DL-Litecore , DL-Litecore .
already mentioned, role inclusions functionality constraints cannot
combined unrestricted way without losing good computational properties:

18

fiThe DL-Lite Family Relations

.
b
b

DL-LiteHN
krom
b

b

b

...

SHIQ
DL-LiteHN
horn
b

DL-LiteHN
bool
b

...
b

DL-Litekrom
b

b

DL-LiteHF
core
b

(HN )

b

b

b

P

b

DL-Litecore
(HF )
DL-Litecore

DL-LiteN
core

(HN )

DL-Litehorn
(HF )
DL-Litehorn
DL-LiteN
horn
+
DL-LiteA,u
b

b

b

b

b

DL-LiteHF
horn

DL-Lite+

DL-LiteA
DL-LiteF = DL-LiteF
DL-LiteF ,u = DL-LiteF
core
horn
H
DL-LiteR = DL-Litecore
DL-LiteR,u = DL-LiteH
horn
DL-Litecore
b

b

AC0

DL-Litebool

Horn-SHIQ

coNP

.

b

DL-LiteHN
core

b

b

b

Figure 3: DL-Lite family relations.
Theorems 5.10 6.7, prove satisfiability DL-LiteHF
core KBs ExpTime-hard
combined complexity, instance checking data-hard P (NLogSpace-hardness
shown Calvanese et al., 2006). DL-LiteA , keep query answering AC0
data complexity satisfiability NLogSpace combined complexity, functional roles
(and attributes) allowed specialized, i.e., used positively right-hand
side role (and attribute) inclusion axioms. So, condition (A3 ) slight generalization
restriction. DL-LiteA allows axioms form B v R.C non-functional
roles R, covered conditions (A1 ) (A2 ). Thus, DL-LiteA regarded
(HF )
(HN )
proper fragment DL-Litecore DL-Litehorn . show Sections 5.3 7
three languages enjoy similar computational properties UNA:
tractable satisfiability query answering AC0 .
conclude section picture Figure 3 illustrating landscape DLLite-related logics grouping according data complexity positive existential
query answering UNA. original eight DL-Lite logics, called Calvanese
et al. (2007b) DL-Lite family, shown bottom sector picture (the logics
+
DL-Lite+
DL-LiteA,u extend DL-LiteA DL-LiteA,u identification constraints,
(HN )

scope article). nearest relatives logic DL-Litehorn
fragments, AC0 well. next layer contains logics DL-LiteHF
core
DL-LiteHF
,


query
answering

data-complete

P
(no
matter
whether

horn
UNA adopted not). fact, logics fragments much expressive DL
Horn-SHIQ, shown enjoy data complexity query answering
Eiter et al. (2008). remains seen whether polynomial query answering practically
feasible; recent experiments DL EL (Lutz, Toman, & Wolter, 2008) indicate
may indeed case. Finally, distant relatives DL-Lite family comprise

19

fiArtale, Calvanese, Kontchakov & Zakharyaschev

upper layer picture, query answering data-complete coNP, is,
expressive DL SHIQ.
4.1 DL-Lite Family OWL 2
upcoming version 2 Web Ontology Language OWL7 defines three profiles,8
is, restricted versions language suit specific needs. DL-Lite family, notably
DL-LiteH
core (or original DL-LiteR ), basis one OWL 2 profiles, called
OWL 2 QL. According http://www.w3.org/TR/owl2-profiles/, OWL 2 QL aimed
applications use large volumes instance data, query answering
important reasoning task. OWL 2 QL, [. . . ] sound complete conjunctive query
answering performed LogSpace respect size data (assertions)
[and] polynomial time algorithms used implement ontology consistency
class expression subsumption reasoning problems. expressive power profile
necessarily quite limited, although include main features conceptual
models UML class diagrams ER diagrams. section, briefly discuss
results obtained article context additional constructs present
OWL 2.
important difference DL-Lite family OWL status
unique name assumption (UNA): assumption quite common data management,
hence adopted DL-Lite family, adopted OWL. Instead, OWL
syntax provides explicit means stating object names, say b, supposed
denote individual, b, interpreted differently, 6 b (in
OWL, constructs called sameAs differentFrom).
complexity results obtain logics form DL-LiteH
depend
whether UNA adopted (because every model DL-LiteH
KB without UNA
untangled model KB respecting UNA; see Lemma 8.10).
N
However, case logics DL-LiteF
DL-Lite , obvious
interaction UNA number restrictions (cf. Table 2). example,
0
UNA, instance checking DL-LiteF
core AC data complexity, whereas dropping
assumption results much higher complexity: Section 8, prove P-complete.
H
addition equality construct DL-LiteH
core DL-Litehorn slightly changes
data complexity query answering instance checking, rises membership
AC0 LogSpace-completeness; see Section 8. important, however,
case loose first-order rewritability query answering instance checking,
result cannot use standard database query engines straightforward manner.
Since OWL 2 profiles defined syntactic restrictions language without
changing basic semantic assumptions, chosen include OWL 2 QL
profile construct interferes UNA which, absence UNA,
would cause higher complexity. OWL 2 QL include number restrictions, even functionality constraints. Also, keys (the mechanism identifying objects
means values properties) supported, although impor7. http://www.w3.org/2007/OWL/
8. logic, profiles would called fragments defined placing restrictions OWL 2
syntax only.

20

fiThe DL-Lite Family Relations

tant notion conceptual modeling. Indeed, keys considered generalization
functionality constraints (Toman & Weddell, 2005, 2008; Calvanese, De Giacomo, Lembo,
Lenzerini, & Rosati, 2007a, 2008b), since asserting unary key, i.e., one involving
single role R, equivalent asserting functionality inverse R. Hence,
absence UNA, allowing keys would change computational properties.
already mentioned, standard OWL constructs, role disjointness, (a)symmetry (ir)reflexivity constraints, added DL-Lite logics
without changing computational behavior. Role transitivity constraints, Tra(R), as(HN )
serting R must interpreted transitive role, added DL-Litehorn
leads increase data complexity reasoning problems NLogSpace,
although satisfiability remains P combined complexity. results found
Section 5.3.
constructs OWL 2 far supported DL-Lite logics
mention nominals (i.e., singleton concepts), Boolean operators roles, role chains.

5. Satisfiability: Combined Complexity
DL-LiteHN
bool clearly sub-logic description logic SHIQ, satisfiability problem
known ExpTime-complete (Tobies, 2001).
Section 5.1 show, however, satisfiability problem DL-LiteN
bool KBs
1
reducible satisfiability problem one-variable fragment, QL , first-order logic
without equality function symbols. satisfiability QL1 -formulas NP-complete
(see, e.g., Borger et al., 1997) logics consideration contain full Booleans
concepts, satisfiability DL-LiteN
bool KBs NP-complete well. shall see
translations Horn Krom KBs QL1 belong Horn Krom fragments
QL1 , respectively, known P- NLogSpace-complete (see, e.g., Papadimitriou, 1994; Borger et al., 1997). Section 5.2, show simulate behavior
polynomial-space-bounded alternating Turing machines means DL-LiteHF
core KBs.
give (optimal) ExpTime lower bound satisfiability KBs languages
family containing unrestricted occurrences functionality constraints role
inclusions. Section 5.3, extend embedding QL1 , defined Section 5.1,
(HN )
logic DL-Litebool , thereby establishing upper bounds DL-LiteN
bool
fragments. Finally, Section 5.4 investigate impact role transitivity constraints.
5.1 DL-LiteN
bool Fragments: First-Order Perspective
aim section construct reduction satisfiability problem DL-LiteN
bool
KBs satisfiability QL1 -formulas. two steps: first present lengthy
yet quite natural transparent (yet exponential) reduction , shall see
proof reduction substantially optimized linear reduction .

Let K = (T , A) DL-LiteN
bool KB. Recall role (K) denotes set direct
inverse role names occurring K ob(A) set object names occurring A.
R role (K), let QR
set natural numbers containing 1 numbers q
concept q R occurs (recall ABox contain number
restrictions). Note |QR
| 2 contains functionality constraint R.

21

fiArtale, Calvanese, Kontchakov & Zakharyaschev

every object name ai ob(A) associate individual constant ai QL1
every concept name Ai unary predicate Ai (x) signature QL1 .
role R role (K), introduce |QR
|-many fresh unary predicates
q QR
T.

Eq R(x),

intended meaning predicates follows: role name Pk ,
Eq Pk (x) Eq Pk (x) represent sets points least q distinct Pk -successors
least q distinct Pk -predecessors, respectively. particular, E1 Pk (x)
E1 Pk (x) represent domain range Pk , respectively.
Additionally, every pair roles Pk , Pk role (K), take two fresh individual constants
dpk

dp
k
QL1 , serve representatives points domains Pk

Pk , respectively (provided empty). Let dr(K) = dr | R role (K) .
Furthermore, pair object names ai , aj ob(A) R role (K), take
fresh propositional variable Rai aj QL1 encode ABox assertion R(ai , aj ).9
1
induction construction DL-LiteN
bool concept C define QL -formula
C :
= ,

(Ai ) = Ai (x),

( q R) = Eq R(x),

(C) = C (x),

(C1 u C2 ) = C1 (x) C2 (x).

1

DL-LiteN
bool TBox corresponds QL -sentence x (x),
^

(x) =
C1 (x) C2 (x) .

(1)

C1 vC2

ABox translated following pair QL1 -sentences
^
^
1
=
Ak (ai )
Ak (ai ),


2

=

^

(2)

Ak (ai )A

Ak (ai )A

Pk ai aj



^

Pk ai aj .

(3)

Pk (ai ,aj )A

Pk (ai ,aj )A

every role R role (K), need two QL1 -formulas:
R (x) = E1 R(x) inv(E1 R)(inv(dr)),
^

R (x) =
Eq0 R(x) Eq R(x) ,

(4)
(5)

0
q,q 0 QR
, q >q
0
00
q >q >q q 00 QR


9. follows, slightly abuse notation write R(ai , aj ) indicate Pk (ai , aj )
R = Pk , Pk (aj , ai ) R = Pk .

22

fiThe DL-Lite Family Relations

(by overloading inv operator),
(
Eq Pk , R = Pk ,
inv(Eq R) =
Eq Pk , R = Pk ,



(
dp
k,
inv(dr) =
dpk ,

R = Pk ,
R = Pk .

Formula (4) says domain R empty range empty either:
contains constant inv(dr), representative domain inv(R).
need formulas representing relationship propositional variables Rai aj
unary predicates role domain range: role R role (K), let R
following QL1 -sentence
^

^

^

q
^


Rai ajk Eq R(ai )

ai ob(A) qQR
aj1 ,...,ajq ob(A) k=1

jk 6=jk0 k6=k0



^


Rai aj inv(R)aj ai , (6)

ai ,aj ob(A)

inv(R)aj ai propositional variable Pk aj ai R = Pk Pk aj ai R = Pk .
Note first conjunct (6) part translation relies UNA.
Finally, DL-LiteN
bool knowledge base K = (T , A), set

h 1
h
^
^

2



R .
K = x (x)
R (x) R (x)
Rrole (K)

Rrole (K)

Thus, K universal sentence QL1 .
Example 5.1 Consider, example, KB K = (T , A)


= v P , P v A, v 2 P, > v 1 P , P v
= {A(a), P (a, a0 )}. obtain following first-order translation:
K = x (x) A(a) P aa0


P aa0 E1 P (a) P aa E1 P (a)


P a0 E1 P (a0 ) P a0 a0 E1 P (a0 )


P aa0 E1 P (a) P aa E1 P (a)


P a0 E1 P (a0 ) P a0 a0 E1 P (a0 )


P aa0 P aa E2 P (a) P a0 P a0 a0 E2 P (a0 )


P aa0 P aa E2 P (a) P a0 P a0 a0 E2 P (a0 )




P aa0 P a0 P a0 P aa0 P aa P aa P a0 a0 P a0 a0 .

(x) =

A(x) E1 P (x)



E1 P (x) A(x) A(x) E2 P (x)


> E2 P (x) E1 P (x) A(x)


E1 P (x) E1 P (dp ) E1 P (x) E1 P (dp)


E2 P (x) E1 P (x) E2 P (x) E1 P (x) . (7)




23

fiArtale, Calvanese, Kontchakov & Zakharyaschev

1
Theorem 5.2 DL-LiteN
bool knowledge base K = (T , A) satisfiable iff QL -sentence

K satisfiable.

Proof () K satisfiable model K whose domain consists
constants occurring K i.e., ob(A) dr(K) (say, Herbrand model K ).
denote domain interpretations (unary) predicates P , propositional
variables p constants QL1 P , pM , respectively. Thus, every
constant a, = a. Let D0 set constants a, ob(A). Without loss
generality may assume D0 6= .

construct interpretation DL-LiteN
bool based domain D0
inductively defined union

[

=



Wm ,

W0 = D0 .

m=0

interpretations object names ai given interpretations M,
namely, aIi =
W0 . set Wm+1 , 0, constructed adding Wm
new elements fresh copies certain elements \ D0 . new element
w0 copy w \ D0 write cp(w0 ) = w, w D0 let cp(w) = w.
set Wm \ Wm1 , 0, denoted Vm (for convenience, let W1 = ,
V0 = D0 ).
interpretations AIk concept names Ak defined taking


AIk = w | |= Ak [cp(w)] .
(8)
interpretation PkI role name Pk defined inductively union
PkI

=


[

Pkm ,



Pkm Wm Wm ,

m=0

along construction . First, role R role (K), define required
R-rank r(R, d) point taking

r(R, d) = max {0} { q QR
| |= Eq R[d] } .
follows (5) r(R, d) = q then, every q 0 QR
, |= Eq 0 R[d]
whenever q 0 q, |= Eq0 R[d] whenever q < q 0 . define actual R-rank
rm (R, w) point w step taking
(
]{w0 Wm | (w, w0 ) Pkm }, R = Pk ,
rm (R, w) =
]{w0 Wm | (w0 , w) Pkm }, R = Pk .
basis induction set, role name Pk role(K),



Pk0 = (aM
, aj ) W0 W0 | |= Pk ai aj .

(9)

Observe that, (6), R role (K) w W0 ,
r0 (R, w) r(R, cp(w)).
24

(10)

fiThe DL-Lite Family Relations

Suppose Wm Pkm , 0, already defined.
rm (R, w) = r(R, cp(w)), roles R role (K) points w Wm , interpretation need would constructed. However, general case
may defects sense actual rank points smaller
required rank.
role name Pk role(K), consider following two sets defects Pkm :



w Vm | rm (Pk , w) < r(Pk , cp(w)) ,
k =



= w Vm | rm (Pk , w) < r(Pk , cp(w)) .
k
purpose of, say,
k identify defective points w Vm precisely
r(Pk , cp(w)) distinct Pk -arrows start (according M), arrows still
missing (only rm (Pk , w) many arrows exist). cure defects, extend Wm
Pkm respectively Wm+1 Pkm+1 according following rules:

(m
k ) Let w k , q = r(Pk , cp(w)) rm (Pk , w) = cp(w). |= Eq 0 Pk [d]
0
q 0 QR
q q > 0. Then, (5), |= E1 Pk [d] and, (4),


|= E1 Pk [dpk ]. case take q fresh copies w10 , . . . , wq0 dp
k (and set

0
0
cp(wi ) = dpk , 1 q), add Wm+1 add pairs (w, wi ), 1 q,
Pkm+1 .




(m
k ) Let w k , q = r(Pk , cp(w)) rm (Pk , w) = cp(w). |= Eq 0 Pk [d]

0
q 0 QR
q q > 0. So, (5), |= E1 Pk [d] and, (4),
0
0
|= E1 Pk [dpk ]. Take q fresh copies w1 , . . . , wq dpk (and set cp(wi0 ) = dpk ,
1 q), add Wm+1 add pairs (wi0 , w), 1 q, Pkm+1 .

Example 5.3 Consider KB K first-order translation K Example 5.1.
Consider model K domain = {a, a0 , dp, dp },
= (E1 P )M = (E1 P )M = (E2 P )M = D,

(E2 P )M = ,
(P aa0 )M = (P a0 a)M = t.

begin construction interpretation K setting W0 = V0 = D0 = {a, a0 }
P 0 = {(a, a0 )}. compute required actual ranks r(R, w) r0 (R, w),
R {P, P } w V0 :
(i) r(P, a) = 2 r0 (P, a) = 1,
(iii) r(P , a) = 1 r0 (P , a) = 0,

(ii) r(P, a0 ) = 2 r0 (P, a0 ) = 0,
(iv) r(P , a0 ) = 1 r0 (P , a0 ) = 1.

next step, draw P -arrow fresh copy dp cure defect (i), draw
two P -arrows a0 two fresh copies dp order cure defects (ii), finally
take fresh copy dp connect P -arrow, thereby curing defect (iii).
One step unraveling construction shown Figure 4.
Observe following important property construction: m, m0 0, w Vm0
R role (K),


< m0 ,
0,
rm (R, w) =
(11)
q,
= m0 , q r(R, cp(w)),


r(R, cp(w)), > m0 .
25

fiArtale, Calvanese, Kontchakov & Zakharyaschev

.

V0

a0
V1



V2

dp

dp

.
Figure 4: Unraveling model (first three steps).
prove property, consider possible cases:
< m0 point w added Wm yet, i.e., w
/ Wm ,
rm (R, w) = 0.
= m0 m0 = 0 rm (R, w) r(R, cp(w)) follows (10).
= m0 m0 > 0 w added step m0 cure defect point
w0 Wm0 1 . means Pk role(K) either (w0 , w) Pkm0
(m 1)
0 1
w0
(w, w0 ) Pkm0 w0 k 0
. Consider former case.
k
.
Since
fresh
witnesses

picked
every time rule (km0 1 )
cp(w) = dp
k

applied, rm0 (Pk , w) = 1, rm0 (Pk , w) = 0 rm0 (R, w) = 0, every R 6= Pk , Pk .
0
suffices show r(Pk , dp
k ) 1. Indeed, |= Eq Pk [cp(w )]

R
0
q QT , have, (5), |= E1 Pk [cp(w )], so, (4), |= E1 Pk [dp
k ].
)

1.

latter
case

considered
analogously.
definition r, r(Pk , dp
k
= m0 + 1 then, role name Pk , defects w cured step m0 + 1
m0
0
applying rules (m
). Therefore, rm0 +1 (R, w) = r(R, cp(w)).
k ) (k
> m0 + 1 (11) follows observation new arrows involving w
added step m0 + 1, is, 0 role name Pk role(K),
Pkm+1 \ Pkm



Vm Vm+1



Vm+1 Vm .

(12)


follows that, R role (K), q QR
w , have:

|= Eq R[cp(w)]

iff

w ( q R)I .

(13)

Indeed, |= Eq R[cp(w)] then, definition, r(R, cp(w)) q. Let w Vm0 . Then,
(11), rm (R, w) = r(R, cp(w)) q, > m0 . follows definition
26

fiThe DL-Lite Family Relations

rm (R, w) RI w ( q R)I . Conversely, let w ( q R)I w Vm0 . Then,
(11), q rm (R, w) = r(R, cp(w)), > m0 . So, definition r(R, cp(w))
(5), |= Eq R[cp(w)].
induction construction concepts C K one readily see that, every
w ,
|= C [cp(w)]
iff
w CI .
(14)
Indeed, basis trivial B = follows (8) B = Ak (13)
B = q R, induction step Booleans (C = C1 C = C1 u C2 )
immediately follows induction hypothesis.
Finally, show A,
|=

iff

|= .

case = C1 v C2 follows (14); = Ak (ai ) = Ak (ai )
definition AIk . = Pk (ai , aj ) = Pk (ai , aj ), (aIi , aIj ) PkI iff, (12),
(aIi , aIj ) Pk0 iff, (9), |= Pk ai aj .
Thus, established |= K.
() Conversely, suppose |= K interpretation domain . construct

model K based . every ai ob(A), let
= ai and,
every R role (K), take ( 1 R)I ( 1 R)I 6= arbitrary element

otherwise, let drM = d. Next, every concept name Ak , let
k = Ak

= ( q R)I . Finally, every
and, every role R role (K) q QR
, set Eq R

role R role (K) every pair objects ai , aj ob(A), define (Rai aj )M true
iff |= R(ai , aj ). One readily check |= K . Details left reader.
q
first-order translation K K obviously lengthy provide us reasonably
low complexity results: |K | |K| + (2 + qT2 ) |role(K)| + 2 |role(K)| |ob(A)|qT . However,
follows proof lot information translation redundant
safely omitted.
define concise translation K K = (T , A) QL1 taking:
h
^

1
2
K = x (x)
R (x) R (x)

,
Rrole (K)
1

(x), R (x), R (x) defined means (1), (4), (5) (2),
respectively,
^
^
^
2
=
EqR,a R(a)
(Pk (ai , aj )) ,
(15)
aob(A)

Rrole (K)
a0 ob(A) R(a,a0 )A

Pk (ai ,aj )A

qR,a maximum number QR
qR,a many distinct ai
R(a, ai ) (here use UNA) (Pk (ai , aj )) = Pk (ai , aj ) >
2
otherwise. size size K linear size K,
respectively, matter whether numbers coded unary binary.
27

fiArtale, Calvanese, Kontchakov & Zakharyaschev

importantly, translation actually done LogSpace. Indeed,
1
2
trivially case (x), R (x), R (x), last conjunct .
2
first conjunct then, R role (K) ob(A), maximum qR,a
QR
qR,a many distinct ai R(a, ai ) A, computed using
log min(max QR
, |ob(A)|) + log |ob(A)| cells. Initially set q = 0, enumerate
object names ai incrementing current q time find R(a, ai ) A. stop
q = max QR
reach end object name list. resulting qR,a maximum
number QR
exceeding q.
Example 5.4 translation K KB K Example 5.1 looks follows:
K = x (x) A(a) E1 P (a) E1 P (a0 ),
(x) defined (7).
1

Corollary 5.5 DL-LiteN
bool KB K satisfiable iff QL -sentence K satisfiable.

Proof claim follows fact K satisfiable iff K satisfiable. Indeed,
|= K clearly |= K . Conversely, |= K one construct new model
M0 based domain taking:
0



k = Ak , concept names Ak ;
0

Eq RM = Eq RM , R role (K) q QR
T;
0

(Rai aj )M true iff R(ai , aj ) A;
0



= ai , ai ob(A);
0

drM = drM , R role (K).
0

claim M0 |= K . Indeed, Eq RM = Eq RM , every R role (K) q QR
.
1
2
follows M0 |= x (x) M0 |= x R (x). definition, M0 |=VA , M0 |=
q
M0 |= x R (x). remains show M0 |= R . Suppose M0 |= i=1 Raaji ,
R(a, aji ) A, distinct aj1 , . . . , ajq , q QR
. Clearly, q qR,a
|= Eq R(a) thus M0 |= Eq R(a).
q
immediate consequence Corollary 5.5, facts translation
done LogSpace, satisfiability problem QL1 -formulas NP-complete
DL-Litebool contains Booleansand encode full propositional logicwe
obtain following result:
F
Theorem 5.6 Satisfiability DL-LiteN
bool , DL-Litebool DL-Litebool knowledge bases
NP-complete combined complexity.
1

Observe K DL-LiteN
krom KB K Krom fragment QL .
F
Theorem 5.7 Satisfiability DL-LiteN
, DL-Lite DL-Lite knowledge bases,
{core, krom}, NLogSpace-complete combined complexity.

28

fiThe DL-Lite Family Relations

Proof satisfiability problem Krom formulas prefix form x (as
K ) NLogSpace-complete (see, e.g., Borger et al., 1997, Exercise 8.3.7)
LogSpace reduction, satisfiability NLogSpace logics mentioned
theorem. lower bound, suffices recall NLogSpace-hardness
satisfiability propositional Krom formulas proved reduction directed graph
reachability problem using core propositional formulas (Borger et al., 1997),
satisfiability logics NLogSpace-hard.
q
1

K DL-LiteN
horn KB K belongs universal Horn fragment QL .
F
Theorem 5.8 Satisfiability DL-LiteN
horn , DL-Litehorn DL-Litehorn KBs P-complete
combined complexity.

Proof QL1 contains function symbols K universal, satisfiability K
LogSpace-reducible satisfiability set propositional Horn formulas, namely,
formulas obtained K replacing x constants occurring
K . remains recall satisfiability problem propositional Horn formulas
P-complete (see, e.g., Papadimitriou, 1994), gives required upper bound
q
DL-LiteN
horn lower bound DL-Litehorn .
5.2 DL-LiteHF
core ExpTime-hard
Unfortunately, translation constructed previous section cannot extended
logics form DL-LiteHN
number restrictions role inclusions.

section show satisfiability problem DL-LiteHF
core KBs ExpTime-hard,
matches upper bound satisfiability DL-LiteHN
KBs
even binary coding
bool
natural numbers (Tobies, 2001).
Note first that, although intersection allowed left-hand side DL-LiteHF
core
concept inclusions, certain cases (when right-hand side consistent) simulate
using role inclusions functionality constraints. Suppose knowledge base K
contains concept inclusion form C1 u C2 v C. Define new KB K0 replacing
axiom K following set new axioms, R1 , R2 , R3 , R12 , R23 fresh
role names:
C1 v R1

C2 v R2 ,

(16)

R1 v R12 ,

R2 v R12 ,

(17)

2 R12 v ,
R1

v

(18)

R3 ,

(19)

R3 v C,

(20)

R3 v R23 ,



2 R23

R2 v R23 ,

v .

(21)
(22)

Lemma 5.9 (i) |= K0 |= K, every interpretation I.
(ii) |= K C 6= model 0 K0 domain
agrees every symbol K.
29

fiArtale, Calvanese, Kontchakov & Zakharyaschev

Proof (i) Suppose |= K0 x C1I C2I . (16), (x, y) R1I ,
, whence
(R1 )I , z (x, z) R2I . (17), {(x, y), (x, z)} R12
= z view (18). (19), (R3 )I hence u (u, y) R3I
(x, y) RI . Finally, follows
u (R3 )I . (20), u C . (21), (u, y) R23
23
(22) u = x, x C . Thus, |= K.
(ii) Take point c C define extension 0 new role names
setting:
0

R1I = {(x, x) | x C1I },
0

R2I = {(x, x) | x C2I },
0

R3I = {(x, x) | x (C1 u C2 )I } {(c, x) | x (C1 u C2 )I },
0

0

= RI RI
R12
1
2

0



0

0

0

= RI RI .
R23
2
3

readily seen 0 satisfies axioms (16)(22), 0 |= K0 .

q

position prove following:
Theorem 5.10 Satisfiability DL-LiteHF
core KBs ExpTime-hard combined complexity
(with without UNA).
Proof prove theorem two steps. First consider logic DL-LiteHF
horn
show encode behavior polynomial-space-bounded alternating Turing machines (ATMs, short) means DL-LiteHF
horn KBs. APSpace = ExpTime,
APSpace class problems recognized polynomial-space-bounded ATMs (see, e.g.,
Kozen, 2006), establish ExpTime-hardness satisfiability DL-LiteHF
horn . Then,
using Lemma 5.9, show get rid conjunctions left-hand side
concept inclusions involved encoding ATMs thus establish ExpTime-hardness
DL-LiteHF
core .
Without loss generality, consider ATMs binary computational
trees. means that, every non-halting state q every symbol tape
alphabet, precisely two instructions form
(q, a) ;0M (q 0 , a0 , d0 )



(q, a) ;1M (q 00 , a00 , d00 ),

(23)

d0 , d00 {, } (resp., ) means move head right (resp., left) one cell.
remind reader non-halting state either and-state or-state.
Given ATM M, polynomial function p(n) every run every
input length n use p(n) tape cells, input word ~a = a1 , . . . , ,
construct DL-LiteHF
horn knowledge base KM,~a following properties: (i) size
KM,~a polynomial size M, ~a, (ii) accepts ~a iff KM,~a satisfiable.
Denote Q set states tape alphabet M.
encode instructions M, need following roles:
Sq , Sq0 , Sq1 , q Q: informally, x (Sq )I , interpretation I, means
x represents configuration state q, x (Sqk )I means
next state, according transition ;kM , q, k {0, 1};
30

fiThe DL-Lite Family Relations

Hi , Hi0 , Hi1 , p(n): x (Hi )I means x represents configuration
head scans ith cell, x (Hik )I that, according transition
;kM , k {0, 1}, next configuration head scans ith cell;
0 , C 1 , p(n) : x (C )I means x represents
Cia , Cia
ia
ia
k )I that, according
configuration ith cell contains a, x (Cia
;kM , k {0, 1}, next configuration ith cell contains a.

intended meaning encoded using following concept inclusions: every
instruction (q, a) ;kM (q 0 , a0 , ) every < p(n),

k
k
Sq u Hi u Cia
v Hi+1
u Sqk0 u Cia
0,

(24)

every instruction (q, a) ;kM (q 0 , a0 , ) every i, 1 < p(n),

k
k
Sq u Hi u Cia
v Hi1
u Sqk0 u Cia
0.

(25)

preserve symbols tape active cell, use following
concept inclusions, k {0, 1}, i, j p(n) j 6= i, :

k
Hj u Cia
v Cia
.

(26)

synchronize roles, need two (functional) roles Tk number role
inclusions added TBox: k {0, 1}, p(n), q Q, ,
k
Cia
v Cia ,

Hik v Hi ,

Sqk v Sq ,

(27)

k
Cia
v Tk ,

Hik v Tk ,

Sqk v Tk ,

(28)

2 Tk v .

(29)

remains encode acceptance conditions ~a. done help
role names Yk , k {0, 1}, concept name A:
Sq v A,

q accepting state,

Yk v Tk ,
2 Tk
Tk u
Sq u Yk
Sq

(31)

v ,
v

(32)

Yk ,

v A,

u Y0 u Y1 v A,

(30)

(33)
q or-state,

(34)

q and-state.

(35)

TBox DL-LiteHF
horn knowledge base KM,~a constructing consists
axioms (24)(35) together auxiliary axiom
u v ,

(36)

fresh concept name. ABox KM,~a comprised following
assertions, object names u:
Sq0 (u, s),

q0 initial state,

H1 (u, s),
Ciai (u, s),

(37)
(38)

p(n), ai ith symbol input tape,

(39)
(40)

D(s).
31

fiArtale, Calvanese, Kontchakov & Zakharyaschev

Clearly, KM,~a = (T , A) DL-LiteHF
a.
horn KB size polynomial size M, ~
Lemma 5.11 ATM accepts ~a iff KB KM,~a satisfiable.
Proof () Suppose accepts ~a |= KM,~a interpretation I.
reconstruct full computation tree ~a induction following way.
Let root tree point sI . (37)(39), represents initial configuration ~a accordance intended meaning roles Sq0 , H1 Ciai
explained (it matter if, instance, sI (H5 )I ).
Assume already found point x representing configuration
c = b1 , . . . , bi1 , (q, bi ), bi+1 , . . . , bp(n) ,

(41)

q current non-halting state head scans ith cell containing bi .
means
x (Sq )I (Hi )I


x (Cjb
) ,
j

j p(n).

Assume contains two instructions form (23) (q, bi ), q nonhalting. (q, bi ) ;kM (q 0 , b0 , ), k = 0 1, then, (24) (26),
points ys , yh yj , j p(n),
(x, ys ) (Sqk0 )I ,

k
(x, yh ) (Hi+1
)I ,

k
(x, yi ) (Cib
0) ,

k
) ,
(x, yj ) (Cjb
j

j 6= i.

0 , C 0 C 0 , j 6= i, sub-roles functional role ,
(28)(29), Sq00 , Hi+1
k
jbj
ib0i
points ys , yh yj coincide; denote point xk . (27),
have:

(x, xk ) TkI ,



) (Cib
xk (Sq0 )I (Hi+1
0)


) ,
xk (Cjb
j

j 6= i.

Similarly, (q, bi ) ;kM (q 00 , b00 , ), k = 0 1, then, (25) (26),
point xk
(x, xk ) TkI ,



) (Cib
xk (Sq00 )I (Hi1
00 )


) ,
xk (Cjb
j

j 6= i.

Thus, k = 0, 1, xk Tk -successor x representing configuration ck
executed (q, bi ) ;kM (q 00 , b00 , d) c; case ck called k-successor c.
According (30), every point constructed computation tree ~a representing configuration accepting state AI . Suppose now, inductively,
x represents configuration c form (41), q or-state, xk represents ksuccessor c (x, xk ) TkI , k = 0, 1, one xk , say x0 , AI .
view (33), x0 (Y0 )I . T0 functional (32) Y0 sub-role
T0 (31), (x, x0 ) Y0I , so, (34), x AI . case x and-state
considered analogously help (35).
Since accepts ~a, conclude sI AI , contrary (36) (40).
() Conversely, suppose accept ~a. Consider full computation
tree (, <0 <1 ) nodes labeled configurations way root
labeled initial configuration
(q0 , a1 ), a2 , . . . , , an+1 , . . . , ap(n) ,
32

fiThe DL-Lite Family Relations

(where ai , n + 1 p(n), blank), node x tree labeled
non-halting c form (41) contains two instructions form (23),
x one <0 -successor labeled 0-successor c one <1 -successor labeled
1-successor c. (It emphasized (, <0 <1 ) tree, different
nodes may labeled configuration.)
use tree construct interpretation = (I , ) follows:
= {u}, u
/ ;
sI root uI = u;
DI = {sI };
k )I , (x, x ) (C k )I , (x, x ) (C k )I , j 6= i,
(x, xk ) (Sqk0 )I , (x, xk ) (Hi+1
k
k
jbj
ib0
iff x labeled c form (41), (q, bi ) ;kM (q 0 , b0 , ) x <k xk , k = 0, 1;
k )I , (x, x ) (C k )I , (x, x ) (C k )I , j 6= i,
(x, xk ) (Sqk0 )I , (x, xk ) (Hi1
k
k
jbj
ib0
k
iff x labeled c form (41), (q, bi ) ;M (q 0 , b0 , ) x <k xk , k = 0, 1;

(u, sI ) (Sq0 )I , (u, sI ) (H1 )I , (u, sI ) (Ciai )I , p(n) extensions
roles Sq , Hi Cia defined according (27);
TkI = <k , k = 0, 1;
Y0I , Y1I AI defined inductively:
Induction basis: x labeled accepting configuration, x AI .
Induction step: (i) x <k xk , k = 0, 1, xk AI , (x, xk ) YkI ; (ii)
x or-state (respectively, and-state) (x, xk ) YkI (respectively,
all) k {0, 1}, x AI .
follows given definition |= KM,~a . Details left reader.

q

lemma proved establishes satisfiability DL-LiteHF
horn KBs
ExpTime-hard. next aim show one eliminate conjunctions
left-hand side TBox axioms (24)(26), (33)(35). help
Lemma 5.9. applying it, check first KM,~a satisfiable satisfiable
interpretation |= KM,~a C 6= , every C occurring
axiom form C1 u C2 v C K. Consider, instance, axiom (24) assume
|= KM,~a , (Sqk0 )I = . Then, construct new interpretation 0 adding two
0
0
new points, say x y, domain I, setting (x, y) (Sqk0 )I , (x, y) (Sq0 )I ,
0
0
0
(x, y) (Tk )I . Furthermore, q 0 accepting state, set AI (x, y) YkI .
One readily check 0 still model KM,~a . conjuncts (24)
remaining axioms considered analogously.
application Lemma 5.9 axiom form C1 uC2 v C C2 = C20 uC200
obtain, (16)(22), new KB K0 concept inclusion form C20 uC200 v R1 ,
requires treatment means lemma. able this,
33

fiArtale, Calvanese, Kontchakov & Zakharyaschev

00

check K0 satisfiable interpretation 00 (R1 )I 6= . Suppose
0
0 |= K0 (R1 )I = . construct 00 adding two new points, say x
0
0
0 , RI 0 RI 0 .
y, domain 0 , adding x C (x, y) R1I , R12
23
3
readily seen 00 |= K0 .
noted proof depend whether UNA adopted
not.
q
immediate consequence obtain:
Corollary 5.12 Satisfiability DL-LiteHF
DL-LiteHN
KBs without UNA


ExpTime-complete combined complexity, {core, krom, horn, bool}.
5.3 Reconciling Number Restrictions Role Inclusions
seen previous section, unrestricted interaction number restrictions role inclusions allowed logics form DL-LiteHN
results high

combined complexity satisfiability. Section 6.2, shall see data complexity
instance checking query answering becomes unacceptably high logics.
quick look proof Theorem 5.10 reveals culprit: interplay role
inclusions R1 v R, R2 v R functionality constraints 2 R v , effectively mean
R1 (x, y) R2 (x, z) = z. section study case
interplay allowed.
(HN )
Recall Section 2.1 DL-Lite
TBoxes , {core, krom, horn, bool},
satisfy following conditions:
(A1 ) may contain positive occurrences qualified number restrictions q R.C,
C conjunction concepts allowed right-hand side -concept
inclusions;
(A2 ) q R.C occurs , contain negative occurrences number
restrictions q 0 R q 0 inv(R) q 0 2;
(A3 ) R proper sub-role , contain negative occurrences
q R q inv(R) q 2.
(HN )

DL-Lite
TBoxes contain role constraints Dis(R1 , R2 ), Asym(Pk ), Sym(Pk ),
Irr(Pk ), Ref(Pk ).
main aim section prove following theorem develop technical
(HN )
tools need investigate data complexity reasoning DL-Litebool
sublogics later paper.
(HN )

Theorem 5.13 combined complexity, (i) satisfiability DL-Litebool KBs NP(HN )
complete; (ii) satisfiability DL-Litehorn KBs P-complete; (iii) satisfiability
(HN )
(HN )
DL-Litekrom DL-Litecore KBs NLogSpace-complete.

34

fiThe DL-Lite Family Relations

(HN )

Let us consider first sub-language DL-Litebool

without qualified number restric(HN )

tions role constraints mentioned above; denote DL-Litebool . sub-

(HN )

language required purely technical reasons. Section 7, use DL-Litehorn ,
need core Krom fragments.
(HN )
Suppose given DL-Litebool
KB K = (T , A). Let Id distinguished
role name. use simulate identity relation required encoding role
constraints. assume either K contain Id satisfies following
conditions:
(Id1 ) Id(ai , aj ) iff = j, ai , aj ob(A),


Id = {1},
(Id2 ) > v Id, Id v Id , QId
= QT
(Id3 ) Id allowed role inclusions form Id v Id Id v R.
follows, without loss generality, assume
0

0
R

(Q) QR
QT whenever R vT R
0

(for case always add missing numbers QR
, e.g., introducing
fictitious concept inclusions form v q R0 ).
Now, way Section 5.1, define two translations e e K
one-variable fragment QL1 first-order logic. former translation, e , retains
information relationships ABox objects, show every model
Ke unraveled model K. define e taking:
h
Ke = x (x) R (x)

^

R (x) R (x)





Rrole (K)

h

1

2



^


R

Rrole (K)

^

Rai aj R0 ai aj



,

RvR0
ai ,aj ob(A)

1

2

(x), , , R (x), R (x) R (1)(6)
^
^

R (x) =
Eq R(x) Eq R0 (x) .
RvR0
inv(R)vinv(R0 )T

(42)

qQR


following lemma analogue Theorem 5.2:
(HN )

Lemma 5.14 DL-Litebool

KB K satisfiable iff QL1 -sentence Ke satisfiable.

Proof proof basically follows lines proof Theorem 5.2 modifications. present modified unraveling construction here; converse direction exactly
Theorem 5.2.
equivalence class [Ri ] = {Rj | Ri Rj } select single role (a representative
class) denote repT (Ri ). extending Pkm Pkm+1 , use following
modified curing rules:
35

fiArtale, Calvanese, Kontchakov & Zakharyaschev



(m
k ) Pk 6= repT (Pk ) nothing: defects cured repT (Pk ). Otherwise, let

w k , q = r(Pk , cp(w)) rm (Pk , w) = cp(w). |= Eq0 Pk [d]
q 0 q > 0. Then, (5), |= E1 Pk [d] and, (4), |= E1 Pk [dp
k ].
0 ) = dp , 1 q),
case take q fresh copies w10 , . . . , wq0 dp
(and
set
cp(w

k
k
add Wm+1

add pairs (w, wi0 ), 1 q, Pjm+1 Pk vT Pj (including
Pj = Pk );
add pairs (wi0 , w), 1 q, Pjm+1 Pk vT Pj ;
Id occurs K, add pairs (wi0 , wi0 ), 1 q, Pjm+1 Id vT Pj .


(m
k ) rule mirror image (k ): Pk dpk replaced everywhere

Pk dpk , respectively; see proof Theorem 5.2.

follows definition Id never
resulting
defects interpreted

interpretation identity relation IdI = (w, w) | w ; interpretations
roles respect role inclusions, i.e., R1I R2I whenever R1 vT R2 .
remains show constructed interpretation indeed model K.
First, (11) trivially holds Id required actual ranks equal 1. Second, (11) holds R R 6= Id R proper sub-roles: proof exactly
Theorem 5.2, taking account cure defects single role
equivalence class that, (42), R0 [R], r(R0 , cp(w)) = r(R, cp(w))
r(inv(R), cp(w)) = r(inv(R0 ), cp(w)). follows (13) holds Id role R
without proper sub-roles. However, (13) necessarily hold roles R proper
sub-roles: follows construction, actual rank may greater required
rank, case following:
|= Eq R[cp(w)]



w ( q R)I .

However, enough purposes. induction structure concepts
using (A3 ), one show |= C1 v C2 whenever |= x (C1 (x) C2 (x)),
concept inclusion C1 v C2 , therefore, |= . |= (see proof
Theorem 5.2) thus |= K.
q
Remark 5.15 follows proofs Theorem 5.2 Lemma 5.14 that,
(HN )
DL-Litebool
KB K = (T , A), every model Ke induces model IM K
following properties:
(ABox) ai , aj ob(A), (aIi , aIj ) RIM iff R(ai , aj ) CleT (A),
CleT (A) =




R2 (ai , aj ) | R1 (ai , aj ) A, R1 vT R2 .

(forest) object names ob(A) induce partitioning IM disjoint labeled
trees Ta = (Ta , Ea , `a ) nodes Ta , edges Ea , root aIM , labeling function
`a : Ea role (K) \ {Id, Id }.
36

fiThe DL-Lite Family Relations

(copy) function cp : IM ob(A) dr(K)
cp(aIM ) = ob(A),
cp(w) = dr if, w0 Ta , (w0 , w) Ea `a (w0 , w) = inv(R).
(iso) R role (K), labeled subtrees generated elements w IM
cp(w) = dr isomorphic.
(concept) w B IM iff |= B [cp(w)], basic concept B K w IM .



(role) IdIM = (w, w) w IM and, every role name Pk ,
PkIM =






(aIi , aIj ) | R(ai , aj ) A, R vT Pk

(w, w) | Id vT Pk

[

(w, w0 ) Ea | `a (w, w0 ) = R, R vT Pk .
aob(A)

model called untangled model K (the untangled model K induced
M, precise).
translation e generalizes thus suffers exponential blowup.
define optimized translation, e , linear size K, taking:
h
^

1
2

e ,
R (x) R (x)
Ke = x (x) R (x)
Rrole (K)
1

(x), R (x), R (x), R (x) defined (1), (42), (4), (5) (2),
respectively,
^
^
^
2
e R(a)
Ae =
EqR,a

(43)
(Pk (ai , aj ))e ,
aob(A)

Rrole (K)
a0 ob(A) R(a,a0 )CleT (A)

Pk (ai ,aj )A

e
e
qR,a
maximum number QR
qR,a many distinct ai
R(a, ai ) CleT (A) (here use UNA) (Pk (ai , aj ))e = Pk (ai , aj ) CleT (A)

> otherwise; cf. (15). note QR
= {1}, roles R role (K),
translation depend whether UNA adopted not.
following corollary proved similarly Corollary 5.5:
(HN )

Corollary 5.16 DL-Litebool

KB K satisfiable iff QL1 -sentence Ke satisfiable.

clear translation e computed NLogSpace (for combined
1
complexity). Indeed, readily seen (x), R (x), R (x), R (x), .
2
order compute Ae , need able check whether R(ai , aj ) CleT (A): test
performed non-deterministic algorithm using logarithmic space |role (K)|
(it basically standard directed graph reachability problem,
NLogSpace-complete; see, e.g., Kozen, 2006); done using N log |role (K)| +
2 log |ob(A)| cells work tape, N constant (in fact, N = 3 enough: one
37

fiArtale, Calvanese, Kontchakov & Zakharyaschev

store R, current role R0 path length graph reachability subroutine,
bounded log |role (K)|). Therefore, translation e computed
NLogSpace transducer.
(HN )
show satisfiability DL-Litebool KBs easily reduced satisfiability
(HN )

(HN )

DL-Litebool
KBs. First, assume DL-Litebool KBs contain role symmetry
asymmetry constraints Asym(Pk ) equivalently replaced Dis(Pk , Pk )
Sym(Pk ) Pk v Pk (it noted introduction Pk v Pk
TBox violate (A3 )). following lemma allows us get rid qualified number
restrictions well role disjointness, reflexivity irreflexivity constraints:
(HN )

Lemma 5.17 every DL-Litebool
KB K = (T , A)

(HN )

KB K0 = (T 0 , A0 ), one construct DL-Litebool

every untangled model IM K model K0 , provided
R1 (ai , aj ), R2 (ai , aj ) CleT (A) Dis(R1 , R2 ) 0 ,
R(ai , ai ) CleT (A) Irr(R) 0 ;

(44)

every model 0 K0 gives rise model K based domain 0
agrees 0 symbols K0 .
(HN )

(HN )

K0 DL-Litehorn KB K DL-Litehorn

KB.

Proof First, every pair R, C q R.C occurs 0 , introduce fresh role
name RC . replace (positive) occurrence q R.C 0 q RC
add following concept role inclusions TBox:

vC
RC



RC v R.

repeat procedure occurrences qualified number restrictions eliminated. Denote 00 resulting TBox. Observe (A1 ) (A2 ) ensure 00
satisfies (A3 ). notice C occurs right-hand side extra
axioms thus 00 belongs fragment 0 . clear that, since
q R.C occur positively, every model 00 model 0 . Conversely, every
model 0 0 , model 00 00 based domain 00 coincides
00 = {(w, u) RI 0 | u C 0 }, new role R . So,
0 symbols 0 RC
C
without loss generality may assume 0 = 00 .
Let
0
0
0
Tirref
Tdisj
,
0 = T00 Tref
0 , T0
0
Tref
irref Tdisj sets role reflexivity, irreflexivity disjointness con(HN )

straints 0 T00 remaining DL-Litebool
TBox. Let




0
T10 = > v Id, Id v Id
Id v P | Ref(P ) Tref
,


A01 = Id(ai , ai ) | ai ob(A0 ) .
(HN )

construct K modifying DL-Litebool
KB K0 = (T00 T10 , A0 A01 ) two steps:
0 , take fresh role name
Step 1. every reflexivity constraint Ref(P ) Tref
P
38

fiThe DL-Lite Family Relations

add new role inclusion SP v P TBox;
replace every basic concept B T00 B SP , defined inductively follows:
ASP = A, concept name A,
( q R)SP = q R, role R
/ {P, P },
( q P )SP = (q 1) SP ( q P )SP = (q 1) SP , q 2,
(P )SP = > (P )SP = >;
replace R(ai , aj ) A0 R 0 P SP (ai , aj ) whenever 6= j.
Intuitively, split role P irreflexive part SP Id. Note P
reflexive proper sub-role then, (A3 ), restrictions maximal number
P -successors P -predecessors, therefore SP Ref(P ) 0 . Let (T1 , A)
(HN )
resulting DL-Litebool
KB. Clearly, (T1 , A) satisfies (Id1 )(Id3 ). Observe
CleT1 (A) role(K0 ) = CleT 0 0 (A0 ),
0

1

(45)

role(K0 ) means restriction role names K0 .
Let IM untangled model (T1 , A). show IM |= T00 . Consider role P
Ref(P ) 0 . Notice SP proper sub-roles T1 IdIM disjoint
SPIM . Thus, SPIM IdIM P IM
(*) (B SP )IM B IM , B = q R q 2, whenever Ref(P ) 0 , R {P, P }
P proper sub-role 0 .
P proper sub-roles 0 (i.e., proper sub-roles T1 different SP Id)
SPIM IdIM = P IM . So, basic concepts B T00 covered (*),
B IM = (B SP )IM . follows (A3 ) IM |= T00 .
0
0 }
Step 2. Next take account set = Tdisj
{Dis(Pk , Id) | Irr(Pk ) Tirref
disjointness constraints modifying KB (T1 , A) constructed previous step.
Observe R1 v logical consequence {Dis(R1 , R2 )} whenever R1 vT R2 .
Let = T1 T2 , T2 defined taking



T2 = R1 v R1 vT1 R2 either Dis(R1 , R2 ) Dis(R2 , R1 ) .
(role), untangled model IM (T , A) R1 , R2 role (K), IM |= Dis(R1 , R2 )
R1 (ai , aj ), R2 (ai , aj ) CleT1 (A), which, (45), means
R1 (ai , aj ), R2 (ai , aj ) CleT 0 0 (A0 ). So, (44) holds every untangled model IM
0

1

0 . IdIM identity relation,
(T , A) model T1 thus, IM |= Tdisj
0
0
0
IM |= Tref Tirref . (45), IM |= shown above, IM |= T00 .
Therefore, IM |= K0 .
Conversely, suppose 0 model K0 . Let interpretation IdI
0
0
0
identity relation, SPI = P \ IdI , P Ref(P ) 0 , AI = AI ,
0
0
P = P aI = aI , concept, role object names A, P K0 . Clearly,
|= (T00 T10 , A0 A01 ). definition SP , |= T1 and, since |= D, obtain
|= T2 thus |= . (45), |= A, whence |= K.
q

39

fiArtale, Calvanese, Kontchakov & Zakharyaschev

(HN )

Now, follows Lemma 5.17, given DL-Lite
KB K0 , {krom, horn,

(HN )
bool}, compute DL-Litebool
KB K using LogSpace transducer (which
essentially required checking whether R 0 P ). immediately obtain Theorem 5.13
Lemma 5.14 observing that, {krom, horn, bool}, Ke belongs
respective first-order fragment condition (44) checked NLogSpace
(HN )
(computing CleT (A) requires directed graph accessibility checks). result DL-Litecore
(HN )
follows corresponding result DL-Litekrom .
5.4 Role Transitivity Constraints
(HN )+

consider languages DL-Lite
, {core, krom, horn, bool}, extend
(HN )
DL-Lite
role transitivity constraints form Tra(Pk ). remind reader
role called simple (see, e.g., Horrocks et al., 2000) transitive sub-roles
(including itself) simple roles R allowed concepts form q R,
q 2. particular, contains Tra(P ) P P simple, cannot
contain occurrences concepts form q P q P , q 2.
(HN )+
DL-Lite
KB K = (T , A), define transitive closure TraT (A)
taking


TraT (A) = P (ai1 , ) | ai2 . . . ain1 P (ai1 , aij+1 ) A, 1 j < n, Tra(P ) .
Clearly, TraT (A) computed NLogSpace: pair (ai , aj ) objects ob(A),
add P (ai , aj ) TraT (A) iff P -path length < |ob(A)| ai aj
(recall directed graph reachability problem NLogSpace-complete).
(HN )+

(HN )

Lemma 5.18 DL-Lite
KB (T , A) satisfiable iff DL-Lite
KB (T 0 , A0 )
0
satisfiable, results removing transitivity axioms
A0 = CleT (TraT (CleT (A))).
Proof Indeed, KB (T 0 , A0 ) satisfiable construct model described
proofs Lemmas 5.14 5.17 take transitive closure P every P
Tra(P ) (and update RI P vT R). P P simple, contains
axioms imposing upper bounds number P -successors predecessors,
resulting interpretation must model (T , A). converse direction trivial. q
note analogue Remark 5.15 holds case: replace CleT (A)
CleT (TraT (CleT (A))) (ABox) take transitive closure transitive subrole (role).
Remark 5.19 noted two different reasons reduction
Lemma 5.18 NLogSpace rather LogSpace (as reduction is). First,
order compute CleT (A), pair ai , aj , one find path directed
graph induced role inclusion axioms. Second, order compute TraT (CleT (A)), one
find path graph induced ABox itself. So, concerned
data complexity, CleT (A) computed LogSpace (in fact, AC0 , shall
40

fiThe DL-Lite Family Relations

see Section 6.1) role inclusion graph (and hence size) depend
A. second reason, however, dangerous data complexity shall see
Section 6.1.
consequence Lemma 5.18 Theorem 5.13 obtain following:
(HN )+

Corollary 5.20 combined complexity, (i) satisfiability DL-Litebool
complete; (ii)
(HN )+
DL-Litekrom

(HN )+
satisfiability DL-Litehorn KBs P-complete;
(HN )+
DL-Litecore
KBs NLogSpace-complete.

KBs NP-

(iii) satisfiability

Note KBs contain number restrictions form q R,
q 2, (as extensions DL-LiteH
languages) result depend
UNA.
Remark 5.21 noted role disjointness, symmetry, asymmetry transitivity constraints added logics DL-LiteHF
DL-LiteHN

,
{core, krom, horn, bool}, without changing combined complexity satisfiability problems (which, Corollary 5.12, ExpTime-complete). Indeed, follows
Theorem 10 Glimm et al. (2007), KB satisfiability extension SHIQ
role conjunction ExpTime length role conjunctions bounded
constant (in case, constant 2 Dis(R1 , R2 ) encoded
(R1 u R2 ).> v ; Asym(R) dealt similarly). conjecture role reflexivity irreflexivity constraints change complexity either.

6. Instance Checking: Data Complexity
far assumed whole KB K = (T , A) input satisfiability problem. According classification suggested Vardi (1982), considering
combined complexity. Two types complexity knowledge bases are:
schema (or TBox ) complexity, TBox regarded input,
ABox assumed fixed;
data (or ABox ) complexity, ABox regarded input.
easy see schema complexity satisfiability problem logics
considered coincides corresponding combined complexity. section,
analyze data complexity satisfiability instance checking.
(HN )

H
6.1 DL-LiteN
bool , DL-Litebool DL-Litebool

AC0

follows, without loss generality assume role concept names
given knowledge base K = (T , A) occur TBox write role(T ), role (T )
dr(T ) instead role(K), role (K) dr(K), respectively; set concept names
(HN )
denoted con(T ). section reduce satisfiability DL-Litebool KBs model
checking first-order logic. end, fix signature containing two unary predicates
Ak Ak , concept name Ak , two binary predicates Pk Pk , role
name Pk .
41

fiArtale, Calvanese, Kontchakov & Zakharyaschev

(HN )

Consider first case DL-Litebool
KB K. represent ABox K
first-order model AA signature. domain AA ob(A) and,
ai , aj ob(A) predicates Ak , Ak , Pk Pk signature,
AA |= Ak [ai ]

iff

Ak (ai ) A,

AA |= Pk [ai , aj ]

iff

Pk (ai , aj ) A,

AA |= Ak [ai ]

iff

Ak (ai ) A,

AA |= Pk [ai , aj ]

iff

Pk (ai , aj ) A.

construct first-order sentence signature (i) depends
depend A, (ii) AA |= iff Ke satisfiable.
simplify presentation, denote ext(T ) extension following
concept inclusions:
0
0
00
q 0 R v q R, R role (T ) q, q 0 QR
q > q q > q > q
00
R
q QT ,
0
0
q R v q R0 , q QR
R v R inv(R) v inv(R ) .
V
Clearly, (ext(T )) (x) equivalent (in first-order logic) (x)T R (x) Rrole (T ) R (x);
see (1), (5) (42).
Let Bcon(T ) set basic concepts occurring (i.e., concepts form
q R, con(T ), R role (T ) q QR
). indicate basic concepts
hold hold domain element first-order model Ke , use functions
: Bcon(T ) {>, }, called types. Denote Tp set types
(there 2|Bcon(T )| them). complex concept C, define (C) induction:
(C) = (C) (C1 u C2 ) = (C1 ) (C2 ). propositional variable-free formula
^

=
(C1 ) (C2 )
C1 vC2 ext(T )

ensures type consistent concept role inclusions .
emphasized built > using Boolean connectives therefore
depend particular domain element AA . following formula true given
1
2
element x AA type (see Ae ; (2) (43), respectively):
(x) =

^


(Ak (x) (Ak )) (Ak (x) (Ak ))



Ak con(T )

^

^

Eq RT (x) ( q R)



^



Rrole (T ) qQR



xy PkT (x, y) Pk (x, y) ,

Pk role(T )

Eq RT (x) RT (x, y), R role (T ), abbreviations defined
^
^

Eq RT (x) = y1 . . . yq
(yi 6= yj )
RT (x, yi ) ,
1i<jq

RT (x, y) =

_
Pk vT

Pk (x, y)



_
Pk vT

R

42

(46)

1iq

Pk (y, x).
R

(47)

fiThe DL-Lite Family Relations

Clearly, R(ai , aj ) CleT (A) iff AA |= RT [ai , aj ] AA |= Eq RT [a] iff
least q distinct R-successors CleT (A) (and thus every model K).
Without loss generality may assume role (T ) = {R1 , . . . , Rk } 6= . Denote
Tpk set k-tuples ~ containing type dri Tp role Ri role (T ).
set
_
~
x (x),

=
k
~
Tp


(dr1 ,...,drk )



(x)

=

_

(x)

^




dr






Tp

Ri role (T )

^



(Ri )

Ri role (T )

_



ds (Ri ) inv(dri ) (inv(Ri )) .

Srole (T )

explain meaning subformulas , assume (T , A) satisfiable. order
construct model Ke first-order model AA , specify basic
concepts contain given constant Ke . words, select type
dri dr(T ) ob(A). formula says one select k-tuple
types ~ = (dr1 , . . . , drk ) Tpk one disjuncts true AA .
k-tuple fixes witness part model M, consisting dri , determines
basic concepts dri belong to. disjunct says (having fixed
witness part model), every ob(A), type (determining basic
concepts belongs to)
consistent information (cf. (x));
consistent concept role inclusions (cf. );
);
dr1 , . . . , drk consistent concept role inclusions (cf. dr


role Ri nonempty domain (i.e., either ds > Ri )
nonempty range, particular, inv(dri ) (inv(Ri )) = >; see R (x) defined
(4).
Lemma 6.1 AA |= iff Ke satisfiable.
~
Proof () Fix ~ = (dr1 , . . . , drk ) Tpk AA |= x (x). Then,
~

ob(A), fix type respective disjunct (x) holds AA
denote . Define first-order model domain ob(A) dr(T ) taking:
|= B [c] iff c (B) = >, c ob(A) dr(T ) B Bcon(T )
(B unary predicate B defined p. 22). easy check |= Ke .
() Suppose Ke satisfiable. model Ke domain
ob(A) dr(T ). see AA |= , suffices take functions dri defined
by:
43

fiArtale, Calvanese, Kontchakov & Zakharyaschev

dri (B) = > iff |= B [dri ], dri dr(T ) B Bcon(T ),
(B) = > iff |= B [a], ob(A) B Bcon(T ).
Details left reader.

q

follows Lemmas 6.1 5.17 Corollary 5.16 have:
H
Corollary 6.2 satisfiability instance checking problems DL-LiteN
bool , DL-Litebool
(HN )
DL-Litebool KBs AC0 data complexity.
(HN )

H
Proof DL-LiteN
bool DL-Litebool sub-languages DL-Litebool ,
(HN )
result immediately follows Lemma 6.1 Corollary 5.16. DL-Litebool KB
(HN )

K0 = (T 0 , A0 ), Lemma 5.17, construct DL-Litebool
KB K = (T , A)
0
K satisfiable iff K satisfiable (44) holds. latter condition corresponds
following first-order sentence
^
^


0 =
xy R1T (x, y) R2T (x, y)

x PkT (x, x) ,
Dis(R1 ,R2 )T 0

Irr(Pk )T 0

evaluated AA . Therefore, K0 satisfiable iff AA |= 0 . Let = 0 0
result replacing SP (t1 , t2 ), Ref(P ) 0 , P (t1 , t2 ) (t1 6= t2 ); see
proof Lemma 5.17. remains observe AA |= iff AA0 |= 0 .
q
before, result depend UNA member DL-Lite family
number restrictions form q R, q 2 (in particular, DL-LiteH
bool
fragments).
note transitive roles cannot included languages free
concerned data complexity:
Lemma 6.3 Satisfiability instance checking DL-Litecore KBs extended role transitivity constraints NLogSpace-hard data complexity.
Proof Suppose given directed graph. Let P role name. Define ABox
taking P (ai , aj ) iff edge (ai , aj ) graph. node
reachable node a0 iff DL-Litecore ABox {P (a0 , )} satisfiable
models transitive P . encoding immediately gives claim lemma
directed graph reachability problem NLogSpace-complete, NLogSpace closed
complement (see, e.g., Kozen, 2006) TBox {Tra(P )} depend
input.
q
hand, reduction Lemma 5.18 computable NLogSpace,
obtain following:
(HN )+

Corollary 6.4 Satisfiability instance checking DL-Litebool
complete data complexity.

KBs NLogSpace-

Proof upper bound obtained applying NLogSpace reduction Lemma 5.18
using Corollary 6.2. lower bound follows Lemma 6.3.
q

44

fiThe DL-Lite Family Relations

6.2 P- coNP-hardness Data Complexity
Let us turn data complexity instance checking DL-Lite logics
arbitrary number restrictions role inclusions. follows results Ortiz et al.
(2006) SHIQ, instance checking (and fact query answering) DL-LiteHN
bool
coNP data complexity, results Hustadt et al. (2005) Eiter et al. (2008)
Horn-SHIQ imply polynomial-time upper bound DL-LiteHF
horn .
show upper bounds optimal following sense: one
hand, instance checking DL-LiteHF
core P-hard data complexity; hand,
HN
becomes coNP-hard DL-LiteHF
krom DL-Litecore (that is, allow negated
concept names arbitrary number restrictionsin fact, 2 R enough). Note
results section depend whether adopt UNA not.
Theorem 6.5 instance checking (and query answering) problem DL-LiteHF
krom KBs
data-hard coNP (with without UNA).
Proof proof reduction unsatisfiability problem 2+2CNF,
known coNP-complete (Schaerf, 1993). Given 2+2CNF formula
=

n
^

(ak,1 ak,2 ak,3 ak,4 ),

k=1

ak,j one propositional variables a1 , . . . , , construct KB (T , )
whose TBox depend . use object names f , ck , 1 k n,
ai , 1 m, role names S, Sf Pj , Pj,t , Pj,f , 1 j 4, concept names
D.
Define set following assertions, 1 k n:
S(f, ck ),

P1 (ck , ak,1 ),

P2 (ck , ak,2 ),

P3 (ck , ak,3 ),

P4 (ck , ak,4 ),

let consist axioms
2 Pj v ,
Pj,f v Pj ,

Pj,t v Pj ,

Pj,t v Pj,f ,

Pj,f


Pj,t

v A,

P1,f u P2,f u P3,t u P4,t v

Sf ,

v A,

for1 j 4,

(48)

1 j 4,

(49)

1 j 4,

(50)

1 j 4,

(51)
(52)



2 v ,

(53)

Sf v S,

(54)

Sf v D.

(55)

Note axiom (52) belong DL-LiteHF
krom conjunctions
left-hand side. However, eliminated help Lemma 5.9. let us prove
(T , ) |= D(f ) iff satisfiable.
() Suppose satisfiable |= (T , ). Define assignment
truth values f propositional variables taking a(ai ) = iff aIi AI . false
45

fiArtale, Calvanese, Kontchakov & Zakharyaschev

a, k, 1 k n, a(ak,1 ) = a(ak,2 ) = f a(ak,3 ) = a(ak,4 ) = t.
view (50), j, 1 j 4, cIk (Pj,t )I (Pj,f )I , (49),
cIk (Pj )I . Therefore, (48) (51), cIk (Pj,t )I a(ak,j ) = cIk (Pj,f )I
a(ak,j ) = f, hence, (52), cIk (Sf )I . (53) (54), f (Sf )I ,
which, (55), f DI . follows (T , ) |= D(f ).
() Conversely, suppose satisfiable. assignment
a(ak,1 ) = a(ak,2 ) = a(ak,3 ) = f a(ak,4 ) = f, 1 k n. Define taking



= x | 1 yk | 1 k n z ,
aIi = xi , 1 m,
cIk = yk , 1 k n,
f = z,



AI = xi | a(ai ) = yk | 1 k n z ,




= (y , aI ) | 1 k n, a(a ) = (x , x ) | a(a ) = (z, z) ,
Pj,t


k k,j
k,j



= (y , aI ) | 1 k n, a(a ) = f (x , x ) | a(a ) = f ,
Pj,f


k,j
k k,j
P , 1 j 4,
PjI = Pj,t
j,f


SfI = (z, yk ) | a(ak,1 ak,2 ak,3 ak,4 ) = f = ,


= (z, yk ) | 1 k n ,


DI = z | a() = f = .

hard check |= (T , ) 6|= D(f ).

q

Theorem 6.6 instance checking (and query answering) problem DL-LiteHN
core
KBs data-hard coNP (with without UNA).
Proof proof reduction unsatisfiability problem 2+2CNF.
HF
main difference previous one DL-LiteHN
core , unlike DL-Litekrom , cannot express
covering conditions (50). turns out, however, use number restrictions
represent constraints kind. Given 2+2CNF formula , take ABox
constructed proof Theorem 6.5. ( independent) TBox , describing
meaning representation terms , defined way
proof, except axiom (50) replaced following set axioms:
Tj,1 v Tj ,


2 Tj

v ,

Pj v Tj,1 ,

Tj,1

u


Tj,2

Tj,2 v Tj ,

v

(56)
(57)

Pj v Tj,2 ,


Tj,3
,

2 Tj v Pj,t

Tj,3 v Tj ,

(58)
(59)

Tj,3 v Pj,f ,

(60)

Tj , Tj,1 , Tj,2 , Tj,3 fresh role names, j, 1 j 4. Note axioms (52)
(59) belong DL-LiteHN
core conjunctions left-hand side,
46

fiThe DL-Lite Family Relations

easily eliminate using Lemma 5.9. remains prove (T , ) |= D(f )
iff satisfiable.
() Suppose satisfiable |= (T , ). Define assignment
truth values f propositional variables taking a(ai ) = iff aIi AI .
false a, k, 1 k n, a(ak,1 ) = a(ak,2 ) = f, a(ak,3 ) = a(ak,4 ) = t.
j, 1 j 4, cIk (Pj )I ; (58), cIk (Tj,1 )I , (Tj,2 )I .
(cI , v ) . v 6= v cI ( 2 )I
v1 , v2 (cIk , v1 ) Tj,1
1
2
j
j,2
k 2
k

and, (60), cIk (Pj,t )I . Otherwise, v1 = v2 = v, v (Tj,3
) (59),
(56) (57), cIk (Tj,3 )I , which, (60), cIk (Pj,f )I . Therefore,
cIk (Pj,t )I (Pj,f )I , (49), cIk (Pj )I . Thus, (48) (51), cIk (Pj,t )I
a(ak,j ) = cIk (Pj,f )I a(ak,j ) = f, hence, (52), cIk (Sf )I .
(53) (54), f (Sf )I , which, (55), f DI . follows
(T , ) |= D(f ).
() Conversely, suppose satisfiable. assignment
a(ak,1 ) = a(ak,2 ) = a(ak,3 ) = f a(ak,4 ) = f, 1 k n. Define taking




= xi | 1 yk | 1 k n uk,j,1 , uk,j,2 | 1 j 4, 1 k n z ,
aIi = xi , 1 m,

cIk = yk , 1 k n,

f = z,

AI = {xi | a(ai ) = t},


= (y , aI ) | 1 k n, a(a ) = , 1 j 4,
Pj,t
k,j
k k,j


= (y , aI ) | 1 k n, a(a ) = f , 1 j 4,
Pj,f
k,j
k k,j
P , 1 j 4,
PjI = Pj,t
j,f


= (y , u
Tj,1
k k,j,1 ) | 1 k n , 1 j 4,


= (y , u
Tj,2
k k,j,2 ) | 1 k n, a(ak,j ) =


(yk , uk,j,1 ) | 1 k n, a(ak,j ) = f , 1 j 4,


= (y , u
Tj,3
k,j,1 ) | 1 k n, a(ak,j ) = f , 1 j 4,
TI ,
TjI = Tj,1
j,2


SfI = (z, yk ) | a(ak,1 ak,2 ak,3 ak,4 ) = f = ,


= (z, yk ) | 1 k n ,


DI = z | a() = f = .

hard check |= (T , ) 6|= D(f ).

q

next lower bound would follow Theorem 6, item 2 work Calvanese
et al. (2006); unfortunately, proof incorrect cannot repaired.
Theorem 6.7 instance checking (and query answering) problem DL-LiteHF
core KBs
data-hard P (with without UNA).
47

fiArtale, Calvanese, Kontchakov & Zakharyaschev

Proof proof reduction entailment problem Horn-CNF, known
P-complete (see, e.g., Borger et al., 1997, Exercise 2.2.4). Given Horn-CNF formula
=

n
^

(ak,1 ak,2 ak,3 )



k=1

p
^

al,0 ,

l=1

ak,j al,0 one propositional variables a1 , . . . , , construct
KB (T , ) whose TBox depend . need object names c1 , . . . , cn
vk,j,i , 1 k n, 1 j 3, 1 (for variable, take one object name
possible occurrence variable non-unit clause), role names S, St
Pj , Pj,t , 1 j 3, concept name A.
Define set containing assertions:
S(v1,1,i , v1,2,i ), S(v1,2,i , v1,3,i ), S(v1,3,i , v2,1,i ), S(v2,1,i , v2,2,i ), S(v2,2,i , v2,3,i ), . . .
. . . , S(vn,2,i , vn,3,i ), S(vn,3,i , v1,1,i ),
Pj (vk,j,i , ck )

iff

A(v1,1,i )

al,0 = ai ,

iff

ak,j = ai ,

1 m,

1 m, 1 k n, 1 j 3,
1 m, 1 l p

(all objects variable organized S-cycle Pj (vk,j,i , ck ) iff
variable ai occurs kth non-unit clause jth position). Let consist
following concept role inclusions:
St v S,

(61)

2 v ,

(62)

v St ,
St

(63)

v A,

(64)

2 P1 v
P1,t v P1 ,
v P1,t ,


P1,t

u

2 P3

2 P2 v ,

(65)

P2,t v P2 ,

(66)

v P2,t ,

(67)

v ,

(68)

P3,t v P3 ,

(69)


P2,t

v


P3,t
,

(70)

P3,t v A.

(71)

before, axiom, namely (70), belong DL-LiteHF
core
conjunction left-hand side, eliminated help
Lemma 5.9. aim show (T , ) |= A(v1,1,i0 ) iff |= ai0 .
() Suppose |= ai0 . Consider arbitrary model (T , ) define
assignment truth values f propositional variables a(ai ) = iff


v1,1,i
AI , 1 m. (61)(64), i, 1 m, either vk,j,i
AI ,


k, j 1 k n, 1 j 3, vk,j,i
/ , k, j 1 k n,
1 j 3. Now, a(ak,1 ) = a(ak,2 ) = t, 1 k n then, (65)(67),




cIk (P1,t
) , (P2,t
) . (70), cIk (P3,t
) hence, (68) (69), vk,3,i
(P3,t )I ,
48

fiThe DL-Lite Family Relations

St ,

Pj,t , Pj
Pj

a1 a2 a3
y1

a2 a4 a5
y2




.

xk,j,i
.

zk,j,i
a1

a2

a3

a4

a5

Figure 5: model satisfying (T , ), = (a1 a2 a3 ) (a2 a4 a5 ).


ak,3 = ai , means, (71), vk,3,i
AI , v1,1,i
AI a(ai ) = t.

follows a() = t, hence a(ai0 ) = t, which, definition, means v1,1,i
AI .
0
conclude (T , ) |= A(v1,1,i0 ).

() Conversely, suppose 6|= ai0 . assignment a() =
a(ai0 ) = f. construct model (T , ) 6|= A(v1,1,i0 ). Define
taking



= xk,j,i , zk,j,i | 1 k n, 1 j 3, 1 yk | 1 k n ,
cIk = yk , 1 k n,

= xk,j,i , 1 k n, 1 j 3, 1 m,
vk,j,i


AI = xk,j,i | 1 k n, 1 j 3, a(ai ) = ,
[


SI =
Si , Si = (xk,1,i , xk,2,i ), (xk,2,i , xk,3,i ), (xk,3,i , xk1,1,i ) | 1 k n
1im

k 1 = k + 1 k < n, k 1 = 1 k = n,
[
StI =
Si ,
1im
a(ai )=t



PjI = (xk,j,i , yk ) | 1 k n, ai = ak,j
(xk,j,i , zk,j,i ) | 1 k n, ai 6= ak,j , 1 j 2,


P3I = (xk,3,i , yk ) | 1 k n, ai = ak,3 ,


= (x
Pj,t
k,j,i , yk ) | 1 k n, ai = ak,j , a(a
i) =
(xk,j,i , zk,j,i ) | 1 k n, ai 6= ak,j , 1 j 2,


= (x
P3,t
k,3,i , yk ) | 1 k n, ai = ak,3 , a(ai ) = .
routine check indeed |= (T , ) 6|= A(v1,1,i0 ). See Figure 5
example.
q

49

fiArtale, Calvanese, Kontchakov & Zakharyaschev

7. Query Answering: Data Complexity
positive existential query answering problem known data-complete coNP
case DL-LiteHN
bool : upper bound follows results Ortiz et al. (2006),
lower bound established DL-Litekrom Calvanese et al. (2006), Schaerf
(1993). case DL-LiteHF
horn , query answering data-complete P, follows
results Hustadt et al. (2005) Eiter et al. (2008) Horn-SHIQ,
0
DL-LiteH
horn AC (Calvanese et al., 2006).
fact, coNP upper bound holds extension DL-LiteHN
bool role disjointness (a)symmetry constraints (this follows Glimm et al., 2007, Theorem 10;
cf. Remark 5.21). conjecture result holds role (ir)reflexivity constraints.
main result section following:
Theorem 7.1 positive existential query answering problem logics DL-LiteN
horn ,
(HN )
H
0
DL-Litehorn DL-Litehorn AC data complexity.
(HN )

Proof Suppose given consistent DL-Litehorn KB K0 = (T 0 , A0 ) (with
concept role names occurring TBox 0 ) positive existential query prenex
(HN )
form q(~x) = ~y (~x, ~y ) signature K0 . Consider DL-Litehorn KB K = (T , A)
(HN )

provided Lemma 5.17 (the language DL-Litehorn

defined Section 5.3).

Lemma 7.2 every tuple ~a object names K0 , K0 |= q(~a) iff |= q(~a)
untangled models K.
Proof () Suppose K0 |= q(~a) untangled model K. Lemma 5.17
view consistency K0 , ensures (44) holds, |= K0
therefore, |= q(~a).
() Suppose 0 |= K0 . Lemma 5.17, model K domain
0
coincides 0 symbols K0 . |= q(~a), must 0 |= q(~a),
K0 |= q(~a) required.
q
Next show that, Ke Horn sentence, enough consider one special
model I0 K formulation Lemma 7.2. Let M0 minimal Herbrand model
(the universal Horn sentence) Ke . remind reader (for details consult, e.g., Apt, 1990;
Rautenberg, 2006) M0 constructed taking intersection Herbrand
models Ke , is, models based domain consists constant symbols
Ke i.e., = ob(A) dr(T ); cf. Remark 5.15. following
M0 |= B [c]

iff

Ke |= B (c),

B Bcon(T ) c .

Let I0 untangled model K induced M0 . Denote domain I0 I0 .
Property (copy) Remark 5.15 provides us function cp : I0 .
two consequences Lemma 5.14. First,
aIi 0 B I0

iff

K |= B(ai ),

B Bcon(T ) ai ob(A).

50

(72)

fiThe DL-Lite Family Relations

Second, every R role (T ), RI0 6= RI 6= , models K. Indeed,
RI0 6= M0 |= (R) [dr]. Therefore, (T {R v }, A) satisfiable, thus
RI 6= , |= K. Moreover, RI0 6=
w B I0

iff

K |= R v B,

B Bcon(T ) w I0 cp(w) = dr. (73)

Lemma 7.3 I0 |= q(~a) |= q(~a) untangled models K.
Proof Suppose |= K. q(~a) positive existential sentence, enough construct
homomorphism h : I0 I. remind reader that, (forest), domain I0
I0 partitioned disjoint trees Ta , ob(A). Define depth point w I0
length shortest path respective tree root. Denote Wm
set points depth m; particular, W0 = {aI0 | ob(A)}. construct h
union maps hm , 0, hm defined Wm following properties:
hm+1 (w) = hm (w), w Wm ,
(am ) every w Wm , w B I0 hm (w) B , B Bcon(T );
(bm ) u, v Wm , (u, v) RI0 (hm (u), hm (v)) RI , R role (T ).
basis induction, set h0 (aIi 0 ) = aIi , ai ob(A). Property (a0 ) follows
(72) (b0 ) (ABox) Remark 5.15.
induction step, suppose hm already defined Wm , 0. Set
hm+1 (w) = hm (w) w Wm . Consider arbitrary v Wm+1 \ Wm . (forest),
unique u Wm (u, v) Ea , Ta . Let `a (u, v) = S. Then,
(copy), cp(v) = inv(ds). (role), u (S)I0 and, (am ), hm (u) (S)I ,
means w (hm (u), w) . Set hm+1 (v) = w. cp(v) = inv(ds)
(inv(S))I0 6= , follows (73) v B I0 w0 B whenever
w0 (inv(S))I . w (inv(S))I , obtain (am+1 ) v. show (bm+1 ), notice
that, (role), (w, v) RI0 , w Wm+1 , two cases: either
w Wm+1 \ Wm , w = v Id vT R, w Wm , w = u vT R.
former case, (hm+1 (v), hm+1 (v)) RI IdI identity relation (role).
latter case, (u, v) I0 ; hence (hm+1 (u), hm+1 (v)) and, vT R,
(hm+1 (u), hm+1 (v)) RI .
q
Assume that, query q(~x) = ~y (~x, ~y ), ~y = y1 , . . . , yk ,
quantifier-free formula. next lemma shows case check whether I0 |= q(~a)
suffices consider points depth m0 I0 , m0
depend |A|.
Lemma 7.4 Let m0 = k + |role (T )|. I0 |= ~y (~a, ~y ) assignment a0
Wm0 (i.e., a0 (yi ) Wm0 i) I0 |=a0 (~a, ~y ).
Proof Suppose I0 |=a (~a, ~y ), assignment I0 , yi ,
1 k, a(yi )
/ Wm0 . Let minimal subset ~y contains yi
every either P (y 0 , y) P (y, 0 ) subformula , 0
role name P . Let yj > |role (T )| a(yj ) Wm
51

fiArtale, Calvanese, Kontchakov & Zakharyaschev

a(y)
/ Wm1 (for convenience, W1 = before). Clearly, exists:
a(yi )
/ Wm0 , k variables and, (forest), relations P I0 connect point
Wn \ Wn1 point Wn+1 \ Wn2 , n 1. Let w = a(yj ) point
Ta . w Wm \ Wm1 , cp(w) = dr, R role (T ).
|role (T )| distinct labels labeled tree Ta view (copy), point u
depth > |role (T )|, point u0 depth |role (T )| Ta
cp(u) = cp(u0 ); (iso), trees generated u u0 isomorphic. So,
isomorphism g labeled tree generated w (which contains a(y), )
onto labeled tree generated point depth |role (T )| Ta . Define new
assignment aY taking aY (y) = g(a(y)) aY (y) = a(y) otherwise. (copy),
(concept) (role) I0 |=aY (~a, ~y ) aY (y) Wm0 , .
aY (yj )
/ Wm0 j, repeat described construction. k iterations
shall obtain assignment a0 required lemma.
q
complete proof Theorem 7.1, encode problem K |= q(~a)? model
checking problem first-order formulas. precisely way Section 6.1,
fix signature contains unary predicates A, A, concept name A, binary
predicates P , P , role name P , represent ABox K first-order
model AA domain ob(A). define first-order formula ,q (~x)
signature (i) ,q (~x) depends q A, (ii) AA |= ,q (~a)
iff I0 |= q(~a).
begin defining formulas B (x), B Bcon(T ), describe types
elements ob(A) model I0 following sense (see (72)):
AA |= B [ai ]

iff aIi 0 B I0 ,

B Bcon(T ) ai ob(A).

(74)

0 (x), 1 (x), . . . formulas
formulas defined fixed-points sequences B
B
one free variable,
(
A(x),
B = A,
0
B (x) =

Eq R (x), B = q R,
_

i1
i1

0
B
(x) = B
(x)
B
(x) B
(x) , 1,
1
k
B1 uuBk vBext(T )

Eq RT (x) given (46). (As Section 6.1, simplify presentation use ext(T ) instead .) clear that, B Bcon(T ),
(x) i+1 (x) (i.e., every (x) equivalent i+1 (x) first-order logic),
B
B
B
B
(x) j (x) every B Bcon(T ) j i. minimum
B
B
N (x).
exceed N = |Bcon(T )|, set B (x) = B
Next introduce sentences B,dr , B Bcon(T ) dr dr(T ), describe
types elements dr(T ) following sense (see (73)):
AA |= B,dr

iff

w B I0 , B Bcon(T ) w I0 cp(w) = dr.

(75)

(By (concept), definition correct.) sentences defined similarly B (x).
Namely, B Bcon(T ) dr dr(T ), inductively define sequence
52

fiThe DL-Lite Family Relations

0
1
B,dr
, B,dr
, . . . taking
0
B,dr
= 0B,dr




B,dr
= iB,dr

_


i1
i1
B






, 1,
,dr
B
,dr
1
k

B1 uuBk vBext(T )

iB,dr = , 0, whenever B 6= R
0R,dr = x inv(R) (x)



iR,dr =

_

i1
inv(R),ds
,

1.

dsdr(T )
i+1

clear |role (T )|N B,dr
B,dr
, B Bcon(T )
|role (T )|N

dr dr(T ). set B,dr = B,dr
.
consider directed graph GT = (VT , ET ), VT set equivalence
classes [R], [R] = {R0 | R R0 }, R empty model , ET
set pairs ([Ri ], [Rj ])
(path) |= inv(Ri ) v q Rj



either inv(Ri ) 6vT Rj q 2,

Rj proper sub-role satisfying (path). ([Ri ], [Rj ]) ET iff,
ABox A0 , whenever minimal untangled model I0 (T , A0 ) contains copy w inv(dri0 ),
Ri0 [Ri ], w connected copy inv(drj0 ), Rj0 [Rj ], relations
Rj vT S.
Recall given query q(~x) = ~y (~x, ~y ), quantifier-free
positive formula ~y = y1 , . . . , yk . Let ,m0 set paths graph GT
length m0 . precisely,


,m0 = ([R1 ], [R2 ], . . . , [Rn ]) | 1 n m0 , ([Rj ], [Rj+1 ]) ET , 1 j < n .
R

, 0 ,m0 role R role (T ), write 0 one following three
conditions satisfied: (i) = 0 Id vT R, (ii) .[S] = 0 (iii) = 0 .[inv(S)],
role vT R.
Let kT ,m0 set k-tuples form ~ = (1 , . . . , k ), ,m0 . Intuitively,
evaluating query ~y (~x, ~y ) I0 , bound, non-distinguished, variable yi
mapped point w Wm0 . However, first-order model AA contain
points Wm0 \ W0 , represent them, use following trick. (forest),
every point w Wm0 uniquely determined pair (a, ), aI0 root
tree Ta containing w, sequence labels `a (u, v) path aI0 w.
follows unraveling procedure (path) ,m0 . So, formula
,q define assume yi range W0 represent first
component pairs (a, ), whereas second component encoded ith member
~ (these yi confused yi original query q, range
Wm0 ). order treat arbitrary terms occurring (~x, ~y ) uniform way,
set t~ = , = ob(A) = xi , t~ = , = yi (the distinguished variables xi
object names mapped W0 require second component
pairs).
Given assignment a0 Wm0 denote split(a0 ) pair (a, ~ ),
assignment AA ~ = (1 , . . . , k ) kT ,m0
53

fiArtale, Calvanese, Kontchakov & Zakharyaschev

distinguished variable xi , a(xi ) = aI0 = a0 (xi );
bound variable yi , a(yi ) = = ([R1 ], . . . , [Rn ]), n m0 , aI0
root tree containing a0 (yi ) R1 , . . . , Rn sequence
labels `a (u, v) path aI0 a0 (yi ).
every pair (a, ~ ), however, corresponds assignment Wm0 paths
~ may exist I0 : GT represents possible paths models fixed
TBox varying ABox. follows unraveling procedure, point Wm0 \ W0
corresponds ob(A) = ([R], . . . ) ,m0 iff enough R-witnesses
0
R
A, i.e., iff AA |= q
)
R [a] q R [a], q QT . Thus, every (a, ~
~ = (1 , . . . , k ), assignment a0 Wm0 split(a0 ) = (a, ~ ) iff AA |=a ~ (~y ),

^
_

0
q
(1 ,...,k ) (y1 , . . . , yk ) =
Ri (yi ) q Ri (yi )
R

1ik
6=

qQT

Ri , 1 k 6= , = ([Ri ], . . . ).
define now, every ~ kT ,m0 , concept name role name R,
(
(t),
t~ = ,
A~ (t) =
A,inv(ds) , t~ = 0 .[S], 0 ,m0 ,

~

~


R (t1 , t2 ), t1 = t2 = ,
R
R~ (t1 , t2 ) =
(t1 = t2 ),
t~1 t~2 either t~1 6= t~2 6= ,


,
otherwise,
RT (y1 , y2 ) given (47). claim that, every assignment a0 Wm0
(a, ) = split(a0 ),
I0 |=a0 A(t)

iff

AA |=a A~ (t),

I0 |=a0 R(t1 , t2 )

iff

AA |=a R~ (t1 , t2 ),

concept names terms t,
roles R terms t1 , t2 .

(76)
(77)

A(a), A(xi ) A(yi ) = claim follows (74). A(yi ) = 0 .[S],
(copy), cp(a(yi )) = inv(dr), R [S]; claim follows (75).
R(yi1 , yi2 ) i1 = i2 = , claim follows (ABox). Let us consider case
R(yi1 , yi2 ) i2 6= : a0 (yi2 )
/ W0 thus, (role), I0 |=a0 R(yi1 , yi2 ) iff
a0 (yi1 ), a0 (yi2 ) tree Ta , ob(A), i.e., AA |=a (yi1 = yi2 ),
either (a0 (yi1 ), a0 (yi2 )) Ea `a (a0 (yi1 ), a0 (yi2 )) = vT R,
(a0 (yi2 ), a0 (yi1 )) Ea `a (a0 (yi2 ), a0 (yi1 )) = inv(S) vT R,
R

a0 (yi1 ) = a0 (yi2 ) Id vT R, i.e., i1 i2 .
cases similar left reader.
Finally, let ~ (~x, ~y ) result attaching superscript ~ atom

_
,q (~x) = ~y
~ (~x, ~y ) ~ (~y ) .
~
kT ,m

0

54

fiThe DL-Lite Family Relations

follows (76)(77), every assignment a0 Wm0 , I0 |=a0 (~x, ~y ) iff
AA |=a ~ (~x, ~y ) (a, ) = split(a0 ). converse direction notice that, AA |=a ~ (~y )
assignment a0 Wm0 split(a0 ) = (a, ~ ).
Clearly, AA |= ,q (~a) iff I0 |= q(~a), every tuple ~a. note that, every
pair tuples ~a ~b object names ob(A), ~ (~a, ~b) positive existential sentence
inequalities, domain-independent.10 easily seen that, ~b,
~ (~b) domain-independent. follows minimality I0 ,q (~a) domainindependent, tuple ~a object names ob(A).

Finally, note resulting query contains |role (T )|k(k+|role (T )|) disjuncts. q

8. DL-Lite without Unique Name Assumption
section, unless otherwise stated, assume interpretations respect
UNA, is, may aIi = aIj distinct object names ai aj . consequence
relation |=noUNA refers class interpretations.
Description logics without UNA usually extended additional equality
inequality constraints form:
ai aj



ai 6 aj ,

ai , aj object names. semantics quite obvious: |= ai aj iff
aIi = aIj , |= ai 6 aj iff aIi 6= aIj . equality inequality constraints supposed
belong ABox part knowledge base. noted, however, reasoning
equalities LogSpace-reducible reasoning without them:
Lemma 8.1 every KB K = (T , A), one construct LogSpace size
KB K0 = (T , A0 ) without equality constraints |= K iff |= K0 , every
interpretation I.
Proof Let G = (V, E) undirected graph


V = ob(A),
E = (ai , aj ) | ai aj aj ai
[ai ] set vertices G reachable ai . Define A0 removing
equality constraints replacing every ai aj [ai ] minimal j. Note
minimal j computed LogSpace: enumerate object names aj
respect order indexes j check whether current aj reachable
ai G. remains recall reachability undirected graphs SLogSpace-complete
SLogSpace = LogSpace (Reingold, 2008).
q
mentioned Section 5.3, logics form DL-LiteH
feel whether
adopt UNA not. observation Lemmas 5.17, 5.18 8.1 hand,
obtain following result consequence Theorem 5.13:
10. query q(~
x) said domain-independent case AA |=a q(~
x) iff |=a q(~
x),
domain contains ob(A), active domain AA , AA = AAA P = P AA , concept
role names P .

55

fiArtale, Calvanese, Kontchakov & Zakharyaschev

Theorem 8.2 without UNA, combined complexity, (i) satisfiability
H
DL-LiteH
bool KBs NP-complete; (ii) satisfiability DL-Litehorn KBs P-complete;
H
(iii) satisfiability DL-LiteH
krom DL-Litecore KBs NLogSpace-complete. results hold even KBs contain role disjointness, (a)symmetry, (ir )reflexivity transitivity constraints, equalities inequalities.
hand, Corollary 6.2 Lemmas 5.17, 5.18 8.1 derive
following:
Theorem 8.3 Without UNA, satisfiability instance checking DL-LiteH
bool KBs
0
0
AC data complexity. problems AC KBs contain role
disjointness, (a)symmetry (ir )reflexivity constraints inequalities. However,
LogSpace-complete KBs may contain equalities, NLogSpace-complete
role transitivity constraints allowed.
note complexity results (Corollary 5.12, Theorems 6.5, 6.6 6.7)
logics DL-LiteHF
DL-LiteHN
depend UNA.


section, analyze combined data complexity reasoning logics
(HF )
(HN )
form DL-Lite
DL-Lite
(as well fragments) without UNA.
obtained known results summarized Table 2 page 17.
(HN )

8.1 DL-Lite

: Arbitrary Number Restrictions

following theorem shows interaction number restrictions
possibility identifying objects ABox results higher complexity.
Theorem 8.4 Without UNA, satisfiability DL-LiteN
core KBs (even without equality
inequality constraints) NP-hard combined data complexity.
Proof proof reduction following variant 3SAT problemcalled monotone one-in-three 3SAT known NP-complete (Garey & Johnson, 1979):
given positive 3CNF formula
=

n
^


ak,1 ak,2 ak,3 ,

k=1

ak,j one propositional variables a1 , . . . , , decide whether
assignment variables aj exactly one variable true clauses
k
. encode problem language DL-LiteN
core , need object names ai ,
1 k n, 1 m, ck tk , 1 k n, role names P , concept
names A1 , A2 , A3 . Let ABox containing following assertions:
S(a1i , a2i ), . . . , S(ain1 , ani ), S(ani , a1i ),

1 m,

S(t1 , t2 ), . . . , S(tn1 , tn ), S(tn , t1 ),
P (ck , tk ),

1 k n,

P (ck , akk,j ), Aj (akk,j ),

1 k n, 1 j 3,

56

fiThe DL-Lite Family Relations

let TBox following axioms:
A1 v A2 ,

A2 v A3 ,

A3 v A1 ,

2 v ,

4 P v .

Clearly, (T , ) DL-LiteN
core KB depend (so cover
combined data complexity). claim answer monotone one-in-three
3SAT problem positive iff (T , ) satisfiable without UNA.
() Suppose |= (T , ). Define assignment truth values f
propositional variables taking a(ai ) = iff (a1i )I = (t1 )I . aim show
a(ak,j ) = exactly one j {1, 2, 3}, k, 1 k n. j {1, 2, 3},
(cIk , (akk,j )I ) P . Moreover, (akk,i )I 6= (akk,j )I 6= j. cIk ( 3 P )I
(cIk , (tk )I ) P , must (akk,j )I = (tk )I unique j {1, 2, 3}. follows
functionality that, 1 k n, (a1k,j )I = (t1 )I exactly one
j {1, 2, 3}.
() Let assignment satisfying monotone one-in-three 3SAT problem. Take
ai0 a(ai0 ) = (clearly, i0 exists, otherwise a() = f) construct
interpretation = (I , ) taking:



= yk , z k | 1 k n xki | a(ai ) = f, 1 m, 1 k n ,
cIk = yk (tk )I = z k , 1 k n,
(
xki , a(ai ) = f,
(aki )I =
1 m, 1 k n,
z k , a(ai ) = t,


= ((a1i )I , (a2i )I ), . . . , ((ain1 )I , (ani )I ), ((ani )I , (a1i )I ) | 1 ,


P = (cIk , (tk )I ), (cIk , (akk,1 )I ), (cIk , (akk,2 )I ), (cIk , (akk,3 )I ) | 1 k n .
readily checked |= (T , ).

q

fact, lower bound optimal:
(HN )

(HN )+

Theorem 8.5 Without UNA, satisfiability DL-LiteN
DL-Lite
, DL-Lite
KBs equality inequality constraints NP-complete combined data
complexity {core, krom, horn, bool}.
Proof lower bound immediate Theorem 8.4, matching upper bound
(HN )+
proved following non-deterministic algorithm. Given DL-Litebool
KB
K = (T , A),
guess equivalence relation ob(A);

select equivalence class ai / representative, say ai , replace every occurrence ai / ai ;
fail equalities inequalities violated resulting ABoxi.e.,
contains ai 6 ai ai aj , 6= j;
57

fiArtale, Calvanese, Kontchakov & Zakharyaschev

otherwise, remove equality inequality constraints ABox denote
result A0 ;
(HN )+

use NP satisfiability checking algorithm DL-Litebool
KB K0 = (T , A0 ) consistent UNA.

decide whether

Clearly, algorithm returns yes, 0 |= K0 , 0 respecting UNA,
construct model K (not necessarily respecting UNA) extending 0
0
following interpretation object names: aI = aIi , whenever ai representative
a/ (I coincides 0 symbols). Conversely, |= K take
equivalence relation defined ai aj iff aIi = aIj . Let 0 constructed
removing interpretations object names representatives
equivalence classes . follows 0 respects UNA 0 |= K0 , algorithm
returns yes.
q
(HF )

8.2 DL-Lite

: Functionality Constraints
(HF )+

Let us consider DL-Litebool
fragments. following lemma shows
logics reasoning without UNA reduced polynomial time size
ABox reasoning UNA.
(HF )+

Lemma 8.6 every DL-Litebool

KB K = (T , A) equality inequality con(HF )+

straints, one construct polynomial time |A| DL-Litebool
KB K0 = (T , A0 )
A0 contains equalities inequalities K satisfiable without UNA iff K0
satisfiable UNA.
Proof follows identifying aj ak mean replacing occurrence
ak aj . construct A0 first identifying aj ak , aj ak A,
removing equality A, exhaustively applying following procedure
A:
2 R v R(ai , aj ), R(ai , ak ) CleT (A), distinct aj ak ,
identify aj ak (recall functional R cannot transitive sub-roles
thus CleT (A) enough).
resulting ABox contains ai 6 ai , ai , then, clearly, K satisfiable,
add A(ai ) A(ai ) ABox, concept name A. Finally, remove
inequalities ABox denote result A0 . clear A0
computed polynomial time that, without UNA, K satisfiable iff K0
satisfiable. suffices show K0 satisfiable without UNA iff satisfiable
UNA. implication () trivial.
() Observe procedure ensures
e
qR,a
1,

R 2 v , R vT ob(A0 )
(HN )

(see page 37 definitions). Let K00 DL-Litebool
KB provided Lemma 5.17
K0 . follows property proofs Lemma 5.14 Corollary 5.16
58

fiThe DL-Lite Family Relations

K00 satisfiable without UNA (K00 )e satisfied first-order model
constants interpreted domain element. (K00 )e universal
first-order sentence containing equality, satisfiable first-order model
constants interpreted distinct elements. follows proofs Lemma 5.14
Corollary 5.16 first-order model unraveled model J K00
respecting UNA. Lemma 5.17, J model K0 .
q
reduction cannot done better P, shown next theorem:
Theorem 8.7 Without UNA, satisfiability DL-LiteF
core KBs (even without equality
inequality constraints) P-hard combined data complexity.
Proof proof reduction entailment problem Horn-CNF (as proof
Theorem 6.7). Let
=

n
^

ak,1 ak,2 ak,3



p
^



al,0

l=1

k=1

Horn-CNF formula, ak,j al,0 one propositional variables
a1 , . . . , ak,1 , ak,2 , ak,3 distinct, k, 1 k n. encode Pk
complete problem |= ai ? language DL-LiteF
core need object names t, ai ,
1 k n, 1 m, fk gk , 1 k n, role names P , Q, .
ABox contains following assertions
S(a1i , a2i ), . . . , S(an1
, ani ), S(ani , a1i ),


1 m,

P (akk,1 , fk ), P (akk,2 , gk ), Q(gk , akk,3 ), Q(fk , akk,1 ),
(t, a1l,0 ),

1 k n,

1 l p,

TBox asserts roles functional:
2 P v ,

2 Q v ,

2S v



2 v .

Clearly, K = (T , A) DL-LiteF
core KB depend . claim
|= aj iff (T , {T (t, a1j )}) satisfiable without UNA. show this, suffices
prove |= aj iff K |=noUNA (t, a1j ).
() Suppose |= aj . derive aj using following inference rules:
|= al,0 l, 1 l p;
|= ak,1 |= ak,2 , k, 1 k n, |= ak,3 .
show K |=noUNA (t, a1j ) induction length derivation aj .
basis induction trivial. assume aj = ak,3 , |= ak,1 , |= ak,2 , k,
1 k n, K |=noUNA (t, a1k,1 ) (t, a1k,2 ). Suppose |= K. Since
0
0
functional, (a1k,1 )I = (a1k,2 )I . Since functional, (akk,1 )I = (akk,2 )I , k 0 ,
1 k 0 n, particular, k 0 = k. Then, since P functional, fkI = gkI , which,
0
0
functionality Q, (akk,3 )I = (akk,1 )I . Finally, since functional, (akk,3 )I = (akk,1 )I ,
59

fiArtale, Calvanese, Kontchakov & Zakharyaschev

k 0 , 1 k 0 n, particular, k 0 = 1. Thus, |= (t, a1j ) therefore
K |=noUNA (t, a1j ).
() Suppose 6|= aj . assignment a() =
a(aj ) = f. Construct interpretation taking



= xki | a(ai ) = f, 1 k n, 1 z k , uk , vk | 1 k n w ,
(
xki , a(ai ) = f,
(aki )I =
1 k n 1 m,
z k , a(ai ) = t,


tI = w, = (w, z 1 ) ,


= ((a1i )I , (a2i )I ), . . . , ((an1
)I , (ani )I ), ((ani )I , (a1i )I ) | 1 ,

(
vk , a(ak,2 ) = f,
fkI = uk gkI =
1 k n,
uk , a(ak,2 ) = t,


P = ((akk,1 )I , fkI ), ((akk,2 )I , gkI ) | 1 k n ,


QI = (gkI , (akk,3 )I ), (fkI , (akk,1 )I ) | 1 k n .
readily checked |= K 6|= (t, a1j ), K 6|=noUNA (t, a1j ).

q

result strengthens NLogSpace lower bound instance checking
DL-LiteF
core proved Calvanese et al. (2008).
(HF )

(HF )+

Corollary 8.8 Without UNA, satisfiability DL-LiteF
DL-Lite
, DL-Lite
KBs, {core, krom, horn}, equalities inequalities P-complete combined data complexity.
(HF )
(HF )+
Without UNA, satisfiability DL-LiteF
KBs
bool , DL-Litebool DL-Litebool
equalities inequalities NP-complete combined complexity P-complete data
complexity.

Proof upper bounds follow Lemma 8.6 corresponding upper bounds
UNA case. NP lower bound combined complexity obvious polynomial
lower bounds follow Theorem 8.7.
q
8.3 Query Answering: Data Complexity
P coNP upper bounds query answering without UNA follow results Horn-SHIQ (Hustadt et al., 2005; Eiter et al., 2008) SHIQ (Ortiz et al., 2006,
2008; Glimm et al., 2007), respectively (see discussion beginning Section 7).
present following result:
Theorem 8.9 Without UNA, positive existential query answering DL-LiteH
horn KBs
role disjointness, (a)symmetry, (ir )reflexivity constraints inequalities AC0
data complexity. problem LogSpace-complete if, additionally, equalities
allowed KBs.
60

fiThe DL-Lite Family Relations

Proof proof follows lines proof Theorem 7.1 uses observation
models without UNA give answers untangled counterparts.
precisely, let KB K0 = (T 0 , A0 ) above. Suppose consistent. Let q(~x)
positive existential query signature K0 . Given K0 , Lemma 5.17 provides
us KB K. easy see K DL-LiteH
horn KB extended inequality
constraints. following analogue Lemma 7.2, allows us get rid
inequalities:
Lemma 8.10 every tuple ~a object names K0 , K0 |=noUNA q(~a) iff |= q(~a)
untangled models K (respecting UNA).
Proof () Suppose K0 |=noUNA q(~a) untangled model K. respects
UNA, Lemma 5.17 view satisfiability K0 , ensures (44) holds,
|= K0 therefore, |= q(~a).
() Suppose 0 |= K0 . construct interpretation J 0 respecting UNA follows.
0
0
0
0
Let J disjoint union ob(A). Define function h : J taking
0
0
h(a) = aI , ob(A), h(w) = w, w , let


0
0
0
0
0
aJ = a,
AJ = u | h(u) AI

P J = (u, v) | (h(x), h(v)) P ,
object, concept role name a, A, P . Clearly, J 0 respects UNA J 0 |= K0 .
follows h homomorphism.
Lemma 5.17, model K domain J 0 coincides
J 0 symbols K0 . |= q(~a), must J 0 |= q(~a), since h
homomorphism, 0 |= q(~a). Therefore, K0 |=noUNA q(~a) required.
q
remaining part proof exactly Theorem 7.1 (since may assume
K DL-LiteH
horn KB containing inequality constraints).
LogSpace-completeness case equalities follows Lemma 8.1.
q

9. Conclusion
article, investigated boundaries extended DL-Lite family description
logics providing thorough comprehensive understanding interaction
various DL-Lite constructs impact computational complexity reasoning.
studied 40 different logics, classified according five mutually orthogonal features:
(1) presence absence role inclusion assertions, (2) form allowed concept
inclusion assertions, distinguishing four main logical groups called core, Krom, Horn,
Bool, (3) form allowed numeric constraints, ranging none, global functionality constraints only, arbitrary number restrictions, (4) presence absence
unique name assumption (and equalities inequalities object names,
assumption dropped), (5) presence absence standard role constraints
role disjointness, role symmetry, asymmetry, reflexivity, irreflexivity transitivity. resulting logics, studied combined data complexity KB
satisfiability instance checking, well data complexity answering positive
existential queries.
61

fiArtale, Calvanese, Kontchakov & Zakharyaschev

query answering
= instance checking

coNP
query answering

.
Legend
satisfiability
combined complexity

with/without UNA
role inclusions

F

N

ExpTime
NP
P
NLogSpace

UNA
role inclusions

F

UNA
role inclusions

coNP
P
AC0

oo
l

N

instance checking
data complexity

B

ro

K

co

H


n

.



F

N

Figure 6: Complexity basic DL-Lite logics.
obtained tight complexity results illustrated Figure 6, combined
complexity satisfiability represented height vertical dashed lines,
data complexity instance checking size color circle top lines
(recall satisfiability instance checking reducible complement
other). data complexity query answering core Horn logics, shown
left-hand side separating vertical plane, coincides data complexity
instance checking; Krom Bool logics, shown right-hand side plane,
query answering always data-complete coNP. upper layer shows complexity
logics role inclusions, case depend whether adopt
UNA not. middle lower layers deal logics without role inclusions
UNA dropped adopted, respectively. layers, twelve
languages arranged 4 3 grid: one axis shows type concepts inclusions
allowed (Horn, core, Krom, Bool), type number restrictions (none,
global functionality F arbitrary N ). observations order:
UNA without role inclusions, number restrictions increase
complexity reasoning, depends form concept inclusions allowed.
hand, without form number restrictions, logics role
inclusions insensitive UNA; again, complexity determined
shape concept inclusions only.
either cases, instance checking AC0 data complexity,
means problems first-order rewritable.

62

fiThe DL-Lite Family Relations

Without UNA adopted without either disjunctions role inclusions, functionality
leads P-completeness instance checking data complexity, suggests
reducibility Datalog.
data complexity, difference core Horn logics,
Krom Bool ones, means core Krom logics
extended conjunctions left-hand side concept inclusions free.
(HF )

(HN )

Finally, logics DL-Lite
DL-Lite
(qualified) number restrictions role inclusions, whose interaction restricted conditions (A1 )(A3 ),
complexity reasoning always coincides complexity fragments DL-LiteF

and, respectively, DL-LiteN
without role inclusions, matter whether adopt UNA
not.
Role disjointness, symmetry asymmetry constraints added
(HN )
(HF )
languages without changing complexity. fact, DL-Lite
DL-Lite
logics contain types constraints together role reflexivity irreflexivity. conjecture (ir)reflexivity constraints added logics without
affecting complexity. However, extend DL-Lite logic role transitivity
constraints, combined complexity satisfiability remains same, instance
checking query answering become data-hard NLogSpace. addition
equality object nameswhich makes sense UNA droppedleads
increase membership AC0 LogSpace-completeness data complexity;
results remain unchanged.
list DL constructs considered paper far complete.
example, would interest analyze impact nominals, role chains Boolean
operators roles computational behavior DL-Lite logics. Another interesting
practically important problem investigate depth interaction various
constructs aim pushing restrictions (A1 )(A3 ) far possible.
One main ideas behind DL-Lite logics provide efficient access large
amounts data high-level conceptual interface. supposed achieved
representing high-level view information managed system DL-Lite
TBox , data stored relational database ABox A, rewriting positive existential queries knowledge base (T , A) standard first-order queries
database represented A. approach believed viable because, number
DL-Lite logics, query answering problem AC0 data complexity; cf. Theorems 7.1, 8.9 Figure 6. first-order rewriting technique implemented
various system, notably QuOnto (Acciarri et al., 2005; Poggi et al., 2008b),
query, relying ontology-to-relational mappings, data stored standard relational
database management system, Owlgres (Stocker & Smith, 2008), access
ABox stored Postgres database (though, best knowledge, latter
implementation incomplete conjunctive query answering). noted, however,
size rewritten query substantially larger size original
query, cause problems even efficient database query engine.
positive existential query q TBox , two major sources high
complexity first-order formula ,q proof Theorem 7.1: (i) formulas
B (x) computing whether ABox object instance concept B (and formulas
63

fiArtale, Calvanese, Kontchakov & Zakharyaschev

R,dr computing whether objects outgoing R-arrows instances B), (ii)
(HN )
disjunction paths ~ graph GT . case DL-Litecore , size
(HN )
B (x) linear |T |, DL-Litehorn become exponential (however, various
optimizations possible). size disjunction (ii) exponential number
non-distinguished variables q. One way removing source (i) would extend
given database (ABox) precomputing Horn closure ABox respect
TBox storing resulting data supplementary database. approach
advocated Lutz et al. (2008) querying databases via description logic EL.
could promising Horn fragments expressive description logics
SHIQ (Hustadt et al., 2005; Hustadt, Motik, & Sattler, 2007)containing DL-LiteHF
horn
sub-languagefor data complexity instance checking (Hustadt et al., 2005,
2007) conjunctive query answering polynomial (Eiter et al., 2008). disadvantage
using supplementary database necessity update every time ABox
changed. would interesting investigate alternative approach DL-Lite logics
compare approach described above. Another important problem
characterize queries disjunction (ii) represented formula
polynomial size.
unique name assumption replaced OWL constructs sameAs
differentFrom (i.e., 6), challenging problem investigate possible ways
dealing equality (inequality require special treatment shown
proof Lemma 8.10). Although reasoning equality LogSpace-reducible reasoning without (cf. Lemma 8.1), lose property first-order rewritability,
computing equivalence classes may costly real-world applications.
DL-Lite logics among examples DLs usually complex
non-standard reasoning problemssuch checking whether one ontology conservative
extension another one respect given signature (Kontchakov et al., 2008),
computing minimal modules ontologies respect (Kontchakov et al., 2009)
uniform interpolants (Wang, Wang, Topor, & Pan, 2008)can supported practical
reasoning tools. However, first steps made direction,
research needed order include reasoning problems tools standard
OWL toolkit. would interesting investigate unification problem DL-Lite
logics (Baader & Narendran, 2001).
Finally, exist certain parallels Horn logics DL-Lite family, EL,
Horn-SHIQ first-order language tuple equality generating dependencies,
TGDs EGDs, used theory databases (see, e.g., Gottlob & Nash, 2008).
investigations relationships logics may lead deeper understanding
role description logics play database framework.
Acknowledgments
research partially supported FET project TONES (Thinking ONtologiES), funded within EU 6th Framework Programme contract FP6-7603,
large-scale integrating project (IP) OntoRule (ONTOlogies meet Business RULEs
ONtologiES), funded EC ICT Call 3 FP7-ICT-2008-3, contract number FP7231875. thank referees constructive criticism, comments, suggestions.

64

fiThe DL-Lite Family Relations

References
Abiteboul, S., Hull, R., & Vianu, V. (1995). Foundations Databases. Addison-Wesley.
Acciarri, A., Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Palmieri, M., &
Rosati, R. (2005). QuOnto: Querying ontologies. Proc. 20th Nat. Conf.
Artificial Intelligence (AAAI 2005), pp. 16701671.
Apt, K. (1990). Logic programming. van Leeuwen, J. (Ed.), Handbook Theoretical
Computer Science, Volume B: Formal Models Sematics, pp. 493574. Elsevier
MIT Press.
Artale, A., Calvanese, D., Kontchakov, R., & Zakharyaschev, M. (2007a). DL-Lite
light first-order logic. Proc. 22nd Nat. Conf. Artificial Intelligence
(AAAI 2007), pp. 361366.
Artale, A., Calvanese, D., Kontchakov, R., Ryzhikov, V., & Zakharyaschev, M. (2007b).
Reasoning extended ER models. Proc. 26th Int. Conf. Conceptual
Modeling (ER 2007), Vol. 4801 Lecture Notes Computer Science, pp. 277292.
Springer.
Artale, A., Cesarini, F., & Soda, G. (1996). Describing database objects concept
language environment. IEEE Trans. Knowledge Data Engineering, 8 (2), 345
351.
Artale, A., Parent, C., & Spaccapietra, S. (2007). Evolving objects temporal information
systems. Ann. Mathematics Artificial Intelligence, 50, 538.
Baader, F., & Narendran, P. (2001). Unification concepts terms description logics. J.
Symbolic Computation, 31 (3), 277305.
Baader, F., Calvanese, D., McGuinness, D., Nardi, D., & Patel-Schneider, P. F. (Eds.).
(2003). Description Logic Handbook: Theory, Implementation Applications.
Cambridge University Press. (2nd edition, 2007).
Beeri, C., Levy, A. Y., & Rousset, M.-C. (1997). Rewriting queries using views description
logics. Proc. 16th ACM SIGACT SIGMOD SIGART Symp. Principles
Database Systems (PODS97), pp. 99108.
Berardi, D., Calvanese, D., & De Giacomo, G. (2005). Reasoning UML class diagrams.
Artificial Intelligence, 168 (12), 70118.
Bergamaschi, S., & Sartori, C. (1992). taxonomic reasoning conceptual design. ACM
Trans. Database Systems, 17 (3), 385422.
Boppana, R., & Sipser, M. (1990). complexity finite functions. van Leeuwen, J.
(Ed.), Handbook Theoretical Computer Science, Volume A: Algorithms Complexity, pp. 757804. Elsevier MIT Press.
Borger, E., Gradel, E., & Gurevich, Y. (1997). Classical Decision Problem. Perspectives
Mathematical Logic. Springer.
Borgida, A., & Brachman, R. J. (2003). Conceptual modeling description logics.
Baader et al. (Baader et al., 2003), chap. 10, pp. 349372.

65

fiArtale, Calvanese, Kontchakov & Zakharyaschev

Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Poggi, A., & Rosati, R. (2007).
Ontology-based database access. Proc. 15th Ital. Conf. Database Systems
(SEBD 2007), pp. 324331.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Poggi, A., Rosati, R., & Ruzzi, M.
(2008). Data integration DL-Lite ontologies. Schewe, K.-D., & Thalheim,
B. (Eds.), Revised Selected Papers 3rd Int. Workshop Semantics Data
Knowledge Bases (SDKB 2008), Vol. 4925 Lecture Notes Computer Science, pp.
2647. Springer.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2005). DL-Lite:
Tractable description logics ontologies. Proc. 20th Nat. Conf. Artificial
Intelligence (AAAI 2005), pp. 602607.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2006). Data
complexity query answering description logics. Proc. 10th Int. Conf.
Principles Knowledge Representation Reasoning (KR 2006), pp. 260270.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2007a). OWL
model football leagues?. Proc. 3rd Int. Workshop OWL: Experiences
Directions (OWLED 2007), Vol. 258 CEUR Workshop Proceedings.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2007b). Tractable
reasoning efficient query answering description logics: DL-Lite family. J.
Automated Reasoning, 39 (3), 385429.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2008a). Inconsistency tolerance P2P data integration: epistemic logic approach. Information
Systems, 33 (4), 360384.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2008b). Path-based
identification constraints description logics. Proc. 11th Int. Conf.
Principles Knowledge Representation Reasoning (KR 2008), pp. 231241.
Calvanese, D., De Giacomo, G., & Lenzerini, M. (2002a). Description logics information
integration. Kakas, A., & Sadri, F. (Eds.), Computational Logic: Logic Programming Beyond, Essays Honour Robert A. Kowalski, Vol. 2408 Lecture Notes
Computer Science, pp. 4160. Springer.
Calvanese, D., De Giacomo, G., & Lenzerini, M. (2002b). framework ontology integration. Cruz, I., Decker, S., Euzenat, J., & McGuinness, D. (Eds.), Emerging
Semantic Web Selected Papers First Semantic Web Working Symposium,
pp. 201214. IOS Press.
Calvanese, D., De Giacomo, G., Lenzerini, M., Nardi, D., & Rosati, R. (1998a). Description
logic framework information integration. Proc. 6th Int. Conf.
Principles Knowledge Representation Reasoning (KR98), pp. 213.
Calvanese, D., Lenzerini, M., & Nardi, D. (1998b). Description logics conceptual data
modeling. Chomicki, J., & Saake, G. (Eds.), Logics Databases Information
Systems, pp. 229264. Kluwer Academic Publishers.
Calvanese, D., Lenzerini, M., & Nardi, D. (1999). Unifying class-based representation formalisms. J. Artificial Intelligence Research, 11, 199240.
66

fiThe DL-Lite Family Relations

Corona, C., Ruzzi, M., & Savo, D. F. (2009). Filling gap OWL 2 QL
QuOnto: ROWLKit. Proc. 22nd Int. Workshop Description Logics
(DL 2009), Vol. 477 CEUR Workshop Proceedings.
Cuenca Grau, B., Horrocks, I., Kazakov, Y., & Sattler, U. (2008). Modular reuse ontologies: Theory practice. J. Artificial Intelligence Research, 31, 273318.
Decker, S., Erdmann, M., Fensel, D., & Studer, R. (1999). Ontobroker: Ontology based
access distributed semi-structured information. Meersman, R., Tari, Z.,
& Stevens, S. (Eds.), Database Semantic: Semantic Issues Multimedia Systems,
chap. 20, pp. 351370. Kluwer Academic Publishers.
Dolby, J., Fokoue, A., Kalyanpur, A., Ma, L., Schonberg, E., Srinivas, K., & Sun, X. (2008).
Scalable grounded conjunctive query evaluation large expressive knowledge
bases. Proc. 7th Int. Semantic Web Conf. (ISWC 2008), Vol. 5318 Lecture
Notes Computer Science, pp. 403418. Springer.
Eiter, T., Gottlob, G., Ortiz, M., & Simkus, M. (2008). Query answering description logic Horn-SHIQ. Proc. 11th Eur. Conference Logics Artificial
Intelligence (JELIA 2008), pp. 166179.
Franconi, E., & Ng, G. (2000). i.com tool intelligent conceptual modeling. Proc.
7th Int. Workshop Knowledge Representation meets Databases (KRDB 2000),
Vol. 29 CEUR Workshop Proceedings, pp. 4553.
Garey, M., & Johnson, D. (1979). Computers Intractability: Guide Theory
NP-Completeness. W. H. Freeman.
Ghilardi, S., Lutz, C., & Wolter, F. (2006). damage ontology? case conservative extensions description logics. Doherty, P., Mylopoulos, J., & Welty,
C. (Eds.), Proc. 10th Int. Conf. Principles Knowledge Representation
Reasoning (KR 2006), pp. 187197.
Glimm, B., Horrocks, I., Lutz, C., & Sattler, U. (2007). Conjunctive query answering
description logic SHIQ. Proc. 20th Int. Joint Conf. Artificial Intelligence
(IJCAI 2007), pp. 399404.
Goasdoue, F., Lattes, V., & Rousset, M.-C. (2000). use CARIN language
algorithms information integration: Picsel system. Int. J. Cooperative
Information Systems, 9 (4), 383401.
Gottlob, G., & Nash, A. (2008). Efficient core computation data exchange. J.
ACM, 55 (2), 149.
Hayes, P. (2004). RDF semantics. W3C Recommendation. http://www.w3.org/TR/
rdf-mt/.
Heflin, J., & Hendler, J. (2001). portrait Semantic Web action. IEEE Intelligent
Systems, 16 (2), 5459.
Heymans, S., Ma, L., Anicic, D., Ma, Z., Steinmetz, N., Pan, Y., Mei, J., Fokoue, A.,
Kalyanpur, A., Kershenbaum, A., Schonberg, E., Srinivas, K., Feier, C., Hench, G.,
Wetzstein, B., & Keller, U. (2008). Ontology reasoning large data repositories.
Hepp, M., De Leenheer, P., de Moor, A., & Sure, Y. (Eds.), Ontology Management,
67

fiArtale, Calvanese, Kontchakov & Zakharyaschev

Semantic Web, Semantic Web Services, Business Applications, Vol. 7 Semantic
Web Beyond Computing Human Experience, pp. 89128. Springer.
Horrocks, I., Patel-Schneider, P. F., & van Harmelen, F. (2003). SHIQ RDF
OWL: making web ontology language. J. Web Semantics, 1 (1), 726.
Horrocks, I., Sattler, U., & Tobies, S. (2000). Practical reasoning expressive description logics. J. Interest Group Pure Applied Logic, 8 (3), 239264.
Hustadt, U., Motik, B., & Sattler, U. (2007). Reasoning description logics reduction
disjunctive Datalog. J. Automated Reasoning, 39 (3), 351384.
Hustadt, U., Motik, B., & Sattler, U. (2005). Data complexity reasoning expressive
description logics. Proc. 19th Int. Joint Conf. Artificial Intelligence
(IJCAI 2005), pp. 466471.
Immerman, N. (1999). Descriptive Complexity. Springer.
Klyne, G., & Carroll, J. J. (2004). Resource description framework (RDF): Concepts
abstract syntax. W3C Recommendation. http://www.w3.org/TR/rdf-concepts/.
Kontchakov, R., Pulina, L., Sattler, U., Schneider, T., Selmer, P., Wolter, F., & Zakharyaschev, M. (2009). Minimal module extraction DL-Lite ontologies using
QBF solvers. Proc. 21st Int. Joint Conf. Artificial Intelligence (IJCAI 2009), pp. 836840.
Kontchakov, R., Wolter, F., & Zakharyaschev, M. (2008). tell difference
DL-Lite ontologies?. Proc. 11th Int. Conf. Principles
Knowledge Representation Reasoning (KR 2008), pp. 285295.
Kontchakov, R., & Zakharyaschev, M. (2008). DL-Lite role inclusions. Domingue, J.,
& Anutariya, C. (Eds.), Proc. 3rd Asian Semantic Web Conf. (ASWC 2008),
Vol. 5367 Lecture Notes Computer Science, pp. 1630. Springer.
Kozen, D. (2006). Theory Computation. Springer.
Lenzerini, M. (2002). Data integration: theoretical perspective. Proc. 21st ACM
SIGACT SIGMOD SIGART Symp. Principles Database Systems (PODS 2002),
pp. 233246.
Levy, A. Y., & Rousset, M.-C. (1998). Combining Horn rules description logics
CARIN. Artificial Intelligence, 104 (12), 165209.
Lutz, C., Toman, D., & Wolter, F. (2008). Conjunctive query answering EL using
database system. Proc. 5th Int. Workshop OWL: Experiences Directions (OWLED 2008).
McGuinness, D., & Wright, J. R. (1998). Conceptual modelling configuration: description logic-based approach. Artificial Intelligence Engineering Design, Analysis,
Manufacturing. Special Issue Configuration, 12, 333344.
Meyer, T., Lee, K., & Booth, R. (2005). Knowledge integration description logics.
Proc. 20th Nat. Conf. Artificial Intelligence (AAAI 2005), pp. 645650.
Noy, N. F. (2004). Semantic integration: survey ontology-based approaches. SIGMOD
Record, 33 (4), 6570.
68

fiThe DL-Lite Family Relations

Ortiz, M., Calvanese, D., & Eiter, T. (2006). Characterizing data complexity conjunctive
query answering expressive description logics. Proc. 21st Nat. Conf.
Artificial Intelligence (AAAI 2006), pp. 275280.
Ortiz, M., Calvanese, D., & Eiter, T. (2008). Data complexity query answering expressive description logics via tableaux. J. Automated Reasoning, 41 (1), 6198.
Papadimitriou, C. (1994). Computational Complexity. Addison-Wesley.
Perez-Urbina, H., Motik, B., & Horrocks, I. (2009). comparison query rewriting
techniques DL-Lite. Proc. 22nd Int. Workshop Description Logics
(DL 2009), Vol. 477 CEUR Workshop Proceedings.
Poggi, A., Lembo, D., Calvanese, D., De Giacomo, G., Lenzerini, M., & Rosati, R. (2008a).
Linking data ontologies. J. Data Semantics, X, 133173.
Poggi, A., Rodriguez, M., & Ruzzi, M. (2008b). Ontology-based database access
DIG-Mastro OBDA Plugin Protege. Clark, K., & Patel-Schneider,
P. F. (Eds.), Proc. 4th Int. Workshop OWL: Experiences Directions
(OWLED 2008 DC).
Rautenberg, W. (2006). Concise Introduction Mathematical Logic. Springer.
Reingold, O. (2008). Undirected connectivity log-space. J. ACM, 55 (4).
Schaerf, A. (1993). complexity instance checking problem concept languages
existential quantification. J. Intelligent Information Systems, 2, 265278.
Schmidt-Schau, M., & Smolka, G. (1991). Attributive concept descriptions complements. Artificial Intelligence, 48 (1), 126.
Stocker, M., & Smith, M. (2008). Owlgres: scalable OWL reasoner. Proc. 5th
Int. Workshop OWL: Experiences Directions (OWLED 2008).
Tobies, S. (2001). Complexity results practical algorithms logics Knowledge Representation. Ph.D. thesis, LuFG Theoretical Computer Science, RWTH-Aachen, Germany.
Toman, D., & Weddell, G. E. (2005). interaction inverse features pathfunctional dependencies description logics. Proc. 19th Int. Joint Conf.
Artificial Intelligence (IJCAI 2005), pp. 603608.
Toman, D., & Weddell, G. E. (2008). keys functional dependencies first-class
citizens description logics. J. Automated Reasoning, 40 (23), 117132.
Vardi, M. (1982). complexity relational query languages (extended abstract).
Proc. 14th ACM SIGACT Symp. Theory Computing (STOC82), pp.
137146.
Vollmer, H. (1999). Introduction Circuit Complexity: Uniform Approach. Springer.
Wang, Z., Wang, K., Topor, R. W., & Pan, J. Z. (2008). Forgetting concepts DL-Lite.
Bechhofer, S., Hauswirth, M., Hoffmann, J., & Koubarakis, M. (Eds.), Proc.
5th Eur. Semantic Web Conf. (ESWC 2008), Vol. 5021 Lecture Notes Computer
Science, pp. 245257. Springer.

69


