journal artificial intelligence

submitted published

dl lite family relations
alessandro artale
diego calvanese

artale inf unibz
calvanese inf unibz

krdb centre
free university bozen bolzano
piazza domenicani bolzano italy

roman kontchakov
michael zakharyaschev

roman dcs bbk ac uk
michael dcs bbk ac uk

department computer science information systems
birkbeck college
malet street london wc e hx u k

abstract
recently introduced series description logics common moniker dllite attracted attention description logic semantic web communities due
low computational complexity inference one hand ability represent
conceptual modeling formalisms main aim article carry
thorough systematic investigation inference extensions original dl lite
logics along five axes adding boolean connectives ii number restrictions
concept constructs iii allowing role hierarchies iv allowing role disjointness symmetry
asymmetry reflexivity irreflexivity transitivity constraints v adopting dropping unique name assumption analyze combined complexity satisfiability
resulting logics well data complexity instance checking answering
positive existential queries embedding dl lite logics suitable fragments one variable first order logic provides useful insights
properties particular computational behavior

introduction
description logic cf baader calvanese mcguinness nardi patel schneider
references therein family knowledge representation formalisms developed
past three decades recent years widely used application areas
conceptual modeling bergamaschi sartori calvanese et al b
mcguinness wright franconi ng borgida brachman berardi calvanese de giacomo artale et al b
information data integration beeri levy rousset levy rousset
goasdoue lattes rousset calvanese et al b
noy meyer lee booth
ontology data access dolby et al poggi et al heymans et al

semantic web heflin hendler horrocks patel schneider van harmelen
c

ai access foundation rights reserved

fiartale calvanese kontchakov zakharyaschev

description logics dls short underlie standard web ontology language owl
process standardized w c second edition owl
widespread use dls flexible modeling languages stems fact
similarly traditional modeling formalisms structure domain interest
classes concepts dl parlance objects common properties properties
associated objects means binary relationships roles objects
constraints available standard dls resemble used conceptual modeling
formalisms structuring information hierarchies e inclusions disjointness
concepts roles domain range constraints roles mandatory participation
roles functionality general numeric restrictions roles covering within concept
hierarchies etc dl knowledge base kb constraints combined form
tbox asserting intensional knowledge abox collects extensional knowledge
individual objects whether object instance concept two objects
connected role standard reasoning services dl kb include checking
consistency satisfiability instance checking whether certain individual instance
concept logic entailment whether certain constraint logically implied
kb sophisticated services emerging support modular development
ontologies checking example whether one ontology conservative extension
another respect certain vocabulary see e g ghilardi lutz wolter
cuenca grau horrocks kazakov sattler kontchakov wolter zakharyaschev
kontchakov pulina sattler schneider selmer wolter zakharyaschev
description logics recently used provide access large amounts data
high level conceptual interface relevance data integration
ontology data access setting tbox constitutes conceptual high level
view information managed system abox physically stored
relational database accessed standard relational database technology poggi
et al calvanese et al fundamental inference service case answering queries abox constraints tbox taken account kind
queries often considered first order conjunctive queries
correspond commonly used select project join sql queries key properties
viable practice efficiency query evaluation
ideal target traditional database query processing ii query evaluation
done leveraging relational technology already used storing data
objectives mind series description logicsthe dl lite familyhas
recently proposed investigated calvanese de giacomo lembo lenzerini
rosati later extended artale calvanese kontchakov
zakharyaschev poggi lembo calvanese de giacomo lenzerini rosati
logics family meet requirements time
capable representing many important types constraints used conceptual modeling
particular inference dl lite logics done efficiently size
data data complexity overall size kb combined complexity
shown kb satisfiability logics polynomial combined complexity
answering queries ac data complexitywhich roughly means given
http www w org owl



fithe dl lite family relations

conjunctive query kb query tbox rewritten independently
abox union conjunctive queries abox alone emphasized
data complexity measure important application context dl lite
logics since one reasonably assume size data largely dominates size
tbox query rewriting techniques implemented systems
quonto acciarri calvanese de giacomo lembo lenzerini palmieri rosati
poggi rodriguez ruzzi b rowlkit corona ruzzi savo owlgres
stocker smith requiem perez urbina motik horrocks
demonstrated kontchakov et al developing analyzing
dl lite ontologies tboxes supported efficient tools capable checking
types entailment ontologies respect given vocabularies particular
minimal module extraction tools kontchakov et al yet exist
richer languages
significance dl lite family testified fact forms basis
owl ql one three profiles owl owl profiles fragments
full owl language designed standardized specific application
requirements according current version official w c profiles document
purpose owl ql language choice applications use large
amounts data query answering important reasoning task
common denominator dl lite logics constructed far follows quantification roles inverses qualified words concepts
form r c must c ii tbox axioms concept inclusions cannot represent kind disjunctive information say two concepts cover whole
domain dl lite related dialects designedwith aim capturing
conceptual modeling constraints somewhat ad hoc mannerby extending
core language number constructs global functionality constraints
role inclusions restricted boolean operators concepts see section details
although attempts made calvanese et al artale et al
kontchakov zakharyaschev put original dl lite logics general
perspective investigate extensions variety dl constructs required
conceptual modeling resulting picture still remains rather fragmentary far
comprehensive systematic investigation dl lite family relatives become
even urgent challenging view choice constructs included
specification owl ql profile particular owl make
unique name assumption una usually adopted dl lite uses equalities
inequalities object names instead
main aim article fill gap provide thorough comprehensive understanding interaction dl lite constructs impact
computational complexity reasoning achieve goal consider spectrum
logics classified according five mutually orthogonal features
presence absence role inclusions
http www dis uniroma quonto
http www w org tr owl profiles
http www w org tr owl profiles owl ql



fiartale calvanese kontchakov zakharyaschev

form allowed concept inclusions consider four classes called core
krom horn bool exhibit different computational properties
form allowed numeric constraints ranging none global functionality
constraints arbitrary number restrictions
presence absence unique name assumption equalities inequalities object names assumption dropped
presence absence standard role constraints disjointness symmetry
asymmetry reflexivity irreflexivity transitivity
resulting cases investigate combined data complexity kb satisfiability instance checking well data complexity query answering
obtained tight complexity summarized section table remark
already mentioned original motivation distinguishing feature logics
dl lite family lite ness sense low computational complexity
reasoning tasks query answering ac data complexity tractable kb satisfiability
combined complexity broader perspective take logics
meet requirement particular krom bool concept inclusions however
identify another distinguishing feature regarded natural logic
characterization dl lite family embeddability one variable fragment firstorder logic without equality function symbols allows us relate complexity
dl lite logics complexity corresponding fragments first order logic thus
obtain deep insight underlying logical properties dl lite variant
example upper complexity bounds established follow embedding
well known classical decision see e g borger gradel gurevich
descriptive complexity see e g immerman
one interesting findings article number restrictions even
expressed locally instead global role functionality added original dl lite
logics una without role inclusions free without changing
computational complexity first order shows cases
extend dl lite logics role constraints mentioned keeping
complexity gives framework analyze effect adopting dropping
una equalities object names example observe
equality allowed language dl lite makes sense without una
query answering becomes logspace complete data complexity therefore
first order rewritable turns dropping una p hardness
reasoning combined data complexity presence functionality constraints nlogspace hardness shown calvanese et al np hardness
arbitrary number restrictions allowed
another interesting finding dramatic impact role inclusions combined
number restrictions even functionality constraints computational complexity reasoning already observed calvanese et al combination increases data complexity instance checking membership logspace
note way logics bool concept inclusions turn quite useful conceptual
modeling reasonably manageable computationally kontchakov et al



fithe dl lite family relations

nlogspace hardness situation actually even worse data
complexity instance checking turns p complete case core horn
logics conp complete case krom bool logics moreover kb satisfiability
nlogspace complete combined complexity simplest core casei e efficiently tractable role inclusions number restrictions used separatelybecomes
exptime completei e provably intractable used together
retain role inclusions functionality constraints language keep
complexity within required limits poggi et al introduced another dl lite
dialect called dl litea restricts interaction role inclusions functionality constraints extend showing dl lite logics
limited interaction role inclusions number restrictions still embedded one variable fragment first order logic exhibit behavior
fragments role inclusions number restrictions
article structured following way section introduce logics
extended dl lite family illustrate features conceptual modeling formalisms
section discuss reasoning services complexity measures analyzed
follows give overview obtained complexity section
place introduced dl lite logics context original dl lite family
discuss relationship owl section study combined complexity
kb satisfiability instance checking section consider data complexity
section study data complexity query answering
section analyze impact dropping una adding equalities
object names complexity reasoning section concludes article

extended dl lite family description logics
description logic baader et al family logics studied
used knowledge representation reasoning since dls elements
domain interest structured concepts unary predicates properties
specified means roles binary predicates complex concept role expressions
simply concepts roles constructed starting set concept role
names applying suitable constructs set available constructs depends
specific description logic concepts roles used knowledge base
assert knowledge intensional level called tbox terminological
extensional level called abox assertional tbox typically
consists set axioms stating inclusion concepts roles abox one
assert membership objects e constants concepts pair objects
connected role dls supported reasoning services satisfiability checking
query answering rely logic semantics
syntax semantics logics dl lite family
introduce extended dl lite family description logics initially
proposed aim capturing typical conceptual modeling formalisms uml
class diagrams er see section details maintaining good computational properties standard dl reasoning tasks calvanese et al begin


fiartale calvanese kontchakov zakharyaschev

defining logic dl litehn
bool regarded supremum original
dl lite family calvanese et al b lattice description logics
hn
dl litehn
bool language dl litebool contains object names concept names
role names p p complex roles r concepts c language
defined follows

pk

r



pk



b







ak



q r

c



b



c



c u c

q positive integer concepts form b called basic
dl litehn
bool tbox finite set concept role inclusion axioms simply
concept role inclusions form
c v c



r v r

abox finite set assertions form
ak ai

ak ai

pk ai aj



pk ai aj

taken together constitute dl litehn
bool knowledge base k
following denote role k set role names occurring role k
set pk pk pk role k ob set object names role r
set

pk r pk
inv r
pk r pk
usual description logic interpretation consists nonempty
domain interpretation function assigns object name ai element
aii concept name ak subset aik domain role name
pk binary relation pki domain unless otherwise stated adopt
unique name assumption una
aii aij



j

una

however shall indicate depend una
depend assumption discuss consequences
dropping see sections
role concept constructs interpreted standard way
pk x x pki






q r




x x ri q

c c


c u c



c



inverse role
empty set
least q r successors
c

c

c c



fithe dl lite family relations

x denotes cardinality x use standard abbreviations
c c c u c



r r

q r q r

concepts form q r q r called number restrictions form
r called existential concepts
satisfaction relation standard
c v c

iff

c c

r v r

iff

r r

ak ai

iff aii aik

pk ai aj

iff

aii aij pki

ak ai

iff aii
aik

pk ai aj

iff

aii aij
pki

knowledge base k said satisfiable consistent interpretation satisfying members case write k well
say model k
languages dl lite family investigate article obtained restricting language dl litehn
bool along three axes boolean operators bool
concepts ii number restrictions n iii role inclusions hierarchies h
similarly classical logic adopt following definitions dl litehn
bool tbox
called krom tbox concept inclusions restricted
b v b

b v b



b v b

krom

bi b basic concepts called horn tbox
concept inclusions restricted
l
bk v b
horn
k

definition empty conjunction finally call core tbox
concept inclusions restricted
b v b



b v b

core

b v b equivalent b u b v core tboxes regarded sitting
intersection krom horn tboxes
remark sometimes use conjunctions
right hand side concept includ
sions restricted languages c v k bk clearly syntactic sugar add
extra expressive power
hn
hn
hn
dl litehn
krom dl litehorn dl litecore fragments dl litebool krom
hn
hn
horn core tboxes denoted dl litekrom dl litehorn dl litehn
core respectively fragments obtained limiting use number restrictions role
inclusions

krom fragment first order logic consists formulas prenex normal form whose quantifier free
part conjunction binary clauses



fiartale calvanese kontchakov zakharyaschev

hn
dl liteh
fragment dl lite core krom horn bool without number
restrictions q r q role inclusions denoted dl liteh
note
h
dl lite still use existential concepts r r
hf
dl litehf
fragment dl litehn
number
denote dl lite

restrictions q r existential concepts q q
occur concept inclusions form r v inclusion called
global functionality constraint states role r functional precisely
r v x ri x z ri z
f
dl liten
dl lite dl lite role inclusions excluded language
core krom horn bool obtain three fragments dl liten
arbitrary number restrictions dl litef

functionality
constraints

existential
concepts

r dl lite without number restrictions different r

shall see later article logics form dl litehf
dl litehn


even core turn computationally rather costly interaction
role inclusions functionality constraints generally number restrictions hand purpose conceptual modeling one may need
constructs cf example section compromise found artificially
limiting interplay role inclusions number restrictions way similar
logic dl litea proposed poggi et al
tbox let vt denote reflexive transitive closure relation


r r inv r inv r r v r
let r r iff r vt r r vt r say r proper sub role r
r vt r r
r
hn

hn

dl lite introduce logics dl lite
core krom horn bool
hn
one hand restrict logics dl lite limiting interaction
role inclusions number restrictions order reduce complexity reasoning
hand include additional constructs limited qualified existential quantifiers role disjointness symmetry ir reflexivity constraints increase
expressive power logics affect computational properties
hn
dl lite
tboxes must satisfy conditions remind
reader occurrence concept right hand left hand side concept
inclusion called negative scope odd even number negations
otherwise occurrence called positive
may contain positive occurrences qualified number restrictions q r c
c conjunction concepts allowed right hand side concept
inclusions
q r c occurs contain negative occurrences number
restrictions q r q inv r q
r proper sub role contain negative occurrences
q r q inv r q


fithe dl lite family relations

role
role
constraints inclusions






yes

disj
sym
ir ref
disj
sym
ir ref
tran


number
restrictions
r
r funct
qr
r
r funct
qr

concept inclusions
krom
horn
dl litekrom dl litehorn
dl litef
dl litef
krom
horn
n
dl litekrom dl liten
horn
h
dl liteh
dl lite
krom
horn
hf
dl litekrom dl litehf
horn
hn
dl litehn
dl lite
krom
horn

core
dl litecore
dl litef
core
dl liten
core
dl liteh
core
dl litehf
core
dl litehn
core

hf

bool
dl litebool
dl litef
bool
dl liten
bool
dl liteh
bool
dl litehf
bool
dl litehn
bool

hf

hf


r c funct dl lite hf
dl litekrom dl litehorn dl litebool
core
hn
hn
hn
hn

q r c
dl litecore
dl litekrom dl litehorn dl litebool

yes




r c funct dl lite hf
core

yes

q r c

hf

dl litekrom



hn


dl lite hn
dl litekrom
core

hf

dl litehorn

hn

dl litehorn

hf

dl litebool

hn

dl litebool

restricted

table extended dl lite family
hn

follows dl lite
tbox contain say functionality constraint
r v occurrence q r c q
hn
additionally dl lite
tboxes contain role constraints axioms form
dis r r

asym pk

sym pk

irr pk



ref pk

meaning constructs defined usual interpretation


q r c x c x ri q
dis r r
asym pk
sym pk
irr pk
ref pk

iff
iff

iff
iff
iff

r r roles r r disjoint
pki pk role pk asymmetric

pki pk

pk symmetric

x x
pki x
x x pki x

pk irreflexive
pk reflexive

emphasized extra constructs often used conceptual modeling
hn
introduction dl lite
motivated owl ql proposal note
hn
dl lite
contains dl liteh

dl liten

proper fragments
hn

hn

dl lite

bool horn krom core denote dl lite
extension
hn
dl lite
role transitivity constraints form tra pk meaning
expected
tra pk

iff

x pki z pki imply x z pki x z
pk transitive


fiartale calvanese kontchakov zakharyaschev

dl litebool

dl litehn





dl litehorn






dl litekrom










dl litecore

pp



dl litehf


dl liteh


dl liten


hn
dl lite
dl lite hn







pp





dl litef








ip
p
dl lite


hf dl lite
dl lite hf



figure language inclusions extended dl lite family
remind reader standard restriction limiting use transitive roles dls
see e g horrocks sattler tobies
simple roles r allowed concepts form q r q
simple role given tbox understand role without transitive sub roles
including particular contains tra p p p simple
cannot contain occurrences concepts form q p q p q
hf

hf

hf

dl lite
dl lite
define languages dl lite
sub languages
hn
dl lite
number restrictions form r r c functionality
constraints r v allowedprovided course satisfy
hf
particular r c allowed r functional dl lite
extensions
hf
dl lite
role transitivity constraints satisfying restriction
thus extended dl lite family consider article consists different
logics collected table inclusions logics shown figure
obtained taking product left right hand parts picture
subscript right hand part ranges core krom horn bool e
subscripts left hand part similarly superscript left hand part
ranges f n h hf hn hf hn hf hn e superscripts
right hand part
position logics relative dl lite logics known literature
owl ql profile discussed section starting section begin
thorough investigation computational properties logics extended dllite family without una illustrate expressive
power dl lite logics concrete example
dl lite conceptual modeling
tight correspondence conceptual modeling formalisms er model
uml class diagrams description logics pointed
papers e g calvanese et al b borgida brachman berardi et al
give example showing dl lite logics used conceptual
modeling purposes details see work artale et al b


fithe dl lite family relations



employee



empcode integer
salary integer

workson
boss

project

manager

projectname string



disjoint complete

areamanager

manages
topmanager



figure uml class diagram
let us consider uml class diagram depicted figure representing portion
company information system according diagram managers employees partitioned area managers top managers information
represented means following concept inclusions brackets specify
minimal dl lite language inclusion belongs
manager v employee

dl litecore

areamanager v manager

dl litecore

topmanager v manager

dl litecore

areamanager v topmanager

dl litecore

manager v areamanager topmanager

dl litebool

employee two functional attributes empcode salary integer values
unlike owl distinguish abstract objects data values hence
model datatype integer means concept attribute
employees salary means role thus salary represented follows
employee v salary
salary



dl litecore

v integer

dl litecore
dl litef
core

salary v

functional attribute empcode values integer represented way
binary relationship workson employee domain project range
workson v employee
workson



dl litecore

v project

dl litecore

binary relationship boss domain employee range manager treated analogously employee works project exactly one boss project must


fiartale calvanese kontchakov zakharyaschev

involve least three employees
employee v workson

dl litecore

employee v boss

dl litecore
dl litef
core

boss v
project v workson

dl liten
core

top manager manages exactly one project works project project
managed exactly one top manager
manages v topmanager
manages



v project

dl litecore

topmanager v manages
project v manages

dl litecore
dl litecore



dl litecore

manages v

dl litef
core

manages v

dl litef
core
dl liteh
core

manages v workson

languages extended dl lite family capable representing
hn
uml class diagram figure dl litehn
bool dl litebool note however except covering constraint manager v areamanager topmanager concept
inclusions dl lite translation uml class diagram belong variants
hn
core fragments dl litehn
core dl litecore hard imagine situation
one needs horn concept inclusions represent integrity constraints uml class diagrams example express together axioms chief executive
officer may work five projects manager one
ceo u workson u manages v

dl liten
horn

context uml class diagrams krom fragment dl litekrom variants
seems useless extends dl litecore concept inclusions form b v b
equivalently v b b rarely used conceptual modeling indeed
would correspond partitioning whole domain interest two parts
general useful covering constraints form b v b bk require full
bool language hand krom fragments important pinpointing
borderlines complexity classes description logics dl lite family
extensions see table

reasoning dl lite logics
discuss reasoning consider article mutual relationships complexity measures adopt provide overview complexity
dl lite logics obtained article



fithe dl lite family relations

reasoning
concentrate three fundamental standard reasoning tasks description
logics satisfiability consistency instance checking query answering
dl l extended dl lite family define l concept inclusion
concept inclusion allowed l similarly define notions l kb l tbox
finally define l concept concept occur right hand side
l concept inclusion conjunction concepts
satisfiability kb satisfiability check given l kb k whether
model k clearly satisfiability minimal requirement ontology
well known dl baader et al many reasoning tasks description logics
reducible satisfiability consider example subsumption
given l tbox l concept inclusion c v c decide whether c v c
c c every model reduce un satisfiability take
fresh concept name fresh object name set k
v c v c



easy
see c v c iff k satisfiable core krom horn kbs
c k dk dk possibly negated basic concept checking unsatisfiability
k amounts checking unsatisfiability kbs kk tk tk
v c v dk horn kbs replace v b equivalent u b v
concept satisfiability problemgiven l tbox l concept c decide
whether c model easily reducible kb satisfiability indeed
take fresh concept name fresh object name set k
v c



c satisfiable respect iff k satisfiable
instance checking instance checking decide given object name
l concept c l kb k whether k c ai c every
model k instance checking reducible un satisfiability object
instance l concept c every model k iff kb k
v c





notdsatisfiable fresh concept name core krom horn kbs
c k dk dk possibly negated basic concept proceed
subsumption checking unsatisfiability k amounts checking unsatisfiability
kb kk tk tk v dk
conversely kb satisfiability reducible complement instance checking k
satisfiable iff k fresh concept name fresh object
query answering positive existential query q x xn first order formula
x xn constructed means conjunction disjunction existential quantification starting atoms ak pk ak concept name pk


fiartale calvanese kontchakov zakharyaschev

role name terms taken list variables list
object names e positive existential formula precisely




yi







ak

ai


pk











yi

free variables called distinguished variables q bound ones nondistinguished variables q write q x xn query distinguished variables
x xn conjunctive query positive existential query contains disjunction
constructed atoms means conjunction existential quantification
given query q x x x x xn n tuple object names
write q replacing every occurrence xi x ith member
queries containing distinguished variables called ground known
boolean
let interpretation assignment function associating
every variable element use following notation ai
aii

satisfaction relation positive existential formulas respect
given assignment defined inductively taking
ak

iff

ti aik

pk

iff



ti
pk



iff





iff



yi

iff

b assignment b may differ yi

ground query q satisfaction relation depend assignment
write q instead q answer query yes

kb k say tuple object names certain answer
q x respect k write k q q whenever k query
answering formulated follows given l kb k query q x
tuple object names decide whether k q
note instance checking special case query answering object
instance l concept c respect kb k iff answer query
respect k yes k c v fresh
concept name horn concepts b u u bk consider query ak
respect k k b v bk v ak
ai fresh concept names similarly deal krom concepts u u dk
di possibly negated basic concept core concepts reduction holds
conjunctions basic concepts
complexity measures data combined complexity
computational complexity reasoning discussed analyzed
respect different complexity measures depend parameters


fithe dl lite family relations

regarded input e vary regarded
fixed satisfiability instance checking parameters consider size
tbox size abox number symbols
denoted respectively size k knowledge k simply given
query answering one parameter consider would size
query however analysis adopt standard database assumption size
queries bounded reasonable constant case negligible
respect size tbox size abox thus count
query part input
hence consider reasoning two complexity measures whole
kb k regarded input deal combined complexity however
abox counted input tbox query regarded
fixed concern data complexity vardi combined complexity interest
still designing testing ontology hand data complexity
preferable cases tbox fixed size size query
negligible compared size abox case instance context
ontology data access calvanese de giacomo lembo lenzerini poggi rosati
data intensive applications decker erdmann fensel studer noy
lenzerini calvanese et al since logics dl lite family
tailored deal large data sets stored relational databases data complexity
instance checking query answering particular interest us
remarks complexity classes logspace ac
deal following complexity classes
ac logspace nlogspace p np exptime
definitions found standard textbooks e g garey johnson
papadimitriou vollmer kozen remind reader
two smallest classes logspace ac
belongs logspace two tape turing machine
starting input length n written read input tape stops accepting rejecting state used log n cells initially blank read write work
tape logspace transducer three tape turing machine started
input length n written read input tape writes polynomial size
write output tape log n cells initially blank read write
work tape logspace reduction reduction computable logspace transducer
composition two logspace transducers logspace transducer kozen
lemma
formal definition complexity class ac see e g boppana sipser
vollmer references therein circuit model functions
represented directed acyclic graphs built unbounded fan
gates e gates may unbounded number incoming edges
definition assume decision encoded alphabet
regarded boolean functions ac class definable


fiartale calvanese kontchakov zakharyaschev

family circuits constant depth polynomial size generated
deterministic turing machine logarithmic time size input latter
condition called logtime uniformity intuitively ac allows us use polynomially
many processors run time must constant typical example ac
evaluation first order queries databases model checking first order sentences
finite database first order model regarded input
query first order sentence assumed fixed abiteboul hull vianu
vollmer hand undirected graph reachability known
logspace reingold ac boolean function f n
called ac reducible constant depth reducible function g n
logtime uniform family constant depth circuits built
g gates computes f case say ac reduction note
reductions considered section ac reductions unless otherwise indicated
follows write reduction ac reduction
summary complexity
article aim investigate combined data complexity satisfiability instance checking ii data complexity query answering
logics extended dl lite family without una
hf
obtained known first logics table logics dl lite
hn
dl lite
included summarized table remind reader
satisfiability instance checking reducible complements
instance checking special case query answering fact
table follow lower upper bounds marked respectively
taking account hierarchy languages dl lite family example
nlogspace membership satisfiability dl liten
krom theorem implies
n
f
upper bound dl litekrom dl litekrom dl litecore dl litef
core dl litecore

sub languages dl liten
krom
remark two complexity noted included
table
equality object names allowed language dl lite
makes sense una dropped ac memberships table replaced logspace completeness see section theorem inequality
constraints affect complexity
ii extend languages role transitivity constraints combined complexity satisfiability remains data complexity instance
checking query answering become nlogspace hard see lemma e
membership ac data complexity replaced nlogspace completeness
complexity remain
case property first order rewritabilitythat possibility rewriting
given query q given tbox single first order query q returning certain
answers q every abox ensures query answering
ac data complexityis lost


fithe dl lite family relations

complexity
languages

una

combined complexity
satisfiability

h
dl lite core
h
dl litehorn
h
dl litekrom
h
dl litebool
n hf hn
dl lite f
core
f n hf hn
dl litehorn
f n hf hn
dl litekrom
f n hf hn
dl litebool
f hf
dl litecore horn
f hf
dl litekrom
f hf
dl litebool
n hn
dl litecore horn
n hn
dl litekrom bool
dl litehf
core horn
dl litehf
krom bool
dl litehn
core horn
hn
dl litekrom bool

yes

yes



yes

data complexity
instance checking


query answering

nlogspace

ac

ac

p th

ac

ac c



nlogspace th

ac

conp b

np th

ac th

conp



nlogspace

ac

ac

p th

ac

ac th

nlogspace th

ac

conp



np th

ac cor

conp

p cor th

p th

p

p cor

p

conp

np

p cor

conp

np th

conp th

conp

np th

conp

conp

exptime th

p th

p

exptime

conp th

conp

exptime

conp th

conp

exptime f

conp

conp e

complexity respective fragment propositional boolean logic
b follows proof data complexity instance checking ale schaerf
c calvanese et al
follows horn shiq hustadt motik sattler eiter gottlob ortiz simkus
e follows shiq ortiz calvanese eiter glimm horrocks lutz sattler
f follows shiq tobies

table complexity dl lite logics complexity bounds save ac tight

n
means dl lite dl liten
dl lite

particular dl lite h dl lite dl liteh


dl litecore horn means dl litecore dl litehorn likewise dl litekrom bool
x x means upper respectively lower bound follows x

detailed proofs given sections variants logics
involving number restrictions upper bounds hold assumption
numbers q concepts form q r given binary intuitively follows
fact proofs use numbers explicitly occur kb
lower bounds remain unary coding since corresponding proofs
use numbers exceeding
next section consider extended dl lite family general context
identifying place among dl lite related logics particular owl profiles


fiartale calvanese kontchakov zakharyaschev

landscape dl lite logics
original family dl lite logics created two goals mind identify
description logics one hand capable representing basic features
conceptual modeling formalisms uml class diagrams er diagrams
hand computationally tractable particular matching ac data
complexity database query answering
saw section represent uml class diagrams one need typical quantification constructs basic description logic alc schmidt schau smolka
namely universal restriction r c qualified existential quantification r c one
take role filler c indeed domain range restrictions
relationship p expressed concepts inclusions p v b p v b respectively thus almost concept inclusions required capturing uml class diagrams
form b v b b v b observations motivated introduction
calvanese et al first dl lite logic nomenclature corresponds
dl litef
core main polynomial time upper bound combined
complexity kb satisfiability logspace upper bound data complexity
conjunctive query answering una extended calvanese
h
et al two larger languages dl litef
horn dl litehorn originally
called dl liteu f dl liteu r respectively calvanese et al b introduced another member dl lite family named dl liter extended dl liteh
core
role disjointness axioms form dis r r computational behavior
logic turned dl liteh
core may worth mentioning
dl liteh
covers

dl
fragment

rdfs
klyne
carroll hayes note
core
calvanese et al considered variants dl liteu f dl liteu r
arbitrary n ary relations usual binary roles showed query answering still logspace data complexity conjecture similar
obtained dl lite logics introduced artale et al b
demonstrated n ary relations represented dl litef
core means reification
variant dl lite called dl litea attributes introduced
poggi et al aim capturing many features conceptual modeling
formalisms possible still maintaining computational properties basic
variants dl lite one features dl litea borrowed conceptual modeling
formalisms adopted owl distinction abstract objects data
values consequently concepts sets objects datatypes sets data
values roles e object properties owl relating objects objects
attributes e data properties owl relating objects data values however
far concerned distinction concepts
datatypes roles attributes impact reasoning whatsoever since
datatypes simply treated special concepts mutually disjoint
disjoint proper concepts instead relevant reasoning possibility
express dl litea role inclusions functionality e dl litea includes
f
hf
dl liteh
core dl litecore dl litecore
already mentioned role inclusions functionality constraints cannot
combined unrestricted way without losing good computational properties



fithe dl lite family relations


b
b

dl litehn
krom
b

b

b



shiq
dl litehn
horn
b

dl litehn
bool
b


b

dl litekrom
b

b

dl litehf
core
b

hn

b

b

b

p

b

dl litecore
hf
dl litecore

dl liten
core

hn

dl litehorn
hf
dl litehorn
dl liten
horn

dl litea u
b

b

b

b

b

dl litehf
horn

dl lite

dl litea
dl litef dl litef
dl litef u dl litef
core
horn
h
dl liter dl litecore
dl liter u dl liteh
horn
dl litecore
b

b

ac

dl litebool

horn shiq

conp



b

dl litehn
core

b

b

b

figure dl lite family relations
theorems prove satisfiability dl litehf
core kbs exptime hard
combined complexity instance checking data hard p nlogspace hardness
shown calvanese et al dl litea keep query answering ac
data complexity satisfiability nlogspace combined complexity functional roles
attributes allowed specialized e used positively right hand
side role attribute inclusion axioms condition slight generalization
restriction dl litea allows axioms form b v r c non functional
roles r covered conditions thus dl litea regarded
hf
hn
proper fragment dl litecore dl litehorn sections
three languages enjoy similar computational properties una
tractable satisfiability query answering ac
conclude section picture figure illustrating landscape dllite related logics grouping according data complexity positive existential
query answering una original eight dl lite logics called calvanese
et al b dl lite family shown bottom sector picture logics

dl lite
dl litea u extend dl litea dl litea u identification constraints
hn

scope article nearest relatives logic dl litehorn
fragments ac well next layer contains logics dl litehf
core
dl litehf



query
answering

data complete

p

matter
whether

horn
una adopted fact logics fragments much expressive dl
horn shiq shown enjoy data complexity query answering
eiter et al remains seen whether polynomial query answering practically
feasible recent experiments dl el lutz toman wolter indicate
may indeed case finally distant relatives dl lite family comprise



fiartale calvanese kontchakov zakharyaschev

upper layer picture query answering data complete conp
expressive dl shiq
dl lite family owl
upcoming version web ontology language owl defines three profiles
restricted versions language suit specific needs dl lite family notably
dl liteh
core original dl liter basis one owl profiles called
owl ql according http www w org tr owl profiles owl ql aimed
applications use large volumes instance data query answering
important reasoning task owl ql sound complete conjunctive query
answering performed logspace respect size data assertions
polynomial time used implement ontology consistency
class expression subsumption reasoning expressive power profile
necessarily quite limited although include main features conceptual
uml class diagrams er diagrams section briefly discuss
obtained article context additional constructs present
owl
important difference dl lite family owl status
unique name assumption una assumption quite common data management
hence adopted dl lite family adopted owl instead owl
syntax provides explicit means stating object names say b supposed
denote individual b interpreted differently b
owl constructs called sameas differentfrom
complexity obtain logics form dl liteh
depend
whether una adopted every model dl liteh
kb without una
untangled model kb respecting una see lemma
n
however case logics dl litef
dl lite obvious
interaction una number restrictions cf table example

una instance checking dl litef
core ac data complexity whereas dropping
assumption much higher complexity section prove p complete
h
addition equality construct dl liteh
core dl litehorn slightly changes
data complexity query answering instance checking rises membership
ac logspace completeness see section important however
case loose first order rewritability query answering instance checking
cannot use standard database query engines straightforward manner
since owl profiles defined syntactic restrictions language without
changing basic semantic assumptions chosen include owl ql
profile construct interferes una absence una
would cause higher complexity owl ql include number restrictions even functionality constraints keys mechanism identifying objects
means values properties supported although impor http www w org owl
logic profiles would called fragments defined placing restrictions owl
syntax



fithe dl lite family relations

tant notion conceptual modeling indeed keys considered generalization
functionality constraints toman weddell calvanese de giacomo lembo
lenzerini rosati b since asserting unary key e one involving
single role r equivalent asserting functionality inverse r hence
absence una allowing keys would change computational properties
already mentioned standard owl constructs role disjointness symmetry ir reflexivity constraints added dl lite logics
without changing computational behavior role transitivity constraints tra r hn
serting r must interpreted transitive role added dl litehorn
leads increase data complexity reasoning nlogspace
although satisfiability remains p combined complexity found
section
constructs owl far supported dl lite logics
mention nominals e singleton concepts boolean operators roles role chains

satisfiability combined complexity
dl litehn
bool clearly sub logic description logic shiq satisfiability
known exptime complete tobies
section however satisfiability dl liten
bool kbs

reducible satisfiability one variable fragment ql first order logic
without equality function symbols satisfiability ql formulas np complete
see e g borger et al logics consideration contain full booleans
concepts satisfiability dl liten
bool kbs np complete well shall see
translations horn krom kbs ql belong horn krom fragments
ql respectively known p nlogspace complete see e g papadimitriou borger et al section simulate behavior
polynomial space bounded alternating turing machines means dl litehf
core kbs
give optimal exptime lower bound satisfiability kbs languages
family containing unrestricted occurrences functionality constraints role
inclusions section extend embedding ql defined section
hn
logic dl litebool thereby establishing upper bounds dl liten
bool
fragments finally section investigate impact role transitivity constraints
dl liten
bool fragments first order perspective
aim section construct reduction satisfiability dl liten
bool
kbs satisfiability ql formulas two steps first present lengthy
yet quite natural transparent yet exponential reduction shall see
proof reduction substantially optimized linear reduction

let k dl liten
bool kb recall role k denotes set direct
inverse role names occurring k ob set object names occurring
r role k let qr
set natural numbers containing numbers q
concept q r occurs recall abox contain number
restrictions note qr
contains functionality constraint r



fiartale calvanese kontchakov zakharyaschev

every object name ai ob associate individual constant ai ql
every concept name ai unary predicate ai x signature ql
role r role k introduce qr
many fresh unary predicates
q qr


eq r x

intended meaning predicates follows role name pk
eq pk x eq pk x represent sets points least q distinct pk successors
least q distinct pk predecessors respectively particular e pk x
e pk x represent domain range pk respectively
additionally every pair roles pk pk role k take two fresh individual constants
dpk

dp
k
ql serve representatives points domains pk

pk respectively provided empty let dr k dr r role k
furthermore pair object names ai aj ob r role k take
fresh propositional variable rai aj ql encode abox assertion r ai aj

induction construction dl liten
bool concept c define ql formula
c


ai ai x

q r eq r x

c c x

c u c c x c x



dl liten
bool tbox corresponds ql sentence x x


x
c x c x



c vc

abox translated following pair ql sentences




ak ai
ak ai










ak ai

ak ai

pk ai aj





pk ai aj



pk ai aj

pk ai aj

every role r role k need two ql formulas
r x e r x inv e r inv dr


r x
eq r x eq r x





q q qr
q q


q q q q qr


follows slightly abuse notation write r ai aj indicate pk ai aj
r pk pk aj ai r pk



fithe dl lite family relations

overloading inv operator

eq pk r pk
inv eq r
eq pk r pk




dp
k
inv dr
dpk

r pk
r pk

formula says domain r empty range empty
contains constant inv dr representative domain inv r
need formulas representing relationship propositional variables rai aj
unary predicates role domain range role r role k let r
following ql sentence






q



rai ajk eq r ai

ai ob qqr
aj ajq ob k

jk jk k k






rai aj inv r aj ai

ai aj ob

inv r aj ai propositional variable pk aj ai r pk pk aj ai r pk
note first conjunct part translation relies una
finally dl liten
bool knowledge base k set

h
h







r
k x x
r x r x
rrole k

rrole k

thus k universal sentence ql
example consider example kb k


v p p v v p v p p v
p obtain following first order translation
k x x p aa


p aa e p p aa e p


p e p p e p


p aa e p p aa e p


p e p p e p


p aa p aa e p p p e p


p aa p aa e p p p e p




p aa p p p aa p aa p aa p p

x

x e p x



e p x x x e p x


e p x e p x x


e p x e p dp e p x e p dp


e p x e p x e p x e p x






fiartale calvanese kontchakov zakharyaschev


theorem dl liten
bool knowledge base k satisfiable iff ql sentence

k satisfiable

proof k satisfiable model k whose domain consists
constants occurring k e ob dr k say herbrand model k
denote domain interpretations unary predicates p propositional
variables p constants ql p pm respectively thus every
constant let set constants ob without loss
generality may assume

construct interpretation dl liten
bool domain
inductively defined union







wm

w



interpretations object names ai given interpretations
namely aii
w set wm constructed adding wm
elements fresh copies certain elements element
w copy w write cp w w w let cp w w
set wm wm denoted vm convenience let w
v
interpretations aik concept names ak defined taking


aik w ak cp w

interpretation pki role name pk defined inductively union
pki






pkm



pkm wm wm



along construction first role r role k define required
r rank r r point taking

r r max q qr
eq r
follows r r q every q qr
eq r
whenever q q eq r whenever q q define actual r rank
rm r w point w step taking

w wm w w pkm r pk
rm r w
w wm w w pkm r pk
basis induction set role name pk role k



pk
aj w w pk ai aj



observe r role k w w
r r w r r cp w




fithe dl lite family relations

suppose wm pkm already defined
rm r w r r cp w roles r role k points w wm interpretation need would constructed however general case
may defects sense actual rank points smaller
required rank
role name pk role k consider following two sets defects pkm



w vm rm pk w r pk cp w
k



w vm rm pk w r pk cp w
k
purpose say
k identify defective points w vm precisely
r pk cp w distinct pk arrows start according arrows still
missing rm pk w many arrows exist cure defects extend wm
pkm respectively wm pkm according following rules


k let w k q r pk cp w rm pk w cp w eq pk

q qr
q q e pk


e pk dpk case take q fresh copies w wq dp
k set



cp wi dpk q add wm add pairs w wi q
pkm





k let w k q r pk cp w rm pk w cp w eq pk


q qr
q q e pk


e pk dpk take q fresh copies w wq dpk set cp wi dpk
q add wm add pairs wi w q pkm

example consider kb k first order translation k example
consider model k domain dp dp
e p e p e p

e p
p aa p

begin construction interpretation k setting w v
p compute required actual ranks r r w r r w
r p p w v
r p r p
iii r p r p

ii r p r p
iv r p r p

next step draw p arrow fresh copy dp cure defect draw
two p arrows two fresh copies dp order cure defects ii finally
take fresh copy dp connect p arrow thereby curing defect iii
one step unraveling construction shown figure
observe following important property construction w vm
r role k




rm r w

q
q r r cp w


r r cp w


fiartale calvanese kontchakov zakharyaschev



v


v



v

dp

dp


figure unraveling model first three steps
prove property consider possible cases
point w added wm yet e w
wm
rm r w
rm r w r r cp w follows
w added step cure defect point
w wm means pk role k w w pkm


w
w w pkm w k
consider former case
k

since
fresh
witnesses

picked
every time rule km
cp w dp
k

applied rm pk w rm pk w rm r w every r pk pk

suffices r pk dp
k indeed eq pk cp w

r

q qt e pk cp w e pk dp
k




latter
case

considered
analogously
definition r r pk dp
k
role name pk defects w cured step


applying rules
therefore rm r w r r cp w
k k
follows observation arrows involving w
added step role name pk role k
pkm pkm



vm vm



vm vm




follows r role k q qr
w

eq r cp w

iff

w q r



indeed eq r cp w definition r r cp w q let w vm
rm r w r r cp w q follows definition


fithe dl lite family relations

rm r w ri w q r conversely let w q r w vm
q rm r w r r cp w definition r r cp w
eq r cp w
induction construction concepts c k one readily see every
w
c cp w
iff
w ci

indeed basis trivial b follows b ak
b q r induction step booleans c c c c u c
immediately follows induction hypothesis
finally


iff



case c v c follows ak ai ak ai
definition aik pk ai aj pk ai aj aii aij pki iff
aii aij pk iff pk ai aj
thus established k
conversely suppose k interpretation domain construct

model k every ai ob let
ai
every r role k take r r arbitrary element

otherwise let drm next every concept name ak let
k ak

q r finally every
every role r role k q qr
set eq r

role r role k every pair objects ai aj ob define rai aj true
iff r ai aj one readily check k details left reader
q
first order translation k k obviously lengthy provide us reasonably
low complexity k k qt role k role k ob qt however
follows proof lot information translation redundant
safely omitted
define concise translation k k ql taking
h




k x x
r x r x


rrole k


x r x r x defined means
respectively





eqr r
pk ai aj

aob

rrole k
ob r

pk ai aj

qr maximum number qr
qr many distinct ai
r ai use una pk ai aj pk ai aj

otherwise size size k linear size k
respectively matter whether numbers coded unary binary


fiartale calvanese kontchakov zakharyaschev

importantly translation actually done logspace indeed


trivially case x r x r x last conjunct

first conjunct r role k ob maximum qr
qr
qr many distinct ai r ai computed
log min max qr
ob log ob cells initially set q enumerate
object names ai incrementing current q time r ai stop
q max qr
reach end object name list resulting qr maximum
number qr
exceeding q
example translation k kb k example looks follows
k x x e p e p
x defined


corollary dl liten
bool kb k satisfiable iff ql sentence k satisfiable

proof claim follows fact k satisfiable iff k satisfiable indeed
k clearly k conversely k one construct model
domain taking




k ak concept names ak


eq rm eq rm r role k q qr



rai aj true iff r ai aj




ai ai ob


drm drm r role k


claim k indeed eq rm eq rm every r role k q qr



follows x x x r x definition va
q
x r x remains r suppose raaji
r aji distinct aj ajq q qr
clearly q qr
eq r thus eq r
q
immediate consequence corollary facts translation
done logspace satisfiability ql formulas np complete
dl litebool contains booleansand encode full propositional logicwe
obtain following
f
theorem satisfiability dl liten
bool dl litebool dl litebool knowledge bases
np complete combined complexity


observe k dl liten
krom kb k krom fragment ql
f
theorem satisfiability dl liten
dl lite dl lite knowledge bases
core krom nlogspace complete combined complexity



fithe dl lite family relations

proof satisfiability krom formulas prefix form x
k nlogspace complete see e g borger et al exercise
logspace reduction satisfiability nlogspace logics mentioned
theorem lower bound suffices recall nlogspace hardness
satisfiability propositional krom formulas proved reduction directed graph
reachability core propositional formulas borger et al
satisfiability logics nlogspace hard
q


k dl liten
horn kb k belongs universal horn fragment ql
f
theorem satisfiability dl liten
horn dl litehorn dl litehorn kbs p complete
combined complexity

proof ql contains function symbols k universal satisfiability k
logspace reducible satisfiability set propositional horn formulas namely
formulas obtained k replacing x constants occurring
k remains recall satisfiability propositional horn formulas
p complete see e g papadimitriou gives required upper bound
q
dl liten
horn lower bound dl litehorn
dl litehf
core exptime hard
unfortunately translation constructed previous section cannot extended
logics form dl litehn
number restrictions role inclusions

section satisfiability dl litehf
core kbs exptime hard
matches upper bound satisfiability dl litehn
kbs
even binary coding
bool
natural numbers tobies
note first although intersection allowed left hand side dl litehf
core
concept inclusions certain cases right hand side consistent simulate
role inclusions functionality constraints suppose knowledge base k
contains concept inclusion form c u c v c define kb k replacing
axiom k following set axioms r r r r r fresh
role names
c v r

c v r



r v r

r v r



r v
r

v



r



r v c



r v r



r

r v r

v




lemma k k every interpretation
ii k c model k domain
agrees every symbol k


fiartale calvanese kontchakov zakharyaschev

proof suppose k x c c x r
whence
r z x z r x x z r
z view r hence u u r
x ri finally follows
u r u c u r

u x x c thus k
ii take point c c define extension role names
setting


r x x x c


r x x x c


r x x x c u c c x x c u c




ri ri
r













ri ri
r



readily seen satisfies axioms k

q

position prove following
theorem satisfiability dl litehf
core kbs exptime hard combined complexity
without una
proof prove theorem two steps first consider logic dl litehf
horn
encode behavior polynomial space bounded alternating turing machines atms short means dl litehf
horn kbs apspace exptime
apspace class recognized polynomial space bounded atms see e g
kozen establish exptime hardness satisfiability dl litehf
horn
lemma get rid conjunctions left hand side
concept inclusions involved encoding atms thus establish exptime hardness
dl litehf
core
without loss generality consider atms binary computational
trees means every non halting state q every symbol tape
alphabet precisely two instructions form
q q



q q



resp means move head right resp left one cell
remind reader non halting state state state
given atm polynomial function p n every run every
input length n use p n tape cells input word
construct dl litehf
horn knowledge base km following properties size
km polynomial size ii accepts iff km satisfiable
denote q set states tape alphabet
encode instructions need following roles
sq sq sq q q informally x sq interpretation means
x represents configuration state q x sqk means
next state according transition km q k


fithe dl lite family relations

hi hi hi p n x hi means x represents configuration
head scans ith cell x hik according transition
km k next configuration head scans ith cell
c p n x c means x represents
cia cia
ia
ia
k according
configuration ith cell contains x cia
km k next configuration ith cell contains

intended meaning encoded following concept inclusions every
instruction q km q every p n

k
k
sq u hi u cia
v hi
u sqk u cia




every instruction q km q every p n

k
k
sq u hi u cia
v hi
u sqk u cia




preserve symbols tape active cell use following
concept inclusions k j p n j

k
hj u cia
v cia




synchronize roles need two functional roles tk number role
inclusions added tbox k p n q q
k
cia
v cia

hik v hi

sqk v sq



k
cia
v tk

hik v tk

sqk v tk



tk v



remains encode acceptance conditions done help
role names yk k concept name
sq v

q accepting state

yk v tk
tk
tk u
sq u yk
sq



v
v



yk

v

u u v




q state



q state



tbox dl litehf
horn knowledge base km constructing consists
axioms together auxiliary axiom
u v



fresh concept name abox km comprised following
assertions object names u
sq u

q initial state

h u
ciai u




p n ai ith symbol input tape







fiartale calvanese kontchakov zakharyaschev

clearly km dl litehf

horn kb size polynomial size
lemma atm accepts iff kb km satisfiable
proof suppose accepts km interpretation
reconstruct full computation tree induction following way
let root tree point si represents initial configuration accordance intended meaning roles sq h ciai
explained matter instance si h
assume already found point x representing configuration
c b bi q bi bi bp n



q current non halting state head scans ith cell containing bi
means
x sq hi


x cjb

j

j p n

assume contains two instructions form q bi q nonhalting q bi km q b k
points ys yh yj j p n
x ys sqk

k
x yh hi


k
x yi cib


k

x yj cjb
j

j

c c j sub roles functional role
sq hi
k
jbj
ib
points ys yh yj coincide denote point xk


x xk tki



cib
xk sq hi




xk cjb
j

j

similarly q bi km q b k
point xk
x xk tki



cib
xk sq hi




xk cjb
j

j

thus k xk tk successor x representing configuration ck
executed q bi km q b c case ck called k successor c
according every point constructed computation tree representing configuration accepting state ai suppose inductively
x represents configuration c form q state xk represents ksuccessor c x xk tki k one xk say x ai
view x functional sub role
x x x ai case x state
considered analogously help
since accepts conclude si ai contrary
conversely suppose accept consider full computation
tree nodes labeled configurations way root
labeled initial configuration
q ap n


fithe dl lite family relations

ai n p n blank node x tree labeled
non halting c form contains two instructions form
x one successor labeled successor c one successor labeled
successor c emphasized tree different
nodes may labeled configuration
use tree construct interpretation follows
u u

si root ui u
di si
k x x c k x x c k j
x xk sqk x xk hi
k
k
jbj
ib
iff x labeled c form q bi km q b x k xk k
k x x c k x x c k j
x xk sqk x xk hi
k
k
jbj
ib
k
iff x labeled c form q bi q b x k xk k

u si sq u si h u si ciai p n extensions
roles sq hi cia defined according
tki k k
ai defined inductively
induction basis x labeled accepting configuration x ai
induction step x k xk k xk ai x xk yki ii
x state respectively state x xk yki respectively
k x ai
follows given definition km details left reader

q

lemma proved establishes satisfiability dl litehf
horn kbs
exptime hard next aim one eliminate conjunctions
left hand side tbox axioms help
lemma applying check first km satisfiable satisfiable
interpretation km c every c occurring
axiom form c u c v c k consider instance axiom assume
km sqk construct interpretation adding two


points say x domain setting x sqk x sq



x tk furthermore q accepting state set ai x yki
one readily check still model km conjuncts
remaining axioms considered analogously
application lemma axiom form c uc v c c c uc
obtain kb k concept inclusion form c uc v r
requires treatment means lemma able


fiartale calvanese kontchakov zakharyaschev



check k satisfiable interpretation r suppose

k r construct adding two points say x


ri ri
domain adding x c x r r


readily seen k
noted proof depend whether una adopted

q
immediate consequence obtain
corollary satisfiability dl litehf
dl litehn
kbs without una


exptime complete combined complexity core krom horn bool
reconciling number restrictions role inclusions
seen previous section unrestricted interaction number restrictions role inclusions allowed logics form dl litehn
high

combined complexity satisfiability section shall see data complexity
instance checking query answering becomes unacceptably high logics
quick look proof theorem reveals culprit interplay role
inclusions r v r r v r functionality constraints r v effectively mean
r x r x z z section study case
interplay allowed
hn
recall section dl lite
tboxes core krom horn bool
satisfy following conditions
may contain positive occurrences qualified number restrictions q r c
c conjunction concepts allowed right hand side concept
inclusions
q r c occurs contain negative occurrences number
restrictions q r q inv r q
r proper sub role contain negative occurrences
q r q inv r q
hn

dl lite
tboxes contain role constraints dis r r asym pk sym pk
irr pk ref pk
main aim section prove following theorem develop technical
hn
tools need investigate data complexity reasoning dl litebool
sublogics later
hn

theorem combined complexity satisfiability dl litebool kbs np hn
complete ii satisfiability dl litehorn kbs p complete iii satisfiability
hn
hn
dl litekrom dl litecore kbs nlogspace complete



fithe dl lite family relations

hn

let us consider first sub language dl litebool

without qualified number restric hn

tions role constraints mentioned denote dl litebool sub

hn

language required purely technical reasons section use dl litehorn
need core krom fragments
hn
suppose given dl litebool
kb k let id distinguished
role name use simulate identity relation required encoding role
constraints assume k contain id satisfies following
conditions
id id ai aj iff j ai aj ob


id
id v id id v id qid
qt
id id allowed role inclusions form id v id id v r
follows without loss generality assume



r

q qr
qt whenever r vt r


case add missing numbers qr
e g introducing
fictitious concept inclusions form v q r
way section define two translations e e k
one variable fragment ql first order logic former translation e retains
information relationships abox objects every model
ke unraveled model k define e taking
h
ke x x r x



r x r x





rrole k

h










r

rrole k



rai aj r ai aj





rvr
ai aj ob





x r x r x r



r x
eq r x eq r x
rvr
inv r vinv r



qqr


following lemma analogue theorem
hn

lemma dl litebool

kb k satisfiable iff ql sentence ke satisfiable

proof proof basically follows lines proof theorem modifications present modified unraveling construction converse direction exactly
theorem
equivalence class ri rj ri rj select single role representative
class denote rept ri extending pkm pkm use following
modified curing rules


fiartale calvanese kontchakov zakharyaschev




k pk rept pk nothing defects cured rept pk otherwise let

w k q r pk cp w rm pk w cp w eq pk
q q e pk e pk dp
k
dp q
case take q fresh copies w wq dp

set
cp w

k
k
add wm

add pairs w wi q pjm pk vt pj including
pj pk
add pairs wi w q pjm pk vt pj
id occurs k add pairs wi wi q pjm id vt pj



k rule mirror image k pk dpk replaced everywhere

pk dpk respectively see proof theorem

follows definition id never
resulting
defects interpreted

interpretation identity relation idi w w w interpretations
roles respect role inclusions e r r whenever r vt r
remains constructed interpretation indeed model k
first trivially holds id required actual ranks equal second holds r r id r proper sub roles proof exactly
theorem taking account cure defects single role
equivalence class r r r r cp w r r cp w
r inv r cp w r inv r cp w follows holds id role r
without proper sub roles however necessarily hold roles r proper
sub roles follows construction actual rank may greater required
rank case following
eq r cp w



w q r

however enough purposes induction structure concepts
one c v c whenever x c x c x
concept inclusion c v c therefore see proof
theorem thus k
q
remark follows proofs theorem lemma
hn
dl litebool
kb k every model ke induces model im k
following properties
abox ai aj ob aii aij rim iff r ai aj clet
clet




r ai aj r ai aj r vt r

forest object names ob induce partitioning im disjoint labeled
trees ta ta ea nodes ta edges ea root aim labeling function
ea role k id id


fithe dl lite family relations

copy function cp im ob dr k
cp aim ob
cp w dr w ta w w ea w w inv r
iso r role k labeled subtrees generated elements w im
cp w dr isomorphic
concept w b im iff b cp w basic concept b k w im



role idim w w w im every role name pk
pkim






aii aij r ai aj r vt pk

w w id vt pk



w w ea w w r r vt pk
aob

model called untangled model k untangled model k induced
precise
translation e generalizes thus suffers exponential blowup
define optimized translation e linear size k taking
h





e
r x r x
ke x x r x
rrole k


x r x r x r x defined
respectively




e r
ae
eqr


pk ai aj e
aob

rrole k
ob r clet

pk ai aj

e
e
qr
maximum number qr
qr many distinct ai
r ai clet use una pk ai aj e pk ai aj clet

otherwise cf note qr
roles r role k
translation depend whether una adopted
following corollary proved similarly corollary
hn

corollary dl litebool

kb k satisfiable iff ql sentence ke satisfiable

clear translation e computed nlogspace combined

complexity indeed readily seen x r x r x r x

order compute ae need able check whether r ai aj clet test
performed non deterministic logarithmic space role k
basically standard directed graph reachability
nlogspace complete see e g kozen done n log role k
log ob cells work tape n constant fact n enough one


fiartale calvanese kontchakov zakharyaschev

store r current role r path length graph reachability subroutine
bounded log role k therefore translation e computed
nlogspace transducer
hn
satisfiability dl litebool kbs easily reduced satisfiability
hn

hn

dl litebool
kbs first assume dl litebool kbs contain role symmetry
asymmetry constraints asym pk equivalently replaced dis pk pk
sym pk pk v pk noted introduction pk v pk
tbox violate following lemma allows us get rid qualified number
restrictions well role disjointness reflexivity irreflexivity constraints
hn

lemma every dl litebool
kb k

hn

kb k one construct dl litebool

every untangled model im k model k provided
r ai aj r ai aj clet dis r r
r ai ai clet irr r



every model k gives rise model k domain
agrees symbols k
hn

hn

k dl litehorn kb k dl litehorn

kb

proof first every pair r c q r c occurs introduce fresh role
name rc replace positive occurrence q r c q rc
add following concept role inclusions tbox

vc
rc



rc v r

repeat procedure occurrences qualified number restrictions eliminated denote resulting tbox observe ensure
satisfies notice c occurs right hand side extra
axioms thus belongs fragment clear since
q r c occur positively every model model conversely every
model model domain coincides
w u ri u c role r
symbols rc
c
without loss generality may assume
let



tirref
tdisj

tref


tref
irref tdisj sets role reflexivity irreflexivity disjointness con hn

straints remaining dl litebool
tbox let





v id id v id
id v p ref p tref



id ai ai ai ob
hn

construct k modifying dl litebool
kb k two steps
take fresh role name
step every reflexivity constraint ref p tref
p


fithe dl lite family relations

add role inclusion sp v p tbox
replace every basic concept b b sp defined inductively follows
asp concept name
q r sp q r role r
p p
q p sp q sp q p sp q sp q
p sp p sp
replace r ai aj r p sp ai aj whenever j
intuitively split role p irreflexive part sp id note p
reflexive proper sub role restrictions maximal number
p successors p predecessors therefore sp ref p let
hn
resulting dl litebool
kb clearly satisfies id id observe
clet role k clet






role k means restriction role names k
let im untangled model im consider role p
ref p notice sp proper sub roles idim disjoint
spim thus spim idim p im
b sp im b im b q r q whenever ref p r p p
p proper sub role
p proper sub roles e proper sub roles different sp id
spim idim p im basic concepts b covered
b im b sp im follows im


step next take account set tdisj
dis pk id irr pk tirref
disjointness constraints modifying kb constructed previous step
observe r v logical consequence dis r r whenever r vt r
let defined taking



r v r vt r dis r r dis r r
role untangled model im r r role k im dis r r
r ai aj r ai aj clet means
r ai aj r ai aj clet holds every untangled model im




idim identity relation
model thus im tdisj



im tref tirref im shown im
therefore im k
conversely suppose model k let interpretation idi



identity relation spi p idi p ref p ai ai


p p ai ai concept role object names p k clearly
definition sp since obtain
thus whence k
q



fiartale calvanese kontchakov zakharyaschev

hn

follows lemma given dl lite
kb k krom horn

hn
bool compute dl litebool
kb k logspace transducer
essentially required checking whether r p immediately obtain theorem
lemma observing krom horn bool ke belongs
respective first order fragment condition checked nlogspace
hn
computing clet requires directed graph accessibility checks dl litecore
hn
follows corresponding dl litekrom
role transitivity constraints
hn

consider languages dl lite
core krom horn bool extend
hn
dl lite
role transitivity constraints form tra pk remind reader
role called simple see e g horrocks et al transitive sub roles
including simple roles r allowed concepts form q r
q particular contains tra p p p simple cannot
contain occurrences concepts form q p q p q
hn
dl lite
kb k define transitive closure trat
taking


trat p ai ai p ai aij j n tra p
clearly trat computed nlogspace pair ai aj objects ob
add p ai aj trat iff p path length ob ai aj
recall directed graph reachability nlogspace complete
hn

hn

lemma dl lite
kb satisfiable iff dl lite
kb

satisfiable removing transitivity axioms
clet trat clet
proof indeed kb satisfiable construct model described
proofs lemmas take transitive closure p every p
tra p update ri p vt r p p simple contains
axioms imposing upper bounds number p successors predecessors
resulting interpretation must model converse direction trivial q
note analogue remark holds case replace clet
clet trat clet abox take transitive closure transitive subrole role
remark noted two different reasons reduction
lemma nlogspace rather logspace reduction first
order compute clet pair ai aj one path directed
graph induced role inclusion axioms second order compute trat clet one
path graph induced abox concerned
data complexity clet computed logspace fact ac shall


fithe dl lite family relations

see section role inclusion graph hence size depend
second reason however dangerous data complexity shall see
section
consequence lemma theorem obtain following
hn

corollary combined complexity satisfiability dl litebool
complete ii
hn
dl litekrom

hn
satisfiability dl litehorn kbs p complete
hn
dl litecore
kbs nlogspace complete

kbs np

iii satisfiability

note kbs contain number restrictions form q r
q extensions dl liteh
languages depend
una
remark noted role disjointness symmetry asymmetry transitivity constraints added logics dl litehf
dl litehn


core krom horn bool without changing combined complexity satisfiability corollary exptime complete indeed follows
theorem glimm et al kb satisfiability extension shiq
role conjunction exptime length role conjunctions bounded
constant case constant dis r r encoded
r u r v asym r dealt similarly conjecture role reflexivity irreflexivity constraints change complexity

instance checking data complexity
far assumed whole kb k input satisfiability according classification suggested vardi considering
combined complexity two types complexity knowledge bases
schema tbox complexity tbox regarded input
abox assumed fixed
data abox complexity abox regarded input
easy see schema complexity satisfiability logics
considered coincides corresponding combined complexity section
analyze data complexity satisfiability instance checking
hn

h
dl liten
bool dl litebool dl litebool

ac

follows without loss generality assume role concept names
given knowledge base k occur tbox write role role
dr instead role k role k dr k respectively set concept names
hn
denoted con section reduce satisfiability dl litebool kbs model
checking first order logic end fix signature containing two unary predicates
ak ak concept name ak two binary predicates pk pk role
name pk


fiartale calvanese kontchakov zakharyaschev

hn

consider first case dl litebool
kb k represent abox k
first order model aa signature domain aa ob
ai aj ob predicates ak ak pk pk signature
aa ak ai

iff

ak ai

aa pk ai aj

iff

pk ai aj

aa ak ai

iff

ak ai

aa pk ai aj

iff

pk ai aj

construct first order sentence signature depends
depend ii aa iff ke satisfiable
simplify presentation denote ext extension following
concept inclusions



q r v q r r role q q qr
q q q q q

r
q qt


q r v q r q qr
r v r inv r v inv r
v
clearly ext x equivalent first order logic x r x rrole r x
see
let bcon set basic concepts occurring e concepts form
q r con r role q qr
indicate basic concepts
hold hold domain element first order model ke use functions
bcon called types denote tp set types
bcon complex concept c define c induction
c c c u c c c propositional variable free formula



c c
c vc ext

ensures type consistent concept role inclusions
emphasized built boolean connectives therefore
depend particular domain element aa following formula true given


element x aa type see ae respectively
x




ak x ak ak x ak



ak con





eq rt x q r







rrole qqr



xy pkt x pk x

pk role

eq rt x rt x r role abbreviations defined



eq rt x yq
yi yj
rt x yi
jq

rt x


pk vt

pk x




pk vt

r





iq

pk x
r



fithe dl lite family relations

clearly r ai aj clet iff aa rt ai aj aa eq rt iff
least q distinct r successors clet thus every model k
without loss generality may assume role r rk denote
tpk set k tuples containing type dri tp role ri role
set


x x


k

tp


dr drk



x





x






dr






tp

ri role





ri

ri role





ds ri inv dri inv ri

srole

explain meaning subformulas assume satisfiable order
construct model ke first order model aa specify basic
concepts contain given constant ke words select type
dri dr ob formula says one select k tuple
types dr drk tpk one disjuncts true aa
k tuple fixes witness part model consisting dri determines
basic concepts dri belong disjunct says fixed
witness part model every ob type determining basic
concepts belongs
consistent information cf x
consistent concept role inclusions cf

dr drk consistent concept role inclusions cf dr


role ri nonempty domain e ds ri
nonempty range particular inv dri inv ri see r x defined

lemma aa iff ke satisfiable

proof fix dr drk tpk aa x x


ob fix type respective disjunct x holds aa
denote define first order model domain ob dr taking
b c iff c b c ob dr b bcon
b unary predicate b defined p easy check ke
suppose ke satisfiable model ke domain
ob dr see aa suffices take functions dri defined



fiartale calvanese kontchakov zakharyaschev

dri b iff b dri dri dr b bcon
b iff b ob b bcon
details left reader

q

follows lemmas corollary
h
corollary satisfiability instance checking dl liten
bool dl litebool
hn
dl litebool kbs ac data complexity
hn

h
proof dl liten
bool dl litebool sub languages dl litebool
hn
immediately follows lemma corollary dl litebool kb
hn

k lemma construct dl litebool
kb k

k satisfiable iff k satisfiable holds latter condition corresponds
following first order sentence





xy r x r x

x pkt x x
dis r r

irr pk

evaluated aa therefore k satisfiable iff aa let
replacing sp ref p p see
proof lemma remains observe aa iff aa
q
depend una member dl lite family
number restrictions form q r q particular dl liteh
bool
fragments
note transitive roles cannot included languages free
concerned data complexity
lemma satisfiability instance checking dl litecore kbs extended role transitivity constraints nlogspace hard data complexity
proof suppose given directed graph let p role name define abox
taking p ai aj iff edge ai aj graph node
reachable node iff dl litecore abox p satisfiable
transitive p encoding immediately gives claim lemma
directed graph reachability nlogspace complete nlogspace closed
complement see e g kozen tbox tra p depend
input
q
hand reduction lemma computable nlogspace
obtain following
hn

corollary satisfiability instance checking dl litebool
complete data complexity

kbs nlogspace

proof upper bound obtained applying nlogspace reduction lemma
corollary lower bound follows lemma
q



fithe dl lite family relations

p conp hardness data complexity
let us turn data complexity instance checking dl lite logics
arbitrary number restrictions role inclusions follows ortiz et al
shiq instance checking fact query answering dl litehn
bool
conp data complexity hustadt et al eiter et al
horn shiq imply polynomial time upper bound dl litehf
horn
upper bounds optimal following sense one
hand instance checking dl litehf
core p hard data complexity hand
hn
becomes conp hard dl litehf
krom dl litecore allow negated
concept names arbitrary number restrictionsin fact r enough note
section depend whether adopt una
theorem instance checking query answering dl litehf
krom kbs
data hard conp without una
proof proof reduction unsatisfiability cnf
known conp complete schaerf given cnf formula


n


ak ak ak ak

k

ak j one propositional variables construct kb
whose tbox depend use object names f ck k n
ai role names sf pj pj pj f j concept names

define set following assertions k n
f ck

p ck ak

p ck ak

p ck ak

p ck ak

let consist axioms
pj v
pj f v pj

pj v pj

pj v pj f

pj f


pj

v

p f u p f u p u p v

sf

v

j



j



j



j






v



sf v



sf v



note axiom belong dl litehf
krom conjunctions
left hand side however eliminated help lemma let us prove
f iff satisfiable
suppose satisfiable define assignment
truth values f propositional variables taking ai iff aii ai false


fiartale calvanese kontchakov zakharyaschev

k k n ak ak f ak ak
view j j cik pj pj f
cik pj therefore cik pj ak j cik pj f
ak j f hence cik sf f sf
f di follows f
conversely suppose satisfiable assignment
ak ak ak f ak f k n define taking



x yk k n z
aii xi
cik yk k n
f z



ai xi ai yk k n z




ai k n x x z z
pj


k k j
k j



ai k n f x x f
pj f


k j
k k j
p j
pji pj
j f


sfi z yk ak ak ak ak f


z yk k n


di z f

hard check f

q

theorem instance checking query answering dl litehn
core
kbs data hard conp without una
proof proof reduction unsatisfiability cnf
hf
main difference previous one dl litehn
core unlike dl litekrom cannot express
covering conditions turns however use number restrictions
represent constraints kind given cnf formula take abox
constructed proof theorem independent tbox describing
meaning representation terms defined way
proof except axiom replaced following set axioms
tj v tj


tj

v

pj v tj

tj

u


tj

tj v tj

v




pj v tj


tj


tj v pj

tj v tj




tj v pj f



tj tj tj tj fresh role names j j note axioms
belong dl litehn
core conjunctions left hand side


fithe dl lite family relations

easily eliminate lemma remains prove f
iff satisfiable
suppose satisfiable define assignment
truth values f propositional variables taking ai iff aii ai
false k k n ak ak f ak ak
j j cik pj cik tj tj
ci v v v ci
v v cik v tj


j
j
k
k

cik pj otherwise v v v v tj

cik tj cik pj f therefore
cik pj pj f cik pj thus cik pj
ak j cik pj f ak j f hence cik sf
f sf f di follows
f
conversely suppose satisfiable assignment
ak ak ak f ak f k n define taking




xi yk k n uk j uk j j k n z
aii xi

cik yk k n

f z

ai xi ai


ai k n j
pj
k j
k k j


ai k n f j
pj f
k j
k k j
p j
pji pj
j f


u
tj
k k j k n j


u
tj
k k j k n ak j


yk uk j k n ak j f j


u
tj
k j k n ak j f j
ti
tji tj
j


sfi z yk ak ak ak ak f


z yk k n


di z f

hard check f

q

next lower bound would follow theorem item work calvanese
et al unfortunately proof incorrect cannot repaired
theorem instance checking query answering dl litehf
core kbs
data hard p without una


fiartale calvanese kontchakov zakharyaschev

proof proof reduction entailment horn cnf known
p complete see e g borger et al exercise given horn cnf formula


n


ak ak ak



k

p


al

l

ak j al one propositional variables construct
kb whose tbox depend need object names c cn
vk j k n j variable take one object name
possible occurrence variable non unit clause role names st
pj pj j concept name
define set containing assertions
v v v v v v v v v v
vn vn vn v
pj vk j ck

iff

v

al ai

iff

ak j ai



k n j
l p

objects variable organized cycle pj vk j ck iff
variable ai occurs kth non unit clause jth position let consist
following concept role inclusions
st v



v



v st
st



v



p v
p v p
v p


p

u

p

p v



p v p



v p



v



p v p




p

v


p




p v



axiom namely belong dl litehf
core
conjunction left hand side eliminated help
lemma aim v iff ai
suppose ai consider arbitrary model define
assignment truth values f propositional variables ai iff


v
ai vk j
ai


k j k n j vk j
k j k n
j ak ak k n




cik p
p
cik p
hence vk
p


fithe dl lite family relations

st

pj pj
pj












xk j


zk j










figure model satisfying


ak ai means vk
ai v
ai ai

follows hence ai definition means v
ai

conclude v

conversely suppose ai assignment
ai f construct model v define
taking



xk j zk j k n j yk k n
cik yk k n

xk j k n j
vk j


ai xk j k n j ai



si
si si xk xk xk xk xk xk k n
im

k k k n k k n

sti
si
im
ai



pji xk j yk k n ai ak j
xk j zk j k n ai ak j j


p xk yk k n ai ak


x
pj
k j yk k n ai ak j

xk j zk j k n ai ak j j


x
p
k yk k n ai ak ai
routine check indeed v see figure
example
q



fiartale calvanese kontchakov zakharyaschev

query answering data complexity
positive existential query answering known data complete conp
case dl litehn
bool upper bound follows ortiz et al
lower bound established dl litekrom calvanese et al schaerf
case dl litehf
horn query answering data complete p follows
hustadt et al eiter et al horn shiq

dl liteh
horn ac calvanese et al
fact conp upper bound holds extension dl litehn
bool role disjointness symmetry constraints follows glimm et al theorem
cf remark conjecture holds role ir reflexivity constraints
main section following
theorem positive existential query answering logics dl liten
horn
hn
h

dl litehorn dl litehorn ac data complexity
hn

proof suppose given consistent dl litehorn kb k
concept role names occurring tbox positive existential query prenex
hn
form q x x signature k consider dl litehorn kb k
hn

provided lemma language dl litehorn

defined section

lemma every tuple object names k k q iff q
untangled k
proof suppose k q untangled model k lemma
view consistency k ensures holds k
therefore q
suppose k lemma model k domain

coincides symbols k q must q
k q required
q
next ke horn sentence enough consider one special
model k formulation lemma let minimal herbrand model
universal horn sentence ke remind reader details consult e g apt
rautenberg constructed taking intersection herbrand
ke domain consists constant symbols
ke e ob dr cf remark following
b c

iff

ke b c

b bcon c

let untangled model k induced denote domain
property copy remark provides us function cp
two consequences lemma first
aii b

iff

k b ai

b bcon ai ob





fithe dl lite family relations

second every r role ri ri k indeed
ri r dr therefore r v satisfiable thus
ri k moreover ri
w b

iff

k r v b

b bcon w cp w dr

lemma q q untangled k
proof suppose k q positive existential sentence enough construct
homomorphism h remind reader forest domain
partitioned disjoint trees ta ob define depth point w
length shortest path respective tree root denote wm
set points depth particular w ai ob construct h
union maps hm hm defined wm following properties
hm w hm w w wm
every w wm w b hm w b b bcon
bm u v wm u v ri hm u hm v ri r role
basis induction set h aii aii ai ob property follows
b abox remark
induction step suppose hm already defined wm set
hm w hm w w wm consider arbitrary v wm wm forest
unique u wm u v ea ta let u v
copy cp v inv ds role u hm u
means w hm u w set hm v w cp v inv ds
inv follows v b w b whenever
w inv w inv obtain v bm notice
role w v ri w wm two cases
w wm wm w v id vt r w wm w u vt r
former case hm v hm v ri idi identity relation role
latter case u v hence hm u hm v vt r
hm u hm v ri
q
assume query q x x yk
quantifier free formula next lemma shows case check whether q
suffices consider points depth
depend
lemma let k role assignment
wm e yi wm
proof suppose assignment yi
k yi
wm let minimal subset contains yi
every p p subformula
role name p let yj role yj wm


fiartale calvanese kontchakov zakharyaschev


wm convenience w clearly exists
yi
wm k variables forest relations p connect point
wn wn point wn wn n let w yj point
ta w wm wm cp w dr r role
role distinct labels labeled tree ta view copy point u
depth role point u depth role ta
cp u cp u iso trees generated u u isomorphic
isomorphism g labeled tree generated w contains
onto labeled tree generated point depth role ta define
assignment ay taking ay g ay otherwise copy
concept role ay ay wm
ay yj
wm j repeat described construction k iterations
shall obtain assignment required lemma
q
complete proof theorem encode k q model
checking first order formulas precisely way section
fix signature contains unary predicates concept name binary
predicates p p role name p represent abox k first order
model aa domain ob define first order formula q x
signature q x depends q ii aa q
iff q
begin defining formulas b x b bcon describe types
elements ob model following sense see
aa b ai

iff aii b

b bcon ai ob



x x formulas
formulas defined fixed points sequences b
b
one free variable

x
b

b x

eq r x b q r






b
x b
x
b
x b
x

k
b uubk vbext

eq rt x given section simplify presentation use ext instead clear b bcon
x x e every x equivalent x first order logic
b
b
b
b
x j x every b bcon j minimum
b
b
n x
exceed n bcon set b x b
next introduce sentences b dr b bcon dr dr describe
types elements dr following sense see
aa b dr

iff

w b b bcon w cp w dr



concept definition correct sentences defined similarly b x
namely b bcon dr dr inductively define sequence


fithe dl lite family relations



b dr
b dr
taking

b dr
b dr




b dr
ib dr






b







dr
b
dr

k

b uubk vbext

ib dr whenever b r
r dr x inv r x



ir dr




inv r ds




dsdr


clear role n b dr
b dr
b bcon
role n

dr dr set b dr b dr

consider directed graph gt vt et vt set equivalence
classes r r r r r r empty model et
set pairs ri rj
path inv ri v q rj



inv ri vt rj q

rj proper sub role satisfying path ri rj et iff
abox whenever minimal untangled model contains copy w inv dri
ri ri w connected copy inv drj rj rj relations
rj vt
recall given query q x x quantifier free
positive formula yk let set paths graph gt
length precisely


r r rn n rj rj et j n
r

role r role write one following three
conditions satisfied id vt r ii iii inv
role vt r
let kt set k tuples form k intuitively
evaluating query x bound non distinguished variable yi
mapped point w wm however first order model aa contain
points wm w represent use following trick forest
every point w wm uniquely determined pair ai root
tree ta containing w sequence labels u v path ai w
follows unraveling procedure path formula
q define assume yi range w represent first
component pairs whereas second component encoded ith member
yi confused yi original query q range
wm order treat arbitrary terms occurring x uniform way
set ob xi yi distinguished variables xi
object names mapped w require second component
pairs
given assignment wm denote split pair
assignment aa k kt


fiartale calvanese kontchakov zakharyaschev

distinguished variable xi xi ai xi
bound variable yi yi r rn n ai
root tree containing yi r rn sequence
labels u v path ai yi
every pair however corresponds assignment wm paths
may exist gt represents possible paths fixed
tbox varying abox follows unraveling procedure point wm w
corresponds ob r iff enough r witnesses

r
e iff aa q

r q r q qt thus every
k assignment wm split iff aa





q
k yk
ri yi q ri yi
r

ik


qqt

ri k ri
define every kt concept name role name r




inv ds






r
r
r





otherwise
rt given claim every assignment wm
split


iff

aa

r

iff

aa r

concept names terms
roles r terms




xi yi claim follows yi
copy cp yi inv dr r claim follows
r yi yi claim follows abox let us consider case
r yi yi yi
w thus role r yi yi iff
yi yi tree ta ob e aa yi yi
yi yi ea yi yi vt r
yi yi ea yi yi inv vt r
r

yi yi id vt r e
cases similar left reader
finally let x attaching superscript atom


q x
x

kt





fithe dl lite family relations

follows every assignment wm x iff
aa x split converse direction notice aa
assignment wm split
clearly aa q iff q every tuple note every
pair tuples b object names ob b positive existential sentence
inequalities domain independent easily seen b
b domain independent follows minimality q domainindependent tuple object names ob

finally note resulting query contains role k k role disjuncts q

dl lite without unique name assumption
section unless otherwise stated assume interpretations respect
una may aii aij distinct object names ai aj consequence
relation nouna refers class interpretations
description logics without una usually extended additional equality
inequality constraints form
ai aj



ai aj

ai aj object names semantics quite obvious ai aj iff
aii aij ai aj iff aii aij equality inequality constraints supposed
belong abox part knowledge base noted however reasoning
equalities logspace reducible reasoning without
lemma every kb k one construct logspace size
kb k without equality constraints k iff k every
interpretation
proof let g v e undirected graph


v ob
e ai aj ai aj aj ai
ai set vertices g reachable ai define removing
equality constraints replacing every ai aj ai minimal j note
minimal j computed logspace enumerate object names aj
respect order indexes j check whether current aj reachable
ai g remains recall reachability undirected graphs slogspace complete
slogspace logspace reingold
q
mentioned section logics form dl liteh
feel whether
adopt una observation lemmas hand
obtain following consequence theorem
query q
x said domain independent case aa q
x iff q
x
domain contains ob active domain aa aa aaa p p aa concept
role names p



fiartale calvanese kontchakov zakharyaschev

theorem without una combined complexity satisfiability
h
dl liteh
bool kbs np complete ii satisfiability dl litehorn kbs p complete
h
iii satisfiability dl liteh
krom dl litecore kbs nlogspace complete hold even kbs contain role disjointness symmetry ir reflexivity transitivity constraints equalities inequalities
hand corollary lemmas derive
following
theorem without una satisfiability instance checking dl liteh
bool kbs


ac data complexity ac kbs contain role
disjointness symmetry ir reflexivity constraints inequalities however
logspace complete kbs may contain equalities nlogspace complete
role transitivity constraints allowed
note complexity corollary theorems
logics dl litehf
dl litehn
depend una


section analyze combined data complexity reasoning logics
hf
hn
form dl lite
dl lite
well fragments without una
obtained known summarized table page
hn

dl lite

arbitrary number restrictions

following theorem shows interaction number restrictions
possibility identifying objects abox higher complexity
theorem without una satisfiability dl liten
core kbs even without equality
inequality constraints np hard combined data complexity
proof proof reduction following variant sat problemcalled monotone one three sat known np complete garey johnson
given positive cnf formula


n



ak ak ak

k

ak j one propositional variables decide whether
assignment variables aj exactly one variable true clauses
k
encode language dl liten
core need object names ai
k n ck tk k n role names p concept
names let abox containing following assertions
ani ani



tn tn tn
p ck tk

k n

p ck akk j aj akk j

k n j



fithe dl lite family relations

let tbox following axioms
v

v

v

v

p v

clearly dl liten
core kb depend cover
combined data complexity claim answer monotone one three
sat positive iff satisfiable without una
suppose define assignment truth values f
propositional variables taking ai iff aim
ak j exactly one j k k n j
cik akk j p moreover akk akk j j cik p
cik tk p must akk j tk unique j follows
functionality k n k j exactly one
j
let assignment satisfying monotone one three sat take
ai ai clearly exists otherwise f construct
interpretation taking



yk z k k n xki ai f k n
cik yk tk z k k n

xki ai f
aki
k n
z k ai


ani ani


p cik tk cik akk cik akk cik akk k n
readily checked

q

fact lower bound optimal
hn

hn

theorem without una satisfiability dl liten
dl lite
dl lite
kbs equality inequality constraints np complete combined data
complexity core krom horn bool
proof lower bound immediate theorem matching upper bound
hn
proved following non deterministic given dl litebool
kb
k
guess equivalence relation ob

select equivalence class ai representative say ai replace every occurrence ai ai
fail equalities inequalities violated resulting aboxi e
contains ai ai ai aj j


fiartale calvanese kontchakov zakharyaschev

otherwise remove equality inequality constraints abox denote

hn

use np satisfiability checking dl litebool
kb k consistent una

decide whether

clearly returns yes k respecting una
construct model k necessarily respecting una extending

following interpretation object names ai aii whenever ai representative
coincides symbols conversely k take
equivalence relation defined ai aj iff aii aij let constructed
removing interpretations object names representatives
equivalence classes follows respects una k
returns yes
q
hf

dl lite

functionality constraints
hf

let us consider dl litebool
fragments following lemma shows
logics reasoning without una reduced polynomial time size
abox reasoning una
hf

lemma every dl litebool

kb k equality inequality con hf

straints one construct polynomial time dl litebool
kb k
contains equalities inequalities k satisfiable without una iff k
satisfiable una
proof follows identifying aj ak mean replacing occurrence
ak aj construct first identifying aj ak aj ak
removing equality exhaustively applying following procedure

r v r ai aj r ai ak clet distinct aj ak
identify aj ak recall functional r cannot transitive sub roles
thus clet enough
resulting abox contains ai ai ai clearly k satisfiable
add ai ai abox concept name finally remove
inequalities abox denote clear
computed polynomial time without una k satisfiable iff k
satisfiable suffices k satisfiable without una iff satisfiable
una implication trivial
observe procedure ensures
e
qr


r v r vt ob
hn

see page definitions let k dl litebool
kb provided lemma
k follows property proofs lemma corollary


fithe dl lite family relations

k satisfiable without una k e satisfied first order model
constants interpreted domain element k e universal
first order sentence containing equality satisfiable first order model
constants interpreted distinct elements follows proofs lemma
corollary first order model unraveled model j k
respecting una lemma j model k
q
reduction cannot done better p shown next theorem
theorem without una satisfiability dl litef
core kbs even without equality
inequality constraints p hard combined data complexity
proof proof reduction entailment horn cnf proof
theorem let


n


ak ak ak



p




al

l

k

horn cnf formula ak j al one propositional variables
ak ak ak distinct k k n encode pk
complete ai language dl litef
core need object names ai
k n fk gk k n role names p q
abox contains following assertions

ani ani




p akk fk p akk gk q gk akk q fk akk
l

k n

l p

tbox asserts roles functional
p v

q v

v



v

clearly k dl litef
core kb depend claim
aj iff j satisfiable without una suffices
prove aj iff k nouna j
suppose aj derive aj following inference rules
al l l p
ak ak k k n ak
k nouna j induction length derivation aj
basis induction trivial assume aj ak ak ak k
k n k nouna k k suppose k since


functional k k since functional akk akk k
k n particular k k since p functional fki gki


functionality q akk akk finally since functional akk akk


fiartale calvanese kontchakov zakharyaschev

k k n particular k thus j therefore
k nouna j
suppose aj assignment
aj f construct interpretation taking



xki ai f k n z k uk vk k n w

xki ai f
aki
k n
z k ai


ti w w z



ani ani


vk ak f
fki uk gki
k n
uk ak


p akk fki akk gki k n


qi gki akk fki akk k n
readily checked k j k nouna j

q

strengthens nlogspace lower bound instance checking
dl litef
core proved calvanese et al
hf

hf

corollary without una satisfiability dl litef
dl lite
dl lite
kbs core krom horn equalities inequalities p complete combined data complexity
hf
hf
without una satisfiability dl litef
kbs
bool dl litebool dl litebool
equalities inequalities np complete combined complexity p complete data
complexity

proof upper bounds follow lemma corresponding upper bounds
una case np lower bound combined complexity obvious polynomial
lower bounds follow theorem
q
query answering data complexity
p conp upper bounds query answering without una follow horn shiq hustadt et al eiter et al shiq ortiz et al
glimm et al respectively see discussion beginning section
present following
theorem without una positive existential query answering dl liteh
horn kbs
role disjointness symmetry ir reflexivity constraints inequalities ac
data complexity logspace complete additionally equalities
allowed kbs


fithe dl lite family relations

proof proof follows lines proof theorem uses observation
without una give answers untangled counterparts
precisely let kb k suppose consistent let q x
positive existential query signature k given k lemma provides
us kb k easy see k dl liteh
horn kb extended inequality
constraints following analogue lemma allows us get rid
inequalities
lemma every tuple object names k k nouna q iff q
untangled k respecting una
proof suppose k nouna q untangled model k respects
una lemma view satisfiability k ensures holds
k therefore q
suppose k construct interpretation j respecting una follows




let j disjoint union ob define function h j taking


h ai ob h w w w let







aj
aj u h u ai

p j u v h x h v p
object concept role name p clearly j respects una j k
follows h homomorphism
lemma model k domain j coincides
j symbols k q must j q since h
homomorphism q therefore k nouna q required
q
remaining part proof exactly theorem since may assume
k dl liteh
horn kb containing inequality constraints
logspace completeness case equalities follows lemma
q

conclusion
article investigated boundaries extended dl lite family description
logics providing thorough comprehensive understanding interaction
dl lite constructs impact computational complexity reasoning
studied different logics classified according five mutually orthogonal features
presence absence role inclusion assertions form allowed concept
inclusion assertions distinguishing four main logical groups called core krom horn
bool form allowed numeric constraints ranging none global functionality constraints arbitrary number restrictions presence absence
unique name assumption equalities inequalities object names
assumption dropped presence absence standard role constraints
role disjointness role symmetry asymmetry reflexivity irreflexivity transitivity resulting logics studied combined data complexity kb
satisfiability instance checking well data complexity answering positive
existential queries


fiartale calvanese kontchakov zakharyaschev

query answering
instance checking

conp
query answering


legend
satisfiability
combined complexity

without una
role inclusions

f

n

exptime
np
p
nlogspace

una
role inclusions

f

una
role inclusions

conp
p
ac

oo
l

n

instance checking
data complexity

b

ro

k

co

h


n





f

n

figure complexity basic dl lite logics
obtained tight complexity illustrated figure combined
complexity satisfiability represented height vertical dashed lines
data complexity instance checking size color circle top lines
recall satisfiability instance checking reducible complement
data complexity query answering core horn logics shown
left hand side separating vertical plane coincides data complexity
instance checking krom bool logics shown right hand side plane
query answering data complete conp upper layer shows complexity
logics role inclusions case depend whether adopt
una middle lower layers deal logics without role inclusions
una dropped adopted respectively layers twelve
languages arranged grid one axis shows type concepts inclusions
allowed horn core krom bool type number restrictions none
global functionality f arbitrary n observations order
una without role inclusions number restrictions increase
complexity reasoning depends form concept inclusions allowed
hand without form number restrictions logics role
inclusions insensitive una complexity determined
shape concept inclusions
cases instance checking ac data complexity
means first order rewritable



fithe dl lite family relations

without una adopted without disjunctions role inclusions functionality
leads p completeness instance checking data complexity suggests
reducibility datalog
data complexity difference core horn logics
krom bool ones means core krom logics
extended conjunctions left hand side concept inclusions free
hf

hn

finally logics dl lite
dl lite
qualified number restrictions role inclusions whose interaction restricted conditions
complexity reasoning coincides complexity fragments dl litef

respectively dl liten
without role inclusions matter whether adopt una

role disjointness symmetry asymmetry constraints added
hn
hf
languages without changing complexity fact dl lite
dl lite
logics contain types constraints together role reflexivity irreflexivity conjecture ir reflexivity constraints added logics without
affecting complexity however extend dl lite logic role transitivity
constraints combined complexity satisfiability remains instance
checking query answering become data hard nlogspace addition
equality object nameswhich makes sense una droppedleads
increase membership ac logspace completeness data complexity
remain unchanged
list dl constructs considered far complete
example would interest analyze impact nominals role chains boolean
operators roles computational behavior dl lite logics another interesting
practically important investigate depth interaction
constructs aim pushing restrictions far possible
one main ideas behind dl lite logics provide efficient access large
amounts data high level conceptual interface supposed achieved
representing high level view information managed system dl lite
tbox data stored relational database abox rewriting positive existential queries knowledge base standard first order queries
database represented believed viable number
dl lite logics query answering ac data complexity cf theorems figure first order rewriting technique implemented
system notably quonto acciarri et al poggi et al b
query relying ontology relational mappings data stored standard relational
database management system owlgres stocker smith access
abox stored postgres database though best knowledge latter
implementation incomplete conjunctive query answering noted however
size rewritten query substantially larger size original
query cause even efficient database query engine
positive existential query q tbox two major sources high
complexity first order formula q proof theorem formulas
b x computing whether abox object instance concept b formulas


fiartale calvanese kontchakov zakharyaschev

r dr computing whether objects outgoing r arrows instances b ii
hn
disjunction paths graph gt case dl litecore size
hn
b x linear dl litehorn become exponential however
optimizations possible size disjunction ii exponential number
non distinguished variables q one way removing source would extend
given database abox precomputing horn closure abox respect
tbox storing resulting data supplementary database
advocated lutz et al querying databases via description logic el
could promising horn fragments expressive description logics
shiq hustadt et al hustadt motik sattler containing dl litehf
horn
sub languagefor data complexity instance checking hustadt et al
conjunctive query answering polynomial eiter et al disadvantage
supplementary database necessity update every time abox
changed would interesting investigate alternative dl lite logics
compare described another important
characterize queries disjunction ii represented formula
polynomial size
unique name assumption replaced owl constructs sameas
differentfrom e challenging investigate possible ways
dealing equality inequality require special treatment shown
proof lemma although reasoning equality logspace reducible reasoning without cf lemma lose property first order rewritability
computing equivalence classes may costly real world applications
dl lite logics among examples dls usually complex
non standard reasoning problemssuch checking whether one ontology conservative
extension another one respect given signature kontchakov et al
computing minimal modules ontologies respect kontchakov et al
uniform interpolants wang wang topor pan supported practical
reasoning tools however first steps made direction
needed order include reasoning tools standard
owl toolkit would interesting investigate unification dl lite
logics baader narendran
finally exist certain parallels horn logics dl lite family el
horn shiq first order language tuple equality generating dependencies
tgds egds used theory databases see e g gottlob nash
investigations relationships logics may lead deeper understanding
role description logics play database framework
acknowledgments
partially supported fet project tones thinking ontologies funded within eu th framework programme contract fp
large scale integrating project ip ontorule ontologies meet business rules
ontologies funded ec ict call fp ict contract number fp thank referees constructive criticism comments suggestions



fithe dl lite family relations

references
abiteboul hull r vianu v foundations databases addison wesley
acciarri calvanese de giacomo g lembo lenzerini palmieri
rosati r quonto querying ontologies proc th nat conf
artificial intelligence aaai pp
apt k logic programming van leeuwen j ed handbook theoretical
computer science b formal sematics pp elsevier
mit press
artale calvanese kontchakov r zakharyaschev dl lite
light first order logic proc nd nat conf artificial intelligence
aaai pp
artale calvanese kontchakov r ryzhikov v zakharyaschev b
reasoning extended er proc th int conf conceptual
modeling er vol lecture notes computer science pp
springer
artale cesarini f soda g describing database objects concept
language environment ieee trans knowledge data engineering

artale parent c spaccapietra evolving objects temporal information
systems ann mathematics artificial intelligence
baader f narendran p unification concepts terms description logics j
symbolic computation
baader f calvanese mcguinness nardi patel schneider p f eds
description logic handbook theory implementation applications
cambridge university press nd edition
beeri c levy rousset c rewriting queries views description
logics proc th acm sigact sigmod sigart symp principles
database systems pods pp
berardi calvanese de giacomo g reasoning uml class diagrams
artificial intelligence
bergamaschi sartori c taxonomic reasoning conceptual design acm
trans database systems
boppana r sipser complexity finite functions van leeuwen j
ed handbook theoretical computer science complexity pp elsevier mit press
borger e gradel e gurevich classical decision perspectives
mathematical logic springer
borgida brachman r j conceptual modeling description logics
baader et al baader et al chap pp



fiartale calvanese kontchakov zakharyaschev

calvanese de giacomo g lembo lenzerini poggi rosati r
ontology database access proc th ital conf database systems
sebd pp
calvanese de giacomo g lembo lenzerini poggi rosati r ruzzi
data integration dl lite ontologies schewe k thalheim
b eds revised selected papers rd int workshop semantics data
knowledge bases sdkb vol lecture notes computer science pp
springer
calvanese de giacomo g lembo lenzerini rosati r dl lite
tractable description logics ontologies proc th nat conf artificial
intelligence aaai pp
calvanese de giacomo g lembo lenzerini rosati r data
complexity query answering description logics proc th int conf
principles knowledge representation reasoning kr pp
calvanese de giacomo g lembo lenzerini rosati r owl
model football leagues proc rd int workshop owl experiences
directions owled vol ceur workshop proceedings
calvanese de giacomo g lembo lenzerini rosati r b tractable
reasoning efficient query answering description logics dl lite family j
automated reasoning
calvanese de giacomo g lembo lenzerini rosati r inconsistency tolerance p p data integration epistemic logic information
systems
calvanese de giacomo g lembo lenzerini rosati r b path
identification constraints description logics proc th int conf
principles knowledge representation reasoning kr pp
calvanese de giacomo g lenzerini description logics information
integration kakas sadri f eds computational logic logic programming beyond essays honour robert kowalski vol lecture notes
computer science pp springer
calvanese de giacomo g lenzerini b framework ontology integration cruz decker euzenat j mcguinness eds emerging
semantic web selected papers first semantic web working symposium
pp ios press
calvanese de giacomo g lenzerini nardi rosati r description
logic framework information integration proc th int conf
principles knowledge representation reasoning kr pp
calvanese lenzerini nardi b description logics conceptual data
modeling chomicki j saake g eds logics databases information
systems pp kluwer academic publishers
calvanese lenzerini nardi unifying class representation formalisms j artificial intelligence


fithe dl lite family relations

corona c ruzzi savo f filling gap owl ql
quonto rowlkit proc nd int workshop description logics
dl vol ceur workshop proceedings
cuenca grau b horrocks kazakov sattler u modular reuse ontologies theory practice j artificial intelligence
decker erdmann fensel studer r ontobroker ontology
access distributed semi structured information meersman r tari z
stevens eds database semantic semantic issues multimedia systems
chap pp kluwer academic publishers
dolby j fokoue kalyanpur l schonberg e srinivas k sun x
scalable grounded conjunctive query evaluation large expressive knowledge
bases proc th int semantic web conf iswc vol lecture
notes computer science pp springer
eiter gottlob g ortiz simkus query answering description logic horn shiq proc th eur conference logics artificial
intelligence jelia pp
franconi e ng g com tool intelligent conceptual modeling proc
th int workshop knowledge representation meets databases krdb
vol ceur workshop proceedings pp
garey johnson computers intractability guide theory
np completeness w h freeman
ghilardi lutz c wolter f damage ontology case conservative extensions description logics doherty p mylopoulos j welty
c eds proc th int conf principles knowledge representation
reasoning kr pp
glimm b horrocks lutz c sattler u conjunctive query answering
description logic shiq proc th int joint conf artificial intelligence
ijcai pp
goasdoue f lattes v rousset c use carin language
information integration picsel system int j cooperative
information systems
gottlob g nash efficient core computation data exchange j
acm
hayes p rdf semantics w c recommendation http www w org tr
rdf mt
heflin j hendler j portrait semantic web action ieee intelligent
systems
heymans l anicic z steinmetz n pan mei j fokoue
kalyanpur kershenbaum schonberg e srinivas k feier c hench g
wetzstein b keller u ontology reasoning large data repositories
hepp de leenheer p de moor sure eds ontology management


fiartale calvanese kontchakov zakharyaschev

semantic web semantic web services business applications vol semantic
web beyond computing human experience pp springer
horrocks patel schneider p f van harmelen f shiq rdf
owl making web ontology language j web semantics
horrocks sattler u tobies practical reasoning expressive description logics j interest group pure applied logic
hustadt u motik b sattler u reasoning description logics reduction
disjunctive datalog j automated reasoning
hustadt u motik b sattler u data complexity reasoning expressive
description logics proc th int joint conf artificial intelligence
ijcai pp
immerman n descriptive complexity springer
klyne g carroll j j resource description framework rdf concepts
abstract syntax w c recommendation http www w org tr rdf concepts
kontchakov r pulina l sattler u schneider selmer p wolter f zakharyaschev minimal module extraction dl lite ontologies
qbf solvers proc st int joint conf artificial intelligence ijcai pp
kontchakov r wolter f zakharyaschev tell difference
dl lite ontologies proc th int conf principles
knowledge representation reasoning kr pp
kontchakov r zakharyaschev dl lite role inclusions domingue j
anutariya c eds proc rd asian semantic web conf aswc
vol lecture notes computer science pp springer
kozen theory computation springer
lenzerini data integration theoretical perspective proc st acm
sigact sigmod sigart symp principles database systems pods
pp
levy rousset c combining horn rules description logics
carin artificial intelligence
lutz c toman wolter f conjunctive query answering el
database system proc th int workshop owl experiences directions owled
mcguinness wright j r conceptual modelling configuration description logic artificial intelligence engineering design analysis
manufacturing special issue configuration
meyer lee k booth r knowledge integration description logics
proc th nat conf artificial intelligence aaai pp
noy n f semantic integration survey ontology approaches sigmod
record


fithe dl lite family relations

ortiz calvanese eiter characterizing data complexity conjunctive
query answering expressive description logics proc st nat conf
artificial intelligence aaai pp
ortiz calvanese eiter data complexity query answering expressive description logics via tableaux j automated reasoning
papadimitriou c computational complexity addison wesley
perez urbina h motik b horrocks comparison query rewriting
techniques dl lite proc nd int workshop description logics
dl vol ceur workshop proceedings
poggi lembo calvanese de giacomo g lenzerini rosati r
linking data ontologies j data semantics x
poggi rodriguez ruzzi b ontology database access
dig mastro obda plugin protege clark k patel schneider
p f eds proc th int workshop owl experiences directions
owled dc
rautenberg w concise introduction mathematical logic springer
reingold undirected connectivity log space j acm
schaerf complexity instance checking concept languages
existential quantification j intelligent information systems
schmidt schau smolka g attributive concept descriptions complements artificial intelligence
stocker smith owlgres scalable owl reasoner proc th
int workshop owl experiences directions owled
tobies complexity practical logics knowledge representation ph thesis lufg theoretical computer science rwth aachen germany
toman weddell g e interaction inverse features pathfunctional dependencies description logics proc th int joint conf
artificial intelligence ijcai pp
toman weddell g e keys functional dependencies first class
citizens description logics j automated reasoning
vardi complexity relational query languages extended abstract
proc th acm sigact symp theory computing stoc pp

vollmer h introduction circuit complexity uniform springer
wang z wang k topor r w pan j z forgetting concepts dl lite
bechhofer hauswirth hoffmann j koubarakis eds proc
th eur semantic web conf eswc vol lecture notes computer
science pp springer




