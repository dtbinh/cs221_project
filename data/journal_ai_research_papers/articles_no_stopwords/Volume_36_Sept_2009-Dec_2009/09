journal artificial intelligence

submitted published

friends foes satisfiability
abstract cnf encodings
carmel domshlak

dcarmel ie technion ac il

technion israel institute technology
haifa israel

jorg hoffmann

joerg hoffmann inria fr

inria
nancy france

ashish sabharwal

sabhar cs cornell edu

cornell university
ithaca ny usa

abstract
satisfiability implemented instance satplan tool
highly competitive method finding parallel step optimal plans bottleneck
prove absence plans certain length specifically optimal plan
n steps typically costly prove plan length n
pursue idea leading proof within solution length preserving abstractions overapproximations original task promising abstraction
may much smaller state space related methods highly successful model
checking particular design novel abstraction technique one
several widely used benchmarks construct abstractions exponentially
smaller state spaces preserving length optimal plan
surprisingly idea turns appear quite hopeless context
satisfiability evaluating idea empirically run experiments almost benchmarks
international competitions ipc even hand made
abstractions tend improve performance satplan exploring findings
theoretical point view identify interesting phenomenon may cause
behavior compare graph cnf encodings original
task cnf encodings abstracted task prove
many cases shortest resolution refutation never shorter
suggests fundamental weakness motivates investigation
interplay declarative transition systems approximating abstractions
sat encodings

introduction
areas model checking ai well known closely related
develop tools automatic behavior analysis large scale declaratively specified transition systems particular model checking safety
propertieschecking reachability non temporal formulasproblems given description transition system initial system state target condition
solution corresponds legal path transitions bringing system
initial state state satisfying target condition
c

ai access foundation rights reserved

fidomshlak hoffmann sabharwal

model checking solution corresponds error path system
unwanted system behavior proving absence error paths ultimate
goal system verification thus traditional focus field exactly
besides clever symbolic representations state space key technique accomplish
ambitious task abstraction system abstraction corresponds approximation
considered transition system thus abstraction preserves transitions
original system hence abstract transition system contain solution
neither original system key success model checking many cases
one prove absence solutions rather coarse abstractions comparatively
small state space techniques kind explored depth long time
arguably wide spread instance model checking predicate abstraction graf
sadi system states form equivalence classes defined terms truth
values number expressions predicates linear expressions integer
system variables predicates learned analyzing spurious error paths coarse
abstractions clarke grumberg jha lu veith methods kind
extremely successful verification temporal safety properties e g ball majumdar
millstein rajamani chaki clarke groce jha veith henzinger jhala
majumdar mcmillan
contrast system verification focus ai finding solutions
instances assumed solvable particular optimizing task
solution optimizes certain criterion focus analysis
sequential parallel length solution path unlike general
solution good enough main bottleneck length optimizing
prove absence solutions certain length particular optimal plan
n steps hardest bit typically prove plan length n
note plan actually proved optimal length optimizing
planner avoid constructing proof matter computational techniques

agenda apply idea model checking lengthoptimizing lead optimality proofnon existence plan length n
within abstraction particular focus interplay abstraction
proving optimality parallel step optimal satisfiability
originally proposed kautz selman later developed satplan tool
kautz selman kautz kautz selman hoffmann satplan
performs iteration satisfiability tests cnf formulas b encoding existence
parallel plan length b b starts increased incrementally
n first satisfiable formula n equals length optimal parallel plan
hence satplan parallel optimal step optimal planner class planners
satplan highly competitive particular satplan st prizes optimal
planners international competition ipc namely ipc kautz
hoffmann edelkamp ipc kautz et al one property
cnf encodings employed satplan plays key role analysis later
graph structure blum furst
course objective closely relates many approaches developed
computing lower bounds approximations e g haslum geffner


fifriends foes satisfiability abstract cnf encodings

edelkamp haslum botea helmert bonet koenig helmert haslum
hoffmann katz domshlak bonet geffner key difference
however focus exact lower bounds attempt actually prove optimality
within abstraction want able prove optimality within abstraction
abstraction must term solution length preserving abstraction must
introduce solutions shorter optimal solution original
lower bound step optimal exact support
satplans iteration n constitutes main bottleneck
follows briefly explain initial motivation behind work
summarize empirical theoretical
initial motivation
would course interesting explore whether predicate abstraction applied
indeed initial idea however discussions
idea lead nowhere instead made different discovery state spaces
often dramatically reduced without introducing shorter solutions
abstraction technique call variable domain abstraction technique essentially
adapts work hernadvolgyi holte propositional strips formalism
abstract strips task distinguishing certain values multiplevalued variables underlying strips encoding p q propositions
corresponding non distinguished values abstracted strips task acts p q
note generalizes abstraction used edelkamp
multi valued variable abstracts away completely abstract
see details section
first example noticed compression power variable domain abstraction classical logistics domain domain packages must transported within
cities trucks cities airplanes actions load unload packages
move vehicles importantly constraints vehicle capacities fuel
travel links consequence package p starts city destination
city b cities c b completely irrelevant p one choose
arbitrary location x city c replace facts form p l l
location outside b p x p truck outside b
replaced p x one completely abstract away positions packages
destination minor optimizations possible way
lose many distinctions different positions objectswithout introducing shorter
solution optimal plan rely storing package p city ps origin
destination state space reduction dramatic abstracted state space contains
least c p states less c p respectively number
cities city size number locations city number packages similar
still skeptical prospects software artifacts rigid control structure numeric expressions
essential flow control rather different nature loose control
structure numeric expressions non existent mostly used encode resource consumption example major advantage predicate abstraction capture loop invariantsa great feature
seemingly rather irrelevant plan generation



fidomshlak hoffmann sabharwal

abstractions made similar state space reductions obtained ipc
domains zenotravel blocksworld depots satellite rovers see section
summary empirical
first experiment implemented logistics specific abstraction abstracting set tasks level description modifying actions
initial state tasks feature airplanes locations city
packages number cities scales account variance
hardness individual instances took average values random instances
size increasing number cities introduces increasing amount
irrelevance measure percentage relfrac facts considered relevant
abstracted note additional cities irrelevant individual packagesthey cant removed completely task standard irrelevance
detection mechanisms e g rifo nebel dimopoulos koehler would try
provided abstracted tasks three optimizing planners namely mips bdd
edelkamp helmert ipp hoffmann nebel satplan order examine abstraction affects different approaches optimizing
mips bdd searches blindly exploiting sophisticated symbolic representation
state space ipp equivalent parallel state space heuristic search widely
used h heuristicthe parallel version h originally introduced graphplan blum
furst haslum geffner thus mips bdd ipp satplan represent
orthogonal approaches optimizing abstract task planner
measured runtime compared latter time taken planner
original task time set seconds used value
average computation time occurred stopped evaluating planner
time outs within instances one size
figure b c respectively mips bdd ipp satplan comparing performance original abstracted tasks apparent
figure proving optimality within abstraction dramatically improved
performance mips bdd significantly improved performance ipp right
end scale cities mips bdd abstraction optimal sequential
plans almost fast satplan step optimal plans given usually
much harder optimal sequential plans optimal parallel plans especially highly
parallel domains logistics performance improvement quite remarkable
addition reduced state space size mips bdd benefits small state encoding
stops growing point maximal number locations relevant
package constant
findings mips bdd ipp line original intuition
satplan well expected see much improved runtime behavior within
abstraction surprise appears figure c improvement
obtained satplan proving optimality within abstraction hardly dis satplan version satplan competed international competition
importantly mips bdd sequentially optimal satplan ipp step optimal hence
one compare performance planners directly particular
purpose focus planners reacts abstraction



fifriends foes satisfiability abstract cnf encodings





mips bdd abstract
mips bdd real
relfrac









ipp abstract
ipp real
relfrac













































































































b




satplan abstract
satplan real
relfrac






















































c

figure runtime performance mips b ipp c satplan abstract without real hand made variable domain abstraction
logistics instances explicitly scaled increase amount irrelevance horizontal axis scales number cities left vertical axis shows total runtime
seconds right vertical axis shows percentage relfrac relevant facts

cernible right end scale abstraction yields humble speed factor
particularly insignificant since speed obtained drastically small
relfrac value ipc logistics benchmarks relfrac average
latter corresponds cities figure satplan slight advantage
original tasks
investigate broadly conducted experiments almost strips
domains used international competitions ipc ipc many
cases tailored abstraction domain hand exhaustive
evaluation discussed detail section significantly depart
logistics specific abstraction mips bdd almost consistently obtained
significant improvement ipp improvements happened rarely typically
substantial ipp improved figure note ipc

fidomshlak hoffmann sabharwal

average relfrac improvement yet strong finally satplan
hardly ever obtained improvement
causes difference profiting abstraction three different
techniques intuitive interpretation informedness
abstraction must compete informedness search words
better planner exploiting structure particular example difficult
abstraction exploit structure already exploited intuition
good correspondence logistics figure optimizing exactly
measure original examples satplan faster ipp inverse
relation holds regarding planner profits abstraction said
intuitive interpretations point mere speculation left open
future determine accurately precisely causes difference herein
concentrate satisfiability identify fundamental weakness
respect profiting abstraction
summary theoretical
intrigued satplan wondered kind effect abstraction
actually cnf encoding task formulated boolean satisfiability
instance recall abstractions approximations
action sequence applicable original task applicable abstract task
plan original task plan abstract task intuitively abstract task
generous original task mind consider cnf formula
n encoding existence plan one step shorter optimal plan consider
formula n generated abstract task need prove n
unsatisfiable note n fact unsatisfiable solution length preserving
abstraction intuitively constrained formula easier lead
proof n generous hence less constrained n mean
actually harder refute n refute n
abstraction methods fact trivial see answer question
yes say abstract n ignoring clauses n sub formula
n immediately implying resolution refutation n resolution
refutation n particular shortest possible refutation cannot shorter
n similar situation sometimes occurs interplay abstractions cnf
encodings instance suppose abstract ignoring subset
goals cnf encodings particular graph
cnf encodings kautz selman underlying satplan goal fact yields
one clause cnf hence goal ignoring abstraction n sub formula
n
complex example would correspond abstraction ignoring preconditions
delete effects encodings used satplan one several clauses related
ignored precondition delete effect disappear however cnf changes ways
one precondition delete effect less actions facts become possible
later time steps intuitively additional actions facts help proving
translation deeply frustrated satplan



fifriends foes satisfiability abstract cnf encodings

unsatisfiability n formal proof intuitive statement however less obvious
one goal ignoring abstraction matters complicated
much less intuitive edelkamps abstraction variable domain abstraction
changes made abstract task affect add effects actions recall
variable domain abstraction special interest likely satisfy
constraint solution length preservation
investigate issues detail one consider possible combinations
cnf encodings abstraction methods many different encodings sat
proposed focus graph encodings used
satplan system appearances international competitions kautz selman long kautz selman bonet geffner koehler brenner
hoffmann rittinger anderson weld smith fox kautz kautz et al
indeed according kautz selman kautz selman long et al
cnf encodingsin particular mutex relations computed graphplanare vital
satplans performance recent effective encodings may challenge
assessment rintanen heljanko niemela chen huang xing zhang
robinson gretton pham sattar even graphplan encodings
interest simply widely used almost decade remains
course important question whether extent carry alternative cnf encodings discuss issue depth concluding
section
consider four different encodings three used edition
ipc fourth encoding considered sake completeness encodings
differ two parameters whether use action variables action well fact
variables whether include graph mutexes actions
direct interferences latter motivated fact often enormous
amount action mutexes seriously blowing size formula
abstractions side focus abstraction methods formulated
manipulating tasks language level e modifying tasks actions
initial goal states many commonly used abstractions propositional strips
formulated way consider six abstractions namely removing goals
adding initial facts removing preconditions removing delete effects edelkamps
abstraction removing entire facts variable domain abstraction
combinations cnf encoding abstraction method prove
shortest possible resolution refutation exponentially longer n n
combinations involving abstractions variable domain abstraction
prove shortest possible resolution refutation cannot shorter n
n abstraction trivial outlined abstractions
proof exploits fact abstractions lead larger graphs containing
actions facts abstraction reasoning work
facts disappear graph however one start removing fact
goal action preconditions afterwards fact irrelevant one remove
initial state action effects
matters complicated abstraction variable domain abstraction
encoding action variables full mutexes


fidomshlak hoffmann sabharwal

shortest possible resolution refutation cannot shorter n n
encoding action variables direct action mutexes
possible improvement bounded effort takes recover indirect
action mutexes two encodings action fact variables remains
open question whether bounds exist
importantly proofs valid general resolution many
known restricted variants resolution particular tree resolution refutations generated dpll davis putnam davis logemann loveland
naturally proofs separate combinations rather exploit
exhibit common features
practical significance theoretical extent debatable
direct connection best case resolution refutation size empirical
sat solver performance even large refutation may easy mostly
consists unit resolutions vice versa small refutation exists
mean sat solver notwithstanding appears unlikely best case
resolution refutation size practical sat solver performance completely unrelated
beyond obvious lower bound one example indicates opposite
graph mutexes mutexes reduce best case refutation size work
resolution even invoked words sat solvers exploit mutexes
prune search trees effectively aware explicit empirical proof
tends happen often seems little doubt
suggested explicitly kautz selman kautz selman long et al
ways explaining improved performacce system run graphplan
encodings
interesting situation arises experiments use variable domain abstraction encoding action variables direct action mutexes
employed satplans ipc version setting resolution refutations get
shorter principle although effort takes recover indirect action mutexes employ trivial post abstraction simplification methods
removing action duplicates potential shorten resolution refutations still reported discernible empirical improvement
reason might sat solver shorter refutations
shorter refutations actually appear significant scale evidence
indicating latter mutex recovery becomes necessary rather special situations
abstraction turns indirect mutex direct one typically concern small fraction indirect mutexes addition mutex recovery
simplifications well designed variable domain abstraction affected actions
typically irrelevant anyway example hand made logistics abstraction
reason complications answering question requires determining graph
encodings general whether fact variables syntactic sugar may lead succinct
refutations proof appears quite challenging say section
general resolution recover mutexes effectively c f related investigations brafman
rintanen seem likely case tree resolution
best knowledge yet known



fifriends foes satisfiability abstract cnf encodings

effect potential improvements limited actions appearing redundant
plans get back detail section
view theoretical would potential importance even
evidence empirical relevance simply quite surprising moment
thought clear resolution refutation become easier ignoring goals
however variable domain abstraction domains logistics deflates state spaces
immensely point tiny fraction original size
performing work would never expected best case refutation size remain

organized follows section discusses preliminaries covering employed notions graphs propositional encodings resolution abstraction methods particular formally defines variable domain abstraction section
summarizes empirical section presents regarding resolution refutations abstract cnf encodings related work discussed text appropriate conclude section appendix contains proofs replaced
brief proof sketches main body text additional empirical data
found online appendix see jair web page article

preliminaries
begin discussion concepts needed rest propositional
strips graphs propositional cnf encodings
resolution proofs unsatisfiability abstraction methods used general
rule notation use variants p tasks f g sets facts
actions goals respectively abstractions p g graphs
propositional formulas encodings
strips graphs
classical devoted goal reachability analysis state transition deterministic actions complete information model tuple hs sg
finite set states initial state sg set alternative
goal states finite set actions transition function
specifying state obtained applying solution plan
state transition model sequence actions generate sequence
states sm si ai si sm sg
ai targets large scale state transition huge numbers
states assumed described concise manner via intuitive
declarative language use propositional fragment strips language fikes
nilsson brevity refer fragment strips herein informally
task instance strips consists set propositional facts
hold initially must hold simultaneously end plan
execution state system time defined set propositional facts
hold time task specifies set actions defined
set precondition facts set facts added state set facts
removed state action taken formally strips task


fidomshlak hoffmann sabharwal

given quadruple p p g fact set p initial state description p goal
description g p action set every action pre add
del subset p task defines state transition
model hs sg state space p initial state
sg iff g pre
actions applicable del add
assume actions reasonable sense add del
satisfied known benchmarks particular satisfied benchmarks
used experiments
many including satplan employ form approximate
reachability analysis one primary tools purpose graph first
introduced scope graphplan planner blum furst length bound
b graph p g p associated p layered graph two kinds nodes
fact nodes action nodes layers alternate fact layers f f f b
action layers b pair layers f forming
time step first vertex layer f contains initial state f
b action sets fact sets respectively available time step
precisely includes actions pre f pair
facts p p pre mutex layer c f contains standard noop
action every fact f f contains union add effects
actions obviously f f goal facts g
label appropriate vertices f b p g p four kinds edges
epre f connect actions preconditions f
eadd f connect actions add effects f
ea mutex capture pair wise mutual exclusion relation actions ea mutex actions cannot applied
simultaneously time
ef mutex f f capture pair wise mutual exclusion relation facts
f f f ef mutex facts f f cannot hold together time

note p g p explicit edges deletion effects actions
effects captured mutual exclusion relation e g p add del
ea mutex times mutex edges emutex ea mutex ef mutex
computed iterative calculation interfering action fact pairs blum furst
namely two actions directly interfere effects one contradict effects
one deletes precondition two actions competing
ipc domain rovers operators add delete artificial fact order prevent
parallel application implement restriction via duplicating respective operators
sequentializing original duplicate via two artificial facts similar fixes implemented
couple domains well
fact p p associated noop p delete effects p preconditions
add effects dummy actions simply propagate facts one fact layer next



fifriends foes satisfiability abstract cnf encodings

needs mutex preconditions combining two scenarios together say
two actions mutex directly interfere competing needs
similar spirit two facts mutex non mutex pair actions graph
layer directly together achieving facts variant interest
graph iterative computation ea mutex reduced contain
directly interfering actions call reduced graph denote
p gred p motivation considering often reduced
graph much smaller sat encodings get back
propositional encodings
consider three cnf encodings used one version satplan well
fourth encoding fits naturally picture encodings takes input
task p length bound b creates formula standard conjunctive
normal form cnf cnf formula solved shelf sat solver
process constitutes basic step sat implemented
satplan kautz selman one starts b iteratively
increments b cnf becomes satisfiable first time plan corresponding
satisfying assignment plan minimal b hence optimal
sense
cnf formula logically conjunction clauses clause disjunction literals literal propositional boolean variable negation
cnf formulas often written set clauses clause written set literals underlying logical conjunction disjunction respectively implicit
propositional encodings bounded length tasks specified terms
kinds clauses generated encoding method
encoding constructed p g p uses propositional action variables
b goal fact g goal clause form
b al b al actions b add g
similarly every every p pre precondition clause
al al actions add p
finally mutex clause every ea mutex
note dependence initial state taken account already
terms actions contained sets need stated
explicitly cnf
encoding b similar except uses variables appropriate clauses
facts specifically addition action variables fact
variables f b f f goal fact g goal clause simply
unit clause asserting g b fact f effect clause
form f al al actions
add f every every p pre precondition clause
versions satplan use naive incremental update b shown
clever strategies exploiting typical distribution runtime different values b rintanen
streeter smith



fidomshlak hoffmann sabharwal

takes form p action mutex clauses every
ea mutex fact mutex clauses f f every
f f ef mutex finally fact f f initial state clause
f strictly necessary implemented satplan
include
encoding c except reduced graph p gred p
mutex clauses present action pairs whose preconditions effects
interfere directly
encoding b except c p gred p mutex
clauses action pairs whose preconditions effects interfere directly note
however fact mutexes full graph p g p
encodings reasonable ways turning graph cnf formula encodings essentially underly competition implementations satplan
detail first note different encodings different benefits
drawbacks first observe encodings characterized two decisions
include action mutexes graphplan direct interferences
include action variables action fact variables regarding
empirical observation mutexes help one major observations
design satplan called blackbox kautz selman long et al
particular comparison earlier encoding methods kautz mcallester selman
hand since mutexes talk pairs facts actions encodings may
become quite largethere one clause every pair mutex actions mutex facts
particularly critical actions many benchmarks
thousands compared hundred facts indeed turns action mutexes often consume critically large amounts memory uncommon cnf
formulas millions clauses action mutexes kautz selman
kautz kautz et al motivates encodings c question
make much difference empirically benchmarks
consider distinction used versions satplan
let us say words clarify exactly encodings relate satplan
literature implementations due long history satplan well
imprecisions literature little complicated foremost reference
actual program code underlying satplan satplan e recent
versions used competitions encoding methods versions
implemented one authors four different encoding
methods action graphplan skinny action skinny graphplan
action encoding exactly graphplan encoding exactly b
skinny graphplan encoding exactly skinny action encoding
c except save runtime graph implementation
propagate mutexes direct interferences present final encoding
effectively computing relaxed graph hoffmann nebel use normal
version skinny graphplan encoding feature fact mutexes
consequence encoding used competition



fifriends foes satisfiability abstract cnf encodings

graph c sake readabilitythe greater similarity
encodings significantly simplifies write theoretical hold stated
relaxed graphs
satplan encodings develop historically reflected literature encodings used competitions answer questions
extent necessary explaining encodings original satplan
kautz selman introduced rather different encodings graphplan encodings
direct action mutexes introduced next observed yield performance
comparable graphplan kautz selman subsequently observed
modern sat solvers profit full fact action mutex relations actually
beat planners several domains kautz selman consequently
graphlan encoding e encoding b used competitions long et al prior competition encoding methods
implemented yielding four methods explained ipc booklet
satplan kautz describes four encodings version run competition skinny action encoding theoretical equivalent
encoding c running planner ipc turned full
fact mutexes helped domains encoding used instead kautz et al
consider encoding sake completeness
resolution refutations
theoretical respect resolution proof system robinson
forms basis complete sat solvers around today cf beame kautz
sabharwal sound complete proof system studied extensively theoretical practical reasons works cnf formulas one
simple rule inference given clauses x b x one derive clause b
resolving upon variable x b shorthands arbitrary lists literals
note choice clauses resolve arbitrary long share variable
opposite signs resolution derivation clause c formula consists series
applications resolution rule starting clauses one eventually
derives c c unsatisfiable empty clause called resolution proof
unsatisfiability refutation size number applications
resolution rule unsatisfiable rc denotes resolution complexity
e size smallest resolution proof unsatisfiability interested
whether applying abstraction task convert encoding one
smaller resolution complexity
commonly studied sub class still sound complete resolution derivations
tree resolution derivations derived clause used
whole derivation underlying graph structure proof tree
kautz selman cite graphplan encodings earlier work used action
mutexes however blackbox program code includes functions generate full mutexes kautz
selman explicitly emphasize importance mutexes
abstract little imprecise description initial state goal fact
mutex clauses mentioned skinny action encoding stated identical
encoding c e full graph rather relaxed graph



fidomshlak hoffmann sabharwal

interesting sub classes resolution include regular resolution provably exponentially powerful tree resolution variable resolved upon
path root leaf underlying proof graph ordered
resolution addition variables respect fixed ordering root leaf path
tree resolution captures proofs unsatisfiability generated sat solvers
dpll procedure davis putnam davis et al dont employ called clause learning techniques latter kind sat solvers provably
exponentially powerful even regular resolution although still within realm
general resolution beame et al
note arguments presented general unrestricted resolution however since aour constructions affect rely structural
properties resolution refutations consideration hold stated except slight weakening case lemma known variants resolution
setting variables true false replacing one variable another preserves
proof structure variants include tree dpll regular ordered resolution
state standard property resolution proofs use arguments
pointing certain modifications variable restrictions shortening
clauses given formula cause proofs become longer general resolution
natural sub classes including mentioned let x variable
true false another possibly negated variable variable restriction
x transformation replaces x throughout simplifies
resulting formula removing clauses containing true variable negation
removing false duplicate literals clauses words variable restriction
involves fixing value variable identifying another literal simplifying
formula sequence variable restrictions denote
outcome applying
following proposition combines two basic facts together form useful
us variable restrictions cannot increase resolution complexity formula
lengthening clauses removing clauses cannot decrease resolution complexity
formula
proposition let cnf formulas exists sequence variable
restrictions every clause contains sub clause clause
rc rc
explanation proposition use order notation
used chosen match way eventually utilize proposition
proofs conditions proposition imply one may obtain
applying restriction possibly throwing away literals
clauses possibly adding clauses intuitively three modifications
reduce number solutions cannot make harder prove
formula unsatisfiable property resolution refutations propositional formulas
previously used least indirectly contexts completeness include
proof appendix folklore ideas proof complexity literature
alternative proof somewhat different notation may found appendix
recent article hoffmann gomes selman


fifriends foes satisfiability abstract cnf encodings

way use proposition following cnf encoding
abstracted task encoding original task
carefully chosen restriction bring focus variables already
appearing proposition imply original encoding harder
refute resolution natural sub classes abstracted encoding
abstraction
abstraction methods kinds put use often quite successfully one line work uses abstraction methods decomposition cf sacerdoti
knoblock koehler hoffmann best knowledge
approachexamining abstract state space order prove absence solutions
pursued line work relevant work domainindependent heuristic functions cf mcdermott bonet geffner hoffmann
nebel edelkamp haslum et al helmert et al katz domshlak
abstraction means approximation state space work
differs abstractions used course kinds approximations
useful purpose differ lot use abstraction
one define approximations preserve large extent real
structure particular ideal goal abstractions preserve length optimal solutionsomething one definitely wouldnt expect
abstraction underlying heuristic function since solved every search state
briefly review approximation methods used
far formally introduce novel one variable domain abstraction
use logistics domain illustrative example
one wide spread approximation method subset relaxation
underlying computation made graph blum furst generalized subset relaxation haslum geffner nutshell one assumes
achieving set facts hard achieving hardest subset known
domains including logistics subset solution length corresponding
length graph constructed first fact layer containing mutexes
goal facts typically strictly lower length optimal plan
hand computing subset solution length typically costly
still p one typically guarantee solution length preservation helmert
mattmuller
second wide spread approximation method ignoring delete lists mcdermott
bonet geffner approximation one simply removes
negative effects actions negative effects removed
becomes solvable time linear instance size latter basis heuristic
functions used many modern planners cf bonet geffner hoffmann nebel
gerevini saetti serina ignoring deletes likely introduce shorter
solutions example towers hanoi leads plans length n instead
n hoffmann logistics one ignores deletes moving actions
stated open topic explore model checking abstractions particular predicate abstraction
graf sadi clarke et al instead abstractions



fidomshlak hoffmann sabharwal

plans may get shorter vehicles never move back abstraction
interestingly ignoring deletes load unload decrease plan length since
actions never undone optimal plan use observation
experiments
third abstraction introduced edelkamp pattern database
heuristic approximation one completely removes facts
description notably facts corresponding values multi valued variables
enough facts removed task becomes sufficiently simple obviously approximation hardly solution length preserving logistics remove example
fact package airport particular package loaded onto airplane
airport without actually precondition removed optimal
plan make package pop anywhere
fourth abstraction finally involves removing preconditions sacerdoti
goal facts edelkamps abstraction cannot expected solution
length preserving interesting cases
calls abstraction method designed following hernadvolgyi
holte considering strips state transition systems multiple valued
instead boolean variables propose reduce variable domains distinguishing certain values example content cell puzzle
blank may replaced blank
mapped onto observation many benchmarks done
without introducing shorter plans example logistics unnecessary distinguish
positions packages irrelevant cities therefore replace domain p
b b c c b initial goal cities p ai bi
locations cities b abstract domain b b c strips
amounts replacing set irrelevant facts p l single fact p c
formalize idea
let persistently mutex denote standard notion two facts mutex
fixpoint layer graph typically different values multiple valued variable
definition let p p g strips task p p p pair
persistently mutex facts p p del pre
p g called variable domain abstraction p
defined follows
fact set f f f p f otherwise f f p p
action pre add del pre add del p add del
otherwise pre add del p
words definition simply says replace p p p appears
add list delete list action remove delete list
situation arise instance action moves package one irrelevant position
reader may wonder p remains add list although prerequisite p pre reason
distinguish abstractions simplifications change task
abstractions simplifications way may alter tasks semantics however
simplifications may well affect resolution complexity get back later



fifriends foes satisfiability abstract cnf encodings

another irrelevant position operation p equivalent originally
p p p true abstracted action sequence p p true
corresponding real action sequence particular proposition states variable
domain abstraction approximation usual sense
proposition let p p g strips task let p
p g variable domain abstraction p whenever
ha plan p h plan p
proof let state induced p p first let us
state action applicable
applicable ii p p p
note since abstraction effect facts p p ii implies
thus together ii imply iii homomorphic
finally straightforward definition iv initial state
goal states exactly sg together iii iv
imply claim proposition
let pre add del applicability straightforward p pre
pre pre pre spre otherwise pre pre p p
p p cases pre implies pre consider
sub claim ii case case basis
p p add p p del p add p del thus
p iff p iff p p iff see assumption del case
p p
p p add p p del p add p del thus
p hand p p trivially holds
p p add p p del p add p del thus
p hand since p p persistently mutex facts p
p p del p p pre p p
p p add p p del p add p del thus
p hand add del p p add
immediately p p
completes proof ii
arbitrarily coarse variable domain abstractions may generated iterating application definition note variable domain abstraction refinement edelkamps
abstractioninstead acting irrelevant positions could totally ignored
distinguish whether package currently position makes
difference preserving optimal solution length
hinted variable domain abstraction may able apply
simplifications simplification terminology similar abstraction
topic future work explore whether refined abstraction lead better pattern database
heuristics strips



fidomshlak hoffmann sabharwal

manipulates task language level however abstractions may alter
tasks semantics simplifications e simplifications introduce
transitions goal states concretely consider two simplifications task
p p g duplicate actions exist pre pre
add add del del simplified task p except
removed task p p g irrelevant add effects
exists pre add simplified task p except
remove pre add
obviously duplicate actions irrelevant add effects may arise outcome variable domain abstraction example latter action moving package
irrelevant location irrelevant truck example former two actions loading
package onto airplane distinct irrelevant locations implementation
simple post abstraction processing perform simplifications
shall see section simplifications lead decreased resolution complexity thereby offsetting abstractions many cases cannot
may seem little artificial distinguish abstractions simplifications way seeing
many abstractions bound enable us simplify however note distinction
serves identify borderline cannot reduce resolution
complexity anyhow shall see next section abstraction tend help
empirically performance satplan even post abstraction simplifications

empirical
performed broad empirical evaluation effect abstractions efficiency
optimizing mostly focus variable domain abstraction
definition since clearly promising obtaining solution length preserving
abstractions
section explains specific variable domain abstractions employ experiments section explains experimental setting chose present huge
data set section describes experiments variable domain abstraction ipc benchmarks section discusses domain specific
abstractions hand made instances certain benchmark domains amount
irrelevance controlled section briefly summarizes findings abstraction
methods variable domain abstraction
variable domain abstractions
designed three different methods automatically generate variable domain abstractions methods listed increasingly conservative approximations
note define actions triples pre add del components hence
two actions identical pre add del may contained set reflects practical planner
implementations actions names unique ids checks duplicate actions
usually performed
similar fashion duplicate actions may arise outcome edelkamps pattern database
abstraction



fifriends foes satisfiability abstract cnf encodings

relevance common relevance approximations cf nebel et al algorithmic basis cases simplified backchaining goals
support starts first layer graph contains goal facts possibly
mutexes goal fact layer selects one achiever
preceding action layer marks preconditions action sub goals
process iterated created sub goals
allsupports proceeds similarly support except selects achievers
sub goal
allsupportsnonmutex proceeds similarly allsupports except starts backchaining first plan graph layer contains goals without mutexes
three methods selected set relevant facts r p taken set
goals sub goals created backchaining set facts turned
variable domain abstraction follows first compute partition
fact set p subsets p pk pairwise persistently mutex facts take
subsets correspond underlying multiple valued variables e g position
package perform abstraction within pi values relevant
e pi r within subset pi arbitrarily choose one irrelevant fact p e
p pi r replace irrelevant facts e q pi r q p
p
example logistics support abstracts away p v facts package p except vehicles v selected supportin particular single
airplane contrast allsupports mark p v relevant airplanes v unless
special case applies e g p must transported within origin city finally
allsupportsnonmutex even conservative covers special cases
allsupports abstracts p v fact away note identifying positions inside
airplanes positions outside airplanes may well affect length optimal plan
addition domain independent automatic variable domain abstractions six
ipc domains designed domain specific solution length preserving variable domain
abstractions hand logistics domain specific abstraction explained
introduction zenotravel use similar abstraction exploiting irrelevant object positions blocksworld b considered irrelevant b neither initial
goal position b initially clear depots combination logistics
blocksworld abstraction combination two individual abstractions
satellite abstraction performs simple analysis goal relevance detect directions
irrelevant satellite turn direction relevant satellites initial direction goal direction potential goal camera calibration target
similarly rovers waypoint location considered relevant rover
initial position relevant needed rock sample soil sample image
necessarily lies path rover must traverse reach relevant location
last conditions necessary avoid possibility clearing block c moving
away c although actually placed third block



fidomshlak hoffmann sabharwal

experiment setup presentation
presented data generated set work stations running linux pentium processor running ghz gb ram used time cutoff minutes
experimented plan length optimizing planners satplan ipp koehler
nebel hoffmann dimopoulos mips bdd edelkamp helmert
choice satplan rather satplan arbitrary except
naive encoding c resolution best case satplan improved variable domain abstractionmaking bad empirical even significant
note although satplan could considered recent contains
developments beyond satplan switching back older version
encoding method
test examples took exceptions listed strips domains used
international competitions including ipc precisely use
ipc airport dining philosophers optical telegraph pipesworld notankage
pipes world tankage psr
ipc depots driverlog freecell rovers satellite zenotravel
ipc blocksworld logistics miconic strips simple version
logistics freecell part ipc set
ipc grid mprime mystery movie trivial gripper variable domain
abstraction cannot preserve solution length logistics part ipc set
measurements aimed highlighting potential abstraction principle
speeding computation information task concretely given
task create abstract version run planner x
three possible outcomes
x finds plan abstract plan happens real plan plan
record time taken plan along time taken x
plan given original task
x finds plan real plan since planners optimize plan
length information still gain length optimal abstract plan
lower bound length real plan record time taken compute
bound example satplan time taken last unsatisfiable
iteration along time taken x compute lower bound given
original task
x runs time memory case one could record time taken
last lower bound proved successfully sake readability omit
consider cases
satplan ipp optimize step length plan mips bdd optimizes sequential plan
length however performance planners stand comparative evaluation
refer three simply plan length optimizing planners



fifriends foes satisfiability abstract cnf encodings

note spirit optimistic usefulness abstraction
include time taken create abstract task note actually obtain
several pair x namely one every particular variable domain
abstraction sake readability include distinctions
distinctions mostly inconclusive uninteresting anyway instead present
following best abstraction perspective skip abstract tasks
solved abstract since facts considered relevant
abstract task remains skip instance otherwise select abstract task
providing best information instance best case abstract plan
real else select highest lower bound several abstractions providing
best information choose one lowest runtime
ipc benchmarks
due sheer size experiments planners multiplied domainsdiscussing
entire set neither feasible would useful online appendix see jair
web page article contains detailed data three optimal planners herein
provide summary analysis showing main points particular focus satplan
detailed data satplan ipc domains given table
depots satellite selected table
domains abstraction brings somewhat significant advantage
logistics selected illustrative example
psr selected due interesting caseunusually current optimal planners well badly psr current sub optimal satisficing planners
domain selected challenging instances challenging
measured runtime taken original task note instance selection
criterion presentation optimistic point view abstraction
instance table first specifies whether found abstract plan real plan
characterizes instance terms cases explained
corresponding runtimes satplan abstract real tasks given
rows ta tr table specifies lower bound lg proved real task
graph f first fact layer contain goal facts
mutexes lower bound la proved satplan abstract task
finally actual length lr optimal plans real task last row relfrac
table specifies percentage facts considered relevant
depots best case data shown table scattered across four kinds
variable domain abstractions automatic abstractions sometimes
sometimes less aggressive handmade abstraction example instances numbers
best case aggressive support strategy time
note quality information essential abstraction tells us plan
must least n steps real plan length n must still prove bound n
typically takes time bounds together



fidomshlak hoffmann sabharwal

index
isreal
ta
tr
lg l l
relfrac
abs

index
isreal
ta
tr
lg l l
relfrac
abs

index
isreal
ta
tr
lg l l
relfrac
abs

index
isreal
ta
tr
lg l l
relfrac
abs










n




asnm























hm







asnm







asnm















hm







asnm







asnm







asnm







hm


n




asnm


n




asnm


n












hm


n




asnm


n




asnm







asnm

depots


n










asnm
logistics


n
n







asnm
hm
psr











asnm
asnm
satellite












hm
hm






hm


n




asnm


n




hm


n




hm







hm


n




asnm


n




hm


n












hm







asnm


n












asnm







hm







asnm


n




hm







asnm







hm


n







n




















hm







asnm


n







n




hm

table full selected domains satplan variable domain abstraction best see text notations index
index number instance respective ipc suite isreal whether abstract plan real n l length
optimal plan known lg lower bound plan length proved graph la lower bound proved abstract task
ta runtime secs needed prove lower bound la abstract task tr runtime secs needed prove lower bound la
real task relfrac fraction facts considered relevant dashes time abs corresponding form variable
domain abstraction support allsupports allsupportsnonmutex asnm handmade hm



fifriends foes satisfiability abstract cnf encodings

domain
airport
blocksworld
depots
dining philosophers
driverlog
freecell
grid
logistics
mprime
mystery
optical telegraph
pipesworld notankage
pipesworld tankage
psr
rovers
satellite
zenotravel

index


















ta


















satplan
tr
isreal
lg l l r













n





n


n








n





n











n


relfrac


















table satplan best case variable domain abstraction
challenging successful instances domain notation table

runtime better original task yet cases abstraction
brings quite significant advantage notably instance number satplan
runs time original task solves abstract task finding real plan within
minutes logistics best case data mostly though exclusively due
conservative allsupportsnonmutex handmade abstractions abstract runtime
worse three cases nos slightly better psr best
cases almost exclusively due conservative allsupportsnonmutex abstraction
runtimes abstraction usually faster marginally satellite one
domains abstraction brings significant largely consistent runtime
advantage best cases almost exclusively due hand made abstraction
abstract plans real plans often found significantly faster original task
unclear us good satellite example logistics
state space reduction much larger
next table provides overview satplan ipc
domains make data presentation feasible select one instance per domainthe
challenging successful instance successful mean least one abstract
task instance solved abstract plan found abstract task indeed
abstract facts relevant challenging mean maximum runtime original
task
another strategy would select task maximizes tr ta time advantage given
abstraction however cases strategy would select trivial instance namely tr ta
consistently negative maximal easiest tasks



fidomshlak hoffmann sabharwal

domain
airport
blocksworld
depots
dining philosophers
driverlog
grid
logistics
mprime
mystery
optical telegraph
pipesworld notankage
pipesworldtankage
psr
rovers
satellite
zenotravel

index

















ta

















tr

















ipp
isreal




n
n

n
n
n

n
n
n



lg l l r

















relfrac

















table similar table ipp planner

useful discuss domains groups similar behavior depots logistics
psr satellite already discussed airport dining philosophers
driverlog mystery mprime optical telegraph pipesworld notankage pipesworld
tankage satplan runtimes consistently lower original tasks exceptions mostly among easiest instances picture less consistent qualitatively
similar zenotravel degree advantage varies relatively moderate
dining philosophers less runtime original task optical telegraph
airport pipesworld tankage mprime
much stronger zenotravel mystery driverlog
pipesworld notankage
rovers runtime inconclusive minor advantages abstract
real depending instance blocksworld satplan solves abstract tasks
blocks independently abstraction used dont know causes
bad behavior freecell time allsupports allsupportsnonmutex
abstract anything abstractions generated support satplan runs
time leaving instance number successful case shown table grid
finally ipc test suite contains instances become huge quickly
satplan solve abstract real instances numbers latter
shown table
tables provide similar snapshot ipp mips bdd
respectively picture ipp roughly similar satplan main
difference fact ipp weaker solver satplan many domains
effect domains contain interesting data specifically driverlog
mprime mystery pipesworld notankage psr ipp solves instances
time satplan see advantage abstraction depots


fifriends foes satisfiability abstract cnf encodings

domain
airport
blocksworld
depots
dining philosophers
driverlog
freecell
grid
logistics
mprime
mystery
optical telegraph
pipesworld notankage
pipesworld tankage
psr
rovers
satellite
zenotravel

index




ta




mips bdd
tr
isreal







lg l l r




relfrac



























n
















































table similar tables mips bdd planner

satellite note satellite difference consistently huge
see vague advantage abstraction logistics mips bdd even domains
gave meaningful data domains dashed table mips bdd runs
time even smallest instances domains left empty could run
mips bdd technical reasons stopped abnormally remaining data
set domains however abstractions expected bring consistent advantage
mips bdd particular consider behavior logistics rovers zenotravelin
domains mips bdd vastly improved abstraction satplan ipp
less inconclusive
constructed benchmarks
shown use abstractionof variable domain abstraction least
speed state art systems varies quite promising mips bdd
rather hopeless satplan ran number focused experiments examine
subtle reasons phenomenon experiments done three
ipc benchmarkslogistics rovers zenotravelwhere ipc test
suites relatively bad although possession hand made abstractions
wanted test happens scale instances irrelevance respective
experiment logistics figure discussed introduction rovers tried
large number instance size parameters even minor modifications operators
could setting contained lot irrelevance challenging
satplan ipp short appears rovers domain amenable
abstraction techniques zenotravel obtained picture shown figure


fidomshlak hoffmann sabharwal
















































mips bdd abstract
mips bdd real
relfrac

























ipp abstract
ipp real
relfrac






































b























satplan abstract
satplan real
relfrac




























c
figure runtime performance mips bdd ipp b satplan c
abstract without real hand made variable domain abstraction
zenotravel instances explicitly scaled increase amount irrelevance
horizontal axis scales number cities left vertical axis shows total runtime
seconds right vertical axis shows percentage relfrac relevant facts

shown zenotravel instances feature airplanes persons number
cities scales logistics generated random instances per size
average values time seconds stopping plots timeouts occurred instance size relative behavior abstract real
curves planner quite similar observed figure logistics
satplan ipp abstraction slight disadvantage high relfrac
becomes much efficient relfrac decreases mips bdd advantage brought
abstraction much pronounced decreasing relfrac consistently widens
gap solving abstract real tasks average value relfrac ipc
zenotravel benchmarks lying cities cities
figure yet much gained abstraction


fifriends foes satisfiability abstract cnf encodings

summary appears benchmarks rovers good
abstractions others logistics zenotravel enough irrelevance
ipc test suites
important note situation may quite bad unsolvable examples consider ipc benchmarks dining philosophers optical telegraph edelkamp
dining philosophers extremely basic benchmark cannot abstracted
much contrast optical telegraph essentially version dining philosophers
complex inner life exchanging data two hands philosopher
inner life affect existence solution deadlock situation depends exclusively outer interfaces philosophers taking releasing
forks however inner life course affect length solution one exists
constructed unsolvable version domain without deadlock situation giving
philosophers flexibility releasing forks one would expect setting
abstracting inner life away gives huge savings e tasks proved unsolvable
much efficiently suggests may easier abstract unsolvable tasks
without invalidating property interest exploring topic future work
benchmark domains naturally contain unsolvable instances
subscription issue may become relevant sanchez kambhampati
meuleau brafman benazera
abstractions
discussed earlier one cannot expect removing preconditions goals entire facts
preserves plan length interesting cases however certain cases
delete effects safely ignored specifically driverlog logistics mprime mystery
zenotravel one ignore deletes load unload actions state
object longer origin location load respectively object
longer inside vehicle unload rovers one ignore deletes actions taking
rock soil samples namely deletes stating sample longer origin
location ran planners respective abstracted tasks
summarized follows
satplan clear loss runtime abstraction driverlog e g
task number solved abstract vs real vs sec
ipp vast gain abstraction logistics e g vs sec number
vast loss zenotravel e g vs sec number
mips bdd vast loss abstraction driverlog logistics zenotravel e g
vs sec zenotravel number
inconclusive planner domain pairs

resolution complexity
discussed introduction surprised see little improvement satplan experiments despite dramatic state space reductions brought


fidomshlak hoffmann sabharwal

variable domain abstraction shed light issue examining resolution
complexity original vs abstracted tasks throughout section
consider situation plan length boundthe number time steps cnf
encodingis small thus cnfs unsatisfiable note case
one sat tests performed satplan particular case
sat tests satplan proves optimality plan non existence
plan n steps n length optimal plan proof typically
costly accounting large fraction runtime taken satplan
consider abstraction methods introduced section plus completeness
hypothetical abstraction method adds initial facts section
many cases resolution complexity cannot improved delegating optimality
proof within abstraction section considered cases
resolution complexity become exponentially worse section briefly examines
effect post abstraction simplifications sake readability herein proofs
replaced proof sketches full proofs available appendix
recall resolution complexity defined length shortest possible resolution refutation proofs arguments general unrestricted resolution
however constructions affect structure resolution refutations
hence hold stated except slight weakening case lemma
many known variants resolution including tree dpll regular ordered
resolution general hold variant resolution setting variables true false replacing one variable another preserves proof structure
slightly exceptional status lemma explained discuss

remainder p task abstraction
p denote respective abstracted task task
applying p
resolution complexity become better
prove three main captured theorems first
holds four sat encodings listed section two
apply encodings c respectively respective encodings
abstraction methods essentially say resolution complexity cannot decrease
applying abstraction outlined introduction catchy imprecise intuition
behind approximations abstractions less constrained
formulas harder refute encoding c offset effort
required recover graphplan mutexes get back theorems
follow recall section rc denotes resolution complexity e
size smallest resolution proof unsatisfiability
theorem let p task assume use encoding methods
let abstraction p consists combination
adding initial facts
b ignoring preconditions goals deletes


fifriends foes satisfiability abstract cnf encodings

c removing fact completely
let n length shortest plan p let b n let encodings
b step plan existence p p respectively rc rc
theorem let p task assume use encoding method let
abstraction p consists combination
adding initial facts
b ignoring preconditions goals deletes
c removing fact completely
variable domain abstraction
let n length shortest plan p let b n let encodings
b step plan existence p p respectively rc rc
theorem let p task assume use encoding method c let
abstraction p consists combination
adding initial facts
b ignoring preconditions goals deletes
c removing fact completely
variable domain abstraction
let n length shortest plan p let b n let encodings
b step plan existence p p respectively let number resolution steps
required infer additional mutex clauses appear
encoding b step plan existence p per encoding rc rc
note theorems n defined length shortest plan p
necessarily satisfies n length shortest plan p hence
n b satisfiable detecting finding p plan length b
give us information length shortest plan p b n
however unsatifiable tells us b lower bound plan length p
hence theorems say b n coarse disprove existence
plan length b b n decrease resolution complexity
disproofat least complexity deriving additional mutexes
case theorem
let us first linger bit theorem general intuition
abstractions induce less constrained formulas hence resolution complexity cannot decrease hold encoding stated theorem strict
sense see proposition later section encoding c basically answer
intuition imprecise general formulation devil details
particular case issue variable domain abstraction makes use mutex


fidomshlak hoffmann sabharwal

relations encoding c aware sometimes indirect mutex original
task omitted encoding c becomes direct mutex abstraction included encoding c refuting might involve recovering mutex refutation
need hence potential improvement resolution complexity may stem
power mutex relations upper bound specified theorem shows
thing improvement due proposition provides example
mutex must recovered hence proves analogue theorem
hold encoding c
open question whether analogue theorem holds encoding b
whether analogue theorem holds encoding discuss
open questions appear related intricate properties graphplanbased encodings vs without fact variables know mutexes may
need recovered encoding example provided proposition works
encodings c establish connection two open
questions analogue theorem holds encoding b immediately get
analogue theorem holds encoding
consider detail note far removal goals concerned
theorems actually trivial four encoding methods removes part
goals sub formula abstraction methods latter
case treat removal goals together methods since treament
cause overhead goal clauses need discussed anyway set
achievers goal may change
proofs need helper notion captures approximated graphs assume task p graph p g p assume
abstraction p g p typically many vertices p g p
captures fact p allows fewer often facts actions p
general many constraints propositional translation
task constraints may seem abstraction could
principle make possible derive easier shorter proof fact plan exists
within specified bound however closer inspection restricted facts actions
already available original graph reveals one often ends fewer
weaker constraints original task introduce notations
make formal
definition task p abstraction p g p defined
subgraph p g p induced vertices p g p similarly p gred p defined
subgraph p gred p induced vertices p gred p
definition let p task abstraction called graph
abstraction p p g p p g p identical sets vertices following
conditions hold
eadd p g p eadd p g p
epre p g p epre p g p
emutex p g p emutex p g p


fifriends foes satisfiability abstract cnf encodings

g g
g g goal states p p respectively abstraction called
reduced graph abstraction conditions hold p gred p p gred p
instead
lemma let p task assume use encoding method b let
graph abstraction p let n length shortest plan p
let b n let encodings b step plan existence p p respectively
rc rc
proof sketch say set false variables appear e
fix value variables way defined p g p
yields precisely propositional encoding p g p variable
restriction clauses surviving present stronger
form e fewer literals example encoding precondition clause
c corresponding clause c due condition definition
states introduce preconditions c c due condition
definition states preserves add effectshence set actions
achieving precondition p contains corresponding set p similar observation
holds effect clauses encoding b similar arguments apply
kinds clauses claim follows proposition
lemma let p task assume use encoding method c let
reduced graph abstraction p let n length shortest plan
p let b n let encodings b step plan existence p p
respectively rc rc
proof argument identical proof lemma except underlying
graph encodings c reduced graph resulting potentially fewer mutex clauses encodings b respectively however
way affect proof arguments
lemma let p task let modification p respects
following behavior
shrink list initial facts
b grow set goal facts
c preserves add lists unchanged
grow pre del lists
graph abstraction p well reduced graph abstraction
p


fidomshlak hoffmann sabharwal

proof sketch proof straightforward little tedious details suppose
abstraction p satisfying prerequisites must argue p g p p gred p
satisfy conditions definition condition involving goal states easily follows
property b p g p p g p well reduced counterparts
shown set vertices conditions involving precondition
effect relations follow directly properties c hence remains prove
facts actions available p g p available p g p showing
said mutex relations created facts
actions mutex p g p showing proof little tedious proceeding
inductively construction graph underlying intuition however
simple p g p layer abstracts p g p layer properties c
respected necessarily p g p layer abstracts p g p
layer concludes argument
following immediate consequence lemmas
corollary let p task assume use encoding methods
let abstraction p consists combination
adding initial facts
b ignoring preconditions goals deletes
let n length shortest plan p let b n let encodings
b step plan existence p p respectively rc rc
essentially states rather intuitive fact abstraction anything yields larger graph resulting graphplan encodings
less constrained hence higher resolution complexity anything
matters become much less intuitive consider abstractions remove entire
factsclearly longer approximated graphs since remove vertices words condition definition p g p
p g p identical sets vertices hold need slightly different line
reasoning rely strictly abstracted graphs first
harmless remove fact appear goal pre del list
rely corollary reason requirement fact easily achieved
lemma let p task assume use encoding methods
let p fact appear goal pre del lists
let abstraction p removes p initial facts add lists let
n length shortest plan p let b n let encodings
b step plan existence p p respectively rc rc
proof sketch key point p appear goal never required
deleted action p completely irrelevant task particular
resolution refutations consider concretely first prove every layer
graph available facts mutex fact pairs remain
facts fact pairs involving p thing lost fact layers


fifriends foes satisfiability abstract cnf encodings

p g p p since p occur precondition action layers remain exactly
since p occur preconditions delete effects action mutexes
remain exactly caused p
discussion implies precondition clauses encodings
identical given p appear goal true goal clauses
since action mutexes unchanged follows actually identical
encodings c encodings b difference
contain initial state effect mutex clauses involving p
however clauses never participate resolution refutation effect
mutex clauses contain p polarity negative initial state clause
positive form p time index different p effect mutex
clauses hence every variable corresponding p occurs one polarity concludes
argument
corollary let p task assume use encoding methods
let abstraction p removes fact completely let n length
shortest plan p let b n let encodings b step plan existence
p p respectively rc rc
proof equivalent following two steps first remove p goal facts
present pre del lists corollary step cannot improve resolution
complexity second p removed goal pre del lists
remove p completely removing initial facts add lists
well lemma step well cannot improve resolution complexity
done
corollaries together prove first main theorem
move variable domain abstraction matters complicated
interesting abstraction method enables us construct solution length
preserving abstractions exponentially smaller state spaces many benchmarks first
original form holds encoding
lemma let p task assume use encoding method let
variable domain abstraction p let n length shortest plan p let
b n let encodings b step plan existence p p respectively
rc rc
proof sketch combines two persistently mutex facts p p single fact p first
action pair mutex p mutex p
way become mutex per requires w l g p p del pre
p pre add supposing mutex p p del p
mutex fact pre noop p mutex p hence
p p persistent mutex contradiction
hand derive property rather similar graph
abstractions given definition know abstract encoding
mutexes appear set actions achieving
fact grows applying abstraction goal shrink


fidomshlak hoffmann sabharwal

subtle issue regards precondition clauses action p precondition p
replaced p p direct correspondence two however
lack correspondence affect precondition clause encoding
takes form ak omits actual precondition fact achieved
matter whether fact p p
next proof lemma set variables false appear
arguments difficult see clauses surviving
present stronger form e fewer literals
mutex clauses obvious goal clauses argument exactly
proof sketch lemma given precondition clauses observe ak
contain achievers p plus achievers p claim follows
proposition
corollaries together lemma prove second main theorem encodings b matters complicated
consider first encodings b differ
fact variables changes precondition clauses action p p
precondition p p longer get clause ak proof
sketch instead get clause p clause correspondence
particular consider case two actions p action precondition
p action precondition p gives us clauses p p
clauses p p distinguish achievers
p p regard fact two
clauses share literalwhich dont exploited obtain shorter resolution
refutations open question discuss implications little detail
end sub section
consider encoding c differs includes direct action
mutexes invalidates different argument proof lemma still true
action pair marked mutex p mutex p
however happen mutex p due direct interference
mutex p due mutex preconditions rather direct
interference since encoding c accounts direct interferences
mutex appear improved resolution complexity
following proposition proves formally
proposition assume use encoding method c exist task p
variable domain abstraction p b n rc rc n
length shortest plan p encodings b step plan existence
p p respectively
proof sketch construct p b specified key property construction
two actions getg getg needed achieve goal facts
g g respectively precisely getg x g p x getg p
g p task constructed along help actions way
x p p pairwise persistently mutex variable domain abstraction replaces
p p b set action layer directly beneath goal layer e action


fifriends foes satisfiability abstract cnf encodings

layer graph marks getg getg mutex preconditions
mutex encoding c however include mutex clause
direct conflict situation changes abstraction getg adds p instead p
hence direct conflict delete effect getg consequence
abstraction two resolution steps suffice applying getg getg
option achieve goals mutex clause immediately excludes option
encoding original task required mutex must first
derived reasoning preconditions x p
note reason get shorter refutation variable domain abstraction turns indirect action mutex due competing preconditions
direct interference abstraction exploits knowledge p p
persistently mutexa fact ignored encoding c hence positive stated
proposition less related power abstraction power
graph mutexes capture formally follows note
plan length bound cnf formula per encoding c sub formula cnf
formula per encoding additional clauses inferred
lemma let p task let variable domain abstraction p
let n length shortest plan p let b n let c
encodings b step plan existence p per encoding c respectively let c
encoding b step plan existence p per encoding c let number
resolution steps required infer c additional mutex clauses appear
rc c rc c
proof denote encoding b step plan existence p per encoding

preconditions lemma rc c rc resolution steps
c turned hence shortest resolution refutation
construct one c steps longer
lemma rc rc
c sub formula hence rc rc c
combining observations
rc c rc

observation

rc
rc c

observation




observation

finishes proof
clearly proof argument applies combination variable domain
abstraction abstractions hence corollaries together
lemmas prove third main theorem note latter
hold variants resolution claim lemma


fidomshlak hoffmann sabharwal

number resolution steps takes derive action mutexes present original
encoding used resolution refutation variant resolution
consideration say dpll tree resolution deriving mutex clause
enoughit must derived many times used tree resolution
refutation hence effective value variants resolution would larger
note case dpll solver learns mutex clauses virtue
wide spread clause learning technique
lemma particularly relevant empirical satplan uses
encoding c experiments mostly focus variable domain abstraction
explicit empirical proof proof would difficult come requiring
deep analysis sat solvers search spaces seems reasonable assume
least extent disappointing satplan due whats proved
lemma abstraction cannot improve resolution complexity beyond effort
required recover indirect action mutexes note bound given
lemma rather pessimistic mutex needs recovered case
competing needs p replacing p p direct
interference incur simplifications logistics domain example
abstraction happens actions loading package onto airplane two
different irrelevant cities since load actions involved redundant
solutions anyway seems doubtful mutexes play role resolution complexity
generally interesting consider upper bounds lemma
many resolution steps take recover indirect action mutexes general resolution number steps polynomially bounded since inference process conducted
graph simulated related investigation see brafman
restricted variants resolution matters complicated particular interest
behavior dpll clause learning c f far known formula dpll clause learning proofs provably substantially worse general
resolution proofs would rather surprising graph mutexes
first rintanen provides related investigation showing mutexes
recovered polynomial time particular step lookahead procedure related
identical clause learning
concluding sub section let us turn attention encodings b
mentioned open question whether analogue theorem holds
encoding b whether analogue theorem holds encoding
facing two problematic issues
fact variables encoding b fact variables addition
action variables used encodings c
ii mutexes encoding c may happen variable domain abstraction
converts implicit mutex encoding original task explicit one
abstraction
consider first issue ii situation exactly encoding c regard
proposition holds stated encoding well indeed proved


fifriends foes satisfiability abstract cnf encodings

exactly example minor adaptations proof arguments similarly lemma holds encoding exactly proof argumentsprovided
analogue lemma hence analogue theorem holds encoding b
namely proof arguments lemma remain valid except need refer
encoding b rather accordingly need corresponding version
lemma brings us issue
variable domain abstraction perceived gluing sets facts together recall
example clauses p p sharing literals clauses
p p sharing literal p discussed explain
proof lemma work encodings b k facts glued
together groups k clauses become linked together fashion question

resolution fruitfully exploit increased linkage
issue appears related quite intricate properties graphplan
encodings vs without fact variables encoding differs encoding
b use fact variables lemma tells us resolution cannot
exploit variable domain abstraction appears reasonable think adding fact
variables help lot intuition
whatever one encoding b one easily simulate encoding
statement true answer question yes
answer would contradict lemma hence initial attempt prove answer
tried prove statement however initial investigation indicated
explicitly keeping fact variables non trivial constraints around encoding b
might facilitate significantly shorter resolution derivations general hence statement
might false namely appear families formulas suitably
encoded tasks yield exponential separation encodings
b true suggests reasoning presence fact variables might
powerful hence might indeed able exploit linkage gain yielded
variable domain abstraction
since purpose compare relative power
graphplan encodings b detail progress
towards disproving statement besides note statement indeed false
immediate implications answer question definite
answer left open future
resolution complexity become worse
answer title sub section definite yes four encodings
abstractions consider may exponentially deteriorate resolution complexity
formally following theorem
include full proof c appendix



fidomshlak hoffmann sabharwal

theorem assume use encoding methods exist
infinite sequence tasks p abstractions p b n
rc exponential rc constant independent n
length shortest plan p encodings b step plan
existence p p respectively consists one
adding initial facts
b ignoring preconditions goals deletes
c removing fact completely
variable domain abstraction
proof sketch idea construct p task consists two separate
sub tasks whose overall goal achieve goals sub tasks
sub tasks infeasible within given plan length bound b
tasks bounds constructed size grows polynomially however
first sub task constructed require exponential size resolution refutations
second allows constant size refutations abstraction approximates easy torefute sub task way becomes feasible within b steps resolution
refutation overall task must rely hard refute sub task leads
exponential growth resolution complexity opposed constant resolution complexity single one listed abstractions feasibility
easy refute sub task accomplished simple manner hence proving theorem
order construct tasks whose cnf encodings require exponential size
resolution refutations resort pigeon hole formula php well
known resolution proof php must size exponential haken
construct simple pigeon hole task pp hp capture
four encoding methods cnf encoding b
identical php transforms php variable restrictions hence
proposition resolution refutation must size exponential final
construction uses combination two tasks pp hp serves hard refute
sub task pp hp disjoint sets pigeon hole objects serves easy refute
sub task
essentially theorem states intuitive fact abstractions make bad
choices approximating away concise reason task cannot
solved particular number steps illustrate significance consider
comparison mutex relations analogue theorem hold
adding mutex clause cnf encoding improve resolution complexity
sense mutex relations considerably less risky abstractions consider

pigeon hole used proof theorem may seem artificial
indeed contained sub wide spread domains concerned
transportation example gripper available time steps serve holes
actions picking dropping balls pigeons related investigation see


fifriends foes satisfiability abstract cnf encodings

hoffmann et al seems quite natural task may consist two
disconnected parts one complex one easy prove unsolvable
given number steps think transporting two packages one
close many vehicles requires one step bound allows
one already inside vehicle needs transported along single path road
connections much longer bound concrete example latter situation
formalized hoffmann et al
note simplifications
pointed section may actions abstraction obviously
simplified without altering semantics task particular abstraction
might create duplicate actions actions identical preconditions effects
well redundant add effects contained respective actions precondition
turns natural post abstraction simplification task lead
lower resolution complexity
proposition assume use encoding methods exist
task p task p identical p except irrelevant
add affect duplicate action removed b n rc rc
n length shortest plan p encodings b step plan
existence p p respectively
proof sketch claim duplicate actions consider task p encoding
pigeon hole pigeons holes actions put pigeon p hole h
plan length bound point proof works solvable tasks p
extra action whose preconditions two goals achieves third goal
ensures solvability two steps three goals one pigeon
mutex clauses direct action interference pair goals
achieved three particular every resolution refutation must resolve
three goal clauses obtain p adding duplicate action one pigeons
one holes respective goal clause becomes one literal longer
refutation must get rid literal hence necessitating one step construction
works four encodings
claim removal redundant add effects slightly modify p replacing
effect fact x including another action achieves third goal given
precondition x optimal plan length length bound
refutation must resolve three goal clauses p give one preconditions
additional add effect refutations become longer respective goal
clause construction works four encodings
easy modify constructions used proof proposition way
duplicate action respectively redundancy add effect arise
outcome variable domain abstraction hence via enabling simplifications variable
domain abstraction may improve resolution best case behavior duplicate actions
true edelkamps pattern database abstraction open question


fidomshlak hoffmann sabharwal

whether improvement may exponential whether bounded polynomially
conjecture latter case least unrestricted resolution
notable examples proof proposition specifically
constructed include duplicate actions redundant add effects actions relevant
solving form part optimal solution well constructed variable
domain abstraction likely happen since abstraction target facts
irrelevant solution length consider logistics domain example
actions simplifications apply loads unloads packages locations
cities packages origin destination actions involved
redundant solutions seems doubtful simplification affects resolution
complexity course simplifications might help sat solvers anyway however
observed least significantly experiments

conclusion
abstractions used power allow proving certain properties within much
smaller state spaces particular abstraction preserves length optimal
solution optimality proved within abstraction designed novel abstraction method strips suitable purpose surprisingly
yields little benefits satisfiability represented satplan even domains featuring hand made abstractions exponentially smaller state spaces towards explaining shown many cases
abstraction method well commonly used abstractions lacks ability introduce shorter resolution refutationsother exploiting mutexes
enabling certain post abstraction simplifications contrast shown
abstractions may exponentially increase size shortest resolution refutations
several questions left open theoretical know whether variable domain abstraction improve resolution complexity combination encoding
b whether polynomial upper bound improvement variable domain
abstraction bring encoding whether polynomial upper bound
improvement simplifications apart answering questions importantly remains seen extent generalize bluntly
stated intuition behind approximations usually less
constrained formulas harder refute however actual technicalities
depend quite lot detailsof encoding method abstraction
hence largely unclear extent intuitive statement captures reality
particular hold encodings sat
would interesting e g look alternative encodings described kautz
selman kautz et al kautz selman ernst millstein
weld many encodings unit clauses initial goal state
action clauses stating action implies effects preconditions
structureand lack mechanism graph propagates
changessome properties proved herein obvious removing goals initial state
facts corresponds directly removing clauses true preconditions removing
fact completely may cases simply correspond removing clauses mention


fifriends foes satisfiability abstract cnf encodings

fact hence encodings seems proving might indeed
comparatively easy challenging subject may recent developments
encodings rintanen et al often give substantial speed ups
novel notions parallelity encodings chen et al introduce
long distance mutex relations encodings robinson et al make use
effective operator splitting factoring methods
generally hold methods employed fields particular
hold model checking abstraction e g graf sadi clarke
et al sat encodings e g clarke biere raimi zhu prasad biere
gupta highly successful one example actually obvious
hold gupta strichman abstract ignoring clauses cnf
encoding original transition system motivation much smaller cnf
formula causes less overhead sat solver
ambitiously define generic framework formal notions declarative
transition systems cnf encodings abstractions suitable capture
prove generic statements questions appear worthwhile
challenges indeed think key contribution work may lie asking
question resolution complexity vs without abstraction
practical perspective see mainly four lines first
important question whether observations carry modified extended planningas sat systems one ray ginsberg guarantees plan
optimality branching restrictions within single sat call rather
calling sat solver iteratively second remains open explore whether different
abstraction techniquesbased e g predicate abstractioncan suitably adapted
third important note empirical entirely negative
mips bdd often substantially improved even point figure
optimal sequential planner highly competitive strong optimal parallel planner
satplan highly parallel domain logistics direction
may well worth exploring depth finally effective abstraction methods may
exist unsolvable examples could potentially play crucial role subscription
sanchez kambhampati meuleau et al

acknowledgments
thank anonymous reviewers whose detailed comments helped greatly improve
preliminary version work appeared icaps th international
conference automated scheduling hoffmann sabharwal domshlak
work carmel domshlak supported israel science foundation isf
grants well c wellner fund part
work jorg hoffmann employed max planck institute computer science
saarbrucken germany sap karlsruhe germany work ashish
sabharwal supported iisi cornell university afosr grant fa
national science foundation nsf expeditions computing award computational


fidomshlak hoffmann sabharwal

sustainability grant nsf iis award grant defense advanced
projects agency darpa real grant fa

appendix proof details
proof proposition suppose sequence transformations consists restrictions let strengthening transformation replaces
clause necessarily strict sub clause clause
transformation exists assumptions proposition observe
transformation steps together convert necessarily strict sub formula
transformation steps individually increase
resolution complexity underlying formula without loss generality
prove fact single restriction transformation generic strengthening
transformation since individually shown increase resolution
complexity formula applied sequence combination number
times without increasing resolution complexity would prove particular
resolution complexity sub formula implying
resolution complexity additional initial clauses
cannot hurt resolution refutation desired
start single restriction transformation x ease notation
assume initial formula f c c cm resulting simplified
without loss
formula transformation f c c cm


generality assume ci equals empty clause duplicate
clauses f let c c cm cm cm resolution refutation
f smallest possible size note involves initial clauses resolution
steps construct resolution refutation f size larger
following three steps
step transform c cm cm cm ci defined
follows application transformation x ci containing true
variable negation ci equals true ci containing
false duplicate literals ci consists ci false duplicate literal removed
otherwise ci ci note ci contain x true empty
clause non empty necessarily strict sub clause c key property
ci still logical implicant cj ck ci derived resolving
cj ck original proof ci may necessarily usual resolution
resolvent cj ck next two steps fix
step transform c cm cm cm ci equals ci
defined sequentially increasing follows suppose
ci derived resolving clauses cj ck j k assume
without loss generality already defined cj ck ci equals
true ci equals true well otherwise one two clauses cj ck
equals true ci equals clause otherwise cj ck resolved
together variable ci resolvent two clauses key
property seen easily considering sequential nature


fifriends foes satisfiability abstract cnf encodings

transformation ci true necessarily proper subclause ci particular cm ci equal true
resolution resolvent cj ck equals one cj ck

step finally transform simply removing clauses equal true
occur previously clause sequence stopping sequence soon
first empty clause encountered construction exactly
clauses clauses first clauses
exactly clauses f resolution refutation starting
initial clauses desired
consider strengthening transformation essentially replaces
clause formula sub clause thereby strengthening clause
applying increase resolution complexity underlying formula
ease notation let initial formula f c c cm resolution
refutation c c cm cm cm smallest possible size
argument along lines simpler restriction transformations
transform c cm cm cm ci equals
sub clause ci maps ci ci defined sequentially increasing
follows suppose ci derived resolving clauses cj ck variable x
j k assume without loss generality already defined cj
ck x present cj ck ci simply resolution resolvent
two clauses otherwise x present cj ci equals cj otherwise x must
present ck set ci equal ck key property seen
easily considering sequential nature transformation ci
necessarily proper sub clause ci particular cm ci cj
ck resolution resolvent two transform simply removing
clauses occur previously clause sequence construction
exactly clauses clauses first clauses
exactly clauses f resolution refutation starting initial
clauses desired
proof lemma let p task abstraction abstracts
p g p applied let denote propositional encodings p p respectively
use action encoding action fact encoding b
let u denote set variables variables finally
let variable restriction sets every variable u false setting
propositional formula nothing cnf encoding graph p g p
encoding method b used particular
clauses correspond actions facts p g p trivially satisfied
contain negation variable u set false call
remaining yet unsatisfied clauses surviving clauses argue
surviving clause already present perhaps stronger weaker form
showing easier prove unsatisfiable prove
unsatisfiable


fidomshlak hoffmann sabharwal

first consider encoding conditions definition every surviving
precondition goal clause corresponding clause
condition concerning facts added action precondition
goal clause contains sub clause corresponding clause finally
surviving mutex clauses condition present mutex clause
observations follows every surviving clause contains possibly
non strict sub clause corresponding clause applying proposition obtain
rc rc finishing proof encoding
consider encoding b first definition p g p p g p
identical sets vertices particular fact vertices f hence
surviving initial state clause present initial state clause precondition clauses binary condition definition surviving
precondition clause present precondition clause similarly
goal clause unit clause condition surviving goal clause
present goal clause similar vein surviving mutex clause
present mutex clause finally surviving effect clause condition
contains sub clause corresponding effect clause hence see
every surviving clause contains possibly non strict sub clause corresponding clause applying proposition obtain rc rc
finishing proof encoding b
proof lemma let p task abstraction respects
behavior specified lemma applied four conditions
definition hold p g p p gred p observe condition
definition trivially holds property b therefore focus showing
v p g p v p g p v p gred p v p gred p conditions
definition hold fact p g p p gred p set
vertices original reduced graph conditions definition
would immediately satisfied due properties c would
remain would condition saying mutex clauses added applying
hence task reduced proving following four properties hold
step b task
f f
ii
iii ef mutex f ef mutex

iv ea mutex
ea mutex

f ef mutex ea mutex denote sets facts actions including
noops fact mutexes action mutexes generated p step versions
denote corresponding sets p f ef mutex denotes f f
one needs add lists shrink applying however another argument
shortly require add lists grow justifying strict requirement property c



fifriends foes satisfiability abstract cnf encodings


ef mutex f f subset ef mutex restricted facts ea mutex


defined similarly
order prove four properties hold give inductive argument
alternating f ef mutex one hand ea mutex
base case note f f property
ef mutex f ef mutex sets empty
words goal prove certain facts actions available p
certain step remain available p similarly two facts actions mutually
compatible p remain mutually compatible p seems intuitively justifiable
given properties following argument formalizes intuition terms
notation use pre del add specify actions p pre del add
specify actions p
first part inductive step suppose f f ef mutex f

ef mutex ea mutex
ea mutex inductively
proving conditions ii iv
let pre f f f f pre pre
f f f ef mutex ef mutex f hence f f ef mutex
therefore proving
let ea mutex reduced graph

due properties
direct mutexes immediately ea mutex

c done proving ea mutex ea mutex otherwise
general mutexes several things hold first pre pre f f
likewise del del del del finally
property c add add hence c pre add del
pre add del last equality holds ea mutex similarly
c pre add del finally f pre pre f f
f pre pre f f f f ef mutex
ef mutex f implies c f f ef mutex c c c


ea mutex
proving ea mutex
ea mutex

second part inductive step suppose ea mutex



ea mutex f f ef mutex f ef mutex
proving conditions iii


let f f f aa add aa add recall noop
actions included need explicitly include f f
follows f f proving f f
let f f f f f ef mutex must exist

c f add add c f add add


ea mutex ea mutex
implies c ea mutex




c c c f f ef mutex proving ef mutex
f ef mutex
finishes inductive argument showing conditions iv outlined
hold earlier reasoning proves vertices p g p p g p
well reduced counterparts conditions
definition follow directly properties c mutex relations
p red p restricted facts actions p subset mutex relations



fidomshlak hoffmann sabharwal

reduced mutex relations respectively p condition definition
holds hence abstracts graph well reduced graph
p
proof lemma let abstraction removes p initial facts
add lists given task p p appear goal facts
pre del lists proof lemma let denote propositional
encodings p p respectively use one encodings b c
encodings c fact
identical encodings b differ clauses cannot part
resolution proof
end use graph notation proof lemma
begin arguing induction f f p ef mutex ef mutex p p

p f ea mutex
ea mutex base case

f f p definition ef mutex ef mutex p p p f
sets empty first part induction suppose
inductive conditions f ef mutex hold time step since p pre list
implies well since p del list

ea mutex
ea mutex hence conditions ea mutex hold time step
second part induction suppose inductive conditions
ea mutex hold time step implies f consists f possibly
p ef mutex ef mutex far mutexes involving
p concerned follows conditions f ef mutex hold time step
finishing induction

summarize shown every step sets ea mutex ea mutex
exactly sets f f ef mutex ef mutex facts
pairs facts involving p words actions facts become available mutually excluded graph everything involving p remains
unchanged given observe four encodings goal precondition clauses p exactly p p appear goal

pre lists similarly ea mutex
ea mutex ef mutex ef mutex

implies action mutexes p fact mutexes present encoding
p well therefore encodings c
finally encodings b initial state effect mutex clauses
get removed applying e present however
clauses mention propositional variables corresponding p
variables appears one polarity throughout namely initial state clause
p clause may contain p positive polarity effect mutex clauses
contain p time index clauses cannot part
resolution refutation every variable appearing resolution refutation must
eventually resolved away order derive empty clause follows
respect resolution refutations
proof lemma let p task variable domain abstraction
applied combines two persistently mutex facts p p single fact p
brevity let g denote p g p define g graph obtained unifying p


fifriends foes satisfiability abstract cnf encodings

p fact vertices fact layer g single vertex p layer similarly
noop p noop p vertices action layers finally let g denote subgraph
p g p induced vertices g g abstracted
graph sense similar definition
begin arguing action pair mutex p mutex
p see observe way become mutex per requires
w l g p p del pre p pre add suppose sake
contradiction already mutex p particular means
p del p mutex fact pre however implies
noop p mutex p fact pair p p mutex next layer
p g p contradiction p p persistently mutex follows edges
ea mutex g subset g
since g p initial facts argument implies actions
facts available layer g available layer p g p particular
g construction exactly set vertices g since variable
domain abstraction edges eadd epre g g exactly
define u proof lemma cnf encoding
graph g clauses corresponding actions facts
g trivially satisfied call remaining clauses surviving clauses

observation edges ea mutex g g surviving mutex clauses
mutex clauses surviving precondition goal clauses involving
p appear unchanged since considering variable domain abstraction
actions achieving p g precisely actions achieving p p g hence
surviving precondition goal clauses involving p contain sub clause
precondition goal clause follows proposition rc
rc
proof proposition example task denoted p works
encoding c encoding let denote variable domain abstraction applied
example uses following six facts facts p p glued together
goal facts g g helper facts x facts task p defined
follows
initial state p goal g g
action set containing five actions
getx p x p
gety
getg x g p x
getg p g p
getp p p p
plan length bound makes infeasible shortest parallel
plan requires steps h getx gety getg getp getg observe pairs
actionsexcept getg getg pair involves getydirectly interfere


fidomshlak hoffmann sabharwal

therefore mutex p g p get following fact action sets
step
f p noop p getx gety
f p x noop p noop x noop getx gety getg getg
f p x g g p
easy verify iteratively p g p p x mutex f p x
mutex f p p mutex f x p mutex f mutexes
get f graph reaches fixpoint particular
getg getg indirectly mutex preconditions x p
persistently mutex variable domain abstraction glue p p converting
conflict getg getg direct interference thereby allowing shorter
resolution refutation
consider encoding c p g p contains two goal clauses getg
getg clauses clearly must used resolution refutation formula possible achieve goal individually within given time bound
together hence shortest refutation must involve least two steps
argue shortest refutation achieved abstracted task p
p
p get fact action sets graph except f
p x g g e p course present contain getp
acts similarly noop p corresponding encoding c consists exactly
clauses plus clauses noop p mirrored getp except
get additional clause getg getg mutex clauses arises
getg interferes directly getg rather indirectly incompatible preconditions getg adds p instead p p deleted getg yields
trivial two step tree resolution proof p two goal clauses mutex
clause namely resolve second goal clause mutex clause deriving getg
resolve clause first goal clause hand original
task p getg getg marked mutex layer dont directly
interfere therefore corresponding mutex clause immediately available
resolution proof takes two steps must reason involve x
encoding works similarly lets us derive mutex clause discussed
goal clauses case simply g g
two corresponding effect clauses derive two goal clauses encoding c two
steps two step refutation discussed derives empty clause thus
four step resolution refutation p encoding similarly small
resolution refutation p refutation must mentioned earlier
reason x figure getg getg cannot true
proof theorem construct family strips tasks whose cnf encodings
similar pigeon hole formula php well known
resolution proof php must size exponential haken concretely
php unsatisfiable formula encoding fact way assign


fifriends foes satisfiability abstract cnf encodings

pigeons holes pigeon assigned least one hole hole gets
one pigeon formula variables xp h p h
pigeon p pigeon clause xp xp xp n pair
pigeons p q hole h hole clause xp h xq h
pigeon hole task pp hp defined follows pigeon p
fact assigned p hole h fact free h initial state contains free
facts assigned facts goal state contains assigned facts available
actions noops put p h puts pigeon p free hole h
h longer remains free formally put p h free h assigned p free h
plan length bound b set
consider one four encoding methods let encoding
pp hp restrict setting noop variables false real restrictive
implication terms since plan length bound none goal facts
available time step action encodings c identifying
action variables put p h php variables xp h immediately yields precisely
clauses php goal clauses become pigeon clauses php
action mutex clauses become hole clauses action fact encodings b
fix free fact variables time step well assigned fact variables time step
true identify put p h action variables xp h yields precisely
clauses php follows resolution hardness php proposition
resolution proof fact task pp hp plan
length must require size exponential
claim follows task p consists combination two
disconnected pigeon hole sub tasks pp hp pp hp two separate sets
pigeon hole objects goal p naturally defined follows put first
set pigeons first set holes put second set two pigeons
second set holes consists single hole overall cnf encoding
p logical conjunction encodings disjoint sets
variables pp hp pp hp observe proved unsatisfiable
proving unsatisfiability two pigeon hole particular
constant size resolution refutation involves refuting component
hand argue listed abstractions make one hole
component p trivially satisfiable resolution refutation abstracted
task must resort proof unsatisfiability hole component p
shown requires exponential size hence single example p serves
claim combinations abstraction method cnf encoding
easily verified pp hp becomes solvable ignoring precondition
free put put put pigeons single hole
happens ignoring delete effect free put put
ignoring goal assigned inserting assigned initial state
completely removing assigned one hole component p requires assign
one pigeon course possible finally variable domain abstraction note
assigned assigned persistently mutex pp hp actions
achieving put put respectively according definition
hence replace assigned assigned resulting task


fidomshlak hoffmann sabharwal

single goal assigned achieved step example put action
concludes argument
proof proposition first consider removal duplicate actions example task denoted p works four encodings p defined follows
fact set r r g g g
initial state r r goal g g g
action set containing seven actions
r g r
r g r
r g r
r g r
r g r
r g r
help g g g
task actions applicable initial state consume one
two resources r r actions achieves one goals pair
goals reached three solution perform two steps
second help action serves accomplish g set plan length
bound
graph p g p step mutex relations direct
mutexes actions competing resource hence encoding identical
encoding c encoding b identical encoding properties clearly
hold task p p except additional action
identical
consider encoding p goal clauses
clauses mutex clauses form j k
difficult verify shortest resolution refutation involves steps one
derivation proceeds via deriving
derived sequence steps involving resolution
one mutex clause p thing changes clause
instead plus additional mutex clauses
obviously every resolution refutation must resolve three goal clauses end
empty clause hence additionally need get rid literal clearly
way resolve literal away additional step involving
one mutex clauses hence shortest possible resolution refutation
steps
encoding b resolution proofs first need make three steps resolving goal
clauses g g g respective effect clauses g
g g thereafter matters

claim removal redundant add effects slightly modify example
define p follows


fifriends foes satisfiability abstract cnf encodings

fact set r r g g g x
initial state r r goal g g g
action set containing eight actions
r g r
r g r
r g r
r g r
r g r
r g r
help g g x
help x g
task single help action replaced two help actions need
applied consecutively set plan length bound graph
p g p mutex relations direct mutexes actions competing
resource encodings c b respectively identical
properties clearly hold task p p except help
additional add effect g
consider encoding p goal clauses noop g
noop g noop g refuting involves showing
three goals cannot achieved step step combination
two refutation needs resolve three clauses p get
additional literal first clause help noop g
clearly getting rid additional literal involves least one resolution step
encoding b matters essentially except first need resolve goal
fact clauses respective effect clauses

references
ball majumdar r millstein rajamani automatic predicate abstraction c programs pldi programming language design implementation pp
beame p kautz h sabharwal towards understanding harnessing
potential clause learning journal artificial intelligence
beck c hansen e nebel b rintanen j eds proceedings th
international conference automated scheduling icaps aaai
press
blum furst fast graph analysis artificial
intelligence
blum l furst l fast graph analysis
mellish ed proceedings th international joint conference artificial
intelligence ijcai pp montreal canada morgan kaufmann


fidomshlak hoffmann sabharwal

boddy fox thiebaux eds proceedings th international
conference automated scheduling icaps aaai press
bonet b geffner h heuristic search artificial intelligence

bonet b geffner h heuristics penalties rewards formulated logic computed circuits artificial intelligence

brafman r reachability relevance resolution satisfiability journal artificial intelligence
chaki clarke e groce jha veith h modular verification software
components c icse int conf software engineering pp
chen huang r xing z zhang w long distance mutual exclusion
artificial intelligence
clarke e biere raimi r zhu bounded model checking
satisfiability solving formal methods system design
clarke e grumberg jha lu veith h counterexample guided
abstraction refinement symbolic model checking journal association
computing machinery
davis logemann g loveland machine program theorem proving
communications acm
davis putnam h computing procedure quantification theory journal
association computing machinery
edelkamp pattern databases cesta borrajo eds
recent advances ai th european conference ecp
pp toledo spain springer verlag
edelkamp promela ball rajamani eds proceedings
th international spin workshop model checking software spin
pp portland springer verlag
edelkamp helmert exhibiting knowledge minimize state encoding length biundo fox eds recent advances ai
th european conference ecp lecture notes artificial
intelligence pp durham uk springer verlag
ernst millstein weld automatic sat compilation pollack ed proceedings th international joint conference
artificial intelligence ijcai pp nagoya japan morgan kaufmann
fikes r e nilsson n j strips application theorem
proving solving artificial intelligence
gerevini saetti serina stochastic local search
temporal action graphs journal artificial intelligence


fifriends foes satisfiability abstract cnf encodings

graf sadi h construction abstract state graphs pvs cav
computer aided verification pp
gupta strichman abstraction refinement bounded model checking
etessami k rajamani eds proceedings th international conference
computer aided verification cav lecture notes computer science pp
edinburgh uk springer verlag
haken intractability resolution theoretical computer science

haslum p geffner h admissible heuristics optimal chien
kambhampati r knoblock c eds proceedings th international conference artificial intelligence systems aips pp breckenridge co aaai press menlo park
haslum p botea helmert bonet b koenig domain independent
construction pattern database heuristics cost optimal proceedings
twenty second aaai conference artificial intelligence aaai pp
aaai press
helmert mattmuller r accuracy admissible heuristic functions selected domains proceedings rd aaai conference artificial
intelligence pp chicago il aaai press
helmert haslum p hoffmann j flexible abstraction heuristics optimal
sequential boddy et al boddy fox thiebaux pp
henzinger jhala r majumdar r mcmillan k abstractions proofs
popl principles programming languages pp
hernadvolgyi holte r psvn vector representation production systems
tech rep university ottawa
hoffmann j edelkamp deterministic part ipc overview journal
artificial intelligence
hoffmann j nebel b system fast plan generation
heuristic search journal artificial intelligence
hoffmann j ignoring delete lists works local search topology
benchmarks journal artificial intelligence
hoffmann j gomes c selman b structure hardness goal asymmetry dpll proofs sat logical methods computer science

hoffmann j sabharwal domshlak c friends foes ai
perspective abstraction search long smith long smith pp

katz domshlak c structural pattern heuristics via fork decomposition
beck et al beck hansen nebel rintanen pp


fidomshlak hoffmann sabharwal

kautz h selman b unifying sat graph pollack ed proceedings th international joint conference artificial
intelligence ijcai pp stockholm sweden morgan kaufmann
kautz h satplan satisfiability edelkamp hoffmann
j littman younes h eds proceedings th international
competition ipc whistler bc canada
kautz h selman b hoffmann j satplan satisfiability
gerevini dimopoulos haslum p saetti bonet b givan b eds
proceedings th international competition ipc ambleside uk
kautz h mcallester selman b encoding plans propositional logic
aiello l c doyle j shapiro eds principles knowledge representation
reasoning proceedings th international conference kr pp
cambridge morgan kaufmann
kautz h selman b satisfiability neumann b ed
proceedings th european conference artificial intelligence ecai
pp vienna austria wiley
kautz h selman b pushing envelope propositional logic
stochastic search proceedings th national conference american
association artificial intelligence aaai pp portland mit
press
knoblock c learning abstraction hierarchies solving proceedings
th national conference american association artificial intelligence
aaai pp boston mit press
koehler j nebel b hoffmann j dimopoulos extending graphs
adl subset steel alami steel alami pp
koehler j hoffmann j reasonable forced goal orderings use
agenda driven journal artificial intelligence

long kautz h selman b bonet b geffner h koehler j brenner
hoffmann j rittinger f anderson c r weld smith e fox
aips competition ai magazine
long smith eds icaps proceedings th international conference automated scheduling icaps ambleside uk morgan
kaufmann
mcdermott regression match graphs control search artificial intelligence
meuleau n brafman r benazera e stochastic subscription
hierarchies mdps long smith long smith pp
nebel b dimopoulos koehler j ignoring irrelevant facts operators
plan generation steel alami steel alami pp


fifriends foes satisfiability abstract cnf encodings

prasad r biere gupta survey recent advances sat
formal verification international journal software tools technlogy transfer

ray k ginsberg l complexity optimal efficient
method finding solutions beck et al beck et al pp
rintanen j evaluation strategies satisfiability saitta l ed
proceedings th european conference artificial intelligence ecai pp
valencia spain wiley
rintanen j graphs propositional clause learning brewka g
doherty p eds principles knowledge representation reasoning proceedings th international conference kr pp sydney australia
aaai press
rintanen j heljanko k niemela satisfiability parallel plans
plan search artificial intelligence artificial intelligence

robinson j machine oriented logic resolution principle journal
association computing machinery
robinson n gretton c pham n sattar compact efficient sat
encoding beck et al beck et al pp
sacerdoti e hierarchy abstraction spaces proceedings
rd international joint conference artificial intelligence ijcai pp
stanford ca william kaufmann
sanchez r kambhampati graph heuristics selecting objectives subscription biundo myers k rajan k
eds proceedings th international conference automated
scheduling icaps pp monterey ca usa morgan kaufmann
steel alami r eds recent advances ai th european conference ecp vol lecture notes artificial intelligence
toulouse france springer verlag
streeter smith decision procedures efficiently optimization
boddy et al boddy et al pp




