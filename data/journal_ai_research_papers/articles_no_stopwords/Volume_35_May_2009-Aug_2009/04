journal artificial intelligence

submitted published

modularity aspects disjunctive stable
tomi janhunen
emilia oikarinen

tomi janhunen tkk
emilia oikarinen tkk

helsinki university technology
department information computer science
p box tkk finland

hans tompits
stefan woltran

tompits kr tuwien ac
woltran dbai tuwien ac

technische universitt wien
institut fr informationssysteme
favoritenstrae vienna austria

abstract
practically programming languages allow programmer split program
several modules brings along several advantages software development
interested area answer set programming fully declarative
nonmonotonic languages applied context obtaining modular structure
programs means straightforward since output entire program cannot
general composed output components better understand effects
disjunctive information modularity restrict scope analysis case
disjunctive logic programs dlps subject stable model semantics define notion
dlp function well defined input output interface provided establish
novel module theorem indicates compositionality stable model semantics
dlp functions module theorem extends well known splitting set theorem
enables decomposition dlp functions given strongly connected components
positive dependencies induced rules setting possible split
shared disjunctive rules among components generalized shifting technique
concept modular equivalence introduced mutual comparison dlp functions
generalization translation verification method

introduction
practically programming languages used software development allow programmer
split program several modules interact well dened input output
interfaces given entire program viewed composition component modules typically linked together respective run time environment
expected benets modular program development manifold first imposes
good programming style followed programmer complex software system
much easier develop set interacting components rather monolithic program second modular architecture allows additional exibility regards delegating
programming tasks amongst team programmers setting goal programmer implement desired input output behavior terms concrete module
together implement software system developed third modular program
c

ai access foundation rights reserved

fijanhunen oikarinen tompits woltran

design exploited order boost execution programs program optimization facilitated structural information encompassed module interfaces
answer set programming asp marek truszczyski niemel gelfond
leone paradigm declarative solving solutions
described terms rules subject nonmonotonic semantics stable
gelfond lifschitz typical representations tight correspondence
solutions stable sought default negation fully exploited
order obtain concise encodings relations involved descriptions
furthermore recursive denitions enable e g representation closures relations
natural way due ecient implementations emerging applications
paradigm received increasing attention past two decades meantime
number extensionssuch disjunctions weight constraints aggregateshave
proposed basic syntax normal logic programs concentrate
class disjunctive logic programs dlps appropriate solving search
residing second level polynomial time hierarchy semantical account
dlps respective generalization stable model semantics gelfond
lifschitz
goal investigate modularity context dlps stablemodel semantics since stable dened complete programs
lend modular programming prima facie perhaps reason concept
module yet raised much attention realm answer set programming
except dedicated papers gaifman shapiro eiter gottlob veith b
baral dzifcak takahashi modules mostly appeared product studies
formal properties stratication splitting lately work equivalence
relations programs lifschitz turner eiter gottlob mannila
eiter ianni lukasiewicz schindlauer tompits recent oikarinen
janhunen modular architecture put forth gaifman shapiro
accommodated classes normal smodels programs main
module theorem links stable associated individual modules
composition signicant indicates stable
compositional much sense classical propositional logic
major restriction implied module theorem denition set
positively interdependent atoms must given within module
besides general benets modular program development discussed
looking potential computational advantages modularizing reasoning tasks asp
context search stable probably central reasoning task
module theorem discussed provide basis modularizing
search task extra care however required computation stable
modules separation necessarily ecient sophisticated methods
identifying cones influence boolean circuits junttila niemel devised
identify modules relevant search stable modelsthe rest used
expand qualied stable model one entire program strategy alleviates
treatment extremely large program instances amenable query evaluation
th anniversary stable model semantics celebrated iclp held udine
italy december



fimodularity aspects disjunctive stable

unfortunately contemporary disjunctive answer set solvers claspd drescher
et al cmodels giunchiglia lierler maratea dlv leone et al
gnt janhunen niemel seipel simons exhibit little support modular
reasoning although related techniques strongly connected components exploited internally reasoning tasks boosted modular
instance optimization answer set programs gives rise verifying
whether dierent versions programs answer sets demonstrated
oikarinen janhunen verication tasks may benet modularization
particular approximation techniques modular equivalence introduced
following idea rst modular line optimizer answer set programs called modopt recently implemented janhunen b
interesting applications modules sight gebser et al
propose incremental technique answer set solving idea gradually extend
program instance terms additional modules e g solving ai
moreover theoretical splitting set theorem lifschitz turner
module theorem directly exploited correctness proofs instance proved
oikarinen janhunen b prioritized circumscription
captured disjunctive stable particular translation similar proof
strategy adopted theorem
anticipate compositional semantics prove useful one tries boost
search stable via parallelization e g computing stable modules
parallel however order avoid excessive communication costs extra caution needed
stable computed separation linked together potentially rejected
one possibility identify mutually independent modules basis distribution
besides aspect modularization may lead novel methods non parallelized
computation stable traditional ones
structure preview concentrate formal underpinnings modular programming context disjunctive logic programs
stable model semantics proceed follows rst goal generalize theory
developed normal programs smodels programs oikarinen janhunen
case disjunctive programs end rst introduce notion dlpfunction section term goes back gelfond gabaldon introduced
lp functions partial denitions relations terms old known ones enable functional view disjunctive programs endowed well dened
input output interface idea partition signature program encapsulated
way input atoms output atoms hidden local atoms distinctions
provide basis systematic composition larger disjunctive logic programs
program modules however arbitrary combinations program modules meaningful rst adopt syntactic restrictions introduced gaifman shapiro
context negation disjunction free logic programs interplay default negation disjunctions brings along factors lead relaxation
restrictions sense program modules allowed share rules
basic syntactic issues dlp functions laid concentrate semantics
section respect follow strict model theoretic particular


fijanhunen oikarinen tompits woltran

address role input atoms comes viewing dlp functions mathematical
functions proceed step step assign three dierent classes
dlp function viz classical minimal stable last provides
appropriate generalization disjunctive stable gelfond lifschitz
presence input atoms
second objective establish adequacy concept dlp function
view compositional semantics witnessed main
viz module theorem shows stable dlp function
alternatively obtained unions compatible stable modules constituting
proof theorem notions completion clark loop
formulas lin zhao lee lifschitz rst lifted case dlpfunctions section preparatory step proof module theorem follows
main topic section non trivial underlying semantics
stable inherently nonmonotonic feature already recognized gaifman
shapiro much simpler setting denite programsneither involving default
negation disjunctions observed syntactic restrictions program
composition necessary order guarantee compositionality properties semantics
herbrand current strive analogous
case programs permitting default negation disjunctions turns
strongly connected components positive dependency graphs provide key criterion
comes conning program composition compositionality properties disjunctive
programs stable model semantics arisen context called
splitting set theorem lifschitz turner eiter et al fact
module theorem established herein proper generalization predecessor oikarinen
janhunen illustrate potential modular architecture evaluation
quantied boolean formulas qbfs serve canonical representatives classes
polynomial time hierarchy ph due basic complexity established eiter
gottlob natural perspective concentrate second level
ph case disjunctive programs
third aim look particular applications module theorem disjunctive logic programming section take opposite view
modular construction dlp functions consider possibilities decomposition
even absence structural information turns strongly connected
components exploited respect addition occurrences hidden
atoms must taken account splitting dlp function components
demonstrated section open prospects regards unwinding disjunctions
principle shifting gelfond przymusinska lifschitz truszczyski dix
gottlob marek eiter fink tompits woltran proper generalization
principle partially covers programs involving head cycles formulated
proved correct moreover due modular nature dlp functions makes perfect
sense compare modules notion modular equivalence introduced
purpose section interestingly modular equivalence supports substitutions equivalent
programs lends translation verification put forth oikarinen
main concern gaifman shapiro modularity respect logical consequences
definite program hence intersection herbrand



fimodularity aspects disjunctive stable

janhunen related cases ordinary equivalence smodels programs section contrasts related work finally section provides
brief summary concludes

class dlp functions
topic section syntax dlp functions well syntactic restrictions
imposed composition dlp functions disjunctive rule expression form
b bm c ck



n k b bm c ck propositional atoms since
order atoms considered insignicant write b c shorthand rules
form b b bm c c ck respective
sets atoms basic intuition behind rule b c atom
positive body b inferred none atoms negative body c
atom head inferred b c empty disjunctive
fact written empty constraint written b c
disjunctive logic program dlp conventionally formed nite set disjunctive
rules additionally want distinguished input output interface dlp
end extend denition originally proposed gaifman shapiro case
disjunctive programs natural interface imposes certain restrictions
rules allowed module given set r disjunctive rules write r
signature r e set ground atoms eectively appearing rules r
definition dlp function quadruple hr hi h
pairwise distinct sets input atoms output atoms hidden atoms respectively r
dlp rule b c r
b c h
h
dlp function hr hi occasionally identied r slight abuse
notation write b c denote b c r rst condition
denition rules dlp function must obey interface specication
e r h regards sets atoms h involved module
interface atoms considered visible hence accessible
dlp functions conjoined produce input utilize output
hand hidden atoms h used formalize auxiliary concepts
may make sense context dlp functions may save space
substantially demonstrated e g janhunen oikarinen example
second condition denition concerned set atoms h defined
rules r principle non empty disjunctive head must involve least one
atom h ensure dlp function must interfere
similar approaches within area asp previously introduced gelfond gabaldon
janhunen oikarinen janhunen



fijanhunen oikarinen tompits woltran

denitions input atoms terms rules b c satisfying
otherwise rules may conditioned input atoms given set atoms
distinguish set rules dene atoms r e set defining rules
def r b c r



next objective specify conditions composition dlp functions
may take place roughly speaking idea larger dlp functions formed
modular fashion smaller dlp functions components observed already
gaifman shapiro syntactic restrictions program composition necessary
order guarantee compositionality properties semantics herbrand even simple case denite programs thus program union operator
composition without restrictions satisfactory respect compositionality
start adapting construction gaifman shapiro case
disjunctive programs
definition two dlp functions hr h hr h respect input output interfaces
h h
h h

def r def r r
def r def r r
rst three conditions due gaifman shapiro
imply sets h h mutually pairwise distinct violations
respect rst two conditions circumvented renaming strategy
instance atom h appears h hence violating second condition
possible replace occurrences atom h
appearing removes conict respect forth
hand last two conditions denition concern distribution
rules involved definitions sets atoms e sets rules
def r def r r r respectively regards disjunctive rules
principle sets dening rules must remain intact union r r
formed means module supposed copies rules form
denition output atoms spite two modules subject
conditions denition may eectively share disjunctive rules b c
non empty head demonstrated next
particular input atoms head rule act much atoms negative body c
opposite view program composition considered section possibilities decomposing disjunctive program smaller dlp functions studied counterpart renaming
revealing operator introduced definition used circumventing first two conditions
definition



fimodularity aspects disjunctive stable

example consider following two dlp functions
b
b c

c




b c
e e
b c

formally hr c b hr b c e
r r b c respect input output interfaces
first hidden atoms e occur exactly one two programs
thus first two conditions definition satisfied second disjoint output
atoms viz atom b atom finally def r b def r r b
def r def r r b c shows final two conditions
definition satisfied far syntax concerned makes sense compose
larger dlp function obtained kind union see
contrast disjunctive programs shared rules arise context normal
logic programs since one head atom allowed rule stated
smodels programs simons niemel soininen although programs
may contain among rule types choice rules form
b c



heads cardinality greater one observed oikarinen janhunen
heads choice rules possessing multiple atoms freely split without aecting
semantics splitting rules n dierent rules ai b c
n concern creation n copies rule body b c could
reserve quadratic space worst case atom introduced circumvent
nature proper disjunctive rules subject study
somewhat dierent unlike choice rules disjunctive rules may interact rule heads
example denition depends b vice versa however given choice rule
b c instance choices regarding b independent c
true atoms truth value quite dierent interpretation
ab c makes b true given c true grasp interaction
b natural b input denition conversely input
b demonstrated section shared rules rewritten input atoms
removed rule head drawback rewriting technique compactness
representation partly lost therefore appreciate extra exibility provided
shared rules interpret reect true nature disjunctive rules
general dlp functions composed according following principle

henceforth make use tabular format represent dlp functions output signature
given top input signature bottom rules listed thus
declaration hidden signature remains implicit



fijanhunen oikarinen tompits woltran


l


h

h










h







h





figure treatment signatures composition operator
definition composition let hr h hr h
two dlp functions respect input output interfaces composition defined determined
hr r h h



treatment atom types denitions summarized figure
two symmetric gures left hand side illustrate signatures dlp functions
hr h hr h subject composition input signatures
output signatures emphasized light gray dark gray shadings respectively
superposition two gures yields diagram given right represents
resulting nine categories atoms three may involve shared atoms
originate interface conditions introduced intuitive
readers acquainted principles object oriented programming
although must share hidden atoms may share input atoms e
allowed output atoms treated dierently assumed
input atom becomes output atom appears output
atom e provides input setting input atoms
treated symmetric fashion
hidden atoms retain status
example recall example showed dlp functions respect
input output interfaces thus composition defined
hr r hi set input atoms c b c b
c set output atoms b b set h hidden atoms
e e e tabular format represent modules
b
b c

c




b c
e e
b c



b
b c

e e
c

definitions b share rule b c thanks flexibility
definition able split components whenever appropriate


fimodularity aspects disjunctive stable

following previous approaches gelfond gabaldon oikarinen janhunen
dene signature dlp function hr hi h
notational convenience distinguish visible hidden parts setting
atv ath h atv respectively moreover ati
ato used refer sets input output atoms respectively
notations provide us way access module interface left implicit e g
neglect internal structure modules lastly set atoms denote projections ati ato atv ath si sv sh
respectively
formal terms dlp function hr hi designed provide mapping
subsets set subsets h analogy lp functions formalized
gelfond gabaldon however exact denition mapping deferred
section semantics dlp functions anchored sequel
syntactic class dlp functions denoted assumed sake simplicity
spans xed denumerable signature
holds dlp function given dlp functions pairwise
respect input output interfaces holds
closure
empty dlp function h identity
commutativity
associativity
theory modules put forth oikarinen janhunen
restrictive operator program composition viz join idea behind operator
forbid positive dependencies programs explicated next
technically speaking dene positive dependency graph dg dlp function
hr hi positive dependenciesfollowing denition ben eliyahu
dechter however exclude input atoms graph denitions
external anyway thus let dg ho h b holds
pair atoms b h rule b c r
b b reexive transitive closure gives rise dependency relation
ato ath strongly connected component scc graph dg
maximal set ato ath b every pair b atoms given
dened say mutually dependent dg
scc ato ato oikarinen janhunen
e component shared dlp functions way
mutually dependent call mutually independent
definition joins given two dlp functions composition
defined mutually independent join
defined coincides
consequently length symbols denoted kk gives upper bound
important one considers computational cost translating programs janhunen
practice set could set identifiers names propositions similar objects



fijanhunen oikarinen tompits woltran

case dened thus mutually independent exactly
one following conditions holds scc dg
ato ath



ato ath



example recall programs example obtain
positive dependency graph dg h b e ha di ha ei hence sccs
graph simply singletons b e together observation
ato ato disjoint derive mutually dependent
thus join defined since composition defined
basis analysis performed example
example example two dlp functions composition defined
yet ineligible join consider following situation
b
b c
b c
c




b c
b c
b c



b
b c
b c
b c
c

composition involves scc b respective positive dependency graph non empty intersection output signatures programs
subject composition hence respective join modules question defined

model theory stable model semantics
syntax dlp functions dened turn semantics proceed
three steps introduce correspondingly three kinds viz classical
minimal nally stable dlp function last provide
intended semantics dlp function whereas rst two serve auxiliary concepts
usual interpretation dlp function dened arbitrary subset
given particular interpretation atom true
denoted otherwise false denoted negative
literal dene set l literals satisfied denotedwby
l l everywliteral l l dene disjunctive interpretation l
set l literals l l literal l l
begin cover dlp functions pure classical semantics treats
disjunctive rules classical implications emphasized classical
dlp function specic interpretations dened hence subsets
definition interpretation classical model dlp function
hr hi denoted iff r e every rule b c r
w
b c implies


fimodularity aspects disjunctive stable

set classical denoted cm
classical provide appropriate level abstraction address role input
atoms dlp functions given dlp function interpretation
projection mi viewed actual input may may produce
respective output mo depending semantics assigned treatment input
atoms sequel partial evaluation idea pre interpret input
atoms appearing respect mi
definition dlp function hr hi actual input mi
instantiation respect mi denoted mi quadruple hr hi
r contains reduced rule
b c



rule b c r mi ai bi ci
example consider following dlp function
b
b c
c b
b c
c
actual input c ati reduct c dlp function
h b b b
hand actual input ati obtain reduct
h b b
rules form free input atoms indicates reduct mi
dlp function without input atoms ato ath aected mi
proposition let dlp function interpretation defines
actual input mi ati interpretations n ni mi
n nh mi
proof consider n ni mi
suppose n assume nh satisfy rule
b c follows mi ai bi ci therefore ni ai bi ci
thus n b c contradiction follows nh mi
let nh w mi hold assuming n b c rule implies
n b c n follows ni ai bi ci corresponding
rule included mi ni mi rule satised nh since


fijanhunen oikarinen tompits woltran

w
n b c implies nh b c nh
contradiction hence n

thus input reduction given denition fully compatible classical
semantics characterize semantic operator cm terms equation

mi n n cm mi

cm
mi ati

recall dlp function subsets hence
n cm mi subset mi thus mi n mi ati
since atom ati occurs mi denition
handling input atoms slightly complicated case minimal
primitives parallel circumscription lifschitz mccarthy provide us
straightforward way address rough idea keep interpretation input
atoms fixed minimizing e falsifying others far possible
definition let hr hi dlp function model
minimal iff model n ni mi n
sequel set minimal hr hi denoted mm
treat input atoms stipulating minimality idea proposition
lifts minimal given fact ati mi
proposition let dlp function interpretation defines
actual input mi ati interpretations n ni mi
n mm nh mm mi
proof consider n ni mi
let n mm follows proposition nh mi assume
nh
mm mi recall ati mi thus interpretation
nh mi follows proposition n
interpretation n mi ni ni n n jointly contradict n mm
suppose nh mm mi nh mi n follows
proposition let us assume n mm e model n
ni ni n n thus nh nh since ni ni mi
follows nh mi proposition however nh mi
contradiction nh mm mi

set mm ati minimal sucient determine semantics
positive dlp function e whose rules form b recall
rules ati holds whenever order cover arbitrary dlp functions
interpret negative body literals way proposed gelfond lifschitz
definition given dlp function hr hi interpretation
reduct respect positive dlp function hrm hi
rm b b c r c




fimodularity aspects disjunctive stable

definition interpretation stable model dlp function
input signature ati iff mm e ati minimal model
hidden atoms play special role denition contrast aect
possibilities program decomposition presented section status
nally explicated notion modular equivalence introduced section
denition covers case ordinary disjunctive logic program simply
dlp function hr model stable
minimal model rm denition stable gives rise semantic operator

sm
dlp functions
sm mm



proposition provides us way dismiss ati minimality denition stable
desirable given stable model projection n mo mh minimal
model mi n hence stable model mi words
mi mi mo mh mi
thus derive following
corollary dlp function
sm mo mh sm mi
example recall dlp function example hidden atoms
given follows
b
b c
c b
b c
c
four stable total b c b c
c minimal respective reducts





h b c c b
h b b c c b
h c c b
h b c c b

easy verify mj c minimal model reduct mj
illustrating corollary recall reducts
c h b b b
h b b
sm c b sm b


fijanhunen oikarinen tompits woltran

immediate observation loose general antichain property stable
input signatures introduced instance
example however since interpretation input atoms xed semantics
perceive antichains locally e set n sm ni mi stable forms
antichain input mi ati example sets stable associated
actual inputs c respectively

characterizations classical logic
well known set stable ordinary disjunctive logic program e
dlp function form hr characterized via classical propositional logic
concepts completion clark loop formulas lin zhao lee
lifschitz section generalize concepts arbitrary dlp functions
end main concern role input atoms incorporate
concepts furthermore extend tightness property programs erdem lifschitz
dlp functions introducing notion tightness section
program completion loop formulas
given dlp function loop non empty subset strongly connected
component positive dependency graph dg recall dg
atoms ato ath nodes particular singleton ato
ath thus loop
example consider dlp functions defined follows



b c
c b
ba




b
c b
ba
c

singleton loops b c particular b loop
contains input atom hand loops b b
follows
use wfor set propositional
w formulas atoms denote
v
conjunction ss shorthand ss moreover appearing within
formula set implicitly understood conjunction elements dlp function
atom ato ath dene set supporting formulas
suppf b c b c
loop l ato ath set externally supporting formulas
esuppf l b c l b c l b l
clarks completion procedure conjunctive loop formulas generalized dlpfunctions following way
definition dlp function completion set formulas


fimodularity aspects disjunctive stable

w
comp b c
w b c
suppf ato ath

set loop formulas
w
lf l esuppf l l ato ath loop

observe case ati e ato ath completion
comp reduces denition provided lee lifschitz holds
set lf loop formulas generally speaking propositional theories comp
lf characterize set sm stable following sense

theorem dlp function interpretation
sm comp lf
proof rst relate sets suppf esuppf l introduced
dlp function respective sets complementary rules
suppcr b c b c
esuppcr l l b c b c l b l
first straightforward interpretation comp
jointly ato ath suppcr quite
similarly holds lf loop l ato ath
esuppcr l hand viewing suppcr esuppcr l
dlp functions signatures apply proposition order
evaluate input atoms thus obtain following relationships dlp function
interpretation atom ato ath loop l ato ath

mo mh mi
suppcr mo mh suppcr mi
esuppcr l mo mh esuppcr l mi
finally recall interpretation ato ato mi
ath ath mi inspecting denition comp lf
conclude interpretation comp lf mo mh
comp mi lf mi turn know mo mh comp mi lf mi
mo mh stable model program mi lee lifschitz
recall mi ordinary disjunctive program without input atoms finally
sm mo mh sm mi corollary equality shows
claim

example let us demonstrate functioning program completion loop formulas dlp functions example e hr b c
hr c b r c b b completions
although may seem case singleton loop l somewhat redundant
since tautological rules b make difference



fijanhunen oikarinen tompits woltran

comp b c b b c b
comp b c b b b c
furthermore sets loop formulas
w
w
lf b esuppf b c esuppf c
b
w c b
w
lf b esuppf b
esuppf
w
b esuppf b
b b c b
last formula w
occurrence view esuppf b
yields empty disjunction esuppf b usual
computing classical comp lf comp yields two
b one check indeed stable
recalling ati thus relates actual input ati
whereas ati hand classical
comp lf c relate two possible
inputs ati c finally note b model comp
ruled lf
tight dlp functions
extend well known concept tightness erdem lifschitz dlpfunctions interest since exploit fact positive dependency
graph dg reduced modulo input atoms words since dependency graph
dg atoms ato ath nodes tightness dlp functions
dened respect input signature
beginning section loops dened arbitrary non empty subsets
strongly connected components dg thus dg acyclic
singleton loops however converse necessarily true since program
singleton loops dg may edges ha ai e cycles length one
definition dlp function ati tight tight short positive dependency graph dg acyclic
example recall dlp functions hr b c hr c b
r c b b example tight since potential
non singleton loop b contains input atom hand c tight
worth mentioning ordinary variant viz dlp function hr b c
tightin particular since r tight usual sense
note last observation viz dlp function hr hi may tight
although r tight program relies use disjunctions program fact
dlp functions hr hi r set normal rules form b c
dlp function hr hi tight r tight verify note
second item denition implies head atom normal rule b c
must appear thus loop may involve atoms


fimodularity aspects disjunctive stable

notion tightness introduced denition enables us
characterize stable dlp function classical completion
since ordinary program represented dlp function thus properly
generalize well known completion semantics clark following lemma
already sucient view denition theorem
lemma tight dlp function lf comp
w
proof recall ato ath suppf contained
comp moreover wsince tight singleton loops thus lf contains
formulas esuppf ato ath remains
atom suppf equivalent esuppf whenever
positive dependency graph dg acyclic repeat denition suppf
give denition esuppf l simplied case l
suppf b c b c
esuppf b c b c b
easy see acyclic dependency graph dg implies b
every rule b c thus conclude suppf esuppf
holds ato ath hence claim follows

example recalling dlp function hr b c example
r c b b obtain
comp b
w c b b cw b
lf b esuppf b c esuppf c
b c b
tight observe lf comp expected
observations presented far lead us following
theorem tight dlp function interpretation
sm comp
particular compatible existing characterization stable
case ati e ato ath notion ati tightness coincides ordinary tightness denition completion comp
reduces one provided lee lifschitz

compositional semantics
follows objective establish main e
stable model semantics given denition fully compositional larger
dlp functions formed joins n dlp functions precisely
interconnection sm sm sm n explicated section analogy


fijanhunen oikarinen tompits woltran

section follow quite rigorous consider relationship classical
rst minimal eventually cover case stable
comprises module theorem section use quantied boolean formulas
second level polynomial hierarchy modular representation terms
dlp functions illustrate module theorem finally devote section
comparison splitting set theorem proven lifschitz turner
module theorem
begin formalize criteria combining interpretations well
definition given two dlp functions interpretations
mutually compatible respect compatible
atv atv



according two compatible interpretations respectively agree truth values joint visible atoms atv atv
quick inspection figure reveals three cases may arise join
dened joint output atoms thereafter disallowed may exist
joint input atoms ati ati ati
atoms ato ati output atoms input atoms
symmetry atoms ati ato
recall according denition atoms last two categories end ato
formed atoms atv atv provide basis combine
compatible interpretations
definition let two dlp functions defined
given sets interpretations natural join
respect atv atv denoted
set interpretations

compatible



rst modularity formulated dlp functions classical semantics
dened section combination classical understood
proposition positive dlp functions defined
cm cm
cm



proof consider interpretation projections
respect hr h hr h
follows compatible


fimodularity aspects disjunctive stable

cm




r r
r r
cm cm
cm
cm



generalizing proposition stable dlp functions much elaborate
cover case positive dlp functions minimal rst proof
theorem exploits program completion loop formulas well characterization
stable minimal section follows
lemma dlp functions defined following
conditions hold
comp comp comp
lf lf lf




proof begin proof analyzing formulas introduced clarks completion
loop formulas related joins dlp functions end establish
sets formulas associated directly obtained unions sets
formulas associatedwwith hr h hr h first
implication b c belongs comp belongs comp
comp case shared rule second let us consider atom h
h h h disjoint dened
reason h h e atom dened thus
def r def r r def r def r r denition
implies suppf w suppf suppf suppf
follows implication

w suppf member comp
w
suppf belongs comp ii suppf
belongs comp thus may conclude completions involved
third recall loop l contained scc
follows denition
l h loop def r l def r r l
l h loop def r l def r r l
cases esuppf l esuppf l w
esuppf l
esuppf l thus respective loop formula l
esuppf l
belongs lf contained lf lf

theorem positive dlp functions defined
mm mm
mm



proof consider respective projections
compatible moreover obtain
following chain equivalences


fijanhunen oikarinen tompits woltran

mm
comp lf
comp lf

comp lf
mm mm
mm
mm

theorem

theorem
denition


example let us demonstrate theorem practical setting dlpfunctions visualized composition hr b c e



b c
b
b
b
c
c e b
e



e
c
e
e
c e b
b c

join defined sccs composition b c
e ati minimal b c b b e
b e likewise calculating mm get
mm b c e b e c e b c e b c e
hence minimal model b e compatibility condition
underlying correctly excludes n b c e mm note support
c true e true accordingly c e b active
prepared present central
theorem module theorem dlp functions
defined
sm sm
sm

proof take interpretation respective compatible
projections consideration proof
number preliminary facts established


composition
dened


since dened know dened indicates


respect input output interfaces construction




aect property implies dened


dened
join



preceding item positive dependency graph dg
dened


let us assume mutually dependent e scc


graph ato
ato since
dependency graph potentially fewer dependencies respective graph



fimodularity aspects disjunctive stable

dg follows contained scc latter



since ato
ato ato ato obtain ato
ato thus mutually dependent contradiction


reduct coincides


rule b belongs rule b c
c equivalently rule b c
c rule b c c e


b
b


therefore get following chain equivalences
sm






mm


mm



mm
mm




mm
mm
sm sm
sm
sm

denition
item
theorem
denition
denition
denition



moral theorem denition stable semantics supports modularization long positively interdependent atoms enforced module
example let dlp functions defined
join clearly defined
b
b
bc
c



c
c
bc
b



b c
b
c
bc


straightforward verify sm b b c b c sm
c b c b c since atv atv b c obtain
sm
sm sm sm b c b c
simple cross check confirms sm indeed given set
example consider dlp functions example sm
b b c sm b c shown example join
undefined thus theorem applicable concerning composition
note sm c b c
b sm
sm
theorem easily extended dlp functions consisting two
modules view say nite sequence mn stable
modules n respectively compatible mi mj pairwise compatible

j n property guarantees mi recovered union
ni mi taking respective projection mi


fijanhunen oikarinen tompits woltran

corollary let n sequence dlp functions join
n defined
sm n sm

sm n



example following example simply extends example
b
b
bc
c



c
c
bc
b


b
ac
b c





b c
b
c
bc


sm b b c b c sm c b c b c
sm b c b c thus learn corollary
sm sm
sm
sm b c b c
modular representation quantified boolean formulas
next objective illustrate theory developed far terms extensive
unsat depicted
example end consider pair dlp functions sat
n n
figure purpose evaluation quantified boolean formulas qbfs
form
n

xy
ai bi ci di



aj bj cj dj set boolean variables parameter n gives
number disjuncts matrix boolean formula insdisjunctive normal
form dnf without loss generality may assume x ni ai bi

n
ci di x hold sets x boolean variables
important point general evaluation qbfs form constitutes p complete decision perfectly matches complexity checking
existence stable disjunctive program given completeness property
follows principle decision p turned qbf form
albeit direct representations obtained particular domains
respect let us address three specic domains prior detailing generic
strategic companies domain identied leone et al one rst
practical domains involving decision second level polynomialtime hierarchy solved asp techniques simplied encoding provided
koch leone pfeifer two kinds disjunctive rules
strat x strat x strat x strat x prod x x x x



strat x ctrl x x x x x strat x strat x strat x strat x



recall shorthands

v

ss



v



ss

introduced right example

fimodularity aspects disjunctive stable

function sat
n

function unsat

n

x
n x ai x act
n x bi x act
n ai bi act
act act n

ci u di act
u
u u
act act n

n


unsat
figure dlp functions sat
n n wfor evaluation quantied boolean formula
xy matrix ni ai bi ci di

predicates strat x prod x x x x ctrl x x x x x respectively
denote company x strategic product produced companies x x
company x controlled companies x x obviously instances
predicate strat arising rules forms create positive dependencies program resulting sccs used split program
modules n n dened theorem status
specic company x decided module denes strat x
rather entire encoding
model diagnosis digital circuitry provides another interesting application
area quite recently oikarinen janhunen b presented ecient encoding
prioritized circumscription disjunctive program thus special case
parallel circumscription well enabling concise representation minimal diagnoses sense reiter resulting disjunctive rules involve head cycles
see section details typically pre empt polynomial time translation
computationally easier normal logic program observation suggests completeness second level polynomial time hierarchy although aware
exact hardness correctness proof encoding exploits two modules
module theorem
finally let us mention gebser schaub thiele usadel veber b identify
minimal inconsistent cores large biological networks disjunctive programs
decision question dp complete indicates appropriateness
disjunctive logic programs representation domain since dp complete decision described independent combination npcomplete decision p conp complete decision p foresee
representation form join sat unsat sat stable model p
succinct certicate unsat unique stable model p succinct


fijanhunen oikarinen tompits woltran

x x
x act
x act
x act x act
x act
x act
x act
x act
x x act
act act act act


u act
u act
u act
u act
u u u u
act act act act

unsat
figure particular instances sat


certicates required dlps worked via reductions propositional
un satisability particular test unsatisability realized analogy
unsat
analyzed
n
general case use boolean variables propositional atoms interchangeably
order describe validity captured dlp functions
unsat explanatory janhunen
figure design sat
n n
et al equivalently viewed formula xy matrix
conjunctive normal form cnf clause ai bi ci di active
whenever ai bi false truth clause becomes dependent ci di
put dually ai bi true truth ai bi ci di depends ci di
validity formula xy captured follows given input interpretation
mi act act n upper dlp function sat
n figure tries explain
activation statuses clauses checking respective theory ai bi
act mi ai bi act mi satisable lower dlp function unsat
plays
n
role conp oracle captures test theory ci di act mi
unsatisable correctness representation provided dlp functions
addressed soon enough understand syntax intuitive meaning
moment concrete qbf instance evaluated follows
unsat figure case qbf
example consider dlp functions sat
n n

x x x x x x x
thus parameter instance n input signature act act
unsat illustrated figure output signature former dlpfor sat

function x x atoms e u remain hidden latter
joint input signature used specify active part matrix dlpfunction sat
provides explanation e assignment variables x x

output whereas unsat
responsible respective unsatisfiability check regards

validity qbf given input interpretation act act act act
yields positive answer respective explanation e output interpretation found
sat
x easy check x true x false remainder
matrix true whatever values assigned hence qbf valid
purposes section interpret disjunctions b sets b b b b
positive negative literals respectively disjunctions elements



fimodularity aspects disjunctive stable

unsat figure identical
regards general dlp functions sat
n n
sat
input signatures n output atoms hidden atoms unsat
fully
n
sat
unsat
respected hence composition n n
dened moreover atoms appearing
rules involve positive dependencies belong disjoint sets x u
unsat cannot scc x
therefore clear dg sat
n n
unsat dened regardless qbf
u implies sat
n n
question let us exploit fact context specic dlp functions example

example four stable dlp function sat

act act act act x act act x x act x
listed decreasing level activation hand dlp function unsat


unique stable model act act act act u e interpretation u
act act act act set rules
unique stable model unsat

given
u u u u u u u u
mi stable input interpretation mi moreover
unsat

unsat combining compatible pairs
may apply module theorem calculate sm sat

one pair
act act act act x sm sat

act act act act u sm unsat


thus act act act act x u unique stable model join sat

sat unsat non empty conclude indeed valid
unsat

since
sm



natural ask stated stable general dlpfunctions unsat
sat
n
n associated qbf xy given stable
sat
model n respective projection mx x determines e holds
n matrix act mx ai bi moreover model
mx minimal sense strictly smaller interpretation n mx
property additional feature brought along minimality stable
consequence dlp function sat
n capture possible truth assignments
variables x relevant truth assignments lost hand stable
indicates respective theory
model unsat
n
ci di n act
w
inconsistent alternatively formula act ci di valid
concerning correctness representation given figure due existing
proof janhunen et al present main stepsfully exploiting benets
modular
unsat non empty
theorem qbf xy form valid iff sm sat
n n

proof sketch consider qbf xy form following equivalent


fijanhunen oikarinen tompits woltran

formula xy valid
minimal interpretation n x set n
n ai bi indices determined n n ai bi ai bi
theory ci di unsatisable
unsat compatible stable n act
dlp functions sat

n n
act u respectively
unsat stable model
dlp function sat
n n

n act u
second item minimality n means n n n
n ai bi assumed without loss generality

theorem module theorem suggest approximation strategy verifying
unsat empty know
validity qbfs form sm sat
n sm n
unsat
directly formula valid otherwise check whether sm sat
n n
splitting sets
sake comparison formulate splitting set theorem lifschitz turner
dlp function hr essentially forms ordinary disjunctive
program splitting sets sets atoms closed following sense
definition given dlp function hr set u atoms splitting set every rule b c r
u implies b c u
denitions sets splitting sets however
one mostly interested non trivial splitting sets u sets
need exist nevertheless splitting set u divides respective set rules r two
parts bottom bu r r respect u contains rules b c r
b c u whereas top tu r r r bu r splitting r
bu r tu r becomes proper one e bu r tu r
u non trivial
every atom least one dening rule b c r
according lifschitz turner solution r respect u pair
hx x u u x sm bu r sm tu r x tu r x
denotes partial evaluation tu r sense denition x u
input interpretation similar idea let us introduce dlp functions corresponding
bu r tu r given splitting set u join b
b hbu r u htu r u u
dened following implied theorem


fimodularity aspects disjunctive stable

corollary splitting set theorem lifschitz turner every
dlp function hr corresponding set r disjunctive rules every splitting
set u every interpretation following conditions
equivalent
stable model
u sm b sm
hm u u solution r respect u
fact theorem strictly stronger splitting set theorem previously
demonstrated oikarinen janhunen splitting sets applicable dlpfunctions h b b b trivial way e u
u b splitting sets contrast theorem applies preceding
dlp function versatile ways e dened h b b
h b b consequence dened possible
determine sets stable sm b sm separation
appropriate conclude sm sm
sm b holds
well yet another generality aspect splitting concerns role input atomsthey
assumed nonexistent theorem however enables us treat well

decomposing dlp functions
objectives section contrary construction dlp function join
modules idea exploit strongly connected components dg dlpfunction order decompose smaller components e g priori
information internal structure simplicity rst consider dlpfunctions hidden atoms e ath eects hidden atoms
decomposition dlp functions addressed thereafter dened conjunction
denition sccs dg induced positive dependency relation
reexive transitive e preorder denition sequel set
sccs dg denoted scc positive dependency relation lifts
elements scc follows atoms
end matter pair atoms inspected
lemma dlp function components scc
every
proof b b b b consider
follows b b denition sccs thus
transitive
holds trivially sccs non empty

proposition relation scc reflexive transitive antisymmetric


fijanhunen oikarinen tompits woltran

proof relation scc reexive transitive denition antisymmetry consider scc follows
lemma every thus
maximality components scc


consequently may conclude hscc partially ordered set since
nite denition hscc maxima minima elements need
unique particular scc minimum element scc
implies scc thus may
apply principle well founded induction minima hscc basis
given structure hscc dlp function hr decomposed following way set rules associated scc def r
e set defining rules r general head arbitrary rule
b c r may coincide sense several sccs implies
rule included def r several scc however distribution
rules perfect harmony last two conditions denition must
bear mind integrity constraints b c included def r
scc access integrity constraints set r rules dene
ic r b c r



ready present decomposition scc
definition given dlp function hr decomposition induced
scc includes dlp function
hic r ic r r



scc dlp function
hdef r def r



purpose extra module keep track integrity constraints well
input atoms mentioned rules r modules involved
decomposition induced sccs refers modules
def r input signature provides dening rules every
atom recall output atom dening rules falsied default
proposition dlp function hr decomposition
scc join
f

sscc
defined equal

proof let us consider scc composition
dened modules involve hidden atoms ato
def r def r r def r def r def r r sets rules
r ic r r def r join dened respective composition
integrity constraints create dependencies dg


fimodularity aspects disjunctive stable

let us perform similar analysis two dierent components
scc clear dened since modules involve
hidden atoms def r def r def r r
def r def r def r r r def r r def r
since pairwise joins dened overall join dened denition
denition scc outcome equal

ic r sscc def r r

sscc


ic r r sscc def r
corollary dlp function ath decomposition
scc
sm sm
sscc sm




example consider following dlp function
b c
b c
c b c
b
b
c
b
c

ati ato b c ath two sccs dg
viz b c resulting decomposition consists
h c b c b b c
h b c b b c b
h b c c c b c
respective sets stable
sm
sm
sm
sm






b c b c
b c c
c b b
b c

next address case dlp functions involving hidden atoms e
ath holds components dg subsets ato ath
revise accordingly dlp function hr hi scc
hdef r def r hi



unfortunately decomposition modules form likely negrained certain components scc respective


fijanhunen oikarinen tompits woltran

modules conforming might respect hidden atoms
similar setting may arise individual module scc
integrity constraints refer hidden atoms would disappear
hidden atoms revealed hardly appropriatethere good reasons
hide certain atoms knowledge representation perspective
way distinguish components scc
scc respective modules would respect hidden
atoms e hidden atom dened one would referred othereither
positively negatively similar conicts could arise due integrity constraints packed
module distinguished denition rst sight amalgamate
module whose hidden atoms occur integrity constraints
order avoid fusions kind far possible worth redistributing integrity
constraints referring hidden atoms clearly possible integrity constraints referring hidden atoms involved single component formalize ideas presented
far distinguish precise relation among components scc follows
definition given dlp function components scc respect
hidden atoms denoted h
hidden atom h ath h ati
hidden atom h ath h ati
hidden atoms h ath h ath occurrence integrity constraint b c
clear h irreexive symmetric components scc
dlp function moreover transitive closure h denoted
h gives rise

repartitioning scc maximal block sn components
si
h sj holds every j induces module determined union
sn key observation modules associated dierent blocks
components respect hidden atoms makes theorem applicable
level abstraction summarize treatment dlp functions involving hidden
atoms rules revise denition accordingly
definition given dlp function hr hi decomposition induced
scc
h includes dlp function
hic r ic r r



ic r b c r b c h maximal block sn
components scc si
h sj every j dlp function
hdef r ics r def r ics r hi



sn ics r b c r b c h
regards example denitions yield identical decompositions
dlp function question eects hiding demonstrated following example


fimodularity aspects disjunctive stable

example consider dlp function hr hi
r c b b c c c b
h b c exact partitioning atoms h varies case
case analyzed sccs scc b c
take atoms visible e h decomposition yields three modules h b b h b b c c b
h b c c c b b c addition module
h c c encompassing integrity constraints
hide h obtain h disjunctive rule b therefore components must placed block maximal
giving rise module h c b b c c b
b modules listed
finally set h c obtain h b c h
c addition h stated since decomposition
effectively collapses single module
note non trivial modules mentioned
sm
sm
sm
sm
sm







b
b b b c c b b c c
b c
c c
b c b c b c b c

regardless decomposition obtained holds respective joins
sm




sm
sm
sm
sm
sm
sm
sm
sm
sm
c b

calculations involving
important notice allowed combinations
stable determined terms joint visible atoms modules involved
instance atv atv b b c b sm

sm c b b c b denition thus interestingly
role remaining two modules merely approve upon two
recalling discussion introduction suggests strategy gives
precedence
evaluation modules stable
combination stable modules visible atoms common


fijanhunen oikarinen tompits woltran

shifting disjunctions
section continue pursuit applications module theorem established
section generalize principle shifting disjunctive rules gelfond et al
dix et al applying roughly speaking idea behind
shifting translate disjunctive rule b c several normal non disjunctive
rules shifting head atoms h negative literals h body instance
simple disjunctive rule b c captured normal rules
b c

b c



c b

shown eiter et al local shifting transformation preserves ordinary
equivalence e stable application technique however pre empted
presence head cycles ben eliyahu dechter cycle provided
scc intersects head disjunctive rule b c
instance local shifting longer applicable rule b c
presence b b create strongly connected component b
consequence respective dlp functions
h b c b b b c



h b c b c c b b b b c



dierent stable sm b c sm c discrepancy stable settled applying decomposition technique
section fact leads proper generalization local shifting transformation
formalized dlp functions strongly connected components
definition let hr hi dlp function scc respective set
sccs general shifting dlp function gsh hic r r hi
r set rules
b c b c r scc



hence idea project head rule respect component
atoms dierence shifted negative body viewed
contribution disjunctive rule b c particular component
example scc b c
gsh h b c c b b b b c
importantly sm gsh b c sm contrast set
sm c stable
addition ordinary equivalence uniform equivalence eiter fink preserved local
shifting strong equivalence lifschitz pearce valverde



fimodularity aspects disjunctive stable

prove correctness general shifting principle denition
aim exploit decomposition denition together modular
reconstruction proposition compositionality stable semantics
corollary extend coverage corollary introduce explicit operators
revealing hiding atoms dlp functions follows
definition let hr hi dlp function
reveal hr h ai set h hidden atoms
hide hr h ai set output atoms
since denition stable make dierence output atoms
hidden atoms following properties easy verify role hidden atoms
becomes important section dlp functions compared
proposition let dlp function
ath sm sm reveal
ato sm sm hide
lemma let dlp function ath component scc
respective module decomposition according definition
sm sm gsh



proof recall hdef r input signature def r
notice component scc hence gsh set rules
r b c b c def r
consider interpretation input output signatures
respectively thus mi mo following equivalences
hold






b def r mi mo
b c def r mi mo c
b c def r ao b bo c co
mi ai bi ci mo co
b c ai r ao b bo c co
mi ai bi ci mo co
b c r mi mo c
b r mi mo

thus conclude def r mi mo coincides r mi mo consequently mo
mm def r mi mo mo mm r mi mo therefore sm mi
sm gsh mi since particular mi arbitrarily chosen beginning
obtain equality stable stated directly corollary



fijanhunen oikarinen tompits woltran

theorem dlp function hr hi sm sm gsh
proof since may hidden atoms corollary applicable decomposition scc thus start reveal h hr h
rather since sccs independent hiding scc scc
gsh reveal gsh
h since ath construction know
f

proposition sscc applying gsh equation yields
f
gsh sscc gsh



regards respective sets stable obtain
sm






sm




sm gsh



sm




sscc

sm

corollary

sscc

sm gsh

lemma
corollary

follows proposition sm hide h sm sm gsh
sm hide gsh h since hide h hide gsh h gsh
established sm sm gsh desired

according denition decompositions dlp functions create multiple copies
disjunctive rules whose heads intersect several sccs introduction copies
circumvented applying general shifting technique denition
example dlp function example obtain r ab c
b b r c b c c sets rules associated hr c b hr b c
hr r b c defined

observations enable us view disjunctive rules shared modules
associated sccs syntactic sugar however clever implementation save space
shared rules worst case unwinding rule b c coincides
respective sccs sn sn may create n copies
body b c quadratic blow partly alleviated introducing
atom b name body thus shifting sn becomes
b


ai b ai ai


b
together dening rule b b c b implementation general
shifting principle called dencode requested calculates beforehand whether
pays introduce atom body disjunctive rule
available http www tcs hut software asptools experimenting



fimodularity aspects disjunctive stable

equivalence dlp functions
concept visible equivalence originally introduced order neglect hidden atoms
logic programs theories interest compared basis janhunen oikarinen janhunen extended idea level
logic program modulesgiving rise notion modular equivalence logic programs
section generalize concept modular equivalence dlp functions
introduce translation method checking modular equivalence dlp functions
following analogous approaches oikarinen janhunen
modular equivalence
module interfaces must taken properly account dlp functions compared
reason consider two dlp functions compatible
ati ati ato ato
definition dlp functions modularly equivalent denoted

compatible
bijection f sm sm interpretations
sm atv f atv
proof congruent lifts case normal programs oikarinen
janhunen disjunctive case theorem
proposition let dlp functions
defined
proof let hr h hr h dlp functions
hr hi dlp function acting arbitrary context
dened consider sm theorem
implies sm n sm since
bijection f sm sm
f



holds dene f since n compatible denition
holds n compatible thus n
sm theorem eectively described mapped model
sm function g sm sm dened
g f
clearly g maps set visible atoms
g
justications g bijection follows


fijanhunen oikarinen tompits woltran

g injection n implies g g n n sm since
f f n n
g surjection n sm f n n
sm g n since f surjection
inverse function g sm sm g dened setting
f n n thus

note gsh follows directly theorem applying proposition
context theorem indicates shifting localized particular component
larger dlp function since gsh

g n

verifying modular equivalence
oikarinen janhunen proposed translation method verication
weak equivalence disjunctive logic programs two logic programs weakly equivalent exactly set stable thus weak equivalence
seen special case modular equivalence dlp functions
ati ath ati ath motivates us adjust translationbased technique verication modular equivalence observed previous work
janhunen oikarinen oikarinen janhunen verication visible modular equivalence involves counting general reduction computational time complexity achieved programs enough visible atoms
referred eva property short janhunen oikarinen dlpfunction hr hi dene hidden part restricted dlp function
h hdef r h h enables evaluation hidden atoms h given
arbitrary truth values atoms recalling denition use
instantiation h respect interpretation mv ati h e h mv dene
eva property dlp function
definition dlp function hr hi enough visible atoms iff h mv
unique stable model mv atv ati h
idea behind translation method oikarinen janhunen
ordinary disjunctive programs r r weakly equivalent translations
tr r r tr r r stable following propose modied
version translation function adjusted verication modular equivalence order
able verify modular equivalence need take semantics atoms
input signature account well role hidden atoms modular equivalence
programs consideration case dlp functions transform pair
compatible dlp functions dlp function eqt stable
model stable model sm stable model
n sm atv n atv form translation composition
dlp functions order fully exploit compositionality stable model semantics
justifying correctness method
follows use atoms appearing
atom use shorthand set atoms


fimodularity aspects disjunctive stable

analogously dened shorthands moreover diff unsat unsat ok
atoms appearing translation eqt
summarized denition consists following three parts
dlp function naturally captures stable model sm
ii dlp function hidden hrh h provides representation
hidden part hr hi evaluated respect visible part
input signature hidden consists visible atoms atv atv
set rh contains rule ah bv bh av cv ch b c r
ah e b c def r h hidden parts rules renamed
systematically atoms ath capture unique stable model
n h mv expressed ath rather ath note existence
uniqueness n guaranteed eva property
iii finally dlp function
tr hrtr h h unsat unsat diff ok h
provides minimality check set rtr contains
rule unsat bv bh av ah cv ch rule b c r
rules unsat unsat rules
unsat unsat h
rule unsat bi bo bh ai ao ah cv ch unsat rule
b c r
rule diff unsat rule diff unsat
h
following rules
ok unsat

ok diff unsat unsat

ok

intuition behind translation tr follows rules rst
item check whether interpretation l corresponding actual input
k l l h atv ath tr satises
rules rules satised rules items activated
literals unsat bodies rules second item used
generate subset l l l ati l ati achieved
introducing atom ato ath rules third
item check whether representation l ati ato ath e
k l l h satises rules l
rules
fourth item check whether l proper subset l finally rules fth
item summarize reasons l cannot stable model e
rules satised l l minimal model l
net eect
construction tr k stable model l stable model


fijanhunen oikarinen tompits woltran

definition let hr hi compatible dlp functions enough
visible atoms translation eqt given hidden tr
translation tr minimality check essentially contains rules
tr r r r tr r r translation dened oikarinen janhunen
sets r r disjunctive rules two aspects however
first occurrences hidden atoms h additionally represented counterparts h second need renamed versions atoms h
interpretation atoms input signature kept xed finally note
dlp functions correspond ordinary disjunctive logic programs e
hr hr translation eqt coincides
tr r r
theorem let compatible dlp functions enough visible atoms
iff sm eqt sm eqt
proof sketch let hr hi compatible dlp functions enough
visible atoms theorem given compatible interpretations
hidden tr stable model translation eqt sm sm hidden sm tr given
interpretation unique stable model sm hidden
compatible since eva property hence hidden constrain
stable composition eqt whenever compatible
holds oh oh sm tr
interpretation h stable model established
oikarinen janhunen theorem

verifying modular equivalence dlp functions forms
possible streamline translations involved verication task
theorem let compatible dlp functions enough visible atoms
dlp function defined
iff sm eqt sm eqt
context arbitrary dlp function e necessary
eva property long dened prove theorem notice
due structure translation eqt dened whenever
dened theorems applied

related work
eiter et al consider use disjunctive datalog programs query programs
relational databases query programs formalized triples h r si
set disjunctive rules r signatures input output
relations respectively whereas auxiliary hidden predicates left implicit hence
propositional case notable dierence respect denition input
atoms allowed occur heads disjunctive rules regards semantics


fimodularity aspects disjunctive stable

program reduced respect complete input database specied terms
r yielding instantiation among others stable model semantics applied
analogy denition however contrast modular architecture eiter
et al take positive negative dependencies account recursion
modules tolerated resulting hierarchy complete components admits
straightforward generalization splitting sequences lifschitz turner
essential dierence partial order rather total order modules assumed
respect worth pointing partial orders dlp functions permitted

modularity gained attention context conventional monotonic logic
programming see work bugliesi lamma mello survey two mainstream approaches identied rst called programming large algebraic operators introduced construction logic programs modules
falls categorythe join example operators
quite dierent programming small extend underlying logical language terms abstraction mechanisms eiter et al
b instance logic program modules viewed generalized quantifiers
allowed nest hierarchical fashion give idea consider
module formalizes transitive closure relation denoted predicate rel
tclo x rel x

tclo x tclo x z rel z

tclo acts output predicate module tclo rel whereas rel
input predicate module invoked create transitive closure binary
relation substituted rel consider instance rule
loop x tclo edge x tclo edge x
captures nodes involved loops directed graph whose edges supposed
represented predicate edge call tclo edge would
one module part respective ground program input output signatures
edge x x n tclo x x n
case n vertices however architecture eiter et al b module
tclo rel invoked several times form transitive closures dierent relations
eectively propositional invocation tclo rel would map module
although modules could obtained straightforward renaming predicates
aspect illustrates power programming small tclo rel acts
parameterized connective programmer concisely refer
relation viz transitive closure rel case spite succinctness
point relations may unwound actual implementation aspect
made explicit modular action description mad language proposed lifschitz
ren modular action description turned single module description
recursive fashion outcome determines meaning modular description via
embedding asp lifschitz turner
faber greco leone apply magic set method evaluation datalog
programs negation notion module concept independent


fijanhunen oikarinen tompits woltran

set non disjunctive logic program hr set satises
following two conditions
rule h b c r h b c
b c dangerous rule h b c r h b c
skip exact denition dangerous rules roughly speaking may interfere
existence stable clear independent sets splitting sets sense
denition vice versa general hence module theorem provided
faber et al viewed special case splitting set theorem therefore
observations presented section apply independent sets well

conclusion discussion
introduced formal framework modular programming context
disjunctive logic programs stable model semantics framework
notion dlp function puts eect appropriate input output interfacing
disjunctive logic programs analogous module concepts already studied
cases normal logic programs smodels programs oikarinen janhunen
even propositional theories janhunen special characteristics disjunctive
rules properly taken account syntactic semantic denitions dlpfunctions presented herein respect would draw readers attention
denition item denition items well denition
undoubtedly main module theorem e theorem
proved dlp functions generalthus covering class disjunctive programs module theorem important provides compositional semantics
disjunctive programs generalizes existing approaches splitting sets lifschitz turner magic sets faber et al although
number design decisions e g regards denition module
composition nevertheless brings limits modular programming context
nonmonotonic declarative language module theorem exploited number ways asp disjunctive logic programs demonstrated section
provides basis decomposing disjunctive programs components hence
localization reasoning tasks moreover established section technique
shifting disjunctive rules generalized disjunctive programs involving head cycles
actually generalized form enables us remove shared disjunctive rules altogether
might desirable due higher space requirements finally theory modular
equivalence fully applicable dlp functions demonstrated section
addition discussed anticipate applications module theorem future strongly believe direction yields
theoretical interest leads development practicably useful software
engineering methods asp fact rst tools decomposing linking programs
already implemented context smodels system section enable development analogous tools used disjunctive solvers
see modlist lpcat asp tools collection http www tcs hut software asptools



fimodularity aspects disjunctive stable

claspd cmodels dlv gnt implementation general shifting
principle called dencode asp tool collection section pave way
extending translation verication tool dlpeq janhunen oikarinen
verication modular equivalence extension already available
respective tool lpeq smodels programs oikarinen janhunen
acknowledgments work partially supported academy finland projects advanced constraint programming techniques large structured methods constructing solving large constraint
austrian science foundation fwf projects p formal methods comparing optimizing nonmonotonic logic programs p
methods methodologies developing answer set programs authors would
thank anonymous referees constructive comments well martin gebser torsten schaub suggestion exploit program completion loop formulas
proof module theorem preliminary version appeared
proceedings th international conference logic programming nonmonotonic
reasoning lpnmr vol lncs pp tempe az usa springer

references
baral c dzifcak j takahashi h macros macro calls use ensembles
modular answer set programming etalle truszczyski eds proceedings
nd international conference logic programming iclp vol
lncs pp seattle wa usa springer
ben eliyahu r dechter r propositional semantics disjunctive logic programs annals mathematics artificial intelligence
bugliesi lamma e mello p modularity logic programming journal
logic programming
clark k l negation failure gallaire h minker j eds logic
data bases pp plenum press york
dix j gottlob g marek v w reducing disjunctive non disjunctive
semantics shift operations fundamenta informaticae
drescher c gebser grote kaufmann b knig ostrowski schaub
conict driven disjunctive answer set solving brewka g lang j
eds proceedings th international conference principles knowledge
representation reasoning pp sydney australia aaai press
eiter fink uniform equivalence logic programs stable model
semantics palamidessi c ed proceedings th international conference
logic programming iclp vol lncs pp mumbay india
springer
verification tools mentioned available http www tcs hut software lpeq



fijanhunen oikarinen tompits woltran

eiter fink tompits h woltran simplifying logic programs
uniform strong equivalence lifschitz v niemel eds proceedings
th international conference logic programming nonmonotonic reasoning
lpnmr vol lnai pp fort lauderdale fl usa springer
eiter gottlob g computational cost disjunctive logic programming
propositional case annals mathematics artificial intelligence

eiter gottlob g mannila h disjunctive datalog acm transactions
database systems
eiter gottlob g veith h b modular logic programming generalized
quantiers dix j furbach u nerode eds proceedings th
international conference logic programming nonmonotonic reasoning lpnmr vol lncs pp dagstuhl germany springer
eiter ianni g lukasiewicz schindlauer r tompits h combining
answer set programming description logics semantic web artificial
intelligence
erdem e lifschitz v tight logic programs theory practice logic
programming
faber w greco g leone n magic sets application data integration journal computer system sciences
gaifman h shapiro e fully abstract compositional semantics logic programs proceedings th annual acm symposium principles programming languages pp austin tx usa acm press
gebser kaminski r kaufmann b ostrowski schaub thiele
engineering incremental asp solver de la banda pontelli e eds
proceedings th international conference logic programming iclp
vol lncs pp udine italy springer
gebser schaub thiele usadel b veber p b detecting inconsistencies large biological networks answer set programming de la banda
pontelli e eds proceedings th international conference logic
programming iclp vol lncs pp udine italy springer
gelfond gabaldon building knowledge base example annals
mathematics artificial intelligence
gelfond leone n logic programming knowledge representation
prolog perspective artificial intelligence
gelfond lifschitz v stable model semantics logic programming
kowalski r bowen k eds proceedings th international conference logic programming iclp pp seattle wa usa mit
press


fimodularity aspects disjunctive stable

gelfond lifschitz v classical negation logic programs disjunctive
databases generation computing
gelfond przymusinska h lifschitz v truszczyski disjunctive defaults allen j f fikes r sandewall e eds proceedings nd international conference principles knowledge representation reasoning pp
cambridge usa morgan kaufmann
giunchiglia e lierler maratea answer set programming
propositional satisability journal automated reasoning
janhunen translatability normal logic programs propositional theories journal applied non classical logics
janhunen modular equivalence general ghallab spyropoulos c
fakotakis n avouris n eds proceedings th european conference
artificial intelligence ecai pp patras greece ios press
janhunen b removing redundancy answer set programs de la banda
pontelli e eds proceedings th international conference logic
programming iclp vol lncs pp udine italy springer
janhunen niemel seipel simons p j h unfolding partiality
disjunctions stable model semantics acm transactions computational
logic
janhunen oikarinen e lpeq dlpeq translators automated equivalence testing logic programs lifschitz v niemel eds proceedings
th international conference logic programming nonmonotonic reasoning
lpnmr vol lnai pp fort lauderdale fl usa springer
janhunen oikarinen automated verication weak equivalence within
smodels system theory practice logic programming
junttila niemel towards ecient tableau method boolean circuit
satisability checking lloyd j w et al eds proceedings first international conference computational logic cl vol lncs pp
london uk springer
koch c leone n pfeifer g enhancing disjunctive logic programming systems
sat checkers artificial intelligence
lee j lifschitz v loop formulas disjunctive logic programs palamidessi
c ed proceedings th international conference logic programming
iclp vol lncs pp mumbay india springer
leone n pfeifer g faber w eiter gottlob g scarcello f dlv
system knowledge representation reasoning acm transactions computational logic


fijanhunen oikarinen tompits woltran

lifschitz v computing circumscription joshi k ed proceedings
th international joint conference artificial intelligence ijcai pp
los angeles ca usa morgan kaufmann
lifschitz v pearce valverde strongly equivalent logic programs acm
transactions computational logic
lifschitz v ren w modular action description language proceedings
st national conference artificial intelligence aaai pp
boston usa aaai press
lifschitz v turner h splitting logic program hentenryck p v ed
proceedings th international conference logic programming iclp
pp santa margherita ligure italy mit press
lifschitz v turner h representing transition systems logic programs
gelfond leone n pfeifer g eds proceedings th international
conference logic programming nonmonotonic reasoning lpnmr vol
lnai pp el paso tx usa springer
lin f zhao assat computing answer sets logic program sat
solvers artificial intelligence
marek v w truszczyski stable alternative logic programming paradigm apt k r marek v w truszczyski warren
eds logic programming paradigm year perspective pp
springer
mccarthy j applications circumscription formalizing commonsense knowledge artificial intelligence
niemel logic programs stable model semantics constraint programming
paradigm annals mathematics artificial intelligence
oikarinen e janhunen verifying equivalence logic programs
disjunctive case lifschitz v niemel eds proceedings th international conference logic programming nonmonotonic reasoning lpnmr
vol lnai pp fort lauderdale fl usa springer
oikarinen e janhunen achieving compositionality stable model
semantics smodels programs theory practice logic programming

oikarinen e janhunen b implementing prioritized circumscription computing disjunctive stable dochev pistore traverso p eds
artificial intelligence methodology systems applications th international
conference aimsa vol lncs pp varna bulgaria springer
oikarinen e janhunen translation verication
modular equivalence journal logic computation


fimodularity aspects disjunctive stable

reiter r theory diagnosis rst principles artificial intelligence

simons p niemel soininen extending implementing stable
model semantics artificial intelligence




