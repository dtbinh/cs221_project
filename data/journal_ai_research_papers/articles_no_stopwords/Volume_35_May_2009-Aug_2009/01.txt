Journal Artificial Intelligence Research 35 (2009) 49-117

Submitted 10/08; published 05/09

Message-Based Web Service Composition, Integrity Constraints,
Planning Uncertainty: New Connection
Jorg Hoffmann

JOE . HOFFMANN @ SAP. COM

SAP Research
Karlsruhe, Germany

Piergiorgio Bertoli

BERTOLI @ FBK . EU

Fondazione Bruno Kessler
Trento, Italy

Malte Helmert

HELMERT @ INFORMATIK . UNI - FREIBURG . DE

Albert-Ludwigs-Universitat Freiburg
Freiburg, Germany

Marco Pistore

PISTORE @ FBK . EU

Fondazione Bruno Kessler
Trento, Italy

Abstract
Thanks recent advances, AI Planning become underlying technique several applications. Figuring prominently among automated Web Service Composition (WSC)
capability level, services described terms preconditions effects ontological concepts. key issue addressing WSC planning ontologies formal
vocabularies; axiomatize possible relationships concepts. axioms correspond termed integrity constraints actions change literature,
applying web service essentially belief update operation. reasoning required belief
update known harder reasoning ontology itself. support belief update
severely limited current planning tools.
first contribution consists identifying interesting special case WSC
significant tractable. special case, term forward effects, characterized
fact every ramification web service application involves least one new constant
generated output web service. show that, setting, reasoning required
belief update simplifies standard reasoning ontology itself. relates to, extends,
current notions message-based WSC, need belief update removed strong
(often implicit informal) assumption locality individual messages. clarify
computational properties forward effects case, point strong relation standard notions planning uncertainty, suggesting effective tools latter successfully
adapted address former.
Furthermore, identify significant sub-case, named strictly forward effects, actual
compilation planning uncertainty exists. enables us exploit off-the-shelf planning tools solve message-based WSC general form involves powerful ontologies,
requires reasoning partial matches concepts. provide empirical evidence
approach may quite effective, using Conformant-FF underlying planner.

c
2009
AI Access Foundation. rights reserved.

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

1. Introduction
Since mid-nineties, AI Planning tools become several orders magnitude scalable,
invention automatically generated heuristic functions search techniques
(see McDermott, 1999; Bonet & Geffner, 2001; Hoffmann & Nebel, 2001; Gerevini, Saetti, &
Serina, 2003; Helmert, 2006; Chen, Wah, & Hsu, 2006). paved way adoption
planning underlying technology several applications. One application area
web service composition (WSC), paper mean automated composition
semantic web services (SWS). SWS pieces software advertised formal description
do. Composing SWS means link together aggregate behavior
satisfies complex user requirement. ability automatically compose web services key
reducing human effort time-to-market constructing integrated enterprise applications.
result, widely recognized economic potential WSC.
wide-spread SWS frameworks OWL-S1 WSMO2 , SWS described two distinct
levels. One addresses overall functionality SWS, details precisely
interact SWS. former level, called service profile OWL-S service
capability WSMO, SWS described akin planning operators, preconditions effects. Therefore, planning prime candidate realizing WSC level. approach
follow paper.
setting, key aspect SWS preconditions effects described relative
ontology defines formal (logical) vocabulary. Indeed, ontologies much
formal vocabularies introducing set logical concepts. define axioms constrain behavior domain. instance, ontology may define subsumption relationship
two concepts B, stating members necessarily members B.
natural interpretation axiom, context WSC, every state encountered every possible configuration domain entities must satisfy axiom. sense,
ontology axioms correspond integrity constraints discussed actions change literature
(Ginsberg & Smith, 1988; Eiter & Gottlob, 1992; Brewka & Hertzberg, 1993; Lin & Reiter, 1994;
McCain & Turner, 1995; Herzig & Rifi, 1999).3 Hence WSC considered planning
presence integrity constraints. Since constraints affect outcome action executions,
facing frame ramification problems, execution actions corresponds closely
complex notions belief update (Lutz & Sattler, 2002; Herzig, Lang, Marquis, & Polacsek,
2001). Unsurprisingly, providing support integrity constraints modern scalable planning tools mentioned poses serious challenges. best knowledge, yet
attempted all.
Regarding existing WSC tools, planning tools employed solving WSC problems,
situation isnt much better. tools ignore ontology, i.e., act constraints
domain behavior given (Ponnekanti & Fox, 2002; Srivastava, 2002; Narayanan & McIlraith,
2002; Sheshagiri, desJardins, & Finin, 2003; Pistore, Traverso, & Bertoli, 2005b; Pistore, Marconi, Bertoli, & Traverso, 2005a; Agarwal, Chafle, Dasgupta, Karnik, Kumar, Mittal, & Srivastava,
2005a). approaches tackle full generality belief update using general reasoners,
1. example, see work Ankolekar et al. (2002) Burstein et al. (2004).
2. example, see work Roman et al. (2005) Fensel et al. (2006).
3. Integrity constraints sometimes called state constraints domain constraints.

50

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

suffer inevitable performance deficiencies (Eiter, Faber, Leone, Pfeifer, & Polleres, 2003;
Giunchiglia, Lee, Lifschitz, McCain, & Turner, 2004).
planningbased
formalization

WSC Formalism

variant

restriction
rich version

Forward Effects

WSC

planningbased
formalization

Messagebased WSC

restriction

Conformant Planning


tackled

Strictly Forward Effects

Figure 1: overview planning WSC frameworks addressed paper. Special cases
identified herein shown red / boldface.
work addresses middle ground two extremes, i.e., trade-off
expressivity scalability WSC. via identification special cases
tackled efficiently. Figure 1 gives overview WSC planning frameworks involved.
brief, forward effects case requires every effect ramification web service
affects least one new constant generated web services output. situation,
frame problem trivializes, making planning problem similar common notions
conformant planning (Smith & Weld, 1998; Bonet & Geffner, 2000; Cimatti, Roveri, & Bertoli,
2004; Hoffmann & Brafman, 2006). discuss existing tools latter, particular
Conformant-FF (Hoffmann & Brafman, 2006), extended deal WSC forward
effects. strictly forward effects, action effects required affect outputs,
devise actual compilation conformant planning. thus obtain scalable tool interesting
WSC problems integrity constraints. particular able exploit (some of) heuristic
techniques mentioned (Hoffmann & Nebel, 2001; Hoffmann & Brafman, 2006).
follows, explain various parts Figure 1 little detail. starting
point WSC formalism, addressing WSC terms planning presence integrity constraints, discussed above. formalism essentially enriched form conformant planning.
distinguishing aspects are:
initial state description conjunction literals (possibly mentioning
logical facts task, hence introducing uncertainty).
Actions conditional effects semantics, meaning executed state,
effect applicable.
Actions may output variables, i.e., may create new constants.
set integrity constraints, universally quantified clause.
semantics action execution defined terms belief update operation.
Section 2 provides details choices, motivates example
results literature. show, planning formalism hard. Particularly,
51

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

even testing whether given action sequence plan p2 -complete. contrast
common notions conformant planning, plan testing coNP-complete.
see, forward effects remove additional complexity. Intuitively, forward effects
case covers situation web service outputs new constants, sets characteristic
properties relative inputs, relies ontology axioms describe ramifications
concerning new constants. case syntactically characterized follows:
(1) Every effect literal contains least one output variable.
(2) Within integrity constraint, every literal set variables arguments.
definition best understood example. Consider following variant widespread virtual travel agency (VTA). Web services book travel accommodation must
linked. web services generate new constants corresponding tickets reservations.
example, integrity constraints stating subsumption, z : trainTicket(z)
ticket(z). web service bookTicket may input variable x, precondition train(x ),
output variable y, effect trainTicket(y) ticketFor (y, x). forward effects task:
every effect literal contains output variable y, integrity constraint single variable
z provides arguments literals constraint. Say one instantiates input
bookTicket constant c output new constant d. applying resulting
ground action state train(c) holds true, constant gets created, characteristic
properties relative inputs trainTicket(d) ticketFor (d, c) set directly action.
integrity constraint takes care ramification, establishing ticket(d) holds. Note
status c apart relation affected way. 4
forward effects case closely related wide-spread notion WSC problems,
refer message-based WSC. approaches, composition semantics based
chaining input output messages web services, one sense. Inferences
ontology axioms made many approaches, restricted way limited
assumption locality individual messages, interferences affect particular
message transfer, implications transfers ignored. locality assumption
usually made informal way, often stated explicitly all. One contribution work
shed light issue, via identification forward effects case lies
message-based WSC full planning framework belief update semantics.
message-based WSC forward effects case share focus output constants.
two important differences. First, forward effects case restricted messagebased WSC terms ontology axioms allowed. Essentially, forward effects correspond
special case WSC locality assumption message-based WSC actually justified,
within full planning framework. Second, full framework comes benefit increased
flexibility combination services, locality enforced (e.g. output one
service may reused several points plan).
computational point view, key property forward effects case
removes need belief update. nutshell, reason actions affect new propositions, i.e., propositions involving least one output constant. (Recall point made
4. latter would case effect bookTicket included literal affecting x (example:
train(x)), integrity constraint capable mixing old new constants (example: x, :
trainTicket(y) train(x)).

52

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

unchanged status c, VTA example above.) output constant (d, example)
exist prior application action, hence previous belief carries knowledge
need revised. Consider characterization forward effects, given above.
Condition (1) ensures immediate effect action affects new propositions. Condition (2) ensures changes new propositions propagate new propositions. Since
literals constraint share variables, output constant question copied
them. see, virtue properties complexity plan testing coNP-complete,
rather p2 -complete, forward effects case.
complexity reduction critical reduced complexity
common notions conformant planning initial state uncertainty. Therefore feasible adapt conformant planning tools address WSC forward effects. Scalable planning
tools conformant planning already developed (Cimatti et al., 2004; Bryce, Kambhampati, & Smith, 2006; Hoffmann & Brafman, 2006; Palacios & Geffner, 2007). Hence
promising line research. example, focus Conformant-FF tool (Hoffmann
& Brafman, 2006) (short CFF) outline main steps need taken adapting CFF
handle WSC forward effects.
identify case actual compilation conformant planning initial
state uncertainty exists. that, one must fix set constants priori. manner
fairly standard (see, e.g., Settlers domain Long & Fox, 2003), simply include set
subset potential constants used instantiate outputs. subtle idea
put forward identify condition actions predict properties
assigned potential constants, case created. enables us design
compilation moves action effects initial state formula, uses actions
modify set constants already exist. way, reasoning initial state formula
compiled task reasoning output constants original task,
reasoning mechanisms included tools CFF naturally used implement latter.
trick predicting output properties require actions compatible sense
either produce different outputs, effects. turns condition
naturally given restriction forward effects, call strictly forward effects,
web service effects concern new constants.
Clearly, able reference inputs limitation. example, longer
say, VTA example, output ticket input x. Still, strictly forward
effects case describes interesting class WSC problems. class corresponds web services
modeled early versions OWL-S, example, logical connection
inputs outputs. Further, class WSC problems allows powerful ontologies
universally quantified clauses makes possible combine services flexibly. Using
compilation, class problems solved off-the-shelf tools planning
uncertainty.
validate compilation approach empirically running number tests using CFF
underlying planner. use two test scenarios, scalable variety parameters, covering range different problem structures. examine CFF reacts various
parameters. Viewed isolation, results demonstrate large complex WSC instances
comfortably solved using modern planning heuristics.
comparison alternative WSC tools problematic due widely disparate nature
kinds problems tools solve, kinds input languages understand,
53

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

purpose respective developers mind. nevertheless provide assessment
comparative benefits approach run tests DLVK tool Eiter et al. (2003)
Eiter, Faber, Leone, Pfeifer, Polleres (2004). DLVK one planning tools
deals ontology axioms called static causal rules directly, without need restrict
forward effects without need compilation. Since, context work,
main characteristic WSC presence ontology axioms, means DLVK one
existing native WSC tools. comparison, forward effects compilation approach
solves similar problem, sacrifices expressivity. question is, principle
gain anything sacrifice? Absolutely, answer yes. DLVK much slower
compilation+CFF, solving small fraction test instances even always provided
correct plan length bound. emphasize wish over-state results,
due above-mentioned differences tools. conclusion draw
trade-off expressivity scalability WSC important, forward effects case
seems constitute interesting point trade-off.
paper organized follows. First, Section 2 provides background necessary
understand context contribution work. Section 3 introduces WSC planning
formalism. Section 4 defines discusses forward effects. Section 5 introduces compilation
planning uncertainty, Section 6 presents empirical results. discuss closely
related work relevant points text, Section 7 provides complete overview.
Finally, Section 8 concludes discusses future work. improve readability, proofs
moved Appendix replaced text proof sketches.

2. Background
context work rather intricate. WSC new topic posing many different
challenges existing techniques, effect field populated disparate works differing considerably underlying purpose scope. words, common ground
fairly thin area. Further, work actually involves three fields research WSC, planning,
reasoning actions change relevant understanding contribution.
reasons, explain background detail. first discuss WSC general,
WSC Planning particular. state relevant facts belief update. finally
consider message-based WSC.
2.1 WSC, WSC Planning
Composition semantic web services received considerable attention last years.
general formulation problem, shared large variety works, focuses capability
level, web service conceived atomic operator transforms concepts.
specifically, service defined via IOPE description: service receives input set
typed objects, and, provided precondition P holds, produces output set
typed objects effect E guaranteed hold. typing objects exchanged
services given terms membership concepts. Concepts classes defined
within ontologies, exploit Description Logics (DL), form logic, formally
define universe concepts admitted discourse. ontology express complex relationships among concepts, subsumption hierarchy, way objects belonging concept
structured parts referring concepts.
54

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

general setting instantiated various ways depending kind conditions
admitted preconditions/effects services, kind logics underlying ontology
definitions. Independent this, problem semantic web service composition stated
one linking appropriately set existing services aggregate behavior
desired service (the goal). illustrate problem, consider following example,
inspired work Thakkar, Ambite, Knoblock (2005) e-services bioinformatics
(and relies actual structure proteins, see example Petsko & Ringe, 2004; Branden &
Tooze, 1998; Chasman, 2003; Fersht, 1998):
Example 1 Say want compose web service provides information different classes
proteins. ontology states classes proteins exist, structural characteristics
may occur. available information service every structural characteristic,
presentation service combines range information. Given particular protein class,
composed web service run relevant information services, present output.
Concretely, classes proteins distinguished location (cell, membrane, intermembrane, . . . ). modeled predicates protein(x), cellProtein(x), membraneProtein(x),
intermembraneProtein(x), along sub-concept relations x : cellProtein(x)
protein(x). individual protein characterized following four kinds structures:
1. primary structure states proteins sequence amino-acids, e.g., 1kw3(x) (a protein called Glyoxalase) 1n55(x) (a protein called Triosephosphate Isomerase).
2. secondary structure states proteins external shape terms DSSP (Dictionary Secondary Structure Proteins) code, admitting limited set possible values.
example, G indicates 3-turn helix, B -sheet, on. total set values
G,H,I,T,E,B,S.
3. tertiary structure categorizes proteins 3-D shape.
4. subset proteins, quaternary structure categorizes proteins shape
combined complexes proteins (amounting 3000 different shapes, see example
3DComplex.org, 2008).
various axioms constrain domain, apart mentioned subconcept
relations. First, obvious axioms specify protein value four
kinds structures (i.e., protein sequence amino-acids, external shape, etc). However,
complex axioms. Particular kinds proteins come particular structure
values. modeled axioms as:
x : cellProtein(x) G(x) 1n55(x)
x : cellProtein(x) B(x) 1kw3(x) complexBarrel(x)
DSSP code Z information service, named getInfoDSSPZ , whose precondition
Z(x) whose effect InfoDSSP(y) output service. Similarly, information services amino-acids, 3-D shapes, shapes complexes. presentation service,
named combineInfo, requires information four kinds structures created,
effect combinedPresentation(y) (where output combineInfo).
55

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

input composed web service protein c (a logical constant) class.
goal x : combinedPresentation(x). solution reason characteristics may
occur, apply respective information services, run combineInfo. variant
problem, additional requestInfo service used initiate information request, i.e.,
output requestInfo protein c class.
example shows ontology axioms play crucial role form WSC, formulating
complex dependencies different concepts. Note applying web service may indirect consequences implied ontology axioms. example, output requestInfo
service implications kinds information services required.
Another interesting aspect Example 1 requires SWS community calls partial matches, opposed plug-in matches (Paolucci, Kawamura, Payne, & Sycara, 2002; Li
& Horrocks, 2003; Kumar, Neogi, Pragallapati, & Ram, 2007).5 Consider situation one
wants connect web service w another web service w . is, w executed prior
w , output w used instantiate input w . w w said
partial match if, given ontology axioms, output w sometimes suffices provide
necessary input w . contrast, w w said plug-in match if, given ontology
axioms, output w always suffices provide necessary input w .
Plug-in matches tackled many approaches WSC, whereas partial matches tackled
few. Part reason probably plug-in matches easier handle, many types
WSC algorithms. Indeed existing WSC tools support plug-in matches (see detailed
discussion WSC tools Section 7). Example 1 cannot solved plug-in matches
information services provides necessary input combineInfo service
particular cases.
base work planning formalism allows specify web services (i.e., actions)
outputs, allows specify ontology axioms. axioms interpreted integrity
constraints, resulting semantics corresponds closely common intuitions behind WSC,
well existing formal definitions related WSC (Lutz & Sattler, 2002; Baader, Lutz,
Milicic, Sattler, & Wolter, 2005; Liu, Lutz, Milicic, & Wolter, 2006b, 2006a; de Giacomo, Lenzerini, Poggi, & Rosati, 2006). Since one main aims able exploit existing planning
techniques, consider particular form ontology axioms, correspondence representations used existing tools planning uncertainty. Namely, axioms
universally quantified clauses. example subsumption relation x : trainTicket(x)
ticket(x) mentioned above, usual B abbreviation B. planning task
specifies set clauses, interpreted conjunction clauses. Note provides
significant modeling power. meaning universal quantification clauses
clauses hold planning objects logical constants known exist. sense,
interpretation formulas closed-world customary planning tools. However, contrast
standard planning formalisms including PDDL, assume fixed set constants.
Rather, specification actions outputs enables dynamic creation new constants.
quantifiers ontology axioms range constants exist respective world.
similar fashion, planning goal may contain variables, existentially quantified.
constants used instantiate goal may pre-existed, may generated
5. terminology works slightly different use here, describe additional kinds
matches. details given Section 7.

56

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

outputs web services applied path world. Consider
illustration goal x : combinedPresentation(x) Example 1, goal variable x
instantiated output created combineInfo service.
Another important aspect planning formalism allow incomplete initial state
descriptions. initial state corresponds input user provides composed web
service. Certainly cannot assume contains complete information every aspect
world. (In Example 1, initial state tells us class proteins interested
in, leaves open consequences regarding possible structural characteristics.)
consider case observability, i.e., conformant planning. outcome
WSC sequence web services satisfies user goal possible situations.6
customary conformant planning, actions conditional effects semantics, i.e., fire
precondition holds true, otherwise nothing. Note that, way, obtain notion
partial matches: solution employs different actions depending situation.
main difference planning formalism formalisms underlying current planning tools presence integrity constraints, effect semantics executing actions. semantics defined belief update operation.
2.2 Belief Update
correspondence web service applications belief update first observed Lutz
Sattler (2002), followed Baader et al. (2005), Liu et al. (2006b, 2006a) de Giacomo
et al. (2006). original statement belief update problem, given belief ,
i.e., logical formula defining worlds considered possible. given formula ,
update. Intuitively, corresponds observation telling us world changed
way that, now, true. want obtain formula defining worlds
possible given update. Certainly, need |= . Ensuring corresponds
well-known ramification problem. time, however, world change
unnecessarily. is, want close possible , among formulas
satisfy . corresponds frame problem.
Say want apply action presence integrity constraints. describes
worlds possible prior application a. resulting set possible worlds.
integrity constraints correspond formula IC holds , require
hold . update formula given conjunction action effect IC , i.e.,
= effa IC . means update previous belief information that,
a, effa new formula required hold, IC still true. example, may
action effect A(c) subsumption relation concepts B, formulated clause
x : A(x) B(x). update formula A(c) x : A(x) B(x) ensures B(c) true
.
Belief update widely considered literature AI databases (see example
Fagin, Kuper, Ullman, & Vardi, 1988; Ginsberg & Smith, 1988; Winslett, 1988, 1990; Katzuno
& Mendelzon, 1991; Herzig, 1996; Herzig & Rifi, 1999; Liu et al., 2006b; de Giacomo et al.,
2006). various approaches differ exactly defined. best consensus
one approach adequate every application context. approaches
6. course, generally, observability partial web service effects uncertain. consider
generalizations here. Extending notions accordingly straightforward, future work.

57

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

agree hold updated state affairs, |= . Major differences lie
exactly taken mean close possible . Various authors,
example Brewka Hertzberg (1993), McCain Turner (1995), Herzig (1996), Giunchiglia
Lifschitz (1998), argue notion causality needed, addition (or even instead of)
notion integrity constraints, model domain behavior natural way. counter
arguments, neither follow causal approach work. reason ontologies
context WSC, example ontologies formulated web ontology language OWL
(McGuinness & van Harmelen, 2004), incorporate notion causality. given
set axioms, made intention describe behavior domain itself, rather
behavior exhibits changed particular web services. idea work try
leverage (or reasonably close having). Consideration causal
approaches WSC left future work.
Belief update computationally hard problem. Eiter Gottlob (1992) Liberatore
(2000) show that, non-causal approaches defining , reasoning typically
harder reasoning class formulas used formulating . Specifically, deciding
whether particular literal true 2p -hard even complete conjunction
literals (corresponding single world state) propositional CNF formula.
problem coNP-hard even single world state propositional Horn formula.
use results show that, planning formalism, checking plan testing whether
given action sequence plan 2p -complete, deciding polynomially bounded plan
existence 3p -complete.
Given complexity, perhaps unsurprising support integrity constraints current planning tools severely limited. existing planning tools support integrity
constraints, namely Eiter et al. (2003) Giunchiglia et al. (2004), based generic
deduction, satisfiability testing answer set programming. hence lack planningspecific heuristic search techniques key scalability modern planning tools
developed since mid-nineties. even investigated yet integrity constraints could handled latter tools. existing approach ventures direction implements so-called derived predicates modern planning tools (Thiebaux,
Hoffmann, & Nebel, 2005; Gerevini, Saetti, Serina, & Toninelli, 2005; Chen et al., 2006).
approach postulates strict distinction basic predicates may affected actions,
derived predicates may affected integrity constraints taking form logic programming rules. predicate appears action effect, allowed appear
head rule. desirable restriction context WSC, web services
bound affect properties constrained ontology axioms.
existing work connecting WSC belief update (Lutz & Sattler, 2002; Baader et al.,
2005; Liu et al., 2006b, 2006a; de Giacomo et al., 2006) theoretical nature. actual implemented WSC tools make severe simplifying assumptions. often, assumption ignore
ontology axioms (Ponnekanti & Fox, 2002; Srivastava, 2002; McIlraith & Son, 2002; Sheshagiri
et al., 2003; Sirin, Parsia, Wu, Hendler, & Nau, 2004; Pistore et al., 2005b, 2005a). Sometimes,
ontology constraints restricted subsumption hierarchies, makes update problem
easy (Constantinescu & Faltings, 2003; Constantinescu, Faltings, & Binder, 2004b, 2004a). Sirin
Parsia (2004) Sirin, Parsia, Hendler (2006) discuss problem dealing ontology axioms WSC, make connection belief update, describe alternative
solution. Finally, authors, example Meyer Weske (2006), deal ontology ax58

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

ioms composition, provide formal semantics specify exactly
action applications handled. seems fully formalized WSC approaches implicitly
assume message-based framework. frameworks closely related forward effects
special case identified herein.
2.3 Message-Based WSC
message-based approaches WSC, composition semantics based chaining input
output messages web services. word message standard term context.
authors use individual vocabulary. far aware, first appearance
word message WSC paper title work Liu, Ranganathan, Riabov (2007).
work describes message-based WSC follows. solution directed acyclic graph (DAG)
web services, input needed web service (DAG graph node) w must provided
outputs predecessors w graph. is, plan determines fixed connections
actions. Reasoning, then, takes place within connections. two connections
different output input messages, i.e., two graph edges ending different node,
assumed mutually independent. Consider following example illustration. Say web
service w effect hasAttributeA(c, d) output constant c input (i.e., c
existed already prior application w). Say axiom x, : hasAttributeA(x, y)
conceptB(x) expressing attribute domain restriction. x value attribute A,
x must concept B. Given this, ws effect implies conceptB(c). Now, suppose
belief prior applying w constrain c concept B. applying w leads new
knowledge c. Hence need non-trivial belief update taking account changed
status c, implications may have. Message-based WSC simply acts latter
case. checks whether w correctly supplies inputs web services w w
connected to. is, new fact hasAttributeA(c, d) may taken part proof
effect w implies precondition connected web service w . considered
implications hasAttributeA(c, d) may respect previous state affairs.
sense, message-based WSC ignores need belief update.
intuitions underlying message-based WSC fairly wide-spread. Many papers use
less direct way. many approaches explicitly define WSC solutions
DAGs local input/output connections (Zhan, Arpinar, & Aleman-Meza, 2003; Lecue
& Leger, 2006; Lecue & Delteil, 2007; Kona, Bansal, Gupta, & Hite, 2007; Liu et al., 2007; Ambite
& Kapoor, 2007). various works (Constantinescu & Faltings, 2003; Constantinescu et al.,
2004b, 2004a; Meyer & Weske, 2006), message-based assumptions implicit.
manifest mainly sense ontology axioms used infer properties
output messages, often checking whether inferences imply desired input
message definitely given.
Previous work message-based WSC address message-based WSC relates
various notions, belief update, considered literature. One contribution work
shed light issue, via identification forward effects case lies
message-based WSC full planning framework belief update semantics.
message-based WSC forward effects case share focus outputs. Indeed,
output constants generated actions viewed messages. output constant
represents information object created one web service, form

59

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

input web service. forward effects case, due restriction axioms,
individual messages interact. much message-based WSC. main difference
this: message-based WSC ignores possible interactions, forward effects actually
arent interactions, according formal planning-based execution semantics. sense,
forward effects correspond special case WSC assumptions message-based WSC
justified.
Reconsider example above, featuring web service w effect implying
conceptB(c) c pre-existing constant. explained above, message-based WSC
simply ignore need updating knowledge c. contrast, forward effects case
disallows axiom x, : hasAttributeA(x, y) conceptB(x) may lead new
conclusions old belief (note literals axiom refer different sets variables).
forward effects case differs significantly approaches message-based WSC
terms flexibility allows combine actions plans. messagebased approach using DAGs, solution DAG ensures inputs service w always
provided ws predecessors. is, plug-in match set W ws
predecessors DAG, w itself. Note slightly general usual notion
plug-in matches, |W | may greater 1, hence single service W may
partial match w. notion used, amongst others, Liu et al. (2007).
authors, example Lecue Leger (2006) Lecue Delteil (2007), restrictive
consider every individual input x w turn require exists w W
w plug-in match x (i.e., w guarantees always provide x). Even generous
two definitions, partial matches restricted appear locally, DAG links. Every
action/web service required always executable point applied.
words, services used fixed manner, considering dynamics actual execution.
Example 1, would mean using information services regardless class
protein, hence completely ignoring relevant not.
forward effects case incorporates much general notion partial matches. happens straightforward way, exploiting existing notions planning, form conditional effects semantics. standard notion conformant solution defines partial matches
must work together global level, accomplish goal. best knowledge,
one line work WSC, Constantinescu et al. (Constantinescu & Faltings, 2003;
Constantinescu et al., 2004b, 2004a), incorporates comparable notion partial matches.
work, web services characterized terms input output types. handle partial
matches, so-called switches combine several web services way ascertains relevant
cases covered. switches designed relative subsumption hierarchy types.
Note subsumption hierarchies special case much general integrity constraints
universally quantified clauses consider work.

3. Formalizing WSC
solid basis addressing WSC, define planning formalism featuring integrity constraints,
on-the-fly creation output constants, incomplete initial state descriptions, actions conditional effects semantics. application actions defined belief update operation, following possible models approach Winslett (1988). definition belief update somewhat
canonical widely used discussed. particular underlies recent work

60

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

relating formalizations WSC (Lutz & Sattler, 2002; Baader et al., 2005; Liu et al., 2006b,
2006a; de Giacomo et al., 2006; de Giacomo, Lenzerini, Poggi, & Rosati, 2007). show
(Section 4.3), belief update operations equivalent anyway soon
forward effects case. Recall forward effects case central object
investigation paper.
first give syntax formalism, denote WSC, give semantics. conclude analysis main computational properties.
3.1 Syntax
denote predicates G, H, I, variables x, y, z, constants c, d, e. Literals possibly negated predicates whose arguments variables constants. arguments constants,
literal ground. refer positive ground literals propositions. Given set P predicates
set C constants, denote P C set propositions formed P
C. Given set X variables, denote LX set literals l use variables
X. Note l may use arbitrary predicates constants.7 l literal, write
l[X] indicate l variable arguments X. X = {x1 , . . . , xk } C = (c1 , . . . , ck ),
l[c1 , . . . , ck /x1 , . . . , xk ] denote respective substitution, abbreviated l[C].
way, use substitution notation construct involving variables. Slightly abusing
notation, use vector constants denote set constants appearing it. Further,
function assigns constants variables X, l[a/X] denote substitution
argument x X replaced a(x). concerned first-order logic, is,
whenever write formula mean first-order formula. denote true 1 false 0.
clause, integrity constraint, disjunction literals universal quantification
outside. variables quantified exactly appear least one literals.
example, x, : G(x, y) H(x) integrity constraint x, y, z : G(x, y) H(x) x :
G(x, y)H(x) not. operator tuple (Xo , preo , Yo , effo ), Xo , Yo sets variables, preo conjunction literals LXo , effo conjunction literals LXo Yo .8
intended meaning Xo inputs Yo outputs, i.e., new constants created
operator. operator o, action given (prea , effa ) (preo , effo )[Ca /Xo , Ea /Yo ]
Ca Ea vectors constants. Ea require constants pairwise different makes sense output new constant twice. Given action a, refer
inputs outputs Ca Ea , respectively. use notations prea , effa
obvious meaning.
WSC task, planning task, tuple (P, IC , O, C0 , 0 , G ). Here, P set predicates.
IC set integrity constraints. set operators C0 set constants, initial
constants supply. 0 conjunction ground literals, describing possible initial states. G
conjunction literals existential quantification outside, describing goal states,
e.g., x, : G(x) H(y). predicates taken P, constants taken C0 .
constructs (e.g., sets conjunctions) finite. sometimes identify IC
conjunction clauses contains. Note existential quantification goal variables
7. One could course introduce general notations logical constructs using set predicates constants.
However, herein two notations given suffice.
8. stated, address disjunctive non-deterministic effects. topic future work.

61

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

provides option instantiate goal constants created planning obtaining objects
requested goal may possible use outputs.
various formulas occurring (P, IC , O, C0 , 0 , G ) may make use constants C0 .
Specifically, case clauses IC goal formula G . Allowing use
constants effect complexity algorithmic results. conceivable
feature may useful. simple example, VTA domain user may wish select
particular train. Say train company provides table trains itineraries. table
represented 0 , possibly help IC stating constraints hold particular trains.
user select train, say ICE107, pose goal : ticketFor (y, ICE107).
Constraining produced ticket way would possible without use pre-existing
constants (or would least require rather dirty hack, e.g., encoding desired train terms
special predicate).
Operator descriptions, is, preconditions effects, may use constants C0 .
value benign IC G one always replace constant c
precondition/effect new input/output variable x, instantiate x (during planning)
c. Note, however, would give planner option (uselessly) instantiate x
constant, may hence affect planning performance. example, might
special operator booking ticket ICE107 (e.g., train particular ticketing regulations).
correspondence WSC task web service composition task fairly obvious.
set P predicates formal vocabulary used underlying ontology. set IC
integrity constraints set axioms specified ontology, i.e., domain constraints
subsumption relations. set operators set web services. Note formalization
corresponds closely notion IOPE descriptions: inputs, outputs, preconditions,
effects (Ankolekar et al., 2002; Burstein et al., 2004). action corresponds web service call,
web services parameters instantiated call arguments.
constructs C0 , 0 , G extracted user requirement composition.
assume requirements take form IOPE descriptions. Then, C0
user requirement inputs, 0 user requirement precondition. words, C0 0
describe input given composition user. Similarly, G user requirement effect
condition user wants accomplished user requirement outputs
(existentially quantified) variables G .
3.2 Semantics
follows, assume given WSC task (P, IC , O, C0 , 0 , G ). able model
creation constants, states (also called world states) formalism enriched set
constants exist them. state pair (Cs , ) Cs set constants,
Cs -interpretation, i.e., truth value assignment : P Cs 7 {0, 1}. Quantifiers taken range
constants exist state. is, C-interpretation formula,
writing |= mean |= C C except quantifiers
restricted range C. avoid clumsy notation, sometimes write |= abbreviate
|= .
core definition specifies application action affects state. defined
form belief update. Let us first define latter. Assume state s, set constants
C Cs , formula . define update(s, C , ) set interpretations result

62

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

creating constants C \ Cs , updating according semantics proposed
Winslett (1988).
Say I1 I2 C -interpretations. define partial order interpretations,
setting I1 <s I2
{p P Cs | I1 (p) 6= (p)} {p P Cs | I2 (p) 6= (p)}.

(1)

words, I1 ordered I2 iff differs proper subset values. Given this,
formally define update(s, C , ). Let arbitrary C -interpretation. define
update(s, C , ) : |= {I | |= , <s I} = .

(2)

Hence, update(s, C , ) defined set C -interpretations satisfy ,
minimal respect partial order <s . Put different terms, update(s, C , ) contains
interpretations differ set-inclusion minimal set values.
Now, assume action a. say applicable s, short appl(s, a), |= prea ,
Ca Cs , Ea Cs = . is, top usual precondition satisfaction require
inputs exist outputs yet exist. result executing is:

{(C , ) | C = Cs Ea , update(s, C , IC effa )} appl(s, a)
(3)
res(s, a) :=
{s}
otherwise
Note executed even applicable. case, outcome singleton
set containing itself, i.e., action affect state. important aspect
formalism, get back below. IC effa unsatisfiable, obviously get
res(s, a) = . say case inconsistent.9
overall semantics WSC tasks easily defined via standard notion beliefs.
model uncertainty true state world. belief b set world states
possible given point time. initial belief
b0 := {s | Cs = C0 , |= IC 0 }.

(4)

action inconsistent belief b inconsistent least one b. latter
case, res(b, a) undefined. Otherwise, defined
[
res(s, a).
(5)
res(b, a) :=
sb

extended action sequences obvious way. plan sequence ha1 , . . . ,
res(b0 , ha1 , . . . , i) : |= G .

(6)

illustration, consider formalization example Section 2.
Example 2 Reconsider Example 1. sake conciseness, formalize part
example, simplified axioms. WSC task defined follows:
9. Unless IC mentions constants, based operator inconsistent, action based
inconsistent. operators can, principle, filtered pre-process planning.

63

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

P = {protein, cellProtein, G, H, I, 1n55, 1kw3, InfoDSSP, Info3D, combinedPresentation},
predicates unary.
IC consists clauses:
x : cellProtein(x) protein(x) [subsumption]
x : protein(x) G(x) H(x) I(x) [at least one DSSP value]
x : protein(x) 1n55(x) 1kw3(x) [at least one 3-D shape]
x : cellProtein(x) G(x) 1n55(x) [dependency]
x : cellProtein(x) H(x) 1n55(x) [dependency]
consists operators:
getInfoDSSPG : ({x}, G(x), {y}, InfoDSSP(y))
getInfoDSSPH : ({x}, H(x), {y}, InfoDSSP(y))
getInfoDSSPI : ({x}, I(x), {y}, InfoDSSP(y))
getInfo3D1n55 : ({x}, 1n55(x), {y}, Info3D(y))
getInfo3D1kw3 : ({x}, 1kw3(x), {y}, Info3D(y))
combineInfo: ({x1 , x2 }, InfoDSSP(x1 ) Info3D(x2 ), {y}, combinedPresentation(y))
C0 = {c}, 0 = cellProtein(c)
G = x : combinedPresentation(x)
illustrate formalism, consider plan example task.
initial belief b0 consists states Cs = {c} |= IC cellProtein(c). Say
apply following sequence actions:
1. Apply getInfoDSSPG (c, d) b0 . get belief b1 b0 except
that, b0 |= G(c), new states generated constant
InfoDSSP(d).
2. Apply getInfoDSSPH (c, d) b1 . get belief b2 new states
InfoDSSP(d) generated b1 |= H(c).
3. Apply getInfo3D1n55 (c, e) b2 , yielding b3 .
4. Apply getInfo3D1kw3 (c, e) b3 . yields b4 , get e Info3D(e) b2
|= 1n55(c) |= 1kw3(c).
5. Apply combineInfo(d, e, f ) b4 . brings us b5 b4 except
b4 d, e Cs new states generated f combinedPresentation(f ).
dependencies IC (the last two clauses), get b0 satisfies either G(c)
H(c). subsumption clause clause regarding 3-D shapes (first third clauses)
get b0 satisfies either 1n55(c) 1kw3(c). Hence, easy verify, b5 |=
G hgetInfoDSSPG (c, d), getInfoDSSPH (c, d), getInfo3D1n55 (c, e), getInfo3D1kw3 (c, e),
combineInfo(d, e, f )i plan.
64

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

Note plan make use getInfoDSSPI (c, d). obtain plan, domain
one always apply information services. However, plan trivial take
account relevant not. Reasoning IC enables us find better plans.
semantics executing non-applicable actions vital workings Example 2.
pointed above, definition res(s, a) (Equation (3)), executed even
applicable. realizes partial matches: web service called soon might match
one possible situations. planning terms, actions conditional effects semantics.10
contrasting notion would enforce preconditions, i.e., say res(s, a) undefined
applicable s. would correspond plug-in matches.
Example 2, partial match semantics necessary order able apply actions
cover particular cases. example, consider action getInfoDSSPG (c, d), applied
initial belief example plan. precondition action G(c). However,
states initial belief satisfy precondition. initial belief allows
interpretation satisfying IC 0 (cf. Equation (4)), interpretations satisfy H(c)
rather G(c). Due partial match semantics, getInfoDSSPG (c, d) affect
states match initial belief partial.
Clarification order regarding understanding constants. First, every PDDLlike planning formalism (we aware of), make unique name assumption, i.e., different
constants refer different objects. Second, understanding web services output
create separate individual, i.e., separate information object.
latter directly raises question allow actions share output constants.
answer allow planner treat two objects same. makes
sense two objects play role plan. Consider Example 2. actions
getInfoDSSPG (c, d) getInfoDSSPH (c, d) share output constant, d. means
one name two separate information objects. two objects properties,
derived InfoDSSP(d). difference created different
cases, namely states satisfy G(c) H(c) respectively. single name
two objects useful take name parameter actions need
distinguish different cases. example, combineInfo(d, e, f ) action.
hinted, cases correspond different classes concrete execution traces.
Importantly, particular execution trace, output constant created once. see
this, consider execution trace s0 , a0 , s1 , a1 , . . . , ak , sk+1 , i.e., alternating sequence states
actions s0 b0 , si+1 res(si , ai ) 0 k. Say ai aj share
output constant, d. Say ai applicable si , hence Csi+1 . Then, quite
obviously, Csl + 1 l k + 1. particular, aj applicable sj :
intersection output constants Csj non-empty (cf. definition appl(s, a)). So, due
definition action applicability, never happen constant created twice.
words, never reachable state single constant name refers
one individual information object. sense, use one name several objects occurs
planning time, actual execution trace actual case occur
known. illustration, consider getInfoDSSPG (c, d) getInfoDSSPH (c, d), shared
10. obvious generalization allow several conditional effects per action, style ADL language (Pednault, 1989). omit sake simplifying discussion. extension direction straightforward.

65

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

output d, Example 2. Even concrete state s0 b0 execution starts satisfies
G(c) H(c), one actions fire namely one comes first.
remark initially experimented definition actions instantiate
inputs, applied state outputs are, virtue execution semantics,
instantiated constants outside Cs . framework, one never choose share output
constants, i.e., use name two different outputs. notion settled
strictly richer: planner always choose instantiate outputs constants outside Cs .
question is, make sense share outputs? Answering question domainindependent planner may turn quite non-trivial. get back discuss
possible adaptation CFF Section 4.5. experiments reported herein (Section 6), use
simple heuristic. Outputs shared iff operator effects identical (giving indication
respective outputs may indeed play role plan).
conclude sub-section final interesting observation regarding modeling
framework. Negative effects essential part WSC formalism: compiled
away. simply replace negative effect G(x1 , . . . , xk ) notG(x1 , . . . , xk ) (introducing
new predicate) state integrity constraints two equivalent. is, introduce two new clauses x1 , . . . , xk : G(x1 , . . . , xk ) notG(x1 , . . . , xk ) x1 , . . . , xk :
G(x1 , . . . , xk ) notG(x1 , . . . , xk ). simple compilation technique, formal
details little intricate, moved Appendix A. action original task,
a+ denotes corresponding action compiled task, vice versa. Similarly, action
original task, s+ denotes corresponding state compiled task. get:
Proposition 1 (Compilation Negative Effects WSC) Assume WSC task (P, IC , O, C0 ,
+
0 , G ). Let (P + , +
IC , , C0 , 0 , G ) task negative effects compiled away.
Assume action sequence ha1 , . . . , i. Let b result executing ha1 , . . . , (P, IC ,
+
+
+
+
O, C0 , 0 , G ), let b+ result executing ha+
1 , . . . , (P , IC , , C0 , 0 , G ).
Then, state s, b iff s+ b+ .
proved straightforward application relevant definitions. important aspect result new clauses introduced allowed forward effects
strictly forward effects special cases identified later. Hence, hardness results transfer directly
tasks without negative effects dropping negative effects cannot make algorithms easier.
3.3 Computational Properties
perform brief complexity analysis WSC formalism general form
introduced above. line many related works kind (Eiter & Gottlob, 1992; Bylander,
1994; Liberatore, 2000; Eiter et al., 2004), consider propositional case. context,
means assume fixed upper bound arity predicates, number input/output
parameters operator, number variables appearing goal, number
variables clause. refer WSC tasks restricted way WSC tasks fixed
arity.
consider problems checking plans testing whether given action sequence
plan deciding plan existence. latter, distinguish polynomially bounded
plan existence, unbounded plan existence. deem particularly relevant decision
problems context plan generation. Certainly, plan checks integral part plan gen66

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

eration. Indeed, planning tool based state space search, tool either performs
checks explicitly (potentially many) plan candidates generated search, complexity
inherent effort underlies computation state transitions. Polynomially bounded
plan existence relevant because, commonly used planning benchmark domains, plans
polynomial length (it wide-spread intuition SWS community composed
web services contain exceedingly large numbers web services). Finally, unbounded plan
existence general decision problem involved, thus generic interest.
problems turn hard. prove this, reuse adapt various results
literature. start complexity plan checking, hardness follows
long established result (Eiter & Gottlob, 1992) regarding complexity belief update.
results, detailed proofs available Appendix A.
Theorem 1 (Plan Checking WSC) Assume WSC task fixed arity, sequence
ha1 , . . . , actions. p2 -complete decide whether ha1 , . . . , plan.
Proof Sketch: Membership shown guess-and-check argument. Guess proposition
values along ha1 , . . . , i. check whether values comply res, lead
inconsistent action, final state satisfy goal. ha1 , . . . , plan iff
case guess proposition values. Checking goal satisfaction polynomial, checking
compliance res coNP, checking consistency NP.
Hardness follows simple adaptation proof Lemma 6.2 Eiter Gottlob
(1992). proof uses reduction checking validity QBF formula X.Y.[X, ].
lemma considers case propositional belief updated arbitrary (propositional)
formula , decision problem ask whether formula implied
updated belief. proof, complete conjunction literals, i.e., corresponds single
world state. single propositional fact r true . semantics X.Y.[X, ]
encoded complicated construction defining update . nutshell, CNF telling
us every assignment X (which yield world state updated belief), either
find assignment [X, ] holds (completing ), falsify r.
difference setting lies restricted update formulas action effects
fact integrity constraints supposed hold every belief. adapt
proof by, first, taking integrity constraints clauses Eiter Gottlobs CNF formula
. modify constraints need true new fact holds i.e., insert
every clause. initial belief false, otherwise corresponds exactly above.
action plan makes true. goal Eiter Gottlobs fact r.
2
remark membership Theorem 1 remains valid allowing actions multiple
conditional effects, allowing parallel actions, even allowing combination.
hand, virtue proof argument outlined, hardness holds even initial state
literals 0 complete (describe single world state), plan consists single action
single positive effect literal, goal single propositional fact initially true.
next consider polynomially bounded plan existence. this, membership follows directly
Theorem 1. prove hardness, construct planning task extends Eiter Gottlobs
construction actions allow choose valuation third, existentially quantified, set variables, hence reduces validity checking QBF formula X.Y.Z.[X, Y, Z].

67

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

Theorem 2 (Polynomially Bounded Plan Existence WSC) Assume WSC task fixed arity, natural number b unary representation. p3 -complete decide whether exists
plan length b.
Proof: membership, guess sequence b actions. Theorem 1, check
p2 oracle whether sequence plan.
hardness, validity QBF formula X.Y.Z.[X, Y, Z], CNF, reduced
testing plan existence. Say X = {x1 , . . . , xn }. planning task, n actions (operators
empty input/output parameters) oxi oxi former sets xi true latter
sets xi false. Further, action ot corresponds action used hardness
proof Theorem 1. actions equipped preconditions effects ensuring
plan must first apply, 1 n, either oxi oxi , thereafter must apply ot (of course
enforcing latter requires new goal fact achieved ot ). Hence, choosing
plan candidate task choosing value assignment aX variables X.
construction, oxi oxi actions executed, one ends belief
contains single world state, value assignment aX variables X corresponds
chosen actions. world state basically corresponds belief hardness proof
Theorem 1. difference construction extended cater third
set variables. straightforward. Then, belief results executing ot satisfies
goal iff Eiter Gottlobs fact r holds world states. virtue similar arguments
Eiter Gottlob, latter case iff Y.Z.[aX /X, Y, Z], i.e., substitution
X.Y.Z.[X, Y, Z] aX , valid. this, claim follows.
2
final result regards unbounded plan existence WSC. result relatively easy
obtain generic reduction described Bylander (1994) prove PSPACE-hardness plan
existence STRIPS. Somewhat shockingly, turns plan existence WSC undecidable
even without integrity constraints, complete initial state description. source
undecidability is, course, ability generate new constants on-the-fly.
Theorem 3 (Unbounded Plan Existence WSC) Assume WSC task. decision problem
asking whether plan exists undecidable.
Proof Sketch: modification proof Bylander (1994) plan existence propositional STRIPS planning PSPACE-hard. original proof proceeds generic reduction,
constructing STRIPS task Turing Machine polynomially bounded space. latter restriction necessary model machines tape: tape cells pre-created positions within
bound. Exploiting ability create constants on-the-fly, instead introduce simple
operators allow extend tape, ends.
2
able decide plan existence is, course, significant limitation principle. However, limitation probably marginal importance practice, planning tools
assume plan, try find rather trying prove
plan. sense, planning tools are, nature, semi-decision procedures anyway.
matters decidability setting question whether one find plan

68

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

quickly enough, i.e., exhausting time memory.11 relevant question
web service composition.

4. Forward Effects
high complexity planning WSC motivates search interesting special cases.
define special case, called forward effects, every change action makes state involves
newly generated constant.
start section defining forward effects case making core observation
semantics. discuss modeling power special case. Next, discuss forward effects general perspective belief update. analyze main computational
properties forward effects, conclude section assessment existing
planning tool could adapted handle forward effects.
4.1 WSC|f wd Semantics
forward effects special case WSC defined follows.
Definition 1 Assume WSC task (P, IC , O, C0 , 0 , G ). task forward effects iff:
1. O, l[X] effo , X Yo 6= .
2. clauses IC , = x1 , . . . , xk : l1 [X1 ] ln [Xn ], X1 =
= Xn .
set WSC tasks forward effects denoted WSC|f wd .
first condition says variables every effect literal contain least one output variable. implies every ground effect literal action contains least one new constant.
second condition says that, within every integrity constraint, literals share arguments.
implies effects involving new constants affect literals involving new constants.
Note that, since x1 , . . . , xk definition exactly variables occurring literals,
Xi Xi = x1 , . . . , xk . Note may k = 0, i.e., literals
clause may ground. intentional. constants mentioned clause must
taken C0 , cf. discussion Section 3.1. Therefore, clauses interaction
statements new constants generated WSC|f wd action.
discuss modeling power WSC|f wd (Section 4.2). First, observe
semantics WSC|f wd much simpler general WSC. One longer needs
notion minimal change respect previous state. state precisely, assume

WSC task predicates P. Say interpretation P C , C set constants.
Say C C . denote |C restriction P C , i.e., interpretation P C
coincides propositions. Given state action a, define:

{(C , ) | C = Cs Ea , |Cs = , |= IC effa } appl(s, a)
(7)
res|f wd (s, a) :=
{s}
otherwise
11. Indeed planning community generally rather unconcerned undecidability, cf. numeric track international planning competitions, Helmerts (2002) results decidability numerical planning problems.

69

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

Compare Equation (3), defined member update(s, C , IC effa ),
returns interpretations satisfy IC effa differ minimally . Equation (7), simply set identical , constants (on propositions constants)
existed beforehand. words, set new states get cross-product old
state satisfying assignments IC effa .
Lemma 1 (Semantics WSC|f wd ) Assume WSC|f wd task, reachable state s, action
a. res(s, a) = res|f wd (s, a).
Proof Sketch: WSC|f wd , differs minimally s, follows agrees totally
s, set propositions P Cs interpreted s. see this, denote P Cs +Ea
set propositions arguments Cs Ea , least one argument Ea , denote
IC [Cs + Ea ] instantiation IC constants Cs Ea , clause
least one variable instantiated Ea . key argument |= IC effa equivalent
|= IC [Cs Ea ] effa , turn equivalent |= IC [Cs ] IC [Cs + Ea ] effa .
last formula, IC [Cs ] uses propositions P Cs , whereas IC [Cs + Ea ] effa
uses propositions P Cs +Ea . Since reachable, |= IC [Cs ]. Therefore, satisfy
IC effa , need change values assigned s.
2
4.2 Modeling Power
Intuitively, WSC|f wd covers situation web service outputs new constants, sets
characteristic properties relative inputs, relies ontology axioms describe
ramifications concerning new constants. detailed Section 2, closely corresponds
various notions message-based WSC explored literature. sense, modeling
power WSC|f wd comparable message-based WSC, one most-widespread
approaches area.
simple concrete way assessing modeling power WSC|f wd consider allowed
disallowed axioms. Examples axioms allowed WSC|f wd are: attribute domain
restrictions, taking form x, : G(x, y) H(x); attribute range restrictions, taking form
x, : G(x, y) H(y); relation transitivity, taking form x, y, z : G(x, y) G(y, z)
G(x, z). Note that, axioms, easy construct case action effect, even
though involves new constant, affects old belief. example, constants c e existed
beforehand, action outputs sets G(c, d) G(d, e), axiom x, : G(x, y)
G(y, z) G(x, z) infers G(c, e) statement involve new constant d.
Typical ontology axioms allowed WSC|f wd are: subsumption relations, taking
form x : G(x) H(y); mutual exclusion, taking form x : G(x) H(y); relation reflexivity, taking form x : G(x, x); relation symmetry, taking form x, :
G(x, y) G(y, x). express concept G contained union concepts
H1 , . . . , Hn , generally express complex dependencies concepts, taking form clausal constraints allowed combinations concept memberships.
One example complex dependencies important domain proteins illustrated
Example 1. Capturing dependencies important order able select correct web services. Similar situations arise many domains involve complex interdependencies
and/or complex regulations. example latter Virtual Travel Agency discussed before. example, German rail system kinds regulations regarding
70

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

train may booked kind discount conditions. Modeling
regulations would enable WSC algorithm select appropriate booking services. Another interesting case hospital domain described de Jonge, van der Linden, Willems (2007).
There, problem hospital asset tracking handled means set tracking, logging
filter services, transform logs extract various kinds information. setting, would
make sense model complex dependencies web service composer may determine
hospital assets need tracked retrieved. Namely, latter depends type operation
question, kind examinations operation requires. Accordingly,
need model categorization operations, mapping sets required examinations,
examinations associated hospital assets. complications arise since
required examinations/assets may depend particular circumstances. Clearly, express
categorization dependencies terms clauses. course captures fraction
relevant hospital, considerably informed composer always
tracks assets.
main weakness WSC|f wd allow us express changes regarding preexisting objects. best illustrated considering case negative effects.12
planning community, commonly used model previous properties objects
invalidated action. illustration, reconsider Example 1. Say additional operator
dropCoffeeIn3Dmachine, effect Info3D(y). One would normally expect that,
operator applied, fact Info3D(y) deleted must re-established.
WSC|f wd . According restrictions special case imposes, variable Info3D(y)
must output dropCoffeeIn3Dmachine. is, dropping coffee machine creates
new object, whose characteristic property happens Info3D(y) rather Info3D(y). Clearly,
intended semantics operator.
model intended semantics, would need instantiate pre-existing constant.
Say that, belief b3 Example 1, constant e Info3D(e) previously created
getInfo3D1n55 (c, e). WSC|f wd allow us instantiate dropCoffeeIn3Dmachine
e, effect Info3D(e). However, virtue definition action applicability,
action applicable states e yet exist corresponding execution
paths getInfo3D1n55 (c, e) executed. Hence property Info3D(e) get
deleted state, e used dropCoffeeIn3Dmachine still regarded newly
created object whose characteristic property Info3D(y). difference new action
makes that, now, plan uses name (e) refer two different information objects
(output getInfo3D1n55 (c, e) vs. output dropCoffeeIn3Dmachine) play
role plan, cf. discussion Section 3.2.
interesting workaround let operators output time steps, spirit reminiscent
situation calculus (McCarthy & Hayes, 1969; Reiter, 1991). Every operator obtains extra
output variable t, included every effect literal. new time step stated stand
relation previous time steps, e.g., next(tprev, t) tprev input variable
instantiated previous time step. setting, state world changes
time. particular state object property different tprev.
example, action moves file f RAEDME README could state
name(f, RAEDME, tprev) name(f, README, t). problem construction
12. Or, WSC, positive effects triggering negative effects via IC , cf. Proposition 1.

71

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

time steps special interpretation, ordinary objects.13 causes
least two difficulties. (1) want refer object property, know time step
first place is, know whether actual time step tprev. Note
cannot maintain predicate actualTime(x) would require us invalidate
property tprev. (2) solution frame problem. operators must explicitly state
every relevant property previous time step, property changed new time
step.14
conclude sub-section, let us consider WSC|f wd generalized without losing
Lemma 1. importantly, instead requiring every effect literal involves new constant,
one postulate literals may actually affected integrity constraints.
particular, predicate appear clauses, certainly effect literal
predicate harmful even involve output constant. One obtains potentially stronger notion considering ground literals, rather predicates. Note kind
generalization solves difficulty (1) time-step construction, presuming time steps
constrained clauses. (The frame problem, however, persists.)
Another possibility, deviating somewhat way WSC WSC|f wd currently defined, define integrity constraints terms logic programming style rules, along lines
Eiter et al. (2003, 2004). requirement WSC|f wd relaxed postulate
effect literals without new constants appear rule heads.
remark latter observation suggests certain strategic similarity aforementioned derived predicates (Thiebaux et al., 2005) previously used AI Planning manage
complexity integrity constraints. There, integrity constraints take form stratified logic
programming style derivation rules, predicates appearing rule heads allowed
appear operator effects. overly restricted solution, WSC context. effects
web services indeed likely affect concepts relations appearing ontology
axioms. may WSC|f wd , long output constants involved.
4.3 Belief Update
Lemma 1 specific possible models approach (Winslett, 1988) underlies semantics
action applications. interesting consider semantics WSC|f wd general
perspective belief update. Recall update involves formula characterizing current
belief, formula describing update. seek formula characterizes updated belief.
wide variety definitions proposed updated belief defined.
However, common ground exists. Katzuno Mendelzon (1991) suggest eight postulates,
named (U1) . . . (U8), every sensible belief update operation satisfy. Herzig Rifi
(1999) discuss detail degree postulates satisfied wide range alternative
belief update operators. particular call postulate uncontroversial update operators
investigation satisfy them. take results following. examine
extent draw conclusions updated belief, , setting forward effects
case, relying Herzig Rifis uncontroversial postulates.
13. Note similarity situation calculus ends. Whereas time steps assigned specific role
formulas used situation calculus, ordinary objects handled actions, packages
blocks.
14. Despite difficulties, Theorem 6 shows time step construction used simulate Abacus
machine, hence prove undecidability plan existence WSC|f wd .

72

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

assume planning task predicates P given. need following notations:
formulas, denotes formula results updating belief
update , semantics belief update operator .
Given disjoint sets constants C E, P C+E denotes set propositions formed
predicates P, arguments contained C E exists least one
argument contained E. (Recall P C denotes set propositions formed
predicates P arguments C.)
Given set constants C, IC [C] denotes instantiation IC C. is, IC [C]
conjunction clauses result replacing variables clause IC ,
= x1 , . . . , xk : l1 [X1 ] ln [Xn ], tuple (c1 , . . . , ck ) constants C.
Given disjoint sets constants C E, IC [C + E] conjunction clauses
result replacing variables clause IC , = x1 , . . . , xk : l1 [X1 ]
ln [Xn ], tuple (c1 , . . . , ck ) constants C E, least one constant taken
E.15
ground formula P () denote set propositions occurring .
denote current belief update . another convention, given set
constants C, writing C indicate P () P C . Similarly, given disjoint sets constants
C E, writing C+E indicate P () P C+E . state, denote
conjunction literals satisfied s.
first consider case where, similar claim Lemma 1, corresponds single
concrete world state s. want apply action a. wish characterize set states
res(s, a), i.e., wish construct formula . simplicity notation, denote C := Cs
E := Ea . applicable s, nothing do. Otherwise, that:
(I) IC [C] C P ( C ) P C .
example, set C := . Since |= IC , get desired equivalence. Further,
that:
(IIa) IC [C] IC [C + E] effa ;
(IIb) P (IC [C + E]) P C+E P (effa ) P C+E .
(IIa) holds trivially: defined IC effa , equivalent IC [C E] effa
equivalent IC [C] IC [C + E] effa . (IIb), consequence forward effects
case. Every effect literal contains least one output constant, hence effa contains propositions
P C+E . IC [C + E], least one variable clause instantiated
constant e E. Since, definition, literals clause share variables, e appears
every literal therefore IC [C + E] contains propositions P C+E .
illustration, consider simple VTA example. four predicates, train(x),
ticket(x), trainTicket(x), ticketFor (x, y). set integrity constraints IC consists
15. clause IC contains variable, IC [C + E] empty. customary, empty conjunction
taken true, i.e., 1.

73

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

single axiom x : trainTicket(x) ticket(x). current state s, Cs = {c},
sets propositions 0 except train(c). consider application action
= bookTicket(c, d), whose precondition train(c), whose set E output constants {d},
whose effect effa trainTicket(d) ticketFor (d, c). setting, have: IC [C] =
(trainTicket(c) ticket(c)); C = (train(c)ticket(c)trainTicket(c)ticketFor (c, c));
IC [C + E] = (trainTicket(d) ticket(d)).
derive following that:
(III) (IC [C] C ) (IC [C + E] effa ).
is, characterize updated belief simply conjunction previous belief
action effect extended instantiation ontology axioms. corresponds
exactly Lemma 1. illustrate, continue VTA example. left hand side (III)
refers four propositions based c, sets according s. right hand side
refers propositions based trainTicket(d) ticket(d) well proposition
ticketFor (d, c) links c d.
one prerequisite derivation (III), make assumption which, best
knowledge, discussed anywhere belief update literature:
(IV) Let 1 , 1 , 2 , 2 formulas P (1 ) P (1 ) = , P (1 ) P (2 ) = , P (2 )
P (1 ) = , P (2 ) P (2 ) = . (1 1 ) (2 2 ) (1 2 ) (1 2 ).
assumption postulates formulas talking disjoint sets variables updated
separately. Since formulas disjoint variables essentially speak different aspects
world, seems reasonable assumption.
Now, start formula . make replacements according (I) (IIa), leading
equivalent formula (IC [C] C ) (IC [C] IC [C + E] effa ). map
formula onto (IV) taking 1 IC [C] C , 1 1, 2 IC [C], 2
IC [C + E] effa . Hence, separate update two parts follows:
(A) ( )C := (IC [C] C ) IC [C]
(B) ( )C+E := 1 (IC [C + E] effa )
According (IV), obtain desired formula ( )C ( )C+E .
Illustrating VTA example, simply separate parts update talk
c talk combination constants. (A) part
update trainTicket(c) ticket(c) conjoined , updated trainTicket(c)
ticket(c). (B) part update 1 representing (empty) statement previous state
makes updated (trainTicket(d) ticket(d)) trainTicket(d) ticketFor (d, c).
remains examine ( )C ( )C+E . need prove that:
(C) ( )C IC [C] C ,
(D) ( )C+E IC [C + E] effa .
Essentially, means prove that: (C) updating formula something already implies
incur changes; (D) updating 1 formula yields belief equivalent formula.
see this, compare (A) (C) (B) (D).
74

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

two statements may sound quite trivial, fact far trivial prove
wide variety of, partly rather complex, belief update operations literature. build
works Katzuno Mendelzon (1991) Herzig Rifi (1999). need two
postulates made Katzuno Mendelzon (1991), namely:
(U1) 1 2 : (1 2 ) 2 .
(U2) 1 2 : 1 2 (1 2 ) 1 .
Herzig Rifi (1999) prove (U1) uncontroversial, meaning satisfied belief
update operators investigated (cf. above). prove (U2) equivalent conjunction two weaker statements, one uncontroversial, namely:
(U2a) 1 2 : (1 2 ) (1 2 ).
statement uncontroversial. However, proved satisfied non-causal
update operators investigation, except so-called Winsletts standard semantics (Winslett,
1990). latter semantics useful context anyway. restriction makes
states res(s, a) differ propositions mentioned update
formula. case, include propositions appearing IC [C E], bound
quite lot. So, use Winsletts standard semantics, res(s, a) would likely
retain hardly information s.
Consider formula ( )C specified (A), ( )C = (IC [C] C ) IC [C].
prove (C). indeed quite simple. (IC [C] C ) IC [C],
instantiate 1 (U2) IC [C] C , 2 (U2) IC [C]. obtain
(IC [C] C ) IC IC [C] C , hence ( )C IC [C] C desired.
said above, result uncontroversial, holds non-causal update operators
(except Winsletts standard semantics) investigated Herzig Rifi (1999). terms VTA
example, (U2) allowed us conclude update trainTicket(c) ticket(c) make
change previous belief, already contains property.
Next, consider formula ()C+E specified (B), ()C+E = 1(IC [C +E]effa ).
prove (D). postulate (U1), get ( )C+E IC [C + E] effa ,
IC [C +E]effa update formula 2 . direction, exploit (U2a). instantiate
1 (U2a) 1, get 1 (IC [C + E] effa ) 1 (IC [C + E] effa ),
1 (IC [C + E] effa ) ( )C+E , equivalent IC [C + E] effa
( )C+E . proves claim. Note used postulates uncontroversial
according Herzig Rifi (1999). Reconsidering VTA example, IC [C +E]effa =
(trainTicket(d) ticket(d)) trainTicket(d) ticketFor (d, c). previous state say
anything propositions, thus represented 1. postulates allow us conclude
(for belief update operators investigated Herzig & Rifi, 1999) resulting belief
equivalent (trainTicket(d) ticket(d)) trainTicket(d) ticketFor (d, c).
far, restricted case , belief updated, corresponds single
world state s. Consider general case characterizes belief b, want
characterize set states res(b, a). first glance, seems much changes,
Katzuno Mendelzon (1991) make following postulate:
(U8) 1 , 2 , : (1 2 ) (1 ) (2 ).

75

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

means that, consists two alternate parts, updating taking union
updated parts. words, compute update state-by-state basis.
statement (I) still true, C disjunction states
b, rather single . rest argumentation stays exactly same. Herzig
Rifi (1999) prove (U8) uncontroversial leave that.
However, matters simple. source complications use partial
matches/conditional effects semantics. update formula different individual states
b. Hence cannot directly apply (U8). Obviously, states s1 b applicable updated differently states s2 b applicable latter updated all.16
somewhat subtle distinction states b constants exist them: different
sets constants, integrity constraints update different. Hence, obtain generic
update , split equivalence classes 1 , . . . , n states within
cannot distinguished based prea based existing constants. Then, (U8)
argumentation used show equivalent (III) . last step,
defining final disjunction individual , appears sensible.
follow immediately Katzuno Mendelzon (1991).
illustration, consider variant VTA example two preceding states, one
state train(c) before, new state ticket(c) instead. ,
bookTicket(c, d) applicable, hence update different . part
above, yielding result (trainTicket(d) ticket(d)) trainTicket(d) ticketFor (d, c).
update trivial, yields result. final outcome disjunction
two beliefs.
point situation much easier consider plug-in matches (i.e., forced preconditions) instead partial matches. There, applicable states, easy
see every state b constants. Therefore, plug-in matches, (III) follows immediately (U8). VTA example, update would computed since
bookTicket(c, d) would considered applicable preceding belief. satisfies
train(c) disagrees aspect, e.g. (quite nonsensically) ticket(c) holds,
updated belief equivalent (s ) (trainTicket(d) ticket(d)) trainTicket(d)
ticketFor (d, c).
4.4 Computational Properties
Paralleling analysis general WSC Section 3.3, perform brief complexity
analysis WSC|f wd special case. before, consider propositional case
assumes fixed upper bound arity predicates, number input/output parameters
operator, number variables appearing goal, number variables
clause. before, consider decision problems checking plans, deciding
polynomially bounded plan existence, deciding unbounded plan existence, order.
contrast before, cannot reuse results literature much because, course,
particular circumstances WSC|f wd investigated before. include proof sketches
here, refer Appendix detailed proofs.
16. One might speculate common update would prea , case. example,
possible models approach adopt WSC, updating |= prea prea gives rise result
states change violate prea instead changing satisfy .

76

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

Thanks simpler semantics per Lemma 1, plan checking much easier WSC|f wd
WSC.
Theorem 4 (Plan Checking WSC|f wd ) Assume WSC|f wd task fixed arity, sequence ha1 , . . . , actions. coNP-complete decide whether ha1 , . . . , plan.
Proof Sketch: Hardness obvious, considering empty sequence. Membership shown
guess-and-check argument. Say C union C0 output constants appearing
ha1 , . . . , i. guess interpretation propositions P C. Further,
1 n, guess set Ct constants. needs time-stamped because, action
generated outputs, properties respective propositions remain fixed forever. Thanks
Lemma 1, check polynomial time whether (a) Ct correspond execution
ha1 , . . . , i. Also, check polynomial time whether (b) Cn satisfy G . ha1 , . . . ,
plan iff guess answer (a) yes answer (b) no.
2
Membership Theorem 4 remains valid allowing parallel actions multiple conditional effects provided one imposes restrictions ensuring effects/actions applied simultaneously (in one step) never self-contradictory. Otherwise, checking plans involves
consistency test plan step, NP-complete problem. Note quite reasonable demand simultaneous actions/effects contradict other. Widely used
restrictions imposed ensure mutually exclusive effect conditions, and/or non-conflicting
sets effect literals.
next consider polynomially bounded plan existence. Membership follows directly Theorem 4. prove hardness, reduce validity checking QBF formula X.Y.[X, ].
constructed planning task allows choose values X, thereafter apply actions evaluating arbitrary values . goal accomplished iff setting X exists works
.
Theorem 5 (Polynomially Bounded Plan Existence WSC|f wd ) Assume WSC|f wd task
fixed arity, natural number b unary representation. p2 -complete decide whether
exists plan length b.
Proof Sketch: membership, guess sequence b actions. Theorem 4,
check NP oracle whether sequence plan.
Hardness proved reduction
Wk validity checking QBF formula X.Y.[X, ]
DNF normal form, i.e., = j=1 j . key idea use outputs creation
time steps, hence ensure operators adhere restrictions WSC|f wd . Setting
xi allowed time step i. is, xi operators oxi 1 oxi 0 . take
input set time steps {t0 , . . . , ti1 } required successive, precondition
start(t0 ) next(t0 , t1 ) next(ti2 , ti1 ). output new time step ti attach
successor ti1 , set xi 1 0, respectively, time step i. is,
effect literal form xi (ti ) xi (ti ), respectively. rest planning task consists of:
operators ot allow extending sequence time steps step B, suitable value B (see
below); operators oj allow achieving goal, given j true end time
step sequence length B. integrity constraints (IC empty). values yi
specified, i.e., variables take value initial belief.

77

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

X.Y.[X, ] valid obviously one construct plan task simply setting
xi accordingly, using ot stepping time B, applying oj . necessitates
complicated construction direction proof: namely, plan may cheat
setting xi 1 0. construction ensures costly, plan
forced maintain two parallel sequences time steps, starting faulty xi . choose
sufficiently large value B, together sufficiently small plan length bound b, cheating
possible.
2
final result regards unbounded plan existence. Somewhat surprisingly, turns
still undecidable WSC|f wd . Similar above, key idea let actions output
new time step, thereby ensuring membership constructed task WSC|f wd .
Theorem 6 (Unbounded Plan Existence WSC|f wd ) Assume WSC|f wd task. decision
problem asking whether plan exists undecidable.
Proof Sketch: reduction halting problem Abacus machines, undecidable.
Abacus machine consists tuple integer variables v1 , . . . , vk (ranging positive
integers including 0), tuple instructions I1 , . . . , . state given content
v1 , . . . , vk plus index pc active instruction. machine stops iff reaches state
pc = n. vi initially 0, pc initially 0. instructions either increment variable
jump another instruction, decrement variable jump different instructions
depending whether variable already 0.
difficult encode Abacus machine WSC|f wd task. two key ideas are: (1)
design operator outputs next successor integer; (2) design operators simulating
instructions, stepping successors predecessors integer values. latter kind
operators, membership WSC|f wd ensured letting operators output new time step
new variable values associated. goal asks existence time step
active instruction .
2
argued end Section 3.3 already, dont deem undecidability unbounded plan
existence critical issue practice. planning tools nature semi-decision procedures,
anyway. particular, web service composition typically expected occur real-time setting,
severe time-outs apply.
4.5 Issues Adapting CFF
view, crucial observation WSC|f wd test plans coNP,
rather p2 general WSC. Standard notions planning uncertainty
complexity plan testing, research already resulted sizable number approaches
(comparatively) scalable tools (Cimatti et al., 2004; Bryce et al., 2006; Hoffmann & Brafman,
2006; Palacios & Geffner, 2007). show next section that, certain additional
restrictions WSC|f wd , tools applied off-the-shelf. Regarding general WSC|f wd ,
match complexity plan testing suggests underlying techniques successfully
adapted. following, consider detail CFF tool (Hoffmann & Brafman, 2006).
promising options would extend MBP (Cimatti et al., 2004) POND (Bryce et al.,
2006), look compilation techniques investigated Palacios Geffner (2007).
CFF characterized follows:
78

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

(1) Search performed forward space action sequences.
(2) sequence a, CNF formula (a) generated encodes semantics a,
SAT reasoning (a) checks whether plan.
(3) reasoning results namely literals always true executing cached
speed future tests.
(4) Search guided adaptation FFs (Hoffmann & Nebel, 2001) relaxed plan heuristic.
(5) Relaxed planning makes use strengthened variant CNF formulas (a) used
reasoning action sequences, clauses projected onto 2
literals (i.e., 2 literals removed respective clause).
techniques self-explanatory, except possibly last one. Projecting CNF
formulas ensures relaxed planning remains over-approximation real planning,
projected formulas allow us draw conclusions. time, projected
formulas handled sufficiently runtime-efficiently.17 method 2-projecting
clauses is, nutshell, ignore one condition literals conditional effect
relaxed planning graph.
fairly obvious basic answers given CFF, i.e., techniques (1) (5), apply
WSC|f wd . Note that, indeed, main enabling factor check plans coNP,
rather p2 general WSC. enables us design desired CNF formulas (a)
straightforward fashion. plan checking p2 -hard, either need replace CNF
formulas QBF formulas, create worst-case exponentially large CNF formulas.
are, least, technically quite challenging.
adaptation CFF WSC|f wd immediate promise, trivial. involves
technical challenges regarding on-the-fly creation constants well computation
heuristic function. latter brings significant new opportunities WSC context,
pertaining exploitation typical forms ontology axioms. Let us consider issues
little detail.
First, todays planning tools, CFF pre-instantiates PDDL purely propositional
representation, based core planning algorithms implemented. one allows on-thefly creation constants, pre-instantiation longer possible, hence adaptation
WSC|f wd involves re-implementing entire tool. challenge itself,
difficult obstacles overcome. sloppy formulation key question is: many
constants create? One can, course, create new tuple constants (the outputs of)
every new action application. However, seems likely approach would blow
representation size quickly, would hence infeasible. one instead share
output constants reasonable. one recognize reasonable points? issue
especially urgent inside heuristic function. Namely, easy see that, worst case,
relaxed planning graph grows exponentially number layers. imagine example
web service w1 takes input type generates output type B, whereas w2 takes
input type B generates output type A. Starting one constant type
one type B, get 2 constants type next graph layer. Then, w1 w2
17. Inside heuristic function, formulas come relaxed planning graphs quite big. handling
without approximations seems hopeless. discussed detail Hoffmann Brafman (2006).

79

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

applied two times, get 4 constants type next graph layer, forth.
dilemma probably cannot handled without making approximations relaxed
planning graph.
One positive note, seems possible exploit typical structures ontologies
practice. particular, practical ontologies make extensive use subsumption relations,
structuring domain interest concept hierarchy. Additional ontology axioms often come
form constraints relations (reflexivity, symmetry, transitivity) typing number
relation arguments. may make sense exploit structures optimizing
formulas (a) associated SAT reasoning. Certainly, makes sense exploit structures
inside heuristic function. One include specialized analysis sub-solver techniques
recognize structures solve separately order obtain precise relaxed plans.
One even try take account structures inside relaxed planning, hence
(potentially) obtain fast heuristic function.

5. Compilation Initial State Uncertainty
show that, certain additional restrictions, off-the-shelf scalable tools planning
uncertainty exploited solve WSC|f wd . main limiting factors are: (1)
tools allow generation new constants. (2) tools allow specification
clausal formula initial state, states. approach deal (1) considers
set constants fixed priori, namely initially available constants plus additional potential
constants used instantiate outputs. subtle observation that, within special
case WSC|f wd , dynamics states become predictable priori, one deal
(2) natural way.
follows, first introduce core observation case state space becomes
predictable, certain sense. observe predictability naturally given special
case forward effects, term strictly forward effects. discuss strengths limitations new special case. finally provide compilation strictly forward effects
planning initial state uncertainty.
5.1 Predictable State Spaces
core observation based notion compatible actions. Assume WSC|f wd task (P, IC ,
O, C0 , 0 , G ). Two actions a, compatible either Ea Ea = , effa = effa . is,
either disjunct outputs hence affect disjunct sets literals since
WSC|f wd effects agree completely. set actions compatible Ea C0 =
A, every pair actions compatible.
Lemma 2 states that, given used actions compatible, every state ever reached
satisfies action effects, modulo existing constants.
Lemma 2 (Predictable State Spaces WSC|f wd ) Assume WSC|f wd task, compatible set
actions A, state reached actions A. |= 0 and, A,
Ea Cs |= effa .
Proof: proof induction. base case, b0 , claim holds definition since
Cs Ea = A. Say reached action A. applicable

80

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

s, induction assumption nothing prove. Otherwise, WSC|f wd ,
Lemma 1 res(s, a) = {(C , ) | C = Cs Ea , |Cs = , |= IC effa }.
V
induction assumption applied s, res(s, a) = {(C , ) | C = Cs Ea , |=
0 A,E Cs effa IC effa }. Now, Ea Cs Ea Ea 6 Cs ,

2
Ea Ea 6= hence effa = effa prerequisite. concludes argument.
virtue lemma, possible configurations constants
generated
V
actions characterized formula IC 0 aA effa . Since parts
formula known prior planning, set possible configurations predictable.
even begin plan, already know constants behave generated.
list possible behaviors potential constants initial belief, let actions
affect constants actually exist. words, compile initial state
uncertainty. detail below. First, need identify setting Lemma 2
actually applied.
5.2 Strictly Forward Effects
Given WSC|f wd task, must settle finite set compatible actions planner
try compose plan from. One option simply require every action
unique output constants. appears undesirable since planning tasks often contain many actions,
set potential constants would huge. Further, enable chaining several actions,
potential constants allowed instantiate input parameters every operator, hence
necessitating creation new action and, that, new potential constants. unclear
break recursion, sensible way.
Herein, focus instead restriction WSC|f wd suffices assign unique output
constants individual operators, rather individual actions.
Definition 2 Assume WSC task (P, IC , O, C0 , 0 , G ). task strictly forward effects
iff:
1. O, l[X] effo , |X| > 0 X Yo .
2. clauses IC , = x1 , . . . , xk : l1 [X1 ] ln [Xn ], X1 =
= Xn .
set WSC tasks strictly forward effects denoted WSC|sf wd .
second condition identical corresponding condition WSC|f wd . first condition strictly stronger. WSC|f wd requires least one effect literal variable taken
outputs, WSC|sf wd requires variables taken outputs. Therefore,
obviously, WSC|sf wd WSC|f wd . Note WSC task formulated Example 2 member
WSC|sf wd .
key property WSC|sf wd that, without input variables effect, actions based
operator effect. So, action set compatible, need
choose set unique output constants every operator. Indeed, every set
operators whose effects pairwise identical. choose several sets output constants
group operators.
81

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

5.3 Modeling Power
limitations WSC|f wd , discussed Section 4.2, naturally inherited WSC|sf wd . Moreover, unlike WSC|f wd , cannot state properties effect connect inputs
outputs. serious limitation. illustration, consider small VTA example
using. operator bookTicket effect ticketFor (y, x), relating produced ticket
train x given input. Clearly, notion ticket rather weak cannot state
ticket actually valid for. Another interesting case one extend Example 2 considering two proteins rather one. is, set C0 = {c, c }, 0 =
cellProtein(c) cellProtein(c ). wish encode need combined presentation
those, i.e., G = : combinedPresentation(y, c) combinedPresentation(y, c ). WSC|f wd ,
solve including, every information providing operator, input variable x
effect literal. example, set getInfo3D1n55 := ({x}, 1n55(x), {y}, Info3D(y, x)).
possible WSC|sf wd .
extent, difficulties overcome encoding relevant inputs predicate names. handle composition two proteins c c , would essentially mean
making copy entire model renaming part c . goal would G = y, :
combinedPresentation(y) combinedPresentation (y ), operator preconditions would make
sure combinedPresentation(y) generated before, combinedPresentation (y ) generated using new operators. Note rather dirty hack, depends knowing
number copies needed, prior planning. equivalent solution VTA would introduce
separate ticketFor-x predicate every entity x ticket may bought.
least, would result rather oversized unreadable model. yet troublesome case
time-step construction outlined Section 4.2, added new output variable
effect related via effect literal next(prevt, t) previous time step prevt provided
input. WSC|sf wd , longer relate prevt way stating time
step happens one. Trying encode information predicate names,
would include one predicate per possible time step. necessitates assuming bound
number time steps, clear limitation respect natural encoding.
Despite above, WSC|sf wd far pathological irrelevant special case. example
applies domain proteins shown Example 1. Similarly, hospital domain
discussed Section 4.2 naturally modeled WSC|sf wd . generally, fact
wealth WSC formalisms encode connections inputs outputs.
example, category contains formalisms rely exclusively specifying types
input output parameters. information modeled types kind input
service requires, kind output produces example, input train output
ticket. Examples formalisms various notions message-based composition (Zhan
et al., 2003; Constantinescu et al., 2004a; Lecue & Leger, 2006; Lecue & Delteil, 2007; Kona
et al., 2007; Liu et al., 2007). fact, early versions OWL-S regarded inputs outputs
independent semantic entities, using Description Logic formalization types.
Thus, existence compilation WSC|sf wd planning uncertainty quite
interesting. shows composition model similar early versions OWL-S, general
form partial matches powerful background ontologies, attacked off-the-shelf
planning techniques. opens new connection WSC planning.

82

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

5.4 Compilation
compile WSC|sf wd task task conformant planning initial state uncertainty,
takes form (P, A, 0 , G ). P finite set propositions used. finite set
actions, takes form (pre(a), eff(a)) pair sets literals P. 0
CNF formula P, G conjunction literals P. notions given standard
belief state semantics. state truth value assignment P. initial belief set states
satisfying 0 . result executing action state res(s, a) := 6|= pre(a),18
otherwise res(s, a) := (sadd(a))\del(a). use standard notation gives terms
set propositions makes true, uses add(a) denote positive literals eff(a),
del(a) denote negative literals eff(a). Extension res beliefs definition
plan remain unchanged.
Assume WSC|sf wd task (P, IC , O, C0 , 0 , G ). compiled task (P , A, 0 , G ) makes
use new unary predicate Ex expresses constants yet brought existence. compilation obtained follows. operator O, outputs
Yo =

{y1 , . . . , yk }, create set new constants Eo = {e1 , . . . , ek }. Then, C := C0 oO Eo
set constants fixed priori. Initialize := . operator O,
V include

preo ( xXo Ex(x))
V
V set actions resulting using C instantiate precondition
( eEo Ex(e)). Give actions effect, eEo Ex(e). words, instantiate os outputs Eo , enrich os precondition saying inputs exist
outputs yet exist, replace os effect statement simply bringing outputs
existence.
Replacing effects way, original effects go? included
initial state formula. is, initialize 0 conjunction effo [Eo /Yo ] operators
O. Then, instantiate clauses inVIC C andV
conjoin 0 . obtain final
0 conjoining 0 ( cC0 Ex(c)) cC\C0 Ex(c)) Goal. Here, Goal
new proposition. serves model goal. Namely, introduce set artificial
goal achievement actions. goal form G = x1 , . .V
. , xk .[x1 , . . . , xk ]. new actions
obtained instantiating operator ({x1 , . . . , xk }, ki=1 Ex(xi ), , Goal) C.
is, goal achievement actions instantiate existentially quantified variables goal
possible constants. actions added set A. overall compiled task takes
form (P , A, 0 , Goal), P simply set mentioned propositions.
summary, compile WSC|sf wd task (P, IC , O, C0 , 0 , G ) conformant planning
task (P , A, 0 , G ) follows:
operator O, create uniqueSset new constants Eo = {e1 , . . . , ek }
Yo = {y1 , . . . , yk }. denote C := C0 oO Eo .

P contains instantiations, C, P plus two new predicates, Ex Goal. Ex
arity 1 expresses constants yet brought existence. Goal arity 0
forms new goal, i.e., G = Goal.

actions instantiations O, XV
instantiated
VC, Yo inEx(x))

(
stantiated Eo . preconditions

enriched

(
eEo Ex(e)),
xXo
V
effects replaced eEo Ex(e).

18. before, give actions conditional effects semantics, rather usual distinction forced
preconditions, non-forced effect conditions.

83

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

Further, contains goal achievement actions, achieving Goal preconditions instantiating G C.
original action effects, i.e., conjunction effo [Eo /Yo ] operators
O,
V
. Further, contains ,
moved


instantiated

C,

(
0
IC
0
0
cC0 Ex(c))
V
cC\C0 Ex(c)) Goal.

terminology Section 5.1, means choose set actions actions
obtained operator instantiating inputs constants C,
outputs Eo . suggested Lemma 2, initial state formula 0 compiled
task describes possible configurations constants C, effect applying
action bring respective output constants existence. Note that, although effects
compiled actions positive, planning still hard (coNP-complete, precise) due
uncertainty. (If allow WSC operators delete constants, negative effects
deleting constants compiled task.)
According strategy, create one set output constants per operator,
take account sets operators identical effects. simplify
presentation. results carry immediately complicated strategies create
one set output constants per operator, well strategies share sets output
constants operators identical effects. noted, however, operators
whose effects identical not, general, share outputs. particular, two
effects conflict, e.g., InfoDSSP(d) InfoDSSP(d), initial state formula 0
unsatisfiable. compiled planning task trivially solved empty plan, and,
course, encode solutions original problem.
Example 3 Re-consider planning task defined Example 2. specify compiled task. set
C = {c, d, e, f } c initially available constant, d, e, f potential constants
operator outputs. compiled planning task (P , A, 0 , G ) following:
P = {protein, cellProtein, G, H, I, 1n55, 1kw3, combinedPresentation, InfoDSSP,
Info3D, Ex, Goal}, predicates except Goal unary (have one argument).
consists instantiations of:
getInfoDSSPG [d/y]: ({x}, G(x) Ex(x) Ex(d), Ex(d))
getInfoDSSPH [d/y]: ({x}, H(x) Ex(x) Ex(d), Ex(d))
getInfoDSSPI [d/y]: ({x}, I(x) Ex(x) Ex(d), Ex(d))
getInfo3D1n55 [e/y]: ({x}, 1n55(x) Ex(x) Ex(e), Ex(e))
getInfo3D1kw3 [e/y]: ({x}, 1kw3(x) Ex(x) Ex(e), Ex(e))

combineInfo[f /y]: ({x1 , x2 }, InfoDSSP(x1 ) Info3D(x2 ) Ex(x1 ) Ex(x2 )
Ex(f ), Ex(f ))
GoalOp: ({x}, combinedPresentation(x) Ex(x), Goal)
0 conjunction of:
instantiations IC [consisting five axioms given Example 2]
84

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

cellProtein(c) [0 ]
InfoDSSP(d) Info3D(e) combinedPresentation(f ) [original action effects]
Ex(c) Ex(d) Ex(e) Ex(f ) [constants existence]
Goal [goal yet achieved]
G = Goal
consider plan original task (see Example 2): hgetInfoDSSPG (c, d),
getInfoDSSPH (c, d), getInfo3D1n55 (c, e), getInfo3D1kw3 (c, e), combineInfo(d, e, f )i.
illustrate, verify plan yields plan compiled task. task,
initial belief b0 consists states c existing constant, d, e, f satisfy
respective effects, |= IC cellProtein(c). apply action sequence:
1. Apply getInfoDSSPG (c, d) b0 . get belief b1 b0 except that,
b0 |= G(c), exists.
2. Apply getInfoDSSPH (c, d) b1 . get belief b2 b1 except that,
b1 |= H(c), exists.
3. Apply getInfo3D1n55 (c, e) b2 , yielding b3 .
4. Apply getInfo3D1kw3 (c, e) b3 . brings us b4 Ex(e) b2
|= 1n55(c) |= 1kw3(c).
5. Apply combineInfo(d, e, f ) b4 . brings us b5 b4 except b4
e exist Ex(f ).
6. Apply GoalOp(f ) b5 , yielding b6 .
reasoning IC used Example 2 show b5 satisfies original goal,
used show GoalOp(f ) applicable b5 hence resulting belief b6
satisfies goal. obtain plan compiled task simply attaching goal achievement
action original plan.
prove soundness completeness compilation, need rule inconsistent
operators, i.e., operators whose effects conflict background theory (meaning
IC Xo , Yo : effo unsatisfiable). example, case x : A(x) B(x)
contained IC , effo = A(y) B(y). presence operator, initial belief
compiled task empty, making task meaningless. Note inconsistent operators
never part plan, hence filtered pre-process. Note that, WSC|sf wd ,
operator inconsistent iff actions based inconsistent.
Non-goal achievement actions correspond actions original task, obvious
way. connection, transform plans compiled task directly plans
original task, vice versa.
Theorem 7 (Soundness Compilation) Consider WSC|sf wd task (P, IC , O, C0 , 0 , G )
without inconsistent operators plan ha1 , . . . , compiled task (P , A, 0 , G ).
sub-sequence non-goal achievement actions ha1 , . . . , plan task
(P, IC , O, C0 , 0 , G ).
85

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

Proof Sketch: arbitrary sequence non-goal achievement actions, denote b belief
execution original task, b belief execution compiled task.
state sSin original task, denote [s] class compiled-task states overVthe constants
C0 oO Eo {c
| s(Ex(c)) = 1} = Cs , s|Cs = , |= IC 0 oO effo [Eo ].
One prove b = sb [s]. claim follows directly that.
2

Theorem 8 (Completeness Compilation) Consider WSC|sf wd task (P, IC , O, C0 , 0 ,
G ) without inconsistent operators plan ha1 , . . . , every operator appears
one instantiation Eo outputs. ha1 , . . . , extended goal achievement
actions form plan compiled task (P , A, 0 , G ) obtained using outputs Eo .

Proof Sketch: Follows immediately b = sb [s] shown proof Theorem 7. Say
one executes ha1 , . . . , compiled task, ending belief b. there, plan
compiled task obtained simply attaching one goal achievement action every tuple
constants satisfying G world state b.
2

reader may noticed number instantiations goal achievement operator
exponential arity goal. worst case, instantiations must included
plan compiled task. particular, may happen plan constructed per
proof Theorem 8. However, practical purposes appears reasonable assume fixed upper
bound number goal variables.
indicated, proofs Theorems 7 8 remain valid allowing one Eo
per operator, and/or operators identical effects share output constants. Note operators identical effects several web services provide alternative ways achieving something.
Example 3 illustrates situation (cf. earlier discussion Section 3.2). experiments
described next section, groups operators identical effects assigned
output constants.

6. Empirical Results
show compilation approach merits, report number empirical experiments using CFF underlying planner. start discussion general experimental
setup discuss results two different test scenarios.
6.1 Experiments Setup
implemented compilation WSC|sf wd planning uncertainty described
above, connected CFF tool. noted that, although compiled planning
tasks delete effects, solved CFFs relaxed-plan-based heuristic function.
function makes relaxation ignoring one conditions effect (see
earlier discussion CFF Section 4.5). Ignoring one condition significantly affects
compiled tasks effects typically involve many conditions, particularly conditions
stating inputs exist outputs yet exist.
One problematic point evaluating planning-based WSC choice test cases. field
still rather immature, due widely disparate nature existing WSC tools,

86

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

common set benchmarks.19 fact, web service composition new topic
posing many challenges existing techniques, different works differ widely terms
underlying purpose, specific aspect WSC address. detailed discussion
existing WSC tools given Section 7. method choose evaluation design
two test scenarios reflect intuitively relevant kinds problem structures potential
applications planning-based WSC, scalable number interesting parameters.
test reaction approach parameters.
test scenarios artificial benchmarks, cannot lead broad conclusions significance practice, allow us draw conclusions planning behavior differently
structured test problems. solution method scales quite well tested cases, efficiently finding solutions involve many web service calls, successfully employ
services really necessary. Viewing results isolation, one conclude
representation techniques heuristic functions planning uncertainty may useful
attack large complex planning-like WSC instances.
comparison alternative WSC tools is, again, problematic, due broad range problems tools solve, different kinds solutions find, different kinds input
syntax/language read. obtain least notion empirical comparison tools,
following consider expressivity (How general input language tool?)
scalability (How quickly tool compose?). existing WSC tools constitutes
separate point trade-off two. question whether compilation
approach, restricting WSC|sf wd using CFF solve compiled tasks, sensible point
trade-off.
terms expressivity, approach located general planning methods (like
Eiter et al., 2003, 2004; Giunchiglia et al., 2004), inspired actions change literature,
restricted methods applied WSC far. question whether gain
scalability comparison expressive methods.
confirm experiments answer is, expected, yes. run DLVK tool
(Eiter et al., 2003, 2004), handles powerful planning language based logic programming.
language particular features static causal rules similar integrity constraints
fully general WSC.20 sense, perspective DLVK native WSC tool
handles ontology axioms directly rather via restricting expressivity compiling
away. particular, encoded WSC test problems directly DLVKs input language, without
compilation use CFF.
DLVK relies answer set programming, instead relaxed plan heuristics, find plans. Further, style many reasoning-based planners, DLVK requires input length bound
plan, hence used find optimal plans running several times different bounds.
cases, ran DLVK once, bound corresponding optimal plan length.
Even so, DLVK much slower CFF, solving small fraction test instances.
wish over-interpret results. conclude WSC|sf wd constitutes interesting
point trade-off expressivity scalability WSC.
19. VTA example could considered one benchmark, essentially every individual approach defines
particular version example.
20. similarity lies static causal rules fully general integrity constraints can, side effect applying
action, yield ramifications affecting properties inherited previous state.

87

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

running first tests compilation approach, noticed encoding
per Section 5.4 unnecessarily generous set initial states. Observe compiled
tasks always easier solve propositions true initial state. is, simply, literals operator preconditions, effects, goal positive. Hence, proposition
p appear positively initial state clause, one set p 0 initially, thereby
reduce number initial states, without introducing new plans.21 Setting proposition
0 may cause unit propagations, setting propositions 1 0. iterate steps
fixpoint occurs. resulting initial state description stricter before, yields better performance CFF DLVK. use optimized encoding experiments reported
below.
experimented another optimization. optimization makes assumption
constants requested goal generated step-wise fashion, intermediate
constant generated certainty generating next constant. RecallVthat encoding
per Section 5.4, existence inputs operators, i.e., condition xXo exists(x),
part operator precondition thus interpreted conditional effects semantics. However, CFF DLVK offer distinction effect conditions forced preconditions
must hold entire belief
action applicable. exploit distinction
V
postulate condition xXo exists(x) forced. reduces state space, may cut
solutions. reduction quite beneficial CFF DLVK. Since optimization
affects set plans, switch part test cases, point possible speedup. tests optimization switched discussed text, indicated
keyword forced name test case.
use two versions CFF. One CFFs default configuration makes use FFs enforced Hill-climbing search algorithm well helpful actions pruning technique (Hoffmann
& Nebel, 2001). configuration, CFF helpful actions pruning turned off, search
proceeds standard greedy best-first fashion, open queue ordered increasing heuristic
values. henceforth denote former configuration CFF-def latter configuration
CFF-std.
results obtained 2.8GHz Pentium IV PC running Linux. tests run
time-out 600 seconds CPU, limiting memory usage 1 GB.
6.2 Subsumption Hierarchies
first investigate well approach deal scaling subsumption hierarchies,
building chains successively created entities (outputs). purpose, design test scenario
called SH, demands composition web services realizing chain generation steps,
every generation step deal subsumption hierarchy.
scenario depicted Figure 2. n top-level concepts L1 , . . . , Ln , depicted
TL Figure 2. goal input L1 , goal output Ln . Beneath Li ,
tree-shaped hierarchy sub-concepts. precisely, tree perfectly balanced
branching factor b, depth d. inner nodes tree called intermediate-level
(or simply intermediate) concepts, depicted IL Figure 2. leaf nodes tree
called basic-level (or simply basic) concepts, depicted BL Figure 2. every
non-leaf concept C tree, children C1 , . . . , Cb , axioms x : Ci (x) C(x)
21. course, reducing set initial states invalidate old plans, either.

88

fiTL

W EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

IL

IL

BL

BL

BL

BL

BL

BL

SWS

SWS

SWS

SWS

SWS

SWS

TL

IL

BL

IL

BL

BL

BL

BL

BL

Figure 2: Schematic illustration SH scenario.
expressing subsumption, well axiom x : C(x) C1 (x) Cb (x) expressing
parent covered children.
available web services defined follows. top level concept Li ,
leaf BLi,j corresponding tree structure, web service available takes
BLi,j input outputs Li+1 . corresponding WSC operator takes form oi,j =
({x}, BLi,j (x), {y}, Li+1 (y)). Then, applying, 1 < n order, services oi,j ,
possible make sure constant concept Li+1 created possible cases. Hence,
sequencing steps plan, length (n 1) bd . Note that, already stated
Section 5.4, experiments groups operators identical effects assigned
output constants. SH scenario, means 1 < n, oi,j share
output constant. Hence total number output constants generated, i.e., number
potential constants initial state, equal number top-level concepts, n.
Although SH scenario abstract nature, representative variety relevant
situations. Specifically, scenario model situations sets different services must
used address request none handle alone. role single service
handle particular possible case. example, set different services
set services oi,j assembled Li . Given constant c member Li , i.e.,
Li (c) holds, particular possible case handled service oi,j case c happens
member leaf BLi,j one cases must hold due coverage clauses tree.
89

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

Similar situations arise, e.g., geographically located (regional) services composition
request location-specific addresses locations higher (inter-regional) level. similar
pattern found e-government scenarios clear-cut classification activities
leads establishing several parallel services serve different departmental areas.
Orthogonal horizontal composition, scenario model vertical composition,
one function pursued concatenating existing functions. case
complex procedures diverse areas e-government e-commerce.
scenario instantiated study different aspects scalability approach.
empirical tests measure scalability horizontal vertical direction. Further,
consider two extreme cases possible shapes individual concept trees chain,
giving us instances identical numbers leaves. set test scenario SH-broad,
= 1 b scales 2, 4, 8, 16, 32. set test scenario SH-deep, b = 2
scales 1, 2, 3, 4, 5. scenarios, n scales 2 20.
Further, designed SH-trap variant second chain n concepts linked,
completely irrelevant goal service. variant suitable testing extent
composition techniques affected irrelevant information. Finally, recall encoding
method
comes two versions explained above, default method treats input existence
V
xXo exists(x) conditional effects semantics, whereas non-default method, forced,
compromises completeness efficiency treating input existence forced precondition.
all, following choices: 3 different planners (CFF-def, CFF-std, DLVK);
2 different encoding methods; SH without trap; SH-broad SH-deep. crossproduct choices yields 24 experiments, within 19 possible values
n 5 possible values b d, i.e., 95 test instances. CFF, measured 3 performance
parameters: total runtime, number search states inserted open queue, number
actions plan. DLVK, measured total runtime number actions plan.
course, large amount data interesting. follows, summarize
important observations. Figure 3 shows data selected purpose. Part (a) figure
shows CFF-std SH-broad; (b) shows CFF-std SH-deep; (c) shows CFF-def SH-forcedbroad; (d) shows DLVK SH-broad SH-deep; (e) shows DLVK SH-forced-broad
SH-forced-deep; (f) shows DLVK CFF-std SH-trap. vertical axes show log-scaled
runtime (sec). horizontal axes show n (a), (b) (c). (d), (e) (f), n fixed n = 2
horizontal axes show number leaves concept hierarchy.
Consider first Figure 3 (a) (b). plots point efficiently CFF handle
kind WSC problem, even forced optimization. Comparing two plots points
difference handling broad deep concept hierarchies. plots, CFF-std runtime
shown n, length chain built. (a), show 5 curves 5 different
values b (the number leaves hierarchy depth 1), (b) show 5 curves 5
different values (the depth hierarchy branching factor 2). cases, scaling
behavior fairly good. small concept hierarchies (b = 2 = 1), chains almost arbitrary
length built easily. hierarchies grow, runtime becomes exponentially worse. Note,
however, one curve next size hierarchies doubles, growth
exponential. concept hierarchies 16 leaves, i.e., 16 alternative cases handled
step, still easily build chains 6 steps, solution involves 96 web services.
interesting aspect comparing two plots, (a) (b), underlying search spaces
actually identical: open queues same. difference performance stems
90

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

100

100

10

10

1

1

b=2
b=4
b=8
b=16
b=32

0.1

0.01
2

4

6

8

10

12

14

d=1
d=2
d=3
d=4
d=5

0.1

0.01

16

18

20

2

4

6

(a) CFF-std SH-broad

8

10

12

14

16

18

20

(b) CFF-std SH-deep
10000
SH-broad
SH-deep
1000

100

100

10
10

1
1

0.1
0.1

0.01
2

4

6

8

10

12

14

16

18

20

0.01
2

3

(c) CFF-def SH-forced-broad

4

5

6

(d) DLVK SH-broad SH-deep

10000

10000
SH-forced-broad
SH-forced-deep

DLVK SH-trap-broad
DLVK SH-forced-trap-broad
CFF-std SH-trap-broad

1000

1000

100

100

10

10

1

1

0.1

0.1

0.01

0.01
2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

2

(e) DLVK SH-forced-broad SH-forced-deep

4

6

8

10

12

14

16

18

20

22

24

26

30

(f) DLVK CFF-std SH-trap

Figure 3: Selected results SH scenario. See detailed explanation text.

91

28

32

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

overhead CFFs reasoning techniques, consume runtime case deep
concept hierarchies. Hence slightly worse behavior (b).
run CFF-def test suites Figure 3 (a) (b), obtain much worse behavior.
example, b = 8 get n = 3. reason seems FFs helpful actions
pruning enforced hill-climbing greedy domain. simple way overcome
use standard heuristic search algorithm instead, done CFF-std shown Figure 3 (a)
(b). hand, forced optimization switched on, helpful actions pruning
enforced hill-climbing work much better, obtain significant performance boost using
CFF-def. latter pointed Figure 3 (c), showing data CFF-def SH-forced-broad.
Figure 3 (a) CFF-std SH-broad, plot shows 5 curves, one 5 values
b (legend omitted plot would overlap curves). see that, case,
easily build arbitrarily long chains even b = 16, giving us solution involving 320 web
services n = 20. Even b = 32, still get n = 9.
Figure 3 (d) (e) show one gets trying solve examples, encoding
directly DLVK instead using compilation solving CFF. expected,
performance much worse. Since hardly test instance solved n > 2, fixed n
minimum value 2 plots, unlike (a), (b) (c). (d) (e) shows data
broad deep variants, showing number leaves horizontal axis. order obtain
fine-grained view, broad variant increase number steps 1 rather
multiplicative factor 2 before. see that, without forced optimization Figure 3 (d)
performance poor, largest case solve n = 2, b = 6 solution involves
6 web services. switch forced Figure 3 (e) performance dramatically improved
still different level obtain compilation+CFF.
Figure 3 (f), finally, exemplifies results get trap scenario. show data
broad version, default encoding CFF-std, default forced
encoding DLVK. DLVK quite affected irrelevant chain concepts, solving
single instance n = 2, b = 2 default encoding, getting n = 2, b = 16
forced encoding, instead n = 2, b = 20 without trap. behavior expected since
DLVK make use heuristic techniques would able detect irrelevance
second chain concepts. question whether CFFs techniques better that. Figure 3
(f) shows CFF-std largely unaffected n = 2 one see comparing curve
points vertical axis Figure 3 (a). However, n > 2 performance CFF-std
drastically degrades: instances solved n = 3, b = 2 n = 4, b = 2. reason
seems additional actions yield huge blow-up open queue used global
heuristic search algorithm CFF-std. Indeed, picture different using CFF-def
forced encoding instead: search spaces identical explored trap,
behavior get identical shown Figure 3 (c).
plans found SH scenario optimal, i.e., plans returned contain web
services needed. single exception DLVK trap, solutions include
useless web services trap chain.22
22. Note DLVKs plans parallel. parallel length optimal (because provided correct plan
length bound, cf. Section 6.1. However, parallel step may contain unnecessary actions, top necessary
ones. Thats happens trap.

92

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

6.3 Complex Concept Dependencies
two variants SH scenario feature tightly structured relationships involved
concepts, allow investigation scalability issues varying size structure.
consider advanced scenario, way top-level concepts covered lowerlevel concepts subject complex concept dependencies, similar axioms constraining protein classes characteristics Example 1. Therefore investigate performance
impacted complex concept structures subsumption hierarchies.
TL

TL

IL

IL

IL

IL

BL

BL

BL

BL

BL

BL

BL

BL

BL

BL

BL

BL

SWS

SWS

SWS

SWS

SWS

SWS

SWS

SWS

SWS

SWS

SWS

SWS

TL

TL

IL

BL

BL

IL

IL

BL

BL

BL

BL

BL

BL

IL

BL

BL

BL

BL

Figure 4: Schematic illustration CD scenario vs. SH scenario.
new scenario called CD, concept dependencies. Figure 4 illustrates scenario,
contrasts SH scenario. Similarly SH, top-level concepts,
one associated set basic sub-concepts. b basic concepts
every top-level concept. n top-level concepts L1 , . . . , Ln , goal achieve
Ln starting L1 . before, done combining web services cover
possibilities. Namely, every top-level concept Li every basic concept BLi,j associated
it, operator oi,j = (({x}, BLi,j (x), {y}, Li+1 (y)).23
difference lies connection basic concepts top-level concepts.
SH, rigidly given terms tree structure subsumption coverage axioms
intermediate concepts. Every basic concept i.e., every operator oi,j corresponding
concept included plan order cover possible cases. CD, use instead
complex set axioms connect basic concepts top-level. top-level concept
intermediate concepts ILi,1 , . . . , ILi,m , axioms stating ILi,j
23. Note that, i, operators assigned output constant compilation
technique.

93

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

sub-concept Li , well axiom x : Li (x) ILi,1 (x) ILi,m (x) stating
Li covered ILi,1 , . . . , ILi,m . connection intermediate concepts
basic concepts, complex dependencies used. intermediate subconcept constrained
covered non-empty set combinations basic subconcepts. Precisely, create
random DNF, positive literals, using basic concepts predicates. take
DNF imply ILi,j . Note that, implication, DNF negated hence becomes
CNF, directly encode formalism. every ILi,j .
setting, interesting control many combinations required cover
top-level concept Li . directly corresponds total number random combinations (random DNF disjuncts) generated, intermediate concepts ILi,j taken together.
control via call coverage factor, c, ranging (0, 1]. 2b 1 possible
combinations basic concepts, pick random subset size c (2b 1). combination associated DNF randomly chosen intermediate concept. Note CNF
formulas generated way may enormous. minimize size encoding, use
formula minimization software Espresso (Brayton, Hachtel, McMullen, & Sangiovanni-Vincentelli,
1984; McGeer, Sanghavi, Brayton, & Sangiovanni-Vincentelli, 1993).
hypothetically c set 0 task unsolvable. experiments reported below,
whenever write c = 0% means exactly one combination selected, associated
every intermediate concept.
escaping rigid schema relationships presented SH, CD scenario suitable test whether performance approach tied specific structure SH
problem. Moreover, way CD designed allows us determine degree planners
react intelligently different concept structures. particular, scenario allows analysis of:
1. ability approach, particular selected underlying planner CFF, identify plans contain relevant actions. Especially coverage factor c low,
basic subconcepts may never appear partition intermediate concepts, thus,
plan need include respective operators. Still, due conditional effects/partial matches semantics, plans include operators valid plans. Evaluating
plan length performance varying c therefore interesting.
2. ability approach deal complex axiomatizations. measured
terms impact coverage factor runtime performance. randomization
choice combinations basic factors, different settings c, may induce significant
differences CNF axiomatizations, result, subject underlying reasoning
engine different situations.
summary, CD scenario representative situations complex dependencies must
taken account order select correct services. Examples domains discussed
Sections 4.2 5.3. particular, CD scenario corresponds closely (a scalable version of)
protein domain example. different values DSSP code correspond different basic
concepts, respective getInfoDSSP services operators taking intermediate
concept, InfoDSSP(y). similar amino-acids, 3-D shapes, shapes complexes.
top level concept combinedPresentation(y) achieved constants every intermediate
concept created. So, difference CD lies that, rather single
top-level concept generated intermediates, CD sequence top-level concepts
need generated turn.
94

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

SH scenario, total data experiments extensive, even since
4 scenario parameters rather 2 before, since individual instances contain
random element. Figure 5, report selected results pointing main observations. Part
(a)/(b) figure show CFF-std runtime/plan length n = 4, b = 5; (c)/(d) show CFFstd runtime/search nodes c n = 5, = 3, b = 7; (e) shows DLVK CFF-std runtime
b CD n = 2, c = 100%; (f) show latter data CFF-def CD-forced.
Figure 5 (a) (b) consider scalability solution lengths test varying size
scenario, representing different coverage factors different lines. report data CFFstd. Results similar CD-forced CFF-def, i.e., contrary SH, CD setting
options bring significant performance gain. see Figure 5 (a) CFF scales
pretty well, though well SH, easily able solve tasks 7 top level concepts
4 intermediate concepts 5 basic concepts. Tasks minimum coverage factor,
c = 0%, solved particularly effortlessly. higher c values, one observe somewhat
easy-hard-easy pattern, where, example, curve c = 100% lies significantly
curves c = 40% c = 60%. examine easy-hard-easy pattern detail below.
Figure 5 (b), obvious expected observation plan length grows linearly
n, i.e., number top level concepts. likewise obvious, much important,
observation plan length grows monotonically coverage factor c. reported above,
lower coverage factor opens opportunity employ less basic services, namely
relevant ones. Figure 5 (b) clearly shows CFF-std effective determining
services relevant not.
Let us get back intriguing observation Figure 5 (a), easy-hard-easy pattern
growing c. Figure 5 (c) (d) examine phenomenon detail. plots scale c
horizontal axis, fixed setting n, b. Runtime shown (c), (d) shows
number search states inserted open queue. value c, plots give
average standard deviation results 30 randomized instances. clearly see easyhard-easy pattern (c) runtime, high variance particularly c = 80%. (d),
see pattern number search states, variance much less
pronounced. shows easy-hard-easy pattern due differences actual search
performed CFF, due effort spent search nodes. traced behavior CFF
detail, found reason easy-hard-easy pattern lies runtime CFF spends
SAT reasoning state transitions, i.e., reasoning uses determine facts
definitely true/false belief. high non-100 values c, CNF encodings
concept dependency structures take rather complex form. cases CFF takes lot
runtime, almost runtime spent within single call SAT solver. is, seems
CFFs SAT solver exhibits kind heavy-tailed behavior formulas, phenomenon
well known SAT CP community, see example work Gomes, Selman, Crato,
Kautz (2000). noted that, typical planning benchmarks, CNFs much
simpler structure, motivates use fairly naive SAT solver CFF, using neither clause
learning restarts, order save overhead formulas simple anyway. seems likely
addition advanced SAT techniques solver could ameliorate observed problem.
Finally, Figure 5 (e) (f) compare performances compilation+CFF DLVK (with
compilation). plots fix n = 2, i.e., data shown 2 top level concepts.
instances DLVK solves n > 2 ones forced optimization used n = 3,
= 2, b = 2. Further, plots c fixed c = 100%. reason
95

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

1000

35

c=0%
c=20%
c=40%
c=60%
c=80%
c=100%

100

c=0%
c=20%
c=40%
c=60%
c=80%
c=100%

30

25

10

20

15

1

10
0.1
5

0.01

0
2

3

4

5

6

7

2

3

(a) CFF-std runtime n

4

5

6

7

(b) CFF-std plan length n
250

100

200

10

150

1

100

0.1

50

0.01

0
0

20

40

60

80

100

0

(c) CFF-std runtime c
10000

40

60

1000

DLVK m=2
DLVK m=4
DLVK m=6
CFF-std m=2
CFF-std m=4
CFF-std m=6

1000

20

80

100

(d) CFF-std plan length c
DLVK m=2
DLVK m=4
DLVK m=6
CFF-def m=2
CFF-def m=4
CFF-def m=6

100

100
10
10
1
1

0.1
0.1

0.01

0.01
2

4

6

8

10

12

2

(e) DLVK CFF-std runtime b

4

6

8

10

12

(f) DLVK CFF-def runtime b

Figure 5: Selected results CD scenario. See detailed explanation text.
find significant difference performance DLVK different values c. DLVK
unable exploit lower c lower runtime, neither show easy-hard-easy pattern.
speculate DLVKs answer set programming solver tends perform exhaustive search anyway
accordingly affected different structures heuristic techniques employed
CFF. However, CFF, DLVK able exploit lower coverage factors c shorter plans.
96

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

Figure 5 (e) shows default setting without forced optimization. see performance DLVK explodes quickly CFF experience much trouble. CFF fails
upper ends curves, Figure 5 (e) (f), problem files, i.e., CNFs
describing complex concept dependencies, become large parse (> 4 MB). notwithstanding, CFFs runtime behavior clearly exponential. Note, however, actual encodings,
i.e., problem instances solved, grow exponentially c.
observe DLVK exhibits quite variance, particularly across different
settings m: curves cross Figure 5 (e). even pronounced Figure 5 (f),
observe, SH, forced optimization brings huge advantage
DLVK. = 2 = 6 Figure 5 (f), DLVK fails first unsolved problem instance
due running memory shortly parsing problem.
Concluding section, observe empirical behavior CFF SH CD scenarios promising. results over-interpreted, though. test scenarios
capture problem structure typical variety potential applications WSC technology,
approach yet put test actual practice. same, however, said essentially
current planning-based WSC technology, since field whole still rather immature.

7. Related Work
relation work belief update literature covered detail already Sections 2.2 4.3. relation planning, formalism basically follows commonly
used frameworks. notions operators, actions, conditional effects exactly used
PDDL framework (McDermott et al., 1998; Bacchus, 2000; Fox & Long, 2003), except
extension outputs. Regarding latter, recognized time planning
community, example Golden (2002, 2003) Edelkamp (2003), on-the-fly creation
constants relevant feature certain kinds planning problems. However, attempts actually
address feature planning tools scarce. fact attempt aware work
Golden (2002, 2003) Golden, Pand, Nemani, Votava (2003). Part reason
situation probably almost current state art tools employ pre-processing procedures
compile PDDL task fully grounded description. core algorithms implemented based propositional representation. Lifting algorithms representation
involves variables on-the-fly instantiations requires major (implementation) effort. work
herein, circumvent effort using potential constants feeding resulting problem
CFF, planners employs said pre-processing. Extending CFF WSC|f wd
involve dealing non-propositional representations sub-problem.
notion initial state uncertainty conformant plans closely follows related literature
planning uncertainty (Smith & Weld, 1998; Cimatti et al., 2004; Hoffmann & Brafman,
2006). formalization terms beliefs adapted work Bonet Geffner (2000).
related works planning allow domain axiomatization, i.e., form
axioms constraining possible world states (Eiter et al., 2003; Giunchiglia et al., 2004).
best knowledge, work planning exists, apart work presented herein,
considers combination domain axioms outputs.
words order regarding notions partial plug-in matches. terminology originates work service discovery SWS community (see example Paolucci
et al., 2002; Li & Horrocks, 2003; Kumar et al., 2007). service discovery, one concerned

97

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

matching service advertisements service requests. discovery result set services
whose advertisement matches request. descriptions services requests similar
functional-level service descriptions, i.e., planning operators use here. However,
terminology works slightly different ours, describe additional kinds
matches. notions given Li Horrocks (2003) closest relation ours. Service
descriptions defined terms constructed Description Logic concepts. Say concept
describing advertisement, R concept describing request. Li Horrocks
say R have: exact match R; plug-in match R; subsume match
R; intersection match R 6 . compare setting, consider
situation effect action a, R precondition action r. Exact matches
special case plug-in matches distinguish herein. Intersection matches
correspond call partial matches. Concerning plug-in subsume matches, matters
subtle. intuitive meaning plug-in match advertisement fully suffices
fulfill request. planning terms, means effect implies precondition r.
However, service discovery traditionally taken mean every requested entity
provided, i.e., R. latter notion precondition r implies effect
meaningful planning. Hence use one two notions, correspondence Li
Horrockss subsume matches.
contrast work Li Horrocks (2003), work, Paolucci et al. (2002)
Kumar et al. (2007) define matches individual input/output parameters service descriptions,
rather service descriptions global level (precondition/effect us, constructed
concept Li & Horrocks, 2003). level individual parameters, Paolucci et al. (2002)
suggest notions Li Horrocks (2003) except less formal notation,
define intersection matches. true Kumar et al. (2007). latter
authors define notions contains part-of matches, relating building blocks
constructed concepts. Obviously, notions make sense framework,
arent constructed concepts. Finally, Kumar et al. define ways aggregating matches
individual parameters matches entire service descriptions. Again, applicable
case since work global level first place.
brief survey existing works WSC follows. variety works compile composition less standard deterministic planning formalisms (Ponnekanti & Fox,
2002; Srivastava, 2002; Sheshagiri et al., 2003). works (Agarwal, Dasgupta, Karnik,
Kumar, Kundu, Mittal, & Srivastava, 2005b; Agarwal et al., 2005a) additionally focus end-to-end
integration SWS composition larger context. Akkiraju, Srivastava, Anca-Andreea, Goodwin, Syeda-Mahmood (2006) investigate techniques disambiguate concept names. McIlraith
Fadel (2002) achieve composition particular forms non-atomic services, modeling
latter atomic actions take meaning kind macro-actions. Narayanan McIlraith
(2002) obtain composition ability side-effect verifying SWS properties using Petri Nets.
Kuter, Sirin, Nau, Parsia, Hendler (2005), Au, Kuter, Nau (2005), Au Nau (2006)
focus information gathering composition time, rather plan execution time. McDermott
(2002) treats actual interaction (communication) web service planning problem.
Mediratta Srivastava (2006) design approach WSC based conditional planning, i.e.,
form planning uncertainty. suggests close relation work, focus
Mediratta Srivastavas work actually quite different ours. Mediratta Srivastava
consider output variables, neither consider domain axiomatizations.
98

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

overlap formalism lies allow incomplete initial state descriptions, i.e.,
initial states assign value subset propositions. handle observation
actions allow observing value unspecified proposition. ameliorate need
complete modeling, consider definition user acceptable plans, subset
plan branches, specified user, guaranteed lead goal. latter may
interesting option look extending framework handle partial observability.
Two approaches explore adapt formalisms so-called hand-tailored planning
SWS composition. approaches based Golog (McIlraith & Son, 2002) HTN planning (Sirin et al., 2004), respectively. frameworks enable human user provide control
information. However, non-deterministic action choice allowed. control information
given, planning fully automatic. Hence, sense, frameworks strictly
powerful planning without control information. Further, approaches capable
handling advanced plan constructs loops branches. Golog, possible plans
possible composition solutions described kind logic high-level instructions
given programmer, planner bind instructions concrete actions part
execution. HTN, programmer supplies planning algorithm set so-called
decomposition methods, specifying certain task accomplished terms combination sub-tasks. Recursively, decomposition methods sub-tasks. Thus
overall task decomposed step-wise fashion, atomic actions reached. Neither
McIlraith Son (2002) Sirin et al. (2004) concerned handling ontology axioms,
paper. Hence, combining insights directions synergetic potential,
interesting topic future work.
Another approach capable handling advanced plan constructs (loops, branches) described
Pistore et al. (2005b), Pistore, Traverso, Bertoli, Marconi (2005c), Pistore et al. (2005a),
Bertoli, Pistore, Traverso (2006). work, process level composition implemented,
opposed profile/capability level composition addressed paper. process level,
semantic descriptions detail precisely interact SWS, rather characterizing
terms preconditions effects. Pistore et al. (2005b, 2005c, 2005a) Bertoli
et al. (2006) exploit BDD (Binary Decision Diagram) based search techniques obtain complex
solutions fully automatically. However, ontology axioms handled input/output types
matched based type names.
approaches ontology axioms used requirements
matches relaxed. One described Sirin, Hendler, Parsia (2003), Sirin, Parsia,
Hendler (2004), Sirin Parsia (2004), Sirin et al. (2006). first two papers
series (Sirin et al., 2003, 2004), SWS composition support tool human programmers
proposed: stage composition process, tool provides user list
matching services. matches found examining subconcept relation. output
considered match input B B. corresponds plug-in matches. later work
(Sirin & Parsia, 2004; Sirin et al., 2006), HTN approach (Sirin et al., 2004) mentioned
adapted work standard planning semantics, description logics semantics
OWL-S. difficulties inherent updating belief observed, connection belief
update studied literature made, remains unclear solution adopted.
far aware, methods relaxed matches follow
termed message-based approach WSC. approaches already discussed depth
Section 2.3. Next, give details ones closely related work.
99

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

approach Liu et al. (2007) discussed sufficient detail already Section 2.3,
reconsider here.
Meyer Weske (2006) handle ontology axioms WSC tool, provide
semantics action applications. Reasoning used determine whether particular output
used establish particular input, approach classified message-based,
terms. kind matches handled said plug-in. best knowledge,
tool existing WSC tool employs relaxed plan based heuristic function,
CFF. However, various design decisions, authors sacrifice scalability. explicitly
enumerate world states every belief, hence suffer exponentially large beliefs.
search forward parallel actions consequently suffer huge branching factor.
take heuristic relaxed planning graph length (rather relaxed plan length) thus
suffer fact that, time, hmax much less informative heuristic h+ (Bonet
& Geffner, 2001; Hoffmann, 2005).
approach rather closely related ours, handle partial matches, described
Constantinescu Faltings (2003) Constantinescu et al. (2004a, 2004b). work
ontology assumed take form tree concepts, edges indicate subconcept
relation. tree compiled intervals, interval represents concept
contents arranged correspond tree. intervals used efficient implementation
indexing service lookup (discovery), well matching composition. latter
searches forward space switches. Starting initial input, current input type
A, service input Ai matches Ai 6= . services collected set
collected Ai covers (that is, union intervals various Ai contains
interval A). collected services form switch, next step search,
outputs becomes new input must treated (i.e., switch node). Composition
interleaved discovery, i.e., every search state discovery called find services
match state. search proceeds depth-first fashion. Major differences work
following. First, formalization different, using intervals vs. using standard notions
planning based logics. Second, approach interleaves discovery composition,
separate steps framework (web service discovery needed determine operators
WSC task). Third, approach considers concept trees vs. clausal integrity constraints. Last,
approach uses depth-first search, whereas one main points making one
exploit heuristic techniques implemented standard planning tools scalable WSC.
Finally, interesting approach related planning described Ambite Kapoor (2007).
capture dependencies different input variables web service, input described terms relation variables. done outputs.
relations formulated terms logical formulas relative ontology. underlying formalism first-order logic, modeling language quite expressive.24 Reasoning performed
order establish links (messages, terms) inputs outputs. algorithmic
framework happens inspired partial-order planning (Penberthy & Weld, 1992),
starting goal relation maintaining set open links. solution DAG web
services links correspond different kinds data exchanges (selection, projection, join,
union). Automatic insertion mediator services, e.g., converting set standard formats,
supported.
24. cost undecidable reasoning, according authors major issue practice.

100

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

extent, preconditions/effects clausal integrity constraints used model
relations sense Ambite Kapoor (2007). Say r k-ary relation definition
, describing input web service. set corresponding operators precondition
r(x1 , . . . , xk ), transform set universally quantified clauses. long
latter done, long ontology axioms likewise transformed, obtain
model equivalent Ambite Kapoor. sense, main modeling advantage
approach Ambite Kapoor WSC|f wd existential quantification. open question
whether quantification accommodated framework. Insertion mediator services
supported WSC|f wd , limited sense recognizing, via particular preconditions, particular kind mediator required. Modeling actual data flow bound
awkward. summary, work Ambite Kapoor advanced data description transformation point view. hand, Ambite Kapoor neither consider
belief update, place work context fully-fledged planning formalism,
less concerned exploiting heuristic technologies recent planners. Combining
virtues approaches within either framework interesting direction
research.

8. Discussion
suggested natural planning formalism significant notion web service composition
profile / capability level, incorporating on-the-fly creation constants model outputs, incomplete initial states model incomplete user input, conditional effects semantics model partial
matches, and, importantly, clausal integrity constraints model ontology axioms.
identified interesting special case, forward effects, semantics action applications
simpler general case. demonstrated relates belief update
literature, shown results reduced computational complexity. Forward effects
relate closely message-based WSC, results serve put form WSC context, extend towards general notion partial matches. Further, identified
compilation planning (initial state) uncertainty, opening interesting new connection
planning WSC areas.
empirical results encouraging, over-interpreted. test scenarios serve capture structural properties likely appear applications WSC
technology, approach yet put test actual practice. same, however,
said essentially current planning-based WSC technology, since field still rather immature. sense, thorough evaluation approach, planning-based WSC
whole, challenge future.
Apart evaluation, several directions research improving extending
technology introduced herein. line research find particularly interesting adapt
modern planning tools WSC, starting special cases, complications incurred
integrity constraints manageable. already outlined ideas adapting
CFF, pointed new challenges arise. appears particularly promising tailor generic
heuristic functions, originating planning, exploit typical forms ontology axioms occur
practice. Considering wealth heuristic functions available now, topic alone provides
material whole family subsequent work.

101

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

Acknowledgments
thank anonymous reviewers, well managing editor Derek Long, comments,
significant help improving paper.
Jorg Hoffmann performed part work employed University Innsbruck, Austria. work partly funded European Unions 6th Framework Programme SUPER project (IST FP6-026850, http://www.ip-super.org).
Piergiorgio Bertolis Marco Pistores work partly supported project Software
Methodology Technology Peer-to-Peer Systems (STAMPS).
Malte Helmerts work partly supported German Research Council (DFG) part
Transregional Collaborative Research Center Automatic Verification Analysis Complex
Systems (SFB/TR 14 AVACS). See www.avacs.org information.

Appendix A. Proofs
first formally prove Proposition 1, stating negative effects compiled away WSC.
so, first need introduce compilation formally. Assume WSC task (P,
+
IC , O, C0 , 0 , G ). construct second WSC task (P + , +
IC , , C0 , 0 , G ), initially
+
P + , IC O+ P, IC O, respectively. proceed follows. Let G
P predicate arity k, exists O, = (Xo , preo , Yo , effo ) effo
contains negative literal G(x1 , . . . , xk ). introduce new predicate notG P + ,
introduce two new clauses x1 , . . . , xk : G(x1 , . . . , xk ) notG(x1 , . . . , xk ) x1 , . . . , xk :
G(x1 , . . . , xk ) notG(x1 , . . . , xk ). every operator whose effect contains negation
G, replace, effo , G(a1 , . . . , ak ) notG(a1 , . . . , ak ).25 continue
negative effect literals remain O+ .
action (P, IC , O, C0 , 0 , G ) denote a+ corresponding action
+
+
(P + , +
IC , , C0 , 0 , G ). use notation vice versa, i.e., action
+
+
+
(P , IC , , C0 , 0 , G ) denotes corresponding action (P, IC , O, C0 , 0 , G ).
= (Cs , ) state using predicates P, denote s+ state using predicates P + ,
following properties: Cs+ = Cs ; p P Cs Is+ (p) = (p); notp
p P Cs Is+ (notp) = 1 iff (p) = 0. Since is, obviously, exactly one
s+ , use correspondence vice versa.
+
Proposition 1 Assume WSC task (P, IC , O, C0 , 0 , G ). Let (P + , +
IC , , C0 , 0 , G )
task negative effects compiled away. Assume action sequence ha1 , . . . , i.
Let b result executing ha1 , . . . , (P, IC , O, C0 , 0 , G ), b+ result
+
+
+
+
executing ha+
1 , . . . , (P , IC , , C0 , 0 , G ). Then, state s, b iff
s+ b+ .

Proof: induction length action sequence question. sequence empty,
consider initial beliefs two tasks, claim follows directly
definition. inductive step, say claim holds b b+ , action. need
show that, state s, res(b, a) iff s+ res(b+ , a+ ).
direction right left, say s+ res(b+ , a+ ). definition s+
+
+
+
res(s+
0 , ) state s0 b . induction hypothesis, s0 b. therefore suffices show
25. arguments ai may either variables constants.

102

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

res(s0 , a). need show (1) |= IC effa (2) differs s0 set-inclusion
minimal set values. (1) obvious definitions. Assume contrary (2)
exists s1 s1 |= IC effa s1 identical except exists least one propo+
sition p s1 (p) = s0 (p) s(p) 6= s0 (p). definition, get s+
1 |= IC effa+ .
+
+
+
+
Further, get s1 (p) = s0 (p) s+ (p) 6= s0 (p), altogether s1 <s+ s+ .
0
contradiction s+ res(s+ , a+ ), hence proves res(s0 , a) desired.
direction left right proceeds fashion. Say res(b, a). definition
+
res(s0 , a) state s0 b. induction hypothesis, s+
0 b . suffices
+
+
+
+
+
show s+ res(s+
0 , ). need show (1) |= IC effa (2) differs s0
set-inclusion minimal set values. (1) obvious definitions. Assume contrary
+
+
+
+
(2) exists s+
1 s1 |= IC effa+ s1 identical except
+
+
+
exists least one proposition p s+
1 (p) = s0 (p) (p) 6= s0 (p). definition, get
C

s1 |= IC effa . Further, p P 0 get s1 (p) = s0 (p) s(p) 6= s0 (p).
p = notq 6 P Cs0 get property q. Altogether, get s1 <s0 s.
+
contradiction res(s, a), hence proves s+ res(s+
2
0 , ) desired.
Theorem 1 Assume WSC task fixed arity, sequence ha1 , . . . , actions.
p2 -complete decide whether ha1 , . . . , plan.
Proof: Membership proved guess-and-check argument. First, observe that, arbitrary s, ,
A, decide within coNP whether res(s, A). Guess state Cs = Cs Ea .
Check whether |= IC effa . Check whether 6s . res(s, a) iff guess
succeeds. Further, action a, deciding whether inconsistent is, obviously, equivalent
satisfiability test, contained NP. instruments hand, design
guess-and-check procedure decide whether ha1 , . . . , plan. guess proposition
values along ha1 , . . . , i. check whether values comply res, lead
inconsistent action, final state satisfy goal. detail, checking proceeds
follows. First, check whether initial proposition values satisfy IC 0 . not, stop without
success. Otherwise, iteratively consider action ai , pre-state post-state . Check
NP oracle whether inconsistent. yes, stop success. not, test NP oracle
whether res(s, a). not, stop without success. Otherwise, < n, go ai+1 .
= n, test whether |= G . Stop success 6|= G , stop without success |= G .
ha1 , . . . , plan iff guess proposition values successful.
Hardness follows following adaptation proof Lemma 6.2 Eiter Gottlob
(1992). Validity QBF formula X.Y.[X, ], CNF, reduced plan testing
single action a. use 0-ary predicates X = {x1 , . . . , xm }, = {y1 , . . . , yn },
new 0-ary predicates {z1 , . . . , zm , r, t}. set operators contains single operator
empty in/out parameters, empty precondition, effect t. initial constants empty; 0
conjunction xi , yi , zi , r, t; G r. theory is:
(


^

i=1

(t xi zi )) (


^

(t xi zi )) (

i=1

^

(t r C)) (

C

103

n
^

i=1

(t yi r))

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

viewed set clauses C. readably, theory equivalent to:
[(


^

xi zi ) (r ) ((

n
_

yi ) r)]

i=1

i=1

refer initial belief b. plan test contains single action based (equal to,
fact) o. refer resulting belief b . Obviously, b contains single state everything
except true. Also, consistent: interpretation sets r yi 0 satisfies IC effa .
theory conjuncts xi zi make sure w b makes exactly one xi , zi true.
particular, different assignments X incomparable respect set inclusion. Hence,
every assignment aX truth values X, exists state b complies
aX : aX satisfiable together IC effa , assignment aX distant
least one variable (e.g., aX (xi ) = 1 aX (xi ) = 0 aX closer aX
regarding interpretation zi ).
prove that, plan, X.Y.[X, ] valid. Let aX truth value assignment X. above, state b complies aX . Since plan,
|= r. Therefore, due theory conjunct r , |= . Obviously, values
assigned satisfy aX .
direction, say X.Y.[X, ] valid. Assume that, contrary theW
claim,
plan. b 6|= r. then, due theory conjunct ( ni=1 yi ) r,
sets yi false. Now, X.Y.[X, ] valid, exists truth value
assignment aY complies setting xi zi s. Obtain modifying
comply aY , setting r 1. |= IC effa . then, closer
, hence 6 b contradiction. concludes argument.
2
Theorem 2. Assume WSC task fixed arity, natural number b unary representation.
p3 -complete decide whether exists plan length b.
Proof: membership, guess sequences actions containing b actions (note
size sequence polynomial size input representation). Theorem 1,
check p2 oracle whether sequence plan.
Hardness follows extension proof Lemma 6.2 Eiter Gottlob (1992). Validity QBF formula X.Y.Z.[X, Y, Z], CNF, reduced testing plan existence.
use 0-ary predicates X = {x1 , . . . , xn }, = {y1 , . . . , ym }, Z = {z1 , . . . , zk }, new
0-ary predicates {q1 , . . . , qm , r, t, f1 , . . . fn , h, g}. set operators composed of:
ot := (, f1 fn h, , g h)
1 n: oxi := (, h, , xi )
1 n: oxi := (, h, , xi )
initial constants empty. initial literal conjunction 0 composed yi , zi , qi ,
r, t, , h, g. is, yi , zi , qi well r h true, well
g false. value specified (only) xi . goal G r g. theory is:
(


^

i=1

(t yi qi )) (


^

(t yi qi )) (

i=1

^

(t r C)) (

C

104

n
^

i=1

(t zi r))

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

viewed set clauses C. readably, theory equivalent to:
[(


^

yi qi ) (r ) ((

i=1

n
_

zi ) r)]

i=1

First, note obvious things construction:
ot must included plan.
ot applied, action applied anymore.
ot applied, either oxi oxi must applied, every 1 n.
theory switched off, i.e., made irrelevant false, point ot
applied.
is, plan task must first apply oxi oxi , every 1 n, thereby choosing
value every xi . Then, ot must applied plan must stop. applying ot , changes
made states except values xi set made true one
other. Hence, belief b ot applied contains single state corresponds
extension 0 value assignment X, values flipped.
denote value assignment X aX . denote b := res(b, ot ). Note
ot consistent: interpretation sets r zi 0, besides setting immediate effects
g h, satisfies IC effot . Obviously, applications oxi oxi consistent
well.
theory conjuncts yi qi make sure w b makes exactly one yi , qi true.
particular, different assignments incomparable respect set inclusion. Hence,
every assignment aY truth values , exists state b complies
aY : aY satisfiable together IC effot , assignment aY distant
least one variable (e.g., aY (yi ) = 1 aY (yi ) = 0 aY closer aY regarding
interpretation qi ).
prove that, exists plan ~a yielding assignment aX , X.Y.Z.[X, Y, Z]
valid. Let aY arbitrary truth value assignment . state b
complies aX aY . aX aY satisfiable together IC effot . above,
assignment aY distant least one variable. And, course, one deviates
aX one distant respective variable. Since ~a plan, |= r.
Therefore, due theory conjunct r , |= . Obviously, values assigned Z
satisfy aX aY . proves claim aY chosen arbitrarily.
direction, say X.Y.Z.[X, Y, Z] valid. Let aX assignment X
Y.Z.[aX /X, Y, Z] valid. Let ~a corresponding plan, i.e., ~a first applies, 1 n,
either oxi oxi according aX . Thereafter, ~a applies ot . Assume
Wn ~a plan.



b 6|= r. then, due theory conjunct ( i=1 zi ) r, sets
zi false. Now, Y.Z.[aX /X, Y, Z] valid, exists truth value assignment
aZ Z complies setting xi , yi , qi s. Obtain modifying comply
aZ , setting r 1. |= IC effot . then, closer ,
hence 6 b contradiction. concludes argument.
2

105

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

Theorem 3. Assume WSC task. decision problem asking whether exists plan
undecidable.
Proof: result holds even empty background theory, complete specification
initial state, predicates arity 2, operators arity 2, goal variables
(arity 0), positive literals preconditions goal. result follows minor
modification Tom Bylanders proof (Bylander, 1994) plan existence propositional STRIPS
planning PSPACE-complete.26 original proof proceeds generic reduction, constructing
STRIPS task Turing Machine (TM) polynomially bounded space. latter restriction
necessary model machines tape: tape cells pre-created positions within bound.
makes difference PSPACE-membership undecidability ability create
constants. introduce simple operators allow us extend tape, ends.
detail, say TM (a finite number of) states q tape alphabet symbols (where b
blank); transition function, q0 initial state, F set accepting states;
input word. planning encoding contains following predicates. State(q) indicates
current TM state q. In(a, c) indicates current content tape cell c a. N eighbors(c, c )
true iff c (immediate) right neighbor c. At(c) indicates current position
TM head c. Rightmost(c) (Lef tmost(c)) true iff c currently right (left) neighbor.
set initial constants contains states q, alphabet symbols a, tape cells c corresponding
. initial literals, propositions constants assigned truth values
obvious. every transition (q, a, q , , R) include operator:
({x, x }, State(q) In(x, a) N eighbors(x, x ) At(x),
, State(q ) State(q) In(x, ) In(x, a) At(x ) At(x)).
Obviously, encodes exactly transition. likewise transitions (q, a, q , , L) .
model final states, introduce 0-ary predicate G, include q F operator:
(, State(q), , G)
finally include operators:
({x}, Rightmost(x), {x }, N eighbors(x, x ) In(b, x ) Rightmost(x ) Rightmost(x))

({x }, Lef tmost(x ), {x}, N eighbors(x, x ) In(b, x) Lef tmost(x) Lef tmost(x ))
definitions, easy verify exists plan iff TM reach accepting
state .
2
Lemma 1. Assume WSC|f wd task, reachable state s, action a. res(s, a) =
res|f wd (s, a).
26. Propositional STRIPS framework, empty background theory, complete specification
initial state, goal variables, positive literals preconditions goal, output
parameters operators.

106

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

Proof: applicable s, claim holds trivially. Consider case.
Equation 3, res(s, a) defined

{(C , ) | C = Cs Ea , min(s, C , IC effa )} appl(s, a)
res(s, a) :=
{s}
otherwise
min(s, C , IC effa ) set C -interpretations satisfy IC effa
minimal respect partial order defined I1 I2 :iff propositions p Cs ,
I2 (p) = (p) I1 (p) = (p).
obvious res|f wd (s, a) res(s, a) satisfies IC effa identical
propositions Cs , particular minimal according .
direction, let res(s, a). Assume (p) 6= (p) proposition p
Cs . Define equal except (p) := (p). Obviously, 6s I2 .
suffices show |= IC effa : then, get 6 min(s, C , IC effa ) contradiction,
hence agrees propositions p Cs , hence res|f wd (s, a).
before, denote P Cs +Ea set propositions arguments Cs Ea ,
least one argument E, denote IC [Cs + Ea ] instantiation IC
constants Cs Ea , clause least one variable instantiated Ea . see
|= IC effa , consider first equivalent |= IC [Cs Ea ] effa ,
turn equivalent |= IC [Cs ] IC [Cs + Ea ] effa . last formula, task
WSC|f wd , IC [Cs ] speaks propositions P Cs , whereas IC [Cs +Ea ]effa speaks
propositions P Cs +Ea . treat two parts separately. |= IC [Cs ]
|= IC [Cs ] prerequisite since reachable. |= IC [Cs + Ea ] effa
definition. concludes argument.
2
Theorem 4. Assume WSC|f wd task fixed arity, sequence ha1 , . . . , actions.
coNP-complete decide whether ha1 , . . . , plan.
Proof: Hardness obvious, considering empty sequence. Membership shown
following guess-and-check argument. Say C union C0 output constants appearing
hA1 , . . . , i. guess interpretation propositions P C. Further,
1 n, guess set Ct constants. check polynomial time whether
Ct correspond execution hA1 , . . . , i. 1 n , say
applicable |= prea , Ca Ct , Ea Ct = . First, assert |= IC . Second,
, assert that, applicable, |= effa . Third, assert Ct+1 =
Ct {Ea | , applicable}. Using Lemma 1, easy see Ct correspond
execution iff three assertions hold. Note needs time-stamped
action generated outputs properties respective propositions remain fixed
forever. claim follows because, fixed arity, test polynomial time whether
Cn satisfy G . guess Ct successful corresponds execution
satisfy G . Obviously, hA1 , . . . , plan iff guess Ct .
2
Theorem 5. Assume WSC|f wd task fixed arity, natural number b unary representation. p2 -complete decide whether exists plan length b.
Proof: membership, guess sequence b actions. Theorem 1, check
p2 oracle whether sequence plan.
107

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

prove hardness, assume QBF formula X.Y.[X, ] DNF normal form.
(This formula class complete p2 .) Say X = x1 , . . . , xn , = y1 , . . . , ym , = 1
k . design WSC|f wd task plan iff X.Y.[X, ] true. key construction
use outputs creation time steps, allow setting xi time step i.
yi take arbitrary values. xi set, one operator per k allows achieve goal
given k true. main property need ensure construction xi set
once, i.e., either 1 0. plan task iff one set X that,
, least one true case iff X.Y.[X, ] true.
predicates task P = {x1 (.), . . . , xn (.), y1 (), . . . , ym (), time(.), start(.),
next(..), goal(.)}. indicate predicate arity number points parentheses.
example, predicate next(..) arity 2. theory IC empty. initial constants
C0 = {t0 }. initial literals 0 = time(t0 ). goal y.goal(y). operators
follows:
1 n, have: oxi 1 = ({t0 , . . . , ti1 }, start(t0 ) next(t0 , t1 )
next(ti2 , ti1 ), {ti }, time(ti )next(ti1 , ti )xi (ti )). operator allows generating
time step i, setting xi 1 step.
1 n, have: oxi 0 = ({t0 , . . . , ti1 }, start(t0 ) next(t0 , t1 )
next(ti2 , ti1 ), {ti }, time(ti ) next(ti1 , ti ) xi (ti )). operator allows generating time step i, setting xi 0 step.
define value B below. n j < n + B, have: otj = ({t0 , . . . , tj1 },
start(t0 ) next(t0 , t1 ) next(tj2 , tj1 ), {tj }, time(tj ) next(tj1 , tj )).
operators allow increasing time step n n + B.
1 k, say = xlxj1 xlxjxn ylyj1 ylyjyn xlj {xj , xj }
ylj {yj , yj }. have: oi = ({t0 , . . . , tn+B }, start(t0 ) next(t0 , t1 )
next(tn+B1 , tn+B ) xlxj1 (txj1 ) xlxjxn (txjxn ) ylyj1 () ylyjyn (), {c},
goal(c)). operator allows achieve goal time step n + B, provided
respective true. Note xj precondition literals refer time step tj , i.e.,
value set xj earlier time step, yj precondition literals arguments
refer initial values yj , arbitrary.
Assume choose value B (polynomial input size). X.Y.[X, ] true,
then, obviously, find plan size n + B + k. apply oxi 1 oxi 0 operator xi ,
depending whether xi must set 1 0. apply B operators otj . apply operators
oi . respective input parameter instantiations obvious.
opposite direction proving truth X.Y.[X, ] based plan problematic.
plan might cheat setting xi 1 0. reason construction
complicated able avoid precisely case, based specifying strict enough plan length
bound b. key property that, order cheat xi , plan generate two sequences
time steps ti , . . . , tn+B . Therefore, lower bound length cheating plan n + 2B.
already seen, upper bound length non-cheating plan n + B + k.
determine plan length bound b, simply choose B cheating plan
use many steps: n+2B > n+B +k case iff B > k. set B := k +1, obtain
b := n + 2k + 1. bound b, plan proceed setting xi value (n actions),
108

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

increasing time step n + B = n + k + 1 (k + 1 actions), applying sufficient subset
oi (at k actions). plan cheats, needs apply least n+2B = n+2k +2 actions
able apply oi actions exploiting different value settings xi . concludes
argument.
2
Theorem 6. Assume WSC|f wd task. decision problem asking whether exists plan
undecidable.
Proof: reduce halting problem Abacus machines, undecidable. Abacus machine consists tuple integer variables v1 , . . . , vk (ranging positive integers
including 0), tuple instructions I1 , . . . , . state given content v1 , . . . , vk plus
index pc active instruction. machine stops iff reaches state pc = n. vi
initially 0, pc initially 0. two kinds instructions. Ii : INC j; GOTO Ii increments value vj jumps pc = . Ii : DEC j; BRANCH Ii+ /Ii0 asks whether vj = 0.
so, jumps pc = i0 . Otherwise, decrements value vj jumps pc = i+ .
map arbitrary abacus program WSC|f wd instance follows:
Predicates: number(v), zero(v), succ(v , v), value1 (v, t), . . . , valuek (v, t), instruction1 (t),
. . . , instructionn (t)
Background theory: none (i.e., trivial theory)
Operators:
operator h{v}, {number(v)}, {v }, {number(v ), succ(v , v)}i
instructions form Ii : INC j; GOTO Ii , operator
h{v1 , . . . , vk , t},
{instructioni (t), value1 (v1 , t), . . . , valuek (vk , t), succ(v , vj )},
{t },
{instructioni (t ), value1 (v1 , ), . . . , valuej1 (vj1 , ), valuej (v , ),
valuej+1 (vj+1 , ), . . . , valuek (vk , )}i.
instructions form Ii : DEC j; BRANCH Ii+ /Ii0 , operators
h{v1 , . . . , vk , t},
{instructioni (t), value1 (v1 , t), . . . , valuek (vk , t), succ(vj , v )},
{t },
{instructioni+ (t ), value1 (v1 , ), . . . , valuej1 (vj1 , ), valuej (v , ),
valuej+1 (vj+1 , ), . . . , valuek (vk , )}i.

h{v1 , . . . , vk , t},
{instructioni (t), value1 (v1 , t), . . . , valuek (vk , t), zero(vj )},
{t },
{instructioni0 (t ), value1 (v1 , ), . . . , valuej1 (vj1 , ), valuej (vj , ),
valuej+1 (vj+1 , ), . . . , valuek (vk , )}i.
109

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

Initial constants: v0 , t0
Initial literals: number(v0 )zero(v0 )value1 (v0 , t0 ) valuek (v0 , t0 )instruction1 (t0 )
Goal condition: t.instructionn (t)
describe intuitive meaning constants predicates. two kinds constants: numbers, represent natural numbers (including 0), time points, represent
computation steps Abacus machine. Variables refer time points denoted
above. variables represent numbers.
Three predicates refer numbers exclusively: number(v) true iff v encodes natural number
(and time point); zero(v) true iff v encodes number 0; succ(v , v) true iff v
encodes number one larger number encoded v. reduction
enforce every number uniquely represented (e.g., may several representations
number 3), unique representation necessary. guaranteed number 0
uniquely represented, though.
remaining predicates encode configurations Abacus machine: valuei (v, t) true iff,
time point t, i-th Abacus variable holds number represented v, instructionj (t)
true iff current instruction time point Ij .
Obviously, accepting run Abacus machine extract plan task,
vice versa. proves claim.
2
prove Theorems 7 8, first establish core lemma theorems follow
relatively easily. need notations. denote beliefs (states) (P, IC , O, C0 , 0 , G )
b (s), denote beliefs (states) (P , A, 0 , G ) b (s). Assume sequence ha1 , . . . ,
ai non-goal achievement actions. denote b := res(b0 , ha1 , . . . , ai i) b := res(b0 ,
ha1 , . . . , ai i). Note overload res function denote state transitions
compiled task formalism. Further, state s, C(s) := {c | s(Ex(c)) = 1} denote
constants exist s. denote C relation states true iff
C(s) = C(s ) s|C(s) = |C(s) . C equivalence relation, equivalent states agree
constants exist howVthey interpreted. Note every state reachable
compiled
V
task satisfies |= IC 0 oO effo [Eo ]. Note IC 0 oO effo [Eo ] actually
satisfiable prerequisite, unless IC 0 unsatisfiable, outputs instantiated
unique constants operators consistent. state s, define [s] :=
^
[
{s | defined C0
effo [Eo ]}
Eo , C(s) = Cs , s|Cs = , |= IC 0
oO

oO

is, [s] equivalence class states reachable compiled task agree
constants exist interpreted.
Lemma 3 Assume WSC|sf wd task without inconsistent operators. Let ha1 , . . . , ai consist
non-goal achievement
actions, let b := res(b0 , ha1 , . . . , ai i) b := res(b0 , ha1 , . . . , ai i).

b = sb [s].

Proof: proof induction i. base case, = 0, i.e., b = b0 b = b0 .
b0 =
{s | Cs = C0 , |= IC 0 }
110

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

hand, b0 =
{s | C(s) = C0 , |= IC 0

^

effo [Eo ]}

oO

Obviously, latter comprised one equivalence class possibility assign propositions C0 way compliant IC 0 . exactly claim.
theS
inductive case, say add another action
ha1 , . . . , ai i. induction assumption,
b = sb [s]. need prove res(b, a) = res(b,a) [s ]. Obviously, suffices prove

that, every b, res([s], a) = res(s,a) [s ]. First, say applicable s.

neither applicable [s], res([s], a) = [s] = res(s,a) [s ]. Second, say
applicable s. Lemma 1 res(s, a) =
{(Cs Ea , ) | |Cs = , |= IC effa }
hand, res([s], a) =
{s | ex. [s], C(s ) = C(s) Ea , |C(s) = s, |= IC 0

^

effo [Eo ]}

oO

re-write latter
{s | C(s ) = Cs Ea , |Cs = , |= IC 0

^

effo [Eo ]}

oO

Obviously, desired, latter set comprised one equivalence class possibility
assign propositions Cs Ea way compliant IC effa . concludes
argument.
2
Theorem 7. Assume WSC|sf wd task (P, IC , O, C0 , 0 , G ) without inconsistent operators,
plan ha1 , . . . , compiled task (P , A, 0 , G ). sub-sequence non-goal
achievement actions ha1 , . . . , plan (P, IC , O, C0 , 0 , G ).
Proof: IC 0 unsatisfiable, nothing prove, start belief original
task empty. non-trivial case, first note that, plan compiled task, goal
achievement actions moved back plan. Hence, without loss generality,
assume ha1 , . . . , ai consist entirely non-goal achievement actions, hai+1 , . . . , ai consist
entirely goal achievement actions.
Denote b := res(b0 , ha1 , . . . , ai i) b := res(b0 , ha1 , . . . ,
ai i). Lemma 3, b = sb [s]. Since ha1 , . .
. , plan compiled task, every
b tuple constants satisfying G . b = sb [s], follows every b satisfies
G .
2
Theorem 8. Assume WSC|sf wd task (P, IC , O, C0 , 0 , G ) without inconsistent operators,
plan ha1 , . . . , every operator appears one instantiation Eo
outputs. ha1 , . . . , extended goal achievement actions form plan
compiled task (P , A, 0 , G ) obtained using outputs Eo .
Proof:
Denote b := res(b0 , ha1 , . . . , i) b := res(b0 , ha1 , . . . , i).
Lemma 3,
b = sb [s]. Since ha1 , . . . , plan, every b satisfies G . b = sb [s], follows
every b tuple constants satisfying G . Attaching respective goal achievement
actions yields plan compiled task.
2
111

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

References
3DComplex.org (2008). web server browse protein complexes known 3d structures.
http://supfam.mrc-lmb.cam.ac.uk/elevy/3dcomplex/data/hierarchy 1/root.html.
Agarwal, V., Chafle, G., Dasgupta, K., Karnik, N., Kumar, A., Mittal, S., & Srivastava, B. (2005a).
Synthy: system end end composition web services. Journal Web Semantics,
3(4).
Agarwal, V., Dasgupta, K., Karnik, N., Kumar, A., Kundu, A., Mittal, S., & Srivastava, B. (2005b).
service creation environment based end end composition web services. 14th
International Conference World Wide Web (WWW05), pp. 128137.
Akkiraju, R., Srivastava, B., Anca-Andreea, I., Goodwin, R., & Syeda-Mahmood, T. (2006). Semaplan: Combining planning semantic matching achieve web service composition.
4th International Conference Web Services (ICWS06).
Ambite, J., & Kapoor, D. (2007). Automatically composing data workflows relational descriptions shim services. 6th International Semantic Web Conference (ISWC07).
Ankolekar, A., Burstein, M., Hobbs, J., Lassila, O., Martin, D., McDermott, D., McIlraith, S.,
Narayanan, S., Paolucci, M., Payne, T., & Sycara, K. (2002). DAML-S: Web service description semantic web. 1st International Semantic Web Conference (ISWC02).
Au, T.-C., Kuter, U., & Nau, D. (2005). Web service composition volatile information. 4th
International Semantic Web Conference (ISWC05).
Au, T.-C., & Nau, D. (2006). incompleteness planning volatile external information.
17th European Conference Artificial Intelligence (ECAI06).
Baader, F., Lutz, C., Milicic, M., Sattler, U., & Wolter, F. (2005). Integrating description logics
action formalisms: First results. 20th National Conference Artificial Intelligence
(AAAI05).
Bacchus, F. (2000). Subset PDDL AIPS2000 Planning Competition. AIPS-00 Planning Competition Committee.
Bertoli, P., Pistore, M., & Traverso, P. (2006). Automated web service composition on-the-fly
belief space search. 16th International Conference Automated Planning Scheduling
(ICAPS06).
Bonet, B., & Geffner, H. (2000). Planning incomplete information heuristic search belief
space. 5th International Conference Artificial Intelligence Planning Systems (AIPS00),
pp. 5261.
Bonet, B., & Geffner, H. (2001). Planning heuristic search. Artificial Intelligence, 129(12),
533.
Branden, C., & Tooze, J. (1998). Introduction Protein Structure: Second Edition. Garland Publishing Company, New York. ISBN 0815323050.
Brayton, R., Hachtel, G., McMullen, C., & Sangiovanni-Vincentelli, A. (1984). Logic Minimization
Algorithms VLSI Synthesis. Kluwer Academic Publishers.
Brewka, G., & Hertzberg, J. (1993). things worlds: formalizing actions
plans. J. Logic Computation, 3(5), 517532.
112

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

Bryce, D., Kambhampati, S., & Smith, D. E. (2006). Planning graph heuristics belief space
search. Journal Artificial Intelligence Research, 26, 3599.
Burstein, M., Hobbs, J., Lassila, O., McDermott, D., McIlraith, S., Narayanan, S., Paolucci, M.,
Parsia, B., Payne, T., Sirin, E., Srinivasan, N., Sycara, K., & Martin, D. (2004). OWL-S:
Semantic Markup Web Services. OWL-S 1.1. http://www.daml.org/services/owl-s/1.1/.
Version 1.1.
Bylander, T. (1994). computational complexity propositional STRIPS planning. Artificial
Intelligence, 69(12), 165204.
Chasman, D. (Ed.). (2003). Protein Structure Determination, Analysis Applications Drug
Discovery. Marcel Dekker Ltd. 0-8247-4032-7.
Chen, Y., Wah, B., & Hsu, C. (2006). Temporal planning using subgoal partitioning resolution
SGPlan. Journal Artificial Intelligence Research, 26, 323369.
Cimatti, A., Roveri, M., & Bertoli, P. (2004). Conformant planning via symbolic model checking
heuristic search. Artificial Intelligence, 159(12), 127206.
Constantinescu, I., & Faltings, B. (2003). Efficient matchmaking directory services. 2nd
International Conference Web Intelligence (WI03).
Constantinescu, I., Faltings, B., & Binder, W. (2004a). Large scale, type-compatible service composition. 2nd International Conference Web Services (ICWS04).
Constantinescu, I., Faltings, B., & Binder, W. (2004b). Typed Based Service Composition. 13th
International Conference World Wide Web (WWW04).
de Giacomo, G., Lenzerini, M., Poggi, A., & Rosati, R. (2006). update description
logic ontologies instance level. 21st National Conference Artificial Intelligence
(AAAI06).
de Giacomo, G., Lenzerini, M., Poggi, A., & Rosati, R. (2007). approximation instance
level update erasure description logics. 22nd National Conference American
Association Artificial Intelligence (AAAI07).
de Jonge, M., van der Linden, W., & Willems, R. (2007). eServices hospital equipment. 6th
International Conference Service-Oriented Computing (ICSOC07), pp. 391397.
Edelkamp, S. (2003). Promela planning. 10th International SPIN Workshop Model Checking
Software (SPIN03).
Eiter, T., Faber, W., Leone, N., Pfeifer, G., & Polleres, A. (2003). logic programming approach
knowledge-state planning, II: DLVK system. Artificial Intelligence, 144(1-2), 157211.
Eiter, T., Faber, W., Leone, N., Pfeifer, G., & Polleres, A. (2004). logic programming approach
knowledge-state planning: Semantics complexity. Transactions Computational Logic,
5(2), 206263.
Eiter, T., & Gottlob, G. (1992). complexity propositional knowledge base revision, updates, counterfactuals. Artificial Intelligence, 57(2-3), 227270.
Fagin, R., Kuper, G., Ullman, J., & Vardi, M. (1988). Updating logical databases. Advances
Computing Research, 3, 118.

113

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

Fensel, D., Lausen, H., Polleres, A., de Bruijn, J., Stollberg, M., Roman, D., & Domingue, J. (2006).
Enabling Semantic Web Services Web Service Modeling Ontology. Springer-Verlag.
Fersht, A. (1998). Structure Mechanism Protein Science: Guide Enzyme Catalysis
Protein Folding. MPS. ISBN-13 9780716732686.
Fox, M., & Long, D. (2003). PDDL2.1: extension PDDL expressing temporal planning
domains. Journal Artificial Intelligence Research, 20, 61124.
Gerevini, A., Saetti, A., & Serina, I. (2003). Planning stochastic local search temporal
action graphs. Journal Artificial Intelligence Research, 20, 239290.
Gerevini, A., Saetti, A., Serina, I., & Toninelli, P. (2005). Fast planning domains derived
predicates: approach based rule-action graphs local search. 20th National Conference American Association Artificial Intelligence (AAAI05).
Ginsberg, M., & Smith, D. (1988). Reasoning action I: possible worlds approach. Artificial
Intelligence, 35(2), 165195.
Giunchiglia, E., Lee, J., Lifschitz, V., McCain, N., & Turner, H. (2004). Nonmonotonic causal
theories. Artificial Intelligence, 153(1-2), 49104.
Giunchiglia, E., & Lifschitz, V. (1998). action language based causal explanation: Preliminary report. 15th National Conference Artificial Intelligence (AAAI98).
Golden, K. (2002). DPADL: action language data processing domains. Proc. 3rd
International NASA Planning Scheduling Workshop.
Golden, K. (2003). domain description language data processing. Proc. Workshop
Future PDDL ICAPS03.
Golden, K., Pand, W., Nemani, R., & Votava, P. (2003). Automating processing earth observation data. Proceedings 7th International Symposium Artificial Intelligence,
Robotics Automation Space.
Gomes, C., Selman, B., Crato, N., & Kautz, H. (2000). Heavy-tailed phenomena satisfiability
constraint satisfaction problems. Journal Automated Reasoning, 24(1/2), 67100.
Helmert, M. (2002). Decidability undecidability results planning numerical state variables. 6th International Conference Artificial Intelligence Planning Systems (AIPS02).
Helmert, M. (2006). Fast Downward planning system. Journal Artificial Intelligence Research, 26, 191246.
Herzig, A. (1996). PMA revisited. 5th International Conference Principles Knowledge
Representation Reasoning (KR96).
Herzig, A., Lang, J., Marquis, P., & Polacsek, T. (2001). Updates, actions, planning. 17th
International Joint Conference Artificial Intelligence (IJCAI01), pp. 119124.
Herzig, A., & Rifi, O. (1999). Propositional belief base update minimal change. Artificial
Intelligence, 115(1), 107138.
Hoffmann, J. (2005). ignoring delete lists works: Local search topology planning benchmarks. Journal Artificial Intelligence Research, 24, 685758.
Hoffmann, J., & Brafman, R. (2006). Conformant planning via heuristic forward search: new
approach. Artificial Intelligence, 170(67), 507541.
114

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

Hoffmann, J., & Nebel, B. (2001). planning system: Fast plan generation heuristic
search. Journal Artificial Intelligence Research, 14, 253302.
Katzuno, H., & Mendelzon, A. (1991). difference updating knowledge base
revising it. 2nd International Conference Principles Knowledge Representation
Reasoning (KR91).
Kona, S., Bansal, A., Gupta, G., & Hite, D. (2007). Automatic composition semantic web services. 5th International Conference Web Services (ICWS07).
Kumar, A., Neogi, A., Pragallapati, S., & Ram, J. (2007). Raising programming abstraction
objects services. 5th International Conference Web Services (ICWS07).
Kuter, U., Sirin, E., Nau, D., Parsia, B., & Hendler, J. (2005). Information gathering planning
web service composition. Journal Web Semantics, 3(2-3), 183205.
Lecue, F., & Delteil, A. (2007). Making difference semantic web service composition.
22nd National Conference American Association Artificial Intelligence (AAAI07).
Lecue, F., & Leger, A. (2006). formal model semantic web service composition. 5th
International Semantic Web Conference (ISWC06).
Li, L., & Horrocks, I. (2003). software framework matchmaking based semantic web
technology. 12th International Conference World Wide Web (WWW03).
Liberatore, P. (2000). complexity belief update. Artificial Intelligence, 119(1-2), 141190.
Lin, F., & Reiter, R. (1994). State constraints revisited. Journal Logic Computation, 4(5),
655678.
Liu, H., Lutz, C., Milicic, M., & Wolter, F. (2006a). Reasoning actions using description
logics general TBoxes. 10th European Conference Logics Artificial Intelligence
(JELIA 2006).
Liu, H., Lutz, C., Milicic, M., & Wolter, F. (2006b). Updating description logic ABoxes. 10th International Conference Principles Knowledge Representation Reasoning (KR06).
Liu, Z., Ranganathan, A., & Riabov, A. (2007). planning approach message-oriented semantic
web service composition. 22nd National Conference American Association
Artificial Intelligence (AAAI07).
Long, D., & Fox, M. (2003). 3rd international planning competition: Results analysis.
Journal Artificial Intelligence Research, 20, 159.
Lutz, C., & Sattler, U. (2002). proposal describing services DLs. International
Workshop Description Logics 2002 (DL02).
McCain, N., & Turner, H. (1995). causal theory ramifications qualifications. 14th
International Joint Conference Artificial Intelligence (IJCAI-95), pp. 19781984.
McCarthy, J., & Hayes, P. (1969). philosophical problems standpoint artificial
intelligence. Machine Intelligence, 4, 463502.
McDermott, D. (2002). Estimated-regression planning interactions web services. 6th
International Conference Artificial Intelligence Planning Systems (AIPS02).
McDermott, D., et al. (1998). PDDL Planning Domain Definition Language. AIPS-98
Planning Competition Committee.
115

fiH OFFMANN , B ERTOLI , H ELMERT & P ISTORE

McDermott, D. V. (1999). Using regression-match graphs control search planning. Artificial
Intelligence, 109(1-2), 111159.
McGeer, P., Sanghavi, J., Brayton, R. K., & Sangiovanni-Vincentelli, A. (1993). ESPRESSOSignature: new exact minimizer logic functions. Proceedings 30th ACM/IEEE
Design Automation Conference (DAC-93).
McGuinness, D. L., & van Harmelen, F. (2004). OWL Web Ontology Language Overview (W3C
Recommendation). online http://www.w3.org/TR/owl-features/.
McIlraith, S., & Fadel, R. (2002). Planning complex actions. 9th International Workshop
Non-Monotonic Reasoning (NMR02), pp. 356364.
McIlraith, S., & Son, T. C. (2002). Adapting Golog composition semantic Web services.
8th International Conference Principles Knowledge Representation Reasoning
(KR02).
Mediratta, A., & Srivastava, B. (2006). Applying planning composition web services
user-driven contingent planner. Tech. rep. RI 06002, IBM Research.
Meyer, H., & Weske, M. (2006). Automated service composition using heuristic search. 4th
International Conference Business Process Management (BPM06).
Narayanan, S., & McIlraith, S. (2002). Simulation, verification automated composition web
services. 11th International Conference World Wide Web (WWW02).
Palacios, H., & Geffner, H. (2007). conformant classical planning: Efficient translations
may complete too. 17th International Conference Automated Planning
Scheduling (ICAPS07).
Paolucci, M., Kawamura, T., Payne, T., & Sycara, K. (2002). Semantic matching web services
capabilities. 1st International Semantic Web Conference (ISWC02).
Pednault, E. P. (1989). ADL: Exploring middle ground STRIPS situation
calculus. 1st International Conference Principles Knowledge Representation
Reasoning (KR89).
Penberthy, J., & Weld, D. (1992). UCPOP: sound, complete, partial order planner ADL.
3rd International Conference Principles Knowledge Representation Reasoning
(KR92), pp. 103114.
Petsko, G. A., & Ringe, D. (2004). Protein Structure Function. New Science Press. ISBN
1405119225, 9781405119221.
Pistore, M., Marconi, A., Bertoli, P., & Traverso, P. (2005a). Automated composition web services planning knowledge level. 19th International Joint Conference Artificial
Intelligence (IJCAI05).
Pistore, M., Traverso, P., & Bertoli, P. (2005b). Automated composition web services planning
asynchronous domains. 15th International Conference Automated Planning
Scheduling (ICAPS05).
Pistore, M., Traverso, P., Bertoli, P., & Marconi, A. (2005c). Automated synthesis composite
BPEL4WS web services. 3rd International Conference Web Services (ICWS05).

116

fiW EB ERVICE C OMPOSITION P LANNING U NCERTAINTY: N EW C ONNECTION

Ponnekanti, S., & Fox, A. (2002). SWORD: developer toolkit web services composition.
11th International Conference World Wide Web (WWW02).
Reiter, R. (1991). frame problem situation calculus: simple solution (sometimes)
completeness result goal regression. Artificial intelligence mathematical theory
computation: papers honour John McCarthy, pp. 359380.
Roman, D., Keller, U., Lausen, H., de Bruijn, J., Lara, R., Stollberg, M., Polleres, A., Feier, C.,
Bussler, C., & Fensel, D. (2005). Web Service Modeling Ontology. Applied Ontology, 1(1),
77106.
Sheshagiri, M., desJardins, M., & Finin, T. (2003). planner composing services described
DAML-S. Third Symposium Adaptive Agents Multi-Agent Systems (AAMAS03).
Sirin, E., Parsia, B., Wu, D., Hendler, J., & Nau, D. (2004). HTN planning web service composition using SHOP2. Journal Web Semantics, 1(4).
Sirin, E., Hendler, J., & Parsia, B. (2003). Semi-automatic composition web services using
semantic descriptions. Workshop Web Services ICEIS03.
Sirin, E., & Parsia, B. (2004). Planning semantic web services. Workshop Semantic Web
Services ISWC04.
Sirin, E., Parsia, B., & Hendler, J. (2004). Composition-driven filtering selection semantic
web services. AAAI Fall Symposium Semantic Web Services.
Sirin, E., Parsia, B., & Hendler, J. (2006). Template-based composition semantic web services.
AAAI Fall Symposium Agents Search.
Smith, D. E., & Weld, D. (1998). Conformant Graphplan. 15th National Conference
American Association Artificial Intelligence (AAAI-98).
Srivastava, B. (2002). Automatic web services composition using planning. Knowledge Based
Computer Systems (KBCS02), pp. 467477.
Thakkar, S., Ambite, J. L., & Knoblock, C. (2005). Composing, optimizing, executing plans
bioinformatics web services. VLDB Journal, Special Issue Data Management, Analysis
Mining Life Sciences, 14(3), 330353.
Thiebaux, S., Hoffmann, J., & Nebel, B. (2005). defense PDDL axioms. Artificial Intelligence,
168(12), 3869.
Winslett, M. (1988). Reasoning actions using possible models approach. 7th National
Conference American Association Artificial Intelligence (AAAI88).
Winslett, M. (1990). Updating Logical Databases. Cambridge University Press.
Zhan, R., Arpinar, B., & Aleman-Meza, B. (2003). Automatic composition semantic web services. 1st International Conference Web Services (ICWS03).

117


