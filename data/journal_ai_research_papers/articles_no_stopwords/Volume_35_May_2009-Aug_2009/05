journal artificial intelligence

submitted published

complexity circumscription description logic
piero bonatti

bonatti na infn

section computer science department physics
university naples federico ii italy

carsten lutz

clu informatik uni bremen de

department mathematics computer science
university bremen germany

frank wolter

wolter liverpool ac uk

department computer science
university liverpool uk

abstract
fragments first order logic description logics dls provide nonmonotonic
features defeasible inheritance default rules since many applications would
benefit availability features several families nonmonotonic dls
developed mostly default logic autoepistemic logic
consider circumscription interesting alternative nonmonotonic
dls particular supports defeasible inheritance natural way study dls
extended circumscription different language restrictions different
constraints sets minimized fixed varying predicates pinpoint exact
computational complexity reasoning dls ranging alc alcio alcqo
minimized fixed predicates include concept names role names
reasoning complete nexpnp becomes complete npnexp number
minimized fixed predicates bounded constant roles minimized
fixed complexity ranges nexpnp undecidability

introduction
early knowledge representation kr formalisms semantic networks frames
included wealth features order provide much expressive power possible
quillian minsky particular formalisms usually admitted structured representation classes objects similar modern description logics dls
mechanisms defeasible inheritance default rules features nowadays studied area nonmonotonic logics nmls kr theory developed
embracing approaches largely given favour specialized
ones due unfavourable computational properties semantics
process caused dls nmls develop two independent subfields consequently
modern description logics shiq lack expressive power represent defeasible
inheritance nonmonotonic features horrocks sattler tobies
despite due development continuous interest
integration nonmonotonic features description logics recent years advent several applications dls increased interest even briefly
discuss two first dls become popular tool formalization biomedc

ai access foundation rights reserved

fibonatti lutz wolter

ical ontologies galen rector horrocks snomed cote rothwell
palotay beckett brochu argued example rector stevens
et al important ontologies represent exceptions form
humans heart usually located left hand side body humans
situs inversus heart located right hand side body modelling
situations requires defeasible inheritance e properties transfer instances class
default explicitly overridden special cases mccarthy horty
brewka baader hollunder b second application use dls security policy languages uszok bradshaw johnson jeffers tate dalton aitken
kagal finin joshi tonti bradshaw jeffers montanari suri uszok
formalizing access control policies one must deal situation given request
neither explicitly allowed explicitly denied default decision taken
open closed policies authorizations respectively granted denied
default bonatti samarati moreover policies often formulated incrementally e start general authorizations large classes subjects objects actions
progressively refine introducing exceptions specific subclasses
clearly incarnation defeasible inheritance
applications illustrate integrating nonmonotonic features dls
worthwhile actual engineering computationally well behaved nonmonotonic dl
provides sufficient expressive power turns non trivial task particular
combinations dls nonmonotonic logics typically involve subtle interactions
two component logics easily leads undecidability appears
one optimal way circumnavigate difficulties thus many different combinations
dls nonmonotonic logics proposed literature individual
strengths limitations provide survey section however striking
gap almost existing approaches default logic autoepistemic logic
circumscription received little attention connection dls computational properties dls circumscription almost completely unknown
surprising since circumscription known one weakest forms
nonmonotonic reasoningsee work janhunen one recent surveys bonatti eiter expressiveness analysis terms
queries therefore natural idea use circumscription defining computationally
well behaved yet expressive dl nonmonotonic features
study circumscription mccarthy alternative
defining nonmonotonic dls particular define family dls circumscription enable natural modelling defeasible inheritance general
generalize standard dl knowledge bases circumscribed knowledge bases ckbs
additionally tbox representing terminological knowledge abox representing knowledge individuals equipped circumscription pattern
pattern lists predicates e concept role names minimized sense
admitted ckb extension listed predicates minimal
w r set inclusion following mccarthy minimized predicates used
abnormality predicates identify instances typical class circumscription patterns require predicates fixed minimization allow
vary freely mccarthy main feature dls family


fithe complexity circumscription dls

come built mechanism defeasible inheritance default properties
class humans first example transfer subclass humans situs
inversus exceptions specified priority mechanism well known
defeasible inheritance priority cannot modularly encoded pure default
autoepistemic logic horty workarounds explicit listing exceptions
lead serious maintainability circumscription lends naturally priorities
circumscription patterns express preferences minimized predicates terms partial ordering argued baader hollunder b
well suited ensure smooth interplay defeasible inheritance dl
subsumption thus prefer traditional prioritized circumscription
achieve decidability nonmonotonic dls usually adopt suitable restrictions
expressive power dl component non monotonic features interaction case default logic autoepistemic logic typical restriction concerns
different treatment individuals explicitly denoted constant
goes back reasoning first order default logic reiter
autoepistemic logic moore involve tricky technical issues related
denotation individuals make reasoning decidable dls default logic default rules applied individuals denoted constants occur explicitly
knowledge base baader hollunder unnamed individuals
consequence named unnamed individuals treated uniformly approaches
autoepistemic logic donini lenzerini nardi nutt schaerf donini
nardi rosati alternative solution restrict domain fixed denumerable set constants overcomes different treatment named
unnamed individuals since individuals named flipside ad hoc encodings
required domain finite unique name assumption enforced e
different constants allowed denote individual respect dls
circumscription pose difficulty named individuals treated exactly
way unnamed ones without assumptions domain
time able base nonmonotonic dls rather expressive dl components
alcio alcqo without losing decidability however cannot without
restrictions allow fix minimize concept names circumscription
require role names vary
main contribution detailed analysis computational properties
reasoning ckbs expressive dls alcio alcqo instance
checking satisfiability subsumption decidable concept circumscribed kbs
concept names role names minimized fixed precisely
prove reasoning nexpnp complete lower bound applies
already concept circumscribed kbs alc empty preference relation without
fixed concept names empty tbox empty abox acyclic tbox addition
constant bound imposed number minimized fixed concept
names complexity drops npnexp
situation completely different role names minimized fixed first
complexity reasoning ckbs formulated alc single fixed role name empty
tbox empty preference relation minimized role names turns outside
analytic hierarchy thus highly undecidable shown reduction


fibonatti lutz wolter

name

syntax
r

inverse role
nominal
negation
conjunction
disjunction
least restriction
restriction


c
c ud
c td
n r c
n r c

semantics
ri e e ri
ai
c
c di
c di
e c e ri n
e c e ri n

figure syntax semantics alcqio

satisfiability monadic second order logic mso binary predicates arbitrary
e necessarily tree shaped structures reduction apply ckbs
role names minimized fixed surprisingly case
reasoning empty tboxes becomes decidable nexpnp complete dls
alc alcqo alci extensions undecidable
logics however adding acyclic tboxes leads undecidability reader
table summarising complexity section
interesting note somewhat unusual perspective
nmls first arity predicates impact decidability fixing concept names
unary predicates impair decidability whereas fixing single role name binary
predicate leads strong undecidability second number predicates
minimized fixed bounded vs unbounded affects computational complexity
reasoning although note passing similar effect observed propositional
logic circumscription best knowledge never explicitly
noted
organized follows next section introduce syntax semantics
reasoning circumscribed kbs provide examples section
provides basic polynomial simulation fixed concepts means
minimized concepts polynomial reduction reasoning general tboxes reasoning acyclic tboxes polynomial reduction simultaneous satisfiability
multiple ckbs standard satisfiability section proves decidability complexity concept circumscribed knowledge bases fixed minimized roles
considered sections respectively section discusses related work section
concludes summarizing main pointing interesting
directions improve readability many proof details deferred
appendix extended version article bonatti lutz wolter


description logics circumscription
dls concepts inductively defined help set constructors starting
set nc concept names set nr role names possibly set ni individual


fithe complexity circumscription dls

names countably infinite use term predicates refer elements nc nr
concepts expressive dl alcqio formed constructors shown
figure
inverse role constructor role constructor whereas remaining six
constructors concept constructors figure throughout use
denote cardinality set b denote individual names r denote
roles e role names inverses thereof b denote concept names c
denote possibly complex concepts usual use abbreviation arbitrary
fixed propositional tautology usual boolean abbreviations
r c existential restriction r c r c universal restriction r c
concerned alcqio several
fragments basic fragment allows negation conjunction disjunction
universal existential restrictions called alc availability additional
constructors indicated concatenation corresponding letter q stands number restrictions stands inverse roles nominals explains name
alcqio allows us refer fragments alcio alcqo alcqi
semantics alcqio concepts defined terms interpretation

domain non empty set individuals interpretation function maps concept name nc subset ai role name r nr
binary relation ri individual name ni individual ai
extension inverse roles arbitrary concepts inductively defined shown
third column figure interpretation called model concept c c
model c say c satisfied
general tbox finite set concept implications cis c v c

concepts usual use c abbreviation c v v c abox
finite set concept assertions c role assertions r b b individual
names r role name c concept interpretation satisfies ci c v
c di ii assertion c ai c iii assertion r b ai bi ri
model tbox satisfies implications model abox
satisfies assertions
important class tboxes acyclic tboxes call tbox acyclic set

concept definitions c concept name following two conditions
hold
concept name occurs left hand side definition

relation defined setting b iff c b occurs c
well founded
reason consider alcqio finite model
property e satisfiable concepts satisfiable finite proofs
complexity upper bounds assume finite model property therefore work alcqio investigating circumscription description logics without finite model property remains interesting
open



fibonatti lutz wolter

circumscription varying predicates partial priority ordering
circumscription logical suitable modelling normally typically
holds thus admits modeling defeasible inheritance mccarthy lifschitz
idea define standard first order language domain knowledge
called abnormality predicates identify instances class violate normal
typical properties class capture intuition abnormality exceptional
inference set resulting theory classical logic
rather restricted extension abnormality predicates
minimal respect set inclusion intuitively means reasoning
normal possible since classical
given knowledge base classical first order inferences valid circumscription
additional inferences may become possible
since description logics fragments first order logic circumscription readily
applied alc syntax assert mammals normally inhabitate land
whales live land
mammal v habitat land abmammal
whale v mammal u habitat land
upper inclusion states mammal inhabitating land abnormal mammal
thus satisfying abnormality predicate abmammal applying circumscription
tbox thus consider extension abmammal minimal
however one way defining preferred nonminimized predicate treated two different ways minimization may
fix extension let vary freely
intuitively fixed predicates retain classical semantics varying predicates may
affected minimization concrete example consider tbox
assume non minimized predicates fixed derive following
subsumptions
whale v abmammal


abmammal mammal u habitat land
whale v abmammal abmammal w mammal u habitat land classical consequences
tbox minimization abmammal adds inclusion abmammal v mammal u
habitat land
analyze fixed predicates suppose explicitly introduce concrete
mammal whale adding abox assertion
mammal u whale flipper
might expect derive habitat land flipper actually
case see observe classical model knowledge base falsifies
habitat land flipper extension fixed predicates habitat land
affected minimization habitat land flipper must still false minimization
argument applied negation habitat land flipper
thus derivable seen sentence uses fixed


fithe complexity circumscription dls

predicates consequence circumscribed knowledge base
classical consequence knowledge base
assume let role habitat concept name land vary freely fix
mammal whale view concept inclusion mammal original tbox
setup may interpreted expressing unlikely mammal
live land willing modify extension habitat land order avoid
abnormality obtain additional consequence namely

whale abmammal

see indeed consequence note minimization make
land non empty ii mammal whale ensure
abmammal linking via habitat generated instance land intuitively
equality seen reflecting unlikeliness abnormal mammal
abnormal reason reason captured knowledge
base whale
let us return assertion mammal u whale flipper applying classical
reasoning derive whale w mammal u habitat land e whales
mammals live land thus derive expected conclusion habitat land flipper summary turning habitat land varying
predicates obtained natural modelling habitat attribute
mammals forced default value
driving example might consider whales abnormal degree
believe exist unless evidence
additionally let whale vary freely still derived
additionally obtain consequence


whale abmammal
use abox add evidence whales exist e g assertion
whale mobydick expected change


whale abmammal mobydick
evidence existence another anonymous whale could generated adding
abox assertion male mobydick tbox statement
whale v mother whale u male
mother male varying freely knowledge base classically entails exist
two whales satisfying male male respectively former denoted mobydick
latter denoted abox individual corresponds first order
constant minimization whale contains exactly two individuals
general appropriate combination fixed varying predicates depends
application therefore adhere standard circumscription give users freedom
choose predicates minimized fixed varying
indeed reason let land vary ensure made non empty
minimization



fibonatti lutz wolter

another example consider sentences humans heart usually located
left hand side body humans situs inversus heart located
right hand side body axiomatized follows
human v heart position left abhuman
situs inversus v heart position right
heart position left u heart position right v
predicate abhuman represents abnormal humans minimized humans
situs inversus restricted individuals explicitly declared
property analogy previous example roles specifying heart
position class exceptional individuals situs inversus allowed vary
human fixed retain classical semantics absence
axioms abhuman situs inversus empty minimized
additional axiom friend situs inversus john turns abhuman situs inversus
singleton set containing anonymous individual though may
john example nonclassical consequence consider
human u situs inversus v heart position left
humans default heart position exception
explicitly declared situs inversus
extensively argued mccarthy horty brewka baader
hollunder b interplay subsumption abnormality predicates addressed nonmonotonic dls consider example following
tbox
user
staff
staff
blacklistedstaff

v
v
v
v

hasaccessto confidentialfile abuser
user
hasaccessto confidentialfile abstaff
staff u hasaccessto confidentialfile

get normal possible first attempt could minimize
two abnormality predicates abuser abstaff parallel assume hasaccessto
varying user staff blacklistedstaff fixed parallel
minimization staff members may may access confidential files
equal preference first case abnormal users second case
abnormal staff however one may argue first option preferred since
staff v user way round normality information staff
specific normality information users higher priority effects well known propositional first order case indeed circumscription
soon introduction extended priorities address issues specificity
mccarthy
formalism users specify priorities minimized predicates typically
priorities reflect subsumption hierarchy computed w r class
since subsumption hierarchy general partial order priorities
minimized predicates may form partial order analogous partially


fithe complexity circumscription dls

ordering priorities default rules proposed brewka general
standard prioritized circumscription assumes total ordering mccarthy
lifschitz special case nested circumscription lifschitz
circumscribed knowledge bases
define dls circumscription start introducing circumscription patterns
describe individual predicates treated minimization
definition circumscription pattern cp circumscription pattern tuple cp
form f v strict partial order f v
mutually disjoint subsets nc nr minimized fixed varying predicates
respectively denote reflexive closure define preference relation cp
interpretations setting cp j iff following conditions hold
j ni ai aj
p f pi pj
p pi pj exists q q p q q j
exists p pi pj q q p q q j
f nc e minimized fixed predicates concepts call
f v concept circumscription pattern

use term concept circumscription concept circumscription patterns admitted circumscription patterns define circumscribed dl knowledge
bases
definition circumscribed kb circumscribed knowledge base ckb expression circcp tbox abox cp f v circumscription pattern f v partition predicates used interpretation
model circcp model exists model
cp
ckb circcp called concept circumscribed kb cp concept circumscription pattern

note partially ordered circumscription becomes standard parallel circumscription
empty relation used
main reasoning tasks non circumscribed kbs satisfiability concepts
w r kbs subsumption w r kbs instance checking w r kbs reasoning
tasks fundamental circumscribed kbs well provide precise definitions
tasks throughout following section dl denotes set dls
introduced previous section e alc alci alco alcq alcqi alcio
alcqo alcqio
definition reasoning tasks


fibonatti lutz wolter

concept c satisfiable w r ckb circcp model circcp
satisfies c let l dl satisfiability w r ckbs l defined
follows given concept c l ckb circcp l decide whether c
satisfiable w r circcp
concept c subsumed concept w r ckb circcp symbols
circcp c v c di circcp let l dl
subsumption w r ckbs l defined follows given concepts c
l ckb circcp l decide whether circcp c v
individual name instance concept c w r ckb circcp
symbols circcp c ai c circcp let
l dl instance w r ckbs l defined follows given
concept c l individual name ckb circcp l decide whether
circcp c

reasoning polynomially reduced one another first c satisfiable
w r circcp iff circcp c v circcp c v iff c u
satisfiable w r circcp second c satisfiable w r circcp iff
circcp c individual name appearing conversely
circcp c iff auc satisfiable w r circcp
concept name occurring cp obtained cp adding
leaving use satisfiability w r ckbs basic
reasoning

basic reductions
present three basic reductions reasoning circumscribed knowledge
bases interesting right additionally useful establishing
main later precisely replay well known reduction
fixed predicates minimized predicates context dls reduce reasoning w r ckbs
general tboxes reasoning w r ckbs acyclic tboxes
certain conditions simultaneous satisfiability w r collection ckbs reducible
satisfiability w r single ckb
fixed minimized concepts
circumscription folklore fixed predicates simulated terms minimized
predicates see e g de kleer case dls simulation possible
concept names see let c concept circcp circumscribed
kb cp f v f ak f nc define pattern
cp f f v
ak k k concept names
occur c f v

ai k


fithe complexity circumscription dls

difficult see c satisfiable w r circcp iff satisfiable w r
circcp thus get following
lemma let l dl satisfiability w r concept circumscribed kbs l
polynomially reduced satisfiability w r concept circumscribed kbs l
fixed concept names
contrast concept names fixed role names cannot reduced minimized role names
since boolean operators roles available standard dls alcqio
proof given section cases reasoning minimized
role names decidable whereas corresponding reasoning task ckbs fixed role
names undecidable
reduction clearly relies tboxes however sometimes
work circumscribed kbs tbox empty following lemma proved
appendix shows ckbs alc without fixed role names empty tbox
one simulate fixed concept names minimized concept names without introducing
tbox proof may viewed much careful version proof
lemma adapted yield analogous logics dl
lemma alc satisfiability w r concept circumscribed kbs empty tbox
without fixed roles polynomially reduced satisfiability w r concept circumscribed
kbs empty tbox without fixed predicates
acyclic general tboxes
many dls satisfiability w r non circumscribed kbs general tboxes harder
satisfiability w r non circumscribed kbs acyclic tboxes case alc
alci alcq alcqo latter pspace complete baader mcguiness
nardi patel schneider baader milicic lutz sattler wolter b ding
wu former exptime complete baader et al
dls considered satisfiability exptime hard already acyclic
tboxes alcio extensions areces blackburn marx
circumscribed kbs difference computational complexity acyclic
general tboxes
let c concept circcp ckb cp f v may assume

without loss generality c concept c see observe

axioms c v equivalent c define




acyclic tbox c b u b b b b u
concept role names occurring f v c
circumscription pattern cp f v b v
v b u
ad b conjunctively c thus interested circcp
b ai thus c since otherwise
turn instance b instance b making instance b


fibonatti lutz wolter

linking via role u instance thus obtaining preferred model w r
cp basis proof following lemma given appendix
lemma c satisfiable w r circcp iff c ub satisfiable w r circcp
thus obtained following
proposition let l dl satisfiability w r concept circumscribed kbs l
polynomially reduced satisfiability w r concept circumscribed kbs l acyclic
tboxes without changing abox
shows satisfiability w r ckbs acyclic tboxes complexity
satisfiability w r ckbs general tboxes many cases considered
even true ckbs empty tboxes c f section however identify
cases ckbs non empty tboxes higher complexity see theorems
thus general reduction one underlying proposition cannot exist case
empty tboxes
simultaneous satisfiability
applications often necessary merge tboxes aboxes whole knowledge bases
taking union certain conditions reasoning w r union
several circumscribed kbs reduced reasoning w r component ckbs
concept c simultaneously satisfiable w r ckbs circcp circcpk tk ak
exists interpretation model ckbs satisfies c
following lemma says simultaneous satisfiability polynomially reduced
satisfiability w r single ckb two ckbs share role name
proof idea case k follows given circcp circcp
first take union two ckbs replacing circcp concept name
used circcp fresh concept name introduce
additional concept name p make sure p satisfied abox
individual whenever point model interpretation
disagrees look model p satisfied abox intuitively
additional concept name p satisfies purpose decoupling important
e g case minimized circcp circcp details
given appendix
lemma l dl simultaneous satisfiability w r concept circumscribed kbs
circcp circcpk tk ak circcpi ti ai circcpj tj aj share
role names j k reduced polynomial time satisfiability w r single
concept circumscribed kbs

complexity reasoning concept circumscribed kbs
main contributions consist showing many cases reasoning
circumscribed knowledge bases decidable ii performing detailed analysis


fithe complexity circumscription dls

computational complexity decidable cases section
satisfiability w r concept circumscribed kbs nexpnp complete dl alc
extensions alcio alcqo npnexp complete number
fixed minimized concept names bounded constant first present proofs
upper bounds establish matching lower bounds
upper bounds
start general case bound number fixed
minimized predicates
general case
prepare upper bound proof showing concept satisfiable w r
concept circumscribed kb satisfiable model bounded size use c
denote length concept c e
p number occurrences symbols needed
write c size tbox cvdt c size abox
sum sizes assertions size role assertion
size concept assertions c c
lemma let c concept circcp concept circumscribed kb n c
c satisfiable w r circcp following holds
c formulated alcio c satisfied model
circcp n
ii c formulated alcqo maximal parameter occurring number restriction c c satisfied model
circcp n n
proof let cp c lemma may assume every
assertion c expressed implication v c every assertion r b
expressed v r b denote cl c smallest set concepts contains
subconcepts c subconcepts concepts appearing closed single
negations e cl c start cl c
let common model c circcp let c define equivalence relation setting iff
c cl c c c cl c c
use denote equivalence class w r relation pick
equivalence class exactly one member denote resulting subset
first prove point thus assume c formulated alcio
define interpretation j follows
j



aj

ai

rj

ri

aj

ai


fibonatti lutz wolter

following claim easily proved induction structure c
claim c cl c c iff c j element
j
thus j model satisfying c j model circcp thus
remains model j j cp j assume contrary
j define interpretation follows




ai







daj

r









ai



rj

ai

matter routine following




claim concepts c cl c c iff c j
element j




follows model observe ai ai iff aj aj concept
name therefore since cp concept circumscription pattern
cp follows j cp j derived contradiction conclude j
model circcp thus done since size j bounded n
point ii pick concept k r c cl c
k r c k elements c ri pick
concept k r c cl c k r c k elements
c ri denote collection elements picked take
element ds ds define interpretation j
j



aj

ai

rj

ri
ds ri

aj

ai

following claim easily proved
claim c cl c following
j c j iff c j
ii c iff c j element j
thus j model satisfying c j model circcp
thus remains model j j cp j assume
contrary j define interpretation end take


fithe complexity circumscription dls

j dp dp define follows












aj j dp aj

ri



rj j dp rj

ai



ai





matter routine


claim concepts c cl c c j iff c j


c j iff dp c j element dp






follows model observe ai ai iff aj aj concept
name therefore since cp concept circumscription pattern
cp follows j cp j derived contradiction conclude
j model circcp thus done since size j clearly bounded
n n

interesting note proof lemma go role names
minimized fixed cannot overcome proved undecidability
presented sections
bounded model property established prove decidability
reasoning concept circumscribed kbs formulated alcio alcqo
precisely lemma suggests non deterministic decision procedure satisfiability w r
concept circumscription patterns simply guess interpretation bounded size
check whether model turns procedure shows containment satisfiability complexity class nexpnp contains solved
non deterministic exponentially time bounded turing machine access
np oracle known nexp nexpnp expspace
theorem alcio alcqo nexpnp decide whether concept
satisfiable w r concept circumscribed kb circcp
proof hard see exists np takes input
ckb circcp finite interpretation checks whether model
circcp first verifies polynomial time whether model
answering yes case otherwise guesses interpretation
j domain interprets individual names way
checks whether j model ii j cp answers yes
checks succeed otherwise clearly checking whether j cp done
time polynomial w r size j
np may used oracle nexp deciding
satisfiability concept c w r ckb circcp lemma suffices guess
interpretation size k k c use np
check whether model circcp proves concept satisfiability
nexpnp

bound k clearly dominates two bounds given parts ii lemma



fibonatti lutz wolter

reductions given section theorem yields co nexpnp upper bounds
subsumption instance section upper
bounds tight
bounded number minimized fixed predicates
since nexpnp rather large complexity class natural question whether
impose restrictions concept circumscription reasoning becomes simpler
following identify case considering concept circumscribed kbs
number minimized fixed concept names bounded constant case
complexity satisfiability w r concept circumscribed kbs drops npnexp readers
uninitiated oracle complexity classes recall nexp npnexp nexpnp
npnexp believed much less powerful nexpnp see example work
eiter et al
prove npnexp upper bound first introduce counting formulas common
generalization tboxes aboxes
definition counting formula counting formula boolean combination
concept implications abox assertions c cardinality assertions c n c
concept n non negative integer use denote boolean
operators counting formulas interpretation satisfies cardinality assertion c n
c n satisfaction relation counting formulas
defined obvious way

following assume integers occurring cardinality assertions coded
binary npnexp devised use satisfiability
non circumscribed counting formulas oracle therefore first determine
computational complexity latter follows tobies
alc satisfiability counting formulas nexp hard matching upper bound
dls alcio alcqo obtained facts polynomial
translation counting formulas formulated languages c two variable
fragment first order logic extended counting quantifiers gradel otto rosen
pacholski szwast tendera ii satisfiability c nexp even
numbers counting quantifiers coded binary pratt hartmann
theorem tobies pratt alc alcio alcqo satisfiability counting
formulas nexp complete even numbers number restrictions coded binary
establish improved upper bound
theorem let c constant alcio alcqo npnexp decide satisfiability w r concept circumscribed kbs circcp cp f v
c f c



fithe complexity circumscription dls

proof assume want decide satisfiability concept c w r ckb
circcp cp f v c f c lemma
may assume f may increase constant c appropriately
may assume without loss generality cardinality exactly c thus let
ac lemma c satisfiable w r circcp iff exists
model c circcp size k k c consider
concept
cs
au


u



u

ac

c constant number c concepts constant well clearly sets csi
form partition domain model introduce concept
name b role name r fresh concept name b fresh role name r
respectively concept c denote c replacing c concept name
b role name r b r respectively primed versions
defined analogously denote n set individual names c
nexp oracle going use checks whether counting formula
satisfiable npnexp follows use c
abbreviation counting formula c v v c
guess
sequence ns numbers ns k coded binary
individual name n exactly one set sa
subset e n n
calling oracle check whether counting formula satisfiable
conjunction
c
cs ns
csa n
v b b e v b b n e
calling oracle check whether counting formula satisfiable
conjunction

cs ns note use unprimed versions
csa individual name n use unprimed versions
v b b e v b b n e

v


bm ba



b b

fibonatti lutz wolter

finally










b b

bm ba

states c satisfiable model circcp
satisfiable satisfiable
fact c fixed hard verify npnexp
remains correctness completeness
suppose exists model circcp satisfying c
model size bounded k let guess
numbers ns csi
sets sa ai csia
set e b b ai bi b n
clearly satisfied remains unsatisfiable suppose
exists model j satisfying definitions may assume
j
ai aj
ai aj individual names
moreover unprimed role names occur unprimed concept names
may assume interpretation unprimed concept role
names j coincide thus j model circcp satisfying c
define model j domain j setting


aj aj individual names


rj r j role names r


aj j concept names
conjunct item definition j model
items definition j cp j derived contradiction
conversely suppose says exists model circcp satisfying c take model conjunct item model
satisfying c follows unsatisfiability model
circcp




fithe complexity circumscription dls

corollary obtain co npnexp upper bounds subsumption instance similar drop complexity occurs propositional logic satisfiability w r
circumscribed theories complete npnp difficult see bounding
minimized fixed predicates allows us pnp
lower bounds
prove lower complexity bounds reasoning concept circumscribed kbs
match upper bounds given section
general case
section start general case number fixed minimized
predicates bounded aim establish two nexpnp lower bounds
match upper bound established theorem first bound satisfiability w r
concept circumscribed kbs formulated alc empty tbox nonempty abox second bound satisfiability w r concept circumscribed kbs
formulated alc assumes acyclic tbox empty abox reductions work
already case empty preference relation without fixed predicates note
considering satisfiability concept c w r concept circumscribed kb circcp
empty interesting seen c satisfiable w r
circcp iff c satisfiable without reference kb c concept
obtained c replacing minimized concept names
proof first reduction succinct version cocert col nexpnp complete eiter gottlob mannila satisfiability
w r concept circumscribed kbs empty tbox let us first introduce regular nonsuccinct version co cert col
instance size n undirected graph g vertices n every
edge labelled disjunction two literals boolean variables vi j j n
yes instance size n instance g size n truth value assignment
boolean variables graph g obtained g including edges
whose label evaluates true colorable
shown stewart co cert col complete npnp obtain
complete nexpnp eiter et al use complexity upgrade technique encoding
input succinct form boolean circuits complexity raised one exponential
nexpnp eiter et al precisely succinct version co cert cols
co cert col obtained representing input graph g nodes n
n boolean circuits n inputs one output boolean circuits



named ce cs cs cj j n circuits n inputs
bits binary representation two nodes graph purpose
circuits follows
circuit ce outputs edge two input nodes otherwise


edge input nodes circuit cs outputs first literal

disjunction labelling edge positive otherwise circuit cs


fibonatti lutz wolter

second literal edge input nodes output
arbitrary


edge input nodes circuits cj compute labelling
vk k vk k edge input nodes generating numbers k k

circuit cj outputs j th bit ki edge input nodes
output arbitrary
reduce co cert cols satisfiability w r concept circumscribed kbs formulated alc whose tbox preference relation empty remains
apply lemma eliminate fixed concept names note construction
proof lemma leaves preference relation untouched let






g n ce cs cs cj j n
succinct representation input graph n nodes construct abox
ag c u root circumscription pattern cpg concept cg g
yes instance co cert cols iff cg satisfiable w r circcpg ag
concept c used ag conjunction whose presentation split two parts
intuitively purpose first group conjuncts fix truth assignment
variables vi j j n construct isomorphic image graph g
obtained g including edges whose label evaluates true
purpose second group make sure g colorable
formulating c use several binary counters counting modulo n
number nodes input graph main counters x use concept names
x xn yn bits respectively additionally introduce concept


names k kn serve four additional counters k k
first group conjuncts c found figure following abbreviations
used
ri c denotes n fold nesting r r c
r k x abbreviation

u

j n



xj r kj u xj r kj

similarly r k
abbreviations wc c boolean circuit explained later
intuition behind figure follows lines build binary tree depth
n whose edges labeled role name r n leaves tree instances
concept name leaf labeled possible values counters x
since minimize leaf via circumscription pattern cpg concept name
denotes precisely leaves tree due use counters x leaves
distinct
leaves tree established satisfy number purposes start
leaf counter values x j corresponds variable vi j co certcols determines truth value variable via truth falsity concept


fithe complexity circumscription dls

ri r xi u r xi
j

r xi r xi u xi r xi
r
r

n j

n

r yi u r yi

yi r yi u yi r yi

n



n j n



n



j n



n

r leaf



r n wce u wc u wc







r n wc u u wc
j

j n

r n var leaffix u var k x u var k
n

r var leaffix u var k





j

x u var k









n

p r var leaf



n

p r var leaf



r n tr var tr



n

r tr var tr
n

r tr var tr
n




r tr var tr



n



r elim e tr tr
figure first group conjuncts c

name tr thus leaves jointly describe truth assignment instance g co certcols second purpose leaves represent potential edges g
additionally representing variable leaf x j corresponds
potential edge nodes j explain properly must first
discuss abbreviations wc used lines figure
concept wc c boolean circuit n inputs converting c
concept uses constructors u following condition satisfied
instance wc output c upon input b b n b truth
value concept names x xn yn described b b n
truth value concept name described b introducing one
auxiliary concept name every inner gate c translation done
size wc linear size c following concept names used output
wce uses concept name e output
wc uses concept name si output




wc uses concept name kj

output j n

j



fibonatti lutz wolter

r n col leaffix u col leaffix
n

r col x x u col
n

r col x u col





n



n

p r col leaf



r n r b g



r r u b u r u g u b u g



r n elim u col r u col r clash



r n elim u col g u col g clash



r n elim u col b u col b clash



p r col leaf

n

figure second group conjuncts c
lines ensure concepts propagated leaves next aim
ensure leaf represents potential edge j connected via role var
leaf represents variable first disjunct label j analogously
role var variable second disjunct edge label replaced
concept name leaffix leaf lines lines would apparently
encode properties however careful mentioned replacement
would interact minimization leaf fix resort trick
use concept name leaffix instead leaf way may may reach
instance leaf force concept name p true root
tree lines use cg rule p true finally
fix leaffix via cpg eliminate interaction minimization leaf
remaining lines ensure leaf instance elim iff potential
edge represents present graph g induced truth assignment
described leaves
second group conjuncts c found figure stands
concept u u yn already mentioned purpose conjuncts
ensure graph g described leaves coloring
strategy ensuring follows use n leaves store colors
nodes e leaf x stores color node lines
unique coloring lines ensure leaf viewed
edge connected via role col leaf stores color first node
edge analogously role col second node edge leaffix
p role lines guarantee concept name clash
identifies coloring leaf clash represents edge exists
g dropped g endpoints color idea
clash minimized r g b vary additional concept
names fixed corresponds universal quantification possible colorings


fithe complexity circumscription dls

set cg root u p u r n clash recall ag c u root following
lemma proved appendix
lemma g yes instance co certcols iff cg satisfiable respect
circcpg ag cpg f v root leaf clash
f leaffix tr x xn yn
v set remaining predicates ag
since size ag polynomial n get following applying lemma
theorem alc satisfiability w r concept circumscribed kbs nexpnp hard even
tbox preference relation empty fixed predicates
rather straightforward establish announced second nexpnp lower bound
reduction satisfiability w r concept circumscribed kbs special case formulated
theorem details given appendix
corollary alc satisfiability w r concept circumscribed kbs nexpnp hard
even tbox acyclic abox preference relations empty
fixed predicates
corresponding lower bounds subsumption instance follow
reduction given section
bounded number minimized fixed predicates
establish matching lower bound theorem showing alc satisfiability w r concept circumscribed kbs npnexp hard even constant number
predicates allowed minimized fixed contrast previous section
ignore case empty tboxes directly establish lower bound case
non empty tboxes empty aboxes allows us demonstrate usefulness
lemma separating different parts lower bound proof main reduction
previous section two parts reduction shown figure truly
independent forced us implement technical trick involves concept
names leaffix p lemma contrast achieve true separation
concerns general though conjecture lower bound proved section
established case empty tboxes adapting mentioned technical trick
leave interested reader
recall non deterministic k tape turing machine described tuple
q q qacc qrej
q finite set states finite alphabet q q starting state
q k q k l r k
transition relation qacc qrej q accepting rejecting states purposes
oracle turing machine tape turing machine additionally equipped



fibonatti lutz wolter

tape turing machine oracle whose alphabet identical
query state q
two answer states qyes qno
second tape called oracle tape enters q oracle determines
next state content oracle tape contained language accepted
oracle next state qyes otherwise qno transition head
moved symbols written state q cannot occur left component
tuple ms transition relation
let q q qacc qrej q qyes qno oracle turing machine
following holds
solves npnexp complete
time consumption bounded polynomial p oracle calls contribute single clock tick
q bounded q n q
time consumption q q qacc
rej
polynomial

assume without loss generality never attempt move left
left position tape neither right right position npnexp hardness proof uses reduction word thus let w input
length n let p n q p n construct three tboxes
tw tw tw circumscription patterns cp cp cp concept cw
accepts w iff cw simultaneously satisfiable w r circcp tw circcp tw
circcp tw lemma yields reduction non simultaneous satisfiability w r
concept circumscribed ckbs intuitively purpose first tbox tw impose
basic structure domain tw describes computations tw describes
computations use general tboxes rather acyclic ones since lemma
done without loss generality
tbox tw shown figure previous reduction use concept
names x xm ym implement two binary counters counting

modulo use abbreviations previous reduction additionally
r x states value counter x xm incremented going
r successors e


xj xk r xk u xk r xk


u
u

k

k

u


j k

j k



xj xk r xk u xk r xk

purpose lines ensure possible value j
counters x least one instance nexp satisfies x j


minimize nexp thus enforce nexp exactly elements


elements interconnected via roles r right u form grid later use grid encode computations oracle machine observe


fithe complexity circumscription dls

v aux nexp


nexp v x




r nexp u

u nexp



nexp v r u r x



nexp v u x x u u



v
v

u aux u r
u r u r









j



j

v aux np


figure tbox tw

since working simultaneous satisfiability minimization nexp
interact anything going put tboxes tw tw
minimize concept name thus lines guarantee
exactly instances identified concept names r rm
makes call oracle th step call stored
unique instance u ri e instance satisfy concept name rej
rejected input falsify otherwise finally minimize np thus
line guarantees exactly one instance np instance used
represent computation summing circumscription pattern tw
cp nexp np v
v containing remaining predicates used tw
purpose tw describe computations use following concept
names
j k introduce concept name sai j k intuitively
sai j k expresses symbol j th cell k th tape th step
ms computation start numbering tape cells steps
q q qiq concept name expressing state q
th step computation
q q j k hji k concept name expressing
k th head cell j th step computation
q q j k l r concept names aiq ai j k

k

serve markers precisely aq means time point
executed transition switches state q similarly ai j k
describes symbol

k
written transition tape k describes move tape k
details tw given figure one copy concept inclusions figure
needed every j j every k assume w


fibonatti lutz wolter

n

np v q q u h u sa
u sa n
u sb
u u sb

n





np v h u sb
u u sb



np v

u

j

b qq q

sai j u sb

np v
np v
np v
np v
np v

ua
ua

qq


ai k
l
k
ar


q

j k




aiq u ai j
u ai j
u ai

u
b





q b q b

sai j k

k
hj





j



k
hj

j

j k
j j
sai j k u hji k
sa

u
u



qi
q

b b

sai j k u sbi j k u

np v hji k u hji k







np v

u qiq u hji u hji


u

q q q q q

qiq u qiq

j j






np v resi u ri u resi u ri



np v qiq u resi rej qi
qno



np v

qiq

u resi rej

qi
qyes

np v qiq u hji k hji k
np v

u








j k

qiq u sai j k sa





figure tbox tw
use b denote shared blank symbol lines describe
behaviour turing machine usual way transitions follow transition table
computation starts initial configuration etc line ensures instance
np reach unique instance u ri via role resi lines
deal transitions query state looking oracle
call corresponding instance finally lines ensure head
position tape symbols change querying oracle circumscription
pattern tw simply cp v v set predicates used tw
purpose tw describe computations oracle turing machine note
describe single computation polynomially many since may visit state q computations
represented nexp grid different computations untangled use
different concept names computation use counter x xm count


fithe complexity circumscription dls

configurations counter ym count tape cells configuration
moreover use following concept names
concept name sai sai satisfied instance
nexp x xm value j ym value k th
computation j th step symbol k th cell
q q concept name qiq purpose concept name
two fold first represents current state th computation
second indicates head position th computation
q q l r concept name aiq marker
meaning marker aiq reach current configuration
switched q written moved head direction additionally marker
indicates head position previous configuration
additional concept name nh nohead helps us enforce
single head position
details tw shown figure require one copy line every
purpose lines regenerate grid structure nexp
roles r und u necessary since roles r u used tw use
lemma tboxes cannot share role names lines ensure every
instance nexp reaches unique instance np via role tonp
unique instance u ri via role res lines describe
computation straightforward way precisely lines set
initial configuration reading contents ms oracle tape instance np
lines implement transitions lines enforce unique label
tape unique state unique head position finally line ensures
th computation rejecting rej true instance u ri
note non deterministic machine may one computation
storing rej u ri need know computations rejecting
deal issue rej minimized predicates varying exists
accepting computation th input represent computation
nexp make rej false instance u ri hence rej holds u ri
iff exists accepting computation note cannot fix concept names
x xm ym minimizing rej since would get unbounded number
fixed concept names means elements nexp change position
minimization roles r u harmful since tw
lines ensure structure nexpi r u isomorphic
grid rest tw ensures elements nexp encode computations
thus use circumscription pattern cp rej v v contains
predicates used tw except rej
proof following lemma left reader formulation union
qiqacc imposes least one state computation accepting


fibonatti lutz wolter





nexp v x r nexp u u nexp










nexp v r u r x u u x x u u



nexp v res u ri u res u ri



nexp v tonp np u tonp np



nexp v

uu



j



x u j u tonp sai j sai




nexp v x u sb



qiq




nexp v x u
nexp v

uu



sai u qiq

qq



q q

r aiq





nexp v aiq r sai u u qiq



aiq l sai
u aiq l



nexp v
nexp v

nexp v
nexp v



q u r
u u u u
q u nh

nh q u u nh

nexp v
nexp v

qiq

qq


q

b b
qq




rej


b





qiq u qiq

q q q q q




q

qq

nexp v qiq









q








res rej



figure tbox tw
lemma accepts w iff cw np u

tq




qacc

simultaneously satisfiable w r

circcp tw circcp tw circcp tw

remains apply lemmas obtain following
theorem alc satisfiability w r concept circumscribed ckbs npnexp hard
even tbox acyclic abox preference relations empty
fixed predicates number minimized predicates bounded constant
already mentioned conjecture proved empty tboxes
non empty aboxes corresponding lower bounds subsumption instance
follow reduction given section


fithe complexity circumscription dls

circumscription fixed roles
preceeding sections analyzed computational complexity reasoning
w r concept circumscribed kbs particular established decidability current
section extend concept circumscribed kbs call role fixing ckbs differ
former allowing role names fixed minimized interestingly
seemingly harmless modification reasoning becomes highly undecidable
start defining ckbs studied section
definition ckb circcp cp f v called role fixing contains role names

pinpoint exact complexity reasoning role fixing ckbs present reduction
logical consequence monadic second order logic binary relation symbols
unrestricted structures trees instance w r role fixing ckbs
formulated alc follows latter harder definable
second order arithmetic thus outside analytical hierarchy analogous
satisfiability subsumption follow reductions given section reduction
applies already case tbox preference relation empty
finite set r binary relation symbols denote mso r set formulas
constructed countably infinite set p p variables sets countable infinite
set x x individual variables binary relation symbols r boolean
connectives first order quantification monadic second order quantification
hard see reasoning role fixing ckbs corresponds reasoning tiny fragment mso r specifically consider standard translation alc concepts c
fo formulas thus mso r formulas c x one free individual variable x e g
given borgida take ckb circcp cp f v v
f r translate mso r sentence




x c x x
c xa
r xa xb
cvdt

c

r b

xa individual variables
alc concept c satisfiable w r circcp mso r formula
xc x p p p
satisfiable p stands x p x x x x p x p
denotes replaced p translation easily extended case
arbitrary number concept names minimized arbitrary number concept
role names fixed varies
prove logical consequence mso r reducible instance w r role fixing ckbs thus establish surprising reasoning
skbs correspond tiny fragment mso r hard
mso r reduction indirect instead directly reducing logical consequence
mso r reduce semantic consequence modal logic exploit thomasons logical consequence mso r reduced latter see


fibonatti lutz wolter

works thomason b survey articles wolter et al
goldblatt details
first define semantic consequence modal logic framework
description logic present thomasons starting notation
let r finite set role names r frame structure f f rf f
non empty domain rf f f r r interpretation
r frame f iff f ri rf r r say concept c
valid f write f c c every interpretation f semantic
consequence modal logic defined follows let c alc concepts
roles r semantic consequence c symbols c every
r frame f f c follows f note since validity r frame f
involves quantification possible interpretations symbols contained r
relation c invariant uniform renamings atomic concepts
used later
simplicity consider mso r monadic second order logic one binary
relation symbol r straighforward extend arbitrary finite sets r
relation symbols given set role names r alc concept called alc r concept
uses role names r following theorem follows
thomason b
theorem exist effective translation mso r sentences
alc r concepts alc r concept c mso r sentences
following conditions equivalent
logical consequence mso r
c u
thus establish reduction mso r instance w r role fixing
ckbs reducing instead semantic consequence fact reduction
implemented transparent way extend alc universal role whereas
reduction alc requires number rather technical intermediate steps
reason defer alc case appendix give proof universal
role
let u role name called universal role every interpretation u
fixed interpretation ui since interpretation u fixed anyway
allow use circumscription patterns
suppose c alc r concepts establish reduction construct role fixing ckb circcp c concept c c
instance c w r circcp c noted may assume c
share concept names otherwise simply replace concept names fresh
ones let concept name occur c let cp r v
consists set concept names c v consists
concept names set u c u
b

u

bm

lemma following conditions equivalent


fithe complexity circumscription dls

c
instance u c w r circcp
proof prove point implies point assume point hold let
model circcp ai u c u let f prove
point hold f c f latter easy
witnessed interpretation former let j interpretation
f c j first note since model ai u c
b b distinguish two cases
b j b case b interpretation
j thus since concept names c j
frame obtain c j c
b j least one b j cp assume c j
ai u c j j model thus derived contradiction
assumption model circcp
prove point implies point assume point hold consider
frame f f c f let interpretation f
ai may assume b b since b occurs
ai u c u model remains
exist cp model straightforward f c


obtain exist ai u c moreover clearly



exist b b b ai u
b


u

bm

thus proved logical consequence mso r effectively reducible
instance w r role fixing ckbs formulated alc extended universal role reduction tbox preference relation empty appendix
reduction modified prove alc
without universal role
theorem logical consequence mso r effectively reducible
instance w r role fixing ckbs formulated alc even holds
tbox preference relation empty

circumscription minimized roles
unlike fixed concept names fixed role names cannot simulated minimized role
names due fact boolean operators roles available standard
dls thus theorem imply undecidability reasoning ckbs role
names allowed minimized fixed section investigate ckbs
type formal definition follows
definition ckb circcp cp f v called role minimizing f
contains role names



fibonatti lutz wolter

role minimizing ckbs behave rather differently concept circumscribed
kbs role fixing ckbs first turns reasoning role minimizing
ckbs empty tbox nexpnp complete alcqo undecidable alci
thus contrast circumscribed kbs considered far observe difference
complexity alcqo alci even alc alci second
difference obtained far nexpnp lower bound applies
ckbs formulated alc empty tbox even holds role minimizing ckbs
single role minimized predicate fixed minimized
interest shows complexity drop npnexp number
minimized predicates constant finally non empty tboxes reasoning
role minimizing ckbs becomes undecidable already alc
role minimizing ckbs empty tbox alcqo
first prove nexpnp completeness discussed dls without inverse
roles start upper bound prove first establish bounded model
property selective filtration style argument see e g blackburn et al
difference bounded model property proof given concept circumscribed kbs
build quotient model given model identifying nodes
equivalence relation construct submodel given model selecting relevant nodes
contrast forming quotient technique works empty tboxes since
tbox force us select infinitely many nodes similarly selection technique
work dls inverse role shall see inverse roles
used simulate tboxes
recall role depth rd c concept c defined nesting depth
constructors k r k r c
theorem alcqo satisfiability w r role minimizing ckbs empty tbox
nexpnp
proof let circcp role minimizing ckb cp f v let c
concept satisfiable w r circcp let maximal parameter occurring
number restrictions c set
n max rd c rd c c c n
exists model j circcp satisfying c j
let model circcp exists c fix
minimal set
every concept k r c occurs c k r c exist
least k distinct e e ri e c
every concept k r c occurs c k r c exist
least k distinct e e ri e c
clearly c next define set
setting
ai ni occurs c


fithe complexity circumscription dls

define sets di n inductively

di

ddi

set n



di

define interpretation domain follows



ai ai individual names


r v e ri n dn e e ri


v ai ai n


f ai ai


straightforward inductive argument shows model c

note change interpretation f moreover pi pi
every p together fact model cp even get

pi pi every p follows model circcp j cp
would imply j cp

note ri n n every role r define interpretation j domain
j n putting


aj ai n every concept name


rj ri every role name r
aj ai every individual name c
still j model satisfying c moreover interpretation j cp j
satisfying easily extended interpretation cp satisfying hence
interpretation exists j model circcp n derive
j
proof nexpnp upper bound exactly proof theorem
suffices replace bound k size interpretations bound

give lower bound matching upper bound theorem
theorem alc satisfiability w r role minimizing ckbs empty tbox nexpnp hard holds even one minimized role name fixed prediates
proof theorem alc nexpnp hard decide whether concept c
satisfiable w r circcp cp v contains concept names
clearly still nexpnp hard decide whether exists common model c
circcp size least thus sufficient provide polynomial reduction
satisfiability w r ckbs alc single minimized
role remaining predicates varying suppose c circcp given let
ak take
two fresh role names r r


fibonatti lutz wolter

boolean concepts c ck built fresh concept names b bk
every ci k satisfiable every ci u cj j unsatisfiable one take
example ci b u u bi u bi u bi u u bk k
let cp r v b bk r define c replacing
c every occurrence ai r ci k finally set r ci
k following
c satisfiable w r circcp model size least c
satisfiable w r circcp
let model circcp c size least define interpretation
domain extending follows take mutually distinct dk
interpret b bk r r way


cii di k


r di aii k
ai


r dk
readily checked model c circcp
conversely let model circcp c define interpretation

extending aii r ci k readily checked model c
circcp

role minimizing ckbs nonempty tbox
bounded model property proof important selection nodes
stops n iterations set n n maximum role depths
concepts abox concept c want satisfy bound selection
nodes exist tbox non empty reasoning w r
role minimizing ckbs indeed undecidable case proof reduction
tiling berger

n n

definition tiling quadruple triple p h v finite
set tile types h v horizontal vertical matching conditions
solution p mapping

n n

j j h j
j j v j



fithe complexity circumscription dls

let p h v instance tiling define tbox tp follows
v x u
v
v



u

u



tt

tt

u













h


x u

u

tt





v





v n x b u x b
n

v





w x



v x u



let cp v circumscription pattern v b consists
remaining concept role names
lemma circcp tp iff p solution
proof assume p solution define interpretation follows

xi
yi
ait
ni
bi
di
ai










nn

j j j
j j j
j j

j j



straightforward verify model tp additionally clearly ai
di
thus remains model j tp j cp assume
j since concept role names except b minimized follows
xi xj j j model
ait aj
point j model
n n j matter b j point
x b u x b j
thus j model n n j
thus j differ interpretation concept names b
varying contradiction j cp
conversely assume circcp tp let model circcp tp
ai di induction j define mapping assigns j
element j j

n n



fibonatti lutz wolter

j j xi
j j
start set ai th step following
select put exists
since model
select xi put
exists since model
let j j since model
j xi j
set j
assume contrary since ai
di

j n define interpretation j obtained
following modifications
j removed n
let b j b j
let dj
clearly j cp obtain contradiction model circcp tp
thus remains j model tp suffices consider
concept inclusions referring n b axioms hold
dj let e e c j c concept
right hand side clearly e c j since e c e x x reachable ai e n e x x reachable ai
otherwise would ai di axioms thus e n j c j
e j finally j c j definition b j

n n

define mapping setting j j
mapping well defined satisfies horizontal vertical matching conditions
thus p solution

thus shown following
theorem alc satisfiability w r role minimizing ckbs undecidable
reasoning role minimizing ckbs empty tbox alci
prove undecidability reasoning role minimizing ckbs empty tbox alci
proof uses spy point technique areces blackburn marx namely
aboxes simulate tbox reasoning employing inverse roles simulation
nominals circumscription idea proof rather similar proof
theorem


fithe complexity circumscription dls

let p instance tiling consider ckb circcp tp defined
proof lemma simulate tbox axioms c v c abox assertions
c c u r c c enforcing role r connect relevant points
achieved forcing relevant points domain satisfy r since
nominals language use concept name instead ensure
behaves nominal present details
sake readability write concept assertions c form c
set r c c u r c let b n fresh concept names r fresh role
name occurring tp ap consists assertions
r c c



c v c tp


r

u r

x




r n u b r u b u
r n






r

x




u b



r





let cp b b consists concept role names distinct
b b
lemma circcp ap iff p solution
proof assume p solution take interpretation proof lemma
expanded
ai

n

b

r ai

model circcp ap clearly model ap thus remains
model j ap j cp assume exists j cp
model ap minimized aj follows axiom
encoded xj j one prove
induction axiom encoded j
j j r j j j xj j j j
follows xj xi j observe n j matter
b interpreted

j

u b r u b u
r u b




x

one prove similarly proof lemma j differ
interpretation b b contradiction
conversely suppose model circcp ap ai di first
ai r whenever ai x reachable ai finite number
steps assume case exist


fibonatti lutz wolter

ai ai r
xi
r
exists ai r ai observe
n ai di define interpretation j modifying follows
removed n
let ai b j b j
let dj
clearly j cp obtain contradiction thus sufficient j model
ap clearly assertion ap containing neither b n satisfied j
remaining assertions except follows dj satisfied j
finally observe n ai e ai e r di assertions
thus definition n j consider point removed n

j

r u b
definition j
u b r u b u



x

one use assertions construct solution p way
proof lemma

thus proved following
theorem alci satisfiability w r role minimizing ckbs empty tbox undecidable

related work
already pointed introduction circumscription one several
possible approaches nonmonotonic dls order achieve decidability
approaches adopt suitable restriction expressive power dl
component non monotonic features interaction dl nonmonotonic features section survey existing approaches discuss adopted
restrictions relate dls circumscription whenever possible however
point full fledged formal comparison different approaches serious endeavor outside scope main approaches
nonmonotonic dls excluding relying integration dls logic programming summarized table n stands analyzed specificity
column states whether formalism equipped priority mechanism
specificity e subsumption concepts
start two early approaches circumscription work brewka
frame system given nonmonotonic semantics circumscription
focus showing appropriateness proposed semantics decidability
complexity reasoning analyzed cadoli et al apply circumscription dl


fithe complexity circumscription dls

ref
brewka
cadoli donini
schaerf
padgham zhang

straccia
baader hollunder
baader hollunder b
lambrix
shahmehri wahlloef

donini et al

dl
frame lang
ale

nm features
circ
circ

complexity
n
p

specificity

n

al concrete domains
alc

inheritance
networks
prioritized
default logic
default logic

n



decidable



decidable

n

prioritized
default logic
prioritized
default logic

decidable



n



mknf
restrictions
mknf
restrictions
maximized
typicality

depends dl

n

exptime

n

co nexpnp

n

alcf
alc
alqo feature
agreement
decidable dl

donini et al

alc

giordano gliozzi
olivetti pozzato


alc

table approaches nonmonotonic dls

way authors consider non prioritized circumscription
apply fragment description logic ale decidability reasoning shown
reduction propositional reasoning extended closed world assumption
ecwa p best knowledge first effective reasoning
method nonmonotonic description logic
another early padgham zhang nonmonotonic dl obtained adaptation inheritance networks horty
underlying dl essentially al extended concrete data values main contribution definition formalism discussion applications decidability
complexity analyzed
recent similar spirit circumscription taken giordano
et al authors extend alc modal operator representing typicality
maximize extension achieve nonmonotonic inferences decidability proved via
tableau establishes co nexpnp upper bound subsumption
lower bound given
turn approaches default logic reiter nonmonotonic
dls baader hollunder b straccia lambrix et al
share common restriction default rules applied individual
name denoted individual constant occurs explicitly
knowledge base restriction motivated observation defaults
applied implicit anonymous individuals reasoning becomes undecidable baader


fibonatti lutz wolter

hollunder since dl knowledge bases usually include large number
anonymous individuals due existential quantification restriction introduces
strong asymmetry treatment individuals
another line nonmonotonic dls donini et al first order
autoepistemic logics whose interpretation domains restricted fixed denumerable
set constants use unique domain resolves several issues related quantification
modal logics whether barcan formula hold whether different
worlds kripke structure allowed different domains
avoids asymmetry approaches default logic definition
individuals name side coin domains finite varying
cardinality knowledge bases satisfy unique name assumption
dealt rather technical encodings explicit axiomatization
finite domain represented concept name
first mentioned donini et al decidability apply
monotonic knowledge bases autoepistemic operator used nonmonotonic
fashion queries restriction lifted subsequent publications
make use logic minimal knowledge negation failure mknf
equipped two auto epistemic operators k donini et al
former donini et al underlying monotonic fragment
description logic decidable instance checking price payed
generality decidability apply called simple knowledge bases
quantifying quantification across modal operators r k c allowed
nonetheless kbs expressive enough model default rules different restriction
explored donini et al underlying dl restricted alc limited forms
quantifying allowed called subjectively quantified alckn f knowledge bases
decidability obtained subclass simple subjectively quantified knowledge
bases whose nonmonotonic part restricted inclusions form kc v
v c inferred knowledge base restriction incompatible
traditional embedding priority free circumscription autoepistemic logic
prerequisite free default rules would equivalent inclusions
form k v c
recent line integrating dls logic programming rules introduces
nonmonotonic extensions dls negation failure approaches
eiter et al use loosely coupled integration logic programs dls
interpretations dl component restricted logic program variables
range named dl individuals thus approaches somewhat similar
classical extensions dls defaults nonmonotonic inferences
limited named individuals recent motik rosati
mknf shares mknf dls discussed pros cons adopting fixed
denumerable domain complexity reasoning underlying dl c np
data complexity entailment bounded c c finally mention valued variant
knorr alferes hitzler well founded semantics
autoepistemic operator used restricted contexts suffice encode called
procedural rules monotonic



fithe complexity circumscription dls

alc

concept circ
minim roles
fixed roles

n f n
unrestricted
tbox
tbox

alcqo
alci alcio
nexp
np
nexpnp even tbox abox
nexpnp even f
undecidable
undecidable
highly undecidable even tbox

table summary complexity satisfiability w r ckbs
common limitation nonmonotonic extensions dls mknf
provide support specificity priorities particular defeasible inheritance
mentioned expressiveness analysis autoepistemic approaches donini et al
appear goal mknf pointed
introduction well known propositional case nonmonotonic logics
cannot modularly encode specificity priorities needed inheritance
mechanisms horty

conclusions perspectives
shown circumscription provides elegant defining nonmonotonic
dls resulting formalisms appealing expressive power decidable
appropriate restrictions adopted main restriction leads rather
robust decidability concept names minimized fixed whereas
role names vary empty tboxes decidability retained roles allowed
minimized fixed decidability complexity obtained
listed detail table section bounds
tbox apply general acyclic tboxes
view promising step towards establishing circumscribed dls
major family nonmonotonic dls used practical applications reach goal
additional topics addressed mention two first
presented massive non deterministic guessing
thus admit efficient implementation ideally one would
well behaved extensions tableau underly state art
dl reasoners baader sattler crucial issue whether sophisticated optimization techniques implemented reasoners tableaux caching dependency directed
backtracking etc cf baader et al chap adapted circumscribed dls
first steps made grimm hitzler second seems necessary
develop design methodology modelling defeasible inheritance examples given
indicate main challenge rules thumb determine
predicates fixed varied minimized may appealing hide abnormality
predicates behind explicit syntax defeasible inclusions trade generality
simplicity usability
theoretical perspective initial investigation leave open least
interesting questions example current techniques limited circumscribed dls


fibonatti lutz wolter

finite model property would desirable overcome limitation
obtain decidability even expressive dls shiq owl
possible follow opposite consider circumscribed versions inexpressive
dls el dl lite family baader brandt lutz calvanese
giacomo lembo lenzerini rosati currently popular large
number applications first steps made bonatti faella sauro
investigated circumscribed versions el dl lite
finally worth mentioning complexity circumscription
used prove complexity bounds seemingly unrelated reasoning
description logic example certain reasoning services conservative extensions
modularity description logic satisfiability w r concept circumscribed
knowledge bases mutually reducible polynomial time konev lutz
walther wolter many known nexpnp complete circumscription thus provides class potentially
employed give nexpnp lower bound proofs

acknowledgments
first author partially supported network excellence rewerse ist third author partially supported uk epsrc grant gr

appendix missing proofs section
lemma alc satisfiability w r concept circumscribed kbs empty tbox
without fixed roles polynomially reduced satisfiability w r concept circumscribed kbs empty tbox without fixed predicates
proof proof lemma used tbox axioms state fresh
concept names interpreted complement fixed concept names general
cannot done abox assertions instead construct abox assertions
force case objects relevant truth given abox
care required abox assertions polynomial size first part
proof deals second part straighforward modification
proof lemma
first part proof consists introducing notation proving central
technical claim w r rn nr interpretation e write

e wi iff dn e dn di di ri

n
let n set individual names paths mapping n powerset nr
interpretation well behaved mapping paths every
n w paths ai wi alc concept c associate
set p c pairs w w nr subconcept c follows
c nc p c c
c p c c p


fithe complexity circumscription dls

c u c p c c p p
c r c r p c c rw e w e p
set abox assertions individual name use p denote set

c p c write paths w w p formulate
announced claim
claim suppose circcp c cp contain fixed role names
c formulated alc let c let n set individual
names let restriction n
w paths ai wi model circcp
c well behaved mapping paths paths n
prove claim let model circcp ai c note

n paths thus ai clearly well behaved
paths one prove induction c


n w c p ai wi c iff

ci
case c r leave cases reader let c
e di e ri since w c p wr p

since ai wi ai e wr thus e induction hypothesis



yields e di definition semantics c let c


e di e ri definition e ri since w c p
wr p since ai wi ai e wr thus induction
hypothesis yields e di
thus established facts ai c model


hard verify ai c model
model circcp assume contrary model j
j cp define interpretation j follows
j
aj ai f


aj aj v


rj rj r nc
bj bi b ni
assumption cp contain fixed role names hard verify
j cp obtain contradiction fact model circcp
thus remains j model end prove induction c


n w c p j aj wj c j iff

cj
since induction step proof induction start thus let
c nc v done definition j let f since


fibonatti lutz wolter









restriction aj ai definition j yields aj j aj required
finishes proof claim
prove lemma consider instance checking instead satisfiability since
provided polynomial reductions satisfiability non instance checking vice
versa section nevertheless obtain desired let circcp ckb
cp f v f ak take concept assertion c let
c n set individual names define
ak k fresh concept names
w ai w paths n k
cp v
circcp c iff circcp c follows immediately claim
fact paths paths c

lemma c satisfiable w r circcp iff c u b satisfiable w r circcp
proof suppose model c circcp expand interpretation
setting





ai b b ui
clearly model c u b model circcp
assume contrary model j j cp j
aj b j b j since u varying j cp thus easy
j cp contradicts fact model circcp
conversely suppose model c u b circcp
model c circcp first observe ai suppose
case define interpretation j way except uj
b j b j j cp since b j model thus
derived contradiction follows c hence model
c remains j cp j model
assume j exists c j define model j expanding j follows




aj b j





b j j



uj

note b b u interpreted way j cp
moreover j model derived contradiction

lemma l dl simultaneous satisfiability w r concept circumscribed kbs
circcp circcpk tk ak circcpi ti ai circcpj tj aj share
role names j k reduced satisfiability w r single concept
circumscribed kbs polynomial time
proof suffices reduce simultaneous satisfiability without shared role names complement instance checking w r single ckbs generalization straightforward
give proof case k thus let l dl circcp circcp


fithe complexity circumscription dls

ckbs formulated l share role names c l concept moreover let
concept names shared two ckbs r role names used
least one two ckbs together fresh role name r cpi mi vi
obtain tbox replacing concept name ai n
concept name let obtained cp f v
cp way define tbox follows p fresh concept name
ai u v p n
ai u v p n
p
r p

v r p r r
v p r r

set




r b b b b occur





f

f f

v

v v p r

cp f v
let individual name clearly may assume remains
following
claim c simultaneously satisfiable w r circcp circcp iff
instance p u r c w r circcp
assume instance p u r c w r circcp
model circscp ai p u r c call connected directed
graph gi rr ri r connected connected component


restriction domain maximal connected component gi
may assume without loss generality chosen model connected
use role r ensures connected component
contains bi individual names b easy see


model circcp ai p u r c thus may simply replace
c simultaneously satisfiable respect circcp
circcp clearly model c construction circcp
model model circcp assume
contrary case exists model j
j cp define model j follows


j j
predicates used interpreted j
predicates used interpreted


fibonatti lutz wolter


p

j







ai u ai u j n



otherwise





r j j j
readily checked j model j cp thus
derived contradiction fact model circcp follows
model circcp
remains model circcp since connected model
satisfies ai
p aii n therefore
model analogously case circcp
model circcp
assume c simultaneously satisfiable w r ckbs circcp
circcp exists model c model circcp
circcp modify model setting


aii n


p


r




easy see model ai p u r c
instance p u r c w r circcp thus remains prove
model circcp first following
model circcp case since model j
j cp satisfies j cp thus existence model contradicts
fact model circcp
b model circcp assume contrary model j

j
j cp convert j interpretation j setting aj



n j model satisfies j cp
contradiction fact model circcp
assume contrary shown model j
j cp definition cp j cp implies j cp
j cp hold since j clearly satisfies obtain contradiction
b


appendix b missing proofs section
lemma g yes instance co certcols iff cg satisfiable w r circcpg ag
cpg f v root leaf clash
f leaffix tr x xn yn
v set remaining predicates ag


fithe complexity circumscription dls

proof suppose cg satisfiable w r circcpg ag let model
g yes instance co cert col
circcpg ag cg

start

ai cg
ai
assume contrary case cg

rooti let j interpretation obtained setting
since cg
rootj ai definition ag ai rooti thus j cpg moreover
easily seen j model ag thus established contradiction
fact model circcpg ag proves
lines fig elements di w nodes tree n
w

ai
di w xji iff j st bit w n j min n
di w yji iff n j st bit w j n n j n
di w di w di w di w ri n
n w leaf w n
j n use j denote element n w w n denotes
binary encoding followed j
ii leaf j j n
assume contrary case e leaf
j j n let id jd integers truth values x xn
encode id truth values yn encode jd starting construct
interpretation j setting
leaf j
rj

leaf
ri e id jd e ri

modify j j setting
pj



r n var leaf j
r n var leaf j
r n col leaf j
r n col leaf j

going lines straightforward check j model ag
moreover clearly j cpg thus obtain contradiction fact
model circcpg ag thus shown ii
following easy consequence fact p conjunct cg
lines
iii j ri implies leaf j n r var var col col


fibonatti lutz wolter

suppose contrary aim prove g yes instance
truth assignments subgraph g colorable particular holds
assignment defined setting j n

vij iff j tri

let c n r g b coloring g construct interpretation
j starting applying following modifications

cj
clashj

n c c c r g b


clearly j cpg minimized predicate clash empty j non empty since
non empty obtain contradiction thus suffices j model
cg
ag
since j agree predicates r g b clash inclusions
mention concepts satisfied j lines lines
n j
satisfied construction j since due line ii aj
r
n
implies j j thus remains consider lines first

iv j n j edge g iff j
elimj
let j n let potential edge j labeled vk k vk k since


circuits cs cj deliver output input assume potential
non existing edges label ii iii together lines
var j var k k var j var k k thus definition together
lines yields j edge g iff j
elimi prove iv
remains note j interpret concept name elim way
n j
prove satisfied j let aj
r line
j
n
ii j j let j
elim iv since c coloring
g get c c j thus construction j
c j j
c j
c r g b ii iii together lines col j col
col j col j therefore j
col c u col c j c r g b
j
since holds j
elim preconditions implications lines
never satisfied thus implications satisfied

suppose g yes instance let truth assignment
g colorable let c n r g b color assignment
minimizes w r set inclusion set j j edge g c c j define
interpretation follows following distinguish
number binary encoding string


fithe complexity circumscription dls


rooti

di w n w




n w w n

leaffixi

n w w n

leaf

xji

di w j st bit w n j min n

yji


di w n j st bit w n n j n

tr

n ij vij

tri

n ij vij cs j





elim



n ij j edge g

c



n c c c r g b



n ij j edge g c c j

r



di w di w di w di w n

var



n ij n kl first variable label j vkl

var



n ij n kl second variable label j vkl



col

n ij n n

col

n ij n j n

clash

pi



ai



boolean circuit c corresponding output concept name outc interpreted
outic n ij j n c j true

cg satisfiable w r circcpg ag suffices ai cg
model circcpg ag former easy recall cg rootup ur n clash
definition ai root u p since c coloring ai r n clash
thus remains model circcpg ag since easy verify
model ag boils showing model j ag j cpg
assume contrary j lines since j model
ag leaf j n since leaf n j cpg get leaf j leaf
similar simpler reasons rootj rooti thus j cpg implies clashj clashi
lines since j ag leaf j leaf leaf
leaf j n

j
n j
ai r n j aj
r leaf leaf

thus lines fact j model ag ensure

ii c r g b leaf u elim u col c u col c j clashj
define coloring c setting
c c iff n c j
suppose


c r g b

fibonatti lutz wolter

iii elimi leaf elimj leaf
b col leaf leaf col j leaf j leaf j
c col leaf leaf col j leaf j leaf j
ii guarantees j edge g c c j n ij clashj
since clashj clashi get
c c j c c j
j c c j c c j
contradicts initial minimality assumption coloring c
thus remains prove iii start assume
var leaf leaf var j leaf j leaf j
e var leaf leaf var j leaf j leaf j
lines together fact tri trj implies thus
remains prove b e concentrate b cases analogous take
col leaf leaf n ij n j j j n
line j lines since j
agree interpretation x xn yn e leaffixj
n ij e col j value encoded x xn e j value
encoded yn e j since leaffixi leaffixj leaffixj
leaf j however single element leaf j x xn encodes
yn encodes n converse direction analogous

corollary alc satisfiability w r concept circumscribed kbs nexpnp hard
even tbox acyclic abox preference relations empty
fixed predicates
proof abox ag reduction given section form c
circumscription pattern cpg empty preference relation thus suffices
polynomial reduction satisfiability w r concept circumscribed kbs
form satisfiability w r concept circumscribed kbs acyclic tbox empty
abox preference relation fixed predicates
let circcp concept circumscribed kb c cp
v f let c alc concept define v u c
concept name occur c u role name
occur c define cp v u f c satisfiable w r
circcp iff u c satisfiable w r circcp
u c satisfiable w r circcp model circcp
u c thus e c modify obtain interpretation
j setting aj
e clearly j model c model
circcp assume contrary model j j cp j modify


j interpretation setting ai ai ui readily checked
model cp thus obtained contradiction fact
model circcp


fithe complexity circumscription dls

c satisfiable w r circcp model circcp
c let j defined except aj uj clearly
j model u c j model circcp assume

contrary model j j cp j since fixed cp ai


thus u c j e c j modify j interpretation

setting ai e readily checked model cp thus
obtained contradiction fact model circcp get rid fixed
predicates suffices apply lemma


appendix c missing proofs section
semantic consequence reduced instance checking
w r role fixing ckbs alc already proved alc extended
universal role fact remaining approximate concepts u c alc concepts state extension c contains points within certain
sufficiently large neighbourhood
construct approximation first introduce local version notion
frame validity concepts pointed r frame pair f f f
r frame concept c valid pointed r frame f symbols f c iff
c every interpretation f r finite set role names
r c denotes c

n

r c u

u r



rr

r c

follows use concepts form r c approximations
u c remind reader correspondence modal logic let transa
conta r well known blackburn van
benthem easy prove every r frame f following holds
transa valid f sf transitive
conta valid f rf sf
say f r reachable f rf sf call f
root f every f r reachable f f r frame root
following conditions equivalent
r transa u conta valid f
sf transitive rf sf
observations used proof lemma sometimes write
concept assertions c form c recall role depth rd c concept c
defined nesting depth constructors r r r r c
lemma let c alc r concepts sharing concept names let
fresh concept name let cp r v circumscription pattern
consists concept names c v consists concept names let
individual name following conditions equivalent


fibonatti lutz wolter

r frames f rf sf sf transitive f c f
pointed r frames f
f r transa u conta u c



f

instance r transa u conta u c w r circcp
r transa u conta u c max rd c r

u b

bm

proof point implies point suppose point hold let f pointed
r frame f r transa u conta u c f may
assume root f f r transa u conta obtain rf sf
sf transitive therefore f c obtain f c follows f
frame refuting point
follows use every denote set e
r reachable max rd c steps
point implies point suppose point hold let model circcp

ai r transa u conta u c u



let f set ai f r transa u conta u c
f latter easy witnessed interpretation former
let j interpretation f r transa u conta u c j
since model circcp ai max rd c r
b

u

bm

follows immediately
b



b distinguish two cases
b j b since j frame concept
names conta transa c truth r transa u conta u c
depends truth value concept names
obtain b b j b hence r transa u
conta u c j required
b j least one b


let j modification j b j b j b j cp

r transa u conta u c j j model
contradiction fact model circcp thus r transa u

conta u c j since truth r transa u conta u c depends
truth value b r transa u conta u c j
required


fithe complexity circumscription dls

point implies point suppose point hold consider frame f sf
transitive rf sf f c f follows f transa u conta let
interpretation f may assume root f
may assume b b since b occurs ai
ai r transa u conta u c u model remains
exist cp


ai r transa u conta u c max rd c r

u b



bm



straightforward f r c obtain exist


r c clearly exist b b b

max rd c r b

position prove reduction alc
theorem logical consequence mso r effectively reducible
instance w r role fixing ckbs formulated alc even holds
tbox preference relation empty
proof theorem logical consequence mso r effectively reducible
modal consequence alc r concepts hence suffices reduce
modal consequence alc r concepts let alc r concepts c given
may assume c concept names common replace
every concept name b concept name b denote resulting concept
noted c iff c let cp r v
consists concept names c v consists concept names let
r transa u conta u c max rd c r

u b

bm

c r transa u conta u c equivalence point point
lemma circcp c frames f rf sf sf
transitive f c follows f c contain
circcp c



c


references
areces c blackburn p marx road map complexity hybrid logics
proceedings eighth annual conference eacsl csl
lecture notes computer science pp springer verlag
areces c blackburn p marx computational complexity hybrid
temporal logics logic journal igpl
baader f brandt lutz c pushing el envelope kaelbling l p
saffiotti eds proceedings nineteenth international joint conference
artificial intelligence ijcai pp professional book center


fibonatti lutz wolter

baader f milicic lutz c sattler u wolter f b integrating description logics action formalisms reasoning web services ltcsreport ltcs chair automata theory institute theoretical computer science dresden university technology germany see http lat inf tudresden de reports html
baader f hollunder b embedding defaults terminological knowledge
representation formalisms journal automated reasoning
baader f hollunder b b priorities defaults prerequisites application treating specificity terminological default logic journal automated
reasoning
baader f mcguiness l nardi patel schneider p description
logic handbook theory implementation applications cambridge university
press
baader f sattler u tableau description logics dyckhoff
r ed proceedings international conference automated reasoning
tableaux related methods tableaux vol lecture notes artificial
intelligence pp springer verlag
berger r undecidability dominoe memoirs american
mathematical society
blackburn p van benthem j modal logic semantic perspective handbook
modal logic elsevier
blackburn p de rijke venema modal logic cambridge university
press
bonatti p faella sauro l defeasible inclusions low complexity dls
preliminary notes proceedings st international joint conference artificial intelligence ijcai aaai press
bonatti p lutz c wolter f expressive non monotonic description logics
circumscription proceedings tenth international conference
principles knowledge representation reasoning kr pp aaai
press
bonatti p eiter querying disjunctive databases nonmonotonic
logics theoretical computer science
bonatti p samarati p logics authorization security logics
emerging applications databases pp springer verlag
borgida relative expressiveness description logics predicate logics
artificial intelligence
brewka g logic inheritance frame systems proceedings th
international joint conference artificial intelligence ijcai pp morgan kaufmann


fithe complexity circumscription dls

brewka g adding priorities specificity default logic proceedings
logics artificial intelligence jelia vol lecture notes computer
science pp springer verlag
cadoli donini f schaerf closed world reasoning hybrid systems
proceedings th international symposium methodologies intelligent
systems ismis pp elsevier
calvanese giacomo g lembo lenzerini rosati r tractable
reasoning efficient query answering description logics dl lite family journal automated reasoning
cote r rothwell palotay j beckett r brochu l systematized
nomenclature human veterinary medicine tech rep snomed international
northfield il college american pathologists
de kleer j konolige k eliminating fixed predicates circumscription
artificial intelligence
donini f lenzerini nardi nutt w schaerf epistemic
operator description logics artificial intelligence
donini f nardi rosati r autoepistemic description logics proceedings fifteenth international joint conference artificial intelligence ijcai pp morgan kaufmann
donini f nardi rosati r description logics minimal knowledge
negation failure acm transactions computational logic
eiter gottlob g mannila h disjunctive datalog acm transactions
database systems
eiter lukasiewicz schindlauer r tompits h combining answer set
programming description logics semantic web proceedings
ninth international conference principles knowledge representation
reasoning kr pp
giordano l gliozzi v olivetti n pozzato g l reasoning typicality
preferential description logics proceedings logics artificial intelligence
jelia vol lecture notes computer science pp springerverlag
goldblatt r mathematical modal logic view evolution journal applied
logic
gradel e otto rosen e two variable logic counting decidable
proceedings twelfth ieee symposium logic computer science lics
pp ieee computer society press
grimm hitzler p defeasible inference circumscriptive owl ontologies
proceedings workshop advancing reasoning web scalability
commonsense ceur ws http ceur ws org
horrocks sattler u tobies practical reasoning expressive description logics logic journal igpl


fibonatti lutz wolter

horty j f direct theories nonmonotonoc inheritance handbook
logic artificial intelligence logic programming nonmonotonic reasoning
uncertain reasoning pp clarendon press
janhunen intertranslatability non monotonic logics annals mathematics artificial intelligence
kagal l finin joshi policy language pervasive computing
environment fourth ieee international workshop policies distributed
systems networks policy
knorr alferes j j hitzler p well founded semantics hybrid mknf
knowledge bases proceedings international workshop description
logics dl ceur ws http ceur ws org
konev b lutz c walther wolter f semantic modularity module extraction description logics proceedings th european conference
artificial intelligence ecai pp
lambrix p shahmehri n wahlloef n default extension description
logics use intelligent search engine proceedings thirty first
annual hawaii international conference system sciences hicss
p ieee computer society
lifschitz v computing circumscription proceedings ninth international joint conference artificial intelligence ijcai pp morgan
kaufmann
lifschitz v circumscription handbook logic ai logic programming pp oxford university press
lifschitz v nested abnormality theories artificial intelligence
mccarthy j circumscription form nonmonotonic reasoning artificial intelligence
mccarthy j applications circumscription formalizing common sense knowledge artificial intelligence
minsky framework representating knowledge winston p h ed
psychology computer vision pp mcgraw hill
moore r c semantical considerations nonmonotonic logics artificial intelligence
motik b rosati r faithful integration description logics logic
programming proceedings twentieth international joint conference
artificial intelligence ijcai pp morgan kaufmann
pacholski l szwast w tendera l complexity first order twovariable logic counting siam journal computing
padgham l zhang terminological logic defaults definition
application proceedings thirteenth international joint conference
artificial intelligence ijcai pp morgan kaufmann


fithe complexity circumscription dls

pratt hartmann complexity two variable fragment counting quantifiers journal logic language information
quillian r semantic memory semantic information processing pp
mit press
rector defaults context knowledge alternatives owl indexed knowledge bases proceedings pacific symposium biocomputing psb pp
world scientific
rector horrocks experience building large usable medical ontology
description logic transitivity concept inclusions proceedings
workshop ontological engineering aaai spring symposium aaai press
reiter r logic default reasoning artificial intelligence
stevens r aranguren e wolstencroft k sattler u drummond n horridge
rector owl model biological knowledge international
journal man machine studies
stewart complete involving boolean labelled structures projection transactions journal logic computation
straccia u default inheritance reasoning hybrid kl one style logics
proceedings thirteenth international joint conference artificial intelligence
ijcai pp morgan kaufmann
thomason logical consequence relation propositional tense logic
zeitschrift fur mathematische logik und grundlagen der mathematik
thomason b reduction second order logic modal logic zeitschrift fur
mathematische logik und grundlagen der mathematik
tobies complexity reasoning cardinality restrictions nominals
expressive description logics journal artificial intelligence
tonti g bradshaw j jeffers r montanari r suri n uszok semantic web languages policy representation reasoning comparison kaos
rei ponder proceedings second international semantic web conference
iswc vol lecture notes computer science pp springerverlag
uszok bradshaw j johnson jeffers r tate dalton j aitken
kaos policy management semantic web services ieee intelligent systems

wolter f zakharyaschev modal decision handbook modal
logic elsevier
ding v h wu j mapping alci alc proceedings
international workshop description logics dl ceurws http ceur ws org




