Journal Artificial Intelligence Research 35 (2009) 717-773

Submitted 12/08; published 08/09

Complexity Circumscription Description Logic
Piero A. Bonatti

bonatti@na.infn.it

Section Computer Science, Department Physics
University Naples Federico II, Italy

Carsten Lutz

clu@informatik.uni-bremen.de

Department Mathematics Computer Science
University Bremen, Germany

Frank Wolter

wolter@liverpool.ac.uk

Department Computer Science
University Liverpool, UK

Abstract
fragments first-order logic, Description logics (DLs) provide nonmonotonic
features defeasible inheritance default rules. Since many applications would
benefit availability features, several families nonmonotonic DLs
developed mostly based default logic autoepistemic logic.
paper, consider circumscription interesting alternative approach nonmonotonic
DLs that, particular, supports defeasible inheritance natural way. study DLs
extended circumscription different language restrictions different
constraints sets minimized, fixed, varying predicates, pinpoint exact
computational complexity reasoning DLs ranging ALC ALCIO ALCQO.
minimized fixed predicates include concept names role names,
reasoning complete NExpNP . becomes complete NPNExp number
minimized fixed predicates bounded constant. roles minimized
fixed, complexity ranges NExpNP undecidability.

1. Introduction
Early knowledge representation (KR) formalisms semantic networks frames
included wealth features order provide much expressive power possible
(Quillian, 1968; Minsky, 1975). particular, formalisms usually admitted structured representation classes objects similar modern description logics (DLs),
mechanisms defeasible inheritance, default rules, features nowadays studied area nonmonotonic logics (NMLs). KR theory developed
further, all-embracing approaches largely given favour specialized
ones due unfavourable computational properties problems semantics.
process caused DLs NMLs develop two independent subfields. Consequently,
modern description logics SHIQ lack expressive power represent defeasible
inheritance nonmonotonic features (Horrocks, Sattler, & Tobies, 2000).
Despite (or due to) development, continuous interest
(re)integration nonmonotonic features description logics. recent years, advent several new applications DLs increased interest even further. briefly
discuss two them. First, DLs become popular tool formalization biomedc
2009
AI Access Foundation. rights reserved.

fiBonatti, Lutz, & Wolter

ical ontologies GALEN (Rector & Horrocks, 1997) SNOMED (Cote, Rothwell,
Palotay, Beckett, & Brochu, 1993). argued example Rector (2004) Stevens
et al. (2005), important ontologies represent exceptions form
humans, heart usually located left-hand side body; humans
situs inversus, heart located right-hand side body. Modelling
situations requires defeasible inheritance, i.e., properties transfer instances class
default, explicitly overridden special cases (McCarthy, 1986; Horty, 1994;
Brewka, 1994; Baader & Hollunder, 1995b). second application use DLs security policy languages (Uszok, Bradshaw, Johnson, Jeffers, Tate, Dalton, & Aitken, 2004;
Kagal, Finin, & Joshi, 2003; Tonti, Bradshaw, Jeffers, Montanari, Suri, & Uszok, 2003).
formalizing access control policies, one must deal situation given request
neither explicitly allowed explicitly denied. Then, default decision taken
open closed policies, authorizations respectively granted denied
default (Bonatti & Samarati, 2003). Moreover, policies often formulated incrementally, i.e., start general authorizations large classes subjects, objects, actions,
progressively refine introducing exceptions specific subclasses.
approach clearly incarnation defeasible inheritance.
applications illustrate integrating nonmonotonic features DLs
worthwhile, actual engineering computationally well-behaved nonmonotonic DL
provides sufficient expressive power turns non-trivial task. particular,
combinations DLs nonmonotonic logics typically involve subtle interactions
two component logics easily leads undecidability. appears
one optimal way circumnavigate difficulties, thus many different combinations
DLs nonmonotonic logics proposed literature, individual
strengths limitations (we provide survey Section 7). However, striking
gap: almost existing approaches based default logic autoepistemic logic,
circumscription received little attention connection DLs, computational properties DLs circumscription almost completely unknown.
surprising since circumscription known one weakest forms
nonmonotonic reasoningsee work Janhunen (1999) one recent surveys, paper Bonatti Eiter (1996) expressiveness analysis terms
queries. Therefore, natural idea use circumscription defining computationally
well-behaved, yet expressive DL nonmonotonic features.
paper, study circumscription (McCarthy, 1980) alternative approach
defining nonmonotonic DLs. particular, define family DLs circumscription enable natural modelling defeasible inheritance. general approach
generalize standard DL knowledge bases circumscribed knowledge bases (cKBs) which,
additionally TBox representing terminological knowledge ABox representing knowledge individuals, equipped circumscription pattern.
pattern lists predicates (i.e., concept role names) minimized sense that,
admitted models cKB, extension listed predicates minimal
w.r.t. set inclusion. Following McCarthy (1986), minimized predicates used
abnormality predicates identify instances typical class. Circumscription patterns require predicates fixed minimization, allow
vary freely (McCarthy, 1986). main feature DLs family
718

fiThe Complexity Circumscription DLs

come built-in mechanism defeasible inheritance: default, properties
class (humans first example above) transfer subclass (humans situs
inversus), exceptions specified based priority mechanism. well-known
defeasible inheritance priority cannot modularly encoded pure default
autoepistemic logic (Horty, 1994), workarounds explicit listing exceptions
lead serious maintainability problems. Circumscription lends naturally priorities,
based circumscription patterns express preferences minimized predicates terms partial ordering. argued Baader Hollunder (1995b),
approach well-suited ensure smooth interplay defeasible inheritance DL
subsumption, thus prefer traditional prioritized circumscription.
achieve decidability, nonmonotonic DLs usually adopt suitable restrictions
expressive power DL component, non-monotonic features, interaction. case default logic autoepistemic logic, typical restriction concerns
different treatment individuals explicitly denoted constant,
not. goes back reasoning first-order default logic (Reiter, 1980)
autoepistemic logic (Moore, 1985), involve tricky technical issues related
denotation individuals. make reasoning decidable DLs based default logic, default rules applied individuals denoted constants occur explicitly
knowledge base (Baader & Hollunder, 1995a), unnamed individuals.
consequence, named unnamed individuals treated uniformly. approaches
based autoepistemic logic (Donini, Lenzerini, Nardi, Nutt, & Schaerf, 1998; Donini,
Nardi, & Rosati, 1997, 2002), alternative solution restrict domain fixed, denumerable set constants. approach overcomes different treatment named
unnamed individuals since individuals named. flipside ad-hoc encodings
required domain finite unique name assumption enforced, i.e.,
different constants allowed denote individual. respect, DLs
circumscription pose difficulty all, named individuals treated exactly
way unnamed ones without assumptions domain.
time, able base nonmonotonic DLs rather expressive DL components
ALCIO ALCQO without losing decidability. However, cannot without
restrictions either: allow fix minimize concept names circumscription
require role names vary.
main contribution paper detailed analysis computational properties
reasoning cKBs. show that, expressive DLs ALCIO ALCQO, instance
checking, satisfiability subsumption decidable concept-circumscribed KBs
concept names (and role names) minimized fixed. precisely,
prove reasoning problems NExpNP -complete, lower bound applies
already concept-circumscribed KBs ALC empty preference relation without
fixed concept names (1) empty TBox (2) empty ABox acyclic TBox. addition,
show constant bound imposed number minimized fixed concept
names, complexity drops NPNExp .
situation completely different role names minimized fixed. First,
complexity reasoning cKBs formulated ALC single fixed role name, empty
TBox, empty preference relation, minimized role names turns outside
analytic hierarchy, thus highly undecidable. result shown reduction
719

fiBonatti, Lutz, & Wolter

Name

Syntax
r

inverse role
nominal
negation
conjunction
disjunction
at-least restriction
at-most restriction

{a}
C
C uD
C tD
(> n r C)
(6 n r C)

Semantics
(rI )` = {(d, e) | (e, d) rI }
{aI }
\ C
C DI
C DI
{d | #{e C | (d, e) rI } n}
{d | #{e C | (d, e) rI } n}

Figure 1: Syntax semantics ALCQIO.

satisfiability monadic second-order logic (MSO) binary predicates arbitrary
(i.e., necessarily tree-shaped) structures. reduction apply cKBs
role names minimized, fixed. Surprisingly, find case
reasoning empty TBoxes becomes decidable (and NExpNP -complete) DLs
ALC ALCQO, ALCI extensions undecidable.
logics, however, adding acyclic TBoxes leads undecidability. reader find
table summarising complexity results Section 7.
interesting note results somewhat unusual perspective
NMLs. First, arity predicates impact decidability: fixing concept names
(unary predicates) impair decidability, whereas fixing single role name (binary
predicate) leads strong undecidability result. Second, number predicates
minimized fixed (bounded vs. unbounded) affects computational complexity
reasoning. Although (as note passing) similar effect observed propositional
logic circumscription, has, best knowledge, never explicitly
noted.
paper organized follows. next section introduce syntax, semantics,
reasoning problems circumscribed KBs, provide examples. Section 3
provides basic results polynomial simulation fixed concepts means
minimized concepts, polynomial reduction reasoning general TBoxes reasoning acyclic TBoxes, polynomial reduction simultaneous satisfiability
multiple cKBs standard satisfiability. Then, Section 4 proves decidability complexity results concept-circumscribed knowledge bases. Fixed minimized roles
considered Sections 5 6, respectively. Section 7 discusses related work, Section 8
concludes paper summarizing main results pointing interesting
directions research. improve readability, many proof details deferred
appendix. paper extended version article Bonatti, Lutz, Wolter
(2006).

2. Description Logics Circumscription
DLs, concepts inductively defined help set constructors, starting
set NC concept names, set NR role names, (possibly) set NI individual
720

fiThe Complexity Circumscription DLs

names (all countably infinite). use term predicates refer elements NC NR .
concepts expressive DL ALCQIO formed using constructors shown
Figure 1.
There, inverse role constructor role constructor, whereas remaining six
constructors concept constructors. Figure 1 throughout paper, use #S
denote cardinality set S, b denote individual names, r denote
roles (i.e., role names inverses thereof), A, B denote concept names, C,
denote (possibly complex) concepts. usual, use > abbreviation arbitrary
(but fixed) propositional tautology, >, usual Boolean abbreviations,
r.C (existential restriction) (> 1 r C), r.C (universal restriction) (6 0 r C).
paper, concerned ALCQIO itself, several
fragments.1 basic fragment allows negation, conjunction, disjunction,
universal existential restrictions, called ALC. availability additional
constructors indicated concatenation corresponding letter: Q stands number restrictions, stands inverse roles, nominals. explains name
ALCQIO, allows us refer fragments ALCIO, ALCQO, ALCQI.
semantics ALCQIO-concepts defined terms interpretation =

( , ). domain non-empty set individuals interpretation function maps concept name NC subset AI , role name r NR
binary relation rI , individual name NI individual aI .
extension inverse roles arbitrary concepts inductively defined shown
third column Figure 1. interpretation called model concept C C 6= .
model C, say C satisfied I.
(general) TBox finite set concept implications (CIs) C v C
.
concepts. usual, use C = abbreviation C v v C. ABox
finite set concept assertions C(a) role assertions r(a, b), a, b individual
names, r role name, C concept. interpretation satisfies (i) CI C v
C DI , (ii) assertion C(a) aI C , (iii) assertion r(a, b) (aI , bI ) rI .
Then, model TBox satisfies implications , model ABox
satisfies assertions A.
important class TBoxes acyclic TBoxes: call TBox acyclic set
.
concept definitions = C, concept name following two conditions
hold:
concept name occurs left hand side definition ;
.
relation , defined setting B iff = C B occurs C,
well-founded.
1. reason consider ALCQIO paper finite model
property; i.e., satisfiable concepts satisfiable finite models. proofs
complexity upper bounds assume finite model property and, therefore, work ALCQIO. Investigating circumscription description logics without finite model property remains interesting
open problem.

721

fiBonatti, Lutz, & Wolter

2.1 Circumscription, Varying Predicates, Partial Priority Ordering
Circumscription logical approach suitable modelling normally typically
holds, thus admits modeling defeasible inheritance (McCarthy, 1986; Lifschitz,
1993). idea define, standard first-order language, domain knowledge
so-called abnormality predicates identify instances class violate normal
typical properties class. capture intuition abnormality exceptional,
inference based set models resulting theory classical logic,
rather restricted models extension abnormality predicates
minimal respect set inclusion. Intuitively, means reasoning based
models normal possible. Since models classical models
given knowledge base, classical first-order inferences valid circumscription (but
additional inferences may become possible).
Since description logics fragments first-order logic, circumscription readily
applied. Using ALC syntax, assert mammals normally inhabitate land,
whales live land:
Mammal v habitat.Land AbMammal
Whale v Mammal u habitat.Land
upper inclusion states mammal inhabitating land abnormal mammal,
thus satisfying abnormality predicate AbMammal . applying circumscription
TBox, thus consider models extension AbMammal minimal.
However, one way defining preferred models nonminimized predicate treated two different ways minimization: may
either fix extension let vary freely.
Intuitively, fixed predicates retain classical semantics varying predicates may
affected minimization. concrete example, consider TBox
assume non-minimized predicates fixed. derive following
subsumptions:
Whale v AbMammal
()
.
AbMammal = Mammal u habitat.Land.
Here, Whale v AbMammal AbMammal w Mammal u habitat.Land classical consequences
TBox. minimization AbMammal adds inclusion AbMammal v Mammal u
habitat.Land.
analyze fixed predicates, suppose explicitly introduce concrete
mammal whale adding ABox assertion
Mammal u Whale(flipper)
might expect derive habitat.Land(flipper), actually
case. see this, observe classical model knowledge base falsifies
habitat.Land(flipper); extension fixed predicates habitat Land
affected minimization, habitat.Land(flipper) must still false minimization.
argument applied negation habitat.Land(flipper),
thus derivable. seen sentence uses fixed
722

fiThe Complexity Circumscription DLs

predicates, consequence circumscribed knowledge base if, if,
classical consequence knowledge base.
assume let role habitat concept name Land vary freely, fix
Mammal Whale. view concept inclusion Mammal original TBox,
setup may interpreted expressing unlikely mammal
live land: willing modify extension habitat Land order avoid
abnormality. obtain additional consequence, namely:
.
Whale = AbMammal .
()
see indeed consequence note that, minimization, (i) make
Land non-empty (ii) mammal whale, ensure
AbMammal linking via habitat generated instance Land.2 Intuitively,
equality () seen reflecting unlikeliness abnormal: mammal
abnormal reason, reason captured knowledge
base whale.
Let us return assertion Mammal u Whale(flipper). applying classical
reasoning () (), derive Whale w Mammal u habitat.Land (i.e., whales
mammals live land). Thus derive expected conclusion habitat.Land(flipper). summary, turning habitat Land varying
predicates, obtained natural modelling habitat attribute
mammals forced default value.
Driving example further, might consider whales abnormal degree
believe exist unless evidence do. should,
additionally, let Whale vary freely. result () () still derived,
additionally obtain consequence
.
.
Whale = AbMammal = .
use ABox add evidence whales exist, e.g. assertion
Whale(mobydick). expected, result change
.
.
Whale = AbMammal = {mobydick}.
Evidence existence another, anonymous whale could generated adding
ABox assertion Male(mobydick) TBox statement
Whale v mother.(Whale u Male)
mother Male varying freely. knowledge base classically entails exist
two whales, satisfying Male Male, respectively. former denoted mobydick,
latter denoted ABox individual (which corresponds first-order
constant). minimization, Whale contains exactly two individuals.
general, appropriate combination fixed varying predicates depends
application. Therefore, adhere standard circumscription give users freedom
choose predicates minimized, fixed, varying.
2. Indeed, reason let Land vary: ensure made non-empty
minimization.

723

fiBonatti, Lutz, & Wolter

another example, consider sentences: humans, heart usually located
left-hand side body; humans situs inversus, heart located
right-hand side body. axiomatized follows:
Human v heart.has position.{Left} AbHuman
Situs Inversus v heart.has position.{Right}
heart.has position.{Left} u heart.has position.{Right} v .
predicate AbHuman represents abnormal humans minimized. humans
situs inversus restricted individuals explicitly declared
property, analogy previous example roles specifying heart
position class exceptional individuals Situs Inversus allowed vary
Human fixed retain classical semantics. result absence
axioms, AbHuman Situs Inversus empty minimized models.
additional axiom friend.Situs Inversus(John) turns AbHuman Situs Inversus
singleton set containing anonymous individual (though models, may
John himself). example nonclassical consequence, consider:
Human u Situs Inversus v heart.has position.{Left} ,
is, humans default heart position exception
explicitly declared situs inversus.
extensively argued (McCarthy, 1986; Horty, 1994; Brewka, 1994; Baader &
Hollunder, 1995b) interplay subsumption abnormality predicates addressed nonmonotonic DLs. Consider, example, following
TBox:
User
Staff
Staff
BlacklistedStaff

v
v
v
v

hasAccessTo.{ConfidentialFile} AbUser
User
hasAccessTo.{ConfidentialFile} AbStaff
Staff u hasAccessTo.{ConfidentialFile}

get models normal possible, first attempt could minimize
two abnormality predicates AbUser AbStaff parallel. Assume hasAccessTo
varying, User, Staff, BlacklistedStaff fixed. Then, result parallel
minimization staff members may may access confidential files,
equal preference. first case, abnormal users, second case,
abnormal staff. However, one may argue first option preferred: since
Staff v User (but way round), normality information staff
specific normality information users higher priority. effects well-known propositional/first-order case indeed, circumscription
soon introduction extended priorities address issues specificity
(McCarthy, 1986).
formalism, users specify priorities minimized predicates. Typically,
priorities reflect subsumption hierarchy (as computed w.r.t. class
models). Since subsumption hierarchy general partial order, priorities
minimized predicates may form partial order, too. approach analogous partially
724

fiThe Complexity Circumscription DLs

ordering priorities default rules, proposed Brewka (1994). general
standard prioritized circumscription, assumes total ordering (McCarthy, 1986;
Lifschitz, 1985), special case nested circumscription (Lifschitz, 1995).
2.2 Circumscribed Knowledge Bases
define DLs circumscription, start introducing circumscription patterns.
describe individual predicates treated minimization.
Definition 1 (Circumscription pattern, <CP ) circumscription pattern tuple CP
form (, M, F, V ), strict partial order , , F , V
mutually disjoint subsets NC NR , minimized, fixed, varying predicates,
respectively. , denote reflexive closure . Define preference relation <CP
interpretations setting <CP J iff following conditions hold:
1. = J and, NI , aI = aJ ,
2. p F , pI = pJ ,
3. p , pI 6 pJ exists q , q p, q q J ,
4. exists p pI pJ q q p, q = q J .
F NC (i.e., minimized fixed predicates concepts) call
(, M, F, V ) concept circumscription pattern.
4
use term concept circumscription concept circumscription patterns admitted. Based circumscription patterns, define circumscribed DL knowledge
bases models.
Definition 2 (Circumscribed KB) circumscribed knowledge base (cKB) expression CircCP (T , A), TBox, ABox, CP = (, M, F, V ) circumscription pattern M, F, V partition predicates used A. interpretation
model CircCP (T , A) model exists model 0
0 <CP I.
cKB CircCP (T , A) called concept-circumscribed KB CP concept circumscription pattern.
4
Note partially ordered circumscription becomes standard parallel circumscription
empty relation used .
main reasoning tasks (non-circumscribed) KBs satisfiability concepts
w.r.t. KBs, subsumption w.r.t. KBs, instance checking w.r.t. KBs. reasoning
tasks fundamental circumscribed KBs well. provide precise definitions
tasks. Throughout following section, DL denotes set DLs
introduced previous section; i.e., ALC, ALCI, ALCO, ALCQ, ALCQI, ALCIO,
ALCQO, ALCQIO.
Definition 3 (Reasoning tasks)
725

fiBonatti, Lutz, & Wolter

concept C satisfiable w.r.t. cKB CircCP (T , A) model CircCP (T , A)
satisfies C 6= . Let L DL. satisfiability problem w.r.t. cKBs L defined
follows: given concept C L cKB CircCP (T , A) L, decide whether C
satisfiable w.r.t. CircCP (T , A).
concept C subsumed concept w.r.t. cKB CircCP (T , A), symbols
CircCP (T , A) |= C v D, C DI models CircCP (T , A). Let L DL.
subsumption problem w.r.t. cKBs L defined follows: given concepts C
L cKB CircCP (T , A) L, decide whether CircCP (T , A) |= C v D.
individual name instance concept C w.r.t. cKB CircCP (T , A),
symbols CircCP (T , A) |= C(a), aI C models CircCP (T , A). Let
L DL. instance problem w.r.t. cKBs L defined follows: given
concept C L, individual name a, cKB CircCP (T , A) L, decide whether
CircCP (T , A) |= C(a).
4
reasoning problems polynomially reduced one another: first, C satisfiable
w.r.t. CircCP (T , A) iff CircCP (T , A) 6|= C v , CircCP (T , A) |= C v iff C u
satisfiable w.r.t. CircCP (T , A). second, C satisfiable w.r.t. CircCP (T , A) iff
CircCP (T , A) 6|= C(a), individual name appearing A; conversely,
CircCP (T , A) |= C(a) iff AuC satisfiable w.r.t. CircCP0 (T , A{A(a)}),
concept name occurring A, CP0 obtained CP adding
(and leaving is). paper, use satisfiability w.r.t. cKBs basic
reasoning problem.

3. Basic Reductions
present three basic reductions reasoning problems circumscribed knowledge
bases interesting right and, additionally, useful establishing
main results paper later on. precisely, replay well-known reduction
fixed predicates minimized predicates context DLs, reduce reasoning w.r.t. cKBs
general TBoxes reasoning w.r.t. cKBs acyclic TBoxes, show that,
certain conditions, simultaneous satisfiability w.r.t. collection cKBs reducible
satisfiability w.r.t. single cKB.
3.1 Fixed minimized concepts
circumscription, folklore fixed predicates simulated terms minimized
predicates, see e.g. de Kleer (1989). case DLs, simulation possible
concept names. see this, let C0 concept CircCP (T , A) circumscribed
KB CP = (, M, F, V ) F0 = {A1 , . . . , Ak } = F NC . Define new pattern
CP0 = (, 0 , F \ F0 , V )
0 = {A1 , . . . , Ak , A01 , . . . , A0k }, A01 , . . . , A0k concept names
occur C0 , , F , V , , A;
.
0 = {A0i = Ai | 1 k}.
726

fiThe Complexity Circumscription DLs

difficult see C0 satisfiable w.r.t. CircCP (T , A) iff satisfiable w.r.t.
CircCP0 (T 0 , A). Thus, get following result.
Lemma 4 Let L DL. satisfiability w.r.t. (concept-)circumscribed KBs L
polynomially reduced satisfiability w.r.t. (concept-)circumscribed KBs L
fixed concept names.
contrast concept names, fixed role names cannot reduced minimized role names
since Boolean operators roles available standard DLs ALCQIO.
proof given Section 6, show that, cases, reasoning minimized
role names decidable, whereas corresponding reasoning task cKBs fixed role
names undecidable.
reduction clearly relies TBoxes. However, paper sometimes
work circumscribed KBs TBox empty. following lemma, proved
appendix, shows cKBs ALC without fixed role names empty TBox,
one simulate fixed concept names using minimized concept names without introducing
TBox. proof, may viewed much careful version proof
Lemma 4, adapted yield analogous result logics DL.
Lemma 5 ALC, satisfiability w.r.t. (concept-)circumscribed KBs empty TBox
without fixed roles polynomially reduced satisfiability w.r.t. (concept-)circumscribed
KBs empty TBox without fixed predicates.
3.2 Acyclic General TBoxes
many DLs, satisfiability w.r.t. (non-circumscribed) KBs general TBoxes harder
satisfiability w.r.t. (non-circumscribed) KBs acyclic TBoxes. case ALC,
ALCI, ALCQ, ALCQO, latter problem PSpace-complete (Baader, McGuiness,
Nardi, & Patel-Schneider, 2003; Baader, Milicic, Lutz, Sattler, & Wolter, 2005b; Y. Ding
& Wu, 2007) former ExpTime-complete (Baader et al., 2003).
DLs considered paper satisfiability ExpTime-hard already acyclic
TBoxes ALCIO extensions (Areces, Blackburn, & Marx, 2000). show that,
circumscribed KBs, difference computational complexity acyclic
general TBoxes.
Let C0 concept CircCP (T , A) cKB CP = (, M, F, V ). may assume
.
without loss generality = {> = C} concept C. (To see this, observe
.
axioms C v equivalent > = C D). Define
.
.
.
.
acyclic TBox 0 = {A = C, B = u.A, A0 = A, B 0 = B}, A, B, A0 , B 0 , u
new concept role names occurring , A, , F , V , C0 .
circumscription pattern CP0 = (, 0 , F, V 0 ), 0 = {A0 , B 0 } V 0 =
V {A, B, u}.
ad B 0 conjunctively C0 thus interested models CircCP0 (T 0 , A)
(B 0 )I 6= . models, AI = (and thus C = ) since, otherwise,
turn instance B 0 instance B 0 making instance B
727

fiBonatti, Lutz, & Wolter

linking via role u instance A, thus obtaining preferred model w.r.t.
<CP0 . basis proof following lemma, given appendix.
Lemma 6 C0 satisfiable w.r.t. CircCP (T , A) iff C0 uB 0 satisfiable w.r.t. CircCP0 (T 0 , A).
Thus, obtained following result.
Proposition 7 Let L DL. Satisfiability w.r.t. (concept-)circumscribed KBs L
polynomially reduced satisfiability w.r.t. (concept-)circumscribed KBs L acyclic
TBoxes without changing ABox.
shows satisfiability w.r.t. cKBs acyclic TBoxes complexity
satisfiability w.r.t. cKBs general TBoxes. many cases considered paper,
even true cKBs empty TBoxes, c.f. Section 4. However, identify
cases cKBs non-empty TBoxes higher complexity (see Theorems 24 28),
thus general reduction one underlying Proposition 7 cannot exist case
empty TBoxes.
3.3 Simultaneous Satisfiability
applications, often necessary merge TBoxes, ABoxes, whole knowledge bases
taking union. show that, certain conditions, reasoning w.r.t. union
several circumscribed KBs reduced reasoning w.r.t. component cKBs.
concept C simultaneously satisfiable w.r.t. cKBs CircCP1 (T1 , A1 ), . . . , CircCPk (Tk , Ak )
exists interpretation model cKBs satisfies C 6= .
following lemma says simultaneous satisfiability polynomially reduced
satisfiability w.r.t. single cKB two cKBs share role name.
proof idea case k = 2 follows. Given CircCP1 (T1 , A1 ) CircCP2 (T2 , A2 ),
first take union two cKBs, replacing CircCP2 (T2 , A2 ) concept name
used CircCP1 (T1 , A1 ) fresh concept name A0 . introduce
additional concept name P (for problem) make sure P satisfied ABox
individual whenever point model interpretation A0
disagrees. look model P satisfied ABox. Intuitively,
additional concept name P satisfies purpose decoupling A0 , important
e.g. case A/A0 minimized CircCP1 (T1 , A1 ) CircCP2 (T2 , A2 ). Details
given appendix.
Lemma 8 L DL, simultaneous satisfiability w.r.t. (concept-)circumscribed KBs
CircCP1 (T1 , A1 ), . . . CircCPk (Tk , Ak ), CircCPi (Ti , Ai ) CircCPj (Tj , Aj ) share
role names 1 < j k, reduced polynomial time satisfiability w.r.t. single
(concept-)circumscribed KBs.

4. Complexity Reasoning Concept-Circumscribed KBs
main contributions paper consist (i) showing that, many cases, reasoning
circumscribed knowledge bases decidable; (ii) performing detailed analysis
728

fiThe Complexity Circumscription DLs

computational complexity decidable cases. section, show
satisfiability w.r.t. concept-circumscribed KBs NExpNP -complete DL ALC
extensions ALCIO ALCQO. show NPNExp -complete number
fixed minimized concept names bounded constant. first present proofs
upper bounds establish matching lower bounds.
4.1 Upper Bounds
start general case bound number fixed
minimized predicates.
4.1.1 General Case
prepare upper bound proof showing concept satisfiable w.r.t.
concept-circumscribed KB, satisfiable model bounded size. use |C|
denote length concept C, i.e.,
P number (occurrences of) symbols needed
write C. size |T | TBox CvDT |C| + |D|, size |A| ABox
sum sizes assertions A, size role assertion 1
size concept assertions C(a) |C|.
Lemma 9 Let C0 concept, CircCP (T , A) concept-circumscribed KB, n := |C0 | +
|T | + |A|. C0 satisfiable w.r.t. CircCP (T , A), following holds:
(i) , C0 formulated ALCIO, C0 satisfied model
CircCP (T , A) #I 22n .
(ii) , C0 formulated ALCQO maximal parameter occurring number restriction , A, C0 , C0 satisfied model
CircCP (T , A) #I 22n (m + 1) n.
Proof. Let CP, , A, C0 Lemma 9. may assume = every
assertion C(a) expressed implication {a} v C, every assertion r(a, b)
expressed {a} v r.{b}. Denote cl(C, ) smallest set concepts contains
subconcepts C, subconcepts concepts appearing , closed single
negations (i.e., cl(C, ) start , cl(C, )).
Let common model C0 CircCP (T , A), let d0 C0I . Define equivalence relation setting d0 iff
{C cl(C0 , ) | C } = {C cl(C0 , ) | d0 C }.
use [d] denote equivalence class w.r.t. relation. Pick
equivalence class [d] exactly one member denote resulting subset 0 .
first prove Point (i). Thus, assume C0 formulated ALCIO.
define new interpretation J follows:
J

:= 0

AJ

:= {d 0 | AI }

rJ

:= {(d1 , d2 ) 0 0 | d01 [d1 ], d02 [d2 ] : (d01 , d02 ) rI }

aJ

:= 0 aI [d].
729

fiBonatti, Lutz, & Wolter

following claim easily proved using induction structure C.
Claim: C cl(C0 , ) , C iff d0 C J element
d0 [d] J .
Thus, J model satisfying C0 . show J model CircCP (T , A), thus
remains show model J 0 J 0 <CP J . Assume contrary
J 0 . define interpretation 0 follows:


0

AI

0

:=
[
[d]
:=
dAJ 0

r

I0

[

:=

(d1 ,d2
0
aI

[d1 ] [d2 ]

)rJ 0

:= aI .

matter routine show following:
0

0

Claim: concepts C cl(C0 , ) , C iff d0 C J
element d0 [d] J .
0

0

follows 0 model . Observe AI AI iff AJ AJ concept
name {, }. Therefore since CP concept circumscription pattern
0 <CP follows J 0 <CP J . derived contradiction conclude J
model CircCP (T , A). Thus done since size J bounded 22n .
Point (ii). Pick, 0 concept (> k r C) cl(C0 , )
(> k r C)I , k elements {d0 | d0 C , (d, d0 ) rI }. pick,
concept (6 k r C) cl(C0 , ) ((6 k r C))I , k + 1 elements
{d0 | d0 C , (d, d0 ) rI }. Denote 00 collection elements picked. Take
00 \ 0 element ds 0 ds define interpretation J
J

:= 0 00

AJ

:= {d 0 00 | AI }

rJ

:= {(d1 , d2 ) 0 (0 00 ) | (d1 , d2 ) rI }
{(d1 , d2 ) (00 \ 0 ) (0 00 ) | (ds1 , d2 ) rI }

aJ

:= aI [d].

following claim easily proved.
Claim: C cl(C0 , ), following:
(i) d, d0 J , d0 , C J iff d0 C J ;
(ii) , C iff d0 C J element d0 [d] J .
Thus, J model satisfying C0 . show J model CircCP (T , A),
thus remains show model J 0 J 0 <CP J . Assume
contrary J 0 . define interpretation 0 . end, take
730

fiThe Complexity Circumscription DLs

\ J dp 0 dp . define 0 follows



0

I0

:=
0

0

:= AJ {d \ J | dp AJ }

rI

0

:= rJ {(d1 , d2 ) (I \ J ) | (dp1 , d2 ) rJ }

aI

0

:= aI .

0

0

Again, matter routine show:
0

Claim: concepts C cl(C0 , ) , C J iff C J
0
0
C (I \ J ) iff dp C J element dp [d] 0 .
0

0

0

follows 0 model . Observe AI AI iff AJ AJ concept
name {, }. Therefore since CP concept circumscription pattern
0 <CP follows J 0 <CP J . derived contradiction conclude
J model CircCP (T , A). Thus done since size J clearly bounded
22n (m + 1) n.

interesting note proof Lemma 9 go role names
minimized fixed. problem cannot overcome, proved undecidability
results presented Sections 5 6.
Using bounded model property established, prove decidability
reasoning concept-circumscribed KBs formulated ALCIO ALCQO.
precisely, Lemma 9 suggests non-deterministic decision procedure satisfiability w.r.t.
concept circumscription patterns: simply guess interpretation bounded size
check whether model. turns procedure shows containment satisfiability complexity class NExpNP , contains problems solved
non-deterministic exponentially time-bounded Turing machine access
NP oracle. known NExp NExpNP ExpSpace.
Theorem 10 ALCIO ALCQO, NExpNP decide whether concept
satisfiable w.r.t. concept-circumscribed KB CircCP (T , A).
Proof. hard see exists NP algorithm takes input
cKB CircCP (T , A) finite interpretation I, checks whether model
CircCP (T , A): algorithm first verifies polynomial time whether model
A, answering yes case. Otherwise, algorithm guesses interpretation
J domain interprets individual names way,
checks whether (i) J model A, (ii) J <CP I. answers yes
checks succeed, otherwise. Clearly, checking whether J <CP done
time polynomial w.r.t. size J I.
NP algorithm may used oracle NExp-algorithm deciding
satisfiability concept C0 w.r.t. cKB CircCP (T , A): Lemma 9, suffices guess
interpretation size 24k k = |C0 | + |T | + |A|,3 use NP algorithm
check whether model CircCP (T , A). proves concept satisfiability
NExpNP .

3. bound 24k clearly dominates two bounds given Parts (i) (ii) Lemma 9.

731

fiBonatti, Lutz, & Wolter

reductions given Section 2, Theorem 10 yields co-NExpNP upper bounds
subsumption instance problem. show Section 4.2 upper
bounds tight.
4.1.2 Bounded Number Minimized Fixed Predicates
Since NExpNP rather large complexity class, natural question whether
impose restrictions concept circumscription reasoning becomes simpler.
following, identify case considering concept-circumscribed KBs
number minimized fixed concept names bounded constant. case,
complexity satisfiability w.r.t. concept-circumscribed KBs drops NPNExp . readers
uninitiated oracle complexity classes, recall NExp NPNExp NExpNP ,
NPNExp believed much less powerful NExpNP , see example work
Eiter et al. (2004).
prove NPNExp upper bound, first introduce counting formulas common
generalization TBoxes ABoxes.
Definition 11 (Counting Formula) counting formula Boolean combination
concept implications, ABox assertions C(a), cardinality assertions (C = n) C
concept n non-negative integer. use , , denote Boolean
operators counting formulas. interpretation satisfies cardinality assertion (C = n)
#C = n. satisfaction relation |= models counting formulas
defined obvious way.
4
following, assume integers occurring cardinality assertions coded
binary. NPNExp algorithm devised use algorithm satisfiability
(non-circumscribed) counting formulas oracle. Therefore, first determine
computational complexity latter. follows results Tobies (2000) that,
ALC, satisfiability counting formulas NExp-hard. matching upper bound
DLs ALCIO ALCQO obtained facts (i) polynomial
translation counting formulas formulated languages C2, two-variable
fragment first-order logic extended counting quantifiers (Gradel, Otto, & Rosen,
1997; Pacholski, Szwast, & Tendera, 2000), (ii) satisfiability C2 NExp even
numbers counting quantifiers coded binary (Pratt-Hartmann, 2005).
Theorem 12 (Tobies, Pratt) ALC, ALCIO ALCQO, satisfiability counting
formulas NExp-complete even numbers number restrictions coded binary.
establish improved upper bound.
Theorem 13 Let c constant. ALCIO ALCQO, NPNExp decide satisfiability w.r.t. concept-circumscribed KBs CircCP (T , A), CP = (, M, F, V )
#M c #F c.

732

fiThe Complexity Circumscription DLs

Proof. Assume want decide satisfiability concept C0 w.r.t. cKB
CircCP (T , A), CP = (, M, F, V ) #M c #F c. Lemma 4,
may assume F = (we may increase constant c appropriately).
may assume without loss generality cardinality exactly c. Thus, let
= {A0 , . . . , Ac }. Lemma 9, C0 satisfiable w.r.t. CircCP (T , A) iff exists
model C0 CircCP (T , A) size 24k , k = |C0 | + |T | + |A|. Consider,
, concept
CS :=
Au
A.

u



u

A{A1 ,...,Ac }\S

c constant, number 2c concepts constant well. Clearly, sets CSI ,
, form partition domain model I. Introduce, concept
name B role name r A, fresh concept name B 0 fresh role name r0 ,
respectively. concept C, denote C 0 result replacing C concept name
B role name r B 0 r0 , respectively. primed versions A0 0
defined analogously. Denote N set individual names {C0 }.
NExp-oracle going use algorithm checks whether counting formula
satisfiable not. Now, NPNExp -algorithm follows (we use C @
abbreviation counting formula (C v D) (D v C)):
1. Guess
sequence (nS | ) numbers nS 24k coded binary;
individual name N , exactly one set Sa ;
subset E N N .
2. calling oracle, check whether counting formula 1 satisfiable, 1
conjunction
{(C0 = 0)};
(CS = nS ), ;
CSa (a), N ;
{({a} v {b}) | (a, b) E} {({a} v {b}) | (a, b) N E}.
3. calling oracle, check whether counting formula 2 satisfiable, 2
conjunction
0 A0 ;
(CS = nS ), (note use unprimed versions);
CSa (a), individual name N (we use unprimed versions);
{({a} v {b}) | (a, b) E} {({a} v {b}) | (a, b) N E};
,
(A0 v A)

_
BM,BA

733

(B 0 @ B);

fiBonatti, Lutz, & Wolter

and, finally,
_

^

(A0 @ A)




.
(B = B 0 ) .

BM,BA

4. algorithm states C0 satisfiable model CircCP (T , A) if, if,
1 satisfiable 2 satisfiable.
Using fact c fixed, hard verify NPNExp -algorithm.
remains show correctness completeness.
Suppose exists model CircCP (T , A) satisfying C0 .
model size bounded 24k . Let algorithm guess
numbers nS = #CSI , ,
sets Sa aI CSIa ,
set E = {(a, b), (b, a) | aI = bI , a, b N }.
Clearly, 1 satisfied I. remains show 2 unsatisfiable. suppose
exists model J satisfying 2 . definitions 1 2 , may assume
= J ;
AI = AJ ;
aI = aJ individual names a.
Moreover, unprimed role names occur 2 unprimed concept names
2 , may assume interpretation unprimed concept role
names J coincide. Thus, J model CircCP (T , A) satisfying C0 .
define model J 0 domain J setting
0

aJ = aJ , individual names a;
0

rJ = (r0 )J , role names r;
0

AJ = (A0 )J , concept names A.
Then, conjunct Item 1 definition 2 , J 0 model .
Items 5 6 definition 2 , J 0 <CP J , derived contradiction.
Conversely, suppose algorithm says exists model CircCP (T , A) satisfying C0 . take model 1 . conjunct Item 1 1 , model
satisfying C0 . follows unsatisfiability 2 model
CircCP (T , A).


734

fiThe Complexity Circumscription DLs

corollary, obtain co-NPNExp upper bounds subsumption instance problem. similar drop complexity occurs propositional logic, satisfiability w.r.t.
circumscribed theories complete NPNP difficult see bounding
minimized fixed predicates allows us find PNP algorithm.
4.2 Lower Bounds
prove lower complexity bounds reasoning concept-circumscribed KBs
match upper bounds given Section 4.1.
4.2.1 General Case
Section 4.1, start general case number fixed minimized
predicates bounded. aim establish two NExpNP -lower bounds
match upper bound established Theorem 10. first bound satisfiability w.r.t.
concept-circumscribed KBs formulated ALC empty TBox, nonempty ABox. second bound satisfiability w.r.t. concept-circumscribed KBs
formulated ALC, assumes acyclic TBox empty ABox. reductions work
already case empty preference relation, without fixed predicates. Note
considering satisfiability concept C w.r.t. concept-circumscribed KB CircCP (T , A)
empty interesting: seen C satisfiable w.r.t.
CircCP (T , A) iff C satisfiable (without reference KB), C concept
obtained C replacing minimized concept names .
proof first result reduction succinct version problem coCERT3COL, NExpNP -complete (Eiter, Gottlob, & Mannila, 1997), satisfiability
w.r.t. concept-circumscribed KBs empty TBox. Let us first introduce regular (nonsuccinct) version co-CERT3COL:
Instance size n: undirected graph G vertices {0, 1, . . . , n 1} every
edge labelled disjunction two literals Boolean variables {Vi,j | i, j < n}.
Yes-Instance size n: instance G size n that, truth value assignment
Boolean variables, graph t(G) obtained G including edges
whose label evaluates true 3-colorable.
shown Stewart (1991), co-CERT3COL complete NPNP . obtain problem
complete NExpNP , Eiter et al. use complexity upgrade technique: encoding
input succinct form using Boolean circuits, complexity raised one exponential
NExpNP (Eiter et al., 1997). precisely, succinct version co-CERT3COLS
co-CERT3COL obtained representing input graph G nodes {0, . . . , 2n 1}
4n + 3 Boolean circuits 2n inputs (and one output) each. Boolean circuits
(1)
(2)
(i)
named cE , cS , cS , cj , {1, 2, 3, 4} j < n. circuits, 2n inputs
bits binary representation two nodes graph. purpose
circuits follows:
circuit cE outputs 1 edge two input nodes, 0 otherwise;
(1)

edge input nodes, circuit cS outputs 1 first literal
(2)
disjunction labelling edge positive, 0 otherwise; circuit cS
735

fiBonatti, Lutz, & Wolter

second literal; edge input nodes, output
arbitrary;
(i)

edge input nodes, circuits cj compute labelling
Vk1 ,k2 Vk3 ,k4 edge input nodes generating numbers k1 , . . . , k4 :
(i)
circuit cj outputs j-th bit ki ; edge input nodes,
output arbitrary.
reduce co-CERT3COLS satisfiability w.r.t. concept-circumscribed KBs formulated ALC whose TBox preference relation empty. remains
apply Lemma 5 eliminate fixed concept names (we note construction
proof lemma leaves preference relation untouched). Let
(1)

(2)

(i)

G = (n, cE , cS , cS , {cj }i{1,..,4},j<n )
(succinct representation the) input graph 2n nodes. construct ABox
AG = {C0 u Root(a0 )}, circumscription pattern CPG , concept CG G
yes-instance co-CERT3COLS iff CG satisfiable w.r.t. CircCPG (, AG ).
concept C0 used AG conjunction whose presentation split two parts.
Intuitively, purpose first group conjuncts fix truth assignment
variables {Vi,j | i, j < n}, construct (an isomorphic image of) graph t(G)
obtained G including edges whose label evaluates true t. Then,
purpose second group make sure t(G) 3-colorable.
formulating C0 , use several binary counters counting modulo 2n (the
number nodes input graph). main counters X use concept names
X0 , . . . , Xn1 Y0 , . . . , Yn1 bits, respectively. Additionally, introduce concept
(i)
(i)
names K0 , . . . , Kn1 , {1, 2, 3, 4}, serve four additional counters K (1) , . . . , K (4) .
first group conjuncts C0 found Figure 2, following abbreviations
used:
ri .C denotes n-fold nesting r. .r.C;
r.(K (i) = X) abbreviation

u

j<n

(i)
(i)
(Xj r.Kj ) u (Xj r.Kj )

similarly r.(K (i) = );
abbreviations Wc , c Boolean circuit, explained later on.
intuition behind Figure 2 follows. Lines (1) (5) build binary tree depth
2n whose edges labeled role name r. 22n leaves tree instances
concept name Leaf, labeled possible values counters X
. Since minimize Leaf via circumscription pattern CPG , concept name
denotes precisely leaves tree. Due use counters X , leaves
distinct.
leaves tree established satisfy number purposes. start with,
leaf counter values X = = j corresponds variable Vi,j co3CERTCOLS determines truth value variable via truth/falsity concept
736

fiThe Complexity Circumscription DLs

ri .(r.Xi u r.Xi )
j

r .((Xi r.Xi ) u (Xi r.Xi ))
r
r

n+j

n+i

.(r.Yi u r.Yi )

.((Yi r.Yi ) u (Yi r.Yi ))

< n

(1)

< n, j < 2n

(2)

i<n

(3)

< j < n

(4)

2n

r .Leaf

(5)

r2n .(WcE u Wc(1) u Wc(2) )

(6)





r2n .(Wc(1) u u Wc(4) )
j

j < n

r2n .(var1.LeafFix u var1.(K (1) =X) u var1.(K (2) =Y ))
2n

r .(var2.LeafFix u var2.(K

(3)

(7)

j

=X) u var2.(K

(4)

(8)

=Y ))

(9)

2n

P r .var1.Leaf

(10)

2n

P r .var2.Leaf

(11)

r2n .(S1 (Tr1 var1.Tr))

(12)

2n

r .(S1 (Tr1 var1.Tr))
2n

r .(S2 (Tr2 var2.Tr))
2n

(13)
(14)

r .(S2 (Tr2 var1.Tr))

(15)

2n

(16)

r .(Elim (E (Tr1 Tr2 )))
Figure 2: first group conjuncts C0 .

name Tr. Thus, leaves jointly describe truth assignment instance G co3CERTCOLS . second purpose leaves represent potential edges G:
additionally representing variable, leaf X = = j corresponds
potential edge nodes j. explain properly, must first
discuss abbreviations Wc used Lines (6) (7) Figure 2.
concept Wc , c Boolean circuit 2n inputs, result converting c
concept uses constructors , u, following condition satisfied:
instance Wc , output c upon input b0 , . . . , b2n1 b, truth
value concept names X0 , . . . , Xn1 , Y0 , . . . , Yn1 described b0 , . . . , b2n1 ,
truth value concept name described b. introducing one
auxiliary concept name every inner gate c, translation done
size Wc linear size c. following concept names used output:
WcE uses concept name E output;
Wc(i) uses concept name Si output, {1, 2};


(i)

Wc(i) uses concept name Kj

output, {1, . . . , 4} j < n.

j

737

fiBonatti, Lutz, & Wolter

r2n .(col1.LeafFix u col2.LeafFix)
2n

r .(col1.(X = X) u col1.(Y = 0))
2n

r .(col2.(Y = X) u col2.(Y = 0))

(17)
(18)
(19)

2n

(20)

2n

P r .col2.Leaf

(21)

r2n .((Y = 0) (R B G))

(22)

r .((Y = 0) ((R u B) u (R u G) u (B u G)))

(23)

r2n .((Elim u col1.R u col2.R) Clash)

(24)

r2n .((Elim u col1.G u col2.G) Clash)

(25)

r2n .((Elim u col1.B u col2.B) Clash)

(26)

P r .col1.Leaf

2n

Figure 3: second group conjuncts C0 .
Lines (6) (7) ensure concepts propagated leaves. next aim
ensure leaf represents potential edge (i, j) connected via role var1
leaf represents variable first disjunct label (i, j), analogously
role var2 variable second disjunct edge label. replaced
concept name LeafFix Leaf Lines (8) (9), lines would apparently
encode properties. However, careful mentioned replacement
would interact minimization Leaf. fix problem, resort trick:
use concept name LeafFix instead Leaf. way, may may reach
instance Leaf. not, force concept name P true root
tree Lines (10) (11). use CG rule models P true. Finally,
fix LeafFix via CPG eliminate interaction minimization Leaf.
remaining Lines (12) (16) ensure leaf instance Elim iff potential
edge represents present graph t(G) induced truth assignment
described leaves.
second group conjuncts C0 found Figure 3. Here, (Y = 0) stands
concept (Y0 u u Yn1 ). already mentioned, purpose conjuncts
ensure graph t(G) described leaves 3-coloring.
strategy ensuring follows: use 2n leaves = 0 store colors
nodes, i.e., leaf X = = 0 stores color node i. Lines (22)
(23), unique coloring. Then, Lines (17) (21) ensure leaf (viewed
edge) connected via role col1 leaf stores color first node
edge, analogously role col2 second node edge. LeafFix
P role before. Lines (24) (26) guarantee concept name Clash
identifies problems coloring: leaf Clash represents edge exists
G, dropped t(G), endpoints color. idea
Clash minimized R, G, B vary. additional concept
names fixed, corresponds universal quantification possible colorings.
738

fiThe Complexity Circumscription DLs

Set CG = Root u P u r2n .Clash, recall AG = {C0 u Root(a0 )}. following
lemma proved appendix.
Lemma 14 G yes-instance co-3CERTCOLS iff CG satisfiable respect
CircCPG (, AG ), CPG = (, M, F, V ) = , = {Root, Leaf, Clash},
F = {LeafFix, Tr, X0 , . . . , Xn1 , Y0 , . . . , Yn1 , },
V set remaining predicates AG .
Since size AG polynomial n, get following result applying Lemma 5.
Theorem 15 ALC, satisfiability w.r.t. concept-circumscribed KBs NExpNP -hard even
TBox preference relation empty fixed predicates.
rather straightforward establish announced second NExpNP lower bound
reduction satisfiability w.r.t. concept-circumscribed KBs special case formulated
Theorem 15. Details given appendix.
Corollary 16 ALC, satisfiability w.r.t. concept-circumscribed KBs NExpNP -hard
even TBox acyclic, ABox preference relations empty,
fixed predicates.
Corresponding lower bounds subsumption instance problems follow
reduction given Section 2.
4.2.2 Bounded Number Minimized Fixed Predicates
establish matching lower bound Theorem 13 showing that, ALC, satisfiability w.r.t. concept-circumscribed KBs NPNExp -hard even constant number
predicates allowed minimized fixed. contrast previous section,
ignore case empty TBoxes directly establish lower bound case
non-empty TBoxes empty ABoxes. allows us demonstrate usefulness
Lemma 8 separating different parts lower bound proof: main reduction
previous section, two parts reduction shown Figure 2 3 truly
independent, forced us implement technical trick involves concept
names LeafFix P . using Lemma 8, contrast, achieve true separation
concerns. general, though, conjecture lower bound proved section
established case empty TBoxes adapting mentioned technical trick.
leave problem interested reader.
Recall (non-deterministic) k-tape Turing machine described tuple
(Q, , q0 , , qacc , qrej ),
Q finite set states, finite alphabet, q0 Q starting state,
Q k Q k {L, R}k
transition relation, qacc , qrej Q accepting rejecting states. purposes,
oracle Turing machine 2-tape Turing machine that, additionally, equipped

739

fiBonatti, Lutz, & Wolter

1-tape Turing machine M0 (the oracle) whose alphabet identical M,
query state q? ,
two answer states qyes qno .
second tape called oracle tape. enters q? , oracle determines
next state M: content oracle tape contained language accepted
oracle, next state qyes . Otherwise, qno . transition, head
moved symbols written. state q? cannot occur left-most component
tuple Ms transition relation.
Let = (Q, , q0 , , qacc , qrej , M0 , q? , qyes , qno ) oracle Turing machine
following holds:
solves NPNExp -complete problem;
time consumption bounded polynomial p (where oracle calls contribute single clock tick);
0 , q 0 ) bounded 2q(n) , q
time consumption M0 = (Q0 , , q00 , 0 , qacc
rej
polynomial.

assume without loss generality M0 never attempt move left
left-most position tape (neither right right-most position). NPNExp hardness proof uses reduction word problem M. Thus, let w input
length n, let = p(n) m0 = q(p(n)). construct three TBoxes
Tw , Tw0 , Tw00 , circumscription patterns CP, CP0 , CP00 , concept Cw
accepts w iff Cw simultaneously satisfiable w.r.t. CircCP (Tw , ), CircCP0 (Tw0 , ),
CircCP00 (Tw00 , ). Then, Lemma 8 yields reduction (non-simultaneous) satisfiability w.r.t.
concept-circumscribed cKBs. Intuitively, purpose first TBox Tw impose
basic structure domain, Tw0 describes computations M, Tw00 describes
computations M0 . use general TBoxes rather acyclic ones since, Lemma 6,
done without loss generality.
TBox Tw shown Figure 4. previous reduction, use concept
names X0 , . . . , Xm0 1 Y0 , . . . , Ym0 1 implement two binary counters counting
0
modulo 2m . use abbreviations previous reduction. Additionally,
r.(X++) states value counter X0 , . . . , Xm0 1 incremented going
r-successors, i.e.,


Xj (Xk r.Xk ) u (Xk r.Xk )
0

u
u

k=0..m 1

k=0..m0 1

u


j=0..k1

j=0..k1



Xj (Xk r.Xk ) u (Xk r.Xk )

purpose Lines (27) (30) ensure that, possible value (i, j)
counters X , least one instance NExp satisfies (X = i) (Y = j).
0
0
minimize NExp, thus enforce NExp exactly 2m 2m elements.
0
0
elements interconnected via roles r (for right) u (for up) form 2m 2m grid. Later on, use grid encode computations oracle machine M0 . Observe
740

fiThe Complexity Circumscription DLs

> v aux.NExp
m0

NExp v ((X = 2

(27)
m0

1) r.NExp) u ((Y = 2

1) u.NExp)

(28)

NExp v r.(Y =Y ) u r.(X++)

(29)

NExp v u.(X=X) u u.(Y ++)

(30)

> v
Result v

u aux.(Result u R )
u (R u R )

(31)



i<m



i<j<m

(32)

j

> v aux.NP

(33)
Figure 4: TBox Tw .

that, since working simultaneous satisfiability, minimization NExp
interact anything going put TBoxes Tw0 Tw00 .
minimize concept name Result, thus Lines (31) (32) guarantee
exactly instances Result, identified concept names R0 , . . . , Rm1 .
makes call oracle i-th step, result call stored
(unique) instance Result u Ri , i.e., instance satisfy concept name Rej
M0 rejected input falsify otherwise. Finally, minimize NP, thus
Line (33) guarantees exactly one instance NP. instance used
represent computation M. Summing up, circumscription pattern Tw
CP := (, {NExp, Result, NP}, , V ),
V containing remaining predicates used Tw .
purpose Tw0 describe computations M. use following concept
names:
, i, j < m, k {1, 2}, introduce concept name Sai,j,k . Intuitively,
Sai,j,k expresses symbol j-th cell k-th tape i-th step
Ms computation. start numbering tape cells steps 0.
q Q < m, Qiq concept name expressing state q
i-th step computation.
q Q, i, j < m, k {1, 2}, Hji,k concept name expressing
k-th head cell j i-th step computation.
q Q, , i, j < m, k {1, 2}, {L, R}, concept names Aiq , Ai,j,k
,
i,k

serve markers. precisely, Aq means that, time point i,
executed transition switches state q. Similarly, Ai,j,k
describes symbol

i,k
written transition tape k, describes move tape k.
details Tw0 given Figure 5. One copy concept inclusions figure
needed every i, j, j 0 < every k {1, 2}. assume w = a0 an1
741

fiBonatti, Lutz, & Wolter

0,n,1
0,m1,1
NP v Q0q0 u H00,1 u Sa0,0,1
u Sa0,n1,1
u SB
u u SB
0
n1

(34)

0,0,2
0,m1,2
NP v H00,2 u SB
u u SB

(35)

NP v

u

i,j 0 ,2

a,b,qQ\{q? }

(Sai,j,1 u Sb

NP v
NP v
NP v
NP v
NP v

uA
uA

qQ


Ai,k
L
i,k
AR


q

i,j,k


0 ,2
i,2
Aiq u Ai,j,1
u Ai,j
u Ai,1

u 0 ) (37)
b

< 1

(38)

(q,a,b,q 0 ,a0 ,b0 ,M,M 0 )

Sai+1,j,k

i+1,k
Hj1

< 1

(39)

< 1 j > 0

(40)

i+1,k
Hj+1

< 1 j < 1

i+1,j,k
< 1 j 6= j 0
(Sai,j,k u Hji,k
0 ) Sa

u
u



Qi+1
q

a,b,a6=b

(Sai,j,k u Sbi,j,k ) u

NP v (Hji,k u Hji,k
0 )

(36)



(
NP v

u Qiq u Hji,1 u Hji,2
0 )

u

q,q 0 Q,q6=q 0

(Qiq u Qiq0 )

j 6= j 0

(41)
(42)
(43)
(44)

NP v resi .(Result u Ri ) u resi .(Result u Ri )

(45)

NP v (Qiq? u resi .Rej) Qi+1
qno

(46)

NP v

(Qiq?

u resi .Rej)

Qi+1
qyes

NP v (Qiq? u Hji,k ) Hji+1,k
NP v

u



< 1
< 1

< 1

i+1,j,k

(Qiq? u Sai,j,k ) Sa

(47)
(48)
(49)

Figure 5: TBox Tw0 .
use B denote (shared) blank symbol M0 . Lines (34) (43) describe
behaviour Turing machine usual way: transitions follow transition table,
computation starts initial configuration, etc. Line (45) ensures instance
NP reach (unique) instance Result u Ri via role resi , < m. Lines (46)
(47) deal transitions query state looking result oracle
call corresponding instance Result. Finally, Lines (48) (49) ensure head
position tape symbols change querying oracle. circumscription
pattern Tw0 simply CP0 := (, , , V ), V set predicates used Tw0 .
purpose Tw00 describe computations oracle Turing machine M0 . Note
describe single computation M0 (but polynomially many) since may visit state q? once. computations
represented NExp grid, different computations untangled use
different concept names computation. use counter X0 , . . . , Xm0 1 count
742

fiThe Complexity Circumscription DLs

configurations counter Y0 , . . . , Ym0 1 count tape cells configuration.
Moreover, use following concept names:
< m, concept name Sai . Sai satisfied instance
NExp X0 , . . . , Xm0 1 value j Y0 , . . . , Ym0 1 value k, i-th
computation M0 has, j-th step, symbol k-th cell.
q Q < m, concept name Qiq . purpose concept name
two-fold: first, represents current state M0 i-th computation.
second, indicates head position i-th computation.
, q Q, {L, R} < m, concept name Aiq,a,M marker.
meaning marker Aiq,a,M that, reach current configuration, M0
switched q, written a, moved head direction . Additionally, marker
indicates head position previous configuration.
additional concept name NH (for nohead) helps us enforce M0
single head position.
details Tw00 shown Figure 6, require one copy line every
< m. purpose Lines (50) (51) regenerate grid structure NExp using
roles r0 und u0 . necessary since roles r u used Tw , and, use
Lemma 8, TBoxes cannot share role names. Lines (52) (53) ensure every
instance NExp reaches (only) unique instance NP via role toNP, (only)
unique instance Result u Ri via role res0i , < m. Lines (54) (64) describe
computation M0 straightforward way. precisely, Lines (54) (56) set
initial configuration reading contents Ms oracle tape instance NP.
Lines (57) (61) implement transitions, Lines (62) (64) enforce unique label
tape, unique state, unique head position. Finally, Line (65) ensures that,
i-th computation M0 rejecting, Rej true instance Result u Ri .
Note M0 non-deterministic machine may one computation.
storing Rej Result u Ri , need know computations rejecting.
deal issue, Rej minimized predicates varying: exists
accepting computation M0 i-th input, represent computation
NExp make Rej false instance Result u Ri . Hence, Rej holds Result u Ri
iff exists accepting computation. Note cannot fix concept names
X0 , . . . , Xm0 1 , Y0 , . . . , Ym0 1 minimizing Rej since would get unbounded number
fixed concept names. means elements NExp change position
minimization, roles r0 u0 . harmful since Tw
Lines (50) (51) ensure structure (NExpI , (r0 )I , (u0 )I ) always isomorphic
grid, rest Tw00 ensures elements NExp always encode computations
M0 . thus use circumscription pattern CP00 := (, {Rej}, , V 0 ), V 0 contains
predicates used Tw00 except Rej.
proof following lemma left reader. formulation, union
Qiqacc imposes least one state computation accepting.
743

fiBonatti, Lutz, & Wolter

0

0

NExp v ((X = 2m 1) r0 .NExp) u ((Y = 2m 1) u0 .NExp)
0

0

0

0

(50)

NExp v r .(Y =Y ) u r .(X++) u u .(X=X) u u .(Y ++)

(51)

NExp v res0i .(Result u Ri ) u res0i .(Result u Ri )

(52)

NExp v toNP.NP u toNP.NP

(53)

NExp v

uu



j<m



(X = 0) u (Y = j) u toNP.Sai,j,2 Sai

(54)


NExp v ((X = 0) u (Y m)) SB

(55)

Qiq0
0

(56)

NExp v ((X = 0) u (Y = 0))
NExp v

uu



(Sai u Qiq )

qQ0



(q,a,q 0 ,a0 ,M )0

r0 .Aiq0 ,a0 ,M



(57)

NExp v Aiq,a,R (Sai u u0 .Qiq )

(58)

Aiq,a,L Sai
u0 .Aiq,a,L

(59)

NExp v
NExp v

NExp v
NExp v

(60)

Q u (S r .S )
u (S u ) u u
Q u .NH

NH Q u u .NH

NExp v
NExp v

Qiq

qQ0


q

a,b,a6=b
qQ0




rej


b




(61)
(Qiq u Qiq0 )

q,q 0 Q0 ,q6=q 0

0


q

qQ0

NExp v Qiq0

0







q

(62)
(63)

0

(64)

res0i .Rej

(65)

Figure 6: TBox Tw00 .
Lemma 17 accepts w iff Cw := NP u

tQ

i<m


qacc

simultaneously satisfiable w.r.t.

CircCP (Tw , ), CircCP0 (Tw0 , ), CircCP00 (Tw00 , ).

remains apply Lemmas 6, 4, 8 obtain following result.
Theorem 18 ALC, satisfiability w.r.t. concept-circumscribed cKBs NPNExp -hard
even TBox acyclic, ABox preference relations empty,
fixed predicates, number minimized predicates bounded constant.
already mentioned, conjecture result proved empty TBoxes
(but non-empty ABoxes). Corresponding lower bounds subsumption instance
problems follow reduction given Section 2.
744

fiThe Complexity Circumscription DLs

5. Circumscription Fixed Roles
preceeding sections, analyzed computational complexity reasoning
w.r.t. concept-circumscribed KBs and, particular, established decidability. current
section, extend concept-circumscribed KBs call role-fixing cKBs, differ
former allowing role names fixed (but minimized). Interestingly,
result seemingly harmless modification reasoning becomes highly undecidable.
start defining cKBs studied section.
Definition 19 cKB CircCP (T , A) CP = (, M, F, V ) called role-fixing contains role names.
4
pinpoint exact complexity reasoning role-fixing cKBs, present reduction
logical consequence problem monadic second-order logic binary relation symbols
(over unrestricted structures, trees) instance problem w.r.t. role-fixing cKBs
formulated ALC. follows latter problem harder problem definable
second-order arithmetic thus outside analytical hierarchy. Analogous results
satisfiability subsumption follow reductions given Section 2. reduction
applies already case TBox preference relation empty.
finite set R binary relation symbols, denote MSO(R) set formulas
constructed countably infinite set P1 , P2 , . . . variables sets, countable infinite
set x1 , x2 , . . . individual variables, binary relation symbols R, using Boolean
connectives, first-order quantification, monadic second-order quantification.
hard see reasoning role-fixing cKBs corresponds reasoning tiny fragment MSO(R). specifically, consider standard translation ALC-concepts C
FO-formulas (and thus MSO(R)-formulas) C ] (x) one free individual variable x e.g.
given Borgida (1996) take cKB CircCP (T , A) CP = (, M, F, V ), = V = ,
= {A}, F = {r}. Translate (T , A) MSO(R)-sentence
^
^
^
=
x(C ] (x) D] (x))
C ] (xa )
r(xa , xb ),
CvDT

C(a)A

r(a,b)A

xa individual variables.
ALC-concept C satisfiable w.r.t. CircCP (T , A) if, if, MSO(R)formula
xC ] (x) P (P A] [P/A] ])
satisfiable, P A] stands x (P (x) A] (x))x (A] (x)P (x)) [P/A] ]
denotes A] replaced P . translation easily extended case
arbitrary number concept names minimized arbitrary number concept
role names fixed varies.
prove logical consequence MSO(R) reducible instance problem w.r.t. role-fixing cKBs, thus establish surprising result reasoning
sKBs correspond tiny fragment MSO(R), hard
MSO(R). reduction indirect: instead directly reducing logical consequence
MSO(R), reduce semantic consequence problem modal logic exploit Thomasons result logical consequence MSO(R) reduced latter problem, see
745

fiBonatti, Lutz, & Wolter

works Thomason (1975b, 1975a) survey articles Wolter et al. (2007)
Goldblatt (2003) details.
first define semantic consequence problem modal logic (in framework
description logic) present Thomasons result, starting notation.
Let R finite set role names. R-frame structure F = (F , RF ), F
non-empty domain rF F F r R. interpretation = (I , )
based R-frame F iff F = rI = rF r R. say concept C
valid F write F |= C C = every interpretation based F. semantic
consequence modal logic defined follows. Let C ALC concepts
roles R. semantic consequence C, symbols C D, every
R-frame F, F |= C follows F |= D. Note since validity R-frame F
involves quantification possible interpretations symbols contained R,
relation C invariant uniform renamings atomic concepts (this
used later on).
simplicity, consider MSO(r), monadic second-order logic one binary
relation symbol r. straighforward extend result arbitrary finite sets R
relation symbols. Given set role names R, ALC-concept called ALC R -concept
uses role names R. following theorem follows
results Thomason (1975b, 1975a).
Theorem 20 exist effective translation : 7 () MSO(r) sentences
ALC {r} -concepts ALC {r} -concept C0 MSO(r) sentences ,
following conditions equivalent:
logical consequence MSO(r);
C0 u () ().
thus establish reduction MSO(r) instance problem w.r.t. role-fixing
cKBs reducing instead semantic consequence problem. fact, reduction
implemented transparent way extend ALC universal role, whereas
reduction ALC requires number rather technical intermediate steps.
reason, defer ALC case appendix give proof universal
role.
Let u new role name, called universal role. every interpretation I, u
fixed interpretation uI = . Since interpretation u fixed anyway,
allow use circumscription patterns.
suppose C ALC {r} -concepts. establish reduction, construct role-fixing cKB CircCP (, {C0 (a)}) concept C1 C if, if,
instance C1 w.r.t. CircCP (, {C0 (a)}). noted above, may assume C,
share concept names (otherwise, simply replace concept names fresh
ones). Let concept name occur C D, let CP = (, M, {r}, V ),
= , consists set concept names C, V consists
concept names D. Set = {(u.C u.
B)(a)}.

u

BM

Lemma 21 following conditions equivalent:
746

fiThe Complexity Circumscription DLs

C D;
instance (u.C) w.r.t. CircCP (, A).
Proof. prove Point 1 implies Point 2, assume Point 2 hold. Let
model CircCP (, A) aI ((u.C) u D)I . Let based F. prove
Point 1 hold, show F |= C F 6|= D. latter easy
witnessed interpretation I. show former, let J interpretation based
F. show C J = . First note that, since model aI (u.C)I ,
B = , B . distinguish two cases:
B J = , B . case, B interpretation
J . Thus, since concept names C J based
frame, obtain C J = C = .
B J 6= , least one B . J <CP I. Assume C J 6= .
aI (u.C)J J model A. Thus, derived contradiction
assumption model CircCP (, A).
prove Point 2 implies Point 1, assume Point 1 hold. Consider
frame F F |= C, F 6|= D. Let interpretation based F
aI (D)I . may assume B = B (since B occurs
D). aI ((u.C) u D)I model A. remains show
exist 0 <CP 0 model A. straightforward: F |= C,
0
0
obtain exist 0 aI (u.C)I . Moreover, clearly
0
0
0
exist 0 B ( B B aI (u.
B)I .


u

BM

thus proved logical consequence problem MSO(r) effectively reducible
instance problem w.r.t. role-fixing cKBs formulated ALC extended universal role. reduction, TBox preference relation empty. appendix,
show reduction modified prove result ALC
without universal role.
Theorem 22 logical consequence problem MSO(r) effectively reducible
instance problem w.r.t. role-fixing cKBs formulated ALC. even holds
TBox preference relation empty.

6. Circumscription Minimized Roles
Unlike fixed concept names, fixed role names cannot simulated using minimized role
names. due fact Boolean operators roles available standard
DLs. Thus, Theorem 22 imply undecidability reasoning cKBs role
names allowed minimized, fixed. section, investigate cKBs
type. formal definition follows.
Definition 23 cKB CircCP (T , A) CP = (, M, F, V ) called role-minimizing F
contains role names.
4
747

fiBonatti, Lutz, & Wolter

show role-minimizing cKBs behave rather differently concept-circumscribed
KBs role-fixing cKBs. First, turns reasoning role-minimizing
cKBs empty TBox NExpNP -complete ALCQO, undecidable ALCI.
Thus, contrast circumscribed KBs considered far, observe difference
complexity ALCQO ALCI, even ALC ALCI. second
difference results obtained far NExpNP -lower bound, applies
cKBs formulated ALC empty TBox, even holds role-minimizing cKBs
single role minimized predicate fixed minimized. result
interest shows complexity drop NPNExp number
minimized predicates constant. Finally, show that, non-empty TBoxes, reasoning
role-minimizing cKBs becomes undecidable already ALC.
6.1 Role-minimizing cKBs Empty TBox ALCQO
first prove NExpNP -completeness result discussed DLs without inverse
roles. start upper bound. prove it, first establish bounded model
property using selective filtration-style argument, see e.g. Blackburn et al. (2001).
difference bounded model property proof given concept-circumscribed KBs
that, here, build quotient model given model identifying nodes using
equivalence relation, construct submodel given model selecting relevant nodes.
contrast forming quotient models, technique works empty TBoxes since
TBox force us select infinitely many nodes. Similarly, selection technique
work DLs inverse role because, shall see below, inverse roles
used simulate TBoxes.
Recall role depth rd(C) concept C defined nesting depth
constructors (> k r D) (6 k r D) C.
Theorem 24 ALCQO, satisfiability w.r.t. role-minimizing cKBs empty TBox
NExpNP .
Proof. Let CircCP (, A) role-minimizing cKB CP = (, M, F, V ), let C0
concept satisfiable w.r.t. CircCP (, A). Let m0 maximal parameter occurring
number restrictions C0 . Set
n := max({rd(C0 )} {rd(C) | C(a) A}) := ((m0 + 1) (|A| + |C0 |))n+1 ,
show exists model J CircCP (, A) satisfying C0 #J m.
Let model CircCP (, A) exists d0 C0I . , fix
minimal set D(d) that,
every concept (> k r C) occurs C0 (> k r C)I exist
least k distinct e D(d) (d, e) rI e C
every concept (6 k r C) occurs C0 6 (6 k r C)I exist
least k + 1 distinct e D(d) (d, e) rI e C .
Clearly, #D(d) (m0 + 1) (|C0 | + |A|) . Next, define set D0
setting
D0 := {d0 } {aI | NI occurs C0 }.
748

fiThe Complexity Circumscription DLs

Define sets Di , 1 n, inductively
[
Di+1 := (
D(d))
dDi

set n :=



0in Di .

Define interpretation 0 domain follows:

0

aI = aI , individual names a;
0

r V , (d, e) rI n \ Dn , e D(d), (d, e) rI ;
0

V , AI = AI n ;
0

F , AI = AI .
0

straightforward inductive argument shows 0 model d0 C0I .
0
Note change interpretation F . Moreover, pI pI
every p . Together fact 0 model 0 6<CP I, even get
0
pI = pI every p . follows 0 model CircCP (, A) J <CP 0
would imply J <CP I.
0
Note rI n n , every role r. define interpretation J domain
J = n putting
0

AJ = AI n , every concept name A;
0

rJ = rI , every role name r;
aJ = aI , every individual name C0 .
still J model satisfying C0 . Moreover, interpretation J 0 <CP J
satisfying easily extended interpretation 00 <CP 0 satisfying A. Hence,
interpretation exists J model CircCP (, A). #n derive
#J m.
proof NExpNP -upper bound exactly proof Theorem
10; suffices replace bound 24k size interpretations bound m.

give lower bound matching upper bound Theorem 24.
Theorem 25 ALC, satisfiability w.r.t. role-minimizing cKBs empty TBox NExpNP hard. holds even one minimized role name fixed prediates
Proof. Theorem 15, ALC NExpNP -hard decide whether concept C0
satisfiable w.r.t. CircCP (, A), CP = (, M, , V ) contains concept names only.
Clearly, still NExpNP -hard decide whether exists common model C0
CircCP (, A) size least #M . Thus, sufficient provide polynomial reduction
problem satisfiability problem w.r.t. cKBs ALC single minimized
role remaining predicates varying. Suppose C0 CircCP (, A) given. Let
= {A1 , . . . , Ak } take
two fresh role names r0 , r1 ;
749

fiBonatti, Lutz, & Wolter

Boolean concepts C1 , . . . , Ck built using fresh concept names B1 , . . . , Bk
every Ci , k, satisfiable every Ci u Cj , 6= j, unsatisfiable. One take,
example, Ci = B1 u u Bi1 u Bi u Bi+1 u u Bk , k.
Let CP0 = (, {r0 }, , V {B1 , . . . , Bk , r1 }) define A0 C00 result replacing,
C0 , every occurrence Ai r0 .Ci , k. Finally, set = A0 {r1 .Ci (a) |
k}. show following:
() C0 satisfiable w.r.t. CircCP (, A) model size least #M if, if, C00
satisfiable w.r.t. CircCP0 (, ).
Let model CircCP (, A) C0 size least #M . Define interpretation 0
domain extending follows: take mutually distinct d1 , . . . , dk
interpret B1 , . . . , Bk , r0 , r1 , way
0

CiI = {di }, k,
0

r0I = {(d, di ) | AIi , k},
aI = d1 ,
0

r1I = {(d1 , d1 ), . . . , (d1 , dk )}.
readily checked 0 model C00 CircCP0 (, ).
Conversely, let model CircCP0 (, ) C00 . Define interpretation 0
0
extending AIi = (r0 .Ci )I , k. readily checked 0 model C0
CircCP (, A).

6.2 Role-minimizing cKBs Nonempty TBox
bounded model property proof above, important selection nodes
stops n iterations set n , n maximum role depths
concepts ABox concept C want satisfy. bound selection
nodes exist TBox non-empty, show reasoning w.r.t.
role-minimizing cKBs indeed undecidable case. proof reduction
-tiling problem (Berger, 1966).

N N

Definition 26 tiling problem quadruple triple P = (T, H, V ), finite
set tile types H, V horizontal vertical matching conditions.
solution P mapping :

N N

( (i, j), (i + 1, j)) H i, j 0;
( (i, j), (i, j + 1)) V i, j 0.
4
750

fiThe Complexity Circumscription DLs

Let P = (T, H, V ) instance tiling problem. define TBox TP follows:
> v x.> u y.>
> v
> v



u

u



tT

tT

u

(66)
At0
0



(67)

t0 T,t6=t



(t,t0 )H


x.At0 u

u

tT





(t,t0 )V

y.At0



> v N (x.y.B u y.x.B)
N

v

(68)
(69)
(70)

w x.D y.D

(71)

v x.D u y.D

(72)

Let CP = (, M, , V ) circumscription pattern V = {B, D} consists
remaining concept role names.
Lemma 27 CircCP (TP , ) 6|= D(a) iff P solution.
Proof. Assume P solution . Define interpretation follows:

xI
yI
AIt
NI
BI
DI
aI

:=
:=
:=
:=
:=
:=
:=
:=

NN

{((i, j), (i + 1, j)) | i, j 0}
{((i, j), (i, j + 1)) | i, j 0}
{(i, j) | (i, j) = t}

{(i, j) | > 0 j > 0}

(0, 0)

straightforward verify model TP . Additionally, clearly aI
/ DI .
thus remains show model J TP J <CP I. Assume
J . Since concept role names except B minimized, follows
1. xI = xJ = J J model (66);
2. AIt = AJ
Point 1 J model (67);
3. N = N J because, matter B J is, Point 1
(x.y.B u y.x.B)J = .
Thus J model (69), N = N J .
Thus, J differ interpretation concept names B,
varying. contradiction J <CP I.
Conversely, assume CircCP (TP , ) 6|= D(a), let model CircCP (TP , )
aI 6 DI . induction + j, define mapping assigns (i, j)
element (i, j) i, j 0,

N N

751

fiBonatti, Lutz, & Wolter

1. ((i, j), (i + 1, j)) xI ;
2. ((i, j), (i, j + 1)) ;
start, set (0, 0) = aI . `-th step, following:
Select ((0, ` 1), d) put (0, `) := d. exists
since model (66).
Select ((` 1, 0), d) xI put (`, 0) := d. Again,
exists since model (66).
let i, j > 0 + j = `. Since model (66), d, d0
((i 1, j), d) xI ((i, j 1), d0 ) . show = d0 ,
set (i, j) := d.
Assume contrary 6= d0 . (70)(72) since aI
/ DI ,

(i 1, j 1) N . Define new interpretation J obtained
following modifications:
(i 1, j 1) removed N ;
let d0 B J 6 B J ;
let DJ = .
Clearly, J <CP I. obtain contradiction model CircCP (TP , ),
thus remains show J model TP . suffices consider (69) (72),
concept inclusions referring N , B, D. axioms (70) (72) hold
DJ = . show (69), let e . show e C J C concept
right hand side (69). Clearly, e C J since e C , e {x, y, x , }reachable aI . e N e {x, y, x , }-reachable aI ,
otherwise would aI DI axioms (70) (72). Thus, e N J C J
e 6= (i 1, j 1). Finally, (i 1, j 1) C J , definition B J .

N N

define mapping : setting (i, j) := (i, j) . (67),
mapping well-defined. (68), satisfies horizontal vertical matching conditions.
Thus, P solution.

Thus, shown following result.
Theorem 28 ALC, satisfiability w.r.t role-minimizing cKBs undecidable.
6.3 Reasoning Role-minimizing cKBs Empty TBox ALCI
prove undecidability reasoning role-minimizing cKBs empty TBox ALCI.
proof uses spy-point technique (Areces, Blackburn, & Marx, 1999); namely,
show ABoxes simulate TBox reasoning employing inverse roles simulation
nominals circumscription. Using idea proof rather similar proof
Theorem 28.
752

fiThe Complexity Circumscription DLs

Let P instance tiling problem consider cKB CircCP (TP , ) defined
proof Lemma 27. simulate TBox axioms C v C 0 ABox assertions
((C C 0 ) u r0 .(C C 0 ))(a) enforcing role r0 connect relevant points a.
achieved forcing relevant points domain satisfy r0 .{a}. Since
nominals language use concept name instead {a} ensure
behaves nominal. present details.
sake readability, write concept assertions C(a) form : C
set 1 {r}.C = C u r.C. Let A, B 0 , N 0 fresh concept names r0 fresh role
name occurring TP . AP consists assertions
: 1 {r0 }.(C C 0 ),

(73)

C v C 0 TP ,
: A,

: 1 {r0 }.

u s.r

s=x,y




: 1 {r0 }. N 0 (A u B 0 ) r0 .(A u B 0 ) u
: 1 {r0 }.(N 0 D),


0 .A,

(74)

s.r

s=x,y


0 .(A

u B 0 )



: r0 .D

(75)

(76)

let CP = (, M, , {D, B, B 0 }), consists concept role names distinct
D, B, B 0 .
Lemma 29 CircCP (, AP ) 6|= D(a) iff P solution.
Proof. Assume P solution . Take interpretation proof Lemma 27
expanded
AI = {(0, 0)},

N 0I = ,

B 0I = ,

r0I = {(aI , d) | }.

show model CircCP (, AP ). Clearly, model AP . Thus remains
show model J AP J <CP I. Assume exists J <CP
model AP . minimized (74), AJ = {(0, 0)}. follows axiom
(66) encoded (73) ((0, 0), (1, 0)) xJ ((0, 0), (0, 1)) J . one prove
induction ` > 0 using axiom (66) encoded (73) (74) (i, j)
+ j = `, ((0, 0), (i, j)) r0J ((i, j), (i + 1, j)) xJ , ((i, j), (i, j + 1)) J .
follows xJ = xI J = . observe N 0J = because, matter
B 0 interpreted,

J

(A u B 0 ) r0 .(A u B 0 ) u
s.r0 .(A u B 0 )
= .



s=x,y

one prove similarly proof Lemma 27 J differ
interpretation B, B 0 , D, contradiction.
Conversely, suppose model CircCP (, AP ) aI 6 DI . first show
(aI , d) r0I whenever 6= aI {x, y}-reachable aI finite number
steps. Assume case. exist d, d0
753

fiBonatti, Lutz, & Wolter

= aI (aI , d) r0I ,
(d, d0 ) xI (d, d0 ) ,
(a, d0 ) 6 r0I .
(74), exists d00 aI 6= d00 , (d00 , d0 ) r0I , d00 AI . Observe
N 0I (76) aI 6 DI . Define new interpretation J modifying follows:
removed N 0I ;
let aI B 0J d00 6 B 0J ;
let DJ = .
Clearly J <CP I. obtain contradiction thus sufficient show J model
AP . Clearly, assertion AP containing neither D, B 0 , N 0 satisfied J .
remaining assertions except (75), follows DJ = satisfied J .
Finally, (75), observe N 0I {aI } {e | (aI , e) r0I } 6 DI assertions
(76). Thus, definition N 0J , consider point removed N 0I .

J

s.r0 .(A u B 0 )
definition J .
(A u B 0 ) r0 .(A u B 0 ) u



s=x,y

one use assertions (73) construct solution P way
proof Lemma 27.

thus proved following result.
Theorem 30 ALCI, satisfiability w.r.t. role-minimizing cKBs empty TBox undecidable.

7. Related Work
already pointed introduction circumscription one several
possible approaches nonmonotonic DLs that, order achieve decidability,
approaches adopt suitable restriction expressive power DL
component, non-monotonic features, interaction DL nonmonotonic features. section, survey existing approaches, discuss adopted
restrictions, relate DLs circumscription whenever possible. However,
point full-fledged formal comparison different approaches serious research endeavor outside scope paper. main approaches
nonmonotonic DLs (excluding relying integration DLs logic programming) summarized Table 1, n.a. stands analyzed specificity
column states whether formalism equipped priority mechanism based
specificity (i.e., subsumption) concepts.
start two early approaches based circumscription. work Brewka
(1987), frame system given nonmonotonic semantics based circumscription.
focus showing appropriateness proposed semantics, decidability
complexity reasoning analyzed. Cadoli et al. (1990), apply circumscription DL
754

fiThe Complexity Circumscription DLs

Ref
(Brewka, 1987)
(Cadoli, Donini, &
Schaerf, 1990)
(Padgham & Zhang,
1993)
(Straccia, 1993)
(Baader & Hollunder, 1995a)
(Baader & Hollunder, 1995b)
(Lambrix,
Shahmehri, & Wahlloef,
1998)
(Donini et al., 1997)

DL
frame lang.
< ALE

NM features
Circ
Circ

Complexity
n.a.
p2

Specificity

N

AL concrete domains
ALC

inheritance
networks
prioritized
default logic
default logic

n.a.



decidable



decidable

N

prioritized
default logic
prioritized
default logic

decidable



n.a.



MKNF
restrictions
MKNF
restrictions
maximized
typicality

depends DL

N

3-ExpTime

N

co-NExpNP

N

ALCF
ALC
ALQO+feature
agreement
decidable DL

(Donini et al., 2002)

ALC

(Giordano, Gliozzi,
Olivetti, & Pozzato,
2008)

ALC

Table 1: approaches nonmonotonic DLs

way here. authors consider non-prioritized circumscription
apply fragment description logic ALE. Decidability reasoning shown
reduction propositional reasoning Extended Closed World Assumption
(ECWA), p2 . best knowledge, first effective reasoning
method nonmonotonic description logic.
another early approach Padgham Zhang (1993), nonmonotonic DL obtained adaptation inheritance networks approach (Horty, 1994)
underlying DL essentially AL extended concrete data values. main contribution definition formalism discussion applications, decidability
complexity analyzed.
recent approach similar spirit circumscription taken Giordano
et al. (2008). authors extend ALC modal operator representing typicality,
maximize extension achieve nonmonotonic inferences. Decidability proved via
tableau algorithm establishes co-NExpNP upper bound subsumption.
lower bound given.
turn approaches based default logic (Reiter, 1980). nonmonotonic
DLs Baader Hollunder (1995a, 1995b), Straccia (1993), Lambrix et al. (1998)
share common restriction: default rules applied individual
name, is, denoted individual constant occurs explicitly
knowledge base. restriction motivated observation that, defaults
applied implicit (anonymous) individuals, reasoning becomes undecidable (Baader &
755

fiBonatti, Lutz, & Wolter

Hollunder, 1995a). Since models DL knowledge bases usually include large number
anonymous individuals due existential quantification, restriction introduces
strong asymmetry treatment individuals.
Another line nonmonotonic DLs (Donini et al., 1998, 1997, 2002) based first-order
autoepistemic logics whose interpretation domains restricted fixed denumerable
set constants. use unique domain resolves several issues related quantification
modal logics (such whether Barcan formula hold, whether different
worlds Kripke structure allowed different domains).
avoids asymmetry approaches based default logic because, definition,
individuals name. side coin domains finite varying
cardinality knowledge bases satisfy unique name assumption
dealt using rather technical encodings (such explicit axiomatization
finite domain represented concept name D).
first paper mentioned (Donini et al., 1998), decidability results apply
monotonic knowledge bases4 autoepistemic operator used nonmonotonic
fashion queries. restriction lifted subsequent publications.
make use logic minimal knowledge negation failure (MKNF),
equipped two (auto)epistemic operators K (Donini et al., 1997, 2002).
former paper (Donini et al., 1997), underlying monotonic fragment
description logic decidable instance checking problem. price payed
generality decidability results apply so-called simple knowledge bases,
quantifying-in (that is, quantification across modal operators, R.K C) allowed.
Nonetheless, KBs expressive enough model default rules. different restriction
explored Donini et al. (2002). underlying DL restricted ALC limited forms
quantifying-in allowed, so-called subjectively quantified ALCKN F knowledge bases.
Decidability results obtained subclass simple subjectively quantified knowledge
bases, whose nonmonotonic part restricted inclusions form KC v
> v C inferred knowledge base. restriction incompatible
traditional embedding (priority-free) circumscription autoepistemic logic,
based prerequisite-free default rules would equivalent inclusions
form K> v C.
recent line research integrating DLs logic programming rules introduces
nonmonotonic extensions DLs based negation-as-failure. approaches
(Eiter et al., 2004) use loosely coupled integration logic programs DLs,
interpretations DL component restricted logic program variables
range named DL individuals. Thus, approaches somewhat similar
classical extensions DLs based defaults nonmonotonic inferences
limited named individuals. recent approach (Motik & Rosati, 2007) based
MKNF shares MKNF-DLs discussed pros cons adopting fixed
denumerable domain. complexity reasoning underlying DL C 6 NP,
data complexity entailment bounded C C . Finally, mention 3-valued variant
approach (Knorr, Alferes, & Hitzler, 2007) based well-founded semantics.
4. autoepistemic operator used restricted contexts suffice encode so-called
procedural rules, monotonic.

756

fiThe Complexity Circumscription DLs

ALC

Concept circ.
Minim. roles
Fixed roles

#M n, #F n
(unrestricted)
TBox=
TBox6=

ALCQO
ALCI ALCIO
NExp
NP
NExpNP even = , either TBox= ABox=
NExpNP even #M 1, #F 0
Undecidable
Undecidable
Highly undecidable, even TBox= , =

Table 2: Summary complexity results satisfiability w.r.t. cKBs
common limitation nonmonotonic extensions DLs based MKNF
provide support specificity priorities. particular, defeasible inheritance
mentioned expressiveness analysis autoepistemic approaches (Donini et al.,
1997, 2002) appear goal MKNF-based approach. pointed
introduction, well-known that, propositional case, nonmonotonic logics
cannot modularly encode specificity-based priorities needed inheritance
mechanisms (Horty, 1994).

8. Conclusions Perspectives
shown circumscription provides elegant approach defining nonmonotonic
DLs, resulting formalisms appealing expressive power decidable
appropriate restrictions adopted. main restriction, leads rather
robust decidability results, concept names minimized fixed whereas
role names vary. empty TBoxes, decidability retained roles allowed
minimized, fixed. decidability complexity results obtained
paper listed detail Table 2. results Section 3, bounds
TBox 6= apply general acyclic TBoxes.
view paper promising step towards establishing circumscribed DLs
major family nonmonotonic DLs used practical applications. reach goal,
additional research topics addressed, mention two. First,
algorithms presented paper based massive non-deterministic guessing
thus admit efficient implementation. Ideally, one would algorithms
well-behaved extensions tableau algorithms underly state-of-the-art
DL reasoners (Baader & Sattler, 2000). crucial issue whether sophisticated optimization techniques implemented reasoners (tableaux caching, dependency-directed
backtracking etc.; cf. Baader et al., 2003, Chap. 9) adapted circumscribed DLs.
first steps made Grimm Hitzler (2008). Second, seems necessary
develop design methodology modelling defeasible inheritance. examples given
paper indicate main challenge find rules thumb determine
predicates fixed, varied, minimized. may appealing hide abnormality
predicates behind explicit syntax defeasible inclusions, trade generality
simplicity usability.
theoretical perspective, initial investigation leave open least
interesting questions. example, current techniques limited circumscribed DLs
757

fiBonatti, Lutz, & Wolter

finite model property. would desirable overcome limitation
obtain decidability results even expressive DLs SHIQ OWL.
possible follow opposite approach consider circumscribed versions inexpressive
DLs EL DL-Lite family (Baader, Brandt, & Lutz, 2005a; Calvanese,
Giacomo, Lembo, Lenzerini, & Rosati, 2007), currently popular large
number applications. First steps made Bonatti, Faella, Sauro (2009),
investigated circumscribed versions EL DL-lite.
Finally, worth mentioning complexity results circumscription
used prove complexity bounds other, seemingly unrelated, reasoning problems
description logic. example, certain reasoning services conservative extensions
modularity description logic satisfiability problem w.r.t. concept-circumscribed
knowledge bases mutually reducible polynomial time (Konev, Lutz,
Walther, & Wolter, 2008). many problems known NExpNP complete, circumscription thus provides new class problems potentially
employed give NExpNP lower bound proofs.

Acknowledgments
first author partially supported network excellence REWERSE, IST-2004506779. third author partially supported UK EPSRC grant no. GR/S63182/01.

Appendix A. Missing Proofs Section 3
Lemma 5. ALC, satisfiability w.r.t. (concept-)circumscribed KBs empty TBox
without fixed roles polynomially reduced satisfiability w.r.t. (concept-)circumscribed KBs empty TBox without fixed predicates.
Proof. proof Lemma 4, used TBox axioms state fresh
concept names interpreted complement fixed concept names. general,
cannot done using ABox assertions only. Instead, construct ABox assertions
force case objects relevant truth given ABox.
care required using ABox assertions polynomial size. first part
proof deals problem. second part straighforward modification
proof Lemma 4.
first part proof consists introducing notation proving central
technical claim. w = r1 rn NR , interpretation I, d, e , write

(d, e) wI iff d0 , . . . , dn = d0 , e = dn , (di , di+1 ) ri+1

< n.
Let N set individual names Paths mapping N powerset NR .
interpretation well-behaved mapping Paths every ,
N w Paths(a) (aI , d) wI . ALC-concept C, associate
set P(C) pairs (w, D) w NR subconcept C follows:
C NC , P(C) = {(, C)};
C = D, P(C) = {(, C)} P(D);
758

fiThe Complexity Circumscription DLs

C = D1 u D2 C = D1 D2 , P(C) = {(, C)} P(D1 ) P(D2 );
C = r.D C = r.D, P(C) = {(, C)} {(rw, E) | (w, E) P(D)}.
set ABox assertions individual name a, use P(S, a) denote set

C(a)S P(C). write Paths(S, a) {w | : (w, D) P(S, a)}. formulate
announced claim.
Claim 1. Suppose CircCP (, A) 6|= C0 (a0 ), CP contain fixed role names
C0 (a) formulated ALC. Let = {C0 (a0 )} let N set individual
names S. Let 0 restriction that, N
w Paths(S, a), (aI , d) wI . 0 model CircCP (, A)
C0 (a0 ) well-behaved mapping Paths(a) = Paths(S, a), N .
prove claim. Let model CircCP (, A) aI0 (C0 )I . Note
0
N , Paths(S, a) thus aI . Clearly, 0 well-behaved
Paths. One prove induction C
0

() N , (w, C) P(S, a), (aI , d) wI , C iff
0
CI .
show case C = r.D, leave cases reader. Let C .
e DI (d, e) rI . Since (w, C) P(S, a), (wr, D) P(S, a).
0
Since (aI , d) wI , (aI , e) (wr)I . Thus, e induction hypothesis
0
0
0
yields e DI . definition 0 semantics, C . let C .
0
0
e DI (d, e) rI . definition 0 , (d, e) rI . Since (w, C) P(S, a),
(wr, D) P(S, a). Since (aI , d) wI , (aI , e) (wr)I . Thus, induction
hypothesis yields e DI .
Thus, () established. Using () facts aI0 (C0 )I model
0
0
A, hard verify aI0 (C0 )I 0 model A. show
0 model CircCP (, A). Assume contrary model J 0
J 0 <CP 0 . Define interpretation J follows:
J = ;
AJ = AI F ;
0

AJ = AJ V ;
0

rJ = rJ r NC ;
bJ = bI b NI .
Using assumption CP contain fixed role names, hard verify
J <CP I. obtain contradiction fact model CircCP (, A),
thus remains show J model A. end, prove induction C
0

() N , (w, C) P(S, a), J (aJ , d) wJ , C J iff
0
CJ .
Since induction step proof (), induction start. Thus, let
C = NC . V , done definition J . let F . Since 0
759

fiBonatti, Lutz, & Wolter

0

0

0

0

restriction AJ = AI , definition J yields AJ J = AJ , required.
finishes proof claim.
prove Lemma 5, consider instance checking instead satisfiability. Since
provided polynomial reductions satisfiability (non)-instance checking vice
versa Section 2, nevertheless obtain desired result. Let CircCP (, A) cKB
CP = (, M, F, V ) F = {A1 , . . . , Ak }. Take concept assertion C0 (a0 ). Let
= {C0 (a0 )} N set individual names S. Define
0 = {A1 , . . . , Ak , A01 , . . . , A0k }, A0i fresh concept names;
A0 = {w.(A0i Ai )(a) | w Paths(S, a), N , k};
CP0 = (, 0 , , V ).
CircCP (, A) |= C0 (a0 ) iff CircCP0 (, A0 ) |= C0 (a0 ) follows immediately Claim 1
fact Paths(S, a) = Paths(S 0 , a), 0 = A0 C0 (a0 ).

Lemma 6 C0 satisfiable w.r.t. CircCP (T , A) iff C0 u B 0 satisfiable w.r.t. CircCP0 (T 0 , A).
Proof. Suppose model C0 CircCP (T , A). Expand interpretation 0
setting
0
0
0
0
0
AI = B 0I = , B = A0I = , uI = .
Clearly, 0 model C0 u B 0 (T 0 , A). show 0 model CircCP0 (T 0 , A).
Assume contrary model J (T 0 , A) J <CP0 0 . A0J = ,
AJ = , B J = , B 0 J = . Since u varying J <CP0 0 , thus easy
show J <CP I. contradicts fact model CircCP (T , A).
Conversely, suppose model C0 u B 0 CircCP0 (T 0 , A). show
model C0 CircCP (T , A). First observe AI = . suppose
case. Define new interpretation J way except uJ = ,
B J = , B 0J = . J <CP0 (since B 0I 6= ) J model (T 0 , A). Thus
derived contradiction. follows C = hence model (T , A)
C0 . remains show J <CP J model (T , A).
Assume J exists. C J = . Define model J 0 expanding J follows:
0

0

AJ = B 0J = ,

0

0

B J = A0J = ,

0

uJ = .

Note A, B, A0 , B 0 , u interpreted way, J 0 <CP0 I.
Moreover, J 0 model (T 0 , A). derived contradiction.

Lemma 8 L DL, simultaneous satisfiability w.r.t. (concept) circumscribed KBs
CircCP1 (T1 , A1 ), . . . CircCPk (Tk , Ak ), CircCPi (Ti , Ai ) CircCPj (Tj , Aj ) share
role names 1 < j k, reduced satisfiability w.r.t. single (concept)
circumscribed KBs polynomial time.
Proof. suffices reduce simultaneous satisfiability without shared role names complement instance checking w.r.t. single cKBs. generalization straightforward,
give proof case k = 2. Thus, let L DL CircCP1 (T1 , A1 ), CircCP2 (T2 , A2 )
760

fiThe Complexity Circumscription DLs

cKBs formulated L share role names, C0 L-concept. Moreover, let
A0 , . . . , An1 concept names shared two cKBs, R role names used
least one two cKBs together fresh role name r0 , CPi = (i , Mi , , Vi )
{1, 2}. obtain new TBox T20 T2 replacing concept name Ai , < n,
new concept name A0i . Let A02 obtained A2 CP02 = (02 , M20 , F20 , V20 )
CP2 way. Define TBox follows, P fresh concept name:
Ai u A0i v P < n
Ai u A0i v P < n
P
r.P

v r.P r R
v P r R

set:


:= T1 T20

:= A1 A02 {r0 (b1 , b2 ) | b1 , b2 occur A1 A2 T1 T2 }
:= 1 02


:= M1 M20

F

:= F1 F20

V

:= V1 V20 {P, r0 }

CP := (, M, F, V )
Let a0 individual name A1 (clearly, may assume A1 6= ). remains
show following:
Claim. C0 simultaneously satisfiable w.r.t. CircCP1 (T1 , A1 ) CircCP2 (T2 , A2 ) iff a0
instance (P u r0 .C0 ) w.r.t. CircCP (T , A).
If. Assume a0 instance (P u r0 .C0 ) w.r.t. CircCP (T , A).
model CircSCP (T , A) aI0 (P u r0 .C0 )I . call connected directed
graph GI = (I , rR rI (r )I ) connected. connected component 0
0
0
restriction domain (maximal) connected component GI .
may assume without loss generality chosen model connected:
not, use role r0 ensures connected component 0
contains bI individual names b A1 A2 T1 T2 . easy see 0
0
0
model CircCP (T , A) aI0 (P u r0 .C0 )I , thus may simply replace 0 .
show C0 simultaneously satisfiable respect CircCP1 (T1 , A1 )
CircCP2 (T1 , A2 ). Clearly, model C0 . construction CircCP (T , A),
model T1 , A1 . show model CircCP1 (T1 , A1 ), assume
contrary case. exists model J T1 A1
J <CP1 I. Define model J 0 follows:
0

J = J ;
predicates used T1 A1 interpreted J ;
predicates used T20 A02 interpreted I.
761

fiBonatti, Lutz, & Wolter

(
P

J0

:=

0



((Ai u A0i ) (Ai u A0i ))J 6= < n



otherwise

0

0

r0J = J J .
readily checked J 0 model A, J 0 <CP I. Thus,
derived contradiction fact model CircCP (T , A), follows
model CircCP (T1 , A1 ).
remains show model CircCP (T2 , A2 ). Since connected, model
, satisfies aI0
/ P , AIi = (A0i )I < n. Therefore,
model T2 A2 . Analogously case CircCP1 (T1 , A1 ), show
model CircCP2 (T2 , A2 ).
if. Assume C0 simultaneously satisfiable w.r.t. cKBs CircCP1 (T1 , A1 )
CircCP2 (T2 , A2 ). exists model C0 model CircCP1 (T1 , A1 )
CircCP2 (T2 , A2 ). modify new model 0 setting
0

(A0i )I := AIi < n;
0

P := ;
0

r0I := .
0

0

easy see 0 model A, aI (P u r0 .C0 )I . show
a0 instance (P u r0 .C0 ) w.r.t. CircCP (T , A), thus remains prove
0 model CircCP (T , A). this, first show following:
(a) 0 model CircCP1 (T1 , A1 ). case since model J T1 A1
J <CP1 0 satisfies J <CP1 I. Thus, existence model contradicts
fact model CircCP1 (T1 , A1 ).
(b) 0 model CircCP02 (T20 , A02 ). Assume contrary model J T20

:= (A0i )J
A02 J <CP02 0 . Convert J interpretation J setting AJ



< n. Then, J model T2 A2 satisfies J <CP2 I.
contradiction fact model CircCP2 (T2 , A2 ).
Now, assume contrary shown model J 0
J 0 <CP 0 . definition CP, J 0 <CP 0 implies either J 0 <CP1 0
J 0 <CP02 0 hold. Since J 0 clearly satisfies T1 , A1 , T20 , A02 , obtain contradiction
(a) (b).


Appendix B. Missing Proofs Section 4
Lemma 14 G yes-instance co-3CERTCOLS iff CG satisfiable w.r.t. CircCPG (, AG ),
CPG = (, M, F, V ) = , = {Root, Leaf, Clash},
F = {LeafFix, Tr, X0 , . . . , Xn1 , Y0 , . . . , Yn1 , },
V set remaining predicates AG .
762

fiThe Complexity Circumscription DLs

Proof. If. Suppose CG satisfiable w.r.t. CircCPG (, AG ) let model
6= . show G yes-instance co-CERT3COL .
CircCPG (, AG ) CG

start, show
I.
(I) aI0 CG
6= aI .
Assume contrary case. CG
0
, RootI . Let J interpretation obtained setting
Since CG
RootJ = {aI0 }. definition AG , aI0 RootI , thus J CPG I. Moreover,
easily seen J model AG . thus established contradiction
fact model CircCPG (, AG ), proves (I).
Lines (1)-(4) (Fig. 2), elements di,w (the nodes tree) 2n
w {0, 1}i

aI0 = d0, ;
di,w XjI iff j + 1-st bit w 1, 2n j min{i, n 1};
di,w YjI iff n + j + 1-st bit w 1, i, j n < 2n j n;
(di,w , di+1,w0 ), (di,w , di+1,w1 ) rI , < 2n;
d2n,w Leaf , w {0, 1}2n .
i, j < 2n , use `i,j denote element d2n,w w {0, 1}2n denotes
binary encoding followed j. show
(II) Leaf = {`i,j | i, j < 2n }.
Assume contrary case, i.e., Leaf
6= `i,j i, j < 2n . Let id , jd > 0 integers truth values X0 , . . . , Xn1
encode id truth values Y0 , . . . , Yn1 encode jd . Starting I, construct
interpretation J setting
Leaf J
rJ

:= Leaf \ {d}
:= (rI \ (I d)) {(e, `id ,jd ) | (e, d) rI }

modify J J 0 setting
PJ

0

:= (r2n .var1.Leaf)J
(r2n .var2.Leaf)J
(r2n .col1.Leaf)J
(r2n .col2.Leaf)J

going Lines (1) (26), straightforward check J 0 model AG .
Moreover, clearly J 0 <CPG I, thus obtain contradiction fact
model CircCPG (, AG ). thus shown (II).
following easy consequence (I), fact P conjunct CG ,
Lines (8), (9), (20), (21):
(III) (`i,j , d) rI implies Leaf i, j < 2n , , r {var1, var2, col1, col2}.
763

fiBonatti, Lutz, & Wolter

suppose contrary aim prove G yes-instance. Then,
truth assignments t, subgraph t(G) 3-colorable. particular, holds
assignment defined setting, i, j < 2n ,

t(Vij ) := 1 iff `i,j TrI .

Let c : {0, . . . , 2n 1} {R, G, B} 3-coloring t(G) construct interpretation
J starting applying following modifications:

CJ
ClashJ

= {`i,0 | < 2n , c(i) = C} C {R, G, B}
= .

Clearly, J <CPG I: minimized predicate Clash empty J , non-empty since
non-empty. obtain contradiction, thus suffices show J model
CG
AG .
Since J agree predicates R, G, B, Clash, inclusions
mention concepts satisfied J . Lines (1) (21). Lines (22) (23)
2n J
satisfied construction J since, due Line (5) (II), (aJ
0 , d) (r )
n
implies = `i,j i, j < 2 . thus remains consider Lines (24) (26). first
show
(IV) i, j < 2n , (i, j) edge t(G) iff `i,j
/ ElimJ .
Let i, j < 2n let potential edge (i, j) labeled Vk1 ,k2 Vk3 ,k4 (since
(i)
(i)
circuits cS cj deliver output input, assume potential,
non-existing edges label). (II) (III) together Lines (8) (9),
var1J = var1I = {`k1 ,k2 } var2J = var2I = {`k3 ,k4 }. Thus, definition together
Lines (12) (16) yields (i, j) edge t(G) iff `i,j
/ ElimI . prove (IV),
remains note J interpret concept name Elim way.
2n J
Now, prove (24) (26) satisfied J . Let (aJ
0 , d) (r ) . Line 5
J
n
(II), = `i,j i, j < 2 . Let `i,j
/ Elim . (IV) since c 3-coloring
t(G), get c(i) 6= c(j). Thus, construction J , `i,0
/ C J `j,0
/ C J
C {R, G, B}. (II) (III) together Lines (18) (19), col1J = col1I = {`i,0 }
col2J = col2I = {`j,0 }. Therefore, `i,j
/ (col1.C u col2.C)J C {R, G, B}.
J
Since holds `i,j
/ Elim , preconditions implications Lines (24)
(26) never satisfied. Thus, implications satisfied.

if. Suppose G yes-instance let truth assignment
t(G) 3-colorable. Let c : {0, . . . , 2n 1} {R, G, B} color assignment
minimizes (w.r.t. set inclusion) set {(i, j) | (i, j) edge G c(i) = c(j)}. Define
interpretation follows (here following, distinguish
number binary encoding string):
764

fiThe Complexity Circumscription DLs


RootI

= {di,w | 2n , w {0, 1}i }
= {d0, }



= {d2n,w | w {0, 1}2n }

LeafFixI

= {d2n,w | w {0, 1}2n }

Leaf

XjI

= {di,w | j + 1-st bit w 1, 2n, j min{i, n 1}};

YjI


= {di,w | n + j + 1-st bit w 1, n < 2n, j n};

Tr

= {d2n,ij | t(Vij ) = 1}

TrI`

= {d2n,ij | t(Vij ) cS (i, j)}

(`)

(` = 1, 2)

Elim



= {d2n,ij | (i, j) edge t(G)}

C



= {d2n,i0 | c(i) = C} (C = R, G, B)



= {d2n,ij | (i, j) edge t(G) c(i) = c(j)}

r



= {(di,w , di+1,w0 ), (di,w , di+1,w1 ) | < 2n}

var1



= {(d2n,ij , d2n,kl ) | first variable label (i, j) Vkl }

var2



= {(d2n,ij , d2n,kl ) | second variable label (i, j) Vkl }



col1

= {(d2n,ij , d2n,i0 ) | < 2n }

col2I

= {(d2n,ij , d2n,j0 ) | < 2n }

Clash

PI

=

aI0

= d0, .

Boolean circuit c, corresponding output concept name Outc interpreted
OutIc := {d2n,ij | i, j < 2n c(i, j) true}.

show CG satisfiable w.r.t. CircCPG (, AG ), suffices show aI0 CG
model CircCPG (, AG ). former easy: recall CG = RootuP ur2n .Clash.
definition I, aI0 (Root u P )I . Since c 3-coloring, aI0 (r2n .Clash)I .
thus remains show model CircCPG (, AG ). Since easy verify
model AG , boils showing model J AG J <CPG I.
Assume contrary J . Lines (1)(5) since J model
AG , #Leaf J 22n . Since #Leaf = 22n J <CPG I, get Leaf J = Leaf .
similar simpler reasons, RootJ = RootI . Thus, J <CPG implies ClashJ ( ClashI .
Lines (1) (5) since J models AG Leaf J = Leaf #Leaf =
#Leaf J = 22n ,

J
2n J
(I) {d | (aI0 , d) (r2n )I } = {d J | (aJ
0 , d) (r ) } = Leaf = Leaf

Thus, Lines (24) (26) fact J model AG ensure

(II) C{R,G,B} (Leaf u Elim u col1.C u col2.C)J ClashJ .
Define coloring c0 setting
c0 (i) = C iff d2n,i0 C J
Suppose
765

(C = R, G, B).

fiBonatti, Lutz, & Wolter

(III) (a) ElimI Leaf = ElimJ Leaf ,
(b) col1I (Leaf Leaf ) = col1J (Leaf J Leaf J ),
(c) col2I (Leaf Leaf ) = col2J (Leaf J Leaf J ).
(II) guarantees (i, j) edge G c0 (i) = c0 (j), d2n,ij ClashJ .
Since ClashJ ( ClashI , get
1. c0 (i) = c0 (j), c(i) = c(j);
2. i, j c0 (i) 6= c0 (j), c(i) = c(j).
contradicts initial minimality assumption coloring c.
thus remains prove (III). start (a). Assume
(d) var1I (Leaf Leaf ) = var1J (Leaf J Leaf J )
(e) var2I (Leaf Leaf ) = var2J (Leaf J Leaf J ).
Then, Lines (12) (16) together (I) fact TrI = TrJ implies (a). thus
remains prove (b) (e). concentrate (b) cases analogous. Take
(d, d0 ) col1I (Leaf Leaf ). = d2n,ij d0 = d2n,i0 j 0 i, j, i0 , j 0 < 2n .
Line (18), i0 = j 0 = 0. (I) Lines (17) (18) since J
agree interpretation X0 , . . . , Xn1 , Y0 , . . . , Yn1 , e LeafFixJ
(d2n,ij , e) col1J , value encoded X0 , . . . , Xn1 e J i, value
encoded Y0 , . . . , Yn1 e J 0. Since LeafFixI = LeafFixJ , LeafFixJ =
Leaf J . However, single element Leaf J X0 , . . . , Xn1 encodes
Y0 , . . . , Yn1 encodes 0 d2n,i0 = d0 . converse direction analogous.

Corollary 16 ALC, satisfiability w.r.t. concept-circumscribed KBs NExpNP -hard
even TBox acyclic, ABox preference relations empty,
fixed predicates.
Proof. ABox AG reduction given Section 4.2.1 form {C0 (a0 )}
circumscription pattern CPG empty preference relation. thus suffices
show polynomial reduction satisfiability w.r.t. concept-circumscribed KBs
form satisfiability w.r.t. concept-circumscribed KBs acyclic TBox, empty
ABox preference relation, fixed predicates.
Let CircCP (, A) concept-circumscribed KB = {C0 (a0 )} CP = (
, M, V, F ) = , let C ALC concept. Define = {A v u.C0 },
concept name occur C u role name
occur C. define CP0 = (, M, V {u}, F {A}). C satisfiable w.r.t.
CircCP (, A) iff u C satisfiable w.r.t. CircCP0 (T , ):
If. u C satisfiable w.r.t. CircCP0 (T , ), model CircCP0 (T , )
d0 (A u C)I . Thus, e0 C0I . Modify obtain new interpretation
J setting aJ
0 = e0 . Clearly, J model C. show model
CircCP (, A), assume contrary model J 0 J 0 <CP J . Modify
0
0
J 0 interpretation 0 setting AI = AI uI = . readily checked
0 model 0 <CP0 I, thus obtained contradiction fact
model CircCP0 (T , ).
766

fiThe Complexity Circumscription DLs

if. C satisfiable w.r.t. CircCP (, A), model CircCP (, A)
d0 C . Let J defined I, except AJ = {d0 } uJ = . Clearly,
J model u C. show J model CircCP (T , ), assume
0
contrary model J 0 J 0 <CP0 J . Since fixed CP0 , d0 AI ,
0
0
thus d0 (u.C0 )J e0 C0J . Modify J 0 new interpretation 0
0
setting aI0 = e0 . readily checked 0 model 0 <CP I, thus
obtained contradiction fact model CircCP0 (, A). get rid fixed
predicates, suffices apply Lemma 5.


Appendix C. Missing Proofs Section 5
show semantic consequence problem reduced instance checking
w.r.t. role-fixing cKBs ALC. already proved ALC extended
universal role. fact, remaining problem approximate concepts u.C using ALC concepts state extension C contains points within certain,
sufficiently large neighbourhood.
construct approximation, first introduce local version notion
frame validity concepts. pointed R-frame pair (F, d) F F
R-frame. concept C valid pointed R-frame (F, d), symbols (F, d) |= C, iff
C every interpretation based F. R finite set role names,
R.C denotes C = 0,

N

m1 R.C u

u r.

m1

rR

R.C

> 0. follows, use concepts form R.C approximations
u.C. remind reader correspondence results modal logic. Let transA =
s.A s.s.A contA = s.A r.A. well known (Blackburn & van
Benthem, 2007) easy prove every {r, s}-frame F, following holds:
transA valid F if, if, sF transitive;
contA valid F if, if, rF sF .
Say d0 F {r, s}-reachable F (d, d0 ) (rF sF ) call F
root F every d0 F {r, s}-reachable F. F {r, s}-frame root
d, following conditions equivalent:
1 {r, s}.(transA u contA ) valid (F, d);
sF transitive rF sF .
observations used proof Lemma 31 below. before, sometimes write
concept assertions C(a) form : C. Recall role depth rd(C) concept C
defined nesting depth constructors r.D r.D, r R, C.
Lemma 31 Let C ALC {r} -concepts sharing concept names let
fresh concept name. Let CP = (, M, {r, s}, V ) circumscription pattern,
consists concept names C V consists concept names D. Let
individual name. following conditions equivalent:
767

fiBonatti, Lutz, & Wolter

1. {r, s}-frames F rF sF sF transitive: F |= C, F |= D;
2. pointed {r, s}-frames (F, d):
(F, d) |= 1 {r, s}.(transA u contA u C)



(F, d) |=

3. instance 1 {r, s}.(transA u contA u C) w.r.t. CircCP (, A),
= {a : (1 {r, s}.(transA u contA u C) 1+max {2,rd(C)} {r, s}.

u B)}.

BM

Proof. Point 1 implies Point 2. Suppose Point 2 hold. Let (F, d) pointed
{r, s}-frame (F, d) |= 1 {r, s}.(transA u contA u C) (F, d) 6|= D. may
assume root F. (F, d) |= 1 {r, s}.(transA u contA ) obtain rF sF
sF transitive. Therefore, (F, d) |= 1 {s}.C obtain F |= C. follows F
frame refuting Point 1.
follows use, every , d,I denote set e
{r, s}-reachable 1 + max {2, rd(C)} steps.
Point 2 implies Point 3. Suppose Point 3 hold. Let model CircCP (, A)

aI (1 {r, s}.(transA u contA u C) u D)I .

(77)

Let based F set := aI . show (F, d) |= 1 {r, s}.(transA u contA u C)
(F, d) 6|= D. latter easy witnessed interpretation I. show former,
let J interpretation based F. show (1 {r, s}.(transA u contA u C))J .
(77) since model CircCP (, A), aI (1+max {2,rd(C)} {r, s}.
B)I .

u

BM

follows immediately
B = d,I ,

(78)

B . distinguish two cases:
B J d,I , B . Since J based frame concept
names contA , transA , C , truth 1 {r, s}.(transA u contA u C)
depends truth value concept names d,I only. (78)
obtain B d,I = B J d,I , B . Hence, (77), (1 {r, s}.(transA u
contA u C))J , required.
B J 6 d,I , least one B .
0

Let J 0 modification J B J = B J d,I , B . (78), J 0 <CP
0
I. (1 {r, s}.(transA u contA u C))J , J 0 model
contradiction fact model CircCP (, A). Thus, (1 {r, s}.(transA u
0
contA u C))J . Since, again, truth 1 {r, s}.(transA u contA u C) depends
truth value B d,I only, (1 {r, s}.(transA u contA u C))J ,
required.
768

fiThe Complexity Circumscription DLs

Point 3 implies Point 1. Suppose Point 1 hold. Consider frame F sF
transitive, rF sF , F |= C, F 6|= D. follows F |= transA u contA . Let
interpretation based F (D)I . may assume root F.
may assume B = d,I B (since B occurs D) aI = d.
aI (1 {r, s}.(transA u contA u C) u D))I model A. remains show
exist 0 <CP
0

aI (1 {r, s}.(transA u contA u C) 1+max {2,rd(C)} {r, s}.

u B)

I0

BM

.

straightforward: (F, d) |= 1 {r, s}.C, obtain exist
0
0
0 (1 {r, s}.C)I clearly exist B B B
0
(1+max {2,rd(C)} {r, s}.B)I .

position prove reduction ALC.
Theorem 22 logical consequence problem MSO(r) effectively reducible
instance problem w.r.t. role-fixing cKBs formulated ALC. even holds
TBox preference relation empty.
Proof. Theorem 20, logical consequence problem MSO(r) effectively reducible
modal consequence problem ALC {r} -concepts. Hence, suffices reduce
modal consequence problem ALC {r} -concepts. Let ALC {r} -concepts C given.
may assume C concept names common (if have, replace
every concept name B new concept name B 0 denote resulting concept
D0 ; noted above, C iff C D0 .) Let CP = (, M, {s, r}, V ) = ,
consists concept names C, V consists concept names D. Let
= {a : (1 {r, s}.(transA u contA u C) 1+max {2,rd(C)} {r, s}.

u B)}

BM

C0 = 1 {r, s}.(transA u contA u C) D. equivalence Point 1 Point 3
Lemma 31, CircCP (, A) |= C0 (a) if, if, frames F rF sF sF
transitive, F |= C follows F |= D. C contain s,
CircCP (, A) |= C0 (a)



C D.


References
Areces, C., Blackburn, P., & Marx, M. (1999). road-map complexity hybrid logics.
Proceedings Eighth Annual Conference EACSL (CSL99), No. 1683
Lecture Notes Computer Science, pp. 307321. Springer-Verlag.
Areces, C., Blackburn, P., & Marx, M. (2000). computational complexity hybrid
temporal logics. Logic Journal IGPL, 8 (5), 653679.
Baader, F., Brandt, S., & Lutz, C. (2005a). Pushing EL envelope. Kaelbling, L. P.,
& Saffiotti, A. (Eds.), Proceedings Nineteenth International Joint Conference
Artificial Intelligence (IJCAI05), pp. 364369. Professional Book Center.
769

fiBonatti, Lutz, & Wolter

Baader, F., Milicic, M., Lutz, C., Sattler, U., & Wolter, F. (2005b). Integrating description logics action formalisms reasoning web services. LTCSreport LTCS-05-02, Chair Automata Theory, Institute Theoretical Computer Science, Dresden University Technology, Germany. See http://lat.inf.tudresden.de/research/reports.html.
Baader, F., & Hollunder, B. (1995a). Embedding defaults terminological knowledge
representation formalisms.. Journal Automated Reasoning, 14 (1), 149180.
Baader, F., & Hollunder, B. (1995b). Priorities defaults prerequisites, application treating specificity terminological default logic.. Journal Automated
Reasoning, 15 (1), 4168.
Baader, F., McGuiness, D. L., Nardi, D., & Patel-Schneider, P. (2003). Description
Logic Handbook: Theory, implementation applications. Cambridge University
Press.
Baader, F., & Sattler, U. (2000). Tableau algorithms description logics. Dyckhoff,
R. (Ed.), Proceedings International Conference Automated Reasoning
Tableaux Related Methods (Tableaux2000), Vol. 1847 Lecture Notes Artificial
Intelligence, pp. 118. Springer-Verlag.
Berger, R. (1966). undecidability dominoe problem. Memoirs American
Mathematical Society, 66.
Blackburn, P., & van Benthem, J. (2007). Modal logic: semantic perspective. Handbook
Modal Logic. Elsevier.
Blackburn, P., de Rijke, M., & Venema, Y. (2001). Modal Logic. Cambridge University
Press.
Bonatti, P., Faella, M., & Sauro, L. (2009). Defeasible inclusions low-complexity DLs:
Preliminary notes. Proceedings 21st International Joint Conference Artificial Intelligence (IJCAI09). AAAI Press.
Bonatti, P., Lutz, C., & Wolter, F. (2006). Expressive non-monotonic description logics
based circumscription. Proceedings Tenth International Conference
Principles Knowledge Representation Reasoning (KR06), pp. 400410. AAAI
Press.
Bonatti, P. A., & Eiter, T. (1996). Querying disjunctive databases nonmonotonic
logics.. Theoretical Computer Science, 160 (1&2), 321363.
Bonatti, P. A., & Samarati, P. (2003). Logics authorization security. Logics
Emerging Applications Databases, pp. 277323. Springer-Verlag.
Borgida, A. (1996). relative expressiveness description logics predicate logics.
Artificial Intelligence, 82 (1 - 2), 353367.
Brewka, G. (1987). logic inheritance frame systems. Proceedings 10th
International Joint Conference Artificial Intelligence (IJCAI87), pp. 483488. Morgan Kaufmann.
770

fiThe Complexity Circumscription DLs

Brewka, G. (1994). Adding priorities specificity default logic.. Proceedings
Logics Artificial Intelligence (JELIA94), Vol. 838 Lecture Notes Computer
Science, pp. 247260. Springer-Verlag.
Cadoli, M., Donini, F., & Schaerf, M. (1990). Closed world reasoning hybrid systems.
Proceedings 6th International Symposium Methodologies Intelligent
Systems (ISMIS90), pp. 474481. Elsevier.
Calvanese, D., Giacomo, G. D., Lembo, D., Lenzerini, M., & Rosati, R. (2007). Tractable
reasoning efficient query answering description logics: DL-lite family. Journal Automated Reasoning, 39 (3), 385429.
Cote, R., Rothwell, D., Palotay, J., Beckett, R., & Brochu, L. (1993). systematized
nomenclature human veterinary medicine. Tech. rep., SNOMED International,
Northfield, IL: College American Pathologists.
de Kleer, J., & Konolige, K. (1989). Eliminating fixed predicates circumscription.
Artificial Intelligence, 39 (3), 391398.
Donini, F. M., Lenzerini, M., Nardi, D., Nutt, W., & Schaerf, A. (1998). epistemic
operator description logics.. Artificial Intelligence, 100 (1-2), 225274.
Donini, F. M., Nardi, D., & Rosati, R. (1997). Autoepistemic description logics. Proceedings Fifteenth International Joint Conference Artificial Intelligence (IJCAI97), pp. 136141. Morgan Kaufmann.
Donini, F. M., Nardi, D., & Rosati, R. (2002). Description logics minimal knowledge
negation failure. ACM Transactions Computational Logic, 3 (2), 177225.
Eiter, T., Gottlob, G., & Mannila, H. (1997). Disjunctive Datalog. ACM Transactions
Database Systems, 22 (3), 364418.
Eiter, T., Lukasiewicz, T., Schindlauer, R., & Tompits, H. (2004). Combining answer set
programming description logics semantic web. Proceedings
Ninth International Conference Principles Knowledge Representation
Reasoning (KR 2004), pp. 141151.
Giordano, L., Gliozzi, V., Olivetti, N., & Pozzato, G. L. (2008). Reasoning typicality
preferential description logics. Proceedings Logics Artificial Intelligence
(JELIA08), Vol. 5293 Lecture Notes Computer Science, pp. 192205. SpringerVerlag.
Goldblatt, R. (2003). Mathematical modal logic: view evolution. Journal Applied
Logic, 1, 309392.
Gradel, E., Otto, M., & Rosen, E. (1997). Two-Variable Logic Counting Decidable.
Proceedings Twelfth IEEE Symposium Logic Computer Science (LICS97),
pp. 306317. IEEE Computer Society Press.
Grimm, S., & Hitzler, P. (2008). Defeasible inference circumscriptive OWL ontologies.
Proceedings Workshop Advancing Reasoning Web: Scalability
Commonsense, No. 350 CEUR-WS (http://ceur-ws.org/).
Horrocks, I., Sattler, U., & Tobies, S. (2000). Practical reasoning expressive description logics. Logic Journal IGPL, 8 (3), 239264.
771

fiBonatti, Lutz, & Wolter

Horty, J. F. (1994). direct theories nonmonotonoc inheritance. Handbook
Logic Artificial Intelligence Logic Programming-Nonmonotonic Reasoning
Uncertain Reasoning(Volume 3), pp. 111187. Clarendon Press.
Janhunen, T. (1999). intertranslatability non-monotonic logics. Annals Mathematics Artificial Intelligence, 27 (1-4), 79128.
Kagal, L., Finin, T., & Joshi, A. (2003). policy language pervasive computing
environment. Fourth IEEE International Workshop Policies Distributed
Systems Networks (POLICY2003).
Knorr, M., Alferes, J. J., & Hitzler, P. (2007). well-founded semantics hybrid MKNF
knowledge bases. Proceedings 2007 International Workshop Description
Logics (DL2007), No. 250 CEUR-WS (http://ceur-ws.org/).
Konev, B., Lutz, C., Walther, D., & Wolter, F. (2008). Semantic modularity module extraction description logics. Proceedings 18th European Conference
Artificial Intelligence (ECAI), pp. 5559.
Lambrix, P., Shahmehri, N., & Wahlloef, N. (1998). default extension description
logics use intelligent search engine. : Proceedings Thirty-First
Annual Hawaii International Conference System Sciences (HICSS98)-Volume 5,
p. 2835. IEEE Computer Society.
Lifschitz, V. (1985). Computing circumscription. Proceedings Ninth International Joint Conference Artificial Intelligence (IJCAI85), pp. 121127. Morgan
Kaufmann.
Lifschitz, V. (1993). Circumscription. Handbook Logic AI Logic Programming 3, pp. 298352. Oxford University Press.
Lifschitz, V. (1995). Nested abnormality theories. Artificial Intelligence, 74 (2), 351365.
McCarthy, J. (1980). Circumscription: form nonmonotonic reasoning. Artificial Intelligence, 13, 2739.
McCarthy, J. (1986). Applications circumscription formalizing common sense knowledge. Artificial Intelligence, 28, 89116.
Minsky, M. (1975). framework representating knowledge. Winston, P. H. (Ed.),
Psychology Computer Vision, pp. 211277. McGraw-Hill.
Moore, R. C. (1985). Semantical considerations nonmonotonic logics. Artificial Intelligence, 25, 7594.
Motik, B., & Rosati, R. (2007). Faithful Integration Description Logics Logic
Programming. Proceedings Twentieth International Joint Conference
Artificial Intelligence (IJCAI2007), pp. 477482. Morgan Kaufmann.
Pacholski, L., Szwast, W., & Tendera, L. (2000). Complexity results first-order twovariable logic counting. SIAM Journal Computing, 29 (4), 10831117.
Padgham, L., & Zhang, T. (1993). terminological logic defaults: definition
application. Proceedings Thirteenth International Joint Conference
Artificial Intelligence (IJCAI93), pp. 662668. Morgan Kaufmann.
772

fiThe Complexity Circumscription DLs

Pratt-Hartmann, I. (2005). Complexity two-variable fragment counting quantifiers. Journal Logic, Language, Information, 14 (3), 369395.
Quillian, M. R. (1968). Semantic memory. Semantic Information Processing, pp. 227270.
MIT Press.
Rector, A. (2004). Defaults, context, knowledge: Alternatives OWL-indexed knowledge bases. Proceedings Pacific Symposium Biocomputing (PSB04), pp.
226237. World Scientific.
Rector, A., & Horrocks, I. (1997). Experience building large, re-usable medical ontology
using description logic transitivity concept inclusions. Proceedings
Workshop Ontological Engineering, AAAI Spring Symposium. AAAI Press.
Reiter, R. (1980). logic default reasoning. Artificial Intelligence, 13, 81132.
Stevens, R., Aranguren, M. E., Wolstencroft, K., Sattler, U., Drummond, N., Horridge,
M., & Rector, A. (2005). Using OWL model biological knowledge. International
Journal Man-Machine Studies, 65 (7), 583594.
Stewart, I. A. (1991). Complete problems involving Boolean labelled structures projection transactions. Journal Logic Computation, 1 (6), 861882.
Straccia, U. (1993). Default inheritance reasoning hybrid KL-ONE-style logics..
Proceedings Thirteenth International Joint Conference Artificial Intelligence
(IJCAI93), pp. 676681. Morgan Kaufmann.
Thomason, S. (1975a). logical consequence relation propositional tense logic.
Zeitschrift fur Mathematische Logik und Grundlagen der Mathematik, 21, 2940.
Thomason, S. (1975b). Reduction second-order logic modal logic. Zeitschrift fur
Mathematische Logik und Grundlagen der Mathematik, 21, 107114.
Tobies, S. (2000). complexity reasoning cardinality restrictions nominals
expressive description logics. Journal Artificial Intelligence Research, 12, 199217.
Tonti, G., Bradshaw, J. M., Jeffers, R., Montanari, R., Suri, N., & Uszok, A. (2003). Semantic web languages policy representation reasoning: comparison KAoS,
Rei, Ponder. Proceedings Second International Semantic Web Conference
(ISWC03), Vol. 2870 Lecture Notes Computer Science, pp. 419437. SpringerVerlag.
Uszok, A., Bradshaw, J. M., Johnson, M., Jeffers, R., Tate, A., Dalton, J., & Aitken, S.
(2004). KAoS policy management semantic web services. IEEE Intelligent Systems,
19 (4), 3241.
Wolter, F., & Zakharyaschev, M. (2007). Modal decision problems. Handbook Modal
Logic. Elsevier.
Y. Ding, V. H., & Wu, J. (2007). new mapping ALCI ALC. Proceedings
2007 International Workshop Description Logics (DL2007), No. 250 CEURWS (http://ceur-ws.org/).

773


