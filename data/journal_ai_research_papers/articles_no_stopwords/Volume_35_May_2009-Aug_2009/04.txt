Journal Artificial Intelligence Research 35 (2009) 813857

Submitted 03/09; published 08/09

Modularity Aspects Disjunctive Stable Models
Tomi Janhunen
Emilia Oikarinen

Tomi.Janhunen@tkk.fi
Emilia.Oikarinen@tkk.fi

Helsinki University Technology
Department Information Computer Science
P.O. Box 5400, FI-02015 TKK, Finland

Hans Tompits
Stefan Woltran

tompits@kr.tuwien.ac.at
woltran@dbai.tuwien.ac.at

Technische Universitt Wien
Institut fr Informationssysteme
Favoritenstrae 911, A-1040 Vienna, Austria

Abstract
Practically programming languages allow programmer split program
several modules brings along several advantages software development.
paper, interested area answer-set programming fully declarative
nonmonotonic languages applied. context, obtaining modular structure
programs means straightforward since output entire program cannot
general composed output components. better understand effects
disjunctive information modularity restrict scope analysis case
disjunctive logic programs (DLPs) subject stable-model semantics. define notion
DLP-function, well-defined input/output interface provided, establish
novel module theorem indicates compositionality stable-model semantics
DLP-functions. module theorem extends well-known splitting-set theorem
enables decomposition DLP-functions given strongly connected components
based positive dependencies induced rules. setting, possible split
shared disjunctive rules among components using generalized shifting technique.
concept modular equivalence introduced mutual comparison DLP-functions
using generalization translation-based verification method.

1. Introduction
Practically programming languages used software development allow programmer
split program several modules interact well-dened input/output
interfaces. Given this, entire program viewed composition component modules typically linked together respective run-time environment.
expected benets modular program development manifold. First, imposes
good programming style followed programmer. complex software system
much easier develop set interacting components rather monolithic program. Second, modular architecture allows additional exibility regards delegating
programming tasks amongst team programmers. setting, goal programmer implement desired input/output behavior(s) terms concrete module(s)
together implement software system developed. Third, modular program
c
2009
AI Access Foundation. rights reserved.

fiJanhunen, Oikarinen, Tompits & Woltran

design exploited order boost execution programs. Program optimization facilitated structural information encompassed module interfaces.
Answer-set programming (ASP) (Marek & Truszczyski, 1999; Niemel, 1999; Gelfond
& Leone, 2002) paradigm declarative problem solving solutions problems
described terms rules subject nonmonotonic semantics based stable models
(Gelfond & Lifschitz, 1988). typical problem representations, tight correspondence
solutions stable models sought for, default negation fully exploited
order obtain concise encodings relations involved problem descriptions.
Furthermore, recursive denitions enable, e.g., representation closures relations
natural way. Due ecient implementations emerging applications,
paradigm received increasing attention past two decades.1 meantime,
number extensionssuch disjunctions, weight constraints, aggregateshave
proposed basic syntax normal logic programs. paper, concentrate
class disjunctive logic programs (DLPs) appropriate solving search problems
residing second level polynomial-time hierarchy. semantical account
DLPs based respective generalization stable-model semantics (Gelfond &
Lifschitz, 1991).
paper, goal investigate modularity context DLPs stablemodel semantics. Since stable models dened complete programs,
lend modular programming prima facie. Perhaps reason, concept
module yet raised much attention realm answer-set programming.
Except dedicated papers (Gaifman & Shapiro, 1989; Eiter, Gottlob, & Veith, 1997b;
Baral, Dzifcak, & Takahashi, 2006), modules mostly appeared by-product studies
formal properties stratication, splitting, or, lately, work equivalence
relations programs (Lifschitz & Turner, 1994; Eiter, Gottlob, & Mannila, 1997a;
Eiter, Ianni, Lukasiewicz, Schindlauer, & Tompits, 2008). recent approach Oikarinen
Janhunen (2008a), modular architecture put forth Gaifman Shapiro (1989)
accommodated classes normal smodels programs. main result
module theorem links stable models associated individual modules
composition. result signicant indicates stable models
compositional much sense classical models propositional logic.
major restriction implied module theorem denition set
positively interdependent atoms must given within module.
Besides general benets modular program development discussed above,
looking potential computational advantages modularizing reasoning tasks ASP.
context, search stable models probably central reasoning task.
Results module theorem discussed provide basis modularizing
search task. Extra care, however, required computation stable models
modules separation necessarily ecient. sophisticated methods,
identifying cones influence Boolean circuits (Junttila & Niemel, 2000), devised
identify modules relevant search stable modelsthe rest used
expand qualied stable model one entire program. strategy alleviates
treatment extremely large program instances amenable query evaluation.
1. 20th anniversary stable-model semantics celebrated ICLP08 held Udine,
Italy, December 2008.

814

fiModularity Aspects Disjunctive Stable Models

Unfortunately, contemporary disjunctive answer-set solvers, claspd (Drescher
et al., 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al., 2006),
gnt (Janhunen, Niemel, Seipel, Simons, & You, 2006), exhibit little support modular
reasoning although related techniques strongly connected components exploited internally. reasoning tasks boosted modular approach.
instance, optimization answer-set programs gives rise problem verifying
whether dierent versions programs answer sets. demonstrated
Oikarinen Janhunen (2009), verication tasks may benet modularization,
and, particular, approximation techniques based modular equivalence introduced.
Following idea, rst modular o-line optimizer answer-set programs, called modopt, recently implemented (Janhunen, 2008b).
interesting applications modules sight: Gebser et al. (2008a)
propose incremental technique answer-set solving. idea gradually extend
program instance terms additional modules, e.g., solving AI planning problems.
Moreover, theoretical results splitting-set theorem (Lifschitz & Turner, 1994)
module theorem directly exploited correctness proofs. instance, proved
Oikarinen Janhunen (2008b) models prioritized circumscription
captured disjunctive stable models using particular translation. similar proof
strategy adopted Theorem 8.5 paper.
anticipate compositional semantics prove useful one tries boost
search stable models via parallelization, e.g., computing stable models modules
parallel. However, order avoid excessive communication costs, extra caution needed
stable models computed separation linked together potentially rejected.
One possibility identify mutually independent modules basis distribution.
Besides aspect, modularization may lead novel methods (non-parallelized)
computation stable models, traditional ones.
Structure Preview Results paper, concentrate formal underpinnings modular programming context disjunctive logic programs
stable-model semantics. proceed follows. rst goal generalize theory
developed normal programs smodels programs (Oikarinen & Janhunen, 2008a)
case disjunctive programs. end, rst introduce notion DLPfunction Section 2. term goes back Gelfond Gabaldon (1999) introduced
LP-functions (partial) denitions new relations terms old, known ones. enable functional view disjunctive programs, endowed well-dened
input/output interface. idea partition signature program encapsulated
way input atoms, output atoms, hidden (or local ) atoms. distinctions
provide basis systematic composition larger disjunctive logic programs
program modules. However, arbitrary combinations program modules meaningful and, rst all, adopt syntactic restrictions introduced Gaifman Shapiro
(1989) context negation/disjunction-free logic programs. interplay default negation disjunctions brings along new factors lead relaxation
restrictions sense program modules allowed share rules. Then,
basic syntactic issues DLP-functions laid out, concentrate semantics
Section 3. respect, follow strict model-theoretic approach and, particular,
815

fiJanhunen, Oikarinen, Tompits & Woltran

address role input atoms comes viewing DLP-functions mathematical
functions. proceed step step assign three dierent classes models
DLP-function, viz. classical models, minimal models, stable models. last provides
appropriate generalization disjunctive stable models (Gelfond & Lifschitz, 1991)
presence input atoms.
second objective establish adequacy concept DLP-function
view compositional semantics. witnessed main result paper,
viz. module theorem shows stable models DLP-function, ,
alternatively obtained unions compatible stable models modules constituting
. proof theorem based notions completion (Clark, 1978) loop
formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003) rst lifted case DLPfunctions Section 4 preparatory step. proof module theorem follows
main topic Section 5. result non-trivial underlying semantics based
stable models inherently nonmonotonic. feature already recognized Gaifman
Shapiro (1989) much simpler setting denite programsneither involving default
negation disjunctions. observed them, too, syntactic restrictions program
composition necessary order guarantee compositionality properties semantics
based Herbrand models.2 current paper, strive analogous results
case programs permitting default negation disjunctions. turns
strongly connected components positive dependency graphs provide key criterion
comes conning program composition. compositionality properties disjunctive
programs stable-model semantics arisen context so-called
splitting-set theorem (Lifschitz & Turner, 1994; Eiter et al., 1997a, 2008). fact,
module theorem established herein proper generalization predecessor (Oikarinen &
Janhunen, 2008a). illustrate potential modular architecture evaluation
quantied Boolean formulas (QBFs), serve canonical representatives classes
polynomial-time hierarchy (PH). Due basic complexity results established Eiter
Gottlob (1995), natural perspective concentrate second level
PH case disjunctive programs.
third aim paper look particular applications module theorem disjunctive logic programming. Section 6, take opposite view
modular construction DLP-functions consider possibilities decomposition
even absence structural information. turns strongly connected
components exploited respect but, addition, occurrences hidden
atoms must taken account splitting DLP-function components.
demonstrated Section 7, results open new prospects regards unwinding disjunctions
using principle shifting (Gelfond, Przymusinska, Lifschitz, & Truszczyski, 1991; Dix,
Gottlob, & Marek, 1996; Eiter, Fink, Tompits, & Woltran, 2004). proper generalization
principle partially covers programs involving head-cycles formulated
proved correct. Moreover, due modular nature DLP-functions, makes perfect
sense compare modules. notion modular equivalence introduced
purpose Section 8. Interestingly, modular equivalence supports substitutions equivalent
programs lends translation-based verification put forth Oikarinen
2. main concern Gaifman Shapiro (1989) modularity respect logical consequences
definite program hence intersection Herbrand models.

816

fiModularity Aspects Disjunctive Stable Models

Janhunen (2004, 2009) related cases ordinary equivalence smodels programs. Section 9 contrasts approach related work. Finally, Section 10 provides
brief summary results concludes paper.

2. Class DLP-Functions
topic section syntax DLP-functions well syntactic restrictions
imposed composition DLP-functions. disjunctive rule expression form
a1 b1 , . . . , bm , c1 , . . . , ck ,

(1)

n, m, k 0, a1 , . . . , , b1 , . . . , bm , c1 , . . . , ck propositional atoms. Since
order atoms considered insignicant, write B, C shorthand rules
form (1), = {a1 , . . . , }, B = {b1 , . . . , bm }, C = {c1 , . . . , ck } respective
sets atoms. basic intuition behind rule B, C atom
positive body B inferred none atoms negative body C,
atom head inferred. B C empty, disjunctive
fact, written . empty, constraint, written B, C.
disjunctive logic program (DLP) conventionally formed nite set disjunctive
rules. Additionally, want distinguished input output interface DLP.
end, extend denition originally proposed Gaifman Shapiro (1989) case
disjunctive programs.3 natural interface imposes certain restrictions
rules allowed module. Given set R disjunctive rules, write At(R)
signature R, i.e., set (ground) atoms eectively appearing rules R.
Definition 2.1 DLP-function, , quadruple hR, I, O, Hi, I, O, H
pairwise distinct sets input atoms, output atoms, hidden atoms, respectively, R
DLP rule B, C R,
1. B C H,
2. 6= , (O H) 6= .
DLP-function = hR, I, O, Hi occasionally identied R and, slight abuse
notation, write B, C denote B, C R. rst condition
Denition 2.1, rules DLP-function must obey interface specication ,
i.e., At(R) H. regards sets atoms I, O, H involved module
interface, atoms considered visible hence accessible
DLP-functions conjoined ; either produce input utilize output
. hand, hidden atoms H used formalize auxiliary concepts
may make sense context DLP-functions may save space
substantially demonstrated, e.g., Janhunen Oikarinen (2007, Example 4.5).
second condition Denition 2.1 concerned set atoms H defined
rules R. principle non-empty disjunctive head must involve least one
atom H. ensure DLP-function must interfere
3. Similar approaches within area ASP previously introduced Gelfond Gabaldon
(1999), Janhunen (2006), Oikarinen Janhunen (2008a).

817

fiJanhunen, Oikarinen, Tompits & Woltran

denitions input atoms terms rules B, C satisfying I.
otherwise, rules may conditioned input atoms.4 Given set atoms,
distinguish set rules dene atoms R, i.e., set defining rules
Def R (S) = {A B, C R | 6= }.

(2)

next objective specify conditions composition DLP-functions
may take place. Roughly speaking, idea larger DLP-functions formed
modular fashion using smaller DLP-functions components. observed already
Gaifman Shapiro (1989), syntactic restrictions program composition necessary
order guarantee compositionality properties semantics based Herbrand models, even simple case denite programs. Thus, program union operator
composition without restrictions satisfactory respect compositionality.
start adapting construction Gaifman Shapiro (1989) case
disjunctive programs.
Definition 2.2 Two DLP-functions 1 = hR1 , I1 , O1 , H1 2 = hR2 , I2 , O2 , H2 respect input/output interfaces
1. (I1 O1 H1 ) H2 = ,
2. (I2 O2 H2 ) H1 = ,
3. O1 O2 = ,
4. Def R1 (O1 ) = Def R1 R2 (O1 ),
5. Def R2 (O2 ) = Def R1 R2 (O2 ).
rst three conditions due Gaifman Shapiro (1989)
imply sets O1 , H1 , O2 , H1 mutually pairwise distinct. Violations
respect rst two conditions circumvented renaming strategy.
instance, atom H1 appears I2 O2 H2 , hence violating second condition,
possible replace occurrences 1 new atom 6 I2 O2 H2
appearing 2 . removes conict respect forth.5
hand, last two conditions Denition 2.2 concern distribution
rules involved definitions (2) sets atoms O1 O2 , i.e., sets rules
Def R1 (O1 ) Def R2 (O2 ), R1 R2 , respectively. regards disjunctive rules,
principle sets dening rules must remain intact union R1 R2
formed means module supposed copies rules form
denition output atoms. spite this, two modules 1 2 subject
conditions Denition 2.2 may eectively share disjunctive rules B, C
non-empty head O1 6= O2 6= , demonstrated next.
4. particular, input atoms head rule act much atoms negative body C.
5. opposite view program composition considered Section 6, possibilities decomposing disjunctive program smaller DLP-functions studied. counterpart renaming,
revealing operator introduced Definition 7.3 used circumventing first two conditions
Definition 2.2.

818

fiModularity Aspects Disjunctive Stable Models

Example 2.3 Consider following two DLP-functions:6
{b}
b c;
a,
{a, c}



{a}
b c;
e a, e
{b, c}

formally, 1 = hR1 , {a, c}, {b}, {d}i 2 = hR2 , {b, c}, {a}, {e}i
R1 R2 = {a b c}. show 1 2 respect input/output interfaces
other: First, hidden atoms e occur exactly one two programs
thus first two conditions Definition 2.2 satisfied. Second, disjoint output
atoms, viz. atom b 1 atom 2 . Finally, Def R1 ({b}) = Def R1 R2 ({b}) =
Def R2 ({a}) = Def R1 R2 ({a}) = {a b c}, shows final two conditions
Definition 2.2 satisfied, far syntax concerned, makes sense compose
larger DLP-function obtained kind union 1 2 ; see (4) below.
contrast disjunctive programs, shared rules arise context normal
logic programs since one head atom allowed rule. stated
smodels programs (Simons, Niemel, & Soininen, 2002) although programs
may contain, among rule types, choice rules form
{a1 , . . . , } B, C

(3)

heads cardinality greater one. observed Oikarinen Janhunen (2008a),
heads choice rules possessing multiple atoms freely split without aecting
semantics. splitting rules n dierent rules {ai } B, C
1 n, concern creation n copies rule body B, C could
reserve quadratic space worst case. new atom introduced circumvent
this. nature proper disjunctive rules (1), subject study paper,
somewhat dierent. Unlike choice rules, disjunctive rules may interact rule heads.
Example 2.3, denition depends b vice versa. However, given choice rule
{a, b} c instance, choices regarding b independent other: c
true, atoms truth value. quite dierent interpretation
ab c makes either b true given c true. grasp interaction
b natural b input denition and, conversely, input
b. demonstrated Section 7, shared rules rewritten input atoms
removed rule head drawback rewriting technique, compactness
representation partly lost. Therefore, appreciate extra exibility provided
shared rules interpret reect true nature disjunctive rules.
general, DLP-functions composed according following principle:

6. henceforth make use tabular format represent DLP-functions: output signature
given top, input signature bottom, rules listed between. Thus,
declaration hidden signature remains implicit.

819

fiJanhunen, Oikarinen, Tompits & Woltran

O2
L

I1
H1

H2
I2

=

O1

I1 O2

O2

H2

I1

I1 I2

I2

H1

O1

O1 I2

Figure 1: Treatment signatures composition operator .
Definition 2.4 (Composition) Let 1 = hR1 , I1 , O1 , H1 2 = hR2 , I2 , O2 , H2
two DLP-functions respect input/output interfaces other. Then, composition 1 2 defined determined
1 2 = hR1 R2 , (I1 \ O2 ) (I2 \ O1 ), O1 O2 , H1 H2 i.

(4)

treatment atom types Denitions 2.2 2.4 summarized Figure 1.
two symmetric gures left-hand side illustrate signatures DLP-functions
1 = hR1 , I1 , O1 , H1 2 = hR2 , I2 , O2 , H2 subject composition. Input signatures
output signatures emphasized light gray dark gray shadings, respectively.
superposition two gures yields diagram given right represents
resulting nine categories atoms. three may involve shared atoms
originate 1 2 . interface conditions introduced intuitive
readers acquainted principles object-oriented programming:
1. Although 1 2 must share hidden atoms, may share input atoms, i.e.,
I1 I2 6= allowed. Output atoms treated dierently O1 O2 = assumed.
2. input atom 1 becomes output atom 1 2 appears output
atom 2 , i.e., 2 provides input 1 setting. input atoms 2
treated symmetric fashion.
3. hidden atoms 1 2 retain status 1 2 .
Example 2.5 Recall Example 2.3 showed DLP-functions 1 2 respect
input/output interfaces other. Thus, composition 1 2 defined,
1 2 hR1 R2 , I, O, Hi set input atoms ({a, c} \ {a}) ({b, c} \ {b}) =
{c}, set output atoms {a} {b} = {a, b}, set H hidden atoms
{d} {e} = {d, e}, i.e., using tabular format represent modules,
{b}
b c;
a,
{a, c}



{a}
b c;
e a, e
{b, c}

=

{a, b}
b c;
a, d;
e a, e
{c}

definitions b 1 2 share rule b c. Thanks flexibility
Definition 2.4, able split 1 2 components whenever appropriate.
820

fiModularity Aspects Disjunctive Stable Models

Following previous approaches (Gelfond & Gabaldon, 1999; Oikarinen & Janhunen,
2008a), dene signature At() DLP-function = hR, I, O, Hi H.7
notational convenience, distinguish visible hidden parts At() setting
Atv () = Ath () = H = At() \ Atv (), respectively. Moreover, Ati ()
Ato () used refer sets input output atoms , respectively.
notations provide us way access module interface left implicit, e.g.,
neglect internal structure modules. Lastly, set At() atoms, denote projections Ati (), Ato (), Atv (), Ath () Si , , Sv , Sh ,
respectively.
formal terms, DLP-function = hR, I, O, Hi designed provide mapping
subsets set subsets H analogy LP-functions formalized
Gelfond Gabaldon (1999). However, exact denition mapping deferred
Section 3 semantics DLP-functions anchored. sequel,
(syntactic) class DLP-functions denoted D. assumed, sake simplicity,
spans xed (at denumerable) signature At(D)8 At() At(D)
holds DLP-function D. Given DLP-functions 1 , 2 , 3 pairwise
respect input/output interfaces other, holds
1 2 (closure),
1 = 1 = 1 , empty DLP-function = h, , , (identity),
1 2 = 2 1 (commutativity),
1 (2 3 ) = (1 2 ) 3 (associativity).
theory modules put forth Oikarinen Janhunen (2008a) based
restrictive operator program composition, viz. join . idea behind operator
forbid positive dependencies programs explicated next.
Technically speaking, dene positive dependency graph DG+ () DLP-function
= hR, I, O, Hi using positive dependenciesfollowing denition Ben-Eliyahu
Dechter (1994). However, exclude input atoms graph denitions
external anyway. Thus, let DG+ () = hO H, 1 b 1 holds
pair atoms a, b H rule B, C R
b B. reexive transitive closure 1 gives rise dependency relation
Ato () Ath (). strongly connected component (SCC) graph DG+ ()
maximal set Ato () Ath () b every pair a, b atoms. Given
1 2 dened, say 1 2 mutually dependent DG+ (1 2 )
SCC Ato (1 ) 6= Ato (2 ) 6= (Oikarinen & Janhunen,
2008a), i.e., component shared DLP-functions 1 2 way. 1
2 mutually dependent, call mutually independent.
Definition 2.6 (Joins) Given two DLP-functions 1 2 , composition 1 2
defined 1 2 mutually independent, join, 1 2 , 1 2
defined coincides 1 2 .
7. Consequently, length symbols, denoted kk, gives upper bound |At()|
important one considers computational cost translating programs (Janhunen, 2006).
8. practice, set could set identifiers (names propositions similar objects).

821

fiJanhunen, Oikarinen, Tompits & Woltran

case 1 2 dened, thus 1 2 mutually independent, exactly
one following conditions holds SCC DG+ (1 2 ):
Ato (1 ) Ath (1 );

(5)

Ato (2 ) Ath (2 ).

(6)

Example 2.7 Recall programs 1 2 Example 2.5 obtain
positive dependency graph DG+ (1 2 ) = h{a, b, d, e}, {ha, di, ha, ei}i. Hence, SCCs
graph simply singletons {a}, {b}, {d}, {e}. Together observation
Ato (1 ) Ato (2 ) disjoint, derive 1 2 mutually dependent.
Thus, join 1 2 = 1 2 defined since composition 1 2 defined
basis analysis performed Example 2.5.
Example 2.8 example two DLP-functions composition defined
yet ineligible join, consider following situation:
{b}
b c;
b a, c
{a, c}



{a}
b c;
b, c
{b, c}

=

{a, b}
b c;
b, c;
b a, c
{c}

Here, result composition involves SCC = {a, b} respective positive dependency graph, non-empty intersection output signatures programs
subject composition. Hence, respective join modules question defined.

3. Model Theory Stable-Model Semantics
syntax DLP-functions dened, turn semantics. proceed
three steps introduce, correspondingly, three kinds models, viz. classical models,
minimal models, and, nally, stable models DLP-function. last provide
intended semantics DLP-function whereas rst two serve auxiliary concepts.
usual, interpretation DLP-function dened arbitrary subset
At(). Given particular interpretation At(), atom At() true ,
denoted |= a, , otherwise false , denoted 6|= a. negative
literal a, dene |= 6|= a. set L literals satisfied , denotedWby
|= L, |= l, everyWliteral l L. dene disjunctive interpretation L
set L literals: |= L |= l literal l L.
begin with, cover DLP-functions pure classical semantics, treats
disjunctive rules classical implications. emphasized classical models
DLP-function specic interpretations dened hence subsets At().
Definition 3.1 interpretation At() (classical) model DLP-function
= hR, I, O, Hi, denoted |= , iff |= R, i.e., every rule B, C R,
W
|= B C implies |= A.
822

fiModularity Aspects Disjunctive Stable Models

set classical models denoted CM().
Classical models provide appropriate level abstraction address role input
atoms DLP-functions. Given DLP-function interpretation At(),
projection Mi viewed actual input may (or may not) produce
respective output Mo , depending semantics assigned . treatment input
atoms sequel based partial evaluation: idea pre-interpret input
atoms appearing respect Mi .
Definition 3.2 DLP-function = hR, I, O, Hi actual input Mi ,
instantiation respect Mi , denoted /Mi , quadruple hR , , O, Hi
R contains reduced rule
(A \ I) (B \ I), (C \ I)

(7)

rule B, C R Mi |= Ai Bi Ci .
Example 3.3 Consider following DLP-function :
{a, b}
b c;
c, b;
b c,
{c}
actual input {c} Ati (), reduct /{c} DLP-function
h{a b; b a}, , {a, b}, i.
hand, actual input Ati (), obtain reduct
/ = h{a b}, , {a, b}, i.
rules form (7) free input atoms indicates reduct /Mi
DLP-function without input. Atoms Ato () Ath () aected /Mi .
Proposition 3.4 Let DLP-function At() interpretation defines
actual input Mi Ati () . interpretations N At() Ni = Mi ,
N |= Nh |= /Mi .
Proof. Consider N At() Ni = Mi .
(=) Suppose N |= . Assume Nh satisfy (7) rule
B, C . follows Mi |= Ai Bi Ci , therefore Ni |= Ai Bi Ci .
Thus, N 6|= B, C, contradiction. follows Nh |= /Mi .
(=) Let Nh |=W/Mi hold. Assuming N 6|= B, C rule implies
N |= B C N 6|= A. follows Ni |= Ai Bi Ci corresponding
rule (7) included /Mi Ni = Mi . rule satised Nh since
823

fiJanhunen, Oikarinen, Tompits & Woltran

W
N 6|= B, C implies Nh |= (B \ I) (C \ I) Nh 6|= (A \ I),
contradiction. Hence, N |= .

Thus, input reduction, given Denition 3.2, fully compatible classical
semantics characterize semantic operator CM terms equation
[
{Mi N | N CM(/Mi )}.
(8)
CM() =
Mi Ati ()

Recall models DLP-function subsets At(). Hence,
N CM(/Mi ) subset At(/Mi ) thus Mi N = Mi Ati ()
since atom Ati () occurs /Mi denition.
Handling input atoms slightly complicated case minimal models
primitives parallel circumscription (Lifschitz, 1985; McCarthy, 1986) provide us
straightforward way address them. rough idea keep interpretation input
atoms fixed minimizing (i.e., falsifying) others far possible.
Definition 3.5 Let = hR, I, O, Hi DLP-function. model At()
I-minimal iff model N Ni = Mi N .
sequel, set I-minimal models = hR, I, O, Hi denoted MM()
treat input atoms stipulating I-minimality models. Using idea, Proposition 3.4
lifts minimal models given fact Ati (/Mi ) = .
Proposition 3.6 Let DLP-function At() interpretation defines
actual input Mi Ati () . interpretations N At() Ni = Mi ,
N MM() Nh MM(/Mi ).
Proof. Consider N At() Ni = Mi .
(=) Let N MM(). follows Proposition 3.4 Nh |= /Mi . Assume
Nh
/ MM(/Mi ). Recall Ati (/Mi ) = . Thus, interpretation
Nh |= /Mi . follows Proposition 3.4 N |=
interpretation N = Mi S. Ni = Ni N N jointly contradict N MM().
(=) Suppose Nh MM(/Mi ). So, Nh |= /Mi , N |= follows
Proposition 3.4. Let us assume N 6 MM(), i.e., model N |=
Ni = Ni N N . Thus, (No Nh ) (No Nh ), since Ni = Ni = Mi
follows Nh |= /Mi Proposition 3.4. Then, however, Nh |= /Mi
contradiction Nh MM(/Mi ).

set MM() Ati ()-minimal models sucient determine semantics
positive DLP-function , i.e., whose rules form B. Recall
rules \ Ati () 6= holds whenever 6= . order cover arbitrary DLP-functions,
interpret negative body literals way proposed Gelfond Lifschitz (1991).
Definition 3.7 Given DLP-function = hR, I, O, Hi interpretation At(),
reduct respect positive DLP-function = hRM , I, O, Hi
RM = {A B | B, C R |= C}.
824

(9)

fiModularity Aspects Disjunctive Stable Models

Definition 3.8 interpretation At() stable model DLP-function
input signature Ati () iff MM(M ), i.e., Ati ()-minimal model .
Hidden atoms play special role Denition 3.8. contrast this, aect
possibilities program decomposition, presented Section 6, status
nally explicated notion modular equivalence introduced Section 8.
Denition 3.8 covers case ordinary disjunctive logic program, simply
DLP-function = hR, , O, i: model At() = stable
minimal model RM . denition stable models gives rise semantic operator
At(D)
SM : 22
DLP-functions:
SM() = {M At() | MM(M )}.

(10)

Proposition 3.6 provides us way dismiss Ati ()-minimality denition stable
models desirable. Given stable model , projection N = Mo Mh minimal
model (/Mi )N hence stable model /Mi . words,
(/Mi )M = (/Mi )Mo Mh = /Mi .
Thus, derive following result:
Corollary 3.9 DLP-function ,
SM() = {M At() | Mo Mh SM(/Mi )}.
Example 3.10 Recall DLP-function Example 3.3, hidden atoms,
given follows:
{a, b}
b c;
c, b;
b c,
{c}
four stable models total: M1 = {a}, M2 = {b}, M3 = {a, c}, M4 = {b, c},
{c}-minimal models respective reducts :
M1
M2
M3
M4

= h{a b ; c}, {c}, {a, b}, i,
= h{a b ; b c}, {c}, {a, b}, i,
= h{a c}, {c}, {a, b}, i,
= h{b c}, {c}, {a, b}, i.

Now, easy verify Mj {c}-minimal model reduct Mj .
illustrating Corollary 3.9, recall reducts
/{c} = h{a b; b a}, , {a, b},
/ = h{a b}, , {a, b}, i.
Then, SM(/{c}) = {{a}, {b}} SM(/) = {{a}, {b}}.
825

fiJanhunen, Oikarinen, Tompits & Woltran

immediate observation loose general antichain property stable
models input signatures introduced. instance, M1 M3 M2 M4
Example 3.10. However, since interpretation input atoms xed semantics,
perceive antichains locally, i.e., set {N SM() | Ni = Mi } stable models forms
antichain, input Mi Ati (). Example 3.10, sets stable models associated
actual inputs {c} {M1 , M2 } {M3 , M4 }, respectively.

4. Characterizations using Classical Logic
well known set stable models ordinary disjunctive logic program, i.e.,
DLP-function form hR, , O, i, characterized via classical propositional logic,
using concepts completion (Clark, 1978) loop formulas (Lin & Zhao, 2004; Lee &
Lifschitz, 2003). section, generalize concepts arbitrary DLP-functions.
end, main concern role input atoms incorporate
concepts. Furthermore, extend tightness property programs (Erdem & Lifschitz,
2003) DLP-functions introducing notion I-tightness Section 4.2.
4.1 Program Completion Loop Formulas
Given DLP-function , loop non-empty subset strongly connected
component positive dependency graph DG+ (). Recall DG+ ()
atoms Ato () Ath () nodes. particular, singleton {a} Ato ()
Ath () thus loop.
Example 4.1 Consider DLP-functions 1 2 defined follows:

1 :

{b, c}
c b;
ba
{a}

2 :

{a, b}
c b;
ba
{c}

Here, 1 singleton loops {b} {c}. particular, {a, b} loop
contains input atom a. hand, 2 loops {a}, {b}, {a, b}.
follows,
use,Wfor set propositional
W formulas (or atoms), denote
V
conjunction sS shorthand sS s. Moreover, appearing within
formula, set implicitly understood conjunction elements. DLP-function
atom Ato () Ath (), dene set supporting formulas
SuppF(a, ) = {B C (A \ {a}) | B, C A}
loop L Ato () Ath () , set externally supporting formulas
ESuppF(L, ) = {B C (A \ L) | B, C , L 6= , B L = }.
Clarks completion procedure (conjunctive) loop formulas generalized DLPfunctions following way:
Definition 4.2 DLP-function , completion set formulas
826

fiModularity Aspects Disjunctive Stable Models

W
Comp() = {B C
W | B, C }
{a SuppF(a, ) | Ato () Ath ()}

set loop formulas
W
LF() = {L ESuppF(L, ) | L Ato () Ath () loop }.9

Observe case Ati () = , i.e., Ato () Ath () = At(), completion
Comp() reduces denition provided Lee Lifschitz (2003) holds
set LF() loop formulas. Generally speaking, propositional theories Comp()
LF() characterize set SM() stable models following sense:

Theorem 4.3 DLP-function interpretation At(),
SM() |= Comp() |= LF().
Proof. rst relate sets SuppF(a, ) ESuppF(L, ), introduced
DLP-function , respective sets complementary rules
SuppCR(a, ) = {A \ {a} B, C | B, C A}
ESuppCR(L, ) = {A \ L B, C | B, C , L 6= , B L = }.
First, straightforward that, interpretation At(), |= Comp()
jointly |= (Ato () Ath ()), 6|= SuppCR(a, ). Quite
similarly, holds |= LF() i, loop L (Ato () Ath ()) ,
6|= ESuppCR(L, ). hand, viewing SuppCR(a, ) ESuppCR(L, )
DLP-functions signatures , apply Proposition 3.4 order
evaluate input atoms. Thus, obtain following relationships DLP-function
, interpretation At(), atom Ato () Ath (), loop L Ato () Ath ()
:
1. |= Mo Mh |= /Mi ,
2. |= SuppCR(a, ) Mo Mh |= SuppCR(a, /Mi ),
3. |= ESuppCR(L, ) Mo Mh |= ESuppCR(L, /Mi ).
Finally, recall interpretation At(), Ato () = Ato (/Mi )
Ath () = Ath (/Mi ). Inspecting denition Comp() LF() again,
conclude interpretation At() |= Comp() LF() Mo Mh |=
Comp(/Mi ) LF(/Mi ). turn, know Mo Mh |= Comp(/Mi ) LF(/Mi )
Mo Mh stable model program /Mi results Lee Lifschitz (2003);
recall /Mi ordinary disjunctive program without input atoms. Finally,
SM() = {M At() | Mo Mh SM(/Mi )} Corollary 3.9. equality shows
claim.

Example 4.4 Let us demonstrate functioning program completion loop formulas DLP-functions Example 4.1, i.e., 1 = hR, {a}, {b, c}, 2 =
hR, {c}, {a, b}, i, R = {a c b; b a}. completions
9. Although may seem case singleton loop L = {a} somewhat redundant, so,
since tautological rules b make difference.

827

fiJanhunen, Oikarinen, Tompits & Woltran

Comp(1 ) = {b c, b} {b a, c b a}
Comp(2 ) = {b c, b} {b a, b c}.
Furthermore, sets loop formulas
W
W
LF(1 ) = {b ESuppF({b}, 1 ), c ESuppF({c}, 1 )}
= {b a,
W c b a}
W
LF(2 ) = {b ESuppF({b},
2 ), ESuppF({a}, 2 ),
W
b ESuppF({a, b}, 2 )}
= {b a, b c, b }.
last formula, W
occurrence view ESuppF({a, b}, 2 ) = ,
yields empty disjunction ESuppF({a, b}, 2 ) = usual.
Computing classical models Comp(1 ) LF(1 ) = Comp(1 ) yields two
models, M1 = {a, b} M2 = . One check indeed stable models
1 recalling Ati (1 ) = {a}. Thus, M1 relates actual input M1 Ati (1 ) = {a}
whereas M2 based M2 Ati (1 ) = . hand, classical models
Comp(2 ) LF(2 ) M1 = {c} M2 = , relate two possible
inputs Ati (2 ) = {c}. Finally, note {a, b} model Comp(2 )
ruled LF(2 ).
4.2 Tight DLP-functions
extend well-known concept tightness (Erdem & Lifschitz, 2003) DLPfunctions. interest since exploit fact positive dependency
graph DG+ () reduced modulo input atoms. words, since dependency graph
DG+ () atoms Ato () Ath () nodes, tightness DLP-functions
dened respect input signature.
beginning Section 4, loops dened arbitrary non-empty subsets
strongly connected components DG+ (). Thus, DG+ () acyclic
singleton loops. However, converse necessarily true, since, program
singleton loops, DG+ () may edges ha, ai, i.e., cycles length one.
Definition 4.5 DLP-function Ati ()-tight (or tight, short), positive dependency graph DG+ () acyclic.
Example 4.6 Recall DLP-functions 1 = hR, {a}, {b, c}, 2 = hR, {c}, {a, b},
based R = {a c b; b a} Example 4.1. Here, 1 {a}-tight since potential
non-singleton loop {a, b} contains input atom a. hand, 2 {c}-tight.
worth mentioning ordinary variant 1 , viz. DLP-function hR, , {a, b, c}, i,
-tightin particular, since R tight usual sense.
note last observation, viz. DLP-function hR, I, O, Hi may I-tight
although R tight program, relies use disjunctions program. fact,
DLP-functions hR, I, O, Hi, R set normal rules form B, C,
DLP-function = hR, I, O, Hi I-tight R tight. verify this, note
second item Denition 2.1 implies head atom normal rule B, C
must appear I, thus loop may involve atoms I.
828

fiModularity Aspects Disjunctive Stable Models

show notion tightness introduced Denition 4.5 enables us
characterize stable models DLP-function classical models completion.
Since ordinary program represented DLP-function, thus properly
generalize well-known completion semantics (Clark, 1978). following lemma
already sucient result view Denition 4.2 Theorem 4.3.
Lemma 4.7 tight DLP-function , LF() Comp().
W
Proof. Recall Ato () Ath (), SuppF(a, ) contained
Comp(). Moreover,Wsince tight, singleton loops, thus LF() contains
formulas ESuppF({a}, ), Ato () Ath (). remains
show that, atom a, SuppF(a, ) equivalent ESuppF({a}, ) whenever
positive dependency graph DG+ () acyclic. repeat denition SuppF(a, )
give denition ESuppF(L, ), simplied case L = {a}:
SuppF(a, ) = {B C (A \ {a}) | B, C A};
ESuppF({a}, ) = {B C (A \ {a}) | B, C , A, B {a} = }.
easy see acyclic dependency graph DG+ (), implies B{a} =
every rule B, C . Thus, conclude SuppF(a, ) = ESuppF({a}, )
holds Ato () Ath (). Hence, claim follows.

Example 4.8 Recalling DLP-function 1 = hR, {a}, {b, c}, Example 4.4
R = {a c b; b a}, obtain
Comp(1 ) = {b
W c, b} {b a, cW b a}
LF(1 ) = {b ESuppF({b}, 1 ), c ESuppF({c}, 1 )}
= {b a, c b a}.
Now, 1 tight observe LF(1 ) Comp(1 ) expected.
observations presented far lead us following result:
Theorem 4.9 tight DLP-function interpretation At(),
SM() |= Comp().
particular, result compatible existing characterization stable models
case Ati () = , i.e., Ato () Ath () = At(). Then, notion Ati ()tightness coincides ordinary tightness, denition completion Comp()
reduces one provided Lee Lifschitz (2003).

5. Compositional Semantics
follows, objective establish main result paper, i.e., show
stable-model semantics, given Denition 3.8, fully compositional larger
DLP-functions formed joins 1 . . . n DLP-functions. precisely,
interconnection SM() SM(1 ), . . . , SM(n ) explicated Section 5.1. analogy
829

fiJanhunen, Oikarinen, Tompits & Woltran

Section 3, follow quite rigorous approach consider relationship classical
models rst, minimal models, eventually cover case stable models
comprises module theorem. Then, Section 5.2, use quantied Boolean formulas
second level polynomial hierarchy modular representation terms
DLP-functions illustrate module theorem. Finally, devote Section 5.3
comparison splitting set theorem proven Lifschitz Turner (1994).
5.1 Module Theorem
begin with, formalize criteria combining interpretations well models.
Definition 5.1 Given two DLP-functions 1 2 , interpretations M1 At(1 )
M2 At(2 ) mutually compatible (with respect 1 2 ), compatible,
M1 Atv (2 ) = M2 Atv (1 ).

(11)

According (11), two compatible interpretations M1 M2 1 2 , respectively, agree truth values joint visible atoms Atv (1 ) Atv (2 ).
quick inspection Figure 1 reveals three cases may arise join = 1 2
dened joint output atoms 1 2 thereafter disallowed: may exist
1. joint input atoms Ati () = Ati (1 ) Ati (2 ),
2. atoms Ato (1 ) Ati (2 ) output atoms 1 input atoms 2 ,
3. symmetry, atoms Ati (1 ) Ato (2 ).
Recall according Denition 2.6, atoms last two categories end Ato ()
= 1 2 formed. Atoms Atv (1 ) Atv (2 ) provide basis combine
compatible interpretations 1 2 .
Definition 5.2 Let 1 2 two DLP-functions = 1 2 defined.
Given sets interpretations A1 2At(1 ) A2 2At(2 ) , natural join A1
A2 respect Atv (1 ) Atv (2 ), denoted A1
A2 , set interpretations
A1
A2 = {M1 M2 | M1 A1 , M2 A2 , M1 M2 compatible}.

(12)

rst modularity result formulated DLP-functions classical semantics
dened Section 3. combination classical models understood (12).
Proposition 5.3 positive DLP-functions 1 2 1 2 defined,
CM(1 2 ) = CM(1 )
CM(2 ).

(13)

Proof. Consider interpretation At(1 2 ) projections M1 = At(1 )
M2 = At(2 ) respect 1 = hR1 , I1 , O1 , H1 2 = hR2 , I2 , O2 , H2 i.
follows M1 M2 compatible = M1 M2
830

fiModularity Aspects Disjunctive Stable Models

CM(1 2 )




|= R1 R2
M1 |= R1 M2 |= R2
M1 CM(1 ) M2 CM(2 )
CM(1 )
CM(2 ).



Generalizing Proposition 5.3 stable models DLP-functions much elaborate.
cover case positive DLP-functions minimal models rst. proof
Theorem 5.5 exploits program completion, loop formulas, well characterization
stable minimal models Section 4 follows:
Lemma 5.4 DLP-functions 1 2 1 2 defined, following
conditions hold:
Comp(1 2 ) = Comp(1 ) Comp(2 );
LF(1 2 ) = LF(1 ) LF(2 ).

(14)
(15)

Proof. begin proof analyzing formulas introduced Clarks completion
loop formulas related joins DLP-functions. end, establish
sets formulas associated 1 2 directly obtained unions sets
formulas associatedWwith 1 = hR1 , I1 , O1 , H1 2 = hR2 , I2 , O2 , H2 i: First,
implication B C belongs Comp(1 2 ) belongs Comp(1 ),
Comp(2 ), case shared rule. Second, let us consider atom H,
= O1 O2 H = H1 H2 disjoint 1 2 dened.
reason, either O1 H1 O2 H2 , i.e., atom dened either 1 2 . Thus,
either Def R1 (a) = Def R1 R2 (a) Def R2 (a) = Def R1 R2 (a) Denition 2.2,
implies either SuppF(a, 1 2 )W= SuppF(a, 1 ) SuppF(a, 1 2 ) = SuppF(a, 2 ).
follows implication
1 2 )
W SuppF(a, 1 2 ) member Comp(
W
either (i) SuppF(a, 1 ) belongs Comp(1 ) (ii) SuppF(a, 2 )
belongs Comp(2 ). Thus, may conclude (14) completions involved.
Third, recall loop L At(1 2 ) 1 2 contained SCC
1 2 . follows (5), (6), Denition 2.2 either
1. L O1 H1 loop 1 Def R1 (L) = Def R1 R2 (L),
2. L O2 H2 loop 2 Def R2 (L) = Def R1 R2 (L).
cases above, either ESuppF(L, 1 2 ) = ESuppF(L,W
1 ) ESuppF(L, 1
2 ) = ESuppF(L, 2 ). Thus, respective loop formula L
ESuppF(L, 1 2 )
belongs LF(1 2 ) contained LF(1 ) LF(2 ).

Theorem 5.5 positive DLP-functions 1 2 1 2 defined,
MM(1 2 ) = MM(1 )
MM(2 ).

(16)

Proof. Consider At(1 2 ) respective projections M1 = At(1 )
M2 = At(2 ) compatible and, moreover, = M1 M2 . obtain
following chain equivalences:
831

fiJanhunen, Oikarinen, Tompits & Woltran

MM(1 2 )
|= Comp(1 2 ) |= LF(1 2 )
M1 |= Comp(1 ) M1 |= LF(1 )

M2 |= Comp(2 ) M2 |= LF(2 )
M1 MM(1 ) M2 MM(2 )
MM(1 )
MM(2 ).

[Theorem 4.3]
[(14) (15)]
[Theorem 4.3]
[Denition 5.2]


Example 5.6 Let us demonstrate result Theorem 5.5 practical setting using DLPfunctions 1 2 visualized composition = hR, , {a, b, c, d, e}, i.

1 :

{a, b, c}
b ;
b;
b a;
c;
c e a, b
{d, e}

2 :

{d, e}
c;
e d;
e;
c e a, b
{a, b, c}

join 1 2 defined SCCs composition S1 = {a, b, c}
S2 = {d, e}. Ati (1 )-minimal models 1 {a, b, c}, {a, b, d}, {a, b, e},
{a, b, d, e}. Likewise, calculating MM(2 ), get
MM(2 ) = {, {a}, {b}, {c, d, e}, {a, b, d, e}, {a, c, d, e}, {b, c, d, e}, {a, b, c, d, e}}.
Hence, minimal model = {a, b, d, e} compatibility condition
underlying (16) correctly excludes N = {a, b, c, d, e} 6 MM(). Note support
c true 1 e true. Accordingly, c e a, b active.
prepared present central result:
Theorem 5.7 (Module Theorem) DLP-functions 1 2 1 2
defined,
SM(1 2 ) = SM(1 )
SM(2 ).
(17)
Proof. Again, take interpretation At(1 2 ) respective compatible
projections M1 = At(1 ) M2 = At(2 ) consideration. proof (17)
based (16) number preliminary facts established:
M2
1
1. composition
dened.
1 2

Since 1 2 dened, know 1 2 dened. indicates 1
1

2 respect input/output interfaces other. construction
1
M2
M1
M2
2 aect property implies 1 2 dened.
M2
1
dened.
2. join
1 2
M2
1
preceding item, positive dependency graph DG+ (M
1 2 ) dened.
M1
M2
Let us assume 1 2 mutually dependent, i.e., SCC
M2
1
graph Ato (M
1 ) 6= Ato (2 ) 6= . Since
dependency graph potentially fewer dependencies respective graph

832

fiModularity Aspects Disjunctive Stable Models

DG+ (1 2 ) 1 2 , follows contained SCC latter.
M2

1
Since Ato (M
1 ) = Ato (1 ) Ato (2 ) = Ato (2 ), obtain Ato (1 ) 6=
Ato (2 ) 6= . Thus, 1 2 mutually dependent, contradiction.
M2
1
3. reduct (1 2 )M coincides
1 2 .

rule B belongs (1 2 )M rule B, C 1 ,
2 , C = . Equivalently, rule B, C 1
C M1 = , rule B, C 2 C M2 = , i.e.,
1
2
B
B
1
2 .
therefore get following chain equivalences:
SM(1 2 )






MM((1 2 )M )
M2
1
MM(M
1 2 )
1
2
MM(M
MM(M
1 )
2 )
M2
1
M1 MM(M
1 ) M2 MM(2 )
M1 SM(1 ) M2 SM(2 )
SM(1 )
SM(2 ).

[Denition 3.8]
[Item 3 above]
[Theorem 5.5]
[Denition 5.2]
[Denition 3.8]
[Denition 5.2]



moral Theorem 5.7 Denition 2.6 stable semantics supports modularization long positively interdependent atoms enforced module.
Example 5.8 Let 1 2 DLP-functions defined = 1 2
join (which clearly defined):
{b}
b ;
bc
{a, c}



{c}
c ;
bc
{a, b}

=

{b, c}
b ;
c ;
bc
{a}

straightforward verify SM(1 ) = {{b}, {a, b}, {a, c}, {b, c}} SM(2 ) =
{{c}, {a, b}, {a, c}, {b, c}}. Since Atv (1 ) Atv (2 ) = {a, b, c}, obtain
SM(1 )
SM(2 ) = SM(1 ) SM(2 ) = {{a, b}, {a, c}, {b, c}}.
simple cross-check confirms SM() indeed given set.
Example 5.9 Consider DLP-functions 1 2 Example 2.8. Then, SM(1 ) =
{, {a, b}, {b, c}} SM(2 ) = {, {a, b}, {a, c}}. shown Example 2.8, join 1
2 undefined. Thus, Theorem 5.7 applicable. Concerning composition
1 2 , note SM(1 2 ) = {, {a, c}, {b, c}} =
6 {, {a, b}} = SM(1 )
SM(2 ).
Theorem 5.7 easily extended DLP-functions consisting two
modules. view this, say nite sequence M1 , . . . , Mn stable models
modules 1 , . . . , n , respectively, compatible, Mi Mj pairwise compatible,
1
i, j n. property guarantees Mi recovered union
= ni=1 Mi taking respective projection At(i ) = Mi .
833

fiJanhunen, Oikarinen, Tompits & Woltran

Corollary 5.10 Let 1 , . . . , n sequence DLP-functions join 1
n defined. Then,
SM(1 n ) = SM(1 )

SM(n ).

(18)

Example 5.11 following example simply extends Example 5.8:
{b}
b ;
bc
{a, c}



{c}
c ;
bc
{a, b}

{a}
b ;
ac
{b, c}



=

{a, b, c}
b ;
c ;
bc


SM(1 ) = {{b}, {a, b}, {a, c}, {b, c}}, SM(2 ) = {{c}, {a, b}, {a, c}, {b, c}},
SM(3 ) = {{a}, {a, b}, {a, c}, {b, c}}. Thus, learn Corollary 5.10
SM(1 2 3 ) = SM(1 )
SM(2 )
SM(3 ) = {{a, b}, {a, c}, {b, c}}.
5.2 Modular Representation Quantified Boolean Formulas
next objective illustrate theory developed far terms extensive
unsat depicted
example. end, consider pair DLP-functions sat
n n
Figure 2. purpose evaluation quantified Boolean formulas (QBFs)
form
n
_
XY
(Ai Bi Ci Di ),
(19)
i=1

Aj , Bj , Cj , Dj set Boolean variables, parameter n gives
number disjuncts matrix Boolean formula inSdisjunctive normal
form (DNF).10 Without loss generality, may assume X = ni=1 (Ai Bi ), =

n
i=1 (Ci Di ), X = hold sets X Boolean variables (19).
important point general evaluation QBFs form (19) constitutes p2 -complete decision problem perfectly matches complexity checking
existence stable models disjunctive program. Given completeness property,
follows principle decision problem p2 turned QBF form
(19), albeit direct representations obtained particular problem domains.
respect, let us address three specic domains prior detailing generic approach.
1. strategic companies domain identied Leone et al. (2006) one rst
practical domains involving decision problems second level polynomialtime hierarchy solved using ASP techniques. simplied encoding provided
Koch, Leone, Pfeifer (2003) based two kinds disjunctive rules:
strat(x1 ) strat(x2 ) strat(x3 ) strat(x4 ) prod(y, x1 , x2 , x3 , x4 ),

(20)

strat(x) ctrl(x, x1 , x2 , x3 , x4 ), strat(x1 ), strat(x2 ), strat(x3 ), strat(x4 ),

(21)

10. Also, recall shorthands =

V

sS

=

V

834

sS

introduced right Example 4.1.

fiModularity Aspects Disjunctive Stable Models

Function sat
n :

Function unsat
:
n

X
1 n x Ai : x, act(i);
1 n x Bi : x act(i);
1 n: Ai Bi , act(i)
{act(1), . . . , act(n)}

Ci {u} Di , act(i);
u;
u u
{act(1), . . . , act(n)}

1 n:
:

unsat
Figure 2: DLP-functions sat
n n Wfor evaluation quantied Boolean formula
XY matrix = ni=1 (Ai Bi Ci Di ).

predicates strat(x), prod(y, x1 , x2 , x3 , x4 ), ctrl(x, x1 , x2 , x3 , x4 ), respectively,
denote company x strategic, product produced companies x1 , . . . , x4 ,
company x controlled companies x1 , . . . , x4 . Obviously, instances
predicate strat arising rules forms (20) (21) create positive dependencies program . resulting SCCs used split program
modules 1 , . . . , n = 1 . . . n dened. Theorem 5.7, status
specic company x decided using module denes strat(x)
rather entire encoding .
2. model-based diagnosis digital circuitry provides another interesting application
area. Quite recently, Oikarinen Janhunen (2008b) presented ecient encoding
prioritized circumscription disjunctive program (and thus, special case,
parallel circumscription well)enabling concise representation minimal diagnoses sense Reiter (1987). resulting disjunctive rules involve head-cycles
(see Section 7 details) typically pre-empt polynomial-time translation
computationally easier normal logic program. observation suggests completeness second level polynomial-time hierarchy although aware
exact hardness result. correctness proof encoding exploits two modules
module theorem.
3. Finally, let us mention Gebser, Schaub, Thiele, Usadel, Veber (2008b) identify
minimal inconsistent cores large biological networks disjunctive programs.
decision problem question Dp -complete indicates appropriateness
disjunctive logic programs representation domain. Since Dp complete decision problem described independent combination NPcomplete decision problem P1 coNP-complete decision problem P2 , foresee
representation form join sat unsat , sat stable model P1
succinct certicate, unsat unique stable model P2 succinct
835

fiJanhunen, Oikarinen, Tompits & Woltran

{x1 , x2 }
x1 act(1);
x1 , act(1);
x2 , act(2); x2 act(2);
x1 act(3);
x1 , act(3);
x1 act(4);
x2 , act(4);
x2 x1 , act(4)
{act(1), act(2), act(3), act(4)}


u y1 , y2 , act(1);
u y2 y1 , act(2);
u y1 y2 , act(3);
u y1 y2 act(4);
y1 u; y2 u; u u
{act(1), act(2), act(3), act(4)}

unsat .
Figure 3: Particular instances sat
4 4

certicates. required DLPs worked via reductions propositional
(un)satisability. particular, test unsatisability realized analogy
unsat
analyzed below.
n
general case, use Boolean variables propositional atoms interchangeably
order describe validity problem (19) captured DLP-functions
unsat based explanatory approach Janhunen
Figure 2. design sat
n n
et al. (2006), (19) equivalently viewed formula XY matrix
conjunctive normal form (CNF). clause 11 Ai Bi Ci Di active
whenever Ai Bi false truth clause becomes dependent Ci Di ;
put dually, Ai Bi true truth Ai Bi Ci Di depends Ci Di .
validity formula XY captured follows: Given input interpretation
Mi {act(1), . . . , act(n)}, upper DLP-function sat
n Figure 2 tries explain
activation statuses clauses checking respective theory {Ai Bi |
act(i) Mi } {Ai Bi | act(i) 6 Mi } satisable. lower DLP-function, unsat
, plays
n
role coNP-oracle: captures test theory {Ci Di | act(i) Mi }
unsatisable. correctness representation provided DLP-functions
addressed soon, enough understand syntax intuitive meaning
moment. concrete QBF instance evaluated follows.
unsat Figure 2 case QBF
Example 5.12 Consider DLP-functions sat
n n

x1 x2 y1 y2 [(x1 y1 y2 )(x2 y1 y2 )(x1 y1 y2 )(x1 x2 y1 y2 )]. (22)
Thus, parameter instance n = 4, input signature {act(1), . . . , act(4)}
unsat , illustrated Figure 3. output signature former DLPfor sat
4 4
function {x1 , x2 } atoms, i.e., y1 , y2 , u, remain hidden latter.
joint input signature used specify active part matrix (22). DLPfunction sat
provides explanation, i.e., assignment variables x1 x2
4
output, whereas unsat
responsible respective unsatisfiability check. regards
4
validity QBF given (22), input interpretation {act(1), act(2), act(3), act(4)}
yields positive answer. respective explanation, i.e., output interpretation found
sat
4 , {x1 }. easy check x1 true x2 false remainder
matrix true whatever values assigned y1 y2 . Hence, QBF (22) valid.
11. purposes section, interpret disjunctions B sets B = {b | b B}
positive negative literals, respectively, disjunctions elements.

836

fiModularity Aspects Disjunctive Stable Models

unsat Figure 2, identical
regards general DLP-functions sat
n n
sat
input signatures, n output atoms, hidden atoms unsat
fully
n
sat
unsat
respected. Hence, composition n n
dened. Moreover, atoms appearing
rules involve positive dependencies belong disjoint sets X {u}.
unsat ) cannot SCC X 6=
therefore clear DG+ (sat
n n
unsat dened regardless QBF (19)
(Y {u}) 6= . implies sat
n n
question. Let us exploit fact context specic DLP-functions Example 5.12.

Example 5.13 four stable models DLP-function sat
4 :
{act(1), act(2), act(3), act(4), x1 }, {act(1), act(3), x1 , x2 }, {act(2)}, {x2 },
listed decreasing level activation. hand, DLP-function unsat

4
unique stable model {act(1), act(2), act(3), act(4), y1 , y2 , u}, i.e., interpretation {y1 , y2 , u}
/{act(1), act(2), act(3), act(4)} set rules
unique stable model unsat
4
given
{ u y1 , y2 ; u y2 y1 ; u y1 y2 ; u y1 y2 ; y1 u; y2 u; u u },
/Mi stable models input interpretation Mi . Moreover,
unsat
4
unsat ) combining compatible pairs
may apply module theorem calculate SM(sat
4 4
models. one pair:
{act(1), act(2), act(3), act(4), x1 } SM(sat
4 )
{act(1), act(2), act(3), act(4), y1 , y2 , u} SM(unsat
).
4
Thus, {act(1), act(2), act(3), act(4), x1 , y1 , y2 , u} unique stable model join sat
4
sat unsat ) non-empty, conclude (22) indeed valid.
unsat
.
Since
SM(
4
4
4
natural ask stated stable models general DLPfunctions unsat
sat
n
n associated QBF XY given (19). stable
sat
model n , respective projection MX = X determines , i.e., holds
1 n matrix act(i) MX |= Ai Bi . Moreover, model
MX minimal sense strictly smaller interpretation N MX
property. additional feature brought along minimality stable models.
consequence, DLP-function sat
n capture possible truth assignments
variables X relevant truth assignments lost. hand, stable
indicates respective theory
model unsat
n
{Ci Di | 1 n, act(i) }
W
inconsistent, alternatively, formula 1in,act(i)M Ci Di valid.
Concerning correctness representation given Figure 2, due existing
proof Janhunen et al. (2006), present main stepsfully exploiting benets
modular approach.
unsat ) non-empty.
Theorem 5.14 QBF XY form (19) valid iff SM(sat
n n

Proof sketch. Consider QBF XY form (19). following equivalent:
837

fiJanhunen, Oikarinen, Tompits & Woltran

1. formula XY valid.
2. minimal interpretation N X that, set = {1 n |
N 6|= Ai Bi } indices determined N N |= {Ai Bi | I}{Ai Bi |
6 I}, theory {Ci Di | I} unsatisable.
unsat compatible stable models = N {act(i) |
3. DLP-functions sat
1
n n
I} M2 = {act(i) | I} {u}, respectively.
unsat stable model
4. DLP-function sat
n n

= M1 M2 = N {act(i) | I} {u}.
second item, minimality N means N N {1 n |
N 6|= Ai Bi } = I. assumed without loss generality.

Theorem 5.14 module theorem suggest approximation strategy verifying
unsat ) empty, know
validity QBFs form (19). either SM(sat
n ) SM(n
unsat ) = .
directly formula valid. Otherwise, check whether SM(sat
n n
5.3 Splitting Sets
sake comparison, formulate splitting-set theorem (Lifschitz & Turner,
1994) DLP-function = hR, , O, i, essentially forms ordinary disjunctive
program. Splitting sets sets atoms closed following sense:
Definition 5.15 Given DLP-function = hR, , O, i, set U atoms splitting set if, every rule B, C R,
U 6= implies B C U .
Denitions 2.1 5.15, sets always splitting sets . However,
one mostly interested non-trivial splitting sets U , sets
need exist. Nevertheless, splitting set U divides respective set rules R two
parts. bottom, bU (R), R respect U contains rules B, C R
B C U , whereas top, tU (R), R R \ bU (R). splitting R
bU (R) tU (R) becomes proper one, i.e., bU (R) 6= tU (R) 6= ,
1. U non-trivial
2. every atom least one dening rule B, C R A.
According Lifschitz Turner (1994), solution R respect U pair
hX, X U , \U , X SM(bU (R)), SM(tU (R)/X). Here, tU (R)/X
denotes partial evaluation tU (R) sense Denition 3.2 using X U
input interpretation. Using similar idea, let us introduce DLP-functions corresponding
bU (R) tU (R). Given splitting set U , join = B ,
B = hbU (R), , U, = htU (R), U, \ U,
dened. Then, following result implied Theorem 5.7.
838

fiModularity Aspects Disjunctive Stable Models

Corollary 5.16 (Splitting-Set Theorem Lifschitz & Turner, 1994) every
DLP-function = hR, , O, corresponding set R disjunctive rules, every splitting
set U , every interpretation At() = O, following conditions
equivalent:
1. stable model .
2. U SM(B ) SM(T ).
3. hM U , \ U solution R respect U .
fact, Theorem 5.7 strictly stronger splitting-set theorem. previously
demonstrated Oikarinen Janhunen (2008a), splitting sets applicable DLPfunctions = h{a b; b a}, , {a, b}, trivial way, i.e., U1 =
U2 = {a, b} splitting sets . contrast, Theorem 5.7 applies preceding
DLP-function versatile ways, i.e., 1 2 dened 1 = h{a b}, {b}, {a},
2 = h{b a}, {a}, {b}, i. consequence 1 2 dened, possible
determine sets stable models SM(1 ) = {{a}, {b}} = SM(2 ) separation,
appropriate, conclude SM() = SM(1 )
SM(2 ) = {{a}, {b}} holds
well. Yet another generality aspect splitting concerns role input atomsthey
assumed nonexistent above. Theorem 5.7, however, enables us treat well.

6. Decomposing DLP-Functions
objectives section contrary construction DLP-function join
modules. idea exploit strongly connected components DG+ (), DLPfunction , order decompose smaller components, e.g., priori
information internal structure . simplicity, rst consider DLPfunctions hidden atoms, i.e., Ath () = . eects hidden atoms
decomposition DLP-functions addressed thereafter. dened conjunction
Denition 2.6, SCCs DG+ () induced positive dependency relation
reexive transitive, i.e., preorder denition. sequel, set
SCCs DG+ () denoted SCC+ (). positive dependency relation lifts
elements SCC+ () follows: S1 S2 atoms a1 S1 a2 S2
a1 a2 . end, matter pair atoms inspected.
Lemma 6.1 DLP-function components S1 , S2 SCC+ (), S1 S2
a1 a2 every a1 S1 a2 S2 .
Proof. (=) S1 S2 , b1 S1 b2 S2 b1 b2 . Consider
a1 S1 a2 S2 . follows a1 b1 b2 a2 denition SCCs. Thus,
a1 a2 transitive.
(=) holds trivially SCCs non-empty.

Proposition 6.2 relation SCC+ () reflexive, transitive, antisymmetric.
839

fiJanhunen, Oikarinen, Tompits & Woltran

Proof. relation SCC+ () reexive transitive denition. antisymmetry, consider S1 , S2 SCC+ () S1 S2 S2 S1 . follows
Lemma 6.1 that, every a1 S1 a2 S2 , a1 a2 a2 a1 . Thus, S1 = S2
maximality components SCC+ ().

+
Consequently, may conclude hSCC (), partially ordered set. Since
nite denition, hSCC+ (), maxima minima elements need
unique. particular, SCC+ () minimum element S1 SCC+ ()
S1 S2 S1 implies S2 = S1 , S2 SCC+ (). Thus, may
apply principle well-founded induction using minima hSCC+ (), basis.
Given structure hSCC+ (), i, DLP-function = hR, I, O, decomposed following way: set rules associated SCC+ () Def R (S)
(2), i.e., set defining rules R. general, head arbitrary rule
B, C R may coincide sense (2) several SCCs, implies
rule included Def R (S) several SCC+ (). However, distribution
rules perfect harmony last two conditions Denition 2.2. must
bear mind integrity constraints B, C included Def R (S)
SCC+ (). access integrity constraints set R rules, dene
IC(R) = {A B, C R | = }.

(23)

ready present decomposition based SCC+ ().
Definition 6.3 Given DLP-function = hR, I, O, i, decomposition induced
SCC+ () includes DLP-function
0 = hIC(R), At(IC(R)) (I \ At(R)), ,

(24)

and, SCC+ (), DLP-function
= hDef R (S), At(Def R (S)) \ S, S, i.

(25)

purpose extra module 0 keep track integrity constraints well
input atoms mentioned rules R. modules involved
decomposition induced SCCs. refers modules using
At(Def R (S)) \ input signature provides dening rules (if any) every
atom S. Recall output atom dening rules falsied default.
Proposition 6.4 DLP-function = hR, I, O, decomposition based
SCC+ (), join
F
(26)
0 ( SSCC+ () )
defined equal .

Proof. Let us consider 0 SCC+ (). composition 0
dened modules involve hidden atoms, Ato (0 ) = ,
Def R1 () = = Def R1 R2 () Def R2 (S) = Def R (S) = Def R1 R2 (S) sets rules
R1 = IC(R) R2 = Def R (S). join 0 dened respective composition
integrity constraints 0 create dependencies DG+ (0 ).
840

fiModularity Aspects Disjunctive Stable Models

Let us perform similar analysis S1 S2 based two dierent components
S1 , S2 SCC+ (). clear S1 S2 dened since modules involve
hidden atoms, S1 S2 = , Def R1 (S1 ) = Def R (S1 ) = Def R1 R2 (S1 )
Def R2 (S2 ) = Def R (S2 ) = Def R1 R2 (S2 ), R1 = Def R (S1 ) R2 = Def R (S2 ).
Since pairwise joins dened, overall join (26) dened. Denition 2.4
denition SCC+ (), outcome equal

1. IC(R) SSCC+ () Def R (S) = R,

2. SSCC+ () = O,


3. (At(IC(R)) \ O) ((I \ At(R)) \ O) SSCC+ () (At(Def R (S)) \ O) = I.
Corollary 6.5 DLP-function Ath () = decomposition based
SCC+ (),
SM() = SM(0 )
( SSCC+ () SM(S )).




Example 6.6 Consider following DLP-function :
{a, b, c, d}
b c ;
a, c; b, c;
a, d; b, d;
b;
c d;
b a;
c.

So, Ati () = , Ato () = {a, b, c, d}, Ath () = . two SCCs DG+ (),
viz. S1 = {a, b} S2 = {c, d}. resulting decomposition consists
0 = h{ a, c; a, d; b, c; b, d}, {a, b, c, d}, , i,
S1 = h{a b c ; b; b a}, {c, d}, {a, b}, i,
S2 = h{a b c ; c d; c}, {a, b}, {c, d}, i.
respective sets stable models
SM(0 )
SM(S1 )
SM(S1 )
SM()

=
=
=
=

{{a, b}, {c, d}, {a}, {b}, {c}, {d}, },
{{a, b}, {c}, {d}, {c, d}},
{{c, d}, {a}, {b}, {a, b}},
{{a, b}, {c, d}}.

Next, address case DLP-functions involving hidden atoms, i.e.,
Ath () 6= holds. Then, components DG+ () subsets Ato () Ath ()
revise (25) accordingly. DLP-function = hR, I, O, Hi SCC+ (),
= hDef R (S), At(Def R (S)) \ S, O, Hi.

(27)

Unfortunately, decomposition based modules form (27) likely negrained. certain components S1 , S2 SCC+ () S1 6= S2 , respective
841

fiJanhunen, Oikarinen, Tompits & Woltran

modules S1 S2 conforming (27) might respect hidden atoms other.
similar setting may arise 0 individual module based SCC+ ()
integrity constraints refer hidden atoms . problem would disappear
hidden atoms revealed hardly appropriatethere good reasons
hide certain atoms knowledge representation perspective.
way approach problem distinguish components S1 SCC+ ()
S2 SCC+ () respective modules S1 S2 would respect hidden
atoms other, i.e., hidden atom dened one would referred othereither
positively negatively. Similar conicts could arise due integrity constraints packed
module 0 distinguished Denition 6.3. rst sight, amalgamate 0
module whose hidden atoms occur integrity constraints 0 . But,
order avoid fusions kind far possible, worth redistributing integrity
constraints referring hidden atoms. clearly possible integrity constraints referring hidden atoms involved single component only. formalize ideas presented
far, distinguish precise relation among components SCC+ () follows.
Definition 6.7 Given DLP-function , components S1 , S2 SCC+ () respect
hidden atoms other, denoted S1 !h S2 , S1 6= S2
1. hidden atom h Ath (S1 ) h Ati (S2 ),
2. hidden atom h Ath (S2 ) h Ati (S1 ),
3. hidden atoms h1 Ath (S1 ) h2 Ath (S2 ) occurrence integrity constraint B, C .
clear !h irreexive symmetric components SCC+ ()
DLP-function . Moreover, transitive closure !h , denoted !+
h , gives rise
+
repartitioning SCC (). maximal block S1 , . . . , Sn components
Si !+
h Sj holds every 6= j induces module determined (27) union
= S1 . . . Sn . key observation modules associated dierent blocks
components respect hidden atoms makes Theorem 5.7 applicable
level abstraction. summarize treatment DLP-functions involving hidden
atoms rules, revise Denition 6.3 accordingly.
Definition 6.8 Given DLP-function = hR, I, O, Hi, decomposition induced
SCC+ () !+
h includes DLP-function
0 = hIC0 (R), At(IC0 (R)) (I \ At(R)), ,

(28)

IC0 (R) = { B, C R | (B C) H = } and, maximal block S1 , . . . , Sn
components SCC+ () Si !+
h Sj every 6= j, DLP-function
= hDef R (S) ICS (R), At(Def R (S) ICS (R)) \ S, O, Hi

(29)

= S1 . . . Sn ICS (R) = { B, C R | (B C) (S H) 6= }.
regards Example 6.6, Denitions 6.3 6.8 yield identical decompositions
DLP-function question. eects hiding demonstrated following example:
842

fiModularity Aspects Disjunctive Stable Models

Example 6.9 Consider DLP-function = hR, , O, Hi,
R = { a, c; b ; b c ; c d; c, b}
H = {a, b, c, d}, exact partitioning atoms H varies case
case analyzed below. SCCs SCC+ () S1 = {a}, S2 = {b}, S3 = {c, d}.
1. take atoms visible , i.e., H = , decomposition yields three modules, S1 = h{a b }, {b}, {a}, i, S2 = h{a b ; b c }, {a, c, d}, {b}, i,
S3 = h{b c ; c d; c, b}, {b}, {c, d}, i, addition module
0 = h{ a, c}, {a, c}, , encompassing integrity constraints.
2. hide H = {a} , obtain S1 !h S2 disjunctive rule b . Therefore, components S1 S2 must placed block maximal
giving rise module = h{ a, c; b ; b c }, {c, d}, {b}, {a}i
= S1 S2 = {a, b}. modules 0 = S3 listed above.
3. Finally, set H = {a, c} , obtain S2 !h S3 b c S1 !h S3
a, c addition S1 !h S2 stated above. Since 0 = , decomposition
effectively collapses single module = = S1 S2 S3 .
note non-trivial modules mentioned
SM(S1 )
SM(S2 )
SM(S3 )
SM(0 )
SM(S )

=
=
=
=
=

{{a}, {b}},
{{b}, {a, b}, {b, c}, {a, c}, {b, d}, {a, d}, {b, c, d}, {a, c, d}},
{{b}, {c, d}},
{, {c}, {a, c}},
{{b}, {a, c}, {b, c}, {b, d}, {a, c, d}, {b, c, d}}.

But, regardless decomposition obtained, holds respective joins
SM() =
=
=
=

SM(S1 )
SM(S2 )
SM(S3 )
SM(0 )
SM(S )
SM(S3 )
SM()
SM(S )
SM()
{{a, c, d}, {b}}.

calculations involving
important notice allowed combinations
stable models determined terms joint visible atoms modules involved.
instance, Atv (S1 ) Atv (S3 ) = {a, b} {b, c, d} = {b} SM(S1 )

SM(S3 ) {{a} {c, d}, {b} {b}} = {{a, c, d}, {b}} Denition 5.2. Thus, interestingly,
role remaining two modules S2 0 merely approve upon two
models. Recalling discussion introduction, suggests strategy gives
precedence
1. evaluation modules stable models,
2. combination stable models modules visible atoms common.
843

fiJanhunen, Oikarinen, Tompits & Woltran

7. Shifting Disjunctions
section, continue pursuit applications module theorem established
Section 5. generalize principle shifting disjunctive rules (Gelfond et al., 1991;
Dix et al., 1996) applying results paper. Roughly speaking, idea behind
shifting translate disjunctive rule B, C several normal (non-disjunctive)
rules shifting head atoms h negative literals h body. instance,
simple disjunctive rule b c captured normal rules
b, c,

b a, c,



c a, b.

shown Eiter et al. (2004), local shifting transformation preserves ordinary
equivalence, i.e., stable models.12 application technique is, however, pre-empted
presence head-cycles (Ben-Eliyahu & Dechter, 1994). cycle provided
SCC intersects head disjunctive rule B, C
|S A| > 1. instance, local shifting longer applicable rule b c
presence b b create strongly connected component = {a, b}.
consequence, respective DLP-functions
1 = h{a b c ; b; b a}, , {a, b, c}, i,

(30)

2 = h{a b, c; b a, c; c a, b; b; b a}, , {a, b, c},

(31)

dierent stable models: SM(1 ) = {{a, b}, {c}} SM(2 ) = {{c}}. discrepancy stable models settled applying decomposition technique
Section 6. fact, leads proper generalization local shifting transformation
formalized DLP-functions strongly connected components.
Definition 7.1 Let = hR, I, O, Hi DLP-function SCC+ () respective set
SCCs. general shifting DLP-function GSH() = hIC(R) R , I, O, Hi,
R set rules
{(A S) B, C, (A \ S) | B, C R, SCC+ () 6= }.

(32)

Hence, idea project head rule respect component S,
atoms dierence \ shifted negative body. viewed
contribution disjunctive rule B, C particular component S.
Example 7.2 1 (30), SCC+ (1 ) = {{a, b}, {c}},
GSH(1 ) = h{a b c; c a, b; b; b a}, , {a, b, c}, i.
importantly, SM(GSH(1 )) = {{a, b}, {c}} = SM(1 ), contrast set
SM(2 ) = {{c}} stable models 2 (31).
12. addition ordinary equivalence, uniform equivalence (Eiter & Fink, 2003) preserved local
shifting strong equivalence (Lifschitz, Pearce, & Valverde, 2001).

844

fiModularity Aspects Disjunctive Stable Models

prove correctness general shifting principle Denition 7.1.
aim exploit decomposition Denition 6.3 together modular
reconstruction Proposition 6.4 compositionality stable semantics
Corollary 6.5. extend coverage Corollary 6.5, introduce explicit operators
revealing hiding atoms DLP-functions follows:
Definition 7.3 Let = hR, I, O, Hi DLP-function. Then,
1. Reveal(, A) = hR, I, A, H \ Ai, set H hidden atoms,
2. Hide(, A) = hR, I, \ A, H Ai, set output atoms.
Since denition stable models make dierence output atoms
hidden atoms, following properties easy verify. role hidden atoms
becomes important Section 8 DLP-functions compared other.
Proposition 7.4 Let DLP-function.
1. Ath (), SM() = SM(Reveal(, A)).
2. Ato (), SM() = SM(Hide(, A)).
Lemma 7.5 Let DLP-function Ath () = , component SCC+ (),
respective module decomposition according Definition 6.3. Then,
SM(S ) = SM(GSH(S )).

(33)

Proof. Recall = hDef R (S), I, S, i, input signature = At(Def R (S)) \
S. Notice component SCC+ (S ) hence GSH(S ) set rules
R = {(A S) B, C, (A \ S) | B, C Def R (S)}.
Consider interpretation S, input output signatures
, respectively. Thus, Mi = Mo = S. Then, following equivalences
hold:






B (Def R (S)/Mi )Mo
B, C Def R (S)/Mi Mo |= C
B , C Def R (S) = Ao , B = Bo , C = Co ,
Mi |= Ai Bi Ci , Mo |= Co
B , C , Ai R = Ao , B = Bo , C = Co ,
Mi |= Ai Bi Ci , Mo |= Co
B, C R /Mi Mo |= C
B (R /Mi )Mo .

Thus, conclude (Def R (S)/Mi )Mo coincides (R /Mi )Mo , and, consequently, Mo
MM((Def R (S)/Mi )Mo ) Mo MM((R /Mi )Mo ). Therefore, SM(S /Mi ) =
SM(GSH(S )/Mi ). Since and, particular, Mi arbitrarily chosen beginning,
obtain equality stable models stated (33) directly Corollary 3.9.

845

fiJanhunen, Oikarinen, Tompits & Woltran

Theorem 7.6 DLP-function = hR, I, O, Hi, SM() = SM(GSH()).
Proof. Since may hidden atoms, Corollary 6.5 applicable decomposition based SCC+ (). Thus, start = Reveal(, H) = hR, I, H,
rather itself. Since SCCs independent hiding, SCC+ ( ) = SCC+ ()
GSH( ) = Reveal(GSH(),
H). Since Ath ( ) = construction, know
F

Proposition 6.4 0 ( SSCC+ () ) = . Applying GSH() equation yields
F
GSH( ) = 0 ( SSCC+ () GSH(S )).

(34)

regards respective sets stable models, obtain
SM( )

=



(
SM( )


=

SM(GSH( )).

=

SM(0 )
(

0

SSCC+ ( )

SM(S ))

[Corollary 6.5]

SSCC+ ( )

SM(GSH(S )))

[Lemma 7.5]
[Corollary 6.5 (34)]

follows Proposition 7.4 SM(Hide( , H)) = SM( ) = SM(GSH( )) =
SM(Hide(GSH( ), H)). Since Hide( , H) = Hide(GSH( ), H) = GSH(),
established SM() = SM(GSH()) desired.

According Denition 6.3, decompositions DLP-functions create multiple copies
disjunctive rules whose heads intersect several SCCs. introduction copies
circumvented applying general shifting technique Denition 7.1.
Example 7.7 DLP-function Example 6.6, obtain R1 = {ab c, d;
b; b a} R2 = {c a, b; c d; c} sets rules associated 1 = hR1 , {c, d}, {a, b}, 2 = hR2 , {a, b}, {c, d}, i, 1 2 =
hR1 R2 , , {a, b, c, d}, defined.

observations enable us view disjunctive rules shared modules
associated SCCs syntactic sugar. However, clever implementation save space
using shared rules. worst case, unwinding rule a1 B, C coincides
respective SCCs S1 , . . . , Sn a1 S1 , . . . , Sn may create n copies
body B C. quadratic blow-up partly alleviated introducing new
atom b name body. Thus result shifting a1 S1 , . . . , Sn becomes
a1 b, a2 , . . . , ;
..
.
ai b, a1 , . . . , ai1 , ai+1 , . . . , ;
..
.
b, a1 , . . . , an1
together dening rule b B, C b. implementation general
shifting principle called dencode.13 requested so, calculates beforehand whether
pays introduce new atom body disjunctive rule not.
13. Available http://www.tcs.hut.fi/Software/asptools/ experimenting.

846

fiModularity Aspects Disjunctive Stable Models

8. Equivalence DLP-Functions
concept visible equivalence originally introduced order neglect hidden atoms
logic programs, theories interest, compared basis models (Janhunen, 2006). Oikarinen Janhunen (2008a) extended idea level
logic program modulesgiving rise notion modular equivalence logic programs.
section, generalize concept modular equivalence DLP-functions
introduce translation-based method checking modular equivalence DLP-functions
following analogous approaches Oikarinen Janhunen (2004, 2009).
8.1 Modular Equivalence
Module interfaces must taken properly account DLP-functions compared.
reason, consider two DLP-functions 1 2 compatible
Ati (1 ) = Ati (2 ) Ato (1 ) = Ato (2 ).
Definition 8.1 DLP-functions 1 2 modularly equivalent, denoted 1 2 ,

1. 1 2 compatible
2. bijection f : SM(1 ) SM(2 ) interpretations
SM(1 ), Atv (1 ) = f (M ) Atv (2 ).
proof congruent lifts case normal programs (Oikarinen
& Janhunen, 2008a) disjunctive case using Theorem 5.7.
Proposition 8.2 Let 1 , 2 , DLP-functions. 1 2 1
2 defined, 1 2 .
Proof. Let 1 = hR1 , I1 , O1 , H1 2 = hR2 , I2 , O2 , H2 DLP-functions
1 2 , = hR, I, O, Hi DLP-function acting arbitrary context 1
2 1 2 dened. Consider SM(1 ). Theorem 5.7
implies M1 = At(1 ) SM(1 ) N = At() SM(). Since 1 2 ,
I1 = I2 , O1 = O2 , bijection f : SM(1 ) SM(2 )
M1 (I1 O1 ) = f (M1 ) (I2 O2 )

(35)

holds M1 . Dene M2 = f (M1 ). Since M1 N compatible denition (35)
holds, models M2 N compatible I1 = I2 O1 = O2 . Thus, M2 N
SM(2 ) Theorem 5.7 eectively described mapped model
SM(2 ) function g : SM(1 ) SM(2 ) dened
g(M ) = f (M At(1 )) (M At()).
Clearly, g maps set visible atoms itself, is,
(I1 O1 O) = g(M ) (I2 O2 O).
justications g bijection follows:
847

fiJanhunen, Oikarinen, Tompits & Woltran

g injection: 6= N implies g(M ) 6= g(N ) M, N SM(1 ), since
f (M At(1 )) 6= f (N At(1 )) At() 6= N At().
g surjection: N SM(2 ), = f 1 (N At(2 )) (N At())
SM(1 ) g(M ) = N , since f surjection.
inverse function g 1 : SM(2 ) SM(1 ) g dened setting
= f 1 (N At(2 )) (N At()). Thus, 1 2 .

Note GSH() follows directly Theorem 7.6. Applying Proposition 8.2
context Theorem 7.6 indicates shifting localized particular component
1 larger DLP-function 1 since 1 GSH(1 ) .

g 1 (N )

8.2 Verifying Modular Equivalence
Oikarinen Janhunen (2004) proposed translation-based method verication
weak equivalence disjunctive logic programs. Two logic programs weakly equivalent exactly set stable models. Thus, weak equivalence
seen special case modular equivalence DLP-functions 1 2
Ati (1 ) Ath (1 ) = Ati (2 ) Ath (2 ) = . motivates us adjust translationbased technique verication modular equivalence. observed previous work
(Janhunen & Oikarinen, 2007; Oikarinen & Janhunen, 2008a), verication visible/modular equivalence involves counting problem general. reduction computational time complexity achieved programs enough visible atoms,
referred EVA property short, (Janhunen & Oikarinen, 2007). DLPfunction = hR, I, O, Hi, dene hidden part restricted DLP-function
h = hDef R (H), O, H, enables evaluation hidden atoms H given
arbitrary truth values atoms O. Recalling Denition 3.2, use
instantiation h respect interpretation Mv Ati (h ), i.e., h /Mv , dene
EVA property DLP-function .
Definition 8.3 DLP-function = hR, I, O, Hi enough visible atoms iff h /Mv
unique stable model Mv Atv () = Ati (h ).
idea behind translation-based method Oikarinen Janhunen (2004)
ordinary disjunctive programs R1 R2 weakly equivalent translations
TR(R1 , R2 ) TR(R2 , R1 ) stable models. following, propose modied
version translation function adjusted verication modular equivalence. order
able verify modular equivalence, need take semantics atoms
input signature account well role hidden atoms modular equivalence
programs consideration. case DLP-functions, transform pair 1
2 compatible DLP-functions DLP-function EQT(1 , 2 ) stable
model stable model SM(1 ) stable model
N SM(2 ) Atv (1 ) = N Atv (2 ). form translation composition
DLP-functions order fully exploit compositionality stable model semantics
justifying correctness method.
follows, use new atoms , , appearing At(1 ) At(2 )
atom a, use shorthand = {a | A} set atoms,
848

fiModularity Aspects Disjunctive Stable Models

analogously dened shorthands . Moreover, diff, unsat, unsat , ok new
atoms appearing At(1 ) At(2 ). translation EQT(1 , 2 ),
summarized Denition 8.4 below, consists following three parts:
(i) DLP-function 1 naturally captures stable model SM(1 ).
(ii) DLP-function hidden(2 ) = hRh , O, H , provides representation
hidden part 2 = hR, I, O, Hi evaluated respect visible part .
input signature hidden(2 ) consists visible atoms Atv (2 ) = Atv (1 ) =
O. set Rh contains rule Ah Bv Bh , (Av Cv Ch ) B, C R
Ah 6= , i.e., B, C Def R (H). hidden parts rules renamed
systematically using atoms Ath (2 ) . capture unique stable model
N (2 )h /Mv expressed Ath (2 ) rather Ath (2 ). Note existence
uniqueness N guaranteed EVA property.
(iii) Finally, DLP-function
TR(2 ) = hRTR , H , H {unsat, unsat , diff, ok}, H
provides minimality check. set RTR contains
1. rule unsat Bv Bh , (Av Ah Cv Ch ) rule B, C R,
2. rules a, , unsat a, , unsat O, rules
, , unsat , , unsat H,
3. rule unsat Bi Bo Bh , (Ai Ao Ah Cv Ch ), unsat rule
B, C R,
4. rule diff a, , unsat O, rule diff , , unsat
H,
5. following rules:
ok unsat,

ok diff, unsat, unsat ,

ok.

intuition behind translation TR(2 ) follows. rules rst
item check whether interpretation L At(2 ) corresponding actual input
K = (L (I O)) {a | L H} Atv (2 ) Ath (2 ) TR(2 ) satises
rules 2 . rules 2 satised, rules items 24 activated
literals unsat bodies. rules second item used
generate subset L L L Ati (2 ) = L Ati (2 ). achieved
introducing new atom Ato (2 ) Ath (2 ). rules third
item check whether representation L Ati (2 ) Ato (2 ) Ath (2 ) , i.e.,
K = (L I) {a | L (O H)}, satises rules L
2 . rules
fourth item check whether L proper subset L. Finally, rules fth
item summarize reasons L cannot stable model 2 , i.e., either
rules 2 satised L, L minimal model L
2 . net eect
construction, TR(2 )/K stable model L stable model 2 .
849

fiJanhunen, Oikarinen, Tompits & Woltran

Definition 8.4 Let 1 2 = hR, I, O, Hi compatible DLP-functions enough
visible atoms. Then, translation EQT(1 , 2 ) given 1 hidden(2 ) TR(2 ).
translation TR(2 ) minimality check essentially contains rules
TR(R1 , R2 ) \ R1 , TR(R1 , R2 ) translation dened Oikarinen Janhunen
(2004) sets R1 R2 disjunctive rules. two aspects, however.
First, occurrences hidden atoms H additionally represented using counterparts H . Second, need renamed versions atoms H
interpretation atoms input signature kept xed. Finally, note
DLP-functions 1 2 correspond ordinary disjunctive logic programs, i.e.,
1 = hR1 , , O, 2 = hR2 , , O, i, translation EQT(1 , 2 ) coincides
TR(R1 , R2 ).
Theorem 8.5 Let 1 2 compatible DLP-functions enough visible atoms.
Then, 1 2 iff SM(EQT(1 , 2 )) = SM(EQT(2 , 1 )) = .
Proof sketch. Let 1 2 = hR, I, O, Hi compatible DLP-functions enough
visible atoms. Theorem 5.7, given compatible interpretations M1 At(1 ), M2
At(hidden(2 )), M3 At(TR(2 )), = M1 M2 M3 stable model translation EQT(1 , 2 ) M1 SM(1 ), M2 SM(hidden(2 )), M3 SM(TR(2 )). Given
interpretation M1 At(1 ), unique stable model M2 SM(hidden(2 ))
compatible M1 , since 2 EVA property. Hence, hidden(2 ) constrain
stable models composition EQT(1 , 2 ). Whenever M3 compatible M1
M2 , holds M3 (I OH ) = (M1 M2 )(I OH ) M3 SM(TR(2 ))
interpretation M3 (I O){a H | M3 } stable model 2 established
Oikarinen Janhunen (2004, Theorem 1).

verifying modular equivalence DLP-functions forms 1 2 ,
possible streamline translations involved verication task.
Theorem 8.6 Let 1 2 compatible DLP-functions enough visible atoms,
DLP-function 1 2 defined. Then, 1 2
iff SM(EQT(1 , 2 ) ) = SM(EQT(2 , 1 ) ) = .
context arbitrary DLP-function, i.e., necessary
EVA property, long 1 2 dened. prove Theorem 8.6, notice
due structure translation, EQT(1 , 2 ) dened whenever 1
dened, Theorems 5.7 8.5 applied.

9. Related Work
Eiter et al. (1997a) consider use disjunctive datalog programs query programs
relational databases. approach, query programs formalized triples h, R, Si
set disjunctive rules R signatures input output
relations, respectively, whereas auxiliary (hidden) predicates left implicit. Hence,
propositional case, notable dierence respect Denition 2.1 input
atoms allowed occur heads disjunctive rules. regards semantics,
850

fiModularity Aspects Disjunctive Stable Models

program reduced respect complete input database specied terms
R, yielding instantiation [D], and, among others, stable-model semantics applied
[D] analogy Denition 3.2. However, contrast modular architecture, Eiter
et al. (1997a) take positive negative dependencies account recursion
modules tolerated. resulting hierarchy complete components admits
straightforward generalization splitting sequences (Lifschitz & Turner, 1994).
essential dierence partial order rather total order modules assumed.
respect, worth pointing partial orders DLP-functions permitted
.
Modularity gained attention context conventional (monotonic) logic
programming; see work Bugliesi, Lamma, Mello (1994) survey. Two mainstream approaches identied: rst called programming-in-the-large algebraic operators introduced construction logic programs modules.
approach paper falls categorythe join example operators.
other, quite dierent programming-in-the-small approach, extend underlying logical language terms abstraction mechanisms. approach Eiter et al.
(1997b), instance, logic program modules viewed generalized quantifiers
allowed nest hierarchical fashion. give idea approach, consider
module formalizes transitive closure relation denoted predicate rel(, ):
tclo(x, y) rel(x, y);

tclo(x, y) tclo(x, z), rel(z, y).

Here, tclo(, ) acts output predicate module tclo[rel] whereas rel(, )
input predicate. module invoked create transitive closure binary
relation substituted rel(, ) above. Consider, instance, rule
loop(x) tclo[edge](x, y), tclo[edge](y, x)
captures nodes involved loops directed graph whose edges supposed
represented predicate edge(, ). approach, call tclo[edge] would result
one module part respective ground program input output signatures
= {edge(x, y) | 1 x, n} = {tclo(x, y) | 1 x, n}
case n vertices. However, architecture Eiter et al. (1997b), module
tclo[rel] invoked several times form transitive closures dierent relations.
eectively propositional approach, invocation tclo[rel] would map new module.
Although modules could obtained straightforward renaming predicates,
aspect illustrates power programming-in-the-small approach. Here, tclo[rel] acts
new parameterized connective programmer concisely refer new
relation, viz. transitive closure rel case. But, spite succinctness
point, relations may unwound actual implementation. aspect
made explicit modular action description (MAD) language proposed Lifschitz
Ren (2006): modular action description turned single-module description
recursive fashion. outcome determines meaning modular description via
embedding ASP (Lifschitz & Turner, 1999).
Faber, Greco, Leone (2007) apply magic-set method evaluation datalog
programs negation. notion module based concept independent
851

fiJanhunen, Oikarinen, Tompits & Woltran

set. non-disjunctive logic program = hR, , O, i, set satises,
S, following two conditions:
1. rule h B, C R h = a, B C S,
2. B C dangerous rule h B, C R, {h} B C S.
skip exact denition dangerous rules which, roughly speaking, may interfere
existence stable models. clear independent sets splitting sets sense
Denition 5.15, vice versa general. Hence, module theorem provided
Faber et al. (2007) viewed special case splitting-set theorem and, therefore,
observations presented Section 5.3 apply independent sets well.

10. Conclusion Discussion
paper, introduced formal framework modular programming context
disjunctive logic programs stable-model semantics. framework based
notion DLP-function puts eect appropriate input/output interfacing
disjunctive logic programs. Analogous module concepts already studied
cases normal logic programs smodels programs (Oikarinen & Janhunen, 2008a)
even propositional theories (Janhunen, 2008a), special characteristics disjunctive
rules properly taken account syntactic semantic denitions DLPfunctions presented herein. respect, would draw readers attention
Denition 2.1 (item 2), Denition 2.2 (items 45), well Denition 3.2.
Undoubtedly, main result paper module theorem, i.e., Theorem 5.7,
proved DLP-functions generalthus covering class disjunctive programs. module theorem important provides compositional semantics
disjunctive programs generalizes existing approaches based splitting sets (Lifschitz & Turner, 1994) magic sets (Faber et al., 2007). Although
approach based number design decisions, e.g., regards denition module
composition, nevertheless brings limits modular programming context
nonmonotonic declarative language. module theorem exploited number ways ASP based disjunctive logic programs. demonstrated Section 6,
provides basis decomposing disjunctive programs components hence
localization reasoning tasks. Moreover, established Section 7, technique
shifting disjunctive rules generalized disjunctive programs involving head-cycles.
Actually, generalized form enables us remove shared disjunctive rules altogether
might desirable due higher space requirements. Finally, theory modular
equivalence fully applicable DLP-functions demonstrated Section 8.
addition results discussed above, anticipate applications module theorem future. strongly believe research direction yields
results theoretical interest leads development practicably useful software
engineering methods ASP. fact, rst tools decomposing linking programs
already implemented context smodels system.14 results Section 6 enable development analogous tools used disjunctive solvers
14. See modlist lpcat ASP tools collection http://www.tcs.hut.fi/Software/asptools/.

852

fiModularity Aspects Disjunctive Stable Models

claspD, cmodels, dlv, GnT. implementation general shifting
principle, called dencode, ASP tool collection. results Section 8 pave way
extending translation-based verication tool, dlpeq (Janhunen & Oikarinen, 2004),
verication modular equivalence. extension already available
respective tool, lpeq, smodels programs (Oikarinen & Janhunen, 2009).15
Acknowledgments work partially supported Academy Finland projects #211025 (Advanced Constraint Programming Techniques Large Structured Problems) #122399 (Methods Constructing Solving Large Constraint
Models), Austrian Science Foundation (FWF) projects P18019 (Formal Methods Comparing Optimizing Nonmonotonic Logic Programs) P21698
(Methods Methodologies Developing Answer-Set Programs). authors would
thank anonymous referees constructive comments well Martin Gebser Torsten Schaub suggestion exploit program completion loop formulas
proof module theorem. preliminary version paper appeared
proceedings 9th International Conference Logic Programming Nonmonotonic
Reasoning (LPNMR07), Vol. 4483 LNCS, pp. 175187, Tempe, AZ, USA, Springer.

References
Baral, C., Dzifcak, J., & Takahashi, H. (2006). Macros, macro calls use ensembles
modular answer set programming. Etalle, S., & Truszczyski, M. (Eds.), Proceedings
22nd International Conference Logic Programming (ICLP06 ), Vol. 4079
LNCS, pp. 376390, Seattle, WA, USA. Springer.
Ben-Eliyahu, R., & Dechter, R. (1994). Propositional semantics disjunctive logic programs. Annals Mathematics Artificial Intelligence, 12 (12), 5387.
Bugliesi, M., Lamma, E., & Mello, P. (1994). Modularity logic programming. Journal
Logic Programming, 19/20, 443502.
Clark, K. L. (1978). Negation failure. Gallaire, H., & Minker, J. (Eds.), Logic
Data Bases, pp. 293322. Plenum Press, New York.
Dix, J., Gottlob, G., & Marek, V. W. (1996). Reducing disjunctive non-disjunctive
semantics shift-operations. Fundamenta Informaticae, 28 (1-2), 87100.
Drescher, C., Gebser, M., Grote, T., Kaufmann, B., Knig, A., Ostrowski, M., & Schaub,
T. (2008). Conict-driven disjunctive answer set solving. Brewka, G., & Lang, J.
(Eds.), Proceedings 11th International Conference Principles Knowledge
Representation Reasoning, pp. 170176, Sydney, Australia. AAAI Press.
Eiter, T., & Fink, M. (2003). Uniform equivalence logic programs stable model
semantics. Palamidessi, C. (Ed.), Proceedings 19th International Conference
Logic Programming (ICLP03), Vol. 2916 LNCS, pp. 224238, Mumbay, India.
Springer.
15. Verification tools mentioned available http://www.tcs.hut.fi/Software/lpeq/.

853

fiJanhunen, Oikarinen, Tompits & Woltran

Eiter, T., Fink, M., Tompits, H., & Woltran, T. (2004). Simplifying logic programs
uniform strong equivalence. Lifschitz, V., & Niemel, I. (Eds.), Proceedings
7th International Conference Logic Programming Nonmonotonic Reasoning
(LPNMR04 ), Vol. 2923 LNAI, pp. 8799, Fort Lauderdale, FL, USA. Springer.
Eiter, T., & Gottlob, G. (1995). computational cost disjunctive logic programming:
Propositional case. Annals Mathematics Artificial Intelligence, 15 (3-4), 289
323.
Eiter, T., Gottlob, G., & Mannila, H. (1997a). Disjunctive datalog. ACM Transactions
Database Systems, 22 (3), 364418.
Eiter, T., Gottlob, G., & Veith, H. (1997b). Modular logic programming generalized
quantiers. Dix, J., Furbach, U., & Nerode, A. (Eds.), Proceedings 4th
International Conference Logic Programming Nonmonotonic Reasoning (LPNMR97 ), Vol. 1265 LNCS, pp. 290309, Dagstuhl, Germany. Springer.
Eiter, T., Ianni, G., Lukasiewicz, T., Schindlauer, R., & Tompits, H. (2008). Combining
answer set programming description logics Semantic Web. Artificial
Intelligence, 172 (1213), 14951539.
Erdem, E., & Lifschitz, V. (2003). Tight logic programs. Theory Practice Logic
Programming, 3 (4-5), 499518.
Faber, W., Greco, G., & Leone, N. (2007). Magic sets application data integration. Journal Computer System Sciences, 73, 584609.
Gaifman, H., & Shapiro, E. (1989). Fully abstract compositional semantics logic programs. Proceedings 16th Annual ACM Symposium Principles Programming Languages, pp. 134142, Austin, TX, USA. ACM Press.
Gebser, M., Kaminski, R., Kaufmann, B., Ostrowski, M., Schaub, T., & Thiele, S. (2008a).
Engineering incremental ASP solver. de la Banda, M., & Pontelli, E. (Eds.),
Proceedings 24th International Conference Logic Programming (ICLP08),
Vol. 5366 LNCS, pp. 190205, Udine, Italy. Springer.
Gebser, M., Schaub, T., Thiele, S., Usadel, B., & Veber, P. (2008b). Detecting inconsistencies large biological networks answer set programming. de la Banda,
M., & Pontelli, E. (Eds.), Proceedings 24th International Conference Logic
Programming (ICLP08), Vol. 5366 LNCS, pp. 130144, Udine, Italy. Springer.
Gelfond, M., & Gabaldon, A. (1999). Building knowledge base: example. Annals
Mathematics Artificial Intelligence, 25 (3-4), 165199.
Gelfond, M., & Leone, N. (2002). Logic programming knowledge representation
A-Prolog perspective. Artificial Intelligence, 138 (1-2), 338.
Gelfond, M., & Lifschitz, V. (1988). stable model semantics logic programming.
Kowalski, R. A., & Bowen, K. A. (Eds.), Proceedings 5th International Conference Logic Programming (ICLP88), pp. 10701080, Seattle, WA, USA. MIT
Press.
854

fiModularity Aspects Disjunctive Stable Models

Gelfond, M., & Lifschitz, V. (1991). Classical negation logic programs disjunctive
databases. New Generation Computing, 9, 365385.
Gelfond, M., Przymusinska, H., Lifschitz, V., & Truszczyski, M. (1991). Disjunctive defaults. Allen, J. F., Fikes, R., & Sandewall, E. (Eds.), Proceedings 2nd International Conference Principles Knowledge Representation Reasoning, pp.
230237, Cambridge, MA, USA. Morgan Kaufmann.
Giunchiglia, E., Lierler, Y., & Maratea, M. (2006). Answer set programming based
propositional satisability. Journal Automated Reasoning, 36 (4), 345377.
Janhunen, T. (2006). (in)translatability results normal logic programs propositional theories. Journal Applied Non-Classical Logics, 16 (12), 3586.
Janhunen, T. (2008a). Modular equivalence general. Ghallab, M., Spyropoulos, C.,
Fakotakis, N., & Avouris, N. (Eds.), Proceedings 18th European Conference
Artificial Intelligence (ECAI08), pp. 7579, Patras, Greece. IOS Press.
Janhunen, T. (2008b). Removing redundancy answer set programs. de la Banda,
M., & Pontelli, E. (Eds.), Proceedings 24th International Conference Logic
Programming (ICLP08), Vol. 5366 LNCS, pp. 729733, Udine, Italy. Springer.
Janhunen, T., Niemel, I., Seipel, D., Simons, P., & You, J.-H. (2006). Unfolding partiality
disjunctions stable model semantics. ACM Transactions Computational
Logic, 7 (1), 137.
Janhunen, T., & Oikarinen, E. (2004). lpeq dlpeq translators automated equivalence testing logic programs. Lifschitz, V., & Niemel, I. (Eds.), Proceedings
7th International Conference Logic Programming Nonmonotonic Reasoning
(LPNMR04 ), Vol. 2923 LNAI, pp. 336340, Fort Lauderdale, FL, USA. Springer.
Janhunen, T., & Oikarinen, T. (2007). Automated verication weak equivalence within
smodels system. Theory Practice Logic Programming, 7 (6), 697744.
Junttila, T., & Niemel, I. (2000). Towards ecient tableau method boolean circuit
satisability checking. Lloyd, J. W., et al. (Eds.), Proceedings First International Conference Computational Logic (CL 2000), Vol. 1861 LNCS, pp. 553567,
London, UK. Springer.
Koch, C., Leone, N., & Pfeifer, G. (2003). Enhancing disjunctive logic programming systems
SAT checkers. Artificial Intelligence, 151 (1-2), 177212.
Lee, J., & Lifschitz, V. (2003). Loop formulas disjunctive logic programs. Palamidessi,
C. (Ed.), Proceedings 19th International Conference Logic Programming
(ICLP03 ), Vol. 2916 LNCS, pp. 451465, Mumbay, India. Springer.
Leone, N., Pfeifer, G., Faber, W., Eiter, T., Gottlob, G., & Scarcello, F. (2006). DLV
system knowledge representation reasoning. ACM Transactions Computational Logic, 7 (3), 499562.
855

fiJanhunen, Oikarinen, Tompits & Woltran

Lifschitz, V. (1985). Computing circumscription. Joshi, A. K. (Ed.), Proceedings
9th International Joint Conference Artificial Intelligence (IJCAI85 ), pp. 121127,
Los Angeles, CA, USA. Morgan Kaufmann.
Lifschitz, V., Pearce, D., & Valverde, A. (2001). Strongly equivalent logic programs. ACM
Transactions Computational Logic, 2 (4), 526541.
Lifschitz, V., & Ren, W. (2006). modular action description language. Proceedings
21st National Conference Artificial Intelligence (AAAI06), pp. 853859,
Boston, MA, USA. AAAI Press.
Lifschitz, V., & Turner, H. (1994). Splitting logic program. Hentenryck, P. V. (Ed.),
Proceedings 11th International Conference Logic Programming (ICLP94 ),
pp. 2337, Santa Margherita Ligure, Italy. MIT Press.
Lifschitz, V., & Turner, H. (1999). Representing transition systems logic programs.
Gelfond, M., Leone, N., & Pfeifer, G. (Eds.), Proceedings 6th International
Conference Logic Programming Nonmonotonic Reasoning, (LPNMR99 ), Vol.
1730 LNAI, pp. 92106, El Paso, TX, USA. Springer.
Lin, F., & Zhao, Y. (2004). ASSAT: computing answer sets logic program SAT
solvers. Artificial Intelligence, 157 (1-2), 115137.
Marek, V. W., & Truszczyski, M. (1999). Stable models alternative logic programming paradigm. Apt, K. R., Marek, V. W., Truszczyski, M., & Warren,
D. S. (Eds.), Logic Programming Paradigm: 25-Year Perspective, pp. 375398.
Springer.
McCarthy, J. (1986). Applications circumscription formalizing commonsense knowledge. Artificial Intelligence, 28, 89116.
Niemel, I. (1999). Logic programs stable model semantics constraint programming
paradigm. Annals Mathematics Artificial Intelligence, 25 (34), 241273.
Oikarinen, E., & Janhunen, T. (2004). Verifying equivalence logic programs
disjunctive case. Lifschitz, V., & Niemel, I. (Eds.), Proceedings 7th International Conference Logic Programming Nonmonotonic Reasoning (LPNMR04 ),
Vol. 2923 LNAI, pp. 180193, Fort Lauderdale, FL, USA. Springer.
Oikarinen, E., & Janhunen, T. (2008a). Achieving compositionality stable model
semantics smodels programs. Theory Practice Logic Programming, 8 (56),
717761.
Oikarinen, E., & Janhunen, T. (2008b). Implementing prioritized circumscription computing disjunctive stable models. Dochev, D., Pistore, M., & Traverso, P. (Eds.),
Artificial Intelligence: Methodology, Systems, Applications, 13th International
Conference (AIMSA08), Vol. 5253 LNCS, pp. 167180, Varna, Bulgaria. Springer.
Oikarinen, E., & Janhunen, T. (2009). translation-based approach verication
modular equivalence. Journal Logic Computation, 19 , 591613.
856

fiModularity Aspects Disjunctive Stable Models

Reiter, R. (1987). theory diagnosis rst principles. Artificial Intelligence, 32 (1),
5795.
Simons, P., Niemel, I., & Soininen, T. (2002). Extending implementing stable
model semantics. Artificial Intelligence, 138 (12), 181234.

857


