journal artificial intelligence

submitted published

message web service composition integrity constraints
uncertainty connection
jorg hoffmann

joe hoffmann sap com

sap
karlsruhe germany

piergiorgio bertoli

bertoli fbk eu

fondazione bruno kessler
trento italy

malte helmert

helmert informatik uni freiburg de

albert ludwigs universitat freiburg
freiburg germany

marco pistore

pistore fbk eu

fondazione bruno kessler
trento italy

abstract
thanks recent advances ai become underlying technique several applications figuring prominently among automated web service composition wsc
capability level services described terms preconditions effects ontological concepts key issue addressing wsc ontologies formal
vocabularies axiomatize possible relationships concepts axioms correspond termed integrity constraints actions change literature
applying web service essentially belief update operation reasoning required belief
update known harder reasoning ontology support belief update
severely limited current tools
first contribution consists identifying interesting special case wsc
significant tractable special case term forward effects characterized
fact every ramification web service application involves least one constant
generated output web service setting reasoning required
belief update simplifies standard reasoning ontology relates extends
current notions message wsc need belief update removed strong
often implicit informal assumption locality individual messages clarify
computational properties forward effects case point strong relation standard notions uncertainty suggesting effective tools latter successfully
adapted address former
furthermore identify significant sub case named strictly forward effects actual
compilation uncertainty exists enables us exploit shelf tools solve message wsc general form involves powerful ontologies
requires reasoning partial matches concepts provide empirical evidence
may quite effective conformant underlying planner

c

ai access foundation rights reserved

fih offmann b ertoli h elmert p istore

introduction
since mid nineties ai tools become several orders magnitude scalable
invention automatically generated heuristic functions search techniques
see mcdermott bonet geffner hoffmann nebel gerevini saetti
serina helmert chen wah hsu paved way adoption
underlying technology several applications one application area
web service composition wsc mean automated composition
semantic web services sws sws pieces software advertised formal description
composing sws means link together aggregate behavior
satisfies complex user requirement ability automatically compose web services key
reducing human effort time market constructing integrated enterprise applications
widely recognized economic potential wsc
wide spread sws frameworks owl wsmo sws described two distinct
levels one addresses overall functionality sws details precisely
interact sws former level called service profile owl service
capability wsmo sws described akin operators preconditions effects therefore prime candidate realizing wsc level
follow
setting key aspect sws preconditions effects described relative
ontology defines formal logical vocabulary indeed ontologies much
formal vocabularies introducing set logical concepts define axioms constrain behavior domain instance ontology may define subsumption relationship
two concepts b stating members necessarily members b
natural interpretation axiom context wsc every state encountered every possible configuration domain entities must satisfy axiom sense
ontology axioms correspond integrity constraints discussed actions change literature
ginsberg smith eiter gottlob brewka hertzberg lin reiter
mccain turner herzig rifi hence wsc considered
presence integrity constraints since constraints affect outcome action executions
facing frame ramification execution actions corresponds closely
complex notions belief update lutz sattler herzig lang marquis polacsek
unsurprisingly providing support integrity constraints modern scalable tools mentioned poses serious challenges best knowledge yet
attempted
regarding existing wsc tools tools employed solving wsc
situation isnt much better tools ignore ontology e act constraints
domain behavior given ponnekanti fox srivastava narayanan mcilraith
sheshagiri desjardins finin pistore traverso bertoli b pistore marconi bertoli traverso agarwal chafle dasgupta karnik kumar mittal srivastava
approaches tackle full generality belief update general reasoners
example see work ankolekar et al burstein et al
example see work roman et al fensel et al
integrity constraints sometimes called state constraints domain constraints



fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

suffer inevitable performance deficiencies eiter faber leone pfeifer polleres
giunchiglia lee lifschitz mccain turner
planningbased
formalization

wsc formalism

variant

restriction
rich version

forward effects

wsc

planningbased
formalization

messagebased wsc

restriction

conformant


tackled

strictly forward effects

figure overview wsc frameworks addressed special cases
identified herein shown red boldface
work addresses middle ground two extremes e trade
expressivity scalability wsc via identification special cases
tackled efficiently figure gives overview wsc frameworks involved
brief forward effects case requires every effect ramification web service
affects least one constant generated web services output situation
frame trivializes making similar common notions
conformant smith weld bonet geffner cimatti roveri bertoli
hoffmann brafman discuss existing tools latter particular
conformant hoffmann brafman extended deal wsc forward
effects strictly forward effects action effects required affect outputs
devise actual compilation conformant thus obtain scalable tool interesting
wsc integrity constraints particular able exploit heuristic
techniques mentioned hoffmann nebel hoffmann brafman
follows explain parts figure little detail starting
point wsc formalism addressing wsc terms presence integrity constraints discussed formalism essentially enriched form conformant
distinguishing aspects
initial state description conjunction literals possibly mentioning
logical facts task hence introducing uncertainty
actions conditional effects semantics meaning executed state
effect applicable
actions may output variables e may create constants
set integrity constraints universally quantified clause
semantics action execution defined terms belief update operation
section provides details choices motivates example
literature formalism hard particularly


fih offmann b ertoli h elmert p istore

even testing whether given action sequence plan p complete contrast
common notions conformant plan testing conp complete
see forward effects remove additional complexity intuitively forward effects
case covers situation web service outputs constants sets characteristic
properties relative inputs relies ontology axioms describe ramifications
concerning constants case syntactically characterized follows
every effect literal contains least one output variable
within integrity constraint every literal set variables arguments
definition best understood example consider following variant widespread virtual travel agency vta web services book travel accommodation must
linked web services generate constants corresponding tickets reservations
example integrity constraints stating subsumption z trainticket z
ticket z web service bookticket may input variable x precondition train x
output variable effect trainticket ticketfor x forward effects task
every effect literal contains output variable integrity constraint single variable
z provides arguments literals constraint say one instantiates input
bookticket constant c output constant applying resulting
ground action state train c holds true constant gets created characteristic
properties relative inputs trainticket ticketfor c set directly action
integrity constraint takes care ramification establishing ticket holds note
status c apart relation affected way
forward effects case closely related wide spread notion wsc
refer message wsc approaches composition semantics
chaining input output messages web services one sense inferences
ontology axioms made many approaches restricted way limited
assumption locality individual messages interferences affect particular
message transfer implications transfers ignored locality assumption
usually made informal way often stated explicitly one contribution work
shed light issue via identification forward effects case lies
message wsc full framework belief update semantics
message wsc forward effects case share focus output constants
two important differences first forward effects case restricted messagebased wsc terms ontology axioms allowed essentially forward effects correspond
special case wsc locality assumption message wsc actually justified
within full framework second full framework comes benefit increased
flexibility combination services locality enforced e g output one
service may reused several points plan
computational point view key property forward effects case
removes need belief update nutshell reason actions affect propositions e propositions involving least one output constant recall point made
latter would case effect bookticket included literal affecting x example
train x integrity constraint capable mixing old constants example x
trainticket train x



fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

unchanged status c vta example output constant example
exist prior application action hence previous belief carries knowledge
need revised consider characterization forward effects given
condition ensures immediate effect action affects propositions condition ensures changes propositions propagate propositions since
literals constraint share variables output constant question copied
see virtue properties complexity plan testing conp complete
rather p complete forward effects case
complexity reduction critical reduced complexity
common notions conformant initial state uncertainty therefore feasible adapt conformant tools address wsc forward effects scalable
tools conformant already developed cimatti et al bryce kambhampati smith hoffmann brafman palacios geffner hence
promising line example focus conformant tool hoffmann
brafman short cff outline main steps need taken adapting cff
handle wsc forward effects
identify case actual compilation conformant initial
state uncertainty exists one must fix set constants priori manner
fairly standard see e g settlers domain long fox simply include set
subset potential constants used instantiate outputs subtle idea
put forward identify condition actions predict properties
assigned potential constants case created enables us design
compilation moves action effects initial state formula uses actions
modify set constants already exist way reasoning initial state formula
compiled task reasoning output constants original task
reasoning mechanisms included tools cff naturally used implement latter
trick predicting output properties require actions compatible sense
produce different outputs effects turns condition
naturally given restriction forward effects call strictly forward effects
web service effects concern constants
clearly able reference inputs limitation example longer
say vta example output ticket input x still strictly forward
effects case describes interesting class wsc class corresponds web services
modeled early versions owl example logical connection
inputs outputs class wsc allows powerful ontologies
universally quantified clauses makes possible combine services flexibly
compilation class solved shelf tools
uncertainty
validate compilation empirically running number tests cff
underlying planner use two test scenarios scalable variety parameters covering range different structures examine cff reacts
parameters viewed isolation demonstrate large complex wsc instances
comfortably solved modern heuristics
comparison alternative wsc tools problematic due widely disparate nature
kinds tools solve kinds input languages understand


fih offmann b ertoli h elmert p istore

purpose respective developers mind nevertheless provide assessment
comparative benefits run tests dlvk tool eiter et al
eiter faber leone pfeifer polleres dlvk one tools
deals ontology axioms called static causal rules directly without need restrict
forward effects without need compilation since context work
main characteristic wsc presence ontology axioms means dlvk one
existing native wsc tools comparison forward effects compilation
solves similar sacrifices expressivity question principle
gain anything sacrifice absolutely answer yes dlvk much slower
compilation cff solving small fraction test instances even provided
correct plan length bound emphasize wish state
due mentioned differences tools conclusion draw
trade expressivity scalability wsc important forward effects case
seems constitute interesting point trade
organized follows first section provides background necessary
understand context contribution work section introduces wsc
formalism section defines discusses forward effects section introduces compilation
uncertainty section presents empirical discuss closely
related work relevant points text section provides complete overview
finally section concludes discusses future work improve readability proofs
moved appendix replaced text proof sketches

background
context work rather intricate wsc topic posing many different
challenges existing techniques effect field populated disparate works differing considerably underlying purpose scope words common ground
fairly thin area work actually involves three fields wsc
reasoning actions change relevant understanding contribution
reasons explain background detail first discuss wsc general
wsc particular state relevant facts belief update finally
consider message wsc
wsc wsc
composition semantic web services received considerable attention last years
general formulation shared large variety works focuses capability
level web service conceived atomic operator transforms concepts
specifically service defined via iope description service receives input set
typed objects provided precondition p holds produces output set
typed objects effect e guaranteed hold typing objects exchanged
services given terms membership concepts concepts classes defined
within ontologies exploit description logics dl form logic formally
define universe concepts admitted discourse ontology express complex relationships among concepts subsumption hierarchy way objects belonging concept
structured parts referring concepts


fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

general setting instantiated ways depending kind conditions
admitted preconditions effects services kind logics underlying ontology
definitions independent semantic web service composition stated
one linking appropriately set existing services aggregate behavior
desired service goal illustrate consider following example
inspired work thakkar ambite knoblock e services bioinformatics
relies actual structure proteins see example petsko ringe branden
tooze chasman fersht
example say want compose web service provides information different classes
proteins ontology states classes proteins exist structural characteristics
may occur available information service every structural characteristic
presentation service combines range information given particular protein class
composed web service run relevant information services present output
concretely classes proteins distinguished location cell membrane intermembrane modeled predicates protein x cellprotein x membraneprotein x
intermembraneprotein x along sub concept relations x cellprotein x
protein x individual protein characterized following four kinds structures
primary structure states proteins sequence amino acids e g kw x protein called glyoxalase n x protein called triosephosphate isomerase
secondary structure states proteins external shape terms dssp dictionary secondary structure proteins code admitting limited set possible values
example g indicates turn helix b sheet total set values
g h e b
tertiary structure categorizes proteins shape
subset proteins quaternary structure categorizes proteins shape
combined complexes proteins amounting different shapes see example
dcomplex org
axioms constrain domain apart mentioned subconcept
relations first obvious axioms specify protein value four
kinds structures e protein sequence amino acids external shape etc however
complex axioms particular kinds proteins come particular structure
values modeled axioms
x cellprotein x g x n x
x cellprotein x b x kw x complexbarrel x
dssp code z information service named getinfodsspz whose precondition
z x whose effect infodssp output service similarly information services amino acids shapes shapes complexes presentation service
named combineinfo requires information four kinds structures created
effect combinedpresentation output combineinfo


fih offmann b ertoli h elmert p istore

input composed web service protein c logical constant class
goal x combinedpresentation x solution reason characteristics may
occur apply respective information services run combineinfo variant
additional requestinfo service used initiate information request e
output requestinfo protein c class
example shows ontology axioms play crucial role form wsc formulating
complex dependencies different concepts note applying web service may indirect consequences implied ontology axioms example output requestinfo
service implications kinds information services required
another interesting aspect example requires sws community calls partial matches opposed plug matches paolucci kawamura payne sycara li
horrocks kumar neogi pragallapati ram consider situation one
wants connect web service w another web service w w executed prior
w output w used instantiate input w w w said
partial match given ontology axioms output w sometimes suffices provide
necessary input w contrast w w said plug match given ontology
axioms output w suffices provide necessary input w
plug matches tackled many approaches wsc whereas partial matches tackled
part reason probably plug matches easier handle many types
wsc indeed existing wsc tools support plug matches see detailed
discussion wsc tools section example cannot solved plug matches
information services provides necessary input combineinfo service
particular cases
base work formalism allows specify web services e actions
outputs allows specify ontology axioms axioms interpreted integrity
constraints resulting semantics corresponds closely common intuitions behind wsc
well existing formal definitions related wsc lutz sattler baader lutz
milicic sattler wolter liu lutz milicic wolter b de giacomo lenzerini poggi rosati since one main aims able exploit existing
techniques consider particular form ontology axioms correspondence representations used existing tools uncertainty namely axioms
universally quantified clauses example subsumption relation x trainticket x
ticket x mentioned usual b abbreviation b task
specifies set clauses interpreted conjunction clauses note provides
significant modeling power meaning universal quantification clauses
clauses hold objects logical constants known exist sense
interpretation formulas closed world customary tools however contrast
standard formalisms including pddl assume fixed set constants
rather specification actions outputs enables dynamic creation constants
quantifiers ontology axioms range constants exist respective world
similar fashion goal may contain variables existentially quantified
constants used instantiate goal may pre existed may generated
terminology works slightly different use describe additional kinds
matches details given section



fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

outputs web services applied path world consider
illustration goal x combinedpresentation x example goal variable x
instantiated output created combineinfo service
another important aspect formalism allow incomplete initial state
descriptions initial state corresponds input user provides composed web
service certainly cannot assume contains complete information every aspect
world example initial state tells us class proteins interested
leaves open consequences regarding possible structural characteristics
consider case observability e conformant outcome
wsc sequence web services satisfies user goal possible situations
customary conformant actions conditional effects semantics e fire
precondition holds true otherwise nothing note way obtain notion
partial matches solution employs different actions depending situation
main difference formalism formalisms underlying current tools presence integrity constraints effect semantics executing actions semantics defined belief update operation
belief update
correspondence web service applications belief update first observed lutz
sattler followed baader et al liu et al b de giacomo
et al original statement belief update given belief
e logical formula defining worlds considered possible given formula
update intuitively corresponds observation telling us world changed
way true want obtain formula defining worlds
possible given update certainly need ensuring corresponds
well known ramification time however world change
unnecessarily want close possible among formulas
satisfy corresponds frame
say want apply action presence integrity constraints describes
worlds possible prior application resulting set possible worlds
integrity constraints correspond formula ic holds require
hold update formula given conjunction action effect ic e
effa ic means update previous belief information
effa formula required hold ic still true example may
action effect c subsumption relation concepts b formulated clause
x x b x update formula c x x b x ensures b c true

belief update widely considered literature ai databases see example
fagin kuper ullman vardi ginsberg smith winslett katzuno
mendelzon herzig herzig rifi liu et al b de giacomo et al
approaches differ exactly defined best consensus
one adequate every application context approaches
course generally observability partial web service effects uncertain consider
generalizations extending notions accordingly straightforward future work



fih offmann b ertoli h elmert p istore

agree hold updated state affairs major differences lie
exactly taken mean close possible authors
example brewka hertzberg mccain turner herzig giunchiglia
lifschitz argue notion causality needed addition even instead
notion integrity constraints model domain behavior natural way counter
arguments neither follow causal work reason ontologies
context wsc example ontologies formulated web ontology language owl
mcguinness van harmelen incorporate notion causality given
set axioms made intention describe behavior domain rather
behavior exhibits changed particular web services idea work try
leverage reasonably close consideration causal
approaches wsc left future work
belief update computationally hard eiter gottlob liberatore
non causal approaches defining reasoning typically
harder reasoning class formulas used formulating specifically deciding
whether particular literal true p hard even complete conjunction
literals corresponding single world state propositional cnf formula
conp hard even single world state propositional horn formula
use formalism checking plan testing whether
given action sequence plan p complete deciding polynomially bounded plan
existence p complete
given complexity perhaps unsurprising support integrity constraints current tools severely limited existing tools support integrity
constraints namely eiter et al giunchiglia et al generic
deduction satisfiability testing answer set programming hence lack planningspecific heuristic search techniques key scalability modern tools
developed since mid nineties even investigated yet integrity constraints could handled latter tools existing ventures direction implements called derived predicates modern tools thiebaux
hoffmann nebel gerevini saetti serina toninelli chen et al
postulates strict distinction basic predicates may affected actions
derived predicates may affected integrity constraints taking form logic programming rules predicate appears action effect allowed appear
head rule desirable restriction context wsc web services
bound affect properties constrained ontology axioms
existing work connecting wsc belief update lutz sattler baader et al
liu et al b de giacomo et al theoretical nature actual implemented wsc tools make severe simplifying assumptions often assumption ignore
ontology axioms ponnekanti fox srivastava mcilraith son sheshagiri
et al sirin parsia wu hendler nau pistore et al b sometimes
ontology constraints restricted subsumption hierarchies makes update
easy constantinescu faltings constantinescu faltings binder b sirin
parsia sirin parsia hendler discuss dealing ontology axioms wsc make connection belief update describe alternative
solution finally authors example meyer weske deal ontology ax

fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

ioms composition provide formal semantics specify exactly
action applications handled seems fully formalized wsc approaches implicitly
assume message framework frameworks closely related forward effects
special case identified herein
message wsc
message approaches wsc composition semantics chaining input
output messages web services word message standard term context
authors use individual vocabulary far aware first appearance
word message wsc title work liu ranganathan riabov
work describes message wsc follows solution directed acyclic graph dag
web services input needed web service dag graph node w must provided
outputs predecessors w graph plan determines fixed connections
actions reasoning takes place within connections two connections
different output input messages e two graph edges ending different node
assumed mutually independent consider following example illustration say web
service w effect hasattributea c output constant c input e c
existed already prior application w say axiom x hasattributea x
conceptb x expressing attribute domain restriction x value attribute
x must concept b given ws effect implies conceptb c suppose
belief prior applying w constrain c concept b applying w leads
knowledge c hence need non trivial belief update taking account changed
status c implications may message wsc simply acts latter
case checks whether w correctly supplies inputs web services w w
connected fact hasattributea c may taken part proof
effect w implies precondition connected web service w considered
implications hasattributea c may respect previous state affairs
sense message wsc ignores need belief update
intuitions underlying message wsc fairly wide spread many papers use
less direct way many approaches explicitly define wsc solutions
dags local input output connections zhan arpinar aleman meza lecue
leger lecue delteil kona bansal gupta hite liu et al ambite
kapoor works constantinescu faltings constantinescu et al
b meyer weske message assumptions implicit
manifest mainly sense ontology axioms used infer properties
output messages often checking whether inferences imply desired input
message definitely given
previous work message wsc address message wsc relates
notions belief update considered literature one contribution work
shed light issue via identification forward effects case lies
message wsc full framework belief update semantics
message wsc forward effects case share focus outputs indeed
output constants generated actions viewed messages output constant
represents information object created one web service form



fih offmann b ertoli h elmert p istore

input web service forward effects case due restriction axioms
individual messages interact much message wsc main difference
message wsc ignores possible interactions forward effects actually
arent interactions according formal execution semantics sense
forward effects correspond special case wsc assumptions message wsc
justified
reconsider example featuring web service w effect implying
conceptb c c pre existing constant explained message wsc
simply ignore need updating knowledge c contrast forward effects case
disallows axiom x hasattributea x conceptb x may lead
conclusions old belief note literals axiom refer different sets variables
forward effects case differs significantly approaches message wsc
terms flexibility allows combine actions plans messagebased dags solution dag ensures inputs service w
provided ws predecessors plug match set w ws
predecessors dag w note slightly general usual notion
plug matches w may greater hence single service w may
partial match w notion used amongst others liu et al
authors example lecue leger lecue delteil restrictive
consider every individual input x w turn require exists w w
w plug match x e w guarantees provide x even generous
two definitions partial matches restricted appear locally dag links every
action web service required executable point applied
words services used fixed manner considering dynamics actual execution
example would mean information services regardless class
protein hence completely ignoring relevant
forward effects case incorporates much general notion partial matches happens straightforward way exploiting existing notions form conditional effects semantics standard notion conformant solution defines partial matches
must work together global level accomplish goal best knowledge
one line work wsc constantinescu et al constantinescu faltings
constantinescu et al b incorporates comparable notion partial matches
work web services characterized terms input output types handle partial
matches called switches combine several web services way ascertains relevant
cases covered switches designed relative subsumption hierarchy types
note subsumption hierarchies special case much general integrity constraints
universally quantified clauses consider work

formalizing wsc
solid basis addressing wsc define formalism featuring integrity constraints
fly creation output constants incomplete initial state descriptions actions conditional effects semantics application actions defined belief update operation following possible winslett definition belief update somewhat
canonical widely used discussed particular underlies recent work



fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

relating formalizations wsc lutz sattler baader et al liu et al b
de giacomo et al de giacomo lenzerini poggi rosati
section belief update operations equivalent anyway soon
forward effects case recall forward effects case central object
investigation
first give syntax formalism denote wsc give semantics conclude analysis main computational properties
syntax
denote predicates g h variables x z constants c e literals possibly negated predicates whose arguments variables constants arguments constants
literal ground refer positive ground literals propositions given set p predicates
set c constants denote p c set propositions formed p
c given set x variables denote lx set literals l use variables
x note l may use arbitrary predicates constants l literal write
l x indicate l variable arguments x x x xk c c ck
l c ck x xk denote respective substitution abbreviated l c
way use substitution notation construct involving variables slightly abusing
notation use vector constants denote set constants appearing
function assigns constants variables x l x denote substitution
argument x x replaced x concerned first order logic
whenever write formula mean first order formula denote true false
clause integrity constraint disjunction literals universal quantification
outside variables quantified exactly appear least one literals
example x g x h x integrity constraint x z g x h x x
g x h x operator tuple xo preo yo effo xo yo sets variables preo conjunction literals lxo effo conjunction literals lxo yo
intended meaning xo inputs yo outputs e constants created
operator operator action given prea effa preo effo ca xo ea yo
ca ea vectors constants ea require constants pairwise different makes sense output constant twice given action refer
inputs outputs ca ea respectively use notations prea effa
obvious meaning
wsc task task tuple p ic c g p set predicates
ic set integrity constraints set operators c set constants initial
constants supply conjunction ground literals describing possible initial states g
conjunction literals existential quantification outside describing goal states
e g x g x h predicates taken p constants taken c
constructs e g sets conjunctions finite sometimes identify ic
conjunction clauses contains note existential quantification goal variables
one could course introduce general notations logical constructs set predicates constants
however herein two notations given suffice
stated address disjunctive non deterministic effects topic future work



fih offmann b ertoli h elmert p istore

provides option instantiate goal constants created obtaining objects
requested goal may possible use outputs
formulas occurring p ic c g may make use constants c
specifically case clauses ic goal formula g allowing use
constants effect complexity algorithmic conceivable
feature may useful simple example vta domain user may wish select
particular train say train company provides table trains itineraries table
represented possibly help ic stating constraints hold particular trains
user select train say ice pose goal ticketfor ice
constraining produced ticket way would possible without use pre existing
constants would least require rather dirty hack e g encoding desired train terms
special predicate
operator descriptions preconditions effects may use constants c
value benign ic g one replace constant c
precondition effect input output variable x instantiate x
c note however would give planner option uselessly instantiate x
constant may hence affect performance example might
special operator booking ticket ice e g train particular ticketing regulations
correspondence wsc task web service composition task fairly obvious
set p predicates formal vocabulary used underlying ontology set ic
integrity constraints set axioms specified ontology e domain constraints
subsumption relations set operators set web services note formalization
corresponds closely notion iope descriptions inputs outputs preconditions
effects ankolekar et al burstein et al action corresponds web service call
web services parameters instantiated call arguments
constructs c g extracted user requirement composition
assume requirements take form iope descriptions c
user requirement inputs user requirement precondition words c
describe input given composition user similarly g user requirement effect
condition user wants accomplished user requirement outputs
existentially quantified variables g
semantics
follows assume given wsc task p ic c g able model
creation constants states called world states formalism enriched set
constants exist state pair cs cs set constants
cs interpretation e truth value assignment p cs quantifiers taken range
constants exist state c interpretation formula
writing mean c c except quantifiers
restricted range c avoid clumsy notation sometimes write abbreviate

core definition specifies application action affects state defined
form belief update let us first define latter assume state set constants
c cs formula define update c set interpretations



fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

creating constants c cs updating according semantics proposed
winslett
say c interpretations define partial order interpretations
setting
p p cs p p p p cs p p



words ordered iff differs proper subset values given
formally define update c let arbitrary c interpretation define
update c



hence update c defined set c interpretations satisfy
minimal respect partial order put different terms update c contains
interpretations differ set inclusion minimal set values
assume action say applicable short appl prea
ca cs ea cs top usual precondition satisfaction require
inputs exist outputs yet exist executing

c c cs ea update c ic effa appl

res

otherwise
note executed even applicable case outcome singleton
set containing e action affect state important aspect
formalism get back ic effa unsatisfiable obviously get
res say case inconsistent
overall semantics wsc tasks easily defined via standard notion beliefs
model uncertainty true state world belief b set world states
possible given point time initial belief
b cs c ic



action inconsistent belief b inconsistent least one b latter
case res b undefined otherwise defined

res

res b
sb

extended action sequences obvious way plan sequence ha
res b ha g



illustration consider formalization example section
example reconsider example sake conciseness formalize part
example simplified axioms wsc task defined follows
unless ic mentions constants operator inconsistent action
inconsistent operators principle filtered pre process



fih offmann b ertoli h elmert p istore

p protein cellprotein g h n kw infodssp info combinedpresentation
predicates unary
ic consists clauses
x cellprotein x protein x subsumption
x protein x g x h x x least one dssp value
x protein x n x kw x least one shape
x cellprotein x g x n x dependency
x cellprotein x h x n x dependency
consists operators
getinfodsspg x g x infodssp
getinfodssph x h x infodssp
getinfodsspi x x infodssp
getinfo n x n x info
getinfo kw x kw x info
combineinfo x x infodssp x info x combinedpresentation
c c cellprotein c
g x combinedpresentation x
illustrate formalism consider plan example task
initial belief b consists states cs c ic cellprotein c say
apply following sequence actions
apply getinfodsspg c b get belief b b except
b g c states generated constant
infodssp
apply getinfodssph c b get belief b states
infodssp generated b h c
apply getinfo n c e b yielding b
apply getinfo kw c e b yields b get e info e b
n c kw c
apply combineinfo e f b brings us b b except
b e cs states generated f combinedpresentation f
dependencies ic last two clauses get b satisfies g c
h c subsumption clause clause regarding shapes first third clauses
get b satisfies n c kw c hence easy verify b
g hgetinfodsspg c getinfodssph c getinfo n c e getinfo kw c e
combineinfo e f plan


fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

note plan make use getinfodsspi c obtain plan domain
one apply information services however plan trivial take
account relevant reasoning ic enables us better plans
semantics executing non applicable actions vital workings example
pointed definition res equation executed even
applicable realizes partial matches web service called soon might match
one possible situations terms actions conditional effects semantics
contrasting notion would enforce preconditions e say res undefined
applicable would correspond plug matches
example partial match semantics necessary order able apply actions
cover particular cases example consider action getinfodsspg c applied
initial belief example plan precondition action g c however
states initial belief satisfy precondition initial belief allows
interpretation satisfying ic cf equation interpretations satisfy h c
rather g c due partial match semantics getinfodsspg c affect
states match initial belief partial
clarification order regarding understanding constants first every pddllike formalism aware make unique name assumption e different
constants refer different objects second understanding web services output
create separate individual e separate information object
latter directly raises question allow actions share output constants
answer allow planner treat two objects makes
sense two objects play role plan consider example actions
getinfodsspg c getinfodssph c share output constant means
one name two separate information objects two objects properties
derived infodssp difference created different
cases namely states satisfy g c h c respectively single name
two objects useful take name parameter actions need
distinguish different cases example combineinfo e f action
hinted cases correspond different classes concrete execution traces
importantly particular execution trace output constant created see
consider execution trace ak sk e alternating sequence states
actions b si res si ai k say ai aj share
output constant say ai applicable si hence csi quite
obviously csl l k particular aj applicable sj
intersection output constants csj non empty cf definition appl due
definition action applicability never happen constant created twice
words never reachable state single constant name refers
one individual information object sense use one name several objects occurs
time actual execution trace actual case occur
known illustration consider getinfodsspg c getinfodssph c shared
obvious generalization allow several conditional effects per action style adl language pednault omit sake simplifying discussion extension direction straightforward



fih offmann b ertoli h elmert p istore

output example even concrete state b execution starts satisfies
g c h c one actions fire namely one comes first
remark initially experimented definition actions instantiate
inputs applied state outputs virtue execution semantics
instantiated constants outside cs framework one never choose share output
constants e use name two different outputs notion settled
strictly richer planner choose instantiate outputs constants outside cs
question make sense share outputs answering question domainindependent planner may turn quite non trivial get back discuss
possible adaptation cff section experiments reported herein section use
simple heuristic outputs shared iff operator effects identical giving indication
respective outputs may indeed play role plan
conclude sub section final interesting observation regarding modeling
framework negative effects essential part wsc formalism compiled
away simply replace negative effect g x xk notg x xk introducing
predicate state integrity constraints two equivalent introduce two clauses x xk g x xk notg x xk x xk
g x xk notg x xk simple compilation technique formal
details little intricate moved appendix action original task
denotes corresponding action compiled task vice versa similarly action
original task denotes corresponding state compiled task get
proposition compilation negative effects wsc assume wsc task p ic c

g let p
ic c g task negative effects compiled away
assume action sequence ha let b executing ha p ic




c g let b executing ha
p ic c g
state b iff b
proved straightforward application relevant definitions important aspect clauses introduced allowed forward effects
strictly forward effects special cases identified later hence hardness transfer directly
tasks without negative effects dropping negative effects cannot make easier
computational properties
perform brief complexity analysis wsc formalism general form
introduced line many related works kind eiter gottlob bylander
liberatore eiter et al consider propositional case context
means assume fixed upper bound arity predicates number input output
parameters operator number variables appearing goal number
variables clause refer wsc tasks restricted way wsc tasks fixed
arity
consider checking plans testing whether given action sequence
plan deciding plan existence latter distinguish polynomially bounded
plan existence unbounded plan existence deem particularly relevant decision
context plan generation certainly plan checks integral part plan gen

fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

eration indeed tool state space search tool performs
checks explicitly potentially many plan candidates generated search complexity
inherent effort underlies computation state transitions polynomially bounded
plan existence relevant commonly used benchmark domains plans
polynomial length wide spread intuition sws community composed
web services contain exceedingly large numbers web services finally unbounded plan
existence general decision involved thus generic interest
turn hard prove reuse adapt
literature start complexity plan checking hardness follows
long established eiter gottlob regarding complexity belief update
detailed proofs available appendix
theorem plan checking wsc assume wsc task fixed arity sequence
ha actions p complete decide whether ha plan
proof sketch membership shown guess check argument guess proposition
values along ha check whether values comply res lead
inconsistent action final state satisfy goal ha plan iff
case guess proposition values checking goal satisfaction polynomial checking
compliance res conp checking consistency np
hardness follows simple adaptation proof lemma eiter gottlob
proof uses reduction checking validity qbf formula x x
lemma considers case propositional belief updated arbitrary propositional
formula decision ask whether formula implied
updated belief proof complete conjunction literals e corresponds single
world state single propositional fact r true semantics x x
encoded complicated construction defining update nutshell cnf telling
us every assignment x yield world state updated belief
assignment x holds completing falsify r
difference setting lies restricted update formulas action effects
fact integrity constraints supposed hold every belief adapt
proof first taking integrity constraints clauses eiter gottlobs cnf formula
modify constraints need true fact holds e insert
every clause initial belief false otherwise corresponds exactly
action plan makes true goal eiter gottlobs fact r

remark membership theorem remains valid allowing actions multiple
conditional effects allowing parallel actions even allowing combination
hand virtue proof argument outlined hardness holds even initial state
literals complete describe single world state plan consists single action
single positive effect literal goal single propositional fact initially true
next consider polynomially bounded plan existence membership follows directly
theorem prove hardness construct task extends eiter gottlobs
construction actions allow choose valuation third existentially quantified set variables hence reduces validity checking qbf formula x z x z



fih offmann b ertoli h elmert p istore

theorem polynomially bounded plan existence wsc assume wsc task fixed arity natural number b unary representation p complete decide whether exists
plan length b
proof membership guess sequence b actions theorem check
p oracle whether sequence plan
hardness validity qbf formula x z x z cnf reduced
testing plan existence say x x xn task n actions operators
empty input output parameters oxi oxi former sets xi true latter
sets xi false action ot corresponds action used hardness
proof theorem actions equipped preconditions effects ensuring
plan must first apply n oxi oxi thereafter must apply ot course
enforcing latter requires goal fact achieved ot hence choosing
plan candidate task choosing value assignment ax variables x
construction oxi oxi actions executed one ends belief
contains single world state value assignment ax variables x corresponds
chosen actions world state basically corresponds belief hardness proof
theorem difference construction extended cater third
set variables straightforward belief executing ot satisfies
goal iff eiter gottlobs fact r holds world states virtue similar arguments
eiter gottlob latter case iff z ax x z e substitution
x z x z ax valid claim follows

final regards unbounded plan existence wsc relatively easy
obtain generic reduction described bylander prove pspace hardness plan
existence strips somewhat shockingly turns plan existence wsc undecidable
even without integrity constraints complete initial state description source
undecidability course ability generate constants fly
theorem unbounded plan existence wsc assume wsc task decision
asking whether plan exists undecidable
proof sketch modification proof bylander plan existence propositional strips pspace hard original proof proceeds generic reduction
constructing strips task turing machine polynomially bounded space latter restriction necessary model machines tape tape cells pre created positions within
bound exploiting ability create constants fly instead introduce simple
operators allow extend tape ends

able decide plan existence course significant limitation principle however limitation probably marginal importance practice tools
assume plan try rather trying prove
plan sense tools nature semi decision procedures anyway
matters decidability setting question whether one plan



fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

quickly enough e exhausting time memory relevant question
web service composition

forward effects
high complexity wsc motivates search interesting special cases
define special case called forward effects every change action makes state involves
newly generated constant
start section defining forward effects case making core observation
semantics discuss modeling power special case next discuss forward effects general perspective belief update analyze main computational
properties forward effects conclude section assessment existing
tool could adapted handle forward effects
wsc f wd semantics
forward effects special case wsc defined follows
definition assume wsc task p ic c g task forward effects iff
l x effo x yo
clauses ic x xk l x ln xn x
xn
set wsc tasks forward effects denoted wsc f wd
first condition says variables every effect literal contain least one output variable implies every ground effect literal action contains least one constant
second condition says within every integrity constraint literals share arguments
implies effects involving constants affect literals involving constants
note since x xk definition exactly variables occurring literals
xi xi x xk note may k e literals
clause may ground intentional constants mentioned clause must
taken c cf discussion section therefore clauses interaction
statements constants generated wsc f wd action
discuss modeling power wsc f wd section first observe
semantics wsc f wd much simpler general wsc one longer needs
notion minimal change respect previous state state precisely assume

wsc task predicates p say interpretation p c c set constants
say c c denote c restriction p c e interpretation p c
coincides propositions given state action define

c c cs ea cs ic effa appl

res f wd

otherwise
indeed community generally rather unconcerned undecidability cf numeric track international competitions helmerts decidability numerical



fih offmann b ertoli h elmert p istore

compare equation defined member update c ic effa
returns interpretations satisfy ic effa differ minimally equation simply set identical constants propositions constants
existed beforehand words set states get cross product old
state satisfying assignments ic effa
lemma semantics wsc f wd assume wsc f wd task reachable state action
res res f wd
proof sketch wsc f wd differs minimally follows agrees totally
set propositions p cs interpreted see denote p cs ea
set propositions arguments cs ea least one argument ea denote
ic cs ea instantiation ic constants cs ea clause
least one variable instantiated ea key argument ic effa equivalent
ic cs ea effa turn equivalent ic cs ic cs ea effa
last formula ic cs uses propositions p cs whereas ic cs ea effa
uses propositions p cs ea since reachable ic cs therefore satisfy
ic effa need change values assigned

modeling power
intuitively wsc f wd covers situation web service outputs constants sets
characteristic properties relative inputs relies ontology axioms describe
ramifications concerning constants detailed section closely corresponds
notions message wsc explored literature sense modeling
power wsc f wd comparable message wsc one widespread
approaches area
simple concrete way assessing modeling power wsc f wd consider allowed
disallowed axioms examples axioms allowed wsc f wd attribute domain
restrictions taking form x g x h x attribute range restrictions taking form
x g x h relation transitivity taking form x z g x g z
g x z note axioms easy construct case action effect even
though involves constant affects old belief example constants c e existed
beforehand action outputs sets g c g e axiom x g x
g z g x z infers g c e statement involve constant
typical ontology axioms allowed wsc f wd subsumption relations taking
form x g x h mutual exclusion taking form x g x h relation reflexivity taking form x g x x relation symmetry taking form x
g x g x express concept g contained union concepts
h hn generally express complex dependencies concepts taking form clausal constraints allowed combinations concept memberships
one example complex dependencies important domain proteins illustrated
example capturing dependencies important order able select correct web services similar situations arise many domains involve complex interdependencies
complex regulations example latter virtual travel agency discussed example german rail system kinds regulations regarding


fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

train may booked kind discount conditions modeling
regulations would enable wsc select appropriate booking services another interesting case hospital domain described de jonge van der linden willems
hospital asset tracking handled means set tracking logging
filter services transform logs extract kinds information setting would
make sense model complex dependencies web service composer may determine
hospital assets need tracked retrieved namely latter depends type operation
question kind examinations operation requires accordingly
need model categorization operations mapping sets required examinations
examinations associated hospital assets complications arise since
required examinations assets may depend particular circumstances clearly express
categorization dependencies terms clauses course captures fraction
relevant hospital considerably informed composer
tracks assets
main weakness wsc f wd allow us express changes regarding preexisting objects best illustrated considering case negative effects
community commonly used model previous properties objects
invalidated action illustration reconsider example say additional operator
dropcoffeein dmachine effect info one would normally expect
operator applied fact info deleted must established
wsc f wd according restrictions special case imposes variable info
must output dropcoffeein dmachine dropping coffee machine creates
object whose characteristic property happens info rather info clearly
intended semantics operator
model intended semantics would need instantiate pre existing constant
say belief b example constant e info e previously created
getinfo n c e wsc f wd allow us instantiate dropcoffeein dmachine
e effect info e however virtue definition action applicability
action applicable states e yet exist corresponding execution
paths getinfo n c e executed hence property info e get
deleted state e used dropcoffeein dmachine still regarded newly
created object whose characteristic property info difference action
makes plan uses name e refer two different information objects
output getinfo n c e vs output dropcoffeein dmachine play
role plan cf discussion section
interesting workaround let operators output time steps spirit reminiscent
situation calculus mccarthy hayes reiter every operator obtains extra
output variable included every effect literal time step stated stand
relation previous time steps e g next tprev tprev input variable
instantiated previous time step setting state world changes
time particular state object property different tprev
example action moves file f raedme readme could state
name f raedme tprev name f readme construction
wsc positive effects triggering negative effects via ic cf proposition



fih offmann b ertoli h elmert p istore

time steps special interpretation ordinary objects causes
least two difficulties want refer object property know time step
first place know whether actual time step tprev note
cannot maintain predicate actualtime x would require us invalidate
property tprev solution frame operators must explicitly state
every relevant property previous time step property changed time
step
conclude sub section let us consider wsc f wd generalized without losing
lemma importantly instead requiring every effect literal involves constant
one postulate literals may actually affected integrity constraints
particular predicate appear clauses certainly effect literal
predicate harmful even involve output constant one obtains potentially stronger notion considering ground literals rather predicates note kind
generalization solves difficulty time step construction presuming time steps
constrained clauses frame however persists
another possibility deviating somewhat way wsc wsc f wd currently defined define integrity constraints terms logic programming style rules along lines
eiter et al requirement wsc f wd relaxed postulate
effect literals without constants appear rule heads
remark latter observation suggests certain strategic similarity aforementioned derived predicates thiebaux et al previously used ai manage
complexity integrity constraints integrity constraints take form stratified logic
programming style derivation rules predicates appearing rule heads allowed
appear operator effects overly restricted solution wsc context effects
web services indeed likely affect concepts relations appearing ontology
axioms may wsc f wd long output constants involved
belief update
lemma specific possible winslett underlies semantics
action applications interesting consider semantics wsc f wd general
perspective belief update recall update involves formula characterizing current
belief formula describing update seek formula characterizes updated belief
wide variety definitions proposed updated belief defined
however common ground exists katzuno mendelzon suggest eight postulates
named u u every sensible belief update operation satisfy herzig rifi
discuss detail degree postulates satisfied wide range alternative
belief update operators particular call postulate uncontroversial update operators
investigation satisfy take following examine
extent draw conclusions updated belief setting forward effects
case relying herzig rifis uncontroversial postulates
note similarity situation calculus ends whereas time steps assigned specific role
formulas used situation calculus ordinary objects handled actions packages
blocks
despite difficulties theorem shows time step construction used simulate abacus
machine hence prove undecidability plan existence wsc f wd



fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

assume task predicates p given need following notations
formulas denotes formula updating belief
update semantics belief update operator
given disjoint sets constants c e p c e denotes set propositions formed
predicates p arguments contained c e exists least one
argument contained e recall p c denotes set propositions formed
predicates p arguments c
given set constants c ic c denotes instantiation ic c ic c
conjunction clauses replacing variables clause ic
x xk l x ln xn tuple c ck constants c
given disjoint sets constants c e ic c e conjunction clauses
replacing variables clause ic x xk l x
ln xn tuple c ck constants c e least one constant taken
e
ground formula p denote set propositions occurring
denote current belief update another convention given set
constants c writing c indicate p p c similarly given disjoint sets constants
c e writing c e indicate p p c e state denote
conjunction literals satisfied
first consider case similar claim lemma corresponds single
concrete world state want apply action wish characterize set states
res e wish construct formula simplicity notation denote c cs
e ea applicable nothing otherwise
ic c c p c p c
example set c since ic get desired equivalence

iia ic c ic c e effa
iib p ic c e p c e p effa p c e
iia holds trivially defined ic effa equivalent ic c e effa
equivalent ic c ic c e effa iib consequence forward effects
case every effect literal contains least one output constant hence effa contains propositions
p c e ic c e least one variable clause instantiated
constant e e since definition literals clause share variables e appears
every literal therefore ic c e contains propositions p c e
illustration consider simple vta example four predicates train x
ticket x trainticket x ticketfor x set integrity constraints ic consists
clause ic contains variable ic c e empty customary empty conjunction
taken true e



fih offmann b ertoli h elmert p istore

single axiom x trainticket x ticket x current state cs c
sets propositions except train c consider application action
bookticket c whose precondition train c whose set e output constants
whose effect effa trainticket ticketfor c setting ic c
trainticket c ticket c c train c ticket c trainticket c ticketfor c c
ic c e trainticket ticket
derive following
iii ic c c ic c e effa
characterize updated belief simply conjunction previous belief
action effect extended instantiation ontology axioms corresponds
exactly lemma illustrate continue vta example left hand side iii
refers four propositions c sets according right hand side
refers propositions trainticket ticket well proposition
ticketfor c links c
one prerequisite derivation iii make assumption best
knowledge discussed anywhere belief update literature
iv let formulas p p p p p
p p p
assumption postulates formulas talking disjoint sets variables updated
separately since formulas disjoint variables essentially speak different aspects
world seems reasonable assumption
start formula make replacements according iia leading
equivalent formula ic c c ic c ic c e effa map
formula onto iv taking ic c c ic c
ic c e effa hence separate update two parts follows
c ic c c ic c
b c e ic c e effa
according iv obtain desired formula c c e
illustrating vta example simply separate parts update talk
c talk combination constants part
update trainticket c ticket c conjoined updated trainticket c
ticket c b part update representing empty statement previous state
makes updated trainticket ticket trainticket ticketfor c
remains examine c c e need prove
c c ic c c
c e ic c e effa
essentially means prove c updating formula something already implies
incur changes updating formula yields belief equivalent formula
see compare c b


fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

two statements may sound quite trivial fact far trivial prove
wide variety partly rather complex belief update operations literature build
works katzuno mendelzon herzig rifi need two
postulates made katzuno mendelzon namely
u
u
herzig rifi prove u uncontroversial meaning satisfied belief
update operators investigated cf prove u equivalent conjunction two weaker statements one uncontroversial namely
u
statement uncontroversial however proved satisfied non causal
update operators investigation except called winsletts standard semantics winslett
latter semantics useful context anyway restriction makes
states res differ propositions mentioned update
formula case include propositions appearing ic c e bound
quite lot use winsletts standard semantics res would likely
retain hardly information
consider formula c specified c ic c c ic c
prove c indeed quite simple ic c c ic c
instantiate u ic c c u ic c obtain
ic c c ic ic c c hence c ic c c desired
said uncontroversial holds non causal update operators
except winsletts standard semantics investigated herzig rifi terms vta
example u allowed us conclude update trainticket c ticket c make
change previous belief already contains property
next consider formula c e specified b c e ic c e effa
prove postulate u get c e ic c e effa
ic c e effa update formula direction exploit u instantiate
u get ic c e effa ic c e effa
ic c e effa c e equivalent ic c e effa
c e proves claim note used postulates uncontroversial
according herzig rifi reconsidering vta example ic c e effa
trainticket ticket trainticket ticketfor c previous state say
anything propositions thus represented postulates allow us conclude
belief update operators investigated herzig rifi resulting belief
equivalent trainticket ticket trainticket ticketfor c
far restricted case belief updated corresponds single
world state consider general case characterizes belief b want
characterize set states res b first glance seems much changes
katzuno mendelzon make following postulate
u



fih offmann b ertoli h elmert p istore

means consists two alternate parts updating taking union
updated parts words compute update state state basis
statement still true c disjunction states
b rather single rest argumentation stays exactly herzig
rifi prove u uncontroversial leave
however matters simple source complications use partial
matches conditional effects semantics update formula different individual states
b hence cannot directly apply u obviously states b applicable updated differently states b applicable latter updated
somewhat subtle distinction states b constants exist different
sets constants integrity constraints update different hence obtain generic
update split equivalence classes n states within
cannot distinguished prea existing constants u
argumentation used equivalent iii last step
defining final disjunction individual appears sensible
follow immediately katzuno mendelzon
illustration consider variant vta example two preceding states one
state train c state ticket c instead
bookticket c applicable hence update different part
yielding trainticket ticket trainticket ticketfor c
update trivial yields final outcome disjunction
two beliefs
point situation much easier consider plug matches e forced preconditions instead partial matches applicable states easy
see every state b constants therefore plug matches iii follows immediately u vta example update would computed since
bookticket c would considered applicable preceding belief satisfies
train c disagrees aspect e g quite nonsensically ticket c holds
updated belief equivalent trainticket ticket trainticket
ticketfor c
computational properties
paralleling analysis general wsc section perform brief complexity
analysis wsc f wd special case consider propositional case
assumes fixed upper bound arity predicates number input output parameters
operator number variables appearing goal number variables
clause consider decision checking plans deciding
polynomially bounded plan existence deciding unbounded plan existence order
contrast cannot reuse literature much course
particular circumstances wsc f wd investigated include proof sketches
refer appendix detailed proofs
one might speculate common update would prea case example
possible adopt wsc updating prea prea gives rise
states change violate prea instead changing satisfy



fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

thanks simpler semantics per lemma plan checking much easier wsc f wd
wsc
theorem plan checking wsc f wd assume wsc f wd task fixed arity sequence ha actions conp complete decide whether ha plan
proof sketch hardness obvious considering empty sequence membership shown
guess check argument say c union c output constants appearing
ha guess interpretation propositions p c
n guess set ct constants needs time stamped action
generated outputs properties respective propositions remain fixed forever thanks
lemma check polynomial time whether ct correspond execution
ha check polynomial time whether b cn satisfy g ha
plan iff guess answer yes answer b

membership theorem remains valid allowing parallel actions multiple conditional effects provided one imposes restrictions ensuring effects actions applied simultaneously one step never self contradictory otherwise checking plans involves
consistency test plan step np complete note quite reasonable demand simultaneous actions effects contradict widely used
restrictions imposed ensure mutually exclusive effect conditions non conflicting
sets effect literals
next consider polynomially bounded plan existence membership follows directly theorem prove hardness reduce validity checking qbf formula x x
constructed task allows choose values x thereafter apply actions evaluating arbitrary values goal accomplished iff setting x exists works

theorem polynomially bounded plan existence wsc f wd assume wsc f wd task
fixed arity natural number b unary representation p complete decide whether
exists plan length b
proof sketch membership guess sequence b actions theorem
check np oracle whether sequence plan
hardness proved reduction
wk validity checking qbf formula x x
dnf normal form e j j key idea use outputs creation
time steps hence ensure operators adhere restrictions wsc f wd setting
xi allowed time step xi operators oxi oxi take
input set time steps ti required successive precondition
start next next ti ti output time step ti attach
successor ti set xi respectively time step
effect literal form xi ti xi ti respectively rest task consists
operators ot allow extending sequence time steps step b suitable value b see
operators oj allow achieving goal given j true end time
step sequence length b integrity constraints ic empty values yi
specified e variables take value initial belief



fih offmann b ertoli h elmert p istore

x x valid obviously one construct plan task simply setting
xi accordingly ot stepping time b applying oj necessitates
complicated construction direction proof namely plan may cheat
setting xi construction ensures costly plan
forced maintain two parallel sequences time steps starting faulty xi choose
sufficiently large value b together sufficiently small plan length bound b cheating
possible

final regards unbounded plan existence somewhat surprisingly turns
still undecidable wsc f wd similar key idea let actions output
time step thereby ensuring membership constructed task wsc f wd
theorem unbounded plan existence wsc f wd assume wsc f wd task decision
asking whether plan exists undecidable
proof sketch reduction halting abacus machines undecidable
abacus machine consists tuple integer variables v vk ranging positive
integers including tuple instructions state given content
v vk plus index pc active instruction machine stops iff reaches state
pc n vi initially pc initially instructions increment variable
jump another instruction decrement variable jump different instructions
depending whether variable already
difficult encode abacus machine wsc f wd task two key ideas
design operator outputs next successor integer design operators simulating
instructions stepping successors predecessors integer values latter kind
operators membership wsc f wd ensured letting operators output time step
variable values associated goal asks existence time step
active instruction

argued end section already dont deem undecidability unbounded plan
existence critical issue practice tools nature semi decision procedures
anyway particular web service composition typically expected occur real time setting
severe time outs apply
issues adapting cff
view crucial observation wsc f wd test plans conp
rather p general wsc standard notions uncertainty
complexity plan testing already resulted sizable number approaches
comparatively scalable tools cimatti et al bryce et al hoffmann brafman
palacios geffner next section certain additional
restrictions wsc f wd tools applied shelf regarding general wsc f wd
match complexity plan testing suggests underlying techniques successfully
adapted following consider detail cff tool hoffmann brafman
promising options would extend mbp cimatti et al pond bryce et al
look compilation techniques investigated palacios geffner
cff characterized follows


fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

search performed forward space action sequences
sequence cnf formula generated encodes semantics
sat reasoning checks whether plan
reasoning namely literals true executing cached
speed future tests
search guided adaptation ffs hoffmann nebel relaxed plan heuristic
relaxed makes use strengthened variant cnf formulas used
reasoning action sequences clauses projected onto
literals e literals removed respective clause
techniques self explanatory except possibly last one projecting cnf
formulas ensures relaxed remains approximation real
projected formulas allow us draw conclusions time projected
formulas handled sufficiently runtime efficiently method projecting
clauses nutshell ignore one condition literals conditional effect
relaxed graph
fairly obvious basic answers given cff e techniques apply
wsc f wd note indeed main enabling factor check plans conp
rather p general wsc enables us design desired cnf formulas
straightforward fashion plan checking p hard need replace cnf
formulas qbf formulas create worst case exponentially large cnf formulas
least technically quite challenging
adaptation cff wsc f wd immediate promise trivial involves
technical challenges regarding fly creation constants well computation
heuristic function latter brings significant opportunities wsc context
pertaining exploitation typical forms ontology axioms let us consider issues
little detail
first todays tools cff pre instantiates pddl purely propositional
representation core implemented one allows thefly creation constants pre instantiation longer possible hence adaptation
wsc f wd involves implementing entire tool challenge
difficult obstacles overcome sloppy formulation key question many
constants create one course create tuple constants outputs
every action application however seems likely would blow
representation size quickly would hence infeasible one instead share
output constants reasonable one recognize reasonable points issue
especially urgent inside heuristic function namely easy see worst case
relaxed graph grows exponentially number layers imagine example
web service w takes input type generates output type b whereas w takes
input type b generates output type starting one constant type
one type b get constants type next graph layer w w
inside heuristic function formulas come relaxed graphs quite big handling
without approximations seems hopeless discussed detail hoffmann brafman



fih offmann b ertoli h elmert p istore

applied two times get constants type next graph layer forth
dilemma probably cannot handled without making approximations relaxed
graph
one positive note seems possible exploit typical structures ontologies
practice particular practical ontologies make extensive use subsumption relations
structuring domain interest concept hierarchy additional ontology axioms often come
form constraints relations reflexivity symmetry transitivity typing number
relation arguments may make sense exploit structures optimizing
formulas associated sat reasoning certainly makes sense exploit structures
inside heuristic function one include specialized analysis sub solver techniques
recognize structures solve separately order obtain precise relaxed plans
one even try take account structures inside relaxed hence
potentially obtain fast heuristic function

compilation initial state uncertainty
certain additional restrictions shelf scalable tools
uncertainty exploited solve wsc f wd main limiting factors
tools allow generation constants tools allow specification
clausal formula initial state states deal considers
set constants fixed priori namely initially available constants plus additional potential
constants used instantiate outputs subtle observation within special
case wsc f wd dynamics states become predictable priori one deal
natural way
follows first introduce core observation case state space becomes
predictable certain sense observe predictability naturally given special
case forward effects term strictly forward effects discuss strengths limitations special case finally provide compilation strictly forward effects
initial state uncertainty
predictable state spaces
core observation notion compatible actions assume wsc f wd task p ic
c g two actions compatible ea ea effa effa
disjunct outputs hence affect disjunct sets literals since
wsc f wd effects agree completely set actions compatible ea c
every pair actions compatible
lemma states given used actions compatible every state ever reached
satisfies action effects modulo existing constants
lemma predictable state spaces wsc f wd assume wsc f wd task compatible set
actions state reached actions
ea cs effa
proof proof induction base case b claim holds definition since
cs ea say reached action applicable



fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

induction assumption nothing prove otherwise wsc f wd
lemma res c c cs ea cs ic effa
v
induction assumption applied res c c cs ea
e cs effa ic effa ea cs ea ea cs


ea ea hence effa effa prerequisite concludes argument
virtue lemma possible configurations constants
generated
v
actions characterized formula ic aa effa since parts
formula known prior set possible configurations predictable
even begin plan already know constants behave generated
list possible behaviors potential constants initial belief let actions
affect constants actually exist words compile initial state
uncertainty detail first need identify setting lemma
actually applied
strictly forward effects
given wsc f wd task must settle finite set compatible actions planner
try compose plan one option simply require every action
unique output constants appears undesirable since tasks often contain many actions
set potential constants would huge enable chaining several actions
potential constants allowed instantiate input parameters every operator hence
necessitating creation action potential constants unclear
break recursion sensible way
herein focus instead restriction wsc f wd suffices assign unique output
constants individual operators rather individual actions
definition assume wsc task p ic c g task strictly forward effects
iff
l x effo x x yo
clauses ic x xk l x ln xn x
xn
set wsc tasks strictly forward effects denoted wsc sf wd
second condition identical corresponding condition wsc f wd first condition strictly stronger wsc f wd requires least one effect literal variable taken
outputs wsc sf wd requires variables taken outputs therefore
obviously wsc sf wd wsc f wd note wsc task formulated example member
wsc sf wd
key property wsc sf wd without input variables effect actions
operator effect action set compatible need
choose set unique output constants every operator indeed every set
operators whose effects pairwise identical choose several sets output constants
group operators


fih offmann b ertoli h elmert p istore

modeling power
limitations wsc f wd discussed section naturally inherited wsc sf wd moreover unlike wsc f wd cannot state properties effect connect inputs
outputs serious limitation illustration consider small vta example
operator bookticket effect ticketfor x relating produced ticket
train x given input clearly notion ticket rather weak cannot state
ticket actually valid another interesting case one extend example considering two proteins rather one set c c c
cellprotein c cellprotein c wish encode need combined presentation
e g combinedpresentation c combinedpresentation c wsc f wd
solve including every information providing operator input variable x
effect literal example set getinfo n x n x info x
possible wsc sf wd
extent difficulties overcome encoding relevant inputs predicate names handle composition two proteins c c would essentially mean
making copy entire model renaming part c goal would g
combinedpresentation combinedpresentation operator preconditions would make
sure combinedpresentation generated combinedpresentation generated operators note rather dirty hack depends knowing
number copies needed prior equivalent solution vta would introduce
separate ticketfor x predicate every entity x ticket may bought
least would rather oversized unreadable model yet troublesome case
time step construction outlined section added output variable
effect related via effect literal next prevt previous time step prevt provided
input wsc sf wd longer relate prevt way stating time
step happens one trying encode information predicate names
would include one predicate per possible time step necessitates assuming bound
number time steps clear limitation respect natural encoding
despite wsc sf wd far pathological irrelevant special case example
applies domain proteins shown example similarly hospital domain
discussed section naturally modeled wsc sf wd generally fact
wealth wsc formalisms encode connections inputs outputs
example category contains formalisms rely exclusively specifying types
input output parameters information modeled types kind input
service requires kind output produces example input train output
ticket examples formalisms notions message composition zhan
et al constantinescu et al lecue leger lecue delteil kona
et al liu et al fact early versions owl regarded inputs outputs
independent semantic entities description logic formalization types
thus existence compilation wsc sf wd uncertainty quite
interesting shows composition model similar early versions owl general
form partial matches powerful background ontologies attacked shelf
techniques opens connection wsc



fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

compilation
compile wsc sf wd task task conformant initial state uncertainty
takes form p g p finite set propositions used finite set
actions takes form pre eff pair sets literals p
cnf formula p g conjunction literals p notions given standard
belief state semantics state truth value assignment p initial belief set states
satisfying executing action state res pre
otherwise res sadd del use standard notation gives terms
set propositions makes true uses add denote positive literals eff
del denote negative literals eff extension res beliefs definition
plan remain unchanged
assume wsc sf wd task p ic c g compiled task p g makes
use unary predicate ex expresses constants yet brought existence compilation obtained follows operator outputs
yo

yk create set constants eo e ek c c oo eo
set constants fixed priori initialize operator
v include

preo xxo ex x
v
v set actions resulting c instantiate precondition
eeo ex e give actions effect eeo ex e words instantiate os outputs eo enrich os precondition saying inputs exist
outputs yet exist replace os effect statement simply bringing outputs
existence
replacing effects way original effects go included
initial state formula initialize conjunction effo eo yo operators
instantiate clauses invic c andv
conjoin obtain final
conjoining cc ex c cc c ex c goal goal
proposition serves model goal namely introduce set artificial
goal achievement actions goal form g x v
xk x xk actions
obtained instantiating operator x xk ki ex xi goal c
goal achievement actions instantiate existentially quantified variables goal
possible constants actions added set overall compiled task takes
form p goal p simply set mentioned propositions
summary compile wsc sf wd task p ic c g conformant
task p g follows
operator create uniquesset constants eo e ek
yo yk denote c c oo eo

p contains instantiations c p plus two predicates ex goal ex
arity expresses constants yet brought existence goal arity
forms goal e g goal

actions instantiations xv
instantiated
vc yo inex x


stantiated eo preconditions

enriched


eeo ex e
xxo
v
effects replaced eeo ex e

give actions conditional effects semantics rather usual distinction forced
preconditions non forced effect conditions



fih offmann b ertoli h elmert p istore

contains goal achievement actions achieving goal preconditions instantiating g c
original action effects e conjunction effo eo yo operators

v
contains
moved


instantiated

c



ic


cc ex c
v
cc c ex c goal

terminology section means choose set actions actions
obtained operator instantiating inputs constants c
outputs eo suggested lemma initial state formula compiled
task describes possible configurations constants c effect applying
action bring respective output constants existence note although effects
compiled actions positive still hard conp complete precise due
uncertainty allow wsc operators delete constants negative effects
deleting constants compiled task
according strategy create one set output constants per operator
take account sets operators identical effects simplify
presentation carry immediately complicated strategies create
one set output constants per operator well strategies share sets output
constants operators identical effects noted however operators
whose effects identical general share outputs particular two
effects conflict e g infodssp infodssp initial state formula
unsatisfiable compiled task trivially solved empty plan
course encode solutions original
example consider task defined example specify compiled task set
c c e f c initially available constant e f potential constants
operator outputs compiled task p g following
p protein cellprotein g h n kw combinedpresentation infodssp
info ex goal predicates except goal unary one argument
consists instantiations
getinfodsspg x g x ex x ex ex
getinfodssph x h x ex x ex ex
getinfodsspi x x ex x ex ex
getinfo n e x n x ex x ex e ex e
getinfo kw e x kw x ex x ex e ex e

combineinfo f x x infodssp x info x ex x ex x
ex f ex f
goalop x combinedpresentation x ex x goal
conjunction
instantiations ic consisting five axioms given example


fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

cellprotein c
infodssp info e combinedpresentation f original action effects
ex c ex ex e ex f constants existence
goal goal yet achieved
g goal
consider plan original task see example hgetinfodsspg c
getinfodssph c getinfo n c e getinfo kw c e combineinfo e f
illustrate verify plan yields plan compiled task task
initial belief b consists states c existing constant e f satisfy
respective effects ic cellprotein c apply action sequence
apply getinfodsspg c b get belief b b except
b g c exists
apply getinfodssph c b get belief b b except
b h c exists
apply getinfo n c e b yielding b
apply getinfo kw c e b brings us b ex e b
n c kw c
apply combineinfo e f b brings us b b except b
e exist ex f
apply goalop f b yielding b
reasoning ic used example b satisfies original goal
used goalop f applicable b hence resulting belief b
satisfies goal obtain plan compiled task simply attaching goal achievement
action original plan
prove soundness completeness compilation need rule inconsistent
operators e operators whose effects conflict background theory meaning
ic xo yo effo unsatisfiable example case x x b x
contained ic effo b presence operator initial belief
compiled task empty making task meaningless note inconsistent operators
never part plan hence filtered pre process note wsc sf wd
operator inconsistent iff actions inconsistent
non goal achievement actions correspond actions original task obvious
way connection transform plans compiled task directly plans
original task vice versa
theorem soundness compilation consider wsc sf wd task p ic c g
without inconsistent operators plan ha compiled task p g
sub sequence non goal achievement actions ha plan task
p ic c g


fih offmann b ertoli h elmert p istore

proof sketch arbitrary sequence non goal achievement actions denote b belief
execution original task b belief execution compiled task
state ssin original task denote class compiled task states overvthe constants
c oo eo c
ex c cs cs ic oo effo eo
one prove b sb claim follows directly


theorem completeness compilation consider wsc sf wd task p ic c
g without inconsistent operators plan ha every operator appears
one instantiation eo outputs ha extended goal achievement
actions form plan compiled task p g obtained outputs eo

proof sketch follows immediately b sb shown proof theorem say
one executes ha compiled task ending belief b plan
compiled task obtained simply attaching one goal achievement action every tuple
constants satisfying g world state b


reader may noticed number instantiations goal achievement operator
exponential arity goal worst case instantiations must included
plan compiled task particular may happen plan constructed per
proof theorem however practical purposes appears reasonable assume fixed upper
bound number goal variables
indicated proofs theorems remain valid allowing one eo
per operator operators identical effects share output constants note operators identical effects several web services provide alternative ways achieving something
example illustrates situation cf earlier discussion section experiments
described next section groups operators identical effects assigned
output constants

empirical
compilation merits report number empirical experiments cff underlying planner start discussion general experimental
setup discuss two different test scenarios
experiments setup
implemented compilation wsc sf wd uncertainty described
connected cff tool noted although compiled
tasks delete effects solved cffs relaxed plan heuristic function
function makes relaxation ignoring one conditions effect see
earlier discussion cff section ignoring one condition significantly affects
compiled tasks effects typically involve many conditions particularly conditions
stating inputs exist outputs yet exist
one problematic point evaluating wsc choice test cases field
still rather immature due widely disparate nature existing wsc tools



fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

common set benchmarks fact web service composition topic
posing many challenges existing techniques different works differ widely terms
underlying purpose specific aspect wsc address detailed discussion
existing wsc tools given section method choose evaluation design
two test scenarios reflect intuitively relevant kinds structures potential
applications wsc scalable number interesting parameters
test reaction parameters
test scenarios artificial benchmarks cannot lead broad conclusions significance practice allow us draw conclusions behavior differently
structured test solution method scales quite well tested cases efficiently finding solutions involve many web service calls successfully employ
services really necessary viewing isolation one conclude
representation techniques heuristic functions uncertainty may useful
attack large complex wsc instances
comparison alternative wsc tools problematic due broad range tools solve different kinds solutions different kinds input
syntax language read obtain least notion empirical comparison tools
following consider expressivity general input language tool
scalability quickly tool compose existing wsc tools constitutes
separate point trade two question whether compilation
restricting wsc sf wd cff solve compiled tasks sensible point
trade
terms expressivity located general methods
eiter et al giunchiglia et al inspired actions change literature
restricted methods applied wsc far question whether gain
scalability comparison expressive methods
confirm experiments answer expected yes run dlvk tool
eiter et al handles powerful language logic programming
language particular features static causal rules similar integrity constraints
fully general wsc sense perspective dlvk native wsc tool
handles ontology axioms directly rather via restricting expressivity compiling
away particular encoded wsc test directly dlvks input language without
compilation use cff
dlvk relies answer set programming instead relaxed plan heuristics plans style many reasoning planners dlvk requires input length bound
plan hence used optimal plans running several times different bounds
cases ran dlvk bound corresponding optimal plan length
even dlvk much slower cff solving small fraction test instances
wish interpret conclude wsc sf wd constitutes interesting
point trade expressivity scalability wsc
vta example could considered one benchmark essentially every individual defines
particular version example
similarity lies static causal rules fully general integrity constraints side effect applying
action yield ramifications affecting properties inherited previous state



fih offmann b ertoli h elmert p istore

running first tests compilation noticed encoding
per section unnecessarily generous set initial states observe compiled
tasks easier solve propositions true initial state simply literals operator preconditions effects goal positive hence proposition
p appear positively initial state clause one set p initially thereby
reduce number initial states without introducing plans setting proposition
may cause unit propagations setting propositions iterate steps
fixpoint occurs resulting initial state description stricter yields better performance cff dlvk use optimized encoding experiments reported

experimented another optimization optimization makes assumption
constants requested goal generated step wise fashion intermediate
constant generated certainty generating next constant recallvthat encoding
per section existence inputs operators e condition xxo exists x
part operator precondition thus interpreted conditional effects semantics however cff dlvk offer distinction effect conditions forced preconditions
must hold entire belief
action applicable exploit distinction
v
postulate condition xxo exists x forced reduces state space may cut
solutions reduction quite beneficial cff dlvk since optimization
affects set plans switch part test cases point possible speedup tests optimization switched discussed text indicated
keyword forced name test case
use two versions cff one cffs default configuration makes use ffs enforced hill climbing search well helpful actions pruning technique hoffmann
nebel configuration cff helpful actions pruning turned search
proceeds standard greedy best first fashion open queue ordered increasing heuristic
values henceforth denote former configuration cff def latter configuration
cff std
obtained ghz pentium iv pc running linux tests run
time seconds cpu limiting memory usage gb
subsumption hierarchies
first investigate well deal scaling subsumption hierarchies
building chains successively created entities outputs purpose design test scenario
called sh demands composition web services realizing chain generation steps
every generation step deal subsumption hierarchy
scenario depicted figure n top level concepts l ln depicted
tl figure goal input l goal output ln beneath li
tree shaped hierarchy sub concepts precisely tree perfectly balanced
branching factor b depth inner nodes tree called intermediate level
simply intermediate concepts depicted il figure leaf nodes tree
called basic level simply basic concepts depicted bl figure every
non leaf concept c tree children c cb axioms x ci x c x
course reducing set initial states invalidate old plans



fitl

w eb ervice c omposition p lanning u ncertainty n ew c onnection

il

il

bl

bl

bl

bl

bl

bl

sws

sws

sws

sws

sws

sws

tl

il

bl

il

bl

bl

bl

bl

bl

figure schematic illustration sh scenario
expressing subsumption well axiom x c x c x cb x expressing
parent covered children
available web services defined follows top level concept li
leaf bli j corresponding tree structure web service available takes
bli j input outputs li corresponding wsc operator takes form oi j
x bli j x li applying n order services oi j
possible make sure constant concept li created possible cases hence
sequencing steps plan length n bd note already stated
section experiments groups operators identical effects assigned
output constants sh scenario means n oi j share
output constant hence total number output constants generated e number
potential constants initial state equal number top level concepts n
although sh scenario abstract nature representative variety relevant
situations specifically scenario model situations sets different services must
used address request none handle alone role single service
handle particular possible case example set different services
set services oi j assembled li given constant c member li e
li c holds particular possible case handled service oi j case c happens
member leaf bli j one cases must hold due coverage clauses tree


fih offmann b ertoli h elmert p istore

similar situations arise e g geographically located regional services composition
request location specific addresses locations higher inter regional level similar
pattern found e government scenarios clear cut classification activities
leads establishing several parallel services serve different departmental areas
orthogonal horizontal composition scenario model vertical composition
one function pursued concatenating existing functions case
complex procedures diverse areas e government e commerce
scenario instantiated study different aspects scalability
empirical tests measure scalability horizontal vertical direction
consider two extreme cases possible shapes individual concept trees chain
giving us instances identical numbers leaves set test scenario sh broad
b scales set test scenario sh deep b
scales scenarios n scales
designed sh trap variant second chain n concepts linked
completely irrelevant goal service variant suitable testing extent
composition techniques affected irrelevant information finally recall encoding
method
comes two versions explained default method treats input existence
v
xxo exists x conditional effects semantics whereas non default method forced
compromises completeness efficiency treating input existence forced precondition
following choices different planners cff def cff std dlvk
different encoding methods sh without trap sh broad sh deep crossproduct choices yields experiments within possible values
n possible values b e test instances cff measured performance
parameters total runtime number search states inserted open queue number
actions plan dlvk measured total runtime number actions plan
course large amount data interesting follows summarize
important observations figure shows data selected purpose part figure
shows cff std sh broad b shows cff std sh deep c shows cff def sh forcedbroad shows dlvk sh broad sh deep e shows dlvk sh forced broad
sh forced deep f shows dlvk cff std sh trap vertical axes log scaled
runtime sec horizontal axes n b c e f n fixed n
horizontal axes number leaves concept hierarchy
consider first figure b plots point efficiently cff handle
kind wsc even forced optimization comparing two plots points
difference handling broad deep concept hierarchies plots cff std runtime
shown n length chain built curves different
values b number leaves hierarchy depth b curves
different values depth hierarchy branching factor cases scaling
behavior fairly good small concept hierarchies b chains almost arbitrary
length built easily hierarchies grow runtime becomes exponentially worse note
however one curve next size hierarchies doubles growth
exponential concept hierarchies leaves e alternative cases handled
step still easily build chains steps solution involves web services
interesting aspect comparing two plots b underlying search spaces
actually identical open queues difference performance stems


fiw eb ervice c omposition p lanning u ncertainty n ew c onnection













b
b
b
b
b








































cff std sh broad















b cff std sh deep

sh broad
sh deep









































c cff def sh forced broad







dlvk sh broad sh deep




sh forced broad
sh forced deep

dlvk sh trap broad
dlvk sh forced trap broad
cff std sh trap broad
































































e dlvk sh forced broad sh forced deep



























f dlvk cff std sh trap

figure selected sh scenario see detailed explanation text







fih offmann b ertoli h elmert p istore

overhead cffs reasoning techniques consume runtime case deep
concept hierarchies hence slightly worse behavior b
run cff def test suites figure b obtain much worse behavior
example b get n reason seems ffs helpful actions
pruning enforced hill climbing greedy domain simple way overcome
use standard heuristic search instead done cff std shown figure
b hand forced optimization switched helpful actions pruning
enforced hill climbing work much better obtain significant performance boost
cff def latter pointed figure c showing data cff def sh forced broad
figure cff std sh broad plot shows curves one values
b legend omitted plot would overlap curves see case
easily build arbitrarily long chains even b giving us solution involving web
services n even b still get n
figure e one gets trying solve examples encoding
directly dlvk instead compilation solving cff expected
performance much worse since hardly test instance solved n fixed n
minimum value plots unlike b c e shows data
broad deep variants showing number leaves horizontal axis order obtain
fine grained view broad variant increase number steps rather
multiplicative factor see without forced optimization figure
performance poor largest case solve n b solution involves
web services switch forced figure e performance dramatically improved
still different level obtain compilation cff
figure f finally exemplifies get trap scenario data
broad version default encoding cff std default forced
encoding dlvk dlvk quite affected irrelevant chain concepts solving
single instance n b default encoding getting n b
forced encoding instead n b without trap behavior expected since
dlvk make use heuristic techniques would able detect irrelevance
second chain concepts question whether cffs techniques better figure
f shows cff std largely unaffected n one see comparing curve
points vertical axis figure however n performance cff std
drastically degrades instances solved n b n b reason
seems additional actions yield huge blow open queue used global
heuristic search cff std indeed picture different cff def
forced encoding instead search spaces identical explored trap
behavior get identical shown figure c
plans found sh scenario optimal e plans returned contain web
services needed single exception dlvk trap solutions include
useless web services trap chain
note dlvks plans parallel parallel length optimal provided correct plan
length bound cf section however parallel step may contain unnecessary actions top necessary
ones thats happens trap



fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

complex concept dependencies
two variants sh scenario feature tightly structured relationships involved
concepts allow investigation scalability issues varying size structure
consider advanced scenario way top level concepts covered lowerlevel concepts subject complex concept dependencies similar axioms constraining protein classes characteristics example therefore investigate performance
impacted complex concept structures subsumption hierarchies
tl

tl

il

il

il

il

bl

bl

bl

bl

bl

bl

bl

bl

bl

bl

bl

bl

sws

sws

sws

sws

sws

sws

sws

sws

sws

sws

sws

sws

tl

tl

il

bl

bl

il

il

bl

bl

bl

bl

bl

bl

il

bl

bl

bl

bl

figure schematic illustration cd scenario vs sh scenario
scenario called cd concept dependencies figure illustrates scenario
contrasts sh scenario similarly sh top level concepts
one associated set basic sub concepts b basic concepts
every top level concept n top level concepts l ln goal achieve
ln starting l done combining web services cover
possibilities namely every top level concept li every basic concept bli j associated
operator oi j x bli j x li
difference lies connection basic concepts top level concepts
sh rigidly given terms tree structure subsumption coverage axioms
intermediate concepts every basic concept e every operator oi j corresponding
concept included plan order cover possible cases cd use instead
complex set axioms connect basic concepts top level top level concept
intermediate concepts ili ili axioms stating ili j
note operators assigned output constant compilation
technique



fih offmann b ertoli h elmert p istore

sub concept li well axiom x li x ili x ili x stating
li covered ili ili connection intermediate concepts
basic concepts complex dependencies used intermediate subconcept constrained
covered non empty set combinations basic subconcepts precisely create
random dnf positive literals basic concepts predicates take
dnf imply ili j note implication dnf negated hence becomes
cnf directly encode formalism every ili j
setting interesting control many combinations required cover
top level concept li directly corresponds total number random combinations random dnf disjuncts generated intermediate concepts ili j taken together
control via call coverage factor c ranging b possible
combinations basic concepts pick random subset size c b combination associated dnf randomly chosen intermediate concept note cnf
formulas generated way may enormous minimize size encoding use
formula minimization software espresso brayton hachtel mcmullen sangiovanni vincentelli
mcgeer sanghavi brayton sangiovanni vincentelli
hypothetically c set task unsolvable experiments reported
whenever write c means exactly one combination selected associated
every intermediate concept
escaping rigid schema relationships presented sh cd scenario suitable test whether performance tied specific structure sh
moreover way cd designed allows us determine degree planners
react intelligently different concept structures particular scenario allows analysis
ability particular selected underlying planner cff identify plans contain relevant actions especially coverage factor c low
basic subconcepts may never appear partition intermediate concepts thus
plan need include respective operators still due conditional effects partial matches semantics plans include operators valid plans evaluating
plan length performance varying c therefore interesting
ability deal complex axiomatizations measured
terms impact coverage factor runtime performance randomization
choice combinations basic factors different settings c may induce significant
differences cnf axiomatizations subject underlying reasoning
engine different situations
summary cd scenario representative situations complex dependencies must
taken account order select correct services examples domains discussed
sections particular cd scenario corresponds closely scalable version
protein domain example different values dssp code correspond different basic
concepts respective getinfodssp services operators taking intermediate
concept infodssp similar amino acids shapes shapes complexes
top level concept combinedpresentation achieved constants every intermediate
concept created difference cd lies rather single
top level concept generated intermediates cd sequence top level concepts
need generated turn


fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

sh scenario total data experiments extensive even since
scenario parameters rather since individual instances contain
random element figure report selected pointing main observations part
b figure cff std runtime plan length n b c cffstd runtime search nodes c n b e shows dlvk cff std runtime
b cd n c f latter data cff def cd forced
figure b consider scalability solution lengths test varying size
scenario representing different coverage factors different lines report data cffstd similar cd forced cff def e contrary sh cd setting
options bring significant performance gain see figure cff scales
pretty well though well sh easily able solve tasks top level concepts
intermediate concepts basic concepts tasks minimum coverage factor
c solved particularly effortlessly higher c values one observe somewhat
easy hard easy pattern example curve c lies significantly
curves c c examine easy hard easy pattern detail
figure b obvious expected observation plan length grows linearly
n e number top level concepts likewise obvious much important
observation plan length grows monotonically coverage factor c reported
lower coverage factor opens opportunity employ less basic services namely
relevant ones figure b clearly shows cff std effective determining
services relevant
let us get back intriguing observation figure easy hard easy pattern
growing c figure c examine phenomenon detail plots scale c
horizontal axis fixed setting n b runtime shown c shows
number search states inserted open queue value c plots give
average standard deviation randomized instances clearly see easyhard easy pattern c runtime high variance particularly c
see pattern number search states variance much less
pronounced shows easy hard easy pattern due differences actual search
performed cff due effort spent search nodes traced behavior cff
detail found reason easy hard easy pattern lies runtime cff spends
sat reasoning state transitions e reasoning uses determine facts
definitely true false belief high non values c cnf encodings
concept dependency structures take rather complex form cases cff takes lot
runtime almost runtime spent within single call sat solver seems
cffs sat solver exhibits kind heavy tailed behavior formulas phenomenon
well known sat cp community see example work gomes selman crato
kautz noted typical benchmarks cnfs much
simpler structure motivates use fairly naive sat solver cff neither clause
learning restarts order save overhead formulas simple anyway seems likely
addition advanced sat techniques solver could ameliorate observed
finally figure e f compare performances compilation cff dlvk
compilation plots fix n e data shown top level concepts
instances dlvk solves n ones forced optimization used n
b plots c fixed c reason


fih offmann b ertoli h elmert p istore





c
c
c
c
c
c



c
c
c
c
c
c




































cff std runtime n









b cff std plan length n



































c cff std runtime c








dlvk
dlvk
dlvk
cff std
cff std
cff std









cff std plan length c
dlvk
dlvk
dlvk
cff def
cff def
cff def





























e dlvk cff std runtime b











f dlvk cff def runtime b

figure selected cd scenario see detailed explanation text
significant difference performance dlvk different values c dlvk
unable exploit lower c lower runtime neither easy hard easy pattern
speculate dlvks answer set programming solver tends perform exhaustive search anyway
accordingly affected different structures heuristic techniques employed
cff however cff dlvk able exploit lower coverage factors c shorter plans


fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

figure e shows default setting without forced optimization see performance dlvk explodes quickly cff experience much trouble cff fails
upper ends curves figure e f files e cnfs
describing complex concept dependencies become large parse mb notwithstanding cffs runtime behavior clearly exponential note however actual encodings
e instances solved grow exponentially c
observe dlvk exhibits quite variance particularly across different
settings curves cross figure e even pronounced figure f
observe sh forced optimization brings huge advantage
dlvk figure f dlvk fails first unsolved instance
due running memory shortly parsing
concluding section observe empirical behavior cff sh cd scenarios promising interpreted though test scenarios
capture structure typical variety potential applications wsc technology
yet put test actual practice however said essentially
current wsc technology since field whole still rather immature

related work
relation work belief update literature covered detail already sections relation formalism basically follows commonly
used frameworks notions operators actions conditional effects exactly used
pddl framework mcdermott et al bacchus fox long except
extension outputs regarding latter recognized time
community example golden edelkamp fly creation
constants relevant feature certain kinds however attempts actually
address feature tools scarce fact attempt aware work
golden golden pand nemani votava part reason
situation probably almost current state art tools employ pre processing procedures
compile pddl task fully grounded description core implemented propositional representation lifting representation
involves variables fly instantiations requires major implementation effort work
herein circumvent effort potential constants feeding resulting
cff planners employs said pre processing extending cff wsc f wd
involve dealing non propositional representations sub
notion initial state uncertainty conformant plans closely follows related literature
uncertainty smith weld cimatti et al hoffmann brafman
formalization terms beliefs adapted work bonet geffner
related works allow domain axiomatization e form
axioms constraining possible world states eiter et al giunchiglia et al
best knowledge work exists apart work presented herein
considers combination domain axioms outputs
words order regarding notions partial plug matches terminology originates work service discovery sws community see example paolucci
et al li horrocks kumar et al service discovery one concerned



fih offmann b ertoli h elmert p istore

matching service advertisements service requests discovery set services
whose advertisement matches request descriptions services requests similar
functional level service descriptions e operators use however
terminology works slightly different describe additional kinds
matches notions given li horrocks closest relation service
descriptions defined terms constructed description logic concepts say concept
describing advertisement r concept describing request li horrocks
say r exact match r plug match r subsume match
r intersection match r compare setting consider
situation effect action r precondition action r exact matches
special case plug matches distinguish herein intersection matches
correspond call partial matches concerning plug subsume matches matters
subtle intuitive meaning plug match advertisement fully suffices
fulfill request terms means effect implies precondition r
however service discovery traditionally taken mean every requested entity
provided e r latter notion precondition r implies effect
meaningful hence use one two notions correspondence li
horrockss subsume matches
contrast work li horrocks work paolucci et al
kumar et al define matches individual input output parameters service descriptions
rather service descriptions global level precondition effect us constructed
concept li horrocks level individual parameters paolucci et al
suggest notions li horrocks except less formal notation
define intersection matches true kumar et al latter
authors define notions contains part matches relating building blocks
constructed concepts obviously notions make sense framework
arent constructed concepts finally kumar et al define ways aggregating matches
individual parameters matches entire service descriptions applicable
case since work global level first place
brief survey existing works wsc follows variety works compile composition less standard deterministic formalisms ponnekanti fox
srivastava sheshagiri et al works agarwal dasgupta karnik
kumar kundu mittal srivastava b agarwal et al additionally focus end end
integration sws composition larger context akkiraju srivastava anca andreea goodwin syeda mahmood investigate techniques disambiguate concept names mcilraith
fadel achieve composition particular forms non atomic services modeling
latter atomic actions take meaning kind macro actions narayanan mcilraith
obtain composition ability side effect verifying sws properties petri nets
kuter sirin nau parsia hendler au kuter nau au nau
focus information gathering composition time rather plan execution time mcdermott
treats actual interaction communication web service
mediratta srivastava design wsc conditional e
form uncertainty suggests close relation work focus
mediratta srivastavas work actually quite different mediratta srivastava
consider output variables neither consider domain axiomatizations


fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

overlap formalism lies allow incomplete initial state descriptions e
initial states assign value subset propositions handle observation
actions allow observing value unspecified proposition ameliorate need
complete modeling consider definition user acceptable plans subset
plan branches specified user guaranteed lead goal latter may
interesting option look extending framework handle partial observability
two approaches explore adapt formalisms called hand tailored
sws composition approaches golog mcilraith son htn sirin et al respectively frameworks enable human user provide control
information however non deterministic action choice allowed control information
given fully automatic hence sense frameworks strictly
powerful without control information approaches capable
handling advanced plan constructs loops branches golog possible plans
possible composition solutions described kind logic high level instructions
given programmer planner bind instructions concrete actions part
execution htn programmer supplies set called
decomposition methods specifying certain task accomplished terms combination sub tasks recursively decomposition methods sub tasks thus
overall task decomposed step wise fashion atomic actions reached neither
mcilraith son sirin et al concerned handling ontology axioms
hence combining insights directions synergetic potential
interesting topic future work
another capable handling advanced plan constructs loops branches described
pistore et al b pistore traverso bertoli marconi c pistore et al
bertoli pistore traverso work process level composition implemented
opposed profile capability level composition addressed process level
semantic descriptions detail precisely interact sws rather characterizing
terms preconditions effects pistore et al b c bertoli
et al exploit bdd binary decision diagram search techniques obtain complex
solutions fully automatically however ontology axioms handled input output types
matched type names
approaches ontology axioms used requirements
matches relaxed one described sirin hendler parsia sirin parsia
hendler sirin parsia sirin et al first two papers
series sirin et al sws composition support tool human programmers
proposed stage composition process tool provides user list
matching services matches found examining subconcept relation output
considered match input b b corresponds plug matches later work
sirin parsia sirin et al htn sirin et al mentioned
adapted work standard semantics description logics semantics
owl difficulties inherent updating belief observed connection belief
update studied literature made remains unclear solution adopted
far aware methods relaxed matches follow
termed message wsc approaches already discussed depth
section next give details ones closely related work


fih offmann b ertoli h elmert p istore

liu et al discussed sufficient detail already section
reconsider
meyer weske handle ontology axioms wsc tool provide
semantics action applications reasoning used determine whether particular output
used establish particular input classified message
terms kind matches handled said plug best knowledge
tool existing wsc tool employs relaxed plan heuristic function
cff however design decisions authors sacrifice scalability explicitly
enumerate world states every belief hence suffer exponentially large beliefs
search forward parallel actions consequently suffer huge branching factor
take heuristic relaxed graph length rather relaxed plan length thus
suffer fact time hmax much less informative heuristic h bonet
geffner hoffmann
rather closely related handle partial matches described
constantinescu faltings constantinescu et al b work
ontology assumed take form tree concepts edges indicate subconcept
relation tree compiled intervals interval represents concept
contents arranged correspond tree intervals used efficient implementation
indexing service lookup discovery well matching composition latter
searches forward space switches starting initial input current input type
service input ai matches ai services collected set
collected ai covers union intervals ai contains
interval collected services form switch next step search
outputs becomes input must treated e switch node composition
interleaved discovery e every search state discovery called services
match state search proceeds depth first fashion major differences work
following first formalization different intervals vs standard notions
logics second interleaves discovery composition
separate steps framework web service discovery needed determine operators
wsc task third considers concept trees vs clausal integrity constraints last
uses depth first search whereas one main points making one
exploit heuristic techniques implemented standard tools scalable wsc
finally interesting related described ambite kapoor
capture dependencies different input variables web service input described terms relation variables done outputs
relations formulated terms logical formulas relative ontology underlying formalism first order logic modeling language quite expressive reasoning performed
order establish links messages terms inputs outputs algorithmic
framework happens inspired partial order penberthy weld
starting goal relation maintaining set open links solution dag web
services links correspond different kinds data exchanges selection projection join
union automatic insertion mediator services e g converting set standard formats
supported
cost undecidable reasoning according authors major issue practice



fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

extent preconditions effects clausal integrity constraints used model
relations sense ambite kapoor say r k ary relation definition
describing input web service set corresponding operators precondition
r x xk transform set universally quantified clauses long
latter done long ontology axioms likewise transformed obtain
model equivalent ambite kapoor sense main modeling advantage
ambite kapoor wsc f wd existential quantification open question
whether quantification accommodated framework insertion mediator services
supported wsc f wd limited sense recognizing via particular preconditions particular kind mediator required modeling actual data flow bound
awkward summary work ambite kapoor advanced data description transformation point view hand ambite kapoor neither consider
belief update place work context fully fledged formalism
less concerned exploiting heuristic technologies recent planners combining
virtues approaches within framework interesting direction


discussion
suggested natural formalism significant notion web service composition
profile capability level incorporating fly creation constants model outputs incomplete initial states model incomplete user input conditional effects semantics model partial
matches importantly clausal integrity constraints model ontology axioms
identified interesting special case forward effects semantics action applications
simpler general case demonstrated relates belief update
literature shown reduced computational complexity forward effects
relate closely message wsc serve put form wsc context extend towards general notion partial matches identified
compilation initial state uncertainty opening interesting connection
wsc areas
empirical encouraging interpreted test scenarios serve capture structural properties likely appear applications wsc
technology yet put test actual practice however
said essentially current wsc technology since field still rather immature sense thorough evaluation wsc
whole challenge future
apart evaluation several directions improving extending
technology introduced herein line particularly interesting adapt
modern tools wsc starting special cases complications incurred
integrity constraints manageable already outlined ideas adapting
cff pointed challenges arise appears particularly promising tailor generic
heuristic functions originating exploit typical forms ontology axioms occur
practice considering wealth heuristic functions available topic alone provides
material whole family subsequent work



fih offmann b ertoli h elmert p istore

acknowledgments
thank anonymous reviewers well managing editor derek long comments
significant help improving
jorg hoffmann performed part work employed university innsbruck austria work partly funded european unions th framework programme super project ist fp http www ip super org
piergiorgio bertolis marco pistores work partly supported project software
methodology technology peer peer systems stamps
malte helmerts work partly supported german council dfg part
transregional collaborative center automatic verification analysis complex
systems sfb tr avacs see www avacs org information

appendix proofs
first formally prove proposition stating negative effects compiled away wsc
first need introduce compilation formally assume wsc task p

ic c g construct second wsc task p
ic c g initially

p ic p ic respectively proceed follows let g
p predicate arity k exists xo preo yo effo effo
contains negative literal g x xk introduce predicate notg p
introduce two clauses x xk g x xk notg x xk x xk
g x xk notg x xk every operator whose effect contains negation
g replace effo g ak notg ak continue
negative effect literals remain
action p ic c g denote corresponding action


p
ic c g use notation vice versa e action



p ic c g denotes corresponding action p ic c g
cs state predicates p denote state predicates p
following properties cs cs p p cs p p notp
p p cs notp iff p since obviously exactly one
use correspondence vice versa

proposition assume wsc task p ic c g let p
ic c g
task negative effects compiled away assume action sequence ha
let b executing ha p ic c g b




executing ha
p ic c g state b iff
b

proof induction length action sequence question sequence empty
consider initial beliefs two tasks claim follows directly
definition inductive step say claim holds b b action need
state res b iff res b
direction right left say res b definition



res
state b induction hypothesis b therefore suffices
arguments ai may variables constants



fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

res need ic effa differs set inclusion
minimal set values obvious definitions assume contrary
exists ic effa identical except exists least one propo
sition p p p p p definition get
ic effa




get p p p p altogether

contradiction res hence proves res desired
direction left right proceeds fashion say res b definition

res state b induction hypothesis
b suffices





res
need ic effa differs
set inclusion minimal set values obvious definitions assume contrary




exists
ic effa identical except



exists least one proposition p
p p p p definition get
c

ic effa p p get p p p p
p notq p cs get property q altogether get

contradiction res hence proves res

desired
theorem assume wsc task fixed arity sequence ha actions
p complete decide whether ha plan
proof membership proved guess check argument first observe arbitrary
decide within conp whether res guess state cs cs ea
check whether ic effa check whether res iff guess
succeeds action deciding whether inconsistent obviously equivalent
satisfiability test contained np instruments hand design
guess check procedure decide whether ha plan guess proposition
values along ha check whether values comply res lead
inconsistent action final state satisfy goal detail checking proceeds
follows first check whether initial proposition values satisfy ic stop without
success otherwise iteratively consider action ai pre state post state check
np oracle whether inconsistent yes stop success test np oracle
whether res stop without success otherwise n go ai
n test whether g stop success g stop without success g
ha plan iff guess proposition values successful
hardness follows following adaptation proof lemma eiter gottlob
validity qbf formula x x cnf reduced plan testing
single action use ary predicates x x xm yn
ary predicates z zm r set operators contains single operator
empty parameters empty precondition effect initial constants empty
conjunction xi yi zi r g r theory







xi zi




xi zi





r c

c



n




yi r

fih offmann b ertoli h elmert p istore

viewed set clauses c readably theory equivalent





xi zi r

n


yi r





refer initial belief b plan test contains single action equal
fact refer resulting belief b obviously b contains single state everything
except true consistent interpretation sets r yi satisfies ic effa
theory conjuncts xi zi make sure w b makes exactly one xi zi true
particular different assignments x incomparable respect set inclusion hence
every assignment ax truth values x exists state b complies
ax ax satisfiable together ic effa assignment ax distant
least one variable e g ax xi ax xi ax closer ax
regarding interpretation zi
prove plan x x valid let ax truth value assignment x state b complies ax since plan
r therefore due theory conjunct r obviously values
assigned satisfy ax
direction say x x valid assume contrary thew
claim
plan b r due theory conjunct ni yi r
sets yi false x x valid exists truth value
assignment ay complies setting xi zi obtain modifying
comply ay setting r ic effa closer
hence b contradiction concludes argument

theorem assume wsc task fixed arity natural number b unary representation
p complete decide whether exists plan length b
proof membership guess sequences actions containing b actions note
size sequence polynomial size input representation theorem
check p oracle whether sequence plan
hardness follows extension proof lemma eiter gottlob validity qbf formula x z x z cnf reduced testing plan existence
use ary predicates x x xn ym z z zk
ary predicates q qm r f fn h g set operators composed
ot f fn h g h
n oxi h xi
n oxi h xi
initial constants empty initial literal conjunction composed yi zi qi
r h g yi zi qi well r h true well
g false value specified xi goal g r g theory







yi qi




yi qi





r c

c



n




zi r

fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

viewed set clauses c readably theory equivalent





yi qi r



n


zi r



first note obvious things construction
ot must included plan
ot applied action applied anymore
ot applied oxi oxi must applied every n
theory switched e made irrelevant false point ot
applied
plan task must first apply oxi oxi every n thereby choosing
value every xi ot must applied plan must stop applying ot changes
made states except values xi set made true one
hence belief b ot applied contains single state corresponds
extension value assignment x values flipped
denote value assignment x ax denote b res b ot note
ot consistent interpretation sets r zi besides setting immediate effects
g h satisfies ic effot obviously applications oxi oxi consistent
well
theory conjuncts yi qi make sure w b makes exactly one yi qi true
particular different assignments incomparable respect set inclusion hence
every assignment ay truth values exists state b complies
ay ay satisfiable together ic effot assignment ay distant
least one variable e g ay yi ay yi ay closer ay regarding
interpretation qi
prove exists plan yielding assignment ax x z x z
valid let ay arbitrary truth value assignment state b
complies ax ay ax ay satisfiable together ic effot
assignment ay distant least one variable course one deviates
ax one distant respective variable since plan r
therefore due theory conjunct r obviously values assigned z
satisfy ax ay proves claim ay chosen arbitrarily
direction say x z x z valid let ax assignment x
z ax x z valid let corresponding plan e first applies n
oxi oxi according ax thereafter applies ot assume
wn plan



b r due theory conjunct zi r sets
zi false z ax x z valid exists truth value assignment
az z complies setting xi yi qi obtain modifying comply
az setting r ic effot closer
hence b contradiction concludes argument




fih offmann b ertoli h elmert p istore

theorem assume wsc task decision asking whether exists plan
undecidable
proof holds even empty background theory complete specification
initial state predicates arity operators arity goal variables
arity positive literals preconditions goal follows minor
modification tom bylanders proof bylander plan existence propositional strips
pspace complete original proof proceeds generic reduction constructing
strips task turing machine tm polynomially bounded space latter restriction
necessary model machines tape tape cells pre created positions within bound
makes difference pspace membership undecidability ability create
constants introduce simple operators allow us extend tape ends
detail say tm finite number states q tape alphabet symbols b
blank transition function q initial state f set accepting states
input word encoding contains following predicates state q indicates
current tm state q c indicates current content tape cell c n eighbors c c
true iff c immediate right neighbor c c indicates current position
tm head c rightmost c lef tmost c true iff c currently right left neighbor
set initial constants contains states q alphabet symbols tape cells c corresponding
initial literals propositions constants assigned truth values
obvious every transition q q r include operator
x x state q x n eighbors x x x
state q state q x x x x
obviously encodes exactly transition likewise transitions q q l
model final states introduce ary predicate g include q f operator
state q g
finally include operators
x rightmost x x n eighbors x x b x rightmost x rightmost x

x lef tmost x x n eighbors x x b x lef tmost x lef tmost x
definitions easy verify exists plan iff tm reach accepting
state

lemma assume wsc f wd task reachable state action res
res f wd
propositional strips framework empty background theory complete specification
initial state goal variables positive literals preconditions goal output
parameters operators



fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

proof applicable claim holds trivially consider case
equation res defined

c c cs ea min c ic effa appl
res

otherwise
min c ic effa set c interpretations satisfy ic effa
minimal respect partial order defined iff propositions p cs
p p p p
obvious res f wd res satisfies ic effa identical
propositions cs particular minimal according
direction let res assume p p proposition p
cs define equal except p p obviously
suffices ic effa get min c ic effa contradiction
hence agrees propositions p cs hence res f wd
denote p cs ea set propositions arguments cs ea
least one argument e denote ic cs ea instantiation ic
constants cs ea clause least one variable instantiated ea see
ic effa consider first equivalent ic cs ea effa
turn equivalent ic cs ic cs ea effa last formula task
wsc f wd ic cs speaks propositions p cs whereas ic cs ea effa speaks
propositions p cs ea treat two parts separately ic cs
ic cs prerequisite since reachable ic cs ea effa
definition concludes argument

theorem assume wsc f wd task fixed arity sequence ha actions
conp complete decide whether ha plan
proof hardness obvious considering empty sequence membership shown
following guess check argument say c union c output constants appearing
ha guess interpretation propositions p c
n guess set ct constants check polynomial time whether
ct correspond execution ha n say
applicable prea ca ct ea ct first assert ic second
assert applicable effa third assert ct
ct ea applicable lemma easy see ct correspond
execution iff three assertions hold note needs time stamped
action generated outputs properties respective propositions remain fixed
forever claim follows fixed arity test polynomial time whether
cn satisfy g guess ct successful corresponds execution
satisfy g obviously ha plan iff guess ct

theorem assume wsc f wd task fixed arity natural number b unary representation p complete decide whether exists plan length b
proof membership guess sequence b actions theorem check
p oracle whether sequence plan


fih offmann b ertoli h elmert p istore

prove hardness assume qbf formula x x dnf normal form
formula class complete p say x x xn ym
k design wsc f wd task plan iff x x true key construction
use outputs creation time steps allow setting xi time step
yi take arbitrary values xi set one operator per k allows achieve goal
given k true main property need ensure construction xi set
e plan task iff one set x
least one true case iff x x true
predicates task p x xn ym time start
next goal indicate predicate arity number points parentheses
example predicate next arity theory ic empty initial constants
c initial literals time goal goal operators
follows
n oxi ti start next
next ti ti ti time ti next ti ti xi ti operator allows generating
time step setting xi step
n oxi ti start next
next ti ti ti time ti next ti ti xi ti operator allows generating time step setting xi step
define value b n j n b otj tj
start next next tj tj tj time tj next tj tj
operators allow increasing time step n n b
k say xlxj xlxjxn ylyj ylyjyn xlj xj xj
ylj yj yj oi tn b start next
next tn b tn b xlxj txj xlxjxn txjxn ylyj ylyjyn c
goal c operator allows achieve goal time step n b provided
respective true note xj precondition literals refer time step tj e
value set xj earlier time step yj precondition literals arguments
refer initial values yj arbitrary
assume choose value b polynomial input size x x true
obviously plan size n b k apply oxi oxi operator xi
depending whether xi must set apply b operators otj apply operators
oi respective input parameter instantiations obvious
opposite direction proving truth x x plan problematic
plan might cheat setting xi reason construction
complicated able avoid precisely case specifying strict enough plan length
bound b key property order cheat xi plan generate two sequences
time steps ti tn b therefore lower bound length cheating plan n b
already seen upper bound length non cheating plan n b k
determine plan length bound b simply choose b cheating plan
use many steps n b n b k case iff b k set b k obtain
b n k bound b plan proceed setting xi value n actions


fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

increasing time step n b n k k actions applying sufficient subset
oi k actions plan cheats needs apply least n b n k actions
able apply oi actions exploiting different value settings xi concludes
argument

theorem assume wsc f wd task decision asking whether exists plan
undecidable
proof reduce halting abacus machines undecidable abacus machine consists tuple integer variables v vk ranging positive integers
including tuple instructions state given content v vk plus
index pc active instruction machine stops iff reaches state pc n vi
initially pc initially two kinds instructions ii inc j goto ii increments value vj jumps pc ii dec j branch ii ii asks whether vj
jumps pc otherwise decrements value vj jumps pc
map arbitrary abacus program wsc f wd instance follows
predicates number v zero v succ v v value v valuek v instruction
instructionn
background theory none e trivial theory
operators
operator h v number v v number v succ v v
instructions form ii inc j goto ii operator
h v vk
instructioni value v valuek vk succ v vj

instructioni value v valuej vj valuej v
valuej vj valuek vk
instructions form ii dec j branch ii ii operators
h v vk
instructioni value v valuek vk succ vj v

instructioni value v valuej vj valuej v
valuej vj valuek vk

h v vk
instructioni value v valuek vk zero vj

instructioni value v valuej vj valuej vj
valuej vj valuek vk


fih offmann b ertoli h elmert p istore

initial constants v
initial literals number v zero v value v valuek v instruction
goal condition instructionn
describe intuitive meaning constants predicates two kinds constants numbers represent natural numbers including time points represent
computation steps abacus machine variables refer time points denoted
variables represent numbers
three predicates refer numbers exclusively number v true iff v encodes natural number
time point zero v true iff v encodes number succ v v true iff v
encodes number one larger number encoded v reduction
enforce every number uniquely represented e g may several representations
number unique representation necessary guaranteed number
uniquely represented though
remaining predicates encode configurations abacus machine valuei v true iff
time point th abacus variable holds number represented v instructionj
true iff current instruction time point ij
obviously accepting run abacus machine extract plan task
vice versa proves claim

prove theorems first establish core lemma theorems follow
relatively easily need notations denote beliefs states p ic c g
b denote beliefs states p g b assume sequence ha
ai non goal achievement actions denote b res b ha ai b res b
ha ai note overload res function denote state transitions
compiled task formalism state c c ex c denote
constants exist denote c relation states true iff
c c c c c equivalence relation equivalent states agree
constants exist howvthey interpreted note every state reachable
compiled
v
task satisfies ic oo effo eo note ic oo effo eo actually
satisfiable prerequisite unless ic unsatisfiable outputs instantiated
unique constants operators consistent state define


defined c
effo eo
eo c cs cs ic
oo

oo

equivalence class states reachable compiled task agree
constants exist interpreted
lemma assume wsc sf wd task without inconsistent operators let ha ai consist
non goal achievement
actions let b res b ha ai b res b ha ai

b sb

proof proof induction base case e b b b b
b
cs c ic


fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

hand b
c c ic



effo eo

oo

obviously latter comprised one equivalence class possibility assign propositions c way compliant ic exactly claim
thes
inductive case say add another action
ha ai induction assumption
b sb need prove res b res b obviously suffices prove

every b res res first say applicable

neither applicable res res second say
applicable lemma res
cs ea cs ic effa
hand res
ex c c ea c ic



effo eo

oo

write latter
c cs ea cs ic



effo eo

oo

obviously desired latter set comprised one equivalence class possibility
assign propositions cs ea way compliant ic effa concludes
argument

theorem assume wsc sf wd task p ic c g without inconsistent operators
plan ha compiled task p g sub sequence non goal
achievement actions ha plan p ic c g
proof ic unsatisfiable nothing prove start belief original
task empty non trivial case first note plan compiled task goal
achievement actions moved back plan hence without loss generality
assume ha ai consist entirely non goal achievement actions hai ai consist
entirely goal achievement actions
denote b res b ha ai b res b ha
ai lemma b sb since ha
plan compiled task every
b tuple constants satisfying g b sb follows every b satisfies
g

theorem assume wsc sf wd task p ic c g without inconsistent operators
plan ha every operator appears one instantiation eo
outputs ha extended goal achievement actions form plan
compiled task p g obtained outputs eo
proof
denote b res b ha b res b ha
lemma
b sb since ha plan every b satisfies g b sb follows
every b tuple constants satisfying g attaching respective goal achievement
actions yields plan compiled task



fih offmann b ertoli h elmert p istore

references
dcomplex org web server browse protein complexes known structures
http supfam mrc lmb cam ac uk elevy dcomplex data hierarchy root html
agarwal v chafle g dasgupta k karnik n kumar mittal srivastava b
synthy system end end composition web services journal web semantics

agarwal v dasgupta k karnik n kumar kundu mittal srivastava b b
service creation environment end end composition web services th
international conference world wide web www pp
akkiraju r srivastava b anca andreea goodwin r syeda mahmood semaplan combining semantic matching achieve web service composition
th international conference web services icws
ambite j kapoor automatically composing data workflows relational descriptions shim services th international semantic web conference iswc
ankolekar burstein hobbs j lassila martin mcdermott mcilraith
narayanan paolucci payne sycara k daml web service description semantic web st international semantic web conference iswc
au c kuter u nau web service composition volatile information th
international semantic web conference iswc
au c nau incompleteness volatile external information
th european conference artificial intelligence ecai
baader f lutz c milicic sattler u wolter f integrating description logics
action formalisms first th national conference artificial intelligence
aaai
bacchus f subset pddl aips competition aips competition committee
bertoli p pistore traverso p automated web service composition fly
belief space search th international conference automated scheduling
icaps
bonet b geffner h incomplete information heuristic search belief
space th international conference artificial intelligence systems aips
pp
bonet b geffner h heuristic search artificial intelligence

branden c tooze j introduction protein structure second edition garland publishing company york isbn
brayton r hachtel g mcmullen c sangiovanni vincentelli logic minimization
vlsi synthesis kluwer academic publishers
brewka g hertzberg j things worlds formalizing actions
plans j logic computation


fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

bryce kambhampati smith e graph heuristics belief space
search journal artificial intelligence
burstein hobbs j lassila mcdermott mcilraith narayanan paolucci
parsia b payne sirin e srinivasan n sycara k martin owl
semantic markup web services owl http www daml org services owl
version
bylander computational complexity propositional strips artificial
intelligence
chasman ed protein structure determination analysis applications drug
discovery marcel dekker ltd
chen wah b hsu c temporal subgoal partitioning resolution
sgplan journal artificial intelligence
cimatti roveri bertoli p conformant via symbolic model checking
heuristic search artificial intelligence
constantinescu faltings b efficient matchmaking directory services nd
international conference web intelligence wi
constantinescu faltings b binder w large scale type compatible service composition nd international conference web services icws
constantinescu faltings b binder w b typed service composition th
international conference world wide web www
de giacomo g lenzerini poggi rosati r update description
logic ontologies instance level st national conference artificial intelligence
aaai
de giacomo g lenzerini poggi rosati r approximation instance
level update erasure description logics nd national conference american
association artificial intelligence aaai
de jonge van der linden w willems r eservices hospital equipment th
international conference service oriented computing icsoc pp
edelkamp promela th international spin workshop model checking
software spin
eiter faber w leone n pfeifer g polleres logic programming
knowledge state ii dlvk system artificial intelligence
eiter faber w leone n pfeifer g polleres logic programming
knowledge state semantics complexity transactions computational logic

eiter gottlob g complexity propositional knowledge base revision updates counterfactuals artificial intelligence
fagin r kuper g ullman j vardi updating logical databases advances
computing



fih offmann b ertoli h elmert p istore

fensel lausen h polleres de bruijn j stollberg roman domingue j
enabling semantic web services web service modeling ontology springer verlag
fersht structure mechanism protein science guide enzyme catalysis
protein folding mps isbn
fox long pddl extension pddl expressing temporal
domains journal artificial intelligence
gerevini saetti serina stochastic local search temporal
action graphs journal artificial intelligence
gerevini saetti serina toninelli p fast domains derived
predicates rule action graphs local search th national conference american association artificial intelligence aaai
ginsberg smith reasoning action possible worlds artificial
intelligence
giunchiglia e lee j lifschitz v mccain n turner h nonmonotonic causal
theories artificial intelligence
giunchiglia e lifschitz v action language causal explanation preliminary report th national conference artificial intelligence aaai
golden k dpadl action language data processing domains proc rd
international nasa scheduling workshop
golden k domain description language data processing proc workshop
future pddl icaps
golden k pand w nemani r votava p automating processing earth observation data proceedings th international symposium artificial intelligence
robotics automation space
gomes c selman b crato n kautz h heavy tailed phenomena satisfiability
constraint satisfaction journal automated reasoning
helmert decidability undecidability numerical state variables th international conference artificial intelligence systems aips
helmert fast downward system journal artificial intelligence
herzig pma revisited th international conference principles knowledge
representation reasoning kr
herzig lang j marquis p polacsek updates actions th
international joint conference artificial intelligence ijcai pp
herzig rifi propositional belief base update minimal change artificial
intelligence
hoffmann j ignoring delete lists works local search topology benchmarks journal artificial intelligence
hoffmann j brafman r conformant via heuristic forward search
artificial intelligence


fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

hoffmann j nebel b system fast plan generation heuristic
search journal artificial intelligence
katzuno h mendelzon difference updating knowledge base
revising nd international conference principles knowledge representation
reasoning kr
kona bansal gupta g hite automatic composition semantic web services th international conference web services icws
kumar neogi pragallapati ram j raising programming abstraction
objects services th international conference web services icws
kuter u sirin e nau parsia b hendler j information gathering
web service composition journal web semantics
lecue f delteil making difference semantic web service composition
nd national conference american association artificial intelligence aaai
lecue f leger formal model semantic web service composition th
international semantic web conference iswc
li l horrocks software framework matchmaking semantic web
technology th international conference world wide web www
liberatore p complexity belief update artificial intelligence
lin f reiter r state constraints revisited journal logic computation

liu h lutz c milicic wolter f reasoning actions description
logics general tboxes th european conference logics artificial intelligence
jelia
liu h lutz c milicic wolter f b updating description logic aboxes th international conference principles knowledge representation reasoning kr
liu z ranganathan riabov message oriented semantic
web service composition nd national conference american association
artificial intelligence aaai
long fox rd international competition analysis
journal artificial intelligence
lutz c sattler u proposal describing services dls international
workshop description logics dl
mccain n turner h causal theory ramifications qualifications th
international joint conference artificial intelligence ijcai pp
mccarthy j hayes p philosophical standpoint artificial
intelligence machine intelligence
mcdermott estimated regression interactions web services th
international conference artificial intelligence systems aips
mcdermott et al pddl domain definition language aips
competition committee


fih offmann b ertoli h elmert p istore

mcdermott v regression match graphs control search artificial
intelligence
mcgeer p sanghavi j brayton r k sangiovanni vincentelli espressosignature exact minimizer logic functions proceedings th acm ieee
design automation conference dac
mcguinness l van harmelen f owl web ontology language overview w c
recommendation online http www w org tr owl features
mcilraith fadel r complex actions th international workshop
non monotonic reasoning nmr pp
mcilraith son c adapting golog composition semantic web services
th international conference principles knowledge representation reasoning
kr
mediratta srivastava b applying composition web services
user driven contingent planner tech rep ri ibm
meyer h weske automated service composition heuristic search th
international conference business process management bpm
narayanan mcilraith simulation verification automated composition web
services th international conference world wide web www
palacios h geffner h conformant classical efficient translations
may complete th international conference automated
scheduling icaps
paolucci kawamura payne sycara k semantic matching web services
capabilities st international semantic web conference iswc
pednault e p adl exploring middle ground strips situation
calculus st international conference principles knowledge representation
reasoning kr
penberthy j weld ucpop sound complete partial order planner adl
rd international conference principles knowledge representation reasoning
kr pp
petsko g ringe protein structure function science press isbn

pistore marconi bertoli p traverso p automated composition web services knowledge level th international joint conference artificial
intelligence ijcai
pistore traverso p bertoli p b automated composition web services
asynchronous domains th international conference automated
scheduling icaps
pistore traverso p bertoli p marconi c automated synthesis composite
bpel ws web services rd international conference web services icws



fiw eb ervice c omposition p lanning u ncertainty n ew c onnection

ponnekanti fox sword developer toolkit web services composition
th international conference world wide web www
reiter r frame situation calculus simple solution sometimes
completeness goal regression artificial intelligence mathematical theory
computation papers honour john mccarthy pp
roman keller u lausen h de bruijn j lara r stollberg polleres feier c
bussler c fensel web service modeling ontology applied ontology

sheshagiri desjardins finin planner composing services described
daml third symposium adaptive agents multi agent systems aamas
sirin e parsia b wu hendler j nau htn web service composition shop journal web semantics
sirin e hendler j parsia b semi automatic composition web services
semantic descriptions workshop web services iceis
sirin e parsia b semantic web services workshop semantic web
services iswc
sirin e parsia b hendler j composition driven filtering selection semantic
web services aaai fall symposium semantic web services
sirin e parsia b hendler j template composition semantic web services
aaai fall symposium agents search
smith e weld conformant graphplan th national conference
american association artificial intelligence aaai
srivastava b automatic web services composition knowledge
computer systems kbcs pp
thakkar ambite j l knoblock c composing optimizing executing plans
bioinformatics web services vldb journal special issue data management analysis
mining life sciences
thiebaux hoffmann j nebel b defense pddl axioms artificial intelligence

winslett reasoning actions possible th national
conference american association artificial intelligence aaai
winslett updating logical databases cambridge university press
zhan r arpinar b aleman meza b automatic composition semantic web services st international conference web services icws




