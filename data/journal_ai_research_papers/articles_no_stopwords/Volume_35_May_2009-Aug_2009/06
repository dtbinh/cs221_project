journal artificial intelligence

submitted published

compiling uncertainty away conformant
bounded width
hector palacios

hlp ldc usb

universitat pompeu fabra
roc boronat
barcelona spain

hector geffner

hector geffner upf edu

icrea universitat pompeu fabra
roc boronat
barcelona spain

abstract
conformant finding sequence actions achieving goal
presence uncertainty initial state action effects
approached path finding belief space good belief representations
heuristics critical scaling work different formulation introduced
conformant deterministic actions automatically converted
classical ones solved shelf classical planner translation maps
literals l sets assumptions initial situation literals kl
represent l must true initially true lay general translation scheme
sound establish conditions translation complete
complexity complete translation exponential parameter
called conformant width benchmarks bounded planner
translation exhibits good performance comparison existing planners
basis best performing planner conformant track
international competition

introduction
conformant form goal achieved initial
situation fully known actions may non deterministic effects goldman
boddy smith weld conformant computationally harder
classical even polynomial restrictions plan length plan verification
remains hard haslum jonsson baral kreinovich trejo turner
rintanen practical purely conformant ability
conformant plans needed contingent conformant situations special
case relaxations conformant yield useful heuristics hoffmann
brafman
conformant formulated path finding
belief space sequence actions map given initial belief state target
belief sought bonet geffner belief state represents set states
deemed possible actions whether deterministic map one belief state
c

ai access foundation rights reserved

fipalacios geffner

another formulation underlies current conformant planners hoffmann
brafman bryce kambhampati smith cimatti roveri bertoli
must address two representing beliefs compact way
obtaining effective heuristics beliefs first approached
logical representations make use sat obdd technology
intractable worst case scale better plain state representations second
hand complex heuristics searching belief
space successful far heuristics developed classical bonet
geffner hoffmann nebel
work introduce different conformant
automatically compiled classical solved classical planner
translation maps sets literals initial situation literals l literals
kl express true initial situation l must true lay first
general translation scheme sound establish conditions
translation complete complexity complete translation
exponential parameter call conformant width
benchmark domains bounded implying complete translation
cases polynomial planner translation exhibits good performance
comparison existing conformant planners basis best performing
planner conformant track international competition
translation provides solution two faced conformant planners search belief space belief representation heuristic
beliefs translation beliefs represented literals kl
stand conditionals representation polynomial complete conformant bounded width addition since belief states represented
plain states heuristic beliefs classical heuristic computational point
view though explicit search belief space conformant p
converted classical k p knowledge level petrick bacchus
whose solutions computed classical planner encode conformant solutions p
formulation limited conformant deterministic
uncertainty lies initial situation address nonetheless issues must
handled order generalize translation non deterministic domains
report empirical non deterministic domains well
organized follows define first syntax semantics conformant
p section consider simple sound incomplete translation
k section consider general translation scheme kt
two parameters set tags encoding assumptions initial situation
set merges encoding valid disjunctions tags section analyze several
instances scheme follow particular choices sets tags merges
complete exponential translation ks tags associated possible
initial states section polynomial translation ki fixed integer
complete conformant width bounded section
provide alternative explanation compact complete translation
showing bounded width exponential number possible initial
states includes polynomial number critical initial states plans


ficompiling uncertainty away conformant

conform conform section finally present conformant
planner section empirical evaluation planner section extension
non deterministic actions section discussion related work section
followed brief summary section formal proofs appendix
work revision extension formulation presented palacios
geffner turn ideas first sketched palacios geffner


conformant p
define next syntax semantics conformant considered
syntax
conformant p represented tuples form p hf gi
f stands fluent symbols set clauses f defining
initial situation stands set ground operators actions g set
literals f defining goal every action precondition p given set
fluent literals set conditional effects c l c set fluent literals
l fluent literal
actions assumed deterministic hence uncertainty lies initial
situation thus language conformant p excluding uncertainty
initial situation strips extended conditional effects negation moreover
uncertainty initial situation fluents appear unit clauses
p equivalent classical
refer conditional effects c l action rules associated
sometimes write c l convenient join several effects
associated action condition c l l write c l
true l c empty finally literal l l denotes complement l
semantics
state truth assignment fluents f p hf gi possible initial
state p state satisfies clauses
state write refer set atoms positive literals true
write p refer classical p hf gi
conformant p except initial state fixed
action sequence classical plan p action sequence
executable state goal state sg e n
preconditions action ai true si si state action
ai state si goal literals true sn
finally action sequence conformant plan p iff classical plan p
every possible initial state p
conformant computationally harder classical plan verification remains hard even polynomial restrictions plan length haslum jonsson
baral et al turner rintanen common


fipalacios geffner

conformant belief state formulation bonet geffner
belief state b non empty set states deemed possible given situation
every action executable b maps b belief state ba conformant
task becomes path finding graph nodes belief states
b source node b belief state corresponding initial situation target
belief states bg goals true
assume throughout logically consistent set possible initial
states empty p consistent bodies c c conflicting
effects c l c l associated action mutually exclusive
mutex details see part b appendix

basic translation k
simple translation conformant p classical k p
obtained replacing literals l literals kl kl aimed capturing whether
l known true known false respectively
definition translation k conformant p hf gi
translation k p hf g classical
f kl kl l f
kl l unit clause
g kl l g
precondition l replaced kl conditional
effect c l replaced kc kl kc kl
expressions kc kc c l l abbreviations formulas
kl kl kl kl respectively
intuition behind translation simple first literal kl true initial
state l known true otherwise false removes uncertainty
k p making classical addition soundness
rule c l p mapped two rules support rule kc kl ensures
l known true condition known true cancellation
rule kc kl guarantees kl deleted prevented persist
action applied c known false use support cancellation rules
encoding original rules knowledge level subtlety translation
translation k p sound every classical plan solves k p conformant
plan p incomplete conformant plans p classical plans k p
meaning kl literals follows similar pattern plan achieves kl k p
plan achieves l certainty p yet plan may achieve l certainty
p without making literal kl true k p
proposition soundness k p classical plan k p
conformant plan p
formal proofs found appendix



ficompiling uncertainty away conformant

illustration consider conformant p hf gi f p q r
q g p r actions b effects
q r p p b q p
action sequence b conformant plan p action
sequence indeed classical plan p possible initial state
classical plan possible initial state p true recall
possible initial state p satisfies neither p r assumed
initially false
definition translation k p hf g classical
fluents f kp kp kq kq kr kr initial situation kq goals g
kp kr actions b effects
kq kr kp kp b kq kp
encode supports effects
kq kr kp kp b kq kp
encode cancellations
proposition implies example conformant plan
p cannot classical plan k p easy verify support
kq kr achieves goal kr kq true cancellation kp kp
associated action preserves kp false goal p
translation k complete meaning fails capture conformant plans p classical plans completeness assessed terms weaker
semantics called approximation semantics baral son belief states b
represented valued states fluents true false unknown incomplete belief representation checking whether action applicable belief state b
computing next belief state ba verifying polynomial length plans polynomial
time operations particular literal l true next belief state ba iff action
effect c l literals c true b b l true b
effects c l action complement literal l c true b action
sequence conformant plan p according approximation semantics
belief sequence generated according approximation semantics makes
action sequence applicable terminates belief state goals true
possible prove
proposition k p approximation action sequence classical plan
k p iff conformant plan p according approximation semantics
correspondence surprising though approximation semantics
k p translation throw away disjunctive information restrict plans
make use uncertain knowledge indeed states generated
action sequence classical k p encode precisely


fipalacios geffner

literals known true according approximation namely l true
time according approximation iff literal kl true state si
proposition mean basic translation k approximation
semantics equivalent rather rely equivalent belief representations
translation k delivers way get valid conformant plans classical
planner translation thus addresses representational
heuristic issues arise conformant
illustration proposition given conformant p p r
actions b effects p q r v b q v plan b valid
achieving goal g q v according k p approximation
plan b valid according time initial situation
changed p q neither sanctions plan g q even
valid conformant plan ability reason disjunctions needed
extension basic translation k allows limited form disjunctive reasoning presented palacios geffner extension introduction
literals l xi used encoding conditionals xi l basic translation
k extended different manner ensures tractability completeness
large class

general translation scheme kt
basic translation k extended general translation scheme kt
two parameters set tags set merges
suitable choices two parameters translation kt unlike translation k
sound complete
tag set conjunction literals l p whose truth value initial
situation known tags used introduce class literals kl
classical kt p represent conditional true initially l
true assertion could written k l temporal modal logic use
notation kl rather l used palacios geffner
distinction kl kl roughly kl means conditional
k l true kl means conditional k l true
likewise merge non empty
w collection tags stands disjunctive normal form dnf formula tm merge valid one tags
must true e



tm

merge literal l p translate merge action single effect

kl kl
tm

captures simple form reasoning cases
valid merge used reasoning literal l p computationally
convenient although logically necessary specify certain merges
used literals l others thus formally collection pairs


ficompiling uncertainty away conformant

l merge l literal p pair means merge
l group merges literal l set ml thus understood
collection sets ml l p simplicity however except
may cause confusion keep referring plain set merges
assume collection tags includes tag stands
empty collection literals call empty tag denote empty
tag denote kl simply kl
translation kt p basic translation k p conditioned tags
extended actions capture merges
definition translation kt let p hf gi conformant
kt p classical kt p hf g
f kl kl l f
kl l
g kl l g
v
kc kl kc kl c l p
l tm kl kl xl l p ml
kl precondition action kt p l precondition p kc
kc stand kl kl
v kl kl respectively
c l l xl stands l kl l ranging literals l mutex
l p
translation kt p reduces basic translation
k p empty
v
contains empty tag extra effects xl l kl merge actions l
needed ensure translation kt p consistent p consistent
otherwise ignored indeed l l mutex consistent p invariant
kl kl holds kt p non empty tags hence successful merge
l followed successful merge l rest
thus assume p kt p consistent ignore extra merge effects
come back appendix b proving consistency kt p
consistency p
suitable choices translation kt p sound complete
establishing however let us make notions precise
definition soundness translation kt p sound classical plan
solves classical kt p plan dropping
merge actions conformant plan p
definition completeness translation kt p complete conformant
plan solves conformant p classical plan solves
classical kt p equal merge actions removed
general translation scheme kt sound provided merges valid
tags consistent literals tag true possible initial state


fipalacios geffner

theorem soundness kt p translation kt p sound provided
merges valid tags consistent
unless stated otherwise assume merges valid tags consistent
call translations valid translations
convention keeping notation simple singleton tags p curly
brackets often dropped thus literals kl p written kl p
merges singleton tags p q written p q
example illustration consider moving object origin
destination two actions pick l picks object location hand
empty object location drop l drops object location
object held making interesting let us assume
action pick l drops object held l hand empty
conditional effects action preconditions assuming single
object effects written
pick l hold l hold l
pick l hold hold l
drop l hold hold l
consider instance p domain hand initially empty
object initially l l must moved l e p hf gi
hold l l l l l

g l
action sequence
pick l drop l pick l drop l
conformant plan attempt pick object location
l followed drop target location l ensuring object ends l
originally l followed attempt pick object l
drop l
hand action sequence removing first
drop action
pick l pick l drop l
conformant plan since object originally l would end l
action pick l notation introduced classical plan classical
p two possible initial states classical plan
p state object initially l


ficompiling uncertainty away conformant

consider classical kt p hf g obtained p
l l contains merge l l literals
hold l definition fluents f kt p form kl
kl l l hold l l l initial situation
khold khold l kat l kat l l kat l l kat l l
l l l l l l goal g
g kat l
effects associated actions pick l drop l support rules
pick l khold kat l khold kat l
pick l khold khold kat l
drop l khold khold kat l
one three locations l li condition rule empty tag
along support rules
pick l khold l kat l l khold l kat l l
pick l khold l khold l kat l l
drop l khold l khold l kat l l
condition rule tags l l l l corresponding
cancellation rules
pick l khold kat l khold kat l
pick l khold khold kat l
drop l khold khold kat l

pick l khold l kat l l khold l kat l l
pick l khold l khold l kat l l
drop l khold l khold l kat l l
addition actions include merge actions hold l follow
merge l l literals hold l
hold khold l khold l khold
l kat l l kat l l kat l
empty tag assumed every thus mentioned explicitly



fipalacios geffner

shown plan
pick l drop l pick l drop l l
solves classical kt p hence theorem plan obtained
dropping merge action valid conformant plan p shown
see literals kt p evolve actions executed







kat l l kat l l
khold l kat l l
kat l l kat l l
kat l l khold l
kat l l kat l l
kat l

true
true
true
true
true
true








pick l
drop l
pick l
drop l
merge l

verify manner action sequence
pick l pick l hold drop l
classical plan kt p reason atom khold l holds
first pick action second due cancellation rule
pick l khold l khold l kat l l
expresses assumption l initial situation hold l
known true action pick l assumption hold
known true action

complete translation ks
complete instance translation scheme kt obtained simple manner
setting tags possible initial states p merge
precondition goal literal l includes tags call resulting
exhaustive translation ks
definition translation ks conformant p translation ks p
instance translation kt p
set union empty tag set possible initial states p
understood maximal sets literals consistent
set contain single merge precondition goal literal l
p
translation ks valid hence sound complete due correspondence
tags possible initial states
theorem completeness ks conformant plan p
classical plan ks p dropping merge actions



ficompiling uncertainty away conformant



adder
blocks
blocks
bomb
bomb
bomb
bomb
coins
coins
coins
coins
comm
comm
comm
corners square
corners square
corners square
corners square
corners square
square center
square center
log
log
ring
ring
safe
safe
safe
sortnet
sortnet
sortnet
sortnet
uts k
uts k




k
k
k

k
k
k


k
k







k
k
k
k





k
k



ks
time
len
h










gb






gb




gb







gb


gb


h


gb












gb





pond
time len



















h








h
h
h
h


h
h
h








gb


h
h
h





cff
time
len
h
h
h


























h
h
h
h
h













snh
snh
snh
snh





table ks translation fed planner compared pond conformant
cff along times reported plan lengths stands number
initial states snh means goal syntax handled cff times reported
seconds rounded closest decimal



fipalacios geffner

p whose actions preconditions argument simple
conformant plan p must classical plan p possible initial
state achieves goal literal gi p must achieve
literal kgi ks p well followed merge action gi
must achieve literal kgi presence action preconditions argument must
applied inductively plan length idea remains see proof
appendix details correspondence established evolution
fluents l p evolution fluents kl
ks p
significance exhaustive ks translation theoretical
plenty conformant quite hard current planners even involve
handful possible initial states example square center n task cimatti
et al agent reach center empty square grid certainty
knowing initial location four actions move agent one unit
direction except border grid effects standard
version initial position fully unknown resulting n possible initial
states yet remains difficult actually beyond reach planners
small values n even uncertainty reduced pair possible initial states
reason agent must locate heading goal domain
corners square n table variation square center n possible initial
states four corners grid
table shows conformant planner ks p translation
uses hoffmann nebel solving resulting classical compares
two planners entered conformant track int
competition bonet givan pond bryce et al conformant
hoffmann brafman two planners competition translationbased formulation developed k p earlier
restricted formulation due palacios geffner clearly
ks p translation scale many possible initial
states yet number states small quite well

complete translations may compact
order complete translations polynomial certain assumptions
formulas initial situation need made otherwise checking whether
goal true intractable therefore polynomial complete translation
would impossible unless p np thus assume prime implicate pi
form marquis meaning includes inclusion minimal clauses
entails tautologies known checking whether clause follows logically
formula pi form reduces checking whether clause subsumed clause
tautology hence polynomial operation initial situations
benchmarks p form easily cast pi form normally specified
means set non overlapping oneof x xn expressions translate
clauses x xn binary clauses xi xj j resolvent
tautology


ficompiling uncertainty away conformant

conformant relevance
translation ks p complete introduces number literals kl exponential worst case one possible initial state raises question
possible complete translations exhaustive sense answer
yes section provide simple condition ensures translation
kt p complete makes use notion relevance
definition relevance conformant relevance relation l l p read l
relevant l defined inductively
l l
l l c l p l c action p
l l l l l l
l l l l l l
first clause stands reflexivity third transitivity second captures conditions relevant effect fourth conditions l preempts
conditional effects may delete l replace
l l l l
equivalent context resulting definition one son
tu notion relevance used generate limited set possible partial
initial states approximation complete see section discussion
relation tags partial initial states
notice according definition precondition p action taken
relevant effect q reason want relation l l capture
conditions uncertainty l relevant uncertainty l
say relation conformant relevance preconditions must known
true order action applied introduce propagate uncertainty
effects action
let ci stand set clauses representing uncertainty initial situation namely non unit clauses along tautologies l l complementary
literals l l appearing unit clauses notion conformant relevance
extended clauses follows
definition relevant clauses clause c ci relevant literal l p
literals l c relevant l set clauses ci relevant l denoted ci l
representation uncertainty initial situation relevant
literal l possible analyze completeness translation kt terms
relation merges literals l one hand sets clauses ci l
relevant l
follow earlier account palacios geffner many definitions theorems
differ number details example notion relevance depends rules p
clauses initial situation changes aimed making resulting formulation simpler
cleaner



fipalacios geffner

covering translations
may appear translation kt would complete
w merges precondition goal literals l understood dnf formulas tm contain much
information thus equivalent cnf formula ci l captures fragment
initial situation relevant l intuition partially correct misses
one important point namely every dnf formula equivalent ci l
dnf representation captured merges must vivid enough example ci l
single clause x x completeness requires tag x tag x merge
x x l containing two tags even clause x x tautology
thus equivalent dnf formula true
defining types tags merges required completeness
let us first define closure set literals relative conformant
p hf gi set literals follow
l l
let us say consistent contain pair complementary literals
type merges required precondition goal literals l
imply ci l satisfy well notion satisfaction associates
consistent set literals partial truth assignment implicit closure
extended account conditions dnf formula e g
merge l satisfies cnf formula e g ci l
definition satisfaction
consistent set literals satisfies clause l l

lm contains one literals li
consistent set literals satisfies collection clauses c satisfies clause
c
collection consistent sets literals satisfies collection clauses c set
satisfies c
type merges required completeness simply valid merges
satisfy set clauses ci l call covering merges
definition covering merges valid merge translation kt p covers
literal l satisfies ci l
example ci l given clauses oneof x xn expression e x x xn xi xj j j n j
merge x xn covers literal l xi includes xi xj
j thus xi satisfies ci l
w
merge tn denote dnf formula ti ti
tag ti replaced closure ti simple prove covers literal l
entails ci l merge covers l thus dnf formula strong enough
imply cnf formula ci l closure weak enough entailed
vivid enough satisfy ci l


ficompiling uncertainty away conformant

illustration ci l given tautologies p p q q
ci l merge p p implies ci l satisfy ci l likewise
merge p q p q satisfies ci l entailed finally merge
p q p q p q p q satisfies ci l entailed thus
valid merge covers l
valid translation kt p contains merge covers l precondition
goal literal l p say translation covers p covering
translation
definition covering translation covering translation valid translation
kt p includes one merge covers l precondition goal literal l
p
central covering translations complete
theorem completeness covering translations kt p complete e
conformant plan p classical plan kt p
merge actions removed
words complete translations kt p tags merges
capture information initial situation relevant precondition
goal literal suitable manner
theorem used two ways proving completeness translation
checking covering condition holds constructing complete translations
enforcing covering condition addition interest conformant optimality guarantees theorem useful optimal conformant
well whether cost plans defined length action costs equal
sum non uniform action costs cases theorem ensures
optimal conformant gets mapped optimal classical
provided cost merge actions kt p made sufficiently small
illustration theorem consider conformant p initial situation x xm goal g l actions ai effect xi l
number possible initial states exponential disjunction
among xi exclusive translation ks p complete exponential
size hand consider translation kt p x xm
contains single valid merge x xm l simple verify
merge covers goal l satisfies ci l hence translation kt p
covering theorem complete polynomial
notice testing whether valid translation kt p covering translation
done polynomial time particular computing set literals every tag
tractable operation provided pi form indeed l iff l
iff l tautology subsumed clause
translation kmodels
straightforward exponential translation ks considered section
non empty tags stand possible initial states covering hence complete


fipalacios geffner

according theorem possible however take advantage theorem
devising complete translation usually compact call kmodels
definition translation kmodels p obtained general scheme kt p
defining
contain one merge precondition goal literal l given
ci l consistent
contain tags merges along empty tag
translation kmodels equivalent ks precondition goal
literals l ci l e clauses relevant l yet cases
first translation exponential number variables appearing one ci l
set one largest number variables second exponential
number unknown variables example n precondition goal
literals li n p one ci li unique oneof xi xim
expression merge literal li ks p contain mn n one
expressions merge li kmodels p contain
single oneof xi xim expression ci li translation kmodels thus
exponentially compact exhaustive ks translation remaining sound
complete
theorem translation kmodels p sound complete
worst case however kmodels exponential translation thus consider
next polynomial translations conditions complete
conformant width
address conditions compact covering translation constructed polynomial time define structural parameter call
conformant width p analogy notion width used graphical
dechter provide upper bound time space complexity
required generating covering translation precisely complexity construction exponential conformant width p cannot exceed
number fluents p much lower
principle would define width w p maximum tag size required
translation kt p covering translation definition however would
give us complexity bounds want checking validity merge
tags bounded size intractable operation whether initial situation
prime implicate form need define width different way first let
cover set clauses defined follows
ci l understood conjuntions literals
checking whether entails dnf formula whose terms may literals
conp hard even equivalent true indeed cnf formula contradictory iff
negation dnf valid turn true iff implied actually
general prime implicate form remains conp hard even terms dnf formula
contain literals thank pierre marquis pointing us



ficompiling uncertainty away conformant

definition cover cover c c set clauses c relative conformant
p initial situation collection minimal sets literals consistent
contains literal clause c
two important properties cover c c set clauses c c c stands
dnf formula logically equivalent cnf formula c given c c
computed polynomial time size c bounded constant moreover c c
implies c satisfies c well thus particular c collection clauses
ci l relevant literal l cover c ci l ci l valid merge
covers l completeness covering translations follows complete
translation kt p constructed polynomial time size ci l sets
clauses ci l precondition goal literals l p bounded unfortunately
condition rarely seems hold yet weaker sufficient condition namely
often possible subset c clauses ci l tautologies
c c satisfies ci l thus covers literal l thus define width
literal l size smallest set cardinality wise denote
ci l set clauses ci l extended tautologies form p p fluents p
p p appears ci l appear ci l p p ci l
definition
definition width literal conformant width literal l p written w l
size smallest cardinality wise set clauses c ci l c c satisfies
ci l
consequence definition width literal must lie interval
w l n n number fluents p whose status initial situation
known indeed ci l empty w l set clauses ci l
cover c c set c tautologies ci l must satisfy ci l thus w l c n
similarly ci l contains single clause x xm clauses x xm
xi xj correspond oneof x xm expression simple prove
w l singleton c x xm generating cover c c x xn
satisfies ci l finally ci l contains two tautologies pp qq w l
smallest c ci l whose cover satisfies ci l ci l
width width precondition goal literal maximum
width
definition width conformant width p written
w p w p maxl w l l ranges precondition goal literals p
bounded width complete translations
constructed polynomial time moreover almost existing conformant benchmarks bounded width precisely width equal case
resulting translations use tags never greater size w p
width tags single literals
tree width graphical computing width p
exponential w p recognition small width carried
quite efficiently


fipalacios geffner

proposition determining width width w p p determined time
exponential w p
particular test w p considering one one sets c
includes single clause ci l verifying whether c c satisfies ci l
w p verification must carried setting c set
clauses ci l increasing values fixed value polynomial
number clause sets c verification one done polynomial
time moreover arguments regarding w l w p never exceed
number unknown fluents
proposition bounds width width p w p n n
number fluents whose value initial situation known
polynomial translation ki
translation ki parameter non negative integer instance
general kt scheme designed sound polynomial fixed complete
width w p thus example translation k sound polynomial
complete width
definition translation ki translation ki p obtained general
scheme kt p
set contain one merge c c precondition goal literal l p
set c clauses ci l covers l set
exists one merge c c l created set c clauses ci l
merges created l ci l empty
collection tags appearing merges empty tag
translation ki p applies p width remaining cases exponential polynomial number fluents actions clauses p addition
translation ki p sound width bounded complete
theorem properties ki fixed translation ki p sound polynomial
w p covering complete
soundness merges valid construction covers c c
c ci l entailed c hence complexity polynomial fixed
polynomial number clause sets c size ci l constructing
cover c c one polynomial operation finally completeness follows
definition width w p set clauses c ci l
size c greater whose cover satisfies ci l thus ki p must contain
merge c c l covers l
notice translation ki p reduces basic k p translation
introduced section tags empty tag merges
assessed completeness translation terms approximation semantics
theorem provides alternative interpretation translation k p complete


ficompiling uncertainty away conformant

















domain parameter
safe n combinations
uts n locs
ring n rooms
bomb toilet n bombs
comm n signals
square center n n grid
cube center n n n cube
grid n shapes n keys
logistics n pack locs
coins n coins locs
block tower n blocks
sortnet n bits
adder n pairs bits
look grab objs n n locs
dispose objs n n locs

unknown fluents
n
n
n
n
n
n
n
nm
nm
nm
n n n
n
n
nnm
nnm

width










n n n
n
n



table width parameterized domains
p zero width set clauses ci l
relevant precondition goal literal l empty makes precise intuition
mentioned k p translation complete uncertain
information relevant cases none clauses initial situation
make sets relevant clauses ci l preconditions goal literals l
illustration theorem consider conformant p initial
situation x xm goal g l actions ai
effect xi l singleton set clauses c ci l
c c x xm covers ci l since precondition goal
literal k p includes single merge c c l singleton tags ti xi
write simply x xm translation k p polynomial
since w p theorem complete notice example
translations ks p kmodels p identical exponential number
ci l
width conformant benchmarks
practical value notion width becomes apparent width existing
benchmarks considered table summarizes width many existing benchmark
domains conformant domains depend certain parameters n
capture size instances e g size grid number objects etc domain
bounded width width grow size instances
width equal instances width regardless parameter values
seen table width existing benchmarks
cases means sets ci l clauses relevant precondition
names parameterized domains table coincide names instances
currently used e g comm n ipc refers communication instance necessarily
instance n signals



fipalacios geffner

goal literal l contain single clause often tautology p p disjunction x xm
single oneof x xm expression translates disjunction x xm
clauses xi xk shown w l therefore w p equal theses
cases
extreme domains blocks sortnet adder
maximal widths e widths equivalent number fluents whose status initial situation known fluents interact
action conditions preconditions numbers blocks table thus follow
number fluents involved namely fluents x clear x ontable x
holding x
finally domains dispose look grab palacios geffner
objects unknown locations grid n n must collected robot
whose gripper hold one object time width equal meaning
width domains grows number objects size grid
case clauses possible locations objects
relevant condition hand empty pick actions
let us point completeness translation ki p p
width w p bounded establishes correspondence conformant plans
p classical plans kt p solving p however correspondence
needed suffices ki p solvable plan ki p encode
conformant plan p even ki p capture conformant plans p
perspective makes sense refer smallest value parameter
classical ki p solvable effective width p denoted p turns
p cannot larger w p may much smaller interesting
example comes sortnet n domain bonet geffner sortnet n
considered challenging domain conformant planners able
scale even small values n number entries sorted sorting network
domain width n compact encoding used ipc input vector
represented set bits exploiting fact sorting vectors numbers reduces
sorting vector bits domain cannot solved k translation
reports correctly unsolvable brief unsuccessful search hand
possible reformulate domain replacing unary high low predicates
binary predicates less j compare two vector entries call reformulation
sort n encoding sort n linear n encoding sort n quadratic n
cases width maximum given number fluents whose
status initial situation unknown yet compact sort n encoding
solvable k translation k suffices solve expanded sort n encoding actually solved k thus effective width sort n
interestingly provided k translation sort n instances solved
entries hand conformant planners conformant pond
solve sort n instances n greater


ficompiling uncertainty away conformant

tags initial states
deeper understanding obtained relating tags possible
initial states looking closely relation context covering translations
able answer question polynomial number contexts tags
play role exponential number possible initial states bounded
width
let us first recall notation introduced section state
wrote refer set atoms encoding e p iff p true p
refer classical p hf gi conformant
p hf gi initial state fixed
let us extend notation say action sequence conforms set
states given conformant p iff plan classical p
clearly conformant plan p nothing else action sequence
conforms set possible initial states p yet notion conforms allows
us abstract away initial situation make precise notion basis
definition basis p set states basis conformant p
hf gi subset set possible initial states p every plan
conforms conforms set possible initial states
words basis p necessary consider states
computing conformant plans p suffices consider states aim
width p bounded p polynomial basis even
exponential size moreover states basis close correspondence
tags appearing covering translation
illustration consider p actions ai n effects
ai xi l let g l goal x xn initial situation
set possible initial states truth valuations xi atoms least
one atoms true n states hand one
set n valuations exactly one atoms true provides basis
p e plans conform n possible initial states exactly plans
conform complete set n possible initial states
reduction number possible initial states must considered computing conformant plans two monotonicity properties formulate
notation rel l refer set literals l true state
relevant literal l
rel l l l l relevant l
proposition monotonicity let two states let action sequence
applicable classical p p achieves literal l p
rel l rel l achieves literal l p
proposition monotonicity two collections states
every state every precondition goal literal l p state
rel l rel l plan p conforms plan
p conforms


fipalacios geffner

properties follows
proposition basis p every possible initial state p every
precondition goal literal l p contains state rel l rel l
proposition allows us verify claim made example set
contains number states linear n basis p exponential
number possible initial states indeed precondition single
goal literal l every state makes one atom xi true
literals relevant l state makes one atoms true
hence relation rel l rel l holds
question address build basis complies condition
proposition given covering translation kt p let tn
merge covers precondition goal literal l let ti l denote set
possible initial states p rel l ti e ti l contains possible initial
states p make literals l relevant l false except
closure ti ti first prime implicate form ti l non empty
set
proposition initial situation prime implicate form tn
valid merge covers literal l p set ti l possible initial states
p rel l ti non empty
let ti l stand arbitrary state ti l obtain following
theorem let kt p covering translation p initial
situation pi form let stand collection states ti l l
precondition goal literal p ti tag merge covers l basis
p
important three reasons first tells us build basis p
given tags ti covering translation kt p second tells us size
resulting basis linear number precondition goal literals l tags ti
third makes role tags ti covering translation kt p explicit providing
intuition works tag ti merge covers literal l represents one
possible initial state namely state ti l makes false literals l
relevant l except ti plan conforms critical states
conform possible initial states monotonicity proposition follows
particular
theorem p conformant bounded width p admits
basis polynomial size
namely conformant p width bounded non negative integer admit
polynomial translations complete plans conform possibly
exponential number initial states p correspond plans conform
recall assuming throughout initial situation logically consistent
tags consistent



ficompiling uncertainty away conformant

subset critical initial states polynomial number namely
polynomial basis thus one complete polynomial translation
ki translation another one ks translation tags associated
critical initial states rather initial states
illustration p actions ai effects ai xi l
goal g l initial situation x xn k p translation tags xi
n merge x xn goal literal l covering translation
theorem states basis p collection states si
make tag xi true literals relevant l xi false e
xk atoms k precisely basis p includes
states make single atom xi true n plans conform
basis exactly plans conform whole collection possible initial
states p basis size polynomial though number
possible initial states p exponential

planner
current version conformant planner two instances general
translation scheme kt p whose outputs fed classical planner v one
instance polynomial necessarily complete complete necessarily
polynomial incomplete translation uses k complete
width greater argued solvable instances
larger widths complete translation kmodels translation used instead
simple optimization k translation produces single merge covers l
merge used l instead potentially complex one determined
kmodels mere optimization resulting translation remains complete
merges kmodels set clauses ci l
consistent computed sat solver relsat v bayardo jr schrag
current default mode one used experiments
two translations k kmodels used sequence called first upon
output k fails called upon output kmodels experiments
indicate cases kmodels invoked
translations used accommodate certain simplifications two additional
actions capture types deductions simplifications fact
translations considered uniform sense literals l p
rules c l conditioned tags practical point
view however needed simplifications address source inefficiency
particular
literals kl created closure contains literal relevant l
case invariance kl kl holds thus every occurrence
literal kl kt p replaced kl
conformant planner along benchmarks considered available
http www ldc usb hlp software



fipalacios geffner

support rules kc kl non empty tags created l
relevant literal l merge contains case literal
kl cannot contribute establish precondition goal similarly cancellation
rules kc kl non empty tags created l
relevant literal l merge contains
support cancellation rules kc kl kc kl
grouped kc kl kl every fluent l relevant l
l l entailed case incomplete information
l given initial situation thus invariant kl kl holds
kc equivalent kc
two types sound deductive rules included translations
rule kc kl added c l l rule p action
rule p form c l
rules kl kli kli kln kli n added
unique action precondition l ln static clause p
clause p static true initial situation provably true action
rules versions action compilation static disjunctions rules palacios
geffner appear help certain domains without hurting others
version reported assume initial situation p
prime implicate form rather renders pi form running version tisons
computation none benchmarks solved took
seconds
translators written ocaml code parsing pddl files
written c

experimental
considered instances three sources conformant distribution conformant track international competition ipc relevant publications palacios geffner cimatti et al instances run
cluster linux boxes ghz gb experiment cutoff h gb
memory times include steps particular computation prime implicates translation search done include conformant
track recent international competition ipc
goals sets literals sets clauses transformed standard
way goal clause c l lm modeled goal atom gc
action executed added rules li gc
alternative way represent cnf goals converting dnf first
action end map non mutex terms dummy goal lg alternative encoding pays
cases adder instance get solved default cnf goal
encoding see



ficompiling uncertainty away conformant


bomb
square center
sortnet
blocks
dispose
look grab
sgripper

p
acts atoms effects






















time








k p
pddl
acts atoms effects size




























table translation data selected instances acts atoms effects stand
number actions fluents conditional effects time translation
time seconds rounded closest decimal pddl size size
pddl file megabytes

table shows data concerning translation group selected instances
seen number conditional effects grows considerably cases sometimes
translation may take several seconds
tables plan times lengths obtained number
benchmarks pond bryce et al conformant hoffmann brafman
mbp cimatti et al kacmbp bertoli cimatti last
two planners accept standard syntax pddl
limited number experiments performed general picture
scales well domains exceptions square center cube center
table kacmbp scales better sortnet table kacmbp mbp
scale better adder table pond planner able solve one
instance
table encodings conformant repository bomb x
refers bomb toilet x packages toilets clogging logistics ij k variation classical version uncertainty initial location packages
ring n closing locking windows ring n rooms without knowing
current room safe n opening safe n possible combinations
width clearly best last two domains first two
domains conformant well
table reports experiments four grid domains cube center n refers
reaching center cube size n completely unknown location squarecenter n similar involves square n possible locations corners cube n
corners square n variations set possible initial locations
restricted cube square corners respectively mbp kacmbp appear
effective domains although kacmbp doesnt scale well corner versions
solves corner versions quality plans poor
width
table reports experiments international competition bonet givan domains coins comm uts width
others max width given number unknown fluents initial situation


fipalacios geffner


bomb
bomb
bomb
bomb
bomb
bomb
bomb
bomb
bomb
logistics
logistics
logistics
logistics
ring
ring
ring
ring
ring
ring
safe
safe
safe
safe
safe


time

























len

























pond
time len

h
h
h







h
h
h








h









gb

cff
time
len


































h











mbp
time len
h
h
h
h





h
h
h
h










h


h
h
h
h

kacmbp
time len













h
h
gb
gb
gb
gb










gb











table experiments well known benchmarks times reported seconds rounded
closest decimal means time memory smaller instances



ficompiling uncertainty away conformant


square center
square center
square center
square center
square center
square center
square center
square center
cube center
cube center
cube center
cube center
cube center
cube center
cube center
cube center
cube center
cube center
cube center
corners square
corners square
corners square
corners square
corners square
corners square
corners square
corners square
corners square
corners square
corners square
corners cube
corners cube
corners cube
corners cube
corners cube
corners cube
corners cube
corners cube
corners cube


time
len












gb
gb

















gb
gb


































gb

pond
time len





h
h












h
h







h
h









h
h






cff
time
len


h
h







h
h
















mpl










mpl





mbp
time
len






























gb
gb




















gb






h
h




kacmbp
time
len

















































h
h









h
h



table experiments grid times reported seconds rounded
closest decimal mpl cff means plan exceeds maximal plan length
actions means time memory smaller instances



fipalacios geffner


adder
adder
blocks
blocks
blocks
coins
coins
coins
coins
coins
coins
coins
coins
coins
comm
comm
comm
comm
comm
comm
comm
comm
sortnet
sortnet
sortnet
sortnet
sortnet
sortnet
uts k
uts k
uts k
uts k
uts k
uts k
uts k
uts l
uts l
uts l
uts l


time len
h
h






















h
























gb
gb























pond
time len


h







h
h
















h
gb





h
h












h






h
h

cff
time len
snh
snh


h
h













h















snh
snh
snh
snh
snh
snh























mbp
time
len
nr
nr
nr
nr
nr
h
h





















h
















h
h








h

kacmbp
time
len
nr
nr
nr
nr
nr



h
h








h
h




















h
h



h
h



table experiments ipc times reported seconds rounded
closest decimal snh cff means goal syntax handled
nr mbp kacmbp planners run due lack
translations pddl means time memory smaller instances



ficompiling uncertainty away conformant


dispose
dispose
dispose
dispose
dispose
dispose
dispose
dispose
dispose
dispose
dispose
look grab
look grab
look grab
look grab
look grab
look grab
look grab
look grab
look grab
look grab
look grab
look grab
look grab
look grab
look grab
look grab
look grab
look grab


time
len














gb


gb












gb


gb






h
h
h
h
h
h

pond
time len





gb
gb







h
h
gb
h
h
gb












cff
time
len








h

gb



h
mcl
mcl
h
mcl
mcl
h
h
h










mbp
time len
h
h









h




h




h




h
h
h
h
h
h
h
h
h

kacmbp
time len


h
h


























h
h
h
h
h

h
h



table palacios geffner times reported seconds
rounded closest decimal means time memory smaller instances
mcl mean many edges many clauses respectively

dominates domains except adder pond planner able
solve instance sortnet mbp kacmbp well possibly due
use cardinality heuristic obdd representations fails adder
gets lost search looking closely found could solve
translation first instance less minute provided cnf goal
encoded dnf explained footnote page domains adder
blocks sortnet table along domain look grab next table
domains considered run k translation reports solution
brief search triggering use complete kmodels translation
cases kmodels used k translation unreachable goal fluent
need try


fipalacios geffner


push
push
push
push
push
push
push
push
push
dispose
dispose
dispose


time
len











h
h
gb


gb
gb

pond
time len





h
h
h



gb
gb


cff
time len






gb
gb
gb



h
h


table palacios geffner mbp kacmbp
tried use different syntax times reported
seconds rounded closest decimal means time memory
smaller instances

reported table table variations family grid
palacios geffner dispose retrieving objects whose initial location
unknown placing trash given known location push variation
objects picked two designated positions grid
objects pushed pushing object cell contiguous cell moves
object cell dispose variation dispose robot hand
empty condition pick actions work plan dispose
scan grid performing pick ups every cell followed excursions trash
plans get long plan reported actions look grab
action picks objects sufficiently close pickup must dump objects collected trash continuing
p n table n grid size number objects look n grab
third parameter radius action means hand picks
objects surrounding cells hand picks objects
surrounding cells domains tables width except dispose
look n grab hand empty fluent relevant
goal clauses location objects relevant hand empty
domains appears better planners kmodels translation
triggered instances look grab n r width
instances mentioned section independent grid size
report additional data table comparing search
use planner classical translations search carried
conformant original conformant conformant conformant
planner built top searches explicitly belief space table illustrates
two faced belief space planners mentioned introduction handle


ficompiling uncertainty away conformant


bomb
bomb
safe
logistics
square center
square center
cube center
cube center
blocks
blocks
coins
comm
uts k
dispose
dispose
dispose
look grab

nodes


















cff
time


















nodes sec


















nodes



















time nodes sec



































table cff conformant vs translations nodes stand number
nodes evaluated time expressed seconds nodes sec stands average
number nodes per second numbers shown bold cff
evaluate significantly less nodes order magnitude reduction times
preceded time outs



fipalacios geffner

translation belief representation
update appears overhead maintaining evaluating beliefs
shows number nodes evaluated per second cff evaluates
hundred nodes per second evaluates several thousands time heuristic
used cff conformant setting appears less informed heuristic used
classical translations domains square center n cube center n
blocks look grab needs orders magnitude less nodes cff
plan oppositive true dispose n evaluates many nodes
cff nonetheless even due overhead involved carrying beliefs
manages solve cff cannot solve example instance dispose
solved evaluating half million nodes times cff
evaluating less three thousand nodes
tables provide details conformant track
international competition ipc bryce buffet held almost time
original version submitted planner binaries submitted
organizers months version ipc different
version used ipc winning entry different
version reported relation former ipc cleaner
complete reimplementation relation latter ipc handled width
greater different way explained previous section current version
uses k basic translation regardless width switching
kmodels search k fails version ipc basic translation
combination k k precisely merges literals l width w l
generated according k merges literals l width w l
generated basic translation ipc lighter
basic translation current version could fail width
higher latter solve retrospectively good choice
didnt much impact however bug program
prevented two width domains forest dispose recognized
thus resulted use kmodels translation complete widths
scale well
two conformant planners entered ipc cpa h cpa c
belief space planners represent beliefs dnf formulas use simple
belief state heuristics guiding search tran nguyen pontelli son
belief progression planners done quite effectively progressing term
turn according approximation semantics potential blow comes
number terms dnf formula encoding initial belief state rather choosing
terms initial belief state possible initial states planners limit
terms dnf formula collection partial initial states assign
truth value literals deemed irrelevant resulting belief representation
complete may still exponential number terms son tu order
reduce number terms initial dnf formula independent one
expressions combined example two independent one clauses oneof x x
oneof would give rise possible initial states dnf terms combined
single one expression oneof x x possible initial


ficompiling uncertainty away conformant

domain
blocks
adder
uts cycle
forest
raos keys
dispose

instances







cpa h







cpa c







ipc







table data conformant track recent ipc competition number
solved conformant planners time mins
bold entry planner performed best domain data
bryce buffet

states terms one expressions independent shown
interact technique appears related notion critical
initial states considered section shown plans conform
critical initial states must conform possible initial states heuristics used
cpa h cpa c combinations cardinality heuristic measures
number states belief state total sum heuristic adds heuristic distances
goal possible state number satisfied goals counts
number top goals achieved heuristics simple yet work well
benchmarks
tables data obtained ipc organizers planner logs
first table appears ipc report bryce buffet domains
forest raos keys explained shows number solved
planner displaying bold planner best domain planner cpa h
declared winner declared best three domains blocks raos keys
dispose best two domains uts cycle forest cpa c
best one adder
table shows additional details instances particular total time
taken solve instance length plans three planners
terms domain coverage planners similarly domains except
forest solved instances cpa h solved vs
dispose cpa h solved instances solved vs
terms time plan quality cpa h cpa c appear slightly faster
blocks produce much longer plans dispose scales better
cpa h cpa c size grids worse number objects
indeed manages solve largest grid single object dispose
cpa h cpa c solve instances objects largest grids
cases plan lengths produced shorter e g plan dispose
contains actions cpa h cpa c
dispose actually domain cardinality heuristic well generation plans even plans tend rather long discussed domain
agent scan grid collecting set objects unknown locations time


fipalacios geffner

action picking object cell may contain object made except
first time cardinality belief state reduced indeed initially object
may positions p p pn pick p object positions
p pn gripper pick p object positions p pn
gripper pick action decreasing cardinality belief state
becoming singleton belief object must gripper certainty
version used ipc dispose domain
explores many states search explained used
expensive kmodels translation instead lighter k translation complete
domain width bug fixed solves rather
dispose instances still failing larger grids many objects producing
much shorter plans example dispose solved plan actions
cpa h cpa c solve plans actions respectively
bug surfaced forest domain prevented solution one instance
forest dispose uts cycle conformant widths equal
domains larger widths see table widths blocks adder
second domain ipc got lost search adder indeed
solve instance instance shown solved competition
report appears mistake similarly fourth instance blocks reported
solved cpa h may mistake indeed plan instance found
logs reports goal unreachable kmodels translation
complete according instance four raos key unsolvable
hand failed larger uts cycle raos key instances translation
first resulting pddls large cant loaded
second number init clauses turns quite large giving rise
still larger set prime implicates caused translator run
memory second instance raos keys however rather small didnt solve
due different bug bug fixed solves seconds producing plan
actions compares well solutions produced cpa h cpa c
seconds steps respectively

non deterministic actions
translation schemes considered limited deterministic actions
nonetheless illustrate schemes applied non deterministic
actions well provided suitable transformations included cover transformations briefly matter illustration
consider conformant p non deterministic action effects c oneof
sm si set conjunction literals transformed
p effects mapped deterministic rules form c hi si
expression oneof h hm added initial situation p p hidden hi
variables used encoding uncertainty possible outcomes si action
easy non deterministic conformant p deterministic conformant p equivalent provided plans p p
considered non deterministic action p executed namely


ficompiling uncertainty away conformant



instance

blocks

































adder
uts cycle

forest

raos keys
dispose

cpa h
time
len














cpa c
time
len












































































ipc
time len























































table running time plan length ipc logs time seconds blanks stand
time memory dispose n instances shown
ipc size n grid ranged number objects
scales best n worst



fipalacios geffner

correspondence exists conformant plans p use actions
conformant plans p use actions
hand conformant plan p actions done many times
necessarily represent conformant plan p indeed non deterministically moves
agent right square grid n n starting bottom left corner n actions
row would leave agent top left corner bottom right corner p
anywhere manhattan distance n origin p divergence p
p however arise non deterministic actions executed
building idea non deterministic conformant planner obtained
deterministic conformant planner following way non deterministic
p let p p additional constraint actions
p arising non deterministic actions p executed
easily achieved adding precondition enabled true initially
sets false let p represent deterministic conformant
non deterministic action p mapped deterministic actions executable
hidden fluents h hm oneof h hm
expression initial situation similarly let pi deterministic
encoding non deterministic action p deterministic copies
encoding simple iterative conformant planner non deterministic p defined terms conformant planner deterministic
invoking latter upon p p p solution reported reported
solution uses copy non deterministic action thus encodes
solution original
implemented strategy top additional refinement
takes advantage nature kt translation assumptions initial
situation maintained explicitly tags basically non deterministic actions pi
allowed executed provided literals kl hi depend
particular outcome actions si erased implemented means
additional reset action pi whose unconditional effect enabled e
action done whose conditional effects kl kl hi
kl kl hi namely literals kl hi truth l depends
particular non deterministic outcome si erased except l true
assumptions e kl true non deterministic actions executed
plan provided occurrence except first one preceded
reset action
table compares resulting non deterministic planner mbp kacmbp
number non deterministic considered mbp kacmbp papers
added additional domain slippery gripper sgripper similar
classical gripper number balls moved room b except
robot cannot move b directly non deterministic move action
move c moves robot c typical plan moving
two balls b pick move c move c b
b finally dropping balls b
deterministic conformant planner used non deterministic setting
added following modification merges introduced precondition goal


ficompiling uncertainty away conformant


sgripper
sgripper
sgripper
btuc
btuc
btuc
btuc
btuc
bmtuc
bmtuc
bmtuc
bmtuc
bmtuc
bmtuc
bmtuc
bmtuc
nondet ring
nondet ring
nondet ring
nondet ring
nondet ring
nondet ring key
nondet ring key
nondet ring key
nondet ring key
nondet ring key
nondet ring key


time len































h
h


h
gb





mbp
time
len
h
h

h
h





h
h










h






gb



kacmbp
time
len



























h
h

















h

table non deterministic except sgripper mbp
kacmbp modified render simple translation
pddl particular complex preconditions moved conditions times
reported seconds rounded closest decimal means time memory
smaller instances

literals literals reason setting pays remove uncertainty
literals reset mechanism used indeed provided simple change
reset mechanism none move beyond p single copy
non deterministic action even domains non deterministic actions
required many times plans e g balls room
seen table better mbp collection nondeterministic domains although well kacmbp particular nondetring non det ring key domains case obtained
domains quite meaningful cases failed solved reason
classical planner got lost search plans something may
improve advances classical technology



fipalacios geffner

related work
recent conformant planners cff pond mbp cast conformant
heuristic search belief space bonet geffner compact belief
representations informed heuristic functions however critical making work effective belief representation planners use sat obdds
techniques intractable worst case often exhibit good behavior average
heuristics hand use fixed cardinality heuristics count number
states possible given belief state tractable operation obdd representations heuristics obtained relaxed graph suitably extended take
uncertain information account heuristics appear work well domains
others perspective translation provides handle
two belief states p become plain states translation kt p
solved classical heuristics established conditions
belief representation compact complete
sound incomplete incomplete information advanced
petrick bacchus represent belief states formulas order make
belief updates efficient though several approximations introduced particular
existing disjunctions carried one belief next disjunctions
added imposes limitation type handled
two limitations domains must crafted hand
control information derived domains search plans blind
understood providing solution two
one hand move knowledge level done automatically
lifted knowledge level solved classical planners able search
control information derived automatically representation
third thread work related arises called approximation
semantics baral son approximation semantics belief states b represented sets states single valued state fluents true false
unknown proposition correspondence established plans
p conformant according approximation semantics classical plans
translation k p turns instance general translation
ki p complete width semantics translation
k thus related approximation semantics yet k translation delivers something computational method obtaining conformant plans comply
approximation semantics classical planner
approximation basic k translation weak dealing
existing benchmarks translations ki extend k higher width
replacing set fluents kl fluents kl tags encode assumptions
initial situation extensions approximation semantics context
conformant taken different form switching single valued state
representing beliefs sets valued states valued state progressed efficiently
independently others son tu gelfond morales initial set
valued states obtained forcing states assign boolean truth value true false
number fluents crucial work number fluents


ficompiling uncertainty away conformant

belief representation update exponential conditions ensure
completeness extension approximation semantics expressed terms
relevance analysis similar one underlying analysis width son tu
fluents must set true false initial valued state
appearing clause ci l precondition goal literal l particular
initial situation n tautologies pi pi relevant precondition goal literal
l number initial valued states required completeness exponential n
make fluent pi true false difference seen
tautologies pi pi relevant unique precondition goal literal li
case number valued partial states required completeness remains
exponential n resulting width thus solved
k translation involves tags single literal words tags used
translation scheme encode local contexts required different literals
initial valued states son tu encode possible combinations
form global contexts global contexts correspond consistent combinations
local contexts may thus exponential number even
bounded width planners cpa h cpa c discussed context
conformant track recent int competition ipc build
reduce number partial initial states required technique
replace many one expressions single one tran et al simplification
related notion critical initial states discussed section
another difference valued son et al son tu
translation addresses representation beliefs
computation conformant plans conformant p translated
kt p solved classical planner approaches defined
top approximation semantics knowledge level
incomplete information petrick bacchus need way guide search
plans simplified belief space search petrick bacchus blind
iterative deepening search son et al son tu guided
combination simple heuristics cardinality subgoal counting

summary
practical purely conformant ability conformant plans
needed contingent settings conformant situations special case
introduced conformant conformant p
converted classical kt p solved classical
planner studied conditions general translation sound
complete translation depends two parameters set tags referring local
contexts initial situation set merges stand valid disjunctions
tags seen different translations ks kmodels obtained
suitable choices tags merges introduced measure complexity
conformant called conformant width translation scheme ki polynomial fixed complete width bounded shown
conformant benchmarks width developed conformant planner


fipalacios geffner

translations shown planner exhibits good performance
comparison existing conformant planners recently explored use
ideas general setting contingent albore palacios geffner


acknowledgments
thank alex albore help syntax mbp kacmbp pierre marquis
kindly answering question complexity deductive task thank
anonymous reviewers useful comments h geffner partially supported grant
tin c

appendix proofs
p stands conformant p hf gi kt p
hf g translation propositions theorems body
appear appendix numbers lemmas propositions
numbers preceded letters b appendix b conformant
p classical p kt p arise p assumed
consistent consistency issues important addressed detail
second part appendix shown p consistent kt p consistent
appendix b consistent classical p standard progression lemma
applies namely literal l achieved applicable action sequence
action sequence action iff achieves c rule c l p
b achieves l negation l literal l body c rule p
form c l see theorem b
lemma let action sequence applicable p k p
achieves kl k p achieves l p
proof induction length empty achieves kl k p
kl must hence l must achieves l p
likewise achieves kl k p rule kc kl
k p achieves kc k p b achieves kl k p
rule kc kl k p achieves kl k p l c
true p must contain rule c l inductive hypothesis
must achieve c p therefore must achieve l p b true
inductive hypothesis must achieve l p along l literal l body
c rule c l thus must achieve l p
lemma action sequence applicable k p applicable p
proof empty trivial likewise applicable k p
applicable k p thus inductive hypothesis applicable p since
applicable k p must achieve literals kl k p precondition
l lemma must achieve literals l preconditions
p thus sequence applicable p


ficompiling uncertainty away conformant

proposition classical plan k p conformant plan p
proof direct lemma consider p similar p
dummy action ag whose preconditions goals g p plan k p
ag applicable k p lemma ag applicable p implies
applicable p achieves g thus plan p
proposition action sequence classical plan k p iff conformant
plan p according approximation semantics
proof let us say action sequence applicable p achieves
literal l p belief sequence b bn generated according approximation
semantics preconditions actions ai true bi goals
true bn respectively definition approximation semantics
consistency p applicable action sequence thus achieves literal l p iff
empty l c l effect p achieves
literal l c b achieves l effects c l p achieves l
l c however conditions achieves literal kl
k p sequence achieving literal l p replaced sequence achieving
literal kl k p thus action sequence applicable k p
applicable p achieves literal kl k p iff achieves literal l p
applicable k p iff applicable p last part following first
induction plan length
definition action p define action sequence
followed merges kt p arbitrary order similarly ai
action sequence p define action sequence kt p
lemma let action sequence applicable p applicable
valid translation kt p achieves kl kt p achieves l
p possible initial states satisfy
proof empty achieves kl definition kt p since
l l must thus must achieve l p

likewise empty tag
achieves kl

kt p iff achieves kc kt p rule kc kl kt p
b achieves kl rule kc kl achieves kl
kt p l c merge actions delete positive literals kl
inductive hypothesis achieves c p possible initial state
satisfies hence achieves l p rule c l must
p b inductive hypothesis achieves l l p l body
rule c l p thus achieves l p
v
empty tag third case must considered merge action kl
achieving kl k
kl may cause action sequence
p



case sequence hence must achieve kl nonempty kt p hence inductive hypothesis two cases
sequence must achieve l p possible initial state satisfies


fipalacios geffner

yet since merge valid possible initial states must satisfy one
thus must achieve l p possible initial states initial
states satisfy
lemma applicable valid translation kt p applicable p
applicable k
proof empty direct
p

applicable kt p achieving kl precondition l hence
inductive hypothesis applicable p lemma must achieve
l precondition l thus applicable p

theorem translation kt p sound provided merges valid
tags consistent
proof consider p similar p dummy action ag
whose preconditions goals g p plan kt p iff
ag applicable kt p lemma implies ag applicable
p means plan p
lemma let action sequence applicable p applicable
ks p achieves l p possible initial state achieves kl
ks p
proof empty achieves l p l since l kl must
thus achieves kl ks p
likewise achieves l p rule c l
achieves c p b achieves l rule c l achieves l
ks p l c
inductive hypothesis achieves kc ks p rule kc
achieves kl merges
kl must achieve kl thus
delete positive literals kl
b inductive hypothesis achieves kl kl ks p l
body rule c l p therefore achieves kl


lemma applicable p applicable ks p
proof empty trivial applicable p must
applicable p must achieve precondition l p every possible initial
state inductive hypothesis must applicable ks p
lemma v
must achieve literals kl last
merge action effect ss kl kl must achieve kl
therefore applicable ks p
theorem conformant plan p classical plan ks p
dropping merge actions


ficompiling uncertainty away conformant

proof direct lemma consider p similar p
action ag whose preconditions goals g p plan p sequence ag
applicable p lemma ag applicable ks p thus
plan ks p
definition rel l stands set literals l relevant l p
rel l l l l relevant l
definition stands deductive closure
l l
theorem let tn covering merge literal l valid translation kt p p whose initial situation prime implicate form
tag ti must possible initial state p rel l ti
proof assume otherwise state satisfying makes true literal ls relevant
l ls ti take c disjunction literals ls
states satisfy obtain entails c since prime implicate form
means c contains tautology c subsumed clause c case
contradiction literals c c relevant l hence ti ti
part covering merge must contain literal c c hence c
lemma let action sequence applicable p applicable covering translation kt p achieves l p possible
initial state tag rel l achieves kl
kt p
proof empty achieves l p l thus rel l since
rel l l thus kl initial situation kt p
achieves kl kt p likewise achieves l p
rule c l p achieves c p b achieves l p
rule c l achieves l p l c inductive
hypothesis achieves kc support rule kc kl kt p
merges cannot
must achieve kl kt p must
delete positive literal kl b inductive hypothesis achieves kl
cancellation rule kc kl arising rule c l p must

achieve kl literal l c means therefore
must achieve kl
lemma let kt p covering translation p applicable p
applicable kt p
proof empty direct else applicable p must
applicable p must achieve literal l p therefore inductive
hypothesis must applicable kt p let tn covering
merge l p kt p theorem ti must


fipalacios geffner

possible initial state rel l ti lemma achieving l
p implies achieving kl ti kt p since true ti achieves
l p p possible initial states follows achieves kl ti
ti kt p therefore achieves kl kt mv p ends
sequence merges include action merge l effect ti kl ti kl
applicable k

p
theorem covering translations kt p complete e conformant plan
p classical plan kt p merge actions
removed
proof theorem follows trivially lemma p
p additional dummy action ag goals g p preconditions
ag action sequence plan p iff action sequence ag applicable p
due lemma implies action sequence ag applicable kt p
turn true iff action sequence plan kt p sequence
turn sequence merge actions removed
theorem translation kmodels p sound complete
proof direct merges generated kmodels precondition goal
literals l clearly merges valid tags consistent
cover l ci l satisfy ci l thus follows theorems

proposition width w p p determined time exponential
w p
proof number clauses ci l mi sets clauses c
ci l c clause one set must n literals n
number fluents p hence one literal clause c collected end
ni sets literals size greater inconsistent
consistent minimal consistent set collection
properly included tests polynomial given prime implicate form
thus constructing cover c c set clauses c c exponential
checking whether one cover satisfies ci l polynomial operation provided
prime implicate form indeed c c tn computing closures
ti ti c c pi testing whether ti intersects clause
ci l polynomial operations former reducing checking literal l
whether ti l thus computing width l generate sets c clauses
ci l c starting increasing one one one set
c c satisfies ci l computation exponential w l computation
preconditions goal literals p exponential w p
proposition width p w p n n number
fluents whose value initial situation known


ficompiling uncertainty away conformant

proof inequality w p direct w l defined size c minimal set
clauses c ci l c c satisfies ci l w p w l precondition
goal literal l inequality w p n follows noticing set c clauses
given tautologies l l ci l c c must satisfy clause c ci l
c c must assign truth value literal c inconsistent c
inconsistent thus pruned c c finally max number tautologies
ci l number fluents l neither l l unit clauses
theorem fixed translation ki p sound polynomial w p
covering complete
proof soundness need prove merges ki p valid
tags ki p consistent soundness follows theorem merges
literal l ki p given covers c c collections c less clauses
ci l clearly since
model must satisfy ci l must satisfy
w
c c tm c c time definition
cover c c tags must consistent
proving ki polynomial fixed follow ideas similar ones used
proof proposition shown width p
determined time exponential w p polynomial number clauses
fluents p fixed number sets clauses c ci l size c
polynomial complexity computing covers c c sets hence
merges l ki p polynomial thus whole translation ki p fixed
polynomial number clauses fluents rules p
finally proving completeness w p w l precondition
goal literal l p therefore literal l set c clauses ci l
c c satisfies ci l translation ki p generate unique merge
l covers l since ki p valid translation means ki p covering
translation complete virtue theorem
lemma l relevant l rel l rel l rel l rel l
proof l rel l l relevant l since l relevant l
relevance relation transitive l relevant l thus l rel l therefore
since rel l rel l l rel l l since relevant
l l rel l
proposition let two states let action sequence applicable
classical p p achieves literal l p rel l
rel l achieves literal l p
proof induction length empty achieves literal l p l
must since l relevant l rel l rel l rel l
l must thus achieves l p


fipalacios geffner

likewise achieves l p rule c l
achieves c p b achieves l p rule c l achieves
l p l c
must achieve literal li c p since li relevant l rel l
rel l lemma rel li rel li inductive hypothesis plan
must achieve li p li c thus must achieve l p
b since l relevant l l relevant l rel l
rel l lemma rel l rel l thus inductive hypothesis
must achieve l p l must achieve l p
lemma two collection states every state
every precondition goal literal l p state rel l
rel l applicable p applicable p
proof induction length empty obvious applicable
p applicable p inductive hypothesis applicable p
need prove achieves preconditions action p
l p rec hypothesis state
rel l rel l proposition since achieves l p must
achieve l p since argument applies achieves l p thus
must applicable p
proposition two collections states every state
every precondition goal literal l p state rel l
rel l plan p conforms plan p conforms

proof lemma consider p similar p action
ag whose preconditions goals g p plan p conforms
action sequence ag applicable p lemma ag
applicable p thus must plan p
proposition basis p every possible initial state p every
precondition goal literal l p contains state rel l rel l
proof direct proposition considering set possible initial states
p
proposition initial situation prime implicate form tn
merge covers literal l p set ti l possible initial states p
rel l ti non empty
proof direct theorem
theorem let kt p covering translation let stand collection
states ti l l precondition goal literal p ti tag merge
covers l basis p


ficompiling uncertainty away conformant

proof every possible initial state precondition goal literal
l theorem contains state rel l rel l
follows proposition indeed state must satisfy tag ti covering
merge tn l merges valid theorem must
possible initial state rel l ti therefore rel l rel l
must satisfy ti possibly literals l relevant l
theorem p conformant bounded width p admits
basis polynomial size
proof w p fixed ki p covering translation polynomial number
merges tags case basis p defined theorem contains
polynomial number states regardless number possible initial states

appendix b consistency
assuming throughout conformant p
translations kt p consistent section make notion precise
explain needed prove kt p consistent p proof
take account heads kl merge actions l kt p extended
literals kl literals l mutex l p see definition
start beginning assuming states truth assignments sets
literals fluents language state complete every literal l l l
consistent literal l l complete consistent
states represent truth assignments fluents f consistency p
translation kt p ensures applicable action sequences map complete
consistent states complete consistent states guaranteed complete
consistent states referred simply states done

given complete state action applicable next state sa
sa del add

add l c l p c

del l l add
follows sa complete state complete state action
deletes literal l l added hand may consistent
sa inconsistent example rules c l c l
c c order exclude possibility ensuring reachable
states complete consistent thus represent genuine truth assignments
fluents f consistency condition p needed
definition b consistency classical conformant p hf gi consistent initial situation logically consistent every pair complementary
literals l l mutex p


fipalacios geffner

consistent classical p reachable states complete consistent
standard progression lemma used preceding proofs holds
theorem b progression action sequence applicable complete
consistent state achieves literal l consistent classical p iff achieves
body c rule c l p b achieves l every rule c l
achieves l literal l c
see conformant p consistent sense
valid translation kt p tested benchmarks considered
consistency found consistent except two domains
introduced elsewhere dispose look grab cases since consistency
classical kt p cannot inferred consistency p
checked explicitly definition b similarly plans obtained
kt p checked consistency indicated section soundness
plans ensured provided never trigger conflicting effects kl kl
proof proof theorem b rest particular definition mutexes
mutex atoms true reachable state consistent p
applicable action sequence maps complete consistent state represents
truth assignment action sequence achieves l iff c l add
l l del condition theorem however equivalent c
condition b theorem equivalent indeed l del iff rule
c l literal l c l given complete
consistent true iff l precisely consistency needed else l
would imply l
notion mutex used definition consistency expresses guarantee
pair literals true reachable state sufficient polynomial conditions
mutual exclusivity type invariants defined papers
follow definition bonet geffner
definition b mutex set mutex set collection r unordered literals pairs
l l classical conformant p
pair l l r l l possible initial state
c l c l two rules action l l pair
r p c c mutex r
c l rule p literal l pair l l r l l
b p c mutex l r c p c implies c r rule
c l p
consistency two domains dispose look grab established however
definition mutexes slightly stronger one used actually suffices change
expression p c clause c definition mutex sets p c l



ficompiling uncertainty away conformant

definition pair said mutex r belongs r set literals
said mutex r contains pair r set literals said imply set
literals r mutex r complement l literal l
easy verify r r mutex sets union r r mutex set
thus maximal mutex set p denote r pairs r
called mutexes
simplicity without loss generality assume preconditions p
empty indeed simple mutexes p remain
preconditions pushed conditions assume condition c rule
c l p mutex rules simply pruned addition assume
literal l mutex pair complementary literals l l l cannot
true reachable state thus pruned well
definition mutexes sound meaning pair mutex set true
reachable state
theorem b l l pair mutex set r classical conformant
p reachable state p l l
proof proceed inductively clearly l l cannot part possible initial state
ruled definition mutex sets thus let us assume inductive hypothesis
l l part state reachable less steps let us prove
true states sa reachable one step clearly
l l belong l l belong add b l belongs
add l belongs del possible
p must comprise rules c l c l c c yet
definition mutex sets c c must mutex inductive hypothesis
c c b must rule c l c l
inductive hypothesis follows l mutex c r thus
mutex set definition l l c implies c rule c l
first case however due rule c l c l del
second case completeness reachable states must c hence
l del contradicting b cases
provided initial situation conformant p prime
implicate form computing largest mutex set r testing consistency p
polynomial time operations former one starts set literal pairs
iteratively drops set pairs comply definition
reaching fixed point bonet geffner
move prove conformant p consistent valid
translation kt p consistency classical p possible initial
states direct set mutexes p subset set mutexes p
initial situation constrained
proposition b mutex set rt valid translation kt p consistent conformant p define rt set unordered literals pairs kl kl
kl kl l l mutex p two tags jointly satisfiable
rt mutex set kt p


fipalacios geffner

follows kt p consistent p consistent l l
mutex l p kl kl must mutex rt
theorem b consistency kt p valid translation kt p consistent p
consistent
consistency translation k p follows special case k p kt p
empty set merges set tags containing empty tag
left prove proposition b
proof proposition b must set rt comprised pairs kl kl
kl kl l mutex l p tags jointly satisfiable
set complies clauses definition b go one clause
time
pair rt true initially kt p hf g jointly satisfiable
indeed kl kl must possible initial
state satisfying l l true contradiction l l
mutex p similarly kl kl must case
l l must possible initial state p
l l hold contradiction l l mutex p
action rules kl kl rules must support
rules form kc kl kc kl arising rules
c l c l p since l l mutex p c c
must contain literals l c l c l l mutex p
hence kl kl belongs rt kc kc mutex rt
well
similarly action rules kl kl literal l
mutex l p rules must support cancellation rules form
kc kl kc kl arising rules c l
c l p since l l mutex p c c must contain literals
l c l c mutex p hence rt must contain pair
kl kl kc kc must mutex rt
left set rt given pairs kl kl kl
kl complies clause definition mutex sets well consider
first class pairs kl kl rule kc kl kl arising
rule c l p since l mutex l p one conditions
b c must hold rule c l l l l kc
must imply body kc cancellation rule kc kl
literal l c rt must contain pair kl kl kl
implies kl kc implies kc case c b c l
action cannot merge literal l mutex l l case l implies
l l mutex similarly cannot merge l case l mutex
l l reason cannot merge l thus action
cannot merge must action p



ficompiling uncertainty away conformant

mutex p thus c contains literal l mutex l p means
pair kl kl rt hence kc mutex kl rt
case b last c c implies c p rule c l kc must
imply body kc cancellation rule kc kl indeed
literal l c c kl implies kl
l literal c c literal l c must mutex
l p hence pair kl kl must rt kl implies
kl case c

consider
v pair kl kl along merge action l
rule ti kl ti kl kl kl thus empty tag case since
merge valid consistent must ti ti
jointly consistent follows kl ti kl pair rt
thus body merge mutex kl rt case b

need consider pair kl kl along rules kl
literals kl kl structure thus argument
applies replacing l l
switch second class pairs kl k l rules
kc kl kl since l l mutex p conditions b
c must hold l l case condition c holds kt p
kc implies body kc rule kc kl l l b c
mutex l thus literal l c l l mutex
p therefore kc kl mutex rt case b finally c c
implies c rule c l p kc must imply kc rt
rule kc kl case c
empty tag rule kl may merge due extra
effects kl merge action l merge kl merge kl
case c holds
last class pairs rules kl cancellation rules
form kc kl rule c l p since l mutex
l p conditions b c must hold rule c l l p
l l cancellation rule kc kl case c
b c mutex l thus literal l c l l mutex
p therefore kl implies kl rt hence kl kc
imply kl rt case b finally c c implies c rule c l p
kc must imply kc rule kc kl rt
indeed la implies lb p lb implies la p klb implies kla
rt kla implies klb

references
albore palacios h geffner h translation contingent
proc st int joint conference ai ijcai pp


fipalacios geffner

baral c kreinovich v trejo r computational complexity
approximate presence incompleteness artificial intelligence
baral c son c approximate reasoning actions presence sensing
incomplete information proc ilps pp
bayardo jr r schrag r csp look back techniques solve real world
sat instances proc aaai pp
bertoli p cimatti improving heuristics search belief space
ghallab hertzberg j traverso p eds proc aips pp
aaai press
bonet b geffner h heuristic search proceedings
ecp pp springer
bonet b geffner h incomplete information heuristic search
belief space proc aips pp aaai press
bonet b geffner h heuristic search artificial intelligence

bonet b givan b conformant track th int
competition http www ldc usb bonet ipc docs conformant pdf
bryce buffet international competition uncertainty part benchmarks http ippc loria fr wiki images pdf
bryce kambhampati smith e graph heuristics belief
space search journal artificial intelligence
cimatti roveri bertoli p conformant via symbolic model
checking heuristic search artificial intelligence
dechter r constraint processing morgan kaufmann
goldman r p boddy expressive explicit knowledge
proc aips pp
haslum p jonsson p complexity incomplete information proc ecp lect notes ai vol pp
springer
hoffmann j brafman r contingent via heuristic forward search
implicit belief states proc th int conf automated scheduling
icaps pp aaai
hoffmann j brafman r conformant via heuristic forward search
artificial intelligence
hoffmann j nebel b system fast plan generation
heuristic search journal artificial intelligence
marquis p consequence finding gabbay smets p eds
handbook defeasible reasoning uncertainty management systems vol pp
kluwer


ficompiling uncertainty away conformant

palacios h geffner h compiling uncertainty away solving conformant classical planner sometimes proc aaai pp
palacios h geffner h conformant classical efficient translations may complete proc icaps pp
petrick r bacchus f knowledge incomplete
information sensing proc aips pp
rintanen j complexity partial observability proc icaps pp
smith weld conformant graphplan proceedings aaai pp
aaai press
son c tu p h gelfond morales conformant domains
constraints proc aaai pp
son c tu p h completeness approximation reasoning
action theories incomplete information proc th int conf
principles kr reasoning kr pp
tison p generalized consensus theory applications minimization
boolean circuits ieee transactions computers ec
tran nguyen h pontelli e son c cpa c h two approximationbased conformant planners http ippc loria fr wiki images team cpa pdf
tran nguyen h pontelli e son c improving performance conformant planners static analysis declarative domain specifications practical aspects declarative languages th international symposium padl proceedings vol lecture notes computer science pp springer
turner h polynomial length spans polynomial hierarchy jelia
proc european conference logics ai pp springer verlag




