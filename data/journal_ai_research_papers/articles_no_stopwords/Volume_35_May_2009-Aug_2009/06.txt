Journal Artificial Intelligence Research 35 (2009) 623-675

Submitted 10/08; published 08/09

Compiling Uncertainty Away Conformant Planning
Problems Bounded Width
Hector Palacios

hlp@ldc.usb.ve

Universitat Pompeu Fabra
Roc Boronat, 138
08018 Barcelona, SPAIN

Hector Geffner

hector.geffner@upf.edu

ICREA & Universitat Pompeu Fabra
Roc Boronat, 138
08018 Barcelona, SPAIN

Abstract
Conformant planning problem finding sequence actions achieving goal
presence uncertainty initial state action effects. problem
approached path-finding problem belief space good belief representations
heuristics critical scaling up. work, different formulation introduced
conformant problems deterministic actions automatically converted
classical ones solved off-the-shelf classical planner. translation maps
literals L sets assumptions initial situation, new literals KL/t
represent L must true initially true. lay general translation scheme
sound establish conditions translation complete.
show complexity complete translation exponential parameter
problem called conformant width, benchmarks bounded. planner
based translation exhibits good performance comparison existing planners,
basis T0 , best performing planner Conformant Track 2006
International Planning Competition.

1. Introduction
Conformant planning form planning goal achieved initial
situation fully known actions may non-deterministic effects (Goldman &
Boddy, 1996; Smith & Weld, 1998). Conformant planning computationally harder
classical planning, even polynomial restrictions plan length, plan verification
remains hard (Haslum & Jonsson, 1999; Baral, Kreinovich, & Trejo, 2000; Turner, 2002;
Rintanen, 2004). practical problems purely conformant, ability find
conformant plans needed contingent planning conformant situations special
case relaxations conformant planning yield useful heuristics (Hoffmann &
Brafman, 2005).
problem conformant planning formulated path-finding problem
belief space sequence actions map given initial belief state target
belief sought (Bonet & Geffner, 2000). belief state represents set states
deemed possible, actions, whether deterministic not, map one belief state
c
2009
AI Access Foundation. rights reserved.

fiPalacios & Geffner

another. formulation, underlies current conformant planners (Hoffmann &
Brafman, 2006; Bryce, Kambhampati, & Smith, 2006; Cimatti, Roveri, & Bertoli, 2004)
must address two problems: problem representing beliefs compact way,
problem obtaining effective heuristics beliefs. first problem approached
logical representations make use SAT OBDD technology,
intractable worst case, scale better plain state representations. second
problem, hand, complex, heuristics searching belief
space successful far heuristics developed classical planning (Bonet
& Geffner, 2001; Hoffmann & Nebel, 2001).
work, introduce different approach conformant planning problems
automatically compiled classical problems solved classical planner.
translation maps sets literals initial situation literals L new literals
KL/t express true initial situation, L must true. lay first
general translation scheme sound establish conditions
translation complete. Also, show complexity complete translation
exponential parameter problem call conformant width,
benchmark domains bounded, implying complete translation
cases polynomial. planner based translation exhibits good performance
comparison existing conformant planners basis T0 , best performing
planner Conformant Track 2006 International Planning Competition.
translation-based approach provides solution two problems faced conformant planners search belief space: belief representation heuristic
beliefs. translation-based approach, beliefs represented literals KL/t
stand conditionals, representation polynomial complete conformant problems bounded width. addition, since belief states represented
plain states, heuristic beliefs classical heuristic. computational point
view, though, explicit search belief-space: conformant problems P
converted classical problems K(P ) knowledge-level (Petrick & Bacchus, 2002),
whose solutions, computed classical planner, encode conformant solutions P .
formulation limited conformant problems deterministic
uncertainty lies initial situation. address nonetheless issues must
handled order generalize translation-based approach non-deterministic domains
report empirical results non-deterministic domains well.
paper organized follows. define first syntax semantics conformant
planning problems P (Section 2), consider simple sound incomplete translation
K0 (Section 3). consider general translation scheme KT,M
two parameters, set tags encoding assumptions initial situation,
set merges encoding valid disjunctions tags (Section 4), analyze several
instances scheme follow particular choices sets tags merges:
complete exponential translation KS0 tags associated possible
initial states problem (Section 5), polynomial translation Ki fixed integer
0 complete problems conformant width bounded (Section 6).
provide alternative explanation compact complete translation
showing problems bounded width, exponential number possible initial
states S0 includes always polynomial number critical initial states S00 plans
624

fiCompiling Uncertainty Away Conformant Planning Problems

conform S00 conform S0 (Section 7). finally present conformant
planner T0 (Section 8), empirical evaluation planner (Section 9), extension
non-deterministic actions (Section 10), discussion related work (Section 11).
followed brief summary (Section 12) formal proofs (Appendix).
work revision extension formulation presented Palacios
Geffner (2007), turn based ideas first sketched Palacios Geffner
(2006).

2. Conformant Problem P
define next syntax semantics conformant planning problems considered.
2.1 Syntax
Conformant planning problems P represented tuples form P = hF, I, O, Gi
F stands fluent symbols problem, set clauses F defining
initial situation, stands set (ground) operators actions a, G set
literals F defining goal. Every action precondition P re(a) given set
fluent literals, set conditional effects C L C set fluent literals
L fluent literal.
actions assumed deterministic hence uncertainty lies initial
situation. Thus, language conformant problem P excluding uncertainty
initial situation, Strips extended conditional effects negation. Moreover,
uncertainty initial situation, fluents appear unit clauses
I, P equivalent classical planning problem.
refer conditional effects C L action rules associated
a, sometimes write : C L. convenient, join several effects
associated action condition : C L L0 write C L
true L C empty. Finally, literal L, L denotes complement L.
2.2 Semantics
state truth assignment fluents F P = hF, I, O, Gi possible initial
state P state satisfies clauses I.
state s, write I(s) refer set atoms (positive literals) true
s, write P/s refer classical planning problem P/s = hF, I(s), O, Gi
conformant problem P except initial state fixed s.
action sequence = {a0 , a1 , . . . , } classical plan P/s action sequence
executable state results goal state sG ; i.e., = 0, . . . , n,
preconditions action ai true si , si+1 state results action
ai state si , goal literals true sn+1 .
Finally, action sequence conformant plan P iff classical plan P/s
every possible initial state P .
Conformant planning computationally harder classical planning, plan verification remains hard even polynomial restrictions plan length (Haslum & Jonsson,
1999; Baral et al., 2000; Turner, 2002; Rintanen, 2004). common approach
625

fiPalacios & Geffner

conformant planning based belief state formulation (Bonet & Geffner, 2000).
belief state b non-empty set states deemed possible given situation,
every action executable b, maps b new belief state ba . conformant
planning task becomes path-finding problem graph nodes belief states
b, source node b0 belief state corresponding initial situation, target
belief states bG goals true.
assume throughout logically consistent, set possible initial
states empty, P consistent, bodies C C 0 conflicting
effects : C L : C 0 L associated action mutually exclusive
mutex. details this; see Part B Appendix.

3. Basic Translation K0
simple translation conformant problem P classical problem K(P )
obtained replacing literals L literals KL KL aimed capturing whether
L known true known false respectively.
Definition 1 (Translation K0 ). conformant planning problem P = hF, I, O, Gi,
translation K0 (P ) = hF 0 , 0 , O0 , G0 classical planning problem
F 0 = {KL, KL | L F }
0 = {KL | L unit clause I}
G0 = {KL | L G}
O0 = precondition L replaced KL, conditional
effect : C L replaced : KC KL : KC KL,
expressions KC KC C = L1 , L2 . . . abbreviations formulas
KL1 , KL2 . . . KL1 , KL2 . . . respectively.
intuition behind translation simple: first, literal KL true initial
state 0 L known true I; otherwise false. removes uncertainty
K0 (P ), making classical planning problem. addition, soundness,
rule : C L P mapped two rules: support rule : KC KL, ensures
L known true condition known true, cancellation
rule : KC KL guarantees KL deleted (prevented persist)
action applied C known false. use support cancellation rules
encoding original rules knowledge-level subtlety translation.
translation K0 (P ) sound every classical plan solves K0 (P ) conformant
plan P , incomplete, conformant plans P classical plans K(P ).
meaning KL literals follows similar pattern: plan achieves KL K0 (P ),
plan achieves L certainty P , yet plan may achieve L certainty
P without making literal KL true K0 (P ).1
Proposition 2 (Soundness K0 (P )). classical plan K0 (P ),
conformant plan P .
1. Formal proofs found appendix.

626

fiCompiling Uncertainty Away Conformant Planning Problems

illustration, consider conformant problem P = hF, I, O, Gi F = {p, q, r},
= {q}, G = {p, r}, actions = {a, b} effects
: q r , : p p , b : q p .
problem, action sequence = {a, b} conformant plan P action
sequence 0 = {a} not. Indeed, classical plan P/s possible initial state
s, 0 classical plan possible initial state s0 p true (recall
possible initial state P satisfies neither p r assumed
initially false problem).
Definition 1, translation K0 (P ) = hF 0 , 0 , O0 , G0 classical planning problem
fluents F 0 = {Kp, Kp, Kq, Kq, Kr, Kr}, initial situation 0 = {Kq}, goals G0 =
{Kp, Kr}, actions O0 = {a, b} effects
: Kq Kr , : Kp Kp , b : Kq Kp,
encode supports, effects
: Kq Kr , : Kp Kp , b : Kq Kp,
encode cancellations.
Proposition 2 implies, example, 0 = {a}, conformant plan
P , cannot classical plan K(P ) either. easy verify, support
: Kq Kr achieves goal Kr Kq true 0 , cancellation : Kp Kp
associated action, preserves Kp false goal p.
translation K0 complete, meaning fails capture conformant plans P classical plans, completeness assessed terms weaker
semantics. so-called 0-approximation semantics (Baral & Son, 1997), belief states b
represented 3-valued states fluents true, false, unknown. incomplete belief representation, checking whether action applicable belief state b,
computing next belief state ba , verifying polynomial length plans polynomial
time operations. particular, literal L true next belief state ba iff a) action
effect C L literals C true b, b) L true b
effects C 0 L action a, complement literal L0 C 0 true b. action
sequence conformant plan P according 0-approximation semantics
belief sequence generated according 0-approximation semantics makes
action sequence applicable terminates belief state goals true.
possible prove that:
Proposition 3 (K0 (P ) 0-Approximation). action sequence classical plan
K0 (P ) iff conformant plan P according 0-approximation semantics.
correspondence surprising though 0-approximation semantics
K0 (P ) translation throw away disjunctive information restrict plans
make use uncertain knowledge. Indeed, states s0 , s1 , . . . generated
action sequence = {a0 , a1 , . . .} classical problem K0 (P ) encode precisely
627

fiPalacios & Geffner

literals known true according 0-approximation; namely, L true
time according 0-approximation iff literal KL true state si .
Proposition 3 mean basic translation K0 0-approximation
semantics equivalent rather rely equivalent belief representations.
translation K0 delivers way get valid conformant plans using classical
planner. translation-based approach thus addresses representational
heuristic issues arise conformant planning.
illustration Proposition 3, given conformant problem P = {p, r}
actions b effects : p q, : r v, b : q v, plan = {a, b} valid
achieving goal G = {q, v} according K0 (P ) 0-approximation,
plan = {b} valid according either. time, initial situation
changed = {p q}, neither approach sanctions plan = {a} G = {q}, even
valid conformant plan. this, ability reason disjunctions needed.
extension basic translation K0 allows limited form disjunctive reasoning presented Palacios Geffner (2006). extension based introduction
new literals L/Xi used encoding conditionals Xi L. Below, basic translation
K0 extended different manner ensures tractability completeness
large class problems.

4. General Translation Scheme KT,M
basic translation K0 extended general translation scheme KT,M
two parameters: set tags set merges m. show
suitable choices two parameters, translation KT,M , unlike translation K0 ,
sound complete.
tag set (conjunction) literals L P whose truth value initial
situation known. tags used introduce new class literals KL/t
classical problem KT,M (P ) represent conditional true initially, L
true, assertion could written K(t0 L) temporal modal logic. use
notation KL/t rather L/t used Palacios Geffner (2006),
distinction KL/t KL/t: roughly KL/t means conditional
K(t0 L) true, KL/t means conditional K(t0 L) true.
Likewise, merge non-empty
W collection tags stands Disjunctive Normal Form (DNF) formula tm t. merge valid one tags
must true I; i.e.,
_
|=
.
tm

merge literal L P translate merge action single effect
^
KL/t KL
tm

captures simple form reasoning cases.
valid merge used reasoning literal L P , computationally
convenient (although logically necessary) specify certain merges
used literals L others. Thus, formally, collection pairs
628

fiCompiling Uncertainty Away Conformant Planning Problems

(m, L), merge L literal P . pair means merge
L. group merges literal L set ML , thus, understood
collection sets ML L P . simplicity, however, except
may cause confusion, keep referring plain set merges.
assume collection tags always includes tag stands
empty collection literals, call empty tag denote . empty
tag, denote KL/t simply KL.
translation KT,M (P ) basic translation K0 (P ) conditioned tags
extended actions capture merges :
Definition 4 (Translation KT,M ). Let P = hF, I, O, Gi conformant problem,
KT,M (P ) classical planning problem KT,M (P ) = hF 0 , 0 , O0 , G0
F 0 = {KL/t, KL/t | L F }
0 = {KL/t | I, |= L}
G0 = {KL | L G}
O0 = {a V
: KC/t KL/t, : KC/t KL/t | : C L P }
{am,L : [ tm KL/t] KL XL | L P, ML }
KL precondition action KT,M (P ) L precondition P , KC/t
KC/t stand KL1 /t, KL2 /t,
V . . . , KL1 /t, KL2 /t, . . . respectively,
C = L1 , L2 , . . ., XL stands L0 KL0 L0 ranging literals L0 mutex
L P .
translation KT,M (P ) reduces basic translation
K0 (P ) empty
V
contains empty tag. extra effects XL = L0 KL0 merge actions am,L
needed ensure translation KT,M (P ) consistent P consistent,
otherwise ignored. Indeed, L L0 mutex consistent P , invariant
KL/t KL0 /t holds KT,M (P ) non-empty tags t, hence successful merge
L always followed successful merge L0 . rest paper
thus assume P KT,M (P ) consistent, ignore extra merge effects,
come back Appendix B proving consistency KT,M (P )
consistency P .
suitable choices , translation KT,M (P ) sound complete.
establishing results, however, let us make notions precise.
Definition 5 (Soundness). translation KT,M (P ) sound classical plan
solves classical planning problem KT,M (P ), plan 0 results dropping
merge actions conformant plan P .
Definition 6 (Completeness). translation KT,M (P ) complete conformant
plan 0 solves conformant problem P , classical plan solves
classical problem KT,M (P ) 0 equal merge actions removed.
general translation scheme KT,M sound provided merges valid
tags consistent (literals tag true possible initial state):
629

fiPalacios & Geffner

Theorem 7 (Soundness KT,M (P )). translation KT,M (P ) sound provided
merges valid tags consistent.
Unless stated otherwise, assume merges valid tags consistent,
call translations, valid translations.
convention keeping notation simple, singleton tags = {p}, curly
brackets often dropped. Thus, literals KL/t = {p} written KL/p,
merges = {t1 , t2 } singleton tags t1 = {p} t2 = {q}, written = {p, q}.
Example. illustration, consider problem moving object origin
destination using two actions: pick(l), picks object location hand
empty object location, drop(l), drops object location
object held. making problem interesting, let us assume
action pick(l) drops object held l hand empty.
conditional effects action preconditions. Assuming single
object, effects written as:
pick(l) : hold, at(l) hold at(l)
pick(l) : hold hold at(l)
drop(l) : hold hold at(l) .
Consider instance P domain, hand initially empty
object, initially either l1 l2 , must moved l3 ; i.e., P = hF, I, O, Gi
= {hold , at(l1 ) at(l2 ) , at(l1 ) at(l2 ) , at(l3 )}

G = {at(l3 )} .
action sequence
1 = {pick(l1 ), drop(l3 ), pick(l2 ), drop(l3 )}
conformant plan problem, attempt pick object location
l1 followed drop target location l3 , ensuring object ends l3
originally l1 . followed attempt pick object l2
drop l3 .
hand, action sequence 2 results 1 removing first
drop action
2 = {pick(l1 ), pick(l2 ), drop(l3 )}
conformant plan, since object originally l1 , would end l2
action pick(l2 ). notation introduced above, 1 classical plan classical
problem P/s two possible initial states s, 2 classical plan problem
P/s state object initially l2 .
630

fiCompiling Uncertainty Away Conformant Planning Problems

Consider classical problem KT,M (P ) = hF 0 , 0 , O0 , G0 obtained P
= {at(l1 ), at(l2 )}2 contains merge = {at(l1 ), at(l2 )} literals
hold at(l3 ). definition, fluents F 0 KT,M (P ) form KL/t
KL/t L {at(l), hold}, l {l1 , l2 }, , initial situation 0
0 = {Khold, Khold/at(l), Kat(l3 ), Kat(l3 )/at(l), Kat(l)/at(l), Kat(l0 )/at(l)}
l, l0 {l1 , l2 } l0 6= l, goal G0
G0 = {Kat(l3 )} .
effects associated actions pick(l) drop(l) O0 support rules
pick(l) : Khold, Kat(l) Khold Kat(l)
pick(l) : Khold Khold Kat(l)
drop(l) : Khold Khold Kat(l)
one three locations l = li , condition rule empty tag,
along support rules:
pick(l) : Khold/at(l0 ), Kat(l)/at(l0 ) Khold/at(l0 ) Kat(l)/at(l0 )
pick(l) : Khold/at(l0 ) Khold/at(l0 ) Kat(l)/at(l0 )
drop(l) : Khold/at(l0 ) Khold/at(l0 ) Kat(l)/at(l0 )
condition rule tags at(l0 ) , l0 {l1 , l2 }. corresponding
cancellation rules are:
pick(l) : Khold, Kat(l) Khold Kat(l)
pick(l) : Khold Khold Kat(l)
drop(l) : Khold Khold Kat(l)

pick(l) : Khold/at(l0 ), Kat(l)/at(l0 ) Khold/at(l0 ) Kat(l)/at(l0 )
pick(l) : Khold/at(l0 ) Khold/at(l0 ) Kat(l)/at(l0 )
drop(l) : Khold/at(l0 ) Khold/at(l0 ) Kat(l)/at(l0 ) .
addition, actions O0 include merge actions am,hold am,at(l3 ) follow
merge = {at(l1 ), at(l2 )} literals hold at(l3 ):
am,hold : Khold/at(l1 ), Khold/at(l2 ) Khold
am,at(l3 ) : Kat(l3 )/at(l1 ), Kat(l3 )/at(l2 ) Kat(l3 ) .
2. empty tag assumed every thus mentioned explicitly.

631

fiPalacios & Geffner

shown plan
10 = {pick(l1 ), drop(l3 ), pick(l2 ), drop(l3 ), am,at(l3 ) }
solves classical problem KT,M (P ) hence, Theorem 7, plan 1 obtained
10 dropping merge action, valid conformant plan P (shown above).
see literals KT,M (P ) evolve actions 10 executed:
0:
1:
2:
3:
4:
5:

Kat(l1 )/at(l1 ), Kat(l2 )/at(l2 )
Khold/at(l1 ), Kat(l2 )/at(l2 )
Kat(l3 )/at(l1 ), Kat(l2 )/at(l2 )
Kat(l3 )/at(l1 ), Khold/at(l2 )
Kat(l3 )/at(l1 ), Kat(l3 )/at(l2 )
Kat(l3 )

true
true
true
true
true
true

0






pick(l1 )
drop(l3 )
pick(l2 )
drop(l3 )
merge am,at(l3 ) .

verify manner action sequence 20
20 = {pick(l1 ), pick(l2 ), am,hold , drop(l3 )}
classical plan KT,M (P ), reason atom Khold/at(l1 ) holds
first pick action second. due cancellation rule:
pick(l2 ) : Khold/at(l1 ) Khold/at(l1 ) Kat(l2 )/at(l1 )
expresses assumption at(l1 ) initial situation, hold at(l2 )
known true action pick(l2 ), assumption, hold
known true action.

5. Complete Translation: KS0
complete instance translation scheme KT,M obtained simple manner
setting tags possible initial states problem P merge
precondition goal literal L includes tags. call resulting
exhaustive translation KS0 :
Definition 8 (Translation KS0 ). conformant problem P , translation KS0 (P )
instance translation KT,M (P )
set union empty tag set S0 possible initial states P
(understood maximal sets literals consistent I),
set contain single merge = S0 precondition goal literal L
P.
translation KS0 valid hence sound, complete due correspondence
tags possible initial states:
Theorem 9 (Completeness KS0 ). conformant plan P ,
classical plan 0 KS0 (P ) result dropping merge actions 0 .

632

fiCompiling Uncertainty Away Conformant Planning Problems

#S0
Problem
adder-01
blocks-02
blocks-03
bomb-10-1
bomb-10-5
bomb-10-10
bomb-20-1
coins-08
coins-09
coins-10
coins-11
comm-08
comm-09
comm-10
corners-square-16
corners-square-24
corners-square-28
corners-square-116
corners-square-120
square-center-16
square-center-24
log-2-10-10
log-3-10-10
ring-5
ring-6
safe-50
safe-70
safe-100
sortnet-07
sortnet-08
sortnet-09
sortnet-10
uts-k-08
uts-k-10

18
18
231
1k
1k
1k
1M
1k
1k
1k
1M
512
1k
2k
4
4
4
4
4
256
576
1k
59k
1,2k
4,3k
50
70
100
256
512
1k
2k
16
20

KS0
time
len
> 2h
0,2
23
59,2
80
5,9
19
11,3
15
18,3
10
> 2.1GB
20,2
27
19,9
25
21,5
31
> 2.1GB
18,3
61
77,7
68
> 2.1GB
0,2
102
0,7
202
1,2
264
581,4 3652
> 2.1GB
13,1
102
> 2.1GB
183,5
85
> 2h
12,6
17
> 2.1GB
0,5
50
1,4
70
6
100
2,9
28
9,8
36
77,7
45
> 2.1GB
0,6
46
1,2
58

POND
time len
0,4
26
0,4
26
126,8 129
1
19
3
15
8
10
4139
39
2
28
5
26
5
28
> 2h
1
53
1
59
1
65
1131
67
> 2h
> 2h
> 2h
> 2h
1322
61
> 2h
> 2h
> 2h
6
20
33
27
9
50
41
70
> 2.1GB
480
25
> 2h
> 2h
> 2h
24
47
2219
67

CFF
time
len
> 2h
> 2h
> 2h
0
19
0
15
0
10
0
39
0
28
0
26
0,1
38
1
78
0
53
0
59
0
65
13,1
140
321
304
> 2h
> 2h
> 2h
> 2h
> 2h
1,6
83
4,7
108
4,3
31
93,6
48
29,4
50
109,9
70
1252,4 100
SNH
SNH
SNH
SNH
4,4
46
16,5
58

Table 1: KS0 translation fed planner compared POND Conformant
(CFF) along times reported plan lengths. #S0 stands number
initial states, SNH means goal syntax handled (by CFF). Times reported
seconds rounded closest decimal.

633

fiPalacios & Geffner

problems P whose actions preconditions, argument simple:
conformant plan P must classical plan P/s possible initial
state s, achieves (goal) literal Gi P/s s, must achieve
literal KGi /s KS0 (P ) well, followed merge action Gi ,
must achieve literal KGi . presence action preconditions, argument must
applied inductively plan length, idea remains (see proof
appendix details): correspondence established evolution
fluents L problem P/s evolution fluents KL/s problem
KS0 (P ).
significance exhaustive KS0 translation theoretical.
plenty conformant problems quite hard current planners even involve
handful possible initial states. example Square-Center-n task (Cimatti
et al., 2004), agent reach center empty square grid certainty,
knowing initial location. four actions move agent one unit
direction, except border grid, effects. standard
version problem, initial position fully unknown resulting n2 possible initial
states, yet problem remains difficult, actually beyond reach planners,
small values n, even uncertainty reduced pair possible initial states.
reason agent must locate heading goal. domain
Corners-Square-n Table 1 variation Square-Center-n possible initial
states four corners grid.
Table 1 shows results conformant planner based KS0 (P ) translation
uses (Hoffmann & Nebel, 2001) solving resulting classical problem, compares
two planners entered Conformant track 2006 Int. Planning
Competition (Bonet & Givan, 2006): POND (Bryce et al., 2006) Conformant
(Hoffmann & Brafman, 2006) (the two planners competition translationbased: T0 , based formulation developed paper, K(P ), based earlier
restricted formulation due Palacios & Geffner, 2006). Clearly, approach
based KS0 (P ) translation scale problems many possible initial
states, yet number states small, quite well.

6. Complete Translations May Compact
order complete translations polynomial, certain assumptions
formulas initial situation need made. Otherwise, checking whether
goal true intractable itself, therefore polynomial complete translation
would impossible (unless P = NP). thus assume prime implicate (PI)
form (Marquis, 2000), meaning includes inclusion-minimal clauses
entails tautologies. known checking whether clause follows logically
formula PI form reduces checking whether clause subsumed clause
tautology, hence polynomial operation. initial situations
benchmarks P form easily cast PI form normally specified
means set non-overlapping oneof (X1 , . . . , Xn ) expressions translate
clauses X1 Xn binary clauses Xi Xj 6= j resolvent
tautology.
634

fiCompiling Uncertainty Away Conformant Planning Problems

6.1 Conformant Relevance
translation KS0 (P ) complete introduces number literals KL/t exponential worst case: one possible initial state s0 . raises question:
possible complete translations exhaustive sense? answer
yes section provide simple condition ensures translation
KT,M (P ) complete. makes use notion relevance:3
Definition 10 (Relevance). conformant relevance relation L L0 P , read L
relevant L0 , defined inductively
1. L L
2. L L0 : C L0 P L C action P
3. L L0 L L00 L00 L0
4. L L0 L L00 L00 L0 .
first clause stands reflexivity, third transitivity, second captures conditions relevant effect, fourth, conditions L preempts
conditional effects may delete L0 . replace 4
4 L L0 L L0
equivalent 4 context 13, resulting definition one Son
Tu (2006), notion relevance used generate limited set possible partial
initial states 0-approximation complete (see Section 11 discussion
relation tags partial initial states).
Notice according definition, precondition p action taken
relevant effect q. reason want relation L L0 capture
conditions uncertainty L relevant uncertainty L0 .
say relation conformant relevance. Preconditions must known
true order action applied, introduce propagate uncertainty
effects action.
let CI stand set clauses representing uncertainty initial situation, namely, non-unit clauses along tautologies L L complementary
literals L L appearing unit clauses I, notion (conformant) relevance
extended clauses follows:
Definition 11 (Relevant Clauses). clause c CI relevant literal L P
literals L0 c relevant L. set clauses CI relevant L denoted CI (L).
representation uncertainty initial situation relevant
literal L, possible analyze completeness translation KT,M terms
relation merges literals L, one hand, sets clauses CI (L)
relevant L other.
3. follow earlier account (Palacios & Geffner, 2007), many definitions theorems
differ number details (for example, notion relevance depends rules P
clauses initial situation). changes aimed making resulting formulation simpler
cleaner.

635

fiPalacios & Geffner

6.2 Covering Translations
may appear translation KT,M would complete
W merges precondition goal literals L, understood DNF formulas tm t, contain much
information, thus equivalent CNF formula CI (L) captures fragment
initial situation relevant L. intuition partially correct, misses
one important point; namely every DNF formula equivalent CI (L) do:
DNF representation captured merges must vivid enough. example, CI (L)
single clause x x, completeness requires tag x, tag x, merge
= {x, x} L containing two tags, even clause x x tautology
thus equivalent DNF formula true.
defining types tags merges required completeness then,
let us first define closure set literals S, relative conformant problem
P = hF, I, O, Gi, set literals follow I:
= {L | I, |= L} .
Let us say consistent contain pair complementary literals.
type merges required precondition goal literals L
imply CI (L) satisfy well. notion satisfaction associates
consistent set literals partial truth assignment implicit closure
S, extended account conditions DNF formula (e.g.,
merge L) satisfies CNF formula (e.g., CI (L)).
Definition 12 (Satisfaction).
1. consistent set literals satisfies clause L1 L2

Lm contains one literals Li , = 1, . . . , m.
2. consistent set literals satisfies collection clauses C satisfies clause
C.
3. collection consistent sets literals satisfies collection clauses C set
satisfies C.
type merges required completeness simply valid merges
satisfy set clauses CI (L). call covering merges:
Definition 13 (Covering Merges). valid merge translation KT,M (P ) covers
literal L satisfies CI (L).
example, CI (L) given clauses result oneof (x1 , . . . , xn ) expression, i.e. x1 x2 xn xi xj j, 1 i, j n, 6= j,
merge = {x1 , . . . , xn } covers literal L, xi includes xi xj
j 6= i, thus xi satisfies CI (L).
W
merge = {t1 , . . . , tn }, denote DNF formula ti ti ,
tag ti replaced closure ti , simple prove covers literal L,
entails CI (L). merge covers L thus DNF formula strong enough
imply CNF formula CI (L) (through closure), weak enough entailed I,
vivid enough satisfy CI (L).
636

fiCompiling Uncertainty Away Conformant Planning Problems

illustration, CI (L) given tautologies p p q q,
= CI (L), merge m1 = {p, p} implies CI (L) satisfy CI (L). Likewise,
merge m2 = {{p, q}, {p, q}} satisfies CI (L) entailed I. Finally, merge
m3 = {{p, q}, {p, q}, {p, q}, {p, q}} satisfies CI (L) entailed I, thus
valid merge covers L.
valid translation KT,M (P ) contains merge covers L precondition
goal literal L P , say translation covers P covering
translation:
Definition 14 (Covering Translation). covering translation valid translation
KT,M (P ) includes one merge covers L, precondition goal literal L
P .
central result paper covering translations complete:
Theorem 15 (Completeness). Covering translations KT,M (P ) complete; i.e.,
conformant plan P , classical plan 0 KT,M (P ) 0
merge actions removed.
words, complete translations KT,M (P ) result tags merges
capture information initial situation relevant precondition
goal literal suitable manner.
Theorem 15 used two ways: proving completeness translation,
checking covering condition holds, constructing complete translations,
enforcing covering condition. addition, interest paper conformant planning optimality guarantees, theorem useful optimal conformant
planning well, whether cost plans defined length (action costs equal
1) sum non-uniform action costs. cases, theorem ensures
problem optimal conformant planning gets mapped problem optimal classical
planning provided cost merge actions KT,M (P ) made sufficiently small.
illustration Theorem 15, consider conformant problem P initial situation = {x1 xm }, goal G = L, actions ai , = 1, . . . , m, effect xi L.
number possible initial states problem exponential m, disjunction
among xi exclusive. So, translation KS0 (P ) complete exponential
size. hand, consider translation KT,M (P ) = {x1 , . . . , xm }
contains single valid merge = {x1 , . . . , xm } L. simple verify
merge covers goal L (satisfies CI (L) = I), hence translation KT,M (P )
covering, Theorem 15, complete, polynomial m.
Notice testing whether valid translation KT,M (P ) covering translation
done polynomial time, particular, computing set literals every tag
tractable operation provided PI form; indeed, I, |= L0 iff |= L0
iff L0 tautology subsumed clause I.
6.3 Translation Kmodels
straightforward show exponential translation KS0 considered Section 3,
(non-empty) tags stand possible initial states, covering hence complete
637

fiPalacios & Geffner

according Theorem 15. possible, however, take advantage Theorem 15
devising complete translation usually compact. call Kmodels.
Definition 16. translation Kmodels(P ) obtained general scheme KT,M (P )
defining
contain one merge precondition goal literal L given models
CI (L) consistent I,4
contain tags merges along empty tag.
translation Kmodels equivalent KS0 precondition goal
literals L, CI (L) = I; i.e., clauses relevant L. Yet, cases,
first translation exponential number variables appearing one CI (L)
set (the one largest number variables), second exponential
number unknown variables I. example, n precondition goal
literals Li , = 1, . . . , n P one, CI (Li ) unique oneof (xi1 , . . . , xim )
expression, merge literal Li KS0 (P ) contain mn models n one-of
expressions I, merge Li Kmodels(P ) contain models
single oneof (xi1 , . . . , xim ) expression CI (Li ). translation Kmodels thus
exponentially compact exhaustive KS0 translation remaining sound
complete:
Theorem 17. translation Kmodels(P ) sound complete.
worst case, however, Kmodels exponential translation. thus consider
next polynomial translations conditions complete.
6.4 Conformant Width
address conditions compact, covering translation constructed polynomial time. this, define structural parameter call
conformant width problem P , analogy notion width used graphical
models (Dechter, 2003), provide upper bound time space complexity
required generating covering translation. precisely, complexity construction exponential conformant width problem P cannot exceed
number fluents P much lower.
principle, would define width w(P ) maximum tag size required
translation KT,M (P ) covering translation. definition, however, would
give us complexity bounds want, checking validity merge
tags bounded size intractable operation, whether initial situation
prime implicate form not.5 need define width different way. First, let
cover set clauses defined follows:
4. models CI (L) understood conjuntions literals.
5. problem checking whether entails DNF formula whose terms may 2 literals
coNP-hard even equivalent true. Indeed, 3-CNF formula; contradictory iff
negation (which 3-DNF) valid, turn true iff implied I. Actually,
general prime implicate form, problem remains coNP-hard even terms DNF formula
contain 2 literals. thank Pierre Marquis pointing results us.

638

fiCompiling Uncertainty Away Conformant Planning Problems

Definition 18 (Cover). cover c(C) set clauses C, relative conformant
problem P initial situation I, collection minimal sets literals consistent
contains literal clause C.
Two important properties cover c(C) set clauses C c(C) stands
DNF formula logically equivalent CNF formula C given I, c(C)
computed polynomial time size C bounded constant. Moreover, c(C)
implies C satisfies C well. Thus particular, C collection clauses
CI (L) relevant literal L, cover c(CI (L)) CI (L) valid merge
covers L. completeness covering translations, follows complete
translation KT,M (P ) constructed polynomial time size |CI (L)| sets
clauses CI (L) precondition goal literals L P bounded. Unfortunately,
condition rarely seems hold, yet weaker sufficient condition does: namely,
often possible find subset C clauses either CI (L) tautologies
c(C) satisfies CI (L) thus covers literal L. thus define width
literal L size smallest set (cardinality-wise). this, denote
CI (L) set clauses CI (L) extended tautologies form p p fluents p
either p p appears CI (L) (if appear CI (L) p p CI (L)
definition).
Definition 19 (Width Literal). conformant width literal L P , written w(L),
size smallest (cardinality-wise) set clauses C CI (L) c(C) satisfies
CI (L).
consequence definition width literal must lie interval
0 w(L) n, n number fluents P whose status initial situation
known. Indeed, CI (L) empty, w(L) = 0, set clauses CI (L),
cover c(C) set C tautologies CI (L) must satisfy CI (L), thus w(L) |C| n.
Similarly, CI (L) contains single clause x1 xm clauses x1 xm
xi xj correspond oneof (x1 , . . . , xm ) expression, simple prove
w(L) = 1 singleton C = {x1 xm } generating cover c(C) = {{x1 }, . . . , {xn }}
satisfies CI (L). Finally, CI (L) contains two tautologies pp qq, w(L) = 2
smallest C CI (L) whose cover satisfies CI (L) CI (L) itself.
width problem width precondition goal literal maximum
width:
Definition 20 (Width Problem). conformant width problem P , written
w(P ), w(P ) = maxL w(L), L ranges precondition goal literals P .
show problems bounded width, complete translations
constructed polynomial time, moreover, almost existing conformant benchmarks bounded width, precisely, width equal 1. case,
resulting translations use tags never greater size w(P ),
problems width 1, tags single literals.
(tree)width graphical models, computing width problem P
exponential w(P ), recognition problems small width carried
quite efficiently:
639

fiPalacios & Geffner

Proposition 21 (Determining Width). width w(P ) P determined time
exponential w(P ).
particular, test w(P ) = 1 considering one one sets C
includes single clause CI (L), verifying whether c(C) satisfies CI (L) not.
w(P ) 6 1, verification must carried setting C set
clauses CI (L) increasing values i. fixed value i, polynomial
number clause sets C verification one done polynomial
time. Moreover, arguments regarding w(L), w(P ) never exceed
number unknown fluents problem:
Proposition 22 (Bounds Width). width P 0 w(P ) n, n
number fluents whose value initial situation known.
6.5 Polynomial Translation Ki
translation Ki , parameter non-negative integer, instance
general KT,M scheme designed sound, polynomial fixed i, complete
problems width w(P ) i. Thus, example, translation K1 sound, polynomial,
complete problems width 1.
Definition 23 (Translation Ki ). translation Ki (P ) obtained general
scheme KT,M (P )
set contain one merge = c(C) precondition goal literal L P
set C clauses CI (L) covers L. set
exists, one merge = c(C) L created set C clauses CI (L),
merges created L CI (L) empty;
collection tags appearing merges empty tag.
translation Ki (P ) applies problems P width, remaining cases exponential polynomial number fluents, actions, clauses P . addition,
translation Ki (P ) sound, problems width bounded i, complete.
Theorem 24 (Properties Ki ). fixed i, translation Ki (P ) sound, polynomial,
w(P ) i, covering complete.
Soundness result merges valid construction, covers c(C)
C CI (L) entailed C hence I. complexity polynomial fixed
i, polynomial number clause sets C size CI (L), constructing
cover c(C) one them, polynomial operation. Finally, completeness follows
definition width: w(P ) i, set clauses C CI (L)
size |C| greater whose cover satisfies CI (L), thus Ki (P ) must contain
merge = c(C) L covers L.
Notice = 0, translation Ki (P ) reduces basic K0 (P ) translation
introduced Section 3 tags (other empty tag) merges. Before,
assessed completeness translation terms 0-approximation semantics.
Theorem 24 provides alternative interpretation: translation K0 (P ) complete
640

fiCompiling Uncertainty Away Conformant Planning Problems

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

Domain-Parameter
Safe-n combinations
UTS-n locs
Ring-n rooms
Bomb-in-the-toilet-n bombs
Comm-n signals
Square-Center-n n grid
Cube-Center-n n n cube
Grid-n shapes n keys
Logistics n pack locs
Coins-n coins locs
Block-Tower-n Blocks
Sortnet-n bits
Adder n pairs bits
Look-and-Grab objs n n locs
1-dispose objs n n locs

# Unknown Fluents
n
n
4n
n
n
2n
3n
nm
nm
nm
n (n 1) + 3n + 1
n
2n
nnm
nnm

Width
1
1
1
1
1
1
1
1
1
1
n (n 1) + 3n + 1
n
2n



Table 2: Width parameterized domains
problems P zero width. problems set clauses CI (L)
relevant precondition goal literal L empty. makes precise intuition
mentioned K0 (P ) translation complete problems uncertain
information relevant. cases, none clauses initial situation
make sets relevant clauses CI (L) preconditions goal literals L.
illustration Theorem 24, consider conformant problem P initial
situation = {x1 xm }, goal G = {L}, actions ai , = 1, . . . , m,
effect xi L. problem, singleton set clauses C = CI (L) =
c(C) = {{x1 }, . . . , {xm }} covers CI (L). Then, since precondition goal
literal, K1 (P ) includes single merge = c(C) L singleton tags ti = {xi },
write simply = {x1 , . . . , xm }. translation K1 (P ) polynomial m,
since w(P ) = 1, Theorem 24 complete. Notice example,
translations KS0 (P ) Kmodels(P ) identical exponential (the number
models CI (L)).
6.6 Width Conformant Benchmarks
practical value notion width becomes apparent width existing
benchmarks considered. Table 2 summarizes width many existing benchmark
domains conformant planning. domains depend certain parameters n
capture size instances (e.g., size grid, number objects, etc).6 domain
bounded width width grow size instances,
width equal instances width regardless parameter values.
seen table, width existing benchmarks 1.
cases, means sets CI (L) clauses relevant precondition
6. names parameterized domains table coincide names instances
currently used. E.g. Comm-n IPC5 refers Communication instance necessarily
instance n signals.

641

fiPalacios & Geffner

goal literal L contain single clause (often tautology p p disjunction x1 . . . xm )
single oneof (x1 , . . . , xm ) expression (that translates disjunction x1 xm
clauses xi xk ). shown above, w(L), therefore, w(P ), equal 1 theses
cases.
extreme domains Blocks, Sortnet, Adder,
maximal widths; i.e., widths equivalent number fluents whose status initial situation known. fluents interact
action conditions (not preconditions). numbers Blocks Table 2, thus follow
number fluents involved; namely, fluents on(x, y), clear(x), ontable(x),
holding(x).
Finally, domains 1-dispose Look-and-Grab (Palacios & Geffner, 2006, 2007)
objects unknown locations grid n n must collected robot
whose gripper hold one object time, width equal m, meaning
width domains grows number objects size grid.
case, clauses possible locations objects
relevant condition hand empty pick actions.
Let us point completeness translation Ki (P ) problems P
width w(P ) bounded i, establishes correspondence conformant plans
P classical plans KT,M (P ). solving P , however, correspondence
needed; suffices Ki (P ) solvable; plan Ki (P ) encode
conformant plan P , even Ki (P ) capture conformant plans P .
perspective, makes sense refer smallest value parameter
classical problem Ki (P ) solvable, effective width P , denoted (P ). turns
(P ) cannot larger w(P ), may much smaller. interesting
example comes Sortnet-n domain (Bonet & Geffner, 2000). Sortnet-n
considered challenging domain conformant planning planners able
scale even small values n (the number entries sorted sorting network).
domain width n, compact encoding used IPC5, input vector
represented set bits, exploiting fact sorting vectors numbers reduces
sorting vector bits (0s 1s). domain cannot solved K1 translation
reports correctly unsolvable brief unsuccessful search. hand,
possible reformulate domain, replacing unary high(i) low(i) predicates
binary predicates less(i, j) compare two vector entries. call reformulation
Sort-2-n. encoding Sort-n linear n, encoding Sort-2-n quadratic n,
cases, problem width maximum, given number fluents whose
status initial situation unknown. Yet, compact Sort-n encoding
solvable K1 translation, K1 suffices solve problem expanded Sort2-n encoding actually solved K0 . Thus effective width Sort-2-n
0. Interestingly, provided K0 translation Sort-2-n, instances solved
20 entries. hand, conformant planners Conformant-FF POND
solve Sort-2-n instances n greater 3.
642

fiCompiling Uncertainty Away Conformant Planning Problems

7. Tags Initial States
deeper understanding results obtained relating tags possible
initial states. looking closely relation context covering translations,
able answer question polynomial number contexts (tags)
play role exponential number possible initial states problems bounded
width.
this, let us first recall notation introduced Section 2.2, state s,
wrote I(s) refer set atoms encoding (i.e, p I(s) iff p true s) P/s
refer classical planning problem P/s = hF, I(s), O, Gi conformant
problem P = hF, I, O, Gi initial state fixed s.
Let us extend notation say action sequence conforms set
states given conformant problem P iff plan classical problem P/s
S. Clearly, conformant plan P nothing else action sequence
conforms set S0 possible initial states P , yet notion conforms allows
us abstract away initial situation make precise notion basis:
Definition 25 (Basis P ). set states 0 basis conformant problem P =
hF, I, O, Gi 0 subset set S0 possible initial states P every plan
conforms 0 conforms set possible initial states S0 .
words, 0 basis P , necessary consider states S0
computing conformant plans P ; suffices consider states 0 . aim
show width P bounded, P polynomial basis 0 even S0
exponential size. Moreover, states basis close correspondence
tags appearing covering translation.
illustration, consider problem P actions ai , = 1, . . . , n, effects
ai : xi L. Let G = {L} goal = {x1 xn } initial situation.
set S0 possible initial states truth valuations xi atoms least
one atoms true. 2n 1 states. hand, one show
set S00 n valuations exactly one atoms true provides basis
P ; i.e., plans conform n possible initial states, exactly plans
conform complete set 2n 1 possible initial states S0 .
reduction number possible initial states must considered computing conformant plans results two monotonicity properties formulate using
notation rel(s, L) refer set literals L0 true state
relevant literal L:
rel(s, L) = {L0 | L0 L0 relevant L} .
Proposition 26 (Monotonicity 1). Let s0 two states let action sequence
applicable classical problems P/s P/s0 . achieves literal L P/s0
rel(s0 , L) rel(s, L), achieves literal L P/s.
Proposition 27 (Monotonicity 2). 0 two collections states
every state every precondition goal literal L P , state s0 0
rel(s0 , L) rel(s, L), plan P conforms 0 , plan
P conforms S.
643

fiPalacios & Geffner

properties, follows
Proposition 28. 0 basis P every possible initial state P every
precondition goal literal L P , 0 contains state s0 rel(s0 , L) rel(s, L).
proposition allows us verify claim made example set S00 ,
contains number states linear n, basis P exponential
number possible initial states. Indeed, problem precondition single
goal literal L, every state makes one atom xi true (these
literals relevant L), state s0 S00 makes one atoms true,
hence relation rel(s0 , L) rel(s, L) holds.
question address build basis complies condition
Proposition 28 given covering translation KT,M (P ). this, let = {t1 , . . . , tn }
merge covers precondition goal literal L, let S[ti , L] denote set
possible initial states P rel(s, L) ti ; i.e., S[ti , L] contains possible initial
states P make literals L0 relevant L false, except
closure ti ti . show first prime implicate form, S[ti , L] non-empty
set:7
Proposition 29. initial situation prime implicate form = {t1 , . . . , tn }
valid merge covers literal L P , set S[ti , L] possible initial states
P rel(s, L) ti non-empty.
Let s[ti , L] stand arbitrary state S[ti , L]. obtain following result:
Theorem 30. Let KT,M (P ) covering translation problem P initial
situation PI form, let 0 stand collection states s[ti , L] L
precondition goal literal P ti tag merge covers L. 0 basis
P .
important result three reasons. First, tells us build basis P
given tags ti covering translation KT,M (P ). Second, tells us size
resulting basis linear number precondition goal literals L tags ti .
third, makes role tags ti covering translation KT,M (P ) explicit, providing
intuition works: tag ti merge covers literal L represents one
possible initial state; namely, state s[ti , L] makes false literals L0
relevant L except ti . plan conforms critical states,
conform possible initial states monotonicity (Proposition 27). follows
particular that:
Theorem 31. P conformant planning problem bounded width, P admits
basis polynomial size.
Namely, conformant problems P width bounded non-negative integer admit
polynomial translations complete, plans conform possibly
exponential number initial states P correspond plans conform
7. Recall assuming throughout initial situation logically consistent
tags consistent I.

644

fiCompiling Uncertainty Away Conformant Planning Problems

subset critical initial states polynomial number (namely,
polynomial basis). Thus, one complete polynomial translation problems
Ki translation; another one, KS0 translation tags associated
critical initial states rather initial states.
illustration, problem P actions ai effects ai : xi L,
goal G = {L}, initial situation = {x1 xn }, K1 (P ) translation tags xi ,
= 1, . . . , n, merge = {x1 , . . . , xn } goal literal L, covering translation.
Theorem 30 states basis 0 P results collection states si
make tag xi true, literals relevant L xi false (i.e.,
xk atoms k 6= i). precisely basis P includes
states make single atom xi true = 1, . . . , n: plans conform
basis exactly plans conform whole collection possible initial
states P . basis size polynomial though, number
possible initial states P exponential m.

8. Planner T0
current version conformant planner T0 based two instances general
translation scheme KT,M (P ) whose outputs fed classical planner v2.3.8 One
instance polynomial necessarily complete; complete necessarily
polynomial. incomplete translation, T0 uses K1 complete problems
width greater 1, argued above, result solvable instances problems
larger widths. complete translation, Kmodels translation used instead
simple optimization: K1 translation produces single merge covers L,
merge used L instead potentially complex one determined
Kmodels. mere optimization resulting translation remains complete.
merges Kmodels, result models set clauses CI (L)
consistent I, computed using SAT solver relsat v2.20 (Bayardo Jr. & Schrag,
1997). current default mode T0 , one used experiments below,
two translations K1 Kmodels used sequence: called first upon
output K1 fails, called upon output Kmodels. experiments
below, indicate cases Kmodels invoked.
translations used T0 accommodate certain simplifications two additional
actions capture types deductions. simplifications fact
translations considered uniform sense literals L P
rules C L conditioned tags . practical point
view, however, needed. simplifications address source inefficiency.
particular:
literals KL/t created closure contains literal relevant L.
case, invariance KL/t KL holds, thus, every occurrence
literal KL/t KT,M (P ) replaced KL.
8. conformant planner T0 along benchmarks considered paper available
http://www.ldc.usb.ve/hlp/software.

645

fiPalacios & Geffner

support rules : KC/t KL/t non-empty tags created L
relevant literal L0 merge contains t, case, literal
KL/t cannot contribute establish precondition goal. Similarly, cancellation
rules : KC/t KL/t non-empty tags created L
relevant literal L0 merge contains t.
support cancellation rules : KC/t KL/t : KC/t KL/t
grouped : KC/t KL/t KL/t every fluent L0 relevant L, either
L0 L0 entailed t. case, incomplete information
L given initial situation, thus invariant KL/t KL/t holds,
KC/t equivalent KC/t.
Two types sound deductive rules included translations:
rule : KC KL added : C, L L rule P action a,
rule P form : C 0 L,
rules KL1 , . . . , KLi1 , KLi+1 , . . . , KLn KLi = 1, . . . , n added
new unique action precondition, L1 Ln static clause P (a
clause P static true initial situation provably true action).
rules versions action compilation static disjunctions rules (Palacios &
Geffner, 2006, 2007), appear help certain domains without hurting others.
version T0 reported assume initial situation P
prime implicate form rather renders PI form running version Tisons
algorithm (1967), computation none benchmarks solved took 48
seconds.
translators T0 written OCaml code parsing PDDL files
written C++.

9. Experimental Results
considered instances three sources: Conformant-FF distribution, conformant track 2006 International Planning Competition (IPC5), relevant publications (Palacios & Geffner, 2006, 2007; Cimatti et al., 2004). instances run
cluster Linux boxes 2.33 GHz 8GB. experiment cutoff 2h 2.1GB
memory. Times T0 include steps, particular, computation prime implicates, translation, search (done FF). include results Conformant
Track recent 2008 International Planning Competition (IPC6).
Goals sets literals sets clauses transformed T0 standard
way: goal clause C : L1 Lm modeled new goal atom GC , new
action executed added rules Li GC , = 1, . . . , m.9
9. alternative way represent CNF goals converting DNF first
action End map non-mutex terms dummy goal LG . alternative encoding pays
cases, Adder-01 instance get solved default CNF goal
encoding (see below).

646

fiCompiling Uncertainty Away Conformant Planning Problems

Problem
bomb-100-100
square-center-96
sortnet-09
blocks-03
dispose-16-1
look-and-grab-8-1-1
sgripper-30

P
#Acts #Atoms #Effects
10100
404
40200
4
196
760
46
68
109
32
30
152
1217
1479
2434
352
358
2220
487
239
1456

Time
2
35,1
8,3
4
163,6
6,9
21,5

K1 (P )
PDDL
#Acts #Atoms #Effects Size
10201
1595
50500
2,9
7
37248
75054
3,8
56
29707
154913
5,1
37
11370
35232
0,7
1218 133122
3458
0,3
353
8708
118497
7,8
860
1127
12769
1

Table 3: Translation data selected instances: #Acts, #Atoms, #Effects stand
number actions, fluents, conditional effects. Time translation
time seconds rounded closest decimal, PDDL Size size
PDDL file Megabytes.

Table 3 shows data concerning translation group selected instances.
seen, number conditional effects grows considerably cases, sometimes
translation may take several seconds.
Tables 4, 5, 6, 7, 8, show plan times lengths obtained number
benchmarks T0 , POND 2.2 (Bryce et al., 2006), Conformant (Hoffmann & Brafman,
2006), MBP (Cimatti et al., 2004) KACMBP (Bertoli & Cimatti, 2002). last
two planners accept problems standard syntax (based PDDL),
limited number experiments performed them. general picture T0
scales well domains, exceptions Square-Center Cube-Center
Table 5, KACMBP scales better, Sortnet Table 6, KACMBP MBP
scale better; Adder Table 6, POND planner able solve one
instance.
problems Table 4 encodings Conformant-FF repository: Bomb-x-y
refers Bomb-in-the-toilet problem x packages, toilets, clogging; Logistics-ij-k variation classical version uncertainty initial location packages;
Ring-n closing locking windows ring n rooms without knowing
current room; Safe-n opening safe n possible combinations.
problems width 1. T0 clearly best last two domains, first two
domains, Conformant-FF well too.
Table 5 reports experiments four grid domains: Cube-Center-n refers problem
reaching center cube size n3 completely unknown location; SquareCenter-n similar involves square n2 possible locations; Corners-Cube-n
Corners-Square-n variations problems set possible initial locations
restricted Cube Square corners respectively. MBP KACMBP appear
effective domains, although KACMBP doesnt scale well corner versions.
T0 solves problems, corner versions, quality plans poor.
problems width 1.
Table 6 reports experiments problems 2006 International Planning Competition (Bonet & Givan, 2006). domains Coins, Comm UTS width 1.
others max width given number unknown fluents initial situation.
647

fiPalacios & Geffner

Problem
bomb-20-1
bomb-20-5
bomb-20-10
bomb-20-20
bomb-100-1
bomb-100-5
bomb-100-10
bomb-100-60
bomb-100-100
logistics-4-3-3
logistics-2-10-10
logistics-3-10-10
logistics-4-10-10
ring-4
ring-5
ring-6
ring-7
ring-8
ring-30
safe-10
safe-30
safe-50
safe-70
safe-100

T0
time
0,1
0,1
0,1
0,1
0,5
0,7
1,1
4,25
9,4
0,1
1
1,5
2,5
0,1
0,1
0,1
0,1
0,1
13,4
0,1
0,1
0,4
1,12
2,5

len
49
35
30
20
199
195
190
140
100
35
84
108
125
13
17
20
30
39
121
10
30
50
70
100

POND
time len
4139 39
> 2h
> 2h
> 2h





56
40
> 2h
> 2h
> 2h
1
18
6
20
33
27
444
33
> 2h

0
10
2
30
9
50
41
70
> 2.1GB

CFF
time
len
0
39
0
35
0
30
0
20
56,7
199
52,9
195
46,8
190
9,4
140
1
100
0
37
1,6
83
4,7
108
4,4
121
0,4
18
4,3
31
93,6
48
837
71
> 2h

0
10
1,4
30
29,4
50
109,9
70
1252,4 100

MBP
time len
> 2h
> 2h
> 2h
> 2h





> 2h
> 2h
> 2h
> 2h
0
11
0,1
14
0,6
17
3,8
20
40
23
> 2h
0,1
10
> 2h
> 2h
> 2h
> 2h

KACMBP
time len
0
40
0,2
40
0,5
40
2
40
1,9
200
4,3
200
16,4 200
> 2h
> 2h
> 2.1GB
> 2.1GB
> 2.1GB
> 2.1GB
0
26
0,1
58
0,2
99
0,5
204
2
432
> 2.1GB
0
10
0,2
30
0,7
50
2,4
70
8,6
100

Table 4: Experiments well known benchmarks. Times reported seconds rounded
closest decimal. means time memory smaller instances.

648

fiCompiling Uncertainty Away Conformant Planning Problems

Problem
square-center-8
square-center-12
square-center-16
square-center-24
square-center-92
square-center-96
square-center-100
square-center-120
cube-center-5
cube-center-7
cube-center-9
cube-center-11
cube-center-15
cube-center-19
cube-center-63
cube-center-67
cube-center-87
cube-center-91
cube-center-119
corners-square-12
corners-square-16
corners-square-20
corners-square-24
corners-square-28
corners-square-36
corners-square-40
corners-square-72
corners-square-76
corners-square-80
corners-square-120
corners-cube-15
corners-cube-16
corners-cube-19
corners-cube-20
corners-cube-23
corners-cube-24
corners-cube-27
corners-cube-52
corners-cube-55

T0
time
len
0,2
21
0,2
33
0,3
44
0,8
69
45,3
273
50,2
285
> 2.1GB
> 2.1GB
0,1
18
0,1
27
0,2
33
0,3
45
0,5
63
0,8
81
28,5
279
41,6
297
137,5 387
> 2.1GB
> 2.1GB
0,1
64
0,2
102
0,3
148
0,5
202
0,7
264
1,7
412
2,5
498
26,1 1474
30,5 1632
38,2 1798
223,6 3898
0,8
147
0,9
174
2,5
225
2,7
258
6,3
319
6,7
358
14,6
429
448
1506
> 2.1GB

POND
time len
2
41
12
52
1322 61
> 2h
> 2h



1
22
2
43
3
47
29
87
880 109
> 2h
> 2h




11
44
1131 67
> 2h
> 2h







907 105
3168 115
> 2h
> 2h






CFF
time
len
70,6
50
> 2h
> 2h





8,2
45
> 2h
> 2h








1,7
82
13,1
140
73,7
214
321
304
MPL






134,5 284
439,4 214
868,4 456
3975,6 332
MPL





MBP
time
len
0
24
0
36
0
48
0
72
0,9
276
0,9
288
1,1
300
1,9
360
0
28
0
33
0,1
54
0,2
59
0,2
69
1,6
111
28
285
> 2.1GB
> 2.1GB


0
36
0
48
0,3
60
0,6
72
1,1
84
1,5
108
7,8
120
118,8 216
371
228
649,6 240
> 2.1GB
3,7
69
12,5
72
549,5 111
1061,9 90
> 2h
> 2h




KACMBP
time
len
0
28
0
42
0
56
0
84
0,3
322
0,3
336
0,3
350
0,4
420
0
25
0
35
0
45
0
55
0
75
0,1
95
0,5
315
0,7
335
1,2
435
1,2
455
2,1
595
0,2
106
0,6
158
3
268
7,5
346
20,7
502
3308,8 808
> 2h
> 2h



174,1 391
270,5 316
1503,1 488
2759
625
6265,9 899
> 2h
> 2h



Table 5: Experiments grid problems. Times reported seconds rounded
closest decimal. MPL CFF means plan exceeds maximal plan length
(500 actions). means time memory smaller instances.

649

fiPalacios & Geffner

Problem
adder-01
adder-02
blocks-01
blocks-02
blocks-03
coins-10
coins-12
coins-15
coins-16
coins-17
coins-18
coins-19
coins-20
coins-21
comm-07
comm-08
comm-09
comm-10
comm-15
comm-16
comm-20
comm-25
sortnet-06
sortnet-07
sortnet-08
sortnet-09
sortnet-10
sortnet-11
uts-k-04
uts-k-05
uts-k-06
uts-k-07
uts-k-08
uts-k-09
uts-k-10
uts-l-07
uts-l-08
uts-l-09
uts-l-10

T0
time len
> 2h
> 2h
0,1
5
0,3
23
82,6
80
0,1
26
0,1
67
0,1
79
0,3
113
0,2
96
0,2
97
0,2
105
0,2
107
> 2h
0,1
54
0,1
61
0,1
68
0,1
75
0,1
110
0,2
138
0,8
278
2,3
453
0,6
21
2,5
28
9,6
36
76,8
45
> 2.1GB
> 2.1GB
0,1
23
0,1
29
0,2
35
0,4
41
0,6
47
0,9
53
1,3
59
0,2
70
0,3
80
0,6
93
0,7
97

POND
time len
1591
5
> 2h
0,1
4
0,4
26
126,8 129
5
28
> 2h
> 2h






0
47
1
53
1
59
1
65
6
95
> 2h
> 2.1GB

18
20
480
25
> 2h
> 2h


2
22
4
28
10
34
13
40
24
47
> 2h
2219
67
201
58
937
67
> 2h
> 2h

CFF
time len
SNH
SNH
0
6
> 2h
> 2h
0,1
38
0,8
72
3
89
33,3 145
1,4
94
6,2
118
16,5 128
20,6 143
> 2h
0
47
0
53
0
59
0
65
0,2
95
0,4
119
6,4
239
56,1 389
SNH
SNH
SNH
SNH
SNH
SNH
0,1
22
0,3
28
0,8
34
1,9
40
4,4
46
8,6
52
16,5
58
0,2
41
0,4
47
0,8
53
1,6
59

MBP
time
len
NR
NR
NR
NR
NR
> 2h
> 2h







0,2
55
0,2
71
0,2
77
0,3
85
0,9
115
1,6
151
50,9
340
> 2h
0
17
0
20
0
28
0
36
0,1
37
0,1
47
5,4
32
1247,3 38
1704,8 50
> 2h
> 2h


10,5
89
41,1
106
1176
137
> 2h

KACMBP
time
len
NR
NR
NR
NR
NR
4,2
106
3654,7 674
> 2h
> 2h





63,6
53
1966,8 53
> 2h
> 2h




0
21
0
28
0
36
0
45
0,1
55
0,1
66
1,5
30
195,4
42
> 2h
> 2h



> 2h
> 2h



Table 6: Experiments problems IPC5. Times reported seconds rounded
closest decimal. SNH CFF means goal syntax handled,
NR MBP KACMBP planners run due lack
translations PDDL. means time memory smaller instances.

650

fiCompiling Uncertainty Away Conformant Planning Problems

Problem
dispose-4-1
dispose-4-2
dispose-4-3
dispose-8-1
dispose-8-2
dispose-8-3
dispose-12-1
dispose-12-2
dispose-12-3
dispose-16-1
dispose-16-2
look-and-grab-4-1-1
look-and-grab-4-1-2
look-and-grab-4-1-3
look-and-grab-4-2-1
look-and-grab-4-2-2
look-and-grab-4-2-3
look-and-grab-4-3-1
look-and-grab-4-3-2
look-and-grab-4-3-3
look-and-grab-8-1-1
look-and-grab-8-1-2
look-and-grab-8-1-3
look-and-grab-8-2-1
look-and-grab-8-2-2
look-and-grab-8-2-3
look-and-grab-8-3-1
look-and-grab-8-3-2
look-and-grab-8-3-3

T0
time
len
0,1
59
0,1
110
0,3
122
2,7
426
18,4
639
197,1 761
78
1274
2555 1437
> 2.1GB
382
1702
> 2.1GB
0,3
30
0,5
4
0,61
4
35
12
49,41
4
60,02
4
> 2.1GB
213,3
4
> 2.1GB
58,2
242
75,3
90
55,89
58
> 2h
> 2h
> 2h
> 2h
> 2h
> 2h

POND
time len
9
55
36
70
308 102
> 2.1GB
> 2.1GB






3098 16
> 2h
> 2h
> 2.1GB
> 2h
> 2h
> 2.1GB












CFF
time
len
0,1
39
0,2
56
0,6
73
339,1 227
2592,1 338
> 2h

> 2.1GB



> 2h
Mcl
Mcl
> 2h
Mcl
Mcl
> 2h
> 2h
> 2h










MBP
time len
> 2h
> 2h









> 2h
0,02
5
0,01
5
> 2h
0,02
5
0,02
5
> 2h
0,02
5
0,02
5
> 2h
> 2h
> 2h
> 2h
> 2h
> 2h
> 2h
> 2h
> 2h

KACMBP
time len
17,1
81
> 2h
> 2h








0,6
54
0,0
6
0,0
6
0,63
40
0,01
6
0,01
6
0,98
60
0,02
6
0,01
6
> 2h
> 2h
> 2h
> 2h
> 2h
1195 178
> 2h
> 2h
17,9
58

Table 7: Problems Palacios Geffner (2006, 2007): Times reported seconds
rounded closest decimal. means time memory smaller instances.
Mcl mean many edges many clauses respectively.

T0 dominates domains except Adder POND planner able
solve instance, Sortnet, MBP KACMBP well, possibly due
use cardinality heuristic OBDD representations. T0 fails Adder
gets lost search. Looking problem closely, found could solve
(translation the) first instance less minute provided CNF goal
problem encoded DNF explained footnote 9, page 646. domains Adder,
Blocks, Sortnet table, along domain Look-and-Grab next table,
domains considered run K1 translation reports solution
brief search, triggering use complete Kmodels translation.
cases Kmodels used, K1 translation unreachable goal fluent
need try it.
651

fiPalacios & Geffner

Problem
push-to-4-1
push-to-4-2
push-to-4-3
push-to-8-1
push-to-8-2
push-to-8-3
push-to-12-1
push-to-12-2
push-to-12-3
1-dispose-8-1
1-dispose-8-2
1-dispose-8-3

T0
time
len
0,2
78
0,3
85
0,6
87
81,8
464
457,9
423
1293,1 597
> 2h
> 2h
> 2.1GB
82,2
1316
> 2.1GB
> 2.1GB

POND
time len
5
50
171
58

> 2h
> 2h
> 2h



> 2.1GB
> 2.1GB


CFF
time len
0,3
46
0,7
47
1,6
48
> 2.1GB
> 2.1GB
> 2.1GB



> 2h
> 2h


Table 8: problems Palacios Geffner (2006, 2007). MBP KACMBP
tried problems use different syntax. Times reported
seconds rounded closest decimal. means time memory
smaller instances.

problems reported Table 7 Table 8 variations family grid problems
(Palacios & Geffner, 2006, 2007). Dispose retrieving objects whose initial location
unknown placing trash given, known location; Push-to variation
objects picked two designated positions grid
objects pushed to: pushing object cell contiguous cell moves
object cell. 1-Dispose variation Dispose robot hand
empty condition pick actions work. result, plan 1-Dispose
scan grid, performing pick ups every cell, followed excursions trash can,
on. plans get long (a plan reported 1316 actions). Look-and-Grab
action picks objects sufficiently close any, pickup must dump objects collected trash continuing. problem
P-n-m table, n grid size number objects. Look-n-Grab,
third parameter radius action: 1 means hand picks
objects 8 surrounding cells, 2 hand picks objects 15
surrounding cells, on. domains Tables 7 8 width 1 except 1-Dispose
Look-n-Grab. because, hand empty fluent relevant
goal, clauses location objects relevant hand empty.
domains T0 appears better planners. Kmodels translation
triggered instances Look-and-Grab-n-m-r > 1 (the width
instances, mentioned Section 6.6, m, independent grid size).
report additional data Table 9, comparing search results
use planner classical translations T0 , search carried
Conformant-FF original conformant problems. Conformant-FF conformant
planner built top searches explicitly belief space. table illustrates
two problems faced belief-space planners mentioned introduction handle
652

fiCompiling Uncertainty Away Conformant Planning Problems

Problem
bomb-100-1
bomb-100-100
Safe-100
logistics-4-10-10
square-center-8
square-center-12
cube-center-5
cube-center-7
blocks-01
blocks-02
coins-20
comm-25
uts-k-10
dispose-8-1
dispose-8-2
dispose-8-3
look-and-grab-4-1-1

Nodes
5149
100
100
356
4634
39000
2211
81600
46
1420
1235
517
58
1107
1797
2494
4955

CFF
Time
32,9
0,8
1747,4
4,42
59,3
>5602,5
8,2
>5602,5
0,0
>5602,5
20,6
56,1
16,5
339,1
2592,1
>5602,5
>5602,5

Nodes/sec
156,5
125
0,1
80,5
78,1
7
269,6
14,6
4600
0,3
60
9,2
3,5
3,3
0,7
0,4
0,9

Nodes
5250
201
102
774
46
72
74
105
47
86
783
1777
62
11713
87030
580896
79

T0
Time Nodes/sec
0,41
12804,9
7,53
26,7
0
25500
0,47
1646,8
0,05
920
0,03
2400
0,01
7400
0,0
5250
0
11750
0,0
4300
0,04
19575
0,43
4132,6
0,34
182,4
0,78
15016,7
14,32
6077,5
190,2
3054,1
0,1
790

Table 9: CFF Conformant Problems vs. Translations: Nodes stand number
nodes evaluated, Time expressed seconds, Nodes/sec stands average
number nodes per second. Numbers shown bold either CFF
evaluate significantly less nodes (an order-of-magnitude reduction more). Times
preceded > time outs.

653

fiPalacios & Geffner

results translation-based approach. belief representation
update problem appears overhead maintaining evaluating beliefs,
shows number nodes evaluated per second: CFF evaluates
hundred nodes per second; evaluates several thousands. time, heuristic
used CFF conformant setting, appears less informed heuristic used
classical translations. domains Square-Center-n, Cube-Center-n,
Blocks, Look-and-Grab, needs orders-of-magnitude less nodes CFF find
plan, oppositive true Dispose-n-m evaluates many nodes
CFF. Nonetheless, even then, due overhead involved carrying beliefs,
manages solve problems CFF cannot solve. example, instance Dispose-8-3
solved T0 evaluating half million nodes, times CFF
evaluating less three thousand nodes.
Tables 10 11 provide details results Conformant Track 2008
International Planning Competition (IPC6) (Bryce & Buffet, 2008), held almost time
original version paper submitted, planner binaries submitted
organizers months before. version T0 IPC6 different
version T0 used IPC5, winning entry, different
version reported paper. relation, former, T0 IPC6 cleaner
complete reimplementation; relation latter, T0 IPC6 handled problems width
greater 1 different way. explained previous section, current version
T0 , uses K1 basic translation regardless width problem, switching
Kmodels search K1 fails. version T0 IPC6, basic translation
combination K0 K1 ; precisely, merges literals L width w(L) = 1,
generated according K1 , merges literals L width w(L) 6= 1
generated all. result basic translation T0 IPC6 lighter
basic translation current version T0 could fail problems width
higher 1 latter solve. Retrospectively, good choice,
didnt much impact results. however bug program
prevented two width-1 domains, Forest Dispose, recognized such,
thus resulted use Kmodels translation, complete widths,
scale well.
two conformant planners entered IPC6 CpA(H) CpA(C);
belief-space planners represent beliefs DNF formulas, use simple
belief-state heuristics guiding search (Tran, Nguyen, Pontelli, & Son, 2008, 2009).
belief progression planners done quite effectively, progressing term
turn, according 0-approximation semantics. potential blow comes
number terms DNF formula encoding initial belief state. Rather choosing
terms initial belief state possible initial states, planners limit
terms DNF formula collection partial initial states assign
truth value literals deemed irrelevant. resulting belief representation
complete may still result exponential number terms (Son & Tu, 2006). order
reduce number terms initial DNF formula, independent one-of
expressions combined. example, two independent one-of clauses oneof (x1 , x2 )
oneof (y1 , y2 ) would give rise 4 possible initial states DNF terms, combined
single one-of expression oneof (x1 y1 , x2 y2 ), results 2 possible initial
654

fiCompiling Uncertainty Away Conformant Planning Problems

Domain
Blocks
Adder
UTS Cycle
Forest
Raos keys
Dispose

# Instances
4
4
27
9
29
90

CpA(H)
4
1
2
1
2
76

CpA(C)
3
1
2
1
2
59

T0 IPC6
3
1
3
8
1
20

Table 10: Data Conformant Track recent IPC6 Competition: Number
problems solved conformant planners, time 20 mins.
bold, entry planner performed best domain. data
Bryce Buffet (2008)

states terms. one-of expressions independent shown
interact problem. technique appears related notion critical
initial states considered Section 7, shown plans conform
critical initial states must conform possible initial states. heuristics used
CpA(H) CpA(C) combinations cardinality heuristic, measures
number states belief state, total sum heuristic, adds heuristic distances
goal possible state, number satisfied goals, counts
number top goals achieved. heuristics simple, yet work well
benchmarks.
Tables 10 11 show data obtained IPC6 organizers planner logs.
first table appears IPC6 report (Bryce & Buffet, 2008), new domains
Forest Raos keys explained, shows number problems solved
planner, displaying bold planner best domain. planner CpA(H),
declared winner, declared best three domains (Blocks, Raos keys,
Dispose), T0 best two domains (UTS Cycle Forest), CpA(C)
best one (Adder).
Table 11 shows additional details instances; particular, total time
taken solve instance length plans three planners.
terms domain coverage, planners similarly domains, except
Forest, T0 solved instances CPA(H) solved (8/9 vs. 1/9),
Dispose, CPA(H) solved instances T0 solved (76/90 vs. 20/90).
terms time plan quality, CpA(H) CpA(C) appear slightly faster
T0 Blocks, produce much longer plans. Dispose, T0 scales better
CpA(H) CpA(C) size grids, worse number objects.
Indeed, T0 manages solve largest grid single object (Dispose-10-01),
CpA(H) CpA(C) solve instances 2 objects largest grids.
cases, plan lengths produced T0 shorter; e.g., plan Dispose-04-03
contains 125 actions T0 , 314 CpA(H), 320 CpA(C).
Dispose actually domain cardinality heuristic well generation plans, even plans tend rather long. discussed above, domain,
agent scan grid collecting set objects unknown locations, time
655

fiPalacios & Geffner

action picking object cell may contain object made (except
first time), cardinality belief state reduced. Indeed, initially object
may positions p1 , p2 , . . . , pn , pick p1 , object positions
p2 , . . . , pn gripper, pick p2 , object positions p3 , . . . , pn
gripper, on, pick action decreasing cardinality belief state,
becoming singleton belief object must gripper certainty.
problem version T0 used IPC6 Dispose domain,
explores many states search, explained above, used
expensive Kmodels translation instead lighter K1 translation complete
domain width 1. bug fixed, T0 solves 60 rather 20 90
Dispose instances, still failing larger grids many objects, producing
much shorter plans. example, Dispose-06-8 solved plan 470 actions,
CpA(H) CpA(C) solve plans 2881 3693 actions respectively.
bug surfaced Forest domain, prevented solution one instance
only. Forest, Dispose, UTS Cycle conformant widths equal 1,
domains larger widths (see Table 2 widths Blocks Adder).
second domain IPC6 got lost search Adder, indeed, T0
solve instance. instance shown solved T0 competition
report, appears mistake. Similarly, fourth instance blocks, reported
solved CPA(H), may mistake too; indeed, plan instance found
logs, T0 reports goal unreachable Kmodels translation
complete. According T0 , instance four Raos key unsolvable too.
hand, T0 failed larger UTS Cycle Raos key instances translation.
first, resulting PDDLs large cant loaded FF;
second, number init clauses turns quite large (above 300), giving rise
still larger set prime implicates (above 5000) caused translator run
memory. second instance Raos keys, however, rather small T0 didnt solve
due different bug. bug fixed, T0 solves 0.3 seconds, producing plan
53 actions, compares well solutions produced CpA(H) CpA(C)
0.7 1.9 seconds, 85 99 steps, respectively.

10. Non-Deterministic Actions
translation schemes considered limited problems deterministic actions
only. Nonetheless, illustrate below, schemes applied non-deterministic
actions well provided suitable transformations included. cover transformations briefly matter illustration only.
Consider conformant problem P non-deterministic action effects : C oneof (S1 ,
S2 , . . . , Sm ), Si set (conjunction) literals, transformed problem
P 0 , effects mapped deterministic rules form : C, hi Si ,
expression oneof (h1 , . . . , hm ) added initial situation P 0 . P 0 , hidden hi
variables used encoding uncertainty possible outcomes Si action a.
easy show non-deterministic conformant problem P deterministic conformant problem P 0 equivalent provided plans P P 0
considered non-deterministic action P executed once. Namely,
656

fiCompiling Uncertainty Away Conformant Planning Problems

Problem

Instance

Blocks

1
2
3
4
1
1
2
3
1
2
3
4
5
6
7
8
1
2
4,1
4,2
4,3
4,4
6,1
6,2
6,3
6,4
8,1
8,2
8,3
10,1
10,2

Adder
UTS Cycle

Forest

Raos keys
Dispose

CpA(H)
time
len
0
4
0,1
28
5,9
411
143,9 257
8,5
3
0,8
3
25,3
6

CpA(C)
time
len
0
7
0,1
35
6,3
157
8,3
0,6
24,7

3
3
6

3,6

24

11,6

18

0,1
0,7
0,3
0,7
1,3
2
4,7
10,4
17,7
27,6
40,1
86,7
86,7

28
85
80
197
314
431
270
643
1016
1389
753
1851
1851

0
1,9
0,4
0,9
1,8
2,8
4,5
42,2
97,9
172,5
40,3
524,6

29
99
88
206
320
434
187
735
1228
1721
518
1962

T0 IPC6
time len
0,1
5
0,1
23
17,8
83

0,1
0,7
5,4
0,2
1,3
2,2
12,1
14,4
69,7
355,1

3
7
10
16
45
78
129
115
200
256

0

16

0,1
3,6
528,3

77
110
125

0,9
217,7

204
329

7,4

326

45

683

Table 11: Running time plan length IPC6 logs. Time seconds. Blanks stand
time memory out. 13 90 Dispose-n-m instances shown,
IPC6, size n grid ranged 2 10, number objects, 1
10. T0 scales best n worst m.

657

fiPalacios & Geffner

correspondence exists conformant plans P use actions
conformant plans P 0 use actions too.
hand, conformant plan P 0 actions done many times
necessarily represent conformant plan P . Indeed, non-deterministically moves
agent right square grid n n, starting bottom left corner, n actions
row would leave agent either top left corner bottom right corner P 0 ,
anywhere Manhattan distance n origin P. divergence P
P 0 , however, arise non-deterministic actions executed once.
Building idea, non-deterministic conformant planner obtained
deterministic conformant planner following way. non-deterministic problem
P , let P1 problem P 0 above, additional constraint actions
P1 arising non-deterministic actions P executed once.
easily achieved adding precondition enabled(a) true initially
sets false. Let P2 represent deterministic conformant problem
non-deterministic action P mapped 2 deterministic actions, executable
once, hidden fluents h1 , . . . , hm oneof (h1 , . . . , hm )
expression initial situation. Similarly, let Pi deterministic problem results
encoding non-deterministic action P deterministic copies.
encoding, simple iterative conformant planner non-deterministic problems P defined terms conformant planner deterministic problems
invoking latter upon P1 , P2 , P3 , on, solution reported. reported
solution uses copy non-deterministic action once, thus encodes
solution original problem.
implemented strategy top T0 additional refinement
takes advantage nature KT,M translation, assumptions initial
situation maintained explicitly tags. Basically, non-deterministic actions Pi
allowed executed provided literals KL/hi depend
particular outcome actions (Si ) erased. implemented means
additional reset(a) action Pi whose unconditional effect enabled(a) (i.e.,
action done again) whose conditional effects KL KL/hi
KL KL/hi = 1, . . . , m. Namely, literals KL/hi truth L depends
particular non-deterministic outcome (Si ) erased, except L true
assumptions; i.e. KL true. non-deterministic actions executed
plan provided occurrence a, except first one, preceded
reset(a) action.
Table 12 compares resulting non-deterministic planner MBP KACMBP
number non-deterministic problems considered MBP KACMBP papers.
added additional domain, Slippery Gripper (sgripper), similar
classical Gripper number balls moved room B, except
robot cannot move B directly, non-deterministic move action
move(A, C, D) moves robot either C D. typical plan moving
two balls B pick A, move C D, move C B,
B, finally dropping balls B.
deterministic conformant planner (T0 ) used non-deterministic setting
added following modification: merges introduced precondition goal
658

fiCompiling Uncertainty Away Conformant Planning Problems

Problem
sgripper-10
sgripper-20
sgripper-30
btuc-100
btuc-150
btuc-200
btuc-250
btuc-300
bmtuc-10-10
bmtuc-20-10
bmtuc-20-20
bmtuc-50-10
bmtuc-50-50
bmtuc-100-10
bmtuc-100-50
bmtuc-100-100
nondet-ring-5
nondet-ring-10
nondet-ring-15
nondet-ring-20
nondet-ring-50
nondet-ring-1key-5
nondet-ring-1key-10
nondet-ring-1key-15
nondet-ring-1key-20
nondet-ring-1key-25
nondet-ring-1key-30

T0
time len
1,4
48
16,7
93
90
138
2,9
200
9,2
300
23
400
44,6 500
82
600
0,1
20
0,1
40
0,3
40
0,9
100
3,3
100
4,9
200
14,9 200
30,2 200
18,3
19
> 2h
> 2h


> 2h
> 2.1GB





MBP
time
len
> 2h
> 2h

> 2h
> 2h



65,9
29
> 2h
> 2h





0
18
2,1
38
1298,9 58
> 2h

0,1
33
11,2
122
5164,4 87
> 2.1GB



KACMBP
time
len
0,6
68
5,4
148
23,3
228
2
200
7,9
300
16,9
400
33,2
500
62,1
600
0,2
20
0,6
40
2,2
40
3,6
100
2722,4 100
25,1
200
> 2h
> 2h
0,1
32
0,5
112
2,4
242
7,3
422
603,1 2552
0,2
42
4
197
33,7
375
246,5 1104
1417,5 2043
> 2h

Table 12: Non-deterministic problems. problems except sgripper MBP
KACMBP. problems modified render simple translation
PDDL; particular, complex preconditions moved conditions. Times
reported seconds rounded closest decimal. means time memory
smaller instances.

literals literals. reason setting pays remove uncertainty
literals reset mechanism used. Indeed, provided simple change
reset mechanism, none problems move beyond P1 (a single copy
non-deterministic action) even domains non-deterministic actions
required many times plans (e.g., 2 balls room A).
seen table, T0 better MBP collection nondeterministic domains, although well KACMBP, particular, NonDetRing Non-Det-Ring-1Key domains. case, results obtained T0
domains quite meaningful. cases T0 failed solved problem, reason
classical planner (FF) got lost search plans, something may
improve advances classical planning technology.

659

fiPalacios & Geffner

11. Related Work
recent conformant planners CFF, POND, MBP cast conformant planning
heuristic search problem belief space (Bonet & Geffner, 2000). Compact belief
representations informed heuristic functions, however, critical making approach work. effective belief representation, planners use SAT OBDDs
techniques intractable worst case often exhibit good behavior average.
heuristics, hand, use fixed cardinality heuristics count number
states possible given belief state (a tractable operation OBDD representations) heuristics obtained relaxed planning graph suitably extended take
uncertain information account. heuristics appear work well domains
others. perspective, translation-based approach provides handle
two problems: belief states P become plain states translation KT,M (P ),
solved using classical heuristics. established conditions
belief representation compact complete.
sound incomplete approach planning incomplete information advanced
Petrick Bacchus (2002) represent belief states formulas. order make
belief updates efficient though, several approximations introduced, particular,
existing disjunctions carried one belief next, new disjunctions
added. imposes limitation type problems handled.
two limitations approach domains must crafted hand,
control information derived domains search plans blind.
approach understood providing solution two problems too:
one hand, move knowledge-level done automatically, other,
problem lifted knowledge-level solved classical planners able search
control information derived automatically new representation.
third thread work related approach arises so-called 0-approximation
semantics (Baral & Son, 1997). 0-approximation semantics, belief states b represented sets states single 3-valued state fluents true, false,
unknown. Proposition 3 above, correspondence established plans
P conformant according 0-approximation semantics classical plans
translation K0 (P ), turns instance general translation
Ki (P ) complete problems width = 0. semantics translation
K0 thus related 0-approximation semantics, yet K0 translation delivers something more: computational method obtaining conformant plans comply
0-approximation semantics using classical planner.
0-approximation basic K0 translation weak dealing
existing benchmarks. translations Ki extend K0 problems higher width
replacing set fluents KL fluents KL/t tags encode assumptions
initial situation. extensions 0-approximation semantics context
conformant planning taken different form: switching single 3-valued state
representing beliefs sets 3-valued states, 3-valued state progressed efficiently
independently others (Son, Tu, Gelfond, & Morales, 2005). initial set
3-valued states obtained forcing states assign boolean truth-value (true false)
number fluents. Crucial approach work number fluents;
660

fiCompiling Uncertainty Away Conformant Planning Problems

belief representation update exponential it. conditions ensure
completeness extension 0-approximation semantics expressed terms
relevance analysis similar one underlying analysis width (Son & Tu,
2006): fluents must set true false initial 3-valued state
appearing clause CI (L) precondition goal literal L. particular,
initial situation n tautologies pi pi , relevant precondition goal literal
L, number initial 3-valued states required completeness exponential n,
make fluent pi true false. difference approach seen
tautologies pi pi relevant unique precondition goal literal Li .
case, number 3-valued partial states required completeness remains
exponential n, resulting problem width 1 thus solved
K1 translation involves tags single literal. words, tags used
translation scheme encode local contexts required different literals
problem, initial 3-valued states (Son & Tu, 2006) encode possible combinations
form global contexts. global contexts correspond consistent combinations
local contexts, may thus exponential number even problem
bounded width. planners CpA(H) CpA(C), discussed context
Conformant Track recent 2008 Int. Planning Competition (IPC6), build
approach, reduce number partial initial states required using technique
replace many one-of expressions single one (Tran et al., 2008, 2009); simplification
related notion critical initial states discussed Section 7.
Another difference 3-valued approach (Son et al., 2005; Son & Tu, 2006),
translation approach addresses representation beliefs
computation conformant plans: conformant problem P translated problem
KT,M (P ), solved classical planner. approaches defined
top 0-approximation semantics, knowledge-level approach planning
incomplete information Petrick Bacchus (2002), need way guide search
plans simplified belief space. search Petrick Bacchus (2002) blind
(iterative deepening), search Son et al. (2005), Son Tu (2006) guided
combination simple heuristics cardinality subgoal counting.

12. Summary
practical problems purely conformant, ability find conformant plans
needed contingent settings conformant situations special case. paper,
introduced new approach conformant planning conformant problems P
converted classical planning problems KT,M (P ) solved classical
planner. studied conditions general translation sound
complete. translation depends two parameters: set tags, referring local
contexts initial situation, set merges stand valid disjunctions
tags. seen different translations, KS0 Kmodels, obtained
suitable choices tags merges, introduced measure complexity
conformant planning called conformant width, translation scheme Ki polynomial fixed complete problems width bounded i. shown
conformant benchmarks width 1, developed conformant planner T0
661

fiPalacios & Geffner

based translations, shown planner exhibits good performance
comparison existing conformant planners. Recently, explored use
ideas general setting contingent planning (Albore, Palacios, & Geffner,
2009).

Acknowledgments
thank Alex Albore help syntax MBP KACMBP, Pierre Marquis
kindly answering question complexity deductive task. thank
anonymous reviewers useful comments. H. Geffner partially supported grant
TIN2006-15387-C03-03.

Appendix A. Proofs
P stands conformant planning problem P = hF, I, O, Gi KT,M (P ) =
hF 0 , 0 , O0 , G0 translation. Propositions theorems body paper
appear appendix numbers; new lemmas propositions
numbers preceded letters B (for Appendix B). conformant problem
P classical problems P/s KT,M (P ) arise P assumed
consistent. Consistency issues important, addressed detail
second part appendix shown P consistent, KT,M (P ) consistent
(Appendix B). consistent classical problem P 0 , standard progression lemma
applies; namely, literal L achieved applicable action sequence +1 = , a,
action sequence action iff A) achieves C rule : C L P 0 ,
B) achieves L negation L0 literal L0 body C 0 rule P 0
form : C 0 L (see Theorem B.2 below).
Lemma A.1. Let action sequence applicable P K0 (P ).
achieves KL K0 (P ), achieves L P .
Proof. induction length . empty achieves KL K0 (P ),
KL must 0 , hence L must I, achieves L P .
Likewise, +1 = , achieves KL K0 (P ) A) rule : KC KL
K0 (P ), achieves KC K0 (P ); B) achieves KL K0 (P )
rule : KC 0 KL K0 (P ), achieves KL0 K0 (P ) L0 C 0 .
A) true, P must contain rule : C L, inductive hypothesis,
must achieve C P , therefore, +1 = , must achieve L P . B) true,
inductive hypothesis, must achieve L P along L0 literal L0 body
C 0 rule : C 0 L, thus +1 = , must achieve L P too.
Lemma A.2. action sequence applicable K0 (P ), applicable P .
Proof. empty, trivial. Likewise, +1 = , applicable K0 (P ),
applicable K0 (P ), thus inductive hypothesis, applicable P . since,
, applicable K0 (P ), must achieve literals KL K0 (P ) precondition
L a, Lemma A.1, must achieve literals L preconditions
P , thus, sequence +1 = , applicable P .
662

fiCompiling Uncertainty Away Conformant Planning Problems

Proposition 2 classical plan K0 (P ), conformant plan P .
Proof. Direct Lemma A.2 consider problem P 0 similar P new
dummy action aG whose preconditions goals G P . plan K0 (P ),
, aG applicable K0 (P 0 ), Lemma A.2, , aG applicable P 0 , implies
applicable P achieves G, thus, plan P .
Proposition 3 action sequence classical plan K0 (P ) iff conformant
plan P according 0-approximation semantics.
Proof. Let us say action sequence = a0 , . . . , 0-applicable P 0-achieves
literal L P belief sequence b0 , . . . , bn+1 generated according 0-approximation
semantics preconditions actions ai true bi , goals
true bn+1 respectively. definition 0-approximation semantics (and
consistency P ), applicable action sequence thus 0-achieves literal L P iff
empty L I, = 0 , A) : C L effect P 0 0-achieves
literal L0 C, B) 0 0-achieves L effects : C 0 L P , 0 0-achieves L0
L0 C 0 . These, however, conditions achieves literal KL
K0 (P ) sequence 0-achieving literal L P replaced sequence achieving
literal KL K0 (P ). Thus, action sequence applicable K0 (P )
0-applicable P achieves literal KL K0 (P ) iff 0-achieves literal L P ,
applicable K0 (P ) iff 0-applicable P , last part following first
using induction plan length.
Definition A.3. action P , define action sequence
followed merges KT,M (P ) arbitrary order. Similarly, = a0 , . . . , ai
action sequence P , define action sequence = a0 , . . . , KT,M (P ).
Lemma A.4. Let action sequence applicable P applicable
valid translation KT,M (P ). achieves KL/t KT,M (P ), achieves L
P/s possible initial states satisfy t.
Proof. empty , achieves KL/t, definition KT,M (P ) since
|= L, L must s, thus must achieve L P/s.

Likewise, +1 = , empty tag, +1
= , achieves KL/t

KT,M (P ) iff A) achieves KC/t KT,M (P ) rule : KC/t KL/t KT,M (P ),
B) achieves KL/t, rule : KC 0 /t KL/t, achieves KL0 /t
KT,M (P ) L0 C 0 (merge actions delete positive literals KL/t).
A, inductive hypothesis, achieves C P/s possible initial state
satisfies t, hence +1 = , achieves L P/s rule : C L must
P . B, inductive hypothesis, achieves L L0 P/s, L0 body
rule : C 0 L P , thus +1 = , achieves L P/s.
V
empty tag = , third case must considered: merge action t0 KL/t0
= , achieving KL K
KL may cause action sequence +1
T,M (P ).



case, sequence , a, hence , , must achieve KL/t0 (nonempty) t0 KT,M (P ), hence inductive hypothesis two cases
above, sequence , must achieve L P/s possible initial state satisfies
663

fiPalacios & Geffner

t0 . Yet, since merge valid, possible initial states must satisfy one
t0 , thus must achieve L P/s possible initial states s, initial
states satisfy = .
Lemma A.5. applicable valid translation KT,M (P ), applicable P .
= , applicable K
Proof. empty, direct. +1 = , a, +1
T,M (P ),

applicable KT,M (P ), achieving KL precondition L a, hence
inductive hypothesis, applicable P , Lemma A.4, must achieve
L precondition L a, thus +1 = , applicable P .

Theorem 7 translation KT,M (P ) sound provided merges valid
tags consistent.
Proof. Consider problem P 0 similar P new dummy action aG
whose preconditions goals G P . plan KT,M (P ) iff
1 , aG applicable KT,M (P 0 ), Lemma A.5 implies , aG applicable
P 0 , means plan P .
Lemma A.6. Let action sequence applicable P applicable
KS0 (P ). achieves L P/s possible initial state s, achieves KL/s
KS0 (P ).
Proof. empty achieves L P/s, L s, since |= L, KL/s must
0 thus achieves KL/s KS0 (P ).
Likewise, +1 = , achieves L P/s A) rule : C L
achieves C P/s; B) achieves L rule : C 0 L, achieves L0
KS0 (P ) L0 C 0 .
A), inductive hypothesis, achieves KC/s KS0 (P ) and, rule : KC/s
= , achieves KL/s (merges
KL/s, , must achieve KL/s, thus, +1
delete positive literals KL/t).
B), inductive hypothesis, achieves KL/s KL0 /s KS0 (P ) L0
body rule : C 0 L P , therefore , achieves KL/s,
= , .
+1
Lemma A.7. applicable P , applicable KS0 (P ).
Proof. empty, trivial. +1 = , applicable P , must
applicable P must achieve precondition L P/s every possible initial
state s, S0 . inductive hypothesis, must applicable KS0 (P ),
Lemma A.6, V
must achieve literals KL/s S0 , then, last
merge action effect sS0 KL/s KL must achieve KL, ,
therefore, , applicable KS0 (P ).
Theorem 9 conformant plan P , classical plan 0 KS0 (P )
result dropping merge actions 0 .
664

fiCompiling Uncertainty Away Conformant Planning Problems

Proof. Direct Lemma A.7 consider problem P 0 similar P new
action aG whose preconditions goals G P . plan P , sequence , aG
applicable P 0 , Lemma A.7, , aG applicable KS0 (P 0 ), thus
plan KS0 (P ).
Definition A.8. rel(s, L) stands set literals L0 relevant L P :
rel(s, L) = {L0 | L0 L0 relevant L} .
Definition A.9. stands deductive closure I:
= { L | I, |= L} .
Theorem A.10. Let = {t1 , . . . , tn } covering merge literal L valid translation KT,M (P ) problem P whose initial situation prime implicate form.
tag ti must possible initial state P rel(s, L) ti .
Proof. Assume otherwise state satisfying makes true literal Ls relevant
L Ls 6 ti . take c disjunction literals Ls
states satisfy I, obtain entails c, since prime implicate form,
means c contains tautology c0 subsumed clause c00 I. But, either case,
contradiction, literals c0 c00 relevant L, hence ti , ti
part covering merge m, must contain literal either c0 c00 , hence c.
Lemma A.11. Let action sequence applicable P applicable covering translation KT,M (P ). Then, achieves L P/s possible
initial state tag rel(s, L) , achieves KL/t
KT,M (P ).
Proof. empty achieves L P/s, L thus, rel(s, L). Since
rel(s, L) , L , thus KL/t initial situation 0 KT,M (P ),
achieves KL/t KT,M (P ). Likewise, +1 = , achieves L P/s, A)
rule : C L P achieves C P/s, B) achieves L P/s
rule : C 0 L, achieves L0 P/s L0 C 0 . A, inductive
hypothesis, achieves KC/t, support rule : KC/t KL/t KT,M (P ),
= , , merges cannot
, must achieve KL/t KT,M (P ), must +1
delete positive literal KL/t. B, inductive hypothesis, achieves KL/t,
cancellation rule : KC 0 /t KL/t arising rule : C 0 L P , must
= , ,
achieve KL0 /t literal L0 C 0 . means , a, therefore, +1
must achieve KL/t.
Lemma A.12. Let KT,M (P ) covering translation P . applicable P ,
applicable KT,M (P ).
Proof. empty, direct. Else, +1 = , applicable P , must
applicable P must achieve literal L P re(a), therefore, inductive
hypothesis must applicable KT,M (P ). Then, let = {t1 , . . . , tn } covering
merge L P re(a) KT,M (P ). Theorem A.10, ti must
665

fiPalacios & Geffner

possible initial state rel(s, L) ti , Lemma A.11, achieving L
P/s implies achieving KL/ti KT,M (P ). Since true ti achieves
L P re(a) P/s possible initial states s, follows achieves KL/ti
ti KT,M (P ), therefore achieves KL KT,MV(P ) ends
sequence merges include action merge am,L effect ti KL/ti KL.
= , applicable K
result, +1
T,M (P ).
Theorem 15 Covering translations KT,M (P ) complete; i.e., conformant plan
P , classical plan 0 KT,M (P ) 0 merge actions
removed.
Proof. theorem follows trivially Lemma A.12 problem P 0
P additional, dummy action aG goals G P preconditions
aG . action sequence plan P iff action sequence , aG applicable P 0 ,
due Lemma A.12 implies action sequence , aG applicable KT,M (P 0 )
turn true iff action sequence plan KT,M (P ). sequence ,
turn, sequence merge actions removed.
Theorem 17 translation Kmodels(P ) sound complete.
Proof. Direct merges generated Kmodels precondition goal
literals L. Clearly merges valid, tags consistent I,
cover L (the models CI (L) satisfy CI (L)). Thus result follows Theorems 7
15.
Proposition 21 width w(P ) P determined time exponential
w(P ).
Proof. number clauses CI (L), mi sets clauses C
CI (L) |C| = i. clause one set must n literals, n
number fluents P , hence, one literal clause C collected, end
ni sets literals size greater i, inconsistent
consistent minimal (no consistent set collection
properly included); tests polynomial given prime implicate form.
Thus constructing cover c(C) set clauses C |C| = exponential i,
checking whether one cover satisfies CI (L) polynomial operation provided
prime implicate form. Indeed, c(C) = {t1 , . . . , tn }, computing closures
ti ti c(C), PI, testing whether ti intersects clause
CI (L) polynomial operations (the former reducing checking literal L0
whether |= ti L0 ). Thus computing width(L), generate sets C clauses
CI (L) |C| = i, starting = 0, increasing one one one set,
c(C) satisfies CI (L). computation exponential w(L), computation
preconditions goal literals P exponential w(P ).
Proposition 22 width P 0 w(P ) n, n number
fluents whose value initial situation known.
666

fiCompiling Uncertainty Away Conformant Planning Problems

Proof. inequality 0 w(P ) direct w(L) defined size |C| minimal set
clauses C CI (L) c(C) satisfies CI (L), w(P ) = w(L) precondition
goal literal L. inequality w(P ) n follows noticing set C clauses
given tautologies L0 L0 CI (L), c(C) must satisfy clause c CI (L),
c(C) must assign truth value literal c, inconsistent c,
inconsistent thus pruned c(C). Finally, max number tautologies
CI (L) number fluents L0 neither L0 L0 unit clauses I.
Theorem 24 fixed i, translation Ki (P ) sound, polynomial, w(P ) i,
covering complete.
Proof. soundness, need prove merges Ki (P ) valid
tags Ki (P ) consistent. soundness follows Theorem 7. merges
literal L Ki (P ) given covers c(C) collections C less clauses
Ci (L) clearly since
model must satisfy CI (L), must satisfy
W
c(C) |= tm = c(C). time, definition
cover c(C), tags must consistent I.
proving Ki polynomial fixed i, follow ideas similar ones used
proof Proposition 21 above, shown width P
determined time exponential w(P ) polynomial number clauses
fluents P . fixed i, number sets clauses C CI (L) size |C|
polynomial, complexity computing covers c(C) sets, hence,
merges L Ki (P ) polynomial too. Thus, whole translation Ki (P ) fixed
polynomial number clauses, fluents, rules P .
Finally, proving completeness, w(P ) i, w(L) precondition
goal literal L P . Therefore, literal L, set C clauses CI (L)
c(C) satisfies CI (L). translation Ki (P ) generate unique merge
L covers L. Since Ki (P ) valid translation, means Ki (P ) covering
translation, complete, virtue Theorem 15.
Lemma A.13. L0 relevant L rel(s, L) rel(s0 , L), rel(s, L0 ) rel(s0 , L0 ).
Proof. L00 rel(s, L0 ), L00 relevant L0 , since L0 relevant L
relevance relation transitive, L00 relevant L. Thus, L00 rel(s, L) therefore,
since rel(s, L) rel(s0 , L), L00 rel(s0 , L). L00 s0 since relevant
L0 , L00 rel(s0 , L0 ).
Proposition 26 Let s0 two states let action sequence applicable
classical problems P/s P/s0 . achieves literal L P/s0 rel(s0 , L)
rel(s, L), achieves literal L P/s.
Proof. induction length . empty, achieves literal L P/s0 , L
must s0 , since L relevant itself, L rel(s0 , L). rel(s0 , L) rel(s, L),
L must s, thus achieves L P/s.
667

fiPalacios & Geffner

Likewise, +1 = , achieves L P/s0 A) rule : C L
achieves C P/s0 ; B) achieves L P/s0 rule : C 0 L, achieves
L0 P/s0 L0 C 0 .
A, must achieve literal Li C P/s0 . Since Li relevant L rel(s0 , L)
rel(s, L), Lemma A.13, rel(s0 , Li ) rel(s, Li ). Then, inductive hypothesis, plan
must achieve Li P/s Li C, thus +1 = , must achieve L P/s
B, since L0 relevant L (as L0 relevant L), rel(s0 , L)
rel(s, L), Lemma A.13, rel(s0 , L0 ) rel(s, L0 ), thus inductive hypothesis,
must achieve L0 P/s L, +1 = , must achieve L P/s.
Lemma A.14. 0 two collection states every state
every precondition goal literal L P , state s0 0 rel(s0 , L)
rel(s, L), applicable P/S 0 , applicable P/S.
Proof. induction length . empty, obvious. +1 = , applicable
P/S 0 , applicable P/S 0 and, inductive hypothesis, applicable P/S.
need prove achieves preconditions action P/S.
L P rec(a) S, hypothesis, state s0 0
rel(s0 , L) rel(s, L). Proposition 26, since achieves L P/s0 , must
achieve L P/s. Since argument applies S, achieves L P/S, thus
+1 = , must applicable P/S.
Proposition 27 0 two collections states every state
every precondition goal literal L P , state s0 0 rel(s0 , L)
rel(s, L), plan P conforms 0 , plan P conforms
S.
Proof. Lemma A.14, consider problem P 0 similar P new action
aG whose preconditions goals G P . plan P conforms 0 ,
action sequence , aG applicable P 0 /S 0 , lemma, , aG
applicable P 0 /S, thus must plan P/S
Proposition 28 0 basis P every possible initial state P every
precondition goal literal L P , 0 contains state s0 rel(s0 , L) rel(s, L).
Proof. Direct Proposition 27, considering set possible initial states
P .
Proposition 29 initial situation prime implicate form = {t1 , . . . , tn }
merge covers literal L P , set S[ti , L] possible initial states P
rel(s, L) ti non-empty.
Proof. Direct Theorem A.10.
Theorem 30 Let KT,M (P ) covering translation let 0 stand collection
states s[ti , L] L precondition goal literal P ti tag merge
covers L. 0 basis P .
668

fiCompiling Uncertainty Away Conformant Planning Problems

Proof. show every possible initial state precondition goal literal
L, 0 theorem contains state s0 rel(s0 , L) rel(s, L). result
follows Proposition 28. Indeed, state must satisfy tag ti covering
merge = {t1 , . . . , tn } L, merges valid. Theorem A.10, must
possible initial state s0 rel(s0 , L) ti , therefore, rel(s0 , L) rel(s, L)
must satisfy ti possibly literals L0 relevant L.
Theorem 31 P conformant planning problem bounded width, P admits
basis polynomial size.
Proof. w(P ) fixed i, Ki (P ) covering translation polynomial number
merges tags, case, basis 0 P defined Theorem 30 contains
polynomial number states, regardless number possible initial states.

Appendix B. Consistency
assuming throughout paper conformant planning problems P
translations KT,M (P ) consistent. section make notion precise,
explain needed, prove KT,M (P ) consistent P is. proof,
take account heads KL merge actions am,L KT,M (P ), extended
literals KL0 literals L0 mutex L P (see Definition 4).
start beginning assuming states truth-assignments sets
literals fluents language. state complete every literal L, L L
s, consistent literal L L s. Complete consistent
states represent truth-assignments fluents F consistency P
translation KT,M (P ) ensures applicable action sequences map complete
consistent states complete consistent states s0 . guaranteed, complete
consistent states referred simply states done
paper.
Given complete state action applicable s, next state sa
sa = (s \ Del(a, s)) Add(a, s)

Add(a, s) = {L | : C L P C s}

Del(a, s) = {L | L Add(a, s)} .
follows sa complete state complete state, action
deletes literal L L added s. hand, may consistent
sa inconsistent, example, rules : C L : C 0 L
C C 0 s. order exclude possibility, ensuring reachable
states complete consistent, thus represent genuine truth assignments
fluents F , consistency condition P needed:
Definition B.1 (Consistency). classical conformant problem P = hF, I, O, Gi consistent initial situation logically consistent every pair complementary
literals L L mutex P .
669

fiPalacios & Geffner

consistent classical problem P , reachable states complete consistent,
standard progression lemma used preceding proofs holds:
Theorem B.2 (Progression). action sequence +1 = , applicable complete
consistent state achieves literal L consistent classical problem P iff A) achieves
body C rule : C L P , B) achieves L every rule : C 0 L,
achieves L0 literal L0 C 0 .
see conformant problem P consistent sense,
valid translation KT,M (P ). tested benchmarks considered paper
consistency found consistent except two domains
introduced elsewhere: 1-Dispose Look-and-Grab. cases, since consistency
classical problem KT,M (P ) cannot inferred consistency P ,
checked explicitly using Definition B.1, similarly, plans obtained
KT,M (P ) checked consistency indicated Section 8: soundness
plans ensured provided never trigger conflicting effects KL/t KL/t.10
Proof. proof Theorem B.2 rest particular definition mutexes,
mutex atoms true reachable state. consistent problem P ,
applicable action sequence maps complete consistent state s0 represents
truth assignment. Then, action sequence +1 = , achieves L iff C) L Add(a, s0 )
D) L s0 L 6 Del(a, s0 ). Condition theorem, however, equivalent C,
Condition B theorem, equivalent D. Indeed, L 6 Del(a, s0 ) iff rule
: C 0 L literal L0 C 0 L0 6 s0 , which, given s0 complete
consistent, true iff L0 s0 (this precisely consistency needed; else L0 s0
would imply L0 6 s0 ).
notion mutex used definition consistency expresses guarantee
pair literals true reachable state. Sufficient polynomial conditions
mutual exclusivity type invariants defined various papers,
follow definition Bonet Geffner (1999).
Definition B.3 (Mutex Set). mutex set collection R unordered literals pairs
(L, L0 ) classical conformant problem P that:
1. pair (L, L0 ) R, L L0 possible initial state s,
2. : C L : C 0 L0 two rules action (L, L0 ) pair
R, P re(a) C C 0 mutex R,
3. : C L rule P literal L pair (L, L0 ) R, either a) L0 = L,
b) P re(a) C mutex L0 R, c) P re(a) C implies C 0 R rule
: C 0 L0 P ;
10. consistency two domains, 1-Dispose Look-and-Grab, established however
definition mutexes slightly stronger one used. actually suffices change
expression P re(a) C clause 3c) definition mutex sets P re(a) C {L0 }.

670

fiCompiling Uncertainty Away Conformant Planning Problems

definition, pair said mutex R belongs R, set literals
said mutex R contains pair R, set literals said imply set
literals 0 R mutex R complement L literal L 0 \ S.
easy verify R1 R2 mutex sets, union R1 R2 mutex set,
thus maximal mutex set P denote R . pairs R
called mutexes.
simplicity without loss generality, assume preconditions P re(a)
empty. Indeed, simple show mutexes problem P remain
preconditions pushed conditions. assume condition C rule
C L P mutex, rules simply pruned. addition, assume
literal L mutex pair complementary literals L0 L0 , L cannot
true reachable state, thus, pruned well.
definition mutexes sound, meaning pair mutex set true
reachable state:
Theorem B.4. (L, L0 ) pair mutex set R classical conformant problem
P , reachable state P , {L, L0 } s.
Proof. proceed inductively. Clearly, L L0 cannot part possible initial state,
ruled definition mutex sets. Thus, let us assume inductive hypothesis
L L0 part state reachable less steps, let us prove
true states s0 = sa reachable one step. Clearly
L L0 belong s0 , either A) L L0 belong Add(a, s), B) L belongs
Add(a, s) L0 belongs Del(a, s). show possible.
A, P must comprise rules : C L : C 0 L0 C C 0 s, yet
definition mutex sets, C C 0 must mutex, inductive hypothesis
C C 0 6 s. B, must rule : C L C s, L0
inductive hypothesis, follows L0 mutex C R, thus,
mutex set definition, either L0 = L C implies C 0 rule : C 0 L0 .
first case, however, due rule : C L C s, L0 Del(a, s),
second case, completeness reachable states, must C 0 s, hence
L0 Del(a, s), contradicting B cases.
Provided initial situation conformant planning problem P prime
implicate form, computing largest mutex set R testing consistency P
polynomial time operations. former, one starts set literal pairs
iteratively drops set pairs comply definition
reaching fixed point (Bonet & Geffner, 1999).
move prove conformant problem P consistent, valid
translation KT,M (P ). consistency classical problems P/s possible initial
states direct, set mutexes P subset set mutexes P/s
initial situation constrained.
Proposition B.5 (Mutex Set RT ). valid translation KT,M (P ) consistent conformant problem P , define RT set (unordered) literals pairs (KL/t, KL0 /t0 )
(KL/t, KL0 /t) (L, L0 ) mutex P , t0 two tags jointly satisfiable
(I 6|= (t t0 )). RT mutex set KT,M (P ).
671

fiPalacios & Geffner

follows KT,M (P ) consistent P consistent, L0 = L
mutex L P , (KL/t, KL/t) must mutex RT .
Theorem B.6 (Consistency KT,M (P )). valid translation KT,M (P ) consistent P
consistent.
consistency translation K0 (P ) follows special case, K0 (P ) KT,M (P )
empty set merges set tags containing empty tag.
left prove Proposition B.5.
Proof Proposition B.5. must show set RT comprised pairs (KL/t, KL0 /t0 )
(KL/t, KL0 /t) L0 mutex L P , tags t0 jointly satisfiable
I, set complies clauses 1, 2, 3 Definition B.3. go one clause
time.
1. pair RT true initially KT,M (P ) = hF 0 , 0 , O0 , G0 jointly satisfiable
I, t, t0 . Indeed, KL/t KL0 /t0 0 must possible initial
state satisfying t0 L L0 true contradiction L L0
mutex P . Similarly, KL/t 0 KL0 /t not, must case
|= L 6|= L0 , must possible initial state P
t, L, L0 hold, contradiction L L0 mutex P too.
2. action rules KL/t KL0 /t0 rules must support
rules form : KC/t KL/t : KC 0 /t0 KL0 /t0 arising rules
: C L : C 0 L0 P .11 since L L0 mutex P , C C 0
must contain literals L1 C L2 C 0 (L1 , L2 ) mutex P ,
hence (KL1 /t, KL2 /t0 ) belongs RT , KC/t KC 0 /t0 mutex RT
well.
Similarly, action rules KL/t KL0 /t literal L0
mutex L P , rules must support cancellation rules form
: KC/t KL/t : KC 0 /t KL0 /t, arising rules : C L
: C 0 L0 P . Since L L0 mutex P , C C 0 must contain literals
L1 C L2 C 0 mutex P , hence RT must contain pair
(KL1 /t, KL2 /t), KC/t KC 0 /t must mutex RT .
3. left show set RT given pairs (KL/t, KL0 /t0 ) (KL/t,
KL0 /t) complies clause 3 definition mutex sets well. Consider
first class pairs (KL/t, KL0 /t0 ) rule : KC/t KL/t KL/t arising
rule : C L P . Since L mutex L0 P , one conditions 3a,
3b, 3c must hold rule : C L L0 . 3a, L0 = L, KC/t
must imply body KC/t0 cancellation rule : KC/t0 KL/t0 ,
literal L1 C, RT must contain pair (KL1 /t, KL1 /t0 ) KL1 /t
implies KL1 /t0 , KC/t implies KC/t0 (case 3c). 3b, C L0
11. action cannot merge literal L00 mutex L L0 , case, L00 implies
L L0 mutex. Similarly, cannot merge L case, L mutex
L0 L0 . reason, cannot merge L0 either. Thus, action
cannot merge must action P .

672

fiCompiling Uncertainty Away Conformant Planning Problems

mutex P , thus C contains literal L1 mutex L0 P . means
pair (KL1 /t, KL0 /t0 ) RT hence KC/t mutex KL0 /t0 RT
(case 3b). Last, 3c, C implies C 0 P rule : C 0 L0 , KC/t must
imply body KC 0 /t0 cancellation rule : KC 0 /t0 KL0 /t0 . Indeed,
literal L1 C C 0 , KL1 /t implies KL1 /t0 ,
L2 literal C 0 C, literal L3 C must mutex
L2 P , hence pair (KL3 /t, KL2 /t0 ) must RT KL3 /t implies
KL2 /t0 (case 3c)
0 0
Consider
V pair (KL/t, KL /t ) along merge action am,L
rule ti KL/ti KL KL/t = KL (thus empty tag). case, since
merge valid t0 consistent, must ti ti
t0 jointly consistent I. follows (KL/ti , KL0 /t0 ) pair RT
thus body merge mutex KL0 /t0 RT (case 3b).

need consider pair (KL/t, KL0 /t0 ) along rules KL0 /t0 ,
literals KL/t KL0 /t0 structure, thus argument
applies, replacing t0 L L0 .
switch second class pairs (KL/t, K/L0 /t) rules :
KC/t KL/t KL/t. Since L L0 mutex P , conditions 3a, 3b,
3c must hold. a, L0 = L, case, condition 3c holds KT,M (P )
KC/t implies body KC/t rule : KC/t KL0 (L0 = L). b, C
mutex L0 , thus literal L1 C L1 L0 mutex
P , therefore KC/t KL0 /t mutex RT (case 3b). Finally, c, C
implies C 0 rule : C 0 L0 P , KC/t must imply KC 0 /t RT
rule : KC 0 /t KL0 /t (case 3c).
empty tag t, rule KL/t may merge, due extra
effects KL0 merge action L, merge KL merge KL0 ,
case 3c holds.
Last, class pairs, rules KL0 /t cancellation rules
form : KC 00 /t KL0 /t rule : C 00 L0 P . Since L0 mutex
L P , conditions 3a, 3b, 3c must hold rule : C 00 L0 L0 P .
a, L = L0 , cancellation rule : KC 00 /t KL (case 3c).
b, C 00 mutex L, thus literal L2 C 00 (L2 , L) mutex
P , therefore KL/t implies KL2 /t RT , hence KL2 /t KC 00 /t
imply KL/t RT (case 3b). Finally, c, C 00 implies C 0 rule : C 0 L P ,
KC 00 /t must imply KC 0 /t rule : KC 0 /t KL/t RT .
Indeed, LA implies LB P , LB implies LA P , KLB /t implies KLA /t
RT , KLA /t implies KLB /t.

References
Albore, A., Palacios, H., & Geffner, H. (2009). translation-based approach contingent
planning. Proc. 21st Int. Joint Conference AI (IJCAI-09), pp. 16231628.
673

fiPalacios & Geffner

Baral, C., Kreinovich, V., & Trejo, R. (2000). Computational complexity planning
approximate planning presence incompleteness. Artificial Intelligence, 122 (12), 241267.
Baral, C., & Son, T. C. (1997). Approximate reasoning actions presence sensing
incomplete information. Proc. ILPS 1997, pp. 387401.
Bayardo Jr., R., & Schrag, R. (1997). Using CSP look-back techniques solve real-world
sat instances. Proc. AAAI, pp. 203208.
Bertoli, P., & Cimatti, A. (2002). Improving heuristics planning search belief space.
Ghallab, M., Hertzberg, J., & Traverso, P. (Eds.), Proc. AIPS-2002, pp. 143152.
AAAI Press.
Bonet, B., & Geffner, H. (1999). Planning heuristic search: New results. Proceedings
ECP-99, pp. 359371. Springer.
Bonet, B., & Geffner, H. (2000). Planning incomplete information heuristic search
belief space. Proc. AIPS-2000, pp. 5261. AAAI Press.
Bonet, B., & Geffner, H. (2001). Planning heuristic search. Artificial Intelligence, 129 (1
2), 533.
Bonet, B., & Givan, B. (2006). Results conformant track 5th int. planning
competition. http://www.ldc.usb.ve/bonet/ipc5/docs/results-conformant.pdf.
Bryce, D., & Buffet, O. (2008). International planning competition uncertainty part: Benchmarks results. http://ippc-2008.loria.fr/wiki/images/0/03/Results.pdf.
Bryce, D., Kambhampati, S., & Smith, D. E. (2006). Planning graph heuristics belief
space search. Journal Artificial Intelligence Research, 26, 3599.
Cimatti, A., Roveri, M., & Bertoli, P. (2004). Conformant planning via symbolic model
checking heuristic search. Artificial Intelligence, 159, 127206.
Dechter, R. (2003). Constraint Processing. Morgan Kaufmann.
Goldman, R. P., & Boddy, M. S. (1996). Expressive planning explicit knowledge.
Proc. AIPS-1996, pp. 110117.
Haslum, P., & Jonsson, P. (1999). results complexity planning incomplete information. Proc. ECP-99, Lect. Notes AI Vol 1809, pp. 308318.
Springer.
Hoffmann, J., & Brafman, R. (2005). Contingent planning via heuristic forward search
implicit belief states. Proc. 15th Int. Conf. Automated Planning Scheduling
(ICAPS 2005), pp. 7180. AAAI.
Hoffmann, J., & Brafman, R. (2006). Conformant planning via heuristic forward search:
new approach. Artificial Intelligence, 170 (6-7), 507541.
Hoffmann, J., & Nebel, B. (2001). planning system: Fast plan generation
heuristic search. Journal Artificial Intelligence Research, 14, 253302.
Marquis, P. (2000). Consequence finding algorithms. Gabbay, D., & Smets, P. (Eds.),
Handbook Defeasible Reasoning Uncertainty Management Systems, Vol. 5, pp.
41145. Kluwer.
674

fiCompiling Uncertainty Away Conformant Planning Problems

Palacios, H., & Geffner, H. (2006). Compiling uncertainty away: Solving conformant planning problems using classical planner (sometimes). Proc. AAAI-06, pp. 900905.
Palacios, H., & Geffner, H. (2007). conformant classical planning: Efficient translations may complete too. Proc. ICAPS-07, pp. 264271.
Petrick, R., & Bacchus, F. (2002). knowledge-based approach planning incomplete
information sensing. Proc. AIPS-02, pp. 212221.
Rintanen, J. (2004). Complexity planning partial observability. Proc. ICAPS2004, pp. 345354.
Smith, D., & Weld, D. (1998). Conformant graphplan. Proceedings AAAI-98, pp. 889
896. AAAI Press.
Son, T. C., Tu, P. H., Gelfond, M., & Morales, A. (2005). Conformant planning domains
constraints: new approach. Proc. AAAI-05, pp. 12111216.
Son, T. C., & Tu, P. H. (2006). completeness approximation based reasoning
planning action theories incomplete information.. Proc. 10th Int. Conf.
Principles KR Reasoning (KR-06), pp. 481491.
Tison, P. (1967). Generalized consensus theory applications minimization
boolean circuits. IEEE Transactions Computers, EC-16 (4), 446456.
Tran, D., Nguyen, H., Pontelli, E., & Son, T. C. (2008). CPA(C)/(H): Two approximationbased conformant planners. http://ippc-2008.loria.fr/wiki/images/5/57/Team2CPA.pdf.
Tran, D., Nguyen, H., Pontelli, E., & Son, T. C. (2009). Improving performance conformant planners: Static analysis declarative planning domain specifications. Practical Aspects Declarative Languages, 11th International Symposium, PADL 2009,Proceedings, Vol. 5418 Lecture Notes Computer Science, pp. 239253. Springer.
Turner, H. (2002). Polynomial-length planning spans polynomial hierarchy. JELIA
02: Proc. European Conference Logics AI, pp. 111124. Springer-Verlag.

675


