Journal Artificial Intelligence Research 35 (2009) 119-159

Submitted 11/08; published 06/09

Trust-Based Mechanisms Robust Efficient Task Allocation
Presence Execution Uncertainty
Sarvapali D. Ramchurn

SDR @ ECS . SOTON . AC . UK

Intelligence, Agents, Multimedia
School Electronics Computer Science
University Southampton, Southampton, UK

Claudio Mezzetti

C . MEZZETTI @ WARWICK . AC . UK

Department Economics
University Warwick, Coventry, UK

Andrea Giovannucci

AGIOVANNUCCI @ IUA . UPF. EDU

SPECS Laboratory
Pompeu Fabra University
Barcelona, Spain

Juan A. Rodriguez-Aguilar

JAR @ IIIA . CSIC . ES

Artificial Intelligence Research Institute
Spanish Council Scientific Research
Barcelona, Spain

Rajdeep K. Dash
Nicholas R. Jennings

RKD @ ECS . SOTON . AC . UK
NRJ @ ECS . SOTON . AC . UK

Intelligence, Agents, Multimedia
School Electronics Computer Science
University Southampton, Southampton, UK

Abstract
Vickrey-Clarke-Groves (VCG) mechanisms often used allocate tasks selfish rational
agents. VCG mechanisms incentive compatible, direct mechanisms efficient (i.e., maximise social utility) individually rational (i.e., agents prefer join rather opt out). However, important assumption mechanisms agents always successfully complete allocated tasks. Clearly, assumption unrealistic many real-world applications,
agents can, often do, fail endeavours. Moreover, whether agent deemed
failed may perceived differently different agents. subjective perceptions
agents probability succeeding given task often captured reasoned using
notion trust. Given background, paper investigate design novel mechanisms
take account trust agents allocating tasks.
Specifically, develop new class mechanisms, called trust-based mechanisms,
take account multiple subjective measures probability agent succeeding given
task produce allocations maximise social utility, whilst ensuring agent obtains
negative utility. show mechanisms pose challenging new combinatorial
optimisation problem (that NP-complete), devise novel representation solving problem,
develop effective integer programming solution (that solve instances 2 105
possible allocations 40 seconds).
c
2009
AI Access Foundation. rights reserved.

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

1. Introduction
Task allocation important challenging problem within field multi-agent systems.
problem involves deciding assign number tasks set agents according
allocation protocol. example, number computational jobs may need allocated agents
run high performance computing data centres (Byde, 2006), number network maintenance
tasks may need performed communications companies number business clients
(Jennings, Faratin, Norman, OBrien, Odgers, & Alty, 2000), number transportation tasks
may need allocated number delivery companies (Sandholm, 1993). general case,
agents performing jobs asking jobs performed trying maximise
gains (e.g., companies owning data centres servers trying minimise
number servers utilised, communications companies try minimise number people
needed complete tasks demanded, transportation companies try use minimum
number vehicles). Given this, Mechanism Design (MD) techniques employed design
task allocation protocols since techniques produce solutions provable
desirable properties faced autonomous utility maximising actors (Dash, Parkes, &
Jennings, 2003). particular, Vickrey-Clarke-Groves (VCG) class mechanisms
advocated number problem domains (Walsh & Wellman, 1998; Hershberger & Suri, 2001;
Dash et al., 2003) maximise social welfare (i.e., efficient) guarantee nonnegative utility participating agents (i.e., individually rational). mechanisms,
agents typically reveal costs performing tasks valuation requested tasks
centre centre computes allocation tasks agent payments
need make receive. However, important underpinning assumption mechanisms
make agent always successfully completes every task assigned centre.
result assumption allocation (i.e., assignment tasks asked
requester agents executed task performer agents) selected centre based
costs valuations provided agents. ensures centre always chooses
performers cheapest requesters ready pay most. However,
agents chosen centre may ultimately successful completing assignment.
example, agent providing access data centre cost 10, success rate
100%, might preferable one providing service cheaper cost 5
10% chance successful. Thus, order make efficient allocations circumstances,
need design mechanisms consider task performers costs service
probability success (POS). Now, probability may perceived differently different agents
typically different standards means evaluating performance
counterparts. example, different customers might evaluate performance data centre
different ways timeliness, security, quality output. Given this, turn notion
trust capture subjective perceptions (Ramchurn, Huynh, & Jennings, 2004). take
account agents trust agents, well costs, allocating tasks requires
design new class mechanisms previously termed trust-based (Dash, Ramchurn,
& Jennings, 2004).
date, however, existing work trust-based mechanisms (TBMs) ignores number important aspects task allocation problem makes less robust uncertainty (see Section
2 details). First, Porter, Ronen, Shoham, Tennenholtz (2008) allow POS reports
come task performer, rather agent. means task requester
2

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

misled task performers opinion (even truthfully revealed) since task requester
may believe, times, task performer failed task performer believes succeeded. Second, previous work (Dash et al., 2004), presented trust-based mechanism
could result inefficient allocations agents strong incentives over-report POS.
Even importantly, however, existing trust-based mechanisms completely ignore computational cost associated including POS computing optimal allocation payments.
Thus, previous work highlights economic benefits, specify new problem effectively represented efficiently solved. ignoring issues, previous work
failed prove mechanisms actually implemented, solved, whether
scale reasonable numbers agents.
background, paper provides economically efficient individually rational
mechanisms scenarios exists uncertainty agents successfully completing
assigned tasks. execution uncertainty generally modelled follows. First, potential task performers assessed task requester uses individual experience
performance information gathered environment (such reports agents
performance) construct estimation POS. Often sources called confidence reputation respectively (Ramchurn et al., 2004; Dasgupta, 1998), combined
give notion trust agent performing particular task. combined view trust
used robust measure POS single estimate (especially one
originating task performer). evident fact agent likely
partial view performance task performer derived finite subset
interactions. example, task requester ten tasks performed agent may benefit
experience acquired another requesters fifty interactions agent. However, incorporating trust decision mechanism requester introduces two major issues.
First, agents use reports agents build trust, introduces possibility interdependent valuations. means value generated one agent system
affected another agents report mechanism (Jehiel & Moldovanu, 2001; Mezzetti, 2004).
This, turn, makes much harder standard VCG-based techniques incentivise agents
reveal private information truthfully. Second, using trust find optimal allocation involves
significant computational cost show solving optimisation problem trust-based
mechanisms NP-complete.
tackle issue interdependence, build upon work Mezzetti (2004, 2007)
construct novel mechanism incentivises agents reveal private information. Moreover, help combat computational complexity generated trust, go develop novel
representation optimisation problem posed trust-based mechanisms provide implementation based Integer Programming (IP). Given this, show main bottleneck
mechanism lies searching large set possible allocations, demonstrate
IP solution comfortably solve small medium instances within minutes (e.g., 6 tasks
50 agents) hours (e.g., 8 tasks 70 agents).1 doing, provide first benchmark
algorithms aim solve optimisation problems.
detail, paper advances state art following ways:

1. Though time taken find optimal solution grows exponentially number tasks, mechanism sets
baseline performance solving optimisation problem posed trust-based mechanisms.

3

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

1. design novel TBMs allocate tasks uncertainty completion. TBMs non-trivial extensions paper Porter et al. (2008)
first consider reputation task performer within system, addition
self-report. allows us build greater robustness mechanism since takes
account subjective perceptions agents (task requesters particular) POS
task performers.
2. prove TBMs incentive compatible, efficient individually rational.
3. develop novel representation optimisation problem posed TBMs and, given
this, cast problem special matching problem (Berge, 1973). show solving
generalised version TBMs NP-complete provide first Integer Programming
solution it. solution solve instances 50 agents 6 tasks within one minute
even larger instances within hours.
rest paper structured follows. start providing overview related
work Section 2. provide contributions listed step-wise manner. First,
simple task allocation model detailed Section 3, introduce TBM single
requester, single task scenario. Section 4 develops generalised TBM multiple requesters
multiple tasks prove economic properties. dealt economic aspects,
turn computational problem implementing TBMs Section 5. Specifically,
develop new representation optimisation problem posed generalised TBM, study
computational costs associated solving problem, provide IP-based solution it.
Section 6 discusses number broader issues related development future trust-based
mechanisms.

2. Related Work
associating uncertainty mechanism design, build upon work areas. regards
capturing uncertainty multi-agent interactions, work focused devising computational
models trust reputation (see papers Teacy, Patel, Jennings, & Luck, 2006, Ramchurn
et al., 2004, reviews). models mostly use statistical methods estimate reliability
opponent agents reports direct interactions opponent.
models try identify false inaccurate reports checking closely report matches
agents direct experience opponent (Teacy et al., 2006; Jurca & Faltings, 2006). Now,
models help choosing successful agents, shown generate
efficient outcomes given mechanism. contrast, paper provide means use
models order this.
case MD, surprisingly little work achieving efficient, incentive compatible individually rational mechanisms take account uncertainty general.
approaches adopted separated work reputation mechanisms mechanisms
task resource allocation. former mainly aim eliciting honest feedback reputation
providers. Examples mechanisms include papers Dellarocas (2002), Miller, Resnick,
Zeckhauser (2005), Jurca Faltings (2003, 2006). particular, Miller et al. (2005) recently developed peer prediction model, incentivises agents report truthfully
experience. mechanism operates rewarding reporters according well reports
4

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

coincide experience peers. Specifically, assigns scores distance
given agents report selected reference reporters reports given task performer.
similar way, Jurca Faltings (2007) attempted solve problem placing
importance repeated presence agents system order induce truthful reporting. However, given focus eliciting honest feedback, mechanism silent
feedback actually used for. particular, cannot employed task allocation
scenario study paper case objective maximise overall utility
society that, therefore, considers value POS agents. example, car repair
lower value building bridge. Hence, feedback car repairer less critical
feeback bridge builder terms impact social welfare. Interestingly, mechanism shown truth-telling (non-unique) Nash equilibrium budget balanced,
individually rational (see Section 6 social desiderata interplay).
terms MD task allocation, type uncertainty taken account Bayesian mechanisms dAGVA (dAspremont & Gerard-Varet, 1979; Arrow, 1979). considers
case payoffs agents determined via probability distribution types
common knowledge agents. However, mechanism cannot deal problem
uncertainty task completion, agent information POS
agents, common knowledge type distributions. Porter et al. (2008)
considered task allocation problem mechanism one closely
related ours. However, limit case agents report
POS. serious drawback assumes agents measure POS
accurately consider case agents may different perceptions
POS (e.g., performer believes performs better worse requester perceives).
Moreover, consider single requester setting, mechanisms develop
deal multiple tasks multiple requesters. Thus, mechanisms considered
two-way generalisation theirs. First, allow multiple reports uncertainty need
fused appropriately give precise POS perceived requester. Second, generalise
mechanism case multiple requesters agents provide combinatorial valuations
multiple tasks. earlier work problem (Dash et al., 2004), proposed preliminary TBM agents could followed risky, potentially profitable strategy,
over-reporting costs under-reporting valuations since payments made according whether succeed fail allocated task (which new mechanism).
contrast, work, payment scheme ensures strategy viable thus
mechanism robust. Moreover, previous work assumed trust functions monotonically increasing POS reports (similar Porter et al.) develop algorithms
needed actually solve optimisation problem posed TBM. paper, present
mechanism applies general trust functions develop algorithms solve TBMs.
Finally, work case interdependent, multidimensional allocation schemes. interdependent payoffs, Jehiel Moldovanu (2001) shown impossible achieve efficiency
one-stage mechanism. Mezzetti (2004), however, shown possible achieve efficiency elegant two-stage mechanism reasonable assumptions. mechanism
achieves efficiency without needing two reporting stages because, setting consider, payments contingent whether tasks successful agents derive
direct payoff allocation task another agent agents assessments
completion probabilities. setting, exists specific function captures interde5

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

pendence exists among agents assessments others POS. function
is, case, agents trust model.

3. Single Requester, Single Task Allocation Mechanisms
section, first present basic VCG mechanism simple task allocation model (a
single task requested single agent) allocated task guaranteed completed
(i.e., agents POS equal 1). briefly describe Porter et al.s (2008) extension
considers task performers privately known objective probability finish
assigned task. Finally, consider case POS task performer function
privately known variables held task performer system. ensures
choice made task requester better informed (drawing data various sources)
POS task performers. show Porter et al.s mechanism would fail produce
efficient allocation settings go provide non-trivial extension model
cater this. doing, define new trust-based mechanism single requester,
single task scenario (as prelude generalised mechanism develop next
section). go prove economic properties simple TBM. Throughout
section, running example task allocation problem employed demonstrate workings
mechanisms discussed.
3.1 Allocation Guaranteed Task Completion
task allocation scenario, single agent derives value certain task performed.
end, agent needs allocate task one available task performers,
charge certain amount execute task. start considering following simple example:
Example 1. MoviePictures.com, computer graphics company, image rendering task
wishes complete new movie. Hence, MoviePictures.com publicly announces intention
companies owning data centres execute task. Given interest shown many
companies, MoviePictures.com needs decide mechanism allocate contract
much pay chosen contractor, given MoviePictures.com know
contractors costs execute job (i.e., know much actually costs company
process images render required quality).
example captured following model. set agents (data
centre agents example), = {1, 2, . . . , i, . . . , I}, privately-known cost
ci ( ) R+ {0} performing rendering task . Furthermore, let MoviePictures.com
represented special agent 0, value v0 ( ) R+ {0} rendering task
cost c0 ( ) > v0 ( ) perform task (c0 ( ) = case agent 0 cannot execute task).
Hence, MoviePictures.com get task performed another agent set
cost ci ( ) v0 ( ).
Now, MoviePictures.com needs decide procedure award contract, hence,
acts centre invite offers agents perform task. devising
mechanism task allocation, focus incentive-compatible direct revelation mechanisms
(DRMs) invoking revelation principle states mechanism transformed
DRM (Krishna, 2002). context, direct revelation means strategy space (i.e.,
possible actions) agents restricted reporting type (i.e., private information,
6

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

example cost valuation task) incentive-compatible means equilibrium strategy
(i.e., best strategy certain equilibrium concept) truth-telling.
Thus, DRM, designer control two parts: 1) allocation rule determines wins contract, 2) payment rule determines transfer money centre (i.e., MoviePictures.com) agents (i.e., data centres). Let K denote
particular allocation within space possible allocations K i0 represent agent
gets allocated task agent 0. Then, setting, space possible allocations
K = {, 10 , 20 , . . . , I0 } denotes case task allocated.
Moreover, abuse notation slightly define cost allocation K agent i,
ci (K) = ci ( ) K = i0 ci (K) = 0 otherwise. Similarly, centre, value
non empty allocation simply value task, i.e., v0 (K) = v0 ( ) K 6=
v0 (K) = 0 K = . Finally, let ri () R payment centre agent i. case ri ()
negative, agent pay |ri ()| centre.
Within context task allocation, direct mechanisms take form sealed-bid auctions
task performers report costs centre (or auctioneer). Agents may wish report
true costs reporting falsely leads preferable outcome them. therefore
distinguish actual costs reported ones superscripting latter b.
task allocation problem consists choosing allocation payment rules
certain desirable system objectives (some detailed below) satisfied. allocation
rule mapping reported costs set allocations, K(b
ci , b
ci ) allocation
chosen agent reports b
ci agents report vector b
ci . Similarly, payment rule
mapping reported costs payments agent, ri (b
ci , b
ci ) payment
agent agent reports b
ci agents report vector b
ci .
Following task execution payments, agent derives utility given utility function ui : K R R. common domain, assume agent rational (expected
utility maximiser) quasi-linear utility function (MasColell, Whinston, & Green, 1995):
Definition 1. quasi-linear utility function one expressed as:
ui (K, ri ) = ri ci (K)

(1)

K K given allocation.
modelled problem above, MoviePictures.com would use protocol
possesses desirable properties efficiency individual rationality. needs make sure
protocol incentive compatible: agents must find optimal report true costs.
desiderata formally defined follows:
Definition 2. Efficiency: allocation mechanism said achieve efficiency outcome
generates maximises total utility agents system (without considering transfers).
is, vectors reports b
c, calculates K that:
"
#
X
b
ci (K)
(2)
K (b
c) = arg max v0 (K)
KK

iI

Definition 3. Individual Rationality: allocation mechanism said achieve individual rationality agents derive higher utility participating mechanism opting it.
7

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

Assuming utility agent obtains opting zero, individually rational
allocation K one (Krishna, 2002):
ui (K, ri ) 0 ,

(3)

Definition 4. Incentive compatibility: allocation mechanism said achieve incentive compatibility agents true type optimal report matter agents report.
is:
ri (ci , b
ci ) ci (K(ci , b
ci )) ri (b
ci , b
ci ) ci (K(b
ci , b
ci )) ci , b
ci , b
ci .

Note incentive compatibility implies vector reports agents b
ci
payments agent must depend report chosen allocation. Incentive
compatibility requires telling truth (weakly) dominant strategy. important
note incentive compatibility dominant strategies strongest possible form incentive
compatibility. VCG mechanism property.
MoviePictures.com decides employ Vickrey auction (also known second-price
sealed bid auction) since protocol possesses desired properties incentive compatibility,
efficiency, individual rationality (Krishna, 2002). detail, received
sealed bids (reports b
c) agents, centre calculates allocation K (b
c) according
Equation (2), transfer ri () winner given by:


X
v0 (K )
ri (b
c) = v0 (K (b
c)) max
b
cj (K )
(4)

K Ki

jI\i

Ki set allocations involve task performer.
3.2 Allocation Execution Uncertainty

mechanism presented previous section, assumed allocation K
decided, value v0 (K ) obtained centre (either v0 ( ) task allocated
0 otherwise). Thus, implicit assumption allocated task, agent
always perform successfully. However, unrealistic, illustrated following example:
Example 2. Many previous rendering tasks required MoviePictures.com allocated
PoorRender Ltd competitive prices. Unfortunately, PoorRender Ltd could
complete task many cases lack staff technical problems (which
knew even bidding task). result, MoviePictures.com incurred severe
losses. Hence, MoviePictures.com decides alter allocation mechanism way
agents POS completing tasks factored selection cheapest agent.
MoviePictures.com assumes contractor knows POS cost privately needs
mechanism elicit information truthfully order choose best allocation.
problem studied Porter et al. (2008) briefly describe, terms,
mechanism order extend generalise later (see Sections 3.3 4). first introduce
boolean indicator variable denote whether task completed ( = 1)
( = 0). Thus, observable task allocated. Moreover, extend
8

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

notation capture centres valuation task execution v0 () = v0 (K )
= 1 v0 () = 0 = 0. setting, assume commonly observed (i.e.,
agent believes = 1, agents {0} believe same). rendering
example, might denote whether images rendered appropriate resolution
allow usage not. Furthermore, probability = 1 task allocated
agent dependent upon another privately known variable, pi ( ) [0, 1], POS
agent executing task . Note variable privately known task performer itself,
single observation within system, carried task performer,
POS. note task performer incurs cost ci ( ) soon attempts task
irrespective whether successful not.
seen, value centre (MoviePictures.com) derive, v0 (), known
allocation calculated. Hence, notions efficiency individual rationality introduced section 3.1 need adjusted new setting. Given probability task
executed given agent, consider expected value allocation, v 0 (K, p),
calculated as:
v 0 (K, p) = v0 (K) pi ( )

(5)

agent chosen perform task allocation K p = hp1 ( ), . . . , pI ( )i
vector POS values agents (the list assessments contractor
probability complete rendering task example). need require
b vector reported POS values
agents report POS, addition cost. denote p
hb
p1 ( ), . . . , pbI ( )i.
following modified desiderata need considered now:

Definition 5. Efficiency: mechanism said achieve efficiency chooses allocation
maximises sum expected utilities (without considering transfers):
#
"
X
b)
b) = arg max v 0 (K, p
b
ci (K)
(6)
K (b
c, p
KK

iI

b reported agents key computing efficient
Note b
ci (K) p
allocation.
Definition 6. Individual Rationality: mechanism achieves individual rationality participating
agent derives expected utility, ui , always non-negative:
ui (c, p) = ri (c, p) ci (K) 0

ri (c, p) expected payment agent receives.
order achieve desiderata, one could suppose nave extension standard
Vickrey mechanism presented would sufficient. mechanism, centre would
ask agents report extended types (b
ci , pbi ( )). allocation chosen would one
maximising expected utility agents payment rule would conditioned according
Equation (4) v 0 (K , p) replacing v0 (K ). However, mechanism would fail
settings, illustrated next section.
9

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

3.2.1 NA IVE PPLICATION V ICKREY AUCTION
Example 3. Consider case MoviePictures.com derives value v0 ( ) = 300
rendering task completed let three contractors whose costs ci ( ) render
images given (c1 ( ), c2 ( ), c3 ( )) = (100, 150, 200). Furthermore, assume contractor
POS given (p1 ( ), p2 ( ), p3 ( )) = (0.5, 0.9, 1). information represented Table
1.
efficient allocation case (shaded line Table 1) involves assigning task agent
2 expected social utility 300 0.9 150 = 120. payment agent 2 using
(reverse) Vickrey auction expected values 300 0.9 (300 200) = 170 (from Equation
(4)). However, mechanism incentive-compatible. example, agent 1 reveals
pb1 ( ) = 1, centre implement K = 10 pay agent 1, r1 = 300120 = 180.
Thus, agents mechanism always better reporting pbi ( ) = 1, matter
actual POS is! Hence, centre able implement efficient allocation.
Agent
1
2
3

ci ( )
100
150
200

pi ( )
0.5
0.9
1

Table 1: Costs performing task agents perceived probability successfully completing
task.

type extension (i.e., including POS) non-trivial POS report agent
affects social value expected centre, agents cost allocation.
result, reporting higher POS positively affect agents probability winning
allocation thus positively affect utility. rectify this, need means
gain utility balanced penalty truthfully reporting type, agent
maximise utility. achieved Porter et al.s (2008) mechanism, briefly detail
next section.
3.2.2 P ORTER ET AL . ECHANISM
mechanism based around payments applied completion tasks. Specifically,
mechanism finds marginal contribution agent made expected welfare
agents depending whether completes assigned task not. Intuitively, works since
payment scheme punishes agent assigned task complete (i.e., = 0).
result, agent incentivised reveal higher POS value real POS since
allocated task, likely reap punishment rather reward obtains
successfully completes task (i.e., = 1).
detail, allocation determined centre according Equation (6). payment rule agent task allocated similar VCG
marginal contribution agent system extracted comparing efficient allocation
b, ) = 0 allowith second best allocation, excluding agent (the agent gets ri (b
c, p
cated task). difference expected marginal contribution extracted (i.e.,
10

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

taking account agents real probability success). achieved follows:



P
(b
)
, p

b
b
v
(K
c
,
p
))

max
b
c
(K
, = 1
v
(K
)


0
0
jI\i j

K Ki

b, ) =
ri (b
c, p



P


b)
b
cj (K )
, = 0
max v 0 (K , p


(7)

jI\i

K Ki

Ki set allocations excluding agent i.
mechanism would work example provided Table 1 since if, example, agent
1 reports pb1 ( ) = 1, allocated task paid 300 120 = 180
probability 0.5 120 probability 0.5. Thus, average, agent 1 paid 30
time incur cost 100, thereby making expected utility 70. Clearly, then,
rational agent overstate POS. fact, incentive compatibility mechanism
arises agent expected utility, given allocated task, is:


b) = pi ( ) v0 (K (b
b)) ci (K (b
b)) max
ui (b
c, p
c, p
c, p


K Ki



b)) max
+ (1 pi ( )) ci (K (b
c, p


K Ki



b), p) ci (K (b
b)) max
c, p
c, p
= v 0 (K (b


K Ki



b)
v 0 (K , p

b)
v 0 (K , p



X

jI\i

b)
v 0 (K , p

X

jI\i



b
cj (K )



b
cj (K )

X

jI\i

(8)


b
cj (K )

Note expected utility within mechanism would
derived agents nave extension VCG truthful reporting p. However,
Porter et al.s mechanism, agents incentive lie. because, pbi ( ) > pi ( )
(i.e., agent over-reports POS), agent might allocated task even though:
h

6= arg max v0 (K x )px ( ) cx (K x )
xI



Kx

=

x0 ,

means could that:

b), p) ci (K (b
b)) < max
v 0 (K (b
c, p
c, p


K Ki



X
b)
b
cj (K )
v 0 (K , p
jI\i

results agent deriving negative utility per Equation (8). Hence, agent
report higher POS values. complete treatment proof incentive-compatibility
mechanism given paper Porter et al. (2008). Furthermore, mechanism
proven individually rational efficient.
3.3 Allocation Multiple Reports Execution Uncertainty
previous section, considered mechanism agent privately known
estimation uncertainty task completion. mechanism considers centre
11

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

receive single estimate agents POS. turn attention previously
unconsidered, general, case several agents may estimate. example,
number agents may interacted given data centre provisioning company many
occasions past therefore acquired partial view POS company. Using
estimates, centre obtain accurate picture given agents likely performance
combines different estimates together. combination results better estimate
number reasons, including:
1. Accuracy estimation: accuracy estimation typically affected noise. Thus,
combining number observations lead refined estimate obtaining
single point estimate.
2. Personal Preferences: agent within system may different opinions
constitutes success attempting task. result, centre may willing assign
weight agents estimate believes agents perspective similar
own.
illustrate points considering following example:
Example 4. MoviePictures.com still satisfied solution chosen far.
PoorRender Ltd still reports high POS, even though MoviePictures.com noticed
failed task number occasions. PoorRender Ltd believes
images rendered high enough quality used feature film MoviePictures.com believed not. MoviePictures.com therefore cannot rely agents
perception POS decide allocation. Rather, MoviePictures.com wants ask
agents submit perception others POS. doing, MoviePictures.com aims
capture knowledge agents might either previous sub-contracted
tasks simple observations. end, MoviePictures.com needs devise mechanism
capture agents perceptions (including own) measures POS agent use
fused measures selection process.
example modelled introducing new variable, Expected Quality
Service (EQOS), noted ij ( ), perception agent POS agent j
task . Now, vector agent EQOS agents (including itself) within system
noted = hi1 ( ), . . . , iI ( )i. Furthermore, shall denote j EQOS agents
within system (including itself) agent j. Thus, image rendering example, ij ( )
might denote probability perceived agent rendering task completed according
certain level quality computer graphics (which perceived differently different
agents). Then, MoviePictures.com needs function order combine EQOS agents
give resultant POS movie rendered graphic requirements.
detail, given previous personal interaction j, compute, based frequency good bad interactions, probability, termed confidence, j POS. Second,
take account agents (i) opinions j, known js reputation society, order compute POS j (Ramchurn et al., 2004). combination measures
generally captured concept trust, defined aggregate expectation, derived
history direct interactions information sources, j complete
12

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

task assigned it. aggregate trust agent j successfully complete task agent 0
function tr0j : [0, 1]|I| [0, 1].
multiple ways trust function could computed, often captured
follows:
tr0j () =

X

wl lj

(9)

lI

P
wl [0, 1] wl = 1. function generates trust weighted sum EQOS values.
cases, actually considered probability distributions trust function
expected value joint distribution constructed individually reported distributions
(Teacy et al., 2006; Jurca & Faltings, 2007). Much work exists literature deals
different ways combining distributions biases incompatibilities agents
perceptions taken account. Essentially, however, assign weights different reports
agents choose expected value reports trust agent. However,
date, none models actually studies get self-interested agents generate reports
truthfully along maximising social welfare.
Now, direct mechanism case elicits agent i, cost EQOS vector,
{ci ( ), }, centre decides allocation payments agents. computing expected utility mechanism, agent must evaluate trust, probability success,
agent allocated task. raises conceptual difficulty. agent
treat agents POS reports assessing probability task completion (as opposed
computing best response type reports)? approach take paper
agent assumes reported POS agents truthful computing trust another
agent; precisely, agent computes value trust function using true EQOS
reported EQOS agents. Thus, trust agent agent j able comb ). already seen, general payment agent depends
plete task tr0j ( ,
b)
reported types agents whether task succeeds fails. end, let i(b
c,
b ). Then, define
agent allocated task vector reported types (b
c,
b )
expected payment agent true types (c, ) reported types (b
c,
follows:
h

b ,
b)
b ,
b)
i(c
i(c
b ; c, ) = ri (b
b , = 1)tr0
b ) + ri (b
b , = 0) 1 tr0
b )
Eri (b
c,
c,
( ,
c,
( ,
point type agent (EQOS plus cost) multidimensional and,
common multidimensional world, could several type reports generate
expected payment agent. ready define modified notion incentive compatibility use.2

Definition 7. Incentive compatibility (in Dominant Strategies): allocation mechanism said
achieve incentive compatibility dominant strategies agents true type optimal report
matter agents report. is: c, , b
ci , b
, b
ci , b
,
b ; c, ) ci (K(ci , b
bi,
b ; c, ) ci (K(b
Eri (ci , b
ci , ,
ci )) Eri (b
ci , b
ci ,
ci , b
ci ))

2. agent uses reported POS agents computing value trust function seems natural
assumption agent rely agents truthfully reporting types. case, example,
history interactions POS reporters publicly known (e.g., eBay Amazon).

13

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

Now, case agents view EQOS reports agents
truthful, trust agent agent j able complete task may depend
true reported types agents; case could relax incentive compatibility
requirement dominant strategy (ex-post) Nash equilibrium (MasColell et al., 1995),
means agents report truthfully, optimal agent always report
true type, matter true types agents are. replacing new trust function
definition expected payment agent i, definition incentive compatibility would
change to:
Definition 8. Incentive compatibility (in Nash Equilibrium): allocation mechanism said
achieve incentive compatibility (ex-post) Nash equilibrium agents true type optimal
report provided agents report type truthfully. is: ci , b
ci , , b
, ci , ,
b , ; c, ) ci (K(b
Eri (ci , ci , , ; c, ) ci (K(ci , ci )) Eri (b
ci , ci ,
ci , ci ))

next demonstrate Porter et al.s mechanism would work setting extending
example 1.
3.3.1 FAILURE P ORTER ET.

AL

ECHANISM

Example 5. Two agents costs performing task requested centre formed
perceptions set agents given Table 2. Suppose tr0i () = [1i ( ) + 2i ( )]/2,
v0 ( ) = 1.
Agent
1
2

tr0 ()

ci ( )
0
0

i1 ( )
0.6
0.8
0.7

i2 ( )
1
0.6
0.8

Table 2: Costs EQOS reports agents single task scenario. trust requester calculated
assuming truthful reports.

Porter et al. specify procedure deals EQOS reports. However, natural
) instead pbi ( ), ignore
extension technique would allocate according tr0i (b
reports agent computation payment. implement example.
Agent 2 winner since generates expected social utility 0.8, agent 1 would
generate utility 0.7. expected utility agent allocated task (according
Equation (8)):
b ) ci (K (b
b )) max
b ) = v0 (K (b
b )) tr0i ( ,
c,
ui (b
c,
c,


K Ki

h



) b
cj (K )
v0 (K ) tr0j (b

(10)
b excludes reports agent i, Ki set allocations excluding agent i,

j agent allocated task allocation K . Unfortunately, extension breaks
incentive compatibility following way. Given efficient allocation computed using
b values agents (using tr0 (b
b Equation (6)), value best
reported
) instead p
14

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

allocation obtained removing one agent could arbitrarily lower. example above, agent
1 reports 12 = 0, efficient allocation becomes agent 1 expected social utility 0.7
agent 1 gets expected utility 0.1 systems utility drops 0.6 reports
removed allocation recomputed. agent 1 truthful obtain 0 utility since agent 2
would winner case. effect, removal agent system breaks
mechanism interdependence valuations introduced trust model.
elaborate issue show solve next section.
thus need develop mechanism incentive-compatible agents reporting
perceptions agents POS. order so, however, need additionally
consider effect reporting EQOS vector agents expected utility. Specifically,
need develop trust-based mechanism EQOS reports agent provide
way increasing overall expected utility (as per intuition behind VCG). Then,
true value EQOS, mechanism result selection optimal allocation
tasks.
3.3.2 INGLE R EQUESTER INGLE TASK RUST-BASED ECHANISM
Intuitively, following mechanism works ascertaining agent derives positive utility
successfully completes task EQOS report change allocation
favour (thus, mechanism develop regarded generalisation paper Porter
et al., 2008).
detail, let i(K) agent performing task allocation K; centre first
determines allocation according to:
#
X
i(K)
b ) = arg max v0 (K) tr0 (b
K (b
c,
)
b
ci (K)
KK

"

(11)

iI

computed efficient allocation above, adopt similar approach Porter et
al.s compute payments tasks executed (see section 3.2.2). However,
novelty mechanism lies use agents EQOS reports computation
efficient allocation (as showed above). Moreover, additional payments losers
incentivise agents select efficient allocation.
Thus, apply different payments cases agent winning allocation succeeds
(i.e., = 1) fails (i.e., = 0). agent allocated task (i.e., K = { i0 })
payment is:

b , ) =
ri (b
c,


b )) Bi (b
b ) , = 1
c,
ci ,
v0 (K (b


b )
Bi (b
ci ,

(12)

, = 0

Bi () 0 term independent report (a constant point view)
reduces payment needs made agent. briefly discuss value Bi ()
could set reduce payout made centre later section, provide greater
detail section 4.4.
addition paying winner, reward losers k \ following way,
depending whether succeeds not:
15

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

b , ) =
rk (b
c,


b )) b
b )) Bk (b
b k ) , = 1
c,
ci (K (b
c,
ck ,
v0 (K (b


b )) Bk (b
b k )
b
ci (K (b
c,
ck ,

(13)

, = 0

Intuitively, payment scheme aims incentivise agents reveal type
efficient allocation chosen. Let K0i allocation assigning task agent i. Suppose
b ) agents report (b
b ).
agent type (ci , ) reports type (b
ci ,
ci ,
agent wins task, derive following expected utility:




b = v0 K0i tr0i ,
b ci K0i Bi (b
b )
ui K0i , ,
ci ,
(14)

b reflects true POS agent i. agent k 6= assigned task,
Note tr0i ,
agent obtains following expected utility participating mechanism:





b = v0 K0k tr0k ,
b b
b )
ui K0k , ,
ck K0k Bi (b
ci ,
(15)

difference Equations (14) (15) identity winner. Hence,
falsely reporting, agent influence identity winner. Agent expected utility
mechanism equal expected social utility system minus constant independent
report. Hence, agent rational report true type, efficient agent
(outcome) chosen. shows single task trust-based mechanism incentive compatible
efficient.3
Proposition 1. mechanism described Equations (11), (12), (13) incentive compatible.
Proposition 2. mechanism described Equations (11), (12), (13) efficient.

Proof. Since agent ks report k affects expected utility agents (see Equations
(14) (15)), interdependence agents payoffs, valuations. However, agent
influence transfer report, computation agent payment
b (and b
independent report
ci ) dependent actual execution task
therefore true value. feature permits implementation efficient
allocation single-stage mechanism.
exemplify payments mechanism, consider following extension Example 5.
Example 6. Two agents zero cost performing task requested centre
EQOS ij ( ) {0.6, 0.7, 0.8} i, j = 1, 2. Suppose tr0i () = [1i ( ) + 2i ( )]/2,
v0 ( ) = 1.
setting Bi = 0.6 example, payment agent
task completed successfully 0.4, payment task fails 0.6. Hence,
centre profits implementing mechanism. Agents incentive report truthfully,
agent likely succeed allocated task. Furthermore, agents willing
participate, probability success least 0.6 (it 0.6 worst case scenario)
3. provide detailed proof generalised case Section 4.3.

16

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

hence, agents expect obtain least zero participating: mechanism individually rational. note total expected payment centre agents
0.8 0.4 2 0.2 0.6 2 = 0.4, could low 0.6 0.4 2 0.4 0.6 2 = 0.
show, Bi always chosen individual rationality satisfied.
Proposition 3. appropriate choice Bi (), mechanism described Equations (11),
(12), (13) individually rational.
Proof. participating mechanism, agent obtain 0 utility. However,
agent decides participate, virtue selection efficient allocation (which returns
allocation social welfare generated less 0), guaranteed, winner, obtain
utility ui described Equation (14) or, loser, utility uk Equation (15). Since
cases ui Bi () efficient allocation chosen, Bi set 0, mechanism
individually rational.
Obviously, since agents utilities tied winning agent, lose
winning agent fails but, expectation, agents make profit least 0 case Bi set
0. Example 6 shows, centre trying minimise payments (and increase profits),
could set Bi greater zero still satisfy individual rationality. Section 4.4,
show set Bi value maintains individual rationality minimising payments
general model.
note sometimes may preferable centre give individual rationality.
Consider, example, modify Example 6 allow additional EQOS value ij ( ) = 0.3
i, j = 1, 2. induce type ij ( ) = 0.3 participate, centre could set Bi () = 0.3,
payment following success 0.7 payment failure 0.3. worst
case scenario centre (i.e., centres profit lowest), total expected payment
mechanism 0.8 0.7 2 0.2 0.3 2 = 1 (in best case scenario, total
expected payment zero). shall see Section 4.4, centre could substantially reduce
payments making Bi () depend report agents (i.e., i). Still,
may preferable centre set Bi () = 0.6, giving participation agents
EQOS values ii ( ) = ij ( ) = 0.3. general, low EQOS types, centre faces
trade efficient task allocation payments minimisation. leave study
trade-off future work (see Section 6 initial thoughts).

4. Generalised Trust-Based Mechanism
mechanisms presented previous section dealt basic task allocation problem
one requester, one task, several performers. Here, aim efficiently solve
general problem trust-based interactions one agent requests
performs (or both) one task. end, extend single requester single task
setting general one multiple requesters multiple tasks Generalised TrustBased Mechanism (GTBM). extension needs consider number complex features
top dealt previously. First, need consider multiple requesters
make requests sets tasks task performers perform sets tasks well.
Thus, centre acts clearing house, determining allocation payments
17

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

multiple bids task requesters multiple asks task performers. significantly
complicates problem incentivising agents reveal types since make
sure agents reveal costs, valuations, EQOS truthfully one task.
Second, computation efficient allocation payments consider much larger
space previously. Thus, believe important show problem modelled,
implemented, solved demonstrate mechanism scales increasing numbers
agents tasks (the computability aspects dealt Section 5).
following example illustrates general setting.
Example 7. using trust-based mechanism months, MoviePictures.com made
significant profits expanded several independent business units, performing rendering
tasks rendering tasks performed certain clients. Now, MoviePictures.com would
find ways business units efficiently allocate tasks amongst themselves. However,
companies uncertainties others performance rendering tasks.
example, business units, HighDefFilms.com, believe PoorRender Ltd (now part
MoviePictures.com) inefficient, others, GoodFilms.com, believe bad,
recently large set animations rendered well cheap price. cater
differences opinion maximising overall utility, MoviePictures.com needs extend
single task trust-based mechanism implement generalised mechanism efficiently.
order deal complex setting, extend task allocation model next
subsection, describing allocation rule payment scheme Section 4.2 proving
economic properties mechanism Section 4.3.
4.1 Extended Task Allocation Setting
Let = {1 , 2 , ..., } denote set tasks requested performed (compared
single task before). use notation .i specify subset tasks
performed specifically agent i.4 Similarly, adding superscript task, i. K
denotes subset tasks agent performs. Note nothing model restricts
agent task performer requester.
selected allocation K multiple task, multiple requester model generates matching problem involves finding agents perform tasks requested
II }). Let set possible allocations
agents (e.g., K = {111 , 112 , . . . , 1I1I , . . . ,
denoted K. Note requested tasks need allocated: is, matching K need
perfect.
multiple task case, agents may express valuations costs sets tasks well
subsets sets tasks. example, agent may vi (1 , 2 , 3 ) = 100 vi (1 , 2 ) =
10 vi (3 ) = 0. Then, agent gets 1 , 2 3 executed gets value 100,
1 2 get executed 3 fails, agent still obtains value 10. Similarly, agent may
task execution costs ci (4 , 5 , 6 ) = 100 ci (4 , 5 ) = 40 ci (6 ) = 10. capture
inter-relationships valuations, let Kij set tasks within allocation K
performed agent j agent (Kij could empty set). Note task
specific task requester. means agents 1 2 request task , task performer
4. paper, consider agents requesting performance multiple units tasks. Although model
easily extensible case, explanation much intricate.

18

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

(putting one bid ) matched agent 1, performs agent 1 agent
2. abuse notation slightly define K = {Ki , K }iI Ki = (Ki1 , ..., KiI )
K = (K1i , ..., KIi ). agent value (assuming tasks K completed) cost
allocation K, vi (K) + {0} ci (K) + {0} respectively, whereby:5
vi (K) = vi (Ki )
ci (K) = ci (K )
Kh K

Moreover, within model, agent EQOS vector, = {ij (Kh )}j,hI
represents belief successful agents within system completing tasks Kh
agent h. Thus, general level, agent type given = {v , ci , }.
j
e j K j EQOS
given set tasks Ki
thatfij mustperform i, subset tasks K


e j completed
e j fifi K j , trust exactly set tasks K
vector , let trj K








j. trust computed shown Section 3.3 simply replacing agent 0
agent replacing single task set tasks . single requester case, trust
function represents aggregate belief agents given task performer hence
task requesters form probability
(give agents EQOS reports) given

success
Q j e j fifi j

e
tri Ki Ki , .
task performer. Finally, let tri Ki Ki , =
jI

ready present generalised trust-based mechanism.

4.2 Allocation Rule Payment Scheme
generalised mechanism (GTBM), task requesters first provide centre list
tasks require performed, along valuation vector associated set
tasks, whereas task performers provide costs performing sets tasks.6 agents
submit EQOS vector centre. Thus, agent provides centre reports
bi = {b
b = (
b1 , ...,
bI ) report profile. Given this, centre applies
b },

vi, b
ci ,
rules mechanism order find allocation K net payments ri agent i.
detail:
1. centre computes allocation according following:

b =
K

arg max

X

K={Ki ,K }iI K iI




X

e Ki
K

e ) tri
vbi (K






e fifi Ki ,
b b
ci (K)
K

(16)

Thus, centre uses reports agents order find allocation maximises
expected utility agents within system.

b .
2. agents carry tasks allocated allocation vector K

5. result setup, agent may want sets tasks performed may unable perform
tasks. cases, assign default value 0 cost sets tasks.
6. noted before, task performers task requesters time (and vice versa).

19

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

3. centre computes payments agents, conditional completion tasks allocated. Let (Ki ) indicator function takes value one Ki set
tasks (requested agent agents) completed, takes value zero
otherwise. payment agent follows:

ri





X
b () =
,

jI\i

X

e j K (b)
K
j









ej b
ej K
cj
vbj K





b
bi )
K
Bi (

(17)

bi ) 0 constant point view (i.e., computed independently
Bi (
agent reports, may depend reports agents), used
reduce payout centre make.
discussed Section 3.3.2, centre faces trade-off. reducing value Bi ()
induces participation larger set types (i.e., types low EQOS), increases
centres payments agents, making mechanism less profitable centre. Thus,
scale payments one might expect application GTBM depends whether
centre decides satisfy individual rationality constraint, thus making sure every
type wants participate. shall see Section 4.4, centre decides satisfy
individual rationality constraint, scale payments agent increases lower
bound trust values could derived using EQOS report.
noted computation payments requires solving several optimisation problems (i.e., finding optimal allocation without several reports).
number agents increases, difficulty computing payments increase
important show payments efficiently computed. elaborate
solution Section 5. so, however, detail prove economic
properties mechanism follows.
4.3 Economic Properties
Here, provide proofs incentive compatibility7 efficiency mechanism.
prove values Bi make mechanism individually rational.
Proposition 4. GTBM incentive compatible.
Proof. order prove incentive-compatibility, analyse agent best response ( i.e.,
bi = {b
bi . first calculate expected
b } )) agents report
best report
vi, b
ci ,
utility agent derive given mechanism.
7. Again, place caveat notion incentive compatibility use Section 3.3 (i.e.,
Dominant Strategy (ex-post) Nash equilibrium depending whether agent computes trust functions
using agents POS reports true not).

20

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

by:

b true types given
expected utility agent reported types


b =
ui ;

X



b b
e K
K
,










bi ,
bi , ,
e |Ki
e ) tri K
b
vi (K



bi ,
bi
ci K





b
+ Eri ;



(18)

Eri expectation ri taken respect likelihood task completion.
e j ) equal one (i.e., tasks K
e j
probability attached indicator variable (K
completed), given
set
tasks requested j Kj agents different report

b
e
b . Hence, use formula payments obtain:
, trj Kj Kj , ,






bi ,
bi , ,
e j fifi Kj
e j trj K
b
vbj K





X

Ke j K b ,b
bi )
b
Eri ; =
j
Bi (






jI\i
bi ,
bi
b
cj K
(19)
replace expression formula ui observe agent
b key point note agent computes
affect utility report changing K ().
b ).
value trust function using true value ( rather reported value
Now, Equation (16) implies allocations K:




bi ,
bi ; ,
bi ; ui
(20)
ui ,


X

efficient allocation, computed taking account true type reported
bi better equal allocation.
types agents
Given condition since Equation (20) applies possible realisations ,
mechanism incentive compatible.
Proposition 5. GTBM efficient.

Proof. Given incentive compatibility mechanism, centre receive truthful reports
agents. result, compute allocation according Equation (16), thereby
leading efficient outcome.
Proposition 6. exist values Bi () GTBM individually rational.
Proof. begin making standard assumption agent derives ui = 0,
participating mechanism. Then, remains shown agent derives non-negative
utility mechanism. Since efficient allocation chosen (and worst null allocation),
expected utility agent always greater equal Bi () according Equation
(18). Since Bi () set 0, mechanism individually rational.
Note possibly many values Bi ( ), besides Bi = 0, guarantee individual
rationality.
21

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

Speaking generally, easily seen GTBM mechanism multiple task,
multiple requester scenario generalisation GTBM mechanism single requester
single task. generalisation mechanism Porter et al. simply assume
agent EQOS probability success. Moreover, paper
Porter et al. example, Bi specified follows:


X

bi ) = max v0 (K ) pbi ( )
Bi (
b
c
(K
)
j

K Ki

jI\i

pbi ( ) reported probability completion agent assigned task allocation
K Ki set allocations excluding agent i.
4.4 Extracting Minimum Marginal Contribution

now, considered Bi ( ) could set arbitrary values try reduce
payments made centre agents. interestingly, possible,
standard VCG mechanism, pay agent marginal contribution system.
However, case, due interdependence valuations, simple comparing
social welfare without given agent system commonly done VCG-based
mechanisms (Porter et al., 2008 obvious example this). because, case,
agent removed domain used compute efficient allocation, remaining EQOS
reports arbitrarily change allocation value. could, turn, exploited agents
improve utility. example Section 3.3.1 showing failure simple extension
Porter et al.s mechanism illustrates point.
Assuming centre wants induce participation agent types, propose
novel approach extracting marginal contribution agent, taking account EQOS
reports agents possible reports agent could make. Let Ki set possible
allocations agent excluded society. value Bi () chosen
equivalent social utility mechanism agent excluded EQOS reports
chosen minimise social utility, is:





X
X
bi ) =
e j fifi Kj , ,
e j trj K

b b
cj (K) (21)
Bi (
min
max
vbj K
|I||T
|
KKi
[0,1]
jI\i e
Kj Kj

noted Bi computed using lowest trust values could derived using
EQOS reports.
Then, generalised payment scheme is:







X X
b
b (.) =
ej b
ej K

K

c
K
v
b
ri ,
j
j



b
jI\i K
e j K
j





X
X
e j fifi Kj , ,
e j trj K

b b
cj (K)
vbj K

min
max
[0,1]|I||T | KKi jI\i e
Kj Kj

(22)

22

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

point note incentive compatibility (and hence efficiency mechanism)
still holds given payment scheme still independent reports. fact, ri rewards
maximum difference agent could make setting elements different values
[0, 1]|I||T | .8
procedure reduces payments made centre, keeping individual rationality
since value efficient allocation (given incentive compatibility proven earlier) always
higher equal value Bi , means that:
ui (K (), ) =



X

jI



X

e j K ( )
K
j





e j trj
vj K
X








e j fifi Kj () , cj (K ())
K



min
max
[0,1]|I||T | KKi jI\i e

X

Kj Kj





e j trj
vj K







e j Kj , , cj (K) 0;
K

noted equation implies restriction placed
functional form trust function tr payment scheme work properties
mechanism hold. improvement previous mechanisms (see Section 2)
considered trust functions monotonically increasing i.
Now, choice Bi determines whether centre runs mechanism profit not.
Hence, understand scale payments may GTBM discussed section,
consider following example.
Example 8. n agents, = {1, ..., n}, requiring single task performed
them. agents value 1 task performed zero cost
performing tasks. EQOS agent h agent probability succeeding
task
P



agent j h (Kj ) [x, 1] h, i, j = 1, ..., n. Suppose trj () =
hI h (Kj ) /n.

example, EQOS agent interval [x, 1], x viewed
lower bound expected probability success task. Equation (21)
compute value Bi :
"P
#
(K ) + x
X

j
hI\i h
Bi ( ) =
max

n
jI\i

Note that, depending value , Bi ( ) could value (n 1)x
(n 1)(n 1 + x)/n; Bi increases lower bound x agents EQOS. actual payment
agent depend success failure task (e.g., payment Bi tasks
fail). Equation (19), calculate value expected payment agent as:
"
#
X (Kj )
X
h
Eri () =
max
Bi ( )

n
hI
jI\i
"
#
X (j) x


n
jI\i

8. minimisation takes place domain trust values could [0, 1] general case.

23

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

(j) agent allocated task agent j efficient allocation rule. Let EV
total expected value tasks:
"P
#
(j)
X
iI
EV () =
n
jI

Note total expected value tasks greater sum expected payments
agents, is:

" (j)
#
#
"P
(j)
X
X
X

x
iI

>
n
n
jI

iI

jI\i

Thus, centre always profits mechanism. lower bound difference total
P
(i)
+ (n 1)x]/n. Note lower
expected value total expected payments [ iI
bound centres profit mechanism increases lower bound EQOS x.
pointed discussion Example 6 Section 3.3.2, centre trying minimise payments, could give individual rationality, increasing Bi , cost inducing
agent types participate mechanism. may appealing probability
task failure high; cases, centre may prefer avoid paying amount almost large
total value tasks. hand, number practical applications centre
may want use mechanism induces participation types, described section.
certainly case, example, lower bound EQOS (i.e., lower bound
probability tasks successful) high. Moreover, mechanism participation
types appropriate centre mainly seeks maximise social welfare. Consider, example, government trying boost economy major public infrastructure projects.
order so, may willing invest trust-based mechanism get best infrastructures built cheapest cost. Moreover, government may willing make low profit
order ensure survivability construction companies guaranteeing payoff
participate mechanism. Another example company might want involve
task performers would company trying acquire much information possible
task performers order maximise returns future decisions. Following running scenario, say MovePictures.com needs contract video editing company add computer
graphics movie may become blockbuster graphics well done. case task
successful, MoviePictures.com likely get many contracts future. therefore critical
available information collected agents order choose reliable video
editing company. case, MoviePictures.com may accept smaller short-run profit running
mechanism full participation, order guarantee selected agent best one
future contracts obtained.
summarise, section devised mechanism incentive compatible, individually rational efficient task allocation uncertainty multiple distributed reports
used order judge uncertainty. noted need two-stage mechanisms, work Mezzetti (2004), settings condition payments
completion tasks (the indicator function () captures dependence payments task
completion). far, considered economic properties mechanisms,
argued earlier, part picture. next section, report implementation.
24

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

5. Implementing Generalised Trust-Based Mechanism
shown above, addition trust basic task allocation problem complicates
payment scheme, requires larger number important optimisation steps normal
VCG. detail, trust-based mechanisms require agents specify expected value set
tasks depending performer tasks which, turn, means space solutions
explored significantly larger common task allocation problems. Moreover, payment
scheme trust-based mechanisms requires finding efficient allocation multiple times
without agents reports. added level complexity, important show
mechanisms actually implementable solutions found usefully sized problems
reasonable time.9
background, section describe first formulation implementation GTBM. particular, GTBM, tackle main optimisation problem posed
Equation (16) (which repeated several times payment scheme). commonly
referred winner determination problem combinatorial auctions. order solve it,
take insight solutions combinatorial exchanges often map problem well
studied matching problem (Kalagnanam & Parkes, 2004; Engel, Wellman, & Lochner, 2006).
doing, develop novel representation optimisation problem using hypergraphs
describe relationships valuations, trust, bids task performers cast
problem special hypergraph matching problem. Given representation, able
solve problem using Integer Programming techniques concise formulation
objective function constraints.
5.1 Representing Search Space
important define search space way relationships valuations, bids,
trust, tasks clearly concisely captured. particular, representation aims map
GTBM optimisation problem matching problem well studied literature.
this, representation must allow us define whole space feasible task allocations,
and, subsequently, define select valid solutions GTBM optimisation problem.
Now, allow bidders (task performers) askers (task requesters) express bids valuations consistent implementable way, choose XOR bidding language. bidding
language requires auctioneer accept one bid XOR bid
XOR bid belong one agent. choose particular bidding language
shown valuation expressed using (Nisan, 2006).10 example XOR
bid context would {ci (1 , 2 ) XOR ci (1 , 3 ) XOR ci (1 , 2 , 3 )} means agent
would go one three bids tasks 1 , 2 3 (ci could replaced
vi task requesters). terms running example, bid would express PoorRender
Ltds cost performing sound editing task (i.e., 1 ), movie production task (i.e., 2 ),
combination (i.e., 1 , 2 ).
9. already known computing efficient allocation payments VCG mechanisms NP-hard (Sandholm,
Suri, Gilpin, & Levine, 2002). Therefore, finding efficient solutions VCG mechanisms already significant
challenge right.
10. bidding languages (such describing Atomic bids, Nisan, 2006) could equally well used
model would require minor changes constraints need apply.

25

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS


"
V
H











+




$


(

%


)

'

&

"#"


(
(

!

H


!"
C


$

%



(
)

&


(*

'




Figure 1: Graphical representation GTBM search space. Nodes colour represent valuation
cost nodes belong agent (here nodes v1 belong agent 1 c4 belong
agent 4). Edges colour either originate node end node.

build overall representation problem, first focus representing expected valuations costs well relationships. depicted Figure 1. detail,
specify three types nodes: (1) valuations (along V column); (2) bids (under C column);
(3) task-per-bidder nodes (under column). node vi ( ) V column stands
valuation submitted agent set tasks . node cj ( ) C column stands
j.
bid issued agent j tasks . element represents allocation

single task task performer (bidder) j task requester yet determined (represented dot). words, elements represent patterns single-task allocations.
term elements task-per-bidder nodes.
Note possible different valuations come requester.
labelled subscript. Moreover, since opted XOR bidding language,
valuations belonging requester mutually exclusive.
26

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

5.1.1 EFINING R ELATIONSHIPS



VALUATIONS , TASKS ,



B IDS

j.
node vi (..., , ...) V
Given nodes defined A, V, C, relating node
define assignment task j specific valuation vi (..., , ...). Similarly,
j.
node cj (..., , ...) C define assignment task
relating node
j.
j.
specific bid cj (..., , ...) agent j. Therefore, triple (v,
, c) v V,
A, c C
fully characterises allocation task , namely single-task allocation. Hence, seen
Figure 1, define two types relationships: valuations task-per-bidder nodes
(noted edges e1 , e2 , ...), bids task-per-bidder nodes (noted edges e1 , e2 , ...).11
Using relationships, valuation related set task-per-bidder nodes
fully cover performance task(s) valuation. instance, relate
v1 (1 , 2 ) nodes 14. (agent 4 performs task 1 ) 22. (agent 2 performs task 2 )
guarantee performance tasks 1 2 . Similar valuation relationships, node C
related set task-per-bidder nodes bid splits. Thus, Figure 1,
bid c4 (1 ) related 14. , whereas bid c2 (2 , 3 ) related nodes 22. 32. .
Thus, identify task performers task given valuation. critical since
GTBM, contrary common task allocation mechanisms (such VCG Mth price auctions),
requires identify exactly performs task order determine POS task (by
virtue requesters trust performer) hence expected value task.
seen, representation allows us capture tasks performers tasks
since valuation node V potentially related multiple nodes A; and, likewise,
bid C column potentially related multiple nodes A. capture related relationships precisely, define special edges connect several nodes (e.g., ones depicted
e1 , e2 , ,e1 , e2 ,... Figure 1). edges termed hyperedges combine number
singleton edges. Hence, Figure 1 best described hypergraph (Berge, 1973). order
precisely define matching problem GTBM poses, elaborate formalism
hypergraphs since help concisely expressing problem later on. specifically,
formal notion hypergraphs, introduced paper Berge (1973), is:

Definition 9. Hypergraph. Let X = {x1 , x2 , . . . , xn } finite set n elements, let E =
{ej |j J} family subsets X J = {1, 2, ...}. family E said hypergraph
X if:
1. ej 6= (j J)
2. jJ ej = X.
pair H = (X, E) called hypergraph. elements x1 , x2 , . . . , xn called vertices
sets e1 , e2 , . . . , ej called hyperedges.
say hypergraph weighted associate hyperedge e E real number,
w(e), called weight e. used give less importance edges.
formal definition hypergraphs, observe Figure 1 results overlapping two separate hypergraphs: (i) valuation hypergraph occurs linking valuations
11. Figure 1 depicts sample possible relationships ease illustration.

27

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

task-per-bidder nodes; (ii) bid hypergraph occurs linking bid corresponding task-per-bidder nodes. follows, formally define hypergraphs valuations bids later structurally characterise notions feasible optimal
allocations.
5.1.2 VALUATION H YPERGRAPH
valuation hypergraph highlights main difference GTBM common combinatorial exchanges (e.g., based traditional VCG Mth -price auctions). particular,
GTBM valuations need take account trust task requester task performer
while, normal combinatorial exchanges, task requesters indifferent task performers.
means weight hyperedge valuation hypergraph dependent trust large
number edges need generated (one per task performer) case normal
combinatorial exchanges.
define valuation hypergraph, need define hyperedges emanate node
V one nodes A. end, let V = {vi ( ) 6= 0| , I} C = {cj ( ) 6=
| , j I} sets valuations bids respectively. Let j. = { |
: cj ( ) 6= } set tasks agent j submits bids. Hence,
= {kj. |k j. , j I, cj ( ) C} set containing tasks bid bidder.12
Furthermore, need define auxiliary sets follows. Given valuation set
tasks , set nodes fulfils if:
[

{kj. } = | | = |A|

kj.

instance, set nodes = {14. , 22. } fulfils valuation {1 , 2 }. Hence,
subsets fulfil valuation set tasks expressed using defined as:
[
= {A |
{kj. } = | | = |A|}
kj.

instance, considering example Figure 1,
A{1 ,2 } = {{14. , 24. }, {14. , 22. }, {14. , 25. }}
A{1 ,3 } = {{14. , 34. }, {14. , 32. }}
Given definitions, define set hyperedges connected valuation
vi ( ) V as:
Eiv ( ) = aA {{vi ( )} a}
instance, Figure 1:
E1v (1 , 2 ) = {e1 , e2 , e3 } E1v (3 ) = {e4 , e5 },
e1 = {v1 (1 , 2 ), 14. , 24. }, e2 = {v1 (1 , 2 ), 14. , 22. }, . . . , on.
12. Recall since mechanism proven incentive-compatible use agents true valuations
costs instead reported counterparts.

28

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

set hyperedges containing valuations agent defined as:
[
Eiv =
Eiv ( )

Then, set hyperedges connecting nodes V nodes defined as:
[
Ev =
Eiv
iI

Given this, define valuation hypergraph pair:
Hv = (V A, E v )
Thus, hyperedge Hv consists single valuation vertex corresponding element V
along complete task allocation valued tasks task-per-bidder nodes A.
valuation hypergraph Hv partly defines space within solution needs found.
However, order define quality solution found, important define weight
attached hyperedge hypergraph Hv . weight hyperedge actually equal
expected value allocation tasks set task performers (bidders). Consider,
instance, valuation v1 (1 , 2 ). possible matchings fulfil represented
pairs (1.1 , 2.1 ). example, hyperedge e2 involving pairing (141 , 221 ) denotes
agent 4 performs task 1 agent 1 agent 2 performs task 2 agent 1. expected valuation
associated allocation depends POS agents 4 2 performing tasks 1 2
respectively.
case, expected valuation associated e2 assessed as:
v 1 (141 , 221 ) = v1 (1 , 2 ) p4 (141 ) p2 (221 )+
v1 (1 ) p4 (141 ) (1 p2 (221 ))+
v1 (2 ) (1

p4 (141 ))



(23)

p2 (221 )

p function returns POS agent assigned given task (computed using
confidence, reputation, trust). Notice value (1 pi (kij )) represents probability
agent failing perform task k agent j. Since requests submitted 1 2 alone,
v(1 ) = v(2 ) = 0. Thus, expected valuation associated particular allocation represented
arc e2 becomes v 1 (141 , 221 ) = v1 (1 , 2 ) p4 (141 ) p2 (221 ). similar argument,
obtain v 1 (141 , 251 ) = v1 (1 , 2 ) p4 (141 ) p5 (251 ) 6= v 1 (141 , 221 ), corresponding
hyperedge e3 .
Generalising, given hyperedge e E v valuation vi ( ), readily build allocation
tasks elements e vi ( ). p function returns POS (be
confidence, reputation, trust) given task performer requesters point view,
compute expected valuation allocation defined hyperedge e follows:


X




v ( ) =
pj (lji )
1 pj (wji )
(24)
vi ( )

lj. e,l
lj. e,w \
29

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

words, given hyperedge e E v , weight assessed using Equation (24)
equivalent expected value computed Equation (16) (i.e., sum expected values
allocations agent i). Now, given edge valuation hypergraph assigned
weight, Hv termed weighted hypergraph.
5.1.3 B ID H YPERGRAPH
define bid hypergraph need determine hyperedges connect bids task-perbidder nodes. detail, given bid cj ( ) C, relate task-per-bidder nodes
constructing hyperedge Ejc ( ) = {cj ( )} {kj. |k }. hyperedge assigned weight
equal cost cj ( ). set hyperedges containing bids agent
defined as:
[
Eic =
Eci ( )

Given this, set hyperedges connecting nodes C nodes defined as:
[
Ec =
Eic
iI

Finally, define bid hypergraph pair:
Hc = (A C, E c )
words, hyperedge Hc consists single bid vertex corresponding element
C along corresponding task-per-bidder nodes A. Notice definitions valuation
bid hypergraphs ensure hyperedge H v contains single valuation V
hyperedge H c contains single bid C.
5.1.4 EFINING ATCHING P ROBLEM GTBM
defined valuation bid hypergraphs, structurally characterise notions
feasible optimal allocations (these needed determine computational complexity
problem define objective function particular). purpose, must firstly recall
notions hypergraph theory. hypergraph, two hyperedges said adjacent
intersection empty. Otherwise said disjoint. hypergraph H = (X, E),
family E E defined matching hyperedges E pairwise disjoint. respect
given matching E , vertex xi said matched covered hyperedge E
incident xi . vertex matched, said unmatched exposed. matching
leaves vertices exposed said complete.
Based definitions above, characterise feasible allocations GTBM follows.
First, must find matching valuation hypergraph necessarily complete (some
valuations may remain exposed). Second, must find another matching bid hypergraph
necessarily complete either. two matchings must related following manner:
task-per-bidder nodes matchings same. words, given task-perbidder node, must related valuation node bid node, else excluded
matchings. way, valuations bids linked create single-task allocations.
instance, Figure 1, e2 belongs matching valuation hypergraph, e4 must
30

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

part matching bid hypergraph ensure bid 22. either
e1 , e2 , e3 part matching bid hypergraph ensure bid 14. .
formally:




Definition 10. Feasible allocation. say pair (E v , E c ) defines feasible allocation iff:


E v matching Hv .


E c matching Hc .




A: ( matched E v ) ( matched E c ).




Given feasible allocation (E v , E c ) defined above, straightforward assess expected utility agents within system follows:
X

eE v

w(e)



X

w(e )


e E c

since weights hyperedges valuation hypergraph stand expected valuations
weights hyperedges bid hypergraph stand costs. Solving Equation (16)
GTBM amounts finding feasible allocation maximises expected utility agents
within system. Therefore, following definition naturally follows.
Definition 11. GTBM Task Allocation Problem problem assessing task allocation
maximises expected utility agents within system amounts solving:
arg max
(E


v


,E c )

X

eE

wv (e)

X

wc (e )

(25)


e E c

v



(E v , E c ) stands feasible allocation.
defined matching problem GTBM, next describe solution
problem using Integer Programming techniques commonly used solve problems
(Cerquides, Endriss, Giovannucci, & Rodrguez-Aguilar, 2007).13
5.2 Integer Programming Solution
section show map problem posed Equation (25) integer program
(Papadimitriou & Steiglitz, 1982) efficiently implemented solved. Given
translation, resulting program solved powerful commercial solvers ILOG
CPLEX14 LINGO.15
13. special purpose algorithms (e.g., using dynamic programming search trees) could designed solve
combinatorial problem. However, understand magnitude problem compare difficulty
solving problem similar problems, believe better first attempt find solution using
standard techniques IP.
14. http://www.ilog.com
15. http://www.lindo.com

31

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

5.2.1 BJECTIVE F UNCTION



IDE C ONSTRAINTS

translation Equation (25) IP reasonably straightforward given representation.
Thus, solving GTBM task allocation problem amounts maximising following objective
function:
X

xe wv (e)

X

ye wc (e )

(26)

e E c

eE v

xe {0, 1} binary decision variable representing whether valuation hyperedge
e selected not, ye {0, 1} binary decision variable representing whether bid
hyperedge e selected not. Thus, xe decision variable selects given valuation
given task-bidder matching, ye selects given bid.
However, side constraints must fulfilled order obtain valid solution. First,
semantics bidding language must satisfied. Second, hyperedge containing set taskper-bidder nodes selected, must ensure bids covering nodes selected too.
Moreover, employ XOR bidding language, auctioneer centre case
select one bid per bidder one valuation per asker. Thus, bidders,
constraint translates into:
X
ye 1
(27)
e Eic

instance, Figure 1 constraint ensures auctioneer selects one hyperedge e1 , e2 ,
e3 , since belong agent 4 (they come nodes labelled subscript
c4 (.)).
valuations, XOR constraints involving collected following expression:
X
xe 1
(28)
eEiv

instance, Figure 1 constraint forces auctioneer select one hyperedge e1 , e2 ,
e3 , e4 , e5 since belong agent 1 (they come nodes labelled
subscript v1 (.)).
valuation hyperedge e E v selected, set task-per-bidder nodes connected
e must performed corresponding bidder agent. instance, Figure 1, hyperedge
e5 selected, task-per-bidder nodes 141 341 must covered bid agent 4.
case, bid c4 (1 , 3 ) one covering tasks. Thus, select hyperedge e5
forced select bid c4 (1 , 3 ) selecting hyperedge e3 . Thus, terms hyperedges, must
ensure number valuation hyperarcs containing given task-per-bidder node less
equal number bid hyperarcs containing it. Graphically, means number
incident valuation hyperedges given node must less number incident bid
hyperedges a.
X

eE v ,kj. e

xe

X

ye

kj.

(29)

e E c ,kj. e

case free-disposal (i.e., allow agents execute tasks without asked
for) simply replace =. summarise, solving GTBM task allocation problem
32

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

amounts maximising objective function defined expression (26) subject constraints
expressions (27), (28), (29). Next, determine complexity results problem.
5.2.2 C OMPLEXITY R ESULTS
represented GTBM task allocation problem defined corresponding IP formulation, analyse computational complexity order show difficulty solving GTBM.
identify main parameters affect computational costs finding optimal allocation. parameters allow us determine settings GTBM
practically used.
Proposition 7. GTBM task allocation problem N P-complete cannot approximated
ratio n1 polynomial time unless P = ZPP, n total number bids
valuations.
Proof. Notice optimisation model, formalised Equation (26), naturally translates
combinatorial exchange (Kalagnanam, Davenport, & Lee, 2000). translation achieved
using representation taking goods (in combinatorial exchange) dummy tasks
, bids elements C, asks weights hyperedges Hv . Thus,
bids remain exchange, number valuations may significantly increase.
reason introduction trust theoretical model makes initial valuations (asks),
elements V, allocation-dependent. Hence, every single valuation V causes several asks
originated exchange considering bidder task may allocated
(see examples Section 5.1.2). shown Sandholm et al. (2002), decision problem
binary single-unit combinatorial exchange winner determination problem N P-complete
optimisation problem cannot approximated ratio n1 polynomial time unless P = ZPP,
n number bids. Therefore, optimisation problem N P-hard,
GTBM.
proof, understood search space GTBM task allocation
problem significantly larger traditional combinatorial exchanges dependency valuations bidders performing tasks. follows, provide formula
allows us calculate exactly big search space is. allows us determine whether
instance solved actually handled solver (which limits
memory requirements computation time).
detail, say Ak subset containing task-per-bidder nodes referring
tasks. formally, Ak = {kj. | j I}. example Figure 1,
A2 = {24. , 22. , 25. }. Thus, expression assess number feasible allocations is:
|E v | =

X X



|Ak |

(30)

iI vi ( )6=0 k

Observe number possible allocations computed cardinality E v (i.e.,
number valuation hyperarcs) since exactly determines number ways valuations
satisfied provided bids. total number decision variables Integer Program
thus |E v | + |E c |. Since number expected valuations several times larger number
bids, expect number decision variables associated bid hyperedges much less
33

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

number valuation hyperedges. Hence, assuming |E c | |E v |, number decision
variables order |E v |.
order understand implications parameters, consider case task
performers bid tasks requesters submit single valuation tasks. Specifically,
consider scenario 15 task performers, 20 requesters, 5 tasks. Given case
|Ak = 5|, number allocations |Ev | = 20 155 = 15187500. reality, agents may
able submit bids asks tasks would result significantly lower number
allocations (given possible matchings). Hence, see whether instances practically
solved, Appendix A, report running times solver, showing instances less
2 105 variables comfortably solved within 40 seconds (in worst case). taken
together, empirical results formula compute size input (i.e., Equation 30)
allow us affirm that, even computational cost associated GTBM potential
rather high, solution handle small medium sized problems reasonable time (see
table 3). However, seen, time complete grows exponentially number
Set
1
2
3

Tasks
5
8
10

Task Requesters
20
20
20

Task Performers
15
15
15

Worst Case Running Time
34
40 mins
3 days

Table 3: Average running times different numbers tasks agents (taken 300 sample runs set
1, 50 sample runs sets 2 3).

tasks. experimental analysis, found impact increasing number
task performers task requesters significant increasing number tasks.
explained fact that, given setup, larger number tasks allows significantly
matchings bids asks larger number bids asks. Hence, many task
requesters performers accommodated small numbers tasks. noted
expect worst case results occur fairly rarely average (much less half
instances generated parameters), shown Figure 2 Appendix A.
described complete picture GTBM implementation, next discuss
important issues may arise trying use GTBM task allocation.

6. Discussion
paper developed task allocation mechanisms operate effectively agents
cannot reliably complete tasks assigned them. Specifically, designed novel Generalised
Trust-Based Mechanism efficient individually rational. mechanism deals
case task requesters form opinions task performers using reports environment direct interactions performers. addition studying economic
properties allocation mechanisms, provided optimisation model generates solutions guarantee efficiency mechanism. optimisation model first solver
trust-based mechanisms (and mechanisms value allocation depends
performer allocation) based Integer Programming. result, shown
input explodes combinatorially due huge number possible allocations must
enumerated. Nevertheless, computational cost associated GTBM shown
34

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

rather high, given implementation, still able manage small medium-sized problems
reasonable time.
Speaking generally, work trust-based mechanisms number broader implications. First, GTBM shows explicitly blend work trust models work
mechanism design. Since mechanism guarantees certain properties hold task allocation
problems, used new, well-founded testbed within trust models evaluated. now, trust models mainly tested randomly generated scenarios
interactions obey somewhat ad hoc market rules used ART testbed (Fullam,
Klos, Muller, Sabater, Topol, Barber, Rosenschein, & Vercouter, 2005). Second, work
first single-stage interdependent valuations mechanism efficient individually rational (as
opposed Mezzettis two-stage mechanism). made achievable settings
consider capturing interdependence types trust function making
payments agents contingent actual execution tasks. Another novelty approach
able extract (maximum) marginal contribution agent despite valuations interdependent (as shown Section 4.4). Third, implementation GTBM
highlights importance considering computational aspects new mechanism, since
determine whether mechanism implementable realistic scenarios indeed
bring claimed benefits. work strong statement direction since provide
complete picture problem, starting representation, implementation
sample results, complexity analysis.
practical terms, GTBM step towards building robust multi-agent systems uncertain
environments. environments, important aggregate agents preferences,
taking account uncertainty order ensure solutions chosen result best
possible outcome whole system. Prior GTBM, possible come
efficient solution would maximise expected utility. Moreover, fact agents
express perception task performers POS new way building expressive
interactions buyers sellers services (Sandholm, 2007). believe
perceptions expressed, better ensuing matching buyers sellers
results proof gain efficiency better matching brings (see sections 3.2.1,
3.3.1, 4.3).
introducing GTBM new class mechanisms, work lays foundations several
areas inquiry. end, outline main areas below.
Budget Balance: important economic property mechanisms contexts budget
balance.16 However, mentioned Section 3.3.2, designed TBMs without
considering budget balance. fact, GTBM budget balanced similar VCG
Porter et al.s mechanism. Now, one possible way overcoming problem sacrifice
either efficiency individual rationality. fact, dAGVA mechanism counterpart
VCG indeed sacrifice individual rationality budget balance (see Section
2). Moreover, Parkes, Kalagnanam, Eso (2001) develop mechanisms number
budget balancing schemes proposed near-incentive compatibility attained
making payments agents close possible VCG ones.
16. mechanism budget balanced, computes transfers allocation overall transfer system
zero (MasColellP
et al., 1995). Thus, budget balanced mechanism, allocation K associated transfer
vector r, ri r ri = 0.

35

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

effective scheme, Threshold rule, results low loss incentive-compatibility
relatively high efficiency (around 80%). budget balance may useful
situations centre cannot run risk incurring loss generating efficient
outcome set agents system. example, MoviePictures.com may find
worth injecting money system find efficient outcome subunits
nearly equally competitive (both price POS). Instead MoviePictures.com might
prefer mechanism generates near-efficient outcome increasing Bi discussed
Section 4.4. this, set agents participate might reduced
individually rational participate mechanism, but, nevertheless,
MoviePictures.com may obtain better outcome. future, study trade-offs
efficiency achieved system profit made centre.
Trust Task Requesters: One potential criticism mechanisms
task requesters (and centre) must trusted reveal observed execution task
(Mezzetti, 2004). However, setting, task requesters strong incentive reveal
observations (in case publicly visible) since would prefer chosen
task performer available next time mechanism run. end, must
ensure task performer go bankrupt. noted Equations (12) (17),
task performer would pay significant amount centre case reported
fail task. Hence, task requester better revealing successful execution
task performer indeed successful.
Another issue trust function used weights given agents EQOS report
may uncertain. Thus, case, agents may learn weights multiple
interactions. Given this, important develop learning search techniques
able deal large number possible weights could used trust
functions. techniques take account fact agents may lose
significantly exploring search space.
Iterative Mechanisms: GTBM one-shot mechanism allocation
payments calculated given type agents {v, c, } using trust models.
However, cases participants may engaged repeated interactions
exploited trust models order build accurate trust values counterparts.
situations, introduction multiple rounds compromise properties
mechanism allowing greater range strategies (e.g., cornering market consistently offering low prices initial rounds accepting losses initial rounds providing
false damaging information competitors). However, explosion strategy
space implies agents might able compute optimal strategy due
intractability process. Now, one way solving problem constrain
strategies agents myopic (i.e., best response current round) shown
Parkes Ungar (2000) using proxy bidding. Another allow agents learn trust
models without participating allocation problem. Then, agents accurate representation trust functions POS values, mechanism implemented
one-shot encounter. Note problem arises one-shot mechanism
implemented iterative context solely realm GTBM.
36

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

Computational Cost: discussed Section 5, algorithms developed compute
efficient allocation run multiple times compute individual payments
agents TBMs. Hence, time needed compute allocation pay agents
may impractical agents limited time find solution, put forward large
number bids, ask large number tasks performed. Hence, important
either less complex mechanisms described Nisan Ronen (2007)
approximate (and computationally less expensive) algorithms developed solve
problems (Archer, Papadimitriou, Talwar, & Tardos, 2003). require work
developing local approximation algorithms approximate mechanisms preserve
properties seek. vein, paper provides point departure
future mechanisms since provides efficient mechanisms approximate
ones compared.
Acknowledgments
thank anonymous reviewers highly valuable comments; allowed us
improve upon previous version paper, restrictive mechanism,
helped rework proofs. grateful Juuso Valimaki initial comments
mechanism, Ioannis Vetsikas, Enrico Gerding, Archie Chapman checking proofs
discussing ideas. Juan A. Rodriguez-Aguilar thanks IEA (TIN2006-15662-C02-01), Agreement
Technologies (CONSOLIDER CSD2007-0022, INGENIO 2010) Jose Castillejo programme
(JC2008-00337) Spanish Ministry Science Innovation. Andrea Giovannucci funded
Juan De La Cierva Contract (JCI-2008-03006) EU funded Synthetic Forager project
(ICT-217148-SF). Claudio Mezzetti thanks Fondazione Cassa di Risparmio di Padova e Rovigo
support. research paper undertaken part ALADDIN (Autonomous
Learning Agents Decentralised Data Information Systems) project jointly funded
BAE Systems EPSRC (Engineering Physical Research Council) strategic partnership
(EP/C548051/1).

Appendix A. Analysing Performance IP Solution
section analyse computational performance Integer Programming solution
detailed Section 5 order gauge sizes problems solved reasonable time.
end, important recall (as shown Section 5) number input variables
optimization problem nearly equal number valuation hyperedges |Ev |, since |Ec | |Ev |.
Given this, assume performance solver directly related number
possible allocations approximated |Ev |.
Therefore, test set composed several instances GTBM Task Allocation Problem
characterised number possible allocations. detail, produce allocations, bids
valuations generated number bids submitted single bidder number
valuations submitted single requester follow geometric distribution p parameter
set 0.23 (Milton & Arnold, 1998) (in order randomly generate relatively large numbers
bids/asks per agent).17 medium-sized problem set follows. number negotiated tasks
set 5. number task performers set 15 number task requesters set 20.
17. Setting p higher would result fewer bids/asks per agent.

37

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

average number generated valuations instance 88 average number bids
65. Finally, number runs experiments 300. experiments performed
Xeon dual processor machine 3Ghz CPUs, 2 GB RAM commercial software employed
solve Integer Program ILOG CPLEX 9.1.

35

Clock time find optimal solution (seconds)

30

25

20

15

10

5

0

0

0.2

0.4

0.6

0.8
1
1.2
No. possible allocations

1.4

1.6

1.8

2
5

x 10

Figure 2: Performance IP solution.

results shown Figure 2. Specifically, x-axis represents number allocations
given problem instance y-axis represents time seconds elapsed solving
corresponding problem instance. Notice dependence difficulty problem
number allocations quite clear. Moreover, seen, possible solve problem
less 2 105 variables within 40 seconds. important note performance
solver used critical case future advancements Mixed Integer Programming (MIP)
solvers CPU clock speeds improve results.
Given results since provide general formula (see Equation (30)) compute
priori number generated allocations, possible estimate feasibility general
problem performing it. means system designer ask task requesters
performers constrain number tasks ask number bids issue come
input solved program reasonable time. important,
however, design special purpose algorithms deal larger inputs left
future work.

References
Archer, A., Papadimitriou, C., Talwar, K., & Tardos, E. (2003). approximate truthful mechanism
combinatorial auctions single parameter agent. Internet Mathematics, 1(2), 129150.
38

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

Arrow, K. J. (1979). property rights doctrine demand revelation incomplete information. Boskin, M. (Ed.), Economics Human Welfare. Academic Press.
Berge, C. (1973). Graphs Hypergraphs. North-Holland Publishing Company.
Byde, A. (2006). comparison mechanisms sequential compute resource auctions.
Proceedings Fifth International Joint Conference Autonomous Agents MultiAgent systems (AAMAS-06), pp. 11991201. ACM Press.
Cerquides, J., Endriss, U., Giovannucci, A., & Rodrguez-Aguilar, J. A. (2007). Bidding languages
winner determination mixed multi-unit combinatorial auctions. Proceedings
Twentieth International Joint Conference Artificial Intelligence, pp. 12211226.
Dasgupta, P. (1998). Trust commodity. Gambetta, D. (Ed.), Trust: Making Breaking
Cooperative Relations, pp. 4972. Blackwell.
Dash, R. K., Parkes, D. C., & Jennings, N. R. (2003). Computational mechanism design: call
arms. IEEE Intelligent Systems, 18(6), 4047.
Dash, R. K., Ramchurn, S. D., & Jennings, N. R. (2004). Trust-based mechanism design.
Proceedings Third International Joint Conference Autonomous Agents MultiAgent Systems (AAMAS-04), Vol. 2, pp. 726753.
dAspremont, C., & Gerard-Varet, L. A. (1979). Incentives incomplete information. Journal
Public Economics, 11(1), 2545.
Dellarocas, C. (2002). Goodwill hunting: economically efficient online feedback mechanism
environments variable product quality. Proceedings (AAMAS-02) Workshop
Agent-Mediated Electronic Commerce, pp. 238252.
Engel, Y., Wellman, M. P., & Lochner, K. (2006). Bid expressiveness clearing algorithms
multi-attribute double auctions. Proceedings Seventh ACM Conference Electronic
Commerce (EC-06), pp. 110119.
Fullam, K., Klos, T., Muller, G., Sabater, J., Topol, Z., Barber, K. S., Rosenschein, J., & Vercouter,
L. (2005). agent reputation trust (ART) testbed architecture. Proceedings
(AAMAS-05) Workshop Trust Agent Societies, pp. 5062.
Hershberger, J., & Suri, S. (2001). Vickrey pricing network routing: Fast payment computation.
Proceedings Forty-Second IEEE Symposium Foundations Computer Science,
pp. 252259.
Jehiel, P., & Moldovanu, B. (2001). Efficient design interdependent valuations. Econometrica,
69(5), 123759.
Jennings, N. R., Faratin, P., Norman, T. J., OBrien, P., Odgers, B., & Alty, J. L. (2000). Implementing business process management system using adept: real-world case study. International Journal Applied Artificial Intelligence, 14(5), 421465.
Jurca, R., & Faltings, B. (2003). incentive compatible reputation mechanism. Proceedings
IEEE Conference E-Commerce (CEC-03), pp. 285292.
Jurca, R., & Faltings, B. (2006). Minimum payments reward honest reputation feedback.
Proceedings Seventh ACM conference Electronic commerce (EC-06), pp. 190199.
39

fiR AMCHURN , EZZETTI , G IOVANNUCCI , RODRIGUEZ , DASH , J ENNINGS

Jurca, R., & Faltings, B. (2007). Obtaining reliable feedback sanctioning reputation mechanisms.
Journal Artificial Intelligence Research (JAIR), 29, 391419.
Kalagnanam, J., Davenport, A. J., & Lee, H. S. (2000). Computational aspects clearing continuous double auctions assignment constraints indivisible demand. Tech. rep., IBM
Research RC21660(97613).
Kalagnanam, J., & Parkes, D. C. (2004). Auctions, bidding exchange design. Simchi-Levi,
D., Wu, S. D., & Shen, M. (Eds.), Handbook Quantitative Supply Chain Analysis: Modeling
E-Business Era, International Series Operations Research Management Science,
chap. 5. Kluwer.
Krishna, V. (2002). Auction Theory. Academic Press.
MasColell, A., Whinston, M., & Green, J. (1995). Microeconomic Theory. Oxford University Press.
Mezzetti, C. (2004). Mechanism design interdependent valuations: Efficiency. Econometrica,
72(5), 16171626.
Mezzetti, C. (2007). Mechanism design interdependent valuations: Surplus extraction. Economic Theory, 31(3), 473488.
Miller, N., Resnick, P., & Zeckhauser, R. (2005). Eliciting honest feedback: peer prediction
method. Management Science, 51(9), 13591373.
Milton, J., & Arnold, J. C. (1998). Introduction Probability Statistics. Principles Applications Engineering Computing Sciences. McGraw-Hill Inc.
Nisan, N. (2006). Bidding languages combinatorial auctions. Cramton, P., Shoham, Y., &
Steinberg, R. (Eds.), Combinatorial Auctions, pp. 215231. MIT Press.
Nisan, N., & Ronen, A. (2007). Computationally feasible VCG mechanisms. Journal Artificial
Intelligence Research (JAIR), 29, 1947.
Papadimitriou, C. H., & Steiglitz, K. (1982). Combinatorial optimization: algorithms complexity. Prentice-Hall, Inc., Upper Saddle River, NJ, USA.
Parkes, D. C., Kalagnanam, J. R., & Eso, M. (2001). Achieving budget-balance vickreybased payment schemes exchanges. Proceedings Seventeenth International Joint
Conference Artificial Intelligence (IJCAI-01), pp. 11611168.
Parkes, D. C., & Ungar, L. H. (2000). Preventing strategic manipulation iterative auctions: Proxy
agents price-adjustment. Proceedings Seventeenth National Conference Artificial Intelligence Twelfth Conference Innovative Applications Artificial Intelligence, pp. 8289.
Porter, R., Ronen, A., Shoham, Y., & Tennenholtz, M. (2008). Fault tolerant mechanism design.
Artificial Intelligence, 172(15), 17831799.
Ramchurn, S. D., Huynh, D., & Jennings, N. R. (2004). Trust multi-agent systems. Knowledge Engineering Review, 19, 125.
Sandholm, T. (2007). Expressive commerce application sourcing: conducted 35
billion generalized combinatorial auctions. AI Magazine, 28(3), 4558.
40

fiT RUST-BASED ECHANISMS ROBUST E FFICIENT TASK LLOCATION

Sandholm, T., Suri, S., Gilpin, A., & Levine, D. (2002). Winner determination combinatorial
auction generalizations. Proceedings First International Joint Conference Autonomous Agents Multi-Agent Systems (AAMAS-02), pp. 6976.
Sandholm, T. W. (1993). implementation contract net protocol based marginal cost
calculations. Proceedings Twelfth International Workshop Distributed Artificial
Intelligence, pp. 295308.
Teacy, W. T. L., Patel, J., Jennings, N. R., & Luck, M. (2006). Travos: Trust reputation
context inaccurate information sources. Autonomous Agents Multi-Agent Systems,
12(2), 183198.
Walsh, W., & Wellman, M. (1998). market protocol decentralized task allocation. Proceedings Third International Conference Multi-Agent Systems (ICMAS-98).

41


