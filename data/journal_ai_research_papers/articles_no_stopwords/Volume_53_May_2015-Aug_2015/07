journal artificial intelligence

submitted published

itsat efficient sat temporal planner
masood feyzbakhsh rankooh
gholamreza ghassem sani

feyzbakhsh ce sharif edu
sani sharif edu

computer engineering department
sharif university technology
azadi ave tehran iran

abstract
satisfiability known efficient deal many types
however competitive state space
methods temporal describes itsat efficient sat
satisfiability temporal planner capable temporally expressive
novelty itsat lies way handles temporal constraints given without
getting involved difficulties introducing continuous variables corresponding
satisfiability sat classical carefully
devised preprocessing encoding schemata considerably improve efficiency
sat temporal present two preprocessing methods mutex relation
extraction action compression separation causal temporal
reasoning enables us employ compact encodings concept parallel
execution semantics although encodings shown quite effective
classical itsat first temporal planner utilizing type encoding
empirical itsat outperform state art temporally
expressive planners competitive fast temporal planners cannot
handle required concurrency

introduction
temporal extension classical actions durative rather
instantaneous introduction durative actions adds dimension
solving namely reasoning time temporal reasoning per se
different causal reasoning time real valued quantity whereas causal
aspects normally represented propositions
current standard language defining temporal pddl
fox long although pddl fox long introduced
community expressive language defining temporal numerical
throughout focus pddl
tackled need expressive power pddl pddl
actions separate preconditions effects upon starting ending temporal
action invariants must preserved execution
action important subset defined pddl every
valid plan includes concurrent execution two actions subset called
required concurrency shown concurrent execution two
actions may necessary solving temporal halsey long fox
cushing kambhampati mausam weld instance temporal
c

ai access foundation rights reserved

firankooh ghassem sani

actions may require proposition available execution
another action cases two actions must executed concurrently
specific example given section describe driverlogshift domain
common many planners temporally expressive eliminate
cases compressing temporal actions create non durative classical actions
describe itsat temporally expressive sat e satisfiability
planner itsat uses takes advantage parallel execution semantics without rendering incomplete required concurrency
durations actions given first abstracted
done breaking temporal action two starting ending instantaneous events
obtained temporally abstract encoded sat formula novel
step step semantics causally valid plans semantics
used encode given temporal sat formula classical step
step encoding methods introduced rintanen heljanko niemela
addition extending methods temporal context
introduce encoding method step semantics causally valid plans
encoding often significant reduction number required
steps
generating causally valid plan itsat performs scheduling phase
phase itsat tries satisfy temporal constraints imposed considering
durations actions done solving simple temporal stp dechter
meiri pearl however required concurrency posed stp
may inconsistent cases cause inconsistency manifests
negative cycle corresponding simple temporal network stn detected itsat
generates number clauses added sat formula collectively prevent
reoccurrence particular negative cycle occurred similar cycles
process repeated temporally valid plan found
similar sat planners itsat takes advantage preprocessing phase
extract information structure information used
throughout encoding phase produce formula whose satisfiability checked
efficiently sat solver section describe preprocessing phase
itsat includes reasoning mutual exclusion called safe action
compression coles coles fox long two propositions regarded mutually
exclusive never jointly true state valid temporal plan
one detect mutually exclusive propositions temporal
graph analysis blum furst known employing mutual exclusion
reasoning significantly improve performance sat planners gerevini
schubert
mentioned earlier itsat breaks temporal action two starting
ending instantaneous events although cases breaking might
necessary producing concurrent plans situations necessary
finding valid plans section mutual exclusion information
one identify temporal actions safely compressed classical action
without falsifying validity temporal plans analysis smaller number
distinct events therefore simpler


fiitsat efficient sat temporal planner

empirically taking advantage preprocessing encoding
scheduling phases itsat significantly outperform state art temporally expressive planners competitive best temporally simple planners
incapable solving required concurrency property components itsat shown figure figure processing components
itsat system shown rectangular blocks links represents data produced
received components

figure block diagram itsat



firankooh ghassem sani

motivation
mentioned earlier temporal planners need reason time continuous
quantity nevertheless causal structures temporal still
similar classical existence abundant temporal domains
classical versions regarded evidence claim suggests
temporal planners benefit approaches previously shown
effective dealing classical
usage boolean satisfiability checking well known paradigm tackling classical
kautz selman given
translated formula propositional logic variable sat formula typically
represents occurrence corresponding action proposition certain place
potential plan causal constraints represented number
ground clauses output plan assumed finite number steps step
may include one actions original sat planner allowed one action
per step kautz selman however previously introduced sat planners
allow multiple occurrence actions step produced formula given
input shelf sat solver tries model model
found plan extracted otherwise number steps output plan
increased one corresponding sat formula given sat solver
process repeated valid plan extracted predefined termination condition
reached order obtain efficient sat planner one important issue
considered encode given sat formula
sat originally used optimal plans e plans minimum
number actions kautz selman guarantee optimality output plan
formula must include certain clauses ban step containing one
action however called satisficing optimality main
objective forcing single action steps necessary alternative consider
actions executed parallel step output plan ernst millstein
weld exploiting parallelism smaller number steps
sat formula another important benefit producing compact formulae lower memory
requirements several encoding methods introduced take advantage action
parallelism encoding methods called step step semantics
valid plans rintanen et al
step step semantics different extent action parallelism
allow occur step step semantics allows set actions executed
parallel actions executed every possible ordering without affecting
validity plan step semantics hand imposes weaker restriction
step plan must exist least one possible ordering actions
executed without falsifying validity plan clear step
semantics potentially allows parallelism permitted step semantics
fact taking advantage step semantics efficient sat classical planner
e mp rintanen competitive state art state space planners
separation causal temporal reasoning phases temporal
enables us employ compact encodings efficient temporal


fiitsat efficient sat temporal planner

related work
previous field temporal benefited enormously employing
well developed classical strategies instance many successful temporal planners utilized ideas partial order e g vhpop younes simmons
cpt vidal geffner graph analysis adopted
temporal planners tgp smith weld tpsys garrido fox long
temporal planners embedded temporal reasoning heuristic
state space search tfd eyerich mattmuller roger lpg td gerevini saetti
serina popf coles coles fox long successful instances
latter
usage boolean satisfiability checking one well known paradigms tackling classical kautz selman order obtain efficient
sat planner one important issue considered encode
given sat formula fact devising efficient encoding methods
important trend field sat examples
efficient encodings split action representation kautz selman ernst et al
robinson gretton pham sattar sas encoding huang chen
zhang compact mutual exclusion representation rintanen
parallel semantics plans another effective encoding method introduced rintanen et al latter encoding method particular interest
satisfiability checking employed field temporal however
sat temporal planners encounter major challenge representing temporal aspects since time continuous quantity cannot treated exact
way discrete causality handled tackle step huang chen
zhang scp lu huang chen xu zhang chen satplan mali
liu use discrete representation time planners assign explicit discrete
time labels step encoding generally speaking step
exactly one time unit ahead step action duration starts
step forced end step one immediate outcome
introduction enormous number steps encoding many
contribute output plan drawback explicit time representation causes
step scp satplan inefficient terms speed memory usage obtain better performance scp uses step semantic allow causal relations
actions time point lu et al
tm lpsat shin davis designed solve
defined pddl fox long another sat planner capable handling
temporal similar step satplan tm lpsat attaches
time labels step however tm lpsat labels predefined discrete
numbers instead label numeric variable whose value determined
solved smt solver armando giunchiglia
encodings compact produced step tsatplan
major disadvantage assigning time label step formula parallelism mentioned cannot exploited effectively two events


firankooh ghassem sani

happen certain step plan time labels must thus
must simultaneous final plan executed compulsory simultaneity
restriction reduces number events happen step final
plan turn increases number steps needed solving input
implies efficiency gain one could obtain parallel execution semantics
sacrificed achieve easy way deal temporal constraints however
majority current temporal satisfying temporal constrains
hardest task finding valid plan shown without required
concurrency one omit temporal constraints altogether causally valid plan
considering temporal constraints postproccessing step schedule
actions plan temporally valid plan cushing et al
actually used many previous temporal planners including yahsp mt vidal
winner temporal satisficing track ipc despite efficient
solving many temporal planners incomplete incapable
solving required concurrency
addition classical sat methods used
deal categories examples uncertainty
castellini giunchiglia tacchella cost optimal robinson gretton
pham sattar numerical hoffmann gomes selman kautz


preliminaries
standard language used defining temporal pddl fox
long figure presents example pddl representation temporal
domain domain simplified version driverlogshift halsey
referred several times throughout figure shows pddl
action separate conditions effects upon starting ending starting
ending conditions effects action specified start end
tokens respectively action may conditions need preserved
execution conditions specified token moreover
duration action defined duration x statement x rational
number function specifying actual duration action
driverlogshift temporal version driverlog domain ipc
classical counterpart driverlogshift objective transfer several objects
original places destinations object loaded unloaded
certain truck load unload operators respectively truck move
locations move operator main difference driverlogshift
driverlog trucks must rested intervals working
shifts working shift defined work operator produces working
truck proposition upon starting deletes proposition upon ending load unload
move working truck invariant working truck deleted
ending work may reproduced rest operator defines resting
shift certain truck


fiitsat efficient sat temporal planner

define domain driverlogshift
requirements typing durative actions
types
location locatable object
truck obj locatable
predicates
obj locatable loc location
obj obj obj truck
link x location
working truck
need rest truck
rested truck
durative action work
parameters
truck truck
duration duration
condition
start rested truck
effect start working truck
end working truck
start rested truck
end need rest truck
durative action rest
parameters
truck truck
duration duration
condition
start need rest truck
effect
start need rest truck
end rested truck
durative action load
parameters
obj obj
truck truck
loc location
duration duration
condition
truck loc
working truck
start obj loc
effect
start obj loc
end obj truck

durative action unload
parameters
obj obj
truck truck
loc location
duration duration
condition
truck loc
working truck
start obj truck
effect
start obj truck
end obj loc
durative action move
parameters
truck truck
loc location
loc location
duration duration
condition
start truck loc
start link loc loc
working truck
effect
start truck loc
end truck loc

figure pddl description driverlogshift domain

note version driverlogshift described figure slightly different
original version halsey drivers walk board
disembark trucks furthermore rest work actions performed drivers
rather trucks however order make examples simpler merged drivers
trucks single entity trucks
simple example driverlogshift shown figure
three locations one truck truck one object package
initial state truck package objective
transfer package
formalism pddl
present formalism specifications pddl formalism devised
way simplifies description preprocessing encoding scheduling phases
itsat mention formalism limitations compared
full specifications pddl limitations discussed details section


firankooh ghassem sani

define dlog
domain driverlogshift
objects
truck
truck
package obj
location
init
rested truck
truck
package
link
link
link
link

goal
package

figure pddl description driverlogshift domain

definition events event e triple pre e add e del e pre e
add e del e three sets atomic propositions facts representing preconditions
positive effects negative effects e respectively
definition temporal actions temporal action quadruple start end
inv dur start end two events denoting starting ending
events inv set atomic propositions representing invariants
dur positive rational number specifying duration
example figure shows temporal action load package truck
instance load operator defined figure figure depicted rectangular box conditions effects written box respectively
start conditions effects placed left hand side box
end conditions effects placed right hand side box
conditions placed middle box start end
two events pre start package add start del start
package pre end add end package truck
del end moreover inv truck working truck
dur


fiitsat efficient sat temporal planner

figure temporal action

definition temporal states temporal state pair state agenda
state classical state represented set atomic propositions
agenda contains finite set open actions e actions started prior yet
ended
definition applicability starting event e action applicable state
following conditions hold
state contains preconditions e
invariants except
invariants added e pre e inv add e state
already open
agenda
esdoes delete thetinvariants open action

del e
agenda inv
ending event e action applicable state following conditions hold
state contains preconditions e pre e state
open agenda

e delete invariants
open action


inv
del e

agenda
definition successors starting event e action applicable state
change unique state satisfying following conditions


set open
actions equal set open actions agenda
agenda

positive negative effects
e respectively added deleted

state state del e add e

ending event e action applicable state change unique state
satisfying following conditions


firankooh ghassem sani

set open actions equal set open actions without
agenda agenda
positive negative
effects e respectively added deleted state

state del e add e
may use succ e represent successor state obtained applying
e
definition definition easily extended cover sequence events
succ en succ succ en en succ hi sequence
events en applicable temporal state succ en defined
example let temporal state
state package truck working truck link

agenda
let load package truck move truck two temporal actions respectively instances load move operators presented figure
event start applicable changes
state truck working truck link

agenda load package truck
start applicable already open isstart applicable deletes truck invariant still open
however end applicable changes
state package truck truck working truck link

agenda

definition temporal temporal p triple g
representing initial state temporal state agenda g set
atomic propositions denoting goal conditions finite set possible
temporal actions p
definition causally valid plans let p g temporal
en sequence events ei starting ending event
action causally valid plan p applicable g state succ
agenda succ


fiitsat efficient sat temporal planner

definition pairing events let en causally valid plan p g assume ei ej respectively starting ending events
certain action j k k j ek neither starting
ending event say ei ej pairing event ej ei
words ei ej pairing events related occurrence
definition valid temporal plans makespan let en causally
valid plan p g n q scheduling function q
set rational numbers valid temporal plan p following
properties

start ei ej pairing event ei j
dur
maximum value assigned events called makespan
example consider p g depicted figure state
g contain propositions listed labels init goal respectively
set possible instantiations operators presented figure objects
listed label objects figure let
hstart work truck
start load truck package
end load truck package
start move truck
end move truck
start move truck
end move truck
start unload truck package
end unload truck package
end work truck
schematic representation depicted figure straightforward checking shows
causally valid plan p however valid temporal plan
duration work truck requires serial execution two move actions one
load action one unload action total duration work truck
still open words one single working shift truck sufficient transfer
package therefore scheduling function properties
definition exists valid temporal plan p depicted figure
plan two working shifts truck used


firankooh ghassem sani

figure causally valid plan

figure valid plan

limitations
end section describing differences formalism valid temporal
plans pddl main limitations formalism listed
according definition starting event action applicable state
already open means similar many previous
temporal planners permit two versions action overlap
consequently current implementation itsat allow self overlapping
actions however specification pddl allows plans actions
shown necessary solving certain temporal fox
long experimental indicate restriction render
itsat incapable solving current benchmark nevertheless
shown theory self overlapping actions may cause complexity
temporal become expspace hard rather pspace hard rintanen

formalism allow two events simultaneously applied
state example cases simultaneity required consider two
temporal actions b starting event adds invariant b


fiitsat efficient sat temporal planner

starting event b adds invariant case might necessary
simultaneously apply starting event actions given state
clear specification pddl whether simultaneity permitted
hand shown almost none current benchmark
require simultaneity solvable rankooh ghassem sani

pddl allows usage numerical variables supported itsat
pddl allows duration dependent effects state dependent durations
actions numerical features supported itsat
itsat currently handle numerical fluents
according formalism duration temporal action defined
duration x assignment x rational number function specifying
actual duration action pddl hand allows
inequalities duration x duration x define range
duration temporal action nevertheless current benchmark
include inequalities although current implementation itsat
support inequalities quite easy include feature kinds
constraints duration actions handled simple temporal
dechter et al

preprocessing phase
preprocessing important phase many planners main objective phase
extract certain information information later used
enhance search performance one important issue addressed devising
preprocessing method correctness extracted information words
constraints inferred preprocessing phase must correct sense
cause planner become incapable finding valid plans moreover
preprocessing method effective required performed polynomial
time section explain two different preprocessing methods used itsat mutual
exclusion analysis action compression formally prove methods
correct performed polynomial time
mutual exclusion analysis
mutual exclusion analysis preprocessing method pairs propositions cannot mutually true state valid plan sat planners typically add
explicit clause sat formula pair mutually exclusive propositions
clauses prevent mutually exclusive pairs propositions true true
time although information obtained search phase acquiring beforehand one prune search tree sat solver thereby improve
performance
polynomial time mutual exclusion analysis classical originally performed constructing graphs data structure introduced


firankooh ghassem sani

graphplan blum furst shown mutual exclusion
information obtained graphs quite effective improving performance sat planners gerevini schubert methods
introduced compute n way mutexes instead pairwise mutexes computed
graphs hn heuristic haslum geffner analyzes reachability set n propositions initial state example methods
shown generalization hn heuristic efficiently computed
syntactic regression operation rintanen gretton
method used itsat finding mutual exclusion relations
graph analysis classical graph layered structure first layer
includes propositions present initial state
layer graph mutual exclusion mutex relations pairs proposition
computed two propositions non mutex first layer
present initial state action applicable layer preconditions
non mutex layer two different actions mutex layer least one
following conditions holds interference e one action
deletes effect action conflict e one action
deletes precondition action preconditions mutex layer
layer includes effects actions applicable layer two propositions
mutex layer become non mutex layer produced non mutex
actions layer transfer propositions one layer next layer exists
special noopp action proposition p requires adds p construction
graph may continue change take places two consecutive layers
case say graph leveled
graphs previously employed tackle temporal
smith weld fact first completely domain independent temporal planner
called tgp extension graphplan blum furst tgp requires
preconditions temporal action preserved throughout time action
open allow actions effects upon starting tgp
compatible requirements pddl tpsys garrido et al
extension tgp another graph temporal planner produce
plans domains required concurrency similar graphplan addition
construction graph tpsys tgp perform backward search
valid temporal plan
lpgp long fox another graph temporal planner lpgp
mutex relations proposition actions computed considering
causal constraints whereas temporal constraints taken
account later plan extracted solving linear programming lp
omitting temporal constraints done converting given temporal
classical graph construction lpgp
similar graphplan
mentioned earlier itsat temporal constraints considered
causally valid plan produced therefore constraints needed
dealt graph construction phase makes graph structure
lpgp suitable itsat explain graph construction phase lpgp


fiitsat efficient sat temporal planner

correctness mutual exclusion information obtained method essential
correctness action compression sat encoding methods however description
lpgp accompanied formal proof correctness therefore
formally prove correctness tractability preprocessing method
definition causal abstraction temporal let p g
temporal ac set classical actions
exactly three classical actions ai ae ac following properties
pre pre start inv add
add add start opena opena proposition specifying
started yet finished
del del start add start
pre ai inv opena
add ai inv opena
del ai
pre ae pre end opena
add ae add end
del ae del end add end opena
causal abstraction p classical p c state g ac
fact definition produce causal abstraction given temporal split temporal action three classical actions ai ae
actions ae correspond respectively starting ending events addition normal effects preconditions adds special proposition named opena
required deleted ae action ai called invariant checking action
requires invariants plus opena preconditions produces opena
effect
given temporal p g itsat produces
c
p state g ac e causal abstraction p itsat constructs classical graph p c
graph itsat similar graphplan one
difference graphs two planners graphplan mentioned earlier propositions propagated layers called noop actions
however itsat exception usage noop actions proposition
form opena introduced causal abstraction action particular proposition
propagated ai invariant checking action therefore ai seen
kind noop action used cover invariants reasoning mutex relations



firankooh ghassem sani

theorem let p g temporal p c state g ac
causal abstraction p let en finite sequence events
applicable sn succ following conditions must hold
two propositions p q members state sn p q non mutex
layer n graph p c
proposition p member state sn action member agenda sn
p opena non mutex layer n graph p c
proof see appendix
graph leveled subsequent extensions graph
effect layers therefore two propositions mutex last layer
leveled graph remain mutex subsequently produced layers case
theorem implies pairs propositions never appear temporal
state execution valid temporal plan matter remains
mutual exclusion analysis itsat performed polynomial time
let p temporal p c causal abstraction p
deduced definition size p c greater p constant
factor process constructing graph p c obtained modifying
construction process graphs graphplan planner way
temporal action noopopena never used graphplan constructs
graphs polynomial time blum furst therefore overall time needed
mutual exclusion analysis itsat polynomial size given temporal

action compression
temporal actions variety temporal relations one another popular
model representing temporal relations actions initially introduced james
allen model included possible temporal relations two actions
allens temporal relations require starting ending events actions
executed simultaneously mentioned section none temporal plans
produced itsat necessitate simultaneity set temporal
relations two temporal actions confined proper subset allens
temporal relations possible temporal relations depicted figure
shown figure types relations actions concurrent e
exists time two actions executed concurrency
unnecessary solving temporal know two actions
required concurrently executed order valid plan checking
two temporal relations depicted figure c sufficient searching phase
planner however valid plans include concurrent executions two actions
restricting temporal relations actions two relations depicted figure
c render planner incomplete



fiitsat efficient sat temporal planner

figure temporal relations two pddl actions

definition compression safe sets actions compressed plans let
p g temporal exists least one valid
temporal plan subset say compression safe p exists
causally valid plan p compressed respect causally valid plan
en compressed respect following property
k ek starting event action ek ending event

according definition starting ending events members
assumed executed consecutively least one causally valid plan therefore
plan executed event causally needed happen starting
ending member suggests members regarded
single event environment rather two separate starting ending events


firankooh ghassem sani

words member compress starting ending events
single event without rendering unsolvable example consider
driverlogshift temporal presented example plan presented
example shows set load move unload actions compressionsafe set actions straightforward analysis example shows
neither work actions presented example member compression safe
subset actions
note according definition causally valid plan regarded
compressed sequence events although concept compression extended
cover even sequences events lead goal state sake
simplicity focused attention sequences causally valid
plans defined compression safe actions solvable temporal
explain later section information obtained compression safety analysis
incorporated encoding adding extra sat formulae
makes hand tighter words information used prune
search space sat solver handling compression safety
never cause planner produce invalid plan unsolvable
safe action compression employed field temporal
coles et al shown temporal possess
property required concurrency temporal actions safely compressed classical
actions cushing et al temporal said required concurrency
every valid temporal plan includes least one action whose execution overlaps
execution action without required concurrency temporal
actions compressed classical actions case transformed
classical phenomenon completely consistent
semantics definition easily shown without required
concurrency set actions indeed compression safe set actions however
case example even required concurrency
property may still exist non empty compression safe set actions
crikey successor popf two state space temporal planners
detect compression safe actions preprocessing task coles et al however
concept compression safety planners different presented
definition crikey assume ending event compression safe
action must executed immediately corresponding starting event instead
starting event compression safe action applied state simple inference
method crikey determine apply corresponding ending event
method reduce branching factor search space state space temporal
idea detecting compression safe actions
one significantly reduce search space satisfiability checking temporal
later explained section compression safe action add
clause sat formula guarantee starting event present step
ending event present step clauses used
prune search tree sat solver checking satisfiability produced
formula
crikey considers action compression safe following two conditions hold


fiitsat efficient sat temporal planner

pre end inv
del end
figure shows temporal plan executed reach proposition q example ending event action b precondition delete effect therefore
crikey considers b compression safe however goal produce q
singleton b compression safe set definition fact method used
crikey specifically devised state space temporal planners
cannot easily employed sat planners itsat contrast
later shown method easily used state space temporal planners
sat planners
cases method used crikey cannot detect actions
compression safe according definition consider plan depicted figure b suppose proposition p member initial state goal
produce proposition g plan actions b must executed consecutively
produce g p q respectively overall conditions
b mutually exclusive never true together however neither b
second property required crikey regarded compression safe action
section mutex information used detecting compression safe
actions
definition swappable events let two different temporal actions e
starting ending event e starting ending event say e
e swappable following conditions hold
e e interference add e del e add e
del e
e e conflict del e pre e inv
del e pre e inv
e e supporting add e pre e inv add e
add e pre e inv add e
according definition two events swappable causal relation
means causally valid plan e e en swap
e e reach another causally valid plan e e en use
swapping reorder events given causally valid plan without falsifying
consider causally valid plan en let ei ej starting
ending event action events plan swappable ej
repeatedly swapping one reorder produce another causally valid plan
ei ej ei ej ej en ei ej two consecutive events
therefore compression safe set case say compressed
towards start similarly every event plan ei ej swappable
ei repeatedly swapping one reorder produce causally valid
plan ei ei ej ei ej en conclude
compression safe set latter case say compressed towards end


firankooh ghassem sani

figure temporal actions regarded compressible itsat crikey b

whether safe compress given action need check
events swappable starting ending events fact considering
mutex relations obtained graph already know
events never executed open information effectively used
given set actions compression safe
definition compressible actions let p g temporal particular temporal action say compressible towards
start every event e e starting ending event least
one following conditions holds
precondition add effect e mutex opena last layer leveled
graph causal abstraction p
e swappable end


fiitsat efficient sat temporal planner

similarly say compressible towards end every event e e
starting ending event least one following conditions holds
precondition add effect e mutex opena last layer leveled
graph causal abstraction p
e swappable start
theorem let p g solvable temporal let set
every member compressible towards start compressible towards
end compression safe p
proof see appendix
give example clarification matter
example let p g temporal set
three temporal actions b c consider hypothetical causally valid plan depicted
figure execution action includes execution action b
turn includes execution action c assume compressible towards start
b compressible towards end plan converted another
causally valid plan b c executed sequentially figures b
c two consecutive swaps b compressed towards
end starting event b swapped starting event c transform
plan figure plan figure b since b compressible towards
end swapping cannot invalid plan similarly starting event b
swapped ending event c transform plan figure b
plan figure c figures g four consecutive swaps
compressed towards start swaps fully
sequential plan shown figure g produced implies even planner
allow execution event b open still capable producing
temporally valid plan figure g
given p g itsat computes compression safe set
theorem check first condition definition itsat needs construct
graph causal abstraction p showed previous
subsection done polynomial time second condition definition
suffices check every possible pair events see swappable since
done pair constant time total time conclude
finding performed polynomial time
method described finding compression safe actions used statespace temporal planners state space temporal planners divided two categories first category includes planners called decision
epoch method cushing et al examples decision epoch planners
tp haslum sapa kambhampati tfd eyerich et al


firankooh ghassem sani

figure action compression

method start action restricted immediately start
end another action state explicit time stamp action applied
state starting time action set time stamp state
starting event action added plan time corresponding
ending event exactly known searching valid plan state


fiitsat efficient sat temporal planner

planner make decision advancing time ending event
open action open action however know action compressionsafe planner advance time ending action thereby prune
search space plans produced way might larger makespans comparison
produced without pruning search space nevertheless produced plans
rescheduled plans improved makespans method explain later
section
alternative state space search called temporally lifted
progression proved complete pddl fox long
crikey popf examples planners
state temporally lifted progression represents permutation
number events state consistency temporal constraints imposed
sequence events state checked solving simple temporal stp
similar decision epoch state may exist two possible choices
add ending event open action open action however compressionsafe actions ending event actions applied immediately starting event
turn reduces future choices planner section
taking advantage compression safe actions manner planner still visit
stps causally valid permutations events
table shows comparison average percentage actions regarded
compression safe method method used crikey popf temporal domains explain information regarding benchmark
domains later section seen table compression
method detect significantly compressible actions number benchmark domain

encoding phase
section explain abstract causal associated given temporal
encoded sat formula classical exist one
way translate particular corresponding sat formula previous
investigations field classical choice encoding method
major impact efficiency sat planner mentioned earlier
successful sat classical planners used special encoding methods
called step step semantics valid plans rintanen et al
section define temporal versions classical step step plans
exactly semantics used translate given temporal
sat formula introduce step encoding two different types
step encodings temporal step first step encoding methods
temporal versions classical step step encodings similar classical
versions encodings restrictive simplifying assumptions assumed
hold second type step encoding however obtained relaxing one
assumptions later step encoding often requires fewer steps
one besides experimental among encoding methods
second step encoding best performance itsat terms speed


firankooh ghassem sani

domain
zenotravel
rovers
depots
airport
pegsol
crewplanning
openstacks
elevators
sokoban
parcprinter
driverlog
floortile
mapanalyser
matchcellar
parking
rtam
satellite
storage
turnandopen
tms
driverlogshift
matchlift

crikey























itsat























table average percentage compressed actions
memory usage planner necessary proofs soundness completeness
encoding methods given section
parallel semantics causally valid plans
mentioned earlier classical step semantics permits parallel execution
one action step validity plan depend execution
order actions simply guaranteed adding particular clause
pair mutually exclusive actions ensure actions included
step however strategy work temporal temporal
temporal constraints imposed starting ending events
actions validity particular ordering events certain step depends
ordering events steps nevertheless itsat
tackled separating causal temporal reasoning phases general focus
finding causally valid plans postpone scheduling phase mentioned
checking feasibility imposing different orderings events step
longer exist next introduce semantics causally valid step step temporal
plans



fiitsat efficient sat temporal planner

definition temporal steps steps let e e en set events
two temporal states temporal step
one one ordering functions n n e permutations events
succ heo eo n temporal step
exist least one one ordering function n n e least one
permutation events succ heo eo n
definition causally valid step step plans let p g temporal suppose sn sequence temporal states
g state sn agenda sn n stepi step step
si si call sequence hstep stepn causally valid step step
plan p say hs sn state transition sequence
classical step step encodings rintanen et al step
step semantics classical valid plans respectively however step encoding
sake improving efficiency planner following restrictive rules
enforced semantics
rule instead accepting possible orderings among actions step
fixed arbitrary ordering allowed rule execution
step necessitates execution actions according fixed ordering
rule preconditions actions step must members state immediately step similarly effects actions step must
consistent state reached immediately step
section present one step two step encodings causal
abstractions temporal encodings step step
semantics causally valid plans definition considering events instead actions
rules applied temporal first step
encoding respect rules second step encoding second restrictive rule
relaxed
fact second rule imposes serious restrictions applicability actions
step instance prevents proposition produced used
step plan neither allow deletion production
particular proposition step relaxing restrictions encoding
compact e relaxation permits events occur step classical
less relaxed form rule introduced effects actions
step used actions step wehrle rintanen
however totally relax rule allow proposition required added
deleted many times step
explaining sat encodings first define sat variables auxilary clauses
commonly used three encoding methods let hstep stepn causally
valid step step plan given temporal p g
hs sn state transition sequence order encode p sat formula
whose model translated back use following sat variables


firankooh ghassem sani

proposition p n define sat variable pt
assigning true f alse pt implies p member state st
action n define sat variable
assigning true f alse implies member agenda st
event e e starting ending event action
n define sat variable et assigning true f alse et
implies e member stept
sat formula satisfiable exists model model binary function
assigns value true f alse variable formula way
formula satisfied encoding methods produced formula
model one easily translate corresponding causally valid step step
plan description given variables formula denote
resulting plan plan showing correctness particular encoding method
two issues must addressed first must exists causally valid
plan temporal p encoding p model call
completeness encoding method second must encoding p
model plan causally valid plan p called soundness
encoding method
note prove finite horizon completeness completeness
encodings words prove exists step step plan
l steps given translated step step
encoding satisfiable sat formula l steps model formula
translated back hand proof completeness would need
value l determined proofs finite horizon completeness could implied
completeness least upper bound value l determined recent
field classical shown classical domains
tight upper bounds length optimal plans determined rintanen gretton
however determining upper bounds temporal beyond scope
current work causally valid plan itsat starts encoding
one step sequentially produces tries satisfy formulae increasing number
steps satisfiable formula encountered predefined time limit
reached
classical sat order produce linear size encodings step
step semantics valid plans special sets clauses named chains used
rintanen et al since used chains itsat formal definition
temporal version given let e en arbitrary fixed ordering
events e r two sets events k natural number special symbol
assigns unique name chain hand define chain e en e r k
conjunction formulae c c stated
c

v

eki bkj j ei e ej r ei ej r

c

v

bki bkj j ei ej r ei ej r


fiitsat efficient sat temporal planner

c

v

bki eki ei r

formulae fact encodes message passing strategy symbol specifies
name message used distinguish sat variables certain chain
chains number k specifies step whose variables affected
message produced message may produced member e
receivers message members r bki true means message
received th event k th step formula ei member e eki
true message produced sent ej first member r
located ei fixed ordering represented chain e en e r k
clauses form eki bkj formula c message produced
transmitted forward according fixed ordering clauses form bki bkj
formula c event ei receives message corresponding sat variable
bef alse clauses form bki eki formula c fact members r
receive message certainly excluded final plan
present examples chains practically used guarantee particular characteristics output plan
example assume e e e e four events suppose proposition x
required e e deleted e added e assume four propositions
p p respectively added e e consider following two cases
case want prevent proposition x required deleted
step say k final plan purpose add conjunction
chain e e e r k mx chain e e e r k mx formula e
set events delete x e e e r set events
require x e r e e note mx mx two symbols enable us
distinguish sat variables used two different chains case
adding chain e e e r k mx add following formulae encoding

ek bk mx




bk mx




bk mx


bk mx ek


bk mx ek


assume exists model produced sat encoding
ek true case since satisfies ek bk mx bk mx true


consequently since satisfies bk mx ek ek f alse words

e member step k e cannot member step similarly
adding chain e e e r k mx add following formulae encoding

ek bk mx




firankooh ghassem sani

bk mx bk mx




bk mx






ek

bk mx ek


argument similar one given chain e e e r k mx shows
adding chain e e e r k x e member step k e cannot
member step adding mentioned chains sat
formula execution step k produces p cannot produce p p
actually occurrence conflicting actions step final plan
avoided linear size classical step encoding rintanen et al
case allow proposition x required deleted particular step
k deleting event precede requiring event fixed ordering
e e purpose need add chain e en e r k mx
formula e r e r case case
execution step k produces p produce p p strategy
initially introduced linear size classical step encoding rintanen et al

note one admits second restrictive rule mentioned case
classical step step encodings proposition added event step
deleted another event step execution step
k produces p cannot produce p cases

temporal versions classical step step encodings
first present temporal versions classical step step encodings similar
classical forms temporal versions encodings assume arbitrary
fixed ordering e en events given temporal p g
assume output plan fixed number steps denoted l
let hstep stepl output plan p hs sl state transition
sequence event e let action e member whose starting
ending event equal e let p set propositions p proposition
p p let ep e p del e ep e p add e rp e p pre e e p
inv action e add e moreover assume two dummy events e en
precondition add effect delete effect
step encoding
given temporal p g produce sat formula l
step semantics causally valid plans p conjunction formulae
described
v
p p state p p
state
v l
p p g


fiitsat efficient sat temporal planner



v





v

al



v

ek pk k l p p e rp



v

ek pk k l p p e ep



v



v



v



v



v

ek ak ak k l e start



v

ek ak ak k l e end

ek pk k l p p e ep
v
w
pk pk eep ek k l p p
pk pk

w

eep

ek k l p p

chain e en ep rp en k mp k l p p
bkn mp ak k l p inv


chain en e ep rp e k mp k l p p
bk mp ak k l p inv


formula indicates member state true iff present initial state similarly formula states members goal state must true
state sl formulae imply agenda agenda sl empty
formulae event applied step k preconditions must
present state sk effects must consistent state sk formulae responsible encoding called explanatory frame axioms formula
implies p present step k must exist least
one event step k p add effects similarly formula implies p
present step k must exist least one event step k
deletes p formulae added guarantee events step
executed possible ordering formula implies p deleted
event ei step k p cannot required event ej step k j
implies p deleted event step k action p invariant
cannot member agenda sk note chain e en ep rp k mp
used formula value bn mp indicates whether p deleted
event step k reason dummy event en
indicator analogously formula implies p deleted event ei step k
p cannot needed event ej step k j formula
implies p deleted event step k action p invariant
cannot member agenda sk formulae responsible
applying appropriate changes agendas states located
step final plan formula implies starting event action
member step k output plan must member agenda sk
agenda sk similarly formula implies ending event action


firankooh ghassem sani

member step k plan must member agenda sk agenda sk
theorem completeness temporal step encoding let p g
solvable temporal e en set events p
hstep stepl causally valid step plan p exists model l
plan
proof see appendix
theorem soundness step encoding let p g temporal
e en set events p l step encoding p
l model plan causally valid step plan p
proof see appendix
step encoding
part present sat formula l step semantics
causally valid plans considering two restrictive rules stated step
encoding similar step encoding described previously section however
two major differences two kinds encoding first step
encoding allows proposition required deleted step provided
deleting event precede requiring event fixed ordering sn
contrast step encoding proposition could deleted
required step final plan second step encoding
step may contain starting ending event action given
temporal p g produce sat formula l
step semantics causally valid plans p conjunction formulae described

v
p p state p p
state
v l
p p g
v

v
al
v
ek pk k l p p e rp
v
ek pk k l p p e ep
v
ek pk k l p p e ep
v
w
pk pk eep ek k l p p


v

pk pk

w



v

chain e en ep rp en k mp k l p p bkn mp

eep

ek k l p p


ak k l p inv


fiitsat efficient sat temporal planner



v



v



v



v



v



v



v



v



v



v

eki ak k l ei start ej end j
eki ak ekj k l ei start ej end j
ekj ak k l ei start ej end j
ekj ak eki k l ei start ej end j
eki ak ekj k l ei start ej end j
eki ak k l ei start ej end j
ekj ak eki k l ei start ej end j
ekj ak k l ei start ej end j
ak ak eki k l ei start
ak ak ekj k l ej end

note formulae exactly formulae similar
step encoding formulae responsible validity initial state goal
state conditions effects events explanatory frame axioms explained
moreover notice formula present step encoding
formula formula present l first major difference
stated step encoding step encoding formulae
enforce appropriate changes agenda sk agenda sk agendas
states immediately step k final plan according definitions
formulae added action property start
located end fixed ordering en formula ensures
started step k open sk formula guarantees
started ended step k must open sk formula ensures
ended step k open sk formula implies ended
started step k must open sk analogously formulae
guarantee similar properties action property start located
end fixed ordering en formula ensures member
agenda sk agenda sk must started step k similarly formula
ensures member agenda sk agenda sk must ended step
k
since step encoding conforms two restrictive rules stated earlier
section may exist step causally valid plan l steps given
l would unsatisfiable case linear size step encoding classical rintanen et al however since
showed theorem step encoding complete completeness step
encoding proved showing satisfiability l entails satisfiability l
theorem completeness step encoding let p g solvable temporal e en set events p hstep stepl
causally valid step plan p exists model l plan


firankooh ghassem sani

proof see appendix
theorem shows step encoding number required steps
solve temporal less equal required step
encoding words step encoding compact step counterpart
theorem soundness step encoding let p g temporal
e en set events p l step encoding p
l model plan causally valid step plan p
proof see appendix
relaxed step encoding
mentioned section step encoding allows proposition
required deleted two events step deleting event
precede requiring event fixed ordering en besides since formulae
present step step encodings proposition
added deleted step encodings restrictions
present classical step step encodings rintanen et al lifted
relaxed version step encoding proposition required
added deleted step many times needed property
previously examined classical step encoding consequently chaining mechanism
explained section compatible introduce generalized version
chains explain conceptual difference used classical encodings
present kinds chains used specially temporal preserving
invariants temporal actions plan produced note similar
non relaxed step encoding assume events step executed
according fixed ordering en
let k natural number e en fixed ordering events reasons discussed later assume ei starting event action ei
ending event action words assume ending event
action located immediately starting event fixed ordering note
demand end action immediately follow start final plan
put constraint fixed ordering cannot compromise completeness
itsat sat solver still choose start action step k choose whatever
actions needed steps k k arbitrary choose end
step k moreover suppose two dummy events e en
precondition add effect delete effect let p set propositions
p proposition p p let ep e p del e ep e p add e op e p
inv action e e en rp e p pre e e p inv action e add e
define chain e en ep ep rp k mp conjunction formulae c
c stated note mp symbol used distinguishing sat varibales
used formula chain e en ep ep rp k mp variables used
formulae



fiitsat efficient sat temporal planner

c

v

eki bkj mp j ei ep ej rp ep ei ej rp ep

c

v

eki bkj mp j ei ep ej rp ep ei ej rp ep

v

bki mp bkj mp j ei rp ep ep ej r ep ep ei ej
rp ep ep
v
c bki mp eki bkj mp j ei ej rp ep ep ei ej rp ep
ep
v
c bki mp eki bkj mp j ei ej rp ep ep ei ej rp
ep ep
v
c bki mp eki ei rp

c

c bk mp pk
c bkn mp pk
fact chain e en ep ep rp k mp encodes message passing method
different chain e en e r k chain e en ep ep rp k mp
conveyed message fact value proposition p therefore true
f alse similar message passing strategy chain e en e r k received
message transferred forward direction fixed ordering e en
event ep ep rp receives message previous event fixed ordering
every event may may change value received message cases
message passed next event events ep change value
received message true events p add effects similarly
events ep change value received message f alse formulae
c c impose changes value received message event
member ep ep neither adds deletes p thus pass received
message without altering value enforced c c c ensure
received messages passed without changed events
chosen stepk output plan according c event rp receives
message value f alse event cannot chosen member stepk
members rp require p necessitates received messages
value true c implies initial value message produced stepk equal
value p state immediately execution stepk similarly c
implies value p state immediately execution stepk
equal final value message stepk
example consider events given example let e set events
add x e e e set events delete x e e
r set events require x e r moreover suppose
two dummy events e e precondition add effect
delete effect assume added chain e e e e r e e k mx


firankooh ghassem sani

sat formula according formulae c c chain conjunction
following formulae
ek bk mp
ek bk mp
bk mp bk mp
bk mp bk mp
bk mp bk mp
bk mp ek bk mp
bk mp ek bk mp
bk mp ek bk mp
bk mp ek bk mp
bk mp ek bk mp
bk mp ek bk mp
bk mp ek bk mp
bk mp ek bk mp
bk mp ek bk mp
bk mp ek bk mp
bk mp ek
bk mp ek
bk mp ek
bk mp ek
bk mp xk
bk mp xk


fiitsat efficient sat temporal planner

straightforward examination shows model chain mentioned ek ek ek ek ek ek true
bk mp bk mp bk mp bk mp bk mp true bk mp f alse
words x deleted e stepk final plan later produced
e e appear stepk bk mp f alse represents
fact x deleted execution e example four propositions
p p p p produced single step final plan note neither
cases example producing propositions one step possible
example step encoding employs generalized message
passing strategy permit parallelism allowed temporal versions
classical step step encodings
addition chain e en ep ep rp k mp responsible tracking
value p inside stepk need extra formulae prevent p deleted
whenever p invariant open temporal action therefore introduce two
ob

ob
chain formulae chainof e en ep op k mof
p chain e en ep op k mp
formula chainof e en ep op k mof
p produced conjunction formulae


c c similar chains explained mof
p symbol used distinguish sat varibales chain formulae
v
cof eki bk j ei ep ej op ei ej op
j mp

cof

v

bk

cof

v

bk

ekj eki ei op ei start ej end

cof

v

bk

ak eki ei start ei op

mof
p

bk

j mof
p

j mof
p

n mof
p

j ei ej op ei ej op

similar chain e en ep rp k mp chainof e en ep op k mof
p represents
message produced sent forward direction fixed ordering whenever
proposition p deleted event cof cof responsible production
propagation mentioned message respectively cof ending event
action p invariant receives message step k step k must
include starting event cases cof prevents open p
deleted assume fixed ordering ending event
action located immediately starting event cof guarantees p deleted
somewhere step k action p invariant open step k step
k must include starting event otherwise open everywhere step k
thus p invariant deleted open
chainof e en ep op k mof
p message indicates p deleted sent
forward thus cannot help preserving invariants members op
started prior deletion p tackle add another chain
namely chainob e en ep op k mob
p formula chain quite analogous



chain e en ep op k mp whenever p deleted event chain sends


firankooh ghassem sani

message backward according fixed ordering chainob e en ep op k mob
p
ob
ob
produced conjunction formulae c c
cob

v

eki bkj mob j ei ep ej op ej ei op

cob

v

bki mob bkj mob j ei ej op ej ei op

cob

v

bki mob eki ekj ei op ei start ej end

cob

v

bk mob ak ekj ej end ej op

p

p

p

p

p



present sat formula l represents relaxed step encoding

step semantics causally valid plans l produced conjunction
formulae described
v
p p state p p
state
v
pl p g
v

v
al
v
chain e e en ep ep rp e en k mp k l p p


v

chainof e en ep op k mof
p k l p p



v

chainob e en ep op k mob
p k l p p



v



v

eki ak k l ei start



v

ekj ak k l ej end



v

ekj ak eki k l ei start ej end



v



v

ak ak eki k l ei start

eki ak ekj k l ei start ej end

ak ak ekj k l ej end

ensures member state true member present
initial state similarly guarantees members goal state true
state sl imply agenda agenda sl empty
explained responsible imposing appropriate changes value sat
variables whenever proposition p added deleted event certain step
output plan prevent invariants action deleted
open responsible enforcing appropriate changes
agenda sk agenda sk agendas states immediately


fiitsat efficient sat temporal planner

step k output plan ensures started step k
open sk indicates started ended step k
open sk ensures ended step k open sk
implies ended started step k open sk
ensures member agenda sk member agenda sk
started step k similarly ensures member agenda sk
agenda sk ended step k
theorem know temporal p satisfiable
exists positive number l non relaxed step encoding p l steps
e l satisfiable accordingly completeness relaxed step encoding

proved showing l satisfiable l satisfiable
theorem completeness relaxed step encoding let p g

temporal formulae l l two step encodings p explained

model l l model plan plan
proof see appendix
theorem shows step encoding number required steps
solve temporal less equal required step
encoding provided fixed ordering used two encodings
words step encoding compact step encoding
theorem soundness relaxed step encoding let p g

temporal e en set events p l relaxed

step encoding p l model plan causally valid step plan
p
proof see appendix
mutual exclusion relations action compression
mentioned earlier section performance sat temporal planner
improved mutual exclusion analysis action compression section
information obtained tasks utilized itsat let
p g temporal mu set mutually exclusive
pairs propositions p com set compression safe actions p see

section let l encoding p l l l taking
advantage mutual exclusion relations add extra formula mut
l mut

l
l
v
k
k
p q p q mu k l theorem shows two mutually exclusive
propositions p q never true state achieved execution
valid temporal plan starting adding mut
encoding cannot
l
render planner incapable finding valid plans
let compression safe action showed section safe
assume causally valid plan ending event occurs immediately
starting event one way impose constraint add extra clauses


firankooh ghassem sani

encoding guarantee starting ending events included
step however two events may conflicting effects case l
l allow events present step therefore information

regarding compression safe actions added
relexed step encoding l
v

done adding com
l com
eki eki com ei start
l
l


k l note l ei starting event action ei denotes ending
event

scheduling phase
section describe causally valid plan augmented temporal information
produce valid temporal plan let en causally valid plan produced
planner scheduling done defining scheduling function definition
assigns rational number event execution time suppose
given different names different occurrences action plan
events e en unique assume
thereby satisfy first condition definition however lead plans
unnecessarily large makespans alternatively obtaining plans improved quality
impose relaxed set constraints function
definition relaxed scheduling functions let causally valid plan
scheduling function relaxed scheduling function following properties
j ei located ej ei swappable ej
cf definition require j
j ei starting event particular action ej pairing
event ei cf definition require j dur
theorem let p g temporal en
causally valid plan p n q relaxed scheduling function
exists valid temporal plan p
proof see appendix
theorem shows whenever relaxed scheduling function exists causally valid
plan p valid temporal plan produced p prove scheduling
method render itsat incomplete need p solvable
planner able produce causally valid plan scheduling function
relaxed scheduling function let valid temporal plan
p every causally valid plan regarded causally valid step plan
singleton steps therefore theorem l model plan

theorem satisfies l moreover theorem l model
plan plan therefore encoding methods used
translating p sat formula resulting formula model translated
hand according definition satisfies constraints form
therefore relaxed scheduling function however mentioned


fiitsat efficient sat temporal planner

section may add certain clauses encoding ensure produced
causally valid plan compressed definition solvable temporal plan exists compressed causally valid plan scheduled
valid temporal plan relaxed scheduling function
theorem let p g solvable temporal com
set every member compressible towards start compressible towards end definition exists valid temporal plan p
causally valid plan p compressed respect com
relaxed scheduling function
proof see appendix
check existence function properties stated solve
instance simple temporal stp dechter et al stp associated
weighted graph named simple temporal network stn construct stn
node xi corresponds event ei causally valid plan let arbitrary
small rational number constraint form j add edge
weight xi xj constraint form j dur
add edge weight dur xi xj another edge weight dur
xj xi add reference node x constructed stn x edge
weight every node solution stp found computing
length shortest path form x nodes dechter et al suppose
shortest paths exist length shortest x xi shown
distance x xi event ei define equal distance x xi
case theorem guarantees resulting plan specifications valid
temporal plan
see intuition behind explained method defining function suppose constructed stn edge weight xi xj
means distance x xj distance x xi implies distance x xi
distance x xj turn implies distance x xi distance x xj
j similarly easily shown exists edge
weight dur xi xj another edge weight dur xj xi
j dur bellman ford cormen leiserson rivest
stein used single source shortest paths weighted graph
polynomial time besides number nodes produced stn equal
number events causally valid plan therefore conclude
mentioned shortest paths exist computed polynomial time
however situations shortest paths exist happens
corresponding stn negative cycle situations stp inconsistent
consequently temporal constraints cannot satisfied time
example case depicted figure
figure action adds propositions p g starting ending events
respectively needs proposition q precondition ending event action b requires
p upon starting adds q upon ending durations actions b
respectively goal reaching fact g bs ae


firankooh ghassem sani

figure negative cycles

causally valid plan start ae end bs start b end b
plan depicted figure plan execution action b must entirely
inside action e b started starting ended ending
however impossible considering fact duration less
b invalidity plan caused fact producing causally valid
plan durations abstracted stn constructed plan figure
depicted figure b bs ae negative cycle total weight

negative cycle prevention
stn causally valid plan includes negative cycle plan cannot transformed
valid temporal plan cases sat solver forced different
solution done adding extra clause least one events
current negative cycle prevented occurring current step however
adding blocking clause planner still produce plans basically
equivalent previous plan instance consider example given figure
suppose bs ae members steps respectively assume
output plan steps forbid exact occurrence negative cycle


fiitsat efficient sat temporal planner

causally valid plan still produced shifting ae layer maintaining
events current steps solution negative cycle
therefore cannot transformed valid temporal plan fact cause
invalidity plan changed exploiting simple structure
negative cycles one prevent reoccurrence cycles effectively
discussion given clear main reason
negative cycles encountered stn particular causally valid plan
specific order events plan fact events negative cycle reoccur
order causally valid plan plan include negative
cycle
temporal p p
regard set possible sequences
events language alphabet
e en n number
events p set sequences events certain p
events appeared
particular order regarded another language straightforward
latter language fact regular language accepted
finite state machine fsm figure c shows finite state machine detects
sequences events ae bs appear according order bs ae
note sake clarity self loop transitions finite state machine
shown figure c
p
definition fsms ap
finite state machine tuple xp

finite set states
finite set alphabet symbols

mapping defining transitions x starting state set
accepting states
adding certain formulae sat encodings one avoid
members given regular language
produced causally valid plans let
p
p temporal p

e en set events p let l
regular
assume l accepted p
finite state machine
p langaue

xi e xj j
p
xi let ei e
eiin e
xj e xi j assume two dummy events e
en precondition add effect delete effect define sat
variable xk k l n x assigning value true xk
means state x operating sequence events steps
k events step k indices less final plan construct
formula
l conjunction formulae stated


v

k j
e e
eki xk
xt k l j xs ei xt ej et
n



ei ej et et



v



v

k j



eki xk
xs k l j ei es ej es es en


ei ej es es

k


xk
xs k l n xs ei es es


e ei es es



firankooh ghassem sani



v

xk n
xk
k l xs





v

xk
k l n



v

xk x k l n

adding
l encoding makes sat solver somehow simulate
behavior finding model represents causally valid plan assume
observing ei causes make transition xs xt moreover let ej first event
ei according fixed ordering e en may cause transition
xt formula guarantees ei member stepk state xs
time observing ei state changed xt next relevant event
xt e ej become aware transition implies ei member
stepk state xs time observing ei remain xs
next relevant event xs become aware current state causes
information regarding state start step propagated first
relevant event step propagates information regarding state
end step next step ensures starting state
place final plan means simulation started
anywhere plan produced enables sat solver detect
strings accepted strings subsequences accepted
finally guarantees never one accepting states

example let finite state machine depicted figure c finite
state machine detects sequences events ae bs appear according
order bs ae assume four events e e ae e bs
e assume two dummy events e e sake simplicity
suppose events e e encoding
two steps consider boolean assignment e e e
e true e f alse words choosing bs
first step ae second step fact plan bs ae
example e e e ae event causes transition
state similarly e e e e e e e e e
e e e e e e e e e e
use formulae stated encode cannot model
produced sat formula contradiction assume model
produced sat formula
starting state hence according true
means state prior checking whether e present first
step final plan


according e
since e true



true must true words verifies e
present first step final plan causes current state



fiitsat efficient sat temporal planner

changed
true implies state prior checking
whether e present first step final plan


according e
since e f alse


true must true words verifies
e present first step final plan causes state
remain
true implies state prior checking whether e
present first step final plan

according e


since e true


true must true words verifies e
present first step final plan causes state changed

true implies state prior checking whether
e present first step final plan


according e
since e true



true must true words finds e
present first step final plan causes state changed

true implies state visiting events
first step final plan


according
since true must

true implies state prior visiting event
second step final plan


according
since true must

true implies state prior checking whether e
present second step final plan


according e
since e true



true must true words verifies
e present second step final plan causes state
changed
true implies state visiting
events first two steps final plan hand accepting
state hence according
f alse clearly
contradiction therefore conclude cannot model produced
sat formula

prove adding
l encoding given prevents planner
producing causally valid plans subsequence events equivalent
string accepted means negative cycle translated
fsm reoccurrence negative cycle avoided translating fsm
sat formula adding formula encoding
p
theorem let p g temporal
e en




set events p l three formulae l l l defined section
p
non empty causally valid plan p obtained solving l let x


firankooh ghassem sani

fsm accepts subsequence em
l encoding
presented exist model l
l
plan
proof see appendix
need adding
l encoding render planner incapable producing plans contain subsequence accepted
p
theorem let p g temporal
e en

set events p l three formulae l l l defined
section let model satisfies l em plan let
p
x fsm accept subsequence
l


encoding composed exists model l l
plan
proof see appendix
explain sequence events introduce negative cycle stn
causally valid plan used prevent similar negative cycles reoccurringp
future
plans produced hand let p temporal

set events p e en causally valid plan p assume stn
representing scheduling function negative cycle n nodes xi xim note
xik node corresponding event eik without loss generality assume
im e events negative cycle ordered order
started finished
let oik set temporal actions p
e action e oik eik
reaching eik sequence ei eim p
ik
consider regular language ln alphabet
defined ln ei ei im eim
ik denotes string symbols ik fact strings ln events
already present current negative cycle inserted sequence
way temporal constraints among ei eim remain unchanged see
exclude events open actions ik consider two hypothetical events eij eij
respectively starting event ending event action therefore
temporal constraint scheduling function form ij ij dur
insert another copy ending event two events
ended execution eij eij longer pairing event
eij mentioned constraint longer exist
theorem let n xi xim negative cycle stn corresponding
causally valid plan e en temporal p xik node corresponding event eik let another causally valid plan p subsequence
member ln defined corresponding stn n
negative cycle
proof see appendix


fiitsat efficient sat temporal planner

consrtucting fsm accepts ln straightforward let fsm theorem
shows added encoding input itsat still
capable finding valid temporal plan provided plan exists

empirical
section preprocessing encoding scheduling methods contribute overall performance itsat since contribution preprocessing
part investigated encoding fixed first analyze performance
three encodings explained section compare performance itsat
several state art temporal planners non numerical temporal
previous international competitions
section theoretically showed novel relaxed step encoding least
compact temporal versions step step encodings fixed ordering e
number steps needed relaxed step encoding solve given less
equal temporal versions step step encodings
empirically relaxed step often needs significantly smaller number steps
compared step step encodings mentioned compactness
causes relaxed step significantly outperform step step encodings
benchmark terms memory speed
section explained two preprocessing methods namely mutual exclusion analysis
action compression section methods contribute
overall performance itsat benchmark purpose compare
four versions itsat itsat without preprocessing itsat mutual exclusion
analysis itsat action compression itsat mutual exclusion
analysis action compression experimental methods
separately enhance performance itsat
section discussed adding certain blocking clauses encoding
one prevent negative cycles reoccurring stns produced
causally valid plans introduced elaborate method preventing negative cycles adding extra clauses certain finite state machines
empirically fsm method crucial efficiency itsat
required concurrency
finally compare performance itsat state art temporal planners namely optic coles et al lpg td gerevini et al
tfd eyerich et al optic tfd different degrees temporal expressivity whereas lpg td temporally expressive e capable solving
required concurrency itsat significantly outperforms
optic tfd competitive lpg td many domains
implementation details
order parse domain validating output plans
produced itsat used val plan validation tool developed
organizers ipc schematic operators given domain instantiated
objects input produce possible valid ground temporal actions itsat


firankooh ghassem sani

performs polynomial reachability analysis recognize actions prepositions
relevant given purpose goal conditions initially
assumed relevant propositions action produces relevant proposition upon
starting ending considered relevant action itsat adds preconditions
starting ending events relevant actions current set relevant propositions
invariants relevant actions added set updating sets relevant
propositions actions repeated changes occur sets
update set relevant propositions omitting relevant propositions
present initial state given omitted propositions
deleted relevant action propositions omitted
start end invariants relevant actions mutual exclusion analysis action
compression methods described section performed sets relevant
actions propositions
mentioned section encoding methods assume exists
predefined fixed ordering events given current implementation
itsat ordering events produced constructing ground actions
taken presumed fixed ordering events starting event action
placed immediately corresponding ending event mentioned ordering
elaborate heuristic methods producing ordering may compact
encoding rintanen et al investigating methods beyond scope
left future
current version itsat use p recosat biere free theshelf system sat solver examined two sat solvers namely
inisat een biere lingeling biere satisfying formulae
however precosat best overall performance among three sat solvers though
lingeling better performance terms memory usage
since p recosat accepts formulae conjunctive normal form cnf formulae described throughout translated equivalent cnf formulae performed simply logical equivalence relations

start formula one step set time limit
three minutes precosat model formula case failure
add three steps formula repeat process model
found predetermined maximum time minutes reached case success
finding model causally valid plan extracted model plan
given scheduling process valid temporal plan scheduling function
fails appropriate fsm generated encoded formula see section
without increasing number steps formula given p recosat
model although parallel solving formulae different number steps
shown effective nave sequential rintanen et al
streeter smith empirical even simple sequential method
sufficient outperform current temporal planners many domains leave
investigation regarding effect parallelism future
experiments explained section conducted ghz corei
cpu gb main memory benchmark used


fiitsat efficient sat temporal planner

sets previous ipcs different domains including
zenotravel rovers depots ipc airport ipc pegsol crewplanning
openstacks elevators sokoban parcprinter ipc driverlog f loortile
matchcellar mapanalyser parking rtam satellite storage turnandopen tms
ipc note domains used different ipcs
domains chosen set recent competition domains
set ipc present experiments
among domains used previous ipcs matchcellar turnandopen tms
include required concurrency sets
temporally expressive planners capable producing valid plans order achieve
better assessment itsat required concurrency used two
extra domains driverlogshift matchlift halsey performed
experiments time window variants satellite airport domains domains
used ipc required concurrency referred throughout
section satellite tw airport tw respectively mentioned domains
required concurrency explained details section
impact different encoding methods
evaluate step step relaxed step encodings produced three different versions itsat namely itsat itsat itsat respectively
versions formula mut encodes mutex relations added
encoding none versions take advantage action compression negative cycle
prevention method described section used three versions itsat
table shows comparison domain among versions regard number
solved
seen table itsat best performance among three
versions fact itsat able solve itsat
itsat furthermore almost solved itsat
itsat solved itsat means relaxed step encoding
significantly efficient temporal versions classical step step
encodings
table shows detailed comparison among mentioned encodings different columns table represent following items name domain
number used encoding method number steps encoding
p recosat terms satisfiability unsatisfiability formula number clauses
variables divided amount time taken p recosat determine
amount memory needed solving formula
encoding method presented two cases unsatisfiable formula
highest number steps satisfiable formula lowest number steps note
produce increased number steps one formula
unsatisfiable symbol used time column cases p recosat
failed model formula seconds presented
domains least one solved least two
planners accordingly openstacks elevators matchcellar rtam omitted


firankooh ghassem sani

domain
zenotravel
rovers
depots
satellite tw
airport tw
airport
pegsol
crewplanning
openstacks
elevators
sokoban
parcprinter
driverlog
floortile
mapanalyser
matchcellar
parking
rtam
satellite
storage
turnandopen
tms
driverlogshift
matchlift
total




























itsat


























solved
itsat


























itsat


























table overall comparison different encoding methods
table moreover satellite storage presented
step step encodings
domain table presents hardest e
greatest number propositions experiments observed
pattern similar chosen domain note
presented table finding first causally valid plan therefore
include information regarding fsm encoding method described
section explain impact fsm negative cycle prevention later
section



fiitsat efficient sat temporal planner

domain

zenotravel

rovers

depots

satellite tw

airport tw

airport

prob encoding steps























































































continued next page


f
f
f



f
f
f



f
f
f



f
f
f



f
f
f



f
f
f






c


v












































































time






































mem
mb





































firankooh ghassem sani

domain

prob encoding steps





pegsol















crewplanning













sokoban














parcprinter













driverlog












floortile














mapanalyser


continued next page


f
f
f



f
f
f



f
f
f



f
f
f



f
f


f
f
f



f
f
f



c


v














































































time







































mem
mb






































fiitsat efficient sat temporal planner

time
domain
prob encoding steps




















f





f




parking



f
























f




satellite



f

















f




storage



f


















f





f




turnandopen


f























f





f




tms



f
























f





f




driverlogshift


f






















table detailed comparison encoding methods
c




v


mem
mb




































firankooh ghassem sani

figure speed comparison itsat itsat

section theoretically showed order solve given
relaxed step encoding requires fewer steps temporal versions classical
step step encodings ordering fixed table shows itsat
often needs considerably smaller number steps phenomenon prominent
airport crewplanning mapanalyser moreover openstacks matchcellar
neither itsat itsat able solve due large number
steps required suggests correlation performance
planner compactness encoding generally speaking relatively
high number steps needed step encoding solve deduce
strong causal connection actions produced plan
hand step encoding devised take advantage causal connections
therefore step encoding expected advantage step encoding
domains phenomenon visible airport crewplanning openstacks
matchcellar domains numbers steps required step encoding
domains exceptionally high table shows relaxed step encoding
significant improvement planner terms memory usage


fiitsat efficient sat temporal planner

figure speed comparison itsat itsat

compared speed itsat itsat itsat
solving benchmark depicted figure figure
seen itsat outperformed itsat itsat almost

impact mutual exclusion analysis action compression
section explained mutual exclusion analysis action compression performed preprocessing components itsat empirically components quite effective enhancing performance planner showed

encoding best performance itsat fixed
formula base comparison produced three formulae investigate

impact preprocessing method three formulae mut base encod
ing plus mutual exclusion information com base encoding plus action

compression information mut com base encoding plus mutual exclusion action compression information table shows number solved
mentioned versions itsat


firankooh ghassem sani

domain
zenotravel
rovers
depots
satellite tw
airport tw
airport
pegsol
crewplanning
openstacks
elevators
sokoban
parcprinter
driverlog
floortile
mapanalyser
matchcellar
parking
rtam
satellite
storage
turnandpen
tms
driverlogshift
matchlift
total



























































mut




























com




























mut com


























table impact mutual exclusion analysis action compression
seen table preprocessing methods significant improvement terms overall coverage fact version itsat uses methods
solves base planner besides version uses methods even considerably outperforms two versions use one preprocessing
method suggest preprocessing components necessary producing
best performance itsat
investigate effectiveness action compression method domains
itsat compresses considerably actions crikey performed another
experiment compressed actions itsat considers compression safe
crikey version itsat used mutual exclusion
information version itsat solves six version


fiitsat efficient sat temporal planner

mutual exclusion information used six four
zenotravel one airport one mapanalyser change
much domains note three mentioned domains itsat
compresses considerably actions crikey
impact fsm negative cycle detection
mentioned earlier among domains used evaluate itsat matchcellar turnandopen tms driverlogshift matchlift time window versions airport satellite
required concurrency fact domains may impossible
schedule causally valid plan produced solving sat formula valid temporal
plan briefly explain domains may require concurrency may introduce negative cycles stn associated
causally valid plan
matchcellar matchlift exists action lighting match action
produces light certain amount time objective mend fuses
actions mending fuse executed light actions
lighting match mending fuse must executed concurrent however causally
valid plan since planner consider durations actions may assume
match remain lit fuses mended discussed section
introduce negative cycle stn produced causally valid plan
tms objective produce certain number ceramic structures
structures need several preparations done furnace producing
heat clear domain similar matchcellar matchlift
requires concurrency similar way
simplified version driverlogshift introduced section difference
simplified version one used section evaluate planners
drivers walk board disembark trucks furthermore
rest work actions performed drivers rather trucks domain
working shifts drivers analogous action lighting match
matchcellar domain
turnandopen exists robot needs move number rooms
doors pair adjacent rooms doors closed
initial state opened robot robot open door
turning doorknob domain actions turning doorknob opening
door must executed concurrently however duration action turning
knob whereas opening door enables itsat schedule every
causally valid plan valid temporal plan therefore preventing negative cycles
necessary domain
time window versions airport satellite specific time
goals must obtained deadline introduced specific
frame action duration equal time deadline actions
executed frame action executed words actions
must concurrent frame action however causally valid plan since
planner consider durations actions may assume frame action


firankooh ghassem sani

domain

satellite tw

airport tw

matchcellar

tms

driverlogshift

matchlift


restarts







c










fsm







v










fsm







memory mb

fsm













table collective size sat encodings fsms
arbitrarily long thereby neglect meet deadline achieving goals
introduce negative cycles stns produced causally valid plans
explained section stn causally valid plan includes negative
cycle must force sat solver different solution done simply
adding extra blocking clause current sat formula prevent least one
events negative cycle reoccurring current step alternatively
introduced elaborate method thing adding encoding
certain fsms encoding method stn causally valid plan
k steps includes negative cycle fsm detects negative cycle encoded
sat formula solver restarted order decrease number
restarts whenever sequence events corresponding negative cycle found itsat
tries potential negative cycles replacing actions current sequence
actions checking stn resulting sequence negative
cycles
table shows collective size sat encodings fsms required solving
domains base encoding used relaxed
step encoding mutual exclusion analysis action compression
domain shown table hardest solved itsat
turnandopen domain excluded table negative cycle encountered
solving domain different columns table represent
following items name domain number number clauses
variables divided amount memory needed produce formula
number causes number variables used memory presented
separated columns base encoding encoding fsms
seen table negative cycle prevention method helps itsat solve
considerable number required concurrency nevertheless sat encoding required fsms significantly larger base encoding domains
number restarts relatively high hand number
restarts increase speed itsat declines restart sat
solver must verify satisfiability formula scratch fact numerous
restarts main reason poor performance itsat time window version
satellite


fiitsat efficient sat temporal planner

itsat versus state art temporal planners
compare itsat three efficient temporal planners namely optic benton
coles coles tfd eyerich et al lpg td gerevini et al
similarities used itsat scp lu
et al included planner experimental
optic newest version popf coles et al heuristic state space
temporal planner called temporally lifted progression cushing
et al enables optic solve
required concurrency besides optic handles self overlapping actions makes
expressive itsat although handling self overlapping actions hardly necessary
solving non numerical temporal fox long among
current benchmark domains zenotravel rovers airport permit actions due
modeling errors fair comparison itsat optic used
corrected versions three domains evaluations guiding search optic
benefits heuristic function relaxed graph hoffmann
nebel
tfd another heuristic state space temporal planner tfd called
decision epoch cushing et al planners use
temporally expressive planners temporally lifted progression words theory temporal defined
pddl solved itsat optic tfd however current benchmark potentially solved decision epoch
guiding search tfd benefits temporal version called context enhanced
additive heuristic helmert geffner
lpg td fast temporal planner temporally expressive fact
lpg td first generates sequential plan given tries reschedule
plan produce one improved quality renders lpg td incapable
solving matchcellar turnandopen tms driverlogshift matchlift similar
optic lpg td benefits heuristic relaxed graph however
instead searching state space lpg td performs search making
local improvements structure similar partial plans called linear
action graph two different configurations lpg td used whether
prefer speed planner quality produced plans present
quality configuration lpg td produced better speed
configuration experiments
scp lu et al sat temporal planner uses discrete representation time planner assigns explicit discrete time labels step encoding
step exactly one time unit ahead step
action duration starts step forced end step means
number layers required producing plan greater equal makespan
spc starts formula one step increases number steps
one every time formula unsatisfiable enables spc optimal plan
corrected version mentioned domains downloaded official website popf
planner



firankooh ghassem sani

number given obtain better performance scp uses step semantic
allow causal relations actions time point
compared itsat planners number
solve domain total score given planner
scoring strategy recent ipcs planner cannot solve get
score otherwise score equal makespan best
produced plan divided makespan plan found planner
presented table
seen table itsat significantly outperforms optic tfd scp
fact itsat solves optic tfd
scp itsat solves lpg td however
mainly lpg td incapable solving required concurrency
exclude satellite tw airport tw matchcellar turnandopen tms driverlogshift
matchlift domains lpg td cannot solve itsat solves
less lpg td shows itsat quite competitive
lpg td even solving without required concurrency
shown table optic solves zero parcprinter driverlog floortile
mapanalyser matchcellar rtam storage tms domains main reason
poor performance optic runs memory early search tfd
solves zero satellite tw airport tw parcprinter driverlog floortile rtam storage
tms except parcprinter tfd runs memory domains
tfd performs poorly unable plan within seconds
mentioned lpg td solves zero domains required concurrency
performance scp rather poor many benchmark domains reason
poor performance scp many benchmark makespan
optimal plan relatively large scp unable
check satisfiability formulae numbers steps less makespan
optimal plan within seconds time limit
compare quality plans produced itsat competing
planners consider table numbers presented table average makespan
ratio plans mutually solved corresponding planner itsat corresponding
domain ratios less one indicate better average quality solutions produced
itsat comparison competing planners cases neither itsat
competing planner able solve domain corresponding
cell table remained blank
performed experiments number two planners portfolios
different pairs planners portfolios enabled us combine advantages
two planners minutes time limit divided equally pair
planners running portfolios presented table
best configuration obtained combining itsat lpg td
resulting planner capable solving benchmark moreover
planners produced best combined itsat



fiitsat efficient sat temporal planner

solved

domain

n

zenotravel





rovers



depots

itsat

optic

scp

ipc

score

itsat

optic

tfd

lpg td

scp

tfd

lpg td





























































satellite tw























airport tw























airport























pegsol























crewplanning























openstacks























elevators























sokoban























parcprinter























driverlog























floortile























mapanalyser























matchcellar























parking























rtam























satellite























storage























turnandopen























tms























driverlogshift























matchlift























total













table itsat versus state art temporal planners





firankooh ghassem sani

domain
zenotravel
rovers
depots
satellite tw
airport tw
airport
pegsol
crewplanning
openstacks
elevators
sokoban
parcprinter
driverlog
floortile
mapanalyser
matchcellar
parking
rtam
satellite
storage
turnandopen
tms
driverlogshift
matchlift

optic

tfd

lpg td

scp





































































































table average makespan ratio

itsat
optic
tfd
lpg td
scp

itsat






optic






tfd






table planners portfolio



lpg td





scp






fiitsat efficient sat temporal planner

figure speed comparison itsat optic

although itsat quite competitive state art temporal planners
empirical reveal drawbacks planner compared speed
itsat optic tfd lpg td scp benchmark
presented figure figure figure figure respectively
figures required concurrency domains separated
domains different symbols scatterplots star symbol
represents required concurrency diamond symbol represents
seen itsat slower optic tfd lpg td
number benchmark major cause drawback itsat
sat solver spends much time refuting several formulae finally
first satisfiable formula shown case classical speed
sat planners significantly improved checking satisfiability several
formulae different number steps parallel discuss detail section
future
another observation itsat performs rather slowly solving number
required concurrency quickly solved optic tfd
mainly due restarting sat solver whenever negative cycles encountered


firankooh ghassem sani

figure speed comparison itsat tfd

explained earlier stn causally valid plan k steps includes negative
cycle fsm detecting negative cycle encoded sat formula
solver try satisfy formula k steps scratch domains
negative cycles abundant performance itsat significantly affected
numerous restarts sat solver
performance itsat particularly poor three domains namely elevators
driverlog rtam domains number ground actions higher
domains linear increase number ground actions may cause
exponential growth size search space tackle
state space planners take advantage heuristic functions devised specially
pruning search space shown sat
solvers tailored solving significant improvement
performance sat classical rintanen think employing
idea improve speed itsat mentioned domains
another drawback itsat poor quality produced plans benchmark
domains notably although itsat solves depots openstacks
parking satellite quality plans rather low domains according


fiitsat efficient sat temporal planner

figure speed comparison itsat lpg td

table mainly due fact itsat abstracts duration actions
thus sat solver lacks competency evaluating quality plans
produced nevertheless quality plans produced itsat generally
comparable planners benchmark domains section explain
idea improving quality plans produced itsat

conclusions future
described itsat temporally expressive sat planner itsat
takes advantage parallel encodings first
durations actions given abstracted abstract
encoded sat formula step step semantics causally valid plans
generating causally valid plan itsat performs scheduling process
process itsat tries satisfy temporal constraints imposed considering
durations actions done solving simple temporal stp
cases inconsistent stp cause negative cycle corresponding
simple temporal network stn detected itsat adds certain clauses sat
formula hand prevent reoccurrence negative cycles process


firankooh ghassem sani

figure speed comparison itsat scp

repeated temporally valid plan produced predefined time limit
reached
main contributions summarized follows
introduced novel method detect temporal actions compressed
classical ones compression technique performed preprocessing task
thus independent used
temporal planner makes compression technique general
popf specifically tailored planner empirical showed
action compression improved performance itsat
empirically showed method capable detecting compression safe
temporal actions previous action compression method used popf
introduced three encoding methods concept parallel plans
sat temporal two methods adopted
classical third method produces compact formulae
employed itsat first time empirical
encoding significantly enhance performance sat temporal


fiitsat efficient sat temporal planner

introduced method avoid producing plans members given
regular language set events done embedding sat
encoding particular fsm accepts language sat encoding
input used method preventing temporal inconsistencies
produced causally valid plans reoccurring subsequent causally valid
plans experiments showed method contributed considerably
performance itsat current benchmark required concurrency
according empirical taking advantage approaches
itsat outperform state art temporally expressive planners
competitive efficient temporal planners handle required concurrency nevertheless believe performance itsat improved several
ways discussed
current version itsat satisfiability formulae different number
steps checked sequential manner starting formula encoding one step
means sat solver refute several formulae finds first satisfiable
formula time required checking satisfiability formulae increased
number steps policy would best performance itsat however
almost never case shown case classical fixed
time needed finding model satisfiable formula usually
considerably less time needed refuting unsatisfiable formula rintanen et al
experiments phenomenon happens case temporal
similar sat classical one take advantage
phenomenon checking satisfiability formulae different numbers steps
parallel applicability parallelisms sensistive amount
memory required saving formulae shown section newly
introduced step encoding considerably efficient temporal version
classical step encoding terms memory usage suggests step
encoding suitable employing parallelism
linear sized classical step step encodings encoding methods
assume exists predefined fixed ordering events given
ordering great impact number steps needed solving input
example consider sequential plan ground action applied
potential plan subsequence mentioned fixed ordering
one step sufficient finding plan hand case reversed
fixed ordering number steps would required model might
large size plan current implementation itsat ordering
events produced constructing ground actions taken predefined
fixed ordering events however considering causal relationships among actions
given one might able effective orderings would
fewer steps solving believe enhancement would
improved version itsat efficient terms speed
memory usage
current version itsat uses shelf general purpose sat solvers
means advancement designing solvers improve performance
itsat recent investigations field sat classical shown


firankooh ghassem sani

designing sat solver tailored solving much improved
performance sat planners particular efficient sat classical
planner mp rintanen able competitive sate art
state space planners employing idea since causal structures temporal
generally similar classical
believe itsat benefit enormously employing oriented sat solver
mentioned section one main drawbacks itsat poor quality
produced plans benchmark domains mainly due fact
itsat abstracts duration actions thus sat solver
needed resources evaluating quality plans produced alternatively one add explicit representation time encoding shin davis
done smt solvers armando giunchiglia handle continuous variables however discussed section solution may
considerably slower search think itsat benefit combination
two approaches first plan produced itsat proceed
introducing appropriate numerical constraint sat formula hand use
smt solver produce improved plans subject ongoing
finally mention components itsat used
fields ai notably step encoding employed
sat classical empirical encoding method
quite effective reducing number steps needed produce valid plans several
temporal domains classical version think improved
performance step encoding comparison step encoding achieved
classical moreover section showed prevent members
given regular language events input produced
output plan used method prevent itsat producing temporally invalid
plans method employed enforce variety constraints plan
produced example consider case require certain actions
executed specific order must clear set plans violating
constraint regarded regular language set actions therefore
constraint introduced encoding method
discussed section

acknowledgments
authors would thank handling editor jorg hoffmann anonymous
reviewers invaluable contributions quality

appendix proofs
theorem let p g temporal p c state g ac
causal abstraction p assume en sequence events
applicable sn succ following conditions must hold
two propositions p q members state sn p q non mutex
layer n graph p c


fiitsat efficient sat temporal planner

proposition p member state sn action member agenda sn
p opena non mutex layer n graph p c
proof give proof induction n length n e
event applied conclusions obviously hold every member state
present first layer graph mutex first layer
agenda definition suppose conclusions hold n k
hold n k assume ek sequence events
applicable sk succ sk succ ek
let p q two members state sk three possible cases
case p q members sk induction hypothesis p
q non mutex layer k graph p c thus noopp noopq
non mutex layer k hence p q mutex layer k
case neither p q members state sk definition p q
must members add ek assume ek ending event action
case ek starting event analogous thus omitted
since ek applicable state sk definition members pre ek must
members state sk must member agenda sk therefore
induction hypothesis members pre ae non mutex layer k
p q definition added ae non mutex
layer k
case p member state sk definition q must member
add ek p cannot member del ek assume ek ending event
action case ek starting event analogous thus
omitted induction hypothesis members pre ae non mutex
layer k definition ae delete p therefore ae present
layer k cannot mutex noopp p q non mutex
layer k
let p member state sk action member agenda sk
two possible cases
case member agenda sk started yet ended
reaching sk invariants members state sk
induction hypothesis invariants must non mutex layer k hence ai
present layer k definition ai adds opena must p
added action mutex ai layer k p member
state sk induction hypothesis p present layer k therefore
noopp mutex ai applicable layer k p
opena mutex layer k hand p member
state sk must added ek since ek applicable sk member
agenda sk definition ek cannot delete invariant assume ek
ending event action b case ek starting event b analogous
thus omitted induction hypothesis mutex


firankooh ghassem sani

ai must applicable layer k means p opena mutex
layer k
case member agenda sk definition ek must
starting event delete p moreover definition starting
invariants must present state sk therefore induction hypothesis
applicable layer k p present state sk must added
ek definition propositions added starting event
added since adds opena p opena cannot mutex layer k
hand p member state sk induction hypothesis
p present layer k therefore noopp mutex applicable
layer k means p opena mutex layer k

theorem let p g solvable temporal let set
every member compressible towards start compressible towards
end compression safe p
proof let causally valid plan p plan must exist p solvable
starting produce sequence causally valid plans swapping events
next plan hand assume arbitrary order ha
members without loss generality assume action repeated
otherwise different names given different occurrences action
eliminate repetition producing causally valid plan consider
causally valid plan ai compressible towards start keep swapping ending
event ai previous event previous event becomes starting
event ai fact swaps collectively cause ai become compressed towards
start swaps never falsify causally valid plan hand assume
e event immediately prior ending event ai causally valid plan e
starting event ai precondition effect e must present
least one state whose agenda includes ai thus theorem precondition
effect e mutex openai last layer levelled graph
causal abstraction p definition e must swappable ending
event ai therefore causally valid plan starting ending events
ai located next similarly ai compressible towards end keep
swapping starting event ai next event next event becomes
ending event ai n ending event members located
next corresponding starting events therefore according definition
compression safe p
lemma let e en set events e r two subsets assume
subset ei e ej
r j let
function defined following rules assigns value true f alse
sat variable chain e en e r k


fiitsat efficient sat temporal planner

eki true ei member
bki true ej e j
satisfies chain e en e r k
proof satisfies formulae c c therefore satisfies
chain e en e r k

c consider arbitrary formula eki bkj formula c ei
eki f alse thus formula trivially satisfied consider case
ei definition formula c know j ei e
therefore according definition must bkj true thus
formula satisfied
c consider arbitrary formula bki bkj formula c bki
f alse formula trivially satisfied hand bki true
must exist l l el e since j must
l j therefore bkj true hence formula satisfied
c consider arbitrary formula bki eki formula c bki
f alse formula trivially satisfied hand bki true
must exist l l el e according
properties must ei
r however definition
chain e en e r ei r ei
therefore
k
ei f alse formula satisfied

lemma let e en set events e r two subsets assume
model chain e en e r k ei e eki true
j ej r bkj true consequently ekj f alse
proof suppose sequence e en event ej first event ei
ej r since formula c chain e en e r k eki bkj
bkj true similarly sequence e en event ej first event ej
ej r must formula bkj bkj c implies
bkj true repeating argument latter case infer
j ej r bkj true according c
ekj f alse
theorem completeness temporal step encoding let p g
solvable temporal e en set events p
hstep stepl causally valid step plan p exists model l
plan


firankooh ghassem sani

proof construct function assigns true f alse sat variables
formula l let hs sl state transition sequence defined
following rules
proposition p k k l pk true iff p
member state sk
action k k l ak true iff member
agenda sk
n k k l eki true
iff ei member stepk moreover k k l ek
ekn f alse
proposition p n k k l
bki mp true iff exists event ej j ej ep ej stepk


proposition p n k k l
bki mp true iff exists event ej j ej ep ej stepk


satisfies formulae therefore model l note
way constructed directly plan
according definition thus formula clearly satisfied
according definition g state sl thus formula clearly
satisfied
according definition agenda thus formula clearly
satisfied
according definition agenda sl thus formula clearly
satisfied
let p arbitrary proposition e event e rp e
stepk
ek f alse therefore formula trivially satisfied consider
case e stepk according definition stepk must step sk
sk thus definition possible ordering events stepk
must able execute events according ordering starting state
sk one possible ordering specific ordering puts e front
events therefore e must applicable sk definition
p state sk implies pk true satisfaction
formula easily follows
stepk
let p arbitrary proposition e event e ep e
ek f alse therefore formula trivially satisfied consider
case e stepk similar previous case starting state sk
must able execute events stepk possible ordering reach sk


fiitsat efficient sat temporal planner

one possible ordering one puts e events therefore addeffects e must members state sj definition p state sk
implies pk true satisfaction formula easily
follows
stepk
let p arbitrary proposition e event e ep e
k
e f alse therefore formula trivially satisfied otherwise
argument given case p
state sk satisfaction
formula easily follows
let p arbitrary proposition consider nontrivial case p member
state sk state sk easily derived definition p
added application sequence events least one events
must add p implies satisfaction formula
case analogous case
lemma used prove satisfies chain e en ep rp en k mp
straightforward see properties model lemma
need proposition p provided ei stepk ep
j ej
stepk rp suppose ej stepk definition
possible ordering events stepk must able execute events
according ordering starting state sk one possible ordering
one puts ei immediately ej notice ei deletes p
ei ep thus ej cannot p precondition ej
rp infer
ej
stepk rp therefore lemma satisfies chain e en ep rp
en k mp satisfies bkn mp ak consider


nontrivial case bkn mp true way construct

least one e en say ej must delete p since stepk step sk
sk must able execute events stepk possible ordering
reach sk consider specific ordering puts ej events
agenda sk according definition ej cannot ending event
therefore definition member agenda state
ej applied clearly contradicts applicability ej ej deletes p
invariant therefore ak f alse implies satisfies
bkn mp ak


case lemma used prove satisfies chain en e ep rp
e k mp similar previous case straightforward confirm
properties lemma since ordering chain e en ep rp
en k mp reversed chain en e ep rp e k mp need
proposition p provided ei stepk ep j ej

stepk rp suppose ej stepk definition possible ordering
events stepk must able execute events according
ordering starting state sk one possible ordering one
puts ei immediately ej argument one given case


firankooh ghassem sani

infer ej
stepk rp therefore lemma satisfies
chain en e ep rp e k mp satisfies bk mp


ak consider nontrivial case bk mp true way

construct least one e en say ej must delete p stepk
step sk sk starting state sk must able execute
events stepk possible ordering consider specific ordering puts ej
events definition since ej deletes p invariant
cannot member agenda sk therefore ak f alse implies
satisfies bk mp ak


assume e starting event action stepk step sk
sk starting state sk must able execute events stepk
possible ordering consider specific ordering puts e
events therefore e must applicable sk definition cannot
member agenda sk thus ak f alse see ak true
consider specific ordering events puts e events events
executed ordering applying e appear state sk
thus must member agenda sk hence satisfies ek ak ak
analogous case assume e ending event action since stepk
step sk sk starting state sk must able execute
events stepk possible ordering consider specific ordering puts e
events therefore e must applicable sk definition
must member agenda sk thus ak true see
ak f alse consider specific ordering events puts e
events events executed ordering applying e
appear state sk thus cannot member agenda sk conclude
satisfies ek ak ak

theorem soundness step encoding let p g temporal
e en set events p l step encoding p
l model plan causally valid step plan p
proof obtain plan follows k k l let stepk
set events e ek true k k l let
sk temporal state assume state sk set propositions p
pk true agenda sk set actions ak true
plan hstep stepl causally valid step plan p
state transition sequence hs sl
formula immediately follows state formula implies
g state sl formulae respectively imply agenda
agenda sn empty sets need k k l
stepk e em e en step sk sk first


fiitsat efficient sat temporal planner

proposition p stepk cannot include two different events ei ej ei rp
ej ep j since satisfies formula lemma infer eki
ekj cannot equal true hand j since satisfies formula
lemma infer eki ekj cannot equal true
thus ei ej cannot members stepk let
arbitrary ordering function induction k k sequence
heo eo k applicable sk k e case event
applied sk conclusion trivially holds induction hypothesis let sk
temporal state resulting applying sequence heo eo k sk let eo k
starting event action omit similar case eo k ending
event conditions definition hold thereby eo k
applicable sk heo eo k applicable sk
formula easily follows preconditions eo k invariants except invariants added eo k members
state sk mentioned neither propositions deleted
another member stepk thus propositions members state sk
formula easily follows member agenda sk notice
according definition starting event e eo k event
add agenda state therefore cannot member agenda sk

let action invariant p p del eo k clearly
start rp thus argued start eo k cannot
members stepk hence start
stepk hand since p deleted
step k satisfies chain en e ep rp e k mp according lemma
b mp true therefore formula infer ak
f alse thus
agenda sk start
stepk
agenda sk jointly


imply
agenda sk
sm applying heo eo sk equal
sk
let p arbitrary member state sm formulae follows
p deleted member stepk cannot added member
therefore p deleted
stepk thus p cannot member

wof state
k
member stepk formula eep e satisfied besides p
added member stepk must member state sk thus
pk true formula infer pk true hence
p state sk hand p added member stepk formula
deduce pk true p state sk therefore
state sm state sk
let p arbitrary member state sk according formula p cannot
deleted member stepk besides formula p member


firankooh ghassem sani

state sk added member stepk cases definition implies
p state sm therefore state sk state sm
let arbitrary member agenda sm formulae
follows starting ending events single action members
stepk agenda sk still open state sm infer
end
stepk therefore according formula ak true must
member agenda sk hand
agenda sk start
must member stepk formula ak true
must member agenda sk therefore agenda sm agenda sk
let arbitrary member agenda sk according formula start
cannot member stepk besides formula member
agenda sk start member stepk cases definition implies
agenda sm therefore agenda sk agenda sm
argument shows state sk state sm agenda sk agenda sm hence
sk sm succ sk heo eo therefore stepk step sk sk
theorem completeness step encoding let p g solvable temporal e en set events p hstep stepl
causally valid step plan p exists model l plan
proof theorem exists model l plan
translated model l since formulae shared
l l satisfies formulae satisfies
formulae therefore translated model l
following cases arbitrary temporal action ei starting event ej
ending event
eki f alse formula trivially satisfied eki true
formula ak f alse therefore formula satisfied
eki f alse formula trivially satisfied eki true
formula ak true therefore formula satisfied
ekj f alse formula trivially satisfied ekj true
formula ak f alse therefore formula satisfied
ekj f alse formula trivially satisfied ekj true
formula ak true therefore formula satisfied
exactly case
exactly case
exactly case
exactly case


fiitsat efficient sat temporal planner

follows immediately fact satisfies formula
follows immediately fact satisfies formula

theorem soundness step encoding let p g temporal
e en set events p l step encoding p
l model plan causally valid step plan p
proof obtain plan follows k k l let stepk
set events e ek true moreover k
k l let sk temporal state assume state sk set propositions p
pk true agenda sk set actions ak true
construct plan hstep stepl causally valid step
plan p state transition sequence hs sl
formula immediately follows state formula implies
g state sl formulae imply agenda agenda sn
empty sets need k k l
stepk e em e en step sk sk without loss generality
assume sequence em ordered fixed ordering en note
since satisfies formula lemma proposition p stepk cannot include
two events ei ej ei rp ej ep j induction k
every k sequence ek applicable sk k e
case event applied sk conclusion obviously holds induction
hypothesis let sk temporal state resulting applying sequence ek
sk assume ek starting event action omit similar case
ek ending event conditions definition
hold thereby ek applicable sk
formula clearly preconditions ek invariants
except invariants added eo k members state sk
stated neither propositions deleted ei k thus
propositions members state sk
two possible cases consider first case according fixed
ordering en ending event located ek formula implies
cannot member agenda sk notice according definition
starting event e ek event add agenda
state therefore cannot member agenda sk case
ending event located ek formula implies
member agenda sk end member stepk however end
member stepk certainly remove agenda resulting state since
ek event add agenda state conclude
cannot member agenda sk therefore neither two cases
member agenda sk


firankooh ghassem sani

let action p del ek invariant since p deleted step k
satisfies chain e en ep rp en k mp according lemma
bn np true therefore formula
agenda sk
hand clearly end rp thus argued end
member stepk cannot located ek fixed ordering en
hence member agenda sk cannot member agenda sk
therefore infer
agenda sk
sm applying em sk equal sk
argument given proof theorem state sm state sk
state sk state sm hence state sm state sk
let arbitrary member agenda sm let ei ej starting ending
events respectively three possible cases consider first case
agenda sk ei
stepk ej
stepk e open immediately step
k neither started ended step k case since satisfies
ak true therefore agenda sk consider second case
agenda sk ei stepk ej stepk j e open immediately
step k first ended started step k case since
satisfies formula ak true therefore agenda sk
finally consider third case
agenda sk ei stepk ej
stepk
e open immediately step k started ended
step k case j must satisfy formula
ak true hand j must satisfy formula
since ekj f alse must ak true therefore agenda sk
consequently three cases must member agenda sk hence
agenda sm agenda sk
let arbitrary member agenda sk e ak true two
possible cases case member agenda sk hence ak
f alse formula eki true means started
step k j ending event cannot happen starting event
therefore must remain open execution step k e agenda sm
hand j formula ekj f alse
means started ended step k therefore must remain open
execution step k e agenda sm consider case
member agenda sk hence ak true j formula
eki f alse formula ekj f alse means
open immediately execution step k neither started
ended step k therefore must open execution step k e
agenda sm hand j since ak ak
false formulae combined form formula eki ekj
means ended step k later started
step therefore must open execution step k
agenda sm therefore agenda sk agenda sm


fiitsat efficient sat temporal planner

arguments state sk state sm agenda sk agenda sm hence
sk sm succ sk em therefore ordering functions
sk succ sk heo eo thus stepk
step sk sk
lemma let model chain e en ep ep rp k mp ej member
rp epm e e ep ep ek true following properties
exists event ei ei epm j bkj mp pk
exists event ei ei ep j ei ej epm
eki true bkj mp true
exists event ei ei ep j ei ej epm
eki true bkj mp f alse
proof
assume exists event ei ei epm j consider
case pk true let ei eim set events ei
ei rp ep ep j without loss generality
assume im j since must satisfy c know
bki true assume arbitrary bkis mp true eis ep ep


p

know ekis f alse c bki


mp

hand eis

rp ep ep



c



bki
p


true

true infer

j bkis mp true thereby bkj mp pk
proof case pk f alse analogous except
instead c need use c
assume exists event ei ei ep j ei ej
epm eki true let ei eim set events ei
ei rp ep ep j without loss generality assume
im j since must satisfy c know bki true


p

assume arbitrary bkis mp true eis ep ep
know ekis f alse c bki
hand eis rp

ep



true
mp
k

bi true infer
p

k
bis mp true thereby bkj mp true

ep

j

c

assume exists event ei ei ep j ei ej
epm eki true let ei eim set events ei
ei rp ep ep j without loss generality assume


firankooh ghassem sani

im j since must satisfy c know bki f alse


p

assume arbitrary bkis mp f alse eis ep ep
know ekis f alse c bki
hand eis rp

ep



f alse
mp
k

bi f alse infer
p

k
bis mp f alse thereby bkj mp f alse

ep

j

c


lemma let model chain e en ep rp k mof
p assume ei ep
eki true p inv let ej ej starting event ending event
respectively following properties

ekj true j ekj true
ak true ekj true
proof let ei eim equal set es es op n without loss
generality assume im n since eki true
cof infer bi mof true bis mof true
p

p

cof deduce bis mof true therefore bn mof true
p
p
furthermore j ej ei eim thus bj mof true besides
p

ekj true cof ekj true hand ak
true infer formula cof ekj true

lemma let model chain e en ep rp k mob
p assume ei ep
eki true p inv let ej ej starting event ending event
respectively following properties

ekj true j ekj true
ak true ekj true
proof proof analogous lemma thus omitted
theorem completeness relaxed step encoding let p g

temporal formulae l l two step encodings

p explained section model l l model
plan plan
proof let model l construct function assign value true

f alse binary variable l following rules
r n k l eki eki


fiitsat efficient sat temporal planner

r k l ek ekn f alse
r k l proposition p pk pk
r k l action ak ak
r n k l proposition p exist j
ekj true ej ep ep bki mp pk otherwise bki mp
pk
r n k l proposition p exist j
ekj true ej ep bk true otherwise bk f alse
mp

mp

r n k l proposition p exist j
ekj true ej ep bki mob true otherwise bki mob f alse
p

p

satisfies formulae therefore model

l rules clear plan plan
formula exactly besides assign
value variable formula
formula exactly besides assign
value variable formula
formula exactly besides assign
value variable formula
formula exactly besides assign
value variable formula
formula conjunction formulae c c
satisfies formulae c c thereby satisfies
consider arbitrary formula eki bkj mp c eki f alse
formula trivially satisfied eki true r
bki mp pk hand satisfies
pk true therefore bki mp true formula satisfied
consider arbitrary formula eki bkj mp c eki f alse
formula trivially satisfied eki true r
bki mp pk hand satisfies
pk f alse therefore bki mp f alse formula satisfied

consider arbitrary formula bki mp bkj mp c since ei
member ep ep none events located ei ej
fixed ordering members ep ep r easily
bki mp bkj mp thus formula satisfied


firankooh ghassem sani

consider arbitrary formula bki mp eki bkj mp c eki
true formula trivially satisfied eki f alse since none
events located ei ej fixed ordering members
ep ep r easily bki mp bkj mp thus
formula satisfied
consider arbitrary formula bki mp eki bkj mp c
argument one given c infer bki mp bkj mp
thus formula satisfied
consider arbitrary formula bki mp eki c bki mp true
formula trivially satisfied bki mp f alse exist two
possible cases case exists event ej j ekj true
ej ep ep case r pk bki mp f alse
since must satisfy ej
ep thus ej ep besides
must satisfy implies eki f alse r
eki eki f alse therefore formula satisfied case
exist event ej j ekj true ej ep ep
case r pk bki mp f alse since
must satisfy infer eki f alse r
eki eki f alse therefore formula satisfied
consider formula bk mp pk c r easily deducted bk mp equal pk r
pk pk bk mp pk formula
satisfied
consider formula bkn mp pk c two possible cases
case exists event e ek true e ep ep
case r bn mp pk r
pk pk therefore bn mp pk formula
satisfied case exist event e ek true
e ep ep case r bn mp pk besides
since satisfies formulae right hand side becomes f alse
left hand side e pk pk f alse thus
pk f alse pk f alse similar argument
pk true pk true thus
pk pk r pk pk therefore
bn mp pk pk formula satisfied
satisfies formulae cof cof thereby satisfies

consider arbitrary formula eki bk

j mof
p

cof know cof

j eki f alse formula trivially satisfied eki
true r bj mof true formula satisfied
p



fiitsat efficient sat temporal planner

consider arbitrary formula bk

mof
p

cof bk

bk

j mof
p

mof
p

f alse formula trivially satisfied bk

mof
p



true rule



r must exist event ei
eki true
ei ep since j must j r
bj mof true formula satisfied
p

consider arbitrary formula bk

j mof
p

ekj eki cof bk

j mof
p

f alse formula trivially satisfied bk

j mof
p



true r

must exist event ej j j ekj true ej ep
since satisfies infer ekj f alse r
ekj ekj f alse therefore formula satisfied
consider arbitrary formula bk

n mof
p

ak eki cof bk

n mof
p

f alse formula trivially satisfied bk



true r

n mof
p
k
event ej ej true ej ep
infer ak f alse r

must exist
since satisfies
ak ak f alse therefore formula satisfied

satisfies formulae cob cof thereby satisfies

consider arbitrary formula eki bkj mob cob know cob
p

j eki f alse formula trivially satisfied eki
true r bj mob
true formula satisfied
p
consider arbitrary formula bki mob bkj mob cob bki mob
p

p

p

f alse formula trivially satisfied bki mob true rule r
p

must exist event ei eki true ei ep
since j must j r
true formula satisfied
bj mob
p
consider arbitrary formula bki mob eki ekj cob bki mob
p

p

f alse eki f alse formula trivially satisfied bki mob true
p

eki true r must exist event ei
eki true ei ep since satisfies infer
ak f alse however know j j thus must satisfy therefore ekj true r ekj ekj
true therefore formula satisfied
consider arbitrary formula bk mob ak ekj cob bk mob
p

p

f alse ak f alse formula trivially satisfied bk mob
p

true ak true r must exist event ei
eki true ei ep since satisfies infer
ak f alse however must satisfy therefore ekj


firankooh ghassem sani

true r ekj ekj true therefore formula
satisfied
consider arbitrary formula eki ak let ej ending event
know j j therefore must satisfy
exactly besides assign value
variable formulae thus satisfied
consider arbitrary formula eki ak ekj know j j
therefore must satisfy formula exactly
besides assign value variable formulae thus
satisfied
consider arbitrary formula ekj ak let ei starting event
know j j therefore must satisfy
exactly besides assign value
variable formulae thus satisfied
consider arbitrary formula ekj ak eki know
j j therefore must satisfy exactly
besides assign value variable formulae thus
satisfied
exactly besides assign value
variable formulae thus satisfied
exactly besides assign value
variable formulae thus satisfied

theorem soundness relaxed step encoding let p g

temporal e en set events p l relaxed

step encoding p l model plan causally valid step plan
p
proof obtain plan follows k k l let stepk
set events e ek true k k l
let sk temporal state assume state sk set propositions p
pk true agenda sk set actions ak true
construct plan hstep stepl causally valid step plan
p state transition sequence hs sl
immediately follows state implies g
state sl besides imply agenda agenda sn empty sets
respectively need k k l stepk
ei eim e en step sk sk without loss generality


fiitsat efficient sat temporal planner

assume sequence hei eim ordered according fixed ordering en
e im
induction k conclude k sequence hei eik
applicable sk k e case event applied sk conclusion obviously holds let sk temporal state resulting applying hei eik
sk assume eik starting event action omit similar case
eik ending event conditions definition
holds thereby eik applicable sk
assume p
state sk p precondition eik invariant
added eik two possible cases case p
member state sk added deleted member ei eik
case pk f alse moreover exists event ei
ei ep ep k eki true case p deleted event
ei stepk added deleted event ej stepk j k
case ei ep ik ei eik epm eki true
epm e e ep ep ek true cases lemma
bkik mp f alse contradicts fact satisfies c
since satisfies member agenda sk however eik
event stepk add agenda state thus member
agenda sk
let b action invariant p del eik let ej ej
starting ending events b respectively mentioned earlier assume
ending event action located immediately starting event
fixed ordering b cannot member agenda sk
two possible cases b may member agenda sk case b open
action immediately execution stepk b ended stepk
eik executed case bk true ekik true since
satisfies lemma ekj true assumed b
ended execution eik ik j hand
since ej starting event b ik j thus ik j therefore
lemma ekj true contradicts fact satisfies
bk true ekj true ej start b case b
started step k ended step k execution eik
case ekj true ekj f alse j ik ekik true
since satisfies lemma must ekj true
contradiction
sm applying hei eim sk equal sk
let p arbitrary proposition p state sm two possible cases
case p member state sk added deleted member
ei eim case pk true moreover exists event ei
ei ep ep n eki true case p added event


firankooh ghassem sani

ei stepk added deleted event ej stepk n
case ei ep n ei en epm eki true
epm e e ep ep ek true cases lemma
bkn mp true since satisfies c pk true thus
p state sk therefore state sm state sk
let p arbitrary proposition p
state sm two possible cases case
p member state sk added deleted member
ei eim case pk f alse moreover exists event
ei ei ep ep n eki true case p deleted
event ei stepk added deleted event ej stepk
j n case ei ep n ei en epm
eki true epm e e ep ep ek true cases lemma
bkn mp f alse since satisfies c pk f alse
thus p
state sk therefore state sk state sm
let arbitrary action ei ej starting event ending event
respectively agenda sm since assume ending event action
located immediately starting event fixed ordering two
possible cases case open immediately step k ended
step k case ak true ekj f alse since satisfies
must ak true therefore agenda sk case started
ended step k case eki true ekj f alse
satisfies must ak true therefore agenda sk since
cases agenda sk infer agenda sm agenda sk
let arbitrary action ei ej starting event ending event
respectively
agenda sm since assume ending event action
located immediately starting event fixed ordering two
possible cases case open immediately execution step k
started step k case ak f alse eki f alse
since satisfies must ak f alse therefore
agenda sk
k
case ended step k case ej true since satisfies
must ak f alse therefore
agenda sk
cases
agenda sk infer agenda sk agenda sm
arguments state sk state sm agenda sk agenda sm
hence sk sm sk succ sk hei eim therefore ordering functions sk succ sk heo eo im
thus stepk step sk sk

theorem let p g temporal en
causally valid plan p n q relaxed scheduling function
exists valid temporal plan p


fiitsat efficient sat temporal planner

proof bubble sort sort events increasing order
according values given takes two consecutive members
sequence swaps value first one greater
second one continues swaps whole sequence properly sorted let ei
ej two events swapped bubble sort stage assume
ei located ej sequence prior swapping must j
thus according know ei ej swappable c f definition
whole sequence causally valid plan prior swapping would
causally valid plan swapping means sorting according values
given another causally valid plan say plan obviously satisfies
two conditions definition therefore valid temporal plan p

theorem let p g solvable temporal com
set every member compressible towards start compressible
towards end definition exists valid temporal plan p
causally valid plan p compressed respect com relaxed
scheduling function
proof let e ei ei en causally valid plan p ei ei
two swappable events let e ei ei en swapping ei ei
relaxed scheduling function relaxed
scheduling function
consider two events ej ek ej located ek j
k ej definitely located ek therefore property
holds ej ek hand j k ej ek
swappable therefore property trivially holds ej ek
assume ej starting event particular action ek pairing
event ej definition easily infer ei located
ej ek ei cannot starting ending event similarly
ei located ej ek ei cannot starting ending event
hand since ei ei swappable know cannot
events action therefore j k thus
swapping ei ei cannot falsify fact ej ek pairing events
words ek pairing event ej implies property
holds ej ek
let arbitrary valid temporal plan p since scheduling function
obviously regarded relaxed scheduling function showed
section transformed causally valid plan compressed
respect com series swaps swapping occurs pair
consecutive swappable events therefore must relaxed scheduling function
valid temporal plan p scheduling function



firankooh ghassem sani

p
theorem let p g temporal
e en




set events p l three formulae l l l defined section
p
non empty causally valid plan p obtained solving l let x
fsm accepts subsequence em
l encoding
presented exist model l
l
plan
proof give proof contradiction assume exists model l
l
plan let f p
n function
f equal index th event moreover let g l
function g equal step number sat variable
l corresponds th event assume x xm sequence states
xi xi ef since accepts must
f g

xm satisfies x
true two cases
considered case g g case since plan f j f
g
must ej f alse considering infer
g f

x
true case g g case considering
g n
infer x
true considering deduce
g
x
true argument plus considering
g f
g f
x
true whole deduction repeated xi
true
g f

therefore xm
true since xm xm ef
e e
considering infer j ej em
n

g j


true however since xm
ef ej em em xm
contradicts assumption satisfies
p
theorem let p g temporal
e en



set events p l three formulae l l l defined
section let model satisfies l em plan let
p
x fsm accept subsequence
l


encoding composed exists model l l
plan
proof let us introduce total order relation sat variables l correspond


events input two sat variables eki eki eki eki
one following two conditions holds k k k k
assume f pn function f equal
index th event moreover assume g l
function k g k equal step number sat variable l
corresponds k th event let uk heu et denote subsequence
following properties
g

ef true


fiitsat efficient sat temporal planner

g





k ef eki eki eki f alse
fact uk substring spans u th event last event
whose corresponding sat variable located eki l define model
l
l following rules
r sat variable v l v v
r k l n xk
true
r k l n xs xk
true iff j sequence
jk transforms x xs
r infer satisfies l satisfies
formulae thereby satisfies
l
xk j
arbitrary formula eki f alse
let eki xk


k
k
xk
f alse formula trivially satisfied assume ei xs
k
true r u sequence u transforms x xs since
eki ekj way defined uk j deduce uk j uk hei
denotes concatenation operator sequence events ei ej
xs ei xt therefore ei causes transit xs
xt besides ei ej etout thus member cause
transit state xt therefore uk j transforms x xt
xk j
true hence formula satisfied
k j
arbitrary formula eki true
let eki xk
xs
k
xk
f alse formula trivially satisfied assume ei f alse
k
xk
true r u sequence u transforms x xs
k j
since eki ekj way defined u deduce uk j uk
sequence events ei ej besides ei ej esout
thus member cause transit state xs therefore
uk j transforms x xs xk j
true hence formula satisfied
k
k
let xk
xs arbitrary formula xs f alse formula
trivially satisfied assume xk
true r u
k
sequence u transforms x xs since ek eki way defined uk
deduce uk uk sequence events e ei
besides e ei esout thus member cause transit
state xs therefore uk transforms x xs xk
true
hence formula satisfied

let xk n
xk
arbitrary formula way defined


k

deduce uk n uk every u therefore xk n
u

k

xs
hence formula satisfied
according r formula directly satisfied


firankooh ghassem sani

let xk arbitrary formula accorrding assumptions uk
cannot cause transit accepting states since x r
implies xk f alse hence formula satisfied

theorem let n xi xim negative cycle stn corresponding
causally valid plan e en temporal p xik node corresponding event eik let another causally valid plan p subsequence
member ln defined section corresponding stn n
negative cycle
proof let ei e e k ei eim em em km eim subsequence
ej ej kj string symbols j j consider two arbitraty events
eij eij sequence ij ij temporal constraints
eij eij present ij ij
constraint ij ij scheduling constraint
explained section eij eij swappable besides eij clearly
located eij consequently must ij ij according
scheduling constraint
constraint ij ij dur scheduling rule eij
eij starting event ending event respectively moreover
j j j action eij indicates j j j
oj therefore eij
j since ej ej k string symbols j
j
conclude yet ended reaching eij means eij
eij pairing events thus scheduling constraint
ij ij dur
shows edge xij xij corresponding stn present
corresponding stn thus latter stn n negative cycle

references
allen j f towards general theory action time artif intell

armando giunchiglia e embedding complex decision procedures inside
interactive theorem prover ann math artif intell
benton j coles j coles temporal preferences
time dependent continuous costs proceedings twenty second international
conference automated scheduling icaps atibaia sao paulo
brazil june
biere p cosat sc solver description sat competition sat
competitive event booklet


fiitsat efficient sat temporal planner

biere lingeling plingeling treengeling entering sat competition
proceedings sat competition
blum furst l fast graph analysis artif
intell
castellini c giunchiglia e tacchella sat complex
domains concurrency constraints nondeterminism artif intell

coles j coles fox long extending use inference
temporal forwards search proceedings th international conference automated scheduling icaps thessaloniki greece
september
coles j coles fox long forward chaining partial order proceedings th international conference automated
scheduling icaps toronto ontario canada may pp
cormen h leiserson c e rivest r l stein c introduction
ed mit press
cushing w kambhampati mausam weld temporal
really temporal ijcai proceedings th international joint conference artificial intelligence hyderabad india january pp
dechter r meiri pearl j temporal constraint networks artif intell

b kambhampati sapa multi objective metric temporal planner
j artif intell res jair
een n biere effective preprocessing sat variable clause
elimination theory applications satisfiability testing th international
conference sat st andrews uk june proceedings pp
ernst millstein weld automatic sat compilation
proceedings fifteenth international joint conference artificial
intelligence ijcai nagoya japan august volumes pp

eyerich p mattmuller r roger g context enhanced additive
heuristic temporal numeric proceedings th international conference automated scheduling icaps thessaloniki
greece september
fox long pddl modelling continuous time dependent effects
third international nasa workshop scheduling space
fox long pddl extension pddl expressing temporal
domains j artif intell res jair
fox long note concurrency complexity temporal
th workshop uk scheduling special interest group


firankooh ghassem sani

garrido fox long temporal system durative actions
pddl proceedings th eureopean conference artificial intelligence
ecai lyon france july pp
gerevini saetti serina temporal scheduling domains predictable exogenous events j artif intell res jair

gerevini schubert l k inferring state constraints domain independent
proceedings fifteenth national conference artificial intelligence
tenth innovative applications artificial intelligence conference aaai
iaai july madison wisconsin usa pp
halsey k crikey co ordination temporal ph thesis university durham
halsey k long fox multiple relaxations temporal
proceedings th eureopean conference artificial intelligence ecai
including prestigious applicants intelligent systems pais valencia spain
august pp
haslum p improving heuristics relaxed search analysis tp
hsp competition j artif intell res jair
haslum p geffner h admissible heuristics optimal proceedings fifth international conference artificial intelligence systems
breckenridge co usa april pp
helmert geffner h unifying causal graph additive heuristics
proceedings eighteenth international conference automated
scheduling icaps sydney australia september pp
hoffmann j gomes c p selman b kautz h sat encodings statespace reachability numeric domains ijcai proceedings
th international joint conference artificial intelligence hyderabad india january pp
hoffmann j nebel b system fast plan generation
heuristic search j artif intell res jair
huang r chen zhang w optimal temporally expressive planner
initial application p p network optimization proceedings
th international conference automated scheduling icaps
thessaloniki greece september
huang r chen zhang w sas satisfiability j artif intell
res jair
kautz h selman b satisfiability ecai pp
kautz h selman b pushing envelope propositional logic
stochastic search proceedings thirteenth national conference artificial
intelligence eighth innovative applications artificial intelligence conference
aaai iaai portland oregon august pp


fiitsat efficient sat temporal planner

long fox exploiting graphplan framework temporal
proceedings thirteenth international conference automated
scheduling icaps june trento italy pp
lu q huang r chen xu zhang w chen g sat
cost sensitive temporally expressive acm tist
mali liu satplan sat temporal planner international
journal artificial intelligence tools
rankooh f ghassem sani g encoding methods sat temporal
proceedings twenty third international conference automated
scheduling icaps rome italy june
rintanen j compact representation sets binary constraints ecai
th european conference artificial intelligence august september
riva del garda italy including prestigious applications intelligent systems pais
proceedings pp
rintanen j complexity concurrent temporal proceedings
seventeenth international conference automated scheduling icaps
providence rhode island usa september pp
rintanen j satisfiability heuristics artif intell
rintanen j gretton c computing upper bounds lengths transition
sequences ijcai proceedings rd international joint conference
artificial intelligence beijing china august
rintanen j heljanko k niemela satisfiability parallel plans
plan search artif intell
robinson n gretton c pham n sattar sat parallel
split representation actions proceedings th international conference automated scheduling icaps thessaloniki greece
september
robinson n gretton c pham n sattar partial weighted maxsat
optimal pricai trends artificial intelligence th pacific
rim international conference artificial intelligence daegu korea august september proceedings pp
shin j davis e processes continuous change sat planner
artif intell
smith e weld temporal mutual exclusion reasoning
proceedings sixteenth international joint conference artificial intelligence
ijcai stockholm sweden july august volumes pp

streeter j smith f decision procedures efficiently optimization
proceedings seventeenth international conference automated
scheduling icaps providence rhode island usa september
pp


firankooh ghassem sani

vidal v yahsp yahsp mt th international competition
international competition
vidal v geffner h branching pruning optimal temporal pocl
planner constraint programming artif intell
wehrle rintanen j satisfiability relaxed step plans
ai advances artificial intelligence th australian joint conference
artificial intelligence gold coast australia december proceedings pp

younes h l simmons r g vhpop versatile heuristic partial order
planner j artif intell res jair




