Journal Artificial Intelligence Research 53 (2015) 541-632

Submitted 01/15; published 07/15

ITSAT: Efficient SAT-Based Temporal Planner
Masood Feyzbakhsh Rankooh
Gholamreza Ghassem-Sani

feyzbakhsh@ce.sharif.edu
sani@sharif.edu

Computer Engineering Department,
Sharif University Technology,
Azadi ave., Tehran, Iran

Abstract
Planning satisfiability known efficient approach deal many types
planning problems. However, approach competitive state-space
based methods temporal planning. paper describes ITSAT efficient SAT-based
(satisfiability based) temporal planner capable temporally expressive planning.
novelty ITSAT lies way handles temporal constraints given problems without
getting involved difficulties introducing continuous variables corresponding
satisfiability problems. show how, SAT-based classical planning, carefully
devised preprocessing encoding schemata considerably improve efficiency
SAT-based temporal planning. present two preprocessing methods mutex relation
extraction action compression. show separation causal temporal
reasoning enables us employ compact encodings based concept parallel
execution semantics. Although encodings shown quite effective
classical planning, ITSAT first temporal planner utilizing type encoding.
empirical results show ITSAT outperform state-of-the-art temporally
expressive planners, competitive fast temporal planners cannot
handle required concurrency.

1. Introduction
Temporal planning extension classical planning actions durative rather
instantaneous. introduction durative actions adds new dimension
solving planning problems, namely reasoning time. Temporal reasoning per se
different causal reasoning, time real-valued quantity, whereas causal
aspects planning normally represented propositions.
current standard language defining temporal planning problems PDDL2.1
(Fox & Long, 2003). Although PDDL+ (Fox & Long, 2002) introduced
planning community expressive language defining temporal numerical
planning problems, throughout paper, focus PDDL2.1, planning
problems tackled need expressive power PDDL+. PDDL2.1,
actions separate preconditions effects upon starting ending. temporal
action invariants, must preserved execution
action. important subset problems defined PDDL2.1 problems every
valid plan includes concurrent execution two actions. subset called
problems required concurrency. shown concurrent execution two
actions may necessary solving temporal problems (Halsey, Long, & Fox, 2004;
Cushing, Kambhampati, Mausam, & Weld, 2007). instance, temporal planning
c
2015
AI Access Foundation. rights reserved.

fiRankooh & Ghassem-Sani

problems, actions may require proposition available execution
another action. cases, two actions must executed concurrently.
specific example given Section 2, describe Driverlogshift domain.
common approach many planners temporally expressive eliminate
cases compressing temporal actions create non-durative classical actions.
paper, describe ITSAT, temporally expressive SAT-based (i.e., satisfiability
based) planner. ITSAT uses approach takes advantage parallel execution semantics without rendering incomplete problems required concurrency.
approach, durations actions given problem first abstracted out.
done breaking temporal action two starting ending instantaneous events.
obtained temporally abstract problem encoded SAT formula using novel
-step -step semantics causally valid plans. show semantics
used encode given temporal planning problem SAT formula. Classical -step
-step encoding methods introduced (Rintanen, Heljanko, & Niemela,
2006). addition extending methods temporal planning context,
introduce new encoding method based -step semantics causally valid plans.
show new encoding often results significant reduction number required
steps.
generating causally valid plan, ITSAT performs scheduling phase.
phase, ITSAT tries satisfy temporal constraints imposed considering
durations actions. done solving Simple Temporal Problem (STP) (Dechter,
Meiri, & Pearl, 1991). However, problems required concurrency, posed STP
may inconsistent. cases, cause inconsistency, manifests
negative cycle corresponding Simple Temporal Network (STN), detected. ITSAT
generates number clauses added SAT formula, collectively prevent
reoccurrence particular negative cycle occurred similar cycles.
process repeated temporally valid plan found.
Similar SAT-based planners, ITSAT takes advantage preprocessing phase
extract information structure problems. information used
throughout encoding phase produce formula whose satisfiability checked
efficiently SAT solver. Section 3, describe preprocessing phase
ITSAT, includes reasoning mutual exclusion so-called safe action
compression (Coles, Coles, Fox, & Long, 2009). Two propositions regarded mutually
exclusive never jointly true state valid temporal plan. Here,
show one detect mutually exclusive propositions temporal problems using
planning graph analysis (Blum & Furst, 1997). known employing mutual exclusion
reasoning significantly improve performance SAT-based planners (Gerevini &
Schubert, 1998).
mentioned earlier, ITSAT breaks temporal action two starting
ending instantaneous events. Although cases breaking might
necessary producing concurrent plans, situations necessary
finding valid plans. Section 3, show using mutual exclusion information,
one identify temporal actions safely compressed classical action
without falsifying validity temporal plans. analysis results smaller number
distinct events therefore simpler planning problem.
542

fiITSAT: Efficient SAT-Based Temporal Planner

empirically show taking advantage preprocessing, encoding,
scheduling phases, ITSAT significantly outperform state-of-the-art temporally expressive planners, competitive best temporally simple planners
incapable solving problems required concurrency property. components ITSAT shown Figure 1. figure, processing components
ITSAT system shown rectangular blocks, links represents data produced
received components.

Figure 1. block diagram ITSAT

543

fiRankooh & Ghassem-Sani

1.1 Motivation
mentioned earlier, temporal planners need reason time, continuous
quantity. Nevertheless, causal structures problems temporal planning still
similar classical planning. existence abundant temporal planning domains
classical versions regarded evidence claim. suggests
temporal planners benefit using approaches previously shown
effective dealing classical problems.
usage Boolean satisfiability checking well-known paradigm tackling classical
planning problems (Kautz & Selman, 1992). approach, given planning problem
translated formula propositional logic. variable SAT formula typically
represents occurrence corresponding action proposition certain place
potential plan. causal constraints planning problem represented number
ground clauses. output plan assumed finite number steps. step
may include one actions. original SAT-based planner allowed one action
per step (Kautz & Selman, 1992). However, previously introduced SAT-based planners
allow multiple occurrence actions step. produced formula given
input off-the-shelf SAT solver, tries find model it. model
found, plan extracted it. Otherwise, number steps output plan
increased one corresponding SAT formula given SAT solver.
process repeated valid plan extracted predefined termination condition
reached. order obtain efficient SAT-based planner, one important issue
considered encode given planning problem SAT formula.
SAT-based planning originally used find optimal plans, i.e., plans minimum
number actions (Kautz & Selman, 1992). guarantee optimality output plan,
formula must include certain clauses ban step containing one
action. However, so-called satisficing planning, optimality main
objective, forcing single-action steps necessary. alternative approach consider
actions executed parallel step output plan (Ernst, Millstein,
& Weld, 1997). Exploiting parallelism result smaller number steps
SAT formula. Another important benefit producing compact formulae lower memory
requirements. Several encoding methods introduced take advantage action
parallelism. encoding methods based so-called -step -step semantics
valid plans (Rintanen et al., 2006).
-step -step semantics different extent action parallelism
allow occur step. -step semantics allows set actions executed
parallel, actions executed every possible ordering without affecting
validity plan. -step semantics, hand, imposes weaker restriction:
step plan, must exist least one possible ordering actions
executed without falsifying validity plan. clear -step
semantics potentially allows parallelism permitted -step semantics.
fact, taking advantage -step semantics, efficient SAT-based classical planner,
i.e., Mp (Rintanen, 2012), competitive state-of-the-art state-space planners.
paper, show separation causal temporal reasoning phases temporal
planning enables us employ compact encodings efficient temporal planning.
544

fiITSAT: Efficient SAT-Based Temporal Planner

1.2 Related Work
Previous research field temporal planning benefited enormously employing
well-developed classical planning strategies. instance, many successful temporal planners utilized ideas partial order planning, e.g. VHPOP (Younes & Simmons,
2003) CPT (Vidal & Geffner, 2006). Planning graph analysis adopted
temporal planners TGP (Smith & Weld, 1999) TPSYS (Garrido, Fox, & Long,
2002). temporal planners embedded temporal reasoning heuristic
state space search. TFD (Eyerich, Mattmuller, & Roger, 2009), LPG-td (Gerevini, Saetti,
& Serina, 2006), POPF (Coles, Coles, Fox, & Long, 2010) successful instances
latter approach.
usage Boolean satisfiability checking one well-known paradigms tackling classical planning problems (Kautz & Selman, 1992). order obtain efficient
SAT-based planner, one important issue considered encode
given planning problem SAT formula. fact, devising efficient encoding methods
important research trend field SAT-based planning. Examples
efficient encodings are: split action representation (Kautz & Selman, 1996; Ernst et al.,
1997; Robinson, Gretton, Pham, & Sattar, 2009), SAS+ based encoding (Huang, Chen,
& Zhang, 2012), compact mutual exclusion representation (Rintanen, 2006). Based
parallel semantics plans, another effective encoding method introduced (Rintanen et al., 2006). latter encoding method particular interest paper.
Satisfiability checking employed field temporal planning. However,
SAT-based temporal planners encounter major challenge: representing temporal aspects problems. Since time continuous quantity, cannot treated exact
way discrete causality handled. tackle problem, STEP (Huang, Chen, &
Zhang, 2009), SCP2 (Lu, Huang, Chen, Xu, Zhang, & Chen, 2013), T-SATPLAN (Mali
& Liu, 2006) use discrete representation time. planners assign explicit discrete
time labels step encoding. Generally speaking, approach, step
exactly one time unit ahead step + 1. result, action duration starts
step i, forced end step + d. One immediate outcome approach
introduction enormous number steps encoding, many
contribute output plan. drawback explicit time representation causes
STEP, SCP2, T-SATPLAN inefficient terms speed memory usage. obtain better performance, SCP2 uses -step semantic allow causal relations
actions time point (Lu et al., 2013).
TM-LPSAT (Shin & Davis, 2005), designed solve planning problems
defined PDDL+ (Fox & Long, 2002), another SAT-based planner capable handling
temporal planning problems. Similar STEP T-SATPLAN, TM-LPSAT attaches
time labels step. However, TM-LPSAT, labels predefined discrete
numbers. Instead, label numeric variable whose value determined
problem solved SMT solver (Armando & Giunchiglia, 1993). approach
result encodings compact produced STEP TSATPLAN.
major disadvantage assigning time label step formula parallelism mentioned cannot exploited effectively. two events
545

fiRankooh & Ghassem-Sani

happen certain step plan, time labels must same, thus,
must simultaneous final plan executed. compulsory simultaneity
restriction reduces number events happen step final
plan, turn, increases number steps needed solving input problems.
implies efficiency gain one could obtain using parallel execution semantics
sacrificed achieve easy way deal temporal constraints. However,
majority current temporal planning problems, satisfying temporal constrains
hardest task finding valid plan. shown problems without required
concurrency, one omit temporal constraints altogether, find causally valid plan,
then, considering temporal constraints postproccessing step, schedule
actions plan find temporally valid plan (Cushing et al., 2007). approach
actually used many previous temporal planners including YAHSP3-mt (Vidal,
2014), winner temporal satisficing track IPC 2014. Despite efficient
solving many temporal problems, planners incomplete, incapable
solving problems required concurrency.
addition classical planning problems, SAT-based methods used
deal categories planning problems. Examples planning uncertainty
(Castellini, Giunchiglia, & Tacchella, 2003), cost-optimal planning (Robinson, Gretton,
Pham, & Sattar, 2010) numerical planning (Hoffmann, Gomes, Selman, & Kautz,
2007).

2. Preliminaries
standard language used defining temporal planning problems PDDL2.1 (Fox &
Long, 2003). Figure 2 presents example PDDL2.1 representation temporal
planning domain. domain, simplified version Driverlogshift (Halsey, 2004),
referred several times throughout paper. Figure 2 shows, PDDL2.1,
action separate conditions effects upon starting ending. starting
ending conditions (or effects) action specified start end
tokens, respectively. action may conditions need preserved
execution. conditions specified using token. Moreover,
duration action defined (= ?duration x) statement, x rational
number function specifying actual duration action.
Driverlogshift temporal version Driverlog domain IPC3.
classical counterpart, Driverlogshift, objective transfer several objects
original places destinations. object loaded unloaded
certain truck using LOAD UNLOAD operators, respectively. truck move
locations using MOVE operator. main difference Driverlogshift
Driverlog trucks must rested intervals working
shifts. working shift defined WORK operator, produces (working
truck) proposition upon starting, deletes proposition upon ending. LOAD, UNLOAD,
MOVE (working truck) invariant. (working truck) deleted
ending WORK, may reproduced REST operator, defines resting
shift certain truck.
546

fiITSAT: Efficient SAT-Based Temporal Planner

(define (domain driverlogshift)
(:requirements :typing :durative-actions)
(:types
location locatable - object
truck obj - locatable)
(:predicates
(at ?obj - locatable ?loc - location)
(in ?obj1 - obj ?obj - truck)
(link ?x ?y - location)
(working ?t - truck)
(need-rest - truck)
(rested - truck))
(:durative-action WORK
:parameters
(?truck - truck)
:duration (= ?duration 100)
:condition (and
(at start (rested ?truck)))
:effect (and (at start (working ?truck))
(at end (not (working ?truck)))
(at start (not (rested ?truck)))
(at end (need-rest ?truck))))
(:durative-action REST
:parameters
(?truck - truck)
:duration (= ?duration 20)
:condition (and
(at start (need_rest ?truck)))
:effect (and
(at start (not (need_rest ?truck)))
(at end (rested ?truck))))
(:durative-action LOAD
:parameters
(?obj - obj
?truck - truck
?loc - location)
:duration (= ?duration 10)
:condition (and
(over (at ?truck ?loc))
(over (working ?truck))
(at start (at ?obj ?loc)))
:effect (and
(at start (not (at ?obj ?loc)))
(at end (in ?obj ?truck))))

(:durative-action UNLOAD
:parameters
(?obj - obj
?truck - truck
?loc - location)
:duration (= ?duration 10)
:condition (and
(over (at ?truck ?loc))
(over (working ?truck))
(at start (in ?obj ?truck)))
:effect (and
(at start (not (in ?obj ?truck)))
(at end (at ?obj ?loc))))
(:durative-action MOVE
:parameters
(?truck - truck
?loc-from - location
?loc-to - location)
:duration (= ?duration 50)
:condition (and
(at start (at ?truck ?loc-from))
(at start (link ?loc-from ?loc-to))
(over (working ?truck)))
:effect (and
(at start (not (at ?truck ?loc-from)))
(at end (at ?truck ?loc-to)))))

Figure 2. PDDL2.1 description Driverlogshift domain

Note version Driverlogshift described Figure 2 slightly different
original version (Halsey, 2004), drivers walk to, board,
disembark trucks. Furthermore, REST WORK actions performed drivers
rather trucks. However, order make examples simpler, merged drivers
trucks single entity trucks.
simple example problems Driverlogshift shown Figure 3. problem,
three locations (s0, s1, s2), one truck (truck1), one object (package1).
initial state, truck1 package1 s0. objective problem
transfer package1 s2.
2.1 Formalism PDDL2.1
present formalism specifications PDDL2.1. formalism devised
way simplifies description preprocessing, encoding, scheduling phases
ITSAT. mention formalism limitations compared
full specifications PDDL2.1. limitations discussed details Section 2.2.
547

fiRankooh & Ghassem-Sani

(define (problem DLOG)
(:domain driverlogshift)
(:objects
truck1
- truck
package1 - obj
s0 s1 s2 - location)
(:init
(rested truck1)
(at truck1 s0)
(at package1 s0)
(link s0 s1)
(link s1 s0)
(link s2 s1)
(link s1 s2)
)
(:goal (and
(at package1 s2))))

Figure 3. PDDL2.1 description problem Driverlogshift domain

Definition 1 (events). event, e, triple (pre(e), add(e), del(e)), pre(e),
add(e), del(e) three sets atomic propositions (facts) representing preconditions,
positive effects, negative effects e, respectively.
Definition 2 (temporal actions) temporal action, a, quadruple (start(a), end(a),
inv(a), dur(a)), start(a) end(a) two events denoting starting ending
events a, inv(a) set atomic propositions representing invariants a,
dur(a) positive rational number specifying duration a.
Example 1. Figure 4 shows temporal action = LOAD(package1, truck1, s0),
instance LOAD operator defined Figure 2. Figure 4, depicted rectangular box. Conditions effects written box, respectively.
start conditions effects placed left hand side box,
end conditions effects placed right hand side box.
conditions placed middle box. Here, start(a) end(a)
two events, pre(start(a)) = {(at package1 s0)}, add(start(a)) = , del(start(a)) =
{(at package1 s0)}, pre(end(a)) = , add(end(a)) = {(at package1 truck1)},
del(end(a)) = . Moreover, inv(a) = {(at truck1 s0), (working truck1)},
dur(a) = 10.
548

fiITSAT: Efficient SAT-Based Temporal Planner

Figure 4. temporal action

Definition 3 (temporal states). temporal state, s, pair (state(s), agenda(s)),
state(s) classical planning state represented set atomic propositions,
agenda(s) contains finite set open actions (i.e., actions started prior yet
ended).
Definition 4 (applicability). starting event e action applicable state s,
following conditions hold:
(1) state(s) contains preconditions e
invariants (except
invariants added e): pre(e) (inv(a) add(e)) state(s)
(2) already open s:
/ agenda(s)
(3) eSdoes delete theTinvariants open action s:

del(e) =
agenda(s) inv(a )
ending event e action applicable state s, following conditions hold:
(1) state(s) contains preconditions e: pre(e) state(s)
(2) open s: agenda(s)
(3)
e delete invariants
open action (other a):

)
inv(a
del(e)
=
agenda(s){a}
Definition 5 (successors). starting event e action applicable state s,
change unique state satisfying following conditions:


set open
actions equal set open actions a: agenda(s ) =
agenda(s) {a}

positive negative effects
e respectively added deleted :

state(s ) = (state(s) del(e)) add(e)

ending event e action applicable state s, change unique state
satisfying following conditions:
549

fiRankooh & Ghassem-Sani

set open actions equal set open actions without a:
agenda(s ) = agenda(s) {a}
positive negative
effects e respectively added deleted : state(s ) =

(state(s) del(e)) add(e)
on, may use succ(s, e) represent successor state obtained applying
e s.
Definition 4 Definition 5 easily extended cover sequence events:
succ(s, he1 , ..., en i) = succ(succ(s, he1 , ..., en1 i), en ), succ(s, hi) = s. sequence
events he1 , ..., en applicable temporal state s, succ(s, he1 , ..., en i) defined.
Example 2. Let temporal state
state(s) = {(at package1 s0), (at truck1 s0), (working truck1), (link s0 s1)}

agenda(s) = .
Let = LOAD(package1, truck1, s0) = MOVE(truck1, s0, s1) two temporal actions, respectively instances LOAD MOVE operators presented Figure
2. event start(a) applicable changes
state(s ) = {(at truck1 s0), (working truck1), (link s0 s1)}

agenda(s ) = {LOAD(package1, truck1, s0)}.
Now, start(a) applicable already open . isstart(a ) applicable , deletes (at truck1 s0) invariant a, still open .
However, end(a) applicable changes
state(s ) = {(at package1 truck1), (at truck1 s0), (working truck1), (link s0 s1)}

agenda(s ) = .

Definition 6 (temporal problems). temporal problem, P, triple (I, G, A),
I, representing initial state, temporal state agenda(I) = . G set
atomic propositions denoting goal conditions, finite set possible
temporal actions P.
Definition 7 (causally valid plans). Let P = (I, G, A) temporal problem
= he1 , ..., en sequence events i, ei starting ending event
action A. causally valid plan P, applicable I, G state(succ(s, )),
agenda(succ(s, )) = .
550

fiITSAT: Efficient SAT-Based Temporal Planner

Definition 8 (pairing events). Let = he1 , ..., en causally valid plan problem P = (I, G, A). Assume ei ej respectively starting ending events
certain action < j. k < k < j, ek neither starting
ending event a, say ei (ej ) pairing event ej (ei ) .
words, ei ej pairing events related occurrence .
Definition 9 (valid temporal plans makespan). Let = he1 , ..., en causally
valid plan P = (I, G, A), : {1, ..., n} Q scheduling function , Q
set rational numbers. (, ) valid temporal plan P following
properties:
i, (i) < (i + 1).
A, start(a) = ei , ej pairing event ei , (j) =
(i) + dur(a).
maximum value assigned events called makespan .
Example 3. Consider problem P = (I, G, A) depicted Figure 3, state(I)
G contain propositions listed labels :init :goal, respectively,
set possible instantiations operators presented Figure 2 objects
listed label :objects Figure 3. Let
= hstart(WORK(truck1)),
start(LOAD(truck1, package1, s0)),
end (LOAD(truck1, package1, s0)),
start(MOVE(truck1, s0, s1)),
end (MOVE(truck1, s0, s1)),
start(MOVE(truck1, s1, s2)),
end (MOVE(truck1, s1, s2)),
start(UNLOAD(truck1, package1, s2)),
end (UNLOAD(truck1, package1, s2)),
end (WORK(truck1))i
schematic representation depicted Figure 5. straightforward checking shows
causally valid plan P. However, valid temporal plan
duration WORK(truck1) 100, requires serial execution two MOVE actions, one
LOAD action, one UNLOAD action, total duration 120, WORK(truck1)
still open. words, one single working shift truck1 sufficient transfer
package1 s0 s2. Therefore, scheduling function properties
Definition 9 exists . valid temporal plan P depicted Figure 6.
plan, two working shifts truck1 used.
551

fiRankooh & Ghassem-Sani

Figure 5. causally valid plan

Figure 6. valid plan

2.2 Limitations
end section describing differences formalism valid temporal
plans PDDL2.1. main limitations formalism listed below:
According Definition 4, starting event action applicable state
already open s. means that, similar many previous
temporal planners, permit two versions action overlap.
Consequently, current implementation ITSAT allow self-overlapping
actions. However, specification PDDL2.1 allows plans actions,
shown necessary solving certain temporal problems (Fox &
Long, 2007). experimental results indicate restriction render
ITSAT incapable solving current benchmark problems. Nevertheless,
shown that, theory, self-overlapping actions may cause complexity
temporal planning become EXPSPACE-hard rather PSPACE-hard (Rintanen,
2007).
formalism allow two events simultaneously applied
state. example cases simultaneity required, consider two
temporal actions b, starting event adds invariant b,
552

fiITSAT: Efficient SAT-Based Temporal Planner

starting event b adds invariant a. case, might necessary
simultaneously apply starting event actions given state.
clear specification PDDL2.1 whether simultaneity permitted
not. hand, shown almost none current benchmark
problems require simultaneity solvable (Rankooh & Ghassem-Sani,
2013).
PDDL2.1 allows usage numerical variables. supported ITSAT.
PDDL2.1 allows duration dependent effects state dependent durations
actions numerical planning problems. features supported ITSAT
either; ITSAT currently handle numerical fluents.
According formalism, duration temporal action defined (=
?duration x) assignment, x rational number function specifying
actual duration action. PDDL2.1, hand, allows using
inequalities ( ?duration x) ( ?duration x) define range
duration temporal action. Nevertheless, current benchmark problems
include inequalities. Although current implementation ITSAT
support inequalities, quite easy include feature, kinds
constraints duration actions handled Simple Temporal Problems
(Dechter et al., 1991).

3. Preprocessing Phase
Preprocessing important phase many planners. main objective phase
extract certain information problem. information later used
enhance search performance. One important issue addressed devising
preprocessing method correctness extracted information. words,
constraints inferred preprocessing phase must correct sense that,
cause planner become incapable finding valid plans. Moreover,
preprocessing method effective, required performed polynomial
time. section, explain two different preprocessing methods used ITSAT: mutual
exclusion analysis action compression. formally prove methods
correct performed polynomial time.
3.1 Mutual Exclusion Analysis
Mutual exclusion analysis preprocessing method find pairs propositions cannot mutually true state valid plan. SAT-based planners typically add
explicit clause SAT formula pair mutually exclusive propositions.
clauses prevent mutually exclusive pairs propositions true true
time. Although information obtained search phase itself, acquiring beforehand, one prune search tree SAT solver thereby improve
performance.
Polynomial time mutual exclusion analysis classical planning problems originally performed constructing planning graphs, data structure introduced
553

fiRankooh & Ghassem-Sani

GRAPHPLAN (Blum & Furst, 1997). shown mutual exclusion
information obtained planning graphs quite effective improving performance SAT-based planners (Gerevini & Schubert, 1998). methods
introduced compute n-way mutexes (instead pairwise mutexes computed
planning graphs). hn heuristic (Haslum & Geffner, 2000), analyzes reachability set n propositions initial state, example methods.
shown generalization hn heuristic efficiently computed
using syntactic regression operation (Rintanen & Gretton, 2013).
method used ITSAT finding mutual exclusion relations based
planning graph analysis. classical planning graph layered structure. first layer
includes propositions present initial state problem.
layer planning graph, mutual exclusion (mutex ) relations pairs proposition
computed. Two propositions non-mutex first layer
present initial state. action applicable layer preconditions
non-mutex layer. Two different actions mutex layer i, least one
following conditions holds: 1) interference (i.e., one action
deletes effect action), 2) conflict (i.e., one action
deletes precondition action), 3) preconditions mutex layer i.
Layer + 1 includes effects actions applicable layer i. Two propositions
mutex layer become non-mutex layer + 1 produced non-mutex
actions layer i. transfer propositions one layer next layer, exists
special noopp action proposition p requires adds p. construction
planning graph may continue change take places two consecutive layers.
case, say graph leveled off.
Planning graphs previously employed tackle temporal planning problems
(Smith & Weld, 1999). fact, first completely domain-independent temporal planner
called TGP, extension GRAPHPLAN (Blum & Furst, 1997). TGP requires
preconditions temporal action preserved throughout time action
open, allow actions effects upon starting. result, TGP
compatible requirements PDDL2.1. TPSYS (Garrido et al., 2002),
extension TGP, another planning graph based temporal planner produce
plans domains required concurrency. Similar GRAPHPLAN, addition
construction planning graph, TPSYS TGP perform backward search
valid temporal plan.
LPGP (Long & Fox, 2003) another planning graph based temporal planner. LPGP,
mutex relations proposition actions computed considering
causal constraints problem; whereas temporal constraints taken
account later plan extracted solving Linear Programming (LP) problem.
Omitting temporal constraints problem done converting given temporal
problem classical problem. result, graph construction LPGP
similar GRAPHPLAN.
mentioned earlier, ITSAT, temporal constraints problem considered
causally valid plan produced. Therefore, constraints needed
dealt planning graph construction phase. makes graph structure
LPGP suitable ITSAT. Here, explain graph construction phase LPGP.
554

fiITSAT: Efficient SAT-Based Temporal Planner

correctness mutual exclusion information obtained method essential
correctness action compression SAT encoding methods. However, description
LPGP accompanied formal proof correctness. Therefore, here,
formally prove correctness tractability preprocessing method.
Definition 10 (causal abstraction temporal problems). Let P = (I, G, A)
temporal planning problem Ac set classical actions
exactly three classical actions , ai , ae Ac , following properties:
pre(as ) = pre(start(a)) (inv(a) add(a))
add(as ) = add(start(a)) {opena }, opena new proposition specifying
started yet finished
del(as ) = del(start(a)) add(start(a))
pre(ai ) = inv(a) {opena }
add(ai ) = inv(a) {opena }
del(ai ) =
pre(ae ) = pre(end(a)) {opena }
add(ae ) = add(end(a))
del(ae ) = (del(end(a)) add(end(a))) {opena }
causal abstraction P classical problem P c = (state(I), G, Ac ).
fact, Definition 10, produce causal abstraction given temporal planning problem, split temporal action three classical actions , ai , ae .
Actions ae correspond respectively starting ending events a. addition normal effects preconditions, adds special proposition named opena ,
required deleted ae . action ai called invariant checking action
a, requires invariants plus opena preconditions, produces opena
effect.
given temporal planning problem P = (I, G, A), ITSAT produces
c
P = (state(I), G, Ac ) i.e., causal abstraction P. ITSAT constructs classical planning graph P c .
planning graph ITSAT similar GRAPHPLAN. one
difference planning graphs two planners. GRAPHPLAN, mentioned earlier, propositions propagated layers so-called noop actions.
However, ITSAT, exception usage noop actions: new proposition
form opena introduced causal abstraction action a. particular proposition
propagated ai , invariant checking action a. Therefore, ai seen new
kind noop action used cover invariants reasoning mutex relations.

555

fiRankooh & Ghassem-Sani

Theorem 1. Let P = (I, G, A) temporal planning problem P c = (state(I), G, Ac )
causal abstraction P. Let = he1 , ..., en finite sequence events
applicable I, sn = succ(I, ). following conditions must hold:
two propositions p q members state(sn ), p q non-mutex
layer n planning graph P c .
proposition p member state(sn ), action member agenda(sn ),
p opena non-mutex layer n planning graph P c .
Proof. See Appendix A.
planning graph leveled off, subsequent extensions graph
effect new layers. Therefore, two propositions mutex last layer
leveled-off graph, remain mutex subsequently produced layers. case,
Theorem 1 implies pairs propositions never appear temporal
state execution valid temporal plan. matter remains
show mutual exclusion analysis ITSAT performed polynomial time.
Let P temporal planning problem, P c causal abstraction P.
deduced Definition 10, size P c greater P constant
factor. process constructing planning graph P c obtained modifying
construction process planning graphs GRAPHPLAN planner, way
temporal action a, noopopena never used. GRAPHPLAN constructs planning
graphs polynomial time (Blum & Furst, 1997). Therefore, overall time needed
mutual exclusion analysis ITSAT polynomial size given temporal
planning problem.
3.2 Action Compression
Temporal actions variety temporal relations one another. popular
model representing temporal relations actions initially introduced James
Allen (1984). model included 13 possible temporal relations two actions.
Allens temporal relations require starting and/or ending events actions
executed simultaneously. mentioned Section 2.2, none temporal plans
produced ITSAT necessitate simultaneity. result, set temporal
relations two temporal actions confined proper subset Allens
temporal relations. possible temporal relations depicted Figure 7.
shown Figure 7, 4 6 types relations, actions concurrent, i.e.,
exists time two actions executed. concurrency
unnecessary solving temporal planning problems. know two actions
required concurrently executed, order find valid plan, checking
two temporal relations depicted Figure 7-(c) sufficient searching phase
planner. However, valid plans include concurrent executions two actions,
restricting temporal relations actions two relations depicted Figure
7-(c) render planner incomplete.

556

fiITSAT: Efficient SAT-Based Temporal Planner

Figure 7. Temporal relations two PDDL2.1 actions

Definition 11 (compression-safe sets actions compressed plans). Let
P = (I, G, A) temporal planning problem exists least one valid
temporal plan, subset A. say compression-safe P, exists
causally valid plan P compressed respect . causally valid plan
= he1 , ..., en compressed respect following property:
k, ek starting event action , ek+1 ending event
a.
According Definition 11, starting ending events members
assumed executed consecutively least one causally valid plan. Therefore,
plan executed, event causally needed happen starting
ending member . suggests members regarded
single event environment, rather two separate starting ending events.
557

fiRankooh & Ghassem-Sani

words, member , compress starting ending events
single event without rendering problem unsolvable. example, consider
DRIVERLOGSHIFT temporal planning problem presented Example 3. plan presented
Example 3 shows set LOAD, MOVE, UNLOAD actions compressionsafe set actions problem. straightforward analysis example shows
neither WORK actions presented Example 3 member compression-safe
subset actions.
Note that, according Definition 11, causally valid plan regarded
compressed sequence events. Although concept compression extended
cover even sequences events lead goal state, sake
simplicity, focused attention sequences causally valid
plans, defined compression-safe actions solvable temporal planning problems.
explain later Section 4, information obtained compression-safety analysis
incorporated encoding problem adding extra SAT formulae,
makes problem hand tighter. words, information used prune
search space SAT solver. result, handling compression-safety
never cause planner produce (invalid) plan unsolvable planning problem.
Safe action compression employed field temporal planning
(Coles et al., 2009). shown temporal problems possess
property required concurrency, temporal actions safely compressed classical
actions (Cushing et al., 2007). temporal problem said required concurrency,
every valid temporal plan includes least one action whose execution overlaps
execution action. problems without required concurrency, temporal
actions compressed classical actions. case, problem transformed
classical planning problem. phenomenon completely consistent
semantics Definition 11, easily shown problems without required
concurrency, set actions indeed compression-safe set actions. However,
case Example 3, even problem required concurrency
property, may still exist non-empty compression-safe set actions.
CRIKEY3 successor, POPF, two state-space based temporal planners
detect compression-safe actions preprocessing task (Coles et al., 2009). However,
concept compression-safety planners different presented
Definition 11. CRIKEY3 assume ending event compression-safe
action must executed immediately corresponding starting event. Instead,
starting event compression-safe action applied state, using simple inference
method, CRIKEY3 determine apply corresponding ending event.
method reduce branching factor search space state-space based temporal
planning. Here, show using idea detecting compression-safe actions,
one significantly reduce search space satisfiability checking based temporal
planning. later explained Section 4.4, compression-safe action a, add
clause SAT formula guarantee starting event present step
ending event present step. clauses used
prune search tree SAT solver checking satisfiability produced
formula.
CRIKEY3 considers action compression-safe following two conditions hold:
558

fiITSAT: Efficient SAT-Based Temporal Planner

pre(end(a)) inv(a)
del(end(a)) =
Figure 8-(a) shows temporal plan executed reach proposition q. example ending event action b precondition delete effect. Therefore,
CRIKEY3 considers b compression safe. However, goal produce q,
singleton = {b} compression-safe set Definition 11. fact, method used
CRIKEY3 specifically devised state-space based temporal planners,
cannot easily employed SAT-based planners ITSAT. contrast,
later shown, method easily used state-space based temporal planners
SAT-based planners.
cases method used CRIKEY3 cannot detect actions
compression-safe according Definition 11. Consider plan depicted Figure 8(b). Suppose proposition p member initial state, goal
produce proposition g. plan, actions b must executed consecutively
produce g. p q, respectively overall conditions
b mutually exclusive, never true together. However, neither b
second property required CRIKEY3 regarded compression-safe action.
section show mutex information used detecting compression-safe
actions.
Definition 12 (swappable events). Let two different temporal actions, e
starting ending event a, e starting ending event . say e
e swappable following conditions hold:
e e interference other: add(e) del(e ) = add(e )
del(e) = .
e e conflict other: del(e) (pre(e ) inv(a )) =
del(e ) (pre(e) inv(a)) = .
e e supporting other: add(e) (pre(e ) (inv(a ) add(e ))) =
add(e ) (pre(e) (inv(a) add(e))) = .
According Definition 12, two events swappable causal relation
them. means causally valid plan = he1 , ..., e, e , ..., en i, swap
e e reach another causally valid plan = he1 , ..., e , e, ..., en i. use
swapping reorder events given causally valid plan without falsifying it.
Consider causally valid plan = he1 , ..., en i. Let ei ej starting
ending event action. events plan swappable ej ,
then, repeatedly swapping, one reorder produce another causally valid plan
= he1 , ..., ei , ej , ei+1 , ..., ej1 , ej+1 , ..., en i, ei ej two consecutive events.
Therefore, {a} compression-safe set. case, say compressed
towards start. Similarly, every event plan ei ej swappable
ei , then, repeatedly swapping, one reorder produce causally valid
plan = he1 , ..., ei1 , ei+1 , ..., ej1 , ei , ej , ..., en i. again, conclude {a}
compression-safe set. latter case, say compressed towards end.
559

fiRankooh & Ghassem-Sani

Figure 8. Temporal actions regarded compressible ITSAT (a) CRIKEY3 (b)

find whether safe compress given action a, need check
events swappable starting and/or ending events a. fact, considering
mutex relations obtained planning graph problem, already know
events never executed open. information effectively used
find given set actions compression-safe.
Definition 13 (compressible actions). Let P = (I, G, A) temporal planning problem, particular temporal action. say compressible towards
start, every event e e starting ending event {a}, least
one following conditions holds:
precondition add effect e mutex opena last layer leveled-off
planning graph causal abstraction P.
e swappable end(a).
560

fiITSAT: Efficient SAT-Based Temporal Planner

Similarly, say compressible towards end, every event e e
starting ending event {a}, least one following conditions holds:
precondition add effect e mutex opena last layer leveled-off
planning graph causal abstraction P.
e swappable start(a).
Theorem 2. Let P = (I, G, A) solvable temporal planning problem. Let set
every member either compressible towards start compressible towards
end. compression-safe P.
Proof. See Appendix A.
give example clarification matter.
Example 4. Let P = (I, G, A) temporal planning problem, set
three temporal actions a, b, c. Consider hypothetical causally valid plan depicted
Figure (9-a), execution action includes execution action b
turn includes execution action c. Assume compressible towards start,
b compressible towards end. show plan converted another
causally valid plan a, b, c executed sequentially. Figures (9-b)
(9-c) show results two consecutive swaps b compressed towards
end. starting event b swapped starting event c transform
plan Figure (9-a) plan Figure (9-b). Since b compressible towards
end, swapping cannot result invalid plan. Similarly, starting event b
swapped ending event c transform plan Figure (9-b)
plan Figure (9-c). Figures (9-d) (9-g) show results four consecutive swaps
compressed towards start. result swaps, fully
sequential plan shown figure (9-g) produced. implies even planner
allow execution event b open, still capable producing
temporally valid plan Figure (9-g).
given problem P = (I, G, A), ITSAT computes compression-safe set
Theorem 2. check first condition Definition 13, ITSAT needs construct
planning graph causal abstraction P which, showed previous
subsection, done polynomial time. second condition Definition 13,
suffices check every possible pair events see swappable. Since
done pair constant time, total time O(|A|2 ). conclude
finding performed polynomial time.
method described finding compression-safe actions used statespace temporal planners, too. State-space temporal planners divided two categories. first category includes planners based so-called decision
epoch planning method (Cushing et al., 2007). Examples decision epoch planners
TP4 (Haslum, 2006), SAPA (Do & Kambhampati, 2003), TFD (Eyerich et al., 2009).
561

fiRankooh & Ghassem-Sani

Figure 9. Action compression

method, start action restricted immediately start
end another action. state explicit time-stamp. action applied
state, starting time action set time-stamp state. result,
starting event action added plan, time corresponding
ending event exactly known. searching valid plan, state,
562

fiITSAT: Efficient SAT-Based Temporal Planner

planner make decision either advancing time ending event
open action, open new action. However, know action compressionsafe, planner advance time ending action thereby prune
search space. Plans produced way might larger makespans comparison
produced without pruning search space. Nevertheless, produced plans
rescheduled find plans improved makespans method explain later
Section 6.
alternative approach state space search so-called temporally lifted
progression planning, proved complete PDDL2.1 (Fox & Long,
2003). CRIKEY3 POPF examples planners using approach.
state temporally lifted progression planning represents permutation
number events. state, consistency temporal constraints imposed
sequence events state checked solving Simple Temporal Problem (STP).
Similar decision epoch planning, state, may exist two possible choices:
add ending event open action, open new action. However, compressionsafe actions, ending event actions applied immediately starting event,
turn reduces future choices planner. show Section 6
taking advantage compression-safe actions manner, planner still visit
STPs causally valid permutations events.
Table 1 shows comparison average percentage actions regarded
compression-safe new method method used CRIKEY3 POPF, various temporal planning domains. explain information regarding benchmark
domains problems later Section 6. seen Table 1, compression
method detect significantly compressible actions number benchmark domain.

4. Encoding Phase
section, explain abstract causal problem associated given temporal
problem encoded SAT formula. classical planning, exist one
way translate particular planning problem corresponding SAT formula. Previous
investigations field classical planning show choice encoding method
major impact efficiency SAT-based planner. mentioned earlier,
successful SAT-based classical planners used special encoding methods
based so-called -step -step semantics valid plans (Rintanen et al., 2006).
section, define temporal versions classical -step -step plans.
show exactly semantics used translate given temporal planning
problem SAT formula. introduce -step encoding two different types
-step encodings temporal planning. -step first -step encoding methods
temporal versions classical -step -step encodings. Similar classical
versions, new encodings, restrictive simplifying assumptions assumed
hold. second type -step encoding, however, obtained relaxing one
assumptions. later show, new -step encoding often requires fewer steps
one. Besides, experimental results show, among new encoding methods,
second -step encoding results best performance ITSAT terms speed
563

fiRankooh & Ghassem-Sani

domain
zenotravel
rovers
depots
airport
pegsol
crewplanning
openstacks
elevators
sokoban
parcprinter
driverlog
floortile
mapanalyser
matchcellar
parking
rtam
satellite
storage
turnandopen
tms
driverlogshift
matchlift

CRIKEY3
12
85
100
0
100
100
100
100
100
100
100
100
13
96
100
88
100
100
95
73
98
95

ITSAT
100
100
100
95
100
100
100
100
100
100
98
100
96
96
100
95
98
99
99
75
98
95

Table 1: Average Percentage Compressed Actions
memory usage planner. necessary proofs soundness completeness
encoding methods given section.
4.1 Parallel Semantics Causally Valid Plans
mentioned earlier, classical -step semantics permits parallel execution
one action step, validity plan depend execution
order actions. simply guaranteed adding particular clause
pair mutually exclusive actions ensure actions included
step. However, strategy work temporal planning. temporal
planning, temporal constraints imposed starting ending events
actions, validity particular ordering events certain step, depends
ordering events steps. Nevertheless, ITSAT problem
tackled separating causal temporal reasoning phases. general, focus
finding causally valid plans, postpone scheduling phase, mentioned problem,
checking feasibility imposing different orderings events step,
longer exist. next introduce semantics causally valid -step -step temporal
plans.

564

fiITSAT: Efficient SAT-Based Temporal Planner

Definition 14 (temporal -steps -steps). Let E = {e1 , ..., en } set events,
s1 s2 two temporal states. temporal -step s1 s2
one-to-one ordering functions : {1, ..., n} {1, ..., n} (i.e., permutations events),
have: s2 = succ(s1 , heO(1) , ..., eO(n) i). temporal -step s1 s2
exist least one-to-one ordering function : {1, ..., n} {1, ..., n} (i.e., least one
permutation events), that: s2 = succ(s1 , heO(1) , ..., eO(n) i).
Definition 15 (causally valid -step -step plans). Let P = (I, G, A) temporal planning problem. Suppose s0 , ..., sn sequence temporal states s0 = I,
G state(sn ), agenda(sn ) = . 1 n, Stepi -step (-step)
si1 si , call sequence = hStep1 , ..., Stepn i, causally valid -step (-step)
plan P. say hs0 , ..., sn state transition sequence .
Classical -step -step encodings (Rintanen et al., 2006) based -step
-step semantics classical valid plans, respectively. However, -step encoding,
sake improving efficiency planner, following restrictive rules
enforced semantics.
Rule 1: Instead accepting possible orderings among actions step,
fixed arbitrary ordering allowed. result, rule, execution
step necessitates execution actions according fixed ordering.
Rule 2: Preconditions actions step must members state immediately step. Similarly, effects actions step must
consistent state reached immediately step.
section, present one -step two -step encodings planning causal
abstractions temporal planning. encodings based -step -step
semantics causally valid plans (Definition 15). considering events, instead actions,
rules applied temporal planning, too. first -step
encoding, respect rules, second -step encoding, second restrictive rule
relaxed.
fact, second rule imposes serious restrictions applicability actions
step. instance, prevents proposition produced used
step plan. Neither allow deletion production
particular proposition step. relaxing restrictions, encoding
compact, i.e., relaxation permits events occur step. classical
planning, less relaxed form Rule 2 introduced effects actions
step used actions step (Wehrle & Rintanen, 2007). Here,
however, totally relax Rule 2 allow proposition required, added,
deleted many times step.
explaining SAT encodings, first define SAT variables auxilary clauses
commonly used three encoding methods. Let = hStep1 , ..., Stepn causally
valid -step (or -step) plan given temporal planning problem P = (I, G, A),
hs0 , ..., sn state transition sequence . order encode P SAT formula
whose model translated back , use following SAT variables:
565

fiRankooh & Ghassem-Sani

proposition p, 0 n, define SAT variable pt .
Assigning true (f alse) pt implies p (is not) member state(st ).
action A, 0 n, define SAT variable .
Assigning true (f alse) implies (is not) member agenda(st ).
event e e starting ending event action A,
1 n, define SAT variable et . Assigning true (f alse) et
implies e (is not) member Stept .
SAT formula satisfiable exists model it. model binary function
assigns value true f alse variable formula way
formula satisfied. encoding methods, produced formula
model , one easily translate corresponding causally valid -step (or -step)
plan, using description given variables formula. denote
resulting plan plan(M ). showing correctness particular encoding method,
two issues must addressed. First, must show exists causally valid
plan temporal problem P, encoding P model. call
completeness encoding method. Second, must show encoding P
model , plan(M ) causally valid plan P. called soundness
encoding method.
Note here, prove finite-horizon completeness -completeness
encodings. words, prove exists -step (or -step) plan
l steps given problem, problem translated -step (or -step)
encoding satisfiable SAT formula l steps, model formula
translated back . hand, proof -completeness would need
value l determined. proofs finite-horizon completeness could implied
-completeness least upper bound value l determined. Recent
research field classical planning shown classical planning domains,
tight upper bounds length optimal plans determined (Rintanen & Gretton,
2013). However, determining upper bounds temporal planning beyond scope
current work. find causally valid plan, ITSAT starts encoding
one step, sequentially produces tries satisfy formulae increasing number
steps, satisfiable formula encountered predefined time limit
reached.
classical SAT-based planning, order produce linear-size encodings -step
-step semantics valid plans, special sets clauses, named chains, used
(Rintanen et al., 2006). Since used chains ITSAT, formal definition
temporal version given here. Let e1 , ..., en arbitrary fixed ordering
events, E R two sets events, k natural number, special symbol
assigns unique name chain hand. define chain(e1 , ..., en ; E; R; k; m)
conjunction formulae (C-1) (C-3) stated below.
(C-1)

V

{eki bkj,m |i < j, ei E, ej R, {ei+1 , ..., ej1 } R = }

(C-2)

V

{bki,m bkj,m |i < j, {ei , ej } R, {ei+1 , ..., ej1 } R = }
566

fiITSAT: Efficient SAT-Based Temporal Planner

(C-3)

V

{bki,m eki |ei R}

formulae fact encodes message passing strategy. symbol specifies
name message used distinguish SAT variables certain chain
chains. number k specifies step whose variables affected
message produced. message may produced member E.
receivers message members R. bki,m true, means message
received i-th event k-th step formula. ei member E, eki
true, message produced sent ej , first member R
located ei fixed ordering. represented chain(e1 , ..., en ; E; R; k; m)
clauses form eki bkj,m formula (C-1). message produced,
transmitted forward according fixed ordering clauses form bki,m bkj,m
formula (C-2). event ei receives message, corresponding SAT variable
bef alse clauses form bki,m eki formula (C-3). fact, members R
receive message certainly excluded final plan.
present examples show chains practically used guarantee particular characteristics output plan have.
Example 5. Assume e1 , e2 , e3 , e4 four events. Suppose proposition x
required e1 e4 , deleted e2 , added e3 . assume four propositions
p1 , ..., p4 respectively added e1 , ..., e4 . Consider following two cases:
Case 1: want prevent proposition x required deleted
step, say k, final plan. purpose, add conjunction
chain(e1 , ..., e4 ; E; R; k; mx1 ) chain(e4 , ..., e1 ; E; R; k; mx2 ) formula, E
set events delete x (i.e., E = {e2 }), R set events
require x (i.e., R = {e1 , e4 }). Note mx1 mx2 two symbols enable us
distinguish SAT variables used two different chains. case,
adding chain(e1 , ..., e4 ; E; R; k; mx1 ) add following formulae encoding
problem:
ek2 bk4,mx
1



bk1,mx
1



bk4,mx
1

bk1,mx ek1
1

bk4,mx ek4
1

Assume exists model produced SAT encoding
(ek2 ) = true. case, since satisfies ek2 bk4,mx , (bk4,mx ) = true.
1
1
Consequently, since satisfies bk4,mx ek4 , (ek4 ) = f alse. words,
1
e2 member step k, e4 cannot member step. Similarly,
adding chain(e4 , ..., e1 ; E; R; k; mx2 ) add following formulae encoding
problem:
ek2 bk1,mx
2

567

fiRankooh & Ghassem-Sani

bk4,mx bk1,mx
2



bk4,mx
2

2



ek4

bk1,mx ek1
2

argument similar one given chain(e1 , ..., e4 ; E; R; k; mx1 ) shows
adding chain(e4 , ..., e1 ; E; R; k; x2 ), e2 member step k, e1 cannot
member step. result, adding mentioned chains SAT
formula, execution step k produces p2 , cannot produce p1 p4 .
actually occurrence conflicting actions step final plan
avoided linear-size classical -step encoding (Rintanen et al., 2006).
Case 2: allow proposition x required deleted particular step
k deleting event precede requiring event fixed ordering
he1 , e2 , e3 , s4 i. purpose, need add chain(e1 , ..., en ; E; R; k; mx )
formula, E R E R case 1. case,
execution step k produces p2 , produce p1 , p4 . strategy, too,
initially introduced linear-size classical -step encoding (Rintanen et al.,
2006).
Note one admits second restrictive rule mentioned above, case
classical -step -step encodings, proposition added event step
deleted another event step. result, execution step
k produces p2 , cannot produce p3 cases.

4.2 Temporal Versions Classical -step -step Encodings
first present temporal versions classical -step -step encodings. Similar
classical forms, temporal versions encodings, assume arbitrary
fixed ordering e1 , ..., en events given temporal problem P = (I, G, A).
assume output plan fixed number steps, denoted l.
Let = hStep1 , ..., Stepl output plan P, hs0 , ..., sl state transition
sequence . event e, let action(e) member whose starting
ending event equal e. Let P set propositions P. proposition
p P , let Ep = {e|p del(e)}, Ep+ = {e|p add(e)} Rp = {e|p pre(e)} {e|p
inv(action(e)) add(e)}. Moreover, assume two dummy events e0 en+1 ,
precondition, add effect, delete effect.
4.2.1 -step Encoding
Given temporal problem P = (I, G, A), produce SAT-formula l , based
-step semantics causally valid plans, P conjunction formulae
described below.
V
(-1) {p0 |p state(I)} {p0 |p
/ state(I)}
V l
(-2) {p |p G}
568

fiITSAT: Efficient SAT-Based Temporal Planner

(-3)

V

{a0 |a A}

(-4)

V

{al |a A}

(-5)

V

{ek pk1 |0 < k l, p P, e Rp }

(-6)

V

{ek pk |0 < k l, p P, e Ep+ }

(-7)

V

(-9)

V

(-10)

V

(-11)

V

(-12)

V

{ek ak1 ak |0 < k l, A, e = start(a)}

(-13)

V

{ek ak1 ak |0 < k l, A, e = end(a)}

{ek pk |0 < k l, p P, e Ep }
V
W
(-8) {pk1 pk eEp+ ek |0 < k l, p P }
{pk1 pk

W

eEp

ek |0 < k l, p P }

{chain(e1 , ..., en+1 ; Ep ; Rp {en+1 }; k; mp1 )|0 < k l, p P }
{(bkn+1,mp ak )|0 < k l, p inv(a)}
1

{chain(en , ..., e0 ; Ep ; Rp {e0 }; k; mp2 )|0 < k l, p P }
{(bk0,mp ak1 )|0 < k l, p inv(a)}
2

Formula (-1) indicates member state(s0 ) true iff present initial state. Similarly, formula (-2) states members goal state must true
state(sl ). Formulae (-3) (-4) imply agenda(s0 ) agenda(sl ) empty.
Formulae (-5) (-7) show event applied step k, preconditions must
present state(sk1 ), effects must consistent state(sk ). Formulae (8) (-9) responsible encoding so-called explanatory frame axioms: formula
(-8) implies p present step k, must exist least
one event step k p add effects. Similarly, formula (-9) implies p
present step k, must exist least one event step k
deletes p. Formulae (-10) (-11) added guarantee events step
executed possible ordering. Formula (-10) implies p deleted
event ei step k, p cannot required event ej step k j > i.
implies p deleted event step k, action p invariant,
cannot member agenda(sk ). Note chain(e1 , ..., en+1 ; Ep ; Rp ; k; mp1 )
used formula (-10), value bn+1,mp1 indicates whether p deleted
event step k. reason using dummy event en+1
indicator. Analogously, formula (-11) implies p deleted event ei step k,
p cannot needed event ej step k j < i. Formula (-11)
implies p deleted event step k, action p invariant,
cannot member agenda(sk1 ). Formulae (-12) (-13) responsible
applying appropriate changes agendas states located
step final plan. Formula (-12) implies starting event action
member step k output plan, must member agenda(sk )
agenda(sk1 ). Similarly, formula (-13) implies ending event action
569

fiRankooh & Ghassem-Sani

member step k plan, must member agenda(sk1 ) agenda(sk ).
Theorem 3 (completeness temporal -step encoding). Let P = (I, G, A)
solvable temporal planning problem, {e1 , ..., en } set events P, =
hStep1 , ..., Stepl causally valid -step plan P. exists model l
= plan(M ).
Proof. See Appendix A.
Theorem 4 (soundness -step encoding). Let P = (I, G, A) temporal planning
problem, {e1 , ..., en } set events P, l -step encoding P.
l model , plan(M ) causally valid -step plan P.
Proof. See Appendix A.
4.2.2 -step Encoding
part, present SAT-formula l , based -step semantics
causally valid plans. considering two restrictive rules stated above, -step
encoding similar -step encoding described previously section. However,
two major differences two kinds encoding. First, -step
encoding allows proposition required deleted step, provided
deleting event precede requiring event fixed ordering he1 , ..., sn i.
contrast -step encoding, proposition could deleted
required step final plan. Second, -step encoding,
step may contain starting ending event action. Given
temporal problem P = (I, G, A), produce SAT-formula l , based
-step semantics causally valid plans, P conjunction formulae described
below.
V
(-1) {p0 |p state(I)} {p0 |p
/ state(I)}
V l
(-2) {p |p G}
V
(-3) {a0 |a A}
V
(-4) {al |a A}
V
(-5) {ek pk1 |0 < k l, p P, e Rp }
V
(-6) {ek pk |0 < k l, p P, e Ep+ }
V
(-7) {ek pk |0 < k l, p P, e Ep }
V
W
(-8) {pk1 pk eEp+ ek |0 < k l, p P }
(-9)

V

{pk1 pk

W

(-10)

V

{chain(e1 , ..., en+1 ; Ep ; Rp {en+1 }; k; mp1 )|0 < k l, p P } {(bkn+1,mp

eEp

ek |0 < k l, p P }
1

ak )|0 < k l, p inv(a)}
570

fiITSAT: Efficient SAT-Based Temporal Planner

(-11)

V

(-12)

V

(-13)

V

(-14)

V

(-15)

V

(-16)

V

(-17)

V

(-18)

V

(-19)

V

(-20)

V

{eki ak1 |0 < k l, A, ei = start(a), ej = end(a), < j}
{eki ak ekj |0 < k l, A, ei = start(a), ej = end(a), < j}
{ekj ak |0 < k l, A, ei = start(a), ej = end(a), < j}
{ekj ak1 eki |0 < k l, A, ei = start(a), ej = end(a), < j}
{eki ak1 ekj |0 < k l, A, ei = start(a), ej = end(a), j < i}
{eki ak |0 < k l, A, ei = start(a), ej = end(a), j < i}
{ekj ak eki |0 < k l, A, ei = start(a), ej = end(a), j < i}
{ekj ak1 |0 < k l, A, ei = start(a), ej = end(a), j < i}
{ak1 ak eki |0 < k l, A, ei = start(a)}
{ak1 ak ekj |0 < k l, A, ej = end(a)}

Note formulae (-1) (-9) exactly formulae (-1) (-9). Similar
-step encoding, formulae responsible validity initial state, goal
state, conditions effects events, explanatory frame axioms explained
before. Moreover, notice formula (-10) present -step encoding
formula (-10), formula (-11) present l . results first major difference
stated -step encoding -step encoding. Formulae (-11)to (-20)
enforce appropriate changes agenda(sk1 ) agenda(sk ), agendas
states immediately step k final plan. According definitions,
formulae (-11) (-14) added action property start(a)
located end(a) fixed ordering he1 , ..., en i. Formula (-11) ensures
started step k, open sk1 . Formula (-12) guarantees
started ended step k, must open sk . Formula (-13) ensures
ended step k, open sk . Formula (-14) implies ended
started step k, must open sk1 . Analogously, formulae (-15) (-18)
guarantee similar properties action property start(a) located
end(a) fixed ordering he1 , ..., en i. Formula (-19) ensures member
agenda(sk ) agenda(sk1 ), must started step k. Similarly, formula (-20)
ensures member agenda(sk1 ) agenda(sk ), must ended step
k.
Since -step encoding conforms two restrictive rules stated earlier
section, may exist -step causally valid plan l steps given problem
l would unsatisfiable problem. case linear size step encoding classical planning problems (Rintanen et al., 2006). However, since
showed Theorem 3 -step encoding complete, completeness -step
encoding proved showing satisfiability l entails satisfiability l .
Theorem 5 (completeness -step encoding). Let P = (I, G, A) solvable temporal planning problem, {e1 , ..., en } set events P, = hStep1 , ..., Stepl
causally valid -step plan P. exists model l = plan(M ).
571

fiRankooh & Ghassem-Sani

Proof. See Appendix A.
Theorem 5 shows -step encoding, number required steps
solve temporal planning problem less (or equal to) required -step
encoding. words, -step encoding compact -step counterpart.
Theorem 6 (soundness -step encoding). Let P = (I, G, A) temporal planning
problem, {e1 , ..., en } set events P, l -step encoding P.
l model , plan(M ) causally valid -step plan P.
Proof. See Appendix A.
4.3 Relaxed -step Encoding
mentioned Section 4.2.2, -step encoding allows proposition
required deleted two events step, deleting event
precede requiring event fixed ordering he1 , ..., en i. Besides, since formulae (-5)
(-6) present -step -step encodings, proposition
added deleted step encodings. restrictions,
present classical -step -step encodings (Rintanen et al., 2006), lifted
new relaxed version -step encoding. result, proposition required,
added, deleted step many times needed. property
previously examined classical -step encoding, consequently, chaining mechanism
explained Section 4.1 compatible it. Here, introduce generalized version
chains explain conceptual difference used classical encodings.
present new kinds chains used specially temporal planning preserving
invariants temporal actions plan produced. Note that, similar
non-relaxed -step encoding, assume events step executed
according fixed ordering he1 , ..., en i.
Let k natural number e1 , ..., en fixed ordering events. reasons discussed later, assume ei starting event action, ei+1
ending event action. words, assume ending event
action located immediately starting event fixed ordering. Note here,
demand end action immediately follow start final plan.
put constraint fixed ordering. cannot compromise completeness
ITSAT: SAT solver still choose start action step k, choose whatever
actions needed steps k k + arbitrary m, choose end
step k +m. Moreover, suppose two dummy events e0 en+1 ,
precondition, add-effect, delete-effect. Let P set propositions
P. proposition p P , let Ep = {e|p del(e)}, Ep+ = {e|p add(e)}, Op = {e|p
inv(action(e))} {e0 , en+1 }, Rp = {e|p pre(e)} {e|p inv(action(e)) add(e)}.
define chain (e0 , ..., en+1 ; Ep+ ; Ep ; Rp ; k; mp ) conjunction formulae (C -1)
(C -8) stated below. Note mp symbol used distinguishing SAT varibales
used formula chain (e0 , ..., en+1 ; Ep+ ; Ep ; Rp ; k; mp ) variables used
formulae.

572

fiITSAT: Efficient SAT-Based Temporal Planner

(C -1)

V

{eki bkj,mp |i < j, ei Ep+ , ej Rp Ep , {ei+1 , ..., ej1 } (Rp Ep ) = }

(C -2)

V

{eki bkj,mp |i < j, ei Ep , ej Rp Ep+ , {ei+1 , ..., ej1 } (Rp Ep+ ) = }

V

{bki,mp bkj,mp |i < j, ei Rp (Ep+ Ep ), ej R Ep+ Ep , {ei+1 , ..., ej1 }
(Rp Ep+ Ep ) = }
V
(C -4) {(bki,mp eki ) bkj,mp |i < j, {ei , ej } Rp Ep+ Ep , {ei+1 , ..., ej1 } (Rp Ep+
Ep ) = }
V
(C -5) {(bki,mp eki ) bkj,mp |i < j, {ei , ej } Rp Ep+ Ep , {ei+1 , ..., ej1 } (Rp
Ep+ Ep ) = }
V
(C -6) {bki,mp eki |ei Rp }

(C -3)

(C -7) bk0,mp pk1
(C -8) bkn+1,mp pk
fact, chain (e0 , ..., en+1 ; Ep+ ; Ep ; Rp ; k; mp ) encodes message passing method
different chain(e1 , ..., en ; E; R; k; m). chain (e0 , ..., en+1 ; Ep+ ; Ep ; Rp ; k; mp ),
conveyed message fact value proposition p, therefore either true
f alse. Similar message passing strategy chain(e1 , ..., en ; E; R; k; m), received
message transferred forward direction fixed ordering e1 , ..., en .
event Ep+ , Ep , Rp receives message previous event fixed ordering.
Every event may may change value received message. either cases,
message passed next event. events Ep+ change value
received message true, events p add-effects. Similarly,
events Ep change value received message f alse. formulae
(C -1) (C -2) impose changes value received message. event
member Ep+ Ep , neither adds deletes p, thus, pass received
message without altering value. enforced (C -3). (C -4) (C -5) ensure
received messages passed without changed events
chosen Stepk output plan. According (C -6), event Rp receives
message value f alse, event cannot chosen member Stepk .
members Rp require p, necessitates received messages
value true. (C -7) implies initial value message produced Stepk equal
value p state immediately execution Stepk . Similarly, (C -8)
implies value p state immediately execution Stepk
equal final value message Stepk .
Example 6. Consider events given Example 5. Let E + set events
add x (i.e., E + = {a3 }), E set events delete x (i.e., E = {a2 }),
R set events require x (i.e., R = {a1 , a4 }). Moreover, suppose
two dummy events e0 e5 , precondition, add-effect,
delete-effect. Assume added chain (e0 , ..., e5 ; E + ; E ; R {e0 , e5 }; k; mx )
573

fiRankooh & Ghassem-Sani

SAT formula. According formulae (C -1) (C -8), chain conjunction
following formulae:
ek3 bk4,mp
ek2 bk3,mp
bk0,mp bk1,mp
bk1,mp bk2,mp
bk4,mp bk5,mp
bk0,mp ek0 bk1,mp
bk1,mp ek1 bk2,mp
bk2,mp ek2 bk3,mp
bk3,mp ek3 bk4,mp
bk4,mp ek4 bk5,mp
bk0,mp ek0 bk1,mp
bk1,mp ek1 bk2,mp
bk2,mp ek2 bk3,mp
bk3,mp ek3 bk4,mp
bk4,mp ek4 bk5,mp
bk0,mp ek0
bk1,mp ek1
bk4,mp ek4
bk5,mp ek5
bk0,mp xk1
bk5,mp xk
574

fiITSAT: Efficient SAT-Based Temporal Planner

straightforward examination shows model chain mentioned (ek0 ) = (ek1 ) = (ek2 ) = (ek3 ) = (ek4 ) = (ek5 ) = true,
(bk0,mp ) = (bk1,mp ) = (bk2,mp ) = (bk4,mp ) = (bk5,mp ) = true, (bk3,mp ) = f alse.
words, x deleted e2 Stepk final plan, later produced
e3 , result, e4 appear Stepk , too. Here, (bk3,mp ) = f alse represents
fact x deleted execution e2 . example, four propositions
p1 , p2 , p3 , p4 produced single step final plan. Note neither
cases Example 5, producing propositions one step possible.
example new -step encoding, employs generalized message
passing strategy, permit parallelism allowed temporal versions
classical -step -step encodings.
addition chain (e0 , ..., en+1 ; Ep+ ; Ep ; Rp ; k; mp ), responsible tracking
value p inside Stepk , need extra formulae prevent p deleted
whenever p invariant open temporal action. Therefore, introduce two new
ob

ob
chain formulae: chainof (e1 , ..., en+1 ; Ep ; Op ; k; mof
p ) chain (e0 , ..., en ; Ep ; Op ; k; mp ).
Formula chainof (e1 , ..., en+1 ; Ep ; Op ; k; mof
p ) produced conjunction formulae


(C -1) (C -4). Similar chains explained before, mof
p symbol used distinguish SAT varibales chain formulae.
V
(Cof -1) {eki bk |i < j, ei Ep , ej Op , {ei+1 , ..., ej1 } Op = }
j,mp

(Cof -2)

V

{bk

(Cof -3)

V

{(bk

ekj ) eki |ei Op , ei = start(a), ej = end(a)}

(Cof -4)

V

{(bk

ak ) eki |a A, ei = start(a), ei Op }

i,mof
p

bk

j,mof
p

j,mof
p

n+1,mof
p

|i < j, {ei , ej } Op , {ei+1 , ..., ej1 } Op = }

Similar chain(e1 , ..., en ; Ep ; Rp ; k; mp ), chainof (e1 , ..., en ; Ep ; Op ; k; mof
p ) represents
message produced sent forward direction fixed ordering, whenever
proposition p deleted event. (Cof -1) (Cof -2) responsible production
propagation mentioned message, respectively. (Cof -3), ending event
action p invariant receives message step k, step k must
include starting event a. cases, (Cof -3) prevents open p
deleted. assume fixed ordering, ending event
action located immediately starting event. (Cof -4) guarantees p deleted
somewhere step k, action p invariant open step k, step
k must include starting event (otherwise, open everywhere step k,
thus, p, invariant a, deleted open).
chainof (e1 , ..., en+1 ; Ep ; Op ; k; mof
p ), message indicates p deleted sent
forward. Thus, cannot help preserving invariants members Op
started prior deletion p. tackle problem, add another chain,
namely chainob (e0 , ..., en ; Ep ; Op ; k; mob
p ), formula. chain quite analogous



chain (e1 , ..., en+1 ; Ep ; Op ; k; mp ), whenever p deleted event, chain sends
575

fiRankooh & Ghassem-Sani

message backward according fixed ordering. chainob (e0 , ..., en ; Ep ; Op ; k; mob
p )
ob
ob
produced conjunction formulae (C -1) (C -4).
(Cob -1)

V

{eki bkj,mob |j < i, ei Ep , ej Op , {ej+1 , ..., ei1 } Op = }

(Cob -2)

V

{bki,mob bkj,mob |j < i, {ei , ej } Op , {ej+1 , ..., ei1 } Op = }

(Cob -3)

V

{(bki,mob eki ) ekj |ei Op , ei = start(a), ej = end(a)}

(Cob -4)

V

{(bk0,mob ak1 ) ekj |a A, ej = end(a), ej Op }

p

p

p

p

p



present SAT-formula l , represents relaxed -step encoding

based -step semantics causally valid plans. l produced conjunction
formulae described below.
V
( -1) {p0 |p state(I)} {p0 |p
/ state(I)}
V
( -2) {pl |p G}
V
( -3) {a0 |a A}
V
( -4) {al |a A}
V
( -5) {chain (e0 , e1 , ..., en+1 ; Ep+ ; Ep ; Rp {e0 , en+1 }; k; mp )|0 < k l, p P }
( -6)

V

{chainof (e1 , ..., en+1 ; Ep ; Op ; k; mof
p )|0 < k l, p P }

( -7)

V

{chainob (e0 , ..., en ; Ep ; Op ; k; mob
p )|0 < k l, p P }

( -8)

V

( -9)

V

{eki ak1 |0 < k l, A, ei = start(a)}

( -10)

V

{ekj ak |0 < k l, A, ej = end(a)}

( -11)

V

{ekj ak1 eki |0 < k l, A, ei = start(a), ej = end(a)}

( -12)

V

( -13)

V

{ak1 ak eki |0 < k l, A, ei = start(a)}

{eki ak ekj |0 < k l, A, ei = start(a), ej = end(a)}

{ak1 ak ekj |0 < k l, A, ej = end(a)}

( -1) ensures member state(s0 ) true member present
initial state. Similarly, ( -2) guarantees members goal state true
state(sl ). ( -3) ( -4) imply agenda(s0 ) agenda(sl ) empty. ( -5),
explained before, responsible imposing appropriate changes value SAT
variables, whenever proposition p added deleted event certain step
output plan. ( -6) ( -7) prevent invariants action deleted
open. ( -8) ( -13) responsible enforcing appropriate changes
agenda(sk1 ) agenda(sk ), agendas states immediately
576

fiITSAT: Efficient SAT-Based Temporal Planner

step k output plan. ( -8) ensures started step k
open sk1 . ( -9) indicates started ended step k,
open sk . ( -10) ensures ended step k, open sk . ( -11)
implies ended started step k, open sk1 . ( -12)
ensures member agenda(sk ) member agenda(sk1 ),
started step k. Similarly, ( -13) ensures member agenda(sk1 )
agenda(sk ), ended step k.
Theorem 5, know temporal planning problem P satisfiable,
exists positive number l, non-relaxed -step encoding P l steps
(i.e., l ) satisfiable. Accordingly, completeness relaxed -step encoding

proved showing l satisfiable l satisfiable.
Theorem 7 (completeness relaxed -step encoding). Let P = (I, G, A)

temporal planning problem formulae l l two -step encodings P explained

above. model l , l model plan(M ) = plan(M ).
Proof. See Appendix A.
Theorem 7 shows that, -step encoding, number required steps
solve temporal planning problem less (or equal to) required -step
encoding, provided fixed ordering used two encodings.
words, -step encoding compact -step encoding.
Theorem 8 (soundness relaxed -step encoding). Let P = (I, G, A)

temporal planning problem, {e1 , ..., en } set events P, l relaxed

-step encoding P. l model , plan(M ) causally valid -step plan
P.
Proof. See Appendix A.
4.4 Mutual Exclusion Relations Action Compression
mentioned earlier Section 3, performance SAT-based temporal planner
improved mutual exclusion analysis action compression. section,
show information obtained tasks utilized ITSAT. Let
P = (I, G, A) temporal planning problem, MU set mutually exclusive
pairs propositions P, COM set compression-safe actions P (see

Section 3). Let l encoding P, l , l , l . taking
advantage mutual exclusion relations, add extra formula mut
l , mut
=
l
l
V
k
k
{p q |(p, q) MU , 1 k l}. Theorem 1 shows, two mutually exclusive
propositions p q never true state achieved execution
valid temporal plan starting I. result, adding mut
encoding cannot
l
render planner incapable finding valid plans.
Let compression-safe action. showed Section 3.2, safe
assume causally valid plan, ending event occurs immediately
starting event. One way impose constraint add extra clauses
577

fiRankooh & Ghassem-Sani

encoding guarantee starting ending events always included
step. However, two events may conflicting effects, case l
l allow events present step. Therefore, information

regarding compression-safe actions added
relexed -step encoding, l .
V

done adding com
l , com
= {eki eki+1 |a COM, ei = start(a), 1
l
l


k l}. Note l , ei starting event action, ei+1 denotes ending
event.

5. Scheduling Phase
section, describe causally valid plan augmented temporal information
produce valid temporal plan. Let = he1 , ..., en causally valid plan produced
planner. scheduling done defining scheduling function Definition
9, assigns rational number event execution time. Suppose
given different names different occurrences action plan,
events e1 , ..., en unique. assume i, (i) < (i + 1),
thereby satisfy first condition Definition 9. However, lead plans
unnecessarily large makespans. Alternatively, obtaining plans improved quality,
impose relaxed set constraints function .
Definition 16 (relaxed scheduling functions). Let causally valid plan.
scheduling function relaxed scheduling function following properties:
(S-1) j ei located ej , ei swappable ej
(cf. Definition 12), require (i) < (j).
(S-2) j, ei starting event particular action a, ej pairing
event ei (cf. Definition 8), require (j) = (i) + dur(a).
Theorem 9. Let P = (I, G, A) temporal planning problem, = he1 , ..., en
causally valid plan P, : {1, ..., n} Q relaxed scheduling function .
exists valid temporal plan P.
Proof. See Appendix A.
Theorem 9 shows whenever relaxed scheduling function exists causally valid
plan P, valid temporal plan produced P. prove scheduling
method render ITSAT incomplete, need show P solvable,
planner able produce causally valid plan scheduling function
relaxed scheduling function . Let (, ) valid temporal plan
P. Every causally valid plan regarded causally valid -step plan
singleton steps. Therefore, Theorem 3, l model = plan(M ).

Theorem 5, satisfies l . Moreover, Theorem 7, l model
= plan(M ) = plan(M ). Therefore, encoding methods used
translating P SAT formula, resulting formula model translated
. hand, according Definition 9, satisfies constraints form
(S-1) (S-2), therefore, relaxed scheduling function . However, mentioned
578

fiITSAT: Efficient SAT-Based Temporal Planner

Section 4.2.4, may add certain clauses encoding ensure produced
causally valid plan always compressed (Definition 11). show solvable temporal plan, exists compressed causally valid plan scheduled
valid temporal plan relaxed scheduling function.
Theorem 10. Let P = (I, G, A) solvable temporal planning problem, COM
set every member either compressible towards start compressible towards end (Definition 13). exists valid temporal plan (, ) P
causally valid plan P, compressed respect COM,
relaxed scheduling function .
Proof. See Appendix A.
check existence function properties stated above, solve
instance Simple Temporal Problem (STP) (Dechter et al., 1991). STP associated
weighted graph named Simple Temporal Network (STN). construct STN
node xi corresponds event ei causally valid plan . Let arbitrary
small rational number. constraint form (i) < (j), add edge
weight xi xj . constraint form (j) = (i) + dur(a),
add edge weight -dur(a) xi xj , another edge weight dur(a)
xj xi . add reference node x0 constructed STN. x0 edge
weight 0 every node. solution STP found computing
length shortest path form x0 nodes (Dechter et al., 1991). Suppose
shortest paths exist length shortest x0 xi shown
distance(x0 , xi ). event ei , define (i) equal distance(x0 , xi ).
case, Theorem 9 guarantees resulting plan specifications valid
temporal plan.
see intuition behind explained method defining function , suppose constructed STN, edge weight xi xj .
means distance(x0 , xj ) distance(x0 , xi ) , implies distance(x0 , xi )
distance(x0 , xj ) . This, turn, implies distance(x0 , xi ) < distance(x0 , xj ),
(i) < (j). Similarly, easily shown exists edge
weight -dur(a) xi xj , another edge weight dur(a) xj xi ,
have: (j) = (i) + dur(a). Bellman-Ford algorithm (Cormen, Leiserson, Rivest,
& Stein, 2009) used find single source shortest paths weighted graph
polynomial time. Besides, number nodes produced STN equal
number events causally valid plan. Therefore, conclude that,
mentioned shortest paths exist, (i) computed polynomial time.
However, situations shortest paths exist. happens
corresponding STN negative cycle. situations, STP inconsistent
consequently, temporal constraints cannot satisfied time.
example case depicted Figure 10.
Figure 10, action adds propositions p g starting ending events,
respectively. needs proposition q precondition ending event. Action b requires
p upon starting adds q upon ending. Durations actions b, 5 10,
respectively. goal planning reaching fact g. problem, = , bs , , ae
579

fiRankooh & Ghassem-Sani

Figure 10. Negative Cycles

causally valid plan, = start(a), ae = end(a), bs = start(b), = end(b).
plan depicted Figure 10-(a). plan, execution action b must entirely
inside action (i.e., b started starting ended ending a).
However, impossible considering fact duration less
b. invalidity plan caused fact producing causally valid
plan, durations abstracted out. STN constructed plan Figure
10-(a) depicted Figure 10-(b). bs ae negative cycle total weight
5 2.
5.1 Negative Cycle Prevention
STN causally valid plan includes negative cycle, plan cannot transformed
valid temporal plan. cases, SAT solver forced find different
solution. done adding extra clause least one events
current negative cycle prevented occurring current step. However,
adding blocking clause, planner still produce new plans basically
equivalent previous plan. instance, consider example given Figure 10.
Suppose , bs , , ae members steps 1 4, respectively. Assume
output plan 5 steps. forbid exact occurrence negative cycle,
580

fiITSAT: Efficient SAT-Based Temporal Planner

new causally valid plan still produced shifting ae layer 5 maintaining
events current steps. new solution negative cycle
therefore cannot transformed valid temporal plan. fact, cause
invalidity plan changed. show exploiting simple structure
negative cycles, one prevent reoccurrence cycles effectively.
discussion given above, clear main reason
negative cycles encountered STN particular causally valid plan,
specific order events plan. fact, events negative cycle reoccur
order new causally valid plan, new plan include negative
cycle, too.
temporal planning problem P, P
regard set possible sequences
events language alphabet
= {e1 , ..., en }, n number
events P. set sequences events certain P
events appeared
particular order regarded another language . straightforward
show latter language fact regular language accepted
Finite State Machine (FSM). Figure 10-(c) shows Finite State Machine detects
sequences events , ae , bs , appear according order , bs , , ae i.
Note that, sake clarity, self-loop transitions Finite State Machine
shown Figure 10-(c).
P
Definition 17 (FSMs). AP
Finite State Machine 5-tuple (S , , , xP
0 , ),
finite set states,
finite set alphabet symbols, :

mapping defining transitions , x0 starting state, set
accepting states.
show adding certain formulae SAT encodings, one avoid
members given regular language
produced causally valid plans. Let
P
P temporal problem,P

= {e1 , ..., en } set events P. Let L
regular
. Assume L accepted P
Finite State Machine
P langaue

|T (xi , e) = xj , 6= j}
= (S , ,P
, ). xi , let Ei = {e
Eiin = {e
|T (xj , e) = xi , 6= j}. Assume two dummy events e0
en+1 , precondition, add effect, delete effect. define SAT
variable xk,i 1 k l, 0 n + 1, x . Assigning value true xk,i
means state x, operating sequence events steps 1
k 1 events step k indices less final plan. construct
formula
l conjunction formulae (-1) (-6) stated below:
(-1)

V

k,j
E {e
{eki xk,i
xt |1 k l, < j, (xs , ei ) = xt , ej Et
n+1 },



{ei+1 , ..., ej1 } (Et Et ) = }

(-2)

V

(-3)

V

k,j



{eki xk,i
xs |1 k l, < j, ei Es , ej Es Es {en+1 },


{ei+1 , ..., ej1 } (Es Es ) = }

k,i


{xk,0
xs |1 k l, 1 n, xs , ei Es Es ,


{e1 , ..., ei1 } (Es Es ) = }

581

fiRankooh & Ghassem-Sani

(-4)

V

{xk,n+1
xk+1,0
|1 k < l, xs }



(-5)

V

{xk,i
0 |1 k l, 1 n}

(-6)

V

{xk,i |x , 1 k l, 1 n + 1}

Adding
l encoding problem makes SAT solver somehow simulate
behavior , finding model represents causally valid plan. Assume
observing ei causes make transition xs xt . Moreover, let ej first event
ei (according fixed ordering e1 , ..., en ) may cause transition
xt . Formula (-1) guarantees ei member Stepk , state xs
time observing ei , state changed xt , next relevant event
xt (i.e., ej ) become aware transition. (-2) implies ei member
Stepk , state xs time observing ei , remain xs ,
next relevant event xs become aware current state . (-3) causes
information regarding state start step propagated first
relevant event step. (-4) propagates information regarding state
end step next step. (-5) ensures starting state
place final plan. means simulation started
anywhere plan produced. enables SAT solver detect
strings accepted , strings subsequences accepted
. Finally, (-6) guarantees never one accepting states.

Example 7. Let Finite State Machine depicted Figure 10-(c). Finite
State Machine detects sequences events , ae , bs , appear according
order , bs , , ae i. Assume four events: e1 = , e2 = ae , e3 = bs ,
e4 = . assume two dummy events e0 e5 . sake simplicity,
suppose problem events e0 e5 , encoding
two steps. Consider boolean assignment , (e11 ) = (e13 ) = (e14 ) =
(e22 ) = true, (e12 ) = f alse. words, choosing , bs ,
first step, ae second step. fact, plan(M ) = , bs , , ae i.
example, E0in = {e2 }, e2 = ae event causes transition
state s0 . Similarly, have: E0out = {e1 }, E1in = {e1 }, E1out = {e2 , e3 }, E2in = {e3 },
E2out = {e2 , e4 }, E3in = {e4 }, E3out = {e2 }, E4in = {e2 }, E4out = . show
use formulae (-1) (-6) stated encode , cannot model
produced SAT formula. show contradiction. Assume model
produced SAT formula.
s0 starting state . Hence, according (-5), (s01,1 ) = true,
means state s0 , prior checking whether e1 present first
step final plan.
1
s1,2
According (-1), e11 s1,1
1 . Since (e1 ) = true
0
1,2
(s1,1
0 ) = true, must (s1 ) = true. words, verifies e1
present first step final plan, causes current state

582

fiITSAT: Efficient SAT-Based Temporal Planner

changed s0 s1 . (s1,2
1 ) = true implies state s1 , prior checking
whether e2 present first step final plan.
1,3
1
According (-2), e12 s1,2
1 s1 . Since (e2 ) = f alse
1,3
1,2
(s1 ) = true, must (s1 ) = true. words, verifies
e2 present first step final plan, causes state
remain s1 . (s1,3
1 ) = true implies state s1 , prior checking whether e3
present first step final plan.
1
According (-1), e13 s1,3
s1,4
1
2 . Since (e3 ) = true
1,4
1,3
(s1 ) = true, must (s2 ) = true. words, verifies e3
present first step final plan, causes state changed
s1 s2 . (s1,4
2 ) = true implies state s2 , prior checking whether
e4 present first step final plan.
1
s1,5
According (-1), e14 s1,4
3 . Since (e4 ) = true
2
1,5
(s1,4
2 ) = true, must (s3 ) = true. words, finds e4
present first step final plan, causes state changed
s2 s3 . (s1,5
3 ) = true implies state s3 , visiting events
first step final plan.
1,5
2,0
According (-4), s1,5
3 s3 . Since (s3 ) = true, must
(s2,0
3 ) = true, implies state s3 , prior visiting event
second step final plan.
2,0
2,2
According (-3), s2,0
3 s3 . Since (s3 ) = true, must
(s2,2
3 ) = true, implies state s3 , prior checking whether e2
present second step final plan.
2
s2,5
According (-1), e22 s2,2
4 . Since (e2 ) = true
3
2,5
(s2,2
3 ) = true, must (s4 ) = true. words, verifies
e2 present second step final plan, causes state
changed s3 s4 . (s2,5
4 ) = true implies state s4 , visiting
events first two steps final plan. hand, s4 accepting
state . Hence, according (-6), (s2,5
4 ) = f alse. clearly
contradiction. Therefore, conclude cannot model produced
SAT formula.

prove adding
l encoding given problem, prevents planner
producing causally valid plans subsequence events equivalent
string accepted . means negative cycle translated
FSM, reoccurrence negative cycle avoided translating FSM
SAT formula, adding formula encoding problem.
P
Theorem 11. Let P = (I, G, A) temporal planning problem,
= {e1 , ..., en }




set events P, l three formulae l , l , l (defined Section
P 4),
non-empty causally valid plan P obtained solving l . Let = (S , , , x0 , )
583

fiRankooh & Ghassem-Sani

FSM accepts subsequence = he1 , ..., em ,
l encoding
presented (-1) (-6). exist model l
l
= plan(M ).
Proof. See Appendix A.
need show adding
l encoding render planner incapable producing plans contain subsequence accepted .
P
Theorem 12. Let P = (I, G, A) temporal planning problem,
= {e1 , ..., en }

set events P, l three formulae l , l , l (defined
Section 4). Let model satisfies l , = he1 , ..., em = plan(M ). Let
P
= (S , , , x0 , ) FSM accept subsequence ,
l


encoding composed (-1) (-6). exists model l l
= plan(M ).
Proof. See Appendix A.
explain sequence events introduce negative cycle STN
causally valid plan used prevent similar negative cycles reoccurringP
future
plans produced problem hand. Let P temporal planning problem,

set events P, = e1 , ..., en causally valid plan P. Assume STN
representing scheduling function negative cycle N nodes xi1 , ..., xim . Note
xik node corresponding event eik . Without loss generality, assume
i1 < ... < im , i.e., events negative cycle ordered order
started finished
. Let Oik set temporal actions P
{e|action(e) Oik } {eik }.
reaching eik sequence ei1 , ..., eim , P
ik =
Consider regular language LN alphabet
defined LN = ei1 i2 ei2 ...im eim ,
ik denotes string symbols ik . fact, strings LN , events
already present current negative cycle inserted sequence
way temporal constraints among ei1 , ..., eim remain unchanged. see
exclude events open actions ik , consider two hypothetical events eij eij
respectively starting event ending event action a. Therefore,
temporal constraint scheduling function form (ij ) (ij ) = dur(a).
Here, insert another copy ending event two events,
ended execution eij and, result, eij longer pairing event
eij , mentioned constraint longer exist.
Theorem 13. Let N = xi1 , ..., xim negative cycle STN corresponding
causally valid plan = e1 , ..., en temporal problem P, xik node corresponding event eik . Let another causally valid plan P. subsequence
member LN (defined above), corresponding STN N
negative cycle.
Proof. See Appendix A.
584

fiITSAT: Efficient SAT-Based Temporal Planner

Consrtucting FSM accepts LN straightforward. Let FSM. Theorem
13 shows added encoding input problem, ITSAT still
capable finding valid temporal plan, provided plan exists.

6. Empirical Results
section, show preprocessing, encoding, scheduling methods contribute overall performance ITSAT. Since contribution preprocessing
part investigated encoding fixed, first analyze performance
three encodings explained Section 4. compare performance ITSAT
several state-of-the-art temporal planners non-numerical temporal planning problems
previous International Planning Competitions.
Section 4, theoretically showed novel relaxed -step encoding least
compact temporal versions -step -step encodings fixed ordering (i.e.,
number steps needed relaxed -step encoding solve given problem less
equal temporal versions -step -step encodings). Here,
empirically show relaxed -step often needs significantly smaller number steps,
compared -step -step encodings. show mentioned compactness
causes relaxed -step significantly outperform -step -step encodings
benchmark problems terms memory speed.
Section 3, explained two preprocessing methods, namely mutual exclusion analysis
action compression. section show methods contribute
overall performance ITSAT benchmark problems. purpose, compare
four versions ITSAT: 1) ITSAT without preprocessing, 2) ITSAT mutual exclusion
analysis, 3) ITSAT action compression, 4) ITSAT mutual exclusion
analysis action compression. experimental results show methods
separately enhance performance ITSAT.
Section 5, discussed adding certain blocking clauses encoding
problem, one prevent negative cycles reoccurring STNs produced
causally valid plans. introduced elaborate method preventing negative cycles, adding extra clauses based certain Finite State Machines.
Here, empirically show FSM-based method crucial efficiency ITSAT
problems required concurrency.
Finally, compare performance ITSAT state-of-the-art temporal planners, namely OPTIC (Coles et al., 2010), LPG-td (Gerevini et al., 2006),
TFD (Eyerich et al., 2009). OPTIC TFD different degrees temporal expressivity, whereas LPG-td temporally expressive (i.e., capable solving
problems required concurrency). show ITSAT significantly outperforms
OPTIC TFD, competitive LPG-td many domains.
6.1 Implementation Details
order parse planning problems domain, validating output plans
produced ITSAT, used VAL, plan validation tool developed
organizers IPC 2011. schematic operators given domain instantiated
objects input problem produce possible valid ground temporal actions. ITSAT
585

fiRankooh & Ghassem-Sani

performs polynomial reachability analysis recognize actions prepositions
relevant given problem. purpose, goal conditions initially
assumed relevant propositions. action produces relevant proposition upon
starting ending considered relevant action. ITSAT adds preconditions
starting ending events relevant actions current set relevant propositions.
invariants relevant actions added set, too. Updating sets relevant
propositions actions repeated changes occur sets.
update set relevant propositions omitting relevant propositions
present initial state given problem. omitted propositions
deleted relevant action. propositions omitted
at-start, at-end, invariants relevant actions. Mutual exclusion analysis action
compression methods described Section 3, performed sets relevant
actions propositions.
mentioned Section 4, encoding methods assume exists
predefined fixed ordering events given problem. current implementation
ITSAT, ordering events produced constructing ground actions,
taken presumed fixed ordering events. starting event action
placed immediately corresponding ending event mentioned ordering.
elaborate heuristic methods producing ordering may result compact
encoding (Rintanen et al., 2006). Investigating methods beyond scope
paper left future research.
current version ITSAT, use P recosat (Biere, 2009), free off-theshelf system, SAT solver. examined two SAT solvers, namely
inisat (Een & Biere, 2005) Lingeling (Biere, 2013) satisfying formulae.
However, precosat best overall performance among three SAT solvers; though
Lingeling better performance terms memory usage.
Since P recosat accepts formulae Conjunctive Normal Form (CNF), formulae described throughout paper translated equivalent CNF formulae. performed simply using logical equivalence relations
(1 2 1 2 ) ((1 2 ) 1 2 ).
problem, start formula one step. set time limit
three minutes precosat find model formula. case failure,
add three steps formula repeat process either model
found predetermined maximum time 30 minutes reached. case success
finding model, causally valid plan extracted model. plan
given scheduling process find valid temporal plan. scheduling function
fails, appropriate FSM generated encoded problem formula (see Section
5) without increasing number steps. new formula given P recosat
find new model. Although parallel solving formulae different number steps
shown effective nave sequential approach (Rintanen et al., 2006;
Streeter & Smith, 2007), empirical results show even simple sequential method
sufficient outperform current temporal planners many planning domains. leave
investigation regarding effect using parallelism future research.
experiments explained section conducted 3.1GHz corei5
CPU 4GB main memory. benchmark problems, used problem
586

fiITSAT: Efficient SAT-Based Temporal Planner

sets previous IPCs. problems different planning domains including
zenotravel, rovers, depots IPC 2004, airport IPC 2006, pegsol, crewplanning,
openstacks, elevators, sokoban, parcprinter IPC 2011, driverlog, f loortile,
matchcellar, mapanalyser, parking, rtam, satellite, storage, turnandopen, tms
IPC 2014. Note domains used different IPCs.
domains, chosen problem set recent competition domains.
problem set IPC 2008 present experiments.
Among domains used previous IPCs, matchcellar, turnandopen, tms
include problems required concurrency. problem sets
temporally expressive planners capable producing valid plans. order achieve
better assessment ITSAT problems required concurrency, used two
extra domains driverlogshift matchlift (Halsey, 2004). performed
experiments time-window variants satellite airport domains. domains,
used IPC 2004 required concurrency, referred throughout
section satellite-tw airport-tw, respectively. mentioned domains
required concurrency explained details Section 6.4.
6.2 Impact Different Encoding Methods
evaluate -step, -step, relaxed -step encodings produced three different versions ITSAT, namely, ITSAT-, ITSAT-, ITSAT- , respectively.
versions, formula mut , encodes mutex relations, added
encoding. None versions take advantage action compression. negative cycle
prevention method described Section 5 used three versions ITSAT.
Table 2 shows comparison domain among versions regard number
solved problems.
seen Table 2, ITSAT- best performance among three
versions. fact, ITSAT- able solve 65 problems ITSAT-,
103 problems ITSAT-. Furthermore, almost problems solved ITSAT-
ITSAT- solved ITSAT- . means relaxed -step encoding
significantly efficient temporal versions classical -step -step
encodings.
Table 3, shows detailed comparison among mentioned encodings. different columns Table 3 represent following items: name domain, problem
number, used encoding method, number steps encoding, result
P recosat terms satisfiability unsatisfiability formula, number clauses
variables divided 1000, amount time taken P recosat determine
result, amount memory needed solving formula. problem
encoding method, results presented two cases: unsatisfiable formula
highest number steps, satisfiable formula lowest number steps. Note
produce results, increased number steps one formula
unsatisfiable. Symbol used time column cases P recosat
failed find model formula 1800 seconds. results presented
domains least one problems solved least two
planners. Accordingly, openstacks, elevators, matchcellar, rtam omitted
587

fiRankooh & Ghassem-Sani

domain
zenotravel
rovers
depots
satellite-tw
airport-tw
airport
pegsol
crewplanning
openstacks
elevators
sokoban
parcprinter
driverlog
floortile
mapanalyser
matchcellar
parking
rtam
satellite
storage
turnandopen
tms
driverlogshift
matchlift
total

problems
20
20
22
36
50
50
20
20
20
20
20
20
20
20
20
20
20
20
20
20
20
20
10
14
542

ITSAT-
13
18
13
3
19
20
20
8
0
0
2
15
0
10
14
0
10
0
0
0
1
18
10
14
208

solved
ITSAT-
16
18
17
3
21
21
20
8
0
0
3
16
2
16
19
0
10
0
3
9
2
18
10
14
246

ITSAT-
16
20
19
3
21
38
20
20
9
0
2
17
3
20
19
18
10
0
3
9
2
18
10
14
311

Table 2: Overall Comparison Different Encoding Methods
Table 3. Moreover, satellite storage, results presented
-step -step encodings.
domain, Table 3 presents results hardest problem (i.e.,
problem greatest number propositions). experiments, observed
pattern similar chosen problems problems domain. Note
results presented Table 3 finding first causally valid plan. Therefore,
results include information regarding FSM encoding method described
Section 5. explain impact FSM-based negative cycle prevention later
section.

588

fiITSAT: Efficient SAT-Based Temporal Planner

domain

zenotravel

rovers

depots

satellite-tw

airport-tw

airport

prob encoding steps

10

4

13

3

11

5

4

26

25

18

2

27

26

3

10

6

17

3

11

7


4

12

12

3

5

13

13


6

72

33

19

7

73

34


8

70

31
20

5

71

32


6
Continued next page

result
F
F
F



F
F
F



F
F
F



F
F
F



F
F
F



F
F
F




589

C
1000

V
1000

474
133
69
521
167
92
5467
4444
375
5673
4618
511
7950
3256
1008
8747
3802
1336
33
26
7
36
28
8
5415
1811
243
5573
1817
270
9261
3189
430
9392
3290
506

136
33
23
150
42
32
560
412
15
581
428
24
1259
455
236
1387
534
326
9
7
3
10
8
3
1516
412
44
1541
439
49
1381
361
37
1401
373
44

time
(s)
25
0.4
0.38
33
0.54
0.56


0.14
89
47
0.36
6.6
2.2
1.39
8.9
3
2.1
1.2
1.4
0.1
0.7
0.7
0.1
24
3.7
0.43
19
4.1
0.5
27
3.5
0.16
21
4.3
0.62

mem
(MB)
131
18
10
146
20
17
413
244
12
353
220
12
598
284
129
1001
301
141
3
2
1
4
4
1
912
271
22
900
283
28
837
257
31
844
263
36

fiRankooh & Ghassem-Sani

domain

prob encoding steps

12

12

pegsol
20

5

13

13


6

69

69

crewplanning 8

4

70

70

5

19

13

sokoban
4

6

20

14

7

42

31

parcprinter
20

8

43

32


9

7

driverlog
2

5

8

6

22

11

floortile
10

6

23

12

7

17

9

mapanalyser 15

2
Continued next page

result
F
F
F



F
F
F



F
F
F



F
F
F



F
F


F
F
F



F
F
F

590

C
1000

V
1000

34
25
10
37
27
12
112
102
3
114
104
3
542
274
122
571
295
142
2325
1436
345
2380
1482
385
2634
2803
5248
3291
201
74
31
211
80
36
187009
101893
29988

9
6
3
10
7
4
34
29
1
35
30
1
143
64
37
150
69
43
382
198
51
391
205
58
258
184
294
221
21
11
6
22
12
7
1005
534
122

time
(s)


0.05
22.4
7.3
0.3


0
30
15
0

12
3.9
74
40
1.5

30
1.1
93
25
0.7
6.2
14
23
13.9
55
7
0.14
20
0.62
0.16
18
10
5.4

mem
(MB)
28
26
1
14
11
3
40
49
1
44
46
1
163
78
23
190
125
20
319
119
24
289
128
26
165
70
280
131
48
16
5
49
13
5
1196
519
75

fiITSAT: Efficient SAT-Based Temporal Planner

time
domain
prob encoding steps result
(s)

18

197433 1064
26

10

112123 593
11


3

40062
181
6.7

4
F
1769
150
2.5

2
F
605
75
0.5

parking
11

1
F
238
38
0.4

5

1868
187
4.2

3

911
112
2.5


2

470
75
2

11
F
870
221


satellite
3

5
F
294
91


12

950
244
157

6

352
110
4.9

11
F
1523
125


storage
9

8
F
633
84
48

12

1662
136
5.9


9

710
94
9.4

42
F
2416
203


22
F
944
106
33

turnandopen 1

10
F
371
53
1.1

43

2474
207
176

23

987
111
37

11

406
58
1.3

9
F
491
51
2.3

7
F
257
39
0.5

tms
18

3
F
91
18
0.1

10

546
56
1.4

8

284
43
0.5


4

115
23
0.3

18
F
373
65
1.5

15
F
235
37
0

driverlogshift 11

9
F
54
17
0

19

411
69
0.6

16

260
39
0.3


10

57
20
0.3
Table 3: Detailed Comparison Encoding Methods
C
1000

591

V
1000

mem
(MB)
1177
538
128
177
70
34
297
87
72
431
91
440
95
198
69
149
72
454
112
41
465
106
42
65
42
14
67
42
17
35
19
7
39
21
9

fiRankooh & Ghassem-Sani

Figure 11. Speed Comparison ITSAT- ITSAT-

Section 4, theoretically showed order solve given planning problem,
relaxed -step encoding requires fewer steps temporal versions classical
-step -step encodings ordering fixed. Table 3 shows ITSAT-
often needs considerably smaller number steps. phenomenon prominent
airport, crewplanning, mapanalyser. Moreover, openstacks matchcellar,
neither ITSAT- ITSAT- able solve problem due large number
steps required. suggests correlation performance
planner, compactness encoding. Generally speaking, relatively
high number steps needed -step encoding solve problem, deduce
strong causal connection actions produced plan.
hand, -step encoding devised take advantage causal connections.
Therefore, -step encoding expected advantage -step encoding
domains. phenomenon visible airport, crewplanning, openstacks,
matchcellar domains, numbers steps required -step encoding
domains exceptionally high. Table 3 shows relaxed -step encoding results
significant improvement planner terms memory usage.
592

fiITSAT: Efficient SAT-Based Temporal Planner

Figure 12. Speed Comparison ITSAT- ITSAT-

compared speed ITSAT- ITSAT- ITSAT-
solving benchmark problems. results depicted Figure 11 Figure 12.
seen, ITSAT- outperformed ITSAT- ITSAT- almost
problems.
6.3 Impact Mutual Exclusion Analysis Action Compression
Section 3, explained mutual exclusion analysis action compression performed preprocessing components ITSAT. Here, empirically show components quite effective enhancing performance planner. showed

before, encoding results best performance ITSAT. fixed
formula base comparison, produced three formulae investigate

impact preprocessing method. three formulae mut (the base encod
ing plus mutual exclusion information), com (the base encoding plus action

compression information), mut com (the base encoding plus mutual exclusion action compression information). Table 4 shows number problems solved
mentioned versions ITSAT.
593

fiRankooh & Ghassem-Sani

domain
zenotravel
rovers
depots
satellite-tw
airport-tw
airport
pegsol
crewplanning
openstacks
elevators
sokoban
parcprinter
driverlog
floortile
mapanalyser
matchcellar
parking
rtam
satellite
storage
turnandpen
tms
driverlogshift
matchlift
total

problems
20
20
22
36
50
50
20
20
20
20
20
20
20
20
20
20
20
20
20
20
20
20
10
14
542




13
20
11
3
21
38
20
20
1
0
1
17
0
3
14
0
3
0
0
0
2
0
10
14
211



mut
16
20
19
3
21
38
20
20
9
0
2
17
3
20
19
18
10
0
3
9
2
18
10
14
311



com
14
20
14
3
21
38
20
20
5
0
3
19
1
20
19
20
7
0
0
0
3
18
10
14
289



mut com
18
20
20
3
21
39
20
20
13
0
8
20
4
20
20
20
17
0
16
20
9
18
10
14
370

Table 4: Impact Mutual Exclusion Analysis Action Compression
seen Table 4, preprocessing methods result significant improvement terms overall coverage. fact, version ITSAT uses methods
solves 159 problems base planner. Besides, version uses methods even considerably outperforms two versions use one preprocessing
method. suggest preprocessing components necessary producing
best performance ITSAT.
investigate effectiveness action compression method domains
ITSAT compresses considerably actions CRIKEY, performed another
experiment. compressed actions ITSAT considers compression safe
CRIKEY3 not. new version ITSAT, used mutual exclusion
information. version ITSAT solves six problems version
594

fiITSAT: Efficient SAT-Based Temporal Planner

mutual exclusion information used: six problems, four problems
zenotravel, one airport, one mapanalyser. results change
much domains. Note three mentioned domains ITSAT
compresses considerably actions CRIKEY.
6.4 Impact FSM-Based Negative Cycle Detection
mentioned earlier, among domains used evaluate ITSAT, matchcellar, turnandopen, tms, driverlogshift, matchlift, time-window versions airport satellite
problems required concurrency. fact, domains, may impossible
schedule causally valid plan produced solving SAT formula, valid temporal
plan. Here, briefly explain problems domains may require concurrency, may introduce negative cycles STN associated
causally valid plan.
matchcellar matchlift, exists action lighting match. action
produces light certain amount time. objective mend fuses.
actions mending fuse executed light. result, actions
lighting match mending fuse must executed concurrent. However, causally
valid plan, since planner consider durations actions, may assume
match remain lit fuses mended. discussed Section 5,
introduce negative cycle STN produced causally valid plan.
tms, objective produce certain number ceramic structures.
structures need several preparations done furnace producing
heat. clear domain similar matchcellar matchlift,
requires concurrency similar way.
simplified version driverlogshift introduced Section 2. difference
simplified version one used section evaluate planners,
here, drivers walk to, board, disembark trucks. Furthermore,
REST WORK actions performed drivers rather trucks. domain,
working shifts drivers analogous action lighting match
matchcellar domain.
turnandopen, exists robot needs move number rooms.
doors pair adjacent rooms. doors, closed
initial state, opened robot. robot open door
turning doorknob. domain, actions turning doorknob opening
door must executed concurrently. However, duration action turning
knob 3, whereas opening door 2. enables ITSAT schedule every
causally valid plan valid temporal plan. Therefore, preventing negative cycles
necessary domain.
time-window versions airport satellite, specific time
goals must obtained. deadline introduced problem using specific
frame action duration equal time deadline. actions
executed frame action executed. words, actions
must concurrent frame action. However, causally valid plan, since
planner consider durations actions, may assume frame action
595

fiRankooh & Ghassem-Sani

domain
problem
satellite-tw
3
airport-tw
21
matchcellar
20
tms
18
driverlogshift
10
matchlift
14

restarts
121
1
34
3
43
9

C
1000


12
552
44
121
68
72

FSM
1450
5
408
12
930
180

V
1000


3
65
22
23
26
15

FSM
318
2
203
10
280
112

memory (MB)

FSM
1
382
41
1
9
77
16
2
13
107
31
98

Table 5: Collective Size SAT Encodings FSMs
arbitrarily long, thereby neglect meet deadline achieving goals.
introduce negative cycles STNs produced causally valid plans.
explained Section 5, STN causally valid plan includes negative
cycle, must force SAT solver find different solution. done simply
adding extra blocking clause current SAT formula prevent least one
events negative cycle reoccurring current step. Alternatively,
introduced elaborate method thing, adding encoding
certain FSMs encoding. method, STN causally valid plan
k steps includes negative cycle, FSM detects negative cycle encoded
SAT formula, solver restarted. order decrease number
restarts, whenever sequence events corresponding negative cycle found, ITSAT
tries find potential negative cycles replacing actions current sequence
actions problem checking STN resulting sequence negative
cycles.
Table 5 shows collective size SAT encodings FSMs required solving
problems domains. base encoding, used relaxed
-step encoding mutual exclusion analysis action compression.
domain, results shown Table 5 hardest problem solved ITSAT.
turnandopen domain excluded Table 5, negative cycle encountered
solving problems domain. different columns Table 5 represent
following items: name domain, problem number, number clauses
variables divided 1000, amount memory needed produce formula.
results number causes, number variables, used memory presented
separated columns base encoding encoding FSMs.
seen Table 5, negative cycle prevention method helps ITSAT solve
considerable number problems required concurrency. Nevertheless, SAT encoding required FSMs significantly larger base encoding domains
number restarts relatively high. hand, number
restarts increase, speed ITSAT declines. restart, SAT
solver must verify satisfiability formula, scratch. fact, numerous
restarts main reason poor performance ITSAT time-window version
satellite.
596

fiITSAT: Efficient SAT-Based Temporal Planner

6.5 ITSAT Versus State-of-the-art Temporal Planners
compare ITSAT three efficient temporal planners, namely, OPTIC (Benton,
Coles, & Coles, 2012), TFD (Eyerich et al., 2009), LPG-td (Gerevini et al., 2006).
similarities approach used ITSAT SCP2 (Lu
et al., 2013), included results planner experimental results.
OPTIC newest version POPF (Coles et al., 2010). heuristic state-space
temporal planner based so-called temporally-lifted progression planning (Cushing
et al., 2007). Using approach planning enables OPTIC solve problems
required concurrency. Besides, OPTIC handles self-overlapping actions, makes
expressive ITSAT. Although handling self-overlapping actions hardly necessary
solving non-numerical temporal planning problems (Fox & Long, 2007), among
current benchmark domains, zenotravel, rovers, airport permit actions due
modeling errors. fair comparison ITSAT OPTIC, used
corrected versions three domains1 evaluations. guiding search, OPTIC
benefits heuristic function based relaxed planning graph (Hoffmann
& Nebel, 2001).
TFD another heuristic state-space temporal planner. TFD based so-called
decision epoch planning (Cushing et al., 2007). planners use approach
temporally expressive planners based temporally lifted progression planning. words, theory, temporal planning problems defined
PDDL2.1 solved ITSAT OPTIC TFD. However, current benchmark problems potentially solved using decision epoch planning.
guiding search, TFD benefits temporal version so-called Context-enhanced
Additive Heuristic (Helmert & Geffner, 2008).
LPG-td fast temporal planner, temporally expressive. fact,
LPG-td first generates sequential plan given problem, tries reschedule
plan produce one improved quality. renders LPG-td incapable
solving problem matchcellar, turnandopen, tms, driverlogshift, matchlift. Similar
OPTIC, LPG-td benefits heuristic based relaxed planning graph. However,
instead searching state space problem, LPG-td performs search making
local improvements structure similar partial plans, called Linear
Action Graph. Two different configurations LPG-td used based whether
prefer speed planner quality produced plans. Here, present
results quality configuration LPG-td, produced better results speed
configuration experiments.
SCP2 (Lu et al., 2013), SAT-based temporal planner uses discrete representation time. planner assigns explicit discrete time labels step encoding.
approach, step exactly one time unit ahead step + 1. result,
action duration starts step i, forced end step + d. means
number layers required producing plan greater equal makespan
. SPC2 starts formula one step, increases number steps
one, every time formula unsatisfiable. enables SPC2 find optimal plan
1. corrected version mentioned domains downloaded official website POPF
planner.

597

fiRankooh & Ghassem-Sani

number given problems. obtain better performance, SCP2 uses -step semantic
allow causal relations actions time point.
compared ITSAT planners based number problems
solve domain total score given planner using
scoring strategy recent IPCs; is, planner cannot solve problem, get
score 0 problem; Otherwise, score equal makespan best
produced plan divided makespan plan found planner. results
presented Table 6.
seen Table 6, ITSAT significantly outperforms OPTIC, TFD, SCP2.
fact, ITSAT solves 162 problems OPTIC, 145 problems TFD,
282 problems SCP2. ITSAT solves 64 problems LPG-td. However,
mainly LPG-td incapable solving problems required concurrency.
exclude satellite-tw, airport-tw, matchcellar, turnandopen, tms, driverlogshift,
matchlift domains LPG-td cannot solve problem, ITSAT solves
31 problems less LPG-td. shows ITSAT quite competitive
LPG-td even solving problems without required concurrency.
shown Table 6, OPTIC solves zero problems parcprinter, driverlog, floortile,
mapanalyser, matchcellar, rtam, storage, tms. domains, main reason
poor performance OPTIC runs memory, early search. TFD
solves zero problems satellite-tw, airport-tw, parcprinter, driverlog, floortile, rtam, storage,
tms. Except parcprinter, TFD runs memory, domains
TFD performs poorly unable find plan within 1800 seconds.
mentioned before, LPG-td solves zero problems domains required concurrency.
performance SCP2 rather poor many benchmark domains. reason
poor performance SCP2 that, many benchmark problems, makespan
optimal plan relatively large. result, problems, SCP2 unable
check satisfiability formulae numbers steps less makespan
optimal plan, within 1800 seconds time limit.
compare quality plans produced ITSAT competing
planners, consider Table 7. numbers presented Table 7 average makespan
ratio plans mutually solved corresponding planner ITSAT corresponding
domain. Ratios less one indicate better average quality solutions produced
ITSAT comparison competing planners. cases neither ITSAT
competing planner able solve problem domain, corresponding
cell Table 7 remained blank.
performed experiments based number two planners portfolios
different pairs planners. portfolios enabled us combine advantages
two planners. this, 30 minutes time limit divided equally pair
planners. results running portfolios presented Table 8. results
show best configuration obtained combining ITSAT LPG-td.
resulting planner capable solving 423 542 benchmark problems. Moreover,
planners produced best results combined ITSAT.

598

fiITSAT: Efficient SAT-Based Temporal Planner

solved

domain

N

zenotravel

20

18

rovers

20

depots

ITSAT

OPTIC

SCP2

IPC

score

ITSAT

OPTIC

TFD

LPG-td

SCP2

TFD

LPG-td

12

12

20

1

11.41

10.56

11.32

17.68

1

20

20

20

20

4

18.25

18.35

18.56

16.88

4

22

20

7

5

21

6

9.52

4.21

3.04

19.43

6

satellite-tw

36

3

4

0

0

0

3

4

0

0

0

airport-tw

50

21

7

0

0

0

21

7

0

0

0

airport

50

39

24

20

43

0

35.2

23.35

18.11

39.68

0

pegsol

20

20

19

18

20

20

19.36

18.02

17.24

18.98

20

crewplanning

20

20

20

14

9

0

18.37

20

11.94

7.82

0

openstacks

20

13

20

20

20

0

7.26

17.01

19.83

15.23

0

elevators

20

0

1

3

9

0

0

1

3

7.44

0

sokoban

20

8

2

3

5

1

7.64

1.72

3

3.26

1

parcprinter

20

20

0

0

7

0

20

0

0

5.72

0

driverlog

20

4

0

0

14

0

3.89

0

0

13.38

0

floortile

20

20

0

0

20

10

17.05

0

0

16.51

10

mapanalyser

20

20

0

19

20

0

18.48

0

15.62

14.81

0

matchcellar

20

20

20

20

0

0

20

20

16

0

0

parking

20

17

16

20

20

6

5.05

13.98

18.72

19.02

6

rtam

20

0

0

0

20

0

0

0

0

20

0

satellite

20

16

4

13

20

0

2.61

3.55

7.05

20

0

storage

20

20

0

0

18

20

18.77

0

0

1.45

20

turnandopen

20

9

9

18

0

1

9

6.52

13.34

0

1

tms

20

18

0

0

0

0

18

0

0

0

0

driverlogshift

10

10

10

6

0

9

8.01

9.48

5.03

0

9

matchlift

14

14

13

14

0

13

14

13

14

0

13

total

542 370

208

225

306

88

305.87 191.75 195.8

Table 6: ITSAT Versus State-of-the-art Temporal Planners

599

256.29 88

fiRankooh & Ghassem-Sani

domain
zenotravel
rovers
depots
satellite-tw
airport-tw
airport
pegsol
crewplanning
openstacks
elevators
sokoban
parcprinter
driverlog
floortile
mapanalyser
matchcellar
parking
rtam
satellite
storage
turnandopen
tms
driverlogshift
matchlift

OPTIC

TFD

LPG-td

SCP2

1.47
0.99
1.24
1
1
1.06
0.98
1.11
1.34

0.86




1
2.94

6.72

0.72

1.14
1

1.50
1.03
1.41


0.95
0.98
0.89
1.90

1.18



0.86
0.80
2.98

4.45

0.48

0.98
1

1.41
0.89
2.02


0.91
0.96
0.88
1.31

0.69
0.81
1.03
0.97
0.79

3.01

7.35
0.11





1
1.27
2.11



1.02



1


1.05


3.15


1.05
1

1.19
1

Table 7: Average Makespan Ratio

ITSAT
OPTIC
TFD
LPG-td
SCP2

ITSAT

375
385
423
348

OPTIC
375

262
350
237

TFD
385
262

360
256

Table 8: 2-planners Portfolio

600

LPG-td
423
350
360
302

SCP2
348
237
256
302


fiITSAT: Efficient SAT-Based Temporal Planner

Figure 13. Speed Comparison ITSAT OPTIC

Although ITSAT quite competitive state-of-the-art temporal planners,
empirical results reveal drawbacks planner. compared speed
ITSAT OPTIC, TFD, LPG-td, SCP2 benchmark problems.
results presented Figure 13, Figure 14, Figure 15, Figure 16, respectively.
figures, results required concurrency domains separated
domains using different symbols scatterplots: star symbol
represents problems required concurrency, diamond symbol represents
problems. seen, ITSAT slower OPTIC, TFD, LPG-td
number benchmark problems. major cause drawback ITSAT,
SAT solver spends much time refuting several formulae finally find
first satisfiable formula. shown case classical planning, speed
SAT-based planners significantly improved checking satisfiability several
formulae different number steps parallel. discuss detail Section
7 future research.
Another observation that, ITSAT performs rather slowly solving number
problems required concurrency quickly solved OPTIC TFD.
mainly due restarting SAT solver whenever negative cycles encountered.
601

fiRankooh & Ghassem-Sani

Figure 14. Speed Comparison ITSAT TFD

explained earlier, STN causally valid plan k steps includes negative
cycle, FSM detecting negative cycle encoded SAT formula,
solver try satisfy new formula k steps, scratch. domains
negative cycles abundant, performance ITSAT significantly affected
numerous restarts SAT solver.
performance ITSAT particularly poor three domains, namely elevators,
driverlog, rtam. domains, number ground actions higher
domains. linear increase number ground actions may cause
exponential growth size search space problem. tackle problem,
state-space based planners take advantage heuristic functions devised specially
pruning search space planning problems. shown using SAT
solvers tailored solving planning problems result significant improvement
performance SAT-based classical planning (Rintanen, 2012). think employing
idea improve speed ITSAT mentioned domains.
Another drawback ITSAT poor quality produced plans benchmark
domains. notably, although ITSAT solves problems depots, openstacks,
parking, satellite, quality plans rather low domains, according
602

fiITSAT: Efficient SAT-Based Temporal Planner

Figure 15. Speed Comparison ITSAT LPG-td

Table 7. mainly due fact ITSAT abstracts duration actions,
thus, SAT solver lacks competency evaluating quality plans
produced. Nevertheless, quality plans produced ITSAT generally
comparable planners benchmark domains. Section 7, explain
idea improving quality plans produced ITSAT.

7. Conclusions Future Research
paper, described ITSAT, temporally expressive SAT-based planner. ITSAT
based approach takes advantage parallel encodings. approach, first,
durations actions given problem abstracted out. abstract problem
encoded SAT formula using -step -step semantics causally valid plans.
generating causally valid plan, ITSAT performs scheduling process.
process, ITSAT tries satisfy temporal constraints imposed considering
durations actions. done solving Simple Temporal Problem (STP).
cases inconsistent STP, cause, negative cycle corresponding
Simple Temporal Network (STN), detected. ITSAT adds certain clauses SAT
formula hand prevent reoccurrence negative cycles. process
603

fiRankooh & Ghassem-Sani

Figure 16. Speed Comparison ITSAT SCP2

repeated temporally valid plan produced, predefined time limit
reached.
main contributions paper summarized follows:
introduced novel method detect temporal actions compressed
classical ones. new compression technique performed preprocessing task
thus independent planning algorithm used
temporal planner. makes compression technique general
POPF, specifically tailored planner. empirical results showed
action compression results improved performance ITSAT.
empirically showed method capable detecting compression-safe
temporal actions previous action compression method, used POPF.
introduced three new encoding methods based concept parallel plans
SAT-based temporal planning. two methods adopted
classical planning, third method, produces compact formulae,
employed ITSAT first time. empirical results show new
encoding significantly enhance performance SAT-based temporal planning.
604

fiITSAT: Efficient SAT-Based Temporal Planner

introduced method avoid producing plans members given
regular language set events. done embedding SAT
encoding particular FSM accepts language SAT encoding
input problem. used method preventing temporal inconsistencies
produced causally valid plans reoccurring subsequent causally valid
plans. experiments showed method contributed considerably
performance ITSAT current benchmark problems required concurrency.
According empirical results, taking advantage new approaches,
ITSAT outperform state-of-the-art temporally expressive planners,
competitive efficient temporal planners handle required concurrency. Nevertheless, believe performance ITSAT improved several
ways, discussed below.
current version ITSAT, satisfiability formulae different number
steps checked sequential manner, starting formula encoding one step.
means SAT solver refute several formulae finds first satisfiable
formula. time required checking satisfiability formulae increased
number steps, policy would result best performance ITSAT. However,
almost never case. shown case classical planning, fixed
planning problem, time needed finding model satisfiable formula usually
considerably less time needed refuting unsatisfiable formula (Rintanen et al.,
2006). Based experiments, phenomenon happens case temporal
planning, too. Similar SAT-based classical planning, one take advantage
phenomenon checking satisfiability formulae different numbers steps
parallel. applicability parallelisms sensistive amount
memory required saving formulae. shown Section 6, newly
introduced -step encoding considerably efficient temporal version
classical -step encoding terms memory usage. suggests -step
encoding suitable employing parallelism.
linear sized classical -step -step encodings, encoding methods,
assume exists predefined fixed ordering events given problem.
ordering great impact number steps needed solving input
problem. example, consider sequential plan ground action applied
once. potential plan subsequence mentioned fixed ordering,
one step sufficient finding plan. hand, case reversed
fixed ordering, number steps would required find model might
large size plan itself. current implementation ITSAT, ordering
events produced constructing ground actions, taken predefined
fixed ordering events. However, considering causal relationships among actions
given problem, one might able find effective orderings would result
fewer steps solving problem. believe enhancement would result
improved version ITSAT, efficient terms speed
memory usage.
current version ITSAT uses off-the-shelf general-purpose SAT solvers.
means advancement designing solvers improve performance
ITSAT. Recent investigations field SAT-based classical planning shown
605

fiRankooh & Ghassem-Sani

designing SAT solver tailored solving planning problems result much improved
performance SAT-based planners. particular, efficient SAT-based classical
planner, Mp (Rintanen, 2012), able competitive sate-of-the-art
state-space based planners employing idea. Since causal structures temporal
planning problems generally similar classical planning problems,
believe ITSAT benefit enormously employing planning-oriented SAT solver.
mentioned Section 6, one main drawbacks ITSAT poor quality
produced plans benchmark domains. mainly due fact
ITSAT abstracts duration actions, thus, SAT solver
needed resources evaluating quality plans produced. Alternatively, one add explicit representation time encoding (Shin & Davis,
2005). done using SMT solvers (Armando & Giunchiglia, 1993), handle continuous variables. However, discussed Section 1, solution may result
considerably slower search. think ITSAT benefit combination
two approaches: first plan produced ITSAT, proceed
introducing appropriate numerical constraint SAT formula hand, use
SMT solver produce improved plans. subject ongoing research.
Finally, mention components ITSAT, used
fields AI planning. notably, -step encoding employed
SAT-based classical planning. empirical results show encoding method
quite effective reducing number steps needed produce valid plans several
temporal planning domains classical version. think improved
performance -step encoding comparison -step encoding achieved
classical planning, too. Moreover, Section 5, showed prevent members
given regular language events input problem produced
output plan. used method prevent ITSAT producing temporally invalid
plans. method employed enforce variety constraints plan
produced. example, consider case require certain actions
executed specific order. must clear set plans violating
constraint regarded regular language set actions. Therefore,
constraint introduced encoding problem method
discussed Section 5.

Acknowledgments
authors would thank handling editor, Jorg Hoffmann, anonymous
reviewers invaluable contributions quality paper.

Appendix A. Proofs
Theorem 1. Let P = (I, G, A) temporal planning problem P c = (state(I), G, Ac )
causal abstraction P. Assume = he1 , ..., en sequence events
applicable I, sn = succ(I, ). following conditions must hold:
two propositions p q members state(sn ), p q non-mutex
layer n planning graph P c .
606

fiITSAT: Efficient SAT-Based Temporal Planner

proposition p member state(sn ), action member agenda(sn ),
p opena non-mutex layer n planning graph P c .
Proof. give proof induction n (the length ). n = 0, i.e.,
event applied I, conclusions obviously hold every member state(I)
present first layer graph, mutex first layer,
agenda(I) = Definition 6. suppose conclusions hold n = k 1. show
hold n = k. Assume = he1 , ..., ek sequence events
applicable I, sk = succ(I, ), sk1 = succ(I, he1 , ..., ek1 i).
Let p q two members state(sk ). three possible cases:
Case 1: p q members sk1 , induction hypothesis, p
q non-mutex layer k 1 planning graph P c thus noopp noopq
non-mutex layer k 1. Hence, p q mutex layer k.
Case 2: neither p q members state(sk ), Definition 5, p q
must members add(ek ). Assume ek ending event action
(the case ek starting event analogous thus omitted here).
Since ek applicable state sk1 , Definition 4, members pre(ek ) must
members state(sk1 ), must member agenda(sk1 ). Therefore,
induction hypothesis, members pre(ae ) non-mutex layer k 1.
result, p q, based Definition 10 added ae , non-mutex
layer k.
Case 3: p member state(sk1 ), Definition 5, q must member
add(ek ), p cannot member del(ek ). Assume ek ending event
action (again, case ek starting event analogous thus
omitted here). induction hypothesis, members pre(ae ) non-mutex
layer k 1, Definition 10, ae delete p. Therefore, ae present
layer k 1 cannot mutex noopp . result, p q non-mutex
layer k.
Let p member state(sk ), action member agenda(sk ).
two possible cases:
Case 1: member agenda(sk1 ), started yet ended
reaching sk1 , invariants members state(sk1 ).
induction hypothesis, invariants must non-mutex layer k 1. Hence, ai
present layer k 1. Definition 10, ai adds opena . Now, must show p
added action mutex ai layer k 1. p member
state(sk1 ), induction hypothesis, p present layer k 1. Therefore,
noopp , mutex ai , applicable layer k 1 and, result, p
opena mutex layer k. hand, p member
state(sk1 ), must added ek . Since ek applicable sk1 member
agenda(sk1 ), Definition 4, ek cannot delete invariant a. Assume ek
ending event action b (the case ek starting event b analogous
thus omitted here). induction hypothesis, , mutex
607

fiRankooh & Ghassem-Sani

ai must applicable layer k 1. means p opena mutex
layer k.
Case 2: member agenda(sk1 ), Definition 5, ek must
starting event a, delete p. Moreover, Definition 4, starting
invariants must present state(sk1 ). Therefore, induction hypothesis,
applicable layer k 1. p present state(sk1 ), must added
ek . Definition 10, propositions added starting event
added . Since adds opena , p opena cannot mutex layer k.
hand, p member state(sk1 ), induction hypothesis,
p present layer k 1. Therefore, noopp , mutex , applicable
layer k 1. means p opena mutex layer k.

Theorem 2. Let P = (I, G, A) solvable temporal planning problem. Let set
every member either compressible towards start compressible towards
end. compression-safe P.
Proof. Let 0 causally valid plan P (Such plan must exist P solvable).
Starting 0 , produce sequence causally valid plans swapping events
next plan hand. Assume arbitrary order ha1 , ...,
members . Without loss generality, assume action repeated
0 (otherwise, different names given different occurrences action
eliminate repetition). producing causally valid plan , consider
causally valid plan i1 . ai compressible towards start, keep swapping ending
event ai previous event i1 previous event becomes starting
event ai . fact, swaps collectively cause ai become compressed towards
start. swaps never falsify causally valid plan hand: assume
e event immediately prior ending event ai causally valid plan, e
starting event ai . precondition effect e must present
least one state whose agenda includes ai . Thus, Theorem 1, precondition
effect e mutex openai last layer levelled-off planning graph
causal abstraction P. Definition 13, e must swappable ending
event ai . Therefore, causally valid plan starting ending events
ai located next other. Similarly, ai compressible towards end, keep
swapping starting event ai next event i1 next event becomes
ending event ai . result, n , ending event members located
next corresponding starting events, therefore, according Definition 11,
compression-safe P.
Lemma 1. Let = {e1 , ..., en } set events, E R, two subsets S. Assume
subset ei E, ej
/ R j > i. Let
function defined following rules assigns value true f alse
SAT variable chain(e1 , ..., en ; E; R; k; m):
608

fiITSAT: Efficient SAT-Based Temporal Planner

i, (eki ) = true ei member .
i, (bki,m ) = true ej E j < i.
satisfies chain(e1 , ..., en ; E; R; k; m).
Proof. show satisfies formulae (C-1) (C-3), therefore satisfies
chain(e1 , ..., en ; E; R; k; m).
/
(C-1) Consider arbitrary formula eki bkj,m formula (C-1). ei
(eki ) = f alse, thus formula trivially satisfied. consider case
ei . definition formula (C-1), know < j ei E.
Therefore, according definition , must (bkj,m ) = true, thus
formula satisfied.
(C-2) Consider arbitrary formula bki,m bkj,m formula (C-2). (bki,m ) =
f alse, formula trivially satisfied. hand, (bki,m ) = true,
must exist l, l < el E. Since < j, must
l < j, therefore, (bkj,m ) = true, hence formula satisfied.
(C-3) Consider arbitrary formula bki,m eki formula (C-3). (bki,m ) =
f alse, formula trivially satisfied. hand, (bki,m ) = true,
must exist l, l < el E. according
properties , must ei
/ R. However, definition
chain(e1 , ..., en ; E; R; t; m), ei R and, result, ei
/ . Therefore,
k
(ei ) = f alse formula satisfied.

Lemma 2. Let = {e1 , ..., en } set events, E R two subsets S. Assume
model chain(e1 , ..., en ; E; R; k; m). ei E (eki ) = true,
j > ej R, (bkj,m ) = true, consequently (ekj ) = f alse.
Proof. Suppose sequence e1 , ..., en , event ej first event ei
ej R. Since formula (C-1) chain(e1 , ..., en ; E; R; k; m), eki bkj,m ,
(bkj,m ) = true. Similarly, sequence e1 , ..., en , event ej first event ej
ej R, must formula bkj,m bkj ,m (C-2), implies
(bkj ,m ) = true. repeating argument latter case, infer
j > ej R, (bkj,m ) = true, according (C-3),
(ekj ) = f alse.
Theorem 3 (completeness temporal -step encoding). Let P = (I, G, A)
solvable temporal planning problem, {e1 , ..., en } set events P, =
hStep1 , ..., Stepl causally valid -step plan P. exists model l
= plan(M ).
609

fiRankooh & Ghassem-Sani

Proof. construct function assigns true f alse SAT variables
formula l . Let hs0 , ..., sl state transition sequence . defined
following rules:
proposition p, k 0 k l, (pk ) = true iff p
member state(sk ).
action A, k 0 k l, (ak ) = true iff member
agenda(sk ).
1 n, k 1 k l, (eki ) = true
iff ei member Stepk . Moreover, k 1 k l, (ek0 ) =
(ekn+1 ) = f alse.
proposition p, 0 n + 1, k 0 k l,
(bki,mp ) = true iff exists event ej , j < i, ej Ep , ej Stepk .
1

proposition p, 0 n + 1, k 0 k l,
(bki,mp ) = true iff exists event ej , j > i, ej Ep , ej Stepk .
2

show satisfies formulae (-1) (-13), therefore model l . Note
way constructed, directly = plan(M ).
(-1) According Definition 15, s0 = I, thus formula (-1) clearly satisfied.
(-2) According Definition 15, G state(sl ), thus formula (-2) clearly
satisfied.
(-3) According Definition 6, agenda(I) = , thus formula (-3) clearly
satisfied.
(-4) According Definition 15, agenda(sl ) = , thus formula (-4) clearly
satisfied.
(-5) Let p arbitrary proposition, e event e Rp . e
/ Stepk ,
(ek ) = f alse and, therefore, formula (-5) trivially satisfied. Consider
case e Stepk . According Definition 15, Stepk must -step sk1
sk . Thus, Definition 14, possible ordering events Stepk ,
must able execute events according ordering, starting state
sk1 . One possible ordering specific ordering puts e front
events. Therefore, e must applicable sk1 . Then, Definition 4,
p state(sk1 ). implies (pk1 ) = true, satisfaction
formula (-5) easily follows.
/ Stepk ,
(-6) Let p arbitrary proposition, e event e Ep+ . e
(ek ) = f alse and, therefore, formula (-6) trivially satisfied. Consider
case e Stepk . Similar previous case, starting state sk1 ,
must able execute events Stepk possible ordering reach sk .
610

fiITSAT: Efficient SAT-Based Temporal Planner

One possible ordering one puts e events. Therefore, addeffects e must members state(sj ), Definition 5, p state(sk ).
implies (pk ) = true, satisfaction formula (-6) easily
follows.
/ Stepk
(-7) Let p arbitrary proposition, e event e Ep . e
k
(e ) = f alse and, therefore, formula (-7) trivially satisfied. Otherwise,
argument given case (-6), p
/ state(sk ), satisfaction
formula (-7) easily follows.
(-8) Let p arbitrary proposition. Consider nontrivial case p member
state(sk ) state(sk1 ). easily derived Definition 5, p
added application sequence events, least one events
must add p. implies satisfaction formula (-8).
(-9) case analogous case (-8)
(-10) Lemma 1 used prove satisfies chain(e1 , ..., en+1 ; Ep ; Rp {en+1 }; k; mp1 ).
straightforward see properties model Lemma
1. need show proposition p, provided ei Stepk Ep
j > i, ej
/ Stepk Rp . Suppose ej Stepk . Definition 14,
possible ordering events Stepk , must able execute events
according ordering, starting state sk1 . One possible ordering
one puts ei immediately ej . Notice ei deletes p,
ei Ep . Thus, ej cannot p precondition, ej
/ Rp . infer
ej
/ Stepk Rp . Therefore, Lemma 1, satisfies chain(e1 , ..., en+1 ; Ep ; Rp
{en+1 }; k; mp1 ). Now, show satisfies bkn+1,mp ak . Consider
1

nontrivial case, (bkn+1,mp ) = true. Based way construct ,
1
least one e1 , ..., en , say ej , must delete p. Again, since Stepk -step sk1
sk , must able execute events Stepk possible ordering
reach sk . Consider specific ordering puts ej events. Now,
agenda(sk ), according Definition 5, ej cannot ending event a.
Therefore, Definition 4, member agenda state
ej applied. clearly contradicts applicability ej , ej deletes p,
invariant a. Therefore, (ak ) = f alse, implies satisfies
bkn+1,mp ak .
1

(-11) case, too, Lemma 1 used prove satisfies chain(en , ..., e0 ; Ep ; Rp
{e0 }; k; mp1 ). Similar previous case, straightforward confirm
properties Lemma 1. Since ordering chain(e1 , ..., en+1 ; Ep ; Rp
{en+1 }; k; mp1 ) reversed chain(en , ..., e0 ; Ep ; Rp {e0 }; k; mp1 ), need show
proposition p, provided ei Stepk Ep j < i, ej
/
Stepk Rp . Suppose ej Stepk . Definition 14, possible ordering
events Stepk , must able execute events according
ordering, starting state sk1 . One possible ordering one
puts ei immediately ej . argument one given case
611

fiRankooh & Ghassem-Sani

(-10), infer ej
/ Stepk Rp and, therefore, Lemma 1, satisfies
chain(en , ..., e0 ; Ep ; Rp {e0 }; k; mp1 ). Now, show satisfies bk0,mp
2

ak1 . Consider nontrivial case, (bk0,mp ) = true. Based way
2
construct , least one e1 , ..., en , say ej , must delete p. Again, Stepk
-step sk1 sk , starting state sk1 , must able execute
events Stepk possible ordering. Consider specific ordering puts ej
events. Definition 4, since ej deletes p, invariant
a, cannot member agenda(sk1 ). Therefore, (ak ) = f alse, implies
satisfies bk0,mp ak1 .
2

(-12) Assume e starting event action a. Stepk -step sk1
sk , starting state sk1 , must able execute events Stepk
possible ordering. Consider specific ordering puts e
events. Therefore, e must applicable sk1 . Then, Definition 4, cannot
member agenda(sk1 ), thus (ak1 ) = f alse. see (ak ) = true,
consider specific ordering events puts e events. events
executed ordering, results applying e appear state sk ,
thus must member agenda(sk ). Hence, satisfies ek ak1 ak .
(-13) Analogous case (-12), assume e ending event action a. Since Stepk
-step sk1 sk , starting state sk1 , must able execute
events Stepk possible ordering. Consider specific ordering puts e
events. Therefore, e must applicable sk1 . Then, Definition
4, must member agenda(sk1 ), thus (ak1 ) = true. see
(ak ) = f alse, consider specific ordering events puts e
events. events executed ordering, results applying e
appear state sk , thus cannot member agenda(sk ). conclude
satisfies ek ak1 ak .

Theorem 4 (soundness -step encoding). Let P = (I, G, A) temporal planning
problem, {e1 , ..., en } set events P, l -step encoding P.
l model , plan(M ) causally valid -step plan P.
Proof. obtain plan(M ) follows. k 1 k l, let Stepk
set events e (ek ) = true. k 0 k l, let
sk temporal state. Assume state(sk ) set propositions p
(pk ) = true, agenda(sk ) set actions (ak ) = true.
show = plan(M ) = hStep1 , ..., Stepl causally valid -step plan P
state transition sequence hs0 , ..., sl i.
formula (-1), immediately follows = state(s0 ). Formula (-2) implies
G state(sl ). Formulae (-3) (-4) respectively imply agenda(s0 )
agenda(sn ) empty sets. Now, need show k 1 k l,
Stepk = {e1 , ..., em } {e1 , ..., en } -step sk1 sk . first show
612

fiITSAT: Efficient SAT-Based Temporal Planner

proposition p, Stepk cannot include two different events ei ej ei Rp ,
ej Ep . j < i, since satisfies formula (-10), Lemma 2, infer (eki )
(ekj ) cannot equal true. hand, < j, since satisfies formula
(-11), Lemma 2, infer (eki ) (ekj ) cannot equal true.
Thus, ei ej cannot members Stepk . Let : {1, ..., m} {1, ..., m}
arbitrary ordering function. show induction k , k m, sequence
heO(1) , ..., eO(k ) applicable sk1 . k = 0 (i.e., case event
applied sk1 ), conclusion trivially holds. induction hypothesis, let sk
temporal state resulting applying sequence heO(1) , ..., eO(k ) sk1 . Let eO(k +1)
starting event action (we omit similar case eO(k +1) ending
event a). show conditions (1) (3) Definition 4 hold thereby eO(k +1)
applicable sk . result, heO(1) , ..., eO(k +1) applicable sk1 .
(1) formula (-5), easily follows preconditions eO(k +1) invariants (except invariants added eO(k +1) ) members
state(sk1 ). mentioned above, neither propositions deleted
another member Stepk . Thus, propositions members state(sk ).
(2) formula (-7), easily follows member agenda(sk1 ). Notice
according Definition 5, starting event a, i.e., eO(k +1) , event
add agenda state. Therefore, cannot member agenda(sk ),
either.
(3) Let action invariant p p del(eO(k +1) ). Clearly
start(a ) Rp , thus, argued above, start(a ) eO(k+1) cannot
members Stepk . Hence, start(a )
/ Stepk . hand, since p deleted
step k, satisfies chain(en , ..., e0 ; Ep ; Rp {e0 }; k; mp2 ), according Lemma 2,
have: (b0,mp2 ) = true. Therefore, formula (-11), infer (ak1 ) =
f alse, thus,
/ agenda(sk1 ). start(a )
/ Stepk
/ agenda(sk1 ) jointly


imply
/ agenda(sk ).
show sm , result applying heO(1) , ..., eO(m) sk1 , equal
sk .
Let p arbitrary member state(sm ). formulae (-6) (-7) follows
p deleted member Stepk , cannot added member
). Therefore, p deleted
Stepk thus, p cannot member

Wof state(s
k
member Stepk , formula eEp e satisfied . Besides, p
added member Stepk , must member state(sk1 ), thus
(pk1 ) = true. Now, formula (-9), infer (pk ) = true, hence
p state(sk ). hand, p added member Stepk , formula
(-6), deduce (pk ) = true, p state(sk ). Therefore,
state(sm ) state(sk ).
Let p arbitrary member state(sk ). According formula (-7), p cannot
deleted member Stepk . Besides, formula (-8), p either member
613

fiRankooh & Ghassem-Sani

state(sk1 ) added member Stepk . cases, Definition 5 implies
p state(sm ). Therefore, state(sk ) state(sm ).
Let arbitrary member agenda(sm ). formulae (-12) (-13),
follows starting ending events single action members
Stepk . agenda(sk1 ), still open state sm , infer
end(a)
/ Stepk . Therefore, according formula (-13), (ak ) = true, must
member agenda(sk ). hand,
/ agenda(sk1 ), start(a)
must member Stepk . Then, formula (-12), have: (ak ) = true,
again, must member agenda(sk ). Therefore, agenda(sm ) agenda(sk ).
Let arbitrary member agenda(sk ). According formula (-13), start(a)
cannot member Stepk . Besides, formula (-12), either member
agenda(sk1 ) start(a) member Stepk . cases, Definition 5 implies
agenda(sm ). Therefore, agenda(sk ) agenda(sm ).
argument shows state(sk ) = state(sm ) agenda(sk ) = agenda(sm ). Hence,
sk = sm = succ(sk1 , heO(1) , ..., eO(m) i). Therefore, Stepk -step sk1 sk .
Theorem 5 (completeness -step encoding). Let P = (I, G, A) solvable temporal planning problem, {e1 , ..., en } set events P, = hStep1 , ..., Stepl
causally valid -step plan P. exists model l = plan(M ).
Proof. Theorem 3, exists model l = plan(M ). show
translated model l . Since formulae (1) (10) shared
l l , satisfies formulae. show satisfies
formulae (-11) (-20), therefore translated model l .
following cases, arbitrary temporal action, ei starting event a, ej
ending event a.
(-11) (eki ) = f alse, formula (-11) trivially satisfied. (eki ) = true,
formula (-12) have: (ak1 ) = f alse, therefore formula (-11) satisfied.
(-12) (eki ) = f alse, formula (-12) trivially satisfied. (eki ) = true,
formula (-12) have: (ak ) = true, therefore formula (-12) satisfied.
(-13) (ekj ) = f alse, formula (-13) trivially satisfied. (ekj ) = true,
formula (-13) have: (ak ) = f alse, therefore formula (-13) satisfied.
(-14) (ekj ) = f alse, formula (-14) trivially satisfied. (ekj ) = true,
formula (-13) have: (ak1 ) = true, therefore formula (-14) satisfied.
(-15) Exactly case (-11).
(-16) Exactly case (-12).
(-17) Exactly case (-13).
(-18) Exactly case (-14).
614

fiITSAT: Efficient SAT-Based Temporal Planner

(-19) Follows immediately fact satisfies formula (-12).
(-20) Follows immediately fact satisfies formula (-13).

Theorem 6 (soundness -step encoding). Let P = (I, G, A) temporal planning
problem, {e1 , ..., en } set events P, l -step encoding P.
l model , plan(M ) causally valid -step plan P.
Proof. obtain plan(M ) follows. k 1 k l, let Stepk
set events e (ek ) = true. Moreover, k
0 k l, let sk temporal state. Assume state(sk ) set propositions p
(pk ) = true agenda(sk ) set actions (ak ) = true.
construct = plan(M ) = hStep1 , ..., Stepl show causally valid -step
plan P state transition sequence hs0 , ..., sl i.
formula (-1), immediately follows = state(s0 ). Formula (-2) implies
G state(sl ). Formulae (-3) (-4) imply agenda(s0 ) agenda(sn )
empty sets. Now, need show k 1 k l,
Stepk = {e1 , ..., em } {e1 , ..., en } -step sk1 sk . Without loss generality,
assume sequence he1 , ..., em ordered fixed ordering he1 , ..., en i. Note
since satisfies formula (-10), Lemma 2, proposition p, Stepk cannot include
two events ei ej ei Rp , ej Ep , j < i. induction k , show
every k m, sequence he1 , ..., ek applicable sk1 . k = 0 (i.e.,
case event applied sk1 ), conclusion obviously holds. induction
hypothesis, let sk temporal state resulting applying sequence he1 , ..., ek
sk1 . Assume ek +1 starting event action (we omit similar case
ek +1 ending event a). show conditions (1) (3) Definition 4
hold thereby ek +1 applicable sk .
(1) formula (-5), clearly results preconditions ek +1 invariants
(except invariants added eO(k +1) ) members state(sk1 ).
stated before, neither propositions deleted ei < k . Thus,
propositions members state(sk ).
(2) two possible cases. Consider first case, according fixed
ordering he1 , ..., en i, ending event located ek +1 . Formula (-11) implies
cannot member agenda(sk1 ). Notice according Definition 5,
starting event a, i.e., ek +1 , event add agenda
state. Therefore, cannot member agenda(sk ). case,
ending event located ek +1 , formula (-15) implies either
member agenda(sk1 ), end(a) member Stepk . However, end(a)
member Stepk , certainly remove agenda resulting state. Since
ek +1 event add agenda state, conclude
cannot member agenda(sk ). Therefore, neither two cases,
member agenda(sk ).
615

fiRankooh & Ghassem-Sani

(3) Let action p del(ek +1 ) invariant. Since p deleted step k,
satisfies chain(e1 , ..., en ; Ep ; Rp {en+1 }; k; mp1 ), according Lemma 2,
(bn+1,np1 ) = true. Therefore, formula (-10),
/ agenda(sk ).
hand, clearly end(a ) Rp , thus, argued before, end(a )
member Stepk , cannot located ek +1 fixed ordering he1 , ..., en i.
Hence, member agenda(sk ), cannot member agenda(sk ),
either. Therefore, infer
/ agenda(sk ).
show sm , result applying he1 , ..., em sk1 , equal sk .
argument given proof Theorem 4, state(sm ) state(sk )
state(sk ) state(sm ), hence, state(sm ) = state(sk ).
Let arbitrary member agenda(sm ). Let ei ej starting ending
events a, respectively. three possible cases. Consider first case
agenda(sk1 ), ei
/ Stepk , ej
/ Stepk (i.e., open immediately step
k neither started ended step k). case, since satisfies (-20),
(ak ) = true, therefore, agenda(sk ). Consider second case
agenda(sk1 ), ei Stepk , ej Stepk , j < (i.e., open immediately
step k, first ended started step k). case, since
satisfies formula (-16), (ak ) = true, therefore, agenda(sk ).
Finally, consider third case
/ agenda(sk1 ), ei Stepk , ej
/ Stepk
(i.e., open immediately step k, started ended
step k). case, j < i, must satisfy formula (-16)
(ak ) = true. hand, < j, must satisfy formula (-12) and,
since (ekj ) = f alse, must (ak ) = true, therefore, agenda(sk ).
Consequently, three cases, must member agenda(sk ); hence
agenda(sm ) agenda(sk ).
Let arbitrary member agenda(sk ), i.e., (ak ) = true. two
possible cases. Case 1) member agenda(sk1 ), hence (ak1 ) =
f alse. formula (-19), have: (eki ) = true. means started
step k. Now, j < i, ending event cannot happen starting event,
therefore, must remain open execution step k, i.e., agenda(sm ).
hand, < j, formula (-14) have: (ekj ) = f alse.
means started ended step k, therefore must remain open
execution step k, i.e., agenda(sm ). consider case 2)
member agenda(sk1 ), hence (ak1 ) = true. < j, formula (-11)
(eki ) = f alse, formula (-13) (ekj ) = f alse. means
open immediately execution step k, neither started
ended step k. Therefore, must open execution step k, i.e.,
agenda(sm ). hand, j < i, since (ak ) (ak1 )
false, formulae (-15) (-17) combined form formula (eki ekj ).
means ended step k later started
step. Therefore, must open execution step k,
agenda(sm ). Therefore, agenda(sk ) agenda(sm ).
616

fiITSAT: Efficient SAT-Based Temporal Planner

arguments show state(sk ) = state(sm ) agenda(sk ) = agenda(sm ). Hence,
sk = sm = succ(sk1 , he1 , ..., em i). Therefore, ordering functions : {1, ..., m}
{1, ..., m}, O(i) = i, sk = succ(sk1 , heO(1) , ..., eO(m) i), thus Stepk
-step sk1 sk .
Lemma 3. Let model chain (e1 , ..., en ; Ep+ ; Ep ; Rp ; k; mp ), ej member
Rp , EpM = {e|e Ep+ Ep , (ek ) = true}. following properties:
exists event ei ei EpM < j, (bkj,mp ) = (pk1 ).
exists event ei ei Ep+ , < j, {ei+1 , ..., ej1 } EpM = ,
(eki ) = true, (bkj,mp ) = true.
exists event ei ei Ep , < j, {ei+1 , ..., ej1 } EpM = ,
(eki ) = true, (bkj,mp ) = f alse.
Proof.
Assume exists event ei ei EpM < j. Consider
case (pk1 ) = true. Let {ei0 , ..., eim } set events ei
ei Rp Ep+ Ep , 0 j. Without loss generality,
assume 0 = i0 < i1 < ... < im = j. Since must satisfy (C -7), know
(bki ,m ) = true. Assume arbitrary s, (bkis ,mp ) = true. eis Ep+ Ep ,
0

p

know (ekis ) = f alse, (C -4) (bki


s+1 ,mp

hand, eis

Rp Ep+ Ep ,



(C -3),



(bki ,m )
p
s+1

) = true.

= true. infer

1 j, (bkis ,mp ) = true, thereby (bkj,mp ) = (pk1 ).
proof case (pk1 ) = f alse analogous, except
instead (C -4), need use (C -5) .
Assume exists event ei ei Ep+ , < j, {ei+1 , ..., ej1 }
EpM = , (eki ) = true. Let {ei0 , ..., eim } set events ei
ei Rp Ep+ Ep , j. Without loss generality, assume =
i0 < i1 < ... < im = j. Since must satisfy (C -1), know (bki ,m ) = true.
1

p

Assume arbitrary 1, (bkis ,mp ) = true. eis Ep+ Ep ,
know (ekis ) = f alse, (C -4), (bki
hand, eis Rp

Ep+



) = true.
s+1 ,mp
k

(bi ,m ) = true. infer
p
s+1
k
(bis ,mp ) = true, thereby (bkj,mp ) = true.

Ep ,

1 j,

(C -3),

Assume exists event ei ei Ep , < j, {ei+1 , ..., ej1 }
EpM = , (eki ) = true. Let {ei0 , ..., eim } set events ei
ei Rp Ep+ Ep , j. Without loss generality, assume =
617

fiRankooh & Ghassem-Sani

i0 < i1 < ... < im = j. Since must satisfy (C -1), know (bki ,m ) = f alse.
1

p

Assume arbitrary 1, (bkis ,mp ) = f alse. eis Ep+ Ep ,
know (ekis ) = f alse, (C -5), (bki
hand, eis Rp

Ep+



) = f alse.
s+1 ,mp
k

(bi ,m ) = f alse. infer
p
s+1
k
(bis ,mp ) = f alse, thereby (bkj,mp ) = f alse.

Ep ,

1 j,

(C -3),


Lemma 4. Let model chain(e1 , ..., en+1 ; Ep ; Rp ; k; mof
p ). Assume ei Ep ,
(eki ) = true, p inv(a). Let ej ej+1 starting event ending event
a, respectively. following properties:

(ekj+1 ) = true, < j, (ekj ) = true.
(ak ) = true, (ekj ) = true.
Proof. Let {ei1 , ..., eim } equal set {es |es Op , < n + 1}. Without loss
generality, assume i1 < i2 < ... < im = n + 1. Since (eki ) = true,
(Cof -1), infer (bi1 ,mof ) = true. s, (bis ,mof ) = true,
p

p

(Cof -2), deduce (bis+1 ,mof ) = true. Therefore, (bn+1,mof ) = true.
p
p
Furthermore, < j, ej+1 {ei1 , ..., eim }, thus (bj+1,mof ) = true. Besides,
p

(ekj+1 ) = true, (Cof -3), (ekj ) = true. hand, (ak ) =
true, infer formula (Cof -4) (ekj ) = true.

Lemma 5. Let model chain(e0 , ..., en ; Ep ; Rp ; k; mob
p ). Assume ei Ep ,
(eki ) = true, p inv(a). Let ej ej+1 starting event ending event
a, respectively. following properties:

(ekj ) = true, j + 1 < i, (ekj+1 ) = true.
(ak1 ) = true, (ekj+1 ) = true.
Proof. proof analogous Lemma 4, thus omitted.
Theorem 7 (completeness relaxed -step encoding). Let P = (I, G, A)

temporal planning problem formulae l l two -step encodings

P explained Section 4. model l , l model
plan(M ) = plan(M ).
Proof. Let model l . construct function assign value true

f alse binary variable l , using following rules:
(R-1) 1 n 1 k l, (eki ) = (eki ).
618

fiITSAT: Efficient SAT-Based Temporal Planner

(R-2) 1 k l, (ek0 ) = (ekn+1 ) = f alse.
(R-3) 0 k l proposition p, (pk ) = (pk ).
(R-4) 0 k l action a, (ak ) = (ak ).
(R-5) 0 n + 1, 1 k l, proposition p, exist j <
(ekj ) = true ej Ep+ Ep (bki,mp ) = (pk ); otherwise, (bki,mp ) =
(pk1 ).
(R-6) 1 n + 1, 1 k l, proposition p, exist j <
(ekj ) = true ej Ep (bk ) = true; otherwise, (bk ) = f alse.
i,mp

i,mp

(R-7) 0 n, 1 k l, proposition p, exist j >
(ekj ) = true ej Ep (bki,mob ) = true; otherwise, (bki,mob ) = f alse.
p

p

show satisfies formulae ( -1) ( -13), therefore model

l . rules, clear plan(M ) = plan(M ).
( -1) Formula ( -1) exactly (-1). Besides, assign
value variable formula.
( -2) Formula ( -2) exactly (-2). Besides, assign
value variable formula.
( -3) Formula ( -3) exactly (-3). Besides, assign
value variable formula.
( -4) Formula ( -4) exactly (-4). Besides, assign
value variable formula.
( -5) Formula ( -4) conjunction formulae (C -1) (C -8). show
satisfies formulae (C -1) (C -8), thereby, satisfies ( -5).
Consider arbitrary formula eki bkj,mp (C -1). (eki ) = f alse,
formula trivially satisfied. (eki ) = true, (R-5),
(bki,mp ) = (pk ). hand, satisfies (-6),
(pk ) = true. Therefore, (bki,mp ) = true, formula satisfied again.
Consider arbitrary formula eki bkj,mp (C -2). (eki ) = f alse,
formula trivially satisfied. (eki ) = true, (R-5),
(bki,mp ) = (pk ). hand, satisfies (-7),
(pk ) = f alse. Therefore, (bki,mp ) = f alse, formula satisfied
again.
Consider arbitrary formula bki,mp bkj,mp (C -3). Since ei
member Ep+ Ep , none events located ei ej
fixed ordering members Ep+ Ep , (R-5), easily show
(bki,mp ) = (bkj,mp ). Thus, formula satisfied.
619

fiRankooh & Ghassem-Sani

Consider arbitrary formula bki,mp eki bkj,mp (C -4). (eki ) =
true, formula trivially satisfied. (eki ) = f alse, since none
events located ei ej fixed ordering members
Ep+ Ep , (R-5), easily show (bki,mp ) = (bkj,mp ). Thus,
formula satisfied.
Consider arbitrary formula bki,mp eki bkj,mp (C -5).
argument one given (C -4), infer (bki,mp ) = (bkj,mp ).
Thus, formula satisfied.
Consider arbitrary formula bki,mp eki (C -6). (bki,mp ) = true,
formula trivially satisfied. (bki,mp ) = f alse, exist two
possible cases. Case 1: exists event ej j < i, (ekj ) = true,
ej Ep+ Ep . case, (R-5), (pk ) = (bki,mp ) = f alse.
Since must satisfy (-6), ej
/ Ep+ , thus ej Ep . Besides,
must satisfy (-10), implies (eki ) = f alse. (R-1),
(eki ) = (eki ) = f alse, therefore, formula satisfied. Case 2:
exist event ej j < i, (ekj ) = true, ej Ep+ Ep .
case, (R-5), (pk1 ) = (bki,mp ) = f alse. Now, since
must satisfy (-5), infer (eki ) = f alse. (R-1),
(eki ) = (eki ) = f alse, therefore, formula satisfied again.
Consider formula bk0,mp pk1 (C -6). (R-5), easily deducted (bk0,mp ) always equal (pk1 ). (R-3),
(pk1 ) = (pk1 ). result, (bk0,mp ) = (pk1 ), formula
satisfied.
Consider formula bkn+1,mp pk (C -6). two possible cases.
Case 1: exists event e (ek ) = true, e Ep+ Ep .
case, (R-5), (bn+1,mp ) = (pk ). Now, (R-5),
(pk ) = (pk ). Therefore, (bn+1,mp ) = (pk ), formula
satisfied. Case 2: exist event e (ek ) = true
e Ep+ Ep . case, (R-5), (bn+1,mp ) = (pk1 ). Besides,
since satisfies formulae (-8) right hand side (-8) becomes f alse,
left hand side (-8), i.e., pk1 pk , f alse, too. Thus,
(pk1 ) = f alse, (pk ) = f alse. similar argument
(-9) show (pk1 ) = true, (pk ) = true. Thus,
(pk1 ) = (pk ), (R-3), (pk ) = (pk1 ). Therefore,
(bn+1,mp ) = (pk1 ) = (pk ), formula satisfied again.
( -6) show satisfies formulae (Cof -1) (Cof -4), thereby, satisfies
( -6).
Consider arbitrary formula eki bk

j,mof
p

(Cof -1). know (Cof -

1) < j. (eki ) = f alse, formula trivially satisfied. (eki ) =
true, (R-6), (bj,mof ) = true, formula satisfied.
p

620

fiITSAT: Efficient SAT-Based Temporal Planner

Consider arbitrary formula bk

i,mof
p

(Cof -2). (bk

bk

j,mof
p

i,mof
p

= f alse, formula trivially satisfied. (bk

i,mof
p

)

) = true, rule



(R-6), must exist event ei ,
< i, (eki ) = true,
ei Ep . Since < j, must < j. Now, (R-6),
(bj,mof ) = true, formula satisfied.
p

Consider arbitrary formula bk

j,mof
p

ekj eki (Cof -3). (bk

j,mof
p

f alse, formula trivially satisfied. (bk

j,mof
p

)=

) = true, (R-6),

must exist event ej j < j, (ekj ) = true, ej Ep . Now,
since satisfies (-10), infer (ekj ) = f alse. (R-1),
(ekj ) = (ekj ) = f alse, therefore, formula satisfied.
Consider arbitrary formula bk

n+1,mof
p

ak eki (Cof -4). (bk

n+1,mof
p

= f alse, formula trivially satisfied. (bk

)

) = true, (R-6),

n+1,mof
p
k
event ej (ej ) = true ej Ep . Now,
(-10), infer (ak ) = f alse. (R-4),

must exist
since satisfies
(ak ) = (ak ) = f alse, therefore, formula satisfied.

( -7) show satisfies formulae (Cob -1) (Cof -4), thereby, satisfies
( -7).
Consider arbitrary formula eki bkj,mob (Cob -1). know (Cob -1)
p

j < i. (eki ) = f alse, formula trivially satisfied. (eki ) =
true, (R-7), (bj,mob
) = true, formula satisfied.
p
Consider arbitrary formula bki,mob bkj,mob (Cob -2). (bki,mob ) =
p

p

p

f alse, formula trivially satisfied. (bki,mob ) = true, rule (R-7),
p

must exist event ei < , (eki ) = true, ei Ep .
Since j < i, must j < . Now, (R-7),
) = true, formula satisfied.
(bj,mob
p
Consider arbitrary formula bki,mob eki ekj (Cob -3). (bki,mob ) =
p

p

f alse (eki ) = f alse, formula trivially satisfied. (bki,mob ) = true
p

(eki ) = true, (R-7), must exist event ei , < ,
(eki ) = true, ei Ep . Since satisfies (-10), infer
(ak ) = f alse. However, know = j 1 < j; thus must satisfy (12). Therefore, (ekj ) = true. (R-1), (ekj ) = (ekj ) =
true, therefore, formula satisfied.
Consider arbitrary formula bk0,mob ak1 ekj (Cob -4). (bk0,mob ) =
p

p

f alse (ak1 ) = f alse, formula trivially satisfied. (bk0,mob ) =
p

true (ak1 ) = true, (R-7), must exist event ei
(eki ) = true, ei Ep . Since satisfies (-10), infer
(ak ) = f alse. However, must satisfy (-20). Therefore, (ekj ) =
621

fiRankooh & Ghassem-Sani

true. (R-1), (ekj ) = (ekj ) = true, therefore, formula
satisfied.
( -8) Consider arbitrary formula eki ak1 ( -8). Let ej ending event
a. know = j 1 < j. Therefore, must satisfy (-11). ( -8)
exactly (-11). Besides, assign value
variable formulae. Thus, ( -8) satisfied .
( -9) Consider arbitrary formula eki ak ekj ( -9). know = j 1 < j.
Therefore, must satisfy formula (-12). ( -9) exactly (-12).
Besides, assign value variable formulae. Thus,
( -9) satisfied .
( -10) Consider arbitrary formula ekj ak ( -10). Let ei starting event
a. know = j 1 < j. Therefore, must satisfy (-13). ( -10)
exactly (-13). Besides, assign value
variable formulae. Thus,( -10) satisfied .
( -11) Consider arbitrary formula ekj ak1 eki ( -11). know =
j 1 < j. Therefore, must satisfy (-14). ( -11) exactly (-14).
Besides, assign value variable formulae. Thus,
( -11) satisfied .
( -12) ( -12) exactly (-19). Besides, assign value
variable formulae. Thus, ( -12) satisfied .
( -13) ( -13) exactly (-20). Besides, assign value
variable formulae. Thus, ( -13) satisfied .

Theorem 8 (soundness relaxed -step encoding). Let P = (I, G, A)

temporal planning problem, {e1 , ..., en } set events P, l relaxed

-step encoding P. l model , plan(M ) causally valid -step plan
P.
Proof. obtain plan(M ) follows. k 1 k l, let Stepk
set events e (ek ) = true. k 0 k l,
let sk temporal state. Assume state(sk ) set propositions p
(pk ) = true, agenda(sk ) set actions (ak ) = true.
construct = plan(M ) = hStep1 , ..., Stepl show causally valid -step plan
P state transition sequence hs0 , ..., sl i.
( -1), immediately follows = state(s0 ). Also, ( -2) implies G
state(sl ). Besides, ( -3) ( -4) imply agenda(s0 ) agenda(sn ) empty sets,
respectively. need show k 1 k l, Stepk =
{ei1 , ..., eim } {e1 , ..., en } -step sk1 sk . Without loss generality,
622

fiITSAT: Efficient SAT-Based Temporal Planner

assume sequence hei1 , ..., eim ordered according fixed ordering he1 , ..., en i,
i.e., i1 < i2 < ... < im .
induction k , conclude k m, sequence hei1 , ..., eik
applicable sk1 . k = 0 (i.e., case, event applied sk1 ), conclusion obviously holds. Let sk temporal state resulting applying hei1 , ..., eik
sk1 . Assume eik +1 starting event action a. omit similar case
eik +1 ending event a. show conditions (1) (3) Definition 4
holds thereby eik +1 applicable sk .
(1) Assume p
/ state(sk ), p either precondition eik +1 invariant
added eik +1 . two possible cases. Case 1: p
member state(sk1 ), added deleted member {ei1 , ..., eik }.
case, (pk1 ) = f alse. Moreover, exists event ei
ei Ep+ Ep , < k + 1, (eki ) = true. Case 2: p deleted event
ei Stepk added deleted event ej Stepk , < j k .
case, ei Ep , < ik +1 , {ei+1 , ..., eik +1 } EpM = , (eki ) = true,
EpM = {e|e Ep+ Ep , (ek ) = true}. cases, Lemma 3,
(bkik +1 ,mp ) = f alse, contradicts fact satisfies (C -6).
(2) Since satisfies ( -8), member agenda(sk1 ). However, eik +1
event Stepk add agenda state. Thus, member
agenda(sk ).
(3) Let b action a, invariant p del(eik +1 ). Let ej ej+1
starting ending events b, respectively. mentioned earlier, assume
ending event action located immediately starting event
fixed ordering. show b cannot member agenda(sk ).
two possible cases b may member agenda(sk ). Case 1: b open
action immediately execution Stepk ; b ended Stepk
eik +1 executed. case, (bk1 ) = true, (ekik +1 ) = true. Since
satisfies ( -7), Lemma 5, (ekj+1 ) = true. assumed b
ended execution eik +1 , ik +1 < j + 1. hand,
since ej starting event b, ik +1 6= j, thus, ik +1 < j. Therefore,
Lemma 4, (ekj ) = true. contradicts fact satisfies ( -8),
(bk1 ) = true, (ekj ) = true, ej = start(b). Case 2: b
started step k, ended step k execution eik +1 .
case, (ekj ) = true, (ekj+1 ) = f alse, j + 1 < ik +1 , (ekik +1 ) = true.
Since satisfies ( -7), Lemma 5, must (ekj+1 ) = true,
contradiction.
show sm , result applying hei1 , ..., eim sk1 , equal sk .
Let p arbitrary proposition. p state(sm ), two possible cases.
Case 1: p member state(sk1 ), added deleted member
{ei1 , ..., eim }. case, (pk1 ) = true. Moreover, exists event ei
ei Ep+ Ep , < n + 1, (eki ) = true. Case 2: p added event
623

fiRankooh & Ghassem-Sani

ei Stepk added deleted event ej Stepk , < n + 1.
case, ei Ep+ , < n + 1, {ei+1 , ..., en } EpM = , (eki ) = true,
EpM = {e|e Ep+ Ep , (ek ) = true}. cases, Lemma 3,
(bkn+1,mp ) = true. Since satisfies (C -8), (pk ) = true, thus
p state(sk ). Therefore, state(sm ) state(sk ).
Let p arbitrary proposition. p
/ state(sm ), two possible cases. Case
1: p member state(sk1 ), added deleted member
{ei1 , ..., eim }. case, (pk1 ) = f alse. Moreover, exists event
ei ei Ep+ Ep , < n + 1, (eki ) = true. Case 2: p deleted
event ei Stepk added deleted event ej Stepk ,
< j < n + 1. case, ei Ep , < n + 1, {ei+1 , ..., en } EpM = ,
(eki ) = true, EpM = {e|e Ep+ Ep , (ek ) = true}. cases, Lemma
3, (bkn+1,mp ) = f alse. Since satisfies (C -8), (pk ) = f alse,
thus p
/ state(sk ). Therefore, state(sk ) state(sm ).
Let arbitrary action, ei ej starting event ending event,
respectively. agenda(sm ), since assume ending event action
located immediately starting event fixed ordering, two
possible cases. Case 1: open immediately step k, ended
step k. case, (ak1 ) = true (ekj ) = f alse. Since satisfies
( -13), must (ak ) = true. Therefore, agenda(sk ). Case 2: started
ended step k. case, (eki ) = true (ekj ) = f alse.
satisfies ( -9), must (ak ) = true. Therefore, agenda(sk ). Since
cases, agenda(sk ), infer agenda(sm ) agenda(sk ).
Let arbitrary action, ei ej starting event ending event a,
respectively.
/ agenda(sm ), since assume ending event action
located immediately starting event fixed ordering, two
possible cases. Case 1: open immediately execution step k,
started step k. case, (ak1 ) = f alse (eki ) = f alse.
Since satisfies ( -12), must (ak ) = f alse. Therefore,
/ agenda(sk ).
k
Case 2: ended step k. case, (ej ) = true. Since satisfies
( -10), must (ak ) = f alse. Therefore,
/ agenda(sk ).
cases,
/ agenda(sk ), infer agenda(sk ) agenda(sm ).
arguments show state(sk ) = state(sm ) agenda(sk ) = agenda(sm ).
Hence, sk = sm sk = succ(sk1 , hei1 , ..., eim i). Therefore, ordering functions : {1, ..., m} {1, ..., m}, O(i) = i, sk = succ(sk1 , heO(i1 ) , ..., eO(im ) i),
thus Stepk -step sk1 sk .

Theorem 9. Let P = (I, G, A) temporal planning problem, = he1 , ..., en
causally valid plan P, : {1, ..., n} Q relaxed scheduling function .
exists valid temporal plan P.
624

fiITSAT: Efficient SAT-Based Temporal Planner

Proof. using bubble sort algorithm, sort events increasing order
according values given . algorithm takes two consecutive members
sequence, swaps value first one greater
second one. continues swaps whole sequence properly sorted. Let ei
ej two events swapped bubble sort stage algorithm (assume
ei located ej sequence prior swapping). Then, must (i) > (j).
Thus, according (S-1), know ei ej swappable (c.f., Definition 12).
result, whole sequence causally valid plan prior swapping, would
causally valid plan swapping. means sorting according values
given result another causally valid plan, say . plan obviously satisfies
two conditions Definition 9, therefore, ( , ) valid temporal plan P.

Theorem 10. Let P = (I, G, A) solvable temporal planning problem, COM
set every member either compressible towards start compressible
towards end (Definition 13). exists valid temporal plan (, ) P
causally valid plan P, compressed respect COM, relaxed
scheduling function .
Proof. Let 1 = e1 , ..., ei , ei+1 , ..., en causally valid plan P ei ei+1
two swappable events. Let 2 = e1 , ..., ei+1 , ei , ..., en result swapping ei ei+1
1 . show relaxed scheduling function 1 , relaxed
scheduling function 2 .
Consider two events ej ek 2 , ej located ek . j 6= + 1
k 6= i, 1 , ej definitely located ek , too, therefore property
(S-1) holds ej ek . hand, j = + 1 k = i, ej ek
swappable therefore property (S-1) trivially holds ej ek .
Assume ej starting event particular action a, ek pairing
event ej 2 . Definition 8, easily infer 2 , ei located
ej ek , ei cannot starting ending event a. Similarly,
ei+1 located ej ek , ei+1 cannot starting ending event
a. hand, since ei ei+1 swappable, know cannot
events action, therefore, either j 6= + 1 k 6= i. Thus,
swapping ei ei+1 cannot falsify fact ej ek pairing events.
words, 1 , too, ek pairing event ej . implies property (S-2)
holds ej ek .
Let ( , ) arbitrary valid temporal plan P. Since scheduling function
, obviously regarded relaxed scheduling function . showed
Section 3.2, transformed causally valid plan compressed
respect COM, series swaps, swapping occurs pair
consecutive swappable events. Therefore, must relaxed scheduling function
, (, ) valid temporal plan P, scheduling function
.
625

fiRankooh & Ghassem-Sani

P
Theorem 11. Let P = (I, G, A) temporal planning problem,
= {e1 , ..., en }




set events P, l three formulae l , l , l (defined Section
P 4),
non-empty causally valid plan P obtained solving l . Let = (S , , , x0 , )
FSM accepts subsequence = he1 , ..., em ,
l encoding
presented (-1) (-6). exist model l
l
= plan(M ).
Proof. give proof contradiction. Assume exists model l
l
= plan(M ). Let f : {1, ..., m} {1,P
..., n} function i,
f (i) equal index i-th event . Moreover, let g : {1, ..., m} {1, ..., l}
function i, g(i) equal step number SAT variable
l corresponds i-th event . Assume x0 , ..., xm sequence states
0 < m, xi = (xi1 , ef (i) ). Since accepts , must
f (1),g(1)

xm . satisfies (-5), (x0
) = true. Here, two cases
considered. case 1: g(2) = g(1). case, since = plan(M ), f (1) < j < f (2),
g(1)
must (ej ) = f alse. Now, considering ( 1) ( 2), infer
g(2),f (2)

(x1
) = true. Case 2: g(2) > g(1). case, considering ( 1) ( 2),
g(1),n+1
infer (x1
) = true. by, considering ( 4), deduce
g(1)+1,0
(x1
) = true. argument plus considering ( 3) show
g(2),f (2)
g(i),f (i)
(x1
) = true. whole deduction repeated show (xi1
) = true
g(m),f (m)

1 m. Therefore, (xm1
) = true. Since xm = (xm1 , ef (m) ),
E {e
considering ( 1), infer j, ej Em
n+1 }

g(m),j


) = true. However, since xm ,
{ef (m)+1 , ..., ej1 } (Em Em ) = , (xm
contradicts assumption satisfies ( 6).
P
Theorem 12. Let P = (I, G, A) temporal planning problem,
= {e1 , ..., en }



set events P, l three formulae l , l , l (defined
Section 4). Let model satisfies l , = he1 , ..., em = plan(M ). Let
P
= (S , , , x0 , ) FSM accept subsequence ,
l


encoding composed (-1) (-6). exists model l l
= plan(M ).
Proof. Let us introduce total order relation SAT variables l correspond


events input problem. two sat variables eki eki , eki eki
one following two conditions holds: 1) k < k . 2) k = k < .
Assume f : {1, ..., m} {1, ...,Pn} function i, f (i) equal
index i-th event . Moreover, assume g : {1, ..., m} {1, ..., l}
function k, g(k) equal step number SAT variable l
corresponds k-th event . Let uk,i = heu , ..., et denote subsequence
following properties:
g(t)

(ef (t) ) = true.
626

fiITSAT: Efficient SAT-Based Temporal Planner

g(t)





k ef (t) eki eki , (eki ) = f alse.
fact, uk,i substring spans u-th event last event
whose corresponding SAT variable located eki l . define model
l
l following rules:
(R-1) SAT variable v l , (v) = (v).
(R-2) 1 k l 1 n, (xk,i
0 ) = true.
(R-3) 1 k l, 1 < n, xs , (xk,i
) = true iff j, sequence
jk,i transforms x0 xs .
(R-1), infer satisfies l . show satisfies
formulae (-1) (-6), thereby, satisfies
l .
xk,j
arbitrary formula (-1). (eki ) = f alse
(-1) Let eki xk,i


k,i
k
(xk,i
) = f alse, formula trivially satisfied. Assume (ei ) = (xs ) =
k,i
true. (R-3), u, sequence u transforms x0 xs . Since
eki ekj , way defined uk,j , deduce uk,j = uk,i hei , ()
denotes concatenation operator sequence events {ei+1 , ..., ej1 }.
(-1), (xs , ei ) = xt , therefore ei causes transit xs
xt . Besides, {ei+1 , ..., ej1 } Etout = , thus, member cause
transit state xt . Therefore, uk,j transforms x0 xt ,
(xk,j
) = true. Hence, formula satisfied.
k,j
arbitrary formula (-2). (eki ) = true
(-2) Let eki xk,i
xs
k
(xk,i
) = f alse, formula trivially satisfied. Assume (ei ) = f alse
k,i
(xk,i
) = true. (R-3), u, sequence u transforms x0 xs .
k,j
Since eki ekj , way defined u , deduce uk,j = uk,i ,
sequence events {ei+1 , ..., ej1 }. Besides, {ei+1 , ..., ej1 } Esout = ,
thus, member cause transit state xs . Therefore,
uk,j transforms x0 xs , (xk,j
) = true. Hence, formula satisfied.
k,i
k,0
(-3) Let xk,0
xs arbitrary formula (-3). (xs ) = f alse, formula
trivially satisfied. Assume (xk,0
) = true. (R-3), u,
k,0
sequence u transforms x0 xs . Since ek0 eki , way defined uk,i ,
deduce uk,i = uk,0 , sequence events {e1 , ..., ei1 }.
Besides, {e1 , ..., ei1 }Esout = , thus, member cause transit
state xs . Therefore, uk,i transforms x0 xs , (xk,i
) = true.
Hence, formula satisfied.

(-4) Let xk,n+1
xk+1,0
arbitrary formula (-4). way defined


k+1,0
) =
, deduce uk,n+1 = uk+1,0 every u. Therefore, (xk,n+1
u

k+1,0

(xs
). Hence, formula satisfied.
(-5) According (R-2), formula (-5) directly satisfied , .
627

fiRankooh & Ghassem-Sani

(-6) Let xk,i arbitrary formula (-6). Accorrding assumptions, uk,i
cannot cause transit accepting states. Since x , (R-3)
implies (xk,i ) = f alse. Hence, formula satisfied.

Theorem 13. Let N = xi1 , ..., xim negative cycle STN corresponding
causally valid plan = e1 , ..., en temporal problem P, xik node corresponding event eik . Let another causally valid plan P. subsequence
member LN (defined Section 5), corresponding STN N
negative cycle.
Proof. Let ei1 , e2,1 ..., e2,k2 , ei2 , ..., eim1 , em,1 , ..., em,km , eim subsequence ,
ej,1 , ..., ej,kj string symbols j , 1 < j m. Consider two arbitraty events
eij eij sequence, ij < ij . show temporal constraints
(eij ) (eij ) present (ij ) (ij ).
constraint (ij ) < (ij ), scheduling constraint (S-1)
explained Section 5, eij eij swappable. Besides, , eij clearly
located eij . Consequently, must (ij ) < (ij ) according
scheduling constraint (S-1).
constraint (ij ) (ij ) = dur(a), scheduling rule (S-2), eij
eij starting event ending event a, respectively. Moreover,
j < j < j , action(eij ) 6= a. indicates j < j j ,
Oj , therefore eij
/ j . Since ej ,1 ..., ej ,k string symbols j ,
j
conclude , yet ended reaching eij . means eij
eij pairing events . Thus, scheduling constraint (S-2),
(ij ) (ij ) = dur(a).
shows edge xij xij corresponding STN present
corresponding STN , thus latter STN N negative cycle.

References
Allen, J. F. (1984). Towards general theory action time. Artif. Intell., 23 (2),
123154.
Armando, A., & Giunchiglia, E. (1993). Embedding complex decision procedures inside
interactive theorem prover. Ann. Math. Artif. Intell., 8 (3-4), 475502.
Benton, J., Coles, A. J., & Coles, A. (2012). Temporal planning preferences
time-dependent continuous costs. Proceedings Twenty-Second International
Conference Automated Planning Scheduling, ICAPS 2012, Atibaia, Sao Paulo,
Brazil, June 25-19, 2012.
Biere, A. (2009). P{re,i}cosat@sc09. solver description SAT competition 2009. SAT
2009 Competitive Event Booklet.
628

fiITSAT: Efficient SAT-Based Temporal Planner

Biere, A. (2013). Lingeling, Plingeling Treengeling entering sat competition 2013.
Proceedings SAT Competition 2013.
Blum, A., & Furst, M. L. (1997). Fast planning planning graph analysis. Artif.
Intell., 90 (1-2), 281300.
Castellini, C., Giunchiglia, E., & Tacchella, A. (2003). SAT-based planning complex
domains: Concurrency, constraints nondeterminism. Artif. Intell., 147 (1-2), 85
117.
Coles, A. J., Coles, A., Fox, M., & Long, D. (2009). Extending use inference
temporal planning forwards search. Proceedings 19th International Conference Automated Planning Scheduling, ICAPS 2009, Thessaloniki, Greece,
September 19-23, 2009.
Coles, A. J., Coles, A., Fox, M., & Long, D. (2010). Forward-chaining partial-order planning. Proceedings 20th International Conference Automated Planning
Scheduling, ICAPS 2010, Toronto, Ontario, Canada, May 12-16, 2010, pp. 4249.
Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). Introduction Algorithms
(3. ed.). MIT Press.
Cushing, W., Kambhampati, S., Mausam, & Weld, D. S. (2007). temporal planning
really temporal?. IJCAI 2007, Proceedings 20th International Joint Conference Artificial Intelligence, Hyderabad, India, January 6-12, 2007, pp. 18521859.
Dechter, R., Meiri, I., & Pearl, J. (1991). Temporal constraint networks. Artif. Intell.,
49 (1-3), 6195.
Do, M. B., & Kambhampati, S. (2003). Sapa: multi-objective metric temporal planner.
J. Artif. Intell. Res. (JAIR), 20, 155194.
Een, N., & Biere, A. (2005). Effective preprocessing SAT variable clause
elimination. Theory Applications Satisfiability Testing, 8th International
Conference, SAT 2005, St. Andrews, UK, June 19-23, 2005, Proceedings, pp. 6175.
Ernst, M. D., Millstein, T. D., & Weld, D. S. (1997). Automatic sat-compilation planning
problems. Proceedings Fifteenth International Joint Conference Artificial
Intelligence, IJCAI 97, Nagoya, Japan, August 23-29, 1997, 2 Volumes, pp. 1169
1177.
Eyerich, P., Mattmuller, R., & Roger, G. (2009). Using context-enhanced additive
heuristic temporal numeric planning. Proceedings 19th International Conference Automated Planning Scheduling, ICAPS 2009, Thessaloniki,
Greece, September 19-23, 2009.
Fox, M., & Long, D. (2002). PDDL+: Modelling continuous time-dependent effects.
Third International NASA Workshop Planning Scheduling Space.
Fox, M., & Long, D. (2003). PDDL2.1: extension PDDL expressing temporal
planning domains. J. Artif. Intell. Res. (JAIR), 20, 61124.
Fox, M., & Long, D. (2007). note concurrency complexity temporal planning.
26th Workshop UK Planning Scheduling Special Interest Group.
629

fiRankooh & Ghassem-Sani

Garrido, A., Fox, M., & Long, D. (2002). temporal planning system durative actions
PDDL2.1. Proceedings 15th Eureopean Conference Artificial Intelligence,
ECAI2002, Lyon, France, July 2002, pp. 586590.
Gerevini, A., Saetti, A., & Serina, I. (2006). approach temporal planning scheduling domains predictable exogenous events. J. Artif. Intell. Res. (JAIR), 25,
187231.
Gerevini, A., & Schubert, L. K. (1998). Inferring state constraints domain-independent
planning. Proceedings Fifteenth National Conference Artificial Intelligence
Tenth Innovative Applications Artificial Intelligence Conference, AAAI 98,
IAAI 98, July 26-30, 1998, Madison, Wisconsin, USA., pp. 905912.
Halsey, K. (2004). CRIKEY! Co-ordination Temporal Planning. Ph.D. thesis, University Durham.
Halsey, K., Long, D., & Fox, M. (2004). Multiple relaxations temporal planning.
Proceedings 16th Eureopean Conference Artificial Intelligence, ECAI2004,
including Prestigious Applicants Intelligent Systems, PAIS 2004, Valencia, Spain,
August 22-27, 2004, pp. 10291030.
Haslum, P. (2006). Improving heuristics relaxed search - analysis TP4
HSP*a 2004 planning competition. J. Artif. Intell. Res. (JAIR), 25, 233267.
Haslum, P., & Geffner, H. (2000). Admissible heuristics optimal planning. Proceedings Fifth International Conference Artificial Intelligence Planning Systems,
Breckenridge, CO, USA, April 14-17, 2000, pp. 140149.
Helmert, M., & Geffner, H. (2008). Unifying causal graph additive heuristics.
Proceedings Eighteenth International Conference Automated Planning
Scheduling, ICAPS 2008, Sydney, Australia, September 14-18, 2008, pp. 140147.
Hoffmann, J., Gomes, C. P., Selman, B., & Kautz, H. A. (2007). SAT encodings statespace reachability problems numeric domains. IJCAI 2007, Proceedings
20th International Joint Conference Artificial Intelligence, Hyderabad, India, January 6-12, 2007, pp. 19181923.
Hoffmann, J., & Nebel, B. (2001). planning system: Fast plan generation
heuristic search. J. Artif. Intell. Res. (JAIR), 14, 253302.
Huang, R., Chen, Y., & Zhang, W. (2009). optimal temporally expressive planner:
Initial results application P2P network optimization. Proceedings
19th International Conference Automated Planning Scheduling, ICAPS 2009,
Thessaloniki, Greece, September 19-23, 2009.
Huang, R., Chen, Y., & Zhang, W. (2012). SAS+ planning satisfiability. J. Artif. Intell.
Res. (JAIR), 43, 293328.
Kautz, H. A., & Selman, B. (1992). Planning satisfiability. ECAI, pp. 359363.
Kautz, H. A., & Selman, B. (1996). Pushing envelope: Planning, propositional logic
stochastic search. Proceedings Thirteenth National Conference Artificial
Intelligence Eighth Innovative Applications Artificial Intelligence Conference,
AAAI 96, IAAI 96, Portland, Oregon, August 4-8, 1996, Volume 2., pp. 11941201.
630

fiITSAT: Efficient SAT-Based Temporal Planner

Long, D., & Fox, M. (2003). Exploiting graphplan framework temporal planning.
Proceedings Thirteenth International Conference Automated Planning
Scheduling (ICAPS 2003), June 9-13, 2003, Trento, Italy, pp. 5261.
Lu, Q., Huang, R., Chen, Y., Xu, Y., Zhang, W., & Chen, G. (2013). SAT-based approach
cost-sensitive temporally expressive planning. ACM TIST, 5 (1), 18.
Mali, A. D., & Liu, Y. (2006). T-satplan: SAT-based temporal planner. International
Journal Artificial Intelligence Tools, 15 (5), 779802.
Rankooh, M. F., & Ghassem-Sani, G. (2013). New encoding methods sat-based temporal
planning. Proceedings Twenty-Third International Conference Automated
Planning Scheduling, ICAPS 2013, Rome, Italy, June 10-14, 2013.
Rintanen, J. (2006). Compact representation sets binary constraints. ECAI 2006,
17th European Conference Artificial Intelligence, August 29 - September 1, 2006,
Riva del Garda, Italy, Including Prestigious Applications Intelligent Systems (PAIS
2006), Proceedings, pp. 143147.
Rintanen, J. (2007). Complexity concurrent temporal planning. Proceedings
Seventeenth International Conference Automated Planning Scheduling, ICAPS
2007, Providence, Rhode Island, USA, September 22-26, 2007, pp. 280287.
Rintanen, J. (2012). Planning satisfiability: Heuristics. Artif. Intell., 193, 4586.
Rintanen, J., & Gretton, C. O. (2013). Computing upper bounds lengths transition
sequences. IJCAI 2013, Proceedings 23rd International Joint Conference
Artificial Intelligence, Beijing, China, August 3-9, 2013.
Rintanen, J., Heljanko, K., & Niemela, I. (2006). Planning satisfiability: parallel plans
algorithms plan search. Artif. Intell., 170 (12-13), 10311080.
Robinson, N., Gretton, C., Pham, D. N., & Sattar, A. (2009). Sat-based parallel planning
using split representation actions. Proceedings 19th International Conference Automated Planning Scheduling, ICAPS 2009, Thessaloniki, Greece,
September 19-23, 2009.
Robinson, N., Gretton, C., Pham, D. N., & Sattar, A. (2010). Partial weighted MaxSAT
optimal planning. PRICAI 2010: Trends Artificial Intelligence, 11th Pacific
Rim International Conference Artificial Intelligence, Daegu, Korea, August 30September 2, 2010. Proceedings, pp. 231243.
Shin, J.-A., & Davis, E. (2005). Processes continuous change SAT-based planner.
Artif. Intell., 166 (1-2), 194253.
Smith, D. E., & Weld, D. S. (1999). Temporal planning mutual exclusion reasoning.
Proceedings Sixteenth International Joint Conference Artificial Intelligence,
IJCAI 99, Stockholm, Sweden, July 31 - August 6, 1999. 2 Volumes, 1450 pages, pp.
326337.
Streeter, M. J., & Smith, S. F. (2007). Using decision procedures efficiently optimization.
Proceedings Seventeenth International Conference Automated Planning
Scheduling, ICAPS 2007, Providence, Rhode Island, USA, September 22-26, 2007,
pp. 312319.
631

fiRankooh & Ghassem-Sani

Vidal, V. (2014). Yahsp3 Yahsp3-mt 8th international planning competition.
International Planning Competition.
Vidal, V., & Geffner, H. (2006). Branching pruning: optimal temporal POCL
planner based constraint programming. Artif. Intell., 170 (3), 298335.
Wehrle, M., & Rintanen, J. (2007). Planning satisfiability relaxed -Step plans.
AI 2007: Advances Artificial Intelligence, 20th Australian Joint Conference
Artificial Intelligence, Gold Coast, Australia, December 2-6, 2007, Proceedings, pp.
244253.
Younes, H. L. S., & Simmons, R. G. (2003). VHPOP: Versatile heuristic partial order
planner. J. Artif. Intell. Res. (JAIR), 20, 405430.

632


