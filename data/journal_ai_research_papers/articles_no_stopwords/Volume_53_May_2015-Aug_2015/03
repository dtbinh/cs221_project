journal artificial intelligence

submitted published

placement loading stations electric vehicles
detours necessary
stefan funke
andre nusser

funke fmi uni stuttgart de
nusser fmi uni stuttgart de

universitat stuttgart
institut fur formale methoden der informatik
stuttgart germany

sabine storandt

storandt cs uni freiburg de

albert ludwigs universitat freiburg
institut fur informatik
freiburg germany

abstract
compared conventional cars electric vehicles evs still suffer considerably
shorter cruising ranges combined sparsity battery loading stations complete transition e mobility still seems long way go consider
placing loading stations possible shortest path
sufficiently many run energy model
introduce heuristics provide close optimal solutions even large road networks

introduction
battery powered electric vehicles evs important means towards reduction
carbon dioxide emissions recharged renewable energies e g solar wind
power despite environmental advantages evs still wait breakthrough
main reason limited cruising range often less km together
sparsity battery loading stations blss trip b ev
nowadays non trivial undertaking locations blss taken account
many destinations completely range
hence early phase e mobility important goal establish network
blss ev becomes worry free enterprise modern blss require
little space see figure left illustration placed almost everywhere
generates costs natural objective minimize number installed blss
previous work storandt funke heuristic proposed determine bls
locations one get anywhere anywhere road network without
running energy choosing suitable route unfortunately
guarantees connectivity reasonability routes fact even rather close
destinations routes one recharging stop possible might require long
detours several recharging stops due placement blss related
lam leung chu suffers similar drawbacks long run e mobility
prevail road trip ev undertaken without unreasonable detours
c

ai access foundation rights reserved

fifunke nusser storandt

figure inner city battery loading station left image feasible loading station cover
small map cut right image

introduced ask placement blss
shortest path enough blss get stranded starting fully loaded
battery typically case gas stations conventional cars call
set bls locations ev shortest path cover esc define respective
optimization follows
definition ev shortest path cover esc given di graph g v e edge costs
c e r function path decides whether path traveled
along without recharging ev determining minimum subset l v
blss every shortest path wrt c traveled without running energy
called ev shortest path cover
see figure right idea valid esc looks remainder
define n v e otherwise noted consider sake
clearer presentation assume unique shortest paths enforced
standard techniques symbolic perturbation describe deal ambiguous shortest paths towards end function captures energy
characteristics network considered vehicle typically mountainous areas
roads rough surfaces minimal paths ev runs energy
considerably shorter flat terrain downhill experiments determined
energy consumption road segment e v w e elevations h v h w
distance e max h w h v weighting parameter dependent
ev energy consumption determined euclidean distance
height differences similar energy model used previous work artmeier haselmayr
leucker sachenbacher disregarding energy recuperation negative edge costs
function compares path accumulated energy consumption along edges
evs battery capacity b r determine recharging necessary note
one could employ kind monotonous function approaches introduce
following work notwithstanding particular choice


fiplacement loading stations electric vehicles

contribution
describe model esc instance hitting set
sets shortest paths require least one battery recharge allows
us use developed solving hitting set e g standard greedy
unfortunately turns difficulty computing esc solution
already instance construction n n v shortest paths network
extracting storing naively requires much time space practical
therefore design shortest path extraction representation techniques
allow tackle even large road networks moreover develop several refinements
heuristics provide feasible esc solutions efficiently priori
approximation guarantee shown solutions prove posteriori
instance lower bounds real world instances actual approximation ratio
small constant
extended version original funke nusser storandt b
present following insights regarding esc prove esc np hard even hard approximate proven hardness motivation
justification development heuristic furthermore explain
transform shortest paths one newly developed representation another along
theoretical run time analysis experiments ability transform representations allows flexibility might prove useful applications
compact representations shortest paths used describe simple minimality
checks shortest paths deciding whether need considered respective hitting set instance especially large networks checks reduce number shortest
paths stored significantly addition provide details involved
lower bound constructions finally lay methods dealing ambiguous shortest
paths augmenting already existing loading station set case loading
station locations restricted subset nodes network

theoretical analysis
let us first prove esc np hard hope efficient
solve esc optimality unless p np hence remainder
focus designing compute good approximate solutions
theorem hardness ev shortest path cover esc np hard
prove np hardness esc solution size preserving reduction vertex cover
vc one classical np hard use following definition
notation vc
definition vertex cover given graph g v e goal vertex set c v
minimal cardinality e e e c
prove theorem ability solve esc efficiently implies
ability solve vc efficiently well hence esc np hard otherwise
would contradiction np hardness vc end construct given


fifunke nusser storandt

























figure left vertex cover instance optimal solution size red circled nodes
right respective esc instance constructed inserting auxiliary edge per
node graph left augmenting edges cost circled
nodes indicate optimal hitting set path cost least unhit

vc instance gvc vvc evc corresponding instance esc specified g v e c
follows
v vvc e evc e esc instance initially contains nodes edges
vc instance
v v add auxiliary vertex v auxiliary edge v v g
e e set costs c e uniformly
true paths consisting less three edges false otherwise e every
shortest path traverses least three edges loading station
make set loading stations feasible esc
construction requires polynomial time size gvc figure illustrates
transformation vertex cover instance esc instance small example
first vertex cover solution gvc esc solution esc
instance constructed described
lemma vertex cover c gvc yields esc l g c l c
proof let c vvc vc solution gvc esc graph g contains corresponding
vertex every v vvc simply set l c obviously l c remains
placing loading stations according l every shortest path g traveled
without running energy assume contradiction exists shortest path
g consisting three edges u v v w w x neither v w l every
edge e evc least one two vertices l l c vertex cover
evc follows v w auxiliary edge present g
gvc auxiliary edges cannot middle path containing three edges
every auxiliary vertex degree every path consisting three edges contains
loading station hence l valid esc
complete proof theorem valid esc solution leads
valid vertex cover solution well


fiplacement loading stations electric vehicles

lemma esc l g c yields vertex cover c gvc c l
proof let l valid esc solution l might contain auxiliary vertices construct
c replacing every auxiliary vertex v l respective original vertex v v
might part l conclude c l c valid vertex
cover gvc prove every edge v w evc v w c
assume contradiction exists edge v w evc v w c
accordingly neither v w respective auxiliary vertices v w part
esc solution l implies shortest path v v v w w w three edges
loading station g contradicts l valid esc solution conclude
every edge v w c therefore c valid vertex cover
l optimal solution esc obviously c l fulfilled lemma
placing loading station auxiliary vertex v corresponding original vertex v
time renders loading station v superfluous hence optimal solution
never vertices v v l combination lemma showed
every instance vc construct polynomial time instance esc
optimal solution translates optimal solution vc instance
size straightforward manner therefore hardness vc carry
esc proves theorem furthermore rules existence
polynomial time approximation schemes esc via proven apx hardness factor
better vc dinur safra
corollary esc cannot approximated better
proven hardness efficient solve esc optimality
might difficult design unless one make use certain aspects battery
capacity parameter road network characteristics

modeling esc hitting set
following aim good approximation heuristics solve
esc practice particular exploit fact esc modeled
instance well known hitting set therefore suitable
hitting set computations transfer esc classical hitting set hs defined
follows
definition hitting set given set system u u universe elements
collection subsets u goal minimum cardinality subset l u
set hit least one element l e l
case u consists nodes road network possible bls locations
set composed vertex sets shortest paths excluding
fully charged battery suffice reach function characterizes
paths energy consumption traversing exceeds battery capacity
b r call paths b violating clearly need consider set minimal
paths supersets hit automatically theorem shows hitting set formulation
indeed solves esc see figure illustration


fifunke nusser storandt

v

b

l
l

v

l


b


b


b


v





figure shortest path exhibits b violating prefix v marked red
according hitting set formulation loading station l
subpath vehicle fully reloads l argumentation applies
subpath l illustrated picture cutting prefix
l every layer final path b violating anymore therefore
originally considered path traveled visiting three indicated
loading stations blue bs mark nodes battery fully loaded
e charge level equal battery capacity

theorem correctness hitting set formulation leads feasible esc solution
e placing loading stations according hitting set solution l every shortest
path g traversed ev without running energy according
proof let shortest path g b violating let ev
fully loaded let v minimal b violating prefix prefix
hit loading station l l l l v demanded hitting set
formulation ev reach l v minimal b violating prefix l
appears v v l ev fully charged hence whole argumentation
transfers subpath l applying argument recursively ev finally
reach loading station suffix path longer b violating
therefore ev reach via without running energy

note precision loss reformulating esc hitting set
instance since every solution esc feasible solution exactly cardinality
respective hitting set instance
point common hitting set solving techniques applied solve esc e g
standard greedy greedy repeatedly picks node hitting
far unhit sets adds solution terminates soon sets
hit solution computed greedy guaranteed ln approximation chvatal ignore lower order term
application number sets system upper bounded number shortest
paths graph therefore n hence greedy provides
ln n approximation guarantee running time greedy depends
crucially fast access far unhit sets round


fiplacement loading stations electric vehicles
























figure cut ch graph black edges original edges blue edges indicate shortcuts red node labels reflect contraction order example
moment node labeled contracted shortcut node node
inserted shortest path went right side
search space query leftmost rightmost node illustrated
green edges gout purple edges gin

remainder investigate efficient construction set
system different path extraction representation schemes study influence
greedy

basics practical esc computation
determine suitable bls positions first construct set shortest paths
ev would run energy according computing shortest path
two nodes one nodes classically performed dijkstras
shortly called dijkstra large street networks dijkstra slow
process large number queries necessary application though
therefore instrument speed techniques developed accelerating shortest path
queries achieve better running times approaches particular employ
contraction hierarchies ch geisberger sanders schultes delling
purpose basic idea behind ch augment graph g v e set e
called shortcuts span large sections shortest paths shortcuts instead
original edges allows dramatic reduction operations dijkstra run
central operation ch preprocessing node contraction considering
graph g v e node v contracted goal remove v g without
affecting shortest path distances remaining nodes achieved
creating additional shortcut edges neighbors v follows every pair
neighbors u w v u v v w e shortcut u w created cost
path uvw uvw shortest path u w resulting graph
v removed necessary shortcuts added exhibits shortest path distances
original graph ch preprocessing phase instruments node contraction first
assigning label l v n node nodes contracted increasing label
order contracted nodes constructed set shortcuts e way


fifunke nusser storandt

return preprocessing phase ch graph g v e e original
graph augmented shortcuts labeling see figure left example
according labels original shortcut edges v w referred upwards
l v l w downwards otherwise paths called downwards consist
exclusively edges type shown way created shortcuts
node pair v shortest path exists g g v e e
decomposed upward path starting followed downward path ending
highest node path wrt l called peak node following property
path allows restrict bidirectional dijkstra run gout gin refer
subgraphs g containing upwards paths starting downwards paths
ending respectively figure right subgraphs illustrated resulting
optimal path found bidirectional dijkstra costs shortest path
original graph representation path different path
consists partly shortcuts get shortest path original graph
unpacking procedure applied every shortcut two edges original shortcut
directly spans memorized ch construction thus unpacking one
recursively replace shortcuts spanned edges original edges identified
note ch scheme employed represent shortest path
concisely replacing many subpaths possible shortcuts call
representation ch path experiments turns ch paths
extremely economic representation scheme shortest paths
one shortest path phast delling goldberg
nowatzyk werneck takes advantage ch preprocessing scheme
first phase nodes gout source v settled via dijkstra run
second phase downward edges v w relaxed decreasing order induced l w
thereby computing correct distances nodes v second phase simply sweep
subset edges requires linear time correctness phast
fact every node shortest path decomposed
upwards path contained nodes settled first phase downwards
path set downwards edges forms directed acyclic graph labels l w
induce topological order sweep edges order assures moment
edge v w relaxed node v already settled hence phast computes exact shortest
path distances nodes network note single shortest path query
phast method choice techniques pure ch dijktra computations
normally run time clearly sublinear number edges practice

construction set system
section investigate several strategies extract set system given esc
instance e set minimal shortest paths g b violating along
different extraction strategies present different ways represent store respective
set shortest paths discuss advantages disadvantages representations


fiplacement loading stations electric vehicles

naive extraction
simplest comes mind compute shortest path tree via dijkstra
every v identify nodes tree accumulated energy cost values
b nodes priority queue dijkstra settled predecessors
already belong b violating paths abort exploration source
respective paths search tree backtracked stored e g complete
vertex sets small exploration radii small bounds b practical

larger b space consumption n n n v enormous assuming average

path length n even store dijkstra search tree v via
predecessor labels still space consumption n course could easily
achieve linear space consumption number b violating paths storing
source vertex target vertex path want access
nodes certain path run dijkstra computation network
huge sets paths computing nodes demand
time intensive matter representation use store paths time
complexity n n log n e naive extraction already limits usability
real world instances n log n runtime one dijkstra run
fact main difficulty hitting set type street
networks example speed techniques shortest path queries transit nodes
tn bast funke matijevic hub labeling hl abraham delling goldberg
werneck hitting certain set shortest paths well methods
complete instance construction impractical therefore several custom tailored
heuristics developed allow efficient computation without explicitly constructing
arz luxen sanders setting differs significantly
setting poses additional criterion c identifying paths contained hence
distance bound employed setting leads set equal length paths
scenario due different energy consumption driving uphill downhill
lengths minimal b violating paths differ vastly unfortunately tn hl
related heuristics carry setting therefore need explore
ways extracting storing shortest path sets
phast extraction
large bounds b finding b violating paths source node resembles one
shortest path phast explicitly designed solve task efficiently
paths backtrack respective search tree ch representation e
consist partly shortcuts huge advantage compared conventional paths
terms storage shortcuts spanning large portions shortest path
number nodes ch path significantly smaller two orders magnitude
street network germany downsides though nodes processed
second phase phast l order increasingly distance hence incorporating
b stopping criterion seems difficult moreover b large leads paths
vastly differing lengths n lower bound accumulated runtime phast
every source might already large overhead hence propose different
strategy ch potential significantly faster


fifunke nusser storandt

p

b











g


g

p





















figure left schematic representation ch graph height nodes indicating contraction order blue marked peak p g gin p colored
red g gout p colored green note nodes bottom
layer g g empty nothing done practice
true nodes right energy cost labels black assigned
g g resulting two dijkstra runs starting blue node
resulting intervals nodes g expressed purple example
search matching targets source node labeled g intervals
reveal node labeled g suitable candidate

peak node mapping pnm
large number b violating paths originate source v exploring
paths dijkstra phast time consuming core idea pnm
enumerate b violating paths completely different taking ch representation
paths consideration explained shortest ch paths unimodal respect
labeling l node maximal label called peak intuitively nodes
high label appear shortest paths peaks fact real world graphs
nodes highest level constitute peaks reasonably long shortest paths
gives rise path enumeration explores paths source
peak resulting dramatically reduced search spaces majority nodes
pnm works follows consider one one every node
p v potential peak shortest paths peak p contain nodes
smaller label need search upwards paths ending p downwards paths
starting p prefix suffix candidates respective subgraphs ch graph
g containing paths called g gin p g gout p see figure left
illustration conventional dijkstra run g g typically
sparse reveals distances p contained nodes interested
combinations shortest upward paths g shortest downward paths g
leading minimal b violating paths testing naively expensive therefore
construct p interval tree berg cheong kreveld overmars
nodes g interval b associate node denotes range
possible energy consumption values path prefix p g p p
minimal b violating path intervals easily computed single pass
dijkstra search tree g see figure right example every possible


fiplacement loading stations electric vehicles

figure illustration three methods representing storing shortest paths stored
elements colored orange left complete vertex set
middle shortcut set ch path heights vertices image correspond l value right triple consisting source target
peak vertex

source g query interval tree set targets time log g
storing resulting paths quadruples p c p c p note
employment interval trees make use special choice different choices
interval computation procedure adapted
filtering nodes processed set b violating paths
unfortunately shortest paths concatenation two shortest paths p
p need shortest path remains filter set
appropriately achieved distance oracles quasi constant look
time e g provided hl another pass nodes role peak
pruning quadruple shorter path found p p note pruning
already employed construction phase intermediate path set sizes
become large final set paths stored list triples p even
compact representation ch representation figure visual comparison
provided storing path vertex set shortcut set pnm triple
accessing nodes respective shortest path g required greedy
hitting set longer trivial sophisticated representation schemes
though therefore develop suitable adaptions greedy work
ch representations pnm triples section
minimality checks
mentioned introducing hitting set formulation esc need extract
store minimal b violating shortest paths e paths subpath b violating
well adding non minimal paths set system course invalidate
solution increases complexity storing sets running time greedy
later
naive extraction scheme b violating path sv vk identified dijkstra run might minimal path might still b violating without
prefix precisely check path remains b violating removing
first edge v dont include respective dijkstra run
considering v source ensure b violating path missed


fifunke nusser storandt

phast extraction minimality check becomes complex
paths ch representation might direct access first edge path
original graph path starts shortcut unpack first
shortcut performing minimality check
pnm prefix suffix deletion might lead subpath still b violating
immediately decision favor triple p check first edge
path p last edge path p removal
destroy property path b violating phast paths
ch representation construction therefore unpack shortcuts first
transformability
note extraction scheme tie us certain path representation fact
mentioned representations vertex sets source target pairs ch paths triples
converted especially transformation vertex sets ch paths
turn favorable ch paths yield fair trade space consumption
applicability greedy explained detail section
provide details transformations including theoretical transformation times
latter assume complete vertex set representation contains k elements
source target pairs vertex sets given complete path computed via
dijkstra run g backtracking requiring n log n time
vertex sets ch paths assume ch labels l v n available
recursive procedure allows turn vertex set ch path first
identify node v vertex set highest l value peak
split vertex set prefix v suffix v
sub paths search node highest l value providing us
v v two nodes connected v via direct edge shortcut chgraph nodes contracted v v v v
provides us prefix nodes v suffix nodes v
recurse stops prefix suffix
prefix monotonously increasing wrt l suffix monotonously
decreasing see figure top illustration assuming ch representation
contains h shortcuts transformation performed k h
ch paths pnm triples need extract peak vertex besides
source target done h ch path consists h shortcuts
pnm triples ch paths given source target peak p run dijkstra
starting p g gin p g gout p settled
number edges ch graph assumed runtime single
transformation n log n transformation source targetpairs vertex sets typically peak small l value small g
g peak high l value generates many paths amortized
costs per path considerably smaller


fiplacement loading stations electric vehicles

figure vertex sets ch paths back first row vertex set given
l values derived ch construction indicated vertex elevations
recursively vertex highest l value marked red images
prefix suffix path extracted shortcuts added span
path sections lower l value second row ch path recursively
unpacked shortcuts colored blue red arrows point replacement
edges next unpacking step final path started
first row contain shortcuts

ch paths vertex sets given ch path apply unpacking method
described section e recursively replace shortcuts spanned edges
path consists original edges see figure bottom resulting
path consists k vertices unpacking performed k
vertex sets source target pairs first last vertex complete
path stored rest neglected transformation costs k
consider deletion k elements well
following longer investigate source target pair representation
storing pnm triples requires one item per path time allows
efficient access paths vertices

greedy hitting set computation
explained greedy natural strategy solve hitting set
approximately theoretically yields solutions within factor ln n
optimum setting practice greedy performs much better theoretical
priori approximation guarantee implies
simplest set system representation application greedy hitting
set straightforward requires deliberate operations set
system path representations see following
complete vertex sets
paths simply given set contained vertices single scan
sets determine best node hitting paths another scan remove paths


fifunke nusser storandt

hit selected node two scans combined one
updating counter values removing newly hit paths initial count
still necessary unfortunately space consumption enormous
making single scan quite expensive
ch paths
representing minimal b violating paths ch paths could convert single
paths original paths unpacking shortcuts operate complete
vertex set path note paths would processed one one one
unpacked path would kept memory time much better strategy
uncompressing every single ch path get original node sets maintaining
usage counter edge counting many shortest paths use edge first
scan edges ch paths set system hit incrementing respective
counters traverse shortcut edges graph decreasing order
construction ch preprocessing incrementing counters spanned edges
node counters maintained identify maximum node derived final
scan original non shortcut edges keeping reverse information edges
spanned shortcut allows identification sets hit
node update edge counters removing ch paths set picking
node requires one scan edges push counts non shortcut
edges one scan usage counters one scan set ch paths
peak node triples
paths described triples source target peak node get chpath representation described section proceed ch path
representation note ch path representation computed demand
peak every round avoid keeping paths ch representation permanently memory

multi stage construction
country sized graphs even improved set system extraction methods representations reduce space time consumption enough practical therefore
introduce procedure interleaves set extraction greedy hitting set
computation multi stage multi stage requires significantly
less space complete construction set system therefore applied
considerably larger instances
nested hitting sets
instance esc determined battery capacity b make
following important observation every capacity b b hitting set l
instance corresponding b feasible original instance enough blss
smaller battery capacity suffices larger battery capacity example
b kwh solving e g b kwh would feasible well
construction l b b might considerably faster due smaller exploration


fiplacement loading stations electric vehicles




















b b b



b b b



b b b







b


















figure battery capacity b kwh shortest path needs
hit loading station exhibits energy costs conventional
construction complete path would part hitting set instance
three lower images illustrate happens use nested construction different values b red purple dashed subpath indicates
minimal b violating path starting brown square possible hitter
path purple dashed blue path indicates minimal b b violating
path starting brown square path subpath matter b chosen hitting blue purple path large dot image
assures b violating paths hit well nodes marked brown
squares part final solution

radii l typically much larger necessary instance defined b
simply solution b kwh although real battery capacity b kwh
expect many superfluous loading stations
another advantage first quickly computing hitting set small value
b allows us construct smaller instance feasible hitting
set l feasible original defined b l hopefully much
smaller l second instance defined set paths originating l
b b violating
prove lemma hitting set l second instance indeed
hitting set original instance
lemma given battery capacity b second capacity b b let l feasible
esc solution b l feasible hitting set minimal shortest b b violating
paths originating l l valid esc solution battery capacity b
proof consider b violating path original instance must hit
node v l less b away path v hitter
target prefix thereof constructed path set b b violating
paths originating l therefore subpath hitter l hence l hits bviolating shortest path makes l valid esc solution battery capacity b figure
illustrates proof small example


fifunke nusser storandt

path cover
small values b even compute hitting sets without exploration
evaluation function purely connectivity structure graph
called k hop path cover funke nusser storandt generalization
vertex cover construct set vertices c v directed
necessarily shortest k hop path g contains least one vertex c k
simply vertex cover c esc solution b b maximal energy
cost k hop path easily upper bounded k times maximal energy
cost edge values k takes minutes even large graphs
variant depth first search making step negligible overall running time
combination
implementation combined nested hitting sets k hop path covers multistage procedure constructing sequence hitting sets lr lr l l sequence
values br br b b finally returning l hitting set given
instance
first br k hop cover small value k subsequent solutions
apply nested hitting set choose bi manually might
loss terms quality compared greedy full set system due
nested construction experimental evaluation though loss terms
quality pronounced running times drastically improved
graph sizes handle much larger

refinements lower bounds
section introduce speed strategy greedy independent employed set representation develop construct
instance lower bounds esc solution bounds helpful
experimental evaluation prove posteriori running
computed solutions fact pretty close optima
multiple hitters heuristic
even non naive representations considerable work involved picking
next best node greedy might worthwhile add several
nodes hitting set round normally pick node hits
far unhit sets refrain picking nodes round picking
first node influences hit counters others hand pick nodes
interfere quality solution decline severely
one way achieve generate list nodes sorted ascending order
hit counters picking first one going list selecting next
nodes shortest path distances least nodes already picked
appropriately chosen e g upper bound longest shortest path
b violating thereby make sure path set increased hit counter two
nodes picked one round


fiplacement loading stations electric vehicles

figure set seven node disjoint b violating paths highlighted grey small example graph every valid hitting set b violating paths graph
contain least seven vertices vertex hit one grey
marked paths therefore size set node disjoint paths feasible lower
bound optimal hitting set size

simple instance lower bounds
evaluate quality heuristics would compare outcome
optimal solution optimal value typically unknown instead compare
good easily computable lower bound study transit nodes eisner funke
rather involved lower bound proposed takes effort comparable
solving hitting set propose much simpler alternative suffices
purposes product generation set system obtain
set node disjoint b violating paths two paths set non empty
intersection clearly feasible solution must contain extra node per path set
hence size set node disjoint paths yields valid lower bound see figure
illustration
case generate set system explicitly use nested hitting sets
greedily extract set node disjoint paths running dijkstra computations
random sources adding b violating paths set long intersect
previously selected ones size set provides valid lower bound time

dealing real world settings
throughout made assumptions esc sake
clean definition easier descriptions assumptions necessarily
met practice explain following adapt still perform
well real world settings


fifunke nusser storandt

ambiguous shortest paths
exposition assume uniqueness shortest paths section
discuss necessary modifications case shortest paths ambiguous
first enforce uniqueness shortest paths symbolic perturbation
end define cost path v v vk sum c edge costs
vector c v v vk two cost vectors compared lexicographically
two paths sv sw aggregated edge
costs minimal vi wi considered shorter vi wi otherwise
considered shorter symbolic perturbation easily incorporated e g
dijkstras computation shortest paths node consider
possibly tentative distance label node v aggregated edge costs
ds v along respective path tuple ds v preds v preds v denotes
predecessor current path v ordering case identical ds v values
determined node id predecessor edge relaxations well organization
priority queue made according augmented distance labels easy
see yields canonical unique shortest paths described
edge lengths typically measured precision around one meter rarely happens two paths exhibit exactly length circumstances though
might desirable actually maintain multiple shortest paths nodes hitting
allowing travel along without running energy fortunately adapt cater shortest paths minimal
change backtracking dijkstra exploration well pnm
slight change ch construction former retrieve paths sets instead
following predecessor reference node v set edge relaxation
inspect adjacent nodes check whether distance labels respective edge
cost sums distance label v yields neighbors v lie shortest
path v recursing neighbors obtain shortest paths ch
construction crucial operation contraction node v original version
every pair neighbors u w v u v v w e shortcut u w created
cost path uvw uvw shortest path u w maintain
shortest paths add shortcut uvw shortest path u w possible
existence shortest paths way every shortest path ch representation
comes cost slightly shortcuts added
lower bound construction section modified yield lower bound
case ambiguous shortest paths follows pair contribute
lower bound shortest paths require least one recharging event
compute valid lower bound retrieve maximal set vertex pairs
two vertex pairs set respective shortest path node sets allowed overlap
generalizes idea node disjoint shortest paths case ambiguous shortest paths
experiments showed though considering shortest paths yield
noticeably different mainly due rarity reasonably long ambiguous shortest
paths disregard ambiguities implementation extremely small
battery capacities corresponding cruising range less km found ambiguous


fiplacement loading stations electric vehicles

shortest paths covered bls placement larger battery capacities
bls placement fact covered ambiguous shortest paths
restricted loading station placement
assume esc definition loading stations placed every
node network practice though set possible locations might restricted
due technical financial legal reasons set v v candidate nodes
loading stations incorporate follows construction
set system check every shortest path whether least one nodes
v otherwise ignore path completely never hit anyway
ch extraction methods set flag every edge shortcut indicating whether
spanned path contains node v allows perform check
ch path without unpack actual hitting set computation simply
skip nodes v compute feasible solution
note depending choice v final hitting set might allow drive
shortest paths without running energy though incorporate
locations suitable become loading stations others without losing global
reachability demanded esc formulation introduce prize function
p v r higher prize complicated expensive place
charging station node exploit weighted hitting set
basis computations goal set l elements
p universe
hit sets set system minimizing accumulated prize p l
set system extraction methods remain unaffected prizes greedy hitting
set computation step selection next best hitter changes previously selected
node next hits far unhit sets v denotes set far unhit
sets contain v select node minimizes average prize per set p v v
approximation guarantee greedy weighted hitting set
unweighted hitting set chvatal expect
solution consist mainly cheap charging stations possibly expensive ones
required establish reachability two nodes
placement given initial loading station set
another assumption made esc definition try construct
network loading stations scratch e starting loading stations
loading stations still sparse many areas ones already installed
ignored existing loading stations easily taken account solving
esc given initial set loading stations l check extraction
set system path already hit l case path
pruned remaining steps hitting set computation work

experimental evaluation
proposed techniques computing esc solutions evaluated multi threaded
implementation written c executed nd generation intel core desktop hard

fifunke nusser storandt

ware cores gb ram complete set generations
cores gb ram multi stage construction nested hitting sets use
following abbreviations state k seconds minutes h hours
days gb bytes distinguish cpu time total cpu usage real time
wall clock time several road networks germany derived openstreetmap data
region
pforzheim
tubingen
baden wurttemberg south
southern germany
germany

abb
pf
tu
bw
sg
ge

v






e






table test graph characteristics
osm used evaluation see table overview edge cost function
c used travel time along edge paths hit indeed quickest paths
term shortest paths conventionally used subsuming kinds metrics energy consumption ev modeled explained introduction distance data
osm elevations provided shuttle radar topography mission nasa b
corresponds battery capacity translates certain terrain dependent cruising
range use capacity b pf tu allows drive kilometers average
kilometers larger graphs much going uphill
increases energy consumption equals
dealing complete set systems
construction representation let us first examine time space complexity
extracting complete set minimal b violating paths constructed set systems
naive strategy naive representing path complete sequence
vertices phast exploration phast paths ch representation
peak node mapping pnm representing path source peak target triple
respective found table unfortunately two smallest instances
feasible process strategies already bw graph time space
consumption naive exploded extrapolated gb cpu
days comparison phast factor faster naive space
consumption ch paths improvement least order magnitude pnm
construct bw instance cpu hours compared week needed phast
space consumption triples decreases another factor note longer
paths advantage pnm vs ch representation increases sg ge
phast pnm took much time space e g extrapolated gb days
phast larger networks constructing complete set systems seems infeasible

comparison path representations explained section path extraction
scheme tie us path representation instead transform extracted


fiplacement loading stations electric vehicles

graph

pf
tu
bw
graph

pf
tu
bw

paths





space consumption
naive
phast
pnm
vertex sets ch paths
triples
gb
gb
gb
gb
gb
gb
gb
gb gb

computation time
naive
phast
pnm
cpu
real
cpu
real
cpu
real
h
h

h
h
h
h


h
h

table comparison path extraction representation schemes b corresponds
km pf tu km bw cruising range flat terrain timings include
ch construction phast pnm values brackets extrapolated

paths introduced representations storing representation
provides trade space consumption access times single paths figure
illustrates values small large benchmark instance tu ger
note access times paths represented triples amortized really
want extract single path costs comparable ones
representation greedy require access huge sets paths
every round p representation pays ch representation access
times reported figure purely completeness significant
greedy hitting set computation though specialized greedy ch paths
require unpack paths fact access times relevant greedy
even ones vertex set representation ch representation
contains far less elements sweep hence regard ch paths best
path representation soon set system fits memory representation
transformation times two path representations estimated
reported figure well every transformation runs constant linear
time according analysis cost less comparable accessing paths vertex
set representation transformation time ch paths vertex sets vice versa
corresponds access time paths ch representation transform triples
ch paths need time access path triple form minus time unpack
ch path
hitting set computation evaluated standard greedy well
multiple hitters mh variation set systems pf tu bw varying choices
b figure shows performance terms quality standard greedy vs mh
well running time much faster mh compared standard greedy ratios
averaged test graphs bound b chosen almost zero percent


fifunke nusser storandt

figure comparison several path representation schemes terms space consumption access time axes log scale

maximum energy consumption shortest path respective network fact
long paths set systems got simple greedy even constructed optimum
hence approximation ratio figure cases greedy produces much
closer optimum theoretical ln n guarantee maximum deviation
lower bound indeed less employing mh strategy increases hs size
slightly yields significantly decreased running times especially smaller bounds b
hitters chosen still compared construction time
set systems hitting set computation times negligible state
explicitly change employ multi stage construction though
multi stage construction
construction complete set system proven infeasible larger road
networks make use idea multi stage construction
k hop cover pnm let us first examine compact set system constructed
pnm initial k hop path cover bw network
computed k hop cover c nodes corresponds esc solution
b cruising range km flat terrain pnm used
create final compact set system considering b b violating paths start
nodes c surprisingly number paths hit reduces drastically
table table running times still quite high though
save exploration peak therefore stages


fiplacement loading stations electric vehicles



runtime ratio


quality greedy
quality mh
runtime greedy runtime mh
















approximation factor












percentage max b





figure performance greedy multiple hitters variant mh
averaged pf tu bw
graph
bw
sg
ge

c




b




cpu
h
h
h

real

h
h

paths




table instance creation b k via pnm initial k hop solution c k
help much since improvements terms running time pnm
multi stage cannot expected let us concentrate naive
extracted paths converted ch representation
multi stage hitting sets employ following strategy first construct k hop cover
c e g k yields initial hitting set lr bound br
construct reduced set system consisting br br violating paths starting
nodes lr compute hitting set lr set system use naive
graph
tu
sg
tu
sg
ge
ge
ge

br


k
k
k
k
k

bi nested hs
k k k
k k k
k k
k k
k k k
k k k
k k k k

l








lb








apx








cpu








real








table multi stage hitting set computation lb lower bound apx approximation
factor last two experiments seen detail table



fifunke nusser storandt






p

bi
k
k
k
k







p

bi
k
k
k
k
k

tss





tss







paths





paths







ths





ths







li
k
k
k


li
k
k
k




cpu





cpu







table statistics stage run starting k hop cover stage construction initialized k hop cover ge column
paths gives number sets hit respective stage tss ths
denote cpu time set system construction hitting set computation
respectively

extraction transform vertex sets ch paths efficient storage proceed
iteratively reaching b b final hitting set l l intuitive demand
gap b b large make sure last hitting set
instance still faithfully characterizes original hitting set instance table shows
choices multi stage parameters table give detailed
account intermediate calculations large ge graph experiments confirm
larger gap b b better quality final hitting
set comes cost expensive last stage though contrast
experiments first two calculations table conducted without initial
k hop cover obtained tu sg suggest initial k hop cover
accelerates calculation maintaining similar hitting set size furthermore
apx values remain low even though lower bounds obtained naive way
note example graph germany priori approximation guarantee
plain greedy feasible due excessive running time space
consumption ln n proves excellent quality hitting sets
particular instances table shows introducing multiple stages keeps intermediate
set systems rather compact efficient computation actually possible

conclusions future work
showed model solve natural important facility location
e mobility context taking radically different previous ones avoiding
detours loading stations evs


fiplacement loading stations electric vehicles

naive strategy allows solution small instances hundred
thousand nodes compact representation schemes underlying set systems
heuristic modifications standard greedy make computation solution
even country sized networks germany possible instance lower bounds
certify solution quality close optimal within factor far
pessimistic theoretically achievable approximation bound fact remarkable
possible compute approximate solution seemingly intractable hitting
set within hours quadcore desktop pc computation determined
around locations placing blss would establish complete coverage germany
framework require metric decides shortest paths
hit identical metric determines paths shortest fact
factored function depending application scenario
used implement hitting criteria e g hop distances risk values
future work intend examine exact hitting requirement relaxed
naturally necessary bls right respective shortest
path nearby one suffices could modeled enlarging vertex sets
respective shortest paths surrounding vertices hitting set sizes variant
expected considerably smaller hitting shortest paths directly another
direction take account capacity constraints blss lam et al
particular urban areas certainly necessary provide recharging stations
large number vehicles

references
abraham delling goldberg v werneck r f hierarchical hub
labelings shortest paths european symposium esa pp
springer
artmeier haselmayr j leucker sachenbacher shortest path
revisited optimal routing electric vehicles german conference
artificial intelligence ki pp
arz j luxen sanders p transit node routing reconsidered international
symposium experimental sea pp springer
bast h funke matijevic ultrafast shortest path queries via transit
nodes shortest path th dimacs implemenation challenge vol
dimacs series discrete mathematics theoretical computer science pp
providence ri ams
berg cheong kreveld v overmars computational geometry
applications rd ed edition springer verlag telos santa clara
ca usa
chvatal v greedy heuristic set covering math oper res



fifunke nusser storandt

delling goldberg v nowatzyk werneck r f f phast hardwareaccelerated shortest path trees international parallel distributed processing
symposium ipdps pp
dinur safra hardness approximating minimum vertex cover
annals mathematics
eisner j funke transit nodes lower bounds refined construction
engineering experiments alenex
funke nusser storandt k path covers applications
international conference large databases vldb
funke nusser storandt b placement loading stations electric
vehicles detours necessary aaai conference artificial intelligence
geisberger r sanders p schultes delling contraction hierarchies
faster simpler hierarchical routing road networks international workshop
experimental wea pp springer
lam leung w chu x electric vehicle charging station placement
international conference smart grid communications smartgridcomm pp

nasa shuttle radar topography mission online http www jpl nasa gov srtm
osm openstreetmap project online http www openstreetmap org
storandt funke enabling e mobility facility location battery loading
stations conference artificial intelligence aaai




