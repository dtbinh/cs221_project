Journal Artificial Intelligence Research 50 (2014) 487-533

Submitted 12/13; published 06/14

Improving Delete Relaxation Heuristics Explicitly
Represented Conjunctions
Emil Keyder

emilkeyder@gmail.com

Jorg Hoffmann

hoffmann@cs.uni-saarland.de

Saarland University
66123 Saarbrucken, Germany

Patrik Haslum

patrik.haslum@anu.edu.au

Australian National University & NICTA
Canberra ACT 0200, Australia

Abstract
Heuristic functions based delete relaxation compute upper lower bounds
optimal delete-relaxation heuristic h+ , paramount importance
optimal satisficing planning. introduce principled flexible technique
improving h+ , augmenting delete-relaxed planning tasks limited amount
delete information. done introducing special fluents explicitly represent
conjunctions fluents original planning task, rendering h+ perfect heuristic h
limit. Previous work introduced method growth task
potentially exponential number conjunctions introduced. formulate alternative technique relying conditional effects, limiting growth task linear
number. show method still renders h+ perfect heuristic h
limit. propose techniques find informative set conjunctions introduced
different settings, analyze extend existing methods lower-bounding upperbounding h+ presence conditional effects. evaluate resulting heuristic
functions empirically set IPC benchmarks, show sometimes much
informative standard delete-relaxation heuristics.

1. Introduction
Planning heuristic search one successful approaches planning.
informative heuristic functions domain-independent planning obtained
estimated cost delete relaxation original planning task. delete
relaxation simplifies planning tasks assuming every variable value, achieved,
persists execution rest plan. cost optimal plan
resulting relaxed planning task, denoted h+ , NP-complete compute, however whether
plan delete-relaxed task exists checked polynomial time (Bylander,
1994). satisficing planning, heuristic admissible,
latter fact exploited upper-bound h+ , generating necessarily optimal
plan delete-relaxed task (Hoffmann & Nebel, 2001). optimal planning, lowerbounding methods devised based analysis landmarks, logical formulas
set actions state necessary properties delete-relaxed plans (Karpas &
c
2014
AI Access Foundation. rights reserved.

fiKeyder, Hoffmann, & Haslum

Domshlak, 2009; Helmert & Domshlak, 2009). cost estimates delete-relaxed
task used guide heuristic search state space original task.
Since delete relaxation heuristics first proposed (Bonet & Geffner, 2001), much
work done improve them. One approach focuses better approximation
schemes h+ , obtaining tighter upper bounds thus better non-admissible estimates
(Hoffmann & Nebel, 2001; Keyder & Geffner, 2008, 2009), tighter lower bounds
correspond informative admissible heuristics (Helmert & Domshlak, 2009; Bonet
& Helmert, 2010). many domains, however, important heuristic able
take account delete information (Hoffmann, 2005), indeed long tradition
works proposing heuristics so. Several extend delete relaxation
capture strictly information (Fox & Long, 2001; Helmert, 2006; Helmert & Geffner,
2008; Cai, Hoffmann, & Helmert, 2009; Katz, Hoffmann, & Domshlak, 2013),
consider delete relaxation attempt find low-conflict relaxed plans (Baier &
Botea, 2009), generate modified heuristic values based taking conflicts account
extent (Do & Kambhampati, 2001; Gerevini, Saetti, & Serina, 2003). Here,
approach problem taking inspiration admissible hm family heuristics
(Haslum & Geffner, 2000). important property heuristics introduce, shared
recent work direction, technique renders h+ perfect
heuristic h limit. words, technique offers trade-off amount
delete information considered computational overhead so. one end
continuum, delete-relaxed plans become plans original task.
hm heuristic function considers cost making true simultaneously sets fluents
size m. cost planning task estimated recursively taking cost
set fluents, goal set action preconditions, cost
costly subset size m, ignoring cost achieving remaining fluents
set. possible subset size fluents task must considered,
size representation required compute hm exponential m. hm heuristics
provide guarantee exists hm = h (trivially satisfied
total number fluents task). However, value required achieve
usually large make computing h method infeasible practice.
hm heuristic recently recast hmax = h1 cost planning task
deletes (Haslum, 2009). achieved representing conjunctions fluents c
size original task new fluents c , called -fluents, modifying
initial state, goal, operators planning task capture reasoning
performed hm sets within computation hmax . However, h+ (m )
admissible (since separate copy action may needed establish
-fluent), thus compilation useful obtaining admissible estimates
informative h+ . recent C construction (Haslum, 2012) fixes
issue (introducing action copy every subset -fluents may established),
cost growing task representation exponentially number -fluents rather
linearly representation. hand, C offers possibility
fine-grained tradeoff representation size heuristic accuracy, allowing
choice arbitrary set conjunctions C corresponding -fluents (which need
size). stands contrast hm heuristic compilation,
sets conjunctions size represented.
488

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

Haslum (2012) proposed repeatedly solve C optimally, within iterative procedure
adds new conjunctions set C iteration. relaxed plans
computed therefore gradually become closer, sense, plans original
task. instead explore idea using kind construction obtaining heuristic
functions guiding search.
C
introduce related construction C
ce similar , makes use
conditional effects limit growth task worst case linear, rather
exponential, |C|. gain size comes price information loss relative
C . However, show, information loss affect fundamental property
tending towards perfect heuristic h enough conjunctions introduced:
C , C
ce perfect limit, i. e. always exists set conjunctions C

h+ (C
ce ) = h . Furthermore, information may lost, always case.
Indeed, possible construct families planning tasks C
ce represent
+
C
heuristic function C set conjunctions C, i. e., h+ (C
ce ) = h ( ),
C
representation ce occupies exponentially less space.
said that, theoretical advantage C
ce tend materialize practice
(or least commonly used benchmarks): without optimizations C
indeed grows quickly practical, turns mutex pruning techniques (eliminating compiled actions conflicting preconditions) extremely effective keeping
C
size C bay. therefore consider C
ce , evaluating usefulness
devising improved heuristic functions. focus two main questions:
(A) obtain upper lower bounds h+ compiled tasks?
(B) choose set conjunctions C maximize information gained
addition planning task?
response question (A), analyze extend three state-of-the-art methods
estimating h+ . satisficing setting (upper-bounding h+ ), consider problem
finding low-cost relaxed plans scheduled minimize cost
sequence actions required trigger given set conditional effects, avoiding unnecessary
repeated applications action. problem scantily addressed
previous work. show problem optimal action scheduling given
set effects NP-complete, generalize approximation technique used
planner (Hoffmann & Nebel, 2001).
optimal setting (lower-bounding h+ ), consider LM-cut heuristic (Helmert
& Domshlak, 2009) well admissible heuristics based fluent landmarks (Karpas
& Domshlak, 2009). former, findings mostly negative: First, show
even though introduction -fluents cannot decrease hmax h+ , lowerand upper-bound LM-cut, respectively, LM-cut heuristic value decrease. Second,
show neither two straightforward adaptations LM-cut algorithm
problems conditional effects maintains admissibility domination hmax .1
latter, show C
ce used generate informative fluent landmarks.
Recent work (Keyder, Richter, & Helmert, 2010) extracts landmarks task.
1. sophisticated adaptation LM-cut, based idea context splitting, recently
proposed ? (?). maintains properties.

489

fiKeyder, Hoffmann, & Haslum

allows discovery -fluent landmarks corresponding conjunctive landmarks
original task, suffers due large number -fluents must considered.
C
ce compilation offers possibility discovering interesting conjunctive landmarks
unbounded size, avoiding growing size compilation unnecessarily.
response question (B), devise range strategies depending purpose
C
C
ce compilation used. parameterized terms
allowed growth compiled task relative original task, thus allow
trade-off informativeness heuristic computational overhead.
evaluate resulting heuristics wide range benchmarks International Planning Competition, varying relevant algorithm parameters determine individual
effect performance. results show, several domains heuristics much
informative previous ones, leading significantly improved performance.
next define basic concepts (Section 2), moving formal definition

C
C
ce compilation previously introduced compilations (Section 3).
C

C
Section 4, analyze ce relation theoretical perspective.
Section 5 discusses practical issues arise using compilations purpose
satisficing planning, describes obtained experimental results, Section 6
case optimal planning. Finally, Section 7 summarizes main points
paper indicates possible future research directions.

2. Preliminaries
planning model based propositional STRIPS formalization, add
action costs conditional effects. States operators defined terms set F
propositional variables, fluents. state F given set fluents
true state. planning task described 4-tuple = hF, A, I, Gi, F
set variables, set actions, F initial state, G F
describes set goal states, given {s | G s}. action consists
4-tuple hpre(a), add(a), del(a), ce(a)i, pre(a), add(a), del(a) subsets F .
action cost cost(a) R+
0 . ce(a) = {ce(a)1 , . . . , ce(a)n }, denote set
conditional effects action a, triple hc(a)i , add(a)i , del(a)i subsets
F . simplify notations, require add(a) del(a) = ; need
impose restrictions deletes del(a)i conditional effects, conditional
effects used within delete relaxation. ce(a) = A,
conditional effects, say STRIPS planning task.
action applicable pre(a) s. result applying given
[
[
s[a] = (s \ (del(a)
del(a)i )) (add(a)
add(a)i )
{i|c(a)i s}

{i|c(a)i s}

plan sequence
Pn actions = a1 , . . . , whose application results goal
state. cost i=1 cost(ai ). optimal cost minimal among plans
s; often denote optimal plans . plan called plan ,
simply plan.
heuristic function h mapping states R+
0 . perfect heuristic

h maps state cost optimal plan s. heuristic h admissible
490

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

h(s) h (s) s. h(0 ), denote heuristic function whose value
given estimating cost corresponding state s0 modified task 0 . specify
0 terms transformation = hF, A, I, Gi 0 = hF 0 , A0 , 0 , G0 i; s0 obtained
applying transformation used obtain 0 I. sometimes useful
make explicit h heuristic computed itself; denote h().
Note modified task 0 used computation heuristic function.
particular, actual search plan performed state space original
planning task .
delete relaxation + planning task obtained discarding delete
effects. Formally, + = hF, A+ , I, Gi, A+ = {hpre(a), add(a), , ce+ (a)i | A},
ce+ (a) = {hc(a)i , add(a)i , | ce(a)i ce(a)}. cost action a+ A+
cost corresponding action cost(a). optimal delete relaxation heuristic h+
defined cost h (+ ) optimal plan + .
denote power set F P(F ) = {c | c F }. context hm ,
C
, C
ce , refer fluent subsets c P(F ) sets conjunctions interchangeably.
Throughout paper, assume conjunctions non-unit, i. e., |c| > 1.
landmark planning task logical formula set fluents F
every valid plan makes true state (Hoffmann, Porteous, & Sebastia, 2004).
Orderings landmarks statements order states occur.
natural ordering 1 n 2 means state sj satisfies 2 , state si
occurring sj 1 satisfied. necessary ordering 1 nec 2 means 1
always true state immediately state 2 becomes true,
greedy necessary ordering 1 gn 2 means relationship holds first time
2 made true. Note necessary ordering 1 nec 2 implies greedy necessary
ordering 1 gn 2 , vice versa. landmark graph G directed graph whose
nodes landmarks, whose labelled edges correspond known orderings
landmarks.

3. , C C
ce Compilations
compilation (Haslum, 2009) first technique proposed made use
idea -fluents explicitly represent conjunctions original task. Given
conjunction c F , c new fluent c 6 F unique c, i. e., c 6= c0 c 6= c0 .
defining compilations discuss, use shorthand X C =
X {c | c C c X}, X F set fluents, C P(F ) set
conjunctions. words, X C consists set fluents X itself, together new
fluents c whose intention represent conjunctions c C contained X,
c X.
Definition 1 (The compilation) Given STRIPS planning task = hF, A, I, Gi
parameter Z+ , planning task hF C , AC , C , GC i, C = {c | c
F 1 < |c| m}, AC contains well action ac pair A, c C
del(a) c = add(a) c 6= , ac given del(ac ) = , ce(ac ) = ,
pre(ac ) = (pre(a) (c \ add(a)))C
add(ac ) = add(a) {c0 | c0 C c0 (add(a) c)}
491

fiKeyder, Hoffmann, & Haslum

parameter indicates maximum size conjunctions represented
explicitly resulting compiled task. -fluent inserted (by definition F C , cf.
above) c F 1 < |c| m. c added fluent sets
task (such initial state, action preconditions, goals) containing associated
set c. Furthermore, linear (in |C|) number representatives action added
task model situation elements c made true
already true applied, adds remaining fluents c deleting
none them, thereby making every fluent c, therefore c , true. compilation
allows admissible hm cost original task computed hmax cost
compiled task.
non-admissibility h (m ) = h+ (m ) due construction action representatives ac : Sets fluents simultaneously made true single application
action may require several representatives explicitly achieve
effect . Consider example action adding fluent p state q
r already true. makes fluents p, q, r true simultaneously, whereas
2 , two different representatives required: one c = {p, q} adding {p,q} ,
one c = {p, r} adding {p,r} .
C compilation solves problem instead creating number representatives exponential number -fluents may made true a.
representatives corresponds application makes set -fluents
true (Haslum, 2012). Following example, separate representatives would
introduced -fluent sets , {{p,q} }, {{p,r} }, {{p,q} , {p,r} },
representative resulting last could applied make two -fluents
true simultaneously. C differs allows choice set C P(F ),
introduces fluents c c C, rather subsets size
m:2
Definition 2 (The C compilation) Given STRIPS planning task = hF, A, I, Gi
set non-unit conjunctions C P(F ), C planning task hF C , AC , C , GC i,
0
AC contains action aC pair A, C 0 C c0 C 0 ,
(1) del(a) c0 = add(a) c0 6= ,
(2) c C((c c0 add(a) c 6= ) = c C 0 ),
0

0

0

aC given del(aC ) = , ce(aC ) = ,
[
0
pre(aC ) = (pre(a)
(c0 \ add(a)))C
c0 C 0
C0

add(a ) = (add(a) (pre(a) \ del(a)))C {c0 | c0 C 0 }
2. three differences definition Haslums (2012) definition actions
C . First, Haslums definition features delete effects, ensuring real (non-relaxed) plans correspond
plans original task. Since consider delete relaxations compiled task, safely
omit these. Second, allow sets C 0 used construction actions contain conjunctions c
0
c add(a) (pre(a) \ del(a)); third, add(aC ) contains -fluents c c pre(a) \ del(a).
latter two differences keep definitions simpler. redundant action representatives
redundant add effects cause easily pruned practice.

492

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

0

representatives aC enforce, every c0 C 0 , part c0 deleted,
0
non-added part c0 true already aC executed. Constraint (2)
0
ensures form non-redundancy: aC adds -fluent c0 , adds -fluents
c c c0 , fluents c necessarily become true application
action. Note that, differently , add effects C include -fluents representing
conjunctions fluents added action prevail fluents (non-deleted preconditions).
necessary admissibility h+ (the primary purpose C ), needed
computation h1 (the primary purpose ).
C enumerates possible subsets C constructing representatives
action therefore grows exponentially |C|. exponentiality reminiscent
canonical conditional effects compilation used convert planning tasks conditional
effects classical STRIPS planning tasks exponentially actions (Gazen &
Knoblock, 1997). C
ce compilation introduce result applying
roughly reverse transformation C , resulting closely related planning task
linear (in |C|) number conditional effects:
Definition 3 (The C
ce compilation) Given STRIPS planning task = hF, A, I, Gi
C
C
C
C
set non-unit conjunctions C P(F ), C
ce planning task hF , Ace , , G

C
C
C
C
AC
ce = {hpre(a ), add(a ), del(a ), ce(a )i | A},

aC given
pre(aC ) = pre(a)C
add(aC ) = (add(a) (pre(a) \ del(a)))C
del(aC ) =
ce(aC ) = {h(pre(a) (c \ add(a)))C , {c },
| c C c del(a) = c add(a) 6= }
Rather enumerating sets -fluents may made true action, C
ce
uses conditional effects implicitly describe conditions made true.
information lost information encoded cross-context -fluents
preconditions, appear action representatives C , preconditions
C 0
effect conditions corresponding actions C
ce . action representatives
0
C , -fluents pre(aC ) exists c C 0 s.t. (c \ add(a))
pre(a). situation discussed above, example, {q,r} precondition action
representative adds {p,q} {p,r} C , appear condition
conditional effects corresponding action C
ce . Since effect conditions
determined individually c , conditions never included. return
discussing theoretical relationship C C
ce .
Example 1 Consider STRIPS planning task (adapted Helmert & Geffner, 2008)
variables {x0 , . . . , xn , y}, initial state = {x0 , y}, goal G = {xn }, unit-cost actions
: h, {y}, ,

bi : h{xi , y}, {xi+1 }, {y},
493

fiKeyder, Hoffmann, & Haslum

= 0, . . . , n 1.
optimal solution planning task takes form b0 , a, b1 , a, . . . , bn1 ,
cost 2n1. delete relaxation task, fact deleted application
bi ignored, optimal plan cost n.
-fluent xi ,y introduced C
ce compilation, added precondition
action bi , new conditional effects ce(a)i form h{xi }, {{xi ,y} }, created
action a. conditional effects added b-actions, deletes
therefore cannot achiever -fluent. increases optimal delete relaxation
cost task 1, new instance must added relaxed plan achieve
newly introduced precondition bi . -fluents form {xi ,y} introduced,
delete relaxation cost C
ce becomes 2n 1, optimal cost.
set conjunctions renders delete relaxation cost C perfect (i. e.,
2n 1). However, size C given conjunction set exponential n: action
may principle achieve subset conjunctions, every subset C 0 induces
0
separate representative aC AC .
Regarding compilation, h2 = hmax (2 ) gives optimal cost task.
However, computation requires consideration (n2 ) fluent pairs, rather
linear number -fluents need introduced C
ce . shall see (Theorem 6), example easily extended must scale n hm become
C

perfect, thus showing exponential separation C
ce .
important practical optimization C C
ce mutex pruning. mutex
information original planning task available, specifically given (some)
m-tuples fluents reachable conjunction, discard
compiled task action representatives conditional effects require
m-tuple, without losing admissibility compilation. Namely, value h+ (C )
(respectively h+ (C
ce )) mutex pruning bounded value
0
0
0
h+ (C ) (respectively h+ (C
ce )) larger set C C conjunctions: include

-fluents size m, h mutexes found, i. e., none respective fluents reachable compiled task. Exploiting available mutex information allows us
make compilation informed without add additional -fluents,
helping keep compilation small.
Another optimization use eliminate dominated preconditions. Whenever add
fluent c precondition action, condition conditional effect,
remove condition fluents p c -fluents {c0 | c0 c}.
achieving c implies achieving fluents well, methods count cost
separately (such as, example, hadd related heuristics) would incur overestimation.
Note, however, eliminate duplication caused -fluents representing different fluent sets non-empty intersection. Consider, example,
action pre(a) = {p, q, r}. C = {{p, q}, {q, r}}, pre(a) = {{p,q} , {q,r} },
cost achieving q implicitly counted twice hadd estimate cost
applying a. possible solution, considered replacing overlapping -fluents c , c0
cc0 . This, however, consistently improve heuristics compute
compiled tasks.
494

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

4. Theoretical Properties C
ce
+
C
discuss theoretical properties C
ce , considering cost h (ce )
optimal solutions instead practical approximations (note C
ce version
C considered here, h+ = h delete effects present). proof sketches
shown, full proofs found Appendix A. first show fundamental
expected property:

Theorem 1 (Consistency admissibility) h+ (C
ce ) consistent admissible.
Proof: Regarding consistency, given s, s[a] = s0 , need show
+
C
0
0C
0C C .
h+ (C
ce )(s) cost(a) + h (ce )(s ). Let (s ) optimal plan
ce
0C sC [aC ] C task
aC (s0C ) necessarily plan sC C
ce ,
ce
deletes. Admissibility follows consistency together fact h+ (C
ce )(s) = 0
goal states s.
Furthermore, (ideal) delete relaxation lower bound improve add -fluents:
Theorem 2 (h+ (C
ce ) grows monotonically C) Given planning task sets
0
+
C0
C C non-unit conjunctions, h+ (C
ce ) h (ce ).
C
C
0
Proof: follows fact given plan = aC
1 , . . . , an0 for0 ce , 0 =
0
0
0
C
C
C
C
C
C
a1 , . . . , constitutes plan ce . show induction [a1 ] . . . [ai ]
C
0
C0
C0 =
C [aC
1 ] . . . [ai ] \ {c | c C \ C }, shows result since goal ce G
GC \ {c | c C \ C 0 }, GC sC [] valid plan.
0
= 0, induction hypothesis holds since C = C \ {c | c C \ C 0 } definition.
0
0
0
0
C
C
C
C0
C
0
> 0, aC
applicable [a1 ] . . . [ai1 ] since pre(ai ) = pre(ai ) \ {c | c C \ C },
0
0
0
C
0
C
C C
C [aC
1 ] . . . [ai1 ] [a1 ] . . . [ai ] \ {c | c C \ C } induction hypothesis.
C
C
C
C
C
C
{c | c (I [a1 ] . . . [ai ] \ [a1 ] . . . [ai1 ]) c C 0 }, either c add(ai )C ,
0
C0
implies c add(aC
) due definition ce , exists conditional effect
C
0
cej (aC
) = h(pre(a) (c \0 add(a))) , {c }, i. Since c C , must exist 0corresponding
0
C
C0
conditional effect ce definition, condition must true C [aC
1 ] . . . [ai1 ]
induction hypothesis.

special case C 0 = , Theorem 2 gives us:
+
Corollary 1 (h+ (C
ce ) dominates h ()) Given planning task set non-unit
+
C
+
conjunctions C, h (ce ) h ().

domination strict, follows trivially convergence h (Theorem 5 below).
consider relationship C C
ce compilations. mentioned
above, information encoded cross-context preconditions lost moving
C
exponential C linear C
ce . Estimates obtained ce may therefore inferior
obtained C :
Theorem 3 (h+ (C ) dominates h+ (C
ce )) Given planning task set nonunit conjunctions C, h+ (C ) h+ (C
).
cases inequality strict.
ce
495

fiKeyder, Hoffmann, & Haslum

Proof sketch: standard conditional effects compilation STRIPS (Gazen & Knoblock,
C
1997), applied C
ce , equivalent except presence cross-context preconditions C . Given this, plan C plan C
ce , yet inverse
C C
C
1
n
,
.
. . , aC
case. show first part, show induction C [aC
n ] [a1 , . . . , ]ce ,
1
I[. . . ]ce denotes result applying sequence actions initial state C
C
C
ce . Since goal tasks defined G , shows desired result.
strictness result follows fact possible construct tasks
cross-context preconditions discussed play role, leading situations
C
exist plans C
ce shorter minimum-length plans .
proof strictness (Appendix A), show planning task h+ (C )
value strictly larger h+ (C
ce ) value C chosen conjunctions
size 2. implies exist tasks necessary consider strictly
larger conjunctions C
ce obtain equally good heuristic estimates obtained
C
C . necessarily problematic however, differently hm , C
ce
introduce conjunctions given size, therefore exponential maximum
size conjunctions considered.
C
advantage C
ce potentially exponentially smaller |C|;
domination therefore must qualified reduction size. Furthermore,
C
ce preserves ability compute perfect heuristic given sufficiently large set C
conjunctions. first consider equivalent result C , already proved Haslum
(2012). provide alternative proof conveniently adapted show
C
property C
ce . key proof following equivalence
h1 (m ) h1 (C ):
Lemma 1 Given planning task , C = {c P(F ) | 1 < |c| m}, h1 (m ) = h1 (C ).
Proof sketch: C identical except action sets. h1 values computed
considering single add effect time. inequality h1 (m ) h1 (C )
0
easy see verifying that, every add effect c action aC C (unless
0
c pre(aC ) thus redundant), action ac dominates it, i. e., c add(ac )
0
pre(ac ) pre(aC ). proof similar inequality h1 (C ) h1 (m ), observing
action ac non-redundant add effect, exists dominating action
0
aC C .
Theorem 4 (h+ (C ) perfect limit) Given planning task , exists C
h+ (C ) = h ().
Proof: known h () = hm () sufficiently high values (Haslum &
Geffner, 2000), shown Haslum (2009), hm () = h1 (m ). Lemma 1,
C = {c P(F ) | 1 < |c| m}, h1 (m ) = h1 (C ). Choosing appropriate
corresponding C, thus h () = hm () = h1 (m ) = h1 (C ).
Together fact h1 (C ) h+ (C ), since h+ (C ) h () admissibility
h+ (C ), claim follows.
1
C
+
C
show claim C
ce , remains relate h ( ) h (ce ):

496

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

Lemma 2 Given planning task set non-unit conjunctions C, h1 (C )
h+ (C
ce ).
C
Proof sketch: Consider planning task C
no-cc identical except drops cross1
context -fluents preconditions. show (A) h (C ) h1 (C
no-cc ), (B)
1
C
+
C
h (no-cc ) h (ce ).
Similarly proof Lemma 1, (A) easy see showing every add effect
0
C 00 C : simply set C 00
c action aC C
no-cc dominated action
minimal subset C 0 contains c satisfies condition (2) Definition 2 (in
words, reduce C 0 get rid cross-context -fluents).
+
C
(B), suffices show h+ (C
no-cc ) h (ce ). holds because, action
C
0
relaxed plan ce , C set conjunctions added conditional
0
effects applied plan, action representative aC C
no-cc
preconditions a, used achieve set fluents.

Theorem 5 (h+ (C
ce ) perfect limit) Given planning task , exists C
h+ (C
)
=
h ().
ce
Proof: Choosing appropriate C, h () = hm () = h1 (m ), and,
Lemma 1, h1 (m ) = h1 (C ). Lemma 2, get h1 (C ) h+ (C
ce ). Since,
(), shows claim.
Theorem 1, h+ (C
)

h
ce
Note that, Theorem 3, Theorem 4 actually corollary Theorem 5. presentation chosen make relation two results, role two lemmas,
clearer.
proofs Theorems 4 5 rely obtaining perfect hm , clearly unfeasible
general since involves enumerating subsets fluents (and hence possible states)
worst case. However, C C
ce offer flexibility allowing us choose set
C: selecting subsets guarantees perfect heuristic, may achieved
much less effort, especially beneficial using C
ce whose growth |C| linear.

Indeed, task families obtaining h takes exponential effort hm ,
requires exponentially-sized C , yet C
ce remains small:
C ) exist parameterized task
Theorem 6 (Expressive power C
ce vs. h
families k

1. hm (k ) = h (k ) k,

C
2. h+ (C
k ) = h (k ) implies number action representatives k exponential k,

3. k exists Ck |Ck | (and therefore number conditional effects
+
C

(k )C
ce ) polynomial k, (b) h ((k )ce ) = h (k ).
Proof: Members one family given combination k planning tasks
type shown Example 1, size k, share among action
fluent needs made true step. k k goals, hm = h iff
k.
497

fiKeyder, Hoffmann, & Haslum

C
C
k (k )ce perfect, k -fluents {xi1 , y}, . . . , {xik , y} must introduced individual subtasks i, leading total k 2 -fluents. one
-fluents present, precondition action bij (k )C
ce , similarly
representative C 0 = {} C
,



individual
fluent
preconditions
y, xij ,
k
consequence one actions reestablishing left plan.
number conditional effects created (k )C
ce linear number -fluents added.
However, number action representatives (k )C exponential k: action
adds fluent y, belongs -fluents, hence one representative
subset -fluents.

using h+ (C
ce ) practice, typically able choose C results
perfect heuristic. Instead, try pick set C yields informative heuristic
without making size representation impractical work with.

5. Heuristics Satisficing Planning
consider practical issues involved using C
ce satisficing planning. Section 5.1 deals extraction relaxed plans, Section 5.2 deals strategies
choosing set conjunctions C. Section 5.3 presents experiments resulting
setup.
5.1 Relaxed Planning Conditional Effects
Techniques extracting relaxed plans presence conditional effects long
known (Hoffmann & Nebel, 2001). Here, refine extend techniques.
particularly important context as, unlike IPC benchmarks, structure
conditional effects C
ce rather complex, involving multiple dependencies
different actions, even different executions action.3
Non-admissible delete-relaxation heuristics typically obtained relaxed plan
extraction algorithm (Keyder & Geffner, 2008). different variants algorithm
characterized best-supporter function bs : F 7 use. cases, bs(p)
action adding p minimizes estimate cost making p true.
conditional effects present, algorithms compute set actions
scheduled form relaxed plan planning task. Formally, algorithms construct
relaxed plan according following equations (Keyder & Geffner, 2008):
(
{}
p
(p) =
bs(p) (pre(bs(p))) otherwise
[
(P ) =
(p)
pP

Existing methods choosing best supporters, hadd hmax , easily
extended conditional effects treating conditional effect task separate
3. remark similar issues arise approaches compiling uncertainty classical planning
conditional effects (Palacios & Geffner, 2009; Bonet, Palacios, & Geffner, 2009), techniques may
turn useful well.

498

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

action. particular, method employed, using hmax , compute heuristic
function (Hoffmann & Nebel, 2001). precisely, relaxed conditional effect
ce(a)+
condition c(a)i add add(a)i , action ai add effect add(ai ) =
add(a) add(a)i precondition pre(ai ) = pre(a) c(a)i created. set effects (G)
defined rules forms relaxed plan. presence conditional effects,
however, implies problem schedule relaxed plan: different
schedules may require different numbers action applications, multiple applications
single action avoided making conditions multiple desired effects true
given application a.
illustration, consider planning task action move-briefcase n conditional effects, conditionally transports object location location
B inside briefcase. Using representation above, distinct moving action
generated conditional effect. one possible schedule relaxed plan repeatedly
puts object briefcase, applies move-briefcase, proceeds next object.
plan n 1 steps longer optimal relaxed plan, first places
objects briefcase applies move-briefcase once.
words, single action execution may trigger several conditional effects
once, may exist relaxed plan length less |(G)|. question arises
optimally schedule relaxed plan, minimizing number action applications
required. uses simple approximate solution problem, outline
improve upon below. first note problem scheduling conditional relaxed
plans (SCRP) actually NP-complete:
Theorem 7 (Scheduling conditional relaxed plans) Let + relaxed planning task
conditional effects (G) set effects that, viewed set independent actions,
constitutes plan + . Deciding whether exists sequence actions length k
conditional effects (G) triggered NP-complete.
Proof: Membership follows fact given sequence k actions, easily
checked polynomial time whether conditional effects (G) triggered. Hardness
follows reduction shortest common supersequence problem (SCS) (Garey &
Johnson, 1979). supersequence string x = d0 . . . dm alphabet string
alphabet belongs language L = d0 . . . dm . Given
instance SCS problem strings x0 , . . . , xn alphabet {0, 1} asks
whether exists supersequence strings length k, construct
planning task conditional effects = hF, A, I, Gi,

F = ni=0 {yij | 0 j |xi |}
= {a0 , a1 }, az = {, , , ce(az )}, ce(az ) given set conditional
effects
n |x[
|1
[
{hyij , yij+1 , | xij = z}
i=0 j=0

= {y00 , . . . , yn0 }
G = {y0|x0 | , . . . , yn|xn | }
499

fiKeyder, Hoffmann, & Haslum

two actions a0 a1 correspond addition symbols 0 1 respectively
supersequence implicitly constructed, fluent yij encodes fact
current string constitutes supersequence prefix xi0 , . . . , xij1 .
seen valid plan planning task must trigger conditional effects
task, yet sequence actions length k exists iff common
supersequence x0 , . . . , xn length k. transformation SCS problem
planning task conditional effects polynomial, shows claim.
Note Theorem 7 relate (known) hardness optimal relaxed planning:
wish schedule effects already selected know form
relaxed plan. source complexity has, yet, overlooked literature.
Given hardness result, employ greedy minimization technique call
conditional effect merging. Starting trivial schedule containing one action execution
effect (G), consider pairs effects e, e0 (G) conditional effects
action a. two effects merged single execution conditions
achieved without use either add effects. FFs approximation method
applies similar reasoning, captures special case condition holds:
e e0 appear layer relaxed planning graph, trivially
implies conditions effects independently achievable. However,
may case effects different layers relaxed planning graph.
devise strictly general technique, capturing form independence
effects using call best supporter graph (BSG) representation relaxed plan
(for simplicity, assume task single goal fluent G0 , needed
achieved introducing new action end whose preconditions original goals,
adds G0 ):
Definition 4 (Best supporter graph) Given relaxed planning task + best supporter function bs, best supporter graph directed acyclic graph = hV, Ei,
V = (G), (G) above, E = {hv, v 0 | p pre(v 0 ) v = bs(p)}, vertex
labeled action whose conditional effect represents, edge labelled
set preconditions {p | p pre(v 0 ) v = bs(p)}.
nodes graph represent conditional effects appear relaxed plan,
exists edge hv, v 0 two nodes effect represented v best
supporter (pre)condition effect represented v 0 .4 bs valid best supporter
function (i. e., relaxed plan (G) generated bs sound) sufficient condition
acyclic, easily shown topological sort sound
relaxed plan. implies that, path two conditional effects
action, occur result action application, therefore
merged single occurrence action. nodes removed
BSG, new node added represents effects, combining incoming
outgoing edges. process repeated node merges possible.
algorithm runs polynomial time sound results BSG
topological sort constitutes relaxed plan . not, however, guarantee
optimal scheduling original plan.
4. edge labels used procedure choosing conjunction set C, described Section 5.2.

500

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

example, consider task move-briefcase n conditional effects
transporting object location location B inside briefcase. nodes
BSG n put-into-briefcase(oi ) actions (one object oi ), well n copies
move-briefcase(A, B) (one conditional effect regarding object oi ).
one edge put-into-briefcase(oi ) respective copy move-briefcase(A, B), labeled
in-briefcase(oi ). therefore path graph move-briefcase(A, B)
node another, merged single node conditional effect merging
algorithm. topological sorts merged BSG correspond optimal relaxed plans.
5.2 Choosing C Relaxed Planning
Algorithm 1 shows main procedure computing set conjunctions C used form
C
ce task. algorithm applied once, start search, initial
C
state planning task. resulting C
ce (or ) task used subsequent
heuristic evaluations. Conditional effect merging used conflict extraction
phase configuration discussed below, i. e., use original non-merged BSG
stated Definition 4.
Algorithm 1: Choosing C relaxed plan heuristics.
C=
= RelaxedPlan(C
ce )
plan size(C
ce ) < bound
C = C FindConflicts()
= RelaxedPlan(C
ce )
Algorithm 1 is, high level, similar procedure previously introduced
computing incremental cost lower bounds based C construction (Haslum, 2012).
algorithm repeatedly generates relaxed plans initial state current compiled
task. adds new conjunctions C based conflicts found current
plan, i. e., based current relaxed plan fails executed original planning
task . process stops either conflicts found, implying
current relaxed plan C
ce plan original planning task, user-specified
C
bound size ce reached. express bound terms size C
ce
compared (see below). sometimes impose bound runtime
algorithm.
bound specified, FindConflicts() returns least one new conjunction
long plan , Algorithm 1 complete planning algorithm right.
report results usage algorithm experiments below. relaxed
plan generated iteration optimal, Algorithm 1 used compute sequence
admissible cost estimates converges optimal plan cost (Haslum, 2012).
focus, however, use C
ce generating inadmissible heuristic functions.
therefore use tractable, non-optimal, relaxed planning procedure, impose bound
typically stops Algorithm 1 plan original task found.
remains specify FindConflicts procedure: Given relaxed plan fails
execute original planning task , select set new conjunctions C? One
501

fiKeyder, Hoffmann, & Haslum

answer question provided previous use Algorithm 1 compute
plan cost lower bounds (Haslum, 2012). aim different computing heuristics
satisficing search-based planning make number changes previously
proposed version FindConflicts. Section 5.2.1 summarizes original procedure,
Section 5.2.2 describes changes make it.
5.2.1 Conflict Extraction Incremental Plan Cost Lower Bounds
Given optimal relaxed plan plan original planning task, Haslums
(2012) version FindConflicts returns set conjunctions C prevents relaxed
plan solution next iteration. ensures progress, sense
cost relaxed plan eventually increase, prove real plan cost.
describe conflict extraction procedure, need two definitions:
Definition 5 (Relaxed Plan Dependency Graph) Let non-redundant plan
relaxed planning task + . Construct directed graph G () one node va
action , plus node vG representing goal. Let pre(v) denote precondition
node v, pre(a) node va G node vG . G (S) directed edge
va v 0 iff pre(v 0 ) relaxed reachable using set actions minus {a}.
edge labelled subset pre(v 0 ) relaxed unreachable actions.
relaxed plan dependency graph, RPDG(), transitive reduction G ().
RPDG similar BSG (Definition 4), encodes necessary dependencies actions relaxed plan. path node va node vb
RPDG implies precedes b every valid sequencing ; case, vb said
ordered va . contrast, BSG encodes intentions relaxed plan
heuristic, form chosen best supporters, may impose orderings need
respected every valid sequencing plan (e. g. fluent p added another
action relaxed plan best supporter p). relaxed plan
non-redundant, meaning action removed without invalidating it,
path every action node RPDG goal node.
Definition 6 (Dependency Closure) Let non-redundant plan relaxed planning task + , let v v 0 nodes RPDG(), v 0 ordered v. simple
q1
q2
qm
dependency path path v v1 . . . v 0 v v 0 RPDG(), edge
labelled one fluent, chosen arbitrarily, edge label RPDG(). (Whenever
v 0 ordered v, simple dependency path v v 0 exists.) dependency closure
v v 0 minimal, w.r.t. subset, union paths, (1) contains simple
dependency path v v 0 , (2) q fluent labels edge node v 00
closure, action q add(a), action associated
v 00 , closure contains simple dependency path v node corresponding
a. (Such path guaranteed exist.)
Recall input FindConflicts plan, , valid delete relaxation +
original planning task delete effects considered.
valid + , preconditions actions , well goals, must made true
502

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

...
vd
p1
r
...
vf
q1

p
vd

q1

...

qn

vf

pn
vj
qm

(b)

(a)

Figure 1: Relaxed plan failure scenarios. Wavy edges show deletions precondition.
point. Thus, fails solve original task must case action
d, call deleter, deletes precondition action f , called
failed action. Note failed action goal. Let p pre(f )
deleted fluent. procedure distinguishes two cases, based relation
nodes vd vf RPDG:
first case, illustrated Figure 1 (a), vf ordered vd . Choose dependency
closure vd vf , let L set fluents labelling edges closure:
set conflicts generated {{p, q} | q L}. (Note p 6 L, thus conflict
proper conjunction.)
first case hold, vd vf unordered. must nearest
common descendant node, vj , RPDG, situation illustrated Figure 1
(b). Choose dependency closure vd vj , let L1 set fluents labelling
edges closure. Likewise, choose dependency closure vf vj , let L2
set fluents labelling edges closure. set conflicts generated
{{q, q 0 } | q L1 , q 0 L2 {p}}.
Theorem 8 (Haslum, 2012, Theorem 6) Let = a1 , . . . , non-redundant plan
delete relaxed task + valid original task , let C set
conjunctions extracted procedure described above. action sequence 0 = a01 , . . . , a0n
a0i representative ai valid plan C .
5.2.2 Changes Conflict Extraction Satisficing Planning
number differences setting Haslum (2012).
particular, although -fluents collected initial state, resulting C
ce task
used heuristic evaluations states encountered search, growth
size C
ce task incur overhead heuristic evaluation. Thus,
objective find set C make heuristic accurate across states,
keeping size C limited. hand, computing non-optimal relaxed
plans computationally far cheaper optimal relaxed planning, afford
iterations Algorithm 1.
Therefore, make following modifications strategy: First, use BSG
instead RPDG. necessity orderings latter extend beyond
current (initial) state, therefore useful purpose. BSG
representative relaxed plans found non-optimal relaxed planning procedure.
Second, introduce single -fluent iteration Algorithm 1.
time, cause new relaxed plan found, allows algorithm focus
finding small number conflicts useful wide range states. chosen
conflict {p, qn } case depicted Figure 1 (a), {pn , qm } Figure 1 (b).
503

fiKeyder, Hoffmann, & Haslum

Intuitively, works better setting set conflicts generated
plan failure tends redundant, thus needlessly grows size task
leading slow evaluation times without much gain informativeness.
changes affect fundamental property Algorithm 1, converges
real plan. show convergence, property FindConflicts must
returns least one new conjunction whenever fails solve original task.
variant still gives guarantee:
Lemma 3 Assume eliminate dominated preconditions 5 C . Let = a1 , . . . ,
non-redundant plan C valid original task , let c
conjunction extracted procedure described above. c 6 C.
Proof: simply because, possible relaxed plan failure scenarios (Figure 1),
chosen conjunction c = {x, y} ({x, y} = {p, qn } respectively {x, y} = {pn , qm }) contained
precondition failed action f . Assuming c = {x, y} C, eliminate
dominated preconditions, action precondition C contains x y. Hence,
case, c cannot chosen conjunction.
Theorem 9 (Convergence conflict extraction) Assume eliminate dominated preconditions C , Algorithm 1 run without size bound. eventually
plan .
Proof: Follows Lemma 3 set possible conjunctions finite.
Contrasting Theorem 9 Haslums variant (Theorem 8), latter gives stronger
convergence guarantee (only) sense guarantees certain minimum progress
made iteration.
Lemma 3 (and thus Theorem 9) holds way C
ce , i. e., sequence
C
conditional effects ce , that, viewed set independent actions, constitutes nonredundant plan C
ce . rely eliminating dominated preconditions
makes proof simple, use technique practice anyway.
verify whether convergence holds dominated preconditions eliminated;
conjecture does.
Since multiple conflicts BSG relaxed plan, experiments
choose (arbitrarily) one minimizes number conditional effects (or STRIPS
actions, case C ) created. place bound factor x C
ce exceeds
size original planning task . Precisely, x = 1, -fluents conditional
+
effects added, C
ce = , resulting standard relaxed plan heuristic. growth
bounds x > 1, -fluents added number conditional effects task reaches
(x 1) |A|. C , x limits total number actions task multiple |A|.

5. Recall eliminating dominated preconditions means that, whenever add fluent c precondition action, condition conditional effect, remove condition fluents
p c -fluents {c0 | c0 c}.

504

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

Example 2 Consider STRIPS planning task Example 1, variables
{x0 , . . . , xn , y}, initial state = {x0 , y}, goal G = {xn }, unit-cost actions
: h, {y}, ,

bi : h{xi , y}, {xi+1 }, {y},

= 0, . . . , n 1.
previously discussed, setting C = {x1 ,y , . . . , xn1 ,y } renders delete relaxation
perfect, i. e., results relaxed plan re-establish every two bactions. Exactly set C iteratively selected procedure.
Assuming best supporter function based either hadd hmax , first iteration
Algorithm 1 BSG be:

b0

x1

b1

x2

...

b2

bn2

xn1

bn1

relaxed plan fails execute trying apply second action, b1 . corresponding failure scenario matches Figure 1 (a):


b0

b1

x1

chosen conflict thus {y, x0 }. non-empty set conjunctions C containing single conjunction, precondition b1 contains {x1 ,y} must
established using action a, BSG takes form (note dominated
preconditions xi b1 eliminated):

b0

x1



{x1 ,y}

b1

b2

x2

...

bn2

xn1

bn1

relaxed plan fails execute trying apply fourth action, b2 .
corresponding failure scenario is:


b1

x2

b2

chosen conflict {y, x2 }. Iterating procedure will, manner, select
exactly set C one-by-one, end relaxed plan solve original
planning task.
5.3 Experiments
evaluate impact using C
ce compilation relaxed plan heuristic context greedy search. expected impact using heuristic based improved
relaxation two-fold. one hand, make heuristic informative,
505

fiKeyder, Hoffmann, & Haslum

enabling search find plans fewer node evaluations. hand,
computational overhead associated growth problem, slowing heuristic
evaluations. examine effects individually, well combined influence coverage, set problems planner able solve within given time
memory bounds, take main measure performance.
study, consider objective producing plans high quality (as
measured plan length cost). plan quality unimportant. Rather,
rationale decision methodological: Seeking high quality plan
problem seeking find plan minimum search effort particularly
quality measured non-unit action costs requirements heuristics
two problems quite different. Here, chosen focus one, viz. search efficiency,
measured coverage node evaluations, rather conflate two. choice
plain greedy search algorithm motivated decision. consequence,
treat actions unit cost 1. Previous experiments shown
context greedy search, distinguishing action costs heuristic calculation tends result
lower coverage (Richter & Westphal, 2010). However, least assess impact
heuristics plan quality, report data regarding plan length.
next describe experiment setup baseline. discuss heuristic informativeness, computational overhead, impact conditional effect merging, impact
plan length using C
ce heuristics, comparison state-of-the-art heuristics
problem, difference using C C
ce compilations, finding
plans search.
5.3.1 Experiment Setup Baseline
compilation associated heuristics implemented Fast Downward planner
(Helmert, 2006), used greedy best-first search, lazy evaluation second
open list (with boosting) states resulting preferred operators. planners
tested STRIPS domains 19982011 editions International
Planning Competition (IPC). domains last two IPCs, recent
sets instances used. experiments run Opteron 2384 processors
settings used competition: memory limit 2Gb time limit 30 minutes.
baseline planner configuration uses relaxed plan heuristic, best supporters
identified hadd , unmodified planning task (i. e., growth bound x = 1).
known fact greedy search, particular greedy search lazy evaluation
strong bias towards preferred operators, highly sensitive small changes
relaxed plan, even changes alter heuristic value rather
operators preferred. Unfortunately, fact rarely taken account
heuristics compared context greedy search. Since introduction -fluents
alters structure relaxed plan, believe particularly important determine
whether resulting differences planner performance really due relaxed plan
(or less) informative.
Therefore, first step towards accounting brittleness experiments
greedy heuristic search, introduce simple variance measure use decide
results experiments considered significant. Variance performance
506

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

baseline planner measured randomizing choice supporters equal
hadd values construction relaxed plan measuring maximum deviation
results baseline planner five repeated runs. results shown
columns labeled MaD (Tables 1 4). domain problem set
whole, deviation defined differences coverage median number
heuristic evaluations. Note interested whether randomization helps
hurts search, rather magnitude variation causes.
C
comparing results planner using heuristics based C
ce different
growth bounds results baseline planner, consider difference
significant greater magnitude maximum deviation observed
randomization baseline. interpreted significance
statistical sense (although, assumed randomization affects heuristics equally,
could estimate probability hypothesis difference), simply setting
reasonable threshold counts substantial difference search performance.

5.3.2 Heuristic Informativeness
comparison heuristic informativeness summarized right half Table 1,
shows ratio median (per domain, tasks solved planners)
number heuristic evaluations baseline planner planners using
C
ce -based heuristics. half domains, difference informativeness
C
ce -based heuristics compared baseline exceed threshold significance
set sensitivity study (shown MaD column). Among domains
significant difference, majority using C
ce -based heuristics reduces
number node evaluations, indicating augmented heuristics informative.
cases, ratio grows -fluents added, i.e., growth bound
x increased. drastic example seen Floortile domain,
C
ce -based heuristics evaluate four orders magnitude fewer nodes, compared
standard delete relaxation heuristic. allows easily solve instances
domain. comparison, planner IPC 2011 able solve 9
20 instances domain. Woodworking domain, C
ce heuristics
two orders magnitude informative, associated increase coverage
tasks solved configurations.
roughly third domains consistent (or nearly consistent) loss
informativeness, though significant. Note loss informativeness always correlate loss coverage. attributed different
factors, including small magnitudes loss, well fact ratio node
evaluations taken tasks solved planners compared. Another issue
dramatic coverage losses often due computational overhead incurred
C
ce compilation. particular, Openstacks Satellite domains, decrease
number tasks solved C
ce -based heuristics matches almost exactly number
tasks conflict selection compilation process fails complete within
1800 seconds allocated per task. get back next subsection.
507

fiKeyder, Hoffmann, & Haslum

worth noting quality C
ce -based heuristics highly sensitive
precise choice -fluents used compilation.6 Hence, may exist better policies
making choice relatively simple one used here.
HO PO colums Table 1 (coverage only) examine effect new
heuristic function, respectively new preferred operators returned function,
separation. PO corresponds configuration uses relaxed plan C
ce task
(built x = 1.5 timeout = 60s, discussed Section 5.3.3) identify
preferred operators, together heuristic value baseline (x = 1) heuristic.
HO, hand, uses heuristic values obtained x = 1.5 preferred
operators x = 1. Interestingly, either heuristic values preferred operators alone
sufficient greatly improve coverage Floortile, domain techniques
greatest impact. HO PO configurations able solve every instance
domain.7 effect domains mixed, configurations solving
sometimes more, sometimes fewer instances.
5.3.3 Computational Overhead
computational overhead C
ce -based heuristics, compared standard relaxed
plan heuristic, stems two sources: (1) time spent computing set -fluents
add problem, (2) greater overhead heuristic evaluation C
ce task.
Table 2 shows three measures impact.
first four columns (under Timeouts) show number instances
construction C
ce task finish within 1800 seconds, second set
four columns (under > 60 sec) shows number instances construction
time exceeds 60 seconds (inclusive instances first set columns). Note
behavior spending large amount time C
ce construction without reaching
growth bound partly due strategy selecting -fluents, since purposely
choose -fluents increase size compiled task least.
several domains construction time frequently exceeds 60 seconds,
happen domains C
ce -based heuristic informative,
Floortile Woodworking. suggests imposing time limit construction
C
ce task incur small loss informativeness. present coverage results
strategy (using 60 second time limit) Table 4 below. significantly better
baseline planner, compares favourably state art heuristics.
expected, domains evaluating heuristics C
ce task slower
standard delete relaxation, tends slow growth bound x increases,
due larger number fluents actions compiled planning task. median
slowdown per domain typically order x itself, exceeds one order
6. Indeed, results reported earlier paper (Keyder, Hoffmann, & Haslum, 2012) show increase
informativeness Barman Parcprinter domains.
7. plausible explanation behavior respect dead-end states (intuitively,
robot painted corner) unrecognized standard delete relaxation
heuristic, i. e., relaxed plan exists. appears C
ce highly effective fixing
issue: x = 1 search encounters millions states hFF () = , HO encounters

states hFF (C
(C
ce ) = (suggesting h
ce ) prunes dead-ends early on), PO encounters
states (suggesting hFF (C
)
preferred
operators prevent search entering
ce
dead-end regions first place).

508

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

Domain
x=1 MaD
Airport (50)
36
Barman (20)
13
Blocksworld (35)
35
Depots (22)
19
Driverlog (20)
20
Elevators (20)
19
Floortile (20)
6
FreeCell (80)
79
Grid (5)
5
Gripper (20)
20
Logistics00 (28)
28
Logistics98 (35)
34
Miconic (150)
150
Mprime (35)
35
Mystery (30)
16
Nomystery (20)
9
Openstacks (20)
20
Parcprinter (20)
16
Parking (20)
20
Pathways (30)
30
Pegsol (20)
20
Pipes-NoTk (50)
42
Pipes-Tank (50)
38
PSR (50)
50
Rovers (40)
40
Satellite (36)
35
Scanalyzer (20)
18
Sokoban (20)
19
Tidybot (20)
16
TPP (30)
30
Transport (20)
11
Trucks (30)
14
Visitall (20)
19
Woodwork (20)
20
Zenotravel (20)
20
Total (1126)
1002

+2

+5

+0

+1

+0

+3

+0

+2

+0

+0

+0

+1

+0

+0

+0

+2

+0

+7

+1

+2

+0

+1

+4

+0

+0

+1

+1

+1

+3

+0

+1

+0

+1

+0

+1

+19


Coverage
x =
PO HO
1.5 2 2.5 3 1.5 1.5
+0
+1 +3 +1 +2 +1
+6 +3 +1 3 3 +5
+0
+0
+0
+0
+0
+0

+0 1
+2 +2 +2 +2
+0
+0
+0
+0
+0
+0

+1 +1 +1 +1 +1 +1
+14 +14 +14 +14 +14 +14
+0 +1
+1 3 4 2
+0
+0
+0
+0
+0
+0

+0
+0
+0
+0
+0
+0

+0
+0
+0
+0
+0
+0

+0 1
+0 +1 +1
+1
+0
+0
+0
+0
+0
+0

+0
+0
+0
+0
+0
+0

+3 +3 +3 +3 +3 +1
2 3 3 3 1 2
9 9 9 9 1 1
11 8 7 7 4 10
+0 6
2 8 7 5
+0
1 2 5 1 1
+0
+0
+0
+0
+0
+0

+0 1
+0
+0 1
+0

+0 +2 1 +3
+3 +2
+0
+0
+0
+0
+0
+0

+0
+0
+0 1
+0
1
+0
2 5 6 8 +1
+2 +2 +2 +2 1 +2
+0 2
2 2 3 3
+0
+0 1 1
+0
2
+0
+0
+0
+0
+0
+0

+2 2 +1 +1 7 3
+0 +2
+1 +3 +4 +2
+1 +1 2 2 2 2
+0
+0
+0
+0
+0
+0

+0
+0
+0
+0
+0
+0

+6 9 17 14 3 +3

Median Node Evaluations Ratio
x =
1.5
2
2.5
3
4.32
1.36 : 1
1.34 : 1
1.40 : 1
1.50 : 1
9.91
1 : 1.63
1 : 2.22
1 : 8.33
1 : 25
5
2.84 : 1
2.90 : 1
2.90 : 1
3.02 : 1
12.13
2.84 : 1
3.26 : 1
3.65 : 1
8.55 : 1
1.16 2.17 : 1
2.64 : 1
2.65 : 1
2.31 : 1
1.31
1.25 : 1
1.47 : 1
1.34 : 1
1.22 : 1
6.42 15013 : 1
15110 : 1
14757 : 1
19674 : 1
1.28
1 : 1.11
1 : 1.28
1 : 1.17
1 : 1.29
1.21 1.27 : 1
2.83 : 1
1.27 : 1
1.27 : 1
1
1 : 1.05
1 : 1.51
1 : 1.49 1.23 : 1
1.64
1.47 : 1
1.47 : 1
1.53 : 1
1.60 : 1
1.45 2.53 : 1
2.57 : 1
2.83 : 1
2.70 : 1
1 1.16 : 1
1.22 : 1
1.29 : 1
1.36 : 1
1.09 2.33 : 1
2.33 : 1
2.33 : 1
2.33 : 1
1.07 1.21 : 1
1.27 : 1
1.29 : 1
1.29 : 1
13.93
1 : 1.44
2.58 : 1
9.95 : 1
10.13 : 1
1.08 2.52 : 1
1.31 : 1
1 : 1.23
1 : 1.11
1.58
1 : 1.04
1 : 1.04
1 : 1.08
1 : 1.09
7.06
1 : 1.12
3.02 : 1
1.61 : 1
1.18 : 1
1.21
1 : 1.03
1:1
1 : 1.05
1 : 1.11
3.42
1.44 : 1
1.09 : 1
1.66 : 1
1.41 : 1
16.47
1 : 1.07
1.08 : 1
1.14 : 1
1.29 : 1
2.46
1:1
1:1
1:1
1 : 1.05
1
1:1
1.02 : 1
1.12 : 1
1.12 : 1
1.33
1.12 : 1
1.15 : 1
1.12 : 1
1.20 : 1
1.36
1.15 : 1
1.36 : 1
1.30 : 1
1.29 : 1
1.85
1.17 : 1
1.80 : 1
3.43 : 1
3.25 : 1
1.46
1.17 : 1
1 : 1.09
1.01 : 1
1.06 : 1
1.22
1.15 : 1
1 : 1.25
1 : 1.38
1 : 1.08
2.29
1 : 1.20
1 : 1.13
1 : 1.19
1 : 1.01
2.73
1.20 : 1
1 : 1.11
1 : 1.29
1 : 1.01
1.66
1.16 : 1
1.97 : 1
7.27 : 1
4.57 : 1
1.34
1.01 : 1
1 : 1.08
1 : 1.09
1 : 1.49
52.78 245.72 : 1
263.3 : 1
245.72 : 1
245.72 : 1
1.28
1.22 : 1
1.24 : 1
1.36 : 1
1.42 : 1
MaD

Table 1: Planner coverage heuristic informativeness using C
ce varying growth bounds,
without conditional effect merging. Coverage shows number problems solved baseline
configuration (x = 1), difference (increase/decrease) relative baseline
configurations; PO uses preferred operators obtained C
ce compilation
x = 1.5 = 60s, returning x = 1 heuristic value, HO uses heuristic values
obtained x = 1.5 = 60s, preferred operators x = 1. Heuristic informativeness
measured ratio per-domain median number node evaluations, comparing
baseline configurations (across instances solved configurations), normalized
smaller value 1. is, entry : 1 means baseline planner requires times
many heuristic evaluations planner. Columns labeled MaD show magnitude
maximum deviation (in coverage ratio) baseline sensitivity study: values
bold exceed threshold, therefore consider significant.

magnitude Floortile domain x = 1.5. Somewhat surprisingly,
domains heuristic evaluations become faster -fluents added. possible
explanation eliminate dominated preconditions (cf. Section 3),
number action preconditions decreases delete-relaxation hypergraph
C
ce becomes graph-like result.
509

fiKeyder, Hoffmann, & Haslum

Domain
Airport (50)
Barman (20)
Blocksworld (35)
Depots (22)
Driverlog (20)
Elevators (20)
Floortile (20)
FreeCell (80)
Grid (5)
Gripper (20)
Logistics00 (28)
Logistics98 (35)
Miconic (150)
Mprime (35)
Mystery (30)
Nomystery (20)
Openstacks (20)
Parcprinter (20)
Parking (20)
Pathways (30)
Pegsol (20)
Pipes-NoTank (50)
Pipes-Tank (50)
PSR (50)
Rovers (40)
Satellite (36)
Scanalyzer (20)
Sokoban (20)
Tidybot (20)
TPP (30)
Transport (20)
Trucks (30)
Visitall (20)
Woodwork (20)
Zenotravel (20)
Total (1126)

Timeouts
x =
1.5 2 2.5 3
1
1
1
1

1.5
15

> 60 sec
x =
2
2.5
20
23

3
26

1

9

3

9

6

16

10

10

12

1

1

3

6

9

10

9

9

16

16

16

16

14

16
3

16
6

16
7

5
9
3

5
11
3

5
13
3

5
13
4

6

1
5
12
2
8

1
5
16
2
9

1
6
17
4
10

96

118

134

148

7

2

13

10

20

9

3

23

4
11

Ratio Median Evaluations/sec
x =
1.5
2
2.5
3
1.08 : 1
1.19 : 1
1.30 : 1
1.26 : 1
1.35 : 1
1.88 : 1
2.42 : 1
3.09 : 1
1.50 : 1
1.60 : 1
1.56 : 1
1.42 : 1
1.65 : 1
1.81 : 1
2.03 : 1
2.31 : 1
1.56 : 1
2.38 : 1
3.17 : 1
4.07 : 1
1.87 : 1
2.92 : 1
3.99 : 1
5.45 : 1
17.67 : 1
8.28 : 1
5.97 : 1
5.49 : 1
1.20 : 1
1.31 : 1
1.39 : 1
1.66 : 1
1.27 : 1
2.55 : 1
3.04 : 1
3.04 : 1
1 : 2.13
1 : 2.04
1 : 2.13
1 : 1.69
1.09 : 1
1 : 1.76
1 : 1.35
1 : 1.22
1.20 : 1
1.64 : 1
2.55 : 1
3.72 : 1
1.06 : 1
1.10 : 1
1.18 : 1
1.27 : 1
1.60 : 1
1.80 : 1
1.60 : 1
1.80 : 1
1.28 : 1
1.35 : 1
1.42 : 1
1.42 : 1
1.43 : 1
2.20 : 1
2.53 : 1
3.26 : 1
1.16 : 1
1.73 : 1
2.49 : 1
3.17 : 1
1 : 8.33
1 : 8.33
1 : 6.25
1 : 1.81
2.32 : 1
3.61 : 1
4.84 : 1
6.20 : 1
1.36 : 1
2.04 : 1
1.01 : 1
1.64 : 1
1.25 : 1
1.08 : 1
1.48 : 1
1.11 : 1
1.41 : 1
1.94 : 1
2.31 : 1
2.78 : 1
1.61 : 1
2.37 : 1
2.42 : 1
3.39 : 1
1:1
1:1
1.02 : 1
1 : 1.05
1.11 : 1
1.43 : 1
1.48 : 1
1.83 : 1
1.14 : 1
1.07 : 1
1 : 1.01 1.30 : 1
1.09 : 1
2.22 : 1
2.42 : 1
2.73 : 1
1.23 : 1
1.38 : 1
1.62 : 1
1.82 : 1
1.48 : 1
2.03 : 1
3.36 : 1
2.22 : 1
1.59 : 1
1.70 : 1
2.38 : 1
2.84 : 1
2.38 : 1
4.04 : 1
6.50 : 1
8.80 : 1
1.62 : 1
2.29 : 1
2.52 : 1
3.30 : 1
1 : 1.49
1 : 1.33
1 : 1.15
1 : 1.07
1 : 2.63
1 : 2.08 3.29 : 1
6.32 : 1
1.09 : 1
1:1
1.06 : 1
1.10 : 1

Table 2: Computational overhead C
ce . first set columns (Timeouts) shows number

tasks C
ce construction finish within 1800 second time limit,
second set (> 60 sec) shows number tasks construction time exceeds 60 seconds
(inclusive first set columns). improve readability, non-zero entries
shown (i.e., blank cells columns zeroes). last set columns shows median
(per domain, commonly solved tasks) ratio heuristic evaluations per second baseline
planner (x = 1) planner (x > 1). entry : 1 means baseline planner
performs times many heuristic evaluations per second planner.

5.3.4 Conditional Effect Merging
majority domains, conditional effect merging slightly increases change
informativeness C
ce -based heuristics. exceptions Logistics00
Gripper domains, merging results heuristic twice informative
(using ratio median number evaluations metric presented Table 1),
Nomystery domain order magnitude informative (for problems
solved heuristics), Barman domain four times less
informative. general, higher informativeness occurs domains tasks
510

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

solved planners, result increased coverage. Indeed, shown
Table 4 below, conditional effect merging proves detrimental overall coverage
C
planner using C
ce -based heuristic: best ce configuration conditional
effect merging solves, total, 4 tasks standard relaxed plan heuristic,
configuration without conditional effect merging solves 20 tasks.
runtime overhead merging procedure quite small, transitive closure
operation required check whether path two nodes BSG
implemented efficiently graph known directed acyclic, case
here. x = 1.5, comparing C
ce -based heuristic conditional effect merging
without, ratio median number heuristic evaluations per second (the
metric used right-hand side Table 2) shows maximal per-domain slow-down
2.04, across-domain average 1.11. Coverage decreases domains
Barman therefore appear due sensitivity search small changes
heuristic function (rather due time taken compute function).
5.3.5 Plan Length C
ce
determine effect using C
ce heuristics plan quality, compare length
plans found C
heuristics

found x = 1, standard delete relaxation
ce
heuristic. plan length measure equivalent plan quality unit-cost setting.
consider median ratio plan length found standard delete relaxation
heuristic found C
ce heuristic, set instances solved
configurations (Table 3). general, observe large differences,
median ratio staying close 1. One notable exception blocksworld domain,
heuristics based C
ce compilation consistently find significantly shorter plans.
C
results ce heuristics ability deduce implicit ordering constraints domain,
avoiding actions lead temporary improvements greedy search later
need reversed, adding plan length. C
ce leads shorter plans Gripper,
Mprime, Woodworking domains, tends result longer plans Barman
Grid domains.
5.3.6 Comparison State Art
Table 4 shows coverage variety heuristics planners. best configurations
two compilations x > 1 achieve better overall coverage results
standard relaxed plan heuristic. best-performing heuristics obtained C
ce
compilation without conditional effect merging, C compilation, give coverages
1022 1023 respectively. difference coverage baseline
planner greater significance threshold. numbers far exceed coverage obtained hcea heuristic, fall short 1039 instances solved
dual heuristic approach used LAMA. However, combining LAMA best C
ce -nm
configuration portfolio planner runs LAMA 1500 seconds search
C
ce -nm heuristic 300 seconds results coverage 1063 1115 solvable problems.
Almost difference results C
ce -based heuristics superior performance
Floortile, lesser extent, Airport domains.
511

fiKeyder, Hoffmann, & Haslum

Domain
Airport
Barman
Blocksworld
Depots
Driverlog
Elevators
Floortile
FreeCell
Grid
Gripper
Logistics00
Logistics98
Miconic
Mprime
Mystery
Nomystery
Openstacks
Parcprinter
Parking
Pathways
Pegsol
Pipesworld
Pipesworld
PSR
Rovers
Satellite
Scanalyzer
Sokoban
Tidybot
TPP
Transport
Trucks
Visitall
Woodwork
Zenotravel

x = 1.5
1 : 1.00
1 : 1.11
1.65 : 1
1.08 : 1
1.04 : 1
1 : 1.06
1 : 1.10
1 : 1.02
1 : 1.24
1.04 : 1
1 : 1.14
1.07 : 1
1 : 1.00
1.12 : 1
1 : 1.00
1 : 1.00
1 : 1.02
1 : 1.00
1.26 : 1
1 : 1.01
1 : 1.04
1 : 1.09
1 : 1.12
1 : 1.00
1 : 1.01
1 : 1.00
1 : 1.00
1 : 1.00
1 : 1.06
1 : 1.04
1 : 1.10
1 : 1.00
1.01 : 1
1.21 : 1
1 : 1.00

x
1
1
1.68
1.03
1
1
1
1
1
1.16
1
1.05
1
1.17
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1.21
1

=
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

2
1.00
1.12
1
1
1.00
1.05
1.15
1.03
1.17
1
1.13
1
1.00
1
1.00
1.02
1.02
1.00
1.01
1.00
1.00
1.00
1.00
1.00
1.00
1.00
1.00
1.03
1.19
1.02
1.16
1.00
1.00
1
1.00

x = 2.5
1 : 1.00
1 : 1.23
1.69 : 1
1.04 : 1
1 : 1.00
1 : 1.05
1 : 1.05
1 : 1.04
1 : 1.17
1.31 : 1
1 : 1.13
1.05 : 1
1 : 1.00
1.12 : 1
1 : 1.00
1 : 1.02
1 : 1.02
1 : 1.00
1.04 : 1
1 : 1.01
1 : 1.03
1 : 1.17
1 : 1.04
1 : 1.00
1.01 : 1
1 : 1.00
1 : 1.00
1.01 : 1
1 : 1.16
1 : 1.00
1 : 1.06
1 : 1.00
1 : 1.04
1.21 : 1
1 : 1.00

x
1
1
1.64
1.06
1
1
1
1
1
1.31
1
1.06
1.01
1.17
1
1
1
1.04
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1.21
1

=
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

3
1.00
1.32
1
1
1.00
1.12
1.03
1.06
1.17
1
1.12
1
1
1
1.00
1.02
1.01
1
1.00
1.02
1.02
1.14
1.06
1.00
1.00
1.01
1.00
1.03
1.13
1.00
1.13
1.00
1.08
1
1.00

Table 3: Median ratio length plans found x = 1, length plans found C
ce
different values x, instances solved planners. entry : 1 means
baselines plans times longer planner. conditional effect merging
used.

5.3.7 C vs. C
ce
Given fixed number -fluents, difference size C C
ce
compilations exponential worst case. Mutex pruning, however, mitigate much
growth C . Consider, example, action C
ce compilation n
different conditional effects. mutexes considered, one would expect number
action representatives generated set -fluents C 2n . If, however,
n -fluents generating conditional effects shown mutex
one another, number action representatives generated C n.
found experiments effect leads much slower growth C
might expected. Consider Figure 2. point graph represents
512

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

Domain
Airport (50)
Barman (20)
Blocksworld (35)
Depots (22)
Driverlog (20)
Elevators (20)
Floortile (20)
FreeCell (80)
Grid (5)
Gripper (20)
Logistics00 (28)
Logistics98 (35)
Miconic (150)
Mprime (35)
Mystery (30)
Nomystery (20)
Openstacks (20)
Parcprinter (20)
Parking (20)
Pathways (30)
Pegsol (20)
Pipes-NoTank (50)
Pipes-Tank (50)
PSR (50)
Rovers (40)
Satellite (36)
Scanalyzer (20)
Sokoban (20)
Tidybot (20)
TPP (30)
Transport (20)
Trucks (30)
Visitall (20)
Woodwork (20)
Zenotravel (20)
Total (1126)

x=1
36
13
35
19
20
19
6
79
5
20
28
34
150
35
16
9
20
16
20
30
20
42
38
50
40
35
18
19
16
30
11
14
19
20
20
1002

MaD
+2

+5

+0

+1

+0

+3

+0

+2

+0

+0

+0

+1

+0

+0

+0

+2

+0

+7

+1

+2

+0

+1

+4

+0

+0

+1

+1

+1

+3

+0

+1

+0

+1

+0

+1

+
19

C
ce
37
14
35
22
20
19
20
80
4
20
28
35
150
35
18
9
20
9
12
24
20
42
41
50
40
36
19
18
14
30
11
16
18
20
20
1006

Coverage
C
-nm
C
ce
36
38
19
18
35
35
21
21
20
20
20
19
20
20
80
79
5
5
20
20
28
28
35
35
150
150
35
35
19
19
7
11
20
20
5
10
18
15
29
29
20
20
42
42
41
40
50
50
40
40
36
36
20
20
17
17
14
16
30
30
15
11
15
16
20
18
20
20
20
20
1022
1023

hFF
34
20
35
18
20
19
6
79
5
20
28
33
150
35
16
10
20
20
20
30
20
43
39
50
40
36
18
19
14
30
11
19
3
20
20
1000

hcea
42
0
35
18
20
20
6
79
5
20
28
35
150
35
19
7
19
12
20
28
20
40
32
50
40
36
20
3
16
29
17
15
3
8
20
947

LAMA
31
20
35
21
20
20
5
79
5
20
28
35
150
35
19
13
20
20
20
30
20
44
43
50
40
36
20
19
17
30
19
15
20
20
20
1039

PF
36
20
35
22
20
20
20
79
5
20
28
35
150
35
19
13
20
20
20
30
20
44
44
50
40
36
20
19
17
30
19
16
20
20
20
1062

Table 4: Comparison state-of-the-art-heuristics satisficing planning. Columns x = 1
MaD Table 1. Column C
ce shows coverage best configuration (in terms overall
coverage) compilation using conditional effect merging (namely x = 1.5, = 60);
C
C
ce -nm best ce configuration without conditional effect merging (which happens use
C
x t); best C configuration x > 1 (which happens use
x t). Entries bold columns difference baseline planner
exceeds threshold significance (given MaD column). Column PF shows coverage
portfolio planner runs LAMA 1500 seconds C
ce 300 seconds.
single problem instance (from instance set before), paired value x.
C
C
ce (x-axis) (y-axis), measure ratio growth |A| growth
|F |, i. e., factor compilation increased size action set encoding
(measured number actions C number conditional effects C
ce ),
divided factor compilation increased number fluents.
513

fiKeyder, Hoffmann, & Haslum

1e+08
Action set growth/uent set growth, C

Action set growth/uent set growth, C

4.5
4
3.5
3
2.5
2
1.5
1
0.5
0

0

0.5

1

1.5

2

2.5

3

3.5

4

4.5

Action set growth/uent set growth, Cce

1e+07
1e+06
100000
10000
1000
100
10
1

0

50

100

150

200

250

300

350

Action set growth/uent set growth, Cce

(a)

(b)

Figure 2: Growth problem size ratio growth |A| growth |F |, (a) without
(b) mutex pruning. point corresponds single instance value x. f (x) = x
shown reference.

words, assess growth encoding number conjunctions |C|,
theory worst-case exponential C linear C
ce .
mutex pruning used (Figure 2 (b)), growth C rapid
ratio quickly increases millions; mutex pruning (Figure 2 (a)), growth C
still faster C
ce , difference much smaller.
5.3.8 Finding Plans Search
growth time limit imposed construction C C
ce tasks,
Algorithm 1 used complete planning algorithm. competitive
heuristic search methods, nevertheless interesting observe performance details
algorithm various domains. coverage obtained algorithm using
C C
ce compilations, well statistics growth compiled
C
tasks, shown Table 5. difference C
ce much visible here,
since number -fluents added is, general, much larger growth-bounded
constructions used heuristic computation. C
ce able rapidly add much
larger number -fluents, therefore find relaxed plans solutions
C
original planning task well. Overall, C
ce solves 568 tasks compared 404 ,
solves equal greater number tasks except 4 domains.
Considering individual domains, seen C C
ce able solve
almost tasks certain domains Logistics00, Mprime, Mystery, Parcprinter,
PSR, Woodworking. domains, even addition small amount
information sufficient obtain relaxed plans plans original task,
maximum x values required solve tasks quite low. case Mprime,
Mystery, Woodworking domains, maximum required x values 4.07, 4.62,
1.35, respectively. others Elevators, Openstacks, Transport, Visitall,
even smallest tasks quite large many different plans possible,
possible introduce enough -fluents disqualify possible relaxed plans
constitute real plans, tasks solved.
514

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

Domain
Airport (50)
Barman-sat (20)
Blocksworld (35)
Depots (22)
Driverlog (20)
Elevators-sat11 (20)
Floortile-sat11 (20)
FreeCell (80)
Grid (5)
Gripper (20)
Logistics00 (28)
Logistics98 (35)
Miconic (150)
Mprime (35)
Mystery (30)
Nomystery-sat11 (20)
Openstacks-sat11 (20)
Parcprinter-sat11 (20)
Parking-sat11 (20)
Pathways-noneg (30)
Pegsol-sat11 (20)
Pipes-NoTank (50)
Pipes-Tank (50)
PSR (50)
Rovers (40)
Satellite (36)
Scanalyzer-sat11 (20)
Sokoban-sat11 (20)
Tidybot-sat11 (20)
TPP (30)
Transport-sat11 (20)
Trucks (30)
Visitall-sat11 (20)
Woodwork-sat11 (20)
Zenotravel (20)
Total (1126)

Cov.
34
0
33
16
15
0
4
1
4
16
27
24
106
35
19
5
0
20
0
5
19
10
9
50
21
15
9
0
1
20
0
15
0
20
15
568

Min
1.00
1.21
1.82
1.00
31.47
91.41
1.29
5.37
1.27
1.22
1.20
1.02
1.02
16.72
3.66
1.77
69.36
3.51
2.69
1.03
1.35
4.22
1.90
22.42
1.17
5.54
1.00
1.00

C
ce
Max
44.50
141.79
90.93
37.11
216.18
91.41
22.53
208.75
91.10
41.16
175.11
4.07
4.62
59.80
76.04
51.72
707.06
187.41
94.33
77.38
459.66
43.61
47.75
22.42
43.12
21.36
1.35
92.26

C
Med
2.31
11.44
8.48
8.92
112.50
91.41
1.41
67.69
6.79
31.14
55.01
1.15
1.25
41.14
9.95
7.26
137.98
11.60
13.46
7.29
7.40
19.16
13.93
22.42
13.75
13.56
1.24
7.25

Cov.
31
0
30
14
14
0
9
2
4
6
27
21
36
35
19
3
0
9
0
3
0
5
8
49
14
7
10
1
0
7
0
8
0
20
12
404

Min
1.00
1.21
1.82
1.00
48.92
212.24
1.31
6.77
1.27
1.22
1.20
1.02
1.02
21.91
1.60
2.32
12.61
2.56
1.05
1.70
5.22
2.38
2.89
1.17
6.32
1.00
1.00

Max
168.45
400.94
221.41
74.97
633.11
272.12
41.22
501.28
585.53
149.91
2706.86
13.22
8.34
43.50
276.81
203.41
738.88
110.51
1052.26
645.00
399.10
161.42
2.89
560.95
100.15
1.40
191.54

Med
3.56
15.49
12.45
9.96
107.21
242.18
1.54
76.12
14.11
5.80
54.47
1.14
1.20
33.27
88.23
89.79
242.54
11.71
16.04
26.04
22.09
44.21
2.89
11.27
41.05
1.25
11.14

Table 5: Solving planning tasks search. Table shows Coverage C C
ce compilations, Minimum, Maximum, Median values x solved tasks.

6. Heuristics Optimal Planning
consider admissible heuristics, optimal planning. Section 6.1 considers
LM-cut heuristic, showing certain complications make difficult
obtain improved heuristic estimates C C
ce . Section 6.2, consider
alternative method lower-bound h+ , namely admissible cost-partitioning heuristics based
conjunctive landmarks obtained C
ce . detail choose C
setting, present experimental results Section 6.3.
515

fiKeyder, Hoffmann, & Haslum

a1


a2
a3

g2

aC
3

g1

g1


a1
a2
a3

g2

aC
2

0

g3

g3
(a)

0

{g1 ,g2 ,g3 }
aC
1

0

(b)

Figure 3: LM-cut , C compilation, Example 3.
6.1 LM-cut
state-of-the-art admissible approximation h+ computed LM-cut algorithm
(Helmert & Domshlak, 2009). logical approach obtaining admissible heuristics
C C
ce therefore apply LM-cut compilations. Unfortunately, turns
several serious obstacles this. discussing issues, first give
brief description LM-cut algorithm, present simpler case C
compilation, additional complication conditional effects present.
LM-cut computed planning task deletes, simple transformation first applied replaces goal set G single goal achieved
goal-achievement action whose precondition set G, adds dummy precondition actions whose precondition set empty. LM-cut initializes hLM-cut := 0
and, repeats following steps hmax (G) becomes 0: (1) Compute hmax ; (2) apply
precondition choice function (PCF) action precondition pre(a) removes
pre(a) one fluents p pre(a) hmax (p) maximal; (3) construct
justification graph whose vertices fluents whose arcs precondition/effect
pairs according PCF; (4) find cut L initial state goal
justification graph, given set actions enters goal zone, i. e., set
fluents goal reached 0 cost; (5) add costmin := minaL cost(a)
heuristic value hLM-cut , reduce cost L costmin . proved
Helmert Domshlak (2009), algorithm two fundamental properties, namely (i)
admissibility, hLM-cut h+ , (ii) domination hmax , hmax hLM-cut .
would expected heuristic obtained manner C would
strictly informative obtained original planning task ,
turns case. Indeed, heuristic become strictly less informative:
Example 3 Let = hF, A, I, Gi given F = {g1 , g2 , g3 }, = {a1 , a2 , a3 },
ai = h, {gi }, , i, = , G = {g1 , g2 , g3 } (Figure 3). words, three goals,
achievable single action. Valid plans apply action
order, make goals true. cuts found LM-cut algorithm task
{a1 }, {a2 }, {a3 }, regardless PCFs chosen, LM-cut algorithm therefore
always computes optimal cost 3. Consider C compilation results
set C = {{g1 , g2 , g3 }}. F C contains single -fluent {g1 ,g2 ,g3 } , representative
0
0
action aC
constructed sole non-empty subset C = {{g1 , g2 , g3 }} C.
first cut found LM-cut contains three representatives, adds
expensive goal {g1 ,g2 ,g3 } . possible PCFs, next cut last,
final heuristic estimate 2 two cuts found. If, example,
516

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

0

0

C
precondition choice function chooses g1 hmax justifier aC
2 a3 , g2
0
max
C
h
justifier a1 , cut {a1 , a2 }. cut, goal reached 0 cost
{{g ,g ,g }}
via a1 , a2 , a3 1 2 3 , hmax 0 LM-cut stops.

+
C
Note (similarly h+ (C
ce ), cf. Theorem 2) possible either h ( )
hmax (C ) decrease addition -fluents, example hmax
cost task actually increases (from 1 2) addition -fluent {g1 ,g2 ,g3 } .
However, type interactions introduced difficult LM-cut algorithm
reason about, resulting worse admissible bounds practice. LM-cut course continues dominate hmax , proving sufficient number -fluents added, LM-cut
eventually tend towards optimal cost task.

weakness pointed Example 3 inherited application LM-cut
algorithm C
ce compilation. Furthermore, application involves additional complication proves formidable: LM-cut defined conditional effects, therefore
cannot directly applied C
ce task. turns two straightforward
adaptations algorithm problems conditional effects, neither preserves
properties (i) admissibility (ii) domination hmax .
see (ii) stake, consider planning task single action
two conditional effects ce(a)1 = h{p}, {q}, ce(a)2 = h{q}, {r}, i, initial state
{p}, goal {r}. h+ () = hmax () = 2 due critical path ha, ai,
justification graph considered LM-cut consists sequence. first cut found
{a}. cost reduced, remaining task hmax cost 0, resulting
cost estimate hLM-cut = 1.
issue different conditional effects action may part
critical path. natural approach therefore reduce costs per individual conditional
effect, rather effects action once. Unfortunately, turns
preserve admissibility (i). Indeed, detail Example 4 (Appendix A),
exist STRIPS tasks whose C
ce compilations following property:
exists action reducing cost globally first encountered cut
leads heuristic estimate less hmax (C
ce ), treating effects
+
C
separately leads estimate greater h (ce ) = h ().
therefore simple strategy dealing conditional effects preserves
(i) (ii) planning tasks. Since admissibility cannot sacrificed, must
reduce costs globally give dominating hmax . particular implication
1
C

so, despite Theorem 5 shows hmax (C
ce ) = h (ce ) converges h (),
convergence guaranteed hLM-cut (C
ce ). could course fixed using
max(hmax , hLM-cut ) heuristic value, yet hmax typically informative,
strategy useful practice.
detail Section 6.3 below, IPC benchmarks, using LM-cut computed either C C
ce often results larger search spaces -fluents introduced. cases, overall performance worse hLM-cut (C ) hLM-cut (C
ce )
hLM-cut (). remains open question whether improved.
517

fiKeyder, Hoffmann, & Haslum

6.2 C
ce Landmarks
Landmarks planning tasks formulas set fluents F property made true state execution valid plan.
problem checking whether even single fluent landmark planning task
PSPACE-complete, approaches finding landmarks past focused
delete relaxation, setting whether fluent landmark checked
polynomial time. recently shown maximum fixpoint solution
set simple recursive equations defines complete set single fact delete-relaxation
landmarks, words landmark formulas consist single literal
= p (Keyder et al., 2010). solution computed algorithm repeatedly updates set landmarks fluent action planning task,
convergence. method naturally handle conditional effects treating
independent actions, described Section 5.1.
shown equations applied AND/OR graph
structure, necessarily corresponding delete relaxation planning task.
insight used obtain landmarks task. Single -fluent landmarks
correspond conjunctive landmarks necessarily landmarks
delete relaxation + . approach suffers, however, large number -fluents
considered , rendering landmark generation impractical compilations larger tasks. aim take advantage flexibility C
ce compilation
obtain non-delete-relaxation landmarks original task, considering
focused set -fluents given size m. before, allow us
consider larger conjunctions keeping size delete relaxation task low.
using C
ce landmark finding, focus technique keep overhead
bay, choose set conjunctions C guarantee every -fluent landmark
C
ce (and therefore original planning task). accomplished extracting
landmark graph sets landmarks simultaneously achieved :
Definition 7 (Simultaneously achieved landmarks) set landmarks Ls = {1 ,
. . . , n } simultaneously achieved Lc = 1 ... n landmark .
Maximal sets simultanously achieved landmarks easily extracted set
landmarks orderings. Given initial set landmarks L set orderings,
following sets sets simultaneously achieved landmarks:
LG = {{ | G |= }}
Lnec = {{ | nec } | L}
Lgn = {{ | gn } | L}
LG contains single set made landmarks L entailed G. Since
valid plan must make goals true final state, necessarily simultaneously
achieved. Given landmark , Lnec contains set elements landmarks ordered necessarily . Due definition necessary orderings,
must simultaneously true every state immediately precedes state
becomes true. Lgn similar set, yet since greedy necessary orderings
518

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

weaker necessary orderings, sometimes contain sets appear Lnec ,
therefore result larger overall set conjunctive landmarks. Note necessary orderings greedy necessary orderings, conjunctive landmark
results set necessary orderings therefore subset conjunctive landmark
results greedy necessary orderings. include conjunctive landmarks result
necessary orderings result stronger necessary orderings added
conjunctive landmark . Landmark heuristics sometimes infer
conjunctive landmarks must reachieved landmark ordered necessarily
reachieved. case conjunctive landmarks derived
greedy-necessary orderings, need achieved make landmarks
ordered true first time.
Algorithm 2: Choosing C landmark generation.
C=
L = FindLandmarks(C
ce )
repeat
C = C SimultaneouslyAchieved(L)
L = FindLandmarks(C
ce )
SimultaneouslyAchieved(L) C

strategy choosing C landmark generation shown Algorithm 2.
new conjunctive landmarks L = p1 pn discovered, corresponding fluents
{p1 ,...,pn } added C
ce landmark computation step repeated. Note
process may go several iterations, run fixpoint reached,
addition new -fluents C
ce task result discovery new landmarks.
process terminates new conjunctive landmarks discovered already
exist -fluents C
ce . note method choosing C desired
C
property mentioned above: -fluents introduced C
ce represent fact landmarks ce
conjunctive landmarks original task .
strategy works especially well domains many landmarks several landmarks necessarily greedy necessarily ordered them. One domain
occurs Blocksworld (see illustration Figure 4), method
able find extremely informative conjunctive landmarks allow optimally solve
tasks heuristic tested.
6.3 Experiments
consider performance LM-cut heuristic hLM-cut C C
ce compilations, admissible landmark cost-partitioning heuristic hLM introduced
Karpas Domshlak (2009) different landmark generation schemes, including
LM-cut used search algorithm, hLM
landmarks obtained C
ce . h

use LM-A , variant effective known fluent landmarks
(Karpas & Domshlak, 2009). benchmarks, computers, time/memory limits
used Section 5.3.
519

fiKeyder, Hoffmann, & Haslum

Informativeness
Coverage
Domain
C , 1.5
C
,
1.5
Orig.
x
=
1
C , 1.5 C
ce
ce , 1.5
Airport
1 : 49.02
1 : 52.91
28
28
19
18
Barman-opt
1 : 1.06
1 : 1.12
4
4
4
4
Blocksworld
4.22 : 1
1 : 1.71
28
28
28
27
Depots
1 : 1.96
1 : 6.49
7
5
4
4
Driverlog
1 : 23.7
1 : 48.31
13
13
10
10
Elevators-opt11
1.65 : 1
1 : 1.03
18
18
16
15
Floortile-opt11
19.23 : 1
13.93 : 1
7
6
12
12
FreeCell
1.07 : 1
1 : 2.12
15
15
13
9
Grid
3.47 : 1
1 : 1.35
2
2
2
1
Gripper
1:1
1:1
7
7
6
6
Logistics00
1 : 9.38
1 : 10.47
20
20
16
15
Logistics98
1 : 7.69
1 : 18.87
6
6
2
3
Miconic
1 : 232.55
1 : 769.23 141 141
50
45
Mprime
13.08 : 1
1 : 1.13
22
22
28
22
Mystery
1.03 : 1
1.07 : 1
16
16
17
17
Nomystery-opt11
1 : 126.58
1 : 588.24
14
14
8
8
Openstacks-opt11
1:1
1:1
14
14
14
14
Parcprinter-opt11
1 : 1.14
1 : 4.23
13
13
13
12
Parking-opt11
2
1
1
0
Pathways-noneg
1 : 15.72
1 : 51.81
5
5
4
4
Pegsol-opt11
1.08 : 1
1.08 : 1
17
17
17
17
Pipes-NoTank
1 : 1.48
1 : 2.09
17
17
15
14
Pipes-Tank
1 : 1.30
1 : 2.25
11
10
8
7
PSR
1.04 : 1
1 : 1.03
49
49
49
49
Rovers
1 : 1.72
1 : 3.56
7
7
7
6
Satellite
1 : 3.77
1 : 33.33
7
7
6
6
Scanalyzer-opt11
1 : 1.36
1 : 1.06
11
11
4
5
Sokoban-opt11
1 : 1.28
1 : 1.31
20
20
20
20
Tidybot-opt11
1 : 4.79
1 : 13.19
13
13
7
6
TPP
1 : 5.14
1 : 1.70
6
6
6
6
Transport-opt11
1 : 1.87
1.35 : 1
6
6
6
7
Trucks
1 : 5.94
1 : 10.26
10
10
7
6
Visitall-opt11
1 : 3.86
1 : 3.32
10
10
10
10
Woodwork-opt11
4.07 : 1
1 : 2.36
11
11
7
5
Zenotravel
1 : 39.37
1 : 153.85
12
12
8
8
Total
589 584
444
418
C
Table 6: LM-cut C
ce . two columns left show ratio summed

number heuristic evaluations tasks solved configurations, comparing standard
LM-cut results x = 1 LM-cut computed C C
ce x = 1.5. example,
first entry table, 1 : 49.02, shows LM-cut computed C growth bound
x = 1.5 evaluates, sum commonly solved tasks, nearly 50 times many states LM-cut
computed standard delete relaxation. last 4 columns show coverage. Column Original
shows results obtained Fast Downwards implementation LM-cut (which applies
standard delete relaxation), column x = 1 shows results implementation LMcut unmodified delete relaxation (with differences two purely due
implementation details). Entries bold indicate highest coverage domain, total.

520

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

clear(a)
gn
clear(b)
handempty
ontable(b)

clear(a)
holding(b)

nat

nat

clear(b)
handempty
on(b, a)
clear(c)
handempty
ontable(c)

clear(b)
clear(d)
gn
on(b, a)
holding(c)
nat ontable(d)
gn

on(b, a)
on(c, b)
on(d, c)

nec

clear(c)
clear(c)
clear(d)
on(b, a) gn handempty
on(c, b)
on(b, a)
holding(d)
on(c, b)
ontable(d)

Figure 4: Landmarks graph found C
ce compilation small Blocksworld task,
blocks initially table G = {on(b, a), on(c, b), on(d, c)}. smaller conjunctive
landmarks single fluent landmarks omitted.

6.3.1 LM-cut C C
ce
evaluate impact using C C
ce compilations LM-cut, constructed
C
C
ce tasks following procedure described Section 5.3, repeatedly
selecting conflicts increase size compiled task reached fixed growth
bound x. Conflict selection based hmax supporters rather hadd supporters,
hmax plays key role computation LM-cut, resulted better performance.
that, procedure used generate C C
ce tasks same.
C
tested value x set {1.5, 2, 2.5, 3} C
ce . observed
x = 1.5 dominated larger values x domain-by-domain overall basis,
therefore report results two configurations. exception
Mystery domain, C x = 2.5 x = 3 solved 18 tasks compared 17
x = 1.5.
Overall, heuristic computed LM-cut algorithm standard delete relaxation + dominates computed C C
ce , terms informativeness
terms coverage. first two columns Table 6 show large majority
domains, search using LM-cut computed C C
ce performs many heuristic
evaluations tasks solved configurations. Airport domain,
instance, LM-cut standard delete relaxation requires approximately 50 times fewer
heuristic evaluations solve set tasks either C C
ce . domains, situation less extreme, standard delete relaxation continues give
better heuristic estimates. exceptions Blocksworld, Elevators, Floortile,
FreeCell, Grid, Mprime, Mystery, Pegsol, PSR, Transport Woodworking domains,
+
least one C C
ce yields informative heuristic estimates .
impressively, C C
ce give estimates respectively 19 14 times informative estimates obtained + Floortile domain, estimates using
C 13 times informative + Mprime domain. terms
coverage, translates 12 tasks solved C C
ce Floortile domain,
compared 7 standard version LM-cut, 28 tasks solved C
521

fiKeyder, Hoffmann, & Haslum

Mprime domain, compared 22. Mystery domain, coverage increased 1.
domains, coverage achieved C C
ce -based LM-cut less equal
coverage achieved standard LM-cut. Overall, standard version LM-cut
solves 589 planning tasks compared 445 C 418 C
ce . Though large part
difference (90 tasks) comes Miconic domain, difference remaining
domains still significant.
Comparing C C
ce , seen additional loss information resulting
treatment conditional effects LM-cut leads worse heuristic estimates
C
using C
ce . expected theoretical result ce grows linearly
number -fluents, number -fluents added task using
C
C
ce compilation almost always higher using . However treatment
conditional effects LM-cut (described above) turns greatly degrade performance,
C
LM-cut using C
ce informative LM-cut using 4 domains.
6.3.2 Admissible Landmark Heuristics C
ce Landmarks
admissible landmark heuristic, hLM , uses action cost partitioning derive heuristic
values collection (ordered) landmarks, distributing cost action
set landmarks achieves (Karpas & Domshlak, 2009). Cost partitioning done
different ways: optimal cost partitioning tractable, yields best possible heuristic
value given set landmarks, practice slow coverage suffers; uniform
partitioning generally achieves better time/informativeness trade-off, therefore better
coverage.
evaluate potential informativeness landmarks obtained C
ce using
iterative technique described Section 6.2, used landmarks optimal cost
partitioning setting, since setting makes best possible use information present
given landmarks. compared informativeness heuristic using
landmarks obtained compilation = 1 = 2 sound
complete landmark generation algorithm (Keyder et al., 2010). results shown
first two columns Table 7. show ratio total number heuristic evaluations,
per domain, tasks solved configurations, hLM using landmarks 1
heuristic using landmarks 2 C
ce , respectively. Note landmarks
2 compilations contain landmarks obtained 1
generated C


ce
subset, hLM optimal partitioning 2 C
ce landmarks therefore
dominates hLM optimal partitioning 1 landmarks. Hence ratio always
greater 1.
9 35 domains considered, neither addition 2 landmarks C
ce landmarks leads informative heuristic (cases columns show value 1).
remaining 26 domains, schemes improve 1 landmarks equal degree
7, 2 improves 1 greater degree C
ce 17. one case, Blocksworld,
C
landmarks

much

informative

landmarks
found methce
ods, improve informativeness baseline heuristic using 1 landmarks
factor 122.
Uniform cost partitioning divides cost action evenly set landmarks
achieves, rather searching partitioning maximizes heuristic value
522

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

Domain

Airport
Barman-opt
Blocksworld
Depots
Driverlog
Elevators-opt11
Floortile-opt11
FreeCell
Grid
Gripper
Logistics00
Logistics98
Miconic
Mprime
Mystery
Nomystery-opt11
Openstacks-opt11
Parcprinter-opt11
Parking-opt11
Pathways-noneg
Pegsol-opt11
Pipes-NoTank
Pipes-Tank
PSR
Rovers
Satellite
Scanalyzer-opt11
Sokoban-opt11
Tidybot-opt11
TPP
Transport-opt11
Trucks
Visitall-opt11
Woodwork-opt11
Zenotravel
Total

Informativeness
Coverage
(optimal partitioning) (uniform partitioning)
2
C
1
2
C
ce
ce
1.03
1.03
27
11
27
4
4
4
25.65
122.31
26
28
32
4.28
1.11
7
7
7
1.02
1.01
10
9
9
1.54
1.54
12
12
12
3.28
1.02
2
2
2
1.32
1.01
60
38
39
1.12
1.12
2
2
2
1
1
7
6
7
13.65
13.65
20
22
22
1.25
1.25
3
3
3
3.91
3.91
142
142
143
1.39
1
20
20
20
2.17
1
15
15
15
3.08
1.69
20
20
18
1
1
12
7
11
4.09
1
10
8
10
9.84
1
3
0
0
1
1
4
4
4
1.25
1
17
15
17
1.37
1.27
16
16
16
1.64
1.13
13
10
11
2.68
1.23
49
49
49
1
1
6
6
5
1.06
1.06
6
6
6
1.54
1.01
6
3
6
1.02
1
20
14
18
1.18
1.05
14
9
14
1
1
6
6
6
1
1
6
6
6
1
1
8
6
7
1
1
16
9
9
3.04
1.16
7
4
5
1
1
8
8
8
604
527
570

Table 7: hLM landmarks generated delete relaxation (1 ), 2 (Keyder et al., 2010)
C
ce . two columns left show ratio summed number heuristic evaluations
tasks solved configurations, comparing 2 C
ce baseline using landmarks
1 . Using optimal cost partitioning hLM , landmarks yield better lower bounds,
indeed ratios 1 (which use : 1 presentation, differently
previous tables). right-most three columns show coverage, using uniform cost partitioning.
heuristic uniform partitioning solves tasks optimal cost partitioning
landmark generation schemes considered. Entries bold indicate best results, per domain
total.

523

fiKeyder, Hoffmann, & Haslum

state. make hLM heuristic weaker, though typically much,
makes much faster compute, leading better coverage general. confirmed
uniform cost partitioning results higher coverage optimal cost partitioning
domains three landmark generation schemes considered.
three right-most columns Table 7 show coverage achieved hLM
three landmark generation schemes setting. seen using 1 landmarks results greater coverage combining either 2 C
ce landmarks.
2
C
Compared heuristic using landmarks, using ce landmarks solve many
tasks every domain except Nomystery Rovers domains. C
ce landmarks outperform 1 landmarks two domains: Blocksworld, using C
landmarks
planner
ce
finds optimal solutions 32 35 tasks, tested heuristic,
Miconic, 1 instance. domains, use C
ce landmarks either
1
effect worsens coverage compared . Interestingly, informativeness
LM-cut heuristic increases greatly C C
ce compilations Floortile domain, corresponding increase compilations used find landmarks.
conjunctive landmarks, besides goal, found.

7. Conclusions Open Questions
long tradition works attempting devise heuristics taking account
delete effects. However, techniques rendering h+ perfect limit thus allowing
smoothly interpolate h+ h proposed quite recently,
Haslum (2012) Katz et al. (2013) respectively. extended Haslums approach
introducing new compilation method linear (vs. worst-case exponential) growth,
demonstrated machinery needed using approach generate heuristics.
evaluation shows that, domains, informedness dramatically improved
small cost terms computational overhead.
main open issue lies use words domains here.
domains, gain informativeness small, domains overall performance
suffers dramatically. domain-independent planning technique work well
every domain, simple portfolio approach (cf. column PF Table 4) suffices
improve state art satisficing planning, extent per-domain performance variation technique dramatic. obtain understanding
causes phenomena, ultimately exploit understanding devise reliable/effective practical methods? unchanged worse performance many domains
due fundamental limitations technique, due particular instantiation
(especially selection -fluents) run experiments?
practical perspective, answering questions comes exploration
techniques predicting impact adding -fluents, making informed
decisions -fluents add. observed changes domain formulation, random reorderings, small changes heuristic criteria used -fluent
selection large impact heuristic informativeness coverage. research formulate new heuristic criteria improve existing ones therefore could,
potentially, provide better performance across wide range domains. might in524

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

teresting systematically explore impact random/arbitrary changes, attempt
building complementary-strength compilations combined effective portfolios.
theoretical perspective, currently approaching questions
terms analyzing conditions small (polynomial-size) set -fluents
suffices render h+ perfect. Applied individual domains, analysis offers way
answering question whether lack performance improvement due
essential limitation due choosing wrong set -fluents. hope
eventually obtain syntactic criteria (e. g., based causal graph structure)
automatically applied arbitrary planning task descriptions, serving select -fluents
(or exclude subsets -fluents consideration) targeted manner. first
results direction already published HSDIP14 (Hoffmann, Steinmetz,
& Haslum, 2014).
observations optimal planning pose many questions future work. simple one
whether effective C
ce landmarks could extracted restricting techniques
adding -fluents guaranteed landmarks. daunting challenges regard
LM-cut. observations suggest methods use suffer greatly suboptimal
choices precondition choice functions (PCFs). would therefore worthwhile investigate new methods obtaining better PCFs. Another important direction develop
extensions LM-cut conditional effects guarantee admissibility domination hmax . simple yet impractical method multiply conditional effects
(enumerating subsets thereof). sophisticated method based context splitting, distinctions different occurences action introduced
targeted manner necessary, recently proposed (Roger, Pommerening,
& Helmert, 2014).
summary, explicitly represented conjunctions clearly exhibit potential dramatically improve delete relaxation heuristics. much remains done order
understand use effectively.

Acknowledgments
Part work leading publication carried Emil Keyder Jorg
Hoffmann working INRIA Grand Est, Nancy, France. NICTA funded
Australian Government Department Communications Australian
Research Council ICT Centre Excellence Program. thank University
Freiburg allowing us use computional resources.

Appendix A. Proofs
Theorem 3 (h+ (C ) dominates h+ (C
ce )) Given planning task set con+
C
+
C
junctions C, h ( ) h (ce ). cases inequality strict.
Proof: follows fact plan C plan C
ce , yet
Cn plan C .
1
inverse case. show first part, let = haC
,
.
.
.
,

n
1
show sequence actions constitutes plan C
ce , showing
Cn ] C [aC , . . . , aC ] , I[. . . ]
1
induction C [aC
,
.
.
.
,

denotes
result
ce
n
n ce
1
1
525

fiKeyder, Hoffmann, & Haslum

applying sequence actions initial state C C
ce . Since goal tasks
defined GC , shows desired result. base case, initial state
C
C C
ce , subset relation holds. inductive case, assume
Ci1
C1
C
C
C
C
C
[a1 , . . . , ai1 ] [aC
1 , . . . , ai1 ]ce . Since precondition ai ce subset
C
C
C C
C

precondition aC
Ci , ai applied [a1 , . . . , ai1 ]ce
C

induction hypothesis. need show fluents added aC

Ci
C
C C
C
C
added aC
ce applied [a1 , . . . , ai1 ]ce . add effect ai consists
C
union two sets, (add(a) (pre(a) \ del(a))) , add effect aC

Ci
C
0
C
0
ce therefore added, {c | c Ci }. Since ai applicable ,

Ci1
1
preconditions (pre(a) c0 Ci (c0 \add(a)))C must true C [aC
1 , . . . , ai1 ], therefore
C
0
C [aC
1 , . . . , ai1 ]ce , induction hypothesis. c C (and therefore c Ci , Ci
C
C
C), aC
ce conditional effect effect c condition (pre(a) (c \ add(a))) ,
Ci
C
applies condition subset precondition ai . shows
desired property.
strictness, consider planning task fluent set F = {p1 , p2 , r, g1 , g2 }, initial
state = {p1 }, goal G = {g1 , g2 }, actions
ap2 : h{p1 }, {p2 }, {r, p1 }, ar : h, {r}, ,
ag1 : h{p1 , r}, {g1 }, , ag2 : h{p2 , r}, {g2 }, ,
Let C = {c F | |c| = 2}. optimal plan C sequence
har , ag1 , ap2 , ar , ag2 i. case C follows fact plan must include
ag1 ag2 actions achieving two goals, therefore must achieve
precondition -fluents {p1 ,r} {p2 ,r} , respectively. -fluents
achieved ar , action achieves either p fluents without deleting
r. single representative ar achieves {p1 ,r} {p2 ,r} ,
representative would precondition {p1 ,p2 } , unreachable, since
action achieving p2 deletes p1 . plan C therefore must contain ag1 , ag2 , least two
instances ar , ap2 .
longer holds, however, considering C
ce , action sequence
hap2 , ar , ag1 , ag2 plan contains 4 actions. C
ce , two possible -fluents
added ar , {p1 ,r} {p2 ,r} , treated independently, separate conditional effect
created each, conditions p1 p2 respectively. p1 p2
achieved separately, single application action ar sufficient achieve
two -fluents, without making true (unreachable) cross-context -fluent {p1 ,p2 } .
similar cases, exist plans C
ce shorter minimum length plans
C .
Given STRIPS task = hF, A, I, G, costi, h1 heuristic set P fluents,
defined follows (Bonet & Geffner, 2001):

0
p
1
h (p) =
min{a|padd(a)} h1 (pre(a)) + cost(a) otherwise
h1 (P ) = max h1 (p)
pP

526

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

value heuristic given planning task taken h1 cost goal
G, h1 () = h1 (G).
Lemma 1 Given planning task C = {c P(F ) | 1 < |c| m}, h1 (C ) = h1 (m ).
Proof: Let = hF, A, I, Gi. C identical except action sets.
denote action set AC (m ) C AC (C ). deletes
conditional effects either AC (m ) AC (C ), ignore
follows.
first show h1 (C ) h1 (m ), h1 (m ) h1 (C ). direction
based following two observations. First, STRIPS planning task,
split actions singleton add effects, without affecting h1 . Precisely, given
action p add(a) \ pre(a), denote a[p] action pre(a[p]) = pre(a)
add(a[p]) = {p}. Replacing split-up actions a[p] (i. e. generating
split-up action a[p] every non-redundant add effect a), h1 remains same. Second,
say every split-up action a[p] action set dominated action a0 action set
A0 , i. e., pre(a0 ) pre(a[p]) add(a0 ) add(a[p]). h1 using A0 lower bound
h1 using A.
prove h1 (C ) h1 (m ). every c F 1 < |c| m,
del(a) c = , add(a) c 6= , AC (m ) contains action ac given pre(ac ) =
(pre(a) (c \ add(a)))C , add(ac ) = add(a) {c0 | c0 C c0 (add(a) c)}. Let
0
p add(ac ). p add(a), aC C 0 = dominates ac [p]. Say p = c0
c0 6 pre(ac ). obtain dominating action AC (C ), define:
C 0 := {c00 C | del(a) c00 = , add(a) c00 6= , c00 c0 }
C 0 C, c00 C 0 conditions (1) del(a) c00 = add(a) c00 6=
(2) c C : ((c c00 add(a) c 6= ) = c C 0 ) Definition 2
obviously satisfied.
0
0
Thus AC (C ) contains action aC given pre(aC ) = (pre(a) c00 C 0 (c00 \ add(a)))C
0
add(aC ) = (add(a) (pre(a) \ del(a)))C {c00 | c00 C 0 }. prove (a)
0
0
pre(aC ) pre(ac ) (b) p = c0 add(aC ).
Regarding (a), every c00 C 0

c00 \ add(a) c0 \ add(a) c \ add(a), thus c00 C 0 (c00 \ add(a)) c0 \ add(a) c \ add(a).
Regarding (b), need prove c0 C, del(a)c0 = , add(a)c0 6= , c0 c0 .
first last properties obvious, second one direct construction.
third one, add(a) c0 6= , true otherwise would c0
c \ add(a) implying contradiction construction c0 pre(ac ).
remains prove h1 (m ) h1 (C ). every C 0 C conditions
0
0
(1) (2) stated above, AC (C ) contains action aC . Let p add(aC ). p
-fluent, either p add(a) p pre(a) \ del(a). latter case irrelevant (and
0
split-up action generated); former case, setting c := add(a) get aC [p]
dominated ac AC (m ). Say p = c . least one following cases
must hold: (a) c C 0 (b) c (pre(a) \ del(a)) (c) c (add(a) (pre(a) \ del(a)))
c add(a) 6= . case (a), follows directly definition ac AC (m )
0
0
dominates aC [p]. case (b), p = c pre(aC ) case irrelevant. case (c),
0
c add(a) 6= c del(a) = ac AC (m ) dominates aC [p].
concludes proof.
527

fiKeyder, Hoffmann, & Haslum

Lemma 2 Given planning task set non-unit conjunctions C, h1 (C )
h+ (C
ce ).
C
Proof: Consider planning task C
no-cc identical except
include cross-context preconditions. is, precondition action representative
0
aC modified following:

0

pre(aC ) = pre(a)C

[

(pre(a) (c0 \ add(a)))C

c0 C 0

1
C
+
C
show (A) h1 (C ) h1 (C
no-cc ), (B) h (no-cc ) h (ce ).

first prove (A). proof Lemma 1, suffices prove that, every split0
C
action aC [p] C
no-cc , exists dominating action . p -fluent,
00
0
aC C C 00 = dominates aC [p]. Otherwise, say p = c0 . least one
following cases must hold: (a) c0 C 0 (b) c0 (add(a) (pre(a) \ del(a))). case (b),
00
0
aC C C 00 = dominates aC [p]. case (a), obtain dominating action
00
aC C , define
C 00 := {c00 C | del(a) c00 = , add(a) c00 6= , c00 c0 }
c00 C 00 satisfy conditions (1) del(a) c00 = add(a) c00 6= (2) c C :
00
((c c00 add(a) c 6= ) = c C 0 ) Definition 2, indeed aC action C .
00
00
obviously c0 C 00 thus p add(aC ). remains prove pre(aC )
0
pre(aC [p]). so, intuitively, C 00 corresponds single conjunction c0 (plus
subsumed conjunctions) hence cross-context fluents arise.S Specifically, every
00
c00 C 00 c00 \add(a) c0 \add(a). Thus pre(aC ) = (pre(a) c00 C 00 (c00 \add(a)))C =
0
(pre(a) (c0 \ add(a)))C . latter obviously contained pre(aC [p]), concluding
proof (A).
+
C
+
C
remains prove (B). Since h1 (C
no-cc ) h (no-cc ), suffices prove h (no-cc )
+
C
+
C
h (ce ). Consider state s, relaxed plan ce ce . action ace
+ , representing action original task , let C 0 set conjunctions c whose
ce
+ C . C 0 obviously qualifies
-fluents added ace execution ce
ce

constraint (1) Definition 2; qualifies constraint (2) conditional effect
c property triggered ace conditional effect suitable c0
C 0 a. Define action sequence +
triggered. Thus C
no-cc includes representative
C 0 + adds fluents ,
C0
C
ce
no-cc sequence . Obviously,
precondition union ace conditional effects fire. Thus
+
C
+
C
+ relaxed plan C
no-cc . follows h (no-cc ) h (ce ) desired.

Example 4 Consider STRIPS planning task variables {i, p, q, r, z, g1 , g2 , g3 },
initial state = {i}, goal G = {g1 , g2 , g3 }, actions follows:
528



fiImproving Delete Relaxation Heuristics Explicit Conjunctions

Name
pre
add del ce cost
aqz
{i}
{q,
z}

4

ari
{i}
{r}

1
pz
{i, q}
{p} {z}
1
aiq
apz
{r}
{p}
{z}

4
r
g1
{p, z} {g1 }

1
apz
agiq2
{i, q} {g2 }

1
g3
ar
{r} {g3 }

1
set C = {{i, q}, {p, z}}. operator adding part {i, q} aqz
adds q.
qz
pz pz
operators adding part {p, z} ai adds z, aiq , ar add p;
pz
since aiq
apz
delete z, cannot used establish conjunction {p, z}.
r
Thus actions C
ce are:
Name
pre
add del
ce cost
qz
qz
ai
{i} {q, z}
ce(ai )
4
ari
{i}
{r}


1
{i,
q,

}
{p}


1
apz
i,q
iq
pz
ar
{r}
{p}


4
{p, z, p,z } {g1 }


1
agpz1
g2
aiq
{i, q, i,q } {g2 }


1
{r} {g3 }


1
agr3
ce(aqz
) contains two conditional effects:
Name
c
add del
i,q
ei
{i} {i,q }


ep p,z
{p} {p,z }

pz
Clearly, respect hmax , -fluents preconditions aiq
, agpz1 , agiq2 dominate respective preconditions actions (as pointed Section 5.1,
implementation actually remove preconditions). Thus LM-cuts justification
graph C
ce would structure shown Figure 5.
+
C
hmax (C
ce ) = 10 due cost achieving g1 . h (ce ), construct
qz pz
plan C
ce choice establish p. use ai , aiq ,
use ari , apz
r . latter case, make single application conditionalg2 g3
r pz qz g1
effects action aqz
, relaxed plan 1 = hai , ar , ai , apz , aiq , ar i, whose cost 12.
qz
former case, must use ai twice first i,q , p,z yielding relaxed
pz qz g1
g2 r g3
+
C
plan 2 = haqz
, aiq , ai , apz , aiq , ai , ar i, whose cost 13. Thus h (ce ) = 12. Since,
pz
execution 1 , delete ar , true anyhow state
execution, 1 solves original task get h () = h+ (C
ce ) = 12.
consider LM-cut, say produced cut conditional-effects action
p,z
aqz
connects p p,z via conditional effect ep . two options discussed
Section 6.1 (A) reduce cost aqz
globally, sticking original definition


LM-cut; (B) reduce cost ep p,z , conditional effect ei i,q
p,z
part optimal-cost path ep thus serves justify hmax value.
options violates one essential properties LM-cut:

529

fiKeyder, Hoffmann, & Haslum



z

p



i,q
aqz
: ei

aqz




q

aqz


:


ei i,q

:

r

arg3

p,z

apz
iq


ei i,q

i,q

apz
r

ari

p,z
aqz
: ep

agiq2

agpz1

g1

g2

g3

Figure 5: Illustration LM-cut justification graphs C
ce Example 4. dashed
edges correspond preconditions critical (hmax -maximizing) start,
become critical point execution LM-cut.


p,z
(A) configuration, LM-cut produces cuts {agpz1 } [cost 1], {aqz
: ep } [cost 4],
pz pz
g2
[cost 1], {ar , aiq } [cost 1], {aiq } [cost 1], {ari } [cost 1]. Note that,
i,q
p,z
qz
qz
cut {aqz
: ep }, cost ai reduced 0 globally; particular, cut {ai : ei }
produced. get heuristic value hLM-cut = 9 < hmax (C
ce ) = 10, LM-cut
dominate hmax .
(B) configuration, LM-cut produce following cuts. start, every
p,z
possible precondition choice function (pcf ), get cuts {agpz1 } [cost 1] {aqz
: ep }
[cost 4]. hmax 5 g1 , g2 ; say pcf selects g2 , get cut {agiq2 }
pz
max 4
[cost 1]. Now, pcf select g1 , getting cut {apz
r , aiq } [cost 1]. Then, h
g1
g1 , g2 ; say pcf selects g1 . Say pcf selects p,z apz (another
choice would z), selects i,q apz
(another choice would q), thus remaining
iq
i,q pz
non-dashed part Figure 5. get cut {aqz
: ei , ar } [cost 3]
g1 reached 0 cost p i,q (we would get cut pcf
selecting g1 , point). Now, hmax 2 g3 1 g1 , g2 , get cut
{agr3 } [cost 1]. point, hmax 1 goal facts; say LM-cut selects g3 , thus
get cut {ari } [cost 1] way achieve r. finally hmax
i,q
1 g2 only, yielding cut {aqz
: ei } [cost 1]. Overall, get heuristic value
hLM-cut = 13 > h () = h+ (C
ce ) = 12, LM-cut admissible.

{agr3 }

Bibliography
Baier, J. A., & Botea, A. (2009). Improving planning performance using low-conflict relaxed
plans. Gerevini, A., Howe, A., Cesta, A., & Refanidis, I. (Eds.), Proceedings
530

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

19th International Conference Automated Planning Scheduling (ICAPS09),
pp. 1017, Thessaloniki, Greece. AAAI Press.
Bonet, B., & Geffner, H. (2001). Planning heuristic search. Artificial Intelligence, 129 (1
2), 533.
Bonet, B., & Helmert, M. (2010). Strengthening landmark heuristics via hitting sets.
Coelho, H., Studer, R., & Wooldridge, M. (Eds.), Proceedings 19th European
Conference Artificial Intelligence (ECAI10), pp. 329334, Lisbon, Portugal. IOS
Press.
Bonet, B., Palacios, H., & Geffner, H. (2009). Automatic derivation memoryless policies
finite-state controllers using classical planners. Gerevini, A., Howe, A., Cesta,
A., & Refanidis, I. (Eds.), Proceedings 19th International Conference Automated Planning Scheduling (ICAPS09), pp. 3441, Thessaloniki, Greece. AAAI
Press.
Bylander, T. (1994). computational complexity propositional STRIPS planning.
Artificial Intelligence, 69 (12), 165204.
Cai, D., Hoffmann, J., & Helmert, M. (2009). Enhancing context-enhanced additive
heuristic precedence constraints. Gerevini, A., Howe, A., Cesta, A., & Refanidis, I. (Eds.), Proceedings 19th International Conference Automated Planning
Scheduling (ICAPS09), pp. 5057, Thessaloniki, Greece. AAAI Press.
Do, M. B., & Kambhampati, S. (2001). Sapa: domain-independent heuristic metric temporal planner. Cesta, A., & Borrajo, D. (Eds.), Recent Advances AI Planning. 6th
European Conference Planning (ECP01), Lecture Notes Artificial Intelligence,
pp. 109120, Toledo, Spain. Springer-Verlag.
Fox, M., & Long, D. (2001). STAN4: hybrid planning strategy based subproblem
abstraction. AI Magazine, 22 (3), 8184.
Garey, M. R., & Johnson, D. S. (1979). Computers IntractabilityA Guide
Theory NP-Completeness. Freeman, San Francisco, CA.
Gazen, B. C., & Knoblock, C. (1997). Combining expressiveness UCPOP
efficiency Graphplan. Steel, S., & Alami, R. (Eds.), Recent Advances AI
Planning. 4th European Conference Planning (ECP97), Lecture Notes Artificial
Intelligence, pp. 221233, Toulouse, France. Springer-Verlag.
Gerevini, A., Saetti, A., & Serina, I. (2003). Planning stochastic local search
temporal action graphs. Journal Artificial Intelligence Research, 20, 239290.
Haslum, P., & Geffner, H. (2000). Admissible heuristics optimal planning. Chien, S.,
Kambhampati, R., & Knoblock, C. (Eds.), Proceedings 5th International Conference Artificial Intelligence Planning Systems (AIPS00), pp. 140149, Breckenridge, CO. AAAI Press.
Haslum, P. (2009). hm (P ) = h1 (P ): Alternative characterisations generalisation
hmax hm . Gerevini, A., Howe, A., Cesta, A., & Refanidis, I. (Eds.), Proceedings 19th International Conference Automated Planning Scheduling
(ICAPS09), pp. 354357, Thessaloniki, Greece. AAAI Press.
531

fiKeyder, Hoffmann, & Haslum

Haslum, P. (2012). Incremental lower bounds additive cost planning problems.
Bonet, B., McCluskey, L., Silva, J. R., & Williams, B. (Eds.), Proceedings 22nd
International Conference Automated Planning Scheduling (ICAPS12), pp.
7482, Sao Paulo, Brasil. AAAI Press.
Helmert, M. (2006). Fast Downward planning system. Journal Artificial Intelligence
Research, 26, 191246.
Helmert, M., & Domshlak, C. (2009). Landmarks, critical paths abstractions: Whats
difference anyway?. Gerevini, A., Howe, A., Cesta, A., & Refanidis, I. (Eds.),
Proceedings 19th International Conference Automated Planning Scheduling (ICAPS09), pp. 162169, Thessaloniki, Greece. AAAI Press.
Helmert, M., & Geffner, H. (2008). Unifying causal graph additive heuristics.
Rintanen, J., Nebel, B., Beck, J. C., & Hansen, E. (Eds.), Proceedings 18th
International Conference Automated Planning Scheduling (ICAPS08), pp.
140147, Sydney, Australia. AAAI Press.
Hoffmann, J. (2005). ignoring delete lists works: Local search topology planning
benchmarks. Journal Artificial Intelligence Research, 24, 685758.
Hoffmann, J., & Nebel, B. (2001). planning system: Fast plan generation
heuristic search. Journal Artificial Intelligence Research, 14, 253302.
Hoffmann, J., Porteous, J., & Sebastia, L. (2004). Ordered landmarks planning. Journal
Artificial Intelligence Research, 22, 215278.
Hoffmann, J., Steinmetz, M., & Haslum, P. (2014). take render h+ ( c )
perfect?. Proceedings 6th Workshop Heuristics Search Domain
Independent Planning, ICAPS14.
Karpas, E., & Domshlak, C. (2009). Cost-optimal planning landmarks. Boutilier, C.
(Ed.), Proceedings 21st International Joint Conference Artificial Intelligence
(IJCAI09), pp. 17281733, Pasadena, California, USA. Morgan Kaufmann.
Katz, M., Hoffmann, J., & Domshlak, C. (2013). said need relax variables?.
Borrajo, D., Fratini, S., Kambhampati, S., & Oddi, A. (Eds.), Proceedings
23rd International Conference Automated Planning Scheduling (ICAPS13),
pp. 126134, Rome, Italy. AAAI Press.
Keyder, E., & Geffner, H. (2008). Heuristics planning action costs revisited.
Ghallab, M. (Ed.), Proceedings 18th European Conference Artificial Intelligence (ECAI08), pp. 588592, Patras, Greece. Wiley.
Keyder, E., & Geffner, H. (2009). Trees shortest paths vs. Steiner trees: Understanding
improving delete relaxation heuristics. Boutilier, C. (Ed.), Proceedings
21st International Joint Conference Artificial Intelligence (IJCAI09), pp. 1734
1749, Pasadena, California, USA. Morgan Kaufmann.
Keyder, E., Hoffmann, J., & Haslum, P. (2012). Semi-relaxed plan heuristics. Bonet, B.,
McCluskey, L., Silva, J. R., & Williams, B. (Eds.), Proceedings 22nd International Conference Automated Planning Scheduling (ICAPS12), pp. 128136,
Sao Paulo, Brasil. AAAI Press.
532

fiImproving Delete Relaxation Heuristics Explicit Conjunctions

Keyder, E., Richter, S., & Helmert, M. (2010). Sound complete landmarks And/Or
graphs. Coelho, H., Studer, R., & Wooldridge, M. (Eds.), Proceedings 19th
European Conference Artificial Intelligence (ECAI10), pp. 335340, Lisbon, Portugal. IOS Press.
Palacios, H., & Geffner, H. (2009). Compiling uncertainty away conformant planning
problems bounded width. Journal Artificial Intelligence Research, 35, 623
675.
Richter, S., & Westphal, M. (2010). LAMA planner: Guiding cost-based anytime
planning landmarks. Journal Artificial Intelligence Research, 39, 127177.
Roger, G., Pommerening, F., & Helmert, M. (2014). Optimal planning presence
conditional effects: Extending LM-Cut context-splitting. Schaub, T. (Ed.),
Proceedings 21st European Conference Artificial Intelligence (ECAI14),
Prague, Czech Republic. IOS Press. appear.

533


