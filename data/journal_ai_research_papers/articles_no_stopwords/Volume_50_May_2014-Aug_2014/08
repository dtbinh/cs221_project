journal artificial intelligence

submitted published

mdd propagation sequence constraints
david bergman

david bergman business uconn edu

school business university connecticut
hillside road unit storrs ct

andre cire
willem jan van hoeve

acire andrew cmu edu
vanhoeve andrew cmu edu

tepper school business carnegie mellon university
forbes avenue pittsburgh pa usa

abstract
study propagation sequence constraint context constraint programming limited width mdds first contribution proving establishing
mdd consistency sequence np hard yet task fixed parameter tractable respect length sub sequences addition propose
partial filtering relies specific decomposition constraint
novel extension mdd filtering node domains experimentally evaluate performance proposed filtering demonstrate strength
mdd propagation increases maximum width increased particular mdd propagation outperform conventional domain propagation sequence reducing
search tree size solving time several orders magnitude similar improvements
observed respect current best mdd applies decomposition
sequence among constraints

introduction
central inference process constraint programming constraint propagation rossi
van beek walsh dechter apt traditional constraint processing
techniques designed explicitly defined relations small arity state art constraint programming solvers apply specialized constraint propagation global
constraints arity often efficient combinatorial methods network
flows van hoeve katriel regin
conventional constraint propagation domain filtering operate individual constraints given role identify remove
values variable domains inconsistent respect constraint
consideration whenever domain variable updated e value removed
constraints variable appears reconsidered inspection
cascading process propagating changes variable domains constraints
continues fixed point reached constraint programming solvers assume
variable domains finite ensures termination constraint propagation
process note constraint propagation may sufficient determine
resolution given therefore constraint propagation normally applied
search state systematic search process
c

ai access foundation rights reserved

fibergman cire van hoeve

major benefit propagating variable domains implemented efficiently
many cases however inherent weakness domain propagation implicitly
represents cartesian product variable domains potential solution space
communicating domain changes limits amount information shared
constraints
address shortcoming domain propagation andersen hadzic hooker
tiedemann proposed use multi valued decision diagrams mdds alternative variable domains context constraint propagation mdds directed
acyclic layered graphs principle compactly represent solutions combinatorial wegener andersen et al showed mdds limited
width provide much stronger relaxation solution space traditional
cartesian product variable domains consequence mdds allow represent
communicate refined information constraints propagating mdds
rather variable domains huge reductions search tree size computation time
realized andersen et al hadzic hooker osullivan tiedemann
hadzic hooker tiedemann b hadzic omahony osullivan sellmann
hoda van hoeve hooker cire van hoeve
mdds used represent individual global constraints subsets constraints
constraints given representing individual constraints
work hawkins lagoon stuckey cheng yap higher level
information carried mdd lost projecting variable domains
traditional domain propagation highest potential mdd propagation instead
appears representing specific subsets constraints within mdd
given set constraints create maintain one single limited width mdd
propagated constraint set since mdd defined respect
fixed variable ordering useful select subset constraints compatible
ordering applied way mdd propagation implemented parallel
existing domain propagation constraint programming systems thus complementing
potentially strengthening domain propagation process example cire van hoeve
introduced mdd propagation subset constraints representing disjunctive
scheduling embedded custom global constraint ilog cp
optimizer constraint programming solver greatly improved performance
methodology
constraint propagation limited width mdds amounts mdd filtering mdd
refinement role mdd filtering remove provably inconsistent arcs
mdd hadzic et al b hoda et al mdd refinement
hand aims splitting nodes mdd accurately reflect solution
space hadzic et al order make scalable efficient refinement
must ensure mdd remains within given maximum size typically
restricting maximum widththe number nodes layer increasing
maximum width mdd relaxation strengthened desired level
maximum width would correspond traditional cartesian product
variable domains infinite maximum width would correspond exact mdd


fimdd propagation sequence constraints

representing solutions however increasing size mdd immediately impacts
computation time one typically needs balance trade strength
mdd associated computation time
order characterize outcome mdd filtering notion mdd
consistency introduced andersen et al similar domain consistency
finite domain constraint programming given mdd constraint mdd consistent
arcs mdd belong least one solution constraint consequence
richer data structure mdd represents establishing mdd consistency may
difficult establishing domain consistency example andersen et al
establishing mdd consistency alldifferent constraint np hard
establishing traditional domain consistency done polynomial time regin
contributions
main focus sequence constraint defined specific conjunction among constraints among constraint restricts occurrence
set values sequence variables within lower upper bound beldiceanu
contejean sequence constraint finds applications e g car sequencing
employee scheduling regin puget van hoeve pesant rousseau
sabharwal known classical domain consistency established sequence polynomial time van hoeve pesant rousseau sabharwal van hoeve
et al brand narodytska quimper stuckey walsh maher narodytska
quimper walsh downing feydy stuckey furthermore hoda et al
present mdd filtering among constraints establishing mdd consistency polynomial time however remained open question whether mdd
consistency sequence established polynomial time well
work answer question negatively first contribution showing
establishing mdd consistency sequence constraint np hard
important perspective mdd constraint programming namely
global constraints sequence constraint perhaps suitable combinatorial
structure mdd prescribed variable ordering combines subconstraints contiguous variables existing approaches handle constraint
fully bounds reasoning
second contribution establishing mdd consistency sequence constraint fixed parameter tractable respect lengths subsequences among constraints provided mdd follows order sequence constraint proof constructive follows generic filter
one mdd another
third contribution partial mdd propagation sequence
necessarily establish mdd consistency relies decomposition sequence
cumulative sums extension mdd filtering information
stored nodes
last contribution experimental evaluation proposed partial mdd propagation evaluate strength mdds maximum
widths compare performance existing domain propagators sequence


fibergman cire van hoeve

compare currently best known mdd uses
natural decomposition sequence among constraints hoda et al
experiments demonstrate mdd propagation outperform domain propagation
sequence reducing search tree size solving time several orders magnitude similar observed respect mdd propagation among constraints
thus provide evidence power mdd propagation context
constraint programming
remainder structured follows section provide necessary definitions mdd constraint programming sequence constraint
section present proof establishing mdd consistency sequence nphard section describes establishing mdd consistency fixed parameter tractable
section partial mdd filtering presented section shows experimental present final conclusions section

definitions
first recall basic definitions mdd constraint programming following
work andersen et al hoda et al work ordered multivalued
decision diagram mdd directed acyclic graph whose nodes partitioned n
possibly empty subsets layers l ln layers l ln correspond
respectively variables x xn l contains single root node r ln contains
single terminal node node u mdd let l u denote index
layer mdd width w maximum number nodes layer
maxni li mdd cp mdds typically given fixed maximum width
arcs mdd directed upper lower layer node
li node lj j purposes convenient assume
without loss generality arc connects two adjacent layers arc
layer li labeled element domain xi xi arc refer
label represents notational convenience write u v instead
u v arc u v element xi appears label
arcs given node u li set u v arcs node u node v may
contain multiple arcs denote label let u denote set arcs
comingfi node u define size anfi mdd number arcs e
u u li n
arc label v leaving node layer represents assignment xi v
path mdd r denoted arc labels v vn path
identified solution x xn v vn path v vn feasible
given constraint c setting x xn v vn satisfies c constraint c feasible
mdd mdd contains feasible path c
constraint c called mdd consistent given mdd every arc mdd
lies feasible path thus mdd consistency achieved redundant arcs
e arcs feasible path removed say mdd mdd
consistent respect c domain consistency c equivalent mdd consistency
mdd width one represents variable domains equivalent


fimdd propagation sequence constraints

mdd consistency mdd layer li contains single node si
si si xi n
lastly formally recall definitions among beldiceanu contejean
sequence beldiceanu contejean gen sequence van hoeve et al
constraints among constraint counts number variables assigned
value given set ensures number given lower upper
bound
definition let x set variables l u integer numbers l u x
xx x subset domain values define among x l u
x
l
x u
xx

note expression x evaluated binary value e resulting x
x
sequence constraint conjunction given among constraint
applied every sub sequence length q sequence n variables
definition let x ordered set n variables q l u integer numbers
q n l u q xx x subset domain values
sequence x q l u

nq


among si l u



si represents sub sequence xi xi q
finally generalized sequence constraint extends sequence constraint allowing
among constraints specified different lower upper bounds subsequence length
definition let x ordered set n variables k natural number l u vectors
length k si sub sequence x li ui n li ui n k
xx x subset domain values
gen sequence x l u

k


among si li ui



mdd consistency sequence np hard
stated known non trivial np hardness global constraint
context mdd constraint programming andersen et al
alldifferent constraint challenge determining whether global constraint
made mdd consistent polynomial time must guaranteed
given mdd addition combinatorics global constraint
shape mdd adds another layer complexity establishing mdd consistency
proving np hardness particular difficulty making sure reduction mdd
remains polynomial size sequence constraints far unknown whether
polynomial time mdd consistency exists section answer question
negatively prove following


fibergman cire van hoeve

theorem establishing mdd consistency sequence arbitrary mdd nphard even mdd follows variable ordering sequence constraint
proof proof reduction sat classical np complete garey
johnson instance sat satisfied
particular sequence constraint particular mdd polynomial size solution
therefore establishing mdd consistency sequence arbitrary mdd least
hard sat
consider sat instance n variables x xn consisting clauses c cm
first construct mdd represents basic structure sat formula see
example proof illustration introduce binary variables yi j j
representing literals xj xj per clause ci j n xj xj
may may exist ci order variables sequence first index
clauses index variables yi j j clause ci variable
xj n n ym ym n n
construct mdd layered graph k th layer corresponds k th
variable sequence
clause ci represented n consecutive layers corresponding yi n
part mdd identify precisely paths lead solution satisfying
clause basis diamond structure pair literals yi j j
assigns pair variable appear clause
represent diamond part mdd representing clause thus
ensuring variable take assignment respect clause
variables appear clause explicitly list allowed combinations
precisely clause ci first define local root node ri representing layer l yi
set tag ri unsat node u layer l yi j j n
following variable xj appear ci tag u sat create two nodes v v
l j one single node w l yi j arcs u v label u v label
v w label v w label corresponds diamond structure
set tag w tag u otherwise e tag u unsat yi j appears ci create
two nodes v v l j two nodes w w l yi j arcs u v label u v
label v w label v w label ci contains literal yi j set
tag w sat tag w unsat otherwise ci contains j set tag w unsat
tag w sat
procedure initialized single root node r representing l
iteratively append mdds two consecutive clauses ci ci merging nodes
last layer ci marked sat single node let node
local root ci finalize procedure merging nodes last layer
marked sat single terminal node construction ensure one
yij ij set furthermore variable assignment corresponding
path layers l yi l yi satisfy clause ci exactly n literals
chosen accordingly path
next need ensure feasible path mdd variable xj
correspond literal yi j j clause ci end impose


fimdd propagation sequence constraints

r
c













c












figure mdd corresponding example
constraint
sequence q n l n u n



mdd described sub sequence length n starts positive
literal yi j definition exactly n variables take value sub sequence
starts negative literal j instead last variable sequence corresponds
value xj next clause ci e yi j observe variables except
first last sequence take value already n times therefore
first last variable sequence represent xj complement xj
order one take value xj must take value clause ci
ci since holds sub sequences variables xj must take value
clauses
mdd contains mn layers layer contains six nodes
therefore polynomial size size sat instance overall construction needs polynomial time



fibergman cire van hoeve




x




x
































x

x

x

x

figure exact mdd sequence constraint example

example consider sat instance four boolean variables x x x x clauses
c x x x c x x x corresponding mdd used reduction
given figure

mdd consistency sequence fixed parameter tractable
section establishing mdd consistency sequence arbitrary
mdd fixed parameter tractable respect length sub sequences q
already shown van hoeve et al exact mdd sequence
constraint exists n q nodes e unfolded automaton regular constraint illustrated next example
example consider constraint sequence x q l u
x x x x ordered set binary variables corresponding exact mdd
following order x presented figure convenience node mdd
labeled last q labels represent sub sequence node starting
q layers example second node third layer represents decisions x
x corresponding sub sequence construct next layer append
sub sequence remove first symbol leading nodes labeled
respectively note nodes labeled must take arc label
l similarly nodes labeled must take arc label u q


fimdd propagation sequence constraints

layers possible sub sequences created maximally q thus defines
width subsequent layers
however since given arbitrary mdd necessarily exact mdd need
additional steps exploit connection apply generic
fixed parameter tractability sequence fact applied
determine whether mdd consistency tractable constraint
goal establish mdd consistency given mdd respect another
mdd set variables compatible earlier definitions since
interpreted define constraint mdd consistent respect
every arc belongs path solution exists purposes
assume follow variable ordering
establish mdd consistency first taking intersection
removing arcs compatible intersection computing
intersection two mdds well studied present top intersection
follows definitions description adapted melding
procedure presented knuth
intersection mdd denoted represents possible paths solutions
present partial path root ri node u thus
exist respective endpoints v v information captured
associating node u state u v v representing nodes v
v root initialized ri ri r r r r
respective roots lines top traversal
considers layer lii augments node u lii u v v arc
arc label v v respectively lines
next layer already contains node u state use node
otherwise add node u lii add arc u u note last layer
contains single terminal ti state ti provided empty
last step line clean removing arcs nodes belong
feasible path done bottom traversal observe
necessarily create reduced mdd
presents establish mdd consistency respect

first compute intersection line traverse
top traversal layer lm
identify remove infeasible arcs
define boolean array support u l initialized represents whether arc
node u label l support line line consider arcs
layer lii arc v v exists lii label l v u u mark
associated arc u supported setting support u l lines
remove arcs lm
support lines lastly clean
removing arcs nodes belong feasible path line
theorem establishes mdd consistency respect
w time space
proof correctness follows induction number layers
prove establishes mdd consistency consider arc u u


fibergman cire van hoeve

intersection
input mdd root r mdd root r defined
ordered sequence n variables
output mdd layers li lin arc set ai node u
associated state u
create node r state r r r
li r
n

lii

u lii u v v

v v v v

create node u state u v v

w lij w u u w

else lii u end

add arc u u label arc set ai

end

end
end
remove arcs nodes path r ti lin
return

mdd consistency
input mdd root r mdd root r defined
ordered sequence n variables
output mdd consistent respect
create intersection
n

create array support u l u lm
arcs u label l

arcs v v ai v u u v lii

support u

end

arcs u u u lm


support u remove end

end
end
remove arcs nodes path r lm
n
return



fimdd propagation sequence constraints

applying exists node v v u u solutions
represented paths r u r u equivalent
exists arc ai v v ai label consider v w w since
decision diagrams label appears arc node
therefore w u since ai belongs exist paths w u
w equivalent hence belongs feasible path r
u along u terminating equivalent path exists
r u w terminating
regarding time complexity computing intersection coarse upper bound
multiplies n line w w line max line dmax represents
maximum degree node maxxx x amortize steps since forloops lines consider arc comparison arcs arc
compared w arcs line assume check constant
time whether node outgoing arc given label arc label list
gives total time complexity w memory requirements bounded
size intersection n w w dmax w
dominates complexity since lines performed linear
time space size

observe longer ensures solution represented
path case intersection mdd consistency merely establishes
arc belongs solution although mdd intersections
stronger mdd consistency limitation width intersection
mdd may large product widths therefore intersecting
multiple mdds general increase size resulting mdd exponentially
next apply theorem sequence constraint
corollary let x ordered sequence variables c sequence x q l u
sequence constraint arbitrary mdd following variable ordering x establishing mdd consistency c fixed parameter tractable respect parameter q
proof know exists exact mdd size n q represents c
van hoeve et al applying theorem gives mdd consistency
time space complexity q follows

note theorem applied obtain tractability establishing
mdd consistency constraints consider example constraint among x x
xn l u variable ordering construct exact mdd top
procedure associating node v number variables taking value along
path r v representing length path nodes length
equivalent merged largest layer u different path
lengths exact mdd size nu theorem establishing mdd consistency
tractable among indeed hoda et al showed mdd consistency
established constraint quadratic time complexity


fibergman cire van hoeve

converse theorem hold exist constraints mdd
consistency established polynomial time given mdd minimal
reduced exact mdd hasp
exponential size specific example consider linear inequality
constraints form ni ai xi b xi integer variable ai constant
n b constant mdd consistency established constraints
linear time given mdd computing arc longest r path relative
coefficients ai uses arc andersen et al however hosaka takenaga
kaneda yajima
provide following explicit linear inequality k even
p
n k consider jk aij xij k k xij binary variable
aij k j j k variable order
size

n
reduced ordered bdd inequality bounded


partial mdd filtering sequence
many practical situations value q lead prohibitively large exact mdds
establishing mdd consistency limits applicability corollary therefore
next explore practical partial filtering polynomial q
one immediate propagate sequence constraint mdds
natural decomposition among constraints apply mdd filtering
among proposed hoda et al however well known classical
constraint propagation variable domains among decomposition substantially improved dedicated domain filtering sequence van hoeve
et al brand et al maher et al therefore goal section provide mdd filtering sequence stronger practice mdd
filtering among decomposition stronger domain filtering sequence
follows assume mdd hand respects ordering variables
sequence constraint
cumulative sums encoding
proposed extends original domain consistency filtering
sequence van hoeve et al mdds following cumulative sums encoding proposed brand et al representation takes following form
sequence variables x x x xn constraint sequence x q l u
first introduce variables yn respective initial domains yi

pi n variables represent cumulative sums x e yi represents
j xj n rewrite sequence constraint following
system constraints
n



yi q yi l

n q



yi q yi u

n q



yi yi xi

x indicator function set e x x
x x
brand et al establishing singleton bounds consistency
system suffices establish domain consistency original sequence constraint


fimdd propagation sequence constraints

order apply similar reasoning context mdds crucial observation
domains variables yn naturally represented nodes
mdd words node v layer li represents domain yi restricted
solution space formed r paths containing v let us denote information
node v explicitly interval lb v ub v refer node domain
v following hoda et al compute information linear
time one top pass equation follows
lb v min u v v lb u u v
ub v max u v v ub u u v



nodes v r lb r ub r
individual among constraints posted yi q yi l yi q yi u
need compute node v layer li ancestors layer li
done maintaining vector av length q node v av represents
set ancestor nodes v th layer v q initialize
ar r apply recursion
av u v v au

q

av v
resulting top pass takes linear time size mdd direct
implementation recursive step node takes q w operations
mdd relevant ancestor nodes node v layer li q stored av q
subset layer li similarly compute descendant nodes v vector dv
length q dv contains descendants v th layer v
q initialize dt
however purposes need maintain minimum maximum value
union domains av resp dv constraints inequalities
see application av dv rules makes recursive step
efficient taking qw operations per node
alternatively approximate information maintaining minimum
maximum node domain value layer instead list ancestor layers
compromise filtering may efficient practice requires
maintain two integers per layer
processing constraints
next process constraints turn remove provably inconsistent arcs time filter node information
starting ternary constraints type remove arc u v lb u
u v ub v updating lb v ub v node v done similar rules



lb v max lb v min u v v lb u u v



ub v min ub v min u v v ub u u v


fibergman cire van hoeve










x

x










x

x













x

x













x

x













x

x




initial mdd

b node domains



c mdd filtering

figure mdd propagation constraint sequence x q l u
example

fact resulting special case mdd consistency equality propagator hadzic et al thus inherit mdd consistency ternary
constraints
next process constraints node v layer li n
recall relevant ancestors li q av q relevant descendants
li q dv q variable corresponding node v yi participates
four constraints
yi l yiq
yi u yiq

yi yi q l
yi yi q u
observe apply constraints filter node domain lb v ub v
corresponding yi namely node domains corresponding variables yiq
yi q may support nodes layer li v update lb v
ub v according equations
lb v max lb v

l min lb u
uav q

ub v min ub v u max ub u
uav q

min lb w u
wdv q

max ub w l



wdv q

resulting specific instance generic mdd consistent binary
constraint propagator presented hoda et al inherit mdd
consistency constraints process constraints linear time size
mdd top bottom pass mdd


fimdd propagation sequence constraints

example consider constraint sequence x q l u
ordered sequence binary variables x x x x x x assume given
mdd figure figure b node domains processing
rules figure c shows resulting mdd processing constraints via
rules example consider middle node fourth layer corresponding
variable let node v initial domain av q contains
root node domain since l reduce domain v
next consider arcs v conclude value domain supported
reduces domain v allows us eliminate one incoming arc
first node previous layer
resulting mdd figure c reflects possible deductions made
partial established mdd consistency however witnessed
infeasible path
observe proposed applied immediately general
gen sequence constraints among constraint individual l u q
cumulative sums encoding adjusted straightforward manner represent
different values
formal analysis
next formally compare outcome partial mdd filtering mdd
propagation among encoding domain propagation sequence first
recall following theorem
theorem brand et al thm bounds consistency cumulative sums
encoding incomparable bounds consistency among encoding sequence
note since variable domains among cumulative sums encoding
ranges intervals integer values bounds consistency equivalent domain consistency
corollary mdd consistency cumulative sums encoding incomparable mdd
consistency among encoding sequence
proof apply examples proof theorem work brand et al
consider constraint sequence x q l u ordered
sequence binary variables x x x x x domains xi
x apply trivial mdd width representing cartesian
product variable domains establishing mdd consistency cumulative sums
encoding yields

x x x x
establishing mdd consistency among encoding however yields
x x x x


fibergman cire van hoeve

consider constraint sequence x q l u ordered
sequence binary variables x x x x x domains xi
x apply mdd width representing cartesian
product variable domains establishing mdd consistency cumulative sums
encoding yields

x x x x
establishing mdd consistency among encoding prune value
additional illustration corollary consider example figure mdd
propagation among encoding eliminate value x infeasible
path whereas example showed mdd propagation cumulative sums
detect
theorem mdd consistency cumulative sums encoding sequence incomparable domain consistency sequence
proof first example proof corollary shows domain consistency
sequence stronger mdd consistency cumulative sums encoding
opposite consider constraint sequence x q l u set
binary variables arbitrary size arbitrary values q l u x let
mdd defined x consisting two disjoint paths r arcs one path
label arcs value since projection onto
variable domains gives x x x domain consistency deduce
infeasibility however establishing mdd consistency respect cumulative
sums encoding detect

even though formally mdd propagation cumulative sums incomparable
domain propagation sequence mdd propagation among constraints
next section practice reduce search space
orders magnitude compared methods

computational
purpose computational evaluate empirically strength partial mdd propagator described section perform three main comparisons first
want assess impact increasing maximum width mdd filtering
second want compare mdd propagation classical domain propagation
sequence particular wish evaluate computational overhead mdd
propagation relative domain propagation extent mdd propagation
outperform domain propagation third compare filtering strength mdd
propagator sequence filtering strength mdd propagators individual among constraints best mdd sequence far hoda et al



fimdd propagation sequence constraints

implemented mdd propagator sequence custom global constraint
ibm ilog cplex cp optimizer c interface recall section
applying rules maintain minimum maximum value q
previous ancestors descendants node approximate maintaining
values simply layer evaluated strategies found latter
reduce amount filtering nonetheless resulted much efficient performance
twice fast average hence reported use implementation
mdd propagator among apply code hoda et al
domain propagation applied three first uses domain consistent propagator sequence van hoeve et al running n time second uses
domain consistent propagator sequence network flow representation
maher et al runs n time third model applied decomposition cumulative sums uses explicit global constraint sequence
propagating decomposition takes n worst case considers n variables constraints variable domains contain n elements note
almost test instances cumulative sums encoding established domain consistency
sequence additional advantage cumulative sums encoding permits
insightful comparison mdd propagator since cumulative
sums decomposition
note brand et al introduce multiple sequence constraint
represents conjunction multiple sequence constraints set ordered
variables experimental setup narodytska shows establishing bounds
consistency system already np hard presents domain consistent propagator
encodes system automaton regular constraint runs
nmq time n represents number variables number sequence
constraints q length largest subsequence
order compare multiple sequence constraint conducted experiments identify suitable testbed found instances
multiple sequence constraint would run memory could solved instantly
domain propagator individual sequence constraints creating
data structures multiple sequence constraint took substantially time average instances challenging described next sections
multiple sequence constraint could applied due memory issues therefore
excluded comparisons sections
single sequence constraints solved polynomial time consider
instances multiple sequence constraints experiments assume
defined ordered set variables measure impact different
propagation methods correctly approaches apply fixed search strategy e
following given ordering variables lexicographic value ordering heuristic
method measure number backtracks failed search state well
solving time experiments performed ghz intel xeon machine
thank nina narodytska sharing implementation us



fibergman cire van hoeve

systems sequence constraints
first consider systems multiple sequence constraints defined set
variables generate instances n variables domain
sequence constraints sequence constraint set length subsequence uniform randomly n
q rand n
rand refers standard c random number generator e rand k selects
number range k without minimum length many instances
would easy solve method next define difference l
u rand q set
l rand q
u l
lastly define set values first defining cardinality rand
selecting many values uniformly random generated
instances total
solve instance domain consistency propagator sequence
cumulative sums encoding domain propagation mdd propagator maximum
widths method given maximum time limit seconds
per instance
compare performance domain propagation mdd propagation figure figure report given time point many instances could
solved within time specific method three domain propagation methods
represented cumulative sums cumulative sums decomposition sequence hprs
sequence propagator van hoeve et al sequence flow
flow propagator maher et al observe cumulative sums domain
propagation although guaranteed establish domain consistency outperforms
domain consistent sequence propagators mdd propagation maximum width
already substantially outperform domain propagation observe
larger maximum widths require time mdds processed end
allow solve instances maximum mdd width permits solve
instances within given time limit whereas domain propagation respectively solve
sequence flow sequence hprs cumulative sums instances
illustrate difference domain mdd propagation detail figure presents scatter plots comparing domain propagation cumulative sums mdd
propagation maximum width comparison particularly meaningful
propagation methods rely cumulative sums representation instance
figure depicts number backtracks figure b depicts solving time
methods instances solved within time limit collected
time method figure demonstrates mdd propagation lead
dramatic search tree reductions several orders magnitude naturally mdd
instances available http www andrew cmu edu user vanhoeve mdd







mdd width
mdd width
mdd width
domain cumulative sums
domain sequence hprs
domain sequence flow





number instances solved



mdd propagation sequence constraints













time

figure performance comparison domain mdd propagators sequence
constraint data point reflects total number instances solved
particular method within corresponding time limit

propagation comes computational cost figure b shows almost instances especially harder ones search tree reductions correspond faster solving
times often several orders magnitude
next evaluate impact increasing maximum widths mdd propagator
figure present method survival function respect number
backtracks solving time b formally applied combinatorial backtrack search survival function represents probability run taking
x backtracks gomes fernandez selman bessiere case
approximate function taking proportion instances need least x backtracks figure respectively seconds figure b observe log log plots
respect search tree size figure clearly shows strengthening mdd
propagation maximum width increased particular domain propagation
reflects linear behavior several orders magnitude typical heavy tailed
runtime distributions naturally similar behavior present mdd propagation
much weaker form increasing maximum mdd widths associated solving times
presented figure b reflects similar behavior takes account
initial computational overhead mdd propagation









mdd propagator width time






mdd propagator width backtracks





bergman cire van hoeve























domain propagator cumulative sums time

domain propagator cumulative sums backtracks

b solving time

number backtracks

figure comparing domain mdd propagation sequence constraints data
point reflects number backtracks resp solving time seconds b
specific instance solved best domain propagator cumulative
sums encoding mdd propagator maximum width instances
method needed backtracks less seconds b
excluded stands timeout represents specific instance
could solved within fig b figure instances
labeled separately tick mark note reported number
backtracks seconds may much less instances
reported instances fewer backtracks solved within time
limit

nurse rostering instances
next consider structured class inspired nurse rostering
design work schedule nurse given horizon n days
day nurse work day shift evening shift e night shift n
day introduce variable xi day n domain
xi e n representing shift impose eight sequence constraints
modeling requirements listed table
combinatorial nature size cp search tree turns
largely independent length time horizon lexicographic search
increasing day applied however consider instances time horizons
n address potential scaling issues
presented table columns domain sequence total
number backtracks bt solving time seconds cpu domain consistent
sequence propagator similarly columns domain cumul sums infor

fimdd propagation sequence constraints






survival function



domain consistency
mdd width
mdd width
mdd width
mdd width
mdd width
mdd width
mdd width






survival function





domain consistency
mdd width
mdd width
mdd width
mdd width
mdd width
mdd width
mdd width



















backtracks











time

survival function respect backtracks

b survival function respect solving time

figure evaluating impact increased width mdd propagation via survival function plots respect search backtracks solving time b plots
log log scale data point reflects percentage instances require least many backtracks resp seconds b solved
particular method

requirement

sequence x q l u

least work shifts every days
least days every days
night shifts every days
evening shifts every days
nights shifts cannot appear consecutive days
evening night shifts every days
work shifts every days

sequence x e n
sequence x
sequence x n
sequence x e
sequence x n
sequence x e n
sequence x e n

table nurse rostering specification variable set x represents shifts
assigned sequence days possible shifts day evening e
night n day

mation cumulative sums domain propagation subsequent columns
numbers mdd propagator mdds maximum width note
propagating mdd width corresponds domain propagation indeed associated number backtracks equivalent domain propagator cumulative sums
first observation maximum width already reduces number backtracks
factor maximum width mdd propagation even allows solve


fibergman cire van hoeve

n





domain
sequence
bt
cpu





domain
cumul sums
bt
cpu










mdd
width
bt
cpu





mdd
width
bt
cpu










mdd
width
bt cpu










mdd
width
bt cpu










table comparing domain propagation mdd propagation sequence nurse
rostering instances n stands number variables bt number
backtracks cpu solving time seconds

without search computation times correspondingly reduced e g
resp domain propagators mdd propagator width
instance n lastly observe case mdd propagation
suffer scaling issues compared domain propagation
final remark attempted solve nurse rostering instances
sequence domain propagator cp optimizer ilosequence able solve
instance n seconds none others instances solved within
time limit seconds
comparing mdd filtering sequence among
last experiment compare sequence mdd propagator mdd propagator among constraints hoda et al main goal determine whether
large mdd sufficient solve irrespective propagating among
cumulative sums decomposition whether additional information obtained
sequence propagator makes difference
apply methods mdd propagation sequence mdd propagation
among data set section containing instances time limit
seconds run propagators maximum mdd widths
first compare performance mdd propagators among sequence
figure figure depicts number instances solved within given
time limit methods plot indicates among propagators
much weaker sequence propagator moreover larger maximum widths
alone suffice sequence propagator maximum width outperforms
among propagators maximum widths
scatter plot figure compares mdd propagators among sequence
detail widths instances take backtracks resp less
seconds method discarded figure resp b smaller
widths several instances among propagator solve faster
relative strength sequence propagator increases larger widths width
sequence propagator achieve orders magnitude smaller search trees






sequence width
sequence width
sequence width
sequence width
among width
among width
among width
among width





number instances solved



mdd propagation sequence constraints













time







sequence mdd propagator time

width
width
width
width









width
width
width
width



sequence mdd propagator backtracks



figure performance comparison mdd propagation sequence among
maximum widths data point reflects total number instances
solved particular method within corresponding time limit























among mdd propagator time

among mdd propagator backtracks

b solving time

number backtracks

figure evaluating mdd propagation sequence among maximum
widths via scatter plots respect search backtracks solving time
b plots log log scale follow format figure



fibergman cire van hoeve

solving time among propagators demonstrates advantage
mdd propagation sequence compared among decomposition

conclusion
constraint propagation limited width mdds recently shown powerful
alternative conventional propagation variable domains constraint programming
work studied mdd propagation sequence constraint appears e g rostering scheduling applications first proved establishing
mdd consistency sequence np hard however shown task
fixed parameter tractable respect length sub sequences defined
constraint provided mdd follows variable ordering specified constraint
proposed practical mdd propagation sequence polynomial length sub sequences cumulative decomposition
provided extensive experimental comparing mdd propagator sequence
domain propagators sequence well existing mdd propagator among
computational experiments shown mdd propagator sequence
outperform domain propagators orders magnitude terms search tree size
solving time similar obtained compared existing mdd propagator among demonstrates practice large mdd alone sufficient
solve specific mdd propagators global constraints sequence
lead orders magnitude speedups

acknowledgments
material upon work supported national science foundation
grant cmmi google award thank reviewers
whose comments helped improve

references
andersen h r hadzic hooker j n tiedemann p constraint store
multivalued decision diagrams proceedings cp vol lncs
pp springer
apt k r principles constraint programming cambridge university press
beldiceanu n contejean e introducing global constraints chip journal
mathematical computer modelling
brand narodytska n quimper c stuckey p walsh encodings
sequence constraint proceedings cp vol lncs pp springer
cheng k yap r maintaining generalized arc consistency ad hoc r ary
constraints proceedings cp vol lncs pp springer
cire van hoeve w j mdd propagation disjunctive scheduling
proceedings icaps pp aaai press


fimdd propagation sequence constraints

cire van hoeve w j multivalued decision diagrams sequencing
operations
dechter r constraint processing morgan kaufmann
downing n feydy stuckey p explaining flow propagation
proceedings cpaior vol lncs pp springer
garey johnson computers intractability guide theory
np completeness freeman
gomes c p fernandez c selman b bessiere c statistical regimes across
constrainedness regions constraints
hadzic hooker j n osullivan b tiedemann p approximate compilation constraints multivalued decision diagrams proceedings cp vol
lncs pp springer
hadzic hooker j n tiedemann p b propagating separable equalities
mdd store proceedings cpaior vol lncs pp springer
hadzic omahony e osullivan b sellmann enhanced inference
market split proceedings ictai pp ieee
hawkins p lagoon v stuckey p solving set constraint satisfaction
robdds jair
hoda van hoeve w j hooker j n systematic mdd
constraint programming proceedings cp vol lncs pp
springer
hosaka k takenaga kaneda yajima size ordered binary decision
diagrams representing threshold functions theoretical computer science
knuth e art computer programming fascicle bitwise
tricks techniques binary decision diagrams addison wesley professional
maher narodytska n quimper c g walsh flow propagators
sequence related global constraints proceedings cp vol
lncs pp springer
narodytska n reformulation global constraints ph thesis university
south wales
regin j c filtering constraints difference csps
proceedings aaai vol pp aaai press
regin j c global constraints survey van hentenryck p milano
eds hybrid optimization pp springer
regin j c puget j f filtering global sequencing constraints proceedings cp vol lncs pp springer
rossi f van beek p walsh eds handbook constraint programming
elsevier
van hoeve w j katriel global constraints rossi f van beek p
walsh eds handbook constraint programming chap elsevier


fibergman cire van hoeve

van hoeve w j pesant g rousseau l sabharwal revisiting
sequence constraint proceedings cp vol lncs pp springer
van hoeve w j pesant g rousseau l sabharwal filtering
combinations among constraints constraints
wegener branching programs binary decision diagrams theory applications siam monographs discrete mathematics applications society
industrial applied mathematics




