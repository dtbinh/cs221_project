journal artificial intelligence

submitted published

improving delete relaxation heuristics explicitly
represented conjunctions
emil keyder

emilkeyder gmail com

jorg hoffmann

hoffmann cs uni saarland de

saarland university
saarbrucken germany

patrik haslum

patrik haslum anu edu au

australian national university nicta
canberra act australia

abstract
heuristic functions delete relaxation compute upper lower bounds
optimal delete relaxation heuristic h paramount importance
optimal satisficing introduce principled flexible technique
improving h augmenting delete relaxed tasks limited amount
delete information done introducing special fluents explicitly represent
conjunctions fluents original task rendering h perfect heuristic h
limit previous work introduced method growth task
potentially exponential number conjunctions introduced formulate alternative technique relying conditional effects limiting growth task linear
number method still renders h perfect heuristic h
limit propose techniques informative set conjunctions introduced
different settings analyze extend existing methods lower bounding upperbounding h presence conditional effects evaluate resulting heuristic
functions empirically set ipc benchmarks sometimes much
informative standard delete relaxation heuristics

introduction
heuristic search one successful approaches
informative heuristic functions domain independent obtained
estimated cost delete relaxation original task delete
relaxation simplifies tasks assuming every variable value achieved
persists execution rest plan cost optimal plan
resulting relaxed task denoted h np complete compute however whether
plan delete relaxed task exists checked polynomial time bylander
satisficing heuristic admissible
latter fact exploited upper bound h generating necessarily optimal
plan delete relaxed task hoffmann nebel optimal lowerbounding methods devised analysis landmarks logical formulas
set actions state necessary properties delete relaxed plans karpas
c

ai access foundation rights reserved

fikeyder hoffmann haslum

domshlak helmert domshlak cost estimates delete relaxed
task used guide heuristic search state space original task
since delete relaxation heuristics first proposed bonet geffner much
work done improve one focuses better approximation
schemes h obtaining tighter upper bounds thus better non admissible estimates
hoffmann nebel keyder geffner tighter lower bounds
correspond informative admissible heuristics helmert domshlak bonet
helmert many domains however important heuristic able
take account delete information hoffmann indeed long tradition
works proposing heuristics several extend delete relaxation
capture strictly information fox long helmert helmert geffner
cai hoffmann helmert katz hoffmann domshlak
consider delete relaxation attempt low conflict relaxed plans baier
botea generate modified heuristic values taking conflicts account
extent kambhampati gerevini saetti serina
taking inspiration admissible hm family heuristics
haslum geffner important property heuristics introduce shared
recent work direction technique renders h perfect
heuristic h limit words technique offers trade amount
delete information considered computational overhead one end
continuum delete relaxed plans become plans original task
hm heuristic function considers cost making true simultaneously sets fluents
size cost task estimated recursively taking cost
set fluents goal set action preconditions cost
costly subset size ignoring cost achieving remaining fluents
set possible subset size fluents task must considered
size representation required compute hm exponential hm heuristics
provide guarantee exists hm h trivially satisfied
total number fluents task however value required achieve
usually large make computing h method infeasible practice
hm heuristic recently recast hmax h cost task
deletes haslum achieved representing conjunctions fluents c
size original task fluents c called fluents modifying
initial state goal operators task capture reasoning
performed hm sets within computation hmax however h
admissible since separate copy action may needed establish
fluent thus compilation useful obtaining admissible estimates
informative h recent c construction haslum fixes
issue introducing action copy every subset fluents may established
cost growing task representation exponentially number fluents rather
linearly representation hand c offers possibility
fine grained tradeoff representation size heuristic accuracy allowing
choice arbitrary set conjunctions c corresponding fluents need
size stands contrast hm heuristic compilation
sets conjunctions size represented


fiimproving delete relaxation heuristics explicit conjunctions

haslum proposed repeatedly solve c optimally within iterative procedure
adds conjunctions set c iteration relaxed plans
computed therefore gradually become closer sense plans original
task instead explore idea kind construction obtaining heuristic
functions guiding search
c
introduce related construction c
ce similar makes use
conditional effects limit growth task worst case linear rather
exponential c gain size comes price information loss relative
c however information loss affect fundamental property
tending towards perfect heuristic h enough conjunctions introduced
c c
ce perfect limit e exists set conjunctions c

h c
ce h furthermore information may lost case
indeed possible construct families tasks c
ce represent

c
heuristic function c set conjunctions c e h c
ce h
c
representation ce occupies exponentially less space
said theoretical advantage c
ce tend materialize practice
least commonly used benchmarks without optimizations c
indeed grows quickly practical turns mutex pruning techniques eliminating compiled actions conflicting preconditions extremely effective keeping
c
size c bay therefore consider c
ce evaluating usefulness
devising improved heuristic functions focus two main questions
obtain upper lower bounds h compiled tasks
b choose set conjunctions c maximize information gained
addition task
response question analyze extend three state art methods
estimating h satisficing setting upper bounding h consider
finding low cost relaxed plans scheduled minimize cost
sequence actions required trigger given set conditional effects avoiding unnecessary
repeated applications action scantily addressed
previous work optimal action scheduling given
set effects np complete generalize approximation technique used
planner hoffmann nebel
optimal setting lower bounding h consider lm cut heuristic helmert
domshlak well admissible heuristics fluent landmarks karpas
domshlak former findings mostly negative first
even though introduction fluents cannot decrease hmax h lowerand upper bound lm cut respectively lm cut heuristic value decrease second
neither two straightforward adaptations lm cut
conditional effects maintains admissibility domination hmax
latter c
ce used generate informative fluent landmarks
recent work keyder richter helmert extracts landmarks task
sophisticated adaptation lm cut idea context splitting recently
proposed maintains properties



fikeyder hoffmann haslum

allows discovery fluent landmarks corresponding conjunctive landmarks
original task suffers due large number fluents must considered
c
ce compilation offers possibility discovering interesting conjunctive landmarks
unbounded size avoiding growing size compilation unnecessarily
response question b devise range strategies depending purpose
c
c
ce compilation used parameterized terms
allowed growth compiled task relative original task thus allow
trade informativeness heuristic computational overhead
evaluate resulting heuristics wide range benchmarks international competition varying relevant parameters determine individual
effect performance several domains heuristics much
informative previous ones leading significantly improved performance
next define basic concepts section moving formal definition

c
c
ce compilation previously introduced compilations section
c

c
section analyze ce relation theoretical perspective
section discusses practical issues arise compilations purpose
satisficing describes obtained experimental section
case optimal finally section summarizes main points
indicates possible future directions

preliminaries
model propositional strips formalization add
action costs conditional effects states operators defined terms set f
propositional variables fluents state f given set fluents
true state task described tuple hf gi f
set variables set actions f initial state g f
describes set goal states given g action consists
tuple hpre add del ce pre add del subsets f
action cost cost r
ce ce ce n denote set
conditional effects action triple hc add del subsets
f simplify notations require add del need
impose restrictions deletes del conditional effects conditional
effects used within delete relaxation ce
conditional effects say strips task
action applicable pre applying given


del
del add
add
c

c

plan sequence
pn actions whose application goal
state cost cost ai optimal cost minimal among plans
often denote optimal plans plan called plan
simply plan
heuristic function h mapping states r
perfect heuristic

h maps state cost optimal plan heuristic h admissible


fiimproving delete relaxation heuristics explicit conjunctions

h h h denote heuristic function whose value
given estimating cost corresponding state modified task specify
terms transformation hf gi hf g obtained
applying transformation used obtain sometimes useful
make explicit h heuristic computed denote h
note modified task used computation heuristic function
particular actual search plan performed state space original
task
delete relaxation task obtained discarding delete
effects formally hf gi hpre add ce
ce hc add ce ce cost action
cost corresponding action cost optimal delete relaxation heuristic h
defined cost h optimal plan
denote power set f p f c c f context hm
c
c
ce refer fluent subsets c p f sets conjunctions interchangeably
throughout assume conjunctions non unit e c
landmark task logical formula set fluents f
every valid plan makes true state hoffmann porteous sebastia
orderings landmarks statements order states occur
natural ordering n means state sj satisfies state si
occurring sj satisfied necessary ordering nec means
true state immediately state becomes true
greedy necessary ordering gn means relationship holds first time
made true note necessary ordering nec implies greedy necessary
ordering gn vice versa landmark graph g directed graph whose
nodes landmarks whose labelled edges correspond known orderings
landmarks

c c
ce compilations
compilation haslum first technique proposed made use
idea fluents explicitly represent conjunctions original task given
conjunction c f c fluent c f unique c e c c c c
defining compilations discuss use shorthand x c
x c c c c x x f set fluents c p f set
conjunctions words x c consists set fluents x together
fluents c whose intention represent conjunctions c c contained x
c x
definition compilation given strips task hf gi
parameter z task hf c ac c gc c c c
f c ac contains well action ac pair c c
del c add c ac given del ac ce ac
pre ac pre c add c
add ac add c c c c add c


fikeyder hoffmann haslum

parameter indicates maximum size conjunctions represented
explicitly resulting compiled task fluent inserted definition f c cf
c f c c added fluent sets
task initial state action preconditions goals containing associated
set c furthermore linear c number representatives action added
task model situation elements c made true
already true applied adds remaining fluents c deleting
none thereby making every fluent c therefore c true compilation
allows admissible hm cost original task computed hmax cost
compiled task
non admissibility h h due construction action representatives ac sets fluents simultaneously made true single application
action may require several representatives explicitly achieve
effect consider example action adding fluent p state q
r already true makes fluents p q r true simultaneously whereas
two different representatives required one c p q adding p q
one c p r adding p r
c compilation solves instead creating number representatives exponential number fluents may made true
representatives corresponds application makes set fluents
true haslum following example separate representatives would
introduced fluent sets p q p r p q p r
representative resulting last could applied make two fluents
true simultaneously c differs allows choice set c p f
introduces fluents c c c rather subsets size

definition c compilation given strips task hf gi
set non unit conjunctions c p f c task hf c ac c gc

ac contains action ac pair c c c c
del c add c
c c c c add c c c






ac given del ac ce ac


pre ac pre
c add c
c c
c

add add pre del c c c c
three differences definition haslums definition actions
c first haslums definition features delete effects ensuring real non relaxed plans correspond
plans original task since consider delete relaxations compiled task safely
omit second allow sets c used construction actions contain conjunctions c

c add pre del third add ac contains fluents c c pre del
latter two differences keep definitions simpler redundant action representatives
redundant add effects cause easily pruned practice



fiimproving delete relaxation heuristics explicit conjunctions



representatives ac enforce every c c part c deleted

non added part c true already ac executed constraint

ensures form non redundancy ac adds fluent c adds fluents
c c c fluents c necessarily become true application
action note differently add effects c include fluents representing
conjunctions fluents added action prevail fluents non deleted preconditions
necessary admissibility h primary purpose c needed
computation h primary purpose
c enumerates possible subsets c constructing representatives
action therefore grows exponentially c exponentiality reminiscent
canonical conditional effects compilation used convert tasks conditional
effects classical strips tasks exponentially actions gazen
knoblock c
ce compilation introduce applying
roughly reverse transformation c resulting closely related task
linear c number conditional effects
definition c
ce compilation given strips task hf gi
c
c
c
c
set non unit conjunctions c p f c
ce task hf ace g

c
c
c
c
ac
ce hpre add del ce

ac given
pre ac pre c
add ac add pre del c
del ac
ce ac h pre c add c c
c c c del c add
rather enumerating sets fluents may made true action c
ce
uses conditional effects implicitly describe conditions made true
information lost information encoded cross context fluents
preconditions appear action representatives c preconditions
c
effect conditions corresponding actions c
ce action representatives

c fluents pre ac exists c c c add
pre situation discussed example q r precondition action
representative adds p q p r c appear condition
conditional effects corresponding action c
ce since effect conditions
determined individually c conditions never included return
discussing theoretical relationship c c
ce
example consider strips task adapted helmert geffner
variables x xn initial state x goal g xn unit cost actions
h

bi h xi xi


fikeyder hoffmann haslum

n
optimal solution task takes form b b bn
cost n delete relaxation task fact deleted application
bi ignored optimal plan cost n
fluent xi introduced c
ce compilation added precondition
action bi conditional effects ce form h xi xi created
action conditional effects added b actions deletes
therefore cannot achiever fluent increases optimal delete relaxation
cost task instance must added relaxed plan achieve
newly introduced precondition bi fluents form xi introduced
delete relaxation cost c
ce becomes n optimal cost
set conjunctions renders delete relaxation cost c perfect e
n however size c given conjunction set exponential n action
may principle achieve subset conjunctions every subset c induces

separate representative ac ac
regarding compilation h hmax gives optimal cost task
however computation requires consideration n fluent pairs rather
linear number fluents need introduced c
ce shall see theorem example easily extended must scale n hm become
c

perfect thus showing exponential separation c
ce
important practical optimization c c
ce mutex pruning mutex
information original task available specifically given
tuples fluents reachable conjunction discard
compiled task action representatives conditional effects require
tuple without losing admissibility compilation namely value h c
respectively h c
ce mutex pruning bounded value



h c respectively h c
ce larger set c c conjunctions include

fluents size h mutexes found e none respective fluents reachable compiled task exploiting available mutex information allows us
make compilation informed without add additional fluents
helping keep compilation small
another optimization use eliminate dominated preconditions whenever add
fluent c precondition action condition conditional effect
remove condition fluents p c fluents c c c
achieving c implies achieving fluents well methods count cost
separately example hadd related heuristics would incur overestimation
note however eliminate duplication caused fluents representing different fluent sets non empty intersection consider example
action pre p q r c p q q r pre p q q r
cost achieving q implicitly counted twice hadd estimate cost
applying possible solution considered replacing overlapping fluents c c
cc however consistently improve heuristics compute
compiled tasks


fiimproving delete relaxation heuristics explicit conjunctions

theoretical properties c
ce

c
discuss theoretical properties c
ce considering cost h ce
optimal solutions instead practical approximations note c
ce version
c considered h h delete effects present proof sketches
shown full proofs found appendix first fundamental
expected property

theorem consistency admissibility h c
ce consistent admissible
proof regarding consistency given need

c

c
c c
h c
ce cost h ce let optimal plan
ce
c sc ac c task
ac c necessarily plan sc c
ce
ce
deletes admissibility follows consistency together fact h c
ce
goal states
furthermore ideal delete relaxation lower bound improve add fluents
theorem h c
ce grows monotonically c given task sets


c
c c non unit conjunctions h c
ce h ce
c
c

proof follows fact given plan ac
ce



c
c
c
c
c
c
constitutes plan ce induction ai
c

c
c
c ac
ai c c c c shows since goal ce g
gc c c c c gc sc valid plan

induction hypothesis holds since c c c c c c definition




c
c
c
c
c

ac
applicable ai since pre ai pre ai c c c c



c

c
c c
c ac
ai ai c c c c induction hypothesis
c
c
c
c
c
c
c c ai ai c c c add ai c

c
implies c add ac
due definition ce exists conditional effect
c

cej ac
h pre c add c since c c must exist corresponding

c
c
conditional effect ce definition condition must true c ac
ai
induction hypothesis

special case c theorem gives us

corollary h c
ce dominates h given task set non unit

c

conjunctions c h ce h

domination strict follows trivially convergence h theorem
consider relationship c c
ce compilations mentioned
information encoded cross context preconditions lost moving
c
exponential c linear c
ce estimates obtained ce may therefore inferior
obtained c
theorem h c dominates h c
ce given task set nonunit conjunctions c h c h c

cases inequality strict
ce


fikeyder hoffmann haslum

proof sketch standard conditional effects compilation strips gazen knoblock
c
applied c
ce equivalent except presence cross context preconditions c given plan c plan c
ce yet inverse
c c
c

n


ac
case first part induction c ac
n ce

ce denotes applying sequence actions initial state c
c
c
ce since goal tasks defined g shows desired
strictness follows fact possible construct tasks
cross context preconditions discussed play role leading situations
c
exist plans c
ce shorter minimum length plans
proof strictness appendix task h c
value strictly larger h c
ce value c chosen conjunctions
size implies exist tasks necessary consider strictly
larger conjunctions c
ce obtain equally good heuristic estimates obtained
c
c necessarily problematic however differently hm c
ce
introduce conjunctions given size therefore exponential maximum
size conjunctions considered
c
advantage c
ce potentially exponentially smaller c
domination therefore must qualified reduction size furthermore
c
ce preserves ability compute perfect heuristic given sufficiently large set c
conjunctions first consider equivalent c already proved haslum
provide alternative proof conveniently adapted
c
property c
ce key proof following equivalence
h h c
lemma given task c c p f c h h c
proof sketch c identical except action sets h values computed
considering single add effect time inequality h h c

easy see verifying every add effect c action ac c unless

c pre ac thus redundant action ac dominates e c add ac

pre ac pre ac proof similar inequality h c h observing
action ac non redundant add effect exists dominating action

ac c
theorem h c perfect limit given task exists c
h c h
proof known h hm sufficiently high values haslum
geffner shown haslum hm h lemma
c c p f c h h c choosing appropriate
corresponding c thus h hm h h c
together fact h c h c since h c h admissibility
h c claim follows

c

c
claim c
ce remains relate h h ce



fiimproving delete relaxation heuristics explicit conjunctions

lemma given task set non unit conjunctions c h c
h c
ce
c
proof sketch consider task c
cc identical except drops cross
context fluents preconditions h c h c
cc b

c

c
h cc h ce
similarly proof lemma easy see showing every add effect

c c simply set c
c action ac c
cc dominated action
minimal subset c contains c satisfies condition definition
words reduce c get rid cross context fluents

c
b suffices h c
cc h ce holds action
c

relaxed plan ce c set conjunctions added conditional

effects applied plan action representative ac c
cc
preconditions used achieve set fluents

theorem h c
ce perfect limit given task exists c
h c


h
ce
proof choosing appropriate c h hm h
lemma h h c lemma get h c h c
ce since
shows claim
theorem h c


h
ce
note theorem theorem actually corollary theorem presentation chosen make relation two role two lemmas
clearer
proofs theorems rely obtaining perfect hm clearly unfeasible
general since involves enumerating subsets fluents hence possible states
worst case however c c
ce offer flexibility allowing us choose set
c selecting subsets guarantees perfect heuristic may achieved
much less effort especially beneficial c
ce whose growth c linear

indeed task families obtaining h takes exponential effort hm
requires exponentially sized c yet c
ce remains small
c exist parameterized task
theorem expressive power c
ce vs h
families k

hm k h k k

c
h c
k h k implies number action representatives k exponential k

k exists ck ck therefore number conditional effects

c

k c
ce polynomial k b h k ce h k
proof members one family given combination k tasks
type shown example size k share among action
fluent needs made true step k k goals hm h iff
k


fikeyder hoffmann haslum

c
c
k k ce perfect k fluents xi xik must introduced individual subtasks leading total k fluents one
fluents present precondition action bij k c
ce similarly
representative c c




individual
fluent
preconditions
xij
k
consequence one actions reestablishing left plan
number conditional effects created k c
ce linear number fluents added
however number action representatives k c exponential k action
adds fluent belongs fluents hence one representative
subset fluents

h c
ce practice typically able choose c
perfect heuristic instead try pick set c yields informative heuristic
without making size representation impractical work

heuristics satisficing
consider practical issues involved c
ce satisficing section deals extraction relaxed plans section deals strategies
choosing set conjunctions c section presents experiments resulting
setup
relaxed conditional effects
techniques extracting relaxed plans presence conditional effects long
known hoffmann nebel refine extend techniques
particularly important context unlike ipc benchmarks structure
conditional effects c
ce rather complex involving multiple dependencies
different actions even different executions action
non admissible delete relaxation heuristics typically obtained relaxed plan
extraction keyder geffner different variants
characterized best supporter function bs f use cases bs p
action adding p minimizes estimate cost making p true
conditional effects present compute set actions
scheduled form relaxed plan task formally construct
relaxed plan according following equations keyder geffner


p
p
bs p pre bs p otherwise

p
p
pp

existing methods choosing best supporters hadd hmax easily
extended conditional effects treating conditional effect task separate
remark similar issues arise approaches compiling uncertainty classical
conditional effects palacios geffner bonet palacios geffner techniques may
turn useful well



fiimproving delete relaxation heuristics explicit conjunctions

action particular method employed hmax compute heuristic
function hoffmann nebel precisely relaxed conditional effect
ce
condition c add add action ai add effect add ai
add add precondition pre ai pre c created set effects g
defined rules forms relaxed plan presence conditional effects
however implies schedule relaxed plan different
schedules may require different numbers action applications multiple applications
single action avoided making conditions multiple desired effects true
given application
illustration consider task action move briefcase n conditional effects conditionally transports object location location
b inside briefcase representation distinct moving action
generated conditional effect one possible schedule relaxed plan repeatedly
puts object briefcase applies move briefcase proceeds next object
plan n steps longer optimal relaxed plan first places
objects briefcase applies move briefcase
words single action execution may trigger several conditional effects
may exist relaxed plan length less g question arises
optimally schedule relaxed plan minimizing number action applications
required uses simple approximate solution outline
improve upon first note scheduling conditional relaxed
plans scrp actually np complete
theorem scheduling conditional relaxed plans let relaxed task
conditional effects g set effects viewed set independent actions
constitutes plan deciding whether exists sequence actions length k
conditional effects g triggered np complete
proof membership follows fact given sequence k actions easily
checked polynomial time whether conditional effects g triggered hardness
follows reduction shortest common supersequence scs garey
johnson supersequence string x dm alphabet string
alphabet belongs language l dm given
instance scs strings x xn alphabet asks
whether exists supersequence strings length k construct
task conditional effects hf gi

f ni yij j xi
az ce az ce az given set conditional
effects
n x


hyij yij xij z
j

yn
g x yn xn


fikeyder hoffmann haslum

two actions correspond addition symbols respectively
supersequence implicitly constructed fluent yij encodes fact
current string constitutes supersequence prefix xi xij
seen valid plan task must trigger conditional effects
task yet sequence actions length k exists iff common
supersequence x xn length k transformation scs
task conditional effects polynomial shows claim
note theorem relate known hardness optimal relaxed
wish schedule effects already selected know form
relaxed plan source complexity yet overlooked literature
given hardness employ greedy minimization technique call
conditional effect merging starting trivial schedule containing one action execution
effect g consider pairs effects e e g conditional effects
action two effects merged single execution conditions
achieved without use add effects ffs approximation method
applies similar reasoning captures special case condition holds
e e appear layer relaxed graph trivially
implies conditions effects independently achievable however
may case effects different layers relaxed graph
devise strictly general technique capturing form independence
effects call best supporter graph bsg representation relaxed plan
simplicity assume task single goal fluent g needed
achieved introducing action end whose preconditions original goals
adds g
definition best supporter graph given relaxed task best supporter function bs best supporter graph directed acyclic graph hv ei
v g g e hv v p pre v v bs p vertex
labeled action whose conditional effect represents edge labelled
set preconditions p p pre v v bs p
nodes graph represent conditional effects appear relaxed plan
exists edge hv v two nodes effect represented v best
supporter pre condition effect represented v bs valid best supporter
function e relaxed plan g generated bs sound sufficient condition
acyclic easily shown topological sort sound
relaxed plan implies path two conditional effects
action occur action application therefore
merged single occurrence action nodes removed
bsg node added represents effects combining incoming
outgoing edges process repeated node merges possible
runs polynomial time sound bsg
topological sort constitutes relaxed plan however guarantee
optimal scheduling original plan
edge labels used procedure choosing conjunction set c described section



fiimproving delete relaxation heuristics explicit conjunctions

example consider task move briefcase n conditional effects
transporting object location location b inside briefcase nodes
bsg n put briefcase oi actions one object oi well n copies
move briefcase b one conditional effect regarding object oi
one edge put briefcase oi respective copy move briefcase b labeled
briefcase oi therefore path graph move briefcase b
node another merged single node conditional effect merging
topological sorts merged bsg correspond optimal relaxed plans
choosing c relaxed
shows main procedure computing set conjunctions c used form
c
ce task applied start search initial
c
state task resulting c
ce task used subsequent
heuristic evaluations conditional effect merging used conflict extraction
phase configuration discussed e use original non merged bsg
stated definition
choosing c relaxed plan heuristics
c
relaxedplan c
ce
plan size c
ce bound
c c findconflicts
relaxedplan c
ce
high level similar procedure previously introduced
computing incremental cost lower bounds c construction haslum
repeatedly generates relaxed plans initial state current compiled
task adds conjunctions c conflicts found current
plan e current relaxed plan fails executed original
task process stops conflicts found implying
current relaxed plan c
ce plan original task user specified
c
bound size ce reached express bound terms size c
ce
compared see sometimes impose bound runtime

bound specified findconflicts returns least one conjunction
long plan complete right
report usage experiments relaxed
plan generated iteration optimal used compute sequence
admissible cost estimates converges optimal plan cost haslum
focus however use c
ce generating inadmissible heuristic functions
therefore use tractable non optimal relaxed procedure impose bound
typically stops plan original task found
remains specify findconflicts procedure given relaxed plan fails
execute original task select set conjunctions c one


fikeyder hoffmann haslum

answer question provided previous use compute
plan cost lower bounds haslum aim different computing heuristics
satisficing search make number changes previously
proposed version findconflicts section summarizes original procedure
section describes changes make
conflict extraction incremental plan cost lower bounds
given optimal relaxed plan plan original task haslums
version findconflicts returns set conjunctions c prevents relaxed
plan solution next iteration ensures progress sense
cost relaxed plan eventually increase prove real plan cost
describe conflict extraction procedure need two definitions
definition relaxed plan dependency graph let non redundant plan
relaxed task construct directed graph g one node va
action plus node vg representing goal let pre v denote precondition
node v pre node va g node vg g directed edge
va v iff pre v relaxed reachable set actions minus
edge labelled subset pre v relaxed unreachable actions
relaxed plan dependency graph rpdg transitive reduction g
rpdg similar bsg definition encodes necessary dependencies actions relaxed plan path node va node vb
rpdg implies precedes b every valid sequencing case vb said
ordered va contrast bsg encodes intentions relaxed plan
heuristic form chosen best supporters may impose orderings need
respected every valid sequencing plan e g fluent p added another
action relaxed plan best supporter p relaxed plan
non redundant meaning action removed without invalidating
path every action node rpdg goal node
definition dependency closure let non redundant plan relaxed task let v v nodes rpdg v ordered v simple
q
q
qm
dependency path path v v v v v rpdg edge
labelled one fluent chosen arbitrarily edge label rpdg whenever
v ordered v simple dependency path v v exists dependency closure
v v minimal w r subset union paths contains simple
dependency path v v q fluent labels edge node v
closure action q add action associated
v closure contains simple dependency path v node corresponding
path guaranteed exist
recall input findconflicts plan valid delete relaxation
original task delete effects considered
valid preconditions actions well goals must made true


fiimproving delete relaxation heuristics explicit conjunctions


vd
p
r

vf
q

p
vd

q



qn

vf

pn
vj
qm

b



figure relaxed plan failure scenarios wavy edges deletions precondition
point thus fails solve original task must case action
call deleter deletes precondition action f called
failed action note failed action goal let p pre f
deleted fluent procedure distinguishes two cases relation
nodes vd vf rpdg
first case illustrated figure vf ordered vd choose dependency
closure vd vf let l set fluents labelling edges closure
set conflicts generated p q q l note p l thus conflict
proper conjunction
first case hold vd vf unordered must nearest
common descendant node vj rpdg situation illustrated figure
b choose dependency closure vd vj let l set fluents labelling
edges closure likewise choose dependency closure vf vj let l
set fluents labelling edges closure set conflicts generated
q q q l q l p
theorem haslum theorem let non redundant plan
delete relaxed task valid original task let c set
conjunctions extracted procedure described action sequence n
representative ai valid plan c
changes conflict extraction satisficing
number differences setting haslum
particular although fluents collected initial state resulting c
ce task
used heuristic evaluations states encountered search growth
size c
ce task incur overhead heuristic evaluation thus
objective set c make heuristic accurate across states
keeping size c limited hand computing non optimal relaxed
plans computationally far cheaper optimal relaxed afford
iterations
therefore make following modifications strategy first use bsg
instead rpdg necessity orderings latter extend beyond
current initial state therefore useful purpose bsg
representative relaxed plans found non optimal relaxed procedure
second introduce single fluent iteration
time cause relaxed plan found allows focus
finding small number conflicts useful wide range states chosen
conflict p qn case depicted figure pn qm figure b


fikeyder hoffmann haslum

intuitively works better setting set conflicts generated
plan failure tends redundant thus needlessly grows size task
leading slow evaluation times without much gain informativeness
changes affect fundamental property converges
real plan convergence property findconflicts must
returns least one conjunction whenever fails solve original task
variant still gives guarantee
lemma assume eliminate dominated preconditions c let
non redundant plan c valid original task let c
conjunction extracted procedure described c c
proof simply possible relaxed plan failure scenarios figure
chosen conjunction c x x p qn respectively x pn qm contained
precondition failed action f assuming c x c eliminate
dominated preconditions action precondition c contains x hence
case c cannot chosen conjunction
theorem convergence conflict extraction assume eliminate dominated preconditions c run without size bound eventually
plan
proof follows lemma set possible conjunctions finite
contrasting theorem haslums variant theorem latter gives stronger
convergence guarantee sense guarantees certain minimum progress
made iteration
lemma thus theorem holds way c
ce e sequence
c
conditional effects ce viewed set independent actions constitutes nonredundant plan c
ce rely eliminating dominated preconditions
makes proof simple use technique practice anyway
verify whether convergence holds dominated preconditions eliminated
conjecture
since multiple conflicts bsg relaxed plan experiments
choose arbitrarily one minimizes number conditional effects strips
actions case c created place bound factor x c
ce exceeds
size original task precisely x fluents conditional

effects added c
ce resulting standard relaxed plan heuristic growth
bounds x fluents added number conditional effects task reaches
x c x limits total number actions task multiple

recall eliminating dominated preconditions means whenever add fluent c precondition action condition conditional effect remove condition fluents
p c fluents c c c



fiimproving delete relaxation heuristics explicit conjunctions

example consider strips task example variables
x xn initial state x goal g xn unit cost actions
h

bi h xi xi

n
previously discussed setting c x xn renders delete relaxation
perfect e relaxed plan establish every two bactions exactly set c iteratively selected procedure
assuming best supporter function hadd hmax first iteration
bsg

b

x

b

x



b

bn

xn

bn

relaxed plan fails execute trying apply second action b corresponding failure scenario matches figure


b

b

x

chosen conflict thus x non empty set conjunctions c containing single conjunction precondition b contains x must
established action bsg takes form note dominated
preconditions xi b eliminated

b

x



x

b

b

x



bn

xn

bn

relaxed plan fails execute trying apply fourth action b
corresponding failure scenario


b

x

b

chosen conflict x iterating procedure manner select
exactly set c one one end relaxed plan solve original
task
experiments
evaluate impact c
ce compilation relaxed plan heuristic context greedy search expected impact heuristic improved
relaxation two fold one hand make heuristic informative


fikeyder hoffmann haslum

enabling search plans fewer node evaluations hand
computational overhead associated growth slowing heuristic
evaluations examine effects individually well combined influence coverage set planner able solve within given time
memory bounds take main measure performance
study consider objective producing plans high quality
measured plan length cost plan quality unimportant rather
rationale decision methodological seeking high quality plan
seeking plan minimum search effort particularly
quality measured non unit action costs requirements heuristics
two quite different chosen focus one viz search efficiency
measured coverage node evaluations rather conflate two choice
plain greedy search motivated decision consequence
treat actions unit cost previous experiments shown
context greedy search distinguishing action costs heuristic calculation tends
lower coverage richter westphal however least assess impact
heuristics plan quality report data regarding plan length
next describe experiment setup baseline discuss heuristic informativeness computational overhead impact conditional effect merging impact
plan length c
ce heuristics comparison state art heuristics
difference c c
ce compilations finding
plans search
experiment setup baseline
compilation associated heuristics implemented fast downward planner
helmert used greedy best first search lazy evaluation second
open list boosting states resulting preferred operators planners
tested strips domains editions international
competition ipc domains last two ipcs recent
sets instances used experiments run opteron processors
settings used competition memory limit gb time limit minutes
baseline planner configuration uses relaxed plan heuristic best supporters
identified hadd unmodified task e growth bound x
known fact greedy search particular greedy search lazy evaluation
strong bias towards preferred operators highly sensitive small changes
relaxed plan even changes alter heuristic value rather
operators preferred unfortunately fact rarely taken account
heuristics compared context greedy search since introduction fluents
alters structure relaxed plan believe particularly important determine
whether resulting differences planner performance really due relaxed plan
less informative
therefore first step towards accounting brittleness experiments
greedy heuristic search introduce simple variance measure use decide
experiments considered significant variance performance


fiimproving delete relaxation heuristics explicit conjunctions

baseline planner measured randomizing choice supporters equal
hadd values construction relaxed plan measuring maximum deviation
baseline planner five repeated runs shown
columns labeled mad tables domain set
whole deviation defined differences coverage median number
heuristic evaluations note interested whether randomization helps
hurts search rather magnitude variation causes
c
comparing planner heuristics c
ce different
growth bounds baseline planner consider difference
significant greater magnitude maximum deviation observed
randomization baseline interpreted significance
statistical sense although assumed randomization affects heuristics equally
could estimate probability hypothesis difference simply setting
reasonable threshold counts substantial difference search performance

heuristic informativeness
comparison heuristic informativeness summarized right half table
shows ratio median per domain tasks solved planners
number heuristic evaluations baseline planner planners
c
ce heuristics half domains difference informativeness
c
ce heuristics compared baseline exceed threshold significance
set sensitivity study shown mad column among domains
significant difference majority c
ce heuristics reduces
number node evaluations indicating augmented heuristics informative
cases ratio grows fluents added e growth bound
x increased drastic example seen floortile domain
c
ce heuristics evaluate four orders magnitude fewer nodes compared
standard delete relaxation heuristic allows easily solve instances
domain comparison planner ipc able solve
instances domain woodworking domain c
ce heuristics
two orders magnitude informative associated increase coverage
tasks solved configurations
roughly third domains consistent nearly consistent loss
informativeness though significant note loss informativeness correlate loss coverage attributed different
factors including small magnitudes loss well fact ratio node
evaluations taken tasks solved planners compared another issue
dramatic coverage losses often due computational overhead incurred
c
ce compilation particular openstacks satellite domains decrease
number tasks solved c
ce heuristics matches almost exactly number
tasks conflict selection compilation process fails complete within
seconds allocated per task get back next subsection


fikeyder hoffmann haslum

worth noting quality c
ce heuristics highly sensitive
precise choice fluents used compilation hence may exist better policies
making choice relatively simple one used
ho po colums table coverage examine effect
heuristic function respectively preferred operators returned function
separation po corresponds configuration uses relaxed plan c
ce task
built x timeout discussed section identify
preferred operators together heuristic value baseline x heuristic
ho hand uses heuristic values obtained x preferred
operators x interestingly heuristic values preferred operators alone
sufficient greatly improve coverage floortile domain techniques
greatest impact ho po configurations able solve every instance
domain effect domains mixed configurations solving
sometimes sometimes fewer instances
computational overhead
computational overhead c
ce heuristics compared standard relaxed
plan heuristic stems two sources time spent computing set fluents
add greater overhead heuristic evaluation c
ce task
table shows three measures impact
first four columns timeouts number instances
construction c
ce task finish within seconds second set
four columns sec shows number instances construction
time exceeds seconds inclusive instances first set columns note
behavior spending large amount time c
ce construction without reaching
growth bound partly due strategy selecting fluents since purposely
choose fluents increase size compiled task least
several domains construction time frequently exceeds seconds
happen domains c
ce heuristic informative
floortile woodworking suggests imposing time limit construction
c
ce task incur small loss informativeness present coverage
strategy second time limit table significantly better
baseline planner compares favourably state art heuristics
expected domains evaluating heuristics c
ce task slower
standard delete relaxation tends slow growth bound x increases
due larger number fluents actions compiled task median
slowdown per domain typically order x exceeds one order
indeed reported earlier keyder hoffmann haslum increase
informativeness barman parcprinter domains
plausible explanation behavior respect dead end states intuitively
robot painted corner unrecognized standard delete relaxation
heuristic e relaxed plan exists appears c
ce highly effective fixing
issue x search encounters millions states hff ho encounters

states hff c
c
ce suggesting h
ce prunes dead ends early po encounters
states suggesting hff c

preferred
operators prevent search entering
ce
dead end regions first place



fiimproving delete relaxation heuristics explicit conjunctions

domain
x mad
airport

barman

blocksworld

depots

driverlog

elevators

floortile

freecell

grid

gripper

logistics

logistics

miconic

mprime

mystery

nomystery

openstacks

parcprinter

parking

pathways

pegsol

pipes notk

pipes tank

psr

rovers

satellite

scanalyzer

sokoban

tidybot

tpp

transport

trucks

visitall

woodwork

zenotravel

total











































































coverage
x
po ho




































































































































median node evaluations ratio
x









































































































































































mad

table planner coverage heuristic informativeness c
ce varying growth bounds
without conditional effect merging coverage shows number solved baseline
configuration x difference increase decrease relative baseline
configurations po uses preferred operators obtained c
ce compilation
x returning x heuristic value ho uses heuristic values
obtained x preferred operators x heuristic informativeness
measured ratio per domain median number node evaluations comparing
baseline configurations across instances solved configurations normalized
smaller value entry means baseline planner requires times
many heuristic evaluations planner columns labeled mad magnitude
maximum deviation coverage ratio baseline sensitivity study values
bold exceed threshold therefore consider significant

magnitude floortile domain x somewhat surprisingly
domains heuristic evaluations become faster fluents added possible
explanation eliminate dominated preconditions cf section
number action preconditions decreases delete relaxation hypergraph
c
ce becomes graph


fikeyder hoffmann haslum

domain
airport
barman
blocksworld
depots
driverlog
elevators
floortile
freecell
grid
gripper
logistics
logistics
miconic
mprime
mystery
nomystery
openstacks
parcprinter
parking
pathways
pegsol
pipes notank
pipes tank
psr
rovers
satellite
scanalyzer
sokoban
tidybot
tpp
transport
trucks
visitall
woodwork
zenotravel
total

timeouts
x









sec
x




























































































































ratio median evaluations sec
x















































































































































table computational overhead c
ce first set columns timeouts shows number

tasks c
ce construction finish within second time limit
second set sec shows number tasks construction time exceeds seconds
inclusive first set columns improve readability non zero entries
shown e blank cells columns zeroes last set columns shows median
per domain commonly solved tasks ratio heuristic evaluations per second baseline
planner x planner x entry means baseline planner
performs times many heuristic evaluations per second planner

conditional effect merging
majority domains conditional effect merging slightly increases change
informativeness c
ce heuristics exceptions logistics
gripper domains merging heuristic twice informative
ratio median number evaluations metric presented table
nomystery domain order magnitude informative
solved heuristics barman domain four times less
informative general higher informativeness occurs domains tasks


fiimproving delete relaxation heuristics explicit conjunctions

solved planners increased coverage indeed shown
table conditional effect merging proves detrimental overall coverage
c
planner c
ce heuristic best ce configuration conditional
effect merging solves total tasks standard relaxed plan heuristic
configuration without conditional effect merging solves tasks
runtime overhead merging procedure quite small transitive closure
operation required check whether path two nodes bsg
implemented efficiently graph known directed acyclic case
x comparing c
ce heuristic conditional effect merging
without ratio median number heuristic evaluations per second
metric used right hand side table shows maximal per domain slow
across domain average coverage decreases domains
barman therefore appear due sensitivity search small changes
heuristic function rather due time taken compute function
plan length c
ce
determine effect c
ce heuristics plan quality compare length
plans found c
heuristics

found x standard delete relaxation
ce
heuristic plan length measure equivalent plan quality unit cost setting
consider median ratio plan length found standard delete relaxation
heuristic found c
ce heuristic set instances solved
configurations table general observe large differences
median ratio staying close one notable exception blocksworld domain
heuristics c
ce compilation consistently significantly shorter plans
c
ce heuristics ability deduce implicit ordering constraints domain
avoiding actions lead temporary improvements greedy search later
need reversed adding plan length c
ce leads shorter plans gripper
mprime woodworking domains tends longer plans barman
grid domains
comparison state art
table shows coverage variety heuristics planners best configurations
two compilations x achieve better overall coverage
standard relaxed plan heuristic best performing heuristics obtained c
ce
compilation without conditional effect merging c compilation give coverages
respectively difference coverage baseline
planner greater significance threshold numbers far exceed coverage obtained hcea heuristic fall short instances solved
dual heuristic used lama however combining lama best c
ce nm
configuration portfolio planner runs lama seconds search
c
ce nm heuristic seconds coverage solvable
almost difference c
ce heuristics superior performance
floortile lesser extent airport domains


fikeyder hoffmann haslum

domain
airport
barman
blocksworld
depots
driverlog
elevators
floortile
freecell
grid
gripper
logistics
logistics
miconic
mprime
mystery
nomystery
openstacks
parcprinter
parking
pathways
pegsol
pipesworld
pipesworld
psr
rovers
satellite
scanalyzer
sokoban
tidybot
tpp
transport
trucks
visitall
woodwork
zenotravel

x




































x














































































































x




































x














































































































table median ratio length plans found x length plans found c
ce
different values x instances solved planners entry means
baselines plans times longer planner conditional effect merging
used

c vs c
ce
given fixed number fluents difference size c c
ce
compilations exponential worst case mutex pruning however mitigate much
growth c consider example action c
ce compilation n
different conditional effects mutexes considered one would expect number
action representatives generated set fluents c n however
n fluents generating conditional effects shown mutex
one another number action representatives generated c n
found experiments effect leads much slower growth c
might expected consider figure point graph represents


fiimproving delete relaxation heuristics explicit conjunctions

domain
airport
barman
blocksworld
depots
driverlog
elevators
floortile
freecell
grid
gripper
logistics
logistics
miconic
mprime
mystery
nomystery
openstacks
parcprinter
parking
pathways
pegsol
pipes notank
pipes tank
psr
rovers
satellite
scanalyzer
sokoban
tidybot
tpp
transport
trucks
visitall
woodwork
zenotravel
total

x





































mad









































































c
ce





































coverage
c
nm
c
ce









































































hff





































hcea





































lama





































pf





































table comparison state art heuristics satisficing columns x
mad table column c
ce shows coverage best configuration terms overall
coverage compilation conditional effect merging namely x
c
c
ce nm best ce configuration without conditional effect merging happens use
c
x best c configuration x happens use
x entries bold columns difference baseline planner
exceeds threshold significance given mad column column pf shows coverage
portfolio planner runs lama seconds c
ce seconds
single instance instance set paired value x
c
c
ce x axis axis measure ratio growth growth
f e factor compilation increased size action set encoding
measured number actions c number conditional effects c
ce
divided factor compilation increased number fluents


fikeyder hoffmann haslum

e
action set growth uent set growth c

action set growth uent set growth c
































action set growth uent set growth cce

e
e























action set growth uent set growth cce



b

figure growth size ratio growth growth f without
b mutex pruning point corresponds single instance value x f x x
shown reference

words assess growth encoding number conjunctions c
theory worst case exponential c linear c
ce
mutex pruning used figure b growth c rapid
ratio quickly increases millions mutex pruning figure growth c
still faster c
ce difference much smaller
finding plans search
growth time limit imposed construction c c
ce tasks
used complete competitive
heuristic search methods nevertheless interesting observe performance details
domains coverage obtained
c c
ce compilations well statistics growth compiled
c
tasks shown table difference c
ce much visible
since number fluents added general much larger growth bounded
constructions used heuristic computation c
ce able rapidly add much
larger number fluents therefore relaxed plans solutions
c
original task well overall c
ce solves tasks compared
solves equal greater number tasks except domains
considering individual domains seen c c
ce able solve
almost tasks certain domains logistics mprime mystery parcprinter
psr woodworking domains even addition small amount
information sufficient obtain relaxed plans plans original task
maximum x values required solve tasks quite low case mprime
mystery woodworking domains maximum required x values
respectively others elevators openstacks transport visitall
even smallest tasks quite large many different plans possible
possible introduce enough fluents disqualify possible relaxed plans
constitute real plans tasks solved


fiimproving delete relaxation heuristics explicit conjunctions

domain
airport
barman sat
blocksworld
depots
driverlog
elevators sat
floortile sat
freecell
grid
gripper
logistics
logistics
miconic
mprime
mystery
nomystery sat
openstacks sat
parcprinter sat
parking sat
pathways noneg
pegsol sat
pipes notank
pipes tank
psr
rovers
satellite
scanalyzer sat
sokoban sat
tidybot sat
tpp
transport sat
trucks
visitall sat
woodwork sat
zenotravel
total

cov





































min





























c
ce
max





























c
med





























cov





































min




























max




























med




























table solving tasks search table shows coverage c c
ce compilations minimum maximum median values x solved tasks

heuristics optimal
consider admissible heuristics optimal section considers
lm cut heuristic showing certain complications make difficult
obtain improved heuristic estimates c c
ce section consider
alternative method lower bound h namely admissible cost partitioning heuristics
conjunctive landmarks obtained c
ce detail choose c
setting present experimental section


fikeyder hoffmann haslum







g

ac


g

g






g

ac




g

g




g g g
ac




b

figure lm cut c compilation example
lm cut
state art admissible approximation h computed lm cut
helmert domshlak logical obtaining admissible heuristics
c c
ce therefore apply lm cut compilations unfortunately turns
several serious obstacles discussing issues first give
brief description lm cut present simpler case c
compilation additional complication conditional effects present
lm cut computed task deletes simple transformation first applied replaces goal set g single goal achieved
goal achievement action whose precondition set g adds dummy precondition actions whose precondition set empty lm cut initializes hlm cut
repeats following steps hmax g becomes compute hmax apply
precondition choice function pcf action precondition pre removes
pre one fluents p pre hmax p maximal construct
justification graph whose vertices fluents whose arcs precondition effect
pairs according pcf cut l initial state goal
justification graph given set actions enters goal zone e set
fluents goal reached cost add costmin minal cost
heuristic value hlm cut reduce cost l costmin proved
helmert domshlak two fundamental properties namely
admissibility hlm cut h ii domination hmax hmax hlm cut
would expected heuristic obtained manner c would
strictly informative obtained original task
turns case indeed heuristic become strictly less informative
example let hf gi given f g g g
ai h gi g g g g figure words three goals
achievable single action valid plans apply action
order make goals true cuts found lm cut task
regardless pcfs chosen lm cut therefore
computes optimal cost consider c compilation
set c g g g f c contains single fluent g g g representative


action ac
constructed sole non empty subset c g g g c
first cut found lm cut contains three representatives adds
expensive goal g g g possible pcfs next cut last
final heuristic estimate two cuts found example


fiimproving delete relaxation heuristics explicit conjunctions





c
precondition choice function chooses g hmax justifier ac
g

max
c
h
justifier cut cut goal reached cost
g g g
via hmax lm cut stops


c
note similarly h c
ce cf theorem possible h
hmax c decrease addition fluents example hmax
cost task actually increases addition fluent g g g
however type interactions introduced difficult lm cut
reason resulting worse admissible bounds practice lm cut course continues dominate hmax proving sufficient number fluents added lm cut
eventually tend towards optimal cost task

weakness pointed example inherited application lm cut
c
ce compilation furthermore application involves additional complication proves formidable lm cut defined conditional effects therefore
cannot directly applied c
ce task turns two straightforward
adaptations conditional effects neither preserves
properties admissibility ii domination hmax
see ii stake consider task single action
two conditional effects ce h p q ce h q r initial state
p goal r h hmax due critical path ha ai
justification graph considered lm cut consists sequence first cut found
cost reduced remaining task hmax cost resulting
cost estimate hlm cut
issue different conditional effects action may part
critical path natural therefore reduce costs per individual conditional
effect rather effects action unfortunately turns
preserve admissibility indeed detail example appendix
exist strips tasks whose c
ce compilations following property
exists action reducing cost globally first encountered cut
leads heuristic estimate less hmax c
ce treating effects

c
separately leads estimate greater h ce h
therefore simple strategy dealing conditional effects preserves
ii tasks since admissibility cannot sacrificed must
reduce costs globally give dominating hmax particular implication

c

despite theorem shows hmax c
ce h ce converges h
convergence guaranteed hlm cut c
ce could course fixed
max hmax hlm cut heuristic value yet hmax typically informative
strategy useful practice
detail section ipc benchmarks lm cut computed c c
ce often larger search spaces fluents introduced cases overall performance worse hlm cut c hlm cut c
ce
hlm cut remains open question whether improved


fikeyder hoffmann haslum

c
ce landmarks
landmarks tasks formulas set fluents f property made true state execution valid plan
checking whether even single fluent landmark task
pspace complete approaches finding landmarks past focused
delete relaxation setting whether fluent landmark checked
polynomial time recently shown maximum fixpoint solution
set simple recursive equations defines complete set single fact delete relaxation
landmarks words landmark formulas consist single literal
p keyder et al solution computed repeatedly updates set landmarks fluent action task
convergence method naturally handle conditional effects treating
independent actions described section
shown equations applied graph
structure necessarily corresponding delete relaxation task
insight used obtain landmarks task single fluent landmarks
correspond conjunctive landmarks necessarily landmarks
delete relaxation suffers however large number fluents
considered rendering landmark generation impractical compilations larger tasks aim take advantage flexibility c
ce compilation
obtain non delete relaxation landmarks original task considering
focused set fluents given size allow us
consider larger conjunctions keeping size delete relaxation task low
c
ce landmark finding focus technique keep overhead
bay choose set conjunctions c guarantee every fluent landmark
c
ce therefore original task accomplished extracting
landmark graph sets landmarks simultaneously achieved
definition simultaneously achieved landmarks set landmarks ls
n simultaneously achieved lc n landmark
maximal sets simultanously achieved landmarks easily extracted set
landmarks orderings given initial set landmarks l set orderings
following sets sets simultaneously achieved landmarks
lg g
lnec nec l
lgn gn l
lg contains single set made landmarks l entailed g since
valid plan must make goals true final state necessarily simultaneously
achieved given landmark lnec contains set elements landmarks ordered necessarily due definition necessary orderings
must simultaneously true every state immediately precedes state
becomes true lgn similar set yet since greedy necessary orderings


fiimproving delete relaxation heuristics explicit conjunctions

weaker necessary orderings sometimes contain sets appear lnec
therefore larger overall set conjunctive landmarks note necessary orderings greedy necessary orderings conjunctive landmark
set necessary orderings therefore subset conjunctive landmark
greedy necessary orderings include conjunctive landmarks
necessary orderings stronger necessary orderings added
conjunctive landmark landmark heuristics sometimes infer
conjunctive landmarks must reachieved landmark ordered necessarily
reachieved case conjunctive landmarks derived
greedy necessary orderings need achieved make landmarks
ordered true first time
choosing c landmark generation
c
l findlandmarks c
ce
repeat
c c simultaneouslyachieved l
l findlandmarks c
ce
simultaneouslyachieved l c

strategy choosing c landmark generation shown
conjunctive landmarks l p pn discovered corresponding fluents
p pn added c
ce landmark computation step repeated note
process may go several iterations run fixpoint reached
addition fluents c
ce task discovery landmarks
process terminates conjunctive landmarks discovered already
exist fluents c
ce note method choosing c desired
c
property mentioned fluents introduced c
ce represent fact landmarks ce
conjunctive landmarks original task
strategy works especially well domains many landmarks several landmarks necessarily greedy necessarily ordered one domain
occurs blocksworld see illustration figure method
able extremely informative conjunctive landmarks allow optimally solve
tasks heuristic tested
experiments
consider performance lm cut heuristic hlm cut c c
ce compilations admissible landmark cost partitioning heuristic hlm introduced
karpas domshlak different landmark generation schemes including
lm cut used search hlm
landmarks obtained c
ce h

use lm variant effective known fluent landmarks
karpas domshlak benchmarks computers time memory limits
used section


fikeyder hoffmann haslum

informativeness
coverage
domain
c
c


orig
x


c c
ce
ce
airport






barman opt






blocksworld






depots






driverlog






elevators opt






floortile opt






freecell






grid






gripper






logistics






logistics






miconic




mprime






mystery






nomystery opt






openstacks opt






parcprinter opt






parking opt




pathways noneg






pegsol opt






pipes notank






pipes tank






psr






rovers






satellite






scanalyzer opt






sokoban opt






tidybot opt






tpp






transport opt






trucks






visitall opt






woodwork opt






zenotravel






total



c
table lm cut c
ce two columns left ratio summed

number heuristic evaluations tasks solved configurations comparing standard
lm cut x lm cut computed c c
ce x example
first entry table shows lm cut computed c growth bound
x evaluates sum commonly solved tasks nearly times many states lm cut
computed standard delete relaxation last columns coverage column original
shows obtained fast downwards implementation lm cut applies
standard delete relaxation column x shows implementation lmcut unmodified delete relaxation differences two purely due
implementation details entries bold indicate highest coverage domain total



fiimproving delete relaxation heuristics explicit conjunctions

clear
gn
clear b
handempty
ontable b

clear
holding b

nat

nat

clear b
handempty
b
clear c
handempty
ontable c

clear b
clear
gn
b
holding c
nat ontable
gn

b
c b
c

nec

clear c
clear c
clear
b gn handempty
c b
b
holding
c b
ontable

figure landmarks graph found c
ce compilation small blocksworld task
blocks initially table g b c b c smaller conjunctive
landmarks single fluent landmarks omitted

lm cut c c
ce
evaluate impact c c
ce compilations lm cut constructed
c
c
ce tasks following procedure described section repeatedly
selecting conflicts increase size compiled task reached fixed growth
bound x conflict selection hmax supporters rather hadd supporters
hmax plays key role computation lm cut resulted better performance
procedure used generate c c
ce tasks
c
tested value x set c
ce observed
x dominated larger values x domain domain overall basis
therefore report two configurations exception
mystery domain c x x solved tasks compared
x
overall heuristic computed lm cut standard delete relaxation dominates computed c c
ce terms informativeness
terms coverage first two columns table large majority
domains search lm cut computed c c
ce performs many heuristic
evaluations tasks solved configurations airport domain
instance lm cut standard delete relaxation requires approximately times fewer
heuristic evaluations solve set tasks c c
ce domains situation less extreme standard delete relaxation continues give
better heuristic estimates exceptions blocksworld elevators floortile
freecell grid mprime mystery pegsol psr transport woodworking domains

least one c c
ce yields informative heuristic estimates
impressively c c
ce give estimates respectively times informative estimates obtained floortile domain estimates
c times informative mprime domain terms
coverage translates tasks solved c c
ce floortile domain
compared standard version lm cut tasks solved c


fikeyder hoffmann haslum

mprime domain compared mystery domain coverage increased
domains coverage achieved c c
ce lm cut less equal
coverage achieved standard lm cut overall standard version lm cut
solves tasks compared c c
ce though large part
difference tasks comes miconic domain difference remaining
domains still significant
comparing c c
ce seen additional loss information resulting
treatment conditional effects lm cut leads worse heuristic estimates
c
c
ce expected theoretical ce grows linearly
number fluents number fluents added task
c
c
ce compilation almost higher however treatment
conditional effects lm cut described turns greatly degrade performance
c
lm cut c
ce informative lm cut domains
admissible landmark heuristics c
ce landmarks
admissible landmark heuristic hlm uses action cost partitioning derive heuristic
values collection ordered landmarks distributing cost action
set landmarks achieves karpas domshlak cost partitioning done
different ways optimal cost partitioning tractable yields best possible heuristic
value given set landmarks practice slow coverage suffers uniform
partitioning generally achieves better time informativeness trade therefore better
coverage
evaluate potential informativeness landmarks obtained c
ce
iterative technique described section used landmarks optimal cost
partitioning setting since setting makes best possible use information present
given landmarks compared informativeness heuristic
landmarks obtained compilation sound
complete landmark generation keyder et al shown
first two columns table ratio total number heuristic evaluations
per domain tasks solved configurations hlm landmarks
heuristic landmarks c
ce respectively note landmarks
compilations contain landmarks obtained
generated c


ce
subset hlm optimal partitioning c
ce landmarks therefore
dominates hlm optimal partitioning landmarks hence ratio
greater
domains considered neither addition landmarks c
ce landmarks leads informative heuristic cases columns value
remaining domains schemes improve landmarks equal degree
improves greater degree c
ce one case blocksworld
c
landmarks

much

informative

landmarks
found methce
ods improve informativeness baseline heuristic landmarks
factor
uniform cost partitioning divides cost action evenly set landmarks
achieves rather searching partitioning maximizes heuristic value


fiimproving delete relaxation heuristics explicit conjunctions

domain

airport
barman opt
blocksworld
depots
driverlog
elevators opt
floortile opt
freecell
grid
gripper
logistics
logistics
miconic
mprime
mystery
nomystery opt
openstacks opt
parcprinter opt
parking opt
pathways noneg
pegsol opt
pipes notank
pipes tank
psr
rovers
satellite
scanalyzer opt
sokoban opt
tidybot opt
tpp
transport opt
trucks
visitall opt
woodwork opt
zenotravel
total

informativeness
coverage
optimal partitioning uniform partitioning

c


c
ce
ce

















































































































































































table hlm landmarks generated delete relaxation keyder et al
c
ce two columns left ratio summed number heuristic evaluations
tasks solved configurations comparing c
ce baseline landmarks
optimal cost partitioning hlm landmarks yield better lower bounds
indeed ratios use presentation differently
previous tables right three columns coverage uniform cost partitioning
heuristic uniform partitioning solves tasks optimal cost partitioning
landmark generation schemes considered entries bold indicate best per domain
total



fikeyder hoffmann haslum

state make hlm heuristic weaker though typically much
makes much faster compute leading better coverage general confirmed
uniform cost partitioning higher coverage optimal cost partitioning
domains three landmark generation schemes considered
three right columns table coverage achieved hlm
three landmark generation schemes setting seen landmarks greater coverage combining c
ce landmarks

c
compared heuristic landmarks ce landmarks solve many
tasks every domain except nomystery rovers domains c
ce landmarks outperform landmarks two domains blocksworld c
landmarks
planner
ce
finds optimal solutions tasks tested heuristic
miconic instance domains use c
ce landmarks

effect worsens coverage compared interestingly informativeness
lm cut heuristic increases greatly c c
ce compilations floortile domain corresponding increase compilations used landmarks
conjunctive landmarks besides goal found

conclusions open questions
long tradition works attempting devise heuristics taking account
delete effects however techniques rendering h perfect limit thus allowing
smoothly interpolate h h proposed quite recently
haslum katz et al respectively extended haslums
introducing compilation method linear vs worst case exponential growth
demonstrated machinery needed generate heuristics
evaluation shows domains informedness dramatically improved
small cost terms computational overhead
main open issue lies use words domains
domains gain informativeness small domains overall performance
suffers dramatically domain independent technique work well
every domain simple portfolio cf column pf table suffices
improve state art satisficing extent per domain performance variation technique dramatic obtain understanding
causes phenomena ultimately exploit understanding devise reliable effective practical methods unchanged worse performance many domains
due fundamental limitations technique due particular instantiation
especially selection fluents run experiments
practical perspective answering questions comes exploration
techniques predicting impact adding fluents making informed
decisions fluents add observed changes domain formulation random reorderings small changes heuristic criteria used fluent
selection large impact heuristic informativeness coverage formulate heuristic criteria improve existing ones therefore could
potentially provide better performance across wide range domains might

fiimproving delete relaxation heuristics explicit conjunctions

teresting systematically explore impact random arbitrary changes attempt
building complementary strength compilations combined effective portfolios
theoretical perspective currently approaching questions
terms analyzing conditions small polynomial size set fluents
suffices render h perfect applied individual domains analysis offers way
answering question whether lack performance improvement due
essential limitation due choosing wrong set fluents hope
eventually obtain syntactic criteria e g causal graph structure
automatically applied arbitrary task descriptions serving select fluents
exclude subsets fluents consideration targeted manner first
direction already published hsdip hoffmann steinmetz
haslum
observations optimal pose many questions future work simple one
whether effective c
ce landmarks could extracted restricting techniques
adding fluents guaranteed landmarks daunting challenges regard
lm cut observations suggest methods use suffer greatly suboptimal
choices precondition choice functions pcfs would therefore worthwhile investigate methods obtaining better pcfs another important direction develop
extensions lm cut conditional effects guarantee admissibility domination hmax simple yet impractical method multiply conditional effects
enumerating subsets thereof sophisticated method context splitting distinctions different occurences action introduced
targeted manner necessary recently proposed roger pommerening
helmert
summary explicitly represented conjunctions clearly exhibit potential dramatically improve delete relaxation heuristics much remains done order
understand use effectively

acknowledgments
part work leading publication carried emil keyder jorg
hoffmann working inria grand est nancy france nicta funded
australian government department communications australian
council ict centre excellence program thank university
freiburg allowing us use computional resources

appendix proofs
theorem h c dominates h c
ce given task set con
c

c
junctions c h h ce cases inequality strict
proof follows fact plan c plan c
ce yet
cn plan c

inverse case first part let hac






n

sequence actions constitutes plan c
ce showing
cn c ac ac

induction c ac






denotes

ce
n
n ce




fikeyder hoffmann haslum

applying sequence actions initial state c c
ce since goal tasks
defined gc shows desired base case initial state
c
c c
ce subset relation holds inductive case assume
ci
c
c
c
c
c
c
ai ac
ai ce since precondition ai ce subset
c
c
c c
c

precondition ac
ci ai applied ai ce
c

induction hypothesis need fluents added ac

ci
c
c c
c
c
added ac
ce applied ai ce add effect ai consists
c
union two sets add pre del add effect ac

ci
c

c

ce therefore added c c ci since ai applicable

ci

preconditions pre c ci c add c must true c ac
ai therefore
c

c ac
ai ce induction hypothesis c c therefore c ci ci
c
c
c ac
ce conditional effect effect c condition pre c add
ci
c
applies condition subset precondition ai shows
desired property
strictness consider task fluent set f p p r g g initial
state p goal g g g actions
ap h p p r p ar h r
ag h p r g ag h p r g
let c c f c optimal plan c sequence
har ag ap ar ag case c follows fact plan must include
ag ag actions achieving two goals therefore must achieve
precondition fluents p r p r respectively fluents
achieved ar action achieves p fluents without deleting
r single representative ar achieves p r p r
representative would precondition p p unreachable since
action achieving p deletes p plan c therefore must contain ag ag least two
instances ar ap
longer holds however considering c
ce action sequence
hap ar ag ag plan contains actions c
ce two possible fluents
added ar p r p r treated independently separate conditional effect
created conditions p p respectively p p
achieved separately single application action ar sufficient achieve
two fluents without making true unreachable cross context fluent p p
similar cases exist plans c
ce shorter minimum length plans
c
given strips task hf g costi h heuristic set p fluents
defined follows bonet geffner


p

h p
min padd h pre cost otherwise
h p max h p
pp



fiimproving delete relaxation heuristics explicit conjunctions

value heuristic given task taken h cost goal
g h h g
lemma given task c c p f c h c h
proof let hf gi c identical except action sets
denote action set ac c ac c deletes
conditional effects ac ac c ignore
follows
first h c h h h c direction
following two observations first strips task
split actions singleton add effects without affecting h precisely given
action p add pre denote p action pre p pre
add p p replacing split actions p e generating
split action p every non redundant add effect h remains second
say every split action p action set dominated action action set
e pre pre p add add p h lower bound
h
prove h c h every c f c
del c add c ac contains action ac given pre ac
pre c add c add ac add c c c c add c let

p add ac p add ac c dominates ac p say p c
c pre ac obtain dominating action ac c define
c c c del c add c c c
c c c c conditions del c add c
c c c c add c c c definition
obviously satisfied


thus ac c contains action ac given pre ac pre c c c add c

add ac add pre del c c c c prove


pre ac pre ac b p c add ac
regarding every c c

c add c add c add thus c c c add c add c add
regarding b need prove c c del c add c c c
first last properties obvious second one direct construction
third one add c true otherwise would c
c add implying contradiction construction c pre ac
remains prove h h c every c c conditions


stated ac c contains action ac let p add ac p
fluent p add p pre del latter case irrelevant

split action generated former case setting c add get ac p
dominated ac ac say p c least one following cases
must hold c c b c pre del c c add pre del
c add case follows directly definition ac ac


dominates ac p case b p c pre ac case irrelevant case c

c add c del ac ac dominates ac p
concludes proof


fikeyder hoffmann haslum

lemma given task set non unit conjunctions c h c
h c
ce
c
proof consider task c
cc identical except
include cross context preconditions precondition action representative

ac modified following



pre ac pre c



pre c add c

c c


c

c
h c h c
cc b h cc h ce

first prove proof lemma suffices prove every split
c
action ac p c
cc exists dominating action p fluent


ac c c dominates ac p otherwise say p c least one
following cases must hold c c b c add pre del case b


ac c c dominates ac p case obtain dominating action

ac c define
c c c del c add c c c
c c satisfy conditions del c add c c c

c c add c c c definition indeed ac action c


obviously c c thus p add ac remains prove pre ac

pre ac p intuitively c corresponds single conjunction c plus
subsumed conjunctions hence cross context fluents arise specifically every

c c c add c add thus pre ac pre c c c add c

pre c add c latter obviously contained pre ac p concluding
proof

c

c
remains prove b since h c
cc h cc suffices prove h cc

c

c
h ce consider state relaxed plan ce ce action ace
representing action original task let c set conjunctions c whose
ce
c c obviously qualifies
fluents added ace execution ce
ce

constraint definition qualifies constraint conditional effect
c property triggered ace conditional effect suitable c
c define action sequence
triggered thus c
cc includes representative
c adds fluents
c
c
ce
cc sequence obviously
precondition union ace conditional effects fire thus

c

c
relaxed plan c
cc follows h cc h ce desired

example consider strips task variables p q r z g g g
initial state goal g g g g actions follows




fiimproving delete relaxation heuristics explicit conjunctions

name
pre
add del ce cost
aqz

q
z



ari

r


pz
q
p z

aiq
apz
r
p
z


r
g
p z g


apz
agiq
q g


g
ar
r g


set c q p z operator adding part q aqz
adds q
qz
pz pz
operators adding part p z ai adds z aiq ar add p
pz
since aiq
apz
delete z cannot used establish conjunction p z
r
thus actions c
ce
name
pre
add del
ce cost
qz
qz
ai
q z
ce ai

ari

r




q


p



apz
q
iq
pz
ar
r
p



p z p z g



agpz
g
aiq
q q g



r g



agr
ce aqz
contains two conditional effects
name
c
add del
q
ei
q


ep p z
p p z

pz
clearly respect hmax fluents preconditions aiq
agpz agiq dominate respective preconditions actions pointed section
implementation actually remove preconditions thus lm cuts justification
graph c
ce would structure shown figure

c
hmax c
ce due cost achieving g h ce construct
qz pz
plan c
ce choice establish p use ai aiq
use ari apz
r latter case make single application conditionalg g
r pz qz g
effects action aqz
relaxed plan hai ar ai apz aiq ar whose cost
qz
former case must use ai twice first q p z yielding relaxed
pz qz g
g r g

c
plan haqz
aiq ai apz aiq ai ar whose cost thus h ce since
pz
execution delete ar true anyhow state
execution solves original task get h h c
ce
consider lm cut say produced cut conditional effects action
p z
aqz
connects p p z via conditional effect ep two options discussed
section reduce cost aqz
globally sticking original definition


lm cut b reduce cost ep p z conditional effect ei q
p z
part optimal cost path ep thus serves justify hmax value
options violates one essential properties lm cut



fikeyder hoffmann haslum



z

p



q
aqz
ei

aqz




q

aqz





ei q



r

arg

p z

apz
iq


ei q

q

apz
r

ari

p z
aqz
ep

agiq

agpz

g

g

g

figure illustration lm cut justification graphs c
ce example dashed
edges correspond preconditions critical hmax maximizing start
become critical point execution lm cut


p z
configuration lm cut produces cuts agpz cost aqz
ep cost
pz pz
g
cost ar aiq cost aiq cost ari cost note
q
p z
qz
qz
cut aqz
ep cost ai reduced globally particular cut ai ei
produced get heuristic value hlm cut hmax c
ce lm cut
dominate hmax
b configuration lm cut produce following cuts start every
p z
possible precondition choice function pcf get cuts agpz cost aqz
ep
cost hmax g g say pcf selects g get cut agiq
pz
max
cost pcf select g getting cut apz
r aiq cost h
g
g g say pcf selects g say pcf selects p z apz another
choice would z selects q apz
another choice would q thus remaining
iq
q pz
non dashed part figure get cut aqz
ei ar cost
g reached cost p q would get cut pcf
selecting g point hmax g g g get cut
agr cost point hmax goal facts say lm cut selects g thus
get cut ari cost way achieve r finally hmax
q
g yielding cut aqz
ei cost overall get heuristic value
hlm cut h h c
ce lm cut admissible

agr

bibliography
baier j botea improving performance low conflict relaxed
plans gerevini howe cesta refanidis eds proceedings


fiimproving delete relaxation heuristics explicit conjunctions

th international conference automated scheduling icaps
pp thessaloniki greece aaai press
bonet b geffner h heuristic search artificial intelligence

bonet b helmert strengthening landmark heuristics via hitting sets
coelho h studer r wooldridge eds proceedings th european
conference artificial intelligence ecai pp lisbon portugal ios
press
bonet b palacios h geffner h automatic derivation memoryless policies
finite state controllers classical planners gerevini howe cesta
refanidis eds proceedings th international conference automated scheduling icaps pp thessaloniki greece aaai
press
bylander computational complexity propositional strips
artificial intelligence
cai hoffmann j helmert enhancing context enhanced additive
heuristic precedence constraints gerevini howe cesta refanidis eds proceedings th international conference automated
scheduling icaps pp thessaloniki greece aaai press
b kambhampati sapa domain independent heuristic metric temporal planner cesta borrajo eds recent advances ai th
european conference ecp lecture notes artificial intelligence
pp toledo spain springer verlag
fox long stan hybrid strategy subproblem
abstraction ai magazine
garey r johnson computers intractabilitya guide
theory np completeness freeman san francisco ca
gazen b c knoblock c combining expressiveness ucpop
efficiency graphplan steel alami r eds recent advances ai
th european conference ecp lecture notes artificial
intelligence pp toulouse france springer verlag
gerevini saetti serina stochastic local search
temporal action graphs journal artificial intelligence
haslum p geffner h admissible heuristics optimal chien
kambhampati r knoblock c eds proceedings th international conference artificial intelligence systems aips pp breckenridge co aaai press
haslum p hm p h p alternative characterisations generalisation
hmax hm gerevini howe cesta refanidis eds proceedings th international conference automated scheduling
icaps pp thessaloniki greece aaai press


fikeyder hoffmann haslum

haslum p incremental lower bounds additive cost
bonet b mccluskey l silva j r williams b eds proceedings nd
international conference automated scheduling icaps pp
sao paulo brasil aaai press
helmert fast downward system journal artificial intelligence

helmert domshlak c landmarks critical paths abstractions whats
difference anyway gerevini howe cesta refanidis eds
proceedings th international conference automated scheduling icaps pp thessaloniki greece aaai press
helmert geffner h unifying causal graph additive heuristics
rintanen j nebel b beck j c hansen e eds proceedings th
international conference automated scheduling icaps pp
sydney australia aaai press
hoffmann j ignoring delete lists works local search topology
benchmarks journal artificial intelligence
hoffmann j nebel b system fast plan generation
heuristic search journal artificial intelligence
hoffmann j porteous j sebastia l ordered landmarks journal
artificial intelligence
hoffmann j steinmetz haslum p take render h c
perfect proceedings th workshop heuristics search domain
independent icaps
karpas e domshlak c cost optimal landmarks boutilier c
ed proceedings st international joint conference artificial intelligence
ijcai pp pasadena california usa morgan kaufmann
katz hoffmann j domshlak c said need relax variables
borrajo fratini kambhampati oddi eds proceedings
rd international conference automated scheduling icaps
pp rome italy aaai press
keyder e geffner h heuristics action costs revisited
ghallab ed proceedings th european conference artificial intelligence ecai pp patras greece wiley
keyder e geffner h trees shortest paths vs steiner trees understanding
improving delete relaxation heuristics boutilier c ed proceedings
st international joint conference artificial intelligence ijcai pp
pasadena california usa morgan kaufmann
keyder e hoffmann j haslum p semi relaxed plan heuristics bonet b
mccluskey l silva j r williams b eds proceedings nd international conference automated scheduling icaps pp
sao paulo brasil aaai press


fiimproving delete relaxation heuristics explicit conjunctions

keyder e richter helmert sound complete landmarks
graphs coelho h studer r wooldridge eds proceedings th
european conference artificial intelligence ecai pp lisbon portugal ios press
palacios h geffner h compiling uncertainty away conformant
bounded width journal artificial intelligence

richter westphal lama planner guiding cost anytime
landmarks journal artificial intelligence
roger g pommerening f helmert optimal presence
conditional effects extending lm cut context splitting schaub ed
proceedings st european conference artificial intelligence ecai
prague czech republic ios press appear




