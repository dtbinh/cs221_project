Journal Artificial Intelligence Research 50 (2014) 697-722

Submitted 10/13; published 07/14

MDD Propagation Sequence Constraints
David Bergman

david.bergman@business.uconn.edu

School Business, University Connecticut
2100 Hillside Road, Unit 1041, Storrs, CT 06260

Andre A. Cire
Willem-Jan van Hoeve

acire@andrew.cmu.edu
vanhoeve@andrew.cmu.edu

Tepper School Business, Carnegie Mellon University
5000 Forbes Avenue, Pittsburgh, PA 15213 USA

Abstract
study propagation Sequence constraint context constraint programming based limited-width MDDs. first contribution proving establishing
MDD-consistency Sequence NP-hard. Yet, show task fixed parameter tractable respect length sub-sequences. addition, propose
partial filtering algorithm relies specific decomposition constraint
novel extension MDD filtering node domains. experimentally evaluate performance proposed filtering algorithm, demonstrate strength
MDD propagation increases maximum width increased. particular, MDD propagation outperform conventional domain propagation Sequence reducing
search tree size solving time several orders magnitude. Similar improvements
observed respect current best MDD approach applies decomposition
Sequence Among constraints.

1. Introduction
central inference process constraint programming constraint propagation (Rossi,
van Beek, & Walsh, 2006; Dechter, 2003; Apt, 2003). traditional constraint processing
techniques designed explicitly defined relations small arity, state-of-the-art constraint programming solvers apply specialized constraint propagation algorithms global
constraints arity, often based efficient combinatorial methods network
flows (van Hoeve & Katriel, 2006; Regin, 2011).
Conventional constraint propagation algorithms (or domain filtering algorithms) operate individual constraints given problem. role identify remove
values variable domains inconsistent respect constraint
consideration. Whenever domain variable updated (i.e., value removed),
constraints variable appears reconsidered inspection.
cascading process propagating changes variable domains constraints
continues fixed point reached. constraint programming solvers assume
variable domains finite, ensures termination constraint propagation
process. Note constraint propagation may sufficient determine
resolution given problem. Therefore, constraint propagation normally applied
search state systematic search process.
c
2014
AI Access Foundation. rights reserved.

fiBergman, Cire & van Hoeve

major benefit propagating variable domains implemented efficiently
many cases. However, inherent weakness domain propagation implicitly
represents Cartesian product variable domains potential solution space.
communicating domain changes, limits amount information shared
constraints.
address shortcoming domain propagation, Andersen, Hadzic, Hooker,
Tiedemann (2007) proposed use multi-valued decision diagrams (MDDs) alternative variable domains context constraint propagation. MDDs directed
acyclic layered graphs can, principle, compactly represent solutions combinatorial problem (Wegener, 2000). Andersen et al. (2007) showed MDDs limited
width provide much stronger relaxation solution space traditional
Cartesian product variable domains, consequence MDDs allow represent
communicate refined information constraints. propagating MDDs
rather variable domains, huge reductions search tree size computation time
realized (Andersen et al., 2007; Hadzic, Hooker, OSullivan, & Tiedemann, 2008a;
Hadzic, Hooker, & Tiedemann, 2008b; Hadzic, OMahony, OSullivan, & Sellmann, 2009;
Hoda, van Hoeve, & Hooker, 2010; Cire & van Hoeve, 2012, 2013).
MDDs used represent individual (global) constraints, subsets constraints,
constraints given problem. representing individual constraints,
work Hawkins, Lagoon, Stuckey (2005) Cheng Yap (2008), higher-level
information carried MDD lost projecting variable domains
traditional domain propagation. highest potential MDD propagation instead
appears representing specific subsets constraints within MDD. is,
given set constraints, create maintain one single limited-width MDD,
propagated constraint set. Since MDD defined respect
fixed variable ordering, useful select subset constraints compatible
ordering. applied way, MDD propagation implemented parallel
existing domain propagation constraint programming systems, thus complementing
potentially strengthening domain propagation process. example, Cire van Hoeve
(2013) introduced MDD propagation subset constraints representing disjunctive
scheduling problems. embedded custom global constraint ILOG CP
Optimizer constraint programming solver, greatly improved performance.
1.1 Methodology
Constraint propagation based limited-width MDDs amounts MDD filtering MDD
refinement. role MDD filtering algorithm remove provably inconsistent arcs
MDD (Hadzic et al., 2008b; Hoda et al., 2010). MDD refinement algorithm
hand, aims splitting nodes MDD accurately reflect solution
space (Hadzic et al., 2008a). order make approach scalable efficient, refinement
algorithms must ensure MDD remains within given maximum size (typically
restricting maximum widththe number nodes layer). increasing
maximum width, MDD relaxation strengthened desired level.
is, maximum width 1 would correspond traditional Cartesian product
variable domains, infinite maximum width would correspond exact MDD
698

fiMDD Propagation Sequence Constraints

representing solutions. However, increasing size MDD immediately impacts
computation time, one typically needs balance trade-off strength
MDD associated computation time.
order characterize outcome MDD filtering algorithm, notion MDD
consistency introduced Andersen et al. (2007), similar domain consistency
finite-domain constraint programming: Given MDD, constraint MDD consistent
arcs MDD belong least one solution constraint. consequence
richer data structure MDD represents, establishing MDD consistency may
difficult establishing domain consistency. example, Andersen et al. show
establishing MDD consistency Alldifferent constraint NP-hard,
establishing traditional domain consistency done polynomial time (Regin, 1994).
1.2 Contributions
main focus paper Sequence constraint, defined specific conjunction Among constraints, Among constraint restricts occurrence
set values sequence variables within lower upper bound (Beldiceanu
& Contejean, 1994). Sequence constraint finds applications in, e.g., car sequencing
employee scheduling problems (Regin & Puget, 1997; van Hoeve, Pesant, Rousseau, &
Sabharwal, 2009). known classical domain consistency established Sequence polynomial time (van Hoeve, Pesant, Rousseau, & Sabharwal, 2006; van Hoeve
et al., 2009; Brand, Narodytska, Quimper, Stuckey, & Walsh, 2007; Maher, Narodytska,
Quimper, & Walsh, 2008; Downing, Feydy, & Stuckey, 2012). Furthermore, Hoda et al.
(2010) present MDD filtering algorithm Among constraints establishing MDD consistency polynomial time. However, remained open question whether MDD
consistency Sequence established polynomial time well.
work, answer question negatively first contribution showing
establishing MDD consistency Sequence constraint NP-hard.
important result perspective MDD-based constraint programming. Namely,
global constraints, Sequence constraint perhaps suitable combinatorial
structure MDD approach; prescribed variable ordering, combines subconstraints contiguous variables, existing approaches handle constraint
fully using bounds reasoning only.
second contribution, show establishing MDD consistency Sequence constraint fixed parameter tractable respect lengths subsequences (the Among constraints), provided MDD follows order Sequence constraint. proof constructive, follows generic algorithm filter
one MDD another.
third contribution partial MDD propagation algorithm Sequence,
necessarily establish MDD consistency. relies decomposition Sequence
cumulative sums, new extension MDD filtering information
stored nodes.
last contribution experimental evaluation proposed partial MDD propagation algorithm. evaluate strength algorithm MDDs various maximum
widths, compare performance existing domain propagators Sequence.
699

fiBergman, Cire & van Hoeve

compare algorithm currently best known MDD approach uses
natural decomposition Sequence Among constraints (Hoda et al., 2010).
experiments demonstrate MDD propagation outperform domain propagation
Sequence reducing search tree size, solving time, several orders magnitude. Similar results observed respect MDD propagation Among constraints.
results thus provide evidence power MDD propagation context
constraint programming.
remainder paper structured follows. Section 2, provide necessary definitions MDD-based constraint programming Sequence constraint.
Section 3, present proof establishing MDD consistency Sequence NPhard. Section 4 describes establishing MDD consistency fixed parameter tractable.
Section 5, partial MDD filtering algorithm presented. Section 6 shows experimental results. present final conclusions Section 7.

2. Definitions
first recall basic definitions MDD-based constraint programming, following
work Andersen et al. (2007) Hoda et al. (2010). work, ordered Multivalued
Decision Diagram (MDD) directed acyclic graph whose nodes partitioned n + 1
(possibly empty) subsets layers L1 , . . . , Ln+1 , layers L1 , . . . , Ln correspond
respectively variables x1 , . . . , xn . L1 contains single root node r, Ln+1 contains
single terminal node t. node u MDD, let L (u) denote index
layer. MDD , width w(M ) maximum number nodes layer,
maxni=1 {|Li |}. MDD-based CP, MDDs typically given fixed maximum width.
arcs MDD directed upper lower layer; is, node
Li node Lj < j. purposes convenient assume
(without loss generality) arc connects two adjacent layers. arc
layer Li labeled element domain D(xi ) xi . arc a, refer
label represents `(a). notational convenience, write `(u, v) instead
`((u, v)) arc (u, v). element D(xi ) appears label
arcs given node u Li . set A(u, v) arcs node u node v may
contain multiple arcs, denote label. Let (u) denote set arcs
comingfi node u. define size anfi MDD number arcs, i.e.,
|M | = fi{a | (u), u Li , = 2, . . . , n + 1}fi.
arc label v leaving node layer represents assignment xi = v.
path MDD r denoted arc labels v1 , . . . , vn path
identified solution (x1 , . . . , xn ) = (v1 , . . . , vn ). path v1 , . . . , vn feasible
given constraint C setting (x1 , . . . , xn ) = (v1 , . . . , vn ) satisfies C. Constraint C feasible
MDD MDD contains feasible path C.
constraint C called MDD consistent given MDD every arc MDD
lies feasible path. Thus MDD consistency achieved redundant arcs
(i.e., arcs feasible path) removed. say MDD MDD
consistent respect C. Domain consistency C equivalent MDD consistency
MDD width one represents variable domains. is, equivalent
700

fiMDD Propagation Sequence Constraints

MDD consistency MDD layer Li contains single node si ,
A(si , si+1 ) = D(xi ) = 1, . . . , n.
Lastly, formally recall definitions Among (Beldiceanu & Contejean, 1994),
Sequence (Beldiceanu & Contejean, 1994), Gen-Sequence (van Hoeve et al., 2009)
constraints. Among constraint counts number variables assigned
value given set S, ensures number given lower upper
bound:
Definition 1 Let X set variables, l, u integer numbers 0 l u |X|,
xX D(x) subset domain values. define Among(X, l, u, S)
X
l
(x S) u.
xX

Note expression (x S) evaluated binary value, i.e., resulting 1 x
0 x
/ S. Sequence constraint conjunction given Among constraint
applied every sub-sequence length q sequence n variables:
Definition 2 Let X ordered set n variables, q, l, u integer numbers
0 q n, 0 l u q, xX D(x) subset domain values.
Sequence(X, q, l, u, S) =

nq+1
^

Among(si , l, u, S),

i=1

si represents sub-sequence xi , . . . , xi+q1 .
Finally, generalized Sequence constraint extends Sequence constraint allowing
Among constraints specified different lower upper bounds, subsequence length:
Definition 3 Let X ordered set n variables, k natural number, ~s, ~l, ~u vectors
length k si sub-sequence X, li , ui N, 0 li ui n = 1, 2, . . . , k,
xX D(x) subset domain values.
Gen-Sequence(X, ~s, ~l, ~u, S) =

k
^

Among(si , li , ui , S).

i=1

3. MDD Consistency Sequence NP-Hard
stated before, known non-trivial NP-hardness result global constraint
context MDD-based constraint programming Andersen et al. (2007)
Alldifferent constraint. challenge determining whether global constraint
made MDD consistent polynomial time must guaranteed
given MDD. is, addition combinatorics global constraint itself,
shape MDD adds another layer complexity establishing MDD consistency.
proving NP-hardness, particular difficulty making sure reduction, MDD
remains polynomial size. Sequence constraints, far unknown whether
polynomial-time MDD consistency algorithm exists. section answer question
negatively prove following result.
701

fiBergman, Cire & van Hoeve

Theorem 1 Establishing MDD consistency Sequence arbitrary MDD NPhard even MDD follows variable ordering Sequence constraint.
Proof. proof reduction 3-SAT, classical NP-complete problem (Garey
& Johnson, 1979). show instance 3-SAT satisfied
particular Sequence constraint particular MDD polynomial size solution.
Therefore, establishing MDD consistency Sequence arbitrary MDD least
hard 3-SAT.
Consider 3-SAT instance n variables x1 , . . . , xn , consisting clauses c1 , . . . , cm .
first construct MDD represents basic structure 3-SAT formula (see
Example 1 proof illustration). introduce binary variables yi,j i,j
representing literals xj xj per clause ci , = 1, . . . , j = 1, . . . , n (xj xj
may may exist ci ). order variables sequence , first index
clauses, index variables, yi,j , i,j clause ci variable
xj . is, = y1,1 , 1,1 , y1,2 , 1,2 ,. . . ,y1,n , 1,n , . . . , ym,1 , m,1 , . . . ,ym,n , m,n .
construct MDD layered graph, k-th layer corresponds k-th
variable sequence .
clause ci represented 2n consecutive layers corresponding yi,1 , . . . , i,n .
part MDD, identify precisely paths lead solution satisfying
clause. basis diamond structure pair literals (yi,j , i,j ),
assigns either (0, 1) (1, 0) pair. variable appear clause,
represent using diamond part MDD representing clause, thus
ensuring variable take assignment respect clause.
variables appear clause, explicitly list allowed combinations.
precisely, clause ci , first define local root node ri representing layer L (yi,1 ),
set tag(ri ) = unsat. node u layer L (yi,j ) (for j = 1, . . . , n),
following. variable xj appear ci , tag(u) sat, create two nodes v, v 0
L i,j , one single node w L (yi,j+1 ), arcs (u, v) label 1, (u, v 0 ) label 0,
(v, w) label 0, (v 0 , w) label 1. corresponds diamond structure.
set tag(w) = tag(u). Otherwise (i.e., tag(u) unsat yi,j appears ci ), create
two nodes v, v 0 L i,j , two nodes w, w0 L (yi,j+1 ), arcs (u, v) label 1, (u, v 0 )
label 0, (v, w) label 0, (v 0 , w0 ) label 1. ci contains literal yi,j , set
tag(w) = sat tag(w0 ) = unsat. Otherwise (ci contains i,j ), set tag(w) = unsat
tag(w0 ) = sat.
procedure initialized single root node r representing L (y11 ).
iteratively append MDDs two consecutive clauses ci ci+1 merging nodes
last layer ci marked sat single node, let node
local root ci+1 . finalize procedure merging nodes last layer
marked sat single terminal node t. construction, ensure one
yij ij set 1. Furthermore, variable assignment corresponding
path layers L (yi,1 ) L (yi+1,1 ) satisfy clause ci , exactly n literals
chosen accordingly path.
next need ensure feasible path MDD, variable xj
correspond literal yi,j i,j clause ci . end, impose
702

fiMDD Propagation Sequence Constraints

r
c1

:0
:1

y1,1

y1,1
y1,2
y1,2
y1,3
y1,3
y1,4
y1,4
c2

y2,1

y2,1
y2,2
y2,2
y2,3
y2,3
y2,4
y2,4


Figure 1: MDD corresponding Example 1.
constraint
Sequence(Y, q = 2n, l = n, u = n, = {1})

(1)

MDD described above. sub-sequence length 2n starts positive
literal yi,j , definition exactly n variables take value 1. sub-sequence
starts negative literal i,j instead, last variable sequence corresponds
value xj next clause ci+1 , i.e., yi+1,j . Observe variables except
first last sequence take value 1 already n 1 times. Therefore,
first last variable sequence (which represent xj complement xj
order), one take value 1. is, xj must take value clause ci
ci+1 . Since holds sub-sequences, variables xj must take value
clauses.
MDD contains 2mn + 1 layers, layer contains six nodes.
Therefore, polynomial size (in size 3-SAT instance), overall construction needs polynomial time.

703

fiBergman, Cire & van Hoeve

:0
:1

x1
0

1

x2
00

01

10

11

00

01

10

11

00

01

10

11

00

01

10

11

x3

x4

x5

x6

Figure 2: exact MDD Sequence constraint Example 2.

Example 1 Consider 3-SAT instance four Boolean variables x1 , x2 , x3 , x4 clauses
c1 = (x1 x3 x4 ) c2 = (x2 x3 x4 ). corresponding MDD used reduction
given Figure 1.

4. MDD Consistency Sequence Fixed Parameter Tractable
section show establishing MDD consistency Sequence arbitrary
MDD fixed parameter tractable, respect length sub-sequences q.
already shown van Hoeve et al. (2006, 2009) exact MDD Sequence
constraint exists O(n2q ) nodes (i.e., unfolded automaton Regular constraint), illustrated next example.
Example 2 Consider constraint Sequence(X, q = 3, l = 1, u = 2, = {1})
X = {x1 , x2 , . . . , x6 } ordered set binary variables. corresponding exact MDD,
following order X, presented Figure 2. convenience, node MDD
labeled last q 1 labels represent sub-sequence node (starting
q 1 layers up). example, second node third layer represents decisions x1 = 0
x2 = 1, corresponding sub-sequence 01. construct next layer, either append
0 1 sub-sequence (and remove first symbol), leading nodes labeled 10
11, respectively. Note nodes labeled 00 must take arc label 1,
l = 1. Similarly nodes labeled 11 must take arc label 0, u = 2. q
704

fiMDD Propagation Sequence Constraints

layers, possible sub-sequences created (maximally O(2q1 )), thus defines
width subsequent layers.
However, since given arbitrary MDD, necessarily exact MDD, need
additional steps exploit connection. apply generic approach
show fixed parameter tractability Sequence, fact applied
determine whether MDD consistency tractable constraint.
goal establish MDD consistency given MDD respect another
MDD 0 set variables. compatible earlier definitions since
0 interpreted define constraint. is, MDD consistent respect
0 every arc belongs path (solution) exists 0 . purposes,
assume 0 follow variable ordering.
establish MDD consistency first taking intersection 0 ,
removing arcs compatible intersection. Computing
intersection two MDDs well-studied, present top-down intersection algorithm
follows definitions Algorithm 1. description adapted melding
procedure presented Knuth (2009).
intersection MDD, denoted I, represents possible paths (solutions)
present 0 . partial path root rI node u thus
exist 0 , respective endpoints v, v 0 . information captured
associating node u state s(u) = (v, v 0 ) representing nodes v
v 0 0 . root initialized rI s(rI ) := (r, r0 ) r r0
respective roots 0 (lines 1-2). algorithm then, top-down traversal,
considers layer LIi I, augments node u LIi s(u) = (v, v 0 ) arc
0 arc label v v 0 respectively (lines
5-7). next layer already contains node u state re-use node.
Otherwise add new node u LIi+1 add arc (u, u) I. Note last layer
contains single terminal tI state s(tI ) = (t, t0 ), provided empty.
last step (line 14) clean removing arcs nodes belong
feasible path. done bottom-up traversal I. Observe algorithm
necessarily create reduced MDD.
Algorithm 2 presents algorithm establish MDD-consistency respect
0
. first compute intersection 0 (line 1). traverse
top-down traversal, layer LM
identify remove infeasible arcs. this,
define Boolean array Support[u, l] (initialized 0) represents whether arc
node u label l support (line 3). line 4, consider arcs
layer LIi I. arc = (v, v) exists LIi label l s(v) = (u, u0 ), mark
associated arc u supported setting Support[u, l] := 1 (lines 4-6).
remove arcs LM
support (lines 7-9). Lastly, clean
removing arcs nodes belong feasible path (line 11).
Theorem 2 Algorithm 2 establishes MDD-consistency respect 0 O(|M |
w(M 0 ) time space.
Proof. correctness Algorithm 1 follows induction number layers.
prove Algorithm 2 establishes MDD-consistency, consider arc = (u, u)
705

fiBergman, Cire & van Hoeve

Algorithm 1 Intersection(M ,M 0 )
Input: MDD root r, MDD 0 root r0 . 0 defined
ordered sequence n variables.
Output: MDD layers LI1 , . . . , LIn+1 arc set AI . node u
associated state s(u).
1: create node r state s(r ) := (r, r 0 )
2: LI1 := {r }
3: = 1 n
4:
LIi+1 := {}
5:
u LIi s(u) = (v, v 0 )
6:
= (v, v) a0 = (v 0 , v 0 ) 0 `(a) = `(a0 )
7:
create node u state s(u) := (v, v 0 )
8:
w LIj+1 s(w) = s(u) u := w
9:
else LIi+1 += u end
10:
add arc (u, u) label `(a) arc set AI
11:
end
12:
end
13: end
14: remove arcs nodes path r tI LIn+1
15: return

Algorithm 2 MDD-Consistency(M ,M 0 )
Input: MDD root r, MDD 0 root r0 . 0 defined
ordered sequence n variables.
Output: MDD-consistent respect 0
1: create := Intersection(M ,M 0 )
2: = 1 n
3:
create array Support[u, l] := 0 u LM
arcs u label l
4:
arcs = (v, v) AI s(v) = (u, u0 ) v LIi
5:
Support[u, `(a)] := 1
6:
end
7:
arcs = (u, u) u LM

8:
Support[u, `(a)] = 0 remove end
9:
end
10: end
11: remove arcs nodes path r LM
n+1
12: return

706

fiMDD Propagation Sequence Constraints

applying algorithm. exists node v s(v) = (u, u0 ) solutions
represented paths r u r0 u0 0 equivalent.
exists arc aI = (v, v) AI label a. Consider s(v) = (w, w0 ). Since
decision diagrams, label appears arc node.
Therefore, w = u. Since aI belongs I, exist paths w (or u)
w0 t0 0 equivalent. Hence, belongs feasible path (from r
u, along u terminating t) equivalent path exists 0
(from r0 u0 , w0 terminating t0 ).
Regarding time complexity computing intersection, coarse upper bound
multiplies n (line 3), w(M ) w(M 0 ) (line 5), d2max (line 6), dmax represents
maximum degree node, maxxX |D(x)|. amortize steps since forloops lines 3 6 consider arc comparison arcs 0 . arc
compared w(M 0 ) arcs (line 6); assume check constant
time whether node outgoing arc given label (using arc-label list).
gives total time complexity O(|M | w(M 0 )). memory requirements bounded
size intersection, O(n w(M ) w(M 0 ) dmax ) = O(|M | w(M 0 )).
dominates complexity Algorithm 2, since lines 2-12 performed linear
time space (in size ).

Observe Algorithm 2 longer ensures solution represented
path 0 , case intersection. MDD-consistency merely establishes
arc belongs solution 0 . Although MDD intersections
stronger MDD consistency, limitation width intersection
MDD may large product widths 0 . Therefore intersecting
multiple MDDs will, general, increase size resulting MDD exponentially.
next apply Theorem 2 Sequence constraint.
Corollary 1 Let X ordered sequence variables, C = Sequence(X, q, l, u, S)
sequence constraint, arbitrary MDD following variable ordering X. Establishing MDD consistency C fixed parameter tractable respect parameter q.
Proof. know exists exact MDD 0 size O(n2q1 ) represents C
(van Hoeve et al., 2006, 2009). Applying Theorem 2 gives MDD-consistency algorithm
time space complexity O(|M | 2q1 ), result follows.

note Theorem 2 applied obtain tractability establishing
MDD consistency constraints. Consider example constraint Among(x1 , x2 ,
. . . , xn , l, u, S). variable ordering, construct exact MDD top-down
procedure associating node v number variables taking value along
path r v, representing length path. Nodes length
equivalent merged. largest layer u + 1 different path
lengths, exact MDD size O(nu), Theorem 2 establishing MDD consistency
tractable Among. Indeed, Hoda et al. (2010) showed MDD consistency
established constraint, quadratic time complexity.
707

fiBergman, Cire & van Hoeve

converse Theorem 2 hold: exist constraints MDD
consistency established polynomial time given MDD, minimal
reduced exact MDD hasP
exponential size. specific example, consider linear inequality
constraints form ni=1 ai xi b xi integer variable, ai constant,
= 1, . . . , n, b constant. MDD consistency established constraints
linear time, given MDD, computing arc longest r-t path (relative
coefficients ai ) uses arc (Andersen et al., 2007). However, Hosaka, Takenaga,
Kaneda, Yajima (1997)
provide following explicit linear inequality. k even
P
n = k 2 , consider 1i,jk aij xij k(22k 1)/2, xij binary variable,
aij = 2i1 + 2k+j1 , 1 i, j k. show that, variable order,
size

n/2
reduced ordered BDD inequality bounded (2
).

5. Partial MDD Filtering Sequence
many practical situations value q lead prohibitively large exact MDDs
establishing MDD consistency, limits applicability Corollary 1. Therefore
next explore practical partial filtering algorithm polynomial q.
One immediate approach propagate Sequence constraint MDDs
natural decomposition Among constraints, apply MDD filtering algorithms
Among proposed Hoda et al. (2010). However, well-known classical
constraint propagation based variable domains, Among decomposition substantially improved dedicated domain filtering algorithm Sequence (van Hoeve
et al., 2006, 2009; Brand et al., 2007; Maher et al., 2008). Therefore, goal section provide MDD filtering Sequence stronger practice MDD
filtering Among decomposition, stronger domain filtering Sequence.
follows, assume MDD hand respects ordering variables
Sequence constraint.
5.1 Cumulative Sums Encoding
proposed algorithm extends original domain consistency filtering algorithm
Sequence van Hoeve et al. (2006) MDDs, following cumulative sums encoding proposed Brand et al. (2007). representation takes following form.
sequence variables X = x1 , x2 , . . . , xn , constraint Sequence(X, q, l, u, S),
first introduce variables y0 , y1 , . . . , yn , respective initial domains D(yi ) = [0, i]

Pi = 1, . . . , n. variables represent cumulative sums X, i.e., yi represents
j=1 (xj S) = 1, . . . , n. rewrite Sequence constraint following
system constraints:
{1, . . . , n},

(2)

yi+q yi l

{0, . . . , n q},

(3)

yi+q yi u

{0, . . . , n q},

(4)

yi = yi1 + (xi )

: X {0, 1} indicator function set S, i.e., (x) = 1 x
(x) = 0 x
/ S. Brand et al. show establishing singleton bounds consistency
system suffices establish domain consistency original Sequence constraint.
708

fiMDD Propagation Sequence Constraints

order apply similar reasoning context MDDs, crucial observation
domains variables y0 , . . . , yn naturally represented nodes
MDD. words, node v layer Li represents domain yi1 , restricted
solution space formed r-t paths containing v. Let us denote information
node v explicitly interval [lb(v), ub(v)], refer node domain
v. Following approach Hoda et al. (2010), compute information linear
time one top-down pass, using equation (2), follows:
lb(v) = min(u,v)Ain (v) {lb(u) + (`(u, v))} ,
ub(v) = max(u,v)Ain (v) {ub(u) + (`(u, v))} ,

(5)

nodes v 6= r, [lb(r), ub(r)] = [0, 0].
individual Among constraints posted yi+q yi l yi+q yi u,
need compute node v layer Li+1 ancestors layer Li .
done maintaining vector Av length q + 1 node v, Av [i] represents
set ancestor nodes v i-th layer v, = 0, . . . , q. initialize
Ar = [{r}, , . . . , ], apply recursion
Av [i] = (u,v)Ain (v) Au [i 1]

= 1, 2, . . . , q,

Av [0] = {v}.
resulting top-down pass takes linear time (in size MDD), direct
implementation recursive step node takes O(q (w(M ))2 ) operations
MDD . Now, relevant ancestor nodes node v layer Li+q stored Av [q],
subset layer Li . similarly compute descendant nodes v vector Dv
length q + 1, Dv [i] contains descendants v i-th layer v,
= 0, 1, . . . , q. initialize Dt = [{t}, , . . . , ].
However, purposes need maintain minimum maximum value
union domains Av , resp., Dv , constraints (3) (4) inequalities;
see application Av Dv rules (8) below. makes recursive step
efficient, taking O(qw(M )) operations per node.
Alternatively, approximate information maintaining minimum
maximum node domain value layer, instead list ancestor layers.
compromise filtering, may efficient practice, requires
maintain two integers per layer.
5.2 Processing Constraints
next process constraints (2), (3), (4) turn remove provably inconsistent arcs, time filter node information.
Starting ternary constraints type (2), remove arc (u, v) lb(u) +
(`(u, v)) > ub(v). Updating [lb(v), ub(v)] node v done similar rules (5)
above:


lb(v) = max lb(v), min(u,v)Ain (v) {lb(u) + (`(u, v))} ,
(6)


ub(v) = min ub(v), min(u,v)Ain (v) {ub(u) + (`(u, v))} ,
709

fiBergman, Cire & van Hoeve

:0
:1

y0

[0,0

[0,0]

x1

x1
[0,0]

[0,0]

[1,1]

y1

[1,1]

x2

x2
[0,0]

[2,2]

[1,1]

[0,0]

[2,2]

[1,1]

y2
x3

x3
[1,1]

[0,2]

[2,3]

[1,1]

[2,2]

[2,2]

y3
x4

x4
[1,1]

[0,2]

[1,4]

[1,1]

[2,2]

[3,3]

y4
x5

x5
[2,4]

[0,5]

a. Initial MDD

b. Node domains

y5

c. MDD filtering

Figure 3: MDD propagation constraint Sequence(X, q = 3, l = 1, u = 2, = {1})
Example 3.

fact, resulting algorithm special case MDD consistency equality propagator Hadzic et al. (2008a), thus inherit MDD consistency ternary
constraints.
Next, process constraints (3) (4) node v layer Li+1 (i = 0, . . . , n).
Recall relevant ancestors Li+1q Av [q], relevant descendants
Li+1+q Dv [q]. variable corresponding node v yi , participates
four constraints:
yi l + yiq ,
yi u + yiq ,
(7)
yi yi+q l,
yi yi+q u.
Observe apply constraints filter node domain [lb(v), ub(v)]
corresponding yi . Namely, node domains corresponding variables yiq
yi+q may find support nodes layer Li+1 v. update lb(v)
ub(v) according equations (7):
lb(v) = max{ lb(v),

l + min lb(u),
uAv [q]

ub(v) = min{ ub(v), u + max ub(u),
uAv [q]

min lb(w) u },
wDv [q]

max ub(w) l }.

(8)

wDv [q]

resulting algorithm specific instance generic MDD consistent binary
constraint propagator presented Hoda et al. (2010), inherit MDD
consistency constraints. process constraints linear time (in size
MDD) top-down bottom-up pass MDD.
710

fiMDD Propagation Sequence Constraints

Example 3 Consider constraint Sequence(X, q = 3, l = 1, u = 2, = {1})
ordered sequence binary variables X = {x1 , x2 , x3 , x4 , x5 }. Assume given
MDD Figure 3.a. Figure 3.b. show node domains result processing
rules (5). Figure 3.c. shows resulting MDD processing constraints via
rules (6) (8). example, consider middle node fourth layer, corresponding
variable y3 . Let node v. initial domain [0, 2], Av [q] contains
root node, domain [0, 0]. Since l = 1, reduce domain v [1, 2].
next consider arcs v, conclude value 1 domain supported.
reduces domain v [2, 2], allows us eliminate one incoming arc
(from first node previous layer).
resulting MDD Figure 3.c. reflects possible deductions made
partial algorithm. established MDD consistency however, witnessed
infeasible path (1, 1, 0, 0, 0).
Observe proposed algorithm applied immediately general
Gen-Sequence constraints Among constraint individual l, u q.
cumulative sums encoding adjusted straightforward manner represent
different values.
5.3 Formal Analysis
next formally compare outcome partial MDD filtering algorithm MDD
propagation Among encoding domain propagation Sequence. First,
recall following theorem.
Theorem 3 (Brand et al., 2007, Thm. 4) Bounds consistency cumulative sums
encoding incomparable bounds consistency Among encoding Sequence.
Note since variable domains Among cumulative sums encoding
ranges (intervals integer values), bounds consistency equivalent domain consistency.
Corollary 2 MDD consistency cumulative sums encoding incomparable MDD
consistency Among encoding Sequence.
Proof. apply examples proof Theorem 4 work Brand et al..
Consider constraint Sequence(X, q = 2, l = 1, u = 2, = {1}) ordered
sequence binary variables X = {x1 , x2 , x3 , x4 } domains D(xi ) = {0, 1} =
1, 2, 4, D(x3 ) = {0}. apply trivial MDD width 1 representing Cartesian
product variable domains. Establishing MDD consistency cumulative sums
encoding yields
y0 [0, 0], y1 [0, 1], y2 [1, 2], y3 [1, 2], y4 [2, 3],
x1 {0, 1}, x2 {0, 1}, x3 {0}, x4 {0, 1}.
Establishing MDD consistency Among encoding, however, yields
x1 {0, 1}, x2 {1}, x3 {0}, x4 {1}.
711

fiBergman, Cire & van Hoeve

Consider constraint Sequence(X, q = 3, l = 1, u = 1, = {1}) ordered
sequence binary variables X = {x1 , x2 , x3 , x4 } domains D(xi ) = {0, 1} =
2, 3, 4, D(x1 ) = {0}. Again, apply MDD width 1 representing Cartesian
product variable domains. Establishing MDD consistency cumulative sums
encoding yields
y0 [0, 0], y1 [0, 0], y2 [0, 1], y3 [1, 1], y4 [1, 1],
x1 {0}, x2 {0, 1}, x3 {0, 1}, x4 {0},
establishing MDD consistency Among encoding prune value.
additional illustration Corollary 2, consider Example 3 Figure 3. MDD
propagation Among encoding eliminate value x4 = 0 infeasible
path (1, 1, 0, 0, 0), whereas example showed MDD propagation cumulative sums
detect this.
Theorem 4 MDD consistency cumulative sums encoding Sequence incomparable domain consistency Sequence.
Proof. first example proof Corollary 2 shows domain consistency
Sequence stronger MDD consistency cumulative sums encoding.
show opposite, consider constraint Sequence(X, q, l, u, = {1}) set
binary variables arbitrary size, arbitrary values q, l, u = |X| 1. Let
MDD defined X consisting two disjoint paths r t: arcs one path
label 0, arcs value 1. Since projection onto
variable domains gives x {0, 1} x X, domain consistency deduce
infeasibility. However, establishing MDD consistency respect cumulative
sums encoding detect this.

Even though formally MDD propagation based cumulative sums incomparable
domain propagation Sequence MDD propagation Among constraints,
next section show practice algorithm reduce search space
orders magnitude compared methods.

6. Computational Results
purpose computational results evaluate empirically strength partial MDD propagator described Section 5. perform three main comparisons. First,
want assess impact increasing maximum width MDD filtering.
Second, want compare MDD propagation classical domain propagation
Sequence. particular, wish evaluate computational overhead MDD
propagation relative domain propagation, extent MDD propagation
outperform domain propagation. Third, compare filtering strength MDD
propagator Sequence filtering strength MDD propagators individual Among constraints, best MDD approach Sequence far (Hoda et al.,
2010).
712

fiMDD Propagation Sequence Constraints

implemented MDD propagator Sequence custom global constraint
IBM ILOG CPLEX CP Optimizer 12.4, using C++ interface. Recall Section 5
applying rules (8) either maintain minimum maximum value q
previous ancestors descendants node, approximate maintaining
values simply layer. evaluated strategies found latter
reduce amount filtering, nonetheless resulted much efficient performance
(about twice fast average). Hence, reported results use implementation.
MDD propagator Among, apply code (Hoda et al., 2010).
domain propagation, applied three models. first uses domain consistent propagator Sequence van Hoeve et al. (2009), running O(n3 ) time. second uses
domain consistent propagator Sequence based network flow representation
Maher et al. (2008), runs O(n2 ) time.1 third model, applied decomposition cumulative sums, uses explicit global constraint Sequence.
Propagating decomposition takes O(n2 ) worst case, considers O(n) variables constraints variable domains contain n elements. note
almost test instances, cumulative sums encoding established domain consistency
Sequence. additional advantage, cumulative sums encoding permits
insightful comparison MDD propagator, since based cumulative
sums decomposition.
note Brand et al. (2007) introduce multiple-Sequence constraint
represents conjunction multiple Sequence constraints set ordered
variables (as experimental setup). Narodytska (2011) shows establishing bounds
consistency system already NP-hard, presents domain consistent propagator
encodes system automaton Regular constraint. algorithm runs
O(nmq ) time, n represents number variables, number Sequence
constraints, q length largest subsequence.
order compare algorithms multiple-Sequence constraint, conducted experiments identify suitable testbed. found instances
multiple-Sequence constraint would run memory could solved instantly
using domain propagator individual Sequence constraints, creating
data structures multiple-Sequence constraint took substantially time average. instances challenging (as described next sections),
multiple-Sequence constraint could applied due memory issues. therefore
excluded algorithm comparisons sections below.
single Sequence constraints solved polynomial time, consider
instances multiple Sequence constraints experiments. assume
defined ordered set variables. measure impact different
propagation methods correctly, approaches apply fixed search strategy, i.e.,
following given ordering variables, lexicographic value ordering heuristic.
method, measure number backtracks failed search state well
solving time. experiments performed using 2.33GHz Intel Xeon machine.
1. thank Nina Narodytska sharing implementation us.

713

fiBergman, Cire & van Hoeve

6.1 Systems Sequence Constraints
first consider systems multiple Sequence constraints defined set
variables. generate instances n = 50 variables domain {0, 1, . . . , 10},
5 Sequence constraints. Sequence constraint, set length subsequence uniform randomly [5, n/2)
q = (rand()%((n/2) 5)) + 5.
Here, rand() refers standard C++ random number generator, i.e., rand()%k selects
number range [0, k 1]. Without minimum length 5, many instances
would easy solve either method. next define difference l
u := (rand()%q), set
l := (rand()%(q )),
u := l + .
Lastly, define set values first defining cardinality (rand()%11) + 1,
selecting many values uniformly random {0, 1, . . . , 10}. generated 250
instances total.2
solve instance using domain consistency propagator Sequence,
cumulative sums encoding (domain propagation), MDD propagator maximum
widths 2, 4, 8, 16, 32, 64, 128. method given maximum time limit 1,800 seconds
per instance.
compare performance domain propagation MDD propagation Figure 4. figure, report given time point many instances could
solved within time specific method. three domain propagation methods
represented Cumulative Sums (the cumulative sums decomposition), Sequence - HPRS
(the Sequence propagator van Hoeve et al., 2006, 2009), Sequence - Flow (the
flow-based propagator Maher et al., 2008). Observe cumulative sums domain
propagation, although guaranteed establish domain consistency, outperforms
domain consistent Sequence propagators. Also, MDD propagation maximum width
2 already substantially outperform domain propagation. observe
larger maximum widths require time MDDs processed, end
allow solve instances: maximum MDD width 128 permits solve 250
instances within given time limit, whereas domain propagation respectively solve
220 (Sequence - Flow), 230 (Sequence - HPRS), 232 (Cumulative Sums) instances.
illustrate difference domain MDD propagation detail, Figure 5 presents scatter plots comparing domain propagation (cumulative sums) MDD
propagation (maximum width 32). comparison particularly meaningful
propagation methods rely cumulative sums representation. instance,
Figure 5.a depicts number backtracks Figure 5.b depicts solving time
methods. instances solved within time limit collected
(time out) method. Figure 5.a demonstrates MDD propagation lead
dramatic search tree reductions, several orders magnitude. Naturally, MDD
2. instances available http://www.andrew.cmu.edu/user/vanhoeve/mdd/.

714

fi200
150
100

MDD Width 128
MDD Width 32
MDD Width 2
Domain (Cumulative Sums)
Domain (Sequence HPRS)
Domain (Sequence Flow)

0

50

Number instances solved

250

MDD Propagation Sequence Constraints

102

101

100

101

102

103

Time(s)

Figure 4: Performance comparison domain MDD propagators Sequence
constraint. data point reflects total number instances solved
particular method within corresponding time limit.

propagation comes computational cost, Figure 5.b shows almost instances (especially harder ones), search tree reductions correspond faster solving
times, often several orders magnitude.
next evaluate impact increasing maximum widths MDD propagator.
Figure 6, present method survival function respect number
backtracks (a.) solving time (b.). Formally, applied combinatorial backtrack search algorithms, survival function represents probability run taking
x backtracks (Gomes, Fernandez, Selman, & Bessiere, 2005). case,
approximate function taking proportion instances need least x backtracks (Figure 6.a), respectively seconds (Figure 6.b). Observe log-log plots.
respect search tree size, Figure 6.a clearly shows strengthening MDD
propagation maximum width increased. particular, domain propagation
reflects linear behavior several orders magnitude typical heavy-tailed
runtime distributions. Naturally, similar behavior present MDD propagation,
much weaker form increasing maximum MDD widths. associated solving times
presented Figure 6.b. reflects similar behavior, takes account
initial computational overhead MDD propagation.
715

fi102
101
100
102

101

MDD Propagator (Width 32) Time (s)

106
104
102
100

MDD Propagator (Width 32) Backtracks



103

Bergman, Cire & van Hoeve

100

102

104

106

102



101

100

101

102

103

Domain Propagator (Cumulative Sums) Time (s)

Domain Propagator (Cumulative Sums) Backtracks

b. Solving time

a. Number backtracks

Figure 5: Comparing domain MDD propagation Sequence constraints. data
point reflects number backtracks (a.) resp. solving time seconds (b.)
specific instance, solved best domain propagator (cumulative
sums encoding) MDD propagator maximum width 32. Instances
either method needed 0 backtracks (a.) less 0.01 seconds (b.)
excluded. Here, stands timeout represents specific instance
could solved within 1,800s (Fig. b.). Figure a., instances
labeled separately (at tick-mark 108 ); note reported number
backtracks 1,800 seconds may much less 108 instances.
reported instances fewer 108 backtracks solved within time
limit.

6.2 Nurse Rostering Instances
next consider structured problem class inspired nurse rostering problems.
problem design work schedule nurse given horizon n days.
day, nurse either work day shift (D), evening shift (E), night shift (N),
day (O). introduce variable xi day = 1, . . . , n, domain
D(xi ) = {O, D, E, N } representing shift. impose eight Sequence constraints
modeling requirements listed Table 1.
combinatorial nature problem, size CP search tree turns
largely independent length time horizon, lexicographic search (by
increasing day i) applied. however consider instances various time horizons
(n = 40, 60, 80, 100), address potential scaling issues.
results presented Table 2. columns Domain Sequence show total
number backtracks (BT) solving time seconds (CPU) domain consistent
Sequence propagator. Similarly, columns Domain Cumul. Sums show infor716

fiMDD Propagation Sequence Constraints

1.0
0.5
0.1
0.05

Survival function

0.1

Domain Consistency
MDD Width 2
MDD Width 4
MDD Width 8
MDD Width 16
MDD Width 32
MDD Width 64
MDD Width 128

0.005 0.01

0.05
0.005 0.01

Survival function

0.5

1.0

Domain Consistency
MDD Width 2
MDD Width 4
MDD Width 8
MDD Width 16
MDD Width 32
MDD Width 64
MDD Width 128

100

101

102

103

104

105

106

107

102

Backtracks

101

100

101

102

103

Time (s)

a. Survival function respect backtracks

b. Survival function respect solving time

Figure 6: Evaluating impact increased width MDD propagation via survival function plots respect search backtracks (a.) solving time (b.). plots
log-log scale. data point reflects percentage instances require least many backtracks (a.) resp. seconds (b.) solved
particular method.

Requirement

Sequence(X, q, l, u, S)

least 20 work shifts every 28 days:
least 4 off-days every 14 days:
1 4 night shifts every 14 days:
4 8 evening shifts every 14 days:
Nights shifts cannot appear consecutive days:
2 4 evening/night shifts every 7 days:
6 work shifts every 7 days:

Sequence(X, 28, 20, 28, {D, E, N })
Sequence(X, 14, 4, 14, {O})
Sequence(X, 14, 1, 4, {N })
Sequence(X, 14, 4, 8, {E})
Sequence(X, 2, 0, 1, {N })
Sequence(X, 7, 2, 4, {E, N })
Sequence(X, 7, 0, 6, {D, E, N })

Table 1: Nurse rostering problem specification. Variable set X represents shifts
assigned sequence days. possible shifts day (D), evening (E),
night (N), day (O).

mation cumulative sums domain propagation. subsequent columns show
numbers MDD propagator, MDDs maximum width 1, 2, 4, 8. Note
propagating MDD width 1 corresponds domain propagation, indeed associated number backtracks equivalent domain propagator cumulative sums.
first observation, maximum width 2 already reduces number backtracks
factor 8.3. maximum width 8 MDD propagation even allows solve
717

fiBergman, Cire & van Hoeve

n
40
60
80
100

Domain
Sequence
BT
CPU
438,059 43.83
438,059 78.26
438,059 124.81
438,059 157.75

Domain
Cumul. Sums
BT
CPU
438,059
438,059
438,059
438,059

32.26
53.40
71.33
96.27

MDD
Width 1
BT
CPU
438,059 54.27
438,059 80.36
438,059 106.81
438,059 135.37

MDD
Width 2
BT
CPU
52,443
52,443
52,443
52,443

12.92
18.36
28.58
37.76

MDD
Width 4
BT CPU
439
439
439
439

0.44
0.68
0.94
1.22

MDD
Width 8
BT CPU
0
0
0
0

0.02
0.04
0.06
0.10

Table 2: Comparing domain propagation MDD propagation Sequence nurse
rostering instances. Here, n stands number variables, BT number
backtracks, CPU solving time seconds.

problem without search. computation times correspondingly reduced, e.g.,
157s (resp. 96s) domain propagators 0.10s MDD propagator (width 8)
instance n = 100. Lastly, observe case MDD propagation
suffer scaling issues compared domain propagation.
final remark, attempted solve nurse rostering instances using
Sequence domain propagator CP Optimizer (IloSequence). able solve
instance n = 40 1,150 seconds, none others instances solved within
time limit 1,800 seconds.
6.3 Comparing MDD Filtering Sequence Among
last experiment, compare Sequence MDD propagator MDD propagator Among constraints Hoda et al. (2010). main goal determine whether
large MDD sufficient solve problem (irrespective propagating Among
cumulative sums decomposition), whether additional information obtained
Sequence propagator makes difference.
apply methods, MDD propagation Sequence MDD propagation
Among, data set Section 6.1 containing 250 instances. time limit
1,800 seconds, run propagators maximum MDD widths 2, 8, 32, 128.
first compare performance MDD propagators Among Sequence
Figure 7. figure depicts number instances solved within given
time limit various methods. plot indicates Among propagators
much weaker Sequence propagator, moreover larger maximum widths
alone suffice: using Sequence propagator maximum width 2 outperforms
Among propagators maximum widths 128.
scatter plot Figure 8 compares MDD propagators Among Sequence
detail, widths 2, 8, 32, 128 (instances take 0 backtracks, resp. less
0.01 seconds, either method discarded Figure 8.a, resp. 8.b). smaller
widths, several instances Among propagator solve faster,
relative strength Sequence propagator increases larger widths. width
128, Sequence propagator achieve orders magnitude smaller search trees
718

fi200
150
100

Sequence Width 128
Sequence Width 32
Sequence Width 8
Sequence Width 2
Among Width 128
Among Width 32
Among Width 8
Among Width 2

0

50

Number instances solved

250

MDD Propagation Sequence Constraints

102

101

100

101

102

103

Time(s)

103
102
101
100
101

Sequence MDD Propagator Time (s)

Width 2
Width 8
Width 32
Width 128

102

102

104

106

Width 2
Width 8
Width 32
Width 128

100

Sequence MDD Propagator Backtracks



Figure 7: Performance comparison MDD propagation Sequence Among
various maximum widths. data point reflects total number instances
solved particular method within corresponding time limit.

100

102

104

106

102



101

100

101

102

103

Among MDD Propagator Time (s)

Among MDD Propagator Backtracks

b. Solving time

a. Number backtracks

Figure 8: Evaluating MDD propagation Sequence Among various maximum
widths via scatter plots respect search backtracks (a.) solving time
(b.). plots log-log scale follow format Figure 5.

719

fiBergman, Cire & van Hoeve

solving time Among propagators, demonstrates advantage
MDD propagation Sequence compared Among decomposition.

7. Conclusion
Constraint propagation limited-width MDDs recently shown powerful
alternative conventional propagation variable domains constraint programming.
work, studied MDD propagation Sequence constraint, appears in, e.g., rostering scheduling applications. first proved establishing
MDD consistency Sequence NP-hard. However, shown task
fixed parameter tractable respect length sub-sequences defined
constraint, provided MDD follows variable ordering specified constraint.
proposed practical MDD propagation algorithm Sequence polynomial length sub-sequences, based cumulative decomposition.
provided extensive experimental results comparing MDD propagator Sequence
domain propagators Sequence well existing MDD propagator Among.
computational experiments shown MDD propagator Sequence
outperform domain propagators orders magnitude terms search tree size
solving time. Similar results obtained compared existing MDD propagator Among, demonstrates practice large MDD alone sufficient
solve problems; specific MDD propagators global constraints Sequence
lead orders magnitude speedups.

Acknowledgments
material based upon work supported National Science Foundation
Grant No. CMMI-1130012, Google Research Award. thank reviewers
whose comments helped improve paper.

References
Andersen, H. R., Hadzic, T., Hooker, J. N., & Tiedemann, P. (2007). Constraint Store
Based Multivalued Decision Diagrams. Proceedings CP, Vol. 4741 LNCS,
pp. 118132. Springer.
Apt, K. R. (2003). Principles Constraint Programming. Cambridge University Press.
Beldiceanu, N., & Contejean, E. (1994). Introducing global constraints CHIP. Journal
Mathematical Computer Modelling, 20 (12), 97123.
Brand, S., Narodytska, N., Quimper, C., Stuckey, P., & Walsh, T. (2007). Encodings
Sequence Constraint. Proceedings CP, Vol. 4741 LNCS, pp. 210224. Springer.
Cheng, K., & Yap, R. (2008). Maintaining Generalized Arc Consistency Ad Hoc r-Ary
Constraints. Proceedings CP, Vol. 5202 LNCS, pp. 509523. Springer.
Cire, A. A., & van Hoeve, W.-J. (2012). MDD Propagation Disjunctive Scheduling.
Proceedings ICAPS, pp. 1119. AAAI Press.
720

fiMDD Propagation Sequence Constraints

Cire, A. A., & van Hoeve, W.-J. (2013). Multivalued Decision Diagrams Sequencing
Problems. Operations Research, 61 (6), 14111428.
Dechter, R. (2003). Constraint Processing. Morgan Kaufmann.
Downing, N., Feydy, T., & Stuckey, P. (2012). Explaining Flow-Based Propagation.
Proceedings CPAIOR, Vol. 7298 LNCS, pp. 146162. Springer.
Garey, M., & Johnson, D. (1979). Computers Intractability - Guide Theory
NP-Completeness. Freeman.
Gomes, C. P., Fernandez, C., Selman, B., & Bessiere, C. (2005). Statistical Regimes Across
Constrainedness Regions. Constraints, 10 (4), 317337.
Hadzic, T., Hooker, J. N., OSullivan, B., & Tiedemann, P. (2008a). Approximate Compilation Constraints Multivalued Decision Diagrams. Proceedings CP, Vol.
5202 LNCS, pp. 448462. Springer.
Hadzic, T., Hooker, J. N., & Tiedemann, P. (2008b). Propagating Separable Equalities
MDD Store. Proceedings CPAIOR, Vol. 5015 LNCS, pp. 318322. Springer.
Hadzic, T., OMahony, E., OSullivan, B., & Sellmann, M. (2009). Enhanced Inference
Market Split Problem. Proceedings ICTAI, pp. 716723. IEEE.
Hawkins, P., Lagoon, V., & Stuckey, P. (2005). Solving Set Constraint Satisfaction Problems
Using ROBDDs. JAIR, 24 (1), 109156.
Hoda, S., van Hoeve, W.-J., & Hooker, J. N. (2010). Systematic Approach MDD-Based
Constraint Programming. Proceedings CP, Vol. 6308 LNCS, pp. 266280.
Springer.
Hosaka, K., Takenaga, Y., Kaneda, T., & Yajima, S. (1997). Size ordered binary decision
diagrams representing threshold functions. Theoretical Computer Science, 180, 4760.
Knuth, D. E. (2009). Art Computer Programming, Volume 4, Fascicle 1: Bitwise
Tricks & Techniques; Binary Decision Diagrams. Addison-Wesley Professional.
Maher, M., Narodytska, N., Quimper, C.-G., & Walsh, T. (2008). Flow-Based Propagators
SEQUENCE Related Global Constraints. Proceedings CP, Vol. 5202
LNCS, pp. 159174. Springer.
Narodytska, N. (2011). Reformulation Global Constraints. Ph.D. thesis, University
New South Wales.
Regin, J.-C. (1994). Filtering Algorithm Constraints Difference CSPs.
Proceedings AAAI, Vol. 1, pp. 362367. AAAI Press.
Regin, J.-C. (2011). Global Constraints: Survey. Van Hentenryck, P., & Milano, M.
(Eds.), Hybrid Optimization, pp. 63134. Springer.
Regin, J.-C., & Puget, J.-F. (1997). Filtering Algorithm Global Sequencing Constraints. Proceedings CP, Vol. 1330 LNCS, pp. 3246. Springer.
Rossi, F., van Beek, P., & Walsh, T. (Eds.). (2006). Handbook Constraint Programming.
Elsevier.
van Hoeve, W.-J., & Katriel, I. (2006). Global Constraints. Rossi, F. van Beek, P., &
Walsh, T. (Eds.), Handbook Constraint Programming, chap. 6. Elsevier.
721

fiBergman, Cire & van Hoeve

van Hoeve, W.-J., Pesant, G., Rousseau, L.-M., & Sabharwal, A. (2006). Revisiting
Sequence Constraint. Proceedings CP, Vol. 4204 LNCS, pp. 620634. Springer.
van Hoeve, W.-J., Pesant, G., Rousseau, L.-M., & Sabharwal, A. (2009). New Filtering
Algorithms Combinations Among Constraints. Constraints, 14, 273292.
Wegener, I. (2000). Branching Programs Binary Decision Diagrams: Theory Applications. SIAM monographs discrete mathematics applications. Society
Industrial Applied Mathematics.

722


