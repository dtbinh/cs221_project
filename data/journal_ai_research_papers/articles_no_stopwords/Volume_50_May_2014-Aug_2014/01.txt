Journal Artificial Intelligence Research 50 (2014) 31-70

Submitted 08/13; published 05/14

Knowledge Forgetting Answer Set Programming
Yisong Wang

CSC . YSWANG @ GZU . EDU . CN

Department Computer Science,
Guizhou University, Guiyang, China

Yan Zhang
Yi Zhou

YAN @ SCEM . UWS . EDU . AU
YZHOU @ SCEM . UWS . EDU . AU

Artificial Intelligence Research Group,
University Western Sydney, Australia

Mingyi Zhang

ZHANGMINGYI 045@ GMAIL . COM

Guizhou Academy Sciences, Guiyang, China

Abstract
ability discarding hiding irrelevant information recognized important
feature knowledge based systems, including answer set programming. notion strong
equivalence answer set programming plays important role different problems gives
rise substitution principle amounts knowledge equivalence logic programs.
paper, uniformly propose semantic knowledge forgetting, called HT- FLP-forgetting,
logic programs stable model FLP-stable model semantics, respectively. proposed
knowledge forgetting discards exactly knowledge logic program relevant forgotten variables. Thus preserves strong equivalence sense strongly equivalent logic
programs remain strongly equivalent forgetting variables. show
semantic forgetting result always expressible; prove representation theorem stating
HT- FLP-forgetting precisely characterized Zhang-Zhous four forgetting postulates HT- FLP-model semantics, respectively. reveal underlying connections
proposed forgetting forgetting propositional logic, provide complexity
results decision problems relation forgetting. application proposed forgetting
considered conflict solving scenario.

1. Introduction
Motivated Lin Reiters seminal work (Lin & Reiter, 1994), notion forgetting propositional first-order logics distilling knowledge base part relevant
subset alphabet attracted extensive interests KR community, (e.g., see Lang
& Marquis, 2010; Zhou & Zhang, 2011). recent years, researchers developed forgetting
notions theories non-classical logic systems various perspectives, forgetting description logics (Kontchakov, Wolter, & Zakharyaschev, 2008; Wang, Wang, Topor, &
Pan, 2010; Lutz & Wolter, 2011; Packer, Gibbins, & Jennings, 2011), forgetting logic programs
(Zhang & Foo, 2006; Eiter & Wang, 2008; Wong, 2009; Wang, Wang, & Zhang, 2013), forgetting modal logic (Zhang & Zhou, 2009; Su, Sattar, Lv, & Zhang, 2009; van Ditmarsch, Herzig,
Lang, & Marquis, 2009; Liu & Wen, 2011). logical notion, forgetting studied
different terms variable elimination (Lang, Liberatore, & Marquis, 2003), irrelevance, independence, irredundancy, novelty, separability (Bobrow, Subramanian, Greiner, &
c
2014
AI Access Foundation. rights reserved.

fiWANG , Z HANG , Z HOU , & Z HANG

Pearl, 1997). shown study modeling agents behaviors, forgetting plays
important role conflict resolution (Zhang & Foo, 2006; Lang & Marquis, 2010).
propositional logic, result forgetting atom p formula , written Forget(, {p}),
formula [p/] [p/>], [p/] [p/>] formula obtained replacing occurrence atom p (false) > (true) respectively. Forgetting set atoms
formula defined Forget(, V {p}) = Forget(Forget(, {p}), V ) (Lin, 2001).
easy see forgetting preserves logical equivalence. is, logically equivalent formulas
(theories) remain logically equivalent forgetting atoms. well known that,
mention atoms V
|= iff Forget(, V ) |= .
sense forgetting propositional logic, called propositional forgetting, knowledge
forgetting since Forget(, V ) exactly contains logical content irrelevant V .
logic programs stable model/answer set semantics (Gelfond & Lifschitz, 1988), issue logical equivalence rather complicated due different notions equivalence: (weak)
equivalence strong equivalence. Two logic programs 1 2 (weakly) equivalent
1 2 stable models; 1 2 strongly equivalent
1 2 equivalent every logic program . well known strong equivalence important concept answer set programming (ASP), amounts knowledge
equivalence captures logical content logic program (Osorio & Zacarias, 2004; Osorio
& Cuevas, 2007; Delgrande, Schaub, Tompits, & Woltran, 2013), used simplifying
logic programs two strongly equivalent rules may interchangeable without affecting
original logic programs stable models (Pearce, Tompits, & Woltran, 2001; Ferraris, Lee, & Lifschitz, 2011; Lin & Chen, 2007; Lin & Zhou, 2011). strong equivalence characterized
logic here-and-there (HT), viz, two logic programs strongly equivalent
HT-models (Lifschitz, Pearce, & Valverde, 2001). instance, rule following form p p HT-models > (tautology), arbitrary
formula. Thus safely removed every logic programs without changing stable
models.
Besides stable model/answer set semantics logic programs (Gelfond & Lifschitz, 1988),
FLP-stable model semantics steadily gains importance (Faber, Pfeifer, & Leone, 2011;
Truszczynski, 2010). notion strong equivalence similarly generalized logic programs
FLP-stable models semantics: two theories 1 2 strongly FLP-equivalent
1 2 FLP-stable models every logic program . shown
strong equivalence characterized terms FLP-models, viz, two logic programs
strongly FLP-equivalent FLP-models (Truszczynski, 2010).
develop notion forgetting logic programs, preserving strong equivalence
important, propositional forgetting preserves equivalence propositional logic. Consider two agents need achieve agreement certain goal, agents knowledge
base represented logic program. Suppose two consistent1 logic programs,
combination inconsistent. achieve consistent combination, one may forget atoms
logic programs, combination forgetting results consistent.
forgetting may effectively used solve conflict two agents knowledge
1. logic program consistent stable models.

32

fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

bases (Zhang & Foo, 2006; Eiter & Wang, 2008; Lang & Marquis, 2010). purpose simplicity, hand, agents may replace knowledge bases strongly equivalent
syntactically simpler ones.
Let us consider simple Yale Shooting scenario logic program consisting
following rules:2
shoot aux;

aux shoot;

aux, shoot.

aux used generate possible occurrences action shoot. One interested
logic program represents knowledge auxiliary atom aux ignored.
intuitively results logic program 0 consisting rule3 :
shoot shoot,
captures exactly knowledge irrelevant aux. see 0
obtained HT-forgetting aux (cf. Example 5 atom names), cannot
obtained terms previous forgetting approaches logic programming (cf. Example 11).
turns preserving strong equivalence forgetting challenging.
several attempts define notion forgetting logic programs, none approaches
fully satisfactory. Zhang Foo (2006) first defined syntax oriented weak strong forgetting
notions normal logic programs. forgetting notions preserve neither (weak) equivalence
strong equivalence. Eiter Wang (2008) proposed semantic forgetting consistent
disjunctive logic programs, preserves equivalence strong equivalence. specifically indicated importance preserving strong equivalence logic programming forgetting
raised issue future work. Wong (2009) proposed two forgetting operators disjunctive logic programs. Although two operators indeed preserve strong equivalence, may lose
intuition weakening various circumstances (see Section 5 details). recently proposed
forgetting logic programs may introduce extra knowledge (cf., see Wang et al., 2013, Ex. 2).
Thus knowledge forgetting.
Together preserving strong equivalence, expressiveness another desired criterion
logic programming forgetting. Ideally would expect result forgetting atoms
logic program still expressible logic program. particularly necessary
view agents knowledge bases logic programs forgetting employed means conflict
solving among agents knowledge bases (Zhang & Foo, 2006). previous logic programming forgetting approaches meet criterion, see paper, consider
forgetting arbitrary logic programs, retaining expressibility challenging objective achieve
semantic forgetting notion.
Finally, believe way weakening, knowledge forgetting logic programs
obey common intuitions shared forgetting classical logics. instance, forgetting
something logic program lead weaker program certain sense.
hand, weakening associated relevant information forgotten.
purpose, Zhang Zhou (2009) proposed four forgetting postulates formalize
common intuitions showed forgetting propositional logic modal logic S5
precisely captured postulates. Surprisingly, none previous forgetting notions logic
2. due one anonymous reviewers.
3. rule strongly equivalent choice rule 0{shoot}1 normal rule.

33

fiWANG , Z HANG , Z HOU , & Z HANG

programs actually satisfies Zhang-Zhous postulates. sense previous forgetting notions
logic programs knowledge forgetting operators.
summary, consider following criteria knowledge forgetting notion logic programs meet:
Expressibility. result forgetting arbitrary logic program expressible via logic program;
Preserving strong equivalence. Two strongly equivalent logic programs remain strongly
equivalent forgetting variables;
Satisfying common intuitions forgetting. Preferably, forgetting logic programs
semantically characterized Zhang-Zhous four forgetting postulates.
paper present comprehensive study knowledge forgetting context arbitrary logic programs (propositional theories) stable model FLP-stable models semantics,
called HT- FLP-forgetting respectively. show HT- FLP-forgetting meet
criteria, hence primary advantages compared previous logic program forgetting
notions.
main contributions paper may summarized follows, ? {HT, FLP },
- starting point, investigate model theoretical characterization strong equivalence logic programs stable model FLP-stable model semantics, explore
strong equivalence equivalence propositional logic.
- propose semantic ?-forgetting logic programs ?-stable model semantics respectively. HT-stable model means stable model. ?-forgetting result always
expressible via logic program preserves strong equivalence stable model
FLP-stable model semantics.
- investigate semantic properties ?-forgetting, show ?-forgetting satisfies
Zhang-Zhous four postulates ?-model respectively. particular, forgetting
result consists logical content irrelevant forgotten atoms.
- establish underlying connections ?-forgetting propositional forgetting,
based provide complexity results decision problems relation ?forgetting. particular, show resulting checking deciding logic program
result ?-forgetting set atoms logic program P2 -complete, related
inference problem terms ?-forgetting varies co-NP-complete P2 -complete.
theoretical negative results confirm easy task simplify logic programs
forgetting. fortunately, kind simplification computed offline general.
instance, problem domain description involves lot auxiliary propositional variables.
One firstly simplify description forgetting (part of) auxiliary propositional
variables, kind compilation (Lang et al., 2003).
- Finally consider application knowledge forgetting solving conflicts
context logic programming.
34

fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

rest paper organized follows. Section 2 briefly reviews necessary concepts
notions answer set programming. Section 3 presents characterizations strong equivalence
logic programs. firstly present uniform definition knowledge forgetting logic
programs section 4, explore expressibility, forgetting postulates, relationship
propositional forgetting, computational complexity application knowledge forgetting
conflict solving. Section 5 discusses forgetting approaches logic programs, finally,
Section 6 concludes paper remarks. proofs paper deferred
Appendix clarity.
paper revised extended version paper appeared Proceedings KR
2012 (Wang, Zhang, Zhou, & Zhang, 2012).

2. Answer Set Programming
section briefly recall basic notions logic programming stable model semantics, including syntax, reduction, stable model (Ferraris, 2005) FLP-stable models (Truszczynski, 2010) strong equivalence (Lifschitz et al., 2001; Truszczynski, 2010). paper stable
model called HT-stable model convenience, assume ? {HT , FLP }.
assume propositional language LA finite set propositional atoms,
called signature language LA .
2.1 Syntax
formulas LA built signature4 0-place connective (false) using
binary connectives , follows:
::= | p | | |

(1)

p A. > (true) shorthand , , ( ) (
). theory set formulas.
interpretation set atoms A, atom viewed true
I, false otherwise. propositional logic, notions model satisfaction relation |=
defined usual. following denote \ X X X A, Mod() {M |M |= },
/ M}
Mod() = Mod() (i.e. equivalent ) {I A|I

2 . formula irrelevant set V atoms, written IR(, V ), exists formula
mentioning atoms V .
convenience,

W
V define following notations. Let finite set formulas.
W
denote SV(resp.
S) disjunction (resp. conjunction) formulas S,
denotes denotes >, |S| cardinality S. Similarly (resp. S) mean
{ | S} (resp. { | S}).
2.2 Reduct Stable Models
Let formula X A. ?-reduct w.r.t. X, written Red? (, X), recursively
uniformly defined follows:
4. rest paper, whenever confusion, may explicitly mention signature talk
formulas LA .

35

fiWANG , Z HANG , Z HOU , & Z HANG

(?-R1) Red? (, X) = ;
(?-R2) Red? (p, X) = p X |= p, otherwise;
(?-R3) Red? (1 2 , X) = Red? (1 , X) Red? (2 , X) X |= 1 2 {, },
otherwise;
(HT-R4) RedHT (1 2 , X) = RedHT (1 , X) RedHT (2 , X) X |= 1 2 , otherwise;

1 RedFLP (2 , X), X |= 1 2 ;
(FLP-R4) RedFLP (1 2 , X) =
>,
X 6|= 1 ;

,
otherwise (i.e. X 6|= 1 2 ).

Definition 1 set X ?-stable model formula X minimal (under set inclusion)
model Red? (, X). denote set ?-stable models SM ? ().
Please note that, traditionally, HT-reduct named reduct; Red HT (, X) written X ;
HT-stable model called stable model (Ferraris, 2005); RedFLP (, X) written X
(Truszczynski, 2010).
known that, HT-stable models FLP-stable models comparable sense
HT-stable models FLP-stable models, FLP-stable models HT-stable
models (cf., see Truszczynski, 2010, Exs. 1, 2, 4 5).
Example 1 Let us consider following formulas:
Let = p p p.
RedHT (, ) , RedHT (, {p}) >, RedFLP (, ) , RedHT (, {p}) p.
Thus SM HT () = , SM FLP () = {{p}}.
Let 1 = p p 2 = p p. following:
RedHT (i , ) > RedHT (i , {p}) p, = 1, 2,
RedFLP (1 , ) >, Red FLP (1 , {p}) p, RedFLP (2 , ) >, RedFLP (2 , {p}) >.
Thus, SM FLP (1 ) =

SM HT (1 )

= {, {p}}, SM FLP (2 ) = {}.

Definition 2 Two formulas 1 2 ?-SM -equivalent (under ?-stable model semantics), written 1 ?SM 2 , iff ?-stable models.
notion HT-SM -equivalence indeed notion equivalence logic programs
stable model semantics (cf., see Lifschitz et al., 2001, Thm. 1).
36

fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

2.3 Strong Equivalence Knowledge Logic Programs
Unlike equivalence propositional logic, equivalence logic programs allow
equivalent replacement i.e., 1 2 may different stable models, even though 1
2 equivalent.
Example 2 Let 1 = p q 2 = p p. SM ? (1 ) = SM ? (2 ) = {}, 1 2
?-SM-equivalent; however, p 1 ?-stable model {p, q} unique ?-stable model
p 2 {p}. Thus allow replacing 1 2 p 1 . indicates 1
different knowledge 2 ?-stable model semantics.
motivates notion strong equivalence.
Definition 3 Two formulas 1 2 strongly ?-equivalent (under ?-stable model semantics)
iff 1 ?SM 2 every formula . case 1 2 strongly ?-equivalent,
?-knowledge equivalent.
known notion strong ?-equivalence captured terms ?-models,
?-interpretation pair hX, X A. ?-satisfiability (thus ?-models),
denoted |=? , recursively defined follows:
(?-S1) hX, 6|=? ;
(?-S2) hX, |=? p p X;
(?-S3) hX, |=? 1 2 hX, |=? 1 hX, |=? 2 ;
(?-S4) hX, |=? 1 2 hX, |=? 1 hX, |=? 2 ;
(HT-S5) hX, |=HT 1 2 |= 1 2 ; hX, |=HT 1 implies hX, |=HT 2 ;
(FLP-S5) hX, |=FLP 1 2 |= 1 2 ; 6|= 1 X 6|= 1 hX, |=FLP 2 .
Mod? () denote set ?-models formula . Please note that, ?
either HT FLP . particular, ModHT () (resp. ModFLP ()) denotes set HT-models (resp.
FLP-models) . formulas 1 2 Example 2, one check none h, {p}i,
h{p}, {p}i h{p}, {p, q}i ?-model 1 , every ?-interpretation ?-model 2 .
Definition 4 formula logical ?-consequence formula , written |=? , iff Mod? ()
Mod? (); two formulas ?-equivalent (under ?-model semantics), written ? , iff
Mod? () = Mod? ().
following proposition, item (i) proved Lifschitz, Tang, Turner (cf., see Lifschitz
et al., 1999, (iii) Prop. 6).
Proposition 1 Let A, B, C, set atoms. following
V
W
V
W
(i) (A B) (D C) HT (A B C) D.
V
W
V
W
(ii) (A B) (D C) |=FLP (A B C) D.
37

fiWANG , Z HANG , Z HOU , & Z HANG

Please note inverse (ii) generally hold. instance, p p FLP >
h, {p}i 6|=FLP p p.
Given two formulas 1 2 , known 1 2 strongly HT-equivalent
HT -stable model semantics HT -equivalent, viz. 1 HT 2 ; 1 2
strongly FLP -equivalent FLP -stable model semantics FLP -equivalent,
viz. 1 FLP 2 (cf., see Truszczynski, 2010, Thm. 7). commonly recognized strong
equivalence amounts knowledge equivalence formulas. is, strong ?-equivalence captures
logical content formula ?-stable model semantics (Osorio & Zacarias, 2004; Osorio
& Cuevas, 2007; Delgrande et al., 2013). formally define knowledge logic programs.
Definition 5 ?-knowledge formula ?-stable model semantics, written Cn? (),
consists logical ?-consequence , viz, Cn? () = { | |=? }.
?-knowledge formula stands ?-logical content formula. instance,
CnHT (>) = CnHT (p p) CnHT (p q).
Recall that, ?-model semantics, every formula transformed conjunction
formulas following normal form:
^
_
(B C) (A D)
(2)
A, B, C, sets atoms (cf., ? = HT, see Cabalar & Ferraris, 2007, Thm. 2;
Truszczynski, 2010, Thm. 9 ? = FLP ). is, every formula , conjunction
formulas form (2) strongly ?-equivalent .
formula form (2) called rule, generally written
a1 ; . . . ; al ; d1 ; . . . ; dn b1 , . . . , bk , c1 , . . . , cm

(3)

= {ai |1 l}, B = {bi |1 k}, C = {ci |1 m} = {di |1 n}.
logic program finite set rules. Let r rule form (2). said
disjunctive = ;
positive C = = ;
normal |A| 1 = ;
Horn |A| 1 C = = .
logic program disjunctive (resp. positive, normal, Horn) iff consists disjunctive
(resp. positive, normal, Horn) rules. logic program ?-consistent (under ?-stable model semantics) least one ?-stable model.
known every logic program HT-models FLP-models (cf., see Truszczynski, 2010, Prop. 8).
Proposition 2 Every logic program HT-

FLP-models.

3. Characterizations Knowledge Equivalence
section, perspective ?-models, consider characterization knowledge
equivalence various logic programs firstly, relate knowledge equivalence equivalence propositional logic secondly.
38

fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

3.1 Model Theoretical Characterization
firstly recall basic properties ?-satisfiability (Ferraris & Lifschitz, 2005; Ferraris,
2005; Truszczynski, 2010).
Proposition 3 Let formula X A.
(i) hX, |=? hY, |=? (i.e., |= ).
(ii) hX, |=? iff |= .
(iii) hX, |=? iff X |= Red? (, ).
collection ?-interpretations ?-expressible whenever exists formula
Mod? () = M. collection ?-interpretations may ?-expressible. instance,
formula whose ?-models ones = {h, {p}i}. reason
formula Mod? () = h{p}, {p}i |=? (i) Proposition 3.
requires h{p}, {p}i belonging Mod? (), contradiction.
Given formula X A, hX, ?-countermodel hX, 6|=?
hY, |=? ; hY, ?-countermodel hY, 6|=? . Let X A, define
following formulas:
_
(X ) ((Y \ X) (Y \ X)),
_
^
FLP (X, ) = (X ) (X ),
^
(Y, ) = (Y ) ,
_
^
(X, ) = (X ) (Y \ X).
HT (X, ) =

^

(4)
(5)
(6)
(7)

? (X, ) (Y, ) capture ?-countermodel hX, hY, respectively.
following lemma shows ?-countermodel captured formula (cf.,
? = HT, see Cabalar & Ferraris, 2007, Prop. 1; Truszczynski, 2010, Props. 5 6 ? = FLP ).
Lemma 1 Let X U V A.
(i) hU, V ?-countermodel ? (X, ) iff U = X V = .
(ii) hU, V ?-countermodel (Y, ) iff V = .
Proposition 4 collection ?-interpretations ?-expressible iff
hX, implies hY, M.
Actually, satisfy condition (8) following logic program
? = {? (X, )|hX,
/ hY, M} {(Y, )|hY,
/ M}
captures sense Mod? (? ) = M.
39

(8)

fiWANG , Z HANG , Z HOU , & Z HANG

Note Wong (2009) presented model-theoretical characterization HT-models
disjunctive logic programs (cf., see Wong, 2009, Thm. 2.7). Formally speaking, collection
HT-interpretations disjunctively HT-expressible, i.e., disjunctive logic program
ModHT () = M, iff condition (8) following one hold:
hX, M, 0 hY 0 , 0 hX, 0 M.

(9)

Together Proposition 2,
Corollary 1 collection
tions (8) (9) hold.

FLP -interpretations

disjunctively

FLP -expressible

iff condi-

Actually, satisfies conditions (8) (9) following disjunctive logic program
captures M.
= {(X, )|hX,
/ hY, M} {(Y, )|hY,
/ M}.
Lemma
V
W2 Let A, B beVtwo sets
W atoms, X A. hX, |=?
B |= B A.

V

B

W

iff X |=

Proposition 5 set ?-interpretations positively ?-expressible, i.e., positive logic
program s.t Mod? () = M, iff satisfies criteria:
hX, iff X Y, hX, Xi hY, M.

(10)


Va matter
W fact, case satisfies condition (10), positive logic program =
/ M} captures M.
{ X X|hX, Xi

Corollary 2 Two positive logic programs strongly ?-equivalent equivalent
propositional logic.

Eiter, Fink, Tompits, Woltran (2004) showed disjunctive logic program
strongly equivalent normal logic program closed here-intersection, i.e.,
every pair HT-models hX, hX 0 , , hX X 0 , HT-model (cf.,
see Eiter et al., 2004, Thms. 1 2). terms characterization disjunctive logic programs
Proposition 2, obtain ?-model characterization normal logic programs follows.
Corollary 3 set ?-interpretations normally ?-expressible, i.e., normal logic
program Mod? () = M, iff satisfies, addition (8) (9), following
criteria:
hX, hX 0 , hX X 0 , M.
(11)
Proposition 6 collection ?-interpretations Horn ?-expressible, i.e., Horn logic
program Mod? () = M, iff satisfies, addition (10), following criteria:
hX, hH, hX H, M.
40

(12)

fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

3.2 Relating Knowledge Equivalence Propositional Logic
proved strong equivalence logic programs stable model semantics related
equivalence propositional logic (Pearce et al., 2001; Lin, 2002). holds strong
FLP-equivalence logic programs show following.
Firstly, extend language LA LAA0 A0 = {p0 |p A} p0 fresh atoms.
expression LA , 0 denote result obtained replacing atom p
corresponding atom p0 A0 . following denote
(A) = {p p0 | p A}.

(13)

Please note that, model (A), splitting MA0 =
MA0 = A0 and, every p , atom p0 A0 belongs MA0 . A0
denote set {p A|p0 }.
Definition 6 HT [.] FLP [.] recursively defined follows:
(T1) ? [] = ;
(T2) ? [p] = p;
(T3) ? [1 2 ] = ? [1 ] ? [2 ] {, };
(HT-T4) HT [1 2 ] = (01 02 ) (HT [1 ] HT [2 ]);
(FLP-T4) FLP [1 2 ] = (01 02 ) (1 01 FLP [2 ]).
Please note translation HT translation defined Pearce, Tompits,
Woltran (2001). One verify HT [] = 0 HT [], FLP [] = 0 . Given
theory LA , define ? [] = {? [] | }. evident ? [] linear size .
Example 3 Let = p p p.
HT [] = ((p0 p0 ) p0 ) ((p p p0 ) p) p0 ,
FLP [] = ((p0 p0 ) p0 ) ((p p) (p0 p0 ) p) p0 p.
unique FLP-model (over signature {p}) h{p}, {p}i. However, two HT-models
h, {p}i h{p}, {p}i. signature {p, p0 }, one easily check {HT []} (A)
two models {p, p0 } {p0 }, {FLP []} (A) unique model {p, p0 }.
V
W
Proposition 7 Let = (B C) (A D), A, B, C, subsets A.
(A) |= FLP [] HT [].
following proposition connects ?-equivalence equivalence classical propositional logic (cf., ? = HT, see Pearce et al., 2001, Lem. 2).
Proposition 8 Let formula LA X A. hX, ?-model iff
X 0 model (A) {? []}.
41

fiWANG , Z HANG , Z HOU , & Z HANG

following theorem shows strong ?-equivalence logic programs ?-stable
model semantics reduced equivalence propositional logic (cf., ? = HT, see
Ferraris et al., 2011, Thm. 9; Lin & Zhou, 2011, (5) Thm. 6).
Theorem 4 Two formulas ?-models (over A) iff (A){? []} (A)
{? []} models (over A0 ).
Based theorem, obtain following complexity result (cf., ? =
Tompits, & Woltran, 2009, Thms. 8 11).

HT ,

see Pearce,

Proposition 9 (i) problem deciding formula ?-satisfiable NP-complete.
(ii) problem deciding two formulas ?-equivalent co-NP-complete.

4. Knowledge Forgetting Logic Programs
mentioned introduction, concentrate knowledge forgetting logic programs
stable model semantics. formally stated following:
Definition 7 (Knowledge forgetting) Let logic program V A. logic program
result ?-knowledge forgetting V , consists ?-knowledge
mentions atom V .
show knowledge forgetting result always exists unique strong
equivalence (cf. Theorem 6) semantic ?-forgetting defined explored.
Let V, X, sets atoms. set V -bisimilar X, written V X, \V = X \V .
intuitively states interpretations X agree atoms V .
Two ?-interpretations hH, hX, V -bisimilar, written hH, V hX, i, H V X
V . Now, position define semantic knowledge forgetting terms
bisimulation.
Definition 8 (Semantic knowledge forgetting) Let formula V A. formula
result (semantic) ?-forgetting V whenever, every ?-interpretation ,
Mod? () iff 0 Mod? () s.t V 0 .

(14)

According definition, one see ?-models somehow exactly constructed
. motivates us define following notion extension.
Let V, X, sets atoms. V -extension X, denoted XV , collection
interpretations V -bisimilar X. V -extension ?-interpretation hH, i, denoted
hH, iV , collection ?-interpretations V -similar hH, i. instance, let
hH, = h{p, q}, {p, q}i V = {q, r}. hH, iV contains h{p}, {p}i, h{p}, {p, q}i,
h{p}, {p, q, r}i, h{p, q, r}, {p, q, r}i on. Intuitively speaking, V -extension interpretation collection interpretations formed freely adding removing
atoms
Sin V . V -extension collection (?-)interpretations, written MV , collection V .
classical propositional logic corresponds formula , i.e. = Mod(), MV
corresponds formula whose truth value nothing atoms V . intended
meaning case ?-models similar MV corresponds formula ?-model
42

fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

semantics relevant atoms V . words, suppose MV = Mod? ().
hX, |=? hH, |=? H (resp. ) obtained X (resp. ) freely
adding removing atoms V whenever H . following lemma shows equivalent
condition semantic ?-knowledge forgetting.
Lemma 3 Let formula V A. formula result ?-forgetting V , iff
following condition holds:
Mod? () = Mod? ()V .
(15)
condition ?-forgetting generalization forgetting propositional logic (Lin &
Reiter, 1994) terms following corollary.
Corollary 5 formula result forgetting set V atoms formula iff Mod() =
Mod()V , Mod(.) refers classical propositional logic.
syntactic counterpart forgetting propositional logic defined follows (Lin, 2001;
Lang et al., 2003):
Forget(, {p}) = [p/] [p/>],
Forget(, V {p}) = Forget(Forget(, {p}), V )
[p/>] (resp. [p/]) formula obtained replacing every occurrence
atom p > (resp. ).
?-interpretations related given signature A, follows, shall assume
signature formula/theory implicitly given atoms occurring formula/theory,
unless explicitly stated otherwise. example illustrates ?-forgetting results
computed.
Example 4 Let following formula
(p q) (q p) (p ) (q ).
signature {p, q}, Mod? () = {h, {p, q}i, h{p, q}, {p, q}i}. Please note
? either HT FLP. Definition 8, verify Mod? (){p} =
{h, {q}i, h{q}, {q}i}{p} . corresponds formula = (p q ) (p q)
?-model semantics Proposition 4. matter fact, ? q ? q.
Note Forget(, {p}) = [p/>] [p/] q q 6? q. shows that, unlike
syntactic counterpart forgetting classical propositional logic, ?-forgetting results cannot
computed via [p/>] [p/] Mod? (q) = {h, {q}i, h{q}, {q}i}, Mod? (q) =
{h{q}, {q}i} (over signature {q}).

4.1 Expressibility
Please note Definition 8 guarantee existence forgetting results, however
next theorem shows ?-forgetting result always exists. implies ?-forgetting
result unique (up strong ?-equivalence).
43

fiWANG , Z HANG , Z HOU , & Z HANG

Theorem 6 (Expressibility theorem) Let formula V set atoms. exists
formula Mod? () = Mod? ()V .
Here, uniqueness strong ?-equivalence ?-forgetting result follows fact
that, formula 0 result ?-forgetting V well Mod? ( 0 ) = Mod? ()V =
Mod? (), shows 0 strongly ?-equivalent ?-stable model semantics.
Based expressibility result abusing denotation, denote forgetting result
Forget? (, V ):
Definition 9 Let formula V A. Forget? (, V ) formula s.t Mod? () =
Mod? ()V , i.e., Forget? (, V ) result ?-forgetting V .
sense Forget? operator maps formula set atoms formula. According
Definition 8 expressibility theorem, following corollary easily follows.
Corollary 7 Let , formulas, V , V1 V2 sets atoms.
(i) Forget? (Forget ? (, V1 ), V2 ) ? Forget? (Forget ? (, V2 ), V1 ).
(ii) ? Forget? (, V ) ? Forget? (, V ).
firstly states ?-forgetting independent order forgotten atoms, secondly,
?-forgetting preserves strong ?-equivalence logic programs ?-stable model semantics.
investigate properties forgetting, introduce notion irrelevance
?-model semantics.
Definition 10 formula ?-irrelevant set V atoms, denoted IR? (, V ), exists
formula mentioning atoms V ? .
basic properties ?-forgetting presented below.
Proposition 10 Let two formulas V set atoms.
(i) IR? (Forget ? (, V ), V ).
(ii) ?-model iff Forget? (, V ) has.
(iii) |=? Forget? (, V ).
(iv) |=? Forget? (, V ) |=? Forget? (, V ).
(v) Forget? ( , V ) ? Forget? (, V ) Forget? (, V ).
(vi) Forget? ( , V ) |=? Forget? (, V ) Forget? (, V ).
(vii) Forget? ( , V ) ? Forget? (, V ) IR? (, V ).
44

fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

Intuitively, (i) Proposition says ?-forgetting result irrelevant atoms V ,
i.e., forgotten atoms. sense, signature ?-forgetting result constrained
\ V . intended meaning others easily read out. E.g., item (iii) says
forgetting kind weakening, item (v) shows forgetting distributive property
disjunction.
mentioned earlier, disjunctive programs, positive programs, normal logic programs Horn
programs four types special cases (arbitrary) logic programs setting.
interesting consider whether expressibility result holds special programs.
instance, would know whether result ?-forgetting disjunctive (positive,
normal, Horn) logic program still expressible disjunctive (resp. positive, normal,
Horn) logic program.
indicated following two examples, HT- FLP-forgetting disjunctive, positive
normal logic programs possibly expressible either disjunctive positive logic programs.
simplicity, identify singleton set {} clear context, thus
denote Forget? (, {p}) Forget? (, p), IR? (, {p}) IR? (, p), M{p} Mp etc..
Example 5 Consider following normal logic program signature {p, q}:
(p q) (q p) (p q ).
Mod? () = {h{p}, {p}i, h{q}, {q}i}
Mod? ()p = {h, i, h{q}, {q}i}{p} .
h{p}, {p}i{p} = h, i{p} . implies Forget? (, p) ? q q. easily seen
q q cannot expressed disjunctive logic program Mod? ()p satisfy (9).
Hence Forget? (, p) cannot expressed normal logic program.
Please note q q HT q q. Thus q q result HT-forgetting p .
However, q q result FLP-forgetting p q q FLP > 6FLP q q.
Example 6 Let positive logic program signature {p, q, r} follows:
(p q r) (p q r) (p r q) (q r p).
difficult verify that, signature {p, r}, Mod? (){q} consists
h, i, h, {p, r}i, h{p}, {p}i, h{p}, {p, r}i, h{r}, {r}i, h{r}, {p, r}i, h{p, r}, {p, r}i.
Clearly satisfy condition (9). Hence captured disjunctive logic program. matter fact, following
Forget HT (, q) HT HT (, {p}) HT (, {r}) = (r p p) (p r r),
Forget FLP (, q) FLP FLP (, {p}) FLP (, {r}) = (r p r p) (p p r r)
terms Proposition 4. Interestingly, example shows that, though logic program may
HT-models FLP-models, HT-forgetting result may different FLPforgetting result.

45

fiWANG , Z HANG , Z HOU , & Z HANG

HT- FLP-forgetting Horn logic programs special interest, unlike disjunctive, positive normal logic programs, result HT- FLP-forgetting result Horn
logic program always expressible Horn logic program, show below.
Theorem 8 (Horn expressibility) Let Horn logic program V A. Horn
logic program 0 Forget? (, V ) ? 0 .
obtained model-theoretical characterization classes disjunctive normal
logic programs respectively, easily derive sufficient necessary condition HT-
FLP-forgetting results remain class, i.e., result HT- FLP-forgetting set
atoms disjunctive (resp. normal) logic program disjunctive (resp. normal) logic program.
Proposition 11 Let disjunctive logic program, V A. Forget? (, V )
expressible disjunctive logic programs if,
hH1 , T1 |=? , hT2 , T2 |=? T1 T2 hH3 , T3 |=? hH3 , T3 V hH1 , T2 i.
Proposition 12 Let normal logic program, V A. Forget? (, V ) expressible
normal logic programs if, addition condition (16), following condition holds,
hH1 , T1 |=? , hH2 , T2 |=? T1 V T2
hH3 , T3 |=? H3 V H1 H2 (T3 V T1 T3 V T2 ).

(16)

4.2 Forgetting Postulates
Zhang Zhou (2009) proposed four forgetting postulates work knowledge forgetting,
showed knowledge forgetting precisely characterized four postulates.
argued postulates viewed general semantic characterization
knowledge forgetting logics. Indeed, classical propositional forgetting
characterized postulates. terms forgetting logic programs, addressed
introduction, imposing postulates feasible existing approaches. following,
show ?-forgetting exactly captured postulates, think one major
advantage logic program forgetting approaches.
notion forgetting closely related uniform interpolation property (Visser, 1996;
Goranko & Otto, 2007), instance, forgetting description logics (Lutz & Wolter, 2011)
semantic forgetting logic programs (Gabbay, Pearce, & Valverde, 2011). following
corollary follows Theorem 6, actually implies uniform interpolation property
logics ?-model semantics. Namely, formulas |=? , exists
formula |=? , |=? contains atoms occurring .
formula called uniform interpolant . stated as:
Corollary 9 Let two formulas, V set atoms IR? (, V ).
|=?

iff

Forget? (, V ) |=? .

Let two formulas V set atoms. following Zhang-Zhous four
postulates logic programs ?-model semantics.
46

fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

(W) Weakening: |=? .
(PP) Positive persistence: IR? (, V ) |=? |=? .
(NP) Negative persistence: IR? (, V ) 6|=? 6|=? .
(IR) Irrelevance: IR? (, V ).
specifying ? Forget? (, V ), (W), (PP), (NP) (IR) called postulates knowledge
forgetting logic programs ?-stable model semantics. Viz, result ?-forgetting V
. Based uniform interpolation property (cf. Corollary 9), show following
representation theorem.
Theorem 10 (Representation theorem) Let two formulas V set atoms.
following statements equivalent:
(i) ? Forget? (, V ).
(ii) ? {0 | |=? 0 IR? (0 , V )}.
(iii) Postulates (W), (PP), (NP) (IR) hold.
theorem justifies knowledge forgetting (cf. Definition 7) exists unique
strong equivalence.
obvious consequence follows representation theorem
Forget? (, V ) ? { | |=? IR? (, V )}.
says result ?-forgetting V consists ?-logical consequence
?-irrelevant V . reason forgetting knowledge forgetting logic programs
stable models semantics. mentioned introduction none
forgetting approaches logic programs knowledge forgetting since satisfy
postulates (see Section 5 details).
One note representation theorem applicable forgetting classical
propositional logic, viz, Forget(, V ) { | |= IR(, V )}.
4.3 Relating Propositional Forgetting
shown strong equivalence logic programs may related equivalence
propositional logic (Pearce et al., 2001; Lin, 2002). ?-forgetting preserves strong equivalence
logic programs ?-stable model semantics, worth exploring connections
?-forgetting forgetting propositional logic. section, undertake in-depth
investigation aspect.
first provide direct connection ?-forgetting propositional forgetting via
following proposition.
Proposition 13 Let , 0 , formulas V ? Forget? (, V ) 0
Forget(, V ).
(i) 0 .
47

fiWANG , Z HANG , Z HOU , & Z HANG

(ii) 0 |=? .
result (i) Proposition 13 simply says result ?-forgetting classical propositional forgetting equivalent classical propositional logic. Thus forgetting classic propositional logic computed ?-forgetting logic programs. However seen
Example 4, Forget? (, V ) possibly ?-equivalent Forget(, V ). reverse (ii)
hold generally. instance, Forget? (p, q) ? p, Forget(p, q) p, evidently
p 6|=? p. result Theorem 8, immediately following corollary.
Corollary 11 Let Horn logic program V set atoms. Forget(, V ) expressible Horn logic program.
following result states that, Horn logic programs, ?-forgetting forgetting
propositional logic strongly ?-equivalent. Thus provides method computing ?-forgetting
results Horn logic programs propositional forgetting.
Proposition 14 Let 0 two Horn logic programs, V set atoms 0
Forget(, V ). 0 ? Forget? (, V ).
following proposition states ?-forgetting double negative formulas closely
connected classical propositional forgetting, used prove complexity
results later.
Proposition 15 Let two formulas V set atoms.
(i) Forget(, V ) iff ? Forget? (, V ).
(ii) Forget(, V ) Forget(, V ) iff Forget? (, V ) ? Forget? (, V ).
known strong equivalence logic programs closed related equivalence
propositional logic translating logic programs propositional theories (Pearce et al., 2001;
Lin, 2002). motivates us investigate connection forgettings view
translations. main result section stated follows.
Theorem 12 (?-forgetting vs propositional forgetting) Let two formulas LA
V A.
? Forget? (, V ) iff (A) |= ? [] Forget((A) {? []}, V V 0 ).
Theorem 12, know check whether formula result ?-forgetting set
V atoms formula , equivalent check whether ? [] classically equivalent
Forget((A) {? []}, V V 0 ) theory (A). following example shows
application theorem.
Example 7 [Example 5 continued] Recall following formula:
(p q) (q p) (p q )
48

fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

Forget? (, p) ? q q. signature {p, q}, (A) = (p p0 ) (q q 0 ) and,
program translation yields:
? () (p0 q) (p0 q 0 ) (q 0 p) (q 0 p0 ) (p0 q 0 ).
Forget(? [] (A), {p, p0 }) equivalent to:
(q q 0 ) (q q 0 ),

i.e.

(q 0 q) (q q 0 )

equivalent q 0 q theory ({q}) = {q q 0 }. One check
? [q q] = q 0 q q q 0 q (under theory ({q})). Thus formula q q result
?-forgetting p Theorem 12.

following example shows (A) occurring Forget? ({ []} (A), V V 0 )
necessary Theorem 12.
Example 8 [Continued Example 6] Recall = {p, q, r}, (A) = {p p0 , q q 0 , r
r 0 } consists
(p q r) (p q r) (p r q) (q r p).
that,
HT [] ,
(A) |= ? [] ,
FLP [] (p q r) (p q p0 q 0 r) (p r p0 r 0 q) (q r q 0 r 0 p)
= (p0 q 0 r 0 ) (p0 r 0 q 0 ) (q 0 r 0 p0 ).
One check
Forget(HT [], {q, q 0 }) >,
(A) |= Forget(FLP [], {q, q 0 }) >.
Recall formula 1 = (r p p) (p r r) result HT-forgetting q ;
2 = (r p r p) (p p r r) result FLP-forgetting q .

HT [1 ] 01 (r r 0 p p p0 ) (p p0 r r r 0 ),
FLP [2 ] 02 (r r 0 p r p0 ) (p p0 p r r 0 ).
theory (A),
(A) |= HT [1 ] (p0 p r 0 ) (r 0 r p0 ),
(A) |= HT [1 ] (p0 p r 0 ) (r 0 r p0 ).
One verify model {p0 } (A) model HT [1 ], model
FLP [2 ], i.e. (A) 6|= HT [1 ] > (A) 6|= FLP [2 ] >. Actually, that,
(A) |= Forget({? []} (A), {q, q 0 }) ((p0 r 0 ) (p r) (p0 r 0 )).
One check
(A) |= (p0 p r 0 ) (r 0 r p0 ) ((p0 r 0 ) (p r) (p0 r 0 )),
shows 1 (resp. 2 ) result HT-forgetting (resp.
49

FLP-forgetting)

q .



fiWANG , Z HANG , Z HOU , & Z HANG

following result states reduce checking whether ?-forgetting results two
formulas strongly ?-equivalent checking whether propositional forgetting results corresponding two formulas equivalent.
Proposition 16 Let two formulas LA V set atoms. Forget? (, V ) ?
Forget? (, V ) iff following condition holds:
Forget({? []} (A), V V 0 ) Forget({? []} (A), V V 0 ).
4.4 Computation Complexity
Theorem 6 Propositions 4 10 imply naive approach compute ?-forgetting results. Formally speaking, given formula signature set V atoms, Forget? (, V )
computed follows:
(Step 1) Evaluating ?-models , denoted M.
(Step 2) Restrict \ V , denoted M|V , i.e.
M|V = {hH \ V, \ V i|hH, M}.
(Step 3) Enumerating following formulas (over signature \ V ) M|V :
? (X, ) hX,
/ M|V hY, M|V ,
(Y, ) hY,
/ M|V .
(Step 4) Finally, conjunct constructed formulas, denoted .
Corollary 13 Let , V given above. ? Forget? (, V ).
Alternatively, terms Theorem 10, compute Forget? (, V ) enumerating ?consequences ?-irrelevant V . exist sound complete axiomatic systems
HT-logic (Jongh & Hendriks, 2003), checking HT-consequence relation axiomatically
doable. Though sound complete axiomatic system FLP-logic recently unknown, still
enumerate formulas form (2) signature \ V check FLPconsequence . Nevertheless, observed computational viewpoint,
propositional forgetting, two approaches would expensive. appears
inevitable terms following complexity results, unless complexity hierarchy collapses.
Theorem 14 Let two formulas V set atoms.
(i) problem deciding ? Forget? (, V ) co-NP-complete.
(ii) problem deciding Forget? (, V ) ? Forget? (, V ) P2 -complete.
(iii) problem deciding ? Forget? (, V ) P2 -complete.
50

fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

According representation theorem (i.e. Theorem 10), result (i) Theorem 14 means
checking ?-irrelevant V , i.e. IR? (, V ), intractable. result (ii) Theorem 14,
hand, presents complexity ?-forgetting equivalence checking, i.e., two formulas
strongly ?-equivalent restricted common signatures. last result (iii)
Theorem 14 states checking formula result ?-forgetting generally difficult.
Proposition 17 Let two formulas V set atoms.
(i) problem deciding whether |=? Forget? (, V ) P2 -complete.
(ii) problem deciding whether Forget? (, V ) |=? co-NP-complete.
Theorem 14 Proposition 17 tell us ?-forgetting, general complexity resulting checking inference problems located level complexity polynomial
hierarchy propositional forgetting.
4.5 Conflict Solving Based Knowledge Forgetting
following, consider application proposed forgetting conflict solving logic
program contexts, represent knowledge system consisting knowledge bases multiple
agents.
Definition 11 logic program context n-ary tuple = (1 , . . . , n ) consistent
logic program. ?-conflict-free 1 n consistent ?-stable model semantics.
Definition 12 Let = (1 , . . . , n ) logic program context. ?-solution minimal
subset (Forget? (1 , S), . . . , Forget? (n , S)) ?-conflict-free,
underlying signature.
obvious ?-solution ?-conflict-free logic program context .
consider following simplified Zhang Foos conflict solving scenario (cf., see Zhang
& Foo, 2006, Ex. 6).
Example 9 couple John Mary discussing family investment plan. four
different shares shareA, shareB, shareC shareD, shareA shareB high risk
high return; shareC shareD low risk may suitable long term
investment. Johns Marys investment preference shares encoded following
logic programs J respectively:
J :

:

r1 :sA sB,

r10 :sC ,

r2 :sC sD,

r20 :sD ,

r3 :sD sC,

r30 :sB sA, sC,

r4 : sC, sD,
r40 : sA, sB,
s# stands share#. intuitive meaning rules easily read out. E.g. rule r1
says John wants buy shareA dont buy shareB, rules r2 , r3 r4 mean John
wants buy shareC shareD, them.
51

fiWANG , Z HANG , Z HOU , & Z HANG

one see J ?-stable model due confliction rule r4
r10 , r20 , logic program context = (J , ) ?-conflict-free.
= {sD}, following
Forget HT (J , S) HT {sA sB,
Forget HT (M , S) HT {sC ,

sC; sC },

sB sA, sC,

sA, sB}.

One check Forget HT (J , S) Forget HT (M , S) unique HT-stable model {sA, sC}.
Thus HT-solution . said John Mary may agreement
investment plan shares shareA, shareB shareC agree give belief
(knowledge) shareD. results investment shares shareA shareC,
shareB.
One check that, FLP-stable model semantics, John Mary give
belief shareD results investment plan shares shareA shareC,
share shareB. reason Forget FLP (J , S)Forget FLP (M , S) unique FLP-stable
model {sA, sC}.

5. Related Work
section compare ?-forgetting weak strong forgetting (Zhang & Foo, 2006),
semantic forgetting (Eiter & Wang, 2008) forgetting operators FS FW (Wong, 2009).
5.1 Weak Strong Forgetting
Let normal logic program p propositional atom. reduction respect p,
denoted Red(, {p}), normal logic program obtained
(1) rule r p Head(r), rule r 0 p Body+ (r 0 ),
replacing r 0
Head(r 0 ) Body(r), Body(r 0 ) \ {p}.
(2) rule r 0 replaced new rule previous step,
removing rule r remaining normal logic program.
Let X set propositional atoms. reduction respect X inductively
defined follows:
Red(, ) = ,
Red(, X {p}) = Red(Red(, {p}), X).
strong forgetting p normal logic program normal logic program SForget(, {p})
obtained Red(, {p}) removing rule r either r valid 5 p Head(r)
Body+ (r) Body (r). weak forgetting p normal logic program WForget(, {p})
obtained Red(, {p}) firstly removing rule r either r valid, p Head(r)
Body+ (r) removing p remaining rules.
5. rule r valid Head(r) Body+ (r) 6= Body+ (r) Body (r) 6= .

52

fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

Let X set atoms. strong (and weak) forgetting X recursively defined
SForget(, ) = ;

WForget(, ) = ;

SForget(, X {p}) = SForget(SForget(, {p}), X);
WForget(, X {p}) = WForget(WForget(, {p}), X).
known two forgetting operators independent ordering forgotten atoms
sense strong HT-equivalence logic programs HT-stable model semantics (cf., see
Zhang & Foo, 2006, Prop. 2).
Example 10 Consider two normal logic programs:
= {p q,

q p,

r p},

= {p q,

q p,

r q}.

One check strongly equivalent.
SForget(, {p}) = ,

WForget(, {p}) = {r },

SForget(, {p}) = WForget(, {p}) = {r q}.
example shows neither weak forgetting preserves strong equivalence, strong forgetting. One verify |=? q r 6|=? r ? {HT, FLP }. Thus
strong forgetting satisfy positive persistence, weak forgetting satisfy weakening negative persistence. Actually, HT- FLP-forgetting,
following
Forget HT (, p) HT Forget HT (, p) HT {q r },
Forget FLP (, p) FLP Forget FLP (, p) FLP {q r }.
FLP follows fact HT Proposition 2.



5.2 Semantic Forgetting
addressed certain issues weak strong forgetting, Eiter Wang (2008) proposed
semantic forgetting consistent disjunctive logic programs. Formally speaking, let
consistent disjunctive logic program p atom. set atoms p-stable model iff
stable model stable model \ {p} \ {p}.
disjunctive logic program 0 represents result forgetting p ,
0 mention atom p,
set 0 atoms stable model 0 iff p-stable model 0 p .
terms definition, forgetting results unique strong equivalence.
means, forgetting preserve strong equivalence. compute result forgetting atom consistent disjunctive logic program, proposed three algorithms forget1 ,
forget2 forget3 (Eiter & Wang, 2008). example demonstrates difference
semantic forgetting ?-forgetting.
53

fiWANG , Z HANG , Z HOU , & Z HANG

Example 11 Let = {p q} program signature = {p, q, r}. Although program nothing atom r, forgeti (, r) = (i = 1, 2, 3),
seems intuitive loses information irrelevant want forget. However
Forget? (, r) ? .

example shows semantic forgetting satisfy positive persistence
postulate |=? q p, lost semantic forgetting result forgeti (, r) = 1, 2, 3.
5.3 Forgetting Operators FS FW
Wong (2009) developed forgetting disjunctive logic programs. Differently work
Zhang Foo (2006), Eiter Wang (2008), Wongs forgetting defined based
HT-logic. sense, approach probably shares common logic ground HT-forgetting.
Wong defined two forgetting operators FS FW , correspond two series program
transformations. See Appendix detailed definitions.
interesting feature Wongs forgetting preserves strong equivalence. However,
major issue forgetting that: one hand, forgetting FS may cause unnecessary
information loss; hand, forgetting FW may introduce extra information
one want, illustrated following example.
Example 12 Let us consider normal logic program consisting of:
x,

a, z,

q p,

p q,

p, q.

have:
FS (, {a, p}) HT {y x, z},
FW (, {a, p}) HT {y x, z,

x,

Forget HT (, {a, p}) HT {y x, z,
Forget FLP (, {a, p}) FLP {y x, z,

q },
q q},
q q}.

Since |=HT {q q}, irrelevant atoms p, seems us forgetting
{a, p} affect fact. FS (, {a, p}) 6|=HT {q q}. sense,
see FS lost information wish keep. shows operator FS
satisfy positive persistence postulate.
hand, fact 6|=HT q FW (, {a, p}) |=HT q, appears FW may
introduce unnecessary information, indeed conflicts intuition program weakening via
forgetting, i.e., satisfy weakening postulate.

mentioned introduction, following example confirms expected result
obtained either one three forgetting approaches.
Example 13 [Continued Example 5] normal logic program :
(p q) (q p) (p q ),
54

fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

following:
SForget(, {p}) = forget1 (, {p}) = FS (, {p}) = ,
WForget(, {p}) = FW (, {p}) = {q}.
Here, expected logic program represents information auxiliary atom
p ignored q q.


6. Concluding Remarks
paper two semantic knowledge forgetting approaches, called HT- FLP-forgetting respectively, proposed logic programs stable model FLP-stable model semantics respectively. knowledge forgetting results captured corresponding logical consequence forgotten logic programs irrelevant forgotten atoms. consequently preserves
strong equivalence logic programs HT- FLP-stable model semantics respectively.
major advantage compared existing forgetting approaches logic programming.
starting point, investigated model theoretical characterization logic programs HT- FLP-stable model semantics, studied respective strong equivalence problems
using classical propositional logic equivalence. Many properties forgetting explored,
existence forgetting results, representation theorem, complexity decision problems related forgettings. considered application knowledge forgetting conflict solving.
Although presented abstract approaches computing forgetting results
showed underlying difficulties computation, valuable study practical algorithms
different subclasses logic programs. Another challenging future work extend knowledge forgetting nonmonotonic systems, particular first-order logic programs (Ferraris
et al., 2011). mentioned introduction forgetting effectively used
solve confliction, e.g. strong weak forgetting (Zhang & Foo, 2006) propositional forgetting (Lang & Marquis, 2010), application knowledge forgetting deserves
studying.
concentrate upon paper knowledge forgetting logic programs,
based notion strong equivalence, interesting work consider forgetting
stable model semantics logic programs along work (Wang et al., 2013). Last least,
logic programs supported model semantics enjoys similar properties logic
programs HT- FLP-stable models semantics (Truszczynski, 2010), consider
knowledge forgetting logic programs supported model semantics another paper.

Acknowledgments
thank Mirek Truszczynski encouraging us consider knowledge forgetting logic programs FLP-stable model semantics. thank anonymous reviewers insightful comments, Robin Bianchi help formatting paper. Yisong Wang partially
supported National Natural Science Foundation China grant 61370161 Stadholder
Foundation Guizhou Province grant (2012)62.
55

fiWANG , Z HANG , Z HOU , & Z HANG

Appendix A. Proofs Section 2
Proposition 1 Let A, B, C, set atoms. following
V
W
V
W
(i) (A B) (D C) HT (A B C) D.
V
W
V
W
(ii) (A B) (D C) |=FLP (A B C) D.

V
W
Proof:
(ii)
Suppose
hX,




FLP-model (A B) (D C) FLP-model
V
W
(A B C) D. follows following conditions hold:
V
V
(a) X |= (A B C), implies X |= (A B).
V
V
V
(b) |= (A B C), implies |= (A B) C,
W
W
(c) hX, 6|=FLP D, i.e. X 6|= D.
W
W
W
conditions (a) (b) show hX, |=FLP (D C), i.e. X |= |= C.
Together conditions (b) (c), contradiction follows.


Appendix B. Proofs Section 3
Proposition 4 collection ?-interpretations ?-expressible iff
hX, implies hY, M.

(17)

Actually, satisfy condition (17) following logic program
? = {? (X, )|hX,
/ hY, M} {(Y, )|hY,
/ M}
captures sense Mod? (? ) = M.
Proof: direction left right follows (i) Proposition 3. prove
direction. Let ? propositional theory consisting of, every X A,
? (X, ) hX,
/ hY, M,
(Y, ) hY,
/ M.
Lemma 1, Mod? (? ) = M.



Lemma
V
W2 Let A, B beVtwo sets
W atoms, X A. hX, |=?
B |= B A.

V

B

W

iff X |=

Proof: According (iii) Proposition 3 Proposition 2, sufficient show that,
case ? = HT,
^
_
^
_
^
_
X |= ( B
A)Y iff X |=
B
|=
B
A.

V
W
V
W
Note |= B X |= ( B)Y implies X
V () W
V |= ( A) . Suppose X 6|=
B A, i.e. B X X = . follows |= B due B ,
56

fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

W
V
V
V
W
|= A,Wi.e. 6= . Thus X |= ( B)Y since ( B)Y = B. X |= ( A)Y
i.e. X |= A, X 6= , contradiction.
V
W
V
W
()VWe need show
X |= ( B)Y ( A)Y since |=
B
A. Suppose
W
X |=V( B)YW X 6|= ( A)Y . former implies B X , thus X 6=
X |= B A. latter implies X (A ) = , means X = since X ,
contradiction.

Proposition 5 set ?-interpretations positively ?-expressible, i.e., positive logic
program s.t Mod? () = M, iff satisfies criteria:
hX, iff X Y, hX, Xi hY, M.

(18)

Actually, satisfy condition (18) following logic program
^
_
X|hX, Xi
/ M}
? = { X

captures sense Mod? (? ) = M.

Proof: suffices prove case ? = HT Proposition 2.
() Let positive logic program whose HT-models exact ones M. every
HT-interpretation hX, i, Lemma 2, hX, |= HT iff X , X |= i.e. hX, Xi |= HT ,
hY, |=HT i.e. |= since every rule positive. condition (18) follows.
() Let N = {X A|hX, Xi M}. construct propositional theory consisting
^
_
X
X

every X N (= 2A \ N ).
Firstly show
V Mod()
W = N . Suppose X |= X 6 N . X N . follows
X 6|= X X belongs .
V hand,
W suppose X N X 6|= .
follows exists X 0 N X 6|= X 0 X 0 , i.e., X 0 X X X 0 = ,
X = X 0 thus X N , contradiction.
Secondly show ModHT () = M. one hand, let hX, |=HT . X |=
|= Lemma 2. follows X, N , implies hX, Xi hY, M.
Thus hX, (18). hand, let hX, M. terms (18),
hX, Xi hY, M. Thus X N N , i.e. X |= |= . Thus
hX, |=HT Lemma 2.

Proposition 6 collection ?-interpretations Horn ?-expressible, i.e., Horn logic
program Mod? () = M, iff satisfies, addition (10), following criteria:
hX, hH, hX H, M.

(19)

Proof: suffices prove case ? = HT Proposition 2.
() Suppose Horn logic program ModHT () = M. Proposition 5,
ModHT () satisfies (18). Suppose hX, hH, two HT-models . follows
X, Y, H models Lemma 2. Thus X H |= |= ,
hX H, |= due X H .
57

fiWANG , Z HANG , Z HOU , & Z HANG

() Let N ones defined proof Proposition 5. X, N X
N according (19). follows exists Horn logic program (a set Horn clauses) whose
0
models exactly
Vones inWN . matter fact, Horn program constructed
replacing X
^
^
X p1 , . . . , X pk
(20)


X = {Y 0 \ X|X 0 0 N } = {p1 , . . . , pk }.
firstly show 0 proving


^
_
^
^
X
X
|=
pi
1ik

V
W
pi (1 k) defined (20). direction right left trivial V X W
belongs V
. Let us consider direction. Suppose H |= , H model X
H 6|= X pi (1 k). X H H 6= . follows
H element {Y 0 \ X|X 0 0 N } {p1 , . . . , pk } H.
contradiction.
Finally ModHT (0 ) = follows ModHT () = Proposition 5.

V
W
Proposition 7 Let = (B C) (A D), A, B, C, subsets A.
(A) |= FLP [] HT [].
Proof: Note HT [p] = p p0 FLP [p] = p0 .
HT [] = 0

^

^

B

(c c0 )

cC

_



_

!

(d d0 ) ,

dD

^

_
FLP [] = 0
(B C B 0 C 0 ) (A 0 ) .

Since (A) |= p p0 p0 ,
0

(A) |= HT []

!
^
_
_
0
0
,
(B C )

dD

0

(A) |= FLP []
completes proof.

^


_
(B C ) (A 0 ) .
0



Proposition 8 Let formula LA X A. hX, ?-model iff X 0
model (A) {? []}.
Proof: prove case ? =

FLP

induction structures . Let X A.

= p = . trivial = . hand, hX, |=FLP p iff X |= p iff
X 0 |= p.
58

fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

= 1 2 {, }. follows inductive assumption.
= 1 2 . FLP [1 2 ] = (01 02 ) (1 01 FLP [2 ]). Recall
hX, |=FLP 1 2 iff
|= (1 2 ) and,
either (a) X 6|= 1 , (b) 6|= 1 , (c) hX, |=FLP 2 .
Note
|= (1 2 ) iff 0 |= 01 02 iff X 0 |= 01 02 ,
(a) X 6|= 1 iff X 0 6|= 1 , (b) 6|= 1 iff 0 6|= 01 iff X 0 6|= 01 , (c)
hX, |=FLP 2 iff X 0 |= FLP [2 ] inductive assumption.
follows hX, |=FLP 1 2 iff X 0 |= FLP [1 2 ].


completes proof.

Theorem 4 Two formulas ?-models (over LA ) iff (A) {? []}
(A) {? []} models (over LAA0 ).
Proof: prove case ? = FLP .
() |= (A) {FLP []}
iff MA0 |= (A) {FLP []}
0

|=
iff hMA ,
0
FLP Proposition 8, MA0 = {p|p MA0 }

iff hMA , MA0 |=FLP since FLP
iff MA0 |= (A) {FLP []} Proposition 8
iff |= (A) {FLP []}.
() hX, |=FLP
iff X 0 |= (A) {FLP []} Proposition 8, 0 = {p0 |p }
iff X 0 |= (A) {FLP []} since (A) {FLP []} (A) {FLP []}
iff hX, |=FLP Proposition 8.



Proposition 9 (i) problem deciding formula ?-satisfiable NP-complete.
(ii) problem deciding two formulas ?-equivalent co-NP-complete.
Proof: (i) Membership. formula FLP-satisfiable exists FLP-interpretation
hH, hH, |=FLP . feasible guess FLP-interpretation check
condition hH, |=FLP . Thus problem NP.
Hardness. follows fact FLP-satisfiable iff satisfiable, NPhard, (ii) Proposition 3. shows problem NP-hard.
(ii) Membership. 6FLP exists hH, that, either
(a) hH, |=FLP hH, 6|=FLP ,
(b) hH, 6|=FLP hH, |=FLP .
59

fiWANG , Z HANG , Z HOU , & Z HANG

guess FLP-interpretation hH, check conditions (a) (b) feasible
polynomial time size . Thus problem co-NP.
Hardness. FLP
iff FLP-model
iff model (ii) Proposition 3
iff valid, co-NP-hard. Thus problem co-NP-hard.


Appendix C. Proofs Section 4
Lemma 3 Let formula V A. formula result ?-forgetting V , iff
following condition holds:
Mod? () = Mod? ()V .
Proof: result ?-knowledge forgetting V
iff, every ?-interpretation , |=? iff exists 0 |=? s.t. V 0
iff Mod? () = {M ?-interpretation | 0 |=? V 0 }
iff Mod? () = Mod()V .



Lemma 4 Let X, Y, H, V subsets A.
(i) X V H V X V H X V H .
(ii) X V H 0 V 0 0 H 0 V V 0 X 0 .
Proof: (i) Note (X ) \ V
=(X \ V ) (Y \ V )
=(H \ V ) (T \ V ) due X V H V
=(H ) \ V .
Thus X V . similarly prove X V H .
(ii) Please note 0 = {p0 |p }, V 0 = {p0 |p V } 0 = {p0 |p V }.
(H 0 ) \ (V V 0 ).
= (H \ (V V 0 )) (T 0 \ (V V 0 ))
= (H \ V ) (T 0 \ V 0 ) since H V 0 = 0 V =
= (X \ V ) (Y 0 \ V 0 ) since H V H 0 V 0 0
= (X \ (V V 0 )) (Y 0 \ (V V 0 )) since X V 0 = 0 V =
= (X 0 ) \ (V V 0 ).

follows H 0 V V 0 X 0 .
Theorem 6 (Expressibility theorem) Let formula V set atoms. exists
formula Mod? () = Mod? ()V .
Proof: every hX, Mod? ()V , exists hH, |=? hH, V hX, i,
i.e. X V H V . (i) Proposition 3, hT, |=? . Thus hY, Mod? ()V
due hY, V hT, i. follows collection Mod? ()V satisfies condition (8),
formula Mod? () = Mod? ()V Proposition 4.

Lemma 5 formula ?-irrelevant set V atoms iff hH, |=? implies hX, |=?
every two ?-interpretations hX, hH, hX, V hH,
60

fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

Proof: ?-irrelevant V
iff exists formula mentioning atoms V ?
iff exists formula mentioning atoms V s.t Mod? () = Mod? ()
iff Mod? () = {hX, i|X hH, V hX, s.t hH, |=? }
iff hH, |=? implies hX, |=? every two ?-interpretations hX, hH,
hX, V hH, i.

Proposition 10 Let two formulas V set atoms.
(i) IR? (Forget ? (, V ), V ).
(ii) ?-model iff Forget? (, V ) has.
(iii) |=? Forget? (, V ).
(iv) |=? Forget? (, V ) |=? Forget? (, V ).
(v) Forget? ( , V ) ? Forget? (, V ) Forget? (, V ).
(vi) Forget? ( , V ) |=? Forget? (, V ) Forget? (, V ).
(vii) Forget? ( , V ) ? Forget? (, V ) IR? (, V ).
Proof: (i) immediately follows Lemma 5.
(ii) evident Mod? () 6= iff Mod? ()V 6= Definition 8.
(iii) easy see Mod? () Mod? ()V Definition 8.
(iv) Let |=? , hH, |=? Forget? (, V ), i.e. hH, Mod? ()V . terms
Definition 8, exists hH 0 , 0 |=? hH, V hH 0 , 0 i. implies hH 0 , 0 |=?
since |=? . Thus hH, Mod? ()V , i.e. hH, |=? Forget? (, V ).
(v) hH, |=? Forget? ( , V )
iff hH, Mod? ( )V
iff hH 0 , 0 |=? hH, V hH 0 , 0
iff hH 0 , 0 hH, V hH 0 , 0 and, either hH 0 , 0 |=? hH 0 , 0 |=?
iff hH, Mod? ()V hH, Mod? ()V
iff hH, |=? Forget? (, V ) hH, |=? Forget? (, V )
iff hH, |=? Forget? (, V ) Forget? (, V ).
(vi) hH, |=? Forget? ( , V )
hH, Mod? ( )V
hH 0 , 0 |=? hH, V hH 0 , 0
hH 0 , 0 that. hH, V hH 0 , 0 i, hH 0 , 0 |=? hH 0 , 0 |=?
hH, Mod? ()V hH, Mod? ()V
hH, |=? Forget? (, V ) hH, |=? Forget? (, V )
hH, |=? Forget? (, V ) Forget? (, V ).
(vii) direction left right follows (vi) fact IR(, V ), i.e. Forget? (, V ) ?
. Let us consider direction.
hH, |=? Forget? (, V )
hH, |=? Forget? (, V ) hH, |=?
hH 0 , 0 |=? hH, V hH 0 , 0 i, hH, |=?
61

fiWANG , Z HANG , Z HOU , & Z HANG

hH, V hH 0 , 0 hH 0 , 0 |=? IR(, V ) Lemma 5
hH, Mod? ( )V
hH, |=? Forget? ( , V ).



Theorem 8 (Horn expressibility) Let Horn logic program V A. Horn
logic program 0 Forget? (, V ) ? 0 .
Proof: terms Proposition 2, suffices prove ? = HT. Let = ModHT ()V .
Proposition 6, sufficient show satisfies conditions (5) (12).
first prove satisfies (5). HT-interpretation hX, M,
X , exists hH, ModHT () hX, V hH, i. Note positive,
shows hH, Hi hT, HT-models Lemma 2. Thus hX, Xi
hY, due X V H V . hand, suppose hX, Xi M, hY,
X . exist two HT-models hH 0 , 0 hH 00 , 00 hH 0 , 0 V hX, Xi
hH 00 , 00 V hY, i. Lemma 2, H 0 |= , 0 |= , H 00 |= 00 |= . Since
models Horn theories closed set intersection (Alfred, 1951), H 0 H 00 |= .
Lemma 2 again, hH 0 H 00 , 00 |=HT . Lemma 4, H 0 H 00 V X (= X). Thus
hH 0 H 00 , 00 V hX, i. follows hX, M.
show satisfies (12). Suppose hX, hH, two HT-interpretations
M. follows two HT-models hX 0 , 0 hH 0 , 0 hX 0 , 0 V
hX, hH 0 , 0 V hH, i. Since Horn, hH 0 X 0 , 0 0 |=HT
Proposition 6. Lemma 4, H 0 X 0 V H X 0 0 V . implies
hH 0 X 0 , 0 0 V hX H, i, thus hX H, M.

Proposition 11 Let disjunctive logic program, V A. Forget? (, V )
expressible disjunctive logic programs if,
hH1 , T1 |=? , hT2 , T2 |=? T1 T2 hH3 , T3 |=? hH3 , T3 V hH1 , T2 i.
Proof: Proposition 2, suffices prove ? = HT. Let 0 HT Forget HT (, V ). direction
left right obvious. show direction.
Suppose 0 expressible disjunctive logic programs. exists hX, |=HT 0 ,
0 hY 0 , 0 |=HT 0 hX, 0 6|=HT 0 . follows that, hH1 , T1 |=HT
hT2 , T2 |=HT hH1 , T1 V hX, i, T2 V 0 T1 T2 , exists
hH3 , T3 |=HT hH3 , T3 V hH1 , T2 i, viz. hH3 , T3 V hX, 0 hX, 0 V
hH1 , T2 i, contradiction.

Proposition 12 Let normal logic program, V A. Forget? (, V ) expressible
normal logic programs if, addition condition (21), following condition holds,
hH1 , T1 |=? , hH2 , T2 |=? T1 V T2
hH3 , T3 |=? H3 V H1 H2 (T3 V T1 T3 V T2 ).

(21)

Proof: Proposition 2, suffices prove ? = HT. Let 0 HT Forget HT (, V ). direction
left right easy. consider direction follows.
terms Proposition 11 Corollary 3, sufficient show that, hX, |=HT 0
hX 0 , |=HT 0 , hX X 0 , |=HT 0 according Corollary 3. Suppose hX,
62

fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

hX 0 , two HT-models 0 . two HT-models hH1 , T1 hH2 , T2
hX, V hH1 , T1 hX 0 , V hH2 , T2 i. follows T1 V T2 and, condition (21), exists HT-model hH3 , T3 satisfying either hH3 , T3 V hH1 H2 , T1
hH3 , T3 V hH1 H2 , T2 i, shows hH3 , T3 V hX X 0 , i, hence hX X 0 , |=HT
0 .

Theorem 10 (Representation theorem) Let two formulas V set atoms.
following statements equivalent:
(i) ? Forget? (, V ).
(ii) ? {0 | |=? 0 IR? (0 , V )}.
(iii) Postulates (W), (PP), (NP) (IR) hold.
Proof: Let ? = { | |=? IR? (, V )}. evident IR? (? , V ).
equivalence (i) (ii) follows Corollary 9. (ii) obviously implies (iii).
suffices show (iii) (ii).
Positive Persistence, |=? ? , follows Mod? ()
Mod? (? ). hand, ( W) |=? (IR) IR? (, V ), follows ? . Thus
Mod? (? ) Mod? (). Thus ? ? .

Proposition 13 Let , 0 , formulas V ? Forget? (, V ) 0
Forget(, V ).
(i) 0 .
(ii) 0 |=? .
Proof: (i) |=
iff hT, |=? (i) Proposition 3
iff hT, |=? Forget? (, V ) since ? Forget? (, V )
iff hY, |=? hT, V hY, Definition 8
iff |= V (i) Proposition 3
iff |= Forget(, V ) Corollary 5
iff |= 0 since 0 Forget(, V ).
(ii) hH, |=? 0
|= 0 (i) Proposition 3
|= Forget(, V ) since 0 Forget(, V )
|= V Corollary 5
hH \ V, |=? V (ii) Proposition 3
hH, |=? Forget? (, V ) due hH \ V, V hH, Definition 8
hH, |=? due Forget? (, V ) ? .



Proposition 14 Let 0 two Horn logic programs, V set atoms 0
Forget(, V ). 0 ? Forget? (, V ).
63

fiWANG , Z HANG , Z HOU , & Z HANG

Proof: Proposition 2, suffices show ? = HT.
() hH 0 , 0 |=HT 0
H 0 |= 0 0 |= 0 Lemma 2
H, H |= , |= , H V H 0 V 0 0 Forget(, V )
H, H |= , |= , H V H 0 V 0
H, hH T, |=HT hH T, V hH 0 , 0
hH 0 , 0 |=HT Forget HT (, V ).
() hH 0 , 0 |=HT Forget HT (, V )
hH, |=HT hH 0 , 0 V hH,
H H |= , |= hH 0 , 0 V hH, Lemma 2
H 0 |= Forget(, V ) 0 |= Forget(, V )
H 0 |= 0 0 |= 0 due 0 Forget(, V )
hH 0 , 0 |=HT 0 .
Proposition 15 Let two formulas V set atoms.
(i) Forget(, V ) iff ? Forget? (, V ).
(ii) Forget(, V ) Forget(, V ) iff Forget? (, V ) ? Forget? (, V ).
Proof: (i) () hH, |=?
iff |= , i.e. |= (ii) Proposition 3
iff |= Forget(, V ) since Forget(, V )
iff |= i.e. |= V Corollary 5
iff hH \ V, |=? (H \ V \ V = \ V ) (ii) Proposition 3
iff hH, |=? Forget? (, V ) Definition 8.
() |= i.e. |=
iff hH, |=? (ii) Proposition 3
iff hH, |=? Forget? (, V ) H since ? Forget? (, V )
iff hX, |=? hH, V hX, Definition 8
iff |= V (ii) Proposition 3
iff |= Forget(, V ) Corollary 5.
(ii) () hH, |=? Forget? (, V )
iff hX, |=? hX, V hH, Definition 8
iff |= i.e. |= V (ii) Proposition 3
iff |= Forget(, V ) Corollary 5
iff |= Forget(, V ) since Forget(, V ) Forget(, V )
iff 0 |= i.e. 0 |= 0 V Definition 8
iff hX \ V, 0 |=? (ii) Proposition 3 (X \ V \ V = 0 \ V )
iff hH, |=? Forget? (, V ) hH, V hX \ V, 0 Definition 8.
() |= Forget(, V )
iff |= i.e. |= V Corollary 5
iff hX, |=? V (ii) Proposition 3
iff hX \ V, |=? Forget? (, V ) hX \ V, V hX, Definition 8
iff hX \ V, |=? Forget? (, V ) since Forget? (, V ) ? Forget? (, V )
iff hX 0 , 0 |=? hX \ V, V hX 0 , 0 Definition 8
64



fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

iff 0 |= i.e. 0 |= V 0 (ii) Proposition 3
iff |= Forget(, V ) Corollary 5.



Theorem 12 (?-forgetting vs propositional forgetting) Let two formulas LA
V A.
? Forget? (, V ) iff (A) |= ? [] Forget((A) {? []}, V V 0 ).
model (A).
Proof: () Let =
0
|= (A) {? []}
|= Proposition 8
iff hMA ,
0
?
|= Forget (, V ) since Forget (, V )
iff hMA ,
0
?
?
?
?
Definition 8
iff hH, |=? hH, V hMA ,
0

iff hH, |=? H V V
0
0
iff H |= (A) {? []} H V 0 V 0 MA0 Proposition 8
iff H 0 |= (A) {? []} H 0 V V 0 MA0 Lemma 4
iff MA0 |= Forget((A) {? []}, V V 0 ) Definition 8
iff |= Forget((A) {? []}, V V 0 ).
() hX, |=?
iff X 0 |= (A) {? []} Proposition 8
iff X 0 |= (A) Forget((A) {? []}, V V 0 )
iff |= (A) {? []} V V 0 X 0
|= X Proposition 8
iff hMA ,
0
V
?

A0
Definition 8.
iff hX, |=? Forget? (, V ) due hX, V hMA ,
0



Proposition 16 Let two formulas LA V set atoms. Forget? (, V ) ?
Forget? (, V ) iff following condition holds:
Forget({? []} (A), V V 0 ) Forget({? []} (A), V V 0 ).
Proof: () show Forget({? [] (A), V V 0 ) |= Forget({? [] (A), V V 0 ).
side similarly proved.
|= Forget({? []} (A), V V 0 )
N A0 N V V 0 N |= {? []} (A)
hX, |=? N = X 0 Proposition 8
hX, |=? Forget? (, V ) (iii) Proposition 10
hX, |=? Forget? (, V ) Forget? (, V ) ? Forget? (, V )
hH, |=? hH, V hX, Definition 8
H 0 |= ? [] (A) Proposition 8
X 0 |= Forget({? []} (A), V V 0 ) H 0 V V 0 X 0
|= Forget({? []} (A), V V 0 ) V V 0 X 0 (= N ).
() show Forget? (, V ) |=? Forget? (, V ). side similar.
hH, |=? Forget? (, V )
hX, |=? hH, V hX, i) Definition 8
X 0 |= {? []} (A) Proposition 8
X 0 |= Forget({? []} (A), V V 0 )
65

fiWANG , Z HANG , Z HOU , & Z HANG

X 0 |= Forget({? []} (A), V V 0 )
H1 T10 |= {? []} (A) H1 T10 V V 0 X 0
hH1 , T1 |=? Proposition 8
hX, |=? Forget? (, V ) hX, V hH1 , T1 Definition 8
hH, |=? Forget? (, V ) hX, V hH, i.



Theorem 14 Let two formulas V set atoms.
(i) problem deciding ? Forget? (, V ) co-NP-complete.
(ii) problem deciding Forget? (, V ) ? Forget? (, V ) P2 -complete.
(iii) problem deciding ? Forget? (, V ) P2 -complete.
Proof: (i) Membership. Recall |=? Forget? (, V ) (iii) Proposition 10.
6? Forget? (, V )
iff Forget? (, V ) 6|=?
iff hX, |=? Forget? (, V ) hX, 6|=?
iff hH, |=? hH, V hX, hX, 6|=? .
Since guessing hH, i, hX, checking ?-satisfiability done polynomial
time size V . Thus complement 6? Forget? (, V ), i.e. ? Forget? (, V ),
co-NP.
hardness follows fact that, (i) Proposition 15, ? Forget? (, V ) iff
Forget(, V ), co-NP-complete (cf., see Lang et al., 2003, Prop. 10).
(ii) Membership. Forget? (, V ) 6? Forget? (, V ) exists ?-interpretation hH,
either
(a) hH, |=? Forget? (, V ) hH, 6|=? Forget? (, V ),
(b) hH, 6|=? Forget? (, V ) hH, |=? Forget? (, V ).
one hand, guess ?-interpretation hH, feasible nondeterministic Turing machine. hand, checking hH, |=? feasible deterministic Turing machine;
hH, |=? Forget? (, V ) iff exists hX, |=? hX, V hH, i. Thus
checking conditions (a) (b) done polynomial time size calling
nondeterministic Turing machine. Thus problem P2 .
Note that, (ii) Proposition 15, Forget? (, V ) ? Forget? (, V ) iff Forget(, V )
Forget(, V ), P2 -complete (cf., see Lang et al., 2003, Prop. 24). Thus hardness
follows.
(iii) Membership. Note 6? Forget? (, V ) iff ?-interpretation hH,
hH, |=? hH, 6|=? Forget? (, V ),
hH, 6|=? hH, |=? Forget? (, V ).
Similar case (ii), guessing checking polynomial time size ,
V calling nondeterministic Turing machine. Thus problem P2 .
Note ? Forget? (, V ) iff ? Forget? (, V ) Forget? (, V ) ? Forget? (, V ),
latter P2 -hard (ii). hardness follows.

66

fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

Proposition 17 Let two formulas V set atoms.
(i) problem deciding whether |=? Forget? (, V ) P2 -complete.
(ii) problem deciding whether Forget? (, V ) |=? co-NP-complete.
Proof: (i) Membership. Recall 6|=? Forget? (, V ) iff exists ?-model hH,
hH, 6|= Forget? (, V ). hH, 6|= Forget? (, V ) iff hX, 6|= every ?interpretation hX, hX, V hH, i. hH, guessed polynomial
time size , V . Checking hH, 6|= Forget? (, V ) possible polynomial time
size , V calling nondeterministic Turing machine. Thus original problem
p2 .
Hardness. follows following fact:
> |=? Forget? (, V )
iff > ? Forget? (, V )
iff > Forget(, V ) (i) Proposition 15 (> ? >)
iff QBF V V valid, P2 -complete (Papadimitriou, 1994).
(ii) Membership. Note
Forget? (, V ) 6|=?
iff hH, |=? Forget? (, V ) hH, 6|=
iff hX, |=? hX, V hH, hH, 6|= .
Since guessing checking polynomial size , V , original problem
co-NP.
Hardness follows fact
Forget? (, V ) |=?
iff |=? (ii) Proposition 10
iff ?-model, co-NP-complete Proposition 9.


Appendix D. Forgetting Operators FW FS
Wong proposed six postulates argued postulates respected forgetting
operators disjunctive logic programs strong equivalence:
(F-1) |=HT F (, a) |=HT F (, a);
(F-2) appear , F ({r} , a) HT F ({r}, a) ;
(F-3) F (, a) contain atoms ;
(F-4) F (, a) |=HT r F ({s}, a) |=HT r Cn();
(F-5) F (, a) |=HT (A B, C), |=HT (A B, C, a);
(F-6) F (F (, a), b) HT F (F (, b), a)
F forgetting operator, , disjunctive logic programs, b atoms, r
disjunctive rule,
Cn() ={r| r disjunctive rule |=HT r var(r) var()}.
67

fiWANG , Z HANG , Z HOU , & Z HANG

var() set atoms occurring .
Accordingly, proposed two forgetting operators FS FW : result forgetting atom
disjunctive logic program defined procedure:
(1) Let 1 = Cn().
(2) Form 1 , remove rules form (A B, a, C), replace rule form (A
{a} B, C, a) (A B, C, a). Let resulting logic program 2 .
(3) Replace remove rule 2 , form (A B, C, a) (A {a}
B, C) according following table:

W

B, C,
(remove)
B, C

{a} B, C
(remove)
B, C

Let 3 resulting logic program.
logic program 3 result forgetting p .

References
Alfred, H. (1951). sentences true direct unions algebras. Journal Symbolic
Logic, 16(1), 1421.
Bobrow, D. G., Subramanian, D., Greiner, R., & Pearl, J. (Eds.). (1997). Special issue relevance
97 (1-2). Artificial Intelligence Journal.
Cabalar, P., & Ferraris, P. (2007). Propositional theories strongly equivalent logic programs.
Theory Practice Logic Programming, 7(6), 745759.
Delgrande, J. P., Schaub, T., Tompits, H., & Woltran, S. (2013). model-theoretic approach
belief change answer set programming. ACM Transactions Computational Logic, 14(2),
A:1A:42.
Eiter, T., Fink, M., Tompits, H., & Woltran, S. (2004). eliminating disjunctions stable logic
programming. Principles Knowledge Representation Reasoning: Proceedings
Ninth International Conference (KR2004), pp. 447458, Whistler, Canada. AAAI Press.
Eiter, T., & Wang, K. (2008). Semantic forgetting answer set programming. Artificial Intelligence,
172(14), 16441672.
Faber, W., Pfeifer, G., & Leone, N. (2011). Semantics complexity recursive aggregates
answer set programming. Artificial Intelligence, 175(1), 278298.
Ferraris, P. (2005). Answer sets propositional theories. Logic Programming Nonmonotonic Reasoning, 8th International Conference, Vol. 3662 Lecture Notes Computer Science, pp. 119131, Diamante, Italy. Springer.
Ferraris, P., Lee, J., & Lifschitz, V. (2011). Stable models circumscription. Artificial Intelligence, 175(1), 236263.
Ferraris, P., & Lifschitz, V. (2005). Mathematical foundations answer set programming.
Artemov, S. N., Barringer, H., dAvila Garcez, A. S., Lamb, L. C., & Woods, J. (Eds.),
Show Them! Essays Honour Dov Gabbay, Vol. 1, pp. 615664. College Publications.
68

fiK NOWLEDGE F ORGETTING



NSWER ET P ROGRAMMING

Gabbay, D. M., Pearce, D., & Valverde, A. (2011). Interpolable formulas equilibrium logic
answer set programming. Journal Artificial Intelligence Research, 42, 917943.
Gelfond, M., & Lifschitz, V. (1988). stable model semantics logic programming. Proceedings Fifth International Conference Symposium Logic Programming, pp.
10701080, Seattle, Washington. MIT Press.
Goranko, V., & Otto, M. (2007). Handbook Modal Logic, Vol. 3, chap. 5 Model Theory Modal
Logic, pp. 249329. Elsevier.
Jongh, D. D., & Hendriks, L. (2003). Characterization strongly equivalent logic programs
intermediate logics. Theory Practice Logic Programming, 3(3), 259270.
Kontchakov, R., Wolter, F., & Zakharyaschev, M. (2008). tell difference dl-lite
ontologies?. Principles Knowledge Representation Reasoning: Proceedings
Eleventh International Conference, KR 2008, pp. 285295, Sydney, Australia. AAAI Press.
Lang, J., Liberatore, P., & Marquis, P. (2003). Propositional independence: Formula-variable independence forgetting. Journal Artificial Intelligence Research, 18, 391443.
Lang, J., & Marquis, P. (2010). Reasoning inconsistency: forgetting-based approach. Artificial Intelligence, 174(12-13), 799823.
Lifschitz, V., Pearce, D., & Valverde, A. (2001). Strongly equivalent logic programs. ACM Transactions Computational Logic, 2(4), 526541.
Lifschitz, V., Tang, L. R., & Turner, H. (1999). Nested expressions logic programs. Annals
Mathematics Artificial Intelligence, 25(3-4), 369389.
Lin, F. (2001). strongest necessary weakest sufficient conditions. Artificial Intelligence,
128(1-2), 143159.
Lin, F. (2002). Reducing strong equivalence logic programs entailment classical propositional logic. Proceedings Eights International Conference Principles Knowledge Representation Reasoning (KR-02), pp. 170176, Toulouse, France. Morgan Kaufmann.
Lin, F., & Chen, Y. (2007). Discovering classes strongly equivalent logic programs. Journal
Artificial Intelligence Research, 28, 431451.
Lin, F., & Reiter, R. (1994). Forget it!. Proceedings AAAI Fall Symposium Relevance,
pp. 154159.
Lin, F., & Zhou, Y. (2011). answer set logic programming circumscription via logic GK.
Artificial Intelligence, 175(1), 264277.
Liu, Y., & Wen, X. (2011). progression knowledge situation calculus. IJCAI
2011, Proceedings 22nd International Joint Conference Artificial Intelligence, pp.
976982, Barcelona, Catalonia, Spain. IJCAI/AAAI.
Lutz, C., & Wolter, F. (2011). Foundations uniform interpolation forgetting expressive
description logics. IJCAI 2011, Proceedings 22nd International Joint Conference
Artificial Intelligence, pp. 989995, Barcelona, Catalonia, Spain. IJCAI/AAAI.
Osorio, M., & Cuevas, V. (2007). Updates answer set programming: approach based basic
structural properties. TPLP, 7(4), 451479.
69

fiWANG , Z HANG , Z HOU , & Z HANG

Osorio, M., & Zacarias, F. (2004). updates logic programs: properties-based approach.
Seipel, D., & Torres, J. M. T. (Eds.), FoIKS, Vol. 2942 Lecture Notes Computer Science,
pp. 231241. Springer.
Packer, H. S., Gibbins, N., & Jennings, N. R. (2011). on-line algorithm semantic forgetting. IJCAI 2011, Proceedings 22nd International Joint Conference Artificial
Intelligence, pp. 27042709, Barcelona, Catalonia, Spain. IJCAI/AAAI.
Papadimitriou, C. H. (1994). Computational complexity. Addison Wesley.
Pearce, D., Tompits, H., & Woltran, S. (2001). Encodings equilibrium logic logic programs
nested expressions. Proceedings the10th Portuguese Conference Artificial Intelligence Progress Artificial Intelligence, Knowledge Extraction, Multi-agent Systems,
Logic Programming Constraint Solving, pp. 306320, London, UK. Springer-Verlag.
Pearce, D., Tompits, H., & Woltran, S. (2009). Characterising equilibrium logic nested logic
programs: Reductions complexity. Theory Practice Logic Programming, 9(5),
565616.
Su, K., Sattar, A., Lv, G., & Zhang, Y. (2009). Variable forgetting reasoning knowledge.
Journal Artificial Intelligence Research, 35, 677716.
Truszczynski, M. (2010). Reducts propositional theories, satisfiability relations, generalizations semantics logic programs. Artificial Intelligence, 174(16-17), 12851306.
van Ditmarsch, H. P., Herzig, A., Lang, J., & Marquis, P. (2009). Introspective forgetting. Synthese,
169(2), 405423.
Visser, A. (1996). Uniform interpolation layered bisimulation. Godel96, pp. 139164.
Wang, Y., Wang, K., & Zhang, M. (2013). Forgetting answer set programs revisited. IJCAI
2013, Proceedings 23rd International Joint Conference Artificial Intelligence, pp.
11621168, Beijing, China. IJCAI/AAAI.
Wang, Y., Zhang, Y., Zhou, Y., & Zhang, M. (2012). Forgetting logic programs strong
equivalence. Principles Knowledge Representation Reasoning: Proceedings
Thirteenth International Conference, pp. 643647, Rome, Italy. AAAI Press.
Wang, Z., Wang, K., Topor, R. W., & Pan, J. Z. (2010). Forgetting knowledge bases dl-lite.
Annuals Mathematics Artificial Intelligence, 58(1-2), 117151.
Wong, K.-S. (2009). Forgetting Logic Programs. Ph.D. thesis, University New South
Wales.
Zhang, Y., & Foo, N. Y. (2006). Solving logic program conflict strong weak forgettings.
Artificial Intelligence, 170(8-9), 739778.
Zhang, Y., & Zhou, Y. (2009). Knowledge forgetting: Properties applications. Artificial Intelligence, 173(16-17), 15251537.
Zhou, Y., & Zhang, Y. (2011). Bounded forgetting. Proceedings Twenty-Fifth AAAI
Conference Artificial Intelligence, AAAI 2011, pp. 280285, San Francisco, California,
USA. AAAI Press.

70


