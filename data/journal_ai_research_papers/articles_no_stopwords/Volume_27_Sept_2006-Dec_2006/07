journal artificial intelligence

submitted published

engineering note
flucap heuristic search planner first order mdps
steffen holldobler
eldar karabaev
olga skvortsova

sh iccl tu dresden de
eldar iccl tu dresden de
skvortsova iccl tu dresden de

international center computational logic
technische universitat dresden dresden germany

abstract
present heuristic search solving first order markov decision processes fomdps combines first order state abstraction avoids evaluating states individually heuristic search avoids evaluating states firstly
contrast existing systems start propositionalizing fomdp
perform state abstraction propositionalized version apply state abstraction directly fomdp avoiding propositionalization kind abstraction referred
first order state abstraction secondly guided admissible heuristic search
restricted states reachable initial state demonstrate usefulness techniques solving fomdps system referred flucap
formerly fcplanner entered probabilistic track international competition ipc demonstrated advantage planners
represented first order terms

introduction
markov decision processes mdps adopted representational computational model decision theoretic much recent work e g barto
bradtke singh basic solution techniques mdps rely dynamic
programming dp principle boutilier dean hanks unfortunately classical dynamic programming require explicit enumeration state space grows
exponentially number variables relevant domain therefore
scale complex ai
however several methods avoid explicit state enumeration developed
recently one technique referred state abstraction exploits structure factored mdp representation solve efficiently circumventing explicit state space
enumeration boutilier et al another technique referred heuristic search
restricts computation states reachable initial state e g rtdp
barto et al envelope dp dean kaelbling kirman nicholson
lao feng hansen one existing combines techniques symbolic lao feng hansen performs heuristic
search symbolically factored mdps exploits state abstraction e manipulates sets
states instead individual states precisely following spudd hoey
st aubin hu boutilier mdp components value functions policies
admissible heuristic functions compactly represented algebraic decision diagrams
c

ai access foundation rights reserved

fiholldobler karabaev skvortsova

adds allows computations lao performed efficiently
adds
following ideas symbolic lao given initial state use admissible heuristic
restrict search states reachable initial state moreover
exploit state abstraction order avoid evaluating states individually thus
work much spirit symbolic lao extends important way
whereas symbolic lao starts propositionalization fomdp
performs state abstraction propositionalized version means
propositional adds apply state abstraction directly structure fomdp
avoiding propositionalization kind abstraction referred first order state
abstraction
recently following work boutilier reiter price holldobler skvortsova
developed referred first order value iteration fovi
exploits first order state abstraction dynamics mdp specified probabilistic fluent calculus established holldobler schneeberger
first order language reasoning states actions precisely fovi produces
logical representation value functions policies constructing first order formulae
partition state space clusters referred abstract states effect
performs value iteration top clusters obviating need explicit
state enumeration allows represented first order terms
solved without requiring explicit state enumeration propositionalization
indeed propositionalizing fomdps impractical number propositions grows considerably number domain objects relations
dramatic impact complexity depends directly number propositions finally systems solving fomdps rely propositionalizing
states propositionalize actions problematic first order domains
number ground actions grows dramatically domain size
address limitations proposing solving fomdps
combines first order state abstraction heuristic search novel way exploiting
power logical representations viewed first order generalization lao contribution perform heuristic search
first order mdps circumventing propositionalization fact
improve performance symbolic lao providing compact first order mdp representation probabilistic fluent calculus instead propositional adds alternatively
considered way improve efficiency fovi
heuristic search together symbolic dynamic programming

first order representation mdps
recently several representations propositionally factored mdps proposed
including dynamic bayesian networks boutilier et al adds hoey et al
instance spudd hoey et al used solve
mdps hundreds millions states optimally producing logical descriptions value
functions involve hundreds distinct values work demonstrates large


fiflucap heuristic search planner first order mdps

mdps described logical fashion often solved optimally exploiting logical
structure
meanwhile many realistic domains best represented first order terms
however existing implemented solutions first order mdps rely propositionalization e eliminate variables outset solution attempt instantiating terms
possible combinations domain objects technique impractical
number propositions grows dramatically number domain objects
relations
example consider following goal statement taken colored blocksworld
scenario blocks addition unique identifiers associated colors
g x x red x green x blue x red x red x
red x green x green x ower x x
ower x x represents fact eight blocks comprise one tower
assume number blocks domain color distribution agrees
goal statement namely eight blocks b h domain
four red three green one blue full propositionalization
goal statement g different ground towers
exactly many ways arranging four red three green one blue block tower
eight blocks required color characteristics
number ground combinations hence complexity reasoning propositional planner depends dramatically number blocks importantly
number colors domain fewer colors domain contains harder
solve propositional planner example goal statement g g
eight blocks color ground towers
grounded
address limitations propose concise representation fomdps within
probabilistic fluent calculus logical modelling dynamically changing
systems first order logic first briefly describe basics theory
mdps
mdps
markov decision process mdp tuple z p r c z finite set
states finite set actions p z z written p z z specifies
transition probabilities particular p z z denotes probability ending
state z given agent state z action executed r z r realvalued reward function associating state z immediate utility r z c r
real valued cost function associating cost c action sequential
decision consists mdp finding policy z
maximizes total expected discounted reward received executing policy
infinite indefinite horizon
value state z starting z following policy afterwards
computed following system linear equations
x
v z r z c z
p z z z v z
z z



fiholldobler karabaev skvortsova

discount factor take equal indefinite horizon
e goal reached system enters absorbing state
rewards costs accrued optimal value function v satisfies
x
v z r z max c
p z z v z
aa

z z

z z
competition expected total reward model used optimality criterion without discounting care required design
ensure expected total reward bounded optimal policy following
restrictions made used competition
goal statement identifying set absorbing goal states
positive reward associated transitioning goal state
cost associated action
done action available states could used end accumulation reward
conditions ensure mdp model positive bounded
model described puterman positive reward transitioning
goal state since goal states absorbing outgoing transitions
maximum value state bounded goal reward furthermore done action
ensures action available state guarantees non negative future
reward
probabilistic fluent calculus
fluent calculus fc holldobler schneeberger originally set
first order logic program equality slde resolution sole inference rule
probabilistic fluent calculus pfc extension original fc expressing
domains actions probabilistic effects
states
formally let denote set function symbols distinguish two function symbols
namely binary function symbol associative commutative admits
unit element constant let non variable terms
called fluents function names fluents referred fluent names example
x table fluent meaning informally block x table
fluent name fluent terms defined inductively follows fluent term
fluent fluent term f g fluent term f g fluent terms example
b table holding x fluent term denoting informally block b table
block x robots gripper words freely occurring variables
assumed existentially quantified


fiflucap heuristic search planner first order mdps

assume fluent may occur state moreover function
symbols except binary operator constant fluent names constants
disallowed addition binary function symbol allowed appear
outermost connective fluent term denote set fluents f set fluent
terms lf respectively abstract state defined pair p n p lf
n lf denote individual states z z z etc abstract states z z z etc
set abstract states lp n
interpretation f denoted pair domain set
finite sets ground fluents f interpretation function assigns
fluent term f set f abstract state z p n set z
follows
f f
z p n n
n
substitution example figure depicts interpretation abstract
state z
z x table x holding x
informally read exists block x block
table block x exists block x
robot holds since z contains finite sets ground fluents satisfy
p part satisfy elements n part subtract sets ground
fluents belong ni n set ground fluents correspond
p part thus bold area figure contains exactly sets ground
fluents individual states satisfy p part z none elements
n part example individual state z b table belongs z
whereas z b table holding c words abstract states
characterized means conditions must hold ground instance thereof
thus represent clusters individual states way abstract states embody
form state space abstraction kind abstraction referred first order state
abstraction
actions
actions first order terms starting action function symbol example
action picking block x another block might denoted pickup x
formally let na denote set action names disjoint action space tuple
pre eff set terms form p pn referred
actions na pi variable constant pre lp n
precondition eff lp n effect
far described deterministic actions actions pfc may
probabilistic effects well similar work boutilier et al decompose
stochastic action deterministic primitives natures control referred natures
choices use relation symbol choice model natures choice consider action
pickup x
choice pickup x
pickups x pickupf x


fiholldobler karabaev skvortsova

b table
c table b
b table holding c
c table b c
b table
c table b
b table holding c
c table b c

b


b table

c table b
b table holding c
c table b c

c
figure interpretation fluent term f x table b bold area
interpretation abstract state z x table x
c bold area interpretation abstract state z x
table x holding x



fiflucap heuristic search planner first order mdps

pickups x pickupf x define two natures choices action pickup x
viz succeeds fails example natures choice pickups defined
follows
pre pickups x x e w x
eff pickups x holding x x
fluent e denotes empty robots gripper simplicity denote set
natures choices action ch aj choice aj please note nowhere
action descriptions restrict domain discourse pre specified set
blocks
natures choices aj associated action define probability
prob aj z denoting probability one natures choices aj chosen
state z example
prob pickups x pickup x z
states probability successful execution pickup action state z

next step define reward function state example might
want give reward states block x block
otherwise
reward z z v x
reward z z v x
v denotes subsumption relation described detail section
one observe specified reward function without explicit state enumeration instead state space divided two abstract states depending whether
block x block likewise value functions specified respect
abstract states contrast classical dp states
explicitly enumerated action costs analogously defined follows
cost pickup x
penalizing execution pickup action value
inference mechanism
herein perform inferences e compute successors given abstract state
action schemata directly avoiding unnecessary grounding note computation
predecessors performed similar way
let z p n abstract state p pn action parameters
p pn preconditions pre pp np effects eff pe ne let
substitutions action p pn forward applicable simply applicable z
denoted forward z following conditions hold
f pp u ac p
f np np n n p n u ac p np


fiholldobler karabaev skvortsova

u u ac variables ac equational theory
represented following system associativity commutativity unit element
equations
eac x z x z x z
x x x
x x x

words conditions f f guarantee z contains positive
negative preconditions action action forward applicable z
zsucc p n
p pe u
n n np ne



referred successor z denoted succ z
example consider action pickups x defined take z p n
b table x b e x x action pickups x forward applicable
z x x b u b table x w u thus
zsucc succ z pickups x p n
p holding x b table n x b

first order lao
present generalization symbolic lao feng hansen
referred first order lao folao solving fomdps symbolic lao
heuristic search exploits state abstraction solving factored mdps given
initial state symbolic lao uses admissible heuristic focus computation
parts state space reachable initial state moreover specifies mdp
components value functions policies admissible heuristics propositional adds
allows symbolic lao manipulate sets states instead individual states
despite fact symbolic lao shows advantageous behaviour comparison
classical non symbolic lao hansen zilberstein evaluates states
individually suffers important drawback solving fomdps symbolic
lao propositionalizes impractical large fomdps
intention improve performance symbolic lao providing
compact first order representation mdps heuristic search performed
without propositionalization precisely propose switch representational
formalism fomdps symbolic lao propositional adds probabilistic fluent
calculus folao presented figure
symbolic lao folao two phases alternate complete solution
found guaranteed optimal first expands best partial policy
evaluates states fringe admissible heuristic function performs
dynamic programming states visited best partial policy update values
possibly revise current best partial policy note focus partial policies
map subcollection states actions


fiflucap heuristic search planner first order mdps

policyexpansion g
e f
f rom
repeat

succ z aj

zf rom aj ch

z
f f g
e e f rom
f rom g e
f rom
e e f
g g f
return e f g
fovi e prob reward cost v
repeat
v v
loop z e
loop
loop forward z
q z
p reward z cost

prob aj z v succ z aj
aj ch

end loop
end loop
v z max q z


end loop
v normalize v
r kv v k
stopping criterion
extractp olicy v
return v r
folao prob reward cost h
v h
g
z initialize arbitrary action
repeat
e f g policyexpansion g
v r fovi e prob reward cost v
f r
return v

figure first order lao
policy expansion step perform reachability analysis set f states
yet expanded reachable set initial states
following partial policy set states g contains states expanded
far expanding partial policy mean defined larger set
states dynamic programming step symbolic lao reachability analysis adds
performed means image operator symbolic model checking computes


fiholldobler karabaev skvortsova

set successor states following best current policy instead folao apply
succ operator defined equation one observe since reachability
analysis folao performed abstract states defined first order entities
reasoning successor states kept first order level contrast symbolic
lao would first instantiate possible combinations objects order
able perform computations propositional adds later
contrast symbolic lao dynamic programming step performed
modified version spudd employ modified first order value iteration
fovi original fovi holldobler skvortsova performs value iteration
entire state space modify computes states reachable
initial states precisely set e states visited best current partial policy way improve efficiency original fovi
reachability analysis together symbolic dynamic programming fovi produces
pfc representation value functions policies constructing first order formulae
partition state space abstract states effect performs value iteration
top abstract states obviating need explicit state enumeration
given fomdp value function represented pfc fovi returns best partial
value function v best partial policy residual r order update values
states z e assign values current value function successors
z compute successors respect natures choices aj residual r
computed absolute value largest difference current newly
computed value functions v v respectively note newly computed value
function v taken normalized form e normalize procedure
described section extraction best partial policy straightforward
one simply needs extract maximizing actions best partial value function v
symbolic lao folao converges optimal policy three conditions met current policy unexpanded states residual
r less predefined threshold value function initialized admissible heuristic original convergence proofs lao symbolic lao hansen
zilberstein carry straightforward way folao
calling folao initialize value function admissible heuristic
function h focuses search subset reachable states simple way create
admissible heuristic use dynamic programming compute approximate value
function therefore order obtain admissible heuristic h folao perform
several iterations original fovi start initial value function
admissible since step fovi preserves admissibility resulting value
function admissible well initial value function assigns goal reward
state thereby overestimating optimal value since goal reward maximal possible
reward
since computations folao performed abstract states instead individual
states fomdps solved avoiding explicit state action enumeration propositionalization first order reasoning leads better performance folao comparison
symbolic lao shown section


fiflucap heuristic search planner first order mdps

z
z





z
f g
z

z z
f z z
e z z z
g z z

z

z

z

g

fovia z z z





z



f
z

z
z

z z
f z
e z

b

z z
z f z z z






z
z
z

e

z z




z

z
z
g
g
z z




z
z

z


f

c

z

fovia z z z z z

figure policy expansion

policy expansion
policy expansion step folao similar one symbolic lao
therefore illustrate expansion procedure means example assume start initial state z two nondeterministic actions
applicable z two outcomes respectively without loss
generality assume current best policy chooses optimal action
state z construct successors z z z respect outcomes
action
fringe set f well set g states expanded far contain states z
z whereas set e states visited best current partial policy gets
state z addition see figure next step fovi performed set e
assume values updated way becomes optimal action
z thus successors z recomputed respect optimal action
see figure b
one observe one successors z namely z element
set g thus contained already fringe f previous expansion
step hence state z expanded value recomputed shown
figure c states z z successors z assumption
optimal action z fringe set f contains newly discovered
states z z z perform fovi e z z z z z state z
contained e belong best current partial policy


fiholldobler karabaev skvortsova

dynamic programming step performed states visited best
current partial policy
first order value iteration
folao first order value iteration fovi serves two purposes first
perform several iterations fovi order create admissible heuristic h folao
second dynamic programming step folao apply fovi states visited
best partial policy order update values possibly revise current
best partial policy
original fovi holldobler skvortsova takes finite state space
abstract states finite set stochastic actions real valued reward cost functions
initial value function input produces first order representation optimal
value function policy exploiting logical structure fomdp thus fovi
seen first order counterpart classical value iteration bellman

normalization
following ideas boutilier et al fovi relies normalization state
space represents value function normalization state space mean
equivalence preserving procedure reduces size state space would
effect state space contains redundant entries usually case symbolic
computations
although normalization considered important issue done
hand far best knowledge preliminary implementation boutilier et al performs rudimentary logical simplifications
authors suggest automated first order theorem prover normalization task
holldobler skvortsova developed automated normalization procedure
fovi given state space delivers equivalent one contains redundancy
technique employs notion subsumption relation
formally let z p n z p n abstract states z said
subsumed z written z v z exist substitutions
following conditions hold
p u ac p
n n n n p n u ac p n
u u ac variables motivation notion subsumption
abstract states inherited notion subsumption first order clauses
robinson difference abstract states contain complicated negative parts contrast first order clauses
example consider two abstract states z z defined follows
z x table red
z x red x


fiflucap heuristic search planner first order mdps

n











number states
supdate
snorm





















time msec
update norm





















runtime msec

runtime w norm msec


















n
n
n
n

table representative timing first ten iterations fovi
z informally asserts block x block table
blocks red whereas z informally states block x block
x red z v z relation holds since conditions
satisfied indeed
x u ac x table

x table red u x table red x
x x u table x u
one note subsumption language abstract states inherits complexity bounds subsumption kapur narendran namely deciding subsumption two abstract states np complete general however karabaev et al
recently developed efficient delivers solutions subsumption case abstract states fluent terms
purpose normalization convenient represent value function
set pairs form hz z abstract state real value essence
normalization seen exhaustive application following simplification rule value function v
hz hz
z v z
hz
table illustrates importance normalization providing representative timing first ten iterations fovi experiments carried
taken colored blocksworld scenario consisting ten blocks
even relatively simple fovi normalization switched
scale beyond sixth iteration
table demonstrate normalization iteration
fovi dramatically shrinks computational effort next iterations columns
labelled supdate snorm size state space performing value updates


fiholldobler karabaev skvortsova

normalization respectively example normalization factor e ratio
number supdate states obtained performing one update step
number snorm states obtained performing normalization step seventh
iteration means ninety percent state space contained
redundant information fourth fifth columns table contain time update
norm spent performing value updates normalization respectively
total runtime runtime normalization switched given sixth column
seventh column labelled runtime w norm depicts total runtime fovi
normalization switched would sum values seventh column
values sixth column sixth iteration inclusively subtract latter
former divide total time norm needed performing normalization
first six iterations would obtain normalization gain three
orders magnitude

experimental evaluation
demonstrate advantages combining heuristic search together first order
state abstraction system referred flucap successfully entered
probabilistic track international competition ipc experimental obtained redhat linux running ghz pentium iv
machine gb ram
table present performance comparison flucap together symbolic
lao examples taken colored blocksworld bw scenario introduced
ipc
main objective investigate whether first order state abstraction logic
could improve computational behaviour system solving fomdps
colored bw main interest since ones represented
first order terms hence ones allowed us make use first order
state abstraction therefore concentrated design domain dependent
system tuned taken blocksworld scenario
colored bw differ classical bw ones along
unique identifier block assigned specific color goal formula specified firstorder terms provides arrangement colors instead arrangement blocks
outset solving colored bw symbolic lao starts propositionalizing components namely goal statement actions abstraction
propositional adds applied contrast flucap performs first order abstraction colored bw directly avoiding unnecessary grounding following
abstraction technique affects computation heuristic function
create admissible heuristic flucap performs twenty iterations fovi symbolic
lao performs twenty iterations approximate value iteration similar
apricodd st aubin hoey boutilier columns labelled h time
nas time needed computing heuristic function number abstract
states covers respectively comparison flucap symbolic lao needs evaluate
fewer abstract states heuristic function takes considerably time one


fiflucap heuristic search planner first order mdps

flucap

flucap












n




n
n
n
n
n
n
n
n
n
n

lao

lao

flucap

fovi

flucap

lao

flucap










n n n
n n n
n n
n n n
n n n

























n
n
n
n
n

























n
n

n
n










n
n
n
n
n































table performance comparison flucap denoted flucap symbolic lao
denoted lao cells n denote fact planner
deliver solution within time limit one hour nas ngs number
abstract ground states respectively

conclude abstract states symbolic lao enjoy complex structure
flucap
note comparison fovi flucap restricts value iteration smaller
state space intuitively value function delivered fovi covers larger
state space time allocated heuristic search flucap
used performing additional iterations fovi column labelled
justify harder colors contains higher
percentage runtime spent normalization almost test effort spent
normalization takes three percent total runtime average
order compare heuristic accuracy present column labelled ngs
number ground states heuristic assigns non zero values one see
heuristics returned flucap symbolic lao similar accuracy flucap
takes much less time compute reflects advantage plain first order
abstraction comparison marriage propositionalization abstraction
propositional adds examples gain several orders magnitude h time
column labelled total time presents time needed solve
time planner must execute runs initial state goal state one hour block
allocated note comparison flucap time required
heuristic search symbolic lao e difference total time h time grows
considerably faster size reflects potential employing




fovi













n
n
n
n
n

ngs

nas
flucap


















h time sec
lao












n
n
n
n
n

total time sec

flucap



fovi



c















flucap

b

total av reward
lao



fiholldobler karabaev skvortsova

b










total av reward








n

total time sec








n

h time sec








n

nas








n

ngs








n

table performance flucap larger instances one color blocksworld
cells n denote fact planner deliver solution within
time limit

first order abstraction instead abstraction propositional adds heuristic
search
average reward obtained runs shown column total av reward
planners evaluation score reward value close maximum possible
reward simply indicates planner found reasonably good policy time
number blocks b increases running time symbolic lao increases roughly
times thus could scale seven blocks
contrast flucap could solve seventeen blocks note
number colors c affects efficiency abstraction technique
flucap c decreases abstraction rate increases turn reflected
dramatic decrease runtime opposite holds symbolic lao
addition compare flucap two variants first one denoted fovi
performs heuristic search rather employs fovi compute optimal
total value function policy extracted second one denoted flucap
performs trivial heuristic search starting initial value function admissible
heuristic expected flucap combines heuristic search fovi demonstrates
advantage plain fovi trivial heuristic search illustrate
significance heuristic search general flucap vs fovi importance heuristic
accuracy particular flucap vs flucap fovi flucap scale
seven blocks
table presents performance flucap larger instances one color
bw number blocks varying twenty thirty four believe
flucap scale larger size implementation yet
well optimized general believe flucap system sensitive
size propositional planners
experiments targeted one color
one hand simplest ones us hand bottleneck propositional
planners structure one color allows us apply first order state abstraction full power example blocks flucap operates
thousand abstract states explode individual states proposition

fiflucap heuristic search planner first order mdps

total av reward
umass

michigan

purdue

purdue

purdue

caracas

toulouse

c










dresden

b










canberra


















n
n
n
n

n
n
n

n
n
n
n
n

n
n
n
n
n
n
n
n
n




























n


n
n
n




n
n

n
n
n

n
n
n
n
n

table official competition colored non colored blocksworld scenarios
may n entries table indicate planner
successful solving attempt solve

alization propositional planner must highly optimized order cope
non trivial state space
note additional colors larger instances blocks bw
cause dramatic increase computational time consider
unsolved one observe number abstract states nas increases
number blocks non monotonically generated randomly
example blocks happens harder blocks one finally
note appear tables obtained version
evaluation software rely propositionalization contrast initial
version used competition
table presents competition ipc flucap competitive
comparison planners colored bw flucap perform
well non colored bw propositional ones
goal statements initial states ground flucap yet incorporate
optimization techniques applied modern propositional planners contestants
indicated origin example dresden flucap umass symbolic lao etc
pickup action cost gain five points total reward means
plan contains ten fewer actions average competition domains log files
available online appendix younes littman weissman asmuth
although empirical presented work obtained
domain dependent version flucap recently developed karabaev et al
efficient domain independent inference mechanism core domainindependent version flucap


fiholldobler karabaev skvortsova

related work
follow symbolic dp sdp within situation calculus sc boutilier
et al first order state abstraction fomdps one difference
representation language use pfc instead sc course symbolic value iteration state space may contain redundant abstract states dramatically affect
efficiency order achieve computational savings normalization must performed remove redundancy however original work boutilier et al
done hand best knowledge preliminary implementation
sdp within sc uses human provided rewrite rules logical simplification
contrast holldobler skvortsova developed automated normalization
procedure fovi incorporated competition version flucap brings
computational gain several orders magnitude another crucial difference
uses heuristic search limit number states policy computed
rebel kersting van otterlo de raedt relates folao
uses representation language simpler situation calculus
feature makes state space normalization computationally feasible
motivation closely connected relational envelope
rebp gardiol kaelbling represents mdp dynamics compact set
relational rules extends envelope method dean et al however rebp
propositionalizes actions first afterwards employs abstraction equivalenceclass sampling contrast folao directly applies state action abstraction
first order structure mdp respect rebp closer symbolic lao
folao moreover contrast pfc action descriptions rebp allow negation
appear preconditions effects organization folao symbolic lao
similar real time dp barto et al online search mdps
contrast folao works offline
classified deductive approaches solving fomdps
characterized following features model
aim exact solutions logical reasoning methods used compute abstractions
note fovi aims exact solution fomdp whereas folao due
heuristic search avoids evaluating states seeks approximate solution
therefore would appropriate classify folao approximate deductive
fomdps
another vein developing inductive approaches solving
fomdps e g fern yoon givan authors propose approximate
policy iteration api replace use cost function approximations
policy representations api direct compact state action mappings use
standard relational learner learn mappings effect fern et al provide policylanguage biases enable solution large relational mdps inductive approaches
characterized following features model free aim
approximate solutions abstract model used generate biased samples
underlying fomdp abstract model altered
recent gretton thiebaux proposes inductive policy construction strikes middle ground deductive inductive tech

fiflucap heuristic search planner first order mdps

niques idea use reasoning particular first order regression automatically
generate hypothesis language used input inductive solver
gretton thiebaux related sdp sense
first order domain specification language well logical reasoning employed

conclusions
proposed combines heuristic search first order state abstraction solving fomdps efficiently seen two fold
first use dynamic programming compute approximate value function serves
admissible heuristic heuristic search performed exact solution
states reachable initial state phases exploit
power first order state abstraction order avoid evaluating states individually
experimental breaks ground exploring efficiency
first order representations solving mdps comparison existing mdp planners
must propositionalize domain e g symbolic lao solution scales better larger
fomdps
however plenty remaining done example interested
question extent optimization techniques applied modern propositional
planners combined first order state abstraction future competitions
would face goal initial states partially defined
underlying domain contains infinitely many objects
current version folao targeted allow efficient
first order state abstraction precisely polynomially translated pfc example colored bw domain existentially closed
goal descriptions linearly translated equivalent pfc representation whereas
universally closed goal descriptions would require full propositionalization thus current version pfc less first order expressive e g situation calculus future
would interesting study extensions pfc language particular
trade pfcs expressive power tractability solution methods
fomdps pfc

acknowledgements
grateful anonymous reviewers thorough reading previous versions thank zhengzhu feng fruitful discussions
providing us executable symbolic lao planner greatly appreciate
david e smith patience encouragement valuable comments helped
us improve olga skvortsova supported grant within graduate programme grk specification discrete processes systems processes
operational logics auspices deutsche forschungsgemeinschaft
dfg


fiholldobler karabaev skvortsova

references
barto g bradtke j singh p learning act real time dynamic
programming artificial intelligence
bellman r e dynamic programming princeton university press princeton nj
usa
boutilier c dean hanks decision theoretic structural assumptions computational leverage journal artificial intelligence

boutilier c reiter r price b symbolic dynamic programming firstorder mdps nebel b ed proceedings seventeenth international conference artificial intelligence ijcai pp morgan kaufmann
dean kaelbling l kirman j nicholson time constraints
stochastic domains artificial intelligence
feng z hansen e symbolic heuristic search factored markov decision processes dechter r kearns sutton r eds proceedings eighteenth
national conference artificial intelligence aaai pp edmonton
canada aaai press
fern yoon givan r approximate policy iteration policy language
bias thrun saul l scholkopf b eds proceedings seventeenth annual conference neural information processing systems nips vancouver
canada mit press
gardiol n kaelbling l envelope relational mdps thrun
saul l scholkopf b eds proceedings seventeenth annual conference
neural information processing systems nips vancouver canada mit
press
gretton c thiebaux exploiting first order regression inductive policy
selection chickering halpern j eds proceedings twentieth conference uncertainty artificial intelligence uai banff canada morgan
kaufmann
hansen e zilberstein lao heuristic search finds solutions
loops artificial intelligence
hoey j st aubin r hu boutilier c spudd stochastic
decision diagrams laskey k b prade h eds proceedings fifteenth conference uncertainty artificial intelligence uai pp
stockholm morgan kaufmann
holldobler schneeberger j deductive
generation computing
holldobler skvortsova logic dynamic programming
proceedings workshop learning markov processes
advances challenges nineteenth national conference artificial intelligence aaai pp san jose ca aaai press


fiflucap heuristic search planner first order mdps

kapur narendran p np completeness set unification matching
siekmann j h ed proceedings eighth international conference automated deduction cade pp oxford england springer
verlag
karabaev e ramme g skvortsova efficient symbolic reasoning firstorder mdps proceedings workshop learning monitoring
uncertainty dynamic worlds seventeenth european conference
artificial intelligence ecai riva del garda italy appear
kersting k van otterlo de raedt l bellman goes relational brodley
c e ed proceedings twenty first international conference machine
learning icml pp banff canada acm
puterman l markov decision processes discrete stochastic dynamic programming john wiley sons inc york ny
robinson j machine learning logic resolution principle journal
association computing machinery
st aubin r hoey h boutilier c apricodd approximate policy construction decision diagrams leen k dietterich g tresp v eds
proceedings fourteenth annual conference neural information processing
systems nips pp denver mit press
younes h littman weissman asmuth j first probabilistic track
international competition journal artificial intelligence





