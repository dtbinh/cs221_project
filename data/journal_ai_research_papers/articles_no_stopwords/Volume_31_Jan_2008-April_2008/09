journal artificial intelligence

submitted published

complexity
simple causal graphs
omer gimenez

omer gimenez upc edu

dept de llenguatges sistemes informatics
universitat politecnica de catalunya
jordi girona
barcelona spain

anders jonsson

anders jonsson upf edu

dept information communication technologies
passeig de circumvallacio
barcelona spain

abstract
present three complexity classes simple
causal graphs first describe polynomial time uses macros generate plans class binary state variables acyclic
causal graphs implies plan generation may tractable even
exponentially long minimal solution prove
plan existence multi valued variables chain causal graphs
np hard finally plan existence binary state
variables polytree causal graphs np complete

introduction
area artificial intelligence aims achieve autonomous
control complex systems formally obtain sequence
transformations moving system initial state goal state given description
possible transformations successfully used variety
applications including robotics process information gathering autonomous
agents spacecraft mission control seen significant progress
last ten years part due establishment international
competition
important aspect classify complexity solving
able classify according complexity
makes possible select right tool solving researchers usually distinguish
two plan generation generating sequence transformations achieving goal plan existence determining whether
sequence exists original strips formalism used plan existence undecidable first order case chapman pspace complete propositional
case bylander pddl representation language used international
competition plan existence expspace complete erol nau subrahmanian however usually exhibit structure makes much
c

ai access foundation rights reserved

figimenez jonsson

easier solve helmert showed many benchmark used
international competition fact p np
common type structure researchers used characterize called causal graph knoblock causal graph
graph captures degree independence among state variables
easily constructed given description transformations independence state variables exploited devise
efficiently solving causal graph used tool
describing tractable subclasses brafman domshlak jonsson
backstrom williams nayak decomposing
smaller brafman domshlak jonsson knoblock
basis domain independent heuristics guide search valid plan helmert

present work explore computational complexity solving simple causal graphs present three classes studied literature class jonsson backstrom class cn
domshlak dinitz class polytree causal graphs
brafman domshlak brief plan generation instances
first class solved polynomial time macros plan existence
solvable polynomial time remaining two classes unless p np work first
appeared conference gimenez jonsson current provides
detail additional insights well sections plan length cp nets
belongs class causal graph acyclic state
variables static symmetrically reversible splitting see section precise definition terms class introduced studied jonsson
backstrom example class plan existence easy exists
polynomial time determines whether particular
class solvable plan generation hard exists polynomial time generates valid plan every class precisely
jonsson backstrom showed class
every valid plan exponentially long clearly prevents existence efficient
plan generation
first contribution plan generation fact easy
allowed express valid plan macros macro simply sequence operators
macros present polynomial time produces valid plans
form class namely outputs polynomial
time system macros executed produce actual valid plan
instance sound complete generates valid plan
one exists contrast incremental proposed
jonsson backstrom polynomial size output
investigate complexity class cn multivalued state variables chain causal graphs words causal graph
directed path domshlak dinitz showed solvable instances
class require exponentially long plans however case class
could exist efficient procedure generating valid plans cn instances


ficomplexity

macros novel idea plan existence cn np hard hence
ruling efficient procedure exists unless p np
prove plan existence whose causal graph polytree e underlying undirected graph acyclic np complete even restrict
binary variables closes complexity gap appears brafman domshlak regarding binary variables authors
plan existence np complete singly connected causal
graphs plan generation polynomial polytree causal
graphs bounded indegree use reduction prove similar
polytree cp nets boutilier brafman domshlak hoos poole np complete
related work
several researchers used causal graph devise solving
study complexity knoblock used
causal graph decompose hierarchy increasingly abstract
certain conditions solving hierarchy abstract easier
solving original williams nayak introduced several restrictions
ensure tractability one causal graph
acyclic jonsson backstrom defined class
requires causal graphs acyclic showed plan existence polynomial
class
domshlak dinitz analyzed complexity several classes
acyclic causal graphs brafman domshlak designed polynomialtime solving binary state variables acyclic causal
graph bounded indegree brafman domshlak identified conditions
possible factorize several subproblems solve
subproblems independently claimed suitable
factorization causal graph bounded tree width
idea macros almost old fikes nilsson
minton developed measures utility plan fragments
stores macros deemed useful korf showed macros
exponentially reduce search space size chosen carefully vidal
used relaxed plans generated computing heuristics produce macros
contribute solution macro botea enzenberger muller
schaeffer identifies caches macros competed fourth
international competition authors showed macros help reduce
search effort necessary generate valid plan
jonsson described uses macros generate plans
tree reducible causal graphs exist
generate exponentially long solutions polynomial time unlike handle multi valued variables enables
solve towers hanoi however
tree reducible causal graphs cannot used plan generation
polynomial


figimenez jonsson

hardness plan length
contribution plan generation may polynomial even
exponential length minimal solutions provided solutions may
expressed concise notation macros motivate
discuss consequences previously thought plan generation
exponential length minimal solutions harder np since
known whether np intractable certain cannot generate
exponential length output polynomial time
however exponential length minimal solution
clear plan generation inherently hard difficulty lies fact
plan long consider two functional
f f w f
f f w f f
f cnf formula f number clauses f w k word containing
k copies symbol f f satisfiable e f sat
cases consists generating correct word observe
f f provably intractable since output exponential size input
nevertheless intuitive regard f easier f one way
formalize intuition allow programs produce output succinct
notation instance allow programs write w k instead string containing
k copies symbol f becomes polynomial f
unless p np
wanted investigate following question regarding class plan generation intractable solution plans long f intrinsically hard f answer plan generation solved polynomial
time provided one allowed give solution terms macros macro
simple substitution scheme sequence operators macros back
claim present solves plan generation polynomial time
researchers argued intractability fact plans may exponential length domshlak dinitz proved complexity several classes
multi valued state variables simple causal graphs argued
class cn chain causal graphs intractable since plans
may exponential length brafman domshlak stated plan generation
strips unary operators acyclic causal graphs intractable
reasoning puts question argument used prove
hardness reason analyze complexity
prove hard showing plan existence np hard

notation
let v set state variables let v finite domain state variable v v
define state function v maps state variable v v value
v v domain partial state p function subset vp v state


ficomplexity

variables maps state variable v vp p v v subset c v
state variables p c partial state obtained restricting domain p vp c
sometimes use notation v x vk xk denote partial state p defined
vp v vk p vi xi vi vp write p v denote v
vp
two partial states p q match denote pq p vq q vp
e v vp vq p v q v define replacement operator q
r two partial states p q r partial state defined vp vq vr p v r v
v vr p v q v v vq vr note general p q q p
partial state p subsumes partial state q denote p q pq
vp vq remark p q r follows p r q difference
two partial states q r denote q r partial state p defined
vp v vq q v r v p v q v v vp
tuple p hv init goal ai v set variables
init initial state goal partial goal state set operators operator
hpre post consists partial state pre called pre condition
partial state post called post condition operator applicable state
spre applying operator state state post
valid plan p sequence operators sequentially applicable state init
resulting state satisfies goal
causal graph p directed graph v e state variables
nodes edge u v e u v exists operator
u vpre vpost v vpost

class
jonsson backstrom introduced class study
relative complexity plan existence plan generation section introduce
additional notation needed describe class illustrate properties
begin defining class
definition p belongs class causal graph acyclic
state variable v v binary static symmetrically reversible
splitting
provide formal definitions static symmetrically reversible splitting
note fact causal graph acyclic implies operators unary e
operator vpost without loss generality assume
normal form mean following
state variable v v init v
post v x x implies pre v x
satisfy first condition relabel values v initial goal
states well pre post conditions operators satisfy second condition
operator post v x pre v x remove


figimenez jonsson

v

v

u
v
v

v

w
w
w

w

v



u
v
v





v

w
w
w

w



v



v

w

b

figure causal graph splitting variable partitions v b w
pre v x let pre v x previously undefined resulting
normal form equivalent original one process done
time v
following definitions describe three categories state variables
definition state variable v v static one following holds
exist post v
goal v exist post v
definition state variable v v reversible
post v x exists post v x addition v
symmetrically reversible pre v v pre v v
definitions follows value static state variable cannot
must change whereas value symmetrically reversible state variable change
freely long possible satisfy pre conditions operators change
value third category state variables splitting informally splitting state variable
v splits causal graph three disjoint subgraphs one depends value
v one depends v one independent v however
precise definition involved need additional notation
v v let qv subset state variables different v whose value
changed operator v pre condition formally qv u v v
pre v u vpost define qv way v let
gv v e v subgraph v e whose edges exclude v qv qv
formally e v e v w w qv w
qv finally let v v v subset state
variables weakly connected state variable qv graph gv define
v v way v
definition state variable v v splitting v v v v disjoint
figure illustrates causal graph two splitting state
variables v w edge label v indicates operators changing
value u v pre condition words qv u w graph
gv v e v excludes two edges labeled v v v includes state state variables


ficomplexity

since v weakly connected u w connects remaining state variables set
qv empty since operators changing value state variable
v v pre condition consequently v v empty well figure shows
resulting partition v
w
w
case w qw
g v e excludes edge labeled w
w
v since state variable connected edge w removed
likewise v w use vw v v w v w denote set remaining state
variables belong neither v w v w figure b shows resulting partition
w
lemma splitting state variable v two sets v v v v non empty
v belongs neither v v v v
proof contradiction assume v belongs v v v weakly connected
state variable qv graph gv v e v since e v exclude edges
v qv state variable qv weakly connected state variable
qv gv consequently state variables qv belong v v v v contradicts
v splitting reasoning holds v belong v v
lemma value splitting state variable never needs change twice
valid plan
proof assume valid plan changes value splitting state variable v
least three times reorder operators way
value v need change twice need address three cases v
belongs v v cf figure v belongs v v v belongs vv cf figure b
v belongs v v follows lemma v v empty consequently
operator plan requires v pre condition thus safely remove
operators change value v except possibly last needed case
goal v v belongs v v follows lemma v v empty thus
operator plan requires v pre condition first operator changes
value v necessary set v safely remove operators
change value v except last case goal v cases resulting
plan contains two operators changing value v
v belongs vv edges v v v v vv v vv
qv v v qv v v let subsequences operators
affect state variables v v v v vv respectively write h av av
last operator changes value v claim reordering
h av plan still valid indeed operators require v
holds initial state operators require v holds
due operator av note operators changing value v safely
removed since value v never needed pre condition change value
state variable vv valid plan changes value v twice
value may reset



figimenez jonsson

variable
v
v
v
v
v
v
v
v

operators
av h v v
av h v v
av h v v v
av h v v v v
av
av
av
av
av

h v
h v
h v
h v
h v

v
v
v
v
v

v v
v
v
v
v v

v vi
v

v vi
v


v v
v v

v

v
v v v


v




v


table operators sets v vi v vi example

v
v

v
v

v
v

v

v

figure causal graph example
previous lemma holds splitting state variables general provides
additional insight solve splitting state variable v
first try achieve goal state state variables v v value v
initial state set value v try achieve goal state state
variables v v finally goal v reset value v
example
illustrate class example set state variables
v v v since normal form initial state
init vi vi v goal state defined goal v v
operators listed table figure shows causal graph v e
operators easy verify v static v
v symmetrically reversible remaining
state variables splitting table lists two sets v vi v vi state
variable vi v indeed v vi v vi state variables set
v v v v v


ficomplexity

plan generation
section present polynomial time plan generation
produces solution instance form system macros
idea construct unary macros change value single state variable
macros may change values state variables execution reset
terminating macros generated goal achieved
one state variable time generates valid plan
one exists
begin defining macros use next describe
pseudo code figures prove correctness facilitate
reading moved straightforward involving proof appendix following
description analyze complexity steps involved
follows assume normal form defined previous
section
macros
macro operator macro short ordered sequence operators viewed unit
operator sequence respect pre conditions operators follow
pre condition operator sequence violated applying macro
equivalent applying operators sequence given order semantically
macro equivalent standard operator pre condition postcondition unambiguously induced pre post conditions operators
sequence
since macros functionally operators operator sequence associated macro
include macros long create circular definition consequently
possible create hierarchies macros operator sequences macros
one level include macros level solution
viewed macro sits top hierarchy
define macros first introduce concept induced pre post conditions
operator sequences ha ak operator sequence write k
denote subsequence ha ai
definition operator sequence ha ak induces pre condition pre
pre ak pre post condition post post post ak addition
operator sequence well defined pre post pre ai
k
follows assume p v init goal
vpost vpre operator ha ak operator sequence
lemma p type vpost vpre
proof direct consequence definitions vpre vpre vpre ak vpost
vpost vpost ak


figimenez jonsson

lemma operator sequence applicable state well defined
spre state sk resulting application sk post
proof induction k clearly holds k k note
pre pre ak pre k post post k post ak well defined
k well defined pre k post k pre ak
hypothesis induction state sk resulting application k
sk post k follows sk sk post ak post
assume applicable state means k applicable ak
applicable sk post k hypothesis induction former implies
spre k k well defined latter post k pre ak
last condition implies pre k post k pre ak use pre k
consequence spre k total state finally deduce
pre ak pre k spre k post k pre ak
vpost k vpre k follows well defined spre
conversely assume well defined spre implies k
well defined spre k hypothesis induction k applicable state
remains ak applicable state sk post k pre ak
pre k post k pre ak follows post k pre ak fact
pre ak pre k vpost k vpre k completes proof
since macros induced pre post conditions lemmas trivially extend
case operator sequence includes macros ready
introduce definition macros
definition macro sequence ha ak operators macros
induces pre condition pre pre post condition post post
pre macro well defined circular definitions occur
well defined
make macros consistent standard operators induced post condition
include state variables whose values indeed changed macro achieved
computing difference post pre particular holds
normal form derived macros satisfy second condition normal
form namely post v x x implies pre v x
definition let ancv set ancestors state variable v
define partial state prev vprev ancv
prev u u ancv splitting v v u
prev u otherwise
definition macro macro well defined x post
v x pre prev v x


ficomplexity

macro
mv
mv
mv
mv
mv
mv
mv
mv
mv

sequence

pre condition

hav
hav
hmv av mv
hav
hav
hav
hav
hmv av mv
hav

v
v
v
v
v
v
v
v
v



v
v
v
v
v
v
v


v
v


v
v

post condition





v

v
v
v
v
v
v
v
v
v











table macros generated example

present generates macros fact generates one
macro mvx post v x state variable v value x
illustrate idea macros give flavor table lists macros
generated example previous section
claim macro macro example operator sequence hav
induces pre condition v v post condition v v v
v v thus macro mv induces pre condition pre mv v v
post condition post mv v v v v v since v
v splitting since v v v v v v follows prev v
v v v v pre mv v v prev v
macros combined produce solution idea
identify state variable v goal v append macro mv
solution plan example operator sequence hmv mv however
pre condition mv specifies v v makes necessary insert mv
mv mv addition pre condition mv specifies v makes
necessary insert mv mv resulting final plan hmv mv mv mv mv
note order macros matter mv requires v mv requires
v splitting state variable v goal state achieved state
variables v v value v set expand solution plan
consists solely operators example operator sequence
hav av av av av av av av av case generates optimal
plan although true general
description
proceed providing detailed description plan generation
first describe subroutine generating unary macro sets value state
variable v x call generatemacro described figure
takes input p state variable v value x


figimenez jonsson
















function generatemacro p v x
post v x
hi
satisf true
u u vpre v pre u
u u increasing topological order
u static mu

satisf false
else u splitting mu mu
hs mu
hmu
satisf
return hs
return f ail
figure generating macro sets value v x

set macros vs ancestors causal graph prior executing
perform topological sort state variables assume
v v x contains one macro mvx post mvx v x
use notation mvx test whether contains mvx
operator sets value v x determines whether
possible satisfy pre condition pre starting initial state
finds set u state variables pre assigns values
state variables already satisfy pre initial state constructs two
sequences operators going state variables u increasing
topological order operator sequence use hs oi shorthand denote
operator sequence length consisting operators followed
operator macro possible satisfy pre condition pre
operator returns macro hs otherwise returns f ail
lemma v symmetrically reversible generatemacro p v successfully generates macro generatemacro p v
proof assume generatemacro p v successfully returns macro hs
operator post definition symmetrically
reversible follows exists operator post
pre v v pre v v thus set u identical
consequence values satisf loop
means generatemacro p v returns macro hs note
generatemacro p v may return another macro goes operators different order however guaranteed successfully return macro
theorem macros macros generatemacro p v x
generates macro mvx f ail mvx macro


ficomplexity












function macro p

v v increasing topological order
mv generatemacro p v
mv generatemacro p v
mv f ail mv f ail
mv mv
else mv f ail goal v
mv
return generateplan p v
figure macro
proof theorem appears appendix

next describe plan generation call macro
figure shows pseudocode macro goes state variables
increasing topological order attempts generate two macros state variable
v mv mv macros successfully generated added current
set macros mv generated goal state assign v
adds mv finally generates plan subroutine
generateplan describe later
lemma let p let v v state variable
exists valid plan solving p sets v macro p adds macro mv
addition plan resets v macro p adds mv
proof first note mv mv generated macro p adds
mv generated mv macro p adds mv unless goal v however
goal v contradicts fact valid plan solving p sets v
without resetting remains generatemacro p v
generates mv f ail generatemacro p v generates mv f ail
plan resets v
plan solving p sets v contain operator
post v plan resets v contain operator
post v generatemacro p v successfully generates
mv f ail operator selected line note may return another
macro selects another operator however generates macro
guaranteed successfully return macro mv f ail true mv
prove lemma induction state variables v v ancestors
causal graph set u empty default thus satisf never set false
generatemacro p v successfully returns macro mv hai exists
generatemacro p v successfully returns mv ha
v ancestors causal graph let u u vpre v pre u
since plan contains set u u hypothesis induction
macro p adds mu u u consequence satisf never set


figimenez jonsson



















function generateplan p w
w
return hi
v first variable topological order present w
v splitting
v generate plan p w v v v
v generate plan p w v v v
v generate plan p w v v v v v v
v f ail v f ail v f ail goal v mv

return f ail
else mv
return hv v v
else goal v return hv v mv v mv
else return hv v mv v
generate plan p w v
f ail goal v mv
return f ail
else goal v return h mv
else return
figure generating final plan

false thus generatemacro p v successfully returns mv exists
let w w vpre v pre w plan contains set
w w hypothesis induction macro p adds mw
w w
consequently generatemacro p v successfully returns mv
finally describe subroutine generateplan p w generating final
plan given p set state variables w set macros
set state variables empty generateplan p w returns empty operator
sequence otherwise finds state variable v w comes first topological order
v splitting separates w three sets described v v v v
vv v v v v v recursively generates plans three sets
necessary inserts mv v v v v final plan case
recursively generates plan w v goal v mv
appends mv end resulting plan
lemma let w plan generated generateplan p w let v
first state variable topological order present w let v ha w b final
plan generated macro p mv follows pre post pre mv
proof determine content operator sequence precedes w final
plan inspection note call generateplan p w nested within
sequence recursive calls generateplan starting generateplan p v
let z set state variables u z first state variable
topological order call generateplan prior generateplan p w
u z correspond call generateplan set state variables
u w u u splitting u contribute since


ficomplexity

possible addition macro plan line places macro mu end
plan generated recursively
assume u z splitting state variable three cases w v u w v u
w vu v v u v u w vu u contribute since never places
macros u w v u plan u part since precedes u lines
w v u plans u u part since precede u
cases mu macro mu part since precedes u lines
macros part
since macros unary plan generated generateplan p u
changes values state variables u splitting state variable u
edges vu u v u vu u v u v u v u follows
plan u change value state variable appears pre condition
macro u holds u respect u u respect u
thus macro changes value splitting state variable u ancv
mu case w v u
recall prev defined ancv assigns u u splitting
v v u ancestors v value holds initial state
altered u splitting v v u follows definition macros
pre mv u pre mv u pre mv u correct append mu
mv satisfy pre mv u mu
follows u
vpre mv since pre mv u
would caused generatemacro p v set satisf false line thus
pre condition pre mv mv agrees pre post value state
variable means two partial states match
lemma generateplan p v generates well defined plan
proof note state variable v v generateplan p w called
precisely v first state variable topological order lemma
follows pre post pre mv plan precedes w
final plan since v first state variable topological order w plans v
v v recursively generated generateplan change value
state variable pre mv follows mv applicable following ha v v ha
since mv changes value v mv applicable following ha v v mv v
theorem macro p generates valid plan solving
one exists
proof generateplan p v returns f ail exists state variable
v v goal v mv
lemma follows
exist valid plan solving p sets v consequently exist
plan solving p otherwise generateplan p v returns well defined plan due
lemma since plan sets state variable v goal v
resets state variable v goal v plan valid plan solving



figimenez jonsson

v

v

v

v

v

figure causal graph p
examples
illustrate example introduced jonsson backstrom
instances exponentially sized minimal solutions let pn
hv init goal ai defined natural number n v v vn
goal state defined vgoal v goal vi vi v vn
goal vn state variable vi v two operators
av h v vi vi vi vi
av h v vi vi vi vi
words state variable symmetrically reversible causal graph p shown figure note state variable vi v vn
v
v
pre vi pre vi vi qv vi q vi since
edge causal graph vi vi state variable v vn
v
splitting hand vn vn splitting since v n v vn v vn
backstrom nebel showed length shortest plan solving pn n
e exponential number state variables
state variable vi v vn generates two macros mv
vi
single operator av changes value vi pre av
assigns vi u vi since vi splitting mv defined mv
v
v
v
v
hm av similarly mv defined mv hm av state variable
vn u vn splitting mv n defined mv n hav n
generate final plan goes state variables topological order state variables v vn nothing since
state variables splitting goal state state variable vn
recursively generates plan vn hmv n since goal vn
v
since goal vn inserts n mv n satisfy pre condition
v
vn n mv n achieve goal state goal vn thus final plan
vn
v
vn
hm n expand plan end sequence n operators however individual macro operator sequence length greater together
macros recursively specify complete solution
demonstrate polynomial length
solutions may generate exponential length solutions
modify pn letting goal vi vi v addition
state variable vi v add two operators
bv h v vi vi vi
bv h v vi vi vi


ficomplexity

add operator cv n h vn vn vn consequence state variables v vn still symmetrically reversible splitting
vn symmetrically reversible longer splitting since pre av n vn
v
v
pre cv n vn implies vn v n v n vn still splitting since v vn v vn
assume generatemacro p vi x selects bvxi first consequence
state variable vi v x generatemacro p vi x generates
v
v
macro mvxi hm mv bvxi mv
let li length plan represented mvxi x definition
v

mx li l li induction li
length macro v l
li








generate final plan change value state variable
total length plan l l ln n
n however exists plan length n solves
namely hbv bv n
complexity
section prove complexity polynomial
analyze step separately summary complexity
step given note number edges e causal
graph v since operator may introduce v edges complexity
v e v topological sort follows cormen leiserson rivest
stein
constructing causal graph g v e
calculating v v v v v v
performing topological sort g
generatemacro p v x
generateplan p v
macro p

v
v
v
v
v
v

lemma
lemma
lemma
lemma
theorem

lemma complexity constructing causal graph g v e v
proof causal graph consists v nodes operator state
variable u vpre add edge u unique state variable v vpost
worst case vpre v case complexity v
lemma complexity calculating sets v v v v state variable
v v v
proof state variable v v establish sets qv qv requires
going operator worst case note interested
pre condition v unique state variable vpost means


figimenez jonsson

need go state variable vpre next construct graph gv
copying causal graph g takes time v removing
edges v qv qv takes time v
finally construct set v v state variable weakly connected state variable u qv graph gv state variable u qv
performing undirected search starting u takes time v performed search starting u need search state variables qv
reached search way total complexity search exceed
v case constructing v v identical since perform
procedure state variable v v total complexity step v
lemma complexity generatemacro p v x v
proof operator generatemacro p v x needs check whether
post v x worst case u v case complexity
v
lemma complexity generateplan p v v
proof note state variable v v generateplan p v called recursively exactly v first variable topological order words
generateplan p v called exactly v times generateplan p v contains
constant operations except intersection difference sets lines
since intersection set difference done time v total complexity
generateplan p v v
theorem complexity macro p v
proof prior executing macro p necessary construct causal graph g
sets v v v v state variable v v perform topological sort
g shown steps take time v state variable
v v macro p calls generatemacro p v x twice lemma
follows step takes time v v v finally macro p calls
generateplan p v takes time v due lemma follows
complexity macro p v
conjecture possible improve complexity macro p v however proof seems somewhat complex main objective
devise efficient possible rather interested
establishing polynomial follows theorem
plan length
section study length plans generated given begin
derive general bound length plans compute
actual length particular plan without expanding macros present
uses computation efficiently obtain th action plan


ficomplexity

macro form start introducing concept depth state variables
causal graph
definition depth v state variable v longest path v
state variable causal graph
since causal graph acyclic depth state variable
unique computed polynomial time follows least one state
variable depth e outgoing edges
definition depth p equals largest depth
state variable v p e maxvv v
characterize depth state variables let
n v number state variables let ci denote number state variables
depth depth follows c cd n
example consider whose causal graph appears figure
n c c c c c c
lemma consider values li defined ld li
ci li ci li cd ld values li upper bound
length macros generated state variable v depth
proof prove decreasing induction value assume v depth
follows definition v incoming edges thus operator changing
value v pre condition state variable v ld upper
bound stated
assume v depth li k k upper bounds
length corresponding macros let operator changes value v
definition depth follows cannot pre condition state variable
u depth j otherwise would edge u v causal graph causing
depth u greater thus worst case macro v change
values state variables depths larger change value v reset
values state variables lower levels follows li ci li cd ld
upper bound
theorem upper bounds li lemma satisfy li dj cj
proof note
li ci li ci li cd ld
ci li ci li cd ld
ci li li ci li
easily follows induction


figimenez jonsson

obtain upper bound l total length plan worst
case goal state assigns different value state variable initial state
e goal v init v v v achieve goal state applies one
macro per state variable hence
l c l c l cd ld c l


l
c l




cj




j

previous bound depends distribution variables depths according
causal graph obtain general bound depend depths
variables first distribution maximizes upper bound l
q
lemma upper bound l dj cj n variables
depth maximized ci equal ci n
proof note ci c cd n follows direct
application well known gm arithmetic mean geometric mean inequality
states arithmetic mean positive values xi greater equal geometric
mean equality xi
implies product positive
p
factors xi ci fixed sum dj xj n maximized
equal ci n
theorem length plan generated
n state variables depth n
proof direct consequence lemma since c cd discrete may
possible set c cd n nevertheless n
upper bound l case
observe bound established theorem increasing function
implies given bound applies depth
smaller consequence depth bounded
generates solution plan
polynomial length nd since complexity executing plan proportional
plan length use depth define tractable complexity classes
respect plan execution
theorem length plan generated
n state variables n
proof worst case depth n follows theorem
length plan n n n n
note bound established theorem tight second example section
showed generates plan whose length n


ficomplexity











function operator
first operator
length
length
next operator
primitive
return
else
return operator
figure determining th operator sequence

lemma complexity computing total length plan generated
v
proof generates v v macros state variable
operator sequence macro consists one operator v v
macros use dynamic programming avoid computing length macro
worst case compute length v macros
sum v terms resulting total complexity v
lemma given solution plan length l integer l complexity
determining th operator plan v
proof prove lemma providing determining th operator
appears figure since operator sequences consist operators macros
variable represents operator macro generated macro
function primitive returns true operator f alse macro function
length returns length macro otherwise assume length
macros pre computed know lemma takes time v
simply finds operator macro th position sequence
taking account length macros sequence th position part
macro recursively finds operator appropriate position
operator sequence represented macro worst case go
v operators sequence call operator recursively v times
resulting total complexity v
discussion
general view plan generation output consist valid sequence
grounded operators solves contrast generates
solution plan form system macros one might argue truly solve
plan generation expand system macros arrive
sequence underlying operators case would longer polynomial
since solution plan may exponential length fact
objective execute solution plan offers marginal
benefit incremental proposed jonsson backstrom


figimenez jonsson

hand several reasons view system macros generated
complete solution macros collectively
specify steps necessary reach goal solution plan generated
verified polynomial time plan stored reused polynomial memory
even possible compute length resulting plan determine th
operator plan polynomial time shown lemmas thus
practical purposes system macros represents complete solution even
objective execute solution plan faster
jonsson backstrom necessary execute plan generated
maintain stack currently executing macros select next operator
execute whereas jonsson backstrom perform several steps
operator output
jonsson backstrom proved bounded plan existence
np hard bounded plan existence determining whether
exists valid solution plan length k consequence optimal
plan generation np hard well otherwise would possible
solve bounded plan existence generating optimal plan comparing
length resulting plan k examples seen
generate optimal plan general fact bad
incremental jonsson backstrom sense may
generate exponential length plans even though exists solution polynomial length
since makes possible compute total length valid solution
polynomial time used generate heuristics planners specifically
katz domshlak proposed projecting onto provably tractable
fragments use solution fragments heuristics original
shown tractable fragment unfortunately optimal
np hard hope generating admissible heuristic however
heuristic may still informative guiding search towards solution original
addition exponential length optimal solutions
standard planner hope generating heuristic polynomial time making
macro jonsson current viable option

class cn
domshlak dinitz defined class cn multi valued
state variables chain causal graphs since chain causal graphs acyclic follows
operators unary moreover let vi th state variable chain
operator vpost vi holds vpre vi vi words
operator changes value state variable vi may pre conditions
vi vi
authors showed instances cn exponentially sized minimal
solutions therefore argued class intractable light previous section
argument length solutions discard possibility instances
class solved polynomial time macros
case unless p np


ficomplexity

v

vk

w

figure causal graph p f
c

c c


cn cn
cn

c














c c


cn cn

cn

figure domain transition graph vi
define decision plan existence cn follows valid input planexistence cn instance p cn input p belongs plan existencecn p solvable section plan existencecn np hard implies unless p np solving instances cn truly
intractable namely polynomial time distinguish solvable
unsolvable instances cn particular polynomial time solve cn
instances macros kind output format
prove plan existence cn np hard reduction cnf sat
determining whether cnf formula f satisfiable let c cn
clauses cnf formula f let v vk variables appear f
briefly describe intuition behind reduction create
formula f state variable variable appearing f plans forced
commit value state variables actually
satisfy goal variables used pass messages however
operators defined way plan succeed
state variable values committed satisfying assignment f
proceed describe reduction first define p f
hv init goal ai follows set state variables v v vk w vi
c c cn cn vi w n initial state defines
init v v v goal state defines goal w n figure shows
causal graph p f
domain transition graph state variable vi shown figure node
represents value vi edge x means exists operator
pre vi x post vi edge labels represent pre condition
operators state variable vi multiple labels indicate several operators
associated edge enumerate operators acting vi notation
hpre post mention vi understood void
valid output format one enables efficient distinction output representing valid
plan output representing fact solution found



figimenez jonsson



c c

n



cn cn

n

figure domain transition graph w
two operators hvi vi vi hvi vi vi allow vi
move
clause cj x cj cj two operators
hvi x vi vi cj hvi x vi vi cj operators allow vi move cj cj vi done
clause cj x operator hvi x vi vi cj v
occurs clause cj operator hvi x vi vi cj vi occurs clause
cj operators allow vi move cj cj even vi done
clause cj x two operators hvi x vi cj vi
hvi x vi cj vi operators allow vi move back
domain transition graph state variable w shown figure every clause
cj two operators acting w hvk x w j w ji x cj cj
j pre condition w j replaced w
proposition cnf formula f satisfiable instance p f
solvable
proof proof follows relatively straightforward interpretation variables
values instance p f every state variable vi must use
operator commit note choice made variable vi
cannot set value reason need two values cj cj clause
enforce commitment cj corresponds vi cj corresponds vi
reach goal state variable w advance step step along values n
clearly every clause cj must exist variable vi first set values cj
cj operator message propagated along variables
vi vk operators note existence operator acting
vi implies initial choice state variable vi applied formula
variable vi makes clause cj true hence plan solving p f use
initial choices state variables vi define partial assignment satisfies
clauses f
conversely assignment satisfies f obtain plan
solves p f first set every state variable vi value vi every one
clauses cj choose variable vi among make cj true assignment
increasing order j set state variable vi corresponding clause cj
value cj cj depending vi pass message along vi vk w
theorem plan existence cn np hard


ficomplexity

vx
vc

vc

vc

vc

vc

vc







vx

vy

vy

vz

vz





v

v

v

v

v



figure causal graph pf f c c c three variables x z
proof producing instance p f cnf formula f easily done
polynomial time polynomial time reduction cnf sat p plan existencecn

polytree causal graphs
section study class binary state variables
polytree causal graphs brafman domshlak presented finds
plans class time n n number variables
maximum indegree polytree causal graph brafman domshlak
showed solve time roughly n domains local depth
causal graphs tree width interesting observe fail solve
polytree domains polynomial time different reasons first one fails
tree broad unbounded indegree second one fails tree deep
unbounded local depth since tree width polytree
section prove plan existence polytree causal graphs
binary variables np hard proof reduction sat class
example reduction figure shows causal graph
pf corresponds formula f three variables three
clauses precise definition pf given proposition finally end
section remark reduction solves expressed terms cp nets
boutilier et al namely dominance testing polytree cp nets binary
variables partially specified cpts np complete
let us describe briefly idea behind reduction pf two
v depends
different parts first part state variables vx vx vc vc


formula f property plan may change value v
many times number clauses f truth assignment satisfy however
condition v cannot stated goal overcome difficulty
introducing second part state variables v v vt translates regular
goal
first describe second part let p hv init goal ai
v set state variables v v k set k operators
k k operators defined hv v


figimenez jonsson

hv v operators hvi vi vi
hvi vi vi initial state init vi goal state
goal vi even goal vi odd
lemma valid plan p changes state variable v
least k times valid plan achieves minimum
proof let ai bi respectively sequences operators h h
easy verify plan hb k k b k b b solves
p indeed applying operators ai respectively operators bi
variables v vi become respectively particular variable vi attains goal
state even odd subsequent operators plan modify vi
variable remains goal state end operator appears k times
plan one sequence type bi thus value v changes k times
proceed k minimum consider plan solves
p let number operators appearing
words number times value vi changes
note number times operator appears equal precisely one
number occurrences since k
implies k plan least k occurrences completing
proof
let si subsequence operators plan
clearly si starts since initial state vi operator cannot
appear twice consecutively si si etc note
vi pre condition vi hence must least one operator
plan betweeen two operators reason must
least one operator two operators one operator
first operator shows hand variables vi
vi different values goal state subsequences si si must different
lengths together implies desired
proposition sat reduces plan existence binary variables polytree causal graphs
proof let f cnf formula k clauses n variables produce
pf n k state variables n k operators
two state variables vx vx every variable x f two state variables vc
every clause c f k additional variables v v
vc

k variables
initial state partial goal state defined vgoal v v k
goal vi even goal vi odd p lemma
operators
operators hvx vx hvx vx every variable x f
v hv v v hv v v
operators hvc
c
c
c
c
c
c
c
every clause c f



ficomplexity

seven operators every clause c one partial assignment satisfies c
without loss generality let x z three variables appear clause c
operator among seven vpre vx vx vy vy vz vz vc v
vpost v pre vc pre v post v precondition state variables vx vx vy vy vz vz depends corresponding satisfying partial assignment example operator corresponding partial
assignment x z clause c x z pre condition
vx vx vy vy vz vz
operator h c vc v v
operators hvi vi vi hvi vi vi
k operators p except
note simple facts pf variable x state variables vx
vx pf start applying operators change
back particular plan cannot reach partial states hvx vx
hvx vx course execution
similarly c clause f state variable vc change first
v change back changes possible since
changing vc
c

operator brings back vc
interpret operators operators affect v
change v need apply one operators thus require
vc clause c way bring back v applying operator
pre condition vc deduce every time v changes
value back plan least one k state variables vc
used sense vc brought back cannot
used purpose
f sat valid plan pf assume
f sat let truth assignment satisfies f consider following plan
first set vx x vx x variables x operators
clause c f set vc apply operator corresponds
restricted variables clause c point v changes set
v apply operator point v change
vc

c
repeating process every clause c f switching state variable v
exactly k times following proof lemma easily extend
plan plan sets variables vi goal values
converse namely existence valid plan pf implies f
satisfiable define assignment setting x partial state vx vx
appears execution x otherwise recall one
partial states vx vx vx vx appear execution
plan lemma must state variable v changes least k
times implies k operators corresponding different clauses
used move v apply operator values state
variables vx vx must satisfy corresponding clause thus assignment satisfies
k clauses f


figimenez jonsson

theorem plan existence binary variables polytree
causal graph np complete
proof due proposition need np
brafman domshlak showed holds general setting
causal graphs component directed path singly connected
one directed path pair nodes proof exploits
non trivial auxiliary solvable binary variables directedpath singly connected causal graph plans polynomial length true
non binary variables unrestricted causal graphs
cp nets
boutilier et al introduced notion cp net graphical representation
user preferences brief cp net network dependences set variables
preferences user variable depend values others
ceteris paribus else equal assumption user preferences variable
completely independent values variables mentioned preferences
variable given parent variables network stored conditional preference
tables cpts
boutilier et al showed dominance query acyclic cp nets
deciding one variable outcome preferable another
expressed terms network dependences cp net
becomes causal graph
however certain conditions perform opposite process transform
cp net dominance query answering
query amounts solving possible following
conditions acyclic causal graph binary variables
two operators modify variable opposing directions must nonmatching prevail conditions prevail condition operator partial state
pre v vpost
must allow partially specified cpts cp net description
first condition guarantees obtain consistent cpts instance
operators second condition ensures reduction polynomial size preserving
since fully specified cpts exponential maximum node indegree cp net
particular instance pf reduced f satisfies first condition
note true p lemma drop
reversing operators constructing pf proposition consequence
claim following
theorem dominance testing polytree cp nets binary variables partially
specified cpts np complete


ficomplexity

conclusion
presented three complexity simple causal
graphs first provided polynomial time uses macros generate solution plans class although solutions generally suboptimal
generate representations exponentially long plans polynomial time several implications theoretical work since generally accepted
exponentially sized minimal solutions imply plan generation intractable work
shows case provided one allowed express solution
succinct notation macros showed plan existence class cn
np hard plan existence class binary variables
polytree causal graph np complete
jonsson backstrom investigated whether plan generation significantly
harder plan existence class demonstrated plan existence
solved polynomial time plan generation intractable sense
solution plans may exponential length work casts light even
though solution plans exponential length possible generate representation
solution polynomial time thus appears class plan generation
inherently harder plan existence aware work
determines relative complexity plan existence plan generation question
whether plan generation harder plan existence remains open
potential criticism solution form macros
standard intractable expand system macros arrive possibly
exponentially long sequence underlying operators although true shown
system macros share several characteristics proper solution possible
generate validate solution polynomial time solution stored
polynomial memory showed possible compute total length
solution polynomial time well determine th operator
underlying sequence
since relatively simple class cn class
binary state variables polytree causal graphs could seen promising candidates
proving relative complexity plan existence plan generation however
shown plan existence cn np hard plan existence
polytree causal graphs np complete consequently classes cannot used
plan generation harder plan existence since plan existence already
difficult work closes complexity gaps appear literature regarding
two classes
however possible exist subsets classes
plan existence solved polynomial time fact polytree causal
graphs binary variables know case due brafman
domshlak mentioned section hence plan generation
polynomial restrict polytree causal graphs bounded indegree
bounded local depth consequently reduction sat exhibits unbounded
indegree unbounded local depth


figimenez jonsson

similarly one may ask class cn parameter
bounded would yield tractable subclass state variables reduction
domains whose size depends number clauses corresponding cnf formula
domain size appears interesting candidate cn
binary variables tractable due work brafman domshlak
ideas use extend domain sizes hence would interesting
investigate whether plan existence class cn easier size
state variable domains bounded constant

appendix proof theorem
assume generatemacro p v x successfully returns macro mvx hs
let u u vpre v pre u let w w wk u set
wi

state variables u wi splitting mw
wi comes wj topological order j follows u u static
wk
w
w
k
hmw
hm since state variable wi w
splitting symmetrically reversible
lemma wi w prewi prev
proof since wi vpre v vpost edge wi v causal graph
thus ancestor wi ancestor v ancwi ancv state variable
u ancwi prewi u u splitting wi v u graph gu v e u
includes edge wi v means v v u wi v u follows
prewi u prev u consequence prewi prev

let hs wi w let w
sequence preceding
wi
w
w
w
w

w



k

macro hm hs mw



let sequence appearing hs

wi


lemma k post conditions sequences w


post w
wi wk

post w wk

post w
w wi wi wk v x

proof direct consequence post ha ak post post ak post mw

wi post v x

wi


lemma k pre conditions sequences w

wi
v


satisfy pre w
pre pre pre pre v x


proof since pre ha ak pre ak pre follows pre w
pre
wi
v
pre pre prove pre pre v x state variable u
pre u let mu first operator hs u vpre mu
pre u pre mu u



ficomplexity

u
wi w prev

mu mw

follows pre pre
wi
used macro wi symmetrically reversible prewi prev due
lemma particular pre mu u prev u
since assume normal form u wi implies
wi
u

u vpre mwi follows mu mw
u wi

pre mu prewi wi due u wi deduce pre mu u
prewi u prev u
finally consider case mu u v pre mu u x desired
u v splitting v belongs v u pre mu u v belongs v u
pre mu u pre mu u prev u u v symmetrically reversible
follows pre mu u since case pre mu u would forced
fail include u w u v static pre mu u else would
failed

lemma let p p q r partial states p p p q r p q r
proof direct consequence p q p q
lemma macro mvx generated well defined
proof since includes macros ancestors v causal graph since
causal graph acyclic cyclic definitions occur remains macro
sequence preceding holds pre post pre
note due lemmas enough
wi

prev v x post w
pre

b prev v x post pre
wi

c prev v x post w
pre
wi

case follows easily since vpost wi vpre mwi pre mw
pre wi


w
prev case c similar although time must use post wi
wi
wi w finally case b

post w

wj j required pre pre
holds variable u vpre u v covered v x
splitting static covered prev symmetrically reversible covered
prev u pre u post u pre u

remains mvx macro follows lemmas
well defined satisfies pre mvx pre prev v x finally post mvx
post pre v x direct consequence post w wk v x
lemma pre wi pre v x proof lemma

acknowledgments
work partially funded mec grants tin c tin c grammars


figimenez jonsson

references
backstrom c nebel b complexity sas computational
intelligence
botea enzenberger muller schaeffer j macro improving ai
automatically learned macro operators journal artificial intelligence
boutilier c brafman r domshlak c hoos h poole cp nets tool
representing reasoning conditional ceteris paribus preference statements
journal artificial intelligence
brafman r domshlak c structure complexity unary
operators journal artificial intelligence
brafman r domshlak c factored
proceedings st national conference artificial intelligence
bylander computational complexity propositional strips
artificial intelligence
chapman conjunctive goals artificial intelligence
cormen leiserson c rivest r stein c introduction mit
press mcgraw hill
domshlak c dinitz multi agent line coordination structure complexity proceedings th european conference pp
erol k nau subrahmanian v complexity decidability undecidability
domain independent artificial intelligence
fikes r nilsson n strips application theorem
proving solving artificial intelligence
gimenez jonsson hardness simple
causal graphs proceedings th international conference automated
scheduling pp
helmert complexity standard benchmark domains
artificial intelligence
helmert fast downward system journal artificial intelligence

jonsson role macros tractable causal graphs
proceedings th international joint conference artificial intelligence pp

jonsson p backstrom c tractable plan existence imply tractable
plan generation annals mathematics artificial intelligence
katz domshlak c structural patterns heuristics basic idea concrete
instance workshop heuristics domain independent progress
ideas limitations challenges icaps


ficomplexity

knoblock c automatically generating abstractions artificial intelligence
korf r search quantitative artificial intelligence

minton selectively generalizing plans solving proceedings
th international joint conference artificial intelligence pp
vidal v lookahead strategy heuristic search proceedings
th international conference automated scheduling pp
williams b nayak p reactive planner model executive
proceedings th international joint conference artificial intelligence pp





