Journal Artificial Intelligence Research 31 (2008) 273-318

Submitted 07/07; published 02/08

Modular Reuse Ontologies: Theory Practice
Bernardo Cuenca Grau
Ian Horrocks
Yevgeny Kazakov

berg@comlab.ox.ac.uk
ian.horrocks@comlab.ox.ac.uk
yevgeny.kazakov@comlab.ox.ac.uk

Oxford University Computing Laboratory
Oxford, OX1 3QD, UK

Ulrike Sattler

sattler@cs.man.ac.uk

School Computer Science
University Manchester
Manchester, M13 9PL, UK

Abstract
paper, propose set tasks relevant modular reuse ontologies. order formalize tasks reasoning problems, introduce notions
conservative extension, safety module general class logic-based ontology
languages. investigate general properties relationships notions
study relationships relevant reasoning problems previously
identified. study computability problems, consider, particular, Description Logics (DLs), provide formal underpinning W3C Web Ontology
Language (OWL), show problems consider undecidable algorithmically unsolvable description logic underlying OWL DL. order achieve
practical solution, identify conditions sufficient ontology reuse set symbols safelythat is, without changing meaning. provide notion safety
class, characterizes sufficient condition safety, identify family safety
classescalled localitywhich enjoys collection desirable properties. use notion
safety class extract modules ontologies, provide various modularization algorithms appropriate properties particular safety class use.
Finally, show practical benefits safety checking module extraction algorithms.

1. Motivation
Ontologiesconceptualizations domain shared community usersplay major role Semantic Web, increasingly used knowledge management
systems, e-Science, bio-informatics, Grid applications (Staab & Studer, 2004).
design, maintenance, reuse, integration ontologies complex tasks.
software engineers, ontology engineers need supported tools methodologies
help minimize introduction errors, i.e., ensure ontologies
consistent unexpected consequences. order develop support, important notions software engineering, module, black-box behavior, controlled
interaction, need adapted.
Recently, growing interest topic modularity ontology engineering (Seidenberg & Rector, 2006; Noy, 2004a; Lutz, Walther, & Wolter, 2007; Cuenca
Grau, Parsia, Sirin, & Kalyanpur, 2006b; Cuenca Grau, Horrocks, Kazakov, & Sattler,
c
2008
AI Access Foundation. rights reserved.

fiCuenca Grau, Horrocks, Kazakov, & Sattler

2007), motivated above-mentioned application needs. paper,
focus use modularity support partial reuse ontologies. particular,
consider scenario developing ontology P want reuse set
symbols foreign ontology Q without changing meaning.
example, suppose ontology engineer building ontology research
projects, specifies different types projects according research topic
focus on. ontology engineer charge projects ontology P may use terms
Cystic Fibrosis Genetic Disorder descriptions medical research projects.
ontology engineer expert research projects; may unfamiliar, however,
topics projects cover and, particular, terms Cystic Fibrosis
Genetic Disorder. order complete projects ontology suitable definitions
medical terms, decides reuse knowledge subjects wellestablished medical ontology Q.
straightforward way reuse concepts construct logical union
P Q axioms P Q. reasonable assume additional knowledge
medical terms used P Q implications meaning
projects defined P; indeed, additional knowledge reused terms provides new
information medical research projects defined using medical terms.
Less intuitive fact importing Q may result new entailments concerning
reused symbols, namely Cystic Fibrosis Genetic Disorder. Since ontology engineer
projects ontology expert medicine relies designers Q,
expected meaning reused symbols completely specified Q;
is, fact symbols used projects ontology P imply
original meaning Q changes. P change meaning symbols
Q, say P Q conservative extension Q
realistic application scenarios, often unreasonable assume foreign ontology
Q fixed; is, Q may evolve beyond control modelers P. ontology
engineers charge P may authorized access information Q or,
importantly, may decide later time reuse symbols Cystic Fibrosis
Genetic Disorder medical ontology Q. application scenarios
external ontology Q may change, reasonable abstract particular Q
consideration. particular, given set external symbols, fact
axioms P change meaning symbol independent
particular meaning ascribed symbols Q. case, say P safe
S.
Moreover, even P safely reuses set symbols ontology Q, may still
case Q large ontology. particular, example, foreign medical
ontology may huge, importing whole ontology would make consequences
additional information costly compute difficult ontology engineers
charge projects ontology (who medical experts) understand. practice,
therefore, one may need extract module Q1 Q includes relevant information. Ideally, module small possible still guarantee capture
meaning terms used; is, answering queries research projects
ontology, importing module Q1 would give exactly answers whole
medical ontology Q imported. case, importing module
274

fiModular Reuse Ontologies: Theory Practice

observable effect projects ontology importing entire ontology. Furthermore, fact Q1 module Q independent particular P
consideration.
contributions paper follows:
1. propose set tasks relevant ontology reuse formalize
reasoning problems. end, introduce notions conservative extension,
safety module general class logic-based ontology languages.
2. investigate general properties relationships notions
conservative extension, safety, module use properties study relationships relevant reasoning problems previously identified.
3. consider Description Logics (DLs), provide formal underpinning
W3C Web Ontology Language (OWL), study computability tasks.
show tasks consider undecidable algorithmically unsolvable
description logic underlying OWL DLthe expressive dialect OWL
direct correspondence description logics.
4. consider problem deciding safety ontology signature. Given
problem undecidable OWL DL, identify sufficient conditions safety,
decidable OWL DLthat is, ontology satisfies conditions
safe; converse, however, necessarily hold. propose
notion safety class, characterizes sufficiency condition safety,
identify family safety classescalled localitywhich enjoys collection desirable
properties.
5. next apply notion safety class task extracting modules
ontologies; provide various modularization algorithms appropriate
properties particular safety class use.
6. present empirical evidence practical benefits techniques safety
checking module extraction.
paper extends results previous work (Cuenca Grau, Horrocks, Kutz, &
Sattler, 2006; Cuenca Grau et al., 2007; Cuenca Grau, Horrocks, Kazakov, & Sattler, 2007).

2. Preliminaries
section introduce description logics (DLs) (Baader, Calvanese, McGuinness,
Nardi, & Patel-Schneider, 2003), family knowledge representation formalisms
underlie modern ontology languages, OWL DL (Patel-Schneider, Hayes, & Horrocks, 2004). hierarchy commonly-used description logics summarized Table 1.
syntax description logic L given signature set constructors.
signature (or vocabulary) Sg DL (disjoint) union countably infinite sets AC
atomic concepts (A, B, . . . ) representing sets elements, AR atomic roles (r, s, . . . )
representing binary relations elements, Ind individuals (a, b, c, . . . ) representing constants. assume signature fixed every DL.
275

fiCuenca Grau, Horrocks, Kazakov, & Sattler

DLs

Constructors
Con
>, A, C1 u C2 , R.C
pp, C
pp

Axioms [ Ax ]
TBox
ABox
C, C1 v C2 : C, r(a, b)
pp
pp
pp
pp

Rol
RBox
EL
r
ALC pp
pp
Trans(r)
+
r
+ H
R 1 v R2
+ F
Funct(R)
+ N
(> n S)
+ Q
(> n S.C)
+
{i}
r AR, AC, a, b Ind, R(i) Rol, C(i) Con, n 1 Rol simple
role (see (Horrocks & Sattler, 2005)).
Table 1: hierarchy standard description logics

Every DL provides constructors defining set Rol (general) roles (R, S, . . . ),
set Con (general) concepts (C, D, . . . ), set Ax axioms (, , . . . )
union role axioms (RBox), terminological axioms (TBox) assertions (ABox).
EL (Baader, Brandt, & Lutz, 2005) simple description logic allows one
construct complex concepts using conjunction C1 u C2 existential restriction R.C
starting atomic concepts A, roles R top concept >. EL provides role
constructors role axioms; thus, every role R EL atomic. TBox axioms
EL either concept definitions C general concept inclusion axioms (GCIs)
C1 v C2 . EL assertions either concept assertions : C role assertions r(a, b).
paper assume concept definition C abbreviation two GCIs v C
C v A.
basic description logic ALC (Schmidt-Schau & Smolka, 1991) obtained EL
adding concept negation constructor C. introduce additional constructors
abbreviations: bottom concept shortcut >, concept disjunction C1 C2
stands (C1 u C2 ), value restriction R.C stands (R.C). contrast
EL, ALC express contradiction axioms > v . logic extension
ALC where, additionally, atomic roles declared transitive using role
axiom Trans(r).
extensions description logics add features inverse roles r (indicated
appending letter name logic), role inclusion axioms (RIs) R1 v R2 (+H),
functional roles Funct(R) (+F), number restrictions (> n S), n 1, (+N ), qualified
number restrictions (> n S.C), n 1, (+Q)1 , nominals {a} (+O). Nominals make
possible construct concept representing singleton set {a} (a nominal concept)
individual a. extensions used different combinations; example ALCO
extension ALC nominals; SHIQ extension role hierarchies,
1. dual constructors (6 n S) (6 n S.C) abbreviations (> n + 1 S) (> n + 1 S.C),
respectively

276

fiModular Reuse Ontologies: Theory Practice

inverse roles qualified number restrictions; SHOIQ DL uses
constructors axiom types presented.
Modern ontology languages, OWL, based description logics and, certain extent, syntactic variants thereof. particular, OWL DL corresponds SHOIN
(Horrocks, Patel-Schneider, & van Harmelen, 2003). paper, assume ontology
based description logic L finite set axioms L. signature
ontology (of axiom ) set Sig(O) (Sig()) atomic concepts, atomic roles
individuals occur (respectively ).
main reasoning task ontologies entailment: given ontology axiom
, check implies . logical entailment |= defined using usual Tarski-style
set-theoretic semantics description logics follows. interpretation pair =
(I , ), non-empty set, called domain interpretation,
interpretation function assigns: every AC subset AI , every r AR
binary relation rI , every Ind element aI . Note
sets AC, AR Ind defined interpretation assumed fixed
ontology language (DL).
interpretation function extended complex roles concepts via DLconstructors follows:
(>)I
(C u D)I
(R.C)I
(C)I
(r )I

=
=
=
=
=


C DI
{x | y.hx, yi RI C }
\ C
{hx, yi | hy, xi rI }

(> n R)I = { x | ]{y | hx, yi RI } n }
(> n R.C)I = { x | ]{y | hx, yi RI C } n }
{a}I = {aI }
satisfaction relation |= interpretation DL axiom (read
satisfies , model ) defined follows:
|= C1 v C2 iff C1I C2I ;
|= R1 v R2 iff R1I R2I ;

|= : C iff aI C ;
|= r(a, b) iff haI , bI rI ;

|= Trans(r) iff x, y, z [ hx, yi rI hy, zi rI hx, zi rI ];
|= Funct(R) iff x, y, z [ hx, yi RI hx, zi RI = z ];
interpretation model ontology satisfies axioms O.
ontology implies axiom (written |= ) |= every model O. Given
set interpretations, say axiom (an ontology O) valid every
interpretation model (respectively O). axiom tautology valid
set interpretations (or, equivalently, implied empty ontology).
say two interpretations = (I , ) J = (J , J ) coincide subset
signature (notation: I|S = J |S ) = J X = X J every X S.
say two sets interpretations J equal modulo (notation: I|S = J|S )
every exits J J J |S = I|S every J J exists
I|S = J |S .
277

fiCuenca Grau, Horrocks, Kazakov, & Sattler

Ontology medical research projects P:
P1

Genetic Disorder Project Project u Focus.Genetic Disorder

P2

Cystic Fibrosis EUProject EUProject u Focus.Cystic Fibrosis

P3

EUProject v Project

P4

Focus.> v Project

E1

Project u (Genetic Disorder ::
u Cystic Fibrosis) v

E2

Focus.Cystic Fibrosis v Focus.Genetic Disorder

::

Ontology medical terms Q:
M1 Cystic Fibrosis Fibrosis u located In.Pancreas u Origin.Genetic Origin
M2 Genetic Fibrosis Fibrosis u Origin.Genetic Origin
M3 Fibrosis u located In.Pancreas v Genetic Fibrosis
M4 Genetic Fibrosis v Genetic Disorder
M5 DEFBI Gene v Immuno Protein Gene u associated With.Cystic Fibrosis
Figure 1: Reusing medical terminology ontology research projects

3. Ontology Integration Knowledge Reuse
section, elaborate ontology reuse scenario sketched Section 1. Based
application scenario, motivate define reasoning tasks investigated
remainder paper. particular, tasks based notions conservative
extension (Section 3.2), safety (Sections 3.2 3.3) module (Section 3.4). notions
defined relative language L. Within section, assume L ontology
language based description logic; Section 3.6, define formally class
ontology languages given definitions conservative extensions, safety
modules apply. convenience reader, tasks consider paper
summarized Table 2.
3.1 Motivating Example
Suppose ontology engineer charge SHOIQ ontology research projects,
specifies different types projects according research topic concerned
with. Assume ontology engineer defines two conceptsGenetic Disorder Project
Cystic Fibrosis EUProjectin ontology P. first one describes projects genetic
disorders; second one describes European projects cystic fibrosis, given
axioms P1 P2 Figure 1. ontology engineer expert research projects:
knows, example, every instance EUProject must instance Project (the
concept-inclusion axiom P3) role Focus applied instances
Project (the domain axiom P4). may unfamiliar, however, topics
projects cover and, particular, terms Cystic Fibrosis Genetic Disorder
mentioned P1 P2. order complete projects ontology suitable definitions
278

fiModular Reuse Ontologies: Theory Practice

medical terms, decides reuse knowledge subjects wellestablished widely-used medical ontology.
Suppose Cystic Fibrosis Genetic Disorder described ontology Q containing axioms M1-M5 Figure 1. straightforward way reuse concepts
import P ontology Qthat is, add axioms Q axioms P
work extended ontology P Q. Importing additional axioms ontology
may result new logical consequences. example, easy see axioms M1M4
Q imply every instance Cystic Fibrosis instance Genetic Disorder:
Q |= := (Cystic Fibrosis v Genetic Disorder)

(1)

Indeed, concept inclusion 1 := (Cystic Fibrosis v Genetic Fibrosis) follows axioms
M1 M2 well axioms M1 M3; follows axioms 1 M4.
Using inclusion (1) axioms P1P3 ontology P prove
every instance Cystic Fibrosis EUProject instance Genetic Disorder Project:
P Q |= := (Cystic Fibrosis EUProject v Genetic Disorder Project)

(2)

inclusion , however, follow P alonethat is, P 6|= . ontology
engineer might aware Entailment (2), even though concerns terms primary
scope projects ontology P.
natural expect entailments (1) imported ontology Q result
new logical consequences, , (2), terms defined main ontology P.
One would expect, however, meaning terms defined Q changes
consequence import since terms supposed completely specified within
Q. side effect would highly undesirable modeling ontology P since
ontology engineer P might expert subject Q supposed
alter meaning terms defined Q even implicitly.
meaning reused terms, however, might change import, perhaps due
modeling errors. order illustrate situation, suppose ontology engineer
learned concepts Genetic Disorder Cystic Fibrosis ontology Q
(including inclusion (1)) decided introduce additional axioms formalizing
following statements:
Every instance Project different every instance Genetic Disorder

every instance Cystic Fibrosis.
:::

(3)

::::::
Every::::::::
project Focus Cystic Fibrosis, Focus Genetic Disorder

(4)

Note statements (3) (4) thought adding new information
projects and, intuitively, change constrain meaning medical
terms.
Suppose ontology engineer formalized statements (3) (4) ontology
P using axioms E1 E2 respectively. point, ontology engineer introduced modeling errors and, consequence, axioms E1 E2 correspond (3)
(4): E1 actually formalizes following statement: Every instance Project different every common instance Genetic Disorder Cystic Fibrosis, E2 expresses
279

fiCuenca Grau, Horrocks, Kazakov, & Sattler

Every object either Focus nothing, Focus Cystic Fibrosis,
Focus Genetic Disorder. kinds modeling errors difficult detect,
especially cause inconsistencies ontology.
Note that, although axiom E1 correspond fact (3), still consequence
(3) means constrain meaning medical terms.
hand, E2 consequence (4) and, fact, constrains meaning medical
terms. Indeed, axioms E1 E2 together axioms P1-P4 P imply new axioms
concepts Cystic Fibrosis Genetic Disorder, namely disjointness:
P |= := (Genetic Disorder u Cystic Fibrosis v )

(5)

entailment (5) proved using axiom E2 equivalent to:
> v Focus.(Genetic Disorder Cystic Fibrosis)

(6)

inclusion (6) P4 imply every element domain must projectthat
is, P |= (> v Project). Now, together axiom E1, implies (5).
axioms E1 E2 imply new statements medical terms,
cause inconsistencies used together imported axioms Q. Indeed,
(1) (5) obtain P Q |= := (Cystic Fibrosis v ), expresses inconsistency
concept Cystic Fibrosis.
summarize, seen importing external ontology lead undesirable
side effects knowledge reuse scenario, entailment new axioms even inconsistencies involving reused vocabulary. next section discuss formalize
effects consider undesirable.
3.2 Conservative Extensions Safety Ontology
argued previous section, important requirement reuse ontology Q
within ontology P P Q produces exactly logical consequences
vocabulary Q Q alone does. requirement naturally formulated
using well-known notion conservative extension, recently investigated context ontologies (Ghilardi, Lutz, & Wolter, 2006; Lutz et al., 2007).
Definition 1 (Deductive Conservative Extension). Let O1 two Lontologies, signature L. say deductive S-conservative extension
O1 w.r.t. L, every axiom L Sig() S, |= iff O1 |= .
say deductive conservative extension O1 w.r.t. L deductive
S-conservative extension O1 w.r.t. L = Sig(O1 ).

words, ontology deductive S-conservative extension O1
signature language L every logical consequence constructed
using language L symbols S, already logical consequence O1 ;
is, additional axioms \ O1 result new logical consequences
vocabulary S. Note deductive S-conservative extension O1 w.r.t. L,
deductive S1 -conservative extension O1 w.r.t. L every S1 S.
notion deductive conservative extension directly applied ontology
reuse scenario.
280

fiModular Reuse Ontologies: Theory Practice

Definition 2 (Safety Ontology). Given L-ontologies O0 , say
safe O0 (or imports O0 safe way) w.r.t. L O0 deductive conservative
extension O0 w.r.t. L.

Hence, first reasoning task relevant ontology reuse scenario formulated
follows:
T1.

given L-ontologies O0 , determine safe O0 w.r.t. L.

shown Section 3.1 that, given P consisting axioms P1P4, E1, E2, Q
consisting axioms M1M5 Figure 1, exists axiom = (Cystic Fibrosis v )
uses symbols Sig(Q) Q 6|= P Q |= . According Definition 1,
means P Q deductive conservative extension Q w.r.t. language
L expressed (e.g. L = ALC). possible, however, show
axiom E2 removed P resulting ontology P1 = P \ {E2}, P1 Q
deductive conservative extension Q. following notion useful proving deductive
conservative extensions:
Definition 3 (Model Conservative Extension, Lutz et al., 2007).
Let O1 two L-ontologies signature L. say model
S-conservative extension O1 , every model O1 , exists model J
I|S = J |S . say model conservative extension O1 model
S-conservative extension O1 = Sig(O1 ).

notion model conservative extension Definition 3 seen semantic
counterpart notion deductive conservative extension Definition 1: latter
defined terms logical entailment, whereas former defined terms models.
Intuitively, ontology model S-conservative extension O1 every model
O1 one find model domain interprets symbols
way. notion model conservative extension, however, provide
complete characterization deductive conservative extensions, given Definition 1;
is, notion used proving ontology deductive conservative
extension another, vice versa:
Proposition 4 (Model vs. Deductive Conservative Extensions, Lutz et al., 2007)
1. every two L-ontologies O, O1 O, signature L, model
S-conservative extension O1 deductive S-conservative extension O1
w.r.t. L;
2. exist two ALC ontologies O1 deductive conservative
extension O1 w.r.t. ALC, model conservative extension O1 .
Example 5 Consider ontology P1 consisting axioms P1P4, E1 ontology
Q consisting axioms M1M5 Figure 1. demonstrate P1 Q deductive
conservative extension Q. According proposition 4, sufficient show P1 Q
model conservative extension Q; is, every model Q exists model
J P1 Q I|S = J |S = Sig(Q).
281

fiCuenca Grau, Horrocks, Kazakov, & Sattler

required model J constructed follows: take J identical except interpretations atomic concepts Genetic Disorder Project,
Cystic Fibrosis EUProject, Project, EUProject atomic role Focus,
interpret J empty set. easy check axioms P1P4, E1
satisfied J hence J |= P1 . Moreover, since interpretation symbols Q
remains unchanged, I|Sig(Q) = J |Sig(Q) J |= Q. Hence, P1 Q model
conservative extension Q.
example Statement 2 Proposition, refer interested reader
literature (Lutz et al., 2007, p. 455).

3.3 Safety Ontology Signature
far, ontology reuse scenario assumed reused ontology Q fixed
axioms Q copied P import. practice, however,
often convenient keep Q separate P make axioms available demand
via reference. makes possible continue developing P Q independently.
example, ontology engineers project ontology P may willing depend
particular version Q, may even decide later time reuse medical terms
(Cystic Fibrosis Genetic Disorder) another medical ontology instead. Therefore,
many application scenarios important develop stronger safety condition P
depends little possible particular ontology Q reused. order
formulate condition, abstract particular ontology Q imported
focus instead symbols Q reused:
Definition 6 (Safety Signature). Let L-ontology signature L.
say safe w.r.t. L, every L-ontology O0 Sig(O) Sig(O0 ) S,
safe O0 w.r.t. L; is, O0 deductive conservative extension
O0 w.r.t. L.

Intuitively, knowledge reuse scenario, ontology safe signature w.r.t.
language L imports safe way ontology O0 written L shares
symbols O. associated reasoning problem formulated
following way:
T2.

given L-ontology signature L,
determine safe w.r.t. L.

seen Section 3.2, ontology P consisting axioms P1P4, E1, E2 Figure 1,
import Q consisting axioms M1M5 Figure 1 safe way L = ALC.
According Definition 6, since Sig(P) Sig(Q) = {Cystic Fibrosis, Genetic Disorder},
ontology P safe w.r.t. L.
fact, possible show stronger result, namely, ontology containing
axiom E2 safe = {Cystic Fibrosis, Genetic Disorder} w.r.t. L = ALC. Consider
ontology O0 = {1 , 2 }, 1 = (> v Cystic Fibrosis) 2 = (Genetic Disorder v ).
Since E2 equivalent axiom (6), easy see O0 inconsistent. Indeed E2,
1 2 imply contradiction = (> v ), entailed O0 . Hence, O0
deductive conservative extension O0 . Definition 6, since Sig(O) Sig(O0 ) S,
means safe S.
282

fiModular Reuse Ontologies: Theory Practice

clear one could prove ontology safe signature S: simply find
ontology O0 Sig(O) Sig(O0 ) S, O0 deductive conservative
extension O0 . clear, however, one could prove safe S.
turns notion model conservative extensions used purpose.
following lemma introduces property relates notion model conservative
extension notion safety signature. Intuitively, says notion
model conservative extension stable expansion new axioms provided
share symbols original ontologies.
Lemma 7 Let O, O1 O, O0 L-ontologies signature L
model S-conservative extension O1 Sig(O) Sig(O0 ) S. O0
model S0 -conservative extension O1 O0 S0 = Sig(O0 ).
Proof. order show OO0 model S0 -conservative extension O1 O0 according
Definition 3, let model O1 O0 . construct model J O0
I|S0 = J |S0 .
(])
Since model S-conservative extension O1 , model O1 , Definition 3
exists model J1 I|S = J1 |S . Let J interpretation
J |Sig(O) = J1 |Sig(O) J |S0 = I|S0 . Since Sig(O) S0 = Sig(O) (S Sig(O0 ))
(Sig(O) Sig(O0 )) I|S = J1 |S , interpretation J always exists. Since
J |Sig(O) = J1 |Sig(O) J1 |= O, J |= O; since J |S0 = I|S0 , Sig(O0 ) S0 ,
|= O0 , J |= O0 . Hence J |= O0 I|S0 = J |S0 , proves (]).
Lemma 7 allows us identify condition sufficient ensure safety ontology
signature:
Proposition 8 (Safety Signature vs. Model Conservative Extensions)
Let L-ontology signature L model S-conservative
extension empty ontology O1 = ; is, every interpretation exists
model J J |S = I|S . safe w.r.t. L.
Proof. order prove safe w.r.t. L according Definition 6, take
SHOIQ ontology O0 Sig(O) Sig(O0 ) S. need demonstrate O0
deductive conservative extension O0 w.r.t. L.
(])
Indeed, Lemma 7, since model S-conservative extension O1 = ,
Sig(O)Sig(O0 ) S, OO0 model S0 -conservative extension O1 O0 = O0
S0 = Sig(O0 ). particular, since Sig(O0 ) S0 , O0 deductive
conservative extension O0 , required prove (]).
Example 9 Let P1 ontology consisting axioms P1P4, E1 Figure 1.
show P1 safe = {Cystic Fibrosis, Genetic Disorder} w.r.t. L = SHOIQ.
Proposition 8, order prove safety P1 sufficient demonstrate P1
model S-conservative extension empty ontology, is, every S-interpretation
exists model J P1 I|S = J |S .
Consider model J obtained Example 5. shown Example 5, J
model P1 I|Sig(Q) = J |Sig(Q) Q consists axioms M1M5 Figure 1.
particular, since Sig(Q), I|S = J |S .

283

fiCuenca Grau, Horrocks, Kazakov, & Sattler

3.4 Extraction Modules Ontologies
example Figure 1 medical ontology Q small. Well established medical
ontologies, however, large may describe subject matters designer P interested. example, medical ontology Q could contain information
genes, anatomy, surgical techniques, etc.
Even P imports Q without changing meaning reused symbols, processing
is, browsing, reasoning over, etcthe resulting ontology P Q may considerably
harder processing P alone. Ideally, one would extract (hopefully small) fragment Q1 external medical ontologya modulethat describes concepts
reused P.
Intuitively, answering arbitrary query signature P, importing
module Q1 give exactly answers whole ontology Q
imported.
Definition 10 (Module Ontology). Let O, O0 O10 O0 L-ontologies.
say O10 module O0 w.r.t. L, O0 deductive S-conservative
extension O10 = Sig(O) w.r.t. L.

task extracting modules imported ontologies ontology reuse scenario
thus formulated follows:
T3.

given L-ontologies O, O0 ,
compute module O10 O0 w.r.t. L.

Example 11 Consider ontology P1 consisting axioms P1P4, E1 ontology Q
consisting axioms M1M5 Figure 1. Recall axiom (1) consequence axioms M1, M2 M4 well axioms M1, M3 M4 ontology Q.
fact, sets axioms actually minimal subsets Q imply . particular,
subset Q0 Q consisting axioms M2, M3, M4 M5, Q0 6|= .
demonstrated P1 Q0 deductive conservative extension Q0 . particular
P1 Q0 6|= . then, according Definition 10, Q0 module P1 Q w.r.t.
L = ALC extensions, since P1 Q deductive S-conservative extension
P1 Q0 w.r.t. L = ALC = Sig(P1 ). Indeed, P1 Q |= , Sig() P1 Q0 6|= .
Similarly, one show subset Q imply module Q
w.r.t. P1 .
hand, possible show subsets Q1 = {M1, M2, M4}
Q2 = {M1, M3, M4} Q modules P1 Q w.r.t. L = SHOIQ. so, Definition 10, need demonstrate P1 Q deductive S-conservative extension
P1 Q1 P1 Q2 = Sig(P1 ) w.r.t. L. usual, demonstrate stronger
fact, P1 Q model S-conservative extension P1 Q1 P1 Q2
sufficient Claim 1 Proposition 4.
order show P1 Q model S-conservative extension P1 Q1 =
Sig(P1 ), consider model P1 Q1 . need construct model J P1 Q
I|S = J |S . Let J defined exactly except interpretations
atomic concepts Fibrosis, Pancreas, Genetic Fibrosis, Genetic Origin defined
interpretation Cystic Fibrosis I, interpretations atomic roles located
284

fiModular Reuse Ontologies: Theory Practice

Origin defined identity relation. easy see axioms M1M3 M5
satisfied J . Since modify interpretation symbols P1 , J
satisfies axioms P1 . Moreover, J model M4, Genetic Fibrosis
Genetic Disorder interpreted J Cystic Fibrosis Genetic Disorder I,
model Q1 , implies concept inclusion = (Cystic Fibrosis v Genetic Disorder).
Hence constructed model J P1 Q I|S = J |S , thus P1 Q
model S-conservative extension P1 Q1 .
fact, construction works replace Q1 subset Q implies
. particular, P1 Q model S-conservative extension P1 Q2 . way,
demonstrated modules P Q exactly subsets Q imply
.

algorithm implementing task T3 used extracting module
ontology Q imported P prior performing reasoning terms P. However,
ontology P modified, module extracted since module Q1
P Q might necessarily module modified ontology. Since extraction
modules potentially expensive operation, would convenient extract
module reuse version ontology P reuses specified
symbols Q. idea motivates following definition:
Definition 12 (Module Signature). Let O0 O10 O0 L-ontologies
signature L. say O10 module O0 (or S-module O0 ) w.r.t.
L, every L-ontology Sig(O) Sig(O0 ) S, O10 module
O0 w.r.t. L.

Intuitively, notion module signature uniform analog notion
module ontology, similar way notion safety signature uniform
analog safety ontology. reasoning task corresponding Definition 12
formulated follows:
T4.

given L-ontology O0 signature L,
compute module O10 O0 .

Continuing Example 11, possible demonstrate subset Q implies
axiom , fact module = {Cystic Fibrosis, Genetic Disorder} Q, is,
imported instead Q every ontology shares Q symbols S.
order prove this, use following sufficient condition based notion model
conservative extension:
Proposition 13 (Modules Signature vs. Model Conservative Extensions)
Let O0 O10 O0 L-ontologies signature L O0 model
S-conservative extension O10 . O10 module O0 w.r.t. L.
Proof. order prove O10 module O0 w.r.t. L according Definition 12,
take SHOIQ ontology Sig(O) Sig(O0 ) S. need demonstrate
O10 module O0 w.r.t. L, is, according Definition 10, O0
deductive S0 -conservative extension O10 w.r.t. L S0 = Sig(O).
(])
285

fiCuenca Grau, Horrocks, Kazakov, & Sattler

Indeed, Lemma 7, since O0 model S-conservative extension O10 , Sig(O0 )
Sig(O) S, O0 model S00 -conservative extension O10
S00 = Sig(O). particular, since S0 = Sig(O) S00 , O0 deductive
S0 -conservative extension O10 w.r.t. L, required prove (]).
Example 14 Let Q Example 11. demonstrate subset Q1 Q
implies module = {Cystic Fibrosis, Genetic Disorder} Q. According
Proposition 13, sufficient demonstrate Q model S-conservative extension
Q1 , is, every model Q1 exists model J Q I|S = J |S .
easy see model J constructed Example 11, required
property holds.

Note module signature Q necessarily contain axioms
contain symbols S. example, module Q1 consisting axiom M1, M2
M4 Q contain axiom M5 mentions atomic concept Cystic Fibrosis
S. note even minimal module Q1 might still axioms
M2 mention symbols all.
3.5 Minimal Modules Essential Axioms
One usually interested extracting arbitrary modules reused ontology,
extracting modules easy process afterwards. Ideally, extracted modules
small possible. Hence reasonable consider problem extracting
minimal modules; is, modules contain module subset.
Examples 11 14 demonstrate minimal module ontology signature
necessarily unique: ontology Q consisting axioms M1M5 two minimal modules Q1 = {M1, M2, M4}, Q2 = {M1, M3, M4}, ontology P1 = {P1, P2, P3, E1}
well signature = {Cystic Fibrosis, Genetic Disorder}, since minimal sets axioms imply axiom = (Cystic Fibrosis v Genetic Disorder). Depending
application scenario, one consider several variations tasks T3 T4 computing minimal modules. applications might necessary extract minimal
modules, whereas others minimal module suffices.
Axioms occur minimal module Q essential P
always removed every module Q, thus never need imported
P. true axioms occur minimal modules Q. might
necessary import axioms P order lose essential information Q.
arguments motivate following notion:
Definition 15 (Essential Axiom). Let O0 L-ontologies, signature
axiom L. say essential O0 w.r.t. L contained
minimal module O0 w.r.t. L. say essential axiom O0 w.r.t.
L (or S-essential O0 ) contained minimal module O0 w.r.t. L.
example axioms M1M4 Q essential ontology P1
signature = {Cystic Fibrosis, Genetic Disorder}, axiom M5 essential.
certain situations one might interested computing set essential axioms
ontology, done computing union minimal modules. Note
286

fiModular Reuse Ontologies: Theory Practice

Notation

Input

Task

Checking Safety:
T1

O, O0 , L

Check safe O0 w.r.t. L

T2

O, S, L

Check safe w.r.t. L

Extracting [all / / union of] [minimal] module(s):
T3[a,s,u][m]

O, O0 , L

Extract modules O0 w.r.t. L

T4[a,s,u][m]

O0 , S, L

Extract modules O0 w.r.t. L

O, O0 ontologies signature L
Table 2: Summary reasoning tasks relevant ontology integration reuse
computing union minimal modules might easier computing minimal
modules since one need identify axiom belongs minimal module.
Table 2 summarized reasoning tasks found potentially relevant
ontology reuse scenarios included variants T3am, T3sm, T3um
task T3 T4am, T4sm, T4um task T4 computation minimal modules
discussed section.
variants tasks T3 T4 could considered relevant ontology reuse.
example, instead computing minimal modules, one might interested computing
modules smallest number axioms, modules smallest size measured
number symbols, complexity measure ontology. theoretical
results present paper easily extended many reasoning
tasks.
3.6 Safety Modules General Ontology Languages
notions introduced Section 3 defined respect ontology language.
far, however, implicitly assumed ontology languages description
logics defined Section 2that is, fragments DL SHOIQ. notions considered Section 3 applied, however, much broader class ontology languages.
definitions apply ontology language notion entailment axioms
ontologies, mechanism identifying signatures.
Definition 16. ontology language tuple L = (Sg, Ax, Sig, |=), Sg set
signature elements (or vocabulary) L, Ax set axioms L, Sig function
assigns every axiom Ax finite set Sig() Sg called signature ,
|= entailment relation sets axioms Ax axioms Ax, written
|= . ontology L finiteSset axioms Ax. extend function Sig
ontologies follows: Sig(O) := Sig().

Definition 16 provides general notion ontology language. language L
given set symbols (a signature), set formulae (axioms) constructed
symbols, function assigns formula signature, entailment
relation sets axioms. ontology language OWL DL well description
287

fiCuenca Grau, Horrocks, Kazakov, & Sattler

logics defined Section 2 examples ontology languages accordance Definition 16.
examples ontology languages First Order Logic, Second Order Logic, Logic
Programs.
easy see notions deductive conservative extension (Definition 1), safety
(Definitions 2 6) modules (Definitions 10 12), well reasoning tasks
Table 2, well-defined every ontology language L given Definition 16.
definition model conservative extension (Definition 3) propositions involving
model conservative extensions (Propositions 4, 8, 13) extended
languages standard Tarski model-theoretic semantics, Higher Order Logic.
simplify presentation, however, formulate general requirements
semantics ontology languages, assume deal sublanguages SHOIQ
whenever semantics taken account.
remainder section, establish relationships different
notions safety modules arbitrary ontology languages.
Proposition 17 (Safety vs. Modules Ontology) Let L ontology language,
let O, O0 , O10 O0 ontologies L. Then:
1. O0 safe w.r.t. L iff empty ontology module O0 w.r.t. L.
2. O0 \ O10 safe O10 O10 module O0 w.r.t. L.
Proof. 1. Definition 2, O0 safe w.r.t. L iff (a) O0 deductive conservative
extension w.r.t. L. Definition 10, empty ontology O00 = module
O0 w.r.t. L iff (b) O0 deductive S-conservative extension O00 = w.r.t. L
= Sig(O). easy see (a) (b).
2. Definition 2, O0 \ O10 safe O10 w.r.t. L iff (c) O10 (O0 \ O10 ) = O0
deductive conservative extension O10 w.r.t. L. particular, O0 deductive
S-conservative extension O10 w.r.t. L = Sig(O), implies, Definition 10,
O10 module O0 w.r.t. L.
provide analog Proposition 17 notions safety modules
signature:
Proposition 18 (Safety vs. Modules Signature) Let L ontology language,
O0 O10 O0 , ontologies L, subset signature L. Then:
1. O0 safe w.r.t. L iff empty ontology O00 = S-module O0 w.r.t. L.
2. O0 \ O10 safe Sig(O10 ) w.r.t. L, O10 S-module O0 w.r.t. L.
Proof. 1. Definition 6, O0 safe w.r.t. L iff (a) every Sig(O0 ) Sig(O)
S, case O0 safe w.r.t. L. Definition 12, O00 = S-module
O0 w.r.t. L iff (b) every Sig(O0 ) Sig(O) S, case O00 =
module O0 w.r.t. L. Claim 1 Proposition 17, easy see (a)
equivalent (b).
2. Definition 6, O0 \ O10 safe Sig(O10 ) w.r.t. L iff (c) every O,
Sig(O0 \ O10 ) Sig(O) Sig(O10 ), O0 \ O10 safe w.r.t. L.
288

fiModular Reuse Ontologies: Theory Practice

Definition 12, O10 S-module O0 w.r.t. L iff (d) every Sig(O0 )Sig(O) S,
O10 module O0 w.r.t. L.
order prove (c) implies (d), let Sig(O0 ) Sig(O) S. need
demonstrate O10 module O0 w.r.t. L.
(?)
0
0
0
0
0
0
Let := O1 . Note Sig(O \ O1 ) Sig(O) = Sig(O \ O1 ) (Sig(O) Sig(O1 ))
(Sig(O0 \ O10 ) Sig(O)) Sig(O10 ) Sig(O10 ). Hence, (c) O0 \ O10 safe
= O10 w.r.t. L implies Claim 2 Proposition 17 O10 module
O0 w.r.t. L (?).

4. Undecidability Complexity Results
section study computational properties tasks Table 2 ontology
languages correspond fragments description logic SHOIQ. demonstrate
reasoning tasks algorithmically unsolvable even relatively inexpressive DLs, computationally hard simple DLs.
Since notions modules safety defined Section 3 using notion
deductive conservative extension, reasonable identify (un)decidability
complexity results conservative extensions applicable reasoning tasks Table 2. computational properties conservative extensions recently studied
context description logics. Given O1 language L, problem
deciding whether deductive conservative extension O1 w.r.t. L 2-EXPTIMEcomplete L = ALC (Ghilardi et al., 2006). result extended Lutz et al.
(2007), showed problem 2-EXPTIME-complete L = ALCIQ undecidable L = ALCIQO. Recently, problem studied simple DLs;
shown deciding deductive conservative extensions EXPTIME-complete
L = EL(Lutz & Wolter, 2007). results immediately applied notions
safety modules ontology:
Proposition 19 Given ontologies O0 L, problem determining whether
safe O0 w.r.t. L EXPTIME-complete L = EL, 2-EXPTIME-complete
L = ALC L = ALCIQ, undecidable L = ALCIQO. Given ontologies O, O0 ,
O10 O0 L, problem determining whether O10 module O0
EXPTIME-complete L = EL, 2-EXPTIME complete L = ALC L = ALCIQ,
undecidable L = ALCIQO.
Proof. Definition 2, ontology safe O0 w.r.t. L iff O0 deductive
conservative extension O0 w.r.t. L. Definition 2, ontology O10 module
O0 w.r.t. L O0 deductive S-conservative extension O10 = Sig(O) w.r.t.
L. Hence, algorithm checking deductive conservative extensions reused
checking safety modules.
Conversely, demonstrate algorithm checking safety modules
used checking deductive conservative extensions. Indeed, deductive conservative
extension O1 w.r.t. L iff O\O1 safe O1 w.r.t. L iff, Claim 1 Proposition 17,
O0 = module O1 \ O1 w.r.t. L .

289

fiCuenca Grau, Horrocks, Kazakov, & Sattler

Corollary 20 exist algorithms performing tasks T1, T3[a,s,u]m Table 2
L = EL L = ALCIQ run EXPTIME 2-EXPTIME respectively.
algorithm performing tasks T1, T3[a,s,u]m Table 2 L = ALCIQO.
Proof. task T1 corresponds directly problem checking safety ontology,
given Definition 2.
Suppose 2-EXPTIME algorithm that, given ontologies O, O0 O10
0
, determines whether O10 module O0 w.r.t. L = ALCIQ. demonstrate
algorithm used solve reasoning tasks T3am, T3sm T3um
L = ALCIQ 2-EXPTIME. Indeed, given ontologies O0 , one enumerate
subsets O0 check 2-EXPTIME subsets modules O0
w.r.t. L. determine modules minimal return them,
one them, union depending reasoning task.
Finally, prove solving reasoning tasks T3am, T3sm T3um
easier checking safety ontology. Indeed, Claim 1 Proposition 17,
ontology safe O0 w.r.t. L iff O0 = module O0 w.r.t. L. Note
empty ontology O0 = module O0 w.r.t. L iff O0 = minimal
module O0 w.r.t. L.
demonstrated reasoning tasks T1 T3[a,s,u]m computationally
unsolvable DLs expressive ALCQIO, 2-EXPTIME-hard ALC.
remainder section, focus computational properties reasoning
tasks T2 T4[a,s,u]m related notions safety modules signature.
demonstrate reasoning tasks undecidable DLs expressive
ALCO.
Theorem 21 (Undecidability Safety Signature) problem checking
whether ontology consisting single ALC-axiom safe signature undecidable w.r.t. L = ALCO.
Proof. proof variation construction undecidability deductive conservative extensions ALCQIO (Lutz et al., 2007), based reduction domino tiling
problem.
domino system triple = (T, H, V ) = {1, . . . , k} finite set tiles
H, V horizontal vertical matching relations. solution domino
system mapping ti,j assigns every pair integers i, j 1 element ,
hti,j , ti,j+1 H hti,j , ti+1,j V . periodic solution domino system
solution ti,j exist integers 1 , n 1 called periods
ti+m,j = ti,j ti,j+n = ti,j every i, j 1.
Let set domino systems, Ds subset admit solution
Dps subset Ds admit periodic solution. well-known (Borger, Gradel,
& Gurevich, 1997, Theorem 3.1.7) sets \ Ds Dps recursively inseparable,
is, recursive (i.e. decidable) subset D0 domino systems
Dps D0 Ds .
use property reduction. domino system D, construct
signature = S(D), ontology = O(D) consists single ALC-axiom
that:
290

fiModular Reuse Ontologies: Theory Practice

(q1 )

> v A1 Ak

= {1, . . . , k}

(q2 )

u At0 v
F
v rH .( ht,t0 iH At0 )
F
v rV .( ht,t0 iV At0 )

1 < t0 k

(q3 )
(q4 )

1tk
1tk

Figure 2: ontology Otile = Otile (D) expressing tiling conditions domino system
(a) solution = O(D) safe = S(D) w.r.t. L = ALCO,

(b) periodic solution = O(D) safe = S(D) w.r.t. L = ALCO.
words, set D0 consisting domino systems = O(D)
safe = S(D) w.r.t. L = ALCO, Dps D0 Ds . Since \ Ds Dps
recursively inseparable, implies undecidability D0 hence problem
checking S-safe w.r.t. L = ALCO, otherwise one use problem
deciding membership D0 .
signature = S(D), ontology = O(D) constructed follows. Given
domino system = (T, H, V ), let consist fresh atomic concepts every
two atomic roles rH rV . Consider ontology Otile Figure 2 constructed D. Note
Sig(Otile ) = S. axioms Otile express tiling conditions domino system
D, namely (q1 ) (q2 ) express every domain element assigned unique tile
; (q3 ) (q4 ) express every domain element horizontal vertical matching
successors.
let atomic role B atomic concept s, B
/ S. Let := {}
where:

hF
:= > v s.
(Ci vDi )Otile (Ci u Di ) (rH .rV .B u rV .rH .B)
say rH rV commute interpretation = (I , ) domain
elements a, b, c, d1 d2 ha, bi rH , hb, d1 rV , ha, ci rV ,
hc, d2 rH , d1 = d2 . following claims easily proved:
Claim 1.

Otile (D) model rH rV commute, solution.

Indeed model = (, ) Otile (D) used guide construction solution
ti,j follows. every i, j 1, construct ti,j inductively together elements
ai,j hai,j , ai,j+1 rV hai,j , ai+1,j rH . set a1,1 element
.
suppose ai,j i, j 1 constructed. Since model axioms (q1 )
(q2 ) Figure 2, unique 1 k ai,j . set
ti,j := t. Since model axioms (q3 ) (q4 ) ai,j exist b, c
t0 , t00 hai,j , bi rH , hai,j , ci rV , ht, t0 H, ht, t00 V , b At0 ,
c At00 . case assign ai,j+1 := b, ai+1,j := c, ti,j+1 := t0 , ti+1,j := t00 .
Note values ai,j ti,j assigned two times: ai+1,j+1 ti+1,j+1
constructed ai,j+1 ai,j+1 . However, since rV rH commute I, value
291

fiCuenca Grau, Horrocks, Kazakov, & Sattler

ai+1,j+1 unique, (q2 ), value ti+1,j+1 unique. easy see
ti,j solution D.
Claim 2.

model Otile O, rH rV commute I.

Indeed, easy see Otile |= (> v s.[rH .rV .B u rV .rH .B]). Hence,
= (I , ) model Otile O, exist a, b, c, d1 d2 hx, ai sI
every x , ha, bi rH , hb, d1 rV , d1 B , ha, ci rV , hc, d2 rH ,
d2 (B)I . implies d1 6= d2 , so, rh rV commute I.
Finally, demonstrate = O(D) satisfies properties (a) (b).
order prove property (a) use sufficient condition safety given Proposition 8 demonstrate solution every interpretation
exists model J J |S = I|S . Proposition 8, imply safe
w.r.t. L.
Let arbitrary interpretation. Since solution, contra-positive
Claim 1 either (1) model Otile , (2) rH rV commute I.
demonstrate cases construct required model J
J |S = I|S .
Case (1). = (I , ) model Otile exists axiom (Ci v Di )
Otile 6|= (Ci v Di ). is, exists domain element
CiI 6 DiI . Let us define J identical except interpretation
atomic role define J sJ = {hx, ai | x }. Since interpretations
symbols remained unchanged, CiJ , DiJ , J |= (> v
s.[Ci u Dj ]). implies J |= , so, constructed model J
J |S = I|S .
Case (2). Suppose rH rV commute = (I , ). means
exist domain elements a, b, c, d1 d2 ha, bi rH , hb, d1 rV ,
ha, ci rV , hc, d2 rH , d1 6= d2 . Let us define J identical except
interpretation atomic role atomic concept B. interpret J
sJ = {hx, ai | x }. interpret B J B J = {d1 }. Note (rH .rV .B)J
(rV .rH .B)J since d1 6= d2 . So, J |= (> v s.[rH .rV .B u rV .rH .B])
implies J |= , thus, constructed model J
J |S = I|S .
order prove property (b), assume periodic solution ti,j
periods m, n 1. demonstrate S-safe w.r.t. L. purpose
construct ALCO-ontology O0 Sig(O) Sig(O0 ) O0 |= (> v ),
O0 6|= (> v ). imply safe O0 w.r.t. L = ALCO, and, hence,
safe w.r.t. L = ALCO.
define O0 every model O0 finite encoding periodic solution ti,j
periods n. every pair (i, j) 1 1 j n introduce
fresh individual ai,j define O0 extension Otile following axioms:
(p1 ) {ai1 ,j } v rV .{ai2 ,j }

(p2 ) {ai1 ,j } v rV .{ai2 ,j },

i2 = i1 + 1

mod

(p3 ) {ai,j1 } v rH .{ai,j2 }

(p4 ) {ai,j1 } v rH .{ai,j2 },
j2 = j1 + 1
F
(p5 ) > v 1im, 1jn {ai,j }

mod n

292

fiModular Reuse Ontologies: Theory Practice

purpose axioms (p1 )(p5 ) ensure rH rV commute every model
O0 . easy see O0 model corresponding every periodic solution
periods n. Hence O0 6|= (> v ). hand, Claim 2, since O0 contains
Otile , every model O0 O, rH rV commute. possible
O0 models, O0 |= (> v ).
direct consequence Theorem 21 Proposition 18 undecidability
problem checking whether subset ontology module signature:
Corollary 22 Given signature ALC-ontologies O0 O10 O0 , problem
determining whether O10 S-module O0 w.r.t. L = ALCO undecidable.
Proof. Claim 1 Proposition 18, S-safe w.r.t. L O0 = S-module
w.r.t. L. Hence algorithm recognizing modules signature L used
checking ontology safe signature L.
Corollary 23 algorithm perform tasks T2, T4[a,s,u]m L =
ALCO.
Proof. Theorem 21 directly implies algorithm task T2, since task
corresponds problem checking safety signature.
Solving reasoning tasks T4am, T4sm, T4um L least hard
checking safety ontology, since, Claim 1 Proposition 18, ontology
S-safe w.r.t. L iff O0 = (the minimal) S-module w.r.t. L.

5. Sufficient Conditions Safety
Theorem 21 establishes undecidability checking whether ontology expressed
OWL DL safe w.r.t. signature. undecidability result discouraging leaves
us two alternatives: First, could focus simple DLs problem
decidable. Alternatively, could look sufficient conditions notion safety
is, ontology satisfies conditions, guarantee safe;
converse, however, necessarily hold.
remainder paper focuses latter approach. go further,
however, worth noting Theorem 21 still leaves room investigating former
approach. Indeed, safety may still decidable weaker description logics, EL,
even expressive logics SHIQ. case SHIQ, however, existing
results (Lutz et al., 2007) strongly indicate checking safety likely exponentially
harder reasoning practical algorithms may hard design. said,
follows focus defining sufficient conditions safety use practice
restrict OWL DLthat is, SHOIQontologies.
5.1 Safety Classes
general, sufficient condition safety defined giving, signature
S, set ontologies language satisfy condition signature.
ontologies guaranteed safe signature consideration.
intuitions lead notion safety class.
293

fiCuenca Grau, Horrocks, Kazakov, & Sattler

Definition 24 (Class Ontologies, Safety Class). class ontologies language
L function O() assigns every subset signature L, subset O(S)
ontologies L. class O() anti-monotonic S1 S2 implies O(S2 ) O(S1 );
compact O(S Sig(O)) O(S); subset-closed O1 O2
O2 O(S) implies O1 O(S); union-closed O1 O(S) O2 O(S) implies
(O1 O2 ) O(S).
safety class (also called sufficient condition safety) ontology language L
class ontologies O() L case (i) O(S),
(ii) ontology O(S) S-safe L.

Intuitively, class ontologies collection sets ontologies parameterized
signature. safety class represents sufficient condition safety: ontology O(S)
safe S. Also, w.l.o.g., assume empty ontology belongs
every safety class every signature. follows, whenever ontology belongs
safety class given signature safety class clear context,
sometimes say passes safety test S.
Safety classes may admit many natural properties, given Definition 24. Antimonotonicity intuitively means ontology proved safe w.r.t.
using sufficient condition, proved safe w.r.t. every subset S.
Compactness means sufficient consider common elements Sig(O)
checking safety. Subset-closure (union closure) means (O1 O2 ) satisfy
sufficient condition safety, every subset (the union O1 O2 ) satisfies
condition.
5.2 Locality
section introduce family safety classes L = SHOIQ based
semantic properties underlying notion model conservative extensions. Section 3,
seen that, according Proposition 8, one way prove S-safe show
model S-conservative extension empty ontology.
following definition formalizes classes ontologies, called local ontologies,
safety proved using Proposition 8.
Definition 25 (Class Interpretations, Locality). Given SHOIQ signature S,
say set interpretations local w.r.t. every SHOIQ-interpretation
exists interpretation J I|S = J |S .
class interpretations function I() given SHOIQ signature returns set
interpretations I(S); local I(S) local w.r.t. every S; monotonic S1 S2
implies I(S1 ) I(S2 ); compact every S1 , S2 (S1 S2 ) =
I(S1 )|S = I(S2 )|S , S1 S2 symmetric difference sets S1
S2 defined S1 S2 := S1 \ S2 S2 \ S1 .
Given class interpretations I(), say O() class ontologies O() based
I() every S, O(S) set ontologies valid I(S); I() local
say O() class local ontologies, every O(S) every
O, say local (based I()).


294

fiModular Reuse Ontologies: Theory Practice

r
Example 26 Let IA
() class SHOIQ interpretations defined follows. Given
r
signature S, set IA (S) consists interpretations J rJ = every atomic
r
role r
/ AJ = every atomic concept
/ S. easy show IA
(S)


local every S, since every interpretation = ( , ) interpretation
J = (J , J ) defined J := , rJ = r
/ S, AJ =
/ S, X J := X
r
r
r
remaining symbols X, J IA (S) I|S = J |S . Since IA
(S1 ) IA
(S2 )
r
r
every S1 S2 , case IA () monotonic; IA () compact, since
r
r
(S2 ) defined differently
(S1 ) IA
every S1 S2 sets interpretations IA
elements S1 S2 .
r
r
Given signature S, set AxA
(S) axioms local w.r.t. based IA
(S)
r
consists axioms every J IA (S), case J |= .
r
r
r
(S).
(S) iff AxA
() defined OA
class local ontologies based IA


Proposition 27 (Locality Implies Safety) Let O() class ontologies SHOIQ
based local class interpretations I(). O() subset-closed union-closed
safety class L = SHOIQ. Additionally, I() monotonic, O() anti-monotonic,
I() compact O() compact.
Proof. Assume O() class ontologies based I(). Definition 25
every SHOIQ signature S, O(S) iff valid I(S) iff J |= every
interpretation J I(S). Since I() local class interpretations,
every SHOIQ-interpretation exists J I(S) J |S = I|S . Hence
every I(S) every SHOIQ interpretation model J I(S)
J |S = I|S , implies Proposition 8 safe w.r.t. L = SHOIQ. Thus
O() safety class.
fact O() subset-closed union-closed follows directly Definition 25
since (O1 O2 ) O(S) iff (O1 O2 ) valid I(S) iff O1 O2 valid I(S) iff
O1 O(S) O2 O(S). I() monotonic I(S1 ) I(S2 ) every S1 S2 ,
O(S2 ) implies valid I(S2 ) implies valid I(S1 )
implies O(S1 ). Hence O() anti-monotonic.
I() compact every S1 , S2 (S1 S2 ) =
I(S1 )|S = I(S2 )|S , hence every Sig(O) valid
I(S1 ) iff valid I(S2 ), so, O(S1 ) iff O(S2 ). particular, O(S) iff
O(S Sig(O)) since (S (S Sig(O))) Sig(O) = (S \ Sig(O)) Sig(O) = . Hence,
O() compact.
r
Corollary 28 class ontologies OA
(S) defined Example 26 anti-monotonic
compact subset-closed union-closed safety class.

Example 29 Recall Example 5 Section 3, demonstrated ontology
P1 Q given Figure 1 P1 = {P1, . . . , P4, E1} deductive conservative extension
Q = {Cystic Fibrosis, Genetic Disorder}. done showing every
S-interpretation expanded model J axioms P1P4, E1 interpreting
symbols Sig(P1 ) \ empty set. terms Example 26 means
295

fiCuenca Grau, Horrocks, Kazakov, & Sattler

r
r
P1 OA
(S). Since OA
() class local ontologies, Proposition 27, ontology
P1 safe w.r.t. L = SHOIQ.


Proposition 27 Example 29 suggest particular way proving safety ontologies. Given SHOIQ ontology signature sufficient check whether
r
(S); is, whether every axiom satisfied every interpretation
OA
r
IA (S). property holds, must safe according Proposition 27.
turns notion provides powerful sufficiency test safety works
surprisingly well many real-world ontologies, shown Section 8. next
section discuss perform test practice.
5.3 Testing Locality
r
section, focus detail safety class OA
(), introduced Example 26. ambiguity arise, refer safety class simply locality.2
r
definition AxA
(S) given Example 26 easy see axiom
r
local w.r.t. (based IA (S)) satisfied every interpretation fixes interpretation atomic roles concepts outside empty set. Note defining
locality fix interpretation individuals outside S, principle,
could done. reason elegant way describe interpretations.
Namely, every individual needs interpreted element domain,
canonical element every domain choose.
order test locality w.r.t. S, sufficient interpret every atomic concept
atomic role empty set check satisfied interpretations
remaining symbols. observation suggests following test locality:

Proposition 30 (Testing Locality) Given SHOIQ signature S, concept C, axiom
ontology let (C, S), (, S) (O, S) defined recursively follows:
(C, S) ::=

(>, S)
| (A, S)
| ({a}, S)
| (C1 u C2 , S)
| (C1 , S)
| (R.C1 , S)
| (> n R.C 1 , S)

= >;
=
/ otherwise = A;
= {a};
= (C1 , S) u (C2 , S);
= (C1 , S);
= Sig(R) * otherwise = R. (C1 , S);
= Sig(R) * otherwise = (> n R. (C1 , S)).

(C1 v C2 , S) = ( (C1 , S) v (C2 , S));
| (R1 v R2 , S) = ( v ) Sig(R1 ) * S, otherwise
= R1 .> v Sig(R2 ) * S, otherwise = (R1 v R2 );
| (a : C, S)
= : (C, S);
| (r(a, b), S)
= > v r
/ otherwise = r(a, b);
| (Trans(r), S) = v r
/ otherwise = Trans(r);
| (Funct(R), S) = v Sig(R) * otherwise = Funct(R).

(O, S) ::=
(, S)
(, S) ::=

2. notion locality exactly one used previous work (Cuenca Grau et al., 2007).

296

(a)
(b)
(c)
(d)
(e)
(f )
(g)
(h)
(i)
(j)
(k)
(l)
(m)
(n)

fiModular Reuse Ontologies: Theory Practice

r
Then, OA
(S) iff every axiom (O, S) tautology.

Proof. easy check every atomic concept atomic role r (C, S),
r S, words, atomic concepts roles
eliminated transformation.3 easy show induction every
r
interpretation IA
(S), C = ( (C, S))I |= iff |= (, S). Hence
r
axiom local w.r.t. iff |= every interpretation IA
(S) iff |= (, S)
r
every Sig()-interpretation IA (S) iff (, S) tautology.
Example 31 Let = {} ontology consisting axiom = M2 Figure 1.
demonstrate using Proposition 30 local w.r.t. S1 = {Fibrosis, Genetic Origin},
local w.r.t. S2 = {Genetic Fibrosis, Origin}.
Indeed, according Proposition 30, order check whether local w.r.t. S1
sufficient perform following replacements (the symbols S1 underlined):

M2

[by (f)]
[by (b)]
}|
{
z
}|
{
z
Genetic Fibrosis Fibrosis u Origin.Genetic Origin

(7)

Similarly, order check whether local w.r.t. S2 , sufficient perform
following replacements (the symbols S2 underlined):
[by (b)]
[by (b)]
}|
{
z }| {
z
M2 Genetic Fibrosis Fibrosis u Origin.Genetic Origin

(8)

first case obtain (M2, S1 ) = ( Fibrosis u ) SHOIQ-tautology.
Hence local w.r.t. S1 hence Proposition 8 S1 -safe w.r.t. SHOIQ.
second case (M2, S2 ) = (Genetic Fibrosis u Origin.) SHOIQ
tautology, hence local w.r.t. S2 .

5.4 Tractable Approximation Locality
One important conclusions Proposition 30 one use standard capabilities available DL-reasoners FaCT++ (Tsarkov & Horrocks, 2006), RACER
(Moller & Haarslev, 2003), Pellet (Sirin & Parsia, 2004) KAON2 (Motik, 2006) testing
locality since reasoners, among things, allow testing DL-tautologies. Checking tautologies description logics is, theoretically, difficult problem (e.g.
DL SHOIQ known NEXPTIME-complete, Tobies, 2000). are, however,
several reasons believe locality test would perform well practice. primary
reason sizes axioms need tested tautologies usually
relatively small compared sizes ontologies. Secondly, modern DL reasoners
highly optimized standard reasoning tasks behave well realistic ontologies.
case reasoning costly, possible formulate tractable approximation
locality conditions SHOIQ:
3. Recall constructors , C1 C2 , R.C, (6 n R.C) assumed expressed using >,
C1 u C2 , R.C (> n R.C), hence, particular, every role R Sig(R ) * occurs either
R .C, (> n R .C), R v R, R v R , Trans(R ), Funct(R ), hence eliminated. atomic
concepts
/ eliminated likewise. Note necessarily case Sig( (, S)) S,
since (, S) may still contain individuals occur S.

297

fiCuenca Grau, Horrocks, Kazakov, & Sattler

Definition 32 (Syntactic Locality SHOIQ). Let signature. following
grammar recursively defines two sets concepts Con(S) Con(S) signature S:
Con(S) ::= | C | C u C | C u C | R .C | R.C | (> n R .C) | (> n R.C ) .
Con(S) ::= > | C | C1 u C2 .

/ atomic concept, R (possibly inverse of) atomic role r
/ S, C
Con(S), {1, 2}.
concept, R role, C Con(S), C(i)
axiom syntactically local w.r.t. one following forms: (1) R v R,
(2) Trans(r ), (3) Funct(R ), (4) C v C, (5) C v C , (6) : C . denote
r
AxA
(S) set SHOIQ-axioms syntactically local w.r.t. S.
r
SHOIQ-ontology syntactically local w.r.t. AxA
(S). denote
r
OA (S) set SHOIQ ontologies syntactically local w.r.t. S.

Intuitively, syntactic locality provides simple syntactic test ensure axiom
r
satisfied every interpretation IA
(S). easy see inductive definitions


Con (S) Con (S) Definition 32 every interpretation = (I , )
r
IA
(S) case (C )I = (C )I = every C Con(S)

C Con(S). Hence, every syntactically local axiom satisfied every interpretation
r
IA
(S), obtain following conclusion:
r
r
Proposition 33 AxA
(S) AxA
(S).

Further, shown safety class SHOIQ based syntactic locality
enjoys properties Definition 24:
r
Proposition 34 class syntactically local ontologies OA
() given Definition 32
anti-monotonic, compact, subset-closed, union-closed safety class.
r
r
() safety class Proposition 33. Anti-monotonicity OA
()
Proof. OA



shown induction, proving Con (S2 ) Con (S1 ), Con (S2 ) Con(S1 )
r
r
AxA
(S2 ) AxA
(S1 ) S1 S2 . one show induction
r
r
r
r


AxA (S) iff AxA (S Sig()), OA
() compact. Since OA
(S)
r
r

iff AxA (S), OA () subset-closed union-closed.

Example 35 (Example 31 continued) easy see axiom M2 Figure 1
syntactically local w.r.t. S1 = {Fibrosis, Genetic Origin}. indicate sub-concepts
Con(S1 ):

M2

Con(S1 ) [matches ]
Con(S1 ) [matches R .C]
z
}|
{
z
}|
{
Genetic Fibrosis Fibrosis u Origin.Genetic Origin
(9)
|
{z
}
Con(S1 ) [matches C u C ]

easy show similar way axioms P1 P4, E1 Figure 1 syntactically local w.r.t. = {Cystic Fibrosis, Genetic Disorder}. Hence ontology P1 =
{P1, . . . , P4, E1} considered Example 29 syntactically local w.r.t. S.

298

fiModular Reuse Ontologies: Theory Practice

r (S)
IA

r, 6 :

r
IA
(S)
r
IA
(S)
rid (S)
IA

rJ

AJ

r (S)
IA





r
IA
(S)



r
IA
(S)



rid (S)
IA

J J
{hx, xi | x J }

r, 6 :

rJ

AJ



J

J J
{hx, xi | x J }

J
J

Table 3: Examples Different Local Classes Interpretations
converse Proposition 33 hold general since semantically
local axioms syntactically local. example, axiom = (A v B)
local w.r.t. every since tautology (and hence true every interpretation).
hand, easy see syntactically local w.r.t. = {A, B} according
Definition 32 since involves symbols only. Another example, tautology,
GCI = (r.A v r.B). axiom semantically local w.r.t. = {r}, since
(, S) = (r. v r.) tautology, syntactically local. examples show
limitation syntactic notion locality inability compare different
occurrences concepts given signature S. result, syntactic locality
detect tautological axioms. reasonable assume, however, tautological axioms
occur often realistic ontologies. Furthermore, syntactic locality checking
performed polynomial time matching axiom according Definition 32.
Proposition 36 exists algorithm given SHOIQ ontology sigr
nature S, determines whether OA
(S), whose running time polynomial
|O| + |S|, |O| |S| number symbols occurring respectively.4
5.5 Locality Classes
r
locality condition given Example 26 based class local interpretations IA
()
particular example locality used testing safety. classes
local interpretations constructed similar way fixing interpretations
elements outside different values. Table 3 listed several classes
local interpretations fix interpretation atomic roles outside either
empty set , universal relation , identity relation id ,
interpretation atomic concepts outside either empty set set
elements.
local class interpretations Table 3 defines corresponding class local
ontologies analogously Example 26. Table 4 listed classes together
examples typical types axioms used ontologies. axioms assumed
extension project ontology Figure 1. indicate axioms
local w.r.t. locality conditions assuming, usual, symbols
underlined.
seen Table 4 different types locality conditions appropriate
r
different types axioms. locality condition based IA
(S) captures domain
axiom P4, definition P5, disjointness axiom P6, functionality axiom P7

4. assume numbers number restrictions written using binary coding.

299

fiCuenca Grau, Horrocks, Kazakov, & Sattler

r


r


rid


r


r


rid


3

7

7

3

3

3

3

3

3

7

7

7

P6 Project u Bio Medicine v

3

3

3

7

7

7

P7 Funct(has Focus)

3

7

3

3

7

3

P8 Human Genome : Project

7

7

7

3

3

3

P9 Focus(Human Genome, Gene)

7

3

7

7

3

7

7

7

7

7

7

7



? Ax

Axiom

P4 Focus.> v Project
P5

E2

BioMedical Project Project u
u Focus.Bio Medicine

Focus.Cystic Fibrosis v
v Focus.Cystic Fibrosis

Table 4: Comparison Different Types Locality Conditions

neither assertions P8 P9, since individuals Human Genome Gene prevent
us interpreting atomic role Focus atomic concept Project empty
r
(S), atomic roles concepts outside
set. locality condition based IA
interpreted largest possible sets, capture assertions generally
poor types axioms. example, functionality axiom P7 captured
locality condition since atomic role Focus interpreted universal
relation , necessarily functional. order capture functionality
rid (S) rid (S), every atomic role outside
axioms, one use locality based IA

interpreted identity relation id interpretation domain. Note
modeling error E2 local given locality conditions. Note
possible come locality condition captures axioms P4P9, since
P6 P8 together imply axiom = ({Human Genome} u Bio Medicine v )
uses symbols only. Hence, every subset P containing P6 P8 safe
w.r.t. S, cannot local w.r.t. S.
might possible come algorithms testing locality conditions
classes interpretation Table 3 similar ones presented Proposition 30.
r
example, locality based class IA
(S) tested Proposition 30,
case (a) definition (C, S) replaced following:
(A, S)

= >
/ otherwise =

(a0 )

r
rid (S), checking
remaining classes interpretations, IA
(S) IA
locality, however, straightforward, since clear eliminate
universal roles identity roles axioms preserve validity respective
classes interpretations.
Still, easy come tractable syntactic approximations locality
conditions considered section similar manner done Section 5.4. idea used Definition 32, namely define two sets
Con(S) Con(S) concepts signature interpreted empty

300

fiModular Reuse Ontologies: Theory Practice

Con(S) ::= C | C u C | C u C

Con(S) ::= > | C | C1 u C2

| R.C | > n R.C

r ():
IA

|

r ():
IA

|

r
IA
():

| R .C | (> n R .C )

r
IA
():

| R .C | > n R .C

rid ():
IA

| Rid .C | (> 1 Rid .C ) .

rid ():
IA

| (> Rid .C), 2 .

r (S) ::= C v C | C v C | : C
AxA
r
IA
():

| R v R | Trans(r ) | Funct(R )

r
IA
():

| R v R | Trans(r ) | r (a, b)

rid ():
IA

| Trans(rid ) | Funct(Rid )

Where:
, , r , r , rid 6 S;
Sig(R ), Sig(R ), Sig(Rid ) * S;
Con(S);
C Con(S), C(i)
C concept, R role

Figure 3: Syntactic Locality Conditions Classes Interpretations Table 3
set and, respectively, every interpretation class see situations DL-constructors produce elements sets. Figure 3 gave recursive
r (S) correspond classes r (S)
definitions syntactically local axioms AxA

interpretations Table 3, cases recursive definitions present
indicated classes interpretations.
5.6 Combining Extending Safety Classes
previous section gave examples several safety classes based different local
classes interpretations demonstrated different classes suitable different
types axioms. order check safety ontologies practice, one may try apply
different sufficient tests check succeeds. Obviously, gives
powerful sufficient condition safety, seen union safety classes
used tests.
Formally, given two classes ontologies O1 () O2 (), union (O1 O2 )()
class ontologies defined (O1 O2 )(S) = O1 (S)O2 (S). easy see Definition 24
O1 () O2 () safety classes union (O1 O2 )() safety
class. Moreover, safety classes anti-monotonic subset-closed,
union anti-monotonic, respectively, subset-closed well. Unfortunately unionclosure property safety classes preserved unions, demonstrated
following example:
r
r
Example 37 Consider union (OA
OA
)() two classes local ontologies
r
r
OA () OA () defined Section 5.5. safety class union-closed since,
example, ontology O1 consisting axioms P4P7 Table 4 satisfies first
locality condition, ontology O2 consisting axioms P8P9 satisfies second locality
condition, union O1 O2 satisfies neither first second locality condition
and, fact, even safe shown Section 5.5.


shown Proposition 33, every locality condition gives union-closed safety class;
however, seen Example 37, union safety classes might longer unionclosed. One may wonder locality classes already provide powerful sufficient
301

fiCuenca Grau, Horrocks, Kazakov, & Sattler

conditions safety satisfy desirable properties Definition 24. Surprisingly
case certain extent locality classes considered Section 5.5.
Definition 38 (Maximal Union-Closed Safety Class). safety class O2 () extends
safety class O1 () O1 (S) O2 (S) every S. safety class O1 () maximal unionclosed language L O1 () union-closed every union-closed safety class O2 ()
extends O1 () every L O2 (S) implies O1 (S).

r
r
Proposition 39 classes local ontologies OA
() OA
() defined Section 5.5
maximal union-closed safety classes L = SHIQ.

Proof. According Definition 38, safety class O() maximal union-closed
language L, exists signature ontology L, (i)
/
O(S), (ii) safe w.r.t. L, (iii) every P O(S), case P
safe w.r.t. L; is, every ontology Q L Sig(Q) Sig(O P)
case P Q deductive conservative extension Q. demonstrate
r
r
possible O() = OA
() O() = OA
()
r
first consider case O() = OA () show modify proof
r
case O() = OA
().
Let ontology L satisfies conditions (i)(iii) above. define ontologies
P Q follows. Take P consist axioms v r.> v every atomic
r
concept atomic role r Sig(O) \ S. easy see P OA
(S). Take Q
consist tautologies form v v r.> every A, r S. Note
Sig(O P) Sig(Q) S. claim P Q deductive Sig(Q)-conservative
extension Q.
(])
r
Intuitively, ontology P chosen way P OA
(S) P Q
r
models IA
(S). Q ontology implies nothing tautologies
uses atomic concepts roles S.
r
r
Since
/ OA
(S), exists axiom
/ AxA
(S). Let
:= (, S) (, ) defined Proposition 30. shown proof
r
proposition, |= iff |= every IA
(S). Now, since |= P Q
r
models IA (S), case P Q |= . Proposition 30, since
r
contain individuals, Sig() = Sig(Q) and, since
/ AxA
(S),
tautology, thus Q 6|= . Hence, Definition 1, P Q deductive
Sig(Q)-conservative extension Q (]).
r
O() = OA
() proof repeated taking P consist axioms > v
r.> v A, r Sig(O) \ S, modifying (, ) discussed
Section 5.5.
difficulties extending proof Proposition 39 locality
classes considered Section 5.5. First, clear force interpretations roles
universal identity relation using SHOIQ axioms. Second, clear
define function (, ) cases (see related discussion Section 5.5). Note
proof Proposition 39 work presence nominals, since
guarantee = (, S) contains symbols (see Footnote 3
r
r
p. 297). Hence probably room extend locality classes OA
() OA
()
L = SHOIQ preserving union-closure.
302

fiModular Reuse Ontologies: Theory Practice

6. Extracting Modules Using Safety Classes
section revisit problem extracting modules ontologies. shown
Corollary 23 Section 4, exists general procedure recognize extract
(minimal) modules signature ontology finite time.
techniques described Section 5, however, reused extracting particular
families modules satisfy certain sufficient conditions. Proposition 18 establishes
relationship notions safety module; precisely, subset O1
S-module provided \ O1 safe Sig(O1 ). Therefore, safety class
O() provide sufficient condition testing modulesthat is, order prove
O1 S-module O, sufficient show \ O1 O(S Sig(O1 )). notion
modules based property defined follows.
Definition 40 (Modules Based Safety Class).
Let L ontology language O() safety class L. Given ontology
signature L, say Om O()-based S-module \ Om
O(S Sig(Om )).

Remark 41 Note every safety class O(), ontology signature S, exists
least one O()-based S-module O, namely itself; indeed, Definition 24, empty
ontology = \ belongs O(S) every O() S.
Note follows Definition 40 Om O()-based S-module iff
Om O()-based S0 -module every S0 S0 (S Sig(Om )).

clear that, according Definition 40, procedure checking membership
safety class O() used directly checking whether Om module based O().
order extract O()-module, sufficient enumerate possible subsets
ontology check subsets module based O().
practice, however, possible avoid checking possible subsets
input ontology. Figure 4 presents optimized version module-extraction algorithm.
procedure manipulates configurations form Om | Ou | Os , represent
partitioning ontology three disjoint subsets Om , Ou Os . set Om
accumulates axioms extracted module; set Os intended safe w.r.t.
Sig(Om ). set Ou , initialized O, contains unprocessed axioms.
axioms distributed among Om Os according rules R1 R2. Given axiom
Ou , rule R1 moves Os provided Os remains safe w.r.t. Sig(Om ) according
safety class O(). Otherwise, rule R2 moves Om moves axioms
Os back Ou , since Sig(Om ) might expand axioms Os might become longer
safe w.r.t. Sig(Om ). end process, axioms left Ou ,
set Om O()-based module O.
rewrite rules R1 R2 preserve invariants I1I3 given Figure 4. Invariant I1
states three sets Om , Ou Os form partitioning O; I2 states set Os
satisfies safety test Sig(Om ) w.r.t. O(); finally, I3 establishes rewrite
rules either add elements Om , add elements Os without changing Om ;
words, pair (|Om |, |Os |) consisting sizes sets increases lexicographical
order.
303

fiCuenca Grau, Horrocks, Kazakov, & Sattler

Input:

ontology O, signature S, safety class O()

Output:

module Om based O()
unprocessed


Configuration: Om | Ou | Os ;




module

safe

Initial Configuration =

|O|

Termination Condition: Ou =

Rewrite rules:
R1. Om | Ou {} | Os = Om | Ou | Os {}

(Os {}) O(S Sig(Om ))

R2. Om | Ou {} | Os = Om {} | Ou Os |

(Os {}) 6 O(S Sig(Om ))

Invariants Om | Ou | Os :
I1. = Om ] Ou ] Os

0 | O0 | O0 :
Invariant Om | Ou | Os = Om
u

0 |, |O 0 |)
I3. (|Om |, |Os |) <lex (|Om


I2. Os O(S Sig(Om ))
Figure 4: Procedure Computing Modules Based Safety Class O()
Proposition 42 (Correctness Procedure Figure 4) Let O() safety
class ontology language L, ontology L, signature L. Then:
(1) procedure Figure 4 input O, S, O() terminates returns O()based S-module Om O;
(2) If, additionally, O() anti-monotonic, subset-closed union-closed,
unique minimal O()-based S-module O, procedure returns precisely
minimal module.
Proof. (1) procedure based rewrite rules Figure 4 always terminates
following reasons: (i) every configuration derived rewrite rules, sets Om ,
Ou Os form partitioning (see invariant I1 Figure 4), therefore size
every set bounded; (ii) rewrite step, (|Om |, |Os |) increases lexicographical
order (see invariant I3 Figure 4). Additionally, Ou 6= always possible
apply one rewrite rules R1 R2, hence procedure always terminates
Ou = . Upon termination, invariant I1 Figure 4, partitioned Om Os
invariant I2, Os O(S Sig(Om )), implies, Definition 40, Om
O()-based S-module O.
(2) Now, suppose that, addition, O() anti-monotonic, subset-closed, union0 O()-based S-module O. demonstrate
closed safety class, suppose Om
induction every configuration Om | Ou | Os derivable | | rewrite
0 . prove module computed
rules R1 R2, case Om Om
procedure subset every O()-based S-module O, hence, smallest
O()-based S-module O.
0 . rewrite rule R1 change
Indeed, base case Om = Om
set Om . rewrite rule R2 have: Om | Ou {} | Os = Om {} | Ou Os |
(Os {}) 6 O(S Sig(Om )).
(])
304

fiModular Reuse Ontologies: Theory Practice

Input: ontology O, signature S, safety class O()
Output: module Om based O()
Initial Configuration =

|O|

Termination Condition: Ou =

Rewrite rules:
R1.

Om | Ou {} | Os = Om | Ou | Os {}

{} O(S Sig(Om ))

R2. Om | Ou {} | Os Os = Om {} | Ou Os | Os {} 6 O(S Sig(Om )),
Sig(Os ) Sig() Sig(Om )
Figure 5: Optimized Procedure Computing Modules Based Compact SubsetClosed Union-Closed Safety Class O()
0 {} * 0 . 0 := \ 0 .
Suppose, contrary, Om Om




0 O()-based S-module O, 0 O(S Sig(O 0 )). Since O()
Since Om


0 )). Since
0
subset-closed, {} O(S Sig(Om
Om O() anti-monotonic,
{} O(S Sig(Om )). Since invariant I2 Figure 4, Os O(S Sig(Om ))
O() union-closed, Os {} O(S Sig(Om )), contradicts (]). contradiction
0 .
implies rule R2 preserves property Om Om

Claim (1) Proposition 42 establishes procedure Figure 4 terminates
every input produces module based given safety class. Moreover, possible
show procedure runs polynomial time assuming safety test
performed polynomial time.
safety class O() satisfies additional desirable properties, based classes
local interpretations described Section 5.2, procedure, fact, produces smallest
possible module based safety class, stated claim (2) Proposition 42.
case, possible optimize procedure shown Figure 4. O() union closed,
then, instead checking whether (Os {}) O(S Sig(Om )) conditions rules
R1 R2, sufficient check {} O(S Sig(Om )) since already known
Os O(S Sig(Om )). O() compact subset closed, instead moving
axioms Os Ou rule R2, sufficient move axioms Os contain
least one symbol occur Om before, since set remaining
axioms stay O(S Sig(Om )). Figure 5 present optimized version
algorithm Figure 4 locality classes.
Example 43 Table 5 present trace algorithm Figure 5 ontology
consisting axioms M1M5 Figure 1, signature = {Cystic Fibrosis, Genetic Disorder}
r
safety class O() = OA
() defined Example 26. first column table lists
configurations obtained initial configuration | | applying rewrite
rules R1 R2 Figure 5; row, underlined axiom one
tested safety. second column table shows elements Sig(Om )
appeared current configuration present preceding
configurations. last column indicate whether first conditions rules R1
r
R2 fulfilled selected axiom Ou is, whether local IA
().
rewrite rule corresponding result test applied configuration.
305

fiCuenca Grau, Horrocks, Kazakov, & Sattler

Om | Ou , | Os

New elements Sig(Om )

1 | M1, M2, M3, M4, M5 | Cystic Fibrosis, Genetic Disorder

{} O(S Sig(Om ))?
Yes



R1

2

| M1, M3, M4, M5 | M2



Yes



R1

3

| M1, M4, M5 | M2, M3







R2

4

M1 | M2, M3, M4, M5 |

Fibrosis, located In, Pancreas,
Origin, Genetic Origin





R2

5

M1, M3 | M2, M4, M5 |

Genetic Fibrosis





R2

6

M1, M3, M4 | M2, M5 |



Yes



R1

7

M1, M3, M4 | M2 | M5







R2

8

M1, M2, M3, M4 | | M5



Table 5: trace Procedure Figure 5 input Q = {M1, . . . , M5} Figure 1
= {Cystic Fibrosis, Genetic Disorder}

Note axioms tested safety several times different configurations,
set Ou may increase applications rule R2; example, axiom
= M2 tested safety configurations 1 7, = M3 configurations
2 4. Note different results locality tests obtained cases:
M2 M3 local w.r.t. Sig(Om ) Om = , became non-local
new axioms added Om . easy see that, case, syntactic locality
produces results tests.
example, rewrite procedure produces module Om consisting axioms M1
M4. Note possible apply rewrite rules different choices axiom
Ou , results different computation. words, procedure
Figure 5 implicit non-determinism. According Claim (2) Proposition 42
r
computations produce module Om , smallest OA
()-based
S-module O; is, implicit non-determinism procedure Figure 5
impact result procedure. However, alternative choices
may result shorter computations: example could selected axiom M1
first configuration instead M2 would led shorter trace consisting
configurations 1, 48 only.

worth examining connection S-modules ontology based
particular safety class O() actual minimal S-modules O. turns
O()-based module Om guaranteed cover set minimal modules, provided
O() anti-monotonic subset-closed. words, given S, Om contains
S-essential axioms O. following Lemma provides main technical argument
underlying result.
Lemma 44 Let O() anti-monotonic subset-closed safety class ontology language L, ontology, signature L. Let O1 S-module w.r.t. L
Om O()-based S-module O. O2 := O1 Om S-module w.r.t. L.
306

fiModular Reuse Ontologies: Theory Practice

Proof. Definition 40, since Om O()-based S-module O, \ Om
O(S Sig(Om )). Since O1 \ O2 = O1 \ Om \ Om O() subset-closed, case
O1 \ O2 O(S Sig(Om )). Since O() anti-monotonic, O2 Om ,
O1 \ O2 O(S Sig(O2 )), hence, O2 O()-based S-module O1 . particular O2
S-module O1 w.r.t. L. Since O1 S-module w.r.t. L, O2 S-module
w.r.t. L.
Corollary 45 Let O() anti-monotonic, subset-closed safety class L Om
O()-based S-module O. Om contains S-essential axioms w.r.t. L.
Proof. Let O1 minimal S-module w.r.t. L. demonstrate O1 Om . Indeed,
otherwise, Lemma 44, O1 Om S-module w.r.t. L strictly contained
O1 . Hence Om superset every minimal S-module hence, contains
S-essential axioms w.r.t. L.
shown Section 3.4, axioms M1M4 essential ontology
signature considered Example 43. seen example locality-based
S-module extracted contains axioms, accordance Corollary 45.
case, extracted module contains essential axioms; general, however, localitybased modules might contain non-essential axioms.
interesting application modules pruning irrelevant axioms checking
axiom implied ontology O. Indeed, order check whether |=
suffices retrieve module Sig() verify implication holds w.r.t.
module. cases, sufficient extract module subset signature
which, general, leads smaller modules. particular, order test subsumption
pair atomic concepts, safety class used enjoys nice properties
suffices extract module one them, given following proposition:
Proposition 46 Let O() compact union-closed safety class ontology language
L, ontology A, B atomic concepts. Let OA O()-based module
= {A} O. Then:
1 |= := (A v B) {B v } O() OA |= ;
2 |= := (B v A) {> v B} O() OA |= ;
Proof. 1. Consider two cases: (a) B Sig(OA ) (b) B
/ Sig(OA ).
(a) Remark 41 case OA O()-based module = {A, B}.
Since Sig() S, Definition 12 Definition 1, case |= implies
OA |= .
(b) Consider O0 = {B v }. Since Sig(B v ) = {B} B
/ Sig(OA ), {B v }
O() O() compact, Definition 24 case {B v } O(S Sig(OA )).
Since OA O()-based S-module O, Definition 40, \ OA O(S Sig(OA )).
Since O() union-closed, case (O \ OA ) {B v } O(S Sig(OA )). Note
B v 6 OA , since B 6 Sig(OA ), hence (O \ OA ) {B v } = O0 \ OA , and,
Definition 40, OA O()-based S-module O0 . Now, since |= (A v B),
case O0 |= (A v ), hence, since OA module O0 = {A},
OA |= (A v ) implies OA |= (A v B).
307

fiCuenca Grau, Horrocks, Kazakov, & Sattler

2. proof case analogous Case 1: Case (a) applicable without
changes; Case (b) show OA O()-based module = {A} O0 =
{> v B}, and, hence, since O0 |= (> v A), case OB |= (> v A),
implies O0 |= (B v A).
r ()
Corollary 47 Let SHOIQ ontology A, B atomic concepts. Let OA
r () locality classes based local classes interpretations form r ()
OA

r
r ()
IA (), respectively, Table 3. Let OA module = {A} based OA
r (). |= (A v B) iff |= (A v B) iff
OB module = {B} based OA

OB |= (A v B).
r () {> v A} r ().
Proof. easy see {B v } OA


Proposition 46 implies module based safety class single atomic concept
used capturing either super-concepts (Case 1), sub-concepts (Case
2) B A, provided safety class captures, applied empty signature,
axioms form B v (Case 1) (> v B) (Case 2). is, B super-concept
sub-concept ontology module. property
used, example, optimize classification ontologies. order check
subsumption v B holds ontology O, sufficient extract module
= {A} using modularization algorithm based safety class
ontology {B v } local w.r.t. empty signature, check whether subsumption
holds w.r.t. module. purpose, convenient use syntactically tractable
approximation safety class use; example, one could use syntactic locality
conditions given Figure 3 instead semantic counterparts.
possible combine modularization procedures obtain modules smaller
ones obtained using procedures individually. example, order check
r ()-based module
subsumption |= (A v B) one could first extract OA
1
= {A} O; Corollary 47 module complete super-concepts
O, including Bthat is, atomic concept super-concept O,
r ()-based module = {B}
super-concept M1 . One could extract OA
2
M1 which, Corollary 47, complete sub-concepts B M1 , including A.
Indeed, M2 S-module M1 = {A, B} M1 S-module original
ontology O. Proposition 46, therefore, case M2 S-module O.

7. Related Work
seen Section 3 notion conservative extension valuable formalization ontology reuse tasks. problem deciding conservative extensions
recently investigated context ontologies (Ghilardi et al., 2006; Lutz et al., 2007;
Lutz & Wolter, 2007). problem deciding whether P Q deductive S-conservative
extension Q EXPTIME-complete EL (Lutz & Wolter, 2007), 2-EXPTIME-complete
w.r.t. ALCIQ (Lutz et al., 2007) (roughly OWL-Lite), undecidable w.r.t. ALCIQO
(roughly OWL DL). Furthermore, checking model conservative extensions already undecidable EL (Lutz & Wolter, 2007), ALC even semi-decidable (Lutz
et al., 2007).
308

fiModular Reuse Ontologies: Theory Practice

last years, rapidly growing body work developed
headings Ontology Mapping Alignment, Ontology Merging, Ontology Integration,
Ontology Segmentation (Kalfoglou & Schorlemmer, 2003; Noy, 2004a, 2004b). field
rather diverse roots several communities.
particular, numerous techniques extracting fragments ontologies purposes knowledge reuse proposed. techniques rely syntactically
traversing axioms ontology employing various heuristics determine
axioms relevant not.
example procedure algorithm implemented Prompt-Factor
tool (Noy & Musen, 2003). Given signature ontology Q, algorithm retrieves fragment Q1 Q follows: first, axioms Q mention
symbols added Q1 ; second, expanded symbols Sig(Q1 ).
steps repeated fixpoint reached. example Section 3, =
{Cystic Fibrosis, Genetic Disorder}, Q consists axioms M1M5 Figure 1, algorithm first retrieves axioms M1, M4, M5 containing terms, expands
symbols mentioned axioms, contains symbols Q.
step, remaining axioms Q retrieved. Hence, fragment extracted
Prompt-Factor algorithm consists axioms M1-M5. case, PromptFactor algorithm extracts module (though minimal one). general, however,
extracted fragment guaranteed module. example, consider ontology
Q = {A A, B v C} = (C v B). ontology Q inconsistent due
axiom A: axiom (and particular) thus logical consequence Q. Given
= {B, C}, Prompt-Factor algorithm extracts Q2 = {B v C}; however, Q2 6|= ,
Q2 module Q. general, Prompt-Factor algorithm may fail even Q
consistent. example, consider ontology Q = {> v {a}, v B}, = (A v r.A),
= {A}. easy see Q consistent, admits single element models,
satisfied every model; is, Q |= . case, Prompt-Factor
algorithm extracts Q1 = {A v B}, imply .
Another example Seidenbergs segmentation algorithm (Seidenberg & Rector, 2006),
used segmentation medical ontology GALEN (Rector & Rogers, 1999).
Currently, full version GALEN cannot processed reasoners, authors
investigate possibility splitting GALEN small segments processed
reasoners separately. authors describe segmentation procedure which, given set
atomic concepts S, computes segment ontology. description
procedure high-level. authors discuss concepts roles
included segment not. particular, segment contain
super- sub- concepts input concepts, concepts linked
input concepts (via existential restrictions) super-concepts, subconcepts; included concepts, restrictions, intersection, union,
equivalent concepts considered including roles concepts contain,
together super-concepts super-roles sub-concepts
sub-roles. description procedure entirely clear whether works
classified ontology (which unlikely case GALEN since full version
GALEN classified existing reasoner), or, otherwise, super-
sub- concepts computed. clear axioms included
309

fiCuenca Grau, Horrocks, Kazakov, & Sattler

segment end, since procedure talks inclusion concepts
roles.
different approach module extraction proposed literature (Stuckenschmidt
& Klein, 2004) consists partitioning concepts ontology facilitate visualization
navigation ontology. algorithm uses set heuristics measuring
degree dependency concepts ontology outputs graphical
representation dependencies. algorithm intended visualization technique,
establish correspondence nodes graph sets axioms
ontology.
common modularization procedures mentioned lack
formal treatment notion module. papers describing modularization
procedures attempt formally specify intended outputs procedures,
rather argue modules based intuitive notions.
particular, take semantics ontology languages account. might
possible formalize algorithms identify ontologies intuitionbased modularization procedures work correctly. studies beyond scope
paper.
Module extraction ontologies investigated formal point view
(Cuenca Grau et al., 2006b). Cuenca Grau et al. (2006) define notion module QA
ontology Q atomic concept A. One requirements module Q
conservative extension QA (in paper QA called logical module Q).
paper imposes additional requirement modules, namely module QA
entail subsumptions original ontology atomic concepts involving
atomic concepts QA . authors present algorithm partitioning ontology
disjoint modules proved algorithm correct provided certain safety
requirements input ontology hold: ontology consistent,
contain unsatisfiable atomic concepts, safe axioms (which
terms means local empty signature). contrast, algorithm
present works ontology, including containing non-safe axioms.
growing interest notion modularity ontologies recently
reflected workshop modular ontologies5 held conjunction International
Semantic Web Conference (ISWC-2006). Concerning problem ontology reuse,
various proposals safely combining modules; proposals,
E-connections (Cuenca Grau, Parsia, & Sirin, 2006a), Distributed Description Logics
(Borgida & Serafini, 2003) Package-based Description Logics (Bao, Caragea, & Honavar,
2006) propose specialized semantics controlling interaction importing
imported modules avoid side-effects. contrast works, assume
reuse performed simply building logical union axioms modules
standard semantics, establish collection reasoning services,
safety testing, check side-effects. interested reader find literature
detailed comparison different approaches combining ontologies (Cuenca
Grau & Kutz, 2007).
5. information see homepage workshop http://www.cild.iastate.edu/events/womo.html

310

fiModular Reuse Ontologies: Theory Practice

8. Implementation Proof Concept
section, provide empirical evidence appropriateness locality safety
testing module extraction. purpose, implemented syntactic locar
r
lity checker locality classes OA
() OA
() well algorithm
extracting modules given Figure 5 Section 6.
r
First, show locality class OA
() provides powerful sufficiency test
r
safety works many real-world ontologies. Second, show OA
()-based
modules typically small compared size ontology modules
extracted using techniques. Third, report implementation ontology
editor Swoop (Kalyanpur, Parsia, Sirin, Cuenca Grau, & Hendler, 2006) illustrate
r
r
combination modularization procedures based classes OA
() OA
().
8.1 Locality Testing Safety
r
run syntactic locality checker class OA
() ontologies
library 300 ontologies various sizes complexity import
(Gardiner, Tsarkov, & Horrocks, 2006).6 ontologies P import ontology Q,
check P belongs locality class = Sig(P) Sig(Q).
turned 96 ontologies library import ontologies,
11 syntactically local (and hence semantically local S). 11
non-local ontologies, 7 written OWL-Full species OWL (Patel-Schneider et al.,
2004) framework yet apply. remaining 4 non-localities due
presence so-called mapping axioms form B 0 ,
/ B 0 S.
Note axioms simply indicate atomic concepts A, B 0 two ontologies
consideration synonyms. Indeed, able easily repair non-localities
follows: replace every occurrence P B 0 remove axiom
ontology. transformation, 4 non-local ontologies turned local.

8.2 Extraction Modules
section, compare three modularization7 algorithms implemented
using Manchesters OWL API:8
A1: Prompt-Factor algorithm (Noy & Musen, 2003);
A2: segmentation algorithm proposed Cuenca Grau et al. (2006);
r
A3: modularisation algorithm (Algorithm 5), based locality class OA
().

aim experiments described section provide throughout comparison quality existing modularization algorithms since algorithm extracts
modules according requirements, rather give idea typical size
modules extracted real ontologies algorithms.
6. library available http://www.cs.man.ac.uk/~horrocks/testing/
7. section module understand result considered modularization procedures
may necessarily module according Definition 10 12
8. http://sourceforge.net/projects/owlapi

311

fiCuenca Grau, Horrocks, Kazakov, & Sattler

(a) Modularization
NCI
(a)
Modularization
NCI

(b) Modularization
Modularization
GALEN-Small
(b)
GALEN-Small

(c) Modularization
Modularization SNOMED
(c)
SNOMED

(d) Modularization
Modularization GALEN-Full
(d)
GALEN-Full

(e) Small
Small modules

GALEN-Full
(e)
modules
GALEN-Full

(f) Large
Large modules

GALEN-Full
(f)
modules
GALEN-Full

Figure 6: Distribution sizes syntactic locality-based modules: X-Axis gives
number concepts modules Y-Axis number modules extracted
size range.

312

fiModular Reuse Ontologies: Theory Practice

A2: Segmentation

A3: Loc.-based mod.

] Atomic

A1: Prompt-Factor

Concepts

Max.(%)

Avg.(%)

Max.(%)

Avg.(%)

Max.(%)

Avg.(%)

NCI

27772

87.6

75.84

55

30.8

0.8

0.08

SNOMED

255318

100

100

100

100

0.5

0.05

GO

Ontology

22357

1

0.1

1

0.1

0.4

0.05

SUMO

869

100

100

100

100

2

0.09

GALEN-Small

2749

100

100

100

100

10

1.7

GALEN-Full

24089

100

100

100

100

29.8

3.5

SWEET

1816

96.4

88.7

83.3

51.5

1.9

0.1

DOLCE-Lite

499

100

100

100

100

37.3

24.6

Table 6: Comparison Different Modularization Algorithms

test suite, collected set well-known ontologies available Web,
divided two groups:
Simple. group, included National Cancer Institute (NCI) Ontology,9
SUMO Upper Ontology,10 Gene Ontology (GO),11 SNOMED Ontology12 .
ontologies expressed simple ontology language simple structure;
particular, contain GCIs, definitions.
Complex. group contains well-known GALEN ontology (GALEN-Full),13
DOLCE upper ontology (DOLCE-Lite),14 NASAs Semantic Web Earth Environmental Terminology (SWEET)15 . ontologies complex since use many
constructors OWL DL and/or include significant number GCIs. case
GALEN, considered version GALEN-Small commonly used
benchmark OWL reasoners. ontology almost 10 times smaller original
GALEN-Full ontology, yet similar structure.
Since benchmark ontology modularization use cases
available, systematic way evaluating modularization procedures. Therefore
designed simple experiment setup which, even may necessarily reflect
actual ontology reuse scenario, give idea typical module sizes.
ontology, took set atomic concepts extracted modules every atomic
concept. compare maximal average sizes extracted modules.
worth emphasizing algorithm A3 extract module
input atomic concept: extracted fragment module whole signature,
typically includes fair amount concepts roles.
9.
10.
11.
12.
13.
14.
15.

http://www.mindswap.org/2003/CancerOntology/nciOncology.owl
http://ontology.teknowledge.com/
http://www.geneontology.org
http://www.snomed.org
http://www.openclinical.org/prj_galen.html
http://www.loa-cnr.it/DOLCE.html
http://sweet.jpl.nasa.gov/ontology/
313

fiCuenca Grau, Horrocks, Kazakov, & Sattler

r
r
(a) Concepts DNA Sequence (b) OA
(S)-based module (c) OA
(S)-based module
Microanatomy NCI
DNA Sequence NCI
Micro Anatomy fragment 7b

Figure 7: Module Extraction Functionality Swoop
results obtained summarized Table 6. table provides size
largest module average size modules obtained using
algorithms. table, clearly see locality-based modules significantly
smaller ones obtained using methods; particular, case SUMO,
DOLCE, GALEN SNOMED, algorithms A1 A2 retrieve whole ontology
module input signature. contrast, modules obtain using algorithm
significantly smaller size input ontology.
NCI, SNOMED, GO SUMO, obtained small locality-based modules. explained fact ontologies, even large, simple
structure logical expressivity. example, SNOMED, largest locality-based
module obtained approximately 0.5% size ontology, average size
modules 1/10 size largest module. fact, modules
obtained ontologies contain less 40 atomic concepts.
GALEN, SWEET DOLCE, locality-based modules larger. Indeed,
largest module GALEN-Small 1/10 size ontology, opposed 1/200
case SNOMED. DOLCE, modules even bigger1/3 size
ontologywhich indicates dependencies different concepts
ontology strong complicated. SWEET ontology exception: even
though ontology uses constructors available OWL, ontology heavily
underspecified, yields small modules.
Figure 6, detailed analysis modules NCI, SNOMED,
GALEN-Small GALEN-Full. Here, X-axis represents size ranges ob314

fiModular Reuse Ontologies: Theory Practice

tained modules Y-axis number modules whose size within given range.
plots thus give idea distribution sizes different modules.
SNOMED, NCI GALEN-Small, observe size modules
follows smooth distribution. contrast, GALEN-Full, obtained large number
small modules significant number big ones, medium-sized modules
in-between. abrupt distribution indicates presence big cycle dependencies
ontology. presence cycle spotted clearly Figure 6(f); figure
shows large number modules size 6515 6535 concepts.
cycle occur simplified version GALEN thus obtain smooth
distribution case. contrast, Figure 6(e) see distribution
small modules GALEN-Full smooth much similar one
simplified version GALEN.
considerable differences size modules extracted algorithms A1
A3 due fact algorithms extract modules according different requirements. Algorithm A1 produces fragment ontology contains input atomic
concept syntactically separated rest axiomsthat is, fragment
rest ontology disjoint signatures. Algorithm A2 extracts fragment
ontology module input atomic concept additionally semantically
separated rest ontology: entailment atomic concept
module atomic concept module hold original ontology. Since
algorithm based weaker requirements, expected extracts smaller
modules. surprising difference size modules significant.
order explore use results ontology design analysis,
integrated algorithm extracting modules ontology editor Swoop (Kalyanpur
et al., 2006). user interface Swoop allows selection input signature
retrieval corresponding module.16
Figure 7a shows classification concepts DNA Sequence Microanatomy
r
NCI ontology. Figure 7b shows minimal OA
()-based module DNA Sequence,
r
obtained Swoop. Recall that, according Corollary 47, OA
()-based module
atomic concept contains necessary axioms for, least, (entailed) super-concepts
O. Thus module seen upper ontology O. fact, Figure 7
shows module contains concepts path DNA Sequence
top level concept Anatomy Kind. suggests knowledge NCI
particular concept DNA Sequence shallow sense NCI knows
DNA Sequence macromolecular structure, which, end, anatomy kind. one
wants refine module including information ontology necessary
r
entail path DNA Sequence Micro Anatomy, one could extract OA
()based module Micro Anatomy fragment 7b. Corollary 47, module contains
sub-concepts Micro Anatomy previously extracted module. resulting
module shown Figure 7b.

16. tool downloaded http://code.google.com/p/swoop/

315

fiCuenca Grau, Horrocks, Kazakov, & Sattler

9. Conclusion
paper, proposed set reasoning problems relevant ontology
reuse. established relationships problems studied computability. Using existing results (Lutz et al., 2007) results obtained Section 4,
shown problems undecidable algorithmically unsolvable logic
underlying OWL DL. dealt problems defining sufficient conditions
solution exist, computed practice. introduced studied
notion safety class, characterizes sufficiency condition safety
ontology w.r.t. signature. addition, used safety classes extract modules
ontologies.
future work, would study approximations produce small
modules complex ontologies GALEN, exploit modules optimize ontology
reasoning.

References
Baader, F., Brandt, S., & Lutz, C. (2005). Pushing EL envelope. IJCAI-05, Proceedings Nineteenth International Joint Conference Artificial Intelligence,
Edinburgh, Scotland, UK, July 30-August 5, 2005, pp. 364370. Professional Book
Center.
Baader, F., Calvanese, D., McGuinness, D. L., Nardi, D., & Patel-Schneider, P. F. (Eds.).
(2003). Description Logic Handbook: Theory, Implementation, Applications.
Cambridge University Press.
Bao, J., Caragea, D., & Honavar, V. (2006). semantics linking importing
modular ontologies. Proceedings 5th International Semantic Web Conference
(ISWC-2006), Athens, GA, USA, November 5-9, 2006, Vol. 4273 Lecture Notes
Computer Science, pp. 7286.
Borger, E., Gradel, E., & Gurevich, Y. (1997). Classical Decision Problem. Perspectives
Mathematical Logic. Springer-Verlag. Second printing (Universitext) 2001.
Borgida, A., & Serafini, L. (2003). Distributed description logics: Assimilating information
peer sources. J. Data Semantics, 1, 153184.
Cuenca Grau, B., Horrocks, I., Kazakov, Y., & Sattler, U. (2007). logical framework
modularity ontologies. IJCAI-07, Proceedings Twentieth International
Joint Conference Artificial Intelligence, Hyderabad, India, January 2007, pp. 298
304. AAAI.
Cuenca Grau, B., & Kutz, O. (2007). Modular ontology languages revisited. Proceedings
Workshop Semantic Web Collaborative Knowledge Acquisition, Hyderabad, India, January 5, 2007.
Cuenca Grau, B., Parsia, B., & Sirin, E. (2006a). Combining OWL ontologies using Econnections. J. Web Sem., 4 (1), 4059.
Cuenca Grau, B., Parsia, B., Sirin, E., & Kalyanpur, A. (2006b). Modularity web ontologies. Proceedings Tenth International Conference Principles Knowledge
316

fiModular Reuse Ontologies: Theory Practice

Representation Reasoning (KR-2006), Lake District United Kingdom, June
2-5, 2006, pp. 198209. AAAI Press.
Cuenca Grau, B., Horrocks, I., Kazakov, Y., & Sattler, U. (2007). right amount:
extracting modules ontologies. Proceedings 16th International Conference World Wide Web (WWW-2007), Banff, Alberta, Canada, May 8-12, 2007,
pp. 717726. ACM.
Cuenca Grau, B., Horrocks, I., Kutz, O., & Sattler, U. (2006). ontologies fit
together?. Proceedings 2006 International Workshop Description Logics
(DL-2006), Windermere, Lake District, UK, May 30 - June 1, 2006, Vol. 189 CEUR
Workshop Proceedings. CEUR-WS.org.
Gardiner, T., Tsarkov, D., & Horrocks, I. (2006). Framework automated comparison description logic reasoners. Proceedings 5th International Semantic
Web Conference (ISWC-2006), Athens, GA, USA, November 5-9, 2006, Vol. 4273
Lecture Notes Computer Science, pp. 654667. Springer.
Ghilardi, S., Lutz, C., & Wolter, F. (2006). damage ontology? case conservative extensions description logics. Proceedings Tenth International
Conference Principles Knowledge Representation Reasoning (KR-2006),
Lake District United Kingdom, June 2-5, 2006, pp. 187197. AAAI Press.
Horrocks, I., Patel-Schneider, P. F., & van Harmelen, F. (2003). SHIQ RDF
OWL: making web ontology language. J. Web Sem., 1 (1), 726.
Horrocks, I., & Sattler, U. (2005). tableaux decision procedure SHOIQ. Proceedings
Nineteenth International Joint Conference Artificial Intelligence (IJCAI-05),
Edinburgh, Scotland, UK, July 30-August 5, 2005, pp. 448453. Professional Book
Center.
Kalfoglou, Y., & Schorlemmer, M. (2003). Ontology mapping: state art.
Knowledge Engineering Review, 18, 131.
Kalyanpur, A., Parsia, B., Sirin, E., Cuenca Grau, B., & Hendler, J. A. (2006). Swoop:
web ontology editing browser. J. Web Sem., 4 (2), 144153.
Lutz, C., Walther, D., & Wolter, F. (2007). Conservative extensions expressive description
logics. Proceedings Twentieth International Joint Conference Artificial
Intelligence (IJCAI-07), Hyderabad, India, January 2007, pp. 453459. AAAI.
Lutz, C., & Wolter, F. (2007). Conservative extensions lightweight description logic
EL. Proceedings 21st International Conference Automated Deduction
(CADE-21), Bremen, Germany, July 17-20, 2007, Vol. 4603 Lecture Notes Computer Science, pp. 8499. Springer.
Moller, R., & Haarslev, V. (2003). Description logic systems. Description Logic
Handbook, chap. 8, pp. 282305. Cambridge University Press.
Motik, B. (2006). Reasoning Description Logics using Resolution Deductive
Databases. Ph.D. thesis, Univesitat Karlsruhe (TH), Karlsruhe, Germany.
Noy, N. F. (2004a). Semantic integration: survey ontology-based approaches. SIGMOD
Record, 33 (4), 6570.
317

fiCuenca Grau, Horrocks, Kazakov, & Sattler

Noy, N. F. (2004b). Tools mapping merging ontologies. Staab, & Studer (Staab
& Studer, 2004), pp. 365384.
Noy, N., & Musen, M. (2003). PROMPT suite: Interactive tools ontology mapping
merging. Int. Journal Human-Computer Studies, Elsevier, 6 (59).
Patel-Schneider, P., Hayes, P., & Horrocks, I. (2004). Web ontology language OWL Abstract
Syntax Semantics. W3C Recommendation.
Rector, A., & Rogers, J. (1999). Ontological issues using description logic represent
medical concepts: Experience GALEN. IMIA WG6 Workshop, Proceedings.
Schmidt-Schau, M., & Smolka, G. (1991). Attributive concept descriptions complements. Artificial Intelligence, Elsevier, 48 (1), 126.
Seidenberg, J., & Rector, A. L. (2006). Web ontology segmentation: analysis, classification
use. Proceedings 15th international conference World Wide Web
(WWW-2006), Edinburgh, Scotland, UK, May 23-26, 2006, pp. 1322. ACM.
Sirin, E., & Parsia, B. (2004). Pellet system description. Proceedings 2004 International Workshop Description Logics (DL2004), Whistler, British Columbia,
Canada, June 6-8, 2004, Vol. 104 CEUR Workshop Proceedings. CEUR-WS.org.
Staab, S., & Studer, R. (Eds.). (2004). Handbook Ontologies. International Handbooks
Information Systems. Springer.
Stuckenschmidt, H., & Klein, M. (2004). Structure-based partitioning large class hierarchies. Proceedings Third International Semantic Web Conference (ISWC2004), Hiroshima, Japan, November 7-11, 2004, Vol. 3298 Lecture Notes Computer Science, pp. 289303. Springer.
Tobies, S. (2000). complexity reasoning cardinality restrictions nominals
expressive description logics. J. Artif. Intell. Res. (JAIR), 12, 199217.
Tsarkov, D., & Horrocks, I. (2006). FaCT++ description logic reasoner: System description.
Proceedings Third International Joint Conference Automated Reasoning
(IJCAR 2006), Seattle, WA, USA, August 17-20, 2006, Vol. 4130 Lecture Notes
Computer Science, pp. 292297. Springer.

318


