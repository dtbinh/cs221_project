journal artificial intelligence

submitted published

ini ax efficient weighted max sat solver
federico heras
javier larrosa
albert oliveras

fheras lsi upc edu
larrosa lsi upc edu
oliveras lsi upc edu

technical university catalonia lsi department
jordi girona barcelona spain

abstract
introduce ini ax max sat solver built top incorporates best current sat max sat techniques handle hard clauses
clauses mandatory satisfaction sat soft clauses clauses whose falsification penalized cost max sat well pseudo boolean objective functions constraints
main features learning backjumping hard clauses resolution substractionbased lower bounding lazy propagation two watched literal scheme empirical
evaluation comparing wide set solving alternatives broad set optimization benchmarks
indicates performance ini ax usually close best specialized alternative
cases even better


introduction
max sat optimization version sat goal satisfy maximum number
clauses considered one fundamental combinatorial optimization many important naturally expressed max sat include academic
max cut max clique well real domains routing bioinformatics scheduling
electronic markets
long tradition theoretical work structural complexity papadimitriou
approximability karloff zwick max sat work restricted
simplest case clauses equally important e unweighted max sat
fixed size mainly binary ternary practical point view significant progress
made last years shen zhang larrosa heras larrosa heras de givry
xing zhang li manya planes handful
solvers deal first time instances involving hundreds variables
main motivation work comes study max sat instances modelling realworld usually encounter three features
satisfaction clauses importance clause needs
associated weight represents cost violation extreme case
often happens practice observed cha iwama kambayashi miyazaki
clauses whose satisfaction mandatory usually modelled associating
high weight
literals appear randomly along clauses contrary easy identify
patterns symmetries kinds structures
c

ai access foundation rights reserved

fih eras l arrosa liveras

mandatory clauses reduce dramatically number feasible
assignments optimization part plays secondary role however
mandatory clauses trivially satisfiable real difficulty lays
optimization part
look current max sat solvers none robust three
features instance li et al solvers restricted formulas clauses
equally important e unweighted max sat shen zhangs one restricted binary clauses one described larrosa et al seems efficient overconstrained
e small fraction clauses simultaneously satisfied one
alsinet manya planes seems efficient slightly overconstrained e
almost clauses satisfied solver described argelich manya developed parallel described handle mandatory clauses
one incorporates learning seems perform well structured however
non mandatory clauses must weight finally approaches translating
max sat instance sat instance solve sat solver seem effective
highly structured almost clauses mandatory fu malik le berre

introduce ini ax weighted max sat solver incorporates
current best sat max sat techniques build top ini een sorensson
borrows capability deal pseudo boolean ini een
sorensson features processing mandatory clauses learning backjumping
extended allowing deal weighted clauses preserving two watched literal
lazy propagation method main original contribution ini ax implements
novel efficient lower bounding technique specifically applies unit propagation
order detect disjoint subsets mutually inconsistent clauses done li et al
simplifies following larrosa heras heras larrosa larrosa
et al order increment lower bound however works clauses
accomplish specific patterns transformed ini ax need define
patterns
structure follows section provides preliminary definitions sat
section presents state art solving techniques incorporated modern sat solver
ini section presents preliminary definitions max sat section overviews
ini ax sections focus lower bounding additional features
respectively section present benchmarks used empirical evaluation
report experimental finally section presents related work section concludes
points possible future work

preliminaries sat
sequel x x x xn set boolean variables literal variable xi
negation xi variable literal l refers noted var l given literal l negation l xi
l xi xi l xi clause c disjunction literals size clause noted c
number literals set variables appear c noted var c sometimes
associate subscript greek letter clause e g xi x j order facilitate future references
clause


fim ini ax



e fficient w eighted ax sat olver

dpll basic structure
function search boolean

initqueue

loop



conflict

analyzeconflict

top conflict return f alse
else

learnclause

backjump





else variables assigned return true
else
l selectliteral
enqueue q l

assignment set literals containing variable negation assignments
maximal size n called complete otherwise called partial given assignment
variable x unassigned neither x x belong similarly literal l unassigned var l
unassigned
assignment satisfies literal iff belongs assignment satisfies clause iff satisfies
one literals falsifies clause iff contains negation literals
latter case say clause conflicting happens empty clause noted
boolean formula f conjunctive normal form cnf set clauses representing
conjunction model f complete assignment satisfies clauses f
f model call satisfiable otherwise say unsatisfiable moreover
complete assignments satisfy f say f tautology
clauses size one called unit clauses simply units formula contains unit l
simplified removing clauses containing l removing l clauses
appears application rule quiescence called unit propagation well
recognized fundamental propagation technique current sat solvers
another well known rule resolution given formula containing two clauses
form x x b called clashing clauses allows one add clause b called
resolvent

overview state art dpll sat solvers
section overview architecture sat solvers dpll davis logemann
loveland procedure procedure currently regarded efficient complete
search procedure sat performs systematic depth first search space assignments
internal node associated partial assignment two successors obtained selecting
unassigned variable x extending current assignment x x respectively
visited node units derived due application unit propagation leads


fih eras l arrosa liveras

unit propagation
function q conflict
q contains non propagated literals

l getfirstnonpropagatedlit q markaspropagated l

foreach clause c l becomes unit falsified

c l becomes unit q enqueue q q

else c l becomes falsified return conflict
return none

conflicting clause procedure backtracks performing non chronological backtracking
clause learning originally proposed silva sakallah
algorithmic description dpll procedure appears uses
propagation queue q contains units pending propagation contains representation
current assignment
first propagation queue q filled units contained original formula line
main loop starts line iteration procedure charge propagating pending
units line conflicting clause found line conflict analyzed line
clause learned e inferred recorded line
procedure backtracks propagation queue q undo assignment
exactly one literals learned clause becomes unassigned line one
backtrack still maintaining condition advantageous commonly referred backjumping non chronological backtracking see silva sakallah
leads conflict unassigned literal selected extend current partial assignment
literal added q line iteration takes place
procedure stops complete assignment found line top level conflict
found line first case procedure returns true indicates model
found second case returns f alse means model exists input
formula
performance dpll sat solvers greatly improved sat
solver c haff moskewicz madigan zhao zhang malik incorporated two watched
literal scheme efficient unit propagation first uip scheme zhang madigan moskewicz
malik clause learning cheap vsids branching heuristic currently stateof art sat solvers ini een sorensson implement small variations
three features following describe depth
unit propagation
aim unit propagation twofold one hand finds clauses become units
due current assignment hand detects whether clause become
conflicting concrete procedure given non propagated literals exist
q picks oldest one l marks propagated line clauses containing l
may become falsified units traversed later describe clauses
detected one clauses becomes unit q enqueued q propagated later line


fim ini ax



e fficient w eighted ax sat olver

procedure iterates units propagate conflicting clause
found line
two types literals q decision literals heuristically
selected assigned branching point lines consequence literals
added logical consequences previous decision literals line
ini uses non standard queue handle units pending propagation unlike classical queues
fetching element removed marked consequently q formed
two sets elements already propagated literals literals pending propagation
advantage strategy execution point q contains current assignment
besides propagated literals q divided decision levels decision level contains
decision literal set related consequences furthermore literal l associated
original clause caused propagation noted l clause usually referred
reason l note decision literal l reason represented
ld
example consider formula x x x x x x starting execution
propagation queue empty q k use symbol k separate propagated literals
left literals pending propagation right literal x selected added
q propagation queue contains q kxd propagate x add two
consequences x x propagation queue q xd kx x current
assignment x x x propagation x x add literals q becomes
q xd x x k
x decided add consequence x propagation q

x x x xd x k current assignment x x x x x note literals
propagated complete assignment found note well q contains two
decision levels first one formed literals x x x second one formed
literals x x
l azy data tructures
mentioned aim detect units conflicting clauses taking account
process typically takes total runtime sat solver important
design efficient data structures
first attempt use adjacency lists literal one keeps list clauses
literal appears upon addition literal l assignment clauses
containing l traversed main drawback refinements detect efficiently
clause become unit keeping counters indicating number unassigned
literals clause involved considerable amount work upon backtracking
method used ini two watched literal scheme introduced moskewicz et al
basic idea clause cannot unit conflicting one satisfied literal
ii two unassigned literals
keeps two special literals clause called watched literals initially
two unassigned literals tries maintain invariant one satisfied literal two
unassigned literals watched
invariant may broken one two watched literals becomes falsified
case clause traversed looking another non false literal watch order restore


fih eras l arrosa liveras

invariant one literal cannot found clause declared true unit conflicting depending value watched literal hence literal l added assignment
clauses may become falsified unit line clauses
l watched
main advantage work clauses done upon
backtracking however main drawback way know many literals
unassigned given clause traversing literals note information used
techniques two sided jeroslow branching heuristic see section
r esolution r efutation rees
detects conflict unsatisfiable subset clauses f determined information provided q since f unsatisfiable empty clause derived f via
resolution resolution process called refutation refutation unsatisfiable clause set
f resolution refutation tree simply refutation tree every clause used exactly
resolution process
refutation tree built propagation queue q follows let c conflicting
clause traverse q lifo last first fashion clashing clause found
resolution applied c obtaining resolvent c next traversal q continues
clause clashes c found giving resolvent c iterate process
resolvent obtain empty clause importance refutation trees become
relevant section
example consider f x x x x x x x x x x x x x
apply unit propagation unit clause enqueued producing q kx x
propagated q becomes x kx x x literal x propagated causing
clause become unit q becomes x x kx x x literal x
propagated clause found conflicting figure shows state q
propagation
build refutation tree starting tail q first clause clashing
conflicting clause resolution generates resolvent x x x first
clause clashing x producing resolvent x x next clause clashing x
resolution generates x finally resolve clause obtain figure b shows
resulting refutation tree
learning backjumping
learning backjumping best illustrated example see silva sakallah zhang
et al precise description
example consider formula x x x x x x x x x partial
assignment x x x x x x leads conflict clause suppose current
propagation queue q xd x xd x xd x k
example easy see decision xd incompatible decision xd incompatibility represented clause x x similarly consequence x incompatible
decision xd represented clause x x


fim ini ax



e fficient w eighted ax sat olver

f x x x x x x x x x x x x x

x x x x x x
x

x x x

x x

x
x

x x

x x

x

x

x
x




b

figure graphical representation propagation queue q refutation tree example
top original formula f left propagation q step arrows
indicate order resolving clauses selected right resolution tree
computed step

clause learning implements different techniques used discover implicit incompatibilities adds formula learned clauses accelerate subsequent search
since increase potential future executions however observed
unrestricted clause learning impractical cases recorded clauses consume memory
repeated recording may lead exhaustion reason current sat solvers incorporate
different clause deletion policies order remove learned clauses
learned clauses used backjump presence would allowed unit propagation earlier decision level case say clause asserting backjumping
proceed going back level adding unit propagated literal among several
automated ways generating asserting clauses ini uses called first unique implication point uip zhang et al
branching heuristic
branching occurs function selectliteral literals
propagate function chooses one variable unassigned ones assigns value


fih eras l arrosa liveras

importance branching heuristic well known since different branching heuristic may
produce different sized search trees
early branching heuristics include bohms heuristic buro buning maximum ocurrences minimum sized clauses mom freeman two sided jeroslow
wang heuristic jeroslow wang heuristics try choose literal
assignment generate largest number implications satisfy clauses
heuristics state dependent use information state clauses given
current assignment information number unassigned literals
clause hence implemented jointly data structures adjacency lists since
keep information instance two sided jeroslow wang heuristic computes
literal l f following function
j l



c

cf
lc

selects literal l maximizes function j l
solvers become efficient updating metrics state dependent heuristics dominates
execution time hence ini uses slight modification state independent heuristic first
proposed moskewicz et al heuristic called variable state independent decaying
sum vsids selects literal appears frequently clauses giving priority
recently learned clauses advantage heuristic metrics updated
clauses learned since occurs occasionally computation low overhead
vsids heuristic suits perfectly lazy data structures two watched literal scheme

weighted max sat
weighted clause pair c w c clause w integer representing cost
falsification called weight contains clauses must satisfied
call clauses mandatory hard associate special weight non mandatory
clauses called soft weighted formula conjunctive normal form wcnf set
weighted clauses model complete assignment satisfies mandatory clauses cost
assignment sum weights clauses falsifies given wcnf formula f
weighted max sat finding model f minimum cost cost
called optimal cost f note formula contains mandatory clauses weighted
max sat equivalent classical sat clauses weight called
unweighted max sat following assume weighted max sat
say weighted formula f relaxation weighted formula f noted f v f
optimal cost f less equal optimal cost f non considered
cost infinity say two weighted formulas f f equivalent noted f f
f v f f v f
max sat simplification rules transforms formula f equivalent presumably simpler formula f sat simplification rules e g unit propagation tautology removal
directly applied max sat restricted mandatory clauses however several specific max sat
simplification rules exist larrosa et al instance formula contains clauses c u
c v replaced c u v contains clause c may removed
contains unit l simplified removing including soft clauses containing l


fim ini ax



e fficient w eighted ax sat olver

removing l clauses including soft clauses appears application
rule quiescence natural extension unit propagation max sat
empty clause may appear weighted formula weight clear
formula model weight w cost assignment include
weight w obvious lower bound formula optimal cost weighted empty clauses
interpretation terms lower bounds become relevant section
shown larrosa et al notion resolution extended weighted formulas
follows


b








x u
x b w
x u x b w



x b






x b

b arbitrary disjunctions literals min u w
x u x b w called prior clashing clauses b called resolvent
x u x b w called posterior clashing clauses x b
x b called compensation clauses effect max sat resolution classical
resolution infer namely make explicit connection b however
important difference classical resolution max sat resolution former yields
addition clause max res transformation rule namely requires replacement
left hand clauses right hand clauses reason cost prior clashing
clauses must substracted order compensate inferred information consequently
max res better understood movement knowledge formula
resolution rule max sat preserves equivalence last two compensation clauses
may lose clausal form following rule larrosa et al may needed recover

l b
cnf l b u

l b u cnf b u b

example apply weighted resolution following clauses x x x x x
obtain x x x x x x x x x x x x x x x
x first clause simplified second clause omitted weight
zero fifth clause omitted tautology fourth element clause
simple disjunction hence apply cnf rule obtain two
clauses cnf x x x x x x x x x x x note first
clause tautology therefore obtain equivalent formula x x x x x x
x x

overview ini ax
ini ax weighted max sat solver built top ini een sorensson
dpll sat solver could used ini particularly wellsuited short open source code besides deal pseudo boolean constraints
empty clause represents tautology special weight relations
larrosa et al



fih eras l arrosa liveras

ini ax basic structure
function search integer

ub localsearch lb

initqueue q

loop

propagate

hard conflict
analyzeconflict
top level hard conflict return ub
else
learnclause
backjump








else soft conflict
chronologicalbactrack
end search return ub
else variables assigned
ub lb
ub return ub
chronologicalbactrack
end search return ub
else
l selectliteral
enqueue q l

given wcnf formula possibly containing hard soft clauses ini ax returns
cost optimal model model achieved means branch andbound search usually done solve optimization
ini tree assignments traversed depth first manner search point
tries simplify current formula ideally detect conflict would mean
current partial assignment cannot successfully extended ini ax distinguishes
two types conflicts hard soft hard conflicts indicate model extending
current partial assignment namely mandatory clauses cannot simultaneously satisfied
hard conflicts detected taking account hard clauses methods ini
hard conflict occurs ini ax learns hard clause backjumps ini would
soft conflicts indicate current partial assignment cannot extended optimal
assignment order identify soft conflicts maintains two values search
cost best model found far upper bound ub optimal solution
underestimation best cost achieved extending current partial assignment model lower bound lb current subproblem
soft conflict detected lb ub means current assignment cannot lead
optimal model soft conflict detected backtracks chronologically note


fim ini ax



e fficient w eighted ax sat olver

minimaxsat propagation
function ms conflict
q contains non propagated literals

l getfirstnonpropagatedlit q markaspropagated l


lb lb v l

lb ub return soft conflict
becomes unit falsified

foreach hard clause c l


c l becomes unit q enqueue q q
becomes falsified return hard conflict

else c l
u becomes unit

foreach soft clause c l


c l u becomes unit q u v q v q u







return none
function propagate conflict
c ms
c hard soft conflict return c
improvelb
lb ub return soft conflict
return none

one could backjump computing clause expressing reasons led lb ub
however presence lots soft clauses ends creating many long
clauses affect negatively efficience solver hence decided perform
simple chronological backtracking
want remark soft clause c w w ub must satisfied optimal
assignment therefore following assume soft clauses automatically transformed hard clauses previous search ones soft clause promoted
hard one search
algorithmic description ini ax presented starting
search good initial upper bound obtained local search method line may yield
identification hard clauses current implementation use u bcsat tompkins hoos default parameters selected local search irots iterated
robust tabu search smyth hoos stutzle besides lower bound initialized
zero next queue q initialized unit hard clauses resulting formula line
main loop starts line iteration charge propagating pending literals
line conflict detected attempting extension current partial assignment
line pending literals q propagated function propagate line may return hard soft conflict hard conflict encountered line conflict analyzed
hard clause learned backjumping performed done introduced section
soft conflict encountered line chronological backtracking performed conflict
found line literal heuristically selected added q propagation next iteration
however current assignment complete line upper bound updated search stops
zero cost solution found since cannot improved line else chronological
backtracking performed line note backjumping leads termination top level hard


fih eras l arrosa liveras

conflict found chronological backtracking leads termination two values first
assigned variable tried
describes propagation process function propagate uses array v l
accumulates weight soft clauses become unit l namely original
clauses l w current assignment falsifies clauses exists assume
v l first performs max sat adapted form unit propagation ms line
ms iterates non propagated literals l q line firstly adding l assignment

may make set soft clauses falsified since cost clauses kept v l
add lower bound line lower bound increment identifies soft conflict
returned line hard clause becomes unit corresponding literal added q
future propagation line finally soft clause becomes unit clause q u line
weight u added v q line process hard conflict detected function
returns lines else attempts detect soft conflict call procedure
improvelb line returns soft conflict found line next section
detailed description improvelb found finally conflict detected function
returns none line

lower bounding ini ax
following consider arbitrary search state ini ax call
procedure improvelb purpose section search state characterized
current assignment current assignment determines current subformula
original formula conditioned current assignment clause contains literal part
current assignment removed besides literals whose negation appear current
assignment removed clauses appear
value lb maintained ini ax precisely aggregation costs
clauses become empty due current assignment similarly recall value
v l aggregation costs clauses become unit l due current
assignment thus current subformula contains lb l v l every l
ini ax computes lower bound deriving soft empty clauses w
resolution process clauses added already existing clause lb producing
increment lower bound
w l u l
w
first step improvelb replaces occurrence l u l
min u w amounts applying restricted version max sat resolution known unit neighborhood resolution unr larrosa et al
produces immediate increment lower bound e weight empty clause
line illustrated following example
example consider current state x x x x x x unr
would resolve clauses x x replacing x compensation clauses removed weight zero tautologies two empty
clauses grouped unr would resolve clauses x x
replacing x two empty clauses grouped
equivalent formula x x x x higher lower bound


fim ini ax



e fficient w eighted ax sat olver

lower bounding ini ax
function sup conflict

initqueue q
q contains non propagated literals
l getfirstnonpropagatedlit q markaspropagated l

foreach hard soft clause c l becomes unit falsified
c l becomes unit q enqueue q q
else c l becomes falsified return conflict









return none
procedure improvelb lb
w f
foreach l v l
w min v w
replace l v l
su p con f lict
buildtree
minimum weight among clauses
condition applyresolution
else lb lb remove weight clauses

second step improvelb executes simulation unit propagation sup line
soft clauses treated hard first sup adds q unit soft clauses line
literals q propagated hard soft clauses become unit
inserted q line sup yields conflict means subset soft
hard clauses cannot simultaneously satisfied showed section q used
identify subset build refutation tree improvelb computes tree line
take account weights clauses apply max sat resolution section
dictated one see produce clause minimum
weight among clauses tree line means extension current partial
assignment unassigned variables cost least
important remark step max sat resolution process consider
minimum weight two clauses rather minimum clauses
resolution tree passed parameter line
resolution process replacement clauses leaves
corresponding compensation clauses function applyresolution line
thus obtaining equivalent formula lower bound increment call procedure
resolution lower bounding
example consider formula f x x x x x x x x x
x x x x
step apply sup initially unit clause enqueued producing q kx
x propagated q becomes x kx x x literal x propagated clause
becomes unit producing q x x kx x x literal x propagated
clause found conflicting figure shows state q propagation


fih eras l arrosa liveras

f x x x x x x x x x x x x x

x x x x x x

x






x



x

x x x
x x x x x x x x x
x x x x
x x

x x

x x



x
x

x



x





b

c

f x x x x x x x x x x x x x x x
f



x x x x x x x

figure graphical representation ini ax lower bounding top original
current formula f left propagation q step middle structure
refutation tree computed simulation step right
effect actually executing max sat resolution step resulting formula f
appears bellow substraction lower bounding performed step replaced
substraction weights producing formula f

step build simulated refutation tree starting tail q first clause clashing
conflicting clause resolution generates resolvent x x x
first clause clashing x producing resolvent x x next clause clashing
x resolution generates x finally resolve clause obtain figure b
shows resulting resolution tree
step apply max sat resolution apply max sat resolution indicated refutation
tree computed step figure c graphically shows process leaf clauses
original weighted clauses involved resolution internal node indicates resolution
step resolvents appear junction edges beside resolvent inside box
compensation clauses must added formula preserve equivalence since
clauses used resolution must removed resulting formula f consists root


fim ini ax



e fficient w eighted ax sat olver

tree compensation clauses clauses used refutation tree
resulting formula f x x x x x x x x x x x x
x x x soundness max sat resolution guarantees f f
remark transformations applied resolution lower bounding passed
descendent nodes changes preserve equivalence nevertheless transformations
restored backtracking takes place
alternative transformation resolution identify lower bound increment substract clauses would participated resolution
tree procedure similar lower bound computed li et al call
substraction line lower bounding
example consider formula f previous example steps identical however
substraction lower bounding would replace step step substracts weight
clauses appear refutation tree adds formula
f x x x x x x x note f v f
remark substractions applied substraction lower bounding restored moving descendent node preserve equivalence
increment lower bound technique procedure sup executed
may yield lower bound increments process repeated sup
detect conflict
comparing two previous approaches observe resolution lower bounding
larger overhead resolution steps need actually computed consequences
must added current formula removed upon backtracking however effort invested
transformation may well amortized increment obtained lower bound
becomes part current formula discovered
descendent nodes search hand substraction lower bounding
smaller overhead resolution needs actually computed facilitates
context restoration upon backtracking
ini ax incorporates two alternatives chooses apply one heuristically lines depending specific condition line observed resolution
lower bounding seems effective resolution applied low arity clauses
consequence identification resolution tree ini ax applies resolution
lower bounding largest resolvent resolution tree arity strictly less otherwise applies substraction lower bounding see section details

additional features ini ax
section overview important features ini ax namely use twowatched literal scheme branching heuristic use soft probing ini ax
deals pseudo boolean functions


fih eras l arrosa liveras

two watched literals
ini ax uses two watched literal scheme soft clauses recall one main
advantages technique applied pure sat backtracking takes
place work done clauses unfortunately case soft clauses restoration needs done soft clause becomes unit literal l function ms weight
added v l clause eliminated marked eliminated avoid reusing
lower bounding procedure changes well addition lb restored
backtracking performed however note executions sup simulation unit
propagation clauses considered hard case two watched literal scheme works
exactly sat solver hard soft clauses inconsistency detected
sup stops literals propagate initial state recovered
situation restoring initial state completely overhead free
branching heuristic
ini ax incorporates two alternative branching heuristics first one vsids heuristic moskewicz et al disregarding soft clauses ini default heuristic
likely good structured learning backjumping play significant role
well difficult namely satisfaction component
difficult optimization component since heuristic disregards soft
clauses likely ineffective easy difficulty
optimal one prove optimality extreme case contain soft clauses every complete assignment model vsids heuristic blind therefore
completely useless
overcome limitation vsids ini ax incorporates weighted jeroslow
heuristic heras larrosa extension sat jeroslow heuristic described
section given weighted formula f literal l f following function defined
j l



c w

c w f
lc

mandatory clauses assumed weight equal upper bound ub heuristic
selects literal highest value j l main disadvantage metrics need
updated visited node combination two watched literal updating becomes
expensive seem pay general thus current implementation
heuristic j l values computed root node used throughout solving
process found experiments heuristic good alternative
difficulty lies optimization part e g many ini ax
automatically changes vsids weighted jeroslow contain literal
l hard clauses l hard clauses l
heuristics literal l v l lb ub node search
tree l selected literal l never assigned


fim ini ax



e fficient w eighted ax sat olver

soft probing
probing well known sat technique allows formulation hypothetical scenarios lynce
silva idea temporarily assume l hard unit clause execute unit
propagation yields conflict know model extending current assignment must
contain l process iterated literals quiescence exhaustive experiments
sat context indicate expensive probe search le berre lynce
silva normally done pre process order reduce initial number
branching points
easily extend idea max sat context besides discovery unit hard
clauses may used make explicit weighted unit clauses call soft probing sat
idea temporarily assume l unit clause simulate unit propagation e execute
sup build resolution tree propagation queue q clauses
hard know l must added assignment else reproduce applying max minimum
sat resolution weighted clauses derive unit clause l
weight among clauses unit soft clauses upfront makes future executions
improvelb much effective subsequent search besides derive l u
w generate via unit neighborhood resolution see example initial non trivial lower
l
bound min u w tested soft probing search preprocessing several
benchmarks observed empirically soft probing preprocessing best option
sat

example consider formula f x x x x x x assume x
adding q execute sup conflict reached obtain q xd x x
detect conflicting clause clauses involved refutation tree
resolving clauses x x x x x x x x x x
resolution previous resolvent produces equivalent formula f x x
x x x x x
pseudo boolean functions
pseudo boolean optimization pbo barth sheini sakallah een
sorensson form
minimize nj c j x j
subject nj ai j l j bi
x j l j x j x j c j ai j bi non negative integers
ini ax provided pbo instance translates max sat formula follows pseudo boolean constraint translated set hard clauses ini een
sorensson heuristically decides appropriate translation choosing
among adders sorters bdds objective function translated set soft unit clauses
summand c j x j becomes soft unit clause x j c j translation ini ax
executed usual


fih eras l arrosa liveras

empirical
section present benchmarks solvers used empirical evaluation
report experiments performed order adjust parameters ini ax finally
comparison solvers presented
benchmarks encodings
good set fundamental effectiveness solvers
following present several explain encode weighted max sat
ax k sat
k sat cnf formula cnf formula clauses size k generated random
unsatisfiable sat sat formulas cnfgen generator solved corresponding
max sat benchmarks fixed number variables varied number
clauses repeated
ax cut
given graph g v e cut defined subset vertices u v size cut
number edges vi v j vi u v j v u max cut consists
finding cut maximum size encoded max sat associating one variable xi
graph vertex value true respectively false indicates vertex vi belongs u respectively
v u edge vi v j two soft clauses xi x j xi x j given complete
assignment number violated clauses e size cut associated
assignment experiments considered max cut instances extracted random graphs
nodes varying number edges
ax one
given satisfiable cnf formula max one finding model maximum
number variables set true encoded max sat considering
clauses original formula mandatory adding weighted unary clause xi
variable formula note solving much harder solving usual sat
search cannot stop soon model found optimal model must
found optimality must proved considered max one two types
cnf formula random sat instances variables generated cnfgen structured
satisfiable instances coming sat competition
inimum v ertex c overing



ax c lique

given graph g v e vertex covering set u v every edge vi v j
vi u v j u size vertex covering u minimum vertex covering
consists finding covering minimal size naturally formulated weighted maxsat associate one variable xi graph vertex vi value true respectively false indicates
van gelder ftp dimacs rutgers edu pub challenge satisfiability contributed ucsc instances
http www satcompetition org



fim ini ax



e fficient w eighted ax sat olver

vertex vi belongs u respectively v u binary hard xi x j edge
vi v j specifies one two vertices covering
edge connecting unary clause xi variable xi order specify
preferred add vertices u simple way transform minimum vertex
coverings max cliques vice versa fahle
experiments considered maximum clique instances extracted random graphs
nodes varying number edges considered max clique instances
dimacs challenge
c ombinatorial auctions
combinatorial auction defined set goods g set bidders bid indivisible
subsets goods bid defined subset requested goods gi g amount
money offered bid taker wants maximize revenue must decide bids
accepted note two bids request good cannot jointly accepted sandholm
max sat encoding one variable xi associated bid unit
clauses xi ui indicating bid accepted loss profit ui besides
pair j conflicting bids mandatory clause xi x j
experiments used cats generator k leyton brown shoham
allows generate random instances inspired real world scenarios particular generated
instances regions paths scheduling distributions number goods fixed
increased number bids increasing number bids instances become
constrained namely conflicting pairs bids harder solve
iscellaneous
considered following sets instances widely used literature
unsatisfiable instances nd dimacs implementation challenge considered
de givry larrosa meseguer schiex li et al random sat instances
aim dubois pigeon hole hole coloring pret observe
instances modelled unweighted max sat e clauses weight
max csp random instances generated protocol specified larrosa schiex
de givry heras larrosa zytnicki distinguish different sets
dense loose dl dense tight dt sparse loose sl sparse tight st
tight instances variables loose instances variables
set contains instances values instances values per variable
cooper cussat blanc de roquemaurel regnier graph coloring
structured instances taken weighted constraint satisfaction wcsp repository





ftp dimacs rutgers edu pub challenge graph benchmarks clique
http mat gsia cmu edu challenge html
http mat gsia cmu edu coloring benchmarks
http mulcyber toulouse inra fr plugins scmcvs cvsweb php benchs cvsroot toolbar



fih eras l arrosa liveras

taken pseudo boolean evaluation logic synthesis misc garden
routing mpi minimum prime implicant mps miplib instances encoded
max sat specified previous section
note max csp graph coloring instances encoded max sat
direct encoding walsh
alternative solvers
compare ini ax several optimizers different communities restricted
comparison freely available solvers considered following ones
axsatz li et al li manya planes unweighted max sat solver
best unweighted max sat solver max sat evaluation
ax dpll heras larrosa larrosa et al weighted max sat solver
part oolbar package best solver weighted max sat second
best solver unweighted max sat max sat evaluation
oolbar larrosa larrosa schiex de givry et al
state art weighted csp solver
p ueblo sheini sakallah pseudo boolean solver ranked first
several categories pseudo boolean evaluation
inisat een sorensson pseudo boolean solver translates sat solves minisat ranked first several categories
pseudo boolean evaluation
instances taken pseudo boolean evaluation given original format
p ueblo inisat instances translated max sat pbo partitioning
set clauses three sets h contains mandatory clauses c w contains nonunary weighted clauses c u u contains unary weighted clauses l u
hard clause c j h pseudo boolean constraint c j c j obtained
c j replacing negated variables x x non unary weighted clause
c j u j w pseudo boolean constraint c j r j c j computed
r j variable set trivially satisfies constraint finally objective
function minimize



u jr j



u jl j

l j u j u

c j u j w

experimental
divide experiments two parts purpose first part evaluate impact
different techniques ini ax set different parameters since
techniques effective benchmarks useless even counterproductive others brglez li stallman aimed finding configuration ini ax
http www cril univ artois fr pb



fim ini ax



e fficient w eighted ax sat olver

performs reasonably well instances purpose second part compare ax alternative solvers since solvers specifically designed
type expect ini ax outperform rather want
robustness ini ax showing usually close performance
best alternative type
presented plots tables regarding tables first column contains name
set second column shows number instances remaining columns
report performance different solvers cell contains average cpu time
solver required solve instances solver could solve instances set
number inside brackets indicates number solved instances average cpu time
takes account solved instances cell contains dash means instance could
solved within time limit regarding plots note legend goes accordance
performance solvers time limit set seconds instance
solver written c implemented top inisat een sorensson
executions made ghz xeon computer linux experiments random
instances samples instances plots report mean cpu time seconds
setting parameters ini ax
following evaluate order importance following techniques inside ini ax lower bounding soft probing branching heuristics learning backjumping
starting basic version guides search jeroslow branching heuristic
rest techniques deactivated analyze one one analysis studies one technique
incorporates previously analyzed ones corresponding tuned parameters
three first experiments consider little challenging instances generated randomly
lower bounding plays fundamental role solve finally consider structured instances
learning backjumping required solve
l ower

bounding

experiment analyze impact resolution lower bounding versus substractionbased lower bounding well combined strategies considered following combination
two techniques sup detects inconsistency refutation tree computed
look resolvent maximum size size less equal parameter k
resolution lower bounding applied otherwise substraction lower bounding
applied tested k note k corresponds pure substraction
lower bounding therefore similar li et al k corresponds
pure resolution lower bounding
presented figure seen pure substraction lower bounding k worst option better obtained k increases however
improvement stops nearly stops k k significant improvement noticed plot omits k k case clarity reasons since higher values k may
produce clauses higher size may cause overhead instances set k
rest experiments


fih eras l arrosa liveras

max sat variables




b max sat variables

k
k
k
k
k inf

cpu time

cpu time















k
k
k
k inf
k



number clauses











number clauses

cpu time

c max cut nodes










k
k
k
k
k inf











number nodes

figure performance ini ax different mixed lower boundings k inf

oft

probing

second experiment evaluate impact soft probing preliminary experiments
observed soft probing time consuming decided limit soft probing
follows initially assign propagation level variable probe literal
propagate assigned propagation level l literal produces propagation
level l limited probing propagate literals maximum propagation level
finally restricted since gives best note propagation level
decision level
compare three alternatives probing node search probing pre process
search p probing n figure indicates probing
search worst option max sat max sat produces improvement
max cut finally probing preprocessing gives slightly improvement max sat
best max cut note soft probing preprocessing max sat effect
omitted plot similar n given decided include
soft probing preprocessing
j eroslow

branching heuristic

following experiment evaluate importance weighted jeroslow heuristic figure
shows time difference ini ax jeroslow heuristic previous
two experiments jeroslow without heuristic none indicates guiding search
jeroslow heuristic gives important speed ups hence maintain jeroslow heuristic
ini ax


fim ini ax



e fficient w eighted ax sat olver

max sat variables

cpu time




b max sat variables


n
p

cpu time


















n



number clauses











number clauses
c max cut nodes



cpu time



n

p










number nodes



figure performance ini ax without soft probing probing preprocessing p
probing search

l earning

backjumping

vsids

final experiment evaluate importance learning backjumping experiments use structured instances since well known learning backjumping
useful type besides evaluate importance vsids heuristic
combination learning backjumping recall heuristic specially designed
work cooperation learning meaningless analyze effect
table reports experiment third column reports without learning
backjumping lower bounding probing jeroslow heuristic none
fourth column reports adding learning backjumping previous version learning
fifth column reports adding learning backjumping changing jeroslow heuristic
vsids heuristic vsids ini ax without learning backjumping none clearly worst option significant improvements obtained learning
backjumping learning added finally adding vsids heuristic vsids improve specially routing instances incorporated learning
backjumping ini ax
regarding branching heuristic literals appear hard clauses
polarities applies vsids heuristic otherwise jeroslow heuristic computed
root search tree stated section choice done starting
search


fih eras l arrosa liveras

max sat variables



b max sat variables


none
jeroslow

none
jeroslow


cpu time

cpu time
















number clauses











number clauses
c max cut nodes


cpu time



none
jeroslow






number nodes

figure performance ini ax without heuristic none jeroslow heuristic
computed root node search tree jeroslow


max one col
max one cnt
max one dp
max one ezfact
routing
routing

n inst







none







learning







vsids







figure structured instances
comparison boolean optimizers
reporting omit solver cannot deal corresponding instances
technical reasons e g cannot deal weighted clauses performs extremely bad
comparison others
figure contains plots different benchmarks plots b reports
random unweighted max sat instances p ueblo inisat orders magnitude slower
included graphics max sat plot ini ax lays
ax dpll axsatz best option max sat plot b ini ax
clearly outperforms ax dpll close axsatz best
max sat max sat axsatz times faster ini ax


fim ini ax



e fficient w eighted ax sat olver

plot c reports random max cut instances ini ax performs slightly better
axsatz second alternative
random max one plot ini ax best solver far almost instances
solved instantly p ueblo ax dpll require seconds difficult instances inisat performs poorly structured max one instances reported
figure inisat seems fastest general ini ax close performance
p ueblo note however p instances ini ax system solving
instances
plot e reports random max clique instances ini ax best solver
order magnitude faster ax dpll second best option p ueblo inisat
perform poorly regarding structured dimacs instances ini ax best
option solves instances within time limit ax dpll inisat p ueblo
solve respectively
plots f g h present combinatorial auctions following different distributions
paths distribution ini ax best solver twice faster ax dpll
ranks second regions distribution ini ax best solver ax dpll
second best solver requiring double time paths regions distributions p ueblo
inisat perform poorly scheduling distribution inisat best solver
ini ax ax dpll one order magnitude slower
regarding unsatisfiable dimacs instances presented figure note
instances optimum cost hence soon ini ax solution cost
clauses declared hard learning backjumping applied hard conflicts
arise indicate axsatz ax dpll solve instance sets
pret aim ini ax solves sets instances best times
except hole instances axsatz slightly faster encode
advantageous way p ueblo inisat decision
rather optimization solve instances similar times ini ax
instances fig p ueblo best solver ini ax second best
solver oolbar third last one inisat surprising since oolbar
perform learning hard constraints regarding graph coloring instances
presented fig observed ini ax able solve one instance
oolbar p ueblo inisat solve many less instances max csp
fig oolbar solves instances instantly p ueblo worst option unable
solve lot instances ini ax clearly second best solver ini third
best performing solver note solve instances
regarding instances taken pseudo boolean evaluation found figure
note first time max sat solver tested pseudo boolean instances
indicate solver consistently outperforms ini ax fairly
competitive p ueblo inisat
conclude ini ax robust weighted maxsat solver competitive pure optimization lots
hard clauses sometimes best option
final remark note ini ax almost previous benchmarks submitted second max sat evaluation co located event tenth international conference theory applications satisfiability testing hence interested reader


fih eras l arrosa liveras

max sat variables



cpu time

max dpll
minimaxsat
maxsatz


cpu time

b max sat variables














max dpll
minimaxsat
maxsatz



number clauses

number clauses

c max cut nodes



cpu time

max dpll
maxsatz
minimaxsat


cpu time

max one random sat variables
















minisat

pueblo
max dpll

minimaxsat






number edges

number hard clauses

e max clique nodes


minisat
pueblo
max dpll
minimaxsat



pueblo
minisat
max dpll
minimaxsat


cpu time


cpu time

f c auctions paths goods
























connectivity

number bids

g c auctions scheduling goods

cpu time




h c auctions regions goods


pueblo
max dpll
minimaxsat
minisat

cpu time








minisat
pueblo
max dpll
minimaxsat










number bids











number bids

figure plots different benchmarks note order legend goes accordance
performance solvers

exhaustive comparison including instances solvers second max sat evaluation web page evaluation showed ini ax best
performing solver two four existing categories
http www maxsat udl es



fim ini ax



n inst









dubois
pret
pret
hole
aim
aim
aim

e fficient w eighted ax sat olver

ini ax








axsatz








ax dpll








figure unsatisfiable dimacs instances


col
col
col
col
cnt
dp
ezfact

n inst








ini ax








p ueblo








inisat








figure structured max one instances



graph coloring
max csp dl
max csp dt
max csp sl
max csp st

n inst







toolbar







ini ax







p ueblo







inisat







figure wcsp max csp instances

related work
previous work done incorporating sat techniques inside max sat solver
alsinet et al presented lazy data structure detect clauses become unit requires static branching heuristic argelich manya test different versions branch
bound procedure one versions uses two watched literals uses basic
lower bounding conclude none previous approaches general use
two watched literals far know rest max sat solvers adjacency
lists therefore presumably inefficient unit propagation lynce silva par

fih eras l arrosa liveras


misc
logic synthesis
mpi
mps
routing

n inst






ini ax






p ueblo






inisat






figure pseudo boolean instances
ticularly presence long clauses argelich manya b enhance max sat branch
bound procedure learning hard constraints used combination simple lower bounding techniques improved version presented argelich manya
powerful lower bound incorporate two watched literal scheme
backjumping etc best knowledge max sat solver incorporates backjumping
note ini ax restricts backjumping occurrence hard conflicts related works
integration backjumping techniques branch bound include work zivan
meisels weighted csp manquinho silva pseudo boolean optimization
nieuwenhuis oliveras sat modulo theories
max sat solvers use variations call substraction lower bounding
cases search special patterns mutually inconsistent subsets clauses shen
zhang xing zhang alsinet et al efficiency reasons patterns
restricted small sets small arity clauses clauses arity less ini ax uses natural weighted extension proposed li et al
first one able detect inconsistencies arbitrarily large sets arbitrarily large clauses
idea call resolution lower bounding inspired wcsp domain
larrosa larrosa schiex de givry et al first proposed
max sat context larrosa heras developed li et al heras
larrosa larrosa et al works special patterns fixed size
resolution trees executed use simulated unit propagation allows ini ax
identify arbitrarily large resolution trees following example present two inconsistent
subsets clauses detected ini ax transformed equivalent formula
previous solvers cannot transform since limited specific patterns
x w x w x w x x x w
x w x x w x x x w x x x x w x x x x w
first case ini ax replaces clauses min w w w w
set compensation clauses second case ini ax replaces
min w w w w w set compensation clauses cases equivalence
preserved however solvers literature detect inconsistent subset clauses
cannot transform equivalent one li et al simply cannot detect
heras larrosa
probing method derive weighted unit clauses related res cycle rule
heras larrosa larrosa et al failed literals li et al


fim ini ax



e fficient w eighted ax sat olver

singleton consistency csp debruyne bessiere use simulated unit
propagation allows ini ax identify arbitrarily large resolution trees

conclusions future work
ini ax efficient robust max sat solver deal hard soft
clauses well pseudo boolean functions incorporates best available techniques
type performance similar best specialized solver besides development ini ax combining first time known techniques different fields
main original contribution novel lower bounding technique resolution
ini ax lower bounding combines clean elegant way approaches proposed last years mainly unit propagation lower
bounding resolution transformation use information provided propagation queue determine subset inconsistent clauses ii determine
simple ordering resolution applied increase lower bound generate
equivalent formula however necessarily best ordering easy see
different orderings may generate resolvents compensation clauses different arities one
selects ordering generates smallest resolvents compensation clauses resulting
formula may presumably simpler future work concerns study orderings development vsids heuristics soft clauses backjumping techniques soft conflicts

acknowledgments
would thank niklas een niklas sorensson making inisat code publicly
available grateful anonymous referees helpful suggestions improving

work partially supported spanish ministry education science
projects tin c heras larrosa tin oliveras

references
alsinet manya f planes j improved exact solvers weighted max sat
proceedings sat vol lncs pp springer
argelich j manya f exact max sat solvers constrained j
heuristics
argelich j manya f b learning hard constraints max sat proceedings
csclp vol lncs pp springer
argelich j manya f partial max sat solvers clause learning proceedings
sat vol lncs pp springer
barth p davis putnam enumeration linear pseudo boolean optimization report mpi max planck institut fur informatik im stadtwald saarbrucken germany
brglez f li x stallman role skeptic agent testing benchmarking
sat proceedings sat pp


fih eras l arrosa liveras

buro buning h k report sat competition bulletin european
association theoretical computer science
cha b iwama k kambayashi miyazaki local search partial
maxsat proceedings aaai pp mit press
cooper cussat blanc de roquemaurel regnier p soft arc consistency
applied optimal proceedings cp vol lncs pp
springer
davis logemann g loveland g machine program theorem proving communications acm
de givry heras f larrosa j zytnicki existential arc consistency getting
closer full arc consistency weighted csps proceedings th ijcai pp
professional book center
de givry larrosa j meseguer p schiex solving max sat weighted csp
proceedings cp vol lncs pp springer
debruyne r bessiere c practicable filtering techniques constraint satisfaction proceedings icjai pp morgan kaufmann
een n sorensson n extensible sat solver proceedings sat vol
lncs pp springer
een n sorensson n translating pseudo boolean constraints sat journal
satisfiability boolean modeling computation
fahle simple fast improving branch bound maximum clique
proceedings esa vol lncs pp springer
freeman j w improvements propositional satisfiability search ph
thesis university pennsylvania
fu z malik solving partial max sat proceedings sat
vol lncs pp springer
heras f larrosa j inference rules efficient max sat solving proceedings
th aaai aaai press
jeroslow r g wang j solving propositional satisfiability annals mathematics artificial intelligence
k leyton brown p shoham towards universal test suite combinatorial
auction proceedings acm conference electronic commerce pp

karloff h j zwick u approximation max sat focs
pp
larrosa j heras f resolution max sat relation local consistency
weighted csps proceedings ijcai pp professional book center
larrosa j heras f de givry logical efficient max sat solving
artificial intelligence appear


fim ini ax



e fficient w eighted ax sat olver

larrosa j schiex quest best form local consistency weighted
csp proceedings th ijcai pp
larrosa j node arc consistency weighted csp proceedings aaai pp
aaai press
le berre exploiting real power unit propagation lookahead proceedings
lics workshop theory applications satisfiability testing
le berre sat j project max sat http www sat j org
li c manya f planes j exploiting unit propagation compute lower bounds
branch bound max sat solvers proceedings cp vol lncs pp

li c manya f planes j inference rules max sat journal artificial
intelligence appear
li c manya f planes j detecting disjoint inconsistent subformulas computing lower bounds max sat proceedings th aaai aaai press
lynce silva j p probing preprocessing techniques propositional
satisfiability proceedings ictai pp ieee computer society
lynce silva j p efficient data structures backtrack search sat solvers ann
math artif intell
manquinho v silva j p satisfiability boolean optimization ann math artif intell
moskewicz w madigan c f zhao zhang l malik chaff engineering
efficient sat solver proceedings dac pp acm
nieuwenhuis r oliveras sat modulo theories optimization
proceedings sat vol lncs pp springer
papadimitriou c computational complexity addison wesley usa
sandholm optimal winner determination combinatorial auctions
proceedings ijcai pp morgan kaufmann
sheini h sakallah k pueblo hybrid pseudo boolean sat solver journal
satisfiability boolean modeling computation
shen h zhang h study lower bounds max sat proceedings aaai
pp aaai press mit press
silva j p sakallah k grasp search satisfiability
iccad pp
smyth k hoos h h stutzle iterated robust tabu search max sat
proceedings ai vol lncs pp springer
tompkins hoos h h ubcsat implementation experimentation
environment sls sat max sat proceedings sat vol
lncs pp springer
walsh sat v csp proceedings cp vol lncs pp springer


fih eras l arrosa liveras

xing z zhang w maxsolver efficient exact weighted maximum
satisfiability artificial intelligence
zhang l madigan c f moskewicz w malik efficient conflict driven learning boolean satisfiability solver proceedings iccad pp
zivan r meisels conflict directed backjumping maxcsps proceedings
ijcai pp




