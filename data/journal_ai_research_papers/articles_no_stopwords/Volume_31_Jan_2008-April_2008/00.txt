Journal Artificial Intelligence Research 31 (2008) 1-32

Submitted 5/07; published 01/08

INI AX AT: Efficient Weighted Max-SAT Solver
Federico Heras
Javier Larrosa
Albert Oliveras

FHERAS @ LSI . UPC . EDU
LARROSA @ LSI . UPC . EDU
OLIVERAS @ LSI . UPC . EDU

Technical University Catalonia, LSI Department
Jordi Girona 1-3, 08034, Barcelona, Spain.

Abstract
paper introduce INI AX AT, new Max-SAT solver built top incorporates best current SAT Max-SAT techniques. handle hard clauses
(clauses mandatory satisfaction SAT), soft clauses (clauses whose falsification penalized cost Max-SAT) well pseudo-boolean objective functions constraints.
main features are: learning backjumping hard clauses; resolution-based substractionbased lower bounding; lazy propagation two-watched literal scheme. empirical
evaluation comparing wide set solving alternatives broad set optimization benchmarks
indicates performance INI AX usually close best specialized alternative
and, cases, even better.
+.

1. Introduction
Max-SAT optimization version SAT goal satisfy maximum number
clauses. considered one fundamental combinatorial optimization problems many important problems naturally expressed Max-SAT. include academic problems
max cut max clique, well real problems domains routing, bioinformatics, scheduling
electronic markets.
long tradition theoretical work structural complexity (Papadimitriou,
1994) approximability (Karloff & Zwick, 1997) Max-SAT. work restricted
simplest case clauses equally important (i.e., unweighted Max-SAT)
fixed size (mainly binary ternary). practical point view, significant progress
made last 3 years (Shen & Zhang, 2004; Larrosa & Heras, 2005; Larrosa, Heras, & de Givry,
2007; Xing & Zhang, 2005; Li, Manya, & Planes, 2005, 2006). result, handful
new solvers deal, first time, instances involving hundreds variables.
main motivation work comes study Max-SAT instances modelling realworld problems. usually encounter three features:
satisfaction clauses importance, clause needs
associated weight represents cost violation. extreme case,
often happens practice observed Cha, Iwama, Kambayashi, Miyazaki (1997),
clauses whose satisfaction mandatory. usually modelled associating
high weight them.
Literals appear randomly along clauses. contrary, easy identify
patterns, symmetries kinds structures.
c
2008
AI Access Foundation. rights reserved.

fiH ERAS , L ARROSA , & LIVERAS

problems mandatory clauses reduce dramatically number feasible
assignments, optimization part problem plays secondary role. However,
problems mandatory clauses trivially satisfiable real difficulty lays
optimization part.
look current Max-SAT solvers, find none robust three
features. instance, Li et al.s (2005, 2006) solvers restricted formulas clauses
equally important (i.e. unweighted Max-SAT), Shen Zhangs (2004) one restricted binary clauses, one described Larrosa et al. (2007) seems efficient overconstrained
problems (i.e., small fraction clauses simultaneously satisfied), one
Alsinet, Manya, Planes (2005) seems efficient slightly overconstrained problems (i.e.
almost clauses satisfied). solver described Argelich Manya (2007), developed parallel research described paper, handle mandatory clauses
one incorporates learning, seems perform well structured problems. However,
non-mandatory clauses must weight. Finally, approaches based translating
Max-SAT instance SAT instance solve SAT solver seem effective
highly structured problems almost clauses mandatory (Fu & Malik, 2006; Le Berre,
2006).
paper introduce INI AX AT, new weighted Max-SAT solver incorporates
current best SAT Max-SAT techniques. build top INI + (Een & Sorensson,
2006), borrows capability deal pseudo-boolean problems INI (Een
& Sorensson, 2003) features processing mandatory clauses learning backjumping.
extended allowing deal weighted clauses, preserving two-watched literal
lazy propagation method. main original contribution INI AX implements
novel efficient lower bounding technique. Specifically, applies unit propagation
order detect disjoint subsets mutually inconsistent clauses done Li et al. (2006).
simplifies problem following Larrosa Heras (2005), Heras Larrosa (2006), Larrosa
et al. (2007) order increment lower bound. However, works clauses
accomplish specific patterns transformed, INI AX need define
patterns.
structure paper follows: Section 2 provides preliminary definitions SAT
Section 3 presents state-of-the-art solving techniques incorporated modern SAT solver
INI AT. Then, Section 4 presents preliminary definitions Max-SAT Section 5 overviews
INI AX AT. that, Sections 6 7 focus lower bounding additional features,
respectively. Section 8 present benchmarks used empirical evaluation
report experimental results. Finally, Section 9 presents related work Section 10 concludes
points possible future work.

2. Preliminaries SAT
sequel X = {x1 , x2 , . . . , xn } set boolean variables. literal either variable xi
negation xi . variable literal l refers noted var(l). Given literal l, negation l xi
l xi xi l xi . clause C disjunction literals. size clause, noted |C|,
number literals has. set variables appear C noted var(C). Sometimes
associate subscript Greek letter clause (e.g. (xi x j ) ) order facilitate future references
clause.
2

fiM INI AX AT:



E FFICIENT W EIGHTED AX -SAT OLVER

Algorithm 1: DPLL basic structure.
Function Search() : boolean
1
InitQueue( ) ;
2
Loop
3
UP( ) ;
4
Conflict
5
AnalyzeConflict( ) ;
6
Top Conflict return f alse ;
else
7
LearnClause( ) ;
8
Backjump( ) ;
9
10
11
12

else variables assigned return true ;
else
l := SelectLiteral( ) ;
Enqueue(Q, l) ;

assignment set literals containing variable negation. Assignments
maximal size n called complete, otherwise called partial. Given assignment ,
variable x unassigned neither x x belong . Similarly, literal l unassigned var(l)
unassigned.
assignment satisfies literal iff belongs assignment, satisfies clause iff satisfies
one literals falsifies clause iff contains negation literals.
latter case say clause conflicting always happens empty clause, noted
2. boolean formula F conjunctive normal form (CNF) set clauses representing
conjunction. model F complete assignment satisfies clauses F .
F model, call satisfiable, otherwise say unsatisfiable. Moreover,
complete assignments satisfy F , say F tautology.
Clauses size one called unit clauses simply units. formula contains unit l,
simplified removing clauses containing l removing l clauses
appears. application rule quiescence called unit propagation (UP) well
recognized fundamental propagation technique current SAT solvers.
Another well-known rule resolution, which, given formula containing two clauses
form (x A), (x B) (called clashing clauses), allows one add new clause (A B) (called
resolvent).

3. Overview State-of-the-art DPLL-based SAT Solvers
section overview architecture SAT solvers based DPLL (Davis, Logemann,
& Loveland, 1962) procedure. procedure, currently regarded efficient complete
search procedure SAT, performs systematic depth-first search space assignments.
internal node associated partial assignment two successors obtained selecting
unassigned variable x extending current assignment x x, respectively.
visited node, new units derived due application unit propagation (UP). leads
3

fiH ERAS , L ARROSA , & LIVERAS

Algorithm 2: Unit Propagation.
Function UP(Q) : Conflict
(Q contains non-propagated literals)
13
l := GetFirstNonPropagatedLit(Q); MarkAsPropagated(l) ;
14
foreach clause C l becomes unit falsified
15
C l becomes unit q Enqueue(Q, q) ;
16
else C l becomes falsified return Conflict ;
return None ;

conflicting clause, procedure backtracks, performing non-chronological backtracking
clause learning, originally proposed Silva Sakallah (1996).
algorithmic description DPLL procedure appears Algorithm 1. algorithm uses
propagation queue Q contains units pending propagation contains representation
current assignment.
First, propagation queue Q filled units contained original formula (line 1).
main loop starts line 2 iteration procedure charge propagating pending
units (line 3). conflicting clause found (line 4), conflict analyzed (line 5) result
new clause learned (i.e, inferred recorded, line 7).
Then, procedure backtracks, using propagation queue Q undo assignment
exactly one literals learned clause becomes unassigned (line 8). one
backtrack still maintaining condition, advantageous (this commonly referred backjumping non-chronological backtracking, see Silva & Sakallah, 1996).
leads conflict, new unassigned literal selected extend current partial assignment.
new literal added Q (line 10) new iteration takes place.
procedure stops complete assignment found (line 9) top level conflict
found (line 6). first case, procedure returns true indicates model
found, second case returns f alse means model exists input
formula.
performance DPLL-based SAT solvers greatly improved 2001, SAT
solver C HAFF (Moskewicz, Madigan, Zhao, Zhang, & Malik, 2001) incorporated two-watched
literal scheme efficient unit propagation, First UIP scheme (Zhang, Madigan, Moskewicz,
& Malik, 2001) clause learning cheap VSIDS branching heuristic. Currently, stateof-the-art SAT solvers, INI (Een & Sorensson, 2003), implement small variations
three features. following describe depth.
3.1 Unit Propagation
aim unit propagation twofold: one hand, finds clauses become units
due current assignment, hand, detects whether clause become
conflicting. concrete procedure given Algorithm 2. non-propagated literals exist
Q, picks oldest one l marks propagated (line 13). clauses containing l
may become falsified units traversed (we later describe clauses
detected). one clauses becomes unit q, enqueued Q propagated later (line
4

fiM INI AX AT:



E FFICIENT W EIGHTED AX -SAT OLVER

15). procedure iterates units propagate conflicting clause
found (line 16).
two types literals Q: decision literals algorithm heuristically
selected assigned branching point (lines 11 12 Algorithm 1); consequence literals
added logical consequences previous decision literals (line 15).
INI uses non-standard queue handle units pending propagation. Unlike classical queues,
fetching element, removed, marked such. Consequently, Q formed
two sets elements: already propagated literals literals pending propagation.
advantage strategy execution point, Q contains current assignment.
Besides, propagated literals Q divided decision levels. decision level contains
decision literal set related consequences. Furthermore, literal l associated
original clause caused propagation noted l(); clause usually referred
reason l. Note decision literal l reason represented
ld .
Example 1 Consider formula {(x1 x2 ) , (x1 x3 ) , (x4 x5 ) }. starting execution,
propagation queue empty Q = [k]. use symbol k separate propagated literals (on
left) literals pending propagation (on right). literal x1 selected, added
Q. propagation queue contains Q = [kxd1 ]. propagate x1 add two new
consequences x2 x3 . propagation queue Q = [xd1 kx2 (), x3 ()] current
assignment {x1 , x2 , x3 }. propagation x2 x3 add new literals Q, becomes
Q = [xd1 , x2 (), x3 ()k]
x4 decided, add new consequence x5 . propagation, Q =

[x1 , x2 (), x3 (), xd4 , x5 ()k]. current assignment {x1 , x2 , x3 , x4 , x5 }. Note literals
propagated complete assignment found. Note well Q contains two
decision levels: first one formed literals x1 , x2 x3 second one formed
literals x4 x5 .
3.1.1 L AZY DATA TRUCTURES .
mentioned, aim detect units conflicting clauses. Taking account
process typically takes 80% total runtime SAT solver, important
design efficient data structures.
first attempt use adjacency lists. literal, one keeps list clauses
literal appears. Then, upon addition literal l assignment, clauses
containing l traversed. main drawback refinements detect efficiently
clause become unit, keeping counters indicating number unassigned
literals clause, involved considerable amount work upon backtracking.
method used INI two-watched literal scheme introduced Moskewicz et al.
(2001). basic idea clause cannot unit conflicting (i) one satisfied literal
(ii) two unassigned literals.
algorithm keeps two special literals clause, called watched literals, initially
two unassigned literals, tries maintain invariant always one satisfied literal two
unassigned literals watched.
invariant may broken one two watched literals becomes falsified.
case, clause traversed looking another non-false literal watch order restore
5

fiH ERAS , L ARROSA , & LIVERAS

invariant. one literal cannot found, clause declared true, unit conflicting depending value watched literal. Hence, literal l added assignment,
clauses may become falsified unit (line 14 Algorithm 2) clauses
l watched.
main advantage approach work clauses done upon
backtracking. However, main drawback way know many literals
unassigned given clause traversing literals. Note information used
techniques Two-sided Jeroslow branching heuristic (See Section 3.3).
3.1.2 R ESOLUTION R EFUTATION REES .
detects conflict, unsatisfiable subset clauses F 0 determined using information provided Q. Since F 0 unsatisfiable, empty clause 2 derived F 0 via
resolution. resolution process called refutation. refutation unsatisfiable clause set
F 0 resolution refutation tree (or simply refutation tree) every clause used exactly
resolution process.
refutation tree built propagation queue Q follows: let C0 conflicting
clause. Traverse Q LIFO (Last First Out) fashion clashing clause D0 found.
resolution applied C0 D0 , obtaining resolvent C1 . Next, traversal Q continues
clause D1 clashes C1 found, giving resolvent C2 iterate process
resolvent obtain empty clause 2. importance refutation trees become
relevant Section 6.
Example 2 Consider F = {(x1 ) , (x1 x4 ) , (x1 x2 ) , (x1 x3 x4 ) , (x1 x2 x3 ) , (x1 x5 ) }.
apply unit propagation unit clause enqueued producing Q = [kx1 ()]. x1
propagated Q becomes [x1 ()kx4 (), x2 (), x5 ()]. that, literal x4 propagated causing
clause become unit Q becomes [x1 (), x4 ()kx2 (), x5 (), x3 ()]. that, literal x2
propagated clause found conflicting. Figure 1.a shows state Q
propagation.
build refutation tree. Starting tail Q first clause clashing
conflicting clause . Resolution generates resolvent x1 x2 x4 . first
clause clashing x2 , producing resolvent x1 x4 . next clause clashing x4
resolution generates x1 . Finally, resolve clause obtain 2.Figure 1.b shows
resulting refutation tree.
3.2 Learning Backjumping
Learning backjumping best illustrated example (see Silva & Sakallah, 1996; Zhang
et al., 2001, precise description):
Example 3 Consider formula {(x1 x2 ) , (x3 x4 ) , (x5 x6 ) , (x2 x5 x6 ) } partial
assignment {x1 , x2 , x3 , x4 , x5 , x6 } leads conflict clause . Suppose current
propagation queue Q = [xd1 , x2 (), xd3 , x4 (), xd5 , x6 ()k].
example easy see decision xd1 incompatible decision xd5 . incompatibility represented clause (x1 x5 ). Similarly, consequence x2 incompatible
decision xd5 represented clause (x2 x5 ).
6

fiM INI AX AT:



E FFICIENT W EIGHTED AX -SAT OLVER

F = {(x1 ) , (x1 x4 ) , (x1 x2 ) , (x1 x3 x4 ) , (x1 x2 x3 ) , (x1 x5 ) }

(x1 x2 x3 ) (x1 x3 x4 )
x3 ()

x1 x2 x4

(x1 x2 )

x5 ()
x2 ()

x1 x4

(x1 x4 )

x1

(x1 )

x4 ()
x1 ()

2
a)

b)

Figure 1: Graphical representation propagation queue Q refutation tree example
2. top, original formula F . left, propagation Q step 1. Arrows
indicate order resolving clauses selected. right, resolution tree
computed step 2.

Clause learning implements different techniques used discover implicit incompatibilities adds formula. Learned clauses accelerate subsequent search,
since increase potential future executions. However, observed
unrestricted clause learning impractical cases (recorded clauses consume memory
repeated recording may lead exhaustion). reason, current SAT solvers incorporate
different clause deletion policies order remove learned clauses.
Learned clauses used backjump presence would allowed unit propagation earlier decision level. case, say clause asserting backjumping
proceed going back level adding unit propagated literal. Among several
automated ways generating asserting clauses, INI uses so-called First Unique Implication Point (1UIP) (Zhang et al., 2001).
3.3 Branching Heuristic
Branching occurs function SelectLiteral (Algorithm 1). literals
propagate, function chooses one variable unassigned ones assigns value.
7

fiH ERAS , L ARROSA , & LIVERAS

importance branching heuristic well known, since different branching heuristic may
produce different-sized search trees.
Early branching heuristics include Bohms Heuristic (Buro & Buning, 1993), Maximum Ocurrences Minimum sized clauses (MOM) (Freeman, 1995) Two sided-Jeroslow
Wang Heuristic (Jeroslow & Wang, 1990). heuristics try choose literal
assignment generate largest number implications satisfy clauses.
heuristics state dependent, is, use information state clauses given
current assignment. them, information number unassigned literals
clause. Hence, implemented jointly data structures based adjacency lists since
keep information. instance, Two sided-Jeroslow Wang Heuristic computes
literal l F following function:
J(l) =



2|C|

CF
s.t. lC

selects literal l maximizes function J(l).
solvers become efficient, updating metrics state-dependent heuristics dominates
execution time. Hence INI uses slight modification state-independent heuristic first
proposed Moskewicz et al. (2001). heuristic, called Variable State Independent Decaying
Sum (VSIDS), selects literal appears frequently clauses, giving priority
recently learned clauses. advantage heuristic metrics updated
clauses learned. Since occurs occasionally, computation low overhead.
VSIDS heuristic suits perfectly lazy data structures two-watched literal scheme.

4. (Weighted) Max-SAT
weighted clause pair (C, w), C clause w integer representing cost
falsification, called weight. problem contains clauses must satisfied,
call clauses mandatory hard associate special weight >. Non-mandatory
clauses called soft. weighted formula conjunctive normal form (WCNF) set
weighted clauses. model complete assignment satisfies mandatory clauses. cost
assignment sum weights clauses falsifies. Given WCNF formula F ,
Weighted Max-SAT problem finding model F minimum cost. cost
called optimal cost F . Note formula contains mandatory clauses, weighted
Max-SAT equivalent classical SAT. clauses weight 1, so-called
(unweighted) Max-SAT problem. following, assume weighted Max-SAT.
say weighted formula F 0 relaxation weighted formula F (noted F 0 v F )
optimal cost F 0 less equal optimal cost F (non-models considered
cost infinity). say two weighted formulas F 0 F equivalent (noted F 0 F )
F 0 v F F v F 0 .
Max-SAT simplification rules transforms formula F equivalent, presumably simpler formula F 0 . SAT simplification rules (e.g. unit propagation, tautology removal,...)
directly applied Max-SAT restricted mandatory clauses. However, several specific Max-SAT
simplification rules exist (Larrosa et al., 2007). instance, formula contains clauses (C, u)
(C, v), replaced (C, u + v). contains clause (C, 0), may removed.
contains unit (l, >), simplified removing (including soft) clauses containing l
8

fiM INI AX AT:



E FFICIENT W EIGHTED AX -SAT OLVER

removing l clauses (including soft clauses) appears. application
rule quiescence natural extension unit propagation Max-SAT.
empty clause may appear weighted formula. weight >, clear
formula model. weight w < >, cost assignment include
weight, w obvious lower bound formula optimal cost. Weighted empty clauses
interpretation terms lower bounds become relevant Section 6.
shown Larrosa et al. (2007), notion resolution extended weighted formulas
follows 1 ,


(A B, m),








(x A, u m),
(x B, w m),
{(x A, u), (x B, w)}



(x B, m),






(x B, m)

B arbitrary disjunctions literals = min{u, w}.
(x A, u) (x B, w) called prior clashing clauses, (A B, m) called resolvent,
(x A, u m) (x B, w m) called posterior clashing clauses, (x B, m)
(x B, m) called compensation clauses. effect Max-SAT resolution, classical
resolution, infer (namely, make explicit) connection B. However,
important difference classical resolution Max-SAT resolution. former yields
addition new clause, Max-RES transformation rule. Namely, requires replacement
left-hand clauses right-hand clauses. reason cost prior clashing
clauses must substracted order compensate new inferred information. Consequently,
Max-RES better understood movement knowledge formula.
resolution rule Max-SAT preserves equivalence (). last two compensation clauses
may lose clausal form, following rule (Larrosa et al., 2007) may needed recover it:

l : |B| = 0
CNF(A l B, u) =

{(A l B, u)} CNF(A B, u) : |B| > 0

Example 4 apply weighted resolution following clauses {(x1 x2 , 3), (x1 x2 x3 , 4)}
obtain {(x2 x2 x3 , 3), (x1 x2 , 3 3), (x1 x2 x3 , 4 3), (x1 x2 (x2 x3 ), 3), (x1 x2 x2
x3 , 3)}. first clause simplified. second clause omitted weight
zero. fifth clause omitted tautology. fourth element clause
simple disjunction. Hence, apply CNF rule obtain two new
clauses CNF(x1 x2 (x2 x3 ), 3) = {(x1 x2 x2 x3 , 3), (x1 x2 x3 , 3)}. Note first new
clause tautology. Therefore, obtain equivalent formula {(x2 x3 , 3), (x1 x2 x3 , 1), (x1
x2 x3 , 3)}.

5. Overview INI AX
INI AX weighted Max-SAT solver built top INI + (Een & Sorensson, 2006).
DPLL-based SAT solver could used, INI + particularly wellsuited short open-source code. Besides, deal pseudo-boolean constraints.
1. empty clause represents tautology. special weight >, relations > = >
> > = > (Larrosa et al., 2007)

9

fiH ERAS , L ARROSA , & LIVERAS

Algorithm 3: INI AX basic structure.
Function Search() : integer
17
ub := LocalSearch(); lb := 0 ;
18
InitQueue(Q) ;
19
Loop
20
Propagate() ;
21
Hard Conflict
AnalyzeConflict() ;
Top Level Hard Conflict return ub ;
else
LearnClause() ;
Backjump() ;
22

23
24
25

26

else Soft Conflict
ChronologicalBactrack() ;
End Search return ub ;
else variables assigned
ub := lb ;
ub = 0 return ub ;
ChronologicalBactrack() ;
End Search return ub ;
else
l := SelectLiteral() ;
Enqueue(Q, l) ;

Given WCNF formula (possibly containing hard soft clauses), INI AX returns
cost optimal model (or > model). achieved means branch-andbound search, usually done solve optimization problems.
INI AT, tree assignments traversed depth-first manner. search point,
algorithm tries simplify current formula and, ideally, detect conflict, would mean
current partial assignment cannot successfully extended. INI AX distinguishes
two types conflicts: hard soft. Hard conflicts indicate model extending
current partial assignment (namely, mandatory clauses cannot simultaneously satisfied).
Hard conflicts detected taking account hard clauses using methods INI AT.
hard conflict occurs, INI AX learns hard clause backjumps INI would
do. Soft conflicts indicate current partial assignment cannot extended optimal
assignment. order identify soft conflicts, algorithm maintains two values search:
cost best model found far, upper bound ub optimal solution.
underestimation best cost achieved extending current partial assignment model, lower bound lb current subproblem.
soft conflict detected lb ub, means current assignment cannot lead
optimal model. soft conflict detected, algorithm backtracks chronologically. Note
10

fiM INI AX AT:



E FFICIENT W EIGHTED AX -SAT OLVER

Algorithm 4: MiniMaxSat propagation.
Function MS-UP() : conflict
(Q contains non-propagated literals)
27
l := GetFirstNonPropagatedLit(Q); MarkAsPropagated(l) ;
;
28
lb := lb +V (l))
29
lb ub return Soft Conflict ;
>) becomes unit falsified
30
foreach Hard clause (C l,

31
(C l, >) becomes unit (q, >) Enqueue(Q, q) ;
>) becomes falsified return Hard Conflict ;
32
else (C l,
u) becomes unit
33
foreach Soft clause (C l,

34
(C l, u) becomes unit (q, u) V (q) := V (q) + u ;

35
36
37
38
39

return None ;
Function Propagate() : conflict
c := MS-UP( ) ;
c = Hard Soft Conflict return c ;
improveLB( ) ;
lb ub return Soft Conflict ;
return None ;

one could backjump computing clause expressing reasons led lb ub.
However, presence lots soft clauses, approach ends creating many long
clauses affect negatively efficience solver hence decided perform
simple chronological backtracking.
want remark soft clause (C, w) w ub must satisfied optimal
assignment. Therefore, following assume soft clauses automatically transformed hard clauses previous search. ones, soft clause promoted
hard one search.
algorithmic description INI AX presented Algorithm 3. starting
search, good initial upper bound obtained local search method (line 17) may yield
identification new hard clauses. current implementation use U BCSAT (Tompkins & Hoos, 2004) default parameters. selected local search algorithm IROTS (Iterated
Robust Tabu Search) (Smyth, Hoos, & Stutzle, 2003). Besides, lower bound initialized
zero. Next, queue Q initialized unit hard clauses resulting formula (line 18).
main loop starts line 19 iteration charge propagating pending literals
(line 20) and, conflict detected, attempting extension current partial assignment
(line 26). Pending literals Q propagated function Propagate (line 20), may return hard soft conflict. hard conflict encountered (line 21) conflict analyzed,
new hard clause learned backjumping performed. done introduced Section 3.
soft conflict encountered (line 22) chronological backtracking performed. conflict
found (line 26), literal heuristically selected added Q propagation next iteration.
However, current assignment complete (line 23), upper bound updated. Search stops
zero-cost solution found, since cannot improved (line 24). Else, chronological
backtracking performed (line 25). Note backjumping leads termination top level hard
11

fiH ERAS , L ARROSA , & LIVERAS

conflict found, chronological backtracking leads termination two values first
assigned variable tried.
Algorithm 4 describes propagation process (function Propagate). uses array V (l)
accumulates weight soft clauses become unit l; namely, original
clauses (A l, w) current assignment falsifies A. clauses exists, assume
V (l) = 0. First all, performs Max-SAT-adapted form unit propagation (MS-UP, line 35).
MS-UP iterates non-propagated literals l Q (line 27). Firstly, adding l assignment

may make set soft clauses falsified. Since cost clauses kept V (l),
add lower bound (line 28). lower bound increment identifies soft conflict,
returned (line 29). Then, hard clause becomes unit, corresponding literal added Q
future propagation (line 31). Finally, soft clause becomes unit clause (q, u) (line 33),
weight u added V (q) (line 34). process hard conflict detected, function
returns (lines 32,36). Else, algorithm attempts detect soft conflict call procedure
improveLB (line 37), returns soft conflict found (line 38). next section
detailed description improveLB found. Finally, conflict detected, function
returns None (line 39).

6. Lower Bounding INI AX
following, consider arbitrary search state INI AX call
procedure improveLB. purpose section, search state characterized
current assignment. current assignment determines current subformula
original formula conditioned current assignment: clause contains literal part
current assignment, removed. Besides, literals whose negation appear current
assignment removed clauses appear.
value lb maintained INI AX precisely aggregation costs
clauses become empty due current assignment. Similarly, recall value
V (l) aggregation costs clauses become unit l due current
assignment. Thus, current subformula contains (2, lb) (l,V (l)) every l.
INI AX computes lower bound deriving new soft empty clauses (2, w)
resolution process. clauses added already existing clause (2, lb) producing
increment lower bound.
w) (l, u m), (l,
w
first step, improveLB replaces occurrence (l, u) (l,
m), (2, m) (with = min{u, w}), amounts applying restricted version Max-SAT resolution known Unit Neighborhood Resolution (UNR) (Larrosa et al., 2007).
produces immediate increment lower bound (i.e., weight empty clause
line 43) illustrated following example,
Example 5 Consider current state {(2, 3), (x1 , 1), (x2 , 1), (x1 , 2), (x2 , 2), (x1 x2 , 3)}. UNR
would resolve clauses (x1 , 1) (x1 , 2) replacing (x1 , 1) (2, 1) (all compensation clauses removed weight zero tautologies). two empty
clauses grouped (2, 3 + 1 = 4). UNR would resolve clauses (x2 , 1) (x2 , 2)
replacing (x2 , 1) (2, 1). two empty clauses grouped (2, 4 + 1 = 5). So,
new equivalent formula {(2, 5), (x1 , 1), (x2 , 1), (x1 x2 , 3)} higher lower bound 5.
12

fiM INI AX AT:



E FFICIENT W EIGHTED AX -SAT OLVER

Algorithm 5: Lower Bounding INI AX
Function SUP() : conflict
40
InitQueue(Q) ;
(Q contains non-propagated literals)
l := GetFirstNonPropagatedLit(Q); MarkAsPropagated(l) ;
41
foreach (Hard Soft) Clause C l becomes unit falsified
C l becomes unit q Enqueue(Q, q) ;
else C l becomes falsified return conflict ;

42
43
44
45
46
47
48

return None ;
Procedure improveLB() : lb
w) F
foreach (l, v), (l,
w m), (2, m) := min (v, w) ;
replace (l, v m), (l,
SU P() = con f lict
:= BuildTree() ;
:= minimum weight among clauses ;
Condition ApplyResolution( , ) ;
else lb := lb + m; remove weight clauses ;

second step improveLB executes simulation unit propagation (SUP, line 44)
soft clauses treated hard. First, SUP adds Q unit soft clauses (line
40). Then, new literals Q propagated. new (hard soft) clauses become unit,
inserted Q (line 41). SUP yields conflict, means subset (soft
hard) clauses cannot simultaneously satisfied. showed Section 3 Q used
identify subset build refutation tree . ImproveLB computes tree (line 45).
take account weights clauses apply Max-SAT resolution (Section 4)
dictated , one see produce new clause (2, m), minimum
weight among clauses tree (line 46). means extension current partial
assignment unassigned variables cost least m.
important remark step Max-SAT resolution process consider
minimum weight two clauses, rather minimum clauses
resolution tree. passed parameter line 47.
result resolution process replacement clauses leaves
(2, m) corresponding compensation clauses (function ApplyResolution line 47),
thus obtaining equivalent formula lower bound increment m. call procedure
resolution-based lower bounding.
Example 6 Consider formula F = {(x1 , 2) , (x1 x4 , 1) , (x1 x2 , >) , (x1 x3 x4 , 2) , (x1
x2 x3 , 3) , (x1 x5 , 1) }
Step 1. Apply SUP. Initially, unit clause enqueued producing Q = [kx1 ()].
x1 propagated Q becomes [x1 ()kx4 (), x2 (), x5 ()]. Literal x4 propagated clause
becomes unit, producing Q = [x1 (), x4 ()kx2 (), x5 (), x3 ()]. that, literal x2 propagated
clause found conflicting. Figure 2.a shows state Q propagation.
13

fiH ERAS , L ARROSA , & LIVERAS

F = {(x1 , 2) , (x1 x4 , 2) , (x1 x2 , >) , (x1 x3 x4 , 2) , (x1 x2 x3 , 3) , (x1 x5 , 1) }

(x1 x2 x3 , 3) (x1 x3 x4 , 2)

x3 ()






x5 ()



x2 ()

(x1 x2 x3 , 1)
(x1 x2 x3 x4 , 2) (x1 x2 x4 , 2) (x1 x2 , >)
(x1 x2 x3 x4 , 2)
(x1 x2 , >)

(x1 x4 , 2)

(x1 x4 , 2)



x4 ()
x1 ()

(x1 , 2)

2

(x1 , 2)

(2, 2)

a)

b)

c)

F 0 = {(x1 x2 , >), (x1 x5 , 1), (2, 2), (x1 x2 x3 , 1), (x1 x2 x3 x4 , 2), (x1 x2 x3 x4 , 2)}
F

00

= {(x1 x2 , >), (x1 x2 x3 , 1), (x1 x5 , 1), (2, 2)}

Figure 2: Graphical representation INI AX lower bounding. top, original
current formula F . left, propagation Q step 1. middle, structure
refutation tree computed simulation step 2. right,
effect actually executing Max-SAT resolution (step 3). resulting formula F 0
appears bellow. substraction-based lower bounding performed, step 3 replaced
substraction weights, producing formula F 00 .

Step 2. Build simulated refutation tree. Starting tail Q first clause clashing
conflicting clause . Resolution generates resolvent x1 x2 x4 .
first clause clashing x2 , producing resolvent x1 x4 . next clause clashing
x4 resolution generates x1 . Finally, resolve clause obtain 2.Figure 2.b
shows resulting resolution tree.
Step 3. Apply Max-SAT resolution. apply Max-SAT resolution indicated refutation
tree computed Step 2. Figure 2.c graphically shows result process. Leaf clauses
original (weighted) clauses involved resolution. internal node indicates resolution
step. resolvents appear junction edges. Beside resolvent, inside box,
compensation clauses must added formula preserve equivalence. Since
clauses used resolution must removed, resulting formula F 0 consists root
14

fiM INI AX AT:



E FFICIENT W EIGHTED AX -SAT OLVER

tree ((2, 2)),all compensation clauses clauses used refutation tree. is,
resulting formula F 0 = {(x1 x2 , >), (x1 x5 , 1), (2, 2), (x1 x2 x3 , 1), (x1 x2 x3 x4 , 2), (x1
x2 x3 x4 , 2)}. soundness Max-SAT resolution guarantees F F 0 .
Remark 1 transformations applied resolution-based lower bounding passed
descendent nodes changes preserve equivalence. Nevertheless, transformations
restored backtracking takes place.
alternative problem transformation resolution identify lower bound increment substract clauses would participated resolution
tree. procedure similar lower bound computed Li et al. (2005) call
substraction-based (line 48) lower bounding.
Example 7 Consider formula F previous example. Steps 1 2 identical. However,
substraction-based lower bounding would replace Step 3 Step 3 substracts weight 2
clauses appear refutation tree adds (2, 2) formula. result
F 00 = {(x1 x2 , >), (x1 x2 x3 , 1), (x1 x5 , 1), (2, 2)}. Note F 00 v F .
Remark 2 substractions applied substraction-based lower bounding restored moving descendent node preserve equivalence.
increment lower bound either technique, procedure SUP executed
again, may yield new lower bound increments. process repeated SUP
detect conflict.
comparing two previous approaches, observe resolution-based lower bounding
larger overhead, resolution steps need actually computed consequences
must added current formula removed upon backtracking. However, effort invested
transformation may well amortized increment obtained lower bound
becomes part current formula, discovered
descendent nodes search. hand, substraction-based lower bounding
smaller overhead resolution needs actually computed. facilitates
context restoration upon backtracking.
INI AX incorporates two alternatives chooses apply one heuristically (lines 47,48) depending specific condition (line 47). observed resolution-based
lower bounding seems effective resolution applied low arity clauses.
consequence, identification resolution tree, INI AX applies resolution-based
lower bounding largest resolvent resolution tree arity strictly less 4. Otherwise, applies substraction-based lower bounding. See Section 8 details.

7. Additional Features INI AX
section overview important features INI AX AT, namely use twowatched literal scheme, branching heuristic, use soft probing INI AX
deals pseudo-boolean functions.
15

fiH ERAS , L ARROSA , & LIVERAS

7.1 Two-Watched Literals
INI AX uses two-watched literal scheme soft clauses. Recall one main
advantages technique, applied pure SAT problems, backtracking takes
place, work done clauses. Unfortunately, case soft clauses restoration needs done. soft clause becomes unit literal l function MS-UP, weight
added V (l) clause eliminated (or marked eliminated) avoid reusing
lower bounding procedure. changes, well addition lb, restored
backtracking performed. However, note executions SUP (simulation unit
propagation) clauses considered hard. case two-watched literal scheme works
exactly SAT solver hard soft clauses. inconsistency detected
SUP stops literals propagate, initial state recovered.
situation restoring initial state completely overhead free.
7.2 Branching Heuristic
INI AX incorporates two alternative branching heuristics. first one VSIDS heuristic (Moskewicz et al., 2001) disregarding soft clauses (that is, INI default). heuristic
likely good structured problems learning backjumping play significant role,
well problems difficult find models (namely, satisfaction component
problem difficult optimization component). Since heuristic disregards soft
clauses, likely ineffective problems easy find models difficulty
find optimal one prove optimality. extreme case, problems contain soft clauses (every complete assignment model) VSIDS heuristic blind therefore
completely useless.
overcome limitation VSIDS, INI AX incorporates Weighted Jeroslow
heuristic (Heras & Larrosa, 2006). extension SAT Jeroslow heuristic described
Section 3. Given weighted formula F, literal l F following function defined:
J(l) =



2|C| w

(C,w)F
s.t. lC

mandatory clauses assumed weight equal upper bound ub. heuristic
selects literal highest value J(l). main disadvantage metrics need
updated visited node. combination two-watched literal updating becomes
expensive seem pay general. Thus, current implementation
heuristic, J(l) values computed root node used throughout solving
process. found experiments heuristic good alternative problems
difficulty lies optimization part (e.g. problems many models). INI AX
automatically changes VSIDS weighted Jeroslow problem contain literal
l hard clauses l hard clauses l.
heuristics, literal l V (l) + lb ub node search
tree, l selected literal l never assigned.
16

fiM INI AX AT:



E FFICIENT W EIGHTED AX -SAT OLVER

7.3 Soft Probing
Probing well-known SAT technique allows formulation hypothetical scenarios (Lynce
& Silva, 2003). idea temporarily assume l hard unit clause execute unit
propagation. yields conflict, know model extending current assignment must
contain l. process iterated literals quiescence. Exhaustive experiments
SAT context indicate expensive probe search (Le Berre, 2001; Lynce
& Silva, 2003), normally done pre-process order reduce initial number
branching points.
easily extend idea Max-SAT. context, besides discovery unit hard
clauses, may used make explicit weighted unit clauses. call soft probing. SAT,
idea temporarily assume l unit clause simulate unit propagation (i.e., execute
SUP()). Then, build resolution tree propagation queue Q. clauses
hard, know l must added assignment. Else, reproduce applying Max m) minimum
SAT resolution weighted clauses derive unit clause (l,
weight among clauses . unit soft clauses upfront makes future executions
improveLB much effective subsequent search. Besides, derive (l, u)
w), generate via unit neighborhood resolution (see Example 5) initial non-trivial lower
(l,
bound min{u, w}. tested soft probing search preprocessing several
benchmarks. observed empirically soft probing preprocessing best option
SAT.

Example 8 Consider formula F = {(x1 x2 , 1) , (x1 x3 , 1) , (x2 x3 , 1) }. assume x1
adding Q execute SUP conflict reached. obtain Q = [xd1 , x2 (), x3 ()]
detect conflicting clause. clauses involved refutation tree , , .
Resolving clauses results {(x1 x2 , 1) , (x1 x2 , 1), (x1 x2 x3 , 1), (x1 x2 x3 , 1)}.
resolution previous resolvent produces (equivalent) formula F 0 = {(x1 , 1), (x1
x2 x3 , 1), (x1 x2 x3 , 1)}.
7.4 Pseudo-boolean Functions
pseudo-boolean optimization problem (PBO) (Barth, 1995; Sheini & Sakallah, 2006; Een &
Sorensson, 2006) form:
minimize nj=1 c j x j
subject nj=1 ai j l j bi , = 1 . . .
x j {0, 1}, l j either x j 1 x j , c j , ai j bi non-negative integers.
INI AX provided PBO instance, translates Max-SAT formula follows: pseudo boolean constraint translated set hard clauses using INI + (Een
& Sorensson, 2006) (the algorithm heuristically decides appropriate translation choosing
among adders, sorters BDDs). objective function translated set soft unit clauses.
summand c j x j becomes new soft unit clause (x j , c j ). translation INI AX
executed usual.
17

fiH ERAS , L ARROSA , & LIVERAS

8. Empirical Results
section present benchmarks solvers used empirical evaluation. Then,
report experiments performed order adjust parameters INI AX AT. Finally,
comparison solvers presented.
8.1 Benchmarks Encodings
good set problems fundamental show effectiveness new solvers.
following, present several problems explain encode Weighted Max-SAT.
8.1.1 AX - K -SAT
k-SAT CNF formula CNF formula clauses size k. generated random
unsatisfiable 2-SAT 3-SAT formulas Cnfgen generator2 solved corresponding
MAX-SAT problem. benchmarks, fixed number variables varied number
clauses, repeated.
8.1.2 AX - CUT
Given graph G = (V, E), cut defined subset vertices U V . size cut
number edges (vi , v j ) vi U v j V U . Max-cut problem consists
finding cut maximum size. encoded Max-SAT associating one variable xi
graph vertex. Value true (respectively, false) indicates vertex vi belongs U (respectively,
V U ). edge (vi , v j ), two soft clauses (xi x j , 1), (xi x j , 1). Given complete
assignment, number violated clauses |E| size cut associated
assignment. experiments considered Max-Cut instances extracted random graphs
60 nodes varying number edges.
8.1.3 AX - ONE
Given satisfiable CNF formula, max-one problem finding model maximum
number variables set true. problem encoded Max-SAT considering
clauses original formula mandatory adding weighted unary clause (xi , 1)
variable formula. Note solving problem much harder solving usual SAT
problem, search cannot stop soon model found. optimal model must
found optimality must proved. considered max-one problem two types
CNF formula: random 3-SAT instances 120 variables (generated Cnfgen), structured
satisfiable instances coming 2002 SAT Competition3 .
8.1.4 INIMUM V ERTEX C OVERING



AX -C LIQUE

Given graph G = (V, E), vertex covering set U V every edge (vi , v j ) either
vi U v j U . size vertex covering |U |. minimum vertex covering problem
consists finding covering minimal size. naturally formulated (weighted) MaxSAT. associate one variable xi graph vertex vi . Value true (respectively, false) indicates
2. A. van Gelder ftp://dimacs.rutgers.edu/pub/challenge/satisfiability/contributed/UCSC/instances
3. http://www.satcompetition.org/2002/

18

fiM INI AX AT:



E FFICIENT W EIGHTED AX -SAT OLVER

vertex vi belongs U (respectively, V U ). binary hard (xi x j , >) edge
(vi , v j ). specifies one two vertices covering
edge connecting them. unary clause (xi , 1) variable xi , order specify
preferred add vertices U . simple way transform minimum vertex
coverings max-cliques vice-versa (Fahle, 2002).
experiments, considered maximum clique instances extracted random graphs
150 nodes varying number edges. considered 66 Max-Clique instances
DIMACS challenge4 .
8.1.5 C OMBINATORIAL AUCTIONS
combinatorial auction defined set goods G set bidders bid indivisible
subsets goods. bid defined subset requested goods Gi G amount
money offered. bid-taker, wants maximize revenue, must decide bids
accepted. Note two bids request good, cannot jointly accepted (Sandholm,
1999). Max-SAT encoding, one variable xi associated bid. unit
clauses (xi , ui ) indicating bid accepted loss profit ui . Besides,
pair i, j conflicting bids, mandatory clause (xi x j , >).
experiments, used CATS generator (K. Leyton-Brown & Shoham, 2000)
allows generate random instances inspired real-world scenarios. particular, generated
instances Regions, Paths Scheduling distributions. number goods fixed
60 increased number bids. increasing number bids, instances become
constrained (namely, conflicting pairs bids) harder solve.
8.1.6 ISCELLANEOUS
considered following sets instances widely used literature:
unsatisfiable instances 2nd DIMACS Implementation Challenge 5 considered
de Givry, Larrosa, Meseguer, Schiex (2003) Li et al. (2005): random 3-SAT instances
(aim dubois), pigeon hole problem (hole) coloring problems (pret). Observe
instances modelled unweighted Max-SAT (i.e. clauses weight 1).
Max-CSP random instances generated using protocol specified Larrosa Schiex
(2003) de Givry, Heras, Larrosa, Zytnicki (2005). distinguish 4 different sets
problems: Dense Loose (DL), Dense Tight (DT), Sparse Loose (SL) Sparse Tight (ST).
Tight instances 20 variables loose instances 40 variables.
set contains 10 instances 3 values 10 instances 4 values per variable.
Planning (Cooper, Cussat-Blanc, de Roquemaurel, & Regnier, 2006) graph coloring 6
structured instances taken Weighted Constraint Satisfaction Problem (WCSP) repository 7 .
4.
5.
6.
7.

ftp://dimacs.rutgers.edu/pub/challenge/graph/benchmarks/clique
http://mat.gsia.cmu.edu/challenge.html
http://mat.gsia.cmu.edu/COLORING02/benchmarks
http://mulcyber.toulouse.inra.fr/plugins/scmcvs/cvsweb.php/benchs/?cvsroot=toolbar

19

fiH ERAS , L ARROSA , & LIVERAS

Problems taken 2006 pseudo-boolean evaluation 8 : logic synthesis, misc (garden),
routing, MPI (Minimum Prime Implicant), MPS (miplib). instances encoded
Max-SAT specified previous section.
Note Max-CSP, Planning graph coloring instances encoded Max-SAT using
direct encoding (Walsh, 2000).
8.2 Alternative Solvers
compare INI AX several optimizers different communities. restricted
comparison freely available solvers. considered following ones:
AXSATZ (Li et al., 2006; Li, Manya, & Planes, 2007). Unweighted Max-SAT solver.
best unweighted Max-SAT solver 2006 Max-SAT Evaluation.
AX -DPLL (Heras & Larrosa, 2006; Larrosa et al., 2007). Weighted Max-SAT solver.
part OOLBAR package. best solver weighted Max-SAT second
best solver unweighted Max-SAT 2006 Max-SAT Evaluation.
OOLBAR (Larrosa, 2002; Larrosa & Schiex, 2003; de Givry et al., 2003, 2005).
state-of-the-art Weighted CSP solver.
P UEBLO 1.5 (Sheini & Sakallah, 2006). pseudo-boolean solver. ranked first
several categories 2005 Pseudo Boolean Evaluation.
INISAT + (Een & Sorensson, 2006). pseudo-boolean solver translates problems SAT solves MiniSat. ranked first several categories 2005
Pseudo Boolean Evaluation.
instances taken pseudo-boolean evaluation given original format
P UEBLO INISAT +. instances translated Max-SAT PBO partitioning
set clauses three sets: H contains mandatory clauses (C, >), W contains nonunary weighted clauses (C, u < >) U contains unary weighted clauses (l, u).
hard clause (C j , >) H pseudo boolean constraint C0j 1, C0j obtained
C j replacing + negated variables x 1 x. non-unary weighted clause
(C j , u j ) W pseudo boolean constraint C0j + r j 1, C0j computed before,
r j new variable that, set 1, trivially satisfies constraint. Finally, objective
function minimize is,



u jr j +



u jl j

(l j ,u j )U

(C j ,u j )W

8.3 Experimental Results
divide experiments two parts. purpose first part evaluate impact
different techniques INI AX set different parameters. Since
techniques effective benchmarks useless even counterproductive others (Brglez, Li, & Stallman, 2002), aimed finding configuration INI AX
8. http://www.cril.univ-artois.fr/PB06/

20

fiM INI AX AT:



E FFICIENT W EIGHTED AX -SAT OLVER

performs reasonably well instances. purpose second part compare AX alternative solvers. Since solvers specifically designed
type problems, expect INI AX outperform them. rather want
show robustness INI AX showing usually close performance
best alternative type problems.
Results presented plots tables. Regarding tables, first column contains name
set problems. second column shows number instances. remaining columns
report performance different solvers. cell contains average cpu time
solver required solve instances. solver could solve instances set,
number inside brackets indicates number solved instances average cpu time
takes account solved instances. cell contains dash, means instance could
solved within time limit. Regarding plots, note legend goes accordance
performance solvers. time limit set 900 seconds instance.
solver, written C++, implemented top INISAT + (Een & Sorensson, 2006).
Executions made 3.2 Ghz Xeon computer Linux. experiments random
instances, samples 30 instances plots report mean cpu time seconds.
8.4 Setting Parameters INI AX
following evaluate order importance following techniques inside INI AX AT: lower bounding, soft probing, branching heuristics, learning backjumping.
Starting basic version guides search Jeroslow branching heuristic
rest techniques deactivated, analyze one one. analysis studies one technique
incorporates previously analyzed ones corresponding tuned parameters.
three first experiments consider little challenging instances generated randomly
lower bounding plays fundamental role solve them. Finally, consider structured instances
learning backjumping required solve them.
8.4.1 L OWER

BOUNDING

experiment analyze impact resolution-based lower bounding versus substractionbased lower bounding, well combined strategies. considered following combination
two techniques: SUP detects inconsistency refutation tree computed,
look resolvent maximum size. size less equal parameter K,
resolution-based lower bounding applied, otherwise substraction-based lower bounding
applied. tested K = {0, 1, 2, 3, 4, 5, }. Note K = 0 corresponds pure substraction-based
lower bounding (and therefore similar approach Li et al., 2005), K = corresponds
pure resolution-based lower bounding.
results presented Figure 3. seen, pure substraction-based lower bounding K = 0 always worst option. Better results obtained K increases. However,
improvement stops (or nearly stops) K = 3. K > 3 significant improvement noticed. plot omits K = 4 K = 5 case clarity reasons. Since higher values K may
produce new clauses higher size may cause overhead instances, set K = 3
rest experiments.
21

fiH ERAS , L ARROSA , & LIVERAS

(a) Max-2-SAT, 100 variables

15
10

(b) Max-3-SAT, 60 variables

K=0
K=1
K=2
K=3
K=inf

cpu time

cpu time

20

5
0
200 300 400 500 600 700 800

60
50
40
30
20
10
0

K=0
K=1
K=2
K=inf
K=3

300

number clauses

400

500

600

700

800

number clauses

cpu time

(c) Max-CUT, 60 nodes
14
12
10
8
6
4
2
0
200

K=0
K=1
K=2
K=3
K=inf

250

300

350

400

450

number nodes

Figure 3: Performance INI AX different mixed lower boundings (K = 0, 1, 2, 3, inf).

8.4.2 OFT

PROBING

second experiment, evaluate impact soft probing. preliminary experiments,
observed soft probing time consuming, decided limit soft probing
follows. Initially, assign propagation level 0 variable probe. Then, new literal
propagate assigned propagation level L + 1 literal produces propagation
level L. limited probing propagate literals maximum propagation level M.
finally restricted 2 since gives best results. Note propagation level
decision level.
compare three alternatives: probing node search (S), probing pre-process
search (P) probing (N). results, Figure 4, indicates probing
search worst option Max-2-SAT Max-3-SAT produces improvement
Max-CUT. Finally, probing preprocessing gives slightly improvement Max-2-SAT
best results Max-CUT. Note soft probing preprocessing Max-3-SAT effect
omitted plot (its results similar N). Given results, decided include
soft probing preprocessing.
8.4.3 J EROSLOW

BRANCHING HEURISTIC

following experiment, evaluate importance weighted Jeroslow heuristic. Figure
5 shows time difference INI AX Jeroslow heuristic previous
two experiments (Jeroslow) without heuristic (None). results indicates guiding search
Jeroslow heuristic gives important speed ups. Hence, maintain Jeroslow heuristic
INI AX AT.
22

fiM INI AX AT:



E FFICIENT W EIGHTED AX -SAT OLVER

(a) Max-2-SAT, 100 variables

cpu time

20
15

(b) Max-3-SAT, 60 variables


N
P

cpu time

25

10
5
0
200 300 400 500 600 700 800

70
60
50
40
30
20
10
0


N

300

number clauses

400

500

600

700

800

number clauses
(c) Max-CUT, 60 nodes

5

cpu time

4

N

P

3
2
1
0
300

350
400
450
number nodes

500

Figure 4: Performance INI AX without soft probing, probing preprocessing (P)
probing search (S).

8.4.4 L EARNING ,

BACKJUMPING

VSIDS

final experiment, evaluate importance learning backjumping. experiments use structured instances, since well known learning backjumping
useful type problems. Besides, evaluate importance VSIDS heuristic
combination learning backjumping. Recall heuristic specially designed
work cooperation learning, meaningless analyze effect itself.
Table 6 reports results experiment. third column reports results without learning
backjumping lower bounding, probing Jeroslow heuristic (None).
fourth column reports results adding learning backjumping previous version (Learning).
fifth column reports results adding learning, backjumping changing Jeroslow heuristic
VSIDS heuristic (VSIDS). results show INI AX without learning backjumping (None) clearly worst option. Significant improvements obtained learning
backjumping (Learning) added. Finally, adding VSIDS heuristic (VSIDS) improve results specially routing instances. Based results, incorporated learning
backjumping INI AX AT.
Regarding branching heuristic, problems literals appear hard clauses
polarities applies VSIDS heuristic, otherwise Jeroslow heuristic computed
root search tree stated Section 7. choice done starting
search.
23

fiH ERAS , L ARROSA , & LIVERAS

(a) Max-2-SAT, 100 variables

15

(b) Max-3-SAT, 60 variables
100

None
Jeroslow

None
Jeroslow

80
cpu time

cpu time

20

10
5

60
40
20

0
200 300 400 500 600 700 800

0
300

number clauses

400

500

600

700

800

number clauses
(c) Max-CUT, 60 nodes

5
cpu time

4

None
Jeroslow

3
2
1
0
200 250 300 350 400 450 500
number nodes

Figure 5: Performance INI AX without Heuristic (None) Jeroslow heuristic
computed root node search tree (Jeroslow).

Problem
Max-One 3col
Max-One cnt
Max-One dp
Max-One ezfact32
Routing S3
Routing S4

n. inst.
40
3
6
10
5
10

None

13.57(1)
16.11(4)
654.94(2)
22.26(4)


Learning
29.06
119.53
40.03
0.70
1.02
410.61(2)

VSIDS
15.41
6.58
28.63
0.77
0.10
91.09(9)

Figure 6: Structured instances.
8.5 Comparison Boolean Optimizers
reporting results, omit solver cannot deal corresponding instances
technical reasons (e.g. cannot deal weighted clauses) performs extremely bad
comparison others.
Figure 7 contains plots results different benchmarks. Plots b reports results
random unweighted Max-SAT instances. P UEBLO INISAT + orders magnitude slower,
included graphics. Max-2-SAT (plot a), INI AX lays
AX -DPLL AXSATZ, best option. Max-3-SAT (plot b) INI AX
clearly outperforms AX -DPLL close AXSATZ, best.
Max-2-SAT Max-3-SAT AXSATZ 3 times faster INI AX AT.
24

fiM INI AX AT:



E FFICIENT W EIGHTED AX -SAT OLVER

Plot c reports results random Max-CUT instances. INI AX performs slightly better
AXSATZ, second alternative.
random Max-One (plot d) INI AX best solver far. Almost instances
solved instantly P UEBLO AX -DPLL require 10 seconds difficult instances. INISAT + performs poorly. results structured Max-One instances reported
Figure 9. INISAT + seems fastest general. INI AX close performance
P UEBLO. Note, however, p instances, INI AX system solving
instances.
Plot e reports results Random Max-Clique instances. INI AX best solver,
order magnitude faster AX -DPLL, second best option. P UEBLO INISAT +
perform poorly again. Regarding structured Dimacs instances, INI AX best
option. solves 36 instances within time limit, AX -DPLL,M INISAT + P UEBLO
solve 34, 22 18 respectively.
Plots f , g h present results Combinatorial Auctions following different distributions.
paths distribution, INI AX best solver, twice faster AX -DPLL,
ranks second. regions distribution, INI AX best solver AX -DPLL
second best solver requiring double time. paths regions distributions, P UEBLO
INISAT + perform poorly. scheduling distribution, INISAT + best solver
INI AX AX -DPLL one order magnitude slower.
Results regarding unsatisfiable DIMACS instances presented Figure 8. Note
instances optimum cost 1. Hence, soon INI AX find solution cost 1,
clauses declared hard learning backjumping applied hard conflicts
arise. results indicate AXSATZ AX -DPLL solve instance sets
(Pret150 Aim200), INI AX solves sets instances best times
them, except hole instances AXSATZ slightly faster. encode
problems advantageous way P UEBLO INISAT +, is, decision problems
rather optimization problems solve instances similar times INI AX AT.
planning instances (Fig. 10) P UEBLO best solver. INI AX second best
solver, OOLBAR third last one INISAT +. surprising since OOLBAR
perform learning hard constraints. Results regarding graph coloring instances
presented Fig. 10. observed, INI AX able solve one instance
OOLBAR, P UEBLO INISAT + solve many less instances. Max-CSP problems
(Fig. 10) OOLBAR solves instances instantly P UEBLO worst option unable
solve lot instances. INI AX clearly second best solver INI + third
best performing solver. Note solve instances.
Results regarding instances taken pseudo-boolean evaluation found Figure
11. Note first time Max-SAT solver tested pseudo-boolean instances.
Results indicate solver consistently outperforms INI AX fairly
competitive P UEBLO INISAT +.
results conclude INI AX robust Weighted MaxSAT solver. competitive pure optimization problems problems lots
hard clauses and, sometimes, best option.
final remark, note INI AX almost previous benchmarks submitted Second Max-SAT Evaluation 2007, co-located event Tenth International Conference Theory Applications Satisfiability Testing. Hence, interested reader find
25

fiH ERAS , L ARROSA , & LIVERAS

(a) Max-2-SAT, 100 variables
50
30

cpu time

Max-DPLL
MiniMaxSat
Maxsatz

40
cpu time

(b) Max-3-SAT, 60 variables

20
10
0
200 300 400 500 600 700 800 900

300
250
200
150
100
50
0

Max-DPLL
MiniMaxSat
Maxsatz

300 400 500 600 700 800 900

number clauses

number clauses

(c) Max-CUT, 60 nodes

8

cpu time

Max-DPLL
Maxsatz
MiniMaxSat

10
cpu time

(d) Max-ONE, random 3-SAT, 120 variables

6
4
2
0
300

350

400

450

500

30
Minisat+
25
Pueblo
Max-DPLL
20
MiniMaxSat
15
10
5
0
150 200 250 300 350 400 450 500 550

number edges

number hard clauses

(e) Max-Clique, 150 nodes
50

Minisat+
Pueblo
Max-DPLL
MiniMaxSat

30

Pueblo
Minisat+
Max-DPLL
MiniMaxSat

80
cpu time

40
cpu time

(f) C. Auctions PATHS, 60 Goods
100

20
10

60
40
20

0

0
0

25

50

75

100

70 80 90 100 110 120 130 140 150

connectivity (%)

number bids

(g) C. Auctions SCHEDULING, 60 Goods

cpu time

40
30

(h) C. Auctions REGIONS, 60 Goods
20

Pueblo
Max-DPLL
MiniMaxSat
Minisat+

cpu time

50

20

15
10

Minisat+
Pueblo
Max-DPLL
MiniMaxSat

5

10
0

0
100

70 80 90 100 110 120 130 140 150
number bids

120

140

160

180

200

number bids

Figure 7: Plots different benchmarks. Note order legend goes accordance
performance solvers.

exhaustive comparison, including instances solvers, Second Max-SAT Evaluation 2007 web page9 . results evaluation showed INI AX best
performing solver two four existing categories.
9. http://www.maxsat07.udl.es/

26

fiM INI AX AT:



n. inst.
13
4
4
5
8
8
8

Problem
Dubois
Pret60
Pret150
Hole
Aim50
Aim100
Aim200

E FFICIENT W EIGHTED AX -SAT OLVER

INI AX
0.02
0.07
0.01
8.68
0.00
0.00
0.00

AXSATZ
148.18(7)
10.06

8.34
0.01
9.55


AX -DPLL
174.33(6)
22.00

28.00
0.00
172.00


Figure 8: Unsatisfiable DIMACS instances.

Problem
3col80
3col100
3col120
3col140
cnt
dp
ezfact32

n. inst.
10
10
10
10
3
6
10

INI AX
0.15
2.25
20.49
38.33
6.59
28.81
0.77

P UEBLO
0.10
1.73
14.52
83.17
0.13
1.19(3)
0.34

INISAT +
0.02
0.12
0.74
1.61
0.12
1.21(4)
0.33

Figure 9: Structured Max-one instances.

Problem
Planning
Graph Coloring
Max-CSP DL
Max-CSP DT
Max-CSP SL
Max-CSP ST

n. inst.
71
22
20
20
20
20

Toolbar
4.02
49.29(16)
0.08
0.00
0.01
0.00

INI AX
3.81
4.16(17)
0.20
0.01
0.03
0.01

P UEBLO
0.16
68.50(11)
349.08(13)

123.67


INISAT +
7.40
0.57(11)
8.60
2.40
0.48
1.29

Figure 10: Results WCSP Max-CSP instances.

9. Related Work
previous work done incorporating SAT-techniques inside Max-SAT solver.
Alsinet et al. (2005) presented lazy data structure detect clauses become unit, requires static branching heuristic. Argelich Manya (2006a) test different versions branch
bound procedure. One versions uses two-watched literals, uses basic
lower bounding. conclude none previous approaches general use
two-watched literals. far know, rest Max-SAT solvers based adjacency
lists. Therefore, presumably inefficient unit propagation (Lynce & Silva, 2005), par27

fiH ERAS , L ARROSA , & LIVERAS

Problem
misc
Logic synthesis
MPI
MPS
Routing

n. inst.
7
17
148
16
15

INI AX
3.08(5)
82.55(2)
37.35(107)
22.65(5)
58.74(14)

P UEBLO
8.51(5)
36.21(5)
32.04(101)
36.90(8)
5.96

INISAT +
0.14(5)
253.93(5)
3.06(105)
8.50(8)
13.09

Figure 11: Results pseudo-boolean instances.
ticularly presence long clauses. Argelich Manya (2006b) enhance Max-SAT branch
bound procedure learning hard constraints, used combination simple lower bounding techniques. improved version presented Argelich Manya (2007)
powerful lower bound, incorporate two-watched literal scheme,
backjumping, etc. best knowledge, Max-SAT solver incorporates backjumping.
Note INI AX restricts backjumping occurrence hard conflicts. Related works
integration backjumping techniques branch bound include work Zivan
Meisels (2007) Weighted CSP, Manquinho Silva (2004) pseudo-boolean optimization,
Nieuwenhuis Oliveras (2006) SAT Modulo Theories.
Max-SAT solvers use variations call substraction-based lower bounding.
cases, search special patterns mutually inconsistent subsets clauses (Shen &
Zhang, 2004; Xing & Zhang, 2005; Alsinet et al., 2005). efficiency reasons, patterns
always restricted small sets small arity clauses (2 3 clauses arity less 3). INI AX uses natural weighted extension approach proposed Li et al. (2005).
first one able detect inconsistencies arbitrarily large sets arbitrarily large clauses.
idea call resolution-based lower bounding inspired WCSP domain
(Larrosa, 2002; Larrosa & Schiex, 2003; de Givry et al., 2003, 2005) first proposed
Max-SAT context Larrosa Heras (2005) developed Li et al. (2007), Heras
Larrosa (2006), Larrosa et al. (2007). works, special patterns fixed-size
resolution trees executed. use simulated unit propagation allows INI AX
identify arbitrarily large resolution trees. following example, present two inconsistent
subsets clauses detected INI AX transformed equivalent formula
previous solvers cannot transform since limited specific patterns:
{(x1 , w1 ), (x2 , w2 ), (x3 , w3 ), (x1 x2 x3 , w4 )}
{(x1 , w1 ), (x1 x2 , w2 ), (x1 x2 x3 , w3 ), (x1 x2 x3 x4 , w4 ), (x1 x2 x3 x4 , w5 )}
first case, INI AX replaces clauses (2, m) = min{w1 , w2 , w3 , w4 }
set compensation clauses. second case, INI AX replaces (2, m)
= min{w1 , w2 , w3 , w4 , w5 } set compensation clauses. cases, equivalence
preserved. However, solvers literature detect inconsistent subset clauses
cannot transform problem equivalent one (Li et al., 2007) simply cannot detect
(Heras & Larrosa, 2006).
probing method derive weighted unit clauses related 2 RES cycle rule
Heras Larrosa (2006) Larrosa et al. (2007), failed literals Li et al. (2006),
28

fiM INI AX AT:



E FFICIENT W EIGHTED AX -SAT OLVER

singleton consistency CSP (Debruyne & Bessiere, 1999). Again, use simulated unit
propagation allows INI AX identify arbitrarily large resolution trees.

10. Conclusions Future Work
INI AX efficient robust Max-SAT solver deal hard soft
clauses well pseudo-boolean functions. incorporates best available techniques
type problems, performance similar best specialized solver. Besides development INI AX combining, first time, known techniques different fields,
main original contribution paper novel lower bounding technique based resolution.
INI AX lower bounding combines clean elegant way approaches proposed last years, mainly based unit-propagation-based lower
bounding resolution-based problem transformation. paper use information provided propagation queue (i) determine subset inconsistent clauses (ii) determine
simple ordering resolution applied increase lower bound generate
equivalent formula. However, necessarily best ordering so. easy see
different orderings may generate resolvents compensation clauses different arities. one
selects ordering generates smallest resolvents compensation clauses resulting
formula may presumably simpler. Future work concerns study orderings, development VSIDS-like heuristics soft clauses backjumping techniques soft conflicts.

Acknowledgments
would thank Niklas Een Niklas Sorensson making INISAT + code publicly
available. grateful anonymous referees helpful suggestions improving
paper.
work partially supported Spanish Ministry Education Science
projects TIN2006-15387-C03-02 (Heras Larrosa) TIN2004-03382 (Oliveras).

References
Alsinet, T., Manya, F., & Planes, J. (2005). Improved Exact Solvers Weighted Max-SAT.
Proceedings SAT05, Vol. 3569 LNCS, pp. 371377. Springer.
Argelich, J., & Manya, F. (2006a). Exact Max-SAT solvers over-constrained problems. J.
Heuristics, 12(4-5), 375392.
Argelich, J., & Manya, F. (2006b). Learning Hard Constraints Max-SAT. Proceedings
CSCLP06, Vol. 4651 LNCS, pp. 112. Springer.
Argelich, J., & Manya, F. (2007). Partial Max-SAT Solvers Clause Learning. Proceedings
SAT07, Vol. 4501 LNCS, pp. 2840. Springer.
Barth, P. (1995). Davis-Putnam Based Enumeration Algorithm Linear pseudo-Boolean Optimization. Research report MPI-I-95-2-003, Max-Planck-Institut fur Informatik, Im Stadtwald, D-66123 Saarbrucken, Germany.
Brglez, F., Li, X., & Stallman, M. (2002). role skeptic agent testing benchmarking
SAT algorithms. Proceedings SAT02, pp. 354361.
29

fiH ERAS , L ARROSA , & LIVERAS

Buro, M., & Buning, H. K. (1993). Report SAT Competition. Bulletin European
Association Theoretical Computer Science, 49, 143151.
Cha, B., Iwama, K., Kambayashi, Y., & Miyazaki, S. (1997). Local search algorithms partial
MAXSAT. Proceedings AAAI97, pp. 263268. MIT Press.
Cooper, M., Cussat-Blanc, S., de Roquemaurel, M., & Regnier, P. (2006). Soft Arc Consistency
Applied Optimal Planning. Proceedings CP06, Vol. 4204 LNCS, pp. 680684.
Springer.
Davis, M., Logemann, G., & Loveland, G. (1962). machine program theorem proving. Communications ACM, 5, 394397.
de Givry, S., Heras, F., Larrosa, J., & Zytnicki, M. (2005). Existential arc consistency: getting
closer full arc consistency weighted CSPs. Proceedings 19th IJCAI, pp. 8489.
Professional Book Center.
de Givry, S., Larrosa, J., Meseguer, P., & Schiex, T. (2003). Solving Max-SAT weighted CSP.
Proceedings CP03, Vol. 2833 LNCS, pp. 363376. Springer.
Debruyne, R., & Bessiere, C. (1999). practicable filtering techniques constraint satisfaction problem. Proceedings ICJAI97, pp. 412417. Morgan Kaufmann.
Een, N., & Sorensson, N. (2003). Extensible SAT-solver. Proceedings SAT03, Vol. 2919
LNCS, pp. 502518. Springer.
Een, N., & Sorensson, N. (2006). Translating Pseudo-Boolean Constraints SAT. Journal
Satisfiability, Boolean Modeling Computation, 2, 126.
Fahle, T. (2002). Simple fast: Improving branch-and-bound algorithm maximum clique.
Proceedings ESA02, Vol. 2461 LNCS, pp. 485498. Springer.
Freeman, J. W. (1995). Improvements Propositional Satisfiability Search Algorithms. Ph.D.
thesis, University Pennsylvania.
Fu, Z., & Malik, S. (2006). Solving Partial MAX-SAT Problem. Proceedings SAT06,
Vol. 4121 LNCS, pp. 252265. Springer.
Heras, F., & Larrosa, J. (2006). New Inference Rules Efficient Max-SAT Solving. Proceedings
21th AAAI. AAAI Press.
Jeroslow, R. G., & Wang, J. (1990). Solving propositional satisfiability problems. Annals Mathematics Artificial Intelligence, 1, 167187.
K. Leyton-Brown, M. P., & Shoham, Y. (2000). Towards universal test suite combinatorial
auction algorithms. Proceedings ACM Conference Electronic Commerce00, pp.
6676.
Karloff, H. J., & Zwick, U. (1997). 7/8-Approximation Algorithm MAX 3SAT?. FOCS,
pp. 406415.
Larrosa, J., & Heras, F. (2005). Resolution Max-SAT relation local consistency
weighted CSPs. Proceedings IJCAI05, pp. 193198. Professional Book Center.
Larrosa, J., Heras, F., & de Givry, S. (2007). logical approach efficient max-sat solving.
Artificial Intelligence. appear.
30

fiM INI AX AT:



E FFICIENT W EIGHTED AX -SAT OLVER

Larrosa, J., & Schiex, T. (2003). quest best form local consistency weighted
CSP. Proceedings 18th IJCAI, pp. 239244.
Larrosa, J. (2002). Node Arc Consistency Weighted CSP. Proceedings AAAI02, pp.
4853. AAAI Press.
Le Berre, D. (2001). Exploiting real power Unit Propagation Lookahead. Proceedings
LICS Workshop Theory Applications Satisfiability Testing.
Le Berre, D. (2006). SAT4j project Max-SAT.. http://www.sat4j.org/.
Li, C., Manya, F., & Planes, J. (2005). Exploiting Unit Propagation Compute Lower Bounds
Branch Bound Max-SAT Solvers. Proceedings CP05, Vol. 3709 LNCS, pp.
403414.
Li, C., Manya, F., & Planes, J. (2007). New Inference Rules Max-SAT. Journal Artificial
Intelligence Research. appear.
Li, C.-M., Manya, F., & Planes, J. (2006). Detecting Disjoint Inconsistent Subformulas Computing Lower Bounds Max-SAT. Proceedings 21th AAAI. AAAI Press.
Lynce, I., & Silva, J. P. M. (2003). Probing-Based Preprocessing Techniques Propositional
Satisfiability. Proceedings ICTAI03, pp. 105111. IEEE Computer Society.
Lynce, I., & Silva, J. P. M. (2005). Efficient data structures backtrack search SAT solvers. Ann.
Math. Artif. Intell., 43(1), 137152.
Manquinho, V. M., & Silva, J. P. M. (2004). Satisfiability-Based Algorithms Boolean Optimization. Ann. Math. Artif. Intell., 40(3-4), 353372.
Moskewicz, M. W., Madigan, C. F., Zhao, Y., Zhang, L., & Malik, S. (2001). Chaff: Engineering
Efficient SAT Solver. Proceedings DAC01, pp. 530535. ACM.
Nieuwenhuis, R., & Oliveras, A. (2006). SAT Modulo Theories Optimization Problems.
Proceedings SAT06, Vol. 4121 LNCS, pp. 156169. Springer.
Papadimitriou, C. (1994). Computational Complexity. Addison-Wesley, USA.
Sandholm, T. (1999). Algorithm Optimal Winner Determination Combinatorial Auctions.
Proceedings IJCAI99, pp. 542547. Morgan Kaufmann.
Sheini, H. M., & Sakallah, K. A. (2006). Pueblo: Hybrid Pseudo-Boolean SAT Solver. Journal
Satisfiability, Boolean Modeling Computation, 2, 165189.
Shen, H., & Zhang, H. (2004). Study lower bounds Max-2-SAT. Proceedings AAAI04,
pp. 185190. AAAI Press / MIT Press.
Silva, J. P. M., & Sakallah, K. A. (1996). GRASP - new search algorithm satisfiability.
ICCAD, pp. 220227.
Smyth, K., Hoos, H. H., & Stutzle, T. (2003). Iterated Robust Tabu Search MAX-SAT.
Proceedings AI03, Vol. 2671 LNCS, pp. 129144. Springer.
Tompkins, D. A. D., & Hoos, H. H. (2004). UBCSAT: Implementation Experimentation
Environment SLS Algorithms SAT & MAX-SAT. Proceedings SAT04, Vol.
3542 LNCS, pp. 306320. Springer.
Walsh, T. (2000). SAT v CSP. Proceedings CP00, Vol. 1894 LNCS, pp. 441456. Springer.
31

fiH ERAS , L ARROSA , & LIVERAS

Xing, Z., & Zhang, W. (2005). MaxSolver: efficient exact algorithm (weighted) maximum
satisfiability. Artificial Intelligence, 164(1-2), 4780.
Zhang, L., Madigan, C. F., Moskewicz, M. W., & Malik, S. (2001). Efficient Conflict Driven Learning Boolean Satisfiability Solver. Proceedings ICCAD01, pp. 279285.
Zivan, R., & Meisels, A. (2007). Conflict directed Backjumping MaxCSPs. Proceedings
IJCAI07, pp. 198204.

32


