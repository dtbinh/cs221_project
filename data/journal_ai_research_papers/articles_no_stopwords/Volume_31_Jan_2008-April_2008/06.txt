Journal Artificial Intelligence Research 31 (2008) 497-542

Submitted 08/07; published 03/08

Exploiting Subgraph Structure
Multi-Robot Path Planning
Malcolm R. K. Ryan

malcolmr@cse.unsw.edu.au

ARC Centre Excellence Autonomous Systems
University New South Wales, Australia

Abstract
Multi-robot path planning difficult due combinatorial explosion search
space every new robot added. Complete search combined state-space soon
becomes intractable. paper present novel form abstraction allows
us plan much efficiently. key abstraction partitioning
map subgraphs known structure entry exit restrictions
represent compactly. Planning becomes search much smaller space subgraph
configurations. abstract plan found, quickly resolved correct
(but possibly sub-optimal) concrete plan without need search. prove
technique sound complete demonstrate practical effectiveness
real map.
contending solution, prioritised planning, evaluated shown similar
performance albeit cost completeness. two approaches necessarily
conflicting; demonstrate combined single algorithm outperforms either approach alone.

1. Introduction
many scenarios require large groups robots navigate around shared
environment. Examples include: delivery robots office (Hada & Takase, 2001),
warehouse (Everett, Gage, Gilbreth, Laird, & Smurlo, 1994), shipping yard (Alami, Fleury,
Herrb, Ingrand, & Robert, 1998), mine (Alarie & Gamache, 2002); even virtual
armies computer wargame (Buro & Furtak, 2004). case many robots
independent goals must traverse shared environment without colliding
one another. planning path single robot usually consider
rest world static, world represented graph called
road-map. path-planning problem amounts finding path road-map,
reasonably efficient algorithms exist. However, multi-robot scenario world
static. must avoid collisions obstacles, robots.
Centralised methods (Barraquand & Latombe, 1991), treat robots single composite entity, scale poorly number robots increases. Decoupled methods
(LaValle & Hutchinson, 1998; Erdmann & Lozano-Perez, 1986), first plan
robot independently resolve conflicts afterwards, prove much faster incomplete many problems require robots deliberately detour optimal
path order let another robot pass. Even priority ordering used (van den Berg
& Overmars, 2005), requiring low priority robots plan avoid high-priority robots,
problems found cannot solved priority ordering.

c
2008
AI Access Foundation. rights reserved.

fiRyan

realistic maps common structures roads, corridors open spaces
produce particular topological features map constrain possible interactions robots. long narrow corridor, instance, may impossible one robot
overtake another robots must enter exit first-in/first-out order.
hand, large open space may permit many robots pass simultaneously
without collision.
characterise features particular kinds subgraphs occurring
road-map. decompose map collection simple subgraphs,
build plans hierarchically, first planning movements one subgraph another,
using special-purpose planners build paths within subgraph.
paper propose abstraction. limit considering
homogeneous group robots navigating using shared road-map. identify particular
kinds subgraphs road-map place known constraints ordering robots
pass them. use constraints make efficient planning algorithms
traversing kind subgraph, combine local planners hierarchical
planner solving arbitrary problems.
abstraction used implement centralised prioritised planners,
demonstrate paper. Unlike heuristic abstractions, method
sound complete. is, used centralised search guaranteed find
correct plan one exists. guarantee cannot made prioritised search
used, however two-stage planning process means prioritised planner
abstraction often find plans would available otherwise. Experimental
investigation shows approach effective maps sparsely connected
graph representations.

2. Problem Formulation
assume work provided road-map form graph
G = (V, E) representing connectivity free space single robot moving around
world (e.g. vertical cell decomposition visibility graph, LaValle, 2006).
set robots R = {r1 , . . . , rk } shall consider homogeneous, single map
suffices all. shall assume starting locations goals lie road-map.
Further, shall assume map constructed collisions occur
one robot entering vertex v time another robot occupying, entering
leaving vertex. Robots occupying vertices map affect movement.
appropriate levels underlying control assumptions satisfied
real-world problems.
simple centralised approach computing plan proceeds follows: First, initialise
every robot starting position, select robot move neighbouring vertex,
checking first robot currently occupying vertex. Continue fashion, selecting moving one robots step goal. Pseudocode
process shown Algorithm 1. code presented non-deterministic algorithm, choice points indicated choose operator, backtracking required
fail command encountered. practice, search algorithm depth-first,
breadth-first A* search necessary evaluate alternative paths presents.

498

fiExploiting Subgraph Structure Multi-Robot Path Planning

Algorithm 1 simple centralised planning algorithm.
1: function Plan(G, a, b)
2:
= b
3:
return hi
4:
end
5:
choose r R
6:
select vf : a[vf ] = r
7:
choose vt {v | (vf , v) G}
8:
a[vt ] 6= 2
9:
fail
10:
else
11:
a[vf ] 2
12:
a[vt ] r
13:
return (r, vf , vt ).Plan(G, a, b)
14:
end
15: end function

. Build plan b graph G.
. Nothing do.
. Choose robot.
. Find location.
. Choose edge.
. destination occupied; backtrack.
. Move robot vf vt .
. Recurse.

algorithm complete search composite space Gk = G G G,
k = |R| robots. eliminating vertices represent collisions robots,
size composite graph given by:




fiV (Gk )fi = n Pk
=

n!
(n k)!




k
fiE(G )fi = k |E(G)| (n2) P(k1)
= k |E(G)|

(n 2)!
(n k 1)!

n = |V (G)| k = |R|. running time algorithm depend
search algorithm used, expected long moderately large values
n k.

3. Subgraph Abstraction
Consider problem shown Figure 1. road-map contains 18 vertices 17 edges,
3 robots plan for. So, according formulae, composite
graph 18!/15! = 4896 vertices 3 17 16!/14! = 12240 edges. small map
expanded large search problem. human mind obvious lot
arrangements equivalent. important exact positions robots,
ordering.
Consider subgraph labeled X. recognise subgraph stack. is, robots
move subgraph last-in-first-out (LIFO) order. Robots inside
stack cannot change order without exiting re-entering stack.
goal reverse order robots X, know immediately cannot done
without moving robots stack re-enter opposite
order. robots right order, rearranging right positions
499

fiRyan

y1

x1

x2


x3

x4

x5

y2

y3

y4

y5

y6



z2

z3

z4

z5

z6

Z

x6

c

b

X

z1

Figure 1: planning problem illustrating use subgraphs.
trivial. Thus make distinction arrangement robots (in
specify exactly vertex robot occupies) configuration stack (in
interested order).
X 6 vertices, robots stack, 6 Pm =
6!/(6 m)! possible arrangements. total number arrangements is:
6

P3 + 3 6 P2 + 3 6 P1 + 6 P0 = 120 + 3 30 + 3 6 + 1
= 229

terms deciding whether robot leave stack, however, need know
order. need represent 3! + 3 2! + 3 1! + 1 = 16 different configurations
stack.
Subgraphs Z stacks. Applying analysis three, find
represent abstract state space 60 different states, 144 possible
transitions states (moving top-most robot one stack onto another).
dramatically smaller composite map space above.
stack simple kind subgraph need larger collection canonical
subgraphs represent realistic problems. key features looking follows:
1. Computing transitions subgraph require knowledge exact arrangement robots within subgraph, abstract configuration
(in case, order).
2. two arrangements robots share configuration, transforming one
done easily without search,
3. Therefore planning need done configuration space, significantly
smaller.
Later introduce three subgraph types cliques, halls rings
share properties readily found realistic planning problems. first
need formalise ideas subgraph planning.

500

fiExploiting Subgraph Structure Multi-Robot Path Planning

4. Definitions
section outline concepts use later paper. complete formal
definition terms provided Appendix, along proof soundness
completeness subgraph planning process.
Given map represented graph G partition set disjoint subgraphs
S1 , . . . , Sm . subgraphs induced, i.e. edge exists two vertices
subgraph exists G.
arrangement robots G 1-to-1 partial function : V (G) R,
represents locations robots within G. robot r vertex v, write a(v) = r.
speak arrangement robots within subgraph S. denote
arrangements lowercase roman letters a, b
configuration subgraph set equivalent arrangements robots within S.
Two arrangements equivalent exists plan move robots one
without robots leaving subgraph. denote configuration subgraph Sx
cx . configuration whole map represented tuple subgraph
configurations = (c1 , . . . , cm ).
two operators operate configurations, representing robot
entering leaving subgraph respectively. robot r moves two subgraphs Sx Sy configurations change depending identity edge (u, v)
robot traveled. write:
c0x cx (r, u),
c0y cy (r, v)
complex subgraphs possible transition result several possible configurations, operators return sets. possible transition
impossible particular configuration, case operation returns empty
set.
abstract plan defined sequence transitions intermediate
configurations . every abstract plan two arrangements exists least one
corresponding concrete plan, vice versa. subgraph transitions concrete
plan must exist abstract plan. equivalence arrangements configuration
guarantees existence intermediate steps. See Appendix complete
proof.

5. Subgraph Planning
construct planning algorithm searches space abstract plans (Algorithm 2). procedure much before. First compute configuration
tuple initial arrangement. extend plan one step time. step
consists selecting robot r moving subgraph currently occupies Sx
neighbouring subgraph Sy reduced graph X, along connecting edge (u, v).
transition possible plan-step (s, (u, v)) applicable. is, may
result number different configurations subgraph entered. need choose
one create configuration tuple next step. applicability test
selection subsequent configurations performed lines 10-11 AbstractPlan.
501

fiRyan

abstract plan extended step step fashion reaches configuration
tuple matches goal arrangement. resulting abstract plan resolved
concrete plan. transition abstract plan build two short concrete plans
one move robot outgoing vertex transition, one make sure
incoming vertex clear subgraph appropriately arranged create subsequent
configuration. Since two plans separate subgraphs, combined
parallel. final step rearrange robots goal arrangement. Again,
done parallel subgraphs.
AbstractPlan written non-deterministic program, including choicepoints. search algorithm breadth-first depth-first search needed examine
possible set choices ordered fashion. search complete
abstract plan guaranteed found, one exists theorem
planning algorithm sound complete. Note resolution phase
planner entirely deterministic, search needed abstract plan
found.
5.1 Subgraph Methods
efficiency algorithm relies able compute several functions without
lot search:
Exit compute c (r, u), testing possible robot exit subgraph
determining resulting configuration(s).
Enter compute c (r, v), testing possible robot enter subgraph
determining resulting configuration(s).
Terminate compute b/S c, testing possible robots subgraph
move terminating positions.
ResolveExit build plan rearranging robots subgraph allow one exit.
ResolveEnter build plan rearranging robots subgraph allow one
enter.
ResolveTerminate build plan rearranging robots subgraph
terminating positions.
key efficient subgraph planning carefully constrain allowed structure
subgraphs partition, functions simple implement
require expensive search. advantage approach functions
always computed based arrangement robots within particular
subgraph, relying positions robots elsewhere.

6. Subgraph Structures
key process therefore selection subgraph types. abstractions
need chosen that:
502

fiExploiting Subgraph Structure Multi-Robot Path Planning

v1

v2

v3

v1

vk

v2

(a) stack

v3

vk

(b) hall

v1

v2

v1

v2

v4

v3

v4

v3

(c) clique

(d) ring

Figure 2: Examples four different subgraph structures.

1. commonly occurring real road-maps,
2. easy detect extract road-map,
3. abstract large portion search space,
4. Computing legality transitions fast, sound complete,
5. Resolving abstract plan concrete sequence movements efficient.
paper present four subgraph types: stacks, halls, cliques rings, satisfy
requirements. following analysis, let n number vertices
subgraph k number robots occupying subgraph action takes
place.
6.1 Stacks
stack (Figure 2(a)) represents narrow dead-end corridor road-map.
one exit narrow robots pass one another, robots must enter leave
last-in-first-out order. one simplest subgraphs occur often
real maps, serves easy illustration subgraph methods. Formally
consists chain vertices, linked predecessor successor.
vertex one end chain, called head, connected subgraphs
entrances exits happen there.
configuration stack corresponds ordering robots reside it,
head down. Robots stack cannot pass other, ordering cannot
changed without robots exiting re-entering stack.

503

fiRyan

6.1.1 Enter
robot always enter stack long stack full. one new configuration created, adding robot front ordering. computation
done O(1) time.
6.1.2 Exit
robot exit stack top robot ordering. one new
configuration created, removing robot ordering. computation
done O(1) time.
6.1.3 Terminate
determine whether termination possible, need check order robots
current configuration terminating arrangement. operation
takes O(k) time.
6.1.4 ResolveEnter
Rearranging robots inside stack simple since know ordering constant.
vacate top stack (the possible entrance point) move robots deeper
stack (as necessary). guaranteed room, since entering full stack
permitted. worst takes O(k) time.
6.1.5 ResolveExit
robot exits stack, abstract planner already determined
first robot stack others head vertex. simply move
stack head, out. robots need moved. worst
takes O(n) time.
6.1.6 ResolveTerminate
Finally, moving robots terminating positions done top-to-bottom order.
robot terminating position move upwards without interference.
robot terminating position, robots may need moved lower
order clear path. approach sound, since terminating positions
robots must stack (or else ordering would different). process
O(nk) total worst-case running time.
6.2 Halls
hall generalisation stack (Figure 2(b)). stack, narrow corridor
permit passing, hall may multiple entrances exits along
length. Formally consists single chain vertices, one joined predecessor
successor. must edges vertices hall, may
edges connecting subgraphs node hall. Halls much
commonly occurring structures, still maintain property stacks: robots

504

fiExploiting Subgraph Structure Multi-Robot Path Planning

j=0
v1

v2

v3

v4

v5


v6
B

C


j=1
v1

v2

v3

v4

v5
B



v6
C


j=2
v1


v2

v3

v4

B

v5

v6

C



Figure 3: Example entering hall subgraph, k = 3, n = 6 = 3. Robot
enter three possible sequence positions j = 0, 1 2 j = 3.

cannot reordered without exiting re-entering. Thus, stacks, configuration
hall corresponds order robots occupying it, one end hall
other.
6.2.1 Enter
robot enter hall long full. configurations generated
entrance depend three factors: 1) size hall n, 2) number robots
already hall k, 3) index vertex enters (ranging 1
n).
Figure 3 shows entering hall result several different configurations.
matter robots already hall arranged, left right
entrance, entering robot moves in. enough space hall either
side entrance vertex, new robot inserted point ordering.
space limited (as example) may possible move robots
one side another, limiting possible insertion points.
Given three variables k, n, above, compute maximum minimum
insertion points as:
j min(i 1, k)
j max(0, k (n i))

505

fiRyan

Creating new configuration matter inserting new robot
ordering appropriate point. Since list robots needs copied order
this, takes O(k) time new configuration.
6.2.2 Exit
Whether robot exit hall via given edge depends several factors: 1)
size hall n, 2) number robots hall k, 3) index vertex
exits (from 1 k), 3) index j robot ordering (from 1 k). Exit
possible if:
j n (k j)
exit possible one resulting configuration: previous ordering robot
removed. takes O(k) time compute.
6.2.3 Terminate
Checking termination halls stacks, test order
robots final arrangement matches current configuration. done
O(k) time k robots hall.
6.2.4 ResolveEnter
resolve entrance hall need know subsequent configurations
aiming generate, know proper insertion point entering robot.
robots insertion point shuffled one direction one side
entry vertex, rest side. worst take O(nk) time.
6.2.5 ResolveExit
Resolving exit involves moving robot hall exit vertex, shuffling
robots way. worst case, robots shuffle
one end hall other, takes O(nk) time.
6.2.6 ResolveTerminate
ResolveTerminate hall identical stack, described above.
6.3 Cliques
clique (Figure 2(c)) represents large open area map many exit points
(vertices) around perimeter. Robots cross directly vertex another,
long clique full, robots inside shuffled way allow
happen.
Formally clique totally connected subgraph. Cliques quite different properties
halls stacks. long least one empty vertex clique, possible
rearrange arbitrarily. configuration clique, circumstance,
set robots contains.

506

fiExploiting Subgraph Structure Multi-Robot Path Planning

However special set configurations clique locked.
occurs number robots clique equals number vertices.
impossible clique rearranged. configuration locked clique
explicitly record position robot.
6.3.1 Enter
clique always entered long full. clique one
vacant vertex, single new configuration entering robot added
set occupants. clique one space remaining, entering robot locks
clique. theory, point necessary make new configuration every
possible arrangement occupying robots (with entering robot always vertex
enters).
practice, efficient create single locked configuration
records locking robot vertex, leaves positions unspecified.
permutation robots possible, exact details configuration need
pinned next action (either Exit Terminate) requires be.
form least commitment, significantly reduce branching factor
search.
Performing test creating new configuration takes O(k) time k robots
clique.
6.3.2 Exit
clique unlocked robot exit vertex new configuration
created simply removing robot set occupants.
clique locked robot exit specific vertex occupies. resulting configuration unlocked exact locations robots
discarded.
least-commitment version, locking robot constrained exit vertex
every robot exit vertex except one occupied locking
robot.
Performing test creating new configuration takes O(k) time k robots
clique.
6.3.3 Terminate
unlocked configuration, checking termination simply consists making sure
(and only) required occupants clique. locked configuration
robots must terminating positions (as possibility rearranging
them). least-commitment version locking robot must terminating vertex. assume robots places (thus
committing choice configuration delayed earlier).
Performing test takes O(k) time k robots clique.

507

fiRyan

6.3.4 ResolveEnter
entrance vertex occupied robot wishes enter simply move
occupant directly another vacant vertex clique, since every vertex connected
every other.
using least commitment entering robot locks clique need
look ahead plan see next action involving clique. exit transition
need move exiting robot exit vertex (before clique locked).
subsequent exit, meaning robots terminating clique,
need rearrange terminating positions point.
amortise cost rearrangements subsequent call ResolveExit
ResolveTerminate treat operation taking O(1) time.
6.3.5 ResolveExit
clique full time exit assume exiting robot already
exit vertex nothing needs done. hand, clique full
may robot exit vertex. must moved there. exit vertex
already occupied another robot, moved another unoccupied vertex.
movements done directly, clique totally connected. operation
takes O(1) time.
6.3.6 ResolveTerminate
clique locked assume robots already appropriately
arranged terminal positions work needs done. Otherwise
robots may need rearranged. simple way proceed follows:
robot place, first vacate terminating position moving occupant
another unoccupied vertex, move terminating robot vertex. robot
moved way move again, process correct
may produce longer plans necessary. upside takes O(n) time.
6.4 Rings
ring (Figure 2(d)) resembles hall ends connected. Formally, subgraph
vertices V (S) = {v1 , . . . , vn } induced edges E(S) satisfying:
(vi , vj ) E(S) iff |i j| 1 (mod n)
hall, ordering important ring. Robots ring cannot pass one another
cannot re-order themselves. can, however, rotate ordering (provided
ring full). Thus ring size 4 more, sequence hr1 , r2 , r3 equivalent
hr3 , r1 , r2 hr2 , r1 , r3 i. Equivalent sequences represent configuration.
cliques, rings locked full. locked ring cannot rotated,
ring size three sequences hr1 , r2 , r3 hr3 , r1 , r2 equivalent.
represent two locked configurations different properties.

508

fiExploiting Subgraph Structure Multi-Robot Path Planning

6.4.1 Enter
robot may always enter ring provided full. k robots already
occupying ring, k possible configurations result (or one k
zero), one possible insertion point.
entering robot locks ring must record specific positions
robot ring. still produce k different configurations
robots cannot arbitrarily rearranged, unlike cliques.
possible produce least-commitment versions Enter rings
cliques. Again, significantly reduce branching factor search,
details involved wish enter paper.
operation takes O(k) time new configuration generated.
6.4.2 Exit
ring locked robot exit recorded position, otherwise
exit vertex. robot removed sequence produce resultant
configuration. new configuration unlocked position information
discarded. done O(k) time k robots ring.
6.4.3 Terminate
check termination possible need see order robots around ring
terminal arrangement matches current configuration. configuration
locked rotations allowed, otherwise match must exact. test
done O(k) time k robots ring.
6.4.4 ResolveEnter
robot enter ring, need first rearrange entry
vertex empty nearest robots either side vertex provide correct
insertion point subsequent configuration, selected Enter above. may
require shuffling robots one way another, much fashion stack
hall. worst case take O(nk) operations k robots ring n vertices.
6.4.5 ResolveExit
ring locked robot exiting must already exit position nothing needs
done. Otherwise, unlocked ring, robots may need shuffled around
ring order move robot exit. worst case take O(nk) operations
k robots ring n vertices.
6.4.6 ResolveTerminate
ring locked robots must already terminating positions;
guaranteed abstract planner. Otherwise need rotated correct
positions. one robot moved correct vertex, rest ring
treated stack ResolveTerminate method described used,
O(nk) worst case running time k robots ring n vertices.
509

fiRyan

6.5 Summary
four subgraphs halls rings powerful. subgraphs
common structured maps man-made environments, found often
purely random graphs (consider: shortest path unweighted graph hall).
Halls, rings cliques significant size found many realistic planning problems.
Importantly, structures well constrained enough six procedures
planning outlined implemented efficiently deterministically, without
need search. cases clique ring, resolution methods
describe sometimes sacrifice path optimality speed, could improved
using smarter resolution planners. Since resolution stage done once, probably
would major effect overall running time planner.

7. Prioritised Planning
common solution rapid growth search spaces multi-robot planning prioritised
planning (Erdmann & Lozano-Perez, 1986; van den Berg & Overmars, 2005).
approach give robots fixed priority ordering begin. Planning performed
priority ordering: first plan built robot highest priority; plan
second highest, interfere first; third,
on. new plan must constructed interfere plans
it. example implementation shown Algorithm 3. Usually backtracking
plan made. signified algorithm cut operator line 8
Plan.
cut, search longer complete. problems solutions
prioritised planner cannot find. Figure 4 example. Robots b wish
change positions. plan either robot easy; plan contains one
step. plan robots together requires move way,
right hand side map pass. prioritised planner
committed one-step plan either b cannot construct plan
robot interfere.
incompleteness mistake, however. core makes prioritised planning efficient. search space pruned significantly eliminating

x1

x2


x3

x4

b


Figure 4: simple planning problem cannot solved naive prioritised planning.
goal swap positions robots b.

510

fiExploiting Subgraph Structure Multi-Robot Path Planning

certain plans consideration. still viable solution within pruned space
(and often is) found much quickly. (hopefully few) cases
fails, always resort complete planner backup.
7.1 Prioritised Subgraph Planning
Prioritised planning strictly competitor subgraph planning. fact, prioritised
search subgraph representation orthogonal ideas, quite possible use
together. Algorithm 3, plan constructed robot consecutively,
rather building entire concrete plan, abstract version produced,
fashion Algorithm 2 earlier. compatible abstract plans produced
every robot, resolved concrete plan.
well adding advantage abstraction prioritised planning, subgraph
representation allows planner cover space possible plans.
delaying resolution end, avoid commitment concrete choices high
priority robot hamper planning later robots.
illustrate this, lets return example Figure 4 above. partition
subgraph vertices {x1 , x2 , x3 , x4 } hall X, prioritised subgraph planner
solve problem. abstract plan highest priority robot empty;
nothing already goal subgraph. Given plan, second highest
priority robot plan move X back again. plan produce
goal configuration required. Resolving plan move highest priority robot
x4 back needed, plan built Resolve methods halls,
search.
course thing free lunch example works choose
right partition. instead treat {x1 , x2 } stack {x4 , x3 , y} separate hall
prioritised subgraph planner help us. Furthermore exist problems,
one Figure 5 solved standard prioritised planners
fail introduce wrong subgraph abstraction. difficult generate realistic

x1

x2

x3



x4
b



Figure 5: simple planning problem solved naive prioritised planning
subgraph abstraction. goal swap positions robots
b. priority ordering a, b subgraph planner choose robot
remain inside hall. Robot b trapped, blocks
exit (note edges (x1 , y) (y, x4 ) directed).

511

fiRyan

cases problem small numbers robots, see Section 9.3 below,
occur number robots large.

8. Search Complexity
Let us consider carefully advantages (if any) subgraph decomposition lie. Subgraph transitions act macro-operators one abstract state (set
configurations) another. long history planners using macros one kind
another, advantages disadvantages well known (see Section10.1).
widely recognised macros advantageous reduce depth search,
become disadvantage many macros created branching factor
search becomes large. guidelines apply use subgraphs.
typical search algorithm proceeds follows: select plan frontier incomplete plans create expansions. Add expansions frontier recurse
complete plan found. time taken complete search determined
number nodes search tree, turn determined three factors:
1. d, depth goal state,
2. b, average branching factor tree, i.e. number nodes generated per
node expanded
3. efficiency search.
perfect search algorithm, heads directly goal, nevertheless contain O(bd)
nodes alternative nodes must still generated, even never followed.
uninformed breadth-first search, hand, generate O(bd ) nodes.
regarded sensible upper bound efficiency search (although possible
worse).
Macro-operators tend decrease expense increasing b, well
uninformed search dominates, show less advantage good heuristic exists,
b equally important. becomes important consider keep
increases branching factor minimum. case subgraph planning,
two main reasons b increases:
1. reduced graph may larger average degree original. Since
subgraph contains many vertices, tends out-going edges single
vertex. edges connect different subgraphs, branching factor
significantly larger. Sparse subgraphs (such halls) worse regard
dense subgraphs (such cliques). subgraph decomposition needs chosen
carefully avoid problem.
2. single subgraph transition may create large number possible configurations,
robot enters large hall already occupied several robots.
cases may strictly matter configuration generated
possible use least commitment avoid creating unnecessary alternatives,
possibility different configurations result different outcomes

512

fiExploiting Subgraph Structure Multi-Robot Path Planning

track, need considered. Halls particular
problem.
see experiments follow, careful choice subgraph decomposition important avoid pitfalls, appropriate partition abstraction
significantly improve informed uninformed search.

9. Experiments
empirically test advantages subgraph approach, ran several experiments
real randomly generated problems. first experiment demonstrates
algorithms scale changes size problem, terms number vertices,
edges robots, standard breadth-first search. second experiment shows
results affected using heuristic guide search. experiments
use randomly generated graphs. final experiment demonstrates algorithm
realistic problem.
first two experiments, maps generated randomly automatically partitioned subgraphs. Random generation done follows: first spanning tree
generated adding vertices one one, connecting randomly selected vertex
graph. edges required generated randomly selecting two
non-adjacent vertices creating edge them. edges undirected.1
Automated partitioning worked follows:
1. Initially mark vertices unused.
2. Select pair adjacent unused vertices.
3. Use pair basis growing hall, ring clique:
Hall: Randomly add unused vertices adjacent either end hall, provided
violate hall property. Continue growth possible.
Ring: Randomly add unused vertices adjacent either end ring loop
created. Discard vertices involved loop.
Clique: Randomly add unused vertices adjacent every vertex clique. Continue growth possible.
4. Keep biggest three generated subgraphs. Mark vertices used.
5. Go back step 2, adjacent unused pairs found.
6. remaining unused vertices singletons.
intended ideal algorithm. results far optimal fast
effective. Experience suggests partition generated approach contain
twice many subgraphs one crafted hand, makes effort minimise
degree reduced graph, even randomly generated partitions
advantages subgraph abstraction apparent.
1. noted algorithm generate uniform distribution connected graphs
given size, difficult generate sparse connected graphs uniform distribution.
bias deemed significant.

513

fiRyan

4.0
Original
Reduced

30

3.5

degree

# subgraphs

3.0
20

2.5

2.0
10
1.5

0

1.0
10

20

30

40

50

60

70

80

90

100

10

# vertices

20

30

40

50

60

70

80

90

100

# vertices

Figure 6: results automatic partitioning program Experiment 1a. left
graph shows average number subgraphs generated right graph
shows average degree reduced graph.

9.1 Experiment 1: Scaling Problem Size
9.1.1 Scaling |V |
first experiment investigate effect scaling number vertices
graph search time. Random graphs generated number vertices
ranging 10 100. Edges added average degree = |E|/|V | always
equal 3. (This value seems typical realistic maps.) One hundred graphs
generated size, one partitioned using method described above.
Figure 6 shows performance auto-partitioning. see, number
subgraphs increased roughly linearly size graph, average subgraph
size 4. small graphs (with fewer 40 vertices) reduced graph partitioning
sparser original, size increases average degree reduced graph
gets larger. results presented informative purposes only. make claims
quality partitioning algorithm, indeed reducing
size graph, small factor.
graph, three robots given randomly selected initial final locations,
plan generated. Figure 7(a) shows average run times four approaches.2 shows clear performance hierarchy. complete planners significantly
slower priority planners, cases subgraph abstraction shows significant improvement naive alternative. Nevertheless, every case combinatorial
growth runtime apparent (note graph plotted log scale). linear
relationship number vertices number subgraphs prevents subgraph
2. noted times overall rather slow. acknowledge attribute
implementation, Java heavily optimised avoid garbage collection.
currently working implementation optimised search engine, believe
results still provide valuable comparison methods.

514

fiExploiting Subgraph Structure Multi-Robot Path Planning

1000000

100000

Time (ms)

10000

1000

100
Naive complete
Naive priority
Subgraph complete
Subgraph priority

10

1
10

20

30

40

50

60

70

80

90

100

# vertices
(a) run times
8
Naive complete
Naive priority
Subgraph complete
Subgraph priority

7

Naive complete
Naive priority
Subgraph complete
Subgraph priority

30

5

path length

branching factor

6

4

20

3
10

2
1
0

0
10

20

30

40

50

60

70

80

90

100

10

# vertices

20

30

40

50

60

70

80

90

100

# vertices

(b) branching factor

(c) goal depth

Figure 7: results Experiment 1a. graph (a) boxes show first third
quartile whiskers show complete range. experiment failed
complete due time memory limits incompleteness search, run
time treated infinite. value plotted cases 50%
experiments failed. graph (c) goal depth naive complete
subgraph priority approaches identical graphs 30 60 vertices,
lines overlap. naive complete planner could solve problems
60 vertices.

515

fiRyan

Table 1: number planning failures recorded two prioritised planning approaches Experiment 1a.
# Failures
Vertices Naive Subgraph
10
2
0
20 - 70
0
0
80
1
0
90 - 100
0
0

approaches better this. better partitioning algorithm ameliorate
problem.
analyse causes variation run times, need consider search
process carefully. measure search depth average branching factor b
experiment. results plotted Figure 7(b) (c). expected,
subgraph abstraction used, goal depth decreased grows slowly,
branching factor increased. Since uninformed search, dominates
overall result improvement planning time.
incompleteness prioritised planning shows Table 1. three occasions
naive prioritised search failed find available solutions. However problem
prioritised subgraph search.
9.1.2 Scaling |E|
Next examine effect graph density. Fixing number vertices 30,
generated random graphs average degree ranging 2.0 4.0. value,
100 graphs randomly generated automatically partitioned. planning
problem move three robots selected initial goal locations.
results experiment shown Figure 8. appear much
overall change run times approaches, small improvement
naive prioritised planner graph gets denser. Figures 8(b) (c) show
expected result: increasing density graph increases branching factor
decreases depth. appears affect four approaches similarly.
interesting difference, however, shown Table 2. records percentage
experiments prioritised planners unable find solution.
sparse graphs, naive planner failed many 10% problems, improved
quickly density increased. subgraph abstraction added, planner able
solve two problems. case find problems solved
naive planner subgraph planner.
9.1.3 Scaling |R|
last scaling experiments, investigate approach performs
varying numbers robots. before, 100 random graphs generated partitioned,
30 vertices average degree 3, one partitioned using
516

fiExploiting Subgraph Structure Multi-Robot Path Planning

10000

Time (ms)

1000

100

10
Naive complete
Naive priority
Subgraph complete
Subgraph priority
1
2.0

2.2

2.4

2.6

2.8

3.0

3.2

3.4

3.6

3.8

4.0

degree
(a) run times
8

40

6

Naive complete
Naive priority
Subgraph complete
Subgraph priority

30
path length

branching factor

7

Naive complete
Naive priority
Subgraph complete
Subgraph priority

5
4

20

3
10
2
1
2.0

2.2

2.4

2.6

2.8

3.0

3.2

3.4

3.6

3.8

4.0

0
2.0

2.2

2.4

2.6

2.8

degree

3.0

3.2

degree

(b) branching factor

(c) goal depth

Figure 8: results Experiment 1b.

517

3.4

3.6

3.8

4.0

fiRyan

100000

Time (ms)

10000

1000

100

Naive complete
Naive priority
Subgraph complete
Subgraph priority

10

1
1

2

3

4

5

6

7

8

9

10

# robots
(a) run times
Naive complete
Naive priority
Subgraph complete
Subgraph priority

7

Naive complete
Naive priority
Subgraph complete
Subgraph priority

1000

5

100
path length

branching factor

6

4

3

10

2

1

1
1

2

3

4

5

6

7

8

9

10

1

2

3

4

# robots

5

6
# robots

(b) branching factor

(c) goal depth

Figure 9: results Experiment 1c.

518

7

8

9

10

fiExploiting Subgraph Structure Multi-Robot Path Planning

Table 2: number planning failures recorded two prioritised planning approaches Experiment 1b.
# Failures
Degree Naive Subgraph
2.0
10
0
2.2
8
0
2.4
5
0
2.6
1
1
2.8
0
0
3.0
2
0
3.2
1
1
3.4 - 4.0
0
0

Table 3: number planning failures recorded two prioritised planning approaches Experiment 1c.
# Failures
# Robots Naive Subgraph
1-3
0
0
4
3
0
5
4
0
6
10
0
7
7
1
8
7
1
9
26
0
10
46
1

automatic partitioning algorithm. Ten planning problems set graph
number robots varying 1 10. case initial goal locations selected
randomly.
running times four approaches plotted Figure 9(a). major
performance difference prioritised non-prioritised planners, prioritised planners able handle twice many robots. two complete-search
approaches, subgraph abstraction unnecessary overhead small problems,
shows significant advantage number robots increases.
less obvious advantage subgraph abstraction case prioritised
planning, look failure rates shown Table 3. number robots
increases incompleteness naive prioritised algorithm begins become apparent,
10 robots see 46% problems could solved planner.
advantage subgraph abstraction apparent: total 3 problems
could solved 1000 tried.

519

fiRyan

Figures 9(b) (c) plot average branching factor goal depth problems.
previous experiments, subgraph abstraction seen increase branching
factor decrease depth. complete search approaches branching factor
grows rapidly number robots, node search path contains choice
robot move. prioritised approach reverses trend, planning
ever done one robot time, later robots much heavily constrained
options available them, providing fewer alternatives search tree.
9.1.4 Discussion
summarise experiments, advantages subgraph abstraction twofold. Firstly, decreases necessary search depth planning problem compressing
many robot movements single abstract step. macro-based abstractions,
expense increasing branching factor gains seem outweigh
losses practice. course, dependent degree use uninformed
search, shall address below.
advantage specific prioritised planner. tightly constrained problems sparse maps and/or many robots incompleteness naive prioritised
search becomes significant issue. addition subgraph abstraction
number failures dramatically reduced, without additional search.
9.2 Experiment 2: Heuristic Search
experiments far involved uninformed breadth-first search without use
heuristic. such, runtime algorithms strongly affected changes
search depth branching factor. explained above, uninformed search
O(bd ) expected running time. However perfect heuristic reduce O(bd),
making branching factor much significant aspect. perfect heuristic is, course,
unavailable, possible efficiently compute reasonably good search heuristic
task relaxing problem. Disregarding collisions simply compute sum
shortest path lengths robots location goal. underestimate
actual path length, accurate loosely constrained problems (with robots
dense graphs).
experiment used best-first search algorithm guided heuristic.3
every node search tree, selected plan minimised value. case
subgraph planner, actual locations robots time-point specified,
subgraph occupy, heuristic calculated using maximum distances
vertex robots subgraph goal. pre-computed shortest path
distances every pair nodes running planner, time
computation counted runtime algorithm.
utility heuristic depends largely constrained problem is.
graph dense relatively robots, heuristic direct planner
quickly goal. However graph sparser, interactions robots
become important, heuristic less useful. reason,
3. A* algorithm used, desire minimise length solution, find
solution quickly possible.

520

fiExploiting Subgraph Structure Multi-Robot Path Planning

concentrate attention experiment varying density graph affects
performance different approaches.
Random maps 200 vertices generated, average degree ranging 2
3. One hundred graphs generated size partitioned using algorithm
described earlier. Figure 10 shows results. original graph gets denser,
number subgraphs decreases, mostly possible create longer halls.
good, fewer subgraphs mean shorter paths, consequential increase degree
adversely affect branching factor.
Ten robots placed randomly graph assigned random goal locations.
four planning approaches applied problems. resulting run-times
plotted Figure 11(a). first thing apparent graph
distinction different approaches greatly reduced. size graph
number robots much larger previous experiments,
corresponding effect goal depth branching factor (Figure 11(b) (c)),
run-times much smaller, clearly heuristic effective guiding search.
average ratio search nodes expanded goal depth close 1.0
experiments, slight increase constrained cases, conclude
heuristic close perfect.
compare four approaches see three distinct stages. constrained case, 200 edges, see subgraph approaches outperforming either naive
approach, small benefit prioritised search complete search. 220 edges
pattern changed. two prioritised methods significantly better two
complete approaches. number edges increases, naive methods continue
improve, prioritised subgraph search holds steady complete subgraph search
gets significantly worse (due rapid increase branching factor). 300 edges
naive approaches significantly better subgraph approaches.


Singletons
Halls
Cliques
Rings

60

4.5

Original
Reduced

4.0

50

degree

# subgraphs

3.5
40
30

3.0
2.5

20

2.0

10

1.5

0

1.0
200

210

220

230

240

250

260

270

280

290

300

200

# edges

210

220

230

240

250

260

270

280

290

# edges

(a) subgraphs

(b) degree

Figure 10: results auto-partitioner graphs Experiment 2.

521

300

fiRyan

10000

Time (ms)

1000

100
Naive complete
Naive priority
Subgraph complete
Subgraph priority
10
200

210

220

230

240

250

260

270

280

290

300

edges
(a) run times
120

Naive complete
Naive priority
Subgraph complete
Subgraph priority

400

Naive complete
Naive priority
Subgraph complete
Subgraph priority

300
80

path length

branching factor

100

60

200

40
100
20
0
200

220

240

260

280

300

0
200

220

240

edges

260
edges

(b) branching factor

(c) goal depth

Figure 11: results Experiment 2.

522

280

300

fiExploiting Subgraph Structure Multi-Robot Path Planning

Table 4: number planning failures recorded two prioritised planning approaches Experiment 2.
# Failures
# Edges Naive Subgraph
200
14
0
210
2
0
220
0
0
230
0
0
240
1
0
250 - 300
0
0

cause clearly seen Figures 11(b) (c). branching factors subgraph
approaches increase significantly faster naive approaches, corresponding
improvement goal depth sufficient outweigh cost.
benefits subgraph abstraction highly constrained cases shown
failure cases (Table 4). 200 edges naive prioritised search unable solve 10%
problems, prioritised search subgraphs could solve all. number
failures fell quickly density graph increased.
9.2.1 Discussion
graph becomes moderately dense interactions robots become few,
total-single-robot-paths measure becomes near perfect heuristic. makes
branching factor much critical factor using uninformed search.
auto-partitioning algorithm use poor job limiting factor
subgraph approaches perform poorly.
Better results could achieved better decomposition, clear whether
could found random graph without excessive computation. Certainly partitioning graphs hand easy task. Realistic graphs, hand, generally
shaped natural constraints (e.g. rooms, doors corridors) make decomposition
much simpler, see following experiment.
9.3 Experiment 3: Indoor Map
Figure 12 shows map final two experiments, based floor-plan Level 4
K17 building University New South Wales. road-map 113 vertices 308
edges drawn (by hand) connecting offices open-plan desk locations.
imagined might used map delivery task involving team
medium-sized robots.
road-map partitioned 47 subgraphs 11 cliques, 7 halls 1 ring,
plus 28 remaining singleton nodes (subgraphs containing one vertex). average

523

fiRyan

Figure 12: map Experiment 3. Vertices coloured subgraph.

524

fiExploiting Subgraph Structure Multi-Robot Path Planning

10000
Naive complete
Naive priority
Subgraph complete
Subgraph priority

Time (ms)

1000

100

10
1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

robots

Figure 13: Comparing run times Experiment 3.
degree reduced graph 2.1, compared 2.7 original.4 Partitioning done
hand aid interactive GUI performed simple graph analysis
offered recommendations (by indicating nodes could added hall clique
user creating). road-map clearly laid partitioning mind
deciding partitioning whole difficult. Large open spaces generally
became cliques. Corridors became halls rings. foyer area (around vertex 94)
caused particular trouble finding ideal partitioning, due slightly unusual
topology.5
series experiments run world, varying number robots 1
20. experiment 100 runs performed robot placed
random office desk required make delivery another random office
desk (chosen without replacement, two robots goal). Plans built
using complete prioritised planners without subgraph abstraction.
four approaches utilised total single-robot shortest path heuristic previous
experiment. running times algorithm shown Figure 13.
see small numbers robots (1 2) naive approaches significantly better subgraph approaches. overhead subgraph search
outweighs disadvantages simple problems. number robots increases
subgraph methods take over, around 9 16 robots subgraph methods
significant better either naive approach. 17 robots combination complete
search subgraphs begins perform less well two prioritised approaches
best performers, considerable advantage subgraph approach.
4. comparison, auto-partitioner yielded partition fewer subgraphs (avg. 41.8) higher
degree (avg. 2.25).
5. curious, empty rooms centre map, near vertex 91, bathrooms.
consider robots would need make deliveries there.

525

fiRyan

Naive complete
Naive priority
Subgraph complete
Subgraph priority

1.8
1.7

expanded / path

1.6
1.5
1.4
1.3
1.2
1.1
1.0
1

2

3

4

5

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20
robots

Figure 14: Assessing quality heuristic Experiment 3. value plotted
ratio number expanded nodes search tree goal depth.
perfect heuristic yields value 1.0.

Considering search complexity, let us first examine performance heuristic.
Figure 14 plots ratio average number expanded nodes search tree
goal depth. perfect heuristic, value 1.0, experiment
11 robots. 11 robots heuristic begins become inaccurate.
inaccuracy seems affect complete planners badly prioritised ones,
cases subgraph approach seriously affected naive approach.
explain difference, note heuristic using contains significantly less
information subgraph search naive search. know exactly
robot within subgraph, assume worst possible position.
means value configuration tuple based solely allocation robots
subgraphs, particular configurations subgraphs. Hall subgraphs
particular may several different configurations set robots,
assigned heuristic value despite significantly different real distances
goal.This creates plateau heuristic function broadens search. large
numbers robots permutations become significant factor search. improve
heuristic need find way distinguish value different configurations
subgraph. probably require extra method specific subgraph structure.
graphs branching factor goal depth (Figure 15) show come
expect branching factor larger complete search prioritised search
subgraph abstraction makes worse. Significantly, branching factor prioritised
526

fiExploiting Subgraph Structure Multi-Robot Path Planning

Naive complete
Naive priority
Subgraph complete
Subgraph priority

50

Naive complete
Naive priority
Subgraph complete
Subgraph priority

2000

path length

branching factor

40

30

20

1000

10

0

0
1

2

3

4

5

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20

1

robots

2

3

4

5

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20
robots

(a) branching factor

(b) goal depth

Figure 15: branching factor goal depth Experiment 3.
Table 5: number planning failures recorded two prioritised planning approaches Experiment 3.
# Failures
Edges Naive Subgraph
1-9
0
0
10 - 19
0
1
20
0
2

search increase robots added, step plan
one robot moved. goal depth shows opposite pattern, complete searches
shorter prioritised searches subgraph abstraction approximately halves
search depth cases.
Failure rates recorded Table 5. story different previous
experiments. naive prioritised planner able solve problems every depth,
adding subgraph abstraction caused small number failures complex
problems. clear caused reversal. cases involved complex
elude analysis. problem warrants investigation.
9.3.1 Discussion
experiment shown realistic problem appropriately chosen set
subgraphs subgraph abstraction effective way reduce search even
good heuristic available. subgraph abstraction work well
example, compared random graphs Experiment 2? answer seems found
degree reduced graph. Automatically partitioning random graph significantly
increases degree, saw Figure 10(b). This, turn, increases branching factor
thus search time.

527

fiRyan

contrast, partition realistic map decreased degree graph
2.7 2.1 (by hand) 2.25 (automatically). branching factor subgraph
methods still larger (as one transition still create multiple configurations)
effect reduced enough overcome decrease goal depth. indication
realistic map structure exploited abstraction.
investigation warranted characterise features many possible.

10. Conclusion
demonstrated new kind abstract representation multi-robot path planning
allows much faster planning without sacrificing completeness. Decomposing
road-map subgraphs simple intuitive way providing background knowledge
planner efficiently exploited. key find subgraph structures
allow us treat many arrangements robots equivalent configurations compute
transitions configurations quickly deterministically. described
four structures paper: stacks, halls, cliques rings. structures
simple enough compute configurations easily common enough found
many realistic maps.
shown abstract plans subgraphs resolved deterministically
concrete plans without need search. planner sound complete,
although plans produced necessarily optimal. Future work could prove
worth spending time resolution phase trim unnecessarily wasteful plans,
using, example, simulated annealing (Sanchez, Ramos, & Frausto, 1999). may
time saved abstract planning leaves us space clever resolution.
conventional solution search-space explosion multi-robot planning prioritisation. shown subgraph-based planning competitive
prioritised planning combination two methods powerful still
cases, partly alleviates incompleteness prioritised approach.
10.1 Related Work
Abstraction hierarchical decomposition standard techniques planning
related search problems. use macro-operators dates back far Sacerdotis early
work Abstrips planning system (Sacerdoti, 1974) introduced abstraction
hierarchies, whereby problem could first solved high level abstraction
ignoring lower-level details. idea re-expressed many different ways
history planning far many review detail. present work particularly
inspired generic types Long Fox (2002) similarly detected
substructures task-planning problem solved using structure-specific planners.
Hierarchical planning applied path-planning abstractions
approximate cell decomposition (Barbehenn & Hutchinson, 1995; Conte & Zulli, 1995),
generalised Voronoi graphs (Choset & Burdick, 1995; Choset, 1996) general ad-hoc
hierarchical maps (Bakker, Zivkovic, & Krose, 2005; Zivkovic, Bakker, & Krose, 2005, 2006),
structures identified examples carry well multi-robot
scenario.

528

fiExploiting Subgraph Structure Multi-Robot Path Planning

faster solutions multi-robot problem available assume
existence garage locations robot (LaValle & Hutchinson, 1998) kinds
temporary free space (Sharma & Aloimonos, 1992; Fitch, Butler, & Rus, 2003).
method present makes assumption thus general application.
appear previous work provides complete abstraction-based
planner general multi-robot problem.
work bears similarity explicitly robot path planning,
solving Sokoban puzzle (Botea, Muller, & Schaeffer, 2003; Junghanns & Schaeffer, 2001). domain significantly constrained (the map necessarily
orthogonal grid stones move pushed man)
method employ similar. Dividing map rooms tunnels use
strongly-connected-component algorithm identify equivalent arrangements boulders subpart. Equivalent arrangements treated single abstract state
corresponding configuration formulation used state global
search. particular structures represent different, general ideas partitioning independent local subproblems identifying abstract states strongly
connected components, employed work.
10.2 Future Plans
next stage project plan examine symmetries provided subgraph
representation. Recent work symbolic task-planning (Porteous, Long, & Fox, 2004)
shown recognising exploiting symmetries almost-symmetries planning
problems eliminate large amounts search. Subgraph configurations provide natural
ground similar work problem domain expect similar improvements
possible.
plan investigate problem automatic subgraph partitioning
maps. identified importance trading path depth branching
factor, plan make partitioning algorithm chooses subgraphs optimise
relationship. Automatically finding optimal partition could hard, creating
powerful interactive partitioning tool human operator would seem viable
compromise. One approach would adapt auto-partitioner describe
paper seed vertices selected user, allowed choose
number possible subgraphs based selection.
subgraph structures identified, currently working
formalising properties tree-structured subgraphs. Another possibility would
generalise cliques rings new ring-with-chords structure, although characterising
structure may prove difficult.
many advances search technology may applicable
multi-robot planning problem. currently process re-expressing
entire problem constraint satisfaction problem (CSP) Gecode constraint engine
(Gecode Team, 2006). believe CSP formulation powerful way take
advantage structural knowledge subgraph decomposition represents.

Acknowledgments
529

fiRyan

Id thank Jonathan Paxman, Brad Tonkes Maurice Pagnucco help
developing ideas paper proofreading drafts.

Appendix A. Proof Soundness Completeness
appendix set necessary formal definitions prove soundness
completeness abstract planning process. main result theorem showing
abstract plan exists given problem concrete plan exists.
A.1 Graphs Subgraphs
induced subgraph G graph = (V (S), E(S))
V (S) V (G)

E(S) = {(u, v) | u, v V (S), (u, v) E(G)}

Intuitively describes subgraph consisting subset vertices connecting edges parent graph. Thus induced subgraph specified solely
terms vertices. shall henceforth assume subgraphs refer induced.
partition P G set {S1 , . . . , Sm } subgraphs G satisfying
[
V (G) =
V (Si )

V (Si ) V (Sj ) = , i, j : 6= j
i=1...m

Given graph G partition P construct reduced graph X G
contracting subgraph single vertex
V (X) = P
E(X) = {(Si , Sj ) | x Si , Sj : (x, y) G}
A.2 Robots Arrangements
Let us assume set robots R. arrangement robots graph G
1-to-1 partial function : V (G) R. arrangement represents locations robots
within G. a(v) = r, robot r vertex v. shall use notation a(v) = 2
indicate undefined v, i.e. vertex v unoccupied. arrangement may
necessarily include every robot R. Two arrangements b said disjoint
range(a) range(b) = . Let AG represent set arrangements R G.
subgraph G, arrangement R G define a/S,
induced arrangement R S,
a/S(v) = a(v), v V (S)
S1 S2 disjoint subgraphs G disjoint arrangements a1 S1 a2
S2 , define combined arrangement = a1 a2 arrangement S1 S2
satisfying
(
a1 (v) v S1
a(v) =
a2 (v) v S2

530

fiExploiting Subgraph Structure Multi-Robot Path Planning

Lemma 1 arrangement G partition P = {S1 , . . . , Sm } {a1 , . . . , }
set induced arrangements ai = a/Si , combined arrangement a1 =
a.
Given identity, uniquely identify arrangement G combination
induced arrangements partition P.
A.3 Concrete Plans
need define means move robots around graph. First define
two operators respectively add remove robots given arrangement.
Formally : AG R V (G) AG mapping satisfies
G

(r, v) = b
G



(
r
b(u) =
a(u)

u = v
otherwise

Similarly : AG R AG mapping satisfies
G

r =b
G



(
2
b(u) =
a(u)

a(u) = r
otherwise

omit subscript G clear context.
define plan-step R E(G) G robot/edge pair (r, u, v),
representing movement r along edge u v, u 6= v. plan-step
applicable arrangement AG iff a(u) = r a(v) = 2. case apply
produce new arrangement b = s(a)
s(a) = (a r) (r, v)
concrete plan (or plan) G AG b AG sequence plan-steps
hs1 , . . . , sl exist arrangements a0 , . . . , al AG si applicable ai1

a0 =
al = b
ai = si (ai1 ), : 0 < l
Lemma 2 subgraph G P plan P plan G.
Lemma 3 P plan G b Q plan G b c,
concatenation P Q, written P.Q plan G c.
531

fiRyan

Lemma 4 Let P kQ denote set interleavings sequences P Q. Let S1
S2 disjoint subgraphs G, P1 plan S1 a1 b1 P2 plan S2
a2 b2 , a1 a2 disjoint. arbitrary interleaving P P1 kP2 plan
G a1 a2 b1 b2 .
A.4 Configurations
defined machinery concrete plans, introduce abstraction. key
idea configuration abstraction arrangements. robots
subgraph rearranged one arrangement another, without robots
leave subgraph rearrangement, two arrangements
treated equivalent. Configurations represent sets equivalent arrangements
subgraph. So, example, stack subgraph configuration set arrangements
ordering robots. arrangement entire partitioned graph
abstracted list configurations produces subgraphs.
Formally, define configuration relation graph G equivalence relation
G

AG b iff exists plans Pab Pba G b b
G

respectively.
configuration c G equivalence class . write c = (a) represent
G

G

equivalence class containing arrangement a. Let CG set configurations
G.
Lemma 5 b range(a) = range(b)
G

Given identity, unambiguously define range configuration c
range(c) = range(a), c
extend definitions configurations. c CG
configuration G, r R v V (G)


c (r, v) = (a (r, v)) | c, a(v) = 2
G
G
G


c (r, v) = (a r) | c, a(v) = r
G

G

G

Note map configurations sets configurations.6
Given partition P = {S1 , . . . , Sm } G corresponding set configuration
relations { , . . . , } define configuration tuple R G tuple (c1 , . . . , cm )
S1

Sm

: ci CSi ,
[

range(ci ) = R

i=1...m

range(ci ) range(cj ) = , i, j : 6= j
6. Astute readers notice c (r, v) never contains one element, although may
G

empty.

532

fiExploiting Subgraph Structure Multi-Robot Path Planning

configuration tuple represents abstract state robots entire graph,
terms configurations individual subgraphs partition. Given arrangement G construct corresponding configuration tuple (a) = (c1 , . . . , cm )
ci = (a/Si ). Conversely, a/Si ci ci , write .
Si

Lemma 6 b arrangements graph G partition {S1 , . . . , Sm }
configuration tuple G a, b , exists plan b G.
Proof
= 1 . . . m, let ai = a/Si bi = b/Si . ai ci bi ci
ai bi . Therefore definition exists plan Pi ai bi Si .
Si

Let P P1 k . . . kPm . Since Pi plans disjoint subgraphs, P plan
a1 = b1 bm = b required.

A.5 Abstract Plans
configuration tuples abstract state representation, define abstract
plans, sequences subgraph transitions plan steps move robot one
subgraph another. prove main result section, abstract
plan problem exists corresponding concrete plan exists. allow
us later prove soundness completeness subgraph planning algorithm.
rest section shall assume graph G partition P =
{S1 , . . . , Sm } corresponding configuration relations { , . . . , }.
S1

Sm

subgraph transition (or transition) plan-step = (r, u, v) u Sx ,
v Sy Sx 6= Sy . transition = (r, u, v) applicable configuration tuple
= (c1 , . . . , cm ) G
cx (r, u) 6= , u Sx ,
Sx

cy (r, v) 6= , v Sy .
Sy

is, robots Sx rearranged robot r leave via u robots
Sy rearranged v empty r enter.
transition = (r, u, v) applicable = (c1 , . . . , cm ) u Sx v Sy
apply compute set s() configuration-tuples
(c01 , . . . c0m ) s()

c0x cx (r, u),
Sx



c0y

cy (r, v),

c0z

= cz , otherwise.

Sy

Lemma 7 arrangement G partition {S1 , . . . , Sm } transition =
(r, u, v) applicable applicable (a),
(s(a)) s((a))
533

fiRyan

Proof Let Sx , Sy disjoint subgraphs partition u Sx , v Sy . Let
ax = a/Sx ay = a/Sy . Let (a) = (c1 , . . . , cm ).
ax cx
ax (u) = r
cx (r, u) 6= .
similarly
ay cy
ay (v) = 2
cy (r, v) 6= .
Therefore applicable (a).
Further, let b = s(a) (b) = (c01 , . . . , c0m ).
c0x = (b/Sx )
Sx

= (ax r)
Sx

cx (r, u)

c0y = (b/Sy )
Sy

= (ay (r, v))
Sy

cy (r, v)

c0z = cz .
Therefore (b) s() required.



Lemma 8 = (r, u, v) u, v Sx (i.e. transition) arrangement G applicable a, (a) = (s(a)).
Proof
Let b = s(a). Let ai = a/Si bi = b/Si = 1 . . . m. Let (a) =
(c1 , . . . , cm ) (b) = (c01 , . . . , c0m ).
plan Px = hsi plan ax bx Sx , ax bx implying cx = c0x .
z 6= x, az = bz cz = c0z . Therefore (a) = (b) required.


534

fiExploiting Subgraph Structure Multi-Robot Path Planning

define abstract plan arrangement G tuple (, )
sequence configuration tuples h0 , . . . , l sequence plan steps
hs1 , . . . , sl i,
0 = (),
l = (),
si applicable i1 ,
s(i1 ).
Theorem 1 abstract plan G exists exists corresponding concrete plan P G.
Proof Case ( P ):
Let = (, ) abstract plan G , = h0 , . . . , l
= hs1 , . . . , sl i. Let = (ci0 , . . . , cim ).
shall construct concrete plan
P = P0 . hs1 .P1 . .Pl1 . hsl .Pl
Pi concrete plan ai bi , satisfying
a0 = ,
bl = ,
ai , bi ,
si+1 applicable bi ,
ai+1 = si+1 (bi ), = 0 . . . l 1.
Proposition 1 ai bi exist satisfying conditions = 1 . . . l.
Proof induction:
a0 = therefore a0 exists.
Assume ai exists:
Let si+1 = (r, u, v) u Sx v Sy . definition abstract plan,
si+1 applicable , i+1 = si+1 (i ). Therefore
ci+1
cix (r, u) 6=
x
n


ci+1

(a

(r,
u))
|
a(u)
=
r,


c
x
x 6=
cix : a(u) = r
Set bix equal a.
ci+1
= (bix (r, u))
x
bix (r, u) ci+1
x

535

fiRyan


ci+1
ciy (r, v) 6=

n


ci+1

(a

(r,
v))
|
a(v)
=
2,


c

6=
ciy : a(v) = 2
Set biy equal a.
ci+1
= (biy (r, v))

biy (r, v) ci+1

Set biz = ai /Sz z
/ {x, y}
bij defined every subgraph Sj partition G. Therefore bi = bi1 bim
exists arrangement G.
ai exists bi exists = 0 . . . l 1.
si+1 applicable bi since
bi (u) = bix (u) = r
bi (v) = biy (v) = 2
ai+1 = si+1 (bi ) exists,
ai+1 /Sx = bix r ci+1
x
ai+1 /Sy = biy (r, v) ci+1

ai+1 /Sz = biz , z
/ {x, y} ciz
ci+1
z

ai+1 i+1
induction, ai exists = 0 . . . l bi exists = 0 . . . l 1.
Furthermore bl = () = l , bi exists = 0 . . . l, required.

Proposition 2 concrete plan Pi ai bi exists, = 0, . . . , l
Proof

Since ai , bi plan Pi must exist ai bi , Lemma 6 above.



Proposition 3 P concrete plan G.
Proof
Pi plan ai bi = 0, . . . , l. Furthermore ai+1 = si+1 (bi ),
hsi+1 plan bi ai+1 . Therefore concatenation plans
P = P0 . hs1 . . hsl .Pl
plan G a0 = bl = , required.
536



fiExploiting Subgraph Structure Multi-Robot Path Planning

Case (P ):
Let P = hs1 , . . . , sL concrete plan G. wish construct
abstract plan = (, ) G.
Let = ht0 , . . . , tl increasing sequence integers t0 = 0 ti = iff st
subgraph transition. (Note: using capital L designate length concrete
plan P lowercase l designate number transitions plan,
length corresponding abstract plan .)
construct sequence arrangements = h0 , . . . , L
0 =
i+1 = si+1 (i ), = 0 . . . L 1
split subsequences A0 , . . . , Al



Ai = ti , . . . , ti+1 1
Define = (ti ), = 0, . . . , l, = h0 , . . . , l = hst1 , . . . , stl i.
Proposition 4 : Ai
Proof induction:
definition,
ti (ti ) =
assume = ti + j, j < |Ai | 1. need prove t+1 .
Let st+1 = (r, u, v). Since + 1
/ must u, v Sx . using Lemma 8
(t+1 ) = (st+1 (t ))
= (t )
= .
Therefore, induction
, Ai
required.



Proposition 5 = (, ) valid abstract plan .
Proof
First check initial final configuration-tuples contain
respectively:
0 = (0 ) = ().

Al
l ,
l = ().

537

fiRyan

Now, = 0 . . . l 1 let bi = ti+1 1 (i.e. final element Ai ), let
= bi /Sz z = 1 . . . m.
Let = sti+1 = (r, u, v) u Sx v Sy . applicable bi
definition P . Therefore, Lemma 7 above, applicable

biz

i+1 = (ai+1 )
= (s(bi ))
s((bi )) = s(i ), required.

Therefore valid abstract plan.



theorem significant planning problem. tells us need
perform search concrete plans. Instead, need search abstract plan
convert concrete form. search succeed concrete
plan exists.

References
Alami, R., Fleury, S., Herrb, M., Ingrand, F., & Robert, F. (1998). Multi-robot cooperation
MARTHA project. Robotics & Automation Magazine, IEEE, 5 (1), 3647.
Alarie, S., & Gamache, M. (2002). Overview Solution Strategies Used Truck Dispatching Systems Open Pit Mines. International Journal Surface Mining, Reclamation Environment, 16 (1), 5976.
Bakker, B., Zivkovic, Z., & Krose, B. (2005). Hierarchical dynamic programming robot
path planning. Proceedings IEEE/RSJ International Conference Intelligent
Robots Systems, 27562761.
Barbehenn, M., & Hutchinson, S. (1995). Efficient search hierarchical motion planning
dynamically maintaining single-source shortest paths trees. IEEE transactions
robotics automation, 11 (2), 198214.
Barraquand, J., & Latombe, J.-C. (1991). Robot motion planning: distributed representation approach. International Journal Robotics Research, 10 (6), 628649.
Botea, A., Muller, M., & Schaeffer, J. (2003). Using abstraction planning sokoban.
Computers Games: Lecture Notes Computer Science, Vol. 2883, pp. 360375.
Springer.
Buro, M., & Furtak, T. (2004). RTS games real-time AI research. Proceedings
Behavior Representation Modeling Simulation Conference (BRIMS), Arlington
VA 2004, 5158.
Choset, H. (1996). Sensor based motion planning: hierarchical generalized voronoi
graph. Ph.D. thesis, California Institute Technology, Pasadena, California.
Choset, H., & Burdick, J. (1995). Sensor based planning. I. generalized Voronoi graph.
Proceedings International Conference Robotics utomation, 2.

538

fiExploiting Subgraph Structure Multi-Robot Path Planning

Conte, G., & Zulli, R. (1995). Hierarchical path planning multi-robot environment
simple navigation function. IEEE Transactions Systems, Man Cybernetics,
25 (4), 651654.
Erdmann, M., & Lozano-Perez, T. (1986). Multiple Moving Objects. Tech. rep. 883,
M.I.T. AI Laboratory.
Everett, H., Gage, D., Gilbreth, G., Laird, R., & Smurlo, R. (1994). Real-world issues
warehouse navigation. Proceedings SPIE Conference Mobile Robots IX,
2352.
Fitch, R., Butler, Z., & Rus, D. (2003). Reconfiguration planning heterogeneous selfreconfiguring robots. Proceedings IEEE/RSJ International Conference Intelligent Robots Systems, 3, 24602467.
Gecode Team (2006). Gecode: Generic constraint development environment,. Available
http://www.gecode.org.
Hada, Y., & Takase, K. (2001). Multiple mobile robot navigation using indoor global
positioning system (iGPS). Proceedings IEEE/RSJ International Conference
Intelligent Robots Systems, 2.
Junghanns, A., & Schaeffer, J. (2001). Sokoban: Enhancing general single-agent search
methods using domain knowledge. Artificial Intelligence, 129 (1-2), 219251.
LaValle, S. M. (2006). Planning Algorithms. Cambridge University Press.
LaValle, S. M., & Hutchinson, S. A. (1998). Optimal Motion Planning Multiple Robots
Independent Goals. IEEE Transactions Robotics Automation,
Vol. 14.
Long, D., & Fox, M. (2002). Planning Generic Types, chap. 4, pp. 103138. Morgan
Kaufmann.
Porteous, J., Long, D., & Fox, M. (2004). Identification Exploitation Almost
Symmetry Planning Problems. Brown, K. (Ed.), Proceedings 23rd UK
Planning Scheduling SIG.
Sacerdoti, E. (1974). Planning hierarchy abstraction spaces. Artificial Intelligence,
5 (2), 115135.
Sanchez, G., Ramos, F., & Frausto, J. (1999). Locally-Optimal Path Planning Using
Probabilistic Road Maps Simulatead Annealing. Proceedings IASTED International Conference Robotics Applications.
Sharma, R., & Aloimonos, Y. (1992). Coordinated motion planning: warehousemans
problem constraints free space. IEEE Transactions Systems, Man
Cybernetics, 22 (1), 130141.
van den Berg, J., & Overmars, M. (2005). Prioritized Motion Planning Multiple Robots.
Proceedings IEEE/RSJ International Conference Intelligent Robots Systems, pp. 430435.
Zivkovic, Z., Bakker, B., & Krose, B. (2005). Hierarchical map building using visual landmarks geometric constraints. Proceedings IEEE/RSJ International Conference
Intelligent Robots Systems, 24802485.
539

fiRyan

Zivkovic, Z., Bakker, B., & Krose, B. (2006). Hierarchical Map Building Planning based
Graph Partitioning. IEEE International Conference Robotics Automation.

540

fiExploiting Subgraph Structure Multi-Robot Path Planning

Algorithm 2 Planning subgraph abstraction.
1: function Plan(G, P, R, a, b)
2:
(a)
3:
(b)
4:
AbstractPlan(G, P, R, , )
5:
P Resolve(G, P, , a, b)
6:
return P
7: end function

. Build plan b G using partition P.
. Get initial configuration.
. Get final configuration.
. Build abstract plan.
. Resolve concrete plan.

1: function AbstractPlan(G, P, R, , ) . Build abstract plan G using P.
2:
=
3:
return (hi , hi)
. Done.
4:
end
5:
(c1 , . . . , cm ) =
6:
choose r R
. Choose robot.
7:
select x : r range(cx )
. Find subgraph occupies.
8:
choose Sy P : (Sx , Sy ) X
. Choose neighbouring subgraph.
9:
choose (u, v) E(G) : u Sx , v Sy
. Choose connecting edge.
. Choose resulting configurations Sx Sy .
10:
choose c0x cx (r, u)
11:
choose c0y cy (r, v)
12:
(c1 , . . . , c0x , . . . , c0y , . . . , cm )
. Construct new configuration tuple.
13:
(, ) AbstractPlan(G, P, R, , )
. Recurse.
14:
0 .
15:
0 (r, u, v).
16:
return (0 , 0 )
17: end function
1: function Resolve(G, P, , a, b)
. Resolve abstract plan concrete plan.
2:
= (, )
3:
= h0 , . . . , l
4:
= hs1 , . . . , sl
5:
P hi
6:
a0
7:
= 0 . . . (l 1)
8:
(r, u, v) = si+1
. next transition.
9:
(c01 , . . . , c0m ) = i+1
. target configurations.
10:
find Sx : u Sx
11:
find Sy : v Sy
12:
aiz ai /Sz , z = 1 . . .
13:
(Pxi , bix ) Sx .ResolveExit(aix , r, u, c0x )
. Rearrange Sx let robot r exit.
. Rearrange Sy let robot r enter.
14:
(Pyi , biy ) Sy .ResolveEnter(aiy , r, v, c0y )
15:
P P.(Pxi ||Pyi )
16:
bi = ai1 . . . bix . . . biy . . . aim
17:
ai+1 si+1 (bi )
18:
P P.. hsi+1
. Add transition.
19:
end
20:
z = 1 . . .
21:
Tz Sz .ResolveTerminate(al /Sz , b/Sz )
. Rearrange Sz final arrangement.
22:
end
23:
P P.(T1 || . . . ||Tm )
24:
return P
25: end function

541

fiRyan

Algorithm 3 simple prioritised planning algorithm.
1: function Plan(G, a, b)
2:
a0 [v] 2, v G
. a0 initial arrangement robots
0
3:
b [v] 2, v G
. b0 final arrangement robots
4:
= 1 . . . k
5:
a0 [v] = ri , v : a[v] = ri
6:
b0 [v] = ri , v : b[v] = ri
7:
(P, Pi ) PlanOne(G, ri , hP1 , . . . , Pi1 , h0, . . . , 0i , a0 , b0 )
. Build plan
8:
cut
. backtrack plan
9:
end
10:
return P
11: end function

r1 . . . ri .
r1 . . . ri .

r1 . . . ri .
found

1: function PlanOne(G, ri , hP1 , . . . , Pi1 , ht1 , . . . , ti1 , a, b)
2:
= b
3:
return (hi, hi)
. Done.
4:
end
5:
choose rj R : j
. Choose robot move.
6:
j =
7:
select vf : a[vf ] = ri
8:
choose vt {v | (vf , v) G}
. Choose new action ri
9:
else
10:
(r, vf , vt ) Pj [tj ]
. Select old action rj Pj
11:
tj tj + 1
12:
end
13:
a[vt ] 6= 2
14:
fail
. Backtrack destination occupied.
15:
end
16:
a[vf ] 2
. Move robot.
17:
a[vt ] r
18:
(P, Pi ) PlanOne(G, ri , hP1 , . . . , Pi1 , ht1 , . . . , ti1 , a, b)
. Recurse.
19:
P (rj , vf , vt ).P
. Add step global plan.
20:
j =
21:
Pi (ri , vf , vt ).Pri
. Add step ri plan.
22:
end
23:
return (P, Pi )
24: end function

542


