Journal Artificial Intelligence Research 31 (2008) 319-351

Submitted 09/07; published 02/08

Complexity Planning Problems
Simple Causal Graphs
Omer Gimenez

omer.gimenez@upc.edu

Dept. de Llenguatges Sistemes Informatics
Universitat Politecnica de Catalunya
Jordi Girona, 1-3
08034 Barcelona, Spain

Anders Jonsson

anders.jonsson@upf.edu

Dept. Information Communication Technologies
Passeig de Circumvallacio, 8
08003 Barcelona, Spain

Abstract
present three new complexity results classes planning problems simple
causal graphs. First, describe polynomial-time algorithm uses macros generate plans class 3S planning problems binary state variables acyclic
causal graphs. implies plan generation may tractable even planning
problem exponentially long minimal solution. prove problem
plan existence planning problems multi-valued variables chain causal graphs
NP-hard. Finally, show plan existence planning problems binary state
variables polytree causal graphs NP-complete.

1. Introduction
Planning area research artificial intelligence aims achieve autonomous
control complex systems. Formally, planning problem obtain sequence
transformations moving system initial state goal state, given description
possible transformations. Planning algorithms successfully used variety
applications, including robotics, process planning, information gathering, autonomous
agents spacecraft mission control. Research planning seen significant progress
last ten years, part due establishment International Planning
Competition.
important aspect research planning classify complexity solving
planning problems. able classify planning problem according complexity
makes possible select right tool solving it. Researchers usually distinguish
two problems: plan generation, problem generating sequence transformations achieving goal, plan existence, problem determining whether
sequence exists. original STRIPS formalism used, plan existence undecidable first-order case (Chapman, 1987) PSPACE-complete propositional
case (Bylander, 1994). Using PDDL, representation language used International
Planning Competition, plan existence EXPSPACE-complete (Erol, Nau, & Subrahmanian, 1995). However, planning problems usually exhibit structure makes much
c
2008
AI Access Foundation. rights reserved.

fiGimenez & Jonsson

easier solve. Helmert (2003) showed many benchmark problems used
International Planning Competition fact P NP.
common type structure researchers used characterize planning problems called causal graph (Knoblock, 1994). causal graph planning
problem graph captures degree independence among state variables
problem, easily constructed given description problem transformations. independence state variables exploited devise algorithms
efficiently solving planning problem. causal graph used tool
describing tractable subclasses planning problems (Brafman & Domshlak, 2003; Jonsson
& Backstrom, 1998; Williams & Nayak, 1997), decomposing planning problems
smaller problems (Brafman & Domshlak, 2006; Jonsson, 2007; Knoblock, 1994),
basis domain-independent heuristics guide search valid plan (Helmert,
2006).
present work explore computational complexity solving planning problems simple causal graphs. present new results three classes planning problems studied literature: class 3S (Jonsson & Backstrom, 1998), class Cn
(Domshlak & Dinitz, 2001), class planning problems polytree causal graphs
(Brafman & Domshlak, 2003). brief, show plan generation instances
first class solved polynomial time using macros, plan existence
solvable polynomial time remaining two classes, unless P = NP. work first
appeared conference paper (Gimenez & Jonsson, 2007); current paper provides
detail additional insights well new sections plan length CP-nets.
planning problem belongs class 3S causal graph acyclic state
variables either static, symmetrically reversible splitting (see Section 3 precise definition terms). class 3S introduced studied Jonsson
Backstrom (1998) example class plan existence easy (there exists
polynomial-time algorithm determines whether particular planning problem
class solvable) plan generation hard (there exists polynomial-time algorithm generates valid plan every planning problem class). precisely,
Jonsson Backstrom showed planning problems class 3S
every valid plan exponentially long. clearly prevents existence efficient
plan generation algorithm.
first contribution show plan generation 3S fact easy
allowed express valid plan using macros. macro simply sequence operators
macros. present polynomial-time algorithm produces valid plans
form planning problems class 3S. Namely, algorithm outputs polynomial
time system macros that, executed, produce actual valid plan planning
problem instance. algorithm sound complete, is, generates valid plan
one exists. contrast algorithm incremental algorithm proposed
Jonsson Backstrom (1998), polynomial size output.
investigate complexity class Cn planning problems multivalued state variables chain causal graphs. words, causal graph
directed path. Domshlak Dinitz (2001) showed solvable instances
class require exponentially long plans. However, case class 3S,
could exist efficient procedure generating valid plans Cn instances using
320

fiComplexity Planning Problems

macros novel idea. show plan existence Cn NP-hard, hence
ruling efficient procedure exists, unless P = NP.
prove plan existence planning problems whose causal graph polytree (i.e., underlying undirected graph acyclic) NP-complete, even restrict
problems binary variables. result closes complexity gap appears Brafman Domshlak (2003) regarding planning problems binary variables. authors
show plan existence NP-complete planning problems singly connected causal
graphs, plan generation polynomial planning problems polytree causal
graphs bounded indegree. use reduction prove similar problem
polytree CP-nets (Boutilier, Brafman, Domshlak, Hoos, & Poole, 2004) NP-complete.
1.1 Related Work
Several researchers used causal graph devise algorithms solving planning
problems study complexity planning problems. Knoblock (1994) used
causal graph decompose planning problem hierarchy increasingly abstract
problems. certain conditions, solving hierarchy abstract problems easier
solving original problem. Williams Nayak (1997) introduced several restrictions
planning problems ensure tractability, one causal graph
acyclic. Jonsson Backstrom (1998) defined class 3S planning problems,
requires causal graphs acyclic, showed plan existence polynomial
class.
Domshlak Dinitz (2001) analyzed complexity several classes planning
problems acyclic causal graphs. Brafman Domshlak (2003) designed polynomialtime algorithm solving planning problems binary state variables acyclic causal
graph bounded indegree. Brafman Domshlak (2006) identified conditions
possible factorize planning problem several subproblems solve
subproblems independently. claimed planning problem suitable
factorization causal graph bounded tree-width.
idea using macros planning almost old planning (Fikes & Nilsson,
1971). Minton (1985) developed algorithm measures utility plan fragments
stores macros deemed useful. Korf (1987) showed macros
exponentially reduce search space size planning problem chosen carefully. Vidal
(2004) used relaxed plans generated computing heuristics produce macros
contribute solution planning problems. Macro-FF (Botea, Enzenberger, Muller,
& Schaeffer, 2005), algorithm identifies caches macros, competed fourth
International Planning Competition. authors showed macros help reduce
search effort necessary generate valid plan.
Jonsson (2007) described algorithm uses macros generate plans planning
problems tree-reducible causal graphs. exist planning problems
algorithm generate exponentially long solutions polynomial time, algorithm 3S. Unlike ours, algorithm handle multi-valued variables, enables
solve problems Towers Hanoi. However, planning problems 3S
tree-reducible causal graphs, algorithm cannot used show plan generation
3S polynomial.
321

fiGimenez & Jonsson

1.2 Hardness Plan Length
contribution paper show plan generation may polynomial even
planning problems exponential length minimal solutions, provided solutions may
expressed using concise notation macros. motivate result
discuss consequences. Previously, thought plan generation planning
problems exponential length minimal solutions harder NP, since
known whether problems NP intractable, certain cannot generate
exponential length output polynomial time.
However, planning problem exponential length minimal solution,
clear plan generation inherently hard, difficulty lies fact
plan long. Consider two functional problems
f1 (F ) = w(1, 2|F | ),
f2 (F ) = w(t(F ), 2|F | ),
F 3-CNF formula, |F | number clauses F , w(, k) word containing
k copies symbol , t(F ) 1 F satisfiable (i.e., F 3Sat), 0
not. cases, problem consists generating correct word. Observe
f1 f2 provably intractable, since output exponential size input.
Nevertheless, intuitive regard problem f1 easier problem f2 . One way
formalize intuition allow programs produce output succinct
notation. instance, allow programs write w(,k) instead string containing
k copies symbol , problem f1 becomes polynomial, problem f2
(unless P = NP).
wanted investigate following question: regarding class 3S, plan generation intractable solution plans long, f1 , problem intrinsically hard, f2 ? answer plan generation 3S solved polynomial
time, provided one allowed give solution terms macros, macro
simple substitution scheme: sequence operators and/or macros. back
claim, present algorithm solves plan generation 3S polynomial time.
researchers argued intractability using fact plans may exponential length. Domshlak Dinitz (2001) proved complexity results several classes
planning problems multi-valued state variables simple causal graphs. argued
class Cn planning problems chain causal graphs intractable since plans
may exponential length. Brafman Domshlak (2003) stated plan generation
STRIPS planning problems unary operators acyclic causal graphs intractable
using reasoning. new result puts question argument used prove
hardness problems. reason, analyze complexity problems
prove hard showing plan existence problem NP-hard.

2. Notation
Let V set state variables, let D(v) finite domain state variable v V .
define state function V maps state variable v V value
s(v) D(v) domain. partial state p function subset Vp V state
322

fiComplexity Planning Problems

variables maps state variable v Vp p(v) D(v). subset C V
state variables, p | C partial state obtained restricting domain p Vp C.
Sometimes use notation (v1 = x1 , . . . , vk = xk ) denote partial state p defined
Vp = {v1 , . . . , vk } p(vi ) = xi vi Vp . write p(v) = denote v
/ Vp .
Two partial states p q match, denote pq, p | Vq = q | Vp ,
i.e., v Vp Vq , p(v) = q(v). define replacement operator q
r two partial states, p = q r partial state defined Vp = Vq Vr , p(v) = r(v)
v Vr , p(v) = q(v) v Vq Vr . Note that, general, p q 6= q p.
partial state p subsumes partial state q, denote p q, pq
Vp Vq . remark p q r s, follows p r q s. difference
two partial states q r, denote q r, partial state p defined
Vp = {v Vq | q(v) 6= r(v)} p(v) = q(v) v Vp .
planning problem tuple P = hV, init, goal, Ai, V set variables,
init initial state, goal partial goal state, set operators. operator
= hpre(a); post(a)i consists partial state pre(a) called pre-condition
partial state post(a) called post-condition. Operator applicable state
spre(a), applying operator state results new state post(a).
valid plan P sequence operators sequentially applicable state init
resulting state satisfies goal.
causal graph planning problem P directed graph (V, E) state variables
nodes. edge (u, v) E u 6= v exists operator
u Vpre(a) Vpost(a) v Vpost(a) .

3. Class 3S
Jonsson Backstrom (1998) introduced class 3S planning problems study
relative complexity plan existence plan generation. section, introduce
additional notation needed describe class 3S illustrate properties
3S planning problems. begin defining class 3S:
Definition 3.1 planning problem P belongs class 3S causal graph acyclic
state variable v V binary either static, symmetrically reversible,
splitting.
Below, provide formal definitions static, symmetrically reversible splitting.
Note fact causal graph acyclic implies operators unary, i.e.,
operator A, |Vpost(a) | = 1. Without loss generality, assume 3S planning
problems normal form, mean following:
state variable v, D(v) = {0, 1} init(v) = 0.
post(a) = (v = x), x {0, 1}, implies pre(a)(v) = 1 x.
satisfy first condition, relabel values D(v) initial goal
states well pre- post-conditions operators. satisfy second condition,
operator post(a) = (v = x) pre(a)(v) 6= 1 x, either remove
323

fiGimenez & Jonsson

v

V0

u
v=0
v

v=0

w=0
w
w=1

w

V*



u
v=0
v



(a)

v=0

w=0
w
w=1

w



V0



V1

w

(b)

Figure 1: Causal graph splitting variable partitions (a) v, (b) w.
pre(a)(v) = x, let pre(a)(v) = 1 x previously undefined. resulting planning
problem normal form equivalent original one. process done
time O(|A||V |).
following definitions describe three categories state variables 3S:
Definition 3.2 state variable v V static one following holds:
1. exist post(a)(v) = 1,
2. goal(v) = 0 exist post(a)(v) = 0.
Definition 3.3 state variable v V reversible
post(a) = (v = x), exists post(a ) = (v = 1 x). addition, v
symmetrically reversible pre(a ) | (V {v}) = pre(a) | (V {v}).
definitions follows value static state variable cannot
must change, whereas value symmetrically reversible state variable change
freely, long possible satisfy pre-conditions operators change
value. third category state variables splitting. Informally, splitting state variable
v splits causal graph three disjoint subgraphs, one depends value
v = 1, one depends v = 0, one independent v. However,
precise definition involved, need additional notation.
v V , let Qv0 subset state variables, different v, whose value
changed operator v = 0 pre-condition. Formally, Qv0 = {u V {v} |
s.t. pre(a)(v) = 0 u Vpost(a) }. Define Qv1 way v = 1. Let
Gv0 = (V, E0v ) subgraph (V, E) whose edges exclude v Qv0 Qv1 .
Formally, E0v = E {(v, w) | w Qv0 w
/ Qv1 }. Finally, let V0v V subset state
variables weakly connected state variable Qv0 graph Gv0 . Define
V1v way v = 1.
Definition 3.4 state variable v V splitting V0v V1v disjoint.
Figure 1 illustrates causal graph planning problem two splitting state
variables, v w. edge label v = 0 indicates operators changing
value u v = 0 pre-condition. words, Qv0 = {u, w}, graph
Gv0 = (V, E0v ) excludes two edges labeled v = 0, V0v includes state state variables,
324

fiComplexity Planning Problems

since v weakly connected u w connects remaining state variables. set
Qv1 empty since operators changing value state variable
v v = 1 pre-condition. Consequently, V1v empty well. Figure 1(a) shows
resulting partition v.
w
w
case w, Qw
0 = {s}, G0 = (V, E0 ) excludes edge labeled w = 0,
w
V0 = {s}, since state variable connected edge w = 0 removed.
Likewise, V1w = {t}. use Vw = V V0w V1w denote set remaining state
variables belong neither V0w V1w . Figure 1(b) shows resulting partition
w.
Lemma 3.5 splitting state variable v, two sets V0v V1v non-empty,
v belongs neither V0v V1v .
Proof contradiction. Assume v belongs V0v . v weakly connected
state variable Qv0 graph Gv0 = (V, E0v ). since E0v exclude edges
v Qv1 , state variable Qv1 weakly connected state variable
Qv0 Gv0 . Consequently, state variables Qv1 belong V0v V1v , contradicts
v splitting. reasoning holds show v belong V1v .
Lemma 3.6 value splitting state variable never needs change twice
valid plan.
Proof Assume valid plan changes value splitting state variable v
least three times. show reorder operators way
value v need change twice. need address three cases: v
belongs V0v (cf. Figure 1(a)), v belongs V1v , v belongs Vv (cf. Figure 1(b)).
v belongs V0v , follows Lemma 3.5 V1v empty. Consequently,
operator plan requires v = 1 pre-condition. Thus, safely remove
operators change value v, except possibly last, needed case
goal(v) = 1. v belongs V1v , follows Lemma 3.5 V0v empty. Thus,
operator plan requires v = 0 pre-condition. first operator changes
value v necessary set v 1. that, safely remove operators
change value v, except last case goal(v) = 0. cases resulting
plan contains two operators changing value v.
v belongs Vv , edges V0v , V1v , Vv v Vv
Qv0 V0v Qv1 V1v . Let 0 , 1 , subsequences operators
affect state variables V0v , V1v , Vv , respectively. Write = h , av1 , i, av1
last operator changes value v 0 1. claim reordering
h0 , , av1 , 1 , plan still valid. Indeed, operators 0 require v = 0,
holds initial state, operators 1 require v = 1, holds
due operator av1 . Note operators changing value v safely
removed since value v = 1 never needed pre-condition change value
state variable Vv . result valid plan changes value v twice
(its value may reset 0 ).

325

fiGimenez & Jonsson

Variable
v1
v2
v3
v4
v5
v6
v7
v8

Operators
av11 = h(v1 = 0); (v1 = 1)i
av01 = h(v1 = 1); (v1 = 0)i
av12 = h(v1 = 1, v2 = 0); (v2 = 1)i
av13 = h(v1 = 0, v2 = 1, v3 = 0); (v3 = 1)i
av15
av16
av06
av17
av18

= h(v3
= h(v3
= h(v3
= h(v6
= h(v6

= 0, v4
= 1, v6
= 1, v6
= 1, v7
= 0, v7

= 0, v5 = 0); (v5 = 1)i
= 0); (v6 = 1)i
= 1); (v6 = 0)i
= 0); (v7 = 1)i
= 1, v8 = 0); (v8 = 1)i

V0vi
V

V1vi
V


{v4 , v5 }
V {v4 }

V

V
{v6 , v7 , v8 }


V




V


Table 1: Operators sets V0vi V1vi example planning problem.

v4
v1

v5
v7

v3
v6

v2

v8

Figure 2: Causal graph example planning problem.
previous lemma, holds splitting state variables general, provides
additional insight solve planning problem splitting state variable v.
First, try achieve goal state state variables V0v value v 0,
initial state. Then, set value v 1 try achieve goal state state
variables V1v . Finally, goal(v) = 0, reset value v 0.
3.1 Example
illustrate class 3S using example planning problem. set state variables
V = {v1 , . . . , v8 }. Since planning problem normal form, initial state
init(vi ) = 0 vi V . goal state defined goal = (v5 = 1, v8 = 1),
operators listed Table 1. Figure 2 shows causal graph (V, E)
planning problem. operators easy verify v4 static v1
v6 symmetrically reversible. planning problem 3S, remaining
state variables splitting. Table 1 lists two sets V0vi V1vi state
variable vi V show indeed, V0vi V1vi = state variables set
{v2 , v3 , v5 , v7 , v8 }.
326

fiComplexity Planning Problems

4. Plan Generation 3S
section, present polynomial-time algorithm plan generation 3S.
algorithm produces solution instance 3S form system macros.
idea construct unary macros change value single state variable.
macros may change values state variables execution, always reset
terminating. macros generated, goal achieved
one state variable time. show algorithm generates valid plan
one exists.
begin defining macros use paper. Next, describe
algorithm pseudo-code (Figures 3, 4, 5) prove correctness. facilitate
reading moved straightforward involving proof appendix. Following
description algorithm analyze complexity steps involved.
follows, assume 3S planning problems normal form defined previous
section.
4.1 Macros
macro-operator, macro short, ordered sequence operators viewed unit.
operator sequence respect pre-conditions operators follow
it, pre-condition operator sequence violated. Applying macro
equivalent applying operators sequence given order. Semantically,
macro equivalent standard operator pre-condition postcondition, unambiguously induced pre- post-conditions operators
sequence.
Since macros functionally operators, operator sequence associated macro
include macros, long create circular definition. Consequently,
possible create hierarchies macros operator sequences macros
one level include macros level below. solution planning problem
viewed macro sits top hierarchy.
define macros first introduce concept induced pre- post-conditions
operator sequences. = ha1 , . . . , ak operator sequence, write , 1 k,
denote subsequence ha1 , . . . , ai i.
Definition 4.1 operator sequence = ha1 , . . . , ak induces pre-condition pre() =
pre(ak ) pre(a1 ) post-condition post() = post(a1 ) post(ak ). addition,
operator sequence well-defined (pre(i1 )post(i1 ))pre(ai )
1 < k.
follows, assume P = (V, init, goal, A) planning problem
Vpost(a) Vpre(a) operator A, = ha1 , . . . , ak operator sequence.
Lemma 4.2 planning problem P type , Vpost() Vpre() .
Proof direct consequence definitions Vpre() = Vpre(a1 ) Vpre(ak ) Vpost() =
Vpost(a1 ) Vpost(ak ) .
327

fiGimenez & Jonsson

Lemma 4.3 operator sequence applicable state well-defined
spre(). state sk resulting application sk = post().
Proof induction k. result clearly holds k = 1. k > 1, note
pre() = pre(ak ) pre(k1 ), post() = post(k1 ) post(ak ), well-defined
k1 well-defined (pre(k1 ) post(k1 ))pre(ak ).
hypothesis induction state sk1 resulting application k1
sk1 = post(k1 ). follows sk = sk1 post(ak ) = post().
Assume applicable state s. means k1 applicable ak
applicable sk1 = post(k1 ). hypothesis induction, former implies
spre(k1 ) k1 well-defined, latter (s post(k1 ))pre(ak ).
last condition implies (pre(k1 ) post(k1 ))pre(ak ) use pre(k1 ) s,
consequence spre(k1 ) total state. Finally, deduce
s(pre(ak ) pre(k1 )) spre(k1 ) (s post(k1 ))pre(ak ), using
Vpost(k1 ) Vpre(k1 ) . follows well-defined spre().
Conversely, assume well-defined spre(). implies k1
well-defined spre(k1 ), hypothesis induction, k1 applicable state s.
remains show ak applicable state sk1 , is, (s post(k1 ))pre(ak ).
(pre(k1 ) post(k1 ))pre(ak ) follows post(k1 )pre(ak ). fact
s(pre(ak ) pre(k1 )) Vpost(k1 ) Vpre(k1 ) completes proof.
Since macros induced pre- post-conditions, Lemmas 4.2 4.3 trivially extend
case operator sequence includes macros. ready
introduce definition macros:
Definition 4.4 macro sequence = ha1 , . . . , ak operators macros
induces pre-condition pre(m) = pre() post-condition post(m) = post()
pre(). macro well-defined circular definitions occur
well-defined.
make macros consistent standard operators, induced post-condition
include state variables whose values indeed changed macro, achieved
computing difference post() pre(). particular, holds
3S planning problem normal form, derived macros satisfy second condition normal
form, namely post(m) = (v = x), x {0, 1}, implies pre(m)(v) = 1 x.
Definition 4.5 Let Ancv set ancestors state variable v 3S planning
problem. define partial state prev Vprev = Ancv
1. prev (u) = 1 u Ancv splitting v V1u ,
2. prev (u) = 0 otherwise.
Definition 4.6 macro 3S-macro well-defined and, x {0, 1}, post(m) =
(v = x) pre(m) prev (v = 1 x).
328

fiComplexity Planning Problems

Macro
mv11
mv01
mv12
mv13
mv15
mv16
mv06
mv17
mv18

Sequence

Pre-condition

hav11
hav01
hmv11 , av12 , mv01
hav13
hav15
hav16
hav06
hmv16 , av17 , mv06
hav18

(v1
(v1
(v1
(v1
(v3
(v3
(v3
(v3
(v3

= 0)
= 1)
= 0, v2
= 0, v2
= 0, v4
= 1, v6
= 1, v6
= 1, v6
= 1, v6

= 0)
= 1, v3
= 0, v5
= 0)
= 1)
= 0, v7
= 0, v7

Post-condition

= 0)
= 0)

= 0)
= 1, v8 = 0)

(v1
(v1
(v2
(v3
(v5
(v6
(v6
(v7
(v8

= 1)
= 0)
= 1)
= 1)
= 1)
= 1)
= 0)
= 1)
= 1)

Table 2: Macros generated algorithm example planning problem.

algorithm present generates 3S-macros. fact, generates one
macro = mvx post(m) = (v = x) state variable v value x {0, 1}.
illustrate idea 3S-macros give flavor algorithm, Table 2 lists macros
generated algorithm example 3S planning problem previous section.
claim macro 3S-macro. example, operator sequence hav16
induces pre-condition (v3 = 1, v6 = 0) post-condition (v3 = 1, v6 = 0) (v6 = 1) =
(v3 = 1, v6 = 1). Thus, macro mv16 induces pre-condition pre(mv16 ) = (v3 = 1, v6 = 0)
post-condition post(mv16 ) = (v3 = 1, v6 = 1) (v3 = 1, v6 = 0) = (v6 = 1). Since v2
v3 splitting since v6 V1v2 v6 V1v3 , follows prev6 (v6 = 0) =
(v1 = 0, v2 = 1, v3 = 1, v6 = 0), pre(mv16 ) = (v3 = 1, v6 = 0) prev6 (v6 = 0).
macros combined produce solution planning problem. idea
identify state variable v goal(v) = 1 append macro mv1
solution plan. example, results operator sequence hmv15 , mv18 i. However,
pre-condition mv18 specifies v3 = 1 v7 = 1, makes necessary insert mv13
mv17 mv18 . addition, pre-condition mv13 specifies v2 = 1, makes
necessary insert mv12 mv13 , resulting final plan hmv15 , mv12 , mv13 , mv17 , mv18 i.
Note order macros matter; mv15 requires v3 0 mv18 requires
v3 1. splitting state variable v, goal state achieved state
variables V0v value v set 1. expand solution plan
consists solely operators A. example, results operator sequence
hav15 , av11 , av12 , av01 , av13 , av16 , av17 , av06 , av18 i. case, algorithm generates optimal
plan, although true general.
4.2 Description Algorithm
proceed providing detailed description algorithm plan generation 3S.
first describe subroutine generating unary macro sets value state
variable v x. algorithm, call GenerateMacro, described Figure 3.
algorithm takes input planning problem P , state variable v, value x (either 0
329

fiGimenez & Jonsson

1
2
3
4
5
6
7
8
9
10
11
12
13
14

function GenerateMacro(P , v, x, )
post(a)(v) = x
S0 S1 hi
satisf true
U {u Vpre(a) {v} | pre(a)(u) = 1}
u U increasing topological order
u static mu1
/
satisf false
else u splitting mu0 mu1
S0 hS0 , mu0
S1 hmu1 , S1
satisf
return hS1 , a, S0
return f ail
Figure 3: Algorithm generating macro sets value v x.

1), set macros vs ancestors causal graph. Prior executing
algorithm, perform topological sort state variables. assume that,
v V x {0, 1}, contains one macro mvx post(mvx ) = (v = x).
algorithm, use notation mvx test whether contains mvx .
operator sets value v x, algorithm determines whether
possible satisfy pre-condition pre(a) starting initial state. this,
algorithm finds set U state variables pre(a) assigns 1 (the values
state variables already satisfy pre(a) initial state). algorithm constructs two
sequences operators, S0 S1 , going state variables U increasing
topological order. operator sequence, use hS, oi shorthand denote
operator sequence length |S| + 1 consisting operators followed o,
either operator macro. possible satisfy pre-condition pre(a)
operator A, algorithm returns macro hS1 , a, S0 i. Otherwise, returns f ail.
Lemma 4.7 v symmetrically reversible GenerateMacro(P , v, 1, ) successfully generates macro, GenerateMacro(P , v, 0, ).
Proof Assume GenerateMacro(P , v, 1, ) successfully returns macro hS1 , a, S0
operator post(a) = 1. definition symmetrically
reversible follows exists operator post(a ) = 0
pre(a ) | V {v} = pre(a) | V {v}. Thus, set U identical .
consequence, values S0 , S1 , satisf loop,
means GenerateMacro(P , v, 0, ) returns macro hS1 , , S0 . Note
GenerateMacro(P , v, 0, ) may return another macro goes operators different order; however, guaranteed successfully return macro.
Theorem 4.8 macros 3S-macros GenerateMacro(P , v, x, )
generates macro mvx 6= f ail, mvx 3S-macro.
330

fiComplexity Planning Problems

1
2
3
4
5
6
7
8
9
10

function Macro-3S(P )

v V increasing topological order
mv1 GenerateMacro(P , v, 1, )
mv0 GenerateMacro(P , v, 0, )
mv1 6= f ail mv0 6= f ail
{mv1 , mv0 }
else mv1 6= f ail goal(v) 6= 0
{mv1 }
return GeneratePlan(P , V , )
Figure 4: algorithm Macro-3S.
proof Theorem 4.8 appears Appendix A.

Next, describe algorithm plan generation 3S, call Macro-3S.
Figure 4 shows pseudocode Macro-3S. algorithm goes state variables
increasing topological order attempts generate two macros state variable
v, mv1 mv0 . macros successfully generated, added current
set macros . mv1 generated goal state assign 0 v,
algorithm adds mv1 . Finally, algorithm generates plan using subroutine
GeneratePlan, describe later.
Lemma 4.9 Let P 3S planning problem let v V state variable.
exists valid plan solving P sets v 1, Macro-3S(P ) adds macro mv1 .
If, addition, plan resets v 0, Macro-3S(P ) adds mv0 .
Proof First note mv1 mv0 generated, Macro-3S(P ) adds .
mv1 generated mv0 , Macro-3S(P ) adds mv1 unless goal(v) = 0. However,
goal(v) = 0 contradicts fact valid plan solving P sets v 1
without resetting 0. remains show GenerateMacro(P , v, 1, ) always
generates mv1 6= f ail GenerateMacro(P , v, 0, ) always generates mv0 6= f ail
plan resets v 0.
plan solving P sets v 1 contain operator
post(a)(v) = 1. plan resets v 0, contain operator
post(a )(v) = 0. show GenerateMacro(P , v, 1, ) successfully generates
mv1 6= f ail operator selected line 2. Note algorithm may return another
macro selects another operator a; however, always generates macro a,
guaranteed successfully return macro mv1 6= f ail. true mv0 .
prove lemma induction state variables v. v ancestors
causal graph, set U empty default. Thus, satisf never set false
GenerateMacro(P , v, 1, ) successfully returns macro mv1 = hai a. exists,
GenerateMacro(P , v, 0, ) successfully returns mv0 = ha .
v ancestors causal graph, let U = {u Vpre(a) {v} | pre(a)(u) = 1}.
Since plan contains set u U 1. hypothesis induction,
Macro-3S(P ) adds mu1 u U . consequence, satisf never set
331

fiGimenez & Jonsson

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

function GeneratePlan(P , W , )
|W | = 0
return hi
v first variable topological order present W
v splitting
v0 Generate-Plan(P , W (V0v {v}), )
v1 Generate-Plan(P , W (V1v {v}), )
v Generate-Plan(P , W (V V0v V1v {v}), )
v0 = f ail v1 = f ail v = f ail (goal(v) = 1 mv1
/ )
return f ail
else mv1
/ return hv , v0 , v1
else goal(v) = 0 return hv , v0 , mv1 , v1 , mv0
else return hv , v0 , mv1 , v1
Generate-Plan(P , W {v}, )
= f ail (goal(v) = 1 mv1
/ ) return f ail
else goal(v) = 1 return h, mv1
else return
Figure 5: Algorithm generating final plan

false thus, GenerateMacro(P , v, 1, ) successfully returns mv1 a. exists,
let W = {w Vpre(a ) {v} | pre(a )(w) = 1}. plan contains , set
w W 1. hypothesis induction, Macro-3S(P ) adds mw
1 w W
consequently, GenerateMacro(P , v, 0, ) successfully returns mv0 .
Finally, describe subroutine GeneratePlan(P , W , ) generating final
plan given planning problem P , set state variables W set macros .
set state variables empty, GeneratePlan(P , W , ) returns empty operator
sequence. Otherwise, finds state variable v W comes first topological order.
v splitting, algorithm separates W three sets described V0v , V1v ,
Vv = V V0v V1v . algorithm recursively generates plans three sets
necessary, inserts mv1 V0v V1v final plan. case,
algorithm recursively generates plan W {v}. goal(v) = 1 mv1 , algorithm
appends mv1 end resulting plan.
Lemma 4.10 Let W plan generated GeneratePlan(P , W , ), let v
first state variable topological order present W , let V = ha , W , b final
plan generated Macro-3S(P ). mv1 follows (pre(a )post(a ))pre(mv1 ).
Proof determine content operator sequence precedes W final
plan inspection. Note call GeneratePlan(P , W , ) nested within
sequence recursive calls GeneratePlan starting GeneratePlan(P , V , ).
Let Z set state variables u Z first state variable
topological order call GeneratePlan prior GeneratePlan(P , W , ).
u Z correspond call GeneratePlan set state variables
U W U . u splitting, u contribute since
332

fiComplexity Planning Problems

possible addition macro plan line 16 places macro mu1 end
plan generated recursively.
Assume u Z splitting state variable. three cases: W V0u , W V1u ,
W Vu = V V0u V1u . W Vu , u contribute since never places
macros u . W V0u , plan u part since precedes u0 lines 11,
12, 13. W V1u , plans u u0 part since precede u1
cases. mu1 , macro mu1 part since precedes u1 lines 12
13. macros part .
Since macros unary, plan generated GeneratePlan(P , U , )
changes values state variables U . splitting state variable u,
edges Vu {u} V0u , Vu {u} V1u , V0u V1u . follows
plan u change value state variable appears pre-condition
macro u0 . holds u respect u1 u0 respect u1 .
Thus, macro changes value splitting state variable u Ancv
mu1 case W V1u .
Recall prev defined Ancv assigns 1 u u splitting
v V1u . ancestors v, value 0 holds initial state
altered . u splitting v V1u , follows definition 3S-macros
pre(mv1 )(u) = 1 pre(mv1 )(u) =. pre(mv1 )(u) = 1, correct append mu1
mv1 satisfy pre(mv1 )(u). mu1
/ follows u
/ Vpre(mv1 ) , since pre(mv1 )(u) = 1
would caused GenerateMacro(P , v, 1, ) set satisf false line 8. Thus,
pre-condition pre(mv1 ) mv1 agrees pre(a ) post(a ) value state
variable, means two partial states match.
Lemma 4.11 GeneratePlan(P , V , ) generates well-defined plan.
Proof Note state variable v V , GeneratePlan(P , W , ) called
precisely v first state variable topological order. Lemma 4.10
follows (pre(a ) post(a ))pre(mv1 ), plan precedes W
final plan. Since v first state variable topological order W , plans v0 ,
v1 , v , , recursively generated GeneratePlan, change value
state variable pre(mv1 ). follows mv1 applicable following ha , v , v0 ha , i.
Since mv1 changes value v, mv0 applicable following ha , v , v0 , mv1 , v1 i.
Theorem 4.12 Macro-3S(P ) generates valid plan solving planning problem 3S
one exists.
Proof GeneratePlan(P , V , ) returns f ail exists state variable
v V goal(v) = 1 mv1
/ . Lemma 4.9 follows
exist valid plan solving P sets v 1. Consequently, exist
plan solving P . Otherwise, GeneratePlan(P , V , ) returns well-defined plan due
Lemma 4.11. Since plan sets 1 state variable v goal(v) = 1
resets 0 state variable v goal(v) = 0, plan valid plan solving
planning problem.
333

fiGimenez & Jonsson

v1

v2

v3

v4

v5

Figure 6: Causal graph planning problem P5 .
4.3 Examples
illustrate algorithm example introduced Jonsson Backstrom (1998)
show instances 3S exponentially sized minimal solutions. Let Pn =
hV, init, goal, Ai planning problem defined natural number n, V = {v1 , . . . , vn },
goal state defined Vgoal = V , goal(vi ) = 0 vi {v1 , . . . , vn1 },
goal(vn ) = 1. state variable vi V , two operators A:
av1i = h(v1 = 0, . . . , vi2 = 0, vi1 = 1, vi = 0); (vi = 1)i,
av0i = h(v1 = 0, . . . , vi2 = 0, vi1 = 1, vi = 1); (vi = 0)i.
words, state variable symmetrically reversible. causal graph planning problem P5 shown Figure 6. Note state variable vi {v1 , . . . , vn2 },
v
v
pre(a1i+1 )(vi ) = 1 pre(a1i+2 )(vi ) = 0, vi+1 Qv1i vi+2 Q0vi . Since
edge causal graph vi+1 vi+2 , state variable {v1 , . . . , vn2 }
v
splitting. hand, vn1 vn splitting since V0 n1 = V0vn = V1vn = .
Backstrom Nebel (1995) showed length shortest plan solving Pn 2n 1,
i.e., exponential number state variables.
state variable vi {v1 , . . . , vn1 }, algorithm generates two macros mv1i
vi
m0 . single operator, av1i , changes value vi 0 1. pre(av1i )
assigns 1 vi1 , U = {vi1 }. Since vi1 splitting, mv1i defined mv1i =
v
v
v
v
hm1i1 , av1i , m0i1 i. Similarly, mv0i defined mv0i = hm1i1 , av0i , m0i1 i. state variable
vn , U = {vn1 }, splitting, mv1n defined mv1n = hav1n i.
generate final plan, algorithm goes state variables topological order. state variables v1 vn2 , algorithm nothing, since
state variables splitting goal state 1. state variable vn1 ,
algorithm recursively generates plan vn , hmv1n since goal(vn ) = 1.
v
Since goal(vn1 ) = 0, algorithm inserts m1n1 mv1n satisfy pre-condition
v
vn1 = 1 m0n1 mv1n achieve goal state goal(vn1 ) = 0. Thus, final plan
vn1
v
vn
hm1 , m1 , m0n1 i. expand plan, end sequence 2n 1 operators. However, individual macro operator sequence length greater 3. Together,
macros recursively specify complete solution planning problem.
demonstrate planning problems 3S polynomial length
solutions algorithm may generate exponential length solutions. this,
modify planning problem Pn letting goal(vi ) = 1 vi V . addition,
state variable vi V , add two operators A:
bv1i = h(v1 = 1, . . . , vi1 = 1, vi = 0); (vi = 1)i,
bv0i = h(v1 = 1, . . . , vi1 = 1, vi = 1); (vi = 0)i.
334

fiComplexity Planning Problems

add operator cv1n = h(vn1 = 0, vn = 0); (vn = 1)i A. consequence, state variables {v1 , . . . , vn2 } still symmetrically reversible splitting.
vn1 symmetrically reversible longer splitting, since pre(av1n )(vn1 ) = 1
v
v
pre(cv1n )(vn1 ) = 0 implies vn V0 n1 V1 n1 . vn still splitting since V0vn = V1vn = .
Assume GenerateMacro(P , vi , x, ) always selects bvxi first. consequence,
state variable vi V x {0, 1}, GenerateMacro(P , vi , x, ) generates
v
v
macro mvxi = hm1i1 , . . . , mv11 , bvxi , mv01 , . . . , m0i1 i.
Let Li length plan represented mvxi , x {0, 1}. definition
v

mx Li = 2(L1 + . . . + Li1 ) + 1. show induction Li = 3i1 .
length macro v1 L1 = 1 = 30 . > 1,
Li = 2(30 + . . . + 3i2 ) + 1 = 2

3i1 1
3i1 1
+1=2
+ 1 = 3i1 1 + 1 = 3i1 .
31
2

generate final plan algorithm change value state variable
0 1, total length plan L = L1 + . . . + Ln = 30 + . . . + 3n1 =
(3n 1)/2. However, exists plan length n solves planning problem,
namely hbv11 , . . . , bv1n i.
4.4 Complexity
section prove complexity algorithm polynomial.
analyze step algorithm separately. summary complexity result
step algorithm given below. Note number edges |E| causal
graph O(|A||V |), since operator may introduce O(|V |) edges. complexity result
O(|V | + |E|) = O(|A||V |) topological sort follows Cormen, Leiserson, Rivest,
Stein (1990).
Constructing causal graph G = (V, E)
Calculating V1v V0v v V
Performing topological sort G
GenerateMacro(P , v, x, )
GeneratePlan(P , V , )
Macro-3S(P )

O(|A||V |)
O(|A||V |2 )
O(|A||V |)
O(|A||V |)
O(|V |2 )
O(|A||V |2 )

Lemma 4.13
Lemma 4.14
Lemma 4.15
Lemma 4.16
Theorem 4.17

Lemma 4.13 complexity constructing causal graph G = (V, E) O(|A||V |).
Proof causal graph consists |V | nodes. operator state
variable u Vpre(a) , add edge u unique state variable v Vpost(a) .
worst case, |Vpre(a) | = O(|V |), case complexity O(|A||V |).
Lemma 4.14 complexity calculating sets V0v V1v state variable
v V O(|A||V |2 ).
Proof state variable v V , establish sets Qv0 Qv1 , requires
going operator worst case. Note interested
pre-condition v unique state variable Vpost(a) , means
335

fiGimenez & Jonsson

need go state variable Vpre(a) . Next, construct graph Gv0 .
copying causal graph G, takes time O(|A||V |), removing
edges v Qv0 Qv1 , takes time O(|V |).
Finally, construct set V0v find state variable weakly connected state variable u Qv0 graph Gv0 . state variable u Qv0 ,
performing undirected search starting u takes time O(|A||V |). performed search starting u, need search state variables Qv0
reached search. way, total complexity search exceed
O(|A||V |). case constructing V1v identical. Since perform
procedure state variable v V , total complexity step O(|A||V |2 ).
Lemma 4.15 complexity GenerateMacro(P , v, x, ) O(|A||V |).
Proof operator A, GenerateMacro(P , v, x, ) needs check whether
post(a)(v) = x. worst case, |U | = O(|V |), case complexity
algorithm O(|A||V |).
Lemma 4.16 complexity GeneratePlan(P , V , ) O(|V |2 ).
Proof Note state variable v V , GeneratePlan(P , V , ) called recursively exactly v first variable topological order. words,
GeneratePlan(P , V , ) called exactly |V | times. GeneratePlan(P , V , ) contains
constant operations except intersection difference sets lines 6-8.
Since intersection set difference done time O(|V |), total complexity
GeneratePlan(P , V , ) O(|V |2 ).
Theorem 4.17 complexity Macro-3S(P ) O(|A||V |2 ).
Proof Prior executing Macro-3S(P ), necessary construct causal graph G,
find sets V0v V1v state variable v V , perform topological sort
G. shown steps take time O(|A||V |2 ). state variable
v V , Macro-3S(P ) calls GenerateMacro(P , v, x, ) twice. Lemma 4.15
follows step takes time O(2|V ||A||V |) = O(|A||V |2 ). Finally, Macro-3S(P ) calls
GeneratePlan(P , V , ), takes time O(|V |2 ) due Lemma 4.16. follows
complexity Macro-3S(P ) O(|A||V |2 ).
conjecture possible improve complexity result Macro3S(P ) O(|A||V |). However, proof seems somewhat complex, main objective
devise algorithm efficient possible. Rather, interested
establishing algorithm polynomial, follows Theorem 4.17.
4.5 Plan Length
section study length plans generated given algorithm. begin
with, derive general bound length plans. Then, show compute
actual length particular plan without expanding macros. present
algorithm uses computation efficiently obtain i-th action plan
336

fiComplexity Planning Problems

macro form. start introducing concept depth state variables
causal graph.
Definition 4.18 depth d(v) state variable v longest path v
state variable causal graph.
Since causal graph acyclic planning problems 3S, depth state variable
unique computed polynomial time. Also, follows least one state
variable depth 0, i.e., outgoing edges.
Definition 4.19 depth planning problem P 3S equals largest depth
state variable v P , i.e., = maxvV d(v).
characterize planning problem based depth state variables. Let
n = |V | number state variables, let ci denote number state variables
depth i. planning problem depth d, follows c0 + . . . + cd = n.
example, consider planning problem whose causal graph appears Figure 2.
planning problem, n = 8, = 5, c0 = 2, c1 = 2, c2 = 1, c3 = 1, c4 = 1, c5 = 1.
Lemma 4.20 Consider values Li {0, . . . , d} defined Ld = 1, Li =
2(ci+1 Li+1 + ci+2 Li+2 + . . . + cd Ld ) + 1 < d. values Li upper bound
length macros generated algorithm state variable v depth i.
Proof prove decreasing induction value i. Assume v depth = d.
follows Definition 4.18 v incoming edges. Thus, operator changing
value v pre-condition state variable v, Ld = 1 upper
bound, stated.
Now, assume v depth < d, Li+k k > 0 upper bounds
length corresponding macros. Let operator changes value v.
definition depth follows cannot pre-condition state variable
u depth j i; otherwise would edge u v causal graph, causing
depth u greater i. Thus, worst case, macro v change
values state variables depths larger i, change value v, reset
values state variables lower levels. follows Li = 2(ci+1 Li+1 + . . . + cd Ld ) + 1
upper bound.
Theorem 4.21 upper bounds Li Lemma 4.20 satisfy Li = dj=i+1 (1 + 2cj ).
Proof Note
Li = 2(ci+1 Li+1 + ci+2 Li+2 + . . . + cd Ld ) + 1 =
= 2ci+1 Li+1 + 2(ci+2 Li+2 + . . . + cd Ld ) + 1 =
= 2ci+1 Li+1 + Li+1 = (2ci+1 + 1)Li+1 .
result easily follows induction.
337

fiGimenez & Jonsson

obtain upper bound L total length plan. worst
case, goal state assigns different value state variable initial state,
i.e., goal(v) 6= init(v) v V . achieve goal state algorithm applies one
macro per state variable. Hence
L = c0 L0 + c1 L1 + . . . + cd Ld = c0 L0 +


L0 1
(1 + 2c0 )L0 1
1Y
1
=
=
(1 + 2cj ) .
2
2
2
2
j=0

previous bound depends distribution variables depths according
causal graph. obtain general bound depend depths
variables first find distribution maximizes upper bound L.
Q
Lemma 4.22 upper bound L = 21 dj=0 (1+2cj ) 12 planning problems n variables
depth maximized ci equal, is, ci = n/(d + 1).
Proof Note ci > 0 i, c0 + + cd = n. result follows direct
application well known AM-GM (arithmetic mean-geometric mean) inequality,
states arithmetic mean positive values xi greater equal geometric
mean, equality xi same.
implies product positive
P
factors xi = (1 + 2ci ) fixed sum = dj=0 xj = 2n + maximized
equal, is, ci = n/(d + 1).
Theorem 4.23 length plan generated algorithm planning problem
3S n state variables depth ((1 + 2n/(d + 1))d+1 1)/2.
Proof direct consequence Lemma 4.22. Since c0 , . . . , cd discrete, may
possible set c0 = . . . = cd = n/(d + 1). Nevertheless, ((1 + 2n/(d + 1))d+1 1)/2
upper bound L case.
Observe bound established Theorem 4.23 increasing function d.
implies given d, bound applies planning problems 3S depth
smaller d. consequence, depth planning problem 3S bounded
d, algorithm generates solution plan planning problem
polynomial length O(nd+1 ). Since complexity executing plan proportional
plan length, use depth define tractable complexity classes planning
problems 3S respect plan execution.
Theorem 4.24 length plan generated algorithm planning problem
3S n state variables (3n 1)/2.
Proof worst case, depth planning problem n1. follows Theorem
4.23 length plan ((1 + 2n/n)n 1)/2 = (3n 1)/2.
Note bound established Theorem 4.24 tight; second example Section
4.3, showed algorithm generates plan whose length (3n 1)/2.
338

fiComplexity Planning Problems

1
2
3
4
5
6
7
8
9

function Operator(S, i)
first operator
length(o) <
length(o)
next operator
primitive(o)
return
else
return Operator(o, i)
Figure 7: algorithm determining i-th operator sequence

Lemma 4.25 complexity computing total length plan generated
algorithm O(|V |2 ).
Proof algorithm generates 2|V | = O(|V |) macros, 2 state variable.
operator sequence macro consists one operator 2(|V | 1) = O(|V |)
macros. use dynamic programming avoid computing length macro
once. worst case, compute length O(|V |) macros,
sum O(|V |) terms, resulting total complexity O(|V |2 ).
Lemma 4.26 Given solution plan length l integer 1 l, complexity
determining i-th operator plan O(|V |2 ).
Proof prove lemma providing algorithm determining i-th operator,
appears Figure 7. Since operator sequences consist operators macros,
variable represents either operator macro generated Macro-3S.
function primitive(o) returns true operator f alse macro. function
length(o) returns length macro, 1 otherwise. assume length
macros pre-computed, know Lemma 4.25 takes time O(|V |2 ).
algorithm simply finds operator macro i-th position sequence,
taking account length macros sequence. i-th position part
macro, algorithm recursively finds operator appropriate position
operator sequence represented macro. worst case, algorithm go
O(|V |) operators sequence call Operator recursively O(|V |) times,
resulting total complexity O(|V |2 ).
4.6 Discussion
general view plan generation output consist valid sequence
grounded operators solves planning problem. contrast, algorithm generates
solution plan form system macros. One might argue truly solve
plan generation problem, algorithm expand system macros arrive
sequence underlying operators. case, algorithm would longer polynomial,
since solution plan planning problem 3S may exponential length. fact,
objective execute solution plan once, algorithm offers marginal
benefit incremental algorithm proposed Jonsson Backstrom (1998).
339

fiGimenez & Jonsson

hand, several reasons view system macros generated
algorithm complete solution planning problem 3S. macros collectively
specify steps necessary reach goal. solution plan generated
verified polynomial time, plan stored reused using polynomial memory.
even possible compute length resulting plan determine i-th
operator plan polynomial time shown Lemmas 4.25 4.26. Thus,
practical purposes system macros represents complete solution. Even
objective execute solution plan once, algorithm faster
Jonsson Backstrom (1998). necessary execute plan generated
algorithm maintain stack currently executing macros select next operator
execute, whereas algorithm Jonsson Backstrom perform several steps
operator output.
Jonsson Backstrom (1998) proved bounded plan existence problem 3S
NP-hard. bounded plan existence problem problem determining whether
exists valid solution plan length k. consequence, optimal
plan generation problem 3S NP-hard well; otherwise, would possible
solve bounded plan existence problem generating optimal plan comparing
length resulting plan k. examples seen algorithm
generate optimal plan general. fact, algorithm bad
incremental algorithm Jonsson Backstrom, sense algorithms may
generate exponential length plans even though exists solution polynomial length.
Since algorithm makes possible compute total length valid solution
polynomial time, used generate heuristics planners. Specifically,
Katz Domshlak (2007) proposed projecting planning problems onto provably tractable
fragments use solution fragments heuristics original problem.
shown 3S tractable fragment. Unfortunately, optimal planning
3S NP-hard, hope generating admissible heuristic. However,
heuristic may still informative guiding search towards solution original
problem. addition, planning problems exponential length optimal solutions,
standard planner hope generating heuristic polynomial time, making
macro-based approach (and Jonsson, 2007) (current) viable option.

5. Class Cn
Domshlak Dinitz (2001) defined class Cn planning problems multi-valued
state variables chain causal graphs. Since chain causal graphs acyclic, follows
operators unary. Moreover, let vi i-th state variable chain. > 1,
operator Vpost(a) {vi } holds Vpre(a) = {vi1 , vi }. words,
operator changes value state variable vi may pre-conditions
vi1 vi .
authors showed instances Cn exponentially sized minimal
solutions, therefore argued class intractable. light previous section,
argument length solutions discard possibility instances
class solved polynomial time using macros. show
case, unless P = NP.
340

fiComplexity Planning Problems

v1

vk

w

Figure 8: Causal graph P (F ).
C1

C1, C1

0,1
Cn,Cn
Cn

C1

0,1
0





0,1



1

C1, C1
0,1

Cn,Cn

Cn

Figure 9: Domain transition graph vi .
define decision problem Plan-Existence-Cn follows. valid input PlanExistence-Cn planning instance P Cn . input P belongs Plan-ExistenceCn P solvable. show section problem Plan-ExistenceCn NP-hard. implies that, unless P = NP, solving instances Cn truly
intractable problem, namely, polynomial-time algorithm distinguish solvable
unsolvable instances Cn . particular, polynomial-time algorithm solve Cn
instances using macros kind output format.1
prove Plan-Existence-Cn NP-hard reduction Cnf-Sat, is,
problem determining whether CNF formula F satisfiable. Let C1 , . . . , Cn
clauses CNF formula F , let v1 , . . . , vk variables appear F .
briefly describe intuition behind reduction. planning problem create
formula F state variable variable appearing F , plans forced
commit value (either 0 1) state variables actually using them. Then,
satisfy goal problem, variables used pass messages. However,
operators defined way plan succeed
state variable values committed satisfying assignment F .
proceed describe reduction. First ,we define planning problem P (F ) =
hV, init, goal, Ai follows. set state variables V = {v1 , . . . , vk , w}, D(vi ) =
{S, 0, 1, C1 , C1 , . . . , Cn , Cn } vi D(w) = {S, 1, . . . , n}. initial state defines
init(v) = v V goal state defines goal(w) = n. Figure 8 shows
causal graph P (F ).
domain transition graph state variable vi shown Figure 9. node
represents value D(vi ), edge x means exists operator
pre(a)(vi ) = x post(a)(vi ) = y. Edge labels represent pre-condition
operators state variable vi1 , multiple labels indicate several operators
associated edge. enumerate operators acting vi using notation
= hpre(a); post(a)i (when = 1 mention vi1 understood void):
1. valid output format one enables efficient distinction output representing valid
plan output representing fact solution found.

341

fiGimenez & Jonsson



C1, C1

n1

1

Cn,Cn

n

Figure 10: Domain transition graph w.
(1) Two operators hvi1 = S, vi = S; vi = 0i hvi1 = S, vi = S; vi = 1i allow vi
move either 0 1.
(2) > 1. clause Cj X {Cj , Cj }, two operators
hvi1 = X, vi = 0; vi = Cj hvi1 = X, vi = 1; vi = Cj i. operators allow vi move Cj Cj vi1 done so.
(3) clause Cj X {0, 1}, operator hvi1 = X, vi = 0; vi = Cj v
occurs clause Cj , operator hvi1 = X, vi = 1; vi = Cj vi occurs clause
Cj . operators allow vi move Cj Cj even vi1 done so.
(4) clause Cj X = {0, 1}, two operators hvi1 = X, vi = Cj ; vi = 0i
hvi1 = X, vi = Cj ; vi = 1i. operators allow vi move back 0 1.
domain transition graph state variable w shown Figure 10. every clause
Cj two operators acting w hvk = X, w = j 1; w = ji, X {Cj , Cj }
(if j = 1, pre-condition w = j 1 replaced w = S).
Proposition 5.1 CNF formula F satisfiable planning instance P (F )
solvable.
Proof proof follows relatively straightforward interpretation variables
values planning instance P (F ). every state variable vi , must use
operator (1) commit either 0 1. Note that, choice made, variable vi
cannot set value. reason need two values Cj Cj clause
enforce commitment (Cj corresponds vi = 0, Cj corresponds vi = 1).
reach goal state variable w advance step step along values 1, . . . , n.
Clearly, every clause Cj must exist variable vi first set values Cj
Cj using operator (3). Then, message propagated along variables
vi+1 , . . . , vk using operators (2). Note existence operator (3) acting
vi implies initial choice 0 1 state variable vi , applied formula
variable vi , makes clause Cj true. Hence, plan solving P (F ), use
initial choices state variables vi define (partial) assignment satisfies
clauses F .
Conversely, assignment satisfies F , show obtain plan
solves P (F ). First, set every state variable vi value (vi ). every one
clauses Cj , choose variable vi among make Cj true using assignment .
Then, increasing order j, set state variable vi corresponding clause Cj
value Cj Cj (depending (vi )), pass message along vi+1 , . . . , vk w.
Theorem 5.2 Plan-Existence-Cn NP-hard.
342

fiComplexity Planning Problems

vx
vC

vC

vC

vC

vC

vC

1

2

3

vx

vy

vy

vz

vz

1

2

v1

v2

v3

v4

v5

3

Figure 11: Causal graph PF F = C1 C2 C3 three variables x, y, z.
Proof Producing planning instance P (F ) CNF formula F easily done
polynomial time, polynomial-time reduction Cnf-Sat p Plan-ExistenceCn .

6. Polytree Causal Graphs
section, study class planning problems binary state variables
polytree causal graphs. Brafman Domshlak (2003) presented algorithm finds
plans problems class time O(n2 ), n number variables
maximum indegree polytree causal graph. Brafman Domshlak (2006)
showed solve time roughly O(n ) planning domains local depth
causal graphs tree-width . interesting observe algorithms fail solve
polytree planning domains polynomial time different reasons: first one fails
tree broad (unbounded indegree), second one fails tree deep
(unbounded local depth, since tree-width polytree 1).
section prove problem plan existence polytree causal graphs
binary variables NP-hard. proof reduction 3Sat class
planning problems. example reduction, Figure 11 shows causal graph
planning problem PF corresponds formula F three variables three
clauses (the precise definition PF given Proposition 6.2). Finally, end
section remark reduction solves problem expressed terms CP-nets
(Boutilier et al., 2004), namely, dominance testing polytree CP-nets binary
variables partially specified CPTs NP-complete.
Let us describe briefly idea behind reduction. planning problem PF two
, . . . , v ) depends
different parts. first part (state variables vx , vx , . . . , vC1 , vC
1
1
formula F property plan may change value v1 0 1
many times number clauses F truth assignment satisfy. However,
condition v1 cannot stated planning problem goal. overcome difficulty
introducing second part (state variables v1 , v2 , . . . , vt ) translates regular
planning problem goal.
first describe second part. Let P planning problem hV, init, goal, Ai
V set state variables {v1 , . . . , v2k1 } set 4k 2 operators
{1 , . . . , 2k1 , 1 , . . . , 2k1 }. = 1, operators defined 1 = hv1 = 1; v1 = 0i
343

fiGimenez & Jonsson

1 = hv1 = 0; v1 = 1i. > 1, operators = hvi1 = 0, vi = 1; vi = 0i
= hvi1 = 1, vi = 0; vi = 1i. initial state init(vi ) = 0 i, goal state
goal(vi ) = 0 even goal(vi ) = 1 odd.
Lemma 6.1 valid plan planning problem P changes state variable v1 0 1
least k times. valid plan achieves minimum.
Proof Let Ai Bi be, respectively, sequences operators h1 , . . . , h1 , . . . , i.
easy verify plan hB2k1 , A2k2 , B2k3 , . . . , B3 , A2 , B1 solves planning
problem P . Indeed, applying operators Ai (respectively, operators Bi ),
variables v1 , . . . , vi become 0 (respectively, 1). particular, variable vi attains goal
state (0 even, 1 odd). Subsequent operators plan modify vi ,
variable remains goal state end. operator 1 appears k times
plan (one sequence type Bi ), thus value v1 changes k times 0 1.
proceed show k minimum. Consider plan solves
planning problem P , let number operators appearing (in
words, number times value vi changes, either 0 1
1 0). Note number times operator appears equal precisely one
number occurrences . show i1 > . Since 2k1 1,
implies 1 2k 1, plan has, least, k occurrences 1 , completing
proof.
show i1 > . Let Si subsequence operators plan .
Clearly, Si starts (since initial state vi = 0), operator cannot
appear twice consecutively Si , Si = , , , , etc. note that, > 1,
vi1 = 1 pre-condition, vi1 = 0, hence must least one operator
i1 plan betweeen two operators . reason must
least one operator i1 two operators , one operator i1
first operator . shows i1 . hand, variables vi
vi1 different values goal state, subsequences Si Si1 must different
lengths, is, i1 6= . Together, implies i1 > , desired.
Proposition 6.2 3Sat reduces plan existence planning problems binary variables polytree causal graphs.
Proof Let F CNF formula k clauses n variables. produce planning
problem PF 2n + 4k 1 state variables 2n + 14k 3 operators. planning
problem two state variables vx vx every variable x F , two state variables vC
every clause C F , 2k 1 additional variables v , . . . , v
vC
1
2k1 . variables
0 initial state. (partial) goal state defined Vgoal = {v1 , . . . , v2k1 },
goal(vi ) = 0 even, goal(vi ) = 1 odd, problem P Lemma
6.1. operators are:
(1) Operators hvx = 0; vx = 1i hvx = 0; vx = 1i every variable x F .
= 0; v = 1i, hv = 0, v = 0; v = 1i hv = 1, v = 1; v = 0i
(2) Operators hvC
C
C
C
C
C
C
C
every clause C F .

344

fiComplexity Planning Problems

(3) Seven operators every clause C, one partial assignment satisfies C.
Without loss generality, let x, y, z three variables appear clause C.
operator among seven, Vpre(a) = {vx , vx , vy , vy , vz , vz , vC , v1 },
Vpost(a) = {v1 }, pre(a)(vC ) = 1, pre(a)(v1 ) = 0, post(a)(v1 ) = 1. precondition state variables vx , vx , vy , vy , vz , vz depends corresponding satisfying partial assignment. example, operator corresponding partial
assignment {x = 0, = 0, z = 1} clause C = x z pre-condition
(vx = 0, vx = 1, vy = 0, vy = 1, vz = 1, vz = 0).
(4) operator h(C, vC = 0), v1 = 1; v1 = 0i.
(5) Operators = hvi1 = 0, vi = 1; vi = 0i = hvi1 = 1, vi = 0; vi = 1i
2 2k 1 (the operators problem P except 1 1 ).
note simple facts problem PF . variable x, state variables vx
vx PF start 0, applying operators (1) change 1
back 0. particular, plan cannot reach partial states hvx = 1, vx = 0i
hvx = 0, vx = 1i course execution.
Similarly, C clause F , state variable vC change 0 1 and, first
1, v change back 0. changes possible, since
changing vC
C
0.
operator brings back vC
interpret operators (3) (4), operators affect v1 .
change v1 0 1 need apply one operators (3), thus require
vC = 1 clause C. way bring back v1 0 applying operator
(4) pre-condition vC = 0. deduce every time v1 changes
value 0 1 back 0 plan , least one k state variables vC
used up, sense vC brought 0 1 back 0, cannot
used purpose.
show F 3Sat valid plan problem PF . Assume
F 3Sat, let truth assignment satisfies F . Consider following plan
. First, set vx = (x) vx = 1 (x) variables x using operators (1).
Then, clause C F , set vC = 1, apply operator (3) corresponds
restricted variables clause C (at point, v1 changes 0 1), set
= 1 v = 0, apply operator (4) (at point, v change 1
vC
1
C
0). repeating process every clause C F switching state variable v1
exactly k times 0 1. Now, following proof Lemma 6.1, easily extend
plan plan sets variables vi goal values.
show converse, namely, existence valid plan PF implies F
satisfiable. Define assignment setting (x) = 1 partial state {vx = 1, vx = 0}
appears execution , (x) = 0 otherwise. (Recall one
partial states {vx = 1, vx = 0} {vx = 0, vx = 1} appear execution
plan). Lemma 6.1, must state variable v1 changes 0 1 least k
times. implies k operators (3), corresponding different clauses,
used move v1 0 1. apply operator, values state
variables {vx , vx } must satisfy corresponding clause. Thus assignment satisfies
k clauses F .
345

fiGimenez & Jonsson

Theorem 6.3 Plan existence planning problems binary variables polytree
causal graph NP-complete.
Proof Due Proposition 6.2 need show problem NP.
Brafman Domshlak (2003) showed holds general setting planning
problems causal graphs component directed-path singly connected (that
is, one directed path pair nodes). proof exploits
non-trivial auxiliary result: solvable planning problems binary variables directedpath singly connected causal graph plans polynomial length (the true
non-binary variables, unrestricted causal graphs).
6.1 CP-nets
Boutilier et al. (2004) introduced notion CP-net graphical representation
user preferences. brief, CP-net network dependences set variables:
preferences user variable depend values others,
ceteris paribus (all else equal) assumption, is, user preferences variable
completely independent values variables mentioned. preferences
variable given parent variables network stored conditional preference
tables, CPTs.
Boutilier et al. (2004) showed dominance query problem acyclic CP-nets,
is, problem deciding one variable outcome preferable another,
expressed terms planning problem. network dependences CP-net
becomes causal graph planning problem.
However, certain conditions, perform opposite process: transform
planning problem CP-net dominance query problem, answering
query amounts solving planning problem. possible following
conditions planning problems acyclic causal graph binary variables:
1. Two operators modify variable opposing directions must nonmatching prevail conditions (the prevail condition operator partial state
pre(a) | V Vpost(a) ).
2. must allow partially specified CPTs CP-net description.
first condition guarantees obtain consistent CPTs planning instance
operators. second condition ensures reduction polynomial-size preserving,
since fully specified CPTs exponential maximum node indegree CP-net.
particular, planning instance PF reduced F satisfies first condition.
(Note true planning problem P Lemma 6.1, drop
reversing operators 1 1 constructing PF Proposition 6.2.) consequence,
claim following:
Theorem 6.4 Dominance testing polytree CP-nets binary variables partially
specified CPTs NP-complete.
346

fiComplexity Planning Problems

7. Conclusion
presented three new complexity results planning problems simple causal
graphs. First, provided polynomial-time algorithm uses macros generate solution plans class 3S. Although solutions generally suboptimal, algorithm
generate representations exponentially long plans polynomial time. several implications theoretical work planning, since generally accepted
exponentially sized minimal solutions imply plan generation intractable. work
shows always case, provided one allowed express solution
succinct notation macros. showed plan existence class Cn
NP-hard, plan existence class planning problems binary variables
polytree causal graph NP-complete.
Jonsson Backstrom (1998) investigated whether plan generation significantly
harder plan existence. Using class 3S, demonstrated plan existence
solved polynomial time, plan generation intractable sense
solution plans may exponential length. work casts new light result: even
though solution plans exponential length, possible generate representation
solution polynomial time. Thus, appears class 3S, plan generation
inherently harder plan existence. aware work
determines relative complexity plan existence plan generation, question
whether plan generation harder plan existence remains open.
potential criticism algorithm solution form macros
standard, intractable expand system macros arrive possibly
exponentially long sequence underlying operators. Although true, shown
system macros share several characteristics proper solution. possible
generate validate solution polynomial time, solution stored
using polynomial memory. showed possible compute total length
solution polynomial time, well determine i-th operator
underlying sequence.
Since relatively simple, class Cn class planning problems
binary state variables polytree causal graphs could seen promising candidates
proving relative complexity plan existence plan generation. However,
shown plan existence Cn NP-hard, plan existence planning problems
polytree causal graphs NP-complete. Consequently, classes cannot used
show plan generation harder plan existence, since plan existence already
difficult. work closes complexity gaps appear literature regarding
two classes.
however possible exist subsets planning problems classes
plan existence solved polynomial time. fact, polytree causal
graphs binary variables know case, due algorithms Brafman
Domshlak (2003, 2006) mentioned Section 6. Hence plan generation problem
polynomial restrict polytree causal graphs either bounded indegree
bounded local depth . Consequently, reduction 3Sat exhibits unbounded
indegree unbounded local depth.
347

fiGimenez & Jonsson

Similarly, one may ask class Cn planning problems parameter that,
bounded, would yield tractable subclass. state variables reduction
domains whose size depends number clauses corresponding CNF formula,
domain size appears interesting candidate. Planning problems Cn
binary variables tractable due work Brafman Domshlak (2003),
ideas use extend domain sizes 2. Hence would interesting
investigate whether problem plan existence class Cn easier size
state variable domains bounded constant.

Appendix A. Proof Theorem 4.8
Assume GenerateMacro(P , v, x, ) successfully returns macro mvx = hS1 , a, S0 i.
Let U = {u Vpre(a) {v} | pre(a)(u) = 1} let W = {w1 , . . . , wk } U set
wi

state variables U wi splitting, {mw
0 , m1 } , wi comes wj topological order < j. follows u U static,
wk
w1
w1
k
S1 = hmw
1 , . . . , m1 S0 = hm0 , . . . , m0 i. Since state variable wi W
splitting, symmetrically reversible.
Lemma A.1 wi W , prewi prev .
Proof Since wi Vpre(a) v Vpost(a) , edge wi v causal graph.
Thus, ancestor wi ancestor v, Ancwi Ancv . state variable
u Ancwi , prewi (u) = 1 u splitting wi V1u . graph Gu1 = (V, E1u )
includes edge wi v, means v V1u wi V1u . follows
prewi (u) = 1 prev (u) = 1, consequence, prewi prev .

Let = hS0 , a, S1 i. wi W {0, 1}, let w
sequence preceding
wi1
w
w
w
w
i+1
w

1

k
i.
macro , is, 1 = hm1 , . . . , m1 0 = hS0 , a, mw
0 , . . . , m0


Further, let sequence appearing a, is, = hS0 i.

wi


Lemma A.2 1 k, post-conditions sequences w
1 , , 0

post(w
1 ) = (wi+1 = 1, . . . , wk = 1),

post(a ) = (w1 = 1, . . . , wk = 1),

post(w
0 ) = (w1 = 0, . . . , wi1 = 0, wi = 1, . . . , wk = 1, v = x).

Proof direct consequence post(ha1 , . . . , ak i) = post(a1 ) post(ak ) post(mw
)=
(wi = y), post(a) = (v = x).

wi


Lemma A.3 1 k, pre-conditions sequences w
1 , , 0 ,
wi
v


satisfy pre(w
1 ) pre( ) pre(0 ) pre() pre (v = 1 x).


Proof Since pre(ha1 , . . . , ak i) = pre(ak ) pre(a1 ), follows pre(w
1 ) pre( )
wi
v
pre(0 ) pre(). prove pre() pre (v = 1 x). state variable u
pre()(u) 6=, let mu first operator hS0 , a, S1 u Vpre(mu ) ,
pre()(u) = pre(mu )(u).

348

fiComplexity Planning Problems

u
wi (w = 0) prev ,

mu = mw

1 , follows pre(m ) pre
wi
used m1 3S-macro, wi symmetrically reversible, prewi prev due
Lemma A.1. particular, pre(mu )(u) = prev (u).
Since assume planning problems normal form, u = wi implies
wi
u

u Vpre(mwi ) . follows mu 6= mw
1 i, u 6= wi i. = m0
1
pre(mu ) prewi (wi = 1), due u 6= wi , deduce pre(mu )(u) =
prewi (u) = prev (u).
Finally, consider case mu = a. u = v pre(mu )(u) = 1 x, desired.
u 6= v splitting, either v belongs V0u pre(mu )(u) = 0, v belongs V1u
pre(mu )(u) = 1. is, pre(mu )(u) = prev (u). u 6= v symmetrically reversible
follows pre(mu )(u) = 0, since case pre(mu )(u) = 1 would forced algorithm
either fail include u W . u 6= v static, pre(mu )(u) = 0, else algorithm would
failed.

Lemma A.4 Let p, p , q r partial states. p p (p q)r, (p q)r.
Proof direct consequence p q p q.
Lemma A.5 macro mvx generated algorithm well-defined.
Proof Since includes macros ancestors v causal graph, since
causal graph acyclic, cyclic definitions occur. remains show that, macro
sequence preceding , holds (pre(m ) post(m ))pre(m).
Note due Lemmas A.3 A.4 enough show
wi

(a) (prev (v = 1 x) post(w
1 ))pre(m1 ),

(b) (prev (v = 1 x) post(a ))pre(a),
wi

(c) (prev (v = 1 x) post(w
0 ))pre(m0 ).
wi

Case (a) follows easily since Vpost(wi ) Vpre(mwi ) = pre(mw
1 ) = pre (wi = 0)
1
1
w
prev . Case (c) similar, although time must use post(0 )(wi ) = 1
wi
wi (w = 1). Finally, case (b)

post(w

0 )(wj ) = 0 j < i, required pre(m0 ) = pre
holds variable u Vpre(a) either u = v, covered (v = 1 x),
splitting static, covered prev , symmetrically reversible, covered
prev (u) = 0 pre(a)(u) = 0, post(a )(u) = 1 pre(a)(u) = 1.

remains show mvx 3S-macro. follows Lemmas A.3 A.5
well-defined satisfies pre(mvx ) = pre() prev (v = 1 x). Finally, post(mvx ) =
post()pre() = (v = x) direct consequence post() = (w1 = 0, . . . , wk = 0, v = x)
Lemma A.2, pre()(wi ) = 0, pre()(v) = 1 x proof Lemma A.3.

Acknowledgments
work partially funded MEC grants TIN2006-15387-C03-03 TIN2004-07925C03-01 (GRAMMARS).
349

fiGimenez & Jonsson

References
Backstrom, C., & Nebel, B. (1995). Complexity Results SAS+ Planning. Computational
Intelligence, 11 (4), 625655.
Botea, A., Enzenberger, M., Muller, M., & Schaeffer, J. (2005). Macro-FF: Improving AI
Planning Automatically Learned Macro-Operators. Journal Artificial Intelligence Research, 24, 581621.
Boutilier, C., Brafman, R., Domshlak, C., Hoos, H., & Poole, D. (2004). CP-nets: Tool
Representing Reasoning Conditional Ceteris Paribus Preference Statements.
Journal Artificial Intelligence Research, 21, 135191.
Brafman, R., & Domshlak, C. (2003). Structure Complexity Planning Unary
Operators. Journal Artificial Intelligence Research, 18, 315349.
Brafman, R., & Domshlak, C. (2006). Factored Planning: How, When, Not.
Proceedings 21st National Conference Artificial Intelligence.
Bylander, T. (1994). computational complexity propositional STRIPS planning.
Artificial Intelligence, 69, 165204.
Chapman, D. (1987). Planning conjunctive goals. Artificial Intelligence, 32(3), 333377.
Cormen, T., Leiserson, C., Rivest, R., & Stein, C. (1990). Introduction Algorithms. MIT
Press McGraw Hill.
Domshlak, C., & Dinitz, Y. (2001). Multi-Agent Off-line Coordination: Structure Complexity. Proceedings 6th European Conference Planning, pp. 277288.
Erol, K., Nau, D., & Subrahmanian, V. (1995). Complexity, decidability undecidability
results domain-independent planning. Artificial Intelligence, 76(1-2), 7588.
Fikes, R., & Nilsson, N. (1971). STRIPS: new approach application theorem
proving problem solving. Artificial Intelligence, 5 (2), 189208.
Gimenez, O., & Jonsson, A. (2007). Hardness Planning Problems Simple
Causal Graphs. Proceedings 17th International Conference Automated
Planning Scheduling, pp. 152159.
Helmert, M. (2003). Complexity results standard benchmark domains planning.
Artificial Intelligence, 143(2), 219262.
Helmert, M. (2006). Fast Downward Planning System. Journal Artificial Intelligence
Research, 26, 191246.
Jonsson, A. (2007). Role Macros Tractable Planning Causal Graphs.
Proceedings 20th International Joint Conference Artificial Intelligence, pp.
19361941.
Jonsson, P., & Backstrom, C. (1998). Tractable plan existence imply tractable
plan generation. Annals Mathematics Artificial Intelligence, 22(3-4), 281296.
Katz, M., & Domshlak, C. (2007). Structural Patterns Heuristics: Basic Idea Concrete
Instance. Workshop Heuristics Domain-independent Planning: Progress,
Ideas, Limitations, Challenges (ICAPS-07).
350

fiComplexity Planning Problems

Knoblock, C. (1994). Automatically generating abstractions planning. Artificial Intelligence, 68(2), 243302.
Korf, R. (1987). Planning search: quantitative approach. Artificial Intelligence, 33(1),
6588.
Minton, S. (1985). Selectively generalizing plans problem-solving. Proceedings
9th International Joint Conference Artificial Intelligence, pp. 596599.
Vidal, V. (2004). Lookahead Strategy Heuristic Search Planning. Proceedings
14th International Conference Automated Planning Scheduling, pp. 150159.
Williams, B., & Nayak, P. (1997). reactive planner model-based executive.
Proceedings 15th International Joint Conference Artificial Intelligence, pp.
11781185.

351


