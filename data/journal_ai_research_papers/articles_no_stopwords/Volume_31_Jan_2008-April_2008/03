journal artificial intelligence

submitted published

first order decision diagrams relational mdps
chenggang wang
saket joshi
roni khardon

cwan cs tufts edu
sjoshi cs tufts edu
roni cs tufts edu

department computer science tufts university
college avenue medford usa

abstract
markov decision processes capture sequential decision making uncertainty
agent must choose actions optimize long term reward studies efficient reasoning mechanisms relational markov decision processes rmdp
world states internal relational structure naturally described terms
objects relations among two contributions presented first
develops first order decision diagrams fodd compact representation functions relational structures together set operators combine fodds
novel reduction techniques keep representation small second shows
fodds used develop solutions rmdps reasoning performed
abstract level resulting optimal policy independent domain size number
objects instantiation particular variant value iteration developed special operations fodds shown converge
optimal policy

introduction
many real world cast sequential decision making uncertainty
consider simple example logistics domain agent delivers boxes agent
take three types actions load box truck unload box truck
drive truck city however effects actions may perfectly predictable
example gripper may slippery load actions may succeed navigation
module may reliable may end wrong location uncertainty
compounds already complex course action achieve
goals maximize rewards
markov decision processes mdp become standard model sequential decision making uncertainty boutilier dean hanks provide
general framework artificial intelligence ai agent achieve
maintain well defined goal mdps model agent interacting world
agent fully observe state world takes actions change state
agent tries optimize measure long term reward obtain
actions
classical representation mdps puterman require enumeration state space complex situations specify state space
terms set propositional variables called state attributes state attributes
together determine world state consider simple logistics
c

ai access foundation rights reserved

fiwang joshi khardon

one box one truck state attributes truck paris tp box
paris bp box boston bb etc let state space represented n binary
state attributes total number states would n however
domain dynamics resulting solutions simple structure described
compactly state attributes previous work known propositionally factored developed suite take advantage structure
avoid state enumeration example one use dynamic bayesian networks decision trees algebraic decision diagrams concisely represent mdp model
line work showed substantial speedup propositionally factored domains boutilier
dearden goldszmidt boutilier dean goldszmidt hoey st aubin hu
boutilier
logistics example presented small realistic
large number objects corresponding relations among consider
four trucks three boxes goal box paris
matter box paris propositionally factored need
one propositional variable every possible instantiation relations domain
e g box paris box paris box truck box truck
action space expands way goal becomes ground disjunction
different instances stating box paris box paris box paris box
paris thus get large mdp time lose structure implicit
relations potential benefits structure terms computation
main motivation behind relational first order mdps rmdp first
order representation mdps describe domain objects relations among
use quantification specifying objectives logistics example introduce three predicates capture relations among domain objects e bin box city
ruck city box ruck obvious meaning three parameterized actions e load box ruck unload box ruck drive ruck city
domain dynamics reward solutions described compactly abstractly
relational notation example define goal existential quantification
e b bin b p aris goal one identify abstract policy optimal
every possible instance domain intuitively steps go
agent rewarded box paris one step go
box paris yet agent take one action help achieve goal
box say b truck say truck paris agent execute
action unload b may make bin b p aris true thus goal achieved
two steps go box truck paris agent
take unload action twice increase probability successful unloading
box box truck paris agent first take action
drive followed unload preferred plan depend success probability
different actions goal develop efficient solutions
relational performs general reasoning solving
propositionalize domain complexity
sanner boutilier make distinction first order mdps utilize full power
first order logic describe relational mdps less expressive follow
calling language rmdp



fifirst order decision diagrams relational mdps

change number domain objects changes solutions obtained good
domain size even infinite ones simultaneously abstraction
possible within propositional
several approaches solving rmdps developed last years much
work devoted developing techniques approximate rmdp solutions
different representation languages guestrin koller gearhart kanodia
fern yoon givan gretton thiebaux sanner boutilier
example dzeroski de raedt driessens driessens ramon
gartner use reinforcement learning techniques relational representations fern
yoon givan gretton thiebaux use inductive learning methods
learn value map policy solutions simulations small instances sanner
boutilier develop approximate value iteration need
propositionalize domain represent value functions linear combination
first order basis functions obtain weights lifting propositional approximate
linear programming techniques schuurmans patrascu guestrin koller par
venktaraman b handle first order case
work exact solutions symbolic dynamic programming
sdp boutilier reiter price relational bellman rebel kersting otterlo de raedt first order value iteration fovia gromann
holldobler skvortsova hoolldobler karabaev skvortsova
working implementation sdp hard keep state formulas consistent
manageable size context situation calculus compared sdp rebel
fovia provide practical solutions use restricted languages represent
rmdps reasoning formulas easier perform develop
representation combines strong points approaches
work inspired successful application algebraic decision diagrams add
bryant mcmillan bahar frohm gaona hachtel macii pardo somenzi
solving propositionally factored mdps pomdps hoey et al st aubin
hoey boutilier hansen feng feng hansen intuition
behind idea add representation allows information sharing e g sharing
value states belong abstract state consider
many states together need resort state enumeration sufficient
regularity model adds compact allowing represented
solved efficiently provide generalization lifting adds
handle relational structure adapting mdp main difficulty lifting
propositional solution relational domains transition function specifies
set schemas conditional probabilities propositional solution uses concrete
conditional probability calculate regression function possible
schemas one way around first ground domain hand
perform reasoning see example sanghai domingos weld
however allow solutions abstracting domains
sdp rebel fovia constructions perform general reasoning
first order decision trees even decision diagrams already considered
literature blockeel de raedt groote tveretina several semantics
diagrams possible blockeel de raedt lift propositional decision


fiwang joshi khardon

trees handle relational structure context learning relational datasets
groote tveretina provide notation first order binary decision diagrams
bdd capture formulas skolemized conjunctive normal form provide
theorem proving representation investigates
approaches identifies groote tveretina better suited
operations value iteration therefore adapt extend
handle rmdps particular first order decision diagrams fodd
defined modifying first order bdds capture existential quantification well realvalued functions use aggregation different valuations diagram
allows us capture mdp value functions algebraic diagrams natural way
provide additional reduction transformations algebraic diagrams help keep
size small allow use background knowledge reductions develop
appropriate representations showing value iteration performed
fodds core introduce novel diagram
goal regression given diagram representing current value function
node diagram replaced small diagram capturing truth value
action offers modular efficient form regression accounts potential
effects action simultaneously version abstract value iteration
correct hence converges optimal value function policy
summarize contributions follows identifies
multiple path semantics extending groote tveretina useful representation
rmdps contrasts single path semantics blockeel de raedt
develops fodds manipulate general
context rmdps develops novel weak reduction operations first order
decision diagrams shows relevance solving relational mdps finally
presents version relational value iteration fodds shows
correct thus converges optimal value function policy relational
value iteration developed specified previous work boutilier et al
knowledge first detailed proof correctness convergence
section briefly summarized background motivation rest organized follows section provides background
mdps rmdps section introduces syntax semantics first order decision diagrams fodd section develops reduction operators fodds sections
present representation rmdps fodds relational value iteration
proof correctness convergence last two sections conclude
discussion future work

relational markov decision processes
assume familiarity standard notions mdps value iteration see example
bellman puterman following introduce notions
introduce relational mdps discuss previous work solving
markov decision processes mdps provide mathematical model sequential optimization stochastic actions mdp characterized state space
action space state transition function p r sj si denoting probability


fifirst order decision diagrams relational mdps

transition state sj given state si action immediate reward function r
specifying immediate utility state solution mdp optimal
policy maximizes expected discounted total reward defined bellman equation
v maxaa r

x

p r v



v represents optimal state value function value iteration vi
uses bellman equation iteratively refine estimate value function
vn maxaa r

x

p r vn





vn represents current estimate value function vn next
estimate initialize process v reward function vn captures optimal
value function n steps go discussed
known converge optimal value function
boutilier et al used situation calculus formalize first order mdps
structured form value iteration one useful restrictions introduced
work stochastic actions specified randomized choice among deterministic alternatives example action unload logistics example succeed
fail therefore two alternatives action unloads unload success
unloadf unload failure formulation support number action
alternatives randomness domain captured random choice specifying
action alternative unloads unloadf gets executed agent attempts
action unload choice determined state dependent probability distribution
characterizing dynamics world way one separate regression
effects action alternatives deterministic probabilistic choice
action considerably simplifies reasoning required since need perform
probabilistic goal regression directly work rmdps used assumption use assumption well sanner boutilier investigate model
going beyond assumption
thus relational mdps specified set predicates domain set
probabilistic actions domain reward function probabilistic action
specify deterministic action alternatives effects probabilistic choice
among alternatives relational mdp captures family mdps generated
choosing instantiation state space thus logistics example corresponds
possible instantiations boxes boxes get concrete
mdp choosing instantiation yet attempt solve entire
mdp family simultaneously
boutilier et al introduce case notation represent probabilities rewards
compactly expression case n tn logical formula
equivalent n tn words equals ti
one could define single mdp including possible instances time e g include
states boxes states boxes infinite number boxes obviously
subsets states form separate mdps disjoint thus prefer view rmdp
family mdps



fiwang joshi khardon

true general constrained steps vi require
disjoint partition state space case exactly one
true state denotes abstract state whose member states
value probability reward example reward function logistics
domain discussed illustrated right side figure captured
case b bin b p aris b bin b p aris following notation
operations function defined case expressions operators defined
taking cross product partitions adding multiplying case values
case ti n case j vj j case j ti vj n j
case ti n case j vj j case j ti vj n j
iteration vi value stochastic action x parameterized
free variables x determined following manner
qa x rcase j pcase nj x regr nj x vcase nj x
rcase vcase denote reward value functions case notation n j x
denotes possible outcomes action x pcase nj x choice probabilities nj x note replace sum possible next states standard
value iteration equation finite sum action alternatives j reflected j
equation since different next states arise different action alternatives
regr capturing goal regression determines states one must action
order reach particular state action figure illustrates regression
b bin b p aris reward function r action alternative unloads b
b bin b p aris true action unloads b true box
b truck truck paris notice reward function r partitions
state space two regions abstract states may include infinite
number complete world states e g infinite number domain objects
notice get another set abstract states regression step
way first order regression ensures work abstract states never need
propositionalize domain
regression get parameterized q function accounts possible
instances action need maximize action parameters q function
get maximum value could achieved instance action
illustrate step consider logistics example two boxes b b
b truck paris b p aris b
boston bin b boston action schema unload b instantiate b
b respectively help us achieve goal instantiate b
b respectively effect therefore need perform
maximization action parameters get best instance action yet must
perform maximization generically without knowledge actual state sdp
done several steps first add existential quantifiers action parameters
leads non disjoint partitions sort abstract states q x value
decreasing order include negated conditions first n abstract states
formula n th ensuring mutual exclusion notice step leads complex


fifirst order decision diagrams relational mdps

r
b bin b paris

b bin b paris



b bin b paris


b
tin paris

figure example illustrating regression action alternative unloads b

description resulting state partitions sdp process performed every
action separately call step object maximization denote obj max q x
finally get next value function maximize q functions different
actions three steps provide one iteration vi repeats
update convergence
solutions rebel kersting et al fovia gromann et al
hoolldobler et al follow outline use simpler logical language representing rmdps abstract state rebel captured existentially quantified
conjunction fovia gromann et al hoolldobler et al complex
representation allowing conjunction must hold state set conjunctions
must violated important feature rebel use decision list rivest
style representations value functions policies decision list gives us
implicit maximization operator since rules higher list evaluated first
object maximization step simple rebel state partition represented
implicitly negation rules explicitly conjunction rule
hand regression rebel requires one enumerate possible matches
subset conjunctive goal state partition action effects reason
separately step potentially improved
following section introduce representation first order decision diagrams fodd fodds allow sharing parts partitions leading space time
saving importantly value iteration fodds simple
regression simple object maximization


fiwang joshi khardon

first order decision diagrams
decision diagram graphical representation functions propositional boolean
variables function represented labeled rooted directed acyclic graph
non leaf node labeled propositional variable exactly two children
outgoing edges marked values true false leaves labeled numerical
values given assignment truth values propositional variables traverse
graph node follow outgoing edge corresponding truth value
gives mapping assignment leaf diagram turn
value leaves marked values interpret graph
representing boolean function propositional variables equivalently graph
seen representing logical expression satisfied leaf
reached case leaves known binary decision diagrams bdds
case numerical leaves general algebraic expressions known algebraic
decision diagrams adds decision diagrams particularly interesting impose
order propositional variables require node labels respect order
every path diagram case known ordered decision diagrams odd
case every function unique canonical representation serves normal form
function property means propositional theorem proving easy odd
representations example formula contradictory fact evident
represent bdd since normal form contradiction single leaf valued
property together efficient manipulation odd representations
led successful applications e g vlsi design verification bryant
mcmillan bahar et al well mdps hoey et al st aubin et al
following generalize representation relational
syntax first order decision diagrams
ways generalize adds capture relational structure one could
use closed open formulas nodes latter case must interpret
quantification variables process developing ideas
considered several possibilities including explicit quantifiers lead
useful solutions therefore focus following syntactic definition
explicit quantifiers
representation assume fixed set predicates constant symbols
enumerable set variables allow equality pair terms
constants variables
definition first order decision diagram
first order decision diagram fodd labeled rooted directed acyclic graph
non leaf node exactly two children outgoing edges marked
values true false
non leaf node labeled atom p tn equality
ti variable constant
leaves labeled numerical values


fifirst order decision diagrams relational mdps

p x
q x


h





figure simple fodd

figure shows fodd binary leaves left going edges represent true branches
simplify diagrams draw multiple copies leaves
occasionally values small sub diagrams represent node
fodd
use following notation node n nt denotes true branch n nf
false branch n na outgoing edge n true false
edge e source e node edge e issues target e node edge e
points let e e two edges e sibling e iff source e source e
following slightly abuse notation let na mean edge
sub fodd edge points use na target e interchangeably
n source e true false depending whether e lies
true false branch n
semantics first order decision diagrams
use fodd represent function assigns values states relational mdp
example logistics domain might want assign values different states
way box paris state assigned value
box paris box truck paris raining state
assigned value question define semantics fodds
order intended meaning
semantics first order formulas given relative interpretations interpretation domain elements mapping constants domain elements
predicate relation domain elements specifies predicate
true mdp context state captured interpretation example
logistics domain state includes objects boxes trucks cities relations
among box truck b box paris bin b p aris
one way define meaning fodd b interpretation
following discuss two possibilities
semantics single path
semantics relational decision trees given blockeel de raedt
adapted fodds semantics define unique path followed traversing
regression logistics domain cf figure l



fiwang joshi khardon

b relative variables existential node evaluated relative path
leading
particular reach node variables seen
path consider node n label l n path leading
root let c conjunction labels nodes exited true
branch path node n evaluate x c l n x includes
variables c l n formula satisfied follow true branch
otherwise follow false branch process defines unique path root
leaf value
example evaluate diagram figure interpretation
domain true atoms p q h follow
true branch root since x p x satisfied follow false branch q x
since x p x q x satisfied since leaf labeled say b
satisfy attractive partitions set interpretations
mutually exclusive sets used create abstract state partitions mdp
context however reasons discuss later semantics leads complications
value iteration therefore used
semantics multiple paths
second alternative builds work groote tveretina defined semantics multiple paths following work define semantics first relative
variable valuation given fodd b variables x interpretation valuation
maps variable x domain element done node predicate
evaluates true false traverse single path leaf value
leaf denoted mapb
different valuations may give different values recall use fodds represent
function states state must assigned single value therefore next
define
mapb aggregate mapb
aggregation function consider possible valuations
valuation calculate mapb aggregate values special
case groote tveretina leaf labels variables universally
quantified easily captured formulation minimum aggregation
function use maximum aggregation function corresponds
existential quantification binary case valuation leading value
value assigned gives useful maximization value functions
general case therefore define
mapb max mapb


definition b assigns every unique value v mapb b defines function
interpretations real values later refer function map b
consider evaluating diagram figure interpretation given
true atoms p q h valuation x mapped


fifirst order decision diagrams relational mdps

mapped denoted x leads leaf value maximum leaf
labels interpret diagram logical formula map b
example say satisfies b mapb say falsifies
b
define node formulas nf edge formulas ef recursively follows node
n labeled l n incoming edges e ek node formula nf n ef ei
edge formula true outgoing edge n ef nt nf n l n edge formula
false outgoing edge n ef nf nf n l n formulas
variables existentially quantified capture conditions node edge
reached
basic reduction fodds
groote tveretina define several operators reduce diagram normal
form total order node labels assumed describe operators briefly
give main properties
r neglect operator children node p fodd lead node q
remove p link parents p q directly
r join operator two nodes p q label point two
children join p q remove q link qs parents p
r merge operator node child label parent point
directly grandchild
r sort operator node p parent q label ordering violated l p
l q reorder nodes locally two copies p q labels
nodes violate ordering
define fodd reduced none four operators applied
following
theorem groote tveretina
let neglect join merge sort operator b applying
fodd b b mapb mapo b
b b reduced satisfy mapb mapb identical
property gives soundness property shows reducing fodd gives normal
form however holds maps identical every condition
stronger normal equivalence normal form suffices groote tveretina
use provide theorem prover first order logic strong
enough purposes figure shows two pairs reduced fodds respect r r mapb mapb mapb mapb case
although maps fodds reduced form consider
first pair part figure interpretation p false p b
true substitution x b leads value b b evaluates
diagrams equivalent interpretation p c true object


fiwang joshi khardon

b

b

p x







p




p x
b

p z


p x



p z x









figure examples illustrating weakness normal form

c mapb substitution x c p c false object c
mapb substitution x c c thus map
b well section additional reduction operators
developed b first pair reduced thus diagrams form
reduction however reductions resolve second pair given part b
figure notice functions capture path two edges labeled p graph
change order two nodes rename variables diagrams evaluate
interpretation path even though b b logically
equivalent cannot reduced form r r operators
identify unique minimal syntactic form one may consider possible renamings
variables sorted diagrams produce expensive operation
discussion normal form conjunctions uses operation given garriga
khardon de raedt
combining fodds
given two algebraic diagrams may need add corresponding functions take
maximum use binary operation op values represented functions adopt solution propositional case bryant form
procedure apply b b op b b algebraic diagrams let p q
roots b b respectively procedure chooses root label lower
among labels p q recursively combines corresponding sub diagrams according
relation two labels order make sure
reduced propositional sense one use dynamic programming avoid generating
nodes neglect join operators r r would applicable
figure illustrates process example assume predicate ordering
p p parameter ordering x x non leaf nodes annotated numbers
numerical leaves underlined identification execution trace example


fifirst order decision diagrams relational mdps


p x

p x





p x







p x



p x




p x




p x




figure simple example adding two fodds

top level call adds functions corresponding nodes since p x
smaller label picked label root must add
left right child node node calls performed recursively easy
see size may product sizes input diagrams however
much pruning occur shared variables pruning made possible weak
reductions presented later
since interpretation fixed valuation fodd propositional
following lemma later refer property correctness apply
lemma let c apply b op mapa op mapb
mapc
proof first introduce terminology let nodes x refer set nodes
fodd x let root nodes b aroot broot respectively let
fodds rooted aroott arootf broott brootf croott crootf al ar b l b r
c l c r respectively
proof induction n nodes nodes b lemma true
n case aroot broot single leaves operation
operation two real numbers inductive step need
consider two cases
case aroot broot since root nodes equal valuation reaches al
reach b l reaches ar reach b r
definition apply case c l apply al b l op c r apply ar b r op therefore statement lemma true mapal op mapb l mapc l
mapar op mapb r mapc r since nodes al
nodes b l n nodes ar nodes b r n guaranteed induction
hypothesis
case aroot broot without loss generality let us assume aroot broot
definition apply c l apply al b op c r apply ar b op therefore
statement lemma true mapal op mapb mapc l
mapar op mapb mapc r guaranteed
induction hypothesis



fiwang joshi khardon

order labels
syntax fodds allows two types objects constants variables
argument predicate constant variable assume complete ordering
predicates constants variables ordering two labels given
following rules
p x xn p x x p p
p x xn p x x n exists xj x j j
type xi type x type constant variable type xi type x
xi x
predicate order set arbitrarily appears useful assign equality
predicate first predicate ordering equalities top
diagrams reductions often encounter situations one side equality
completely removed leading substantial space savings may useful
order argument types constant variables ordering may helpful
reductions intuitively variable appearing lower diagram bound
value constant appears heuristic guidelines best
ordering may well dependent later introduce forms arguments
predicate parameters action parameters ordering discussed section

additional reduction operators
context especially algebraic fodds may want reduce diagrams
distinguish strong reductions preserve mapb weak reductions
preserve mapb theorem shows r r given strong reductions details relational vi directly depend reductions
used readers interested rmdp details skip section read
independently except reductions illustrated examples
reduction operators incorporate existing knowledge relationships
predicates domain denote background knowledge b example
blocks world may know block block clear
x x clear
following define conditions reduction operators two types
conditions reachability condition value condition name reachability
conditions starting p path condition reduction operator number
name conditions values starting v reduction operator number
r strong reduction implied branches
consider node n whenever n reached true branch followed
case remove n connect parents directly true branch first
present condition followed lemma regarding operator
p b x nf n l n x variables ef nt


fifirst order decision diagrams relational mdps

let r n denote operator removes node n connects parents directly
true branch notice generalization r easy see
following lemma true
lemma let b fodd n node condition p holds b
r n interpretation valuation map b
mapb
similar reduction formulated false branch e b x nf n
l n whenever node n reached false branch followed case
remove n connect parents directly false branch
implied branches may simply equalities along path example x
p x p may prune p x p x known true implied
branches may background knowledge example blocks world
x guaranteed true reach node labeled clear
remove clear connect parent clear f
r weak reduction removing dominated edges
consider two edges e e fodd whose formulas satisfy follow
e valuation follow e possibly different valuation
e gives better value e intuitively e never determines value diagram
therefore redundant formalize reduction operator r
let p source e q source e e pa e qb b true
false first present conditions operator follow
definition operator
p b x ef e ef e x variables ef e
variables ef e
p b u w
ef e v ef e u variables appear
target e target e v variables appear ef e u
w
variables appear ef e u condition requires
every valuation reaches e valuation reaches e
agree variables appear target e target e
p b r ef e ef e r variables appear
target e target sibling e variables appear ef e r
variables appear ef e r condition requires
every valuation reaches e valuation reaches e
agree variables appear target e target sibling e
v min target e max target e min target e minimum leaf
value target e max target e maximum leaf value target e case
regardless valuation know better follow e e
v min target e max target sibling e
v leaves target e target e non negative values denoted
case fixed valuation better follow e instead e
use r skip notation r consistency earlier versions see
discussion section



fiwang joshi khardon

v leaves g target e target sibling e non negative values
define operators r replace b e e replacing target e constant b
min target e may write r replace e e b
r drop e e dropping node q source e connecting parents
target sibling e
need one safety condition guarantee reduction correct
nf source e sub fodd target e remain
r replace r drop condition says must harm value promised
target e words must guarantee p source e reachable
sub fodd target e modified replacing branch
condition violated q sub fodd pa p sub fodd qb
holds cases p q unrelated one descendant
q sub fodd pa p sub fodd qb b
negations b
lemma let b fodd e e edges conditions p v
hold b r replace b e e b min target e
interpretation mapb mapb
proof consider valuation reaches target e according p
another valuation reaching target e v gives higher value therefore mapb never determined target e replace target e
constant min target e without changing map

lemma let b fodd e e edges conditions p v
hold b r replace b e e b min target e
interpretation mapb mapb
proof consider valuation reaches target e p another
valuation reaching target e agree variables appear
target e target e therefore v achieves higher value otherwise
must branch target e target e negative value therefore according
maximum aggregation value mapb never determined target e
replace constant described

note conditions previous two lemmas comparable since p
p v v intuitively relax conditions values need
strengthen conditions reachability subtraction operation target e
target e propositional test v implicitly assumes common variables operands p check figure illustrates
reachability condition p together v e combining weaker portions conditions lemma lemma cannot guarantee replace
branch constant consider interpretation domain relations h q p addition assume domain knowledge b x h x
z w q z w p v hold e q x e h z
mapb mapb therefore possible replace h z


fifirst order decision diagrams relational mdps

q x
p

q x

h z
p






b



p





b

figure example illustrating subtraction condition r



b

b

p x

p x

q




p



h



h




figure example illustrating condition removing node r

sometimes drop node q completely r drop intuitively
remove node must guarantee gain extra value conditions
r replace guarantee lose value remove node
q valuation supposed reach e may reach better value e sibling
would change map illustrated figure notice conditions p
v hold e p x e p replace p constant
consider interpretation domain relations q p h
mapb via valuation x mapb via valuation x thus
removing p correct
therefore need additional condition guarantee gain extra value
node dropping condition stated valuation reaches e
thus redirected reach value v sibling e q removed
valuation reaches leaf value v v however condition complex
test practice following identify two stronger conditions
lemma let b fodd e e edges condition v hold addition
conditions replacing target e constant b r drop e e
interpretation mapb mapb
proof consider valuation reaching target e true value dominated
another valuation reaching target e remove q source e valuation
reach target sibling e v value produced smaller value
target e map preserved



fiwang joshi khardon

lemma let b fodd e e edges p v hold addition
conditions replacing target e constant b r drop e e
interpretation mapb mapb
proof consider valuation reaching target e value dominated
another valuation reaching target e remove q source e valuation
reach target sibling e conditions p v valuation
reach leaf greater value target e otherwise branch g leading
negative value maximum aggregation map changed

summarize p v hold p v hold
replace target e constant replace v p v hold
drop q source e completely
following provide detailed analysis applicability variants r
r special case r
special case r p q e e e siblings context r
considered focus single node n instead two edges assuming e nt
e nf rewrite conditions r follows
p b x nf n x ef nt condition requires n reachable
nt reachable
p b r v nf n v w
ef nt r variables appear
nt nf v variables appear nf n r w
variables
l n r v
p b u v nf n v w
ef nt u variables appear
nt since sibling e e v variables appear nf n u w

variables l n u v
v min nt max nf
v nt constant
v leaves diagram nt nf non negative values
conditions v true previously analyzed special case
separate reduction operator named r wang joshi khardon
special case may still useful check separately applying generalized
case r provides large reductions seems occur frequently example domains
important special case r occurs l n equality
variable occur fodd node n case condition p
holds since choose value enforce equality subdiagram nt therefore v holds remove node n connecting parents
nt substituting diagram nt note may need make copies
nodes section introduce elaborate reduction handle
equalities taking maximum left right children
application order
cases several instances r applicable turns order
apply important following first example shows order affects


fifirst order decision diagrams relational mdps

p x
q x

p x
q x


p x

q x





p x





q x


q x

q x




b



q x

p x
q x



c

p x

p x








q x


p x






e

figure example illustrating effect application order r

number steps needed reduce diagram second example shows
order affects final
consider fodd figure r applicable edges e p x
e p x e q x e q x reduce top
manner e first apply r pair p x p x get fodd
figure b apply r q x q x get
fodd figure c however apply r first q x q x thus getting
figure r cannot applied p x p x p x
p x negative leaves case diagram still reduced
reduce comparing q x q x right part fodd first
remove q x get fodd shown figure e use neglect operator
remove p x see example applying one instance r may render
instances applicable may introduce possibilities reductions general
must apply reductions sequentially wang develops conditions
several instances r applied simultaneously
one might hope repeated application r lead unique reduced
true fact final depends choice operators order
application consider figure r applicable edges e p x e p
e q x e q reduce top manner e first apply
r pair p x p get fodd figure b cannot
reduced existing reduction operators including operator r introduced
however apply r first q x q get figure c
apply r e p x e p get final figure
clearly compact figure b interesting first example seems


fiwang joshi khardon

p x


p x


p

q x


q


q








b

p x


q x

p x
q x

p



q x




c

figure example illustrating final r reductions order dependent
suggest applying r top manner since takes fewer steps second
seems suggest opposite since final compact
needed develop useful heuristics guide choice reductions application
order general develop complete set reductions
note could consider generalizing r figure b reach q
clearly reach p x q x since p x q x give better values safely replace q thus obtaining final figure theory generalize p b x ef e ef e n ef e n
x variables ef e variables ef e n generalize
corresponding value condition v n min target e max target e
generalize reachability value conditions similarly however resulting
conditions expensive test practice
relaxation reachability conditions
conditions p p sufficient necessary guarantee correct reductions sometimes valuations need agree smaller set variables
intersection variables see consider example shown figure
b intersection x z however guarantee b need
agree x x z intuitively agree variable x avoid
situation two paths p x q x p x q x h z co exist order
prevent co existence two paths p x h z p x q x h z
z well change example little bit replace


fifirst order decision diagrams relational mdps

h z h z v two minimal sets variables different size one x
x z v cannot identify minimum set variables
subtraction must choose intersection heuristically identify minimal set
example greedy procedure



b

p x

p x

q x


h z


q x




h z


h z




figure example illustrating minimal set variables subtraction
unique
r weak reduction unification
consider fodd b let v denote variables let x disjoint subsets v
cardinality define operator r b x replacing variables
x corresponding variables denote resulting fodd b x
variables v x following condition correctness r
v leaves b x b non negative
lemma let b fodd b r b x v holds
interpretation mapb mapb
proof consider valuation v b v b x gives better value
valuation therefore lose value operator gain
extra value consider valuation variables b reaching leaf node value
v construct valuation v b variables x taking corresponding
value reach leaf node b value therefore map
changed unification

figure illustrates cases r applicable r apply
r x x get fodd shown figure b since b b becomes
reduction note unify way e x x get
figure c isomorphic figure b cannot reduce original fodd
c phenomenon happens since subtraction operation
implemented apply used reductions propositional therefore sensitive
variable names
r equality reduction
consider fodd b equality node n labeled x sometimes drop n
connect parents sub fodd taking maximum left


fiwang joshi khardon

p x
p x
p x



x x

q x


q x








b

x x

p x
q x





c

figure example illustrating r

right children n reduction applicable b satisfy following
condition
e equality node n labeled x least one x variable
appears neither nf node formula n simplify description
reduction procedure assume x variable
additionally make following assumption domain
domain contains one object
assumption guarantees valuations reaching right child equality
nodes exist fact needed proving correctness equality reduction operator
first describe reduction procedure r n let bn denote fodd rooted
node n fodd b extract copy bnt name bnt copy copy
bnf bnf copy b bnt copy rename variable x produce diagram
bn copy let bn apply bn copy bnf copy max finally drop node n b
connect parents root bn obtain final b example shown
figure
informally extracting parts fodd rooted node n one x
renaming x part one x condition e
assumption guarantee regardless value valuations reaching
parts since definition map maximize valuations case
maximize diagram structure calculating function
maximum two functions corresponding two children n
apply replacing old sub diagram rooted node n combined diagram
theorem proves affect map b
one concern implementation simply replace old sub diagram
sub diagram may diagram strong reductions applicable
semantically avoid need strong reductions
apply implicitly performs strong reductions r neglect r join follows


fifirst order decision diagrams relational mdps

let ba denote fodd resulting replacing node n b bb
fodd resulting replacing node n leaves node n
final b ba bb bb bb bn correctness apply two
forms calculating b give map

b x


p
q x

x
p


q x



q x

q x


p x




b





c
b x

q x









p x
q x



q x




e

figure example equality reduction fodd reduction
node x satisfies condition e variable b bnt copy nt extracted
c bnt copy renamed produce bn copy bnf copy e final
node n replaced apply bn copy bnf copy max
following prove node n equality condition e holds b
perform equality reduction r without changing map interpretation
satisfying start properties fodds defined e g b bb bb let
n denote set valuations reaching node n let denote set valuations
reaching node n b basic definition map following
claim

b
c


interpretation
mapba mapb
n mapba
mapbb
n mapbb

claim definition map
claim interpretation
mapbb
b n mapbb mapbn
claim claim definition map



fiwang joshi khardon

claim interpretation
mapb mapb
b n mapb mapbn
next prove main property reduction stating valuations reaching
node n b old sub fodd rooted n combined sub fodd produce
map
lemma let n set valuations reaching node n fodd b interpretation satisfying maxn mapbn maxn mapbn
proof condition e variable x appear n f n hence value
n constrained therefore partition valuations n disjoint
sets n valuation variables x variables
x fixed value x take value domain assumption
guarantees every contains least one valuation reaching bnt least one
valuation reaching bnf b note valuation reaches bnt x satisfied
thus mapbnt mapbn copy since x appear bnf

mapbn copy constant therefore correctness
f
apply max mapbn max mapbn
finally definition map maxn mapbn max max mapbn
max max mapbn maxn mapbn

lemma let b fodd n node condition e holds b
r n interpretation satisfying map b mapb
proof let x maxm mapb maxn mapb definition map mapb max x however claim x maxm mapb
claim lemma maxn mapbn maxn mapbn thus

max x mapb mapb
lemma guarantees correctness applying practice may important
avoid violations sorting order would require expensive sorting
diagram x variables sometimes replace variable
name resulting diagram sorted however possible
violation unavoidable tradeoff performing reduction sorting
diagram ignoring potential reduction
summarize section introduced several reductions compress diagrams significantly first r generic strong reduction removes implied
branches diagram three r r r weak reductions alter
overall map diagram alter map specific valuations three
reductions complementary since capture different opportunities space saving

decision diagrams mdps
section fodds used capture rmdp therefore use
fodds represent domain dynamics deterministic action alternatives probabilistic choice action alternatives reward function value functions


fifirst order decision diagrams relational mdps

example domain
first give concrete formulation logistics discussed introduction example follows exactly details given boutilier et al used
illustrate constructions mdps domain includes boxes trucks cities
predicates bin box city ruck city box ruck following
boutilier et al assume b bin b c mutually exclusive
box truck city vice versa background knowledge includes
statements b c b bin b c b c bin b c b reward
function capturing goal awards reward formula b bin b p aris
true box paris thus reward allowed include constants
need completely ground
domain includes actions load unload drive actions effect
preconditions met actions fail probability attempting
load successful version loads executed probability unsuccessful version loadf effectively operation probability drive action executed
deterministically attempting unload probabilities depend whether raining raining successful version unloads executed probability
unloadf probability raining unloads executed probability
unloadf probability
domain dynamics
follow boutilier et al specify stochastic actions randomized choice
among deterministic alternatives domain dynamics defined truth value diagrams tvds every action schema predicate schema p x tvd
p x fodd leaves tvd gives truth value p x
next state performed current state call action parameters x predicate parameters variables allowed tvd
reasoning behind restriction explained section restriction sometimes sidestepped introducing action parameters instead variables
truth value tvd valid fix valuation parameters
tvd simultaneously captures truth values instances p x next state
notice tvds different predicates separate safely done even
action coordinated effects conditionally independent since action alternatives
deterministic
since allow action parameters predicate parameters effects action
restricted predicates action arguments tvd expressive
simple strips schemas example tvds easily express universal effects
action see note p x true x action tvd
p x captured leaf valued universal conditional effects
captured similarly hand since explicit universal quantifiers
tvds cannot capture universal preconditions
domain tvd predicate p x defined generically figure
idea predicate true true undone action
false brought action tvds logistics domain


fiwang joshi khardon

p x
bring


undo






figure template tvd

bin b c


b

b

b b




tin c




b b

b b

bin b c




c c



b

bin b c


tin c

c

c c





c c


e







tin c


b b


tin c




b



rain


bin b paris





f


g

figure fodds logistics domain tvds action choice reward function b tvds bin b c b action choice
unloads b c tvds bin b c b action
choice loads b c note c must action parameter
valid tvd e tvd c action choice drives c
f probability fodd action choice unloads b g reward
function



fifirst order decision diagrams relational mdps

running example given figure tvds omitted figure
trivial sense predicate affected action order simplify
presentation give tvds generic form sort diagrams
order proposed section tvds consistent ordering bin
rain notice tvds capture implicit assumption usually taken
domains preconditions action satisfied
action effect
notice utilize multiple path semantics maximum aggregation predicate true true according one paths specified get disjunction
conditions free use single path semantics blockeel de raedt
corresponding notion tvd significantly complicated since single
path must capture possibilities predicate become true capture must
test sequentially different conditions take union substitutions
different tests turn requires additional annotation fodds appropriate
semantics similarly operation would require union substitutions thus complicating representation explain issues detail section
introduce first order value iteration
probabilistic action choice
one consider modeling arbitrary conditions described formulas state
control natures probabilistic choice action multiple path semantics makes
hard specify mutually exclusive conditions existentially quantified variables
way specify distribution therefore restrict conditions propositional
depend directly action parameters condition interpretation follows
exactly one path since variables thus empty valuation thus
aggregation function interact probabilities assigned diagram showing
action choice unloads logistics example given figure example
condition propositional condition depend action parameters
example assume affected whether box big
diagram figure specifying action choice probability
big b
rain





figure example showing choice probability depend action parameters
note probability usually depends current state depend arbitrary properties state restriction stated e g rain big b
shown figure allow arbitrary conditions depend predicates arguments restricted action parameters dependence complex however
allow free variables probability choice diagram example cannot
model probabilistic choice unloads b depends boxes truck


fiwang joshi khardon

e g b b b b otherwise write fodd capture
condition semantics fodd means path selected max aggregation distribution cannot modeled way clearly restriction
conditions action arguments still give substantial modeling power
reward value functions
reward value functions represented directly algebraic fodds reward
function logistics domain example given figure

value iteration fodds
following boutilier et al define first order value iteration follows
given reward function r action model input set v r n repeat
procedure rel greedy termination
procedure rel greedy
action type x compute

x

qv n

r j prob aj x regr vn aj x




x

qa
vn obj max qvn
vn maxa qa
vn
notation steps procedure discussed section except
work fodds instead case statements note since reward function
depend actions move object maximization step forward adding
reward function e first

x

tv n

j prob aj x regr vn aj x

followed

x

qa
vn r obj max tvn
later see object maximization step makes reductions possible therefore moving step forward get savings computation compute
updated value function way comprehensive example value iteration given
later section
puterman case
value iteration terminates kvi vi k

need test values achieved two diagrams within

formulations goal use absorbing state zero
additional reward goal reached handle formulation
one non zero leaf r case replace equation

x

qv n

max r j prob aj x regr vn aj x

see correct note due discounting max value r r
satisfied state care action max would r r
state get value discounted future reward


fifirst order decision diagrams relational mdps

note goal domains e one non zero
leaf mean cannot disjunctive goals means must
value goal condition equally
regressing deterministic action alternatives
first describe calculation regr vn aj x simple idea call block replacement proceed discuss obtain efficiently
consider vn nodes fodd node take copy corresponding tvd predicate parameters renamed correspond
nodes arguments action parameters unmodified br regress v n x fodd
resulting replacing node vn corresponding tvd outgoing edges
connected leaves tvd
recall rmdp represents family concrete mdps generated choosing
concrete instantiation state space typically represented number objects
types formal properties hold concrete instantiation
fix concrete instantiation state space let denote state resulting
executing action x state notice vn br regress vn x exactly
variables following lemma
lemma let valuation variables vn thus variables
br regress vn x mapvn mapbrregress vn x
proof consider paths p p followed valuation two diagrams
definition tvds sub paths p applied guarantee corresponding nodes
p take truth values p p reach leaf value
obtained

naive implementation block replacement may efficient use block
replacement regression resulting fodd necessarily reduced moreover
since different blocks sorted start even sorted reducing
sorting may expensive operation instead calculate
follows fodd vn traverse br regress vn x postorder traversal
terms blocks combine blocks step combine fodds
parent block yet processed tvd binary leaves
two children processed general fodds call parent
bn true branch child bt false branch child bf represent
combination bn bt bn bf
lemma let b fodd bt bf fodds bn fodd
leaves let b apply calculate diagram bn bt bn bf
interpretation valuation mapb mapb
proof true since fixing valuation effectively ground fodd
paths mutually exclusive words fodd becomes propositional clearly
combination propositional apply correct

high level description calculate br regress v n x block
combination follows


fiwang joshi khardon

procedure block combination br regress vn x
perform topological sort vn nodes see example cormen leiserson rivest
stein
reverse order non leaf node n children bt bf already
processed let bn copy corresponding tvd calculate bn bt
bn bf
return fodd corresponding root
notice different blocks share variables cannot perform weak reductions
process however perform strong reductions intermediate steps since
change map valuation process completed perform
combination weak strong reductions since change map
regressed value function
blue b

b


big
b




b b

big
b






blue b



bin b c
tin c



b b





b

bin b c
tin c



c

figure example illustrating variables allowed tvds
explain cannot variables tvds example illustrated figure suppose value function defined figure saying
blue block big truck block truck
value assigned figure b gives tvd b action loads
c variable instead action parameter figure c gives
block replacement consider interpretation domain b c c relations
blue b big bin b c c action loads b reach
state blue b big b c gives us value figure c b b evaluated gives value valuation b b c c
choice c c makes sure precondition violated making c action parameter applying action must explicitly choose valuation leads correct
value function object maximization turns action parameters variables allows us
choose argument maximize value


fifirst order decision diagrams relational mdps

regressing probabilistic actions
regress probabilistic action must regress deterministic alternatives combine choice probability equation discussed section due
restriction rmdp model explicitly specifies finite number deterministic
action alternatives replace potentially infinite sum equation finite
sum equation done correctly every state equation
correct following specify done fodds
recall prob aj x restricted include action parameters cannot include variables therefore calculate prob aj x regr vn aj x step directly
apply however different regression independent functions
sum j prob aj x regr vn aj x must standardize apart different regression adding functions note action parameters still considered
constants stage holds addition reward function need
standardize apart complicates diagrams often introduces structure
reduced performing operations first use propositional apply procedure
follow weak strong reductions

v

asucc x
q x

p x


p




x



q





b
q x

q x
p x
x x

q x


p x


q x






q x
p x



x x
q x


c



figure example illustrating need standardize apart
figure illustrates need standardize apart different action outcomes action
succeed denoted asucc fail denoted af ail effectively operation
chosen probability part gives value function v part b gives
tvd p action choice asucc x tvds trivial part
c shows part adding two outcomes standardizing apart
simplify presentation diagrams sorted consider interpretation
domain relations q p seen c choosing x e


fiwang joshi khardon

action valuation x x gives value action without
considering discount factor obviously standardize apart e x x
leaf value get wrong value intuitively contribution
asucc value comes bring portion diagram af ails
contribution uses bindings undo portion two portions refer
different objects standardizing apart allows us capture simultaneously
lemma discussion far
lemma consider concrete instantiation rmdp let vn value function
corresponding mdp let x probabilistic action domain

x
qvn calculated equation correct state mapqa x
vn

expected value executing x receiving terminal value v n
observations single path semantics

section suggested single path semantics blockeel de raedt
support value iteration well multiple path semantics explanation
regression use example illustrate suppose value function
defined figure saying red block big city value
assigned figure b gives block replacement action unloads b
however correct consider interpretation domain b b c
relations red b blue b big c bin b c c b note use
single path semantics follow true branch root since b c bin b c true
b b c c follow false branch red b since b c bin b c red b
satisfied therefore get value clearly get value instead
b b c c impossible achieve value figure b single
path semantics reason block replacement fails top node decides true
branch one instance predicate really need true instances
predicate filter true leaf tvd
correct want capture instances true
undone instances made true one path figure c gives one
possible way means variable renaming stands union operator
takes union substitutions treated edge operations note
coordinated operation e instead taking union substitutions
b b c c separately need take union substitutions b c
b c may possible clearly leads complicated diagrams
similar complications arise context object maximization finally use
representation procedures need handle edge marking unions
substitutions look promising
object maximization
notice since handling different probabilistic alternatives action
separately must keep action parameters fixed regression process
added step step maximize choice action
parameters mentioned get maximization free simply rename


fifirst order decision diagrams relational mdps

bin b c

bin b c

bin b c

b b

red b

bin b c

b

b b

tin c

big c





red b
big c


red b

b






b
tin c

tin c b c
b c
b c
b c
b c

big c


b b

b c
b c



red b
big c

b





c

figure example illustrating union

action parameters variable names avoid repetition iterations
consider variables aggregation semantics provides maximization
definition selects best instance action since constants turned
variables additional reduction typically possible stage combination weak
strong reductions used discussion following lemma
lemma consider concrete instantiation rmdp let vn value function
corresponding mdp let x probabilistic action domain
qa
vn calculated object maximization step correct
state mapqa maximum expected values achievable executing
vn
instance x receiving terminal value vn
potential criticism object maximization essentially adding
variables diagram thus future evaluation diagram state becomes
expensive since substitutions need considered however true
diagram remains unchanged object maximization fact illustrated
example given variables may pruned diagram process
reduction thus long final value function compact evaluation efficient
hidden cost
maximizing actions
maximization vn maxa qa
n step combines independent functions therefore must first standardize apart different diagrams follow
propositional apply procedure finally follow weak strong reductions
clearly maintains correctness concrete instantiation state space


fiwang joshi khardon

order argument types
resume discussion ordering argument types extend predicate
action parameters structure suggested operations
section already suggested order constants variables
action parameters special constants object maximization become
variables object maximization thus position allow behave
variables therefore order constants action parameters
note predicate parameters exist inside tvds replaced domain
constants variables regression thus need decide relative
order predicate parameters action parameters put action parameters
predicate parameters latter replaced constant get order
violation order useful hand put predicate parameters
action parameters instantiations predicate parameters possible
notice substituting predicate parameter variable action parameters
still need larger variable tvd therefore order
action parameters variables
summarize ordering constants variables predicate parameters case
tvds action parameters suggested heuristic considerations orders maximize potential reductions avoid need sorting diagrams
finally note want maintain diagram sorted times need
maintain variant versions tvd capturing possible ordering replacements
predicate parameters consider tvd figure rename predicate parameters
x x x respectively x x resulting sub fodd
shown figure b violates order solve define another
tvd corresponding case substitution x substitution
shown figure c case replacing x x x use tvd
figure c instead one figure

x

x x

x

p x

p x

p

p x

p







p x


b




c

figure example illustrating necessity maintain multiple tvds

convergence complexity
since step procedure correct following theorem



fifirst order decision diagrams relational mdps

theorem consider concrete instantiation rmdp let vn value function
corresponding mdp n steps go value vn calculated
procedure correctly captures value function n steps go
state mapvn maximum expected value achievable n
steps
note rmdps require infinite number state partitions
thus cannot converge v finite number steps however since
implements vi exactly standard approximating optimal value functions
policies still hold particular following standard puterman holds
stopping criterion guarantees approximating optimal value functions
policies
theorem let v optimal value function let vk value function calculated
relational vi
r kvn v k n
kvn vn k






log

log



kvn v k

maintains compact diagrams reduction diagrams guaranteed domains therefore provide trivial upper bounds terms
worst case time complexity notice first every time use apply procedure
size output diagram may large product size inputs
must consider size fodd giving regressed value function block
replacement n n size current value function sorted
sorting may require exponential time space worst case example
bryant illustrates ordering may affect size diagram function
n arguments function x x x x x n x n requires diagram
n nodes function x xn x xn xn x n requires n nodes
notice two functions differ permutation arguments
x x x x x n x n block replacement clearly sorting
requires exponential time space true block combination procedure
method calculating simply output exponential
size case heuristics change variable ordering propositional adds
bryant would probably useful
assuming tvds reward function probabilities size c action
action alternatives current value function vn n nodes worst case
space expansion regression apply operations overall size

time complexity one iteration c n however note
worst case analysis take reductions account method
guaranteed work efficiently alternative grounding mdp
unmanageable number states deal despite high worst case complexity
method provides potential improvement next example illustrates reductions
substantially decrease diagram size therefore save considerable time computation


fiwang joshi khardon

comprehensive example value iteration
figure traces steps application value iteration logistics domain
tvds action choice probabilities reward function domain given figure simplify presentation continue predicate ordering bin
rain introduced earlier
given v r shown figure figure b gives regression
v unloads b block replacement denoted regr v unloads b
figure c gives multiplying regr v unloads b choice
probability unloads p r unloads b
figure gives p r unloadf b regr v unloadf b notice diagram simpler since unloadf change state tvds
trivial
figure e gives unreduced adding two outcomes unload b e
adding p r unloads b regr v unloads b p r unloadf b
regr v unloadf b note first standardize apart diagrams unloads b
unloadf b respectively renaming b b b action parameters b
stage considered constants change note
recursive part apply addition performed reductions e removing node
rain children lead value
figure e apply r node bin b p aris left branch
conditions
p b bin b p aris b b bin b p aris bin b p aris
v min bin b p aris max bin b p aris f
v bin b p aris constant
hold according lemma lemma drop node bin b p aris connect
parent bin b p aris true branch figure f gives reduction
next consider true child bin b p aris true child root
conditions
p b b bin b p aris bin b p aris b bin b p aris
v min bin b p aris max bin b p aris
v min bin b p aris max bin b p aris f
hold according lemma lemma drop node bin b p aris
connect parent bin b p aris bin b p aris f figure g gives
unload b
reduction get fully reduced diagram tv

next step perform object maximization maximize action parameters
b get best instance action unload note b
become variables perform one reduction drop equality
right branch r figure h gives object maximization e
unload b
obj max tv
note renamed action parameters avoid
repetition iterations
unload b
figure gives reduced multiplying figure h obj max tv

adding reward function qunload


details change substantially use order suggested section equality
first



fifirst order decision diagrams relational mdps

bin b paris

v



bin b paris


b b

b b
b

tin paris

tin paris















c

bin b paris




rain



rain

b

bin b paris

bin b paris

b




bin b paris

bin b paris


bin b paris

bin b paris

rain
b b

b



tin paris


rain

b b

b b
b

b



b

tin paris

tin paris


rain

b b



tin paris

rain







e

f

bin b paris


bin b paris

b b
b



q unload

b






h

v


l



bin b paris





tin paris

b



tin paris

rain

q



b b

b

tin paris

j



k

bin b paris

bin b paris




drive


rain


g



tin paris





bin b paris

b



rain


q load

bin b paris

tin paris

tin paris
rain



rain

tin paris






b

tin paris


rain




rain




b b














tin paris


rain

n



figure example value iteration logistics domain



fiwang joshi khardon

calculate qload
q drive way shown figure j

figure k respectively drive tvds trivial calculation
relatively simple load potential loading box already paris dropped
diagram reduction operators process object maximization
figure l gives v maximizing qunload
qload
qdrive




standardized apart diagrams maximized reduced
case diagram unload dominates actions therefore q unload

becomes v value function first iteration
start second iteration e computing v v figure gives
block replacement regression v action alternative unloads b
note sorted tvd b obeys ordering chosen
however diagram resulting block replacement sorted
address use block combination combine blocks bottom
figure n illustrates combine blocks p aris tvd
two children processed general fodds combine
p aris two children b processed since b f
combine b two children next step block combination
continuing process get sorted representation regr v unloads b
extracting optimal policies
one way represent policies fodds simply note
policy represented implicitly set regressed value functions value
iteration terminates perform one iteration compute set q functions
equation
given state compute maximizing action follows
q function qa x compute mapqa x x considered variables
maximum map obtained record action name action parameters
valuation obtain maximizing action
clearly implements policy represented value function alternative
represents policy explicitly developed context policy
iteration wang khardon

discussion
adds used successfully solve propositional factored mdps work gives one
proposal lifting ideas rmdps general steps similar technical
details significantly involved propositional case decision diagram
representation combines strong points sdp rebel approaches rmdp
one hand get simple regression directly manipulating diagrams
hand get object maximization free rebel get space saving
since different state partitions share structure diagrams possible disadvantage
compared rebel reasoning required reduction operators might complex


fifirst order decision diagrams relational mdps

terms expressiveness easily capture probabilistic strips style
formulations rebel allowing flexibility since use fodds capture
rewards transitions example representation capture universal effects
actions hand limited sdp since cannot use arbitrary
formulas rewards transitions probabilistic choice example cannot express
universal quantification maximum aggregation cannot used reward
functions action preconditions capture grid world rl domains
state reward propositional factored form since reward
described function location
contrasting single path semantics multiple path semantics see
interesting tension choice representation task multiple path method
directly support state partitions makes awkward specify distributions
policies since values actions must specified leaves however
semantics simplifies many steps easily supporting disjunction maximization
valuations crucial value iteration likely lead significant saving
space time
implementation empirical evaluation progress precise choice
reduction operators application crucial obtain effective system since
general tradeoff run time needed reductions size resulting
fodds apply complex reduction operators get maximally reduced fodds
takes longer perform reasoning required optimization still open issue
theoretically empirically additionally implementation easily incorporate
idea approximation combining leaves similar values control size
fodds st aubin et al gives simple way trading efficiency
accuracy value functions
many open issues concerning current representation
fodds give first step toward complete generalization adds crucially
yet semantically appropriate normal form important simplifying reasoning
one define normal form cf garriga et al treatment conjunctions
clear calculated incrementally local operations adds
would interesting investigate conditions guarantee normal form useful set
reduction operators fodds
another possible improvement representation modified allow
compression example allow edges rename variables traversed
compress isomorphic sub fodds illustrated figure c another
interesting possibility copy operator evaluates several copies predicate
different variables node illustrated figure constructs
usable one must modify fodd mdp algorithmic steps handle diagrams
syntactic notation

conclusion
makes two main contributions first introduce fodds generalization
adds relational domains may useful applications developed
calculus fodds reduction operators minimize size many open


fiwang joshi khardon

p x p

p x
q x



q x

p

f

f










figure example illustrating copy operator

issues regarding best choice operators reductions second contribution
developing fodd value iteration rmdps potential
significant improvement previous approaches performs general
relational probabilistic reasoning without ever grounding domains proved
converge abstract optimal value function solution exists

references
bahar r frohm e gaona c hachtel g macii e pardo somenzi
f algebraic decision diagrams applications proceedings
international conference computer aided design pp
bellman r e dynamic programming princeton university press
blockeel h de raedt l top induction first order logical decision trees
artificial intelligence
boutilier c dean goldszmidt stochastic dynamic programming
factored representations artificial intelligence
boutilier c dean hanks decision theoretic structural assumptions computational leverage journal artificial intelligence

boutilier c dearden r goldszmidt exploiting structure policy construction proceedings international joint conference artificial intelligence
pp
boutilier c reiter r price b symbolic dynamic programming first order
mdps proceedings international joint conference artificial intelligence
pp
bryant r e graph boolean function manipulation ieee
transactions computers c
bryant r e symbolic boolean manipulation ordered binary decision diagrams acm computing surveys
cormen h leiserson c e rivest r l stein c introduction mit press


fifirst order decision diagrams relational mdps

driessens k ramon j gartner graph kernels gaussian processes
relational reinforcement learning machine learning
dzeroski de raedt l driessens k relational reinforcement learning
machine learning
feng z hansen e symbolic heuristic search factored markov decision
processes proceedings national conference artificial intelligence pp

fern yoon givan r approximate policy iteration policy language
bias international conference neural information processing systems
fern yoon givan r approximate policy iteration policy language
bias solving relational markov decision processes journal artificial intelligence

garriga g khardon r de raedt l mining closed sets multi relational
data proceedings international joint conference artificial intelligence
pp
gretton c thiebaux exploiting first order regression inductive policy
selection proceedings conference uncertainty artificial intelligence
pp
groote j f tveretina binary decision diagrams first order predicate
logic journal logic algebraic programming
gromann holldobler skvortsova symbolic dynamic programming
within fluent calculus proceedings iasted international conference
artificial computational intelligence
guestrin c koller gearhart c kanodia n generalizing plans
environments relational mdps proceedings international joint conference
artificial intelligence pp
guestrin c koller par r venktaraman b efficient solution
factored mdps journal artificial intelligence
hansen e feng z dynamic programming pomdps factored
state representation proceedings international conference artificial
intelligence systems pp
hoey j st aubin r hu boutilier c spudd stochastic decision diagrams proceedings conference uncertainty artificial
intelligence pp
hoolldobler karabaev e skvortsova flucap heuristic search planner
first order mdps journal artificial intelligence
kersting k otterlo v de raedt l bellman goes relational proceedings
international conference machine learning
mcmillan k l symbolic model checking kluwer academic publishers


fiwang joshi khardon

puterman l markov decision processes discrete stochastic dynamic programming wiley
rivest r l learning decision lists machine learning
sanghai domingos p weld relational dynamic bayesian networks
journal artificial intelligence
sanner boutilier c approximate linear programming first order mdps
proceedings conference uncertainty artificial intelligence
sanner boutilier c practical linear value approximation techniques firstorder mdps proceedings conference uncertainty artificial intelligence
sanner boutilier c approximate solution techniques factored first order
mdps proceedings international conference automated
scheduling
schuurmans patrascu r direct value approximation factored mdps
international conference neural information processing systems pp
st aubin r hoey j boutilier c apricodd approximate policy construction decision diagrams international conference neural information
processing systems pp
wang c first order markov decision processes tech rep tr computer
science department tufts university
wang c joshi khardon r first order decision diagrams relational
mdps proceedings international joint conference artificial intelligence
pp
wang c khardon r policy iteration relational mdps proceedings
conference uncertainty artificial intelligence




